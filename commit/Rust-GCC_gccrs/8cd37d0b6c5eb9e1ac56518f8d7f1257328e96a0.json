{"sha": "8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkMzdkMGI2YzVlYjllMWFjNTY1MThmOGQ3ZjEyNTczMjhlOTZhMA==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2006-05-04T09:19:02Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2006-05-04T09:19:02Z"}, "message": "[multiple changes]\n\n2006-05-04  Leehod Baruch  <leehod@il.ibm.com>\n\n        * see.c: New file.\n        * Makefile.in (OBJS-common): Add see.o.\n        (see.o): Add dependencies.\n        * common.opt (fsee): New flag for the see optimization was added.\n        * opts.c (flag_see): Initialized.\n        * passes.c (init_optimization_passes, pass_see): New pass.\n        * rtl.h (see_main): Declaration as extern.\n        * timevar.def (TV_SEE): New.\n        * tree-pass.h (pass_see): Declaration as extern.\n        * invoke.texi (-fsee): Document.\n        * recog.c (validate_simplify_insn): New function.\n        * recog.h (validate_simplify_insn): Declaration as extern.\n        * df-problems.c (df_chain_dump): Check for NULL.\n\n2006-05-04  Kenneth Zadeck <zadeck@naturalbridge.com>\n            Daniel Berlin  <dberlin@dberlin.org>\n\n        * cfgrtl.c (insert_insn_bb_end_new): New function.\n        * basic-block.h (insert_insn_bb_end_new): Declaration as extern.\n\n2006-05-04  Leehod Baruch  <leehod.baruch@weizmann.ac.il>\n\n        * df.h (struct web_entry): Moved from web.c.\n        (union_defs): Declaration as extern.\n        (unionfind_root): Likewise.\n        (unionfind_union): Likewise.\n        * web.c (struct web_entry): Moved to df.h.\n        (unionfind_root): Remove static declaration.\n        (unionfind_union): Likewise.\n        (union_defs): Likewise and generalize to use callback function.\n        (web_main): Update arguments for union_defs function call.\n\nFrom-SVN: r113518", "tree": {"sha": "ef41d3b028cb0bd843e780b6ff16b1f90786cd60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef41d3b028cb0bd843e780b6ff16b1f90786cd60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/comments", "author": null, "committer": null, "parents": [{"sha": "23ba9627f42b41b4431d63d55431d01fd5af9bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23ba9627f42b41b4431d63d55431d01fd5af9bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23ba9627f42b41b4431d63d55431d01fd5af9bf4"}], "stats": {"total": 4067, "additions": 4030, "deletions": 37}, "files": [{"sha": "d3195ac030672845eb7d1269a996581830619b4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -1,3 +1,37 @@\n+2006-05-04  Leehod Baruch  <leehod@il.ibm.com>\n+\n+        * see.c: New file.\n+        * Makefile.in (OBJS-common): Add see.o.\n+        (see.o): Add dependencies.\n+        * common.opt (fsee): New flag for the see optimization was added.\n+        * opts.c (flag_see): Initialized.\n+        * passes.c (init_optimization_passes, pass_see): New pass.\n+        * rtl.h (see_main): Declaration as extern.\n+        * timevar.def (TV_SEE): New.\n+        * tree-pass.h (pass_see): Declaration as extern.\n+        * invoke.texi (-fsee): Document.\n+        * recog.c (validate_simplify_insn): New function.\n+        * recog.h (validate_simplify_insn): Declaration as extern.\n+        * df-problems.c (df_chain_dump): Check for NULL.\n+\n+2006-05-04  Kenneth Zadeck <zadeck@naturalbridge.com>\n+            Daniel Berlin  <dberlin@dberlin.org>\n+\n+        * cfgrtl.c (insert_insn_bb_end_new): New function.\n+        * basic-block.h (insert_insn_bb_end_new): Declaration as extern.\n+\n+2006-05-04  Leehod Baruch  <leehod.baruch@weizmann.ac.il>\n+\n+        * df.h (struct web_entry): Moved from web.c.\n+        (union_defs): Declaration as extern.\n+        (unionfind_root): Likewise.\n+        (unionfind_union): Likewise.\n+        * web.c (struct web_entry): Moved to df.h.\n+        (unionfind_root): Remove static declaration.\n+        (unionfind_union): Likewise.\n+        (union_defs): Likewise and generalize to use callback function.\n+        (web_main): Update arguments for union_defs function call.\n+\n 2006-05-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/26447"}, {"sha": "807380a71431f63dd468ffe4809174eb0da55de4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -995,7 +995,7 @@ OBJS-common = \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n- simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o\t\t   \\\n+ see.o simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o\t\t   \\\n  struct-equiv.o targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n@@ -2314,6 +2314,9 @@ cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h \\\n    $(DF_H) $(OBSTACK_H) timevar.h tree-pass.h\n+see.o : see.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \\\n+   $(DF_H) $(OBSTACK_H) timevar.h tree-pass.h\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h \\"}, {"sha": "21ed8923d27eccbaaef5c84145b2b883a25962a0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -1001,6 +1001,8 @@ extern basic_block get_bb_original (basic_block);\n extern void set_bb_copy (basic_block, basic_block);\n extern basic_block get_bb_copy (basic_block);\n \n+extern rtx insert_insn_end_bb_new (rtx, basic_block);\n+\n #include \"cfghooks.h\"\n \n /* In struct-equiv.c */"}, {"sha": "3afbee42456b3b7b08a1206acfb54a3cc0a46f98", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -2899,6 +2899,93 @@ init_rtl_bb_info (basic_block bb)\n }\n \n \n+/* Add EXPR to the end of basic block BB.  */\n+\n+rtx\n+insert_insn_end_bb_new (rtx pat, basic_block bb)\n+{\n+  rtx insn = BB_END (bb);\n+  rtx new_insn;\n+  rtx pat_end = pat;\n+\n+  while (NEXT_INSN (pat_end) != NULL_RTX)\n+    pat_end = NEXT_INSN (pat_end);\n+\n+  /* If the last insn is a jump, insert EXPR in front [taking care to\n+     handle cc0, etc. properly].  Similarly we need to care trapping\n+     instructions in presence of non-call exceptions.  */\n+\n+  if (JUMP_P (insn)\n+      || (NONJUMP_INSN_P (insn)\n+          && (!single_succ_p (bb)\n+              || single_succ_edge (bb)->flags & EDGE_ABNORMAL)))\n+    {\n+#ifdef HAVE_cc0\n+      rtx note;\n+#endif\n+      /* If this is a jump table, then we can't insert stuff here.  Since\n+         we know the previous real insn must be the tablejump, we insert\n+         the new instruction just before the tablejump.  */\n+      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+          || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+        insn = prev_real_insn (insn);\n+\n+#ifdef HAVE_cc0\n+      /* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts\n+         if cc0 isn't set.  */\n+      note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n+      if (note)\n+        insn = XEXP (note, 0);\n+      else\n+        {\n+          rtx maybe_cc0_setter = prev_nonnote_insn (insn);\n+          if (maybe_cc0_setter\n+              && INSN_P (maybe_cc0_setter)\n+              && sets_cc0_p (PATTERN (maybe_cc0_setter)))\n+            insn = maybe_cc0_setter;\n+        }\n+#endif\n+      /* FIXME: What if something in cc0/jump uses value set in new\n+         insn?  */\n+      new_insn = emit_insn_before_noloc (pat, insn);\n+    }\n+\n+  /* Likewise if the last insn is a call, as will happen in the presence\n+     of exception handling.  */\n+  else if (CALL_P (insn)\n+           && (!single_succ_p (bb)\n+               || single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n+    {\n+      /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n+         we search backward and place the instructions before the first\n+         parameter is loaded.  Do this for everyone for consistency and a\n+         presumption that we'll get better code elsewhere as well.  */\n+\n+      /* Since different machines initialize their parameter registers\n+         in different orders, assume nothing.  Collect the set of all\n+         parameter registers.  */\n+      insn = find_first_parameter_load (insn, BB_HEAD (bb));\n+\n+      /* If we found all the parameter loads, then we want to insert\n+         before the first parameter load.\n+\n+         If we did not find all the parameter loads, then we might have\n+         stopped on the head of the block, which could be a CODE_LABEL.\n+         If we inserted before the CODE_LABEL, then we would be putting\n+         the insn in the wrong basic block.  In that case, put the insn\n+         after the CODE_LABEL.  Also, respect NOTE_INSN_BASIC_BLOCK.  */\n+      while (LABEL_P (insn)\n+             || NOTE_INSN_BASIC_BLOCK_P (insn))\n+        insn = NEXT_INSN (insn);\n+\n+      new_insn = emit_insn_before_noloc (pat, insn);\n+    }\n+  else\n+    new_insn = emit_insn_after_noloc (pat, insn);\n+\n+  return new_insn;\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   \"rtl\",\n@@ -2973,4 +3060,3 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   rtl_extract_cond_bb_edges, /* extract_cond_bb_edges */\n   NULL \t\t/* flush_pending_stmts */  \n };\n-"}, {"sha": "9d9cbca64c82a3b7feb23631ece11e3ef3b73e23", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -809,6 +809,10 @@ frtl-abstract-sequences\n Common Report Var(flag_rtl_seqabstr)\n Perform sequence abstraction optimization on RTL\n \n+fsee\n+Common Report Var(flag_see) Init(0)\n+Eliminate redundant sign extensions using LCM.\n+\n fshow-column\n Common C ObjC C++ ObjC++ Report Var(flag_show_column) Init(1)\n Show column numbers in diagnostics, when available.  Default on"}, {"sha": "4f5f2e126588a00f7be0c27781490d226d0ec89c", "filename": "gcc/df-problems.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -2992,7 +2992,9 @@ df_chains_dump (struct dataflow *dflow, FILE *file)\n \t    {\n \t      fprintf (file, \"d%d bb %d luid %d insn %d reg %d \",\n \t\t       j, DF_REF_BBNO (def),\n-\t\t       DF_INSN_LUID (df, DF_REF_INSN (def)),\n+\t\t       DF_REF_INSN (def) ? \n+\t\t       DF_INSN_LUID (df, DF_REF_INSN (def)):\n+\t\t       -1,\n \t\t       DF_REF_INSN (def) ? DF_REF_INSN_UID (def) : -1,\n \t\t       DF_REF_REGNO (def));\n \t      if (def->flags & DF_REF_READ_WRITE)"}, {"sha": "3a735aedd05f86e0990e556f9f61713f5ce83f08", "filename": "gcc/df.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -593,4 +593,23 @@ extern void df_hard_reg_init (void);\n extern bool df_read_modify_subreg_p (rtx);\n \n \n+/* web */\n+\n+/* This entry is allocated for each reference in the insn stream.  */\n+struct web_entry\n+{\n+  /* Pointer to the parent in the union/find tree.  */\n+  struct web_entry *pred;\n+  /* Newly assigned register to the entry.  Set only for roots.  */\n+  rtx reg;\n+  void* extra_info;\n+};\n+\n+extern struct web_entry *unionfind_root (struct web_entry *);\n+extern bool unionfind_union (struct web_entry *, struct web_entry *);\n+extern void union_defs (struct df *, struct df_ref *,\n+                        struct web_entry *, struct web_entry *,\n+\t\t\tbool (*fun) (struct web_entry *, struct web_entry *));\n+\n+\n #endif /* GCC_DF_H */"}, {"sha": "71c692552104bc244f42d848366d37910f8d6372", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -334,7 +334,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsched-spec-load-dangerous  @gol\n -fsched-stalled-insns=@var{n} -fsched-stalled-insns-dep=@var{n} @gol\n -fsched2-use-superblocks @gol\n--fsched2-use-traces -freschedule-modulo-scheduled-loops @gol\n+-fsched2-use-traces -fsee -freschedule-modulo-scheduled-loops @gol\n -fsection-anchors  -fsignaling-nans  -fsingle-precision-constant @gol\n -fstack-protector  -fstack-protector-all @gol\n -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n@@ -5008,6 +5008,12 @@ match the reality and hurt the performance.  This only makes\n sense when scheduling after register allocation, i.e.@: with\n @option{-fschedule-insns2} or at @option{-O2} or higher.\n \n+@item -fsee\n+@opindex fsee\n+Eliminates redundant extension instructions and move the non redundant\n+ones to optimal placement using LCM.\n+Enabled at level @option{-O3}.\n+\n @item -freschedule-modulo-scheduled-loops\n @opindex fscheduling-in-modulo-scheduled-loops\n The modulo scheduling comes before the traditional scheduling, if a loop was modulo scheduled"}, {"sha": "622001829077406d2829c2bd5911ac0509aa9d09", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -592,6 +592,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_inline_functions = 1;\n       flag_unswitch_loops = 1;\n       flag_gcse_after_reload = 1;\n+      flag_see = 1; \n     }\n \n   if (optimize < 2 || optimize_size)"}, {"sha": "fe6f637e86890e0d4e0716ea5ac22d598211f7f2", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -652,6 +652,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_regmove);\n   NEXT_PASS (pass_split_all_insns);\n   NEXT_PASS (pass_mode_switching);\n+  NEXT_PASS (pass_see);\n   NEXT_PASS (pass_recompute_reg_usage);\n   NEXT_PASS (pass_sms);\n   NEXT_PASS (pass_sched);"}, {"sha": "cd1cb7d6bee4eb32e19042744c8b489692302977", "filename": "gcc/recog.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -698,6 +698,46 @@ validate_replace_src_group (rtx from, rtx to, rtx insn)\n   d.insn = insn;\n   note_uses (&PATTERN (insn), validate_replace_src_1, &d);\n }\n+\n+/* Try simplify INSN.\n+   Invoke simplify_rtx () on every SET_SRC and SET_DEST inside the INSN's\n+   pattern and return true if something was simplified.  */\n+\n+bool\n+validate_simplify_insn (rtx insn)\n+{\n+  int i;\n+  rtx pat = NULL;\n+  rtx newpat = NULL;\n+\n+  pat = PATTERN (insn);\n+\n+  if (GET_CODE (pat) == SET)\n+    {\n+      newpat = simplify_rtx (SET_SRC (pat));\n+      if (newpat && !rtx_equal_p (SET_SRC (pat), newpat))\n+\tvalidate_change (insn, &SET_SRC (pat), newpat, 1);\n+      newpat = simplify_rtx (SET_DEST (pat));\n+      if (newpat && !rtx_equal_p (SET_DEST (pat), newpat))\n+\tvalidate_change (insn, &SET_DEST (pat), newpat, 1);\n+    }\n+  else if (GET_CODE (pat) == PARALLEL)\n+    for (i = 0; i < XVECLEN (pat, 0); i++)\n+      {\n+\trtx s = XVECEXP (pat, 0, i);\n+\n+\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n+\t  {\n+\t    newpat = simplify_rtx (SET_SRC (s));\n+\t    if (newpat && !rtx_equal_p (SET_SRC (s), newpat))\n+\t      validate_change (insn, &SET_SRC (s), newpat, 1);\n+\t    newpat = simplify_rtx (SET_DEST (s));\n+\t    if (newpat && !rtx_equal_p (SET_DEST (s), newpat))\n+\t      validate_change (insn, &SET_DEST (s), newpat, 1);\n+\t  }\n+      }\n+  return ((num_changes_pending () > 0) && (apply_change_group () > 0));\n+}\n \f\n #ifdef HAVE_cc0\n /* Return 1 if the insn using CC0 set by INSN does not contain"}, {"sha": "8281a9e55e7c4aff4c42467f409055b5179b67b3", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -87,6 +87,7 @@ extern int strict_memory_address_p (enum machine_mode, rtx);\n extern int validate_replace_rtx (rtx, rtx, rtx);\n extern void validate_replace_rtx_group (rtx, rtx, rtx);\n extern void validate_replace_src_group (rtx, rtx, rtx);\n+extern bool validate_simplify_insn (rtx insn);\n extern int num_changes_pending (void);\n #ifdef HAVE_cc0\n extern int next_insn_tests_no_inequality (rtx);"}, {"sha": "603d72e9e232a092914640a57e46899679679fc3", "filename": "gcc/see.c", "status": "added", "additions": 3782, "deletions": 0, "changes": 3782, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0"}, {"sha": "28b0b766ebab75454ac891c978da79125ad50cd9", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -145,6 +145,7 @@ DEFTIMEVAR (TV_VPT                   , \"value profile opts\")\n DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\n DEFTIMEVAR (TV_COMBINE               , \"combiner\")\n DEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")\n+DEFTIMEVAR (TV_SEE                   , \"see\")\n DEFTIMEVAR (TV_REGMOVE               , \"regmove\")\n DEFTIMEVAR (TV_MODE_SWITCH           , \"mode switching\")\n DEFTIMEVAR (TV_SMS\t\t     , \"sms modulo scheduling\")"}, {"sha": "3121735e85ad005c227135aa28ac01470e01c664", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -356,6 +356,7 @@ extern struct tree_opt_pass pass_partition_blocks;\n extern struct tree_opt_pass pass_regmove;\n extern struct tree_opt_pass pass_split_all_insns;\n extern struct tree_opt_pass pass_mode_switching;\n+extern struct tree_opt_pass pass_see;\n extern struct tree_opt_pass pass_recompute_reg_usage;\n extern struct tree_opt_pass pass_sms;\n extern struct tree_opt_pass pass_sched;"}, {"sha": "7f5ae67d9af069038cad299a25a885502b0f6f08", "filename": "gcc/web.c", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=8cd37d0b6c5eb9e1ac56518f8d7f1257328e96a0", "patch": "@@ -61,25 +61,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-pass.h\"\n \n \n-/* This entry is allocated for each reference in the insn stream.  */\n-struct web_entry\n-{\n-  /* Pointer to the parent in the union/find tree.  */\n-  struct web_entry *pred;\n-  /* Newly assigned register to the entry.  Set only for roots.  */\n-  rtx reg;\n-};\n-\n-static struct web_entry *unionfind_root (struct web_entry *);\n-static void unionfind_union (struct web_entry *, struct web_entry *);\n-static void union_defs (struct df *, struct df_ref *, struct web_entry *, \n-                        struct web_entry *);\n static rtx entry_register (struct web_entry *, struct df_ref *, char *);\n static void replace_ref (struct df_ref *, rtx);\n \n /* Find the root of unionfind tree (the representative of set).  */\n \n-static struct web_entry *\n+struct web_entry *\n unionfind_root (struct web_entry *element)\n {\n   struct web_entry *element1 = element, *element2;\n@@ -95,30 +82,48 @@ unionfind_root (struct web_entry *element)\n   return element;\n }\n \n-/* Union sets.  */\n+/* Union sets.  \n+   Return true if FIRST and SECOND points to the same web entry structure and\n+   nothing is done.  Otherwise, return false.  */\n \n-static void\n+bool\n unionfind_union (struct web_entry *first, struct web_entry *second)\n {\n   first = unionfind_root (first);\n   second = unionfind_root (second);\n   if (first == second)\n-    return;\n+    return true;\n   second->pred = first;\n+  return false;\n }\n \n /* For each use, all possible defs reaching it must come in the same\n-   register, union them.  */\n+   register, union them.\n+   FUN is the function that does the union.  */\n \n-static void\n+void\n union_defs (struct df *df, struct df_ref *use, struct web_entry *def_entry,\n-            struct web_entry *use_entry)\n+ \t    struct web_entry *use_entry,\n+ \t    bool (*fun) (struct web_entry *, struct web_entry *))\n {\n   rtx insn = DF_REF_INSN (use);\n   struct df_link *link = DF_REF_CHAIN (use);\n-  struct df_ref *use_link = DF_INSN_USES (df, insn);\n-  struct df_ref *def_link = DF_INSN_DEFS (df, insn);\n-  rtx set = single_set (insn);\n+  struct df_ref *use_link;\n+  struct df_ref *def_link;\n+  rtx set;\n+\n+  if (insn)\n+    {\n+      use_link = DF_INSN_USES (df, insn);\n+      def_link = DF_INSN_DEFS (df, insn);\n+      set = single_set (insn);\n+    }\n+  else\n+    {\n+      use_link = NULL;\n+      def_link = NULL;\n+      set = NULL;\n+    }\n \n   /* Some instructions may use match_dup for their operands.  In case the\n      operands are dead, we will assign them different pseudos, creating\n@@ -129,8 +134,8 @@ union_defs (struct df *df, struct df_ref *use, struct web_entry *def_entry,\n     {\n       if (use != use_link\n \t  && DF_REF_REAL_REG (use) == DF_REF_REAL_REG (use_link))\n-\tunionfind_union (use_entry + DF_REF_ID (use),\n-\t\t         use_entry + DF_REF_ID (use_link));\n+ \t(*fun) (use_entry + DF_REF_ID (use),\n+ \t\tuse_entry + DF_REF_ID (use_link));\n       use_link = use_link->next_ref;\n     }\n \n@@ -145,29 +150,34 @@ union_defs (struct df *df, struct df_ref *use, struct web_entry *def_entry,\n       while (def_link)\n \t{\n \t  if (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (def_link))\n-\t    unionfind_union (use_entry + DF_REF_ID (use),\n-\t\t\t     def_entry + DF_REF_ID (def_link));\n+ \t    (*fun) (use_entry + DF_REF_ID (use),\n+ \t\t    def_entry + DF_REF_ID (def_link));\n \t  def_link = def_link->next_ref;\n \t}\n     }\n   while (link)\n     {\n-      unionfind_union (use_entry + DF_REF_ID (use),\n-\t\t       def_entry + DF_REF_ID (link->ref));\n+      (*fun) (use_entry + DF_REF_ID (use),\n+\t      def_entry + DF_REF_ID (link->ref));\n       link = link->next;\n     }\n \n   /* A READ_WRITE use requires the corresponding def to be in the same\n      register.  Find it and union.  */\n   if (use->flags & DF_REF_READ_WRITE)\n     {\n-      struct df_ref *link = DF_INSN_DEFS (df, DF_REF_INSN (use));\n+      struct df_ref *link;\n+\n+      if (DF_REF_INSN (use))\n+\tlink = DF_INSN_DEFS (df, DF_REF_INSN (use));\n+      else\n+\tlink = NULL;\n \n       while (link)\n \t{\n \t  if (DF_REF_REAL_REG (link) == DF_REF_REAL_REG (use))\n-\t    unionfind_union (use_entry + DF_REF_ID (use),\n-\t\t\t     def_entry + DF_REF_ID (link));\n+ \t    (*fun) (use_entry + DF_REF_ID (use),\n+ \t\t    def_entry + DF_REF_ID (link));\n \t  link = link->next_ref;\n \t}\n     }\n@@ -258,7 +268,7 @@ web_main (void)\n \n   /* Produce the web.  */\n   for (i = 0; i < DF_USES_SIZE (df); i++)\n-    union_defs (df, DF_USES_GET (df, i), def_entry, use_entry);\n+    union_defs (df, DF_USES_GET (df, i), def_entry, use_entry, unionfind_union);\n \n   /* Update the instruction stream, allocating new registers for split pseudos\n      in progress.  */"}]}