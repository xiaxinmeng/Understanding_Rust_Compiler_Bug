{"sha": "863a75787c5765257e516afa538dee2e22d6d0ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYzYTc1Nzg3YzU3NjUyNTdlNTE2YWZhNTM4ZGVlMmUyMmQ2ZDBhZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-06T12:14:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-06T12:14:02Z"}, "message": "re PR middle-end/45534 (ICE in refs_may_alias_p_1, at tree-ssa-alias.c:1031)\n\n2010-09-06  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/45534\n\t* tree-ssa-address.c (create_mem_ref_raw): Add verify parameter.\n\t(create_mem_ref): Do verify the created TARGET_MEM_REF is valid\n\ton the target.\n\t(maybe_fold_tmr): Do not verify the created TARGET_MEM_REF is\n\tvalid on the target.\n\nFrom-SVN: r163913", "tree": {"sha": "1765fb79bc548e1699fbc45453b13b5b56626b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1765fb79bc548e1699fbc45453b13b5b56626b96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/863a75787c5765257e516afa538dee2e22d6d0ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/863a75787c5765257e516afa538dee2e22d6d0ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/863a75787c5765257e516afa538dee2e22d6d0ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/863a75787c5765257e516afa538dee2e22d6d0ad/comments", "author": null, "committer": null, "parents": [{"sha": "84f47d20bbdf810c4c0643b9980cd9bc57d4d296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f47d20bbdf810c4c0643b9980cd9bc57d4d296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84f47d20bbdf810c4c0643b9980cd9bc57d4d296"}], "stats": {"total": 40, "additions": 27, "deletions": 13}, "files": [{"sha": "4012cf395bd93f744e3540b14fbfe27f9f7271f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863a75787c5765257e516afa538dee2e22d6d0ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863a75787c5765257e516afa538dee2e22d6d0ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=863a75787c5765257e516afa538dee2e22d6d0ad", "patch": "@@ -1,11 +1,21 @@\n+2010-09-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45534\n+\t* tree-ssa-address.c (create_mem_ref_raw): Add verify parameter.\n+\t(create_mem_ref): Do verify the created TARGET_MEM_REF is valid\n+\ton the target.\n+\t(maybe_fold_tmr): Do not verify the created TARGET_MEM_REF is\n+\tvalid on the target.\n+\n 2010-09-06  Andreas Schwab  <schwab@redhat.com>\n \n \t* configure.ac: Quote argument of AC_MSG_WARN.\n \t* configure: Regenerate.\n \n 2010-09-06  Alexander Monakov  <amonakov@ispras.ru>\n \n-\t* sel-sched.c (move_cond_jump): Correct arguments to maybe_tidy_empty_bb.\n+\t* sel-sched.c (move_cond_jump): Correct arguments to\n+\tmaybe_tidy_empty_bb.\n \t* sel-sched-ir.c (maybe_tidy_empty_bb): Export.\n \n 2010-09-06  Andrey Belevantsev  <abel@ispras.ru>"}, {"sha": "a9ca8354e2fca027186de32152270976a5a70142", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863a75787c5765257e516afa538dee2e22d6d0ad/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863a75787c5765257e516afa538dee2e22d6d0ad/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=863a75787c5765257e516afa538dee2e22d6d0ad", "patch": "@@ -324,14 +324,16 @@ valid_mem_ref_p (enum machine_mode mode, addr_space_t as,\n \n /* Checks whether a TARGET_MEM_REF with type TYPE and parameters given by ADDR\n    is valid on the current target and if so, creates and returns the\n-   TARGET_MEM_REF.  */\n+   TARGET_MEM_REF.  If VERIFY is false omit the verification step.  */\n \n static tree\n-create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr)\n+create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr,\n+\t\t    bool verify)\n {\n   tree base, index2;\n \n-  if (!valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), addr))\n+  if (verify\n+      && !valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), addr))\n     return NULL_TREE;\n \n   if (addr->step && integer_onep (addr->step))\n@@ -689,7 +691,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \n   addr_to_parts (type, addr, iv_cand, base_hint, &parts, speed);\n   gimplify_mem_ref_parts (gsi, &parts);\n-  mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n+  mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n   if (mem_ref)\n     return mem_ref;\n \n@@ -705,7 +707,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \t\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n       parts.step = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -740,7 +742,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \tparts.base = tmp;\n       parts.symbol = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -761,7 +763,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \tparts.base = parts.index;\n       parts.index = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -783,7 +785,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \n       parts.offset = NULL_TREE;\n \n-      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts);\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n@@ -899,10 +901,12 @@ maybe_fold_tmr (tree ref)\n   if (!changed)\n     return NULL_TREE;\n \n-  ret = create_mem_ref_raw (TREE_TYPE (ref), TREE_TYPE (addr.offset), &addr);\n-  if (!ret)\n-    return NULL_TREE;\n-\n+  /* If we have propagated something into this TARGET_MEM_REF and thus\n+     ended up folding it, always create a new TARGET_MEM_REF regardless\n+     if it is valid in this for on the target - the propagation result\n+     wouldn't be anyway.  */\n+  ret = create_mem_ref_raw (TREE_TYPE (ref),\n+\t\t\t    TREE_TYPE (addr.offset), &addr, false);\n   copy_mem_ref_info (ret, ref);\n   return ret;\n }"}]}