{"sha": "0024c32045a72ef45a64ab5673a2ba587978d9d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyNGMzMjA0NWE3MmVmNDVhNjRhYjU2NzNhMmJhNTg3OTc4ZDlkMQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2019-01-07T08:10:47Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2019-01-07T08:10:47Z"}, "message": "[nvptx] Add support for a per-worker broadcast buffer and barrier\n\nAdd support for a per-worker broadcast buffer and barrier, to be used for\nopenacc vector_length larger than warp-size.\n\n2019-01-07  Tom de Vries  <tdevries@suse.de>\n\n\t* config/nvptx/nvptx.c (oacc_bcast_partition): Declare.\n\t(nvptx_option_override): Init oacc_bcast_partition.\n\t(nvptx_init_oacc_workers): New function.\n\t(nvptx_declare_function_name): Call nvptx_init_oacc_workers.\n\t(nvptx_needs_shared_bcast): New function.\n\t(nvptx_find_par): Generalize to enable vectors to use shared-memory\n\tto propagate state.\n\t(nvptx_shared_propagate): Initialize vector bcast partition and\n\tsynchronization state.\n\t(nvptx_single):  Generalize to enable vectors to use shared-memory\n\tto propagate state.\n\t(nvptx_process_pars): Likewise.\n\t(nvptx_set_current_function): Initialize oacc_broadcast_partition.\n\t* config/nvptx/nvptx.h (struct machine_function): Add\n\tbcast_partition and sync_bar members.\n\nFrom-SVN: r267629", "tree": {"sha": "50fc1b2838eff6a46f1f643067792ab14ff3c259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50fc1b2838eff6a46f1f643067792ab14ff3c259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0024c32045a72ef45a64ab5673a2ba587978d9d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0024c32045a72ef45a64ab5673a2ba587978d9d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0024c32045a72ef45a64ab5673a2ba587978d9d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0024c32045a72ef45a64ab5673a2ba587978d9d1/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ccc0d492f109456db8df72938bf39fd03510d2b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc0d492f109456db8df72938bf39fd03510d2b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc0d492f109456db8df72938bf39fd03510d2b3"}], "stats": {"total": 175, "additions": 156, "deletions": 19}, "files": [{"sha": "6216416db8794b1d6c9ec32dc3661a4075595818", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0024c32045a72ef45a64ab5673a2ba587978d9d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0024c32045a72ef45a64ab5673a2ba587978d9d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0024c32045a72ef45a64ab5673a2ba587978d9d1", "patch": "@@ -1,3 +1,21 @@\n+2019-01-07  Tom de Vries  <tdevries@suse.de>\n+\n+\t* config/nvptx/nvptx.c (oacc_bcast_partition): Declare.\n+\t(nvptx_option_override): Init oacc_bcast_partition.\n+\t(nvptx_init_oacc_workers): New function.\n+\t(nvptx_declare_function_name): Call nvptx_init_oacc_workers.\n+\t(nvptx_needs_shared_bcast): New function.\n+\t(nvptx_find_par): Generalize to enable vectors to use shared-memory\n+\tto propagate state.\n+\t(nvptx_shared_propagate): Initialize vector bcast partition and\n+\tsynchronization state.\n+\t(nvptx_single):  Generalize to enable vectors to use shared-memory\n+\tto propagate state.\n+\t(nvptx_process_pars): Likewise.\n+\t(nvptx_set_current_function): Initialize oacc_broadcast_partition.\n+\t* config/nvptx/nvptx.h (struct machine_function): Add\n+\tbcast_partition and sync_bar members.\n+\n 2019-01-07  Tom de Vries  <tdevries@suse.de>\n \n \t* config/nvptx/nvptx.c (nvptx_welformed_vector_length_p)"}, {"sha": "2166f37b1824357e659aacd20b216c820835624d", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 134, "deletions": 19, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0024c32045a72ef45a64ab5673a2ba587978d9d1/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0024c32045a72ef45a64ab5673a2ba587978d9d1/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=0024c32045a72ef45a64ab5673a2ba587978d9d1", "patch": "@@ -140,6 +140,7 @@ static GTY((cache)) hash_table<tree_hasher> *needed_fndecls_htab;\n    memory.  It'd be nice if PTX supported common blocks, because then\n    this could be shared across TUs (taking the largest size).  */\n static unsigned oacc_bcast_size;\n+static unsigned oacc_bcast_partition;\n static unsigned oacc_bcast_align;\n static GTY(()) rtx oacc_bcast_sym;\n \n@@ -158,6 +159,8 @@ static bool need_softstack_decl;\n /* True if any function references __nvptx_uni.  */\n static bool need_unisimt_decl;\n \n+static int nvptx_mach_max_workers ();\n+\n /* Allocate a new, cleared machine_function structure.  */\n \n static struct machine_function *\n@@ -217,6 +220,7 @@ nvptx_option_override (void)\n   oacc_bcast_sym = gen_rtx_SYMBOL_REF (Pmode, \"__oacc_bcast\");\n   SET_SYMBOL_DATA_AREA (oacc_bcast_sym, DATA_AREA_SHARED);\n   oacc_bcast_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n+  oacc_bcast_partition = 0;\n \n   worker_red_sym = gen_rtx_SYMBOL_REF (Pmode, \"__worker_red\");\n   SET_SYMBOL_DATA_AREA (worker_red_sym, DATA_AREA_SHARED);\n@@ -1105,6 +1109,40 @@ nvptx_init_axis_predicate (FILE *file, int regno, const char *name)\n   fprintf (file, \"\\t}\\n\");\n }\n \n+/* Emit code to initialize OpenACC worker broadcast and synchronization\n+   registers.  */\n+\n+static void\n+nvptx_init_oacc_workers (FILE *file)\n+{\n+  fprintf (file, \"\\t{\\n\");\n+  fprintf (file, \"\\t\\t.reg.u32\\t%%tidy;\\n\");\n+  if (cfun->machine->bcast_partition)\n+    {\n+      fprintf (file, \"\\t\\t.reg.u64\\t%%t_bcast;\\n\");\n+      fprintf (file, \"\\t\\t.reg.u64\\t%%y64;\\n\");\n+    }\n+  fprintf (file, \"\\t\\tmov.u32\\t\\t%%tidy, %%tid.y;\\n\");\n+  if (cfun->machine->bcast_partition)\n+    {\n+      fprintf (file, \"\\t\\tcvt.u64.u32\\t%%y64, %%tidy;\\n\");\n+      fprintf (file, \"\\t\\tadd.u64\\t\\t%%y64, %%y64, 1; // vector ID\\n\");\n+      fprintf (file, \"\\t\\tcvta.shared.u64\\t%%t_bcast, __oacc_bcast;\\n\");\n+      fprintf (file, \"\\t\\tmad.lo.u64\\t%%r%d, %%y64, %d, %%t_bcast; \"\n+\t       \"// vector broadcast offset\\n\",\n+\t       REGNO (cfun->machine->bcast_partition),\n+\t       oacc_bcast_partition);\n+    }\n+  /* Verify oacc_bcast_size.  */\n+  gcc_assert (oacc_bcast_partition * (nvptx_mach_max_workers () + 1)\n+\t      <= oacc_bcast_size);\n+  if (cfun->machine->sync_bar)\n+    fprintf (file, \"\\t\\tadd.u32\\t\\t%%r%d, %%tidy, 1; \"\n+\t     \"// vector synchronization barrier\\n\",\n+\t     REGNO (cfun->machine->sync_bar));\n+  fprintf (file, \"\\t}\\n\");\n+}\n+\n /* Emit code to initialize predicate and master lane index registers for\n    -muniform-simt code generation variant.  */\n \n@@ -1331,6 +1369,8 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   if (cfun->machine->unisimt_predicate\n       || (cfun->machine->has_simtreg && !crtl->is_leaf))\n     nvptx_init_unisimt_predicate (file);\n+  if (cfun->machine->bcast_partition || cfun->machine->sync_bar)\n+    nvptx_init_oacc_workers (file);\n }\n \n /* Output code for switching uniform-simt state.  ENTERING indicates whether\n@@ -3072,6 +3112,19 @@ nvptx_split_blocks (bb_insn_map_t *map)\n     }\n }\n \n+/* Return true if MASK contains parallelism that requires shared\n+   memory to broadcast.  */\n+\n+static bool\n+nvptx_needs_shared_bcast (unsigned mask)\n+{\n+  bool worker = mask & GOMP_DIM_MASK (GOMP_DIM_WORKER);\n+  bool large_vector = (mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR))\n+    && nvptx_mach_vector_length () != PTX_WARP_SIZE;\n+\n+  return worker || large_vector;\n+}\n+\n /* BLOCK is a basic block containing a head or tail instruction.\n    Locate the associated prehead or pretail instruction, which must be\n    in the single predecessor block.  */\n@@ -3147,7 +3200,7 @@ nvptx_find_par (bb_insn_map_t *map, parallel *par, basic_block block)\n \t    par = new parallel (par, mask);\n \t    par->forked_block = block;\n \t    par->forked_insn = end;\n-\t    if (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+\t    if (nvptx_needs_shared_bcast (mask))\n \t      par->fork_insn\n \t\t= nvptx_discover_pre (block, CODE_FOR_nvptx_fork);\n \t  }\n@@ -3162,7 +3215,7 @@ nvptx_find_par (bb_insn_map_t *map, parallel *par, basic_block block)\n \t    gcc_assert (par->mask == mask);\n \t    par->join_block = block;\n \t    par->join_insn = end;\n-\t    if (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+\t    if (nvptx_needs_shared_bcast (mask))\n \t      par->joining_insn\n \t\t= nvptx_discover_pre (block, CODE_FOR_nvptx_joining);\n \t    par = par->parent;\n@@ -4019,22 +4072,45 @@ nvptx_shared_propagate (bool pre_p, bool is_call, basic_block block,\n   gcc_assert (empty == !data.offset);\n   if (data.offset)\n     {\n+      rtx bcast_sym = oacc_bcast_sym;\n+\n       /* Stuff was emitted, initialize the base pointer now.  */\n-      rtx init = gen_rtx_SET (data.base, oacc_bcast_sym);\n+      if (vector && nvptx_mach_max_workers () > 1)\n+\t{\n+\t  if (!cfun->machine->bcast_partition)\n+\t    {\n+\t      /* It would be nice to place this register in\n+\t\t DATA_AREA_SHARED.  */\n+\t      cfun->machine->bcast_partition = gen_reg_rtx (DImode);\n+\t    }\n+\t  if (!cfun->machine->sync_bar)\n+\t    cfun->machine->sync_bar = gen_reg_rtx (SImode);\n+\n+\t  bcast_sym = cfun->machine->bcast_partition;\n+\t}\n+\n+      rtx init = gen_rtx_SET (data.base, bcast_sym);\n       emit_insn_after (init, insn);\n \n-      oacc_bcast_size = MAX (oacc_bcast_size, data.offset);\n+      unsigned int psize = ROUND_UP (data.offset, oacc_bcast_align);\n+      unsigned int pnum = (nvptx_mach_vector_length () > PTX_WARP_SIZE\n+\t\t\t   ? nvptx_mach_max_workers () + 1\n+\t\t\t   : 1);\n+\n+      oacc_bcast_partition = MAX (oacc_bcast_partition, psize);\n+      oacc_bcast_size = MAX (oacc_bcast_size, psize * pnum);\n     }\n   return empty;\n }\n \n-/* Emit a worker-level synchronization barrier.  We use different\n-   markers for before and after synchronizations.  */\n+/* Emit a CTA-level synchronization barrier.  LOCK is the barrier number,\n+   which is an integer or a register.  THREADS is the number of threads\n+   controlled by the barrier.  */\n \n static rtx\n-nvptx_cta_sync (bool after)\n+nvptx_cta_sync (rtx lock, int threads)\n {\n-  return gen_nvptx_barsync (GEN_INT (after), GEN_INT (0));\n+  return gen_nvptx_barsync (lock, GEN_INT (threads));\n }\n \n #if WORKAROUND_PTXJIT_BUG\n@@ -4327,7 +4403,8 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)\n     {\n       rtx pvar = XEXP (XEXP (cond_branch, 0), 0);\n \n-      if (GOMP_DIM_MASK (GOMP_DIM_VECTOR) == mask)\n+      if (GOMP_DIM_MASK (GOMP_DIM_VECTOR) == mask\n+\t  && nvptx_mach_vector_length () == PTX_WARP_SIZE)\n \t{\n \t  /* Vector mode only, do a shuffle.  */\n #if WORKAROUND_PTXJIT_BUG\n@@ -4394,25 +4471,50 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)\n \t  /* Includes worker mode, do spill & fill.  By construction\n \t     we should never have worker mode only. */\n \t  broadcast_data_t data;\n+\t  unsigned size = GET_MODE_SIZE (SImode);\n+\t  bool vector = (GOMP_DIM_MASK (GOMP_DIM_VECTOR) == mask) != 0;\n+\t  bool worker = (GOMP_DIM_MASK (GOMP_DIM_WORKER) == mask) != 0;\n+\t  rtx barrier = GEN_INT (0);\n+\t  int threads = 0;\n \n \t  data.base = oacc_bcast_sym;\n \t  data.ptr = 0;\n \n-\t  oacc_bcast_size = MAX (oacc_bcast_size, GET_MODE_SIZE (SImode));\n+\t  bool use_partitioning_p = (vector && !worker\n+\t\t\t\t     && nvptx_mach_max_workers () > 1\n+\t\t\t\t     && cfun->machine->bcast_partition);\n+\t  if (use_partitioning_p)\n+\t    {\n+\t      data.base = cfun->machine->bcast_partition;\n+\t      barrier = cfun->machine->sync_bar;\n+\t      threads = nvptx_mach_vector_length ();\n+\t    }\n+\t  gcc_assert (data.base != NULL);\n+\t  gcc_assert (barrier);\n+\n+\t  unsigned int psize = ROUND_UP (size, oacc_bcast_align);\n+\t  unsigned int pnum = (nvptx_mach_vector_length () > PTX_WARP_SIZE\n+\t\t\t       ? nvptx_mach_max_workers () + 1\n+\t\t\t       : 1);\n+\n+\t  oacc_bcast_partition = MAX (oacc_bcast_partition, psize);\n+\t  oacc_bcast_size = MAX (oacc_bcast_size, psize * pnum);\n \n \t  data.offset = 0;\n \t  emit_insn_before (nvptx_gen_shared_bcast (pvar, PM_read, 0, &data,\n-\t\t\t\t\t\t    false),\n+\t\t\t\t\t\t    vector),\n \t\t\t    before);\n+\n \t  /* Barrier so other workers can see the write.  */\n-\t  emit_insn_before (nvptx_cta_sync (false), tail);\n+\t  emit_insn_before (nvptx_cta_sync (barrier, threads), tail);\n \t  data.offset = 0;\n \t  emit_insn_before (nvptx_gen_shared_bcast (pvar, PM_write, 0, &data,\n-\t\t\t\t\t\t    false), tail);\n+\t\t\t\t\t\t    vector),\n+\t\t\t    tail);\n \t  /* This barrier is needed to avoid worker zero clobbering\n \t     the broadcast buffer before all the other workers have\n \t     had a chance to read this instance of it.  */\n-\t  emit_insn_before (nvptx_cta_sync (false), tail);\n+\t  emit_insn_before (nvptx_cta_sync (barrier, threads), tail);\n \t}\n \n       extract_insn (tail);\n@@ -4526,20 +4628,32 @@ nvptx_process_pars (parallel *par)\n     }\n \n   bool is_call = (par->mask & GOMP_DIM_MASK (GOMP_DIM_MAX)) != 0;\n+  bool worker = (par->mask & GOMP_DIM_MASK (GOMP_DIM_WORKER));\n+  bool large_vector = ((par->mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR))\n+\t\t      && nvptx_mach_vector_length () > PTX_WARP_SIZE);\n \n-  if (par->mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+  if (worker || large_vector)\n     {\n       nvptx_shared_propagate (false, is_call, par->forked_block,\n-\t\t\t      par->forked_insn, false);\n+\t\t\t      par->forked_insn, !worker);\n       bool empty = nvptx_shared_propagate (true, is_call,\n \t\t\t\t\t   par->forked_block, par->fork_insn,\n-\t\t\t\t\t   false);\n+\t\t\t\t\t   !worker);\n+      rtx barrier = GEN_INT (0);\n+      int threads = 0;\n+\n+      if (!worker && cfun->machine->sync_bar)\n+\t{\n+\t  barrier = cfun->machine->sync_bar;\n+\t  threads = nvptx_mach_vector_length ();\n+\t}\n \n       if (!empty || !is_call)\n \t{\n \t  /* Insert begin and end synchronizations.  */\n-\t  emit_insn_before (nvptx_cta_sync (false), par->forked_insn);\n-\t  emit_insn_before (nvptx_cta_sync (false), par->join_insn);\n+\t  emit_insn_before (nvptx_cta_sync (barrier, threads),\n+\t\t\t    par->forked_insn);\n+\t  emit_insn_before (nvptx_cta_sync (barrier, threads), par->join_insn);\n \t}\n     }\n   else if (par->mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR))\n@@ -6169,6 +6283,7 @@ nvptx_set_current_function (tree fndecl)\n     return;\n \n   nvptx_previous_fndecl = fndecl;\n+  oacc_bcast_partition = 0;\n }\n \n #undef TARGET_OPTION_OVERRIDE"}, {"sha": "76ce871a73176f8bc21cd4e825a3da208b69b3d8", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0024c32045a72ef45a64ab5673a2ba587978d9d1/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0024c32045a72ef45a64ab5673a2ba587978d9d1/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=0024c32045a72ef45a64ab5673a2ba587978d9d1", "patch": "@@ -221,6 +221,10 @@ struct GTY(()) machine_function\n   int axis_dim[2]; /* Maximum number of threads on each axis, dim[0] is\n \t\t      vector_length, dim[1] is num_workers.  */\n   bool axis_dim_init_p;\n+  rtx bcast_partition; /* Register containing the size of each\n+\t\t\t  vector's partition of share-memory used to\n+\t\t\t  broadcast state.  */\n+  rtx sync_bar; /* Synchronization barrier ID for vectors.  */\n   rtx unisimt_master; /* 'Master lane index' for -muniform-simt.  */\n   rtx unisimt_predicate; /* Predicate for -muniform-simt.  */\n   rtx unisimt_location; /* Mask location for -muniform-simt.  */"}]}