{"sha": "fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "node_id": "C_kwDOANBUbNoAKGZlN2MzZWNmZjFmOWMwNTIwMDkwYTc3ZmE4MjRkOGM1ZDlkYmVjMTI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-03T10:03:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-03T10:03:30Z"}, "message": "pch: Add support for PCH for relocatable executables [PR71934]\n\nSo, if we want to make PCH work for PIEs, I'd say we can:\n1) add a new GTY option, say callback, which would act like\n   skip for non-PCH and for PCH would make us skip it but\n   remember for address bias translation\n2) drop the skip for tree_translation_unit_decl::language\n3) change get_unnamed_section to have const char * as\n   last argument instead of const void *, change\n   unnamed_section::data also to const char * and update\n   everything related to that\n4) maybe add a host hook whether it is ok to support binaries\n   changing addresses (the only thing I'm worried is if\n   some host that uses function descriptors allocates them\n   dynamically instead of having them somewhere in the\n   executable)\n5) maybe add a gengtype warning if it sees in GTY tracked\n   structure a function pointer without that new callback\n   option\n\nHere is 1), 2), 3) implemented.\n\nNote, on stdc++.h.gch/O2g.gch there are just those 10 relocations without\nthe second patch, with it a few more, but nothing huge.  And for non-PIEs\nthere isn't really any extra work on the load side except freading two scalar\nvalues and fseek.\n\n2021-12-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR pch/71934\ngcc/\n\t* ggc.h (gt_pch_note_callback): Declare.\n\t* gengtype.h (enum typekind): Add TYPE_CALLBACK.\n\t(callback_type): Declare.\n\t* gengtype.c (dbgprint_count_type_at): Handle TYPE_CALLBACK.\n\t(callback_type): New variable.\n\t(process_gc_options): Add CALLBACK argument, handle callback\n\toption.\n\t(set_gc_used_type): Adjust process_gc_options caller, if callback,\n\tset type to &callback_type.\n\t(output_mangled_typename): Handle TYPE_CALLBACK.\n\t(walk_type): Likewise.  Handle callback option.\n\t(write_types_process_field): Handle TYPE_CALLBACK.\n\t(write_types_local_user_process_field): Likewise.\n\t(write_types_local_process_field): Likewise.\n\t(write_root): Likewise.\n\t(dump_typekind): Likewise.\n\t(dump_type): Likewise.\n\t* gengtype-state.c (type_lineloc): Handle TYPE_CALLBACK.\n\t(state_writer::write_state_callback_type): New method.\n\t(state_writer::write_state_type): Handle TYPE_CALLBACK.\n\t(read_state_callback_type): New function.\n\t(read_state_type): Handle TYPE_CALLBACK.\n\t* ggc-common.c (callback_vec): New variable.\n\t(gt_pch_note_callback): New function.\n\t(gt_pch_save): Stream out gt_pch_save function address and relocation\n\ttable.\n\t(gt_pch_restore): Stream in saved gt_pch_save function address and\n\trelocation table and apply relocations if needed.\n\t* doc/gty.texi (callback): Document new GTY option.\n\t* varasm.c (get_unnamed_section): Change callback argument's type and\n\tlast argument's type from const void * to const char *.\n\t(output_section_asm_op): Change argument's type from const void *\n\tto const char *, remove unnecessary cast.\n\t* tree-core.h (struct tree_translation_unit_decl): Drop GTY((skip))\n\tfrom language member.\n\t* output.h (unnamed_section_callback): Change argument type from\n\tconst void * to const char *.\n\t(struct unnamed_section): Use GTY((callback)) instead of GTY((skip))\n\tfor callback member.  Change data member type from const void *\n\tto const char *.\n\t(struct noswitch_section): Use GTY((callback)) instead of GTY((skip))\n\tfor callback member.\n\t(get_unnamed_section): Change callback argument's type and\n\tlast argument's type from const void * to const char *.\n\t(output_section_asm_op): Change argument's type from const void *\n\tto const char *.\n\t* config/avr/avr.c (avr_output_progmem_section_asm_op): Likewise.\n\tRemove unneeded cast.\n\t* config/darwin.c (output_objc_section_asm_op): Change argument's type\n\tfrom const void * to const char *.\n\t* config/pa/pa.c (som_output_text_section_asm_op): Likewise.\n\t(som_output_comdat_data_section_asm_op): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_elf_output_toc_section_asm_op):\n\tLikewise.\n\t(rs6000_xcoff_output_readonly_section_asm_op): Likewise.  Instead\n\tof dereferencing directive hardcode variable names and decide based on\n\twhether directive is NULL or not.\n\t(rs6000_xcoff_output_readwrite_section_asm_op): Change argument's type\n\tfrom const void * to const char *.\n\t(rs6000_xcoff_output_tls_section_asm_op): Likewise.  Instead\n\tof dereferencing directive hardcode variable names and decide based on\n\twhether directive is NULL or not.\n\t(rs6000_xcoff_output_toc_section_asm_op): Change argument's type\n\tfrom const void * to const char *.\n\t(rs6000_xcoff_asm_init_sections): Adjust get_unnamed_section callers.\ngcc/c-family/\n\t* c-pch.c (struct c_pch_validity): Remove pch_init member.\n\t(pch_init): Don't initialize v.pch_init.\n\t(c_common_valid_pch): Don't warn and punt if .text addresses change.\nlibcpp/\n\t* include/line-map.h (class line_maps): Add GTY((callback)) to\n\treallocator and round_alloc_size members.", "tree": {"sha": "a39e11dcb1a95a13ecbb969e1cef6d4f1f395e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a39e11dcb1a95a13ecbb969e1cef6d4f1f395e4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6262e3a22b3d86afc116480bc59a7bb30b0cfd40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6262e3a22b3d86afc116480bc59a7bb30b0cfd40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6262e3a22b3d86afc116480bc59a7bb30b0cfd40"}], "stats": {"total": 226, "additions": 175, "deletions": 51}, "files": [{"sha": "2cafa1387bbea96e2f2d770d7255fe7232427b8b", "filename": "gcc/c-family/c-pch.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fc-family%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fc-family%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pch.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -54,7 +54,6 @@ struct c_pch_validity\n {\n   uint32_t pch_write_symbols;\n   signed char match[MATCH_SIZE];\n-  void (*pch_init) (void);\n   size_t target_data_length;\n };\n \n@@ -117,7 +116,6 @@ pch_init (void)\n \tgcc_assert (v.match[i] == *pch_matching[i].flag_var);\n       }\n   }\n-  v.pch_init = &pch_init;\n   target_validity = targetm.get_pch_validity (&v.target_data_length);\n \n   if (fwrite (partial_pch, IDENT_LENGTH, 1, f) != 1\n@@ -278,19 +276,6 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \t}\n   }\n \n-  /* If the text segment was not loaded at the same address as it was\n-     when the PCH file was created, function pointers loaded from the\n-     PCH will not be valid.  We could in theory remap all the function\n-     pointers, but no support for that exists at present.\n-     Since we have the same executable, it should only be necessary to\n-     check one function.  */\n-  if (v.pch_init != &pch_init)\n-    {\n-      cpp_warning (pfile, CPP_W_INVALID_PCH,\n-\t\t   \"%s: had text segment at different address\", name);\n-      return 2;\n-    }\n-\n   /* Check the target-specific validity data.  */\n   {\n     void *this_file_data = xmalloc (v.target_data_length);"}, {"sha": "6ba038881d60fbee4988f0bf9ea03ed68d354959", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -10114,10 +10114,9 @@ avr_output_bss_section_asm_op (const void *data)\n /* Unnamed section callback for progmem*.data sections.  */\n \n static void\n-avr_output_progmem_section_asm_op (const void *data)\n+avr_output_progmem_section_asm_op (const char *data)\n {\n-  fprintf (asm_out_file, \"\\t.section\\t%s,\\\"a\\\",@progbits\\n\",\n-           (const char*) data);\n+  fprintf (asm_out_file, \"\\t.section\\t%s,\\\"a\\\",@progbits\\n\", data);\n }\n \n "}, {"sha": "8ad5b26c9808d9420f989e5a1479cacc80fcbb84", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -134,7 +134,7 @@ int emit_aligned_common = false;\n    DIRECTIVE is as for output_section_asm_op.  */\n \n static void\n-output_objc_section_asm_op (const void *directive)\n+output_objc_section_asm_op (const char *directive)\n {\n   static bool been_here = false;\n "}, {"sha": "2b10ef34061a642afcbd22ffe84a15c1284f7e8b", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -10009,7 +10009,7 @@ pa_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n    to the default text subspace.  */\n \n static void\n-som_output_text_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n+som_output_text_section_asm_op (const char *data ATTRIBUTE_UNUSED)\n {\n   gcc_assert (TARGET_SOM);\n   if (TARGET_GAS)\n@@ -10053,7 +10053,7 @@ som_output_text_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n    sections.  This function is only used with SOM.  */\n \n static void\n-som_output_comdat_data_section_asm_op (const void *data)\n+som_output_comdat_data_section_asm_op (const char *data)\n {\n   in_section = NULL;\n   output_section_asm_op (data);"}, {"sha": "34089743759735c6dd3ffaaa28e173ee00a02bab", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -20599,7 +20599,7 @@ rs6000_ms_bitfield_layout_p (const_tree record_type)\n /* A get_unnamed_section callback, used for switching to toc_section.  */\n \n static void\n-rs6000_elf_output_toc_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n+rs6000_elf_output_toc_section_asm_op (const char *data ATTRIBUTE_UNUSED)\n {\n   if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n       && TARGET_MINIMAL_TOC)\n@@ -21303,35 +21303,39 @@ rs6000_xcoff_asm_globalize_label (FILE *stream, const char *name)\n    points to the section string variable.  */\n \n static void\n-rs6000_xcoff_output_readonly_section_asm_op (const void *directive)\n+rs6000_xcoff_output_readonly_section_asm_op (const char *directive)\n {\n   fprintf (asm_out_file, \"\\t.csect %s[RO],%s\\n\",\n-\t   *(const char *const *) directive,\n+\t   directive\n+\t   ? xcoff_private_rodata_section_name\n+\t   : xcoff_read_only_section_name,\n \t   XCOFF_CSECT_DEFAULT_ALIGNMENT_STR);\n }\n \n /* Likewise for read-write sections.  */\n \n static void\n-rs6000_xcoff_output_readwrite_section_asm_op (const void *directive)\n+rs6000_xcoff_output_readwrite_section_asm_op (const char *)\n {\n   fprintf (asm_out_file, \"\\t.csect %s[RW],%s\\n\",\n-\t   *(const char *const *) directive,\n+\t   xcoff_private_data_section_name,\n \t   XCOFF_CSECT_DEFAULT_ALIGNMENT_STR);\n }\n \n static void\n-rs6000_xcoff_output_tls_section_asm_op (const void *directive)\n+rs6000_xcoff_output_tls_section_asm_op (const char *directive)\n {\n   fprintf (asm_out_file, \"\\t.csect %s[TL],%s\\n\",\n-\t   *(const char *const *) directive,\n+\t   directive\n+\t   ? xcoff_private_data_section_name\n+\t   : xcoff_tls_data_section_name,\n \t   XCOFF_CSECT_DEFAULT_ALIGNMENT_STR);\n }\n \n /* A get_unnamed_section callback, used for switching to toc_section.  */\n \n static void\n-rs6000_xcoff_output_toc_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n+rs6000_xcoff_output_toc_section_asm_op (const char *data ATTRIBUTE_UNUSED)\n {\n   if (TARGET_MINIMAL_TOC)\n     {\n@@ -21358,26 +21362,26 @@ rs6000_xcoff_asm_init_sections (void)\n {\n   read_only_data_section\n     = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,\n-\t\t\t   &xcoff_read_only_section_name);\n+\t\t\t   NULL);\n \n   private_data_section\n     = get_unnamed_section (SECTION_WRITE,\n \t\t\t   rs6000_xcoff_output_readwrite_section_asm_op,\n-\t\t\t   &xcoff_private_data_section_name);\n+\t\t\t   NULL);\n \n   read_only_private_data_section\n     = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,\n-\t\t\t   &xcoff_private_rodata_section_name);\n+\t\t\t   \"\");\n \n   tls_data_section\n     = get_unnamed_section (SECTION_TLS,\n \t\t\t   rs6000_xcoff_output_tls_section_asm_op,\n-\t\t\t   &xcoff_tls_data_section_name);\n+\t\t\t   NULL);\n \n   tls_private_data_section\n     = get_unnamed_section (SECTION_TLS,\n \t\t\t   rs6000_xcoff_output_tls_section_asm_op,\n-\t\t\t   &xcoff_private_data_section_name);\n+\t\t\t   \"\");\n \n   toc_section\n     = get_unnamed_section (0, rs6000_xcoff_output_toc_section_asm_op, NULL);"}, {"sha": "ca2c8404894a40542ace58cd5df5ebc2a81bb18b", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -205,6 +205,15 @@ If @code{skip} is applied to a field, the type machinery will ignore it.\n This is somewhat dangerous; the only safe use is in a union when one\n field really isn't ever used.\n \n+@findex callback\n+@item callback\n+\n+@code{callback} should be applied to fields with pointer to function type\n+and causes the field to be ignored similarly to @code{skip}, except when\n+writing PCH and the field is non-NULL it will remember the field's address\n+for relocation purposes if the process writing PCH has different load base\n+from a process reading PCH.\n+\n @findex for_user\n @item for_user\n "}, {"sha": "36a96e8457467a67fb98cd183c7bf02e4665d793", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -57,6 +57,7 @@ type_lineloc (const_type_p ty)\n     case TYPE_STRING:\n     case TYPE_POINTER:\n     case TYPE_ARRAY:\n+    case TYPE_CALLBACK:\n       return NULL;\n     default:\n       gcc_unreachable ();\n@@ -171,6 +172,7 @@ class state_writer : public s_expr_writer\n   void write_state_version (const char *version);\n   void write_state_scalar_type (type_p current);\n   void write_state_string_type (type_p current);\n+  void write_state_callback_type (type_p current);\n   void write_state_undefined_type (type_p current);\n   void write_state_struct_union_type (type_p current, const char *kindstr);\n   void write_state_struct_type (type_p current);\n@@ -898,6 +900,20 @@ state_writer::write_state_string_type (type_p current)\n     fatal (\"Unexpected type in write_state_string_type\");\n }\n \n+/* Write the callback type.  There is only one such thing! */\n+void\n+state_writer::write_state_callback_type (type_p current)\n+{\n+  if (current == &callback_type)\n+    {\n+      write_any_indent (0);\n+      fprintf (state_file, \"callback \");\n+      write_state_common_type_content (current);\n+    }\n+  else\n+    fatal (\"Unexpected type in write_state_callback_type\");\n+}\n+\n /* Write an undefined type.  */\n void\n state_writer::write_state_undefined_type (type_p current)\n@@ -1143,6 +1159,9 @@ state_writer::write_state_type (type_p current)\n \tcase TYPE_STRING:\n \t  write_state_string_type (current);\n \t  break;\n+\tcase TYPE_CALLBACK:\n+\t  write_state_callback_type (current);\n+\t  break;\n \t}\n     }\n \n@@ -1477,6 +1496,14 @@ read_state_string_type (type_p *type)\n   read_state_common_type_content (*type);\n }\n \n+/* Read the callback_type.  */\n+static void\n+read_state_callback_type (type_p *type)\n+{\n+  *type = &callback_type;\n+  read_state_common_type_content (*type);\n+}\n+\n \n /* Read a lang_bitmap representing a set of GCC front-end languages.  */\n static void\n@@ -1834,6 +1861,11 @@ read_state_type (type_p *current)\n \t      next_state_tokens (1);\n \t      read_state_string_type (current);\n \t    }\n+\t  else if (state_token_is_name (t0, \"callback\"))\n+\t    {\n+\t      next_state_tokens (1);\n+\t      read_state_callback_type (current);\n+\t    }\n \t  else if (state_token_is_name (t0, \"undefined\"))\n \t    {\n \t      *current = XCNEW (struct type);"}, {"sha": "b9daaa43689c29422c5592b7ddd21a43e740db7e", "filename": "gcc/gengtype.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -172,6 +172,7 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n   int nb_struct = 0, nb_union = 0, nb_array = 0, nb_pointer = 0;\n   int nb_lang_struct = 0;\n   int nb_user_struct = 0, nb_undefined = 0;\n+  int nb_callback = 0;\n   type_p p = NULL;\n   for (p = t; p; p = p->next)\n     {\n@@ -202,6 +203,9 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n \tcase TYPE_ARRAY:\n \t  nb_array++;\n \t  break;\n+\tcase TYPE_CALLBACK:\n+\t  nb_callback++;\n+\t  break;\n \tcase TYPE_LANG_STRUCT:\n \t  nb_lang_struct++;\n \t  break;\n@@ -217,6 +221,8 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n     fprintf (stderr, \"@@%%@@ %d structs, %d unions\\n\", nb_struct, nb_union);\n   if (nb_pointer > 0 || nb_array > 0)\n     fprintf (stderr, \"@@%%@@ %d pointers, %d arrays\\n\", nb_pointer, nb_array);\n+  if (nb_callback > 0)\n+    fprintf (stderr, \"@@%%@@ %d callbacks\\n\", nb_callback);\n   if (nb_lang_struct > 0)\n     fprintf (stderr, \"@@%%@@ %d lang_structs\\n\", nb_lang_struct);\n   if (nb_user_struct > 0)\n@@ -495,6 +501,10 @@ struct type scalar_char = {\n   TYPE_SCALAR, 0, 0, 0, GC_USED, {0}\n };\n \n+struct type callback_type = {\n+  TYPE_CALLBACK, 0, 0, 0, GC_USED, {0}\n+};\n+\n /* Lists of various things.  */\n \n pair_p typedefs = NULL;\n@@ -1464,7 +1474,7 @@ static void set_gc_used (pair_p);\n \n static void\n process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n-\t\t    int *length, int *skip, type_p *nested_ptr)\n+\t\t    int *length, int *skip, int *callback, type_p *nested_ptr)\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n@@ -1478,6 +1488,8 @@ process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n       *length = 1;\n     else if (strcmp (o->name, \"skip\") == 0)\n       *skip = 1;\n+    else if (strcmp (o->name, \"callback\") == 0)\n+      *callback = 1;\n     else if (strcmp (o->name, \"nested_ptr\") == 0\n \t     && o->kind == OPTION_NESTED)\n       *nested_ptr = ((const struct nested_ptr_data *) o->info.nested)->type;\n@@ -1526,7 +1538,7 @@ set_gc_used_type (type_p t, enum gc_used_enum level,\n \ttype_p dummy2;\n \tbool allow_undefined_field_types = (t->kind == TYPE_USER_STRUCT);\n \n-\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy,\n+\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy, &dummy,\n \t\t\t    &dummy2);\n \n \tif (t->u.s.base_class)\n@@ -1542,9 +1554,10 @@ set_gc_used_type (type_p t, enum gc_used_enum level,\n \t    int maybe_undef = 0;\n \t    int length = 0;\n \t    int skip = 0;\n+\t    int callback = 0;\n \t    type_p nested_ptr = NULL;\n \t    process_gc_options (f->opt, level, &maybe_undef, &length, &skip,\n-\t\t\t\t&nested_ptr);\n+\t\t\t\t&callback, &nested_ptr);\n \n \t    if (nested_ptr && f->type->kind == TYPE_POINTER)\n \t      set_gc_used_type (nested_ptr, GC_POINTED_TO);\n@@ -1554,6 +1567,8 @@ set_gc_used_type (type_p t, enum gc_used_enum level,\n \t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO);\n \t    else if (skip)\n \t      ;\t\t\t/* target type is not used through this field */\n+\t    else if (callback)\n+\t      f->type = &callback_type;\n \t    else\n \t      set_gc_used_type (f->type, GC_USED, allow_undefined_field_types);\n \t  }\n@@ -2519,6 +2534,7 @@ output_mangled_typename (outf_p of, const_type_p t)\n       {\n       case TYPE_NONE:\n       case TYPE_UNDEFINED:\n+      case TYPE_CALLBACK:\n \tgcc_unreachable ();\n \tbreak;\n       case TYPE_POINTER:\n@@ -2719,6 +2735,8 @@ walk_type (type_p t, struct walk_type_data *d)\n       ;\n     else if (strcmp (oo->name, \"for_user\") == 0)\n       ;\n+    else if (strcmp (oo->name, \"callback\") == 0)\n+      ;\n     else\n       error_at_line (d->line, \"unknown option `%s'\\n\", oo->name);\n \n@@ -2744,6 +2762,7 @@ walk_type (type_p t, struct walk_type_data *d)\n     {\n     case TYPE_SCALAR:\n     case TYPE_STRING:\n+    case TYPE_CALLBACK:\n       d->process_field (t, d);\n       break;\n \n@@ -3275,6 +3294,7 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n       break;\n \n     case TYPE_SCALAR:\n+    case TYPE_CALLBACK:\n       break;\n \n     case TYPE_ARRAY:\n@@ -3820,6 +3840,7 @@ write_types_local_user_process_field (type_p f, const struct walk_type_data *d)\n       break;\n \n     case TYPE_SCALAR:\n+    case TYPE_CALLBACK:\n       break;\n \n     case TYPE_ARRAY:\n@@ -3906,6 +3927,13 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_SCALAR:\n       break;\n \n+    case TYPE_CALLBACK:\n+      oprintf (d->of, \"%*sif ((void *)(%s) == this_obj)\\n\", d->indent, \"\",\n+\t       d->prev_val[3]);\n+      oprintf (d->of, \"%*s  gt_pch_note_callback (&(%s), this_obj);\\n\",\n+\t       d->indent, \"\", d->val);\n+      break;\n+\n     case TYPE_ARRAY:\n     case TYPE_NONE:\n     case TYPE_UNDEFINED:\n@@ -4434,6 +4462,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n     case TYPE_UNDEFINED:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n+    case TYPE_CALLBACK:\n       error_at_line (line, \"global `%s' is unimplemented type\", name);\n     }\n }\n@@ -4728,6 +4757,9 @@ dump_typekind (int indent, enum typekind kind)\n     case TYPE_ARRAY:\n       printf (\"TYPE_ARRAY\");\n       break;\n+    case TYPE_CALLBACK:\n+      printf (\"TYPE_CALLBACK\");\n+      break;\n     case TYPE_LANG_STRUCT:\n       printf (\"TYPE_LANG_STRUCT\");\n       break;\n@@ -4894,6 +4926,7 @@ dump_type (int indent, type_p t)\n \t      t->u.scalar_is_char ? \"true\" : \"false\");\n       break;\n     case TYPE_STRING:\n+    case TYPE_CALLBACK:\n       break;\n     case TYPE_STRUCT:\n     case TYPE_UNION:"}, {"sha": "8fa7064ca85e3a41f0159b52a9ace520dfe03c14", "filename": "gcc/gengtype.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -154,6 +154,9 @@ enum typekind {\n   TYPE_UNION,           /* Type for GTY-ed discriminated unions.  */\n   TYPE_POINTER,         /* Pointer type to GTY-ed type.  */\n   TYPE_ARRAY,           /* Array of GTY-ed types.  */\n+  TYPE_CALLBACK,\t/* A function pointer that needs relocation if\n+\t\t\t   the executable has been loaded at a different\n+\t\t\t   address.  */\n   TYPE_LANG_STRUCT,     /* GCC front-end language specific structs.\n                            Various languages may have homonymous but\n                            different structs.  */\n@@ -331,6 +334,9 @@ extern struct type string_type;\n extern struct type scalar_nonchar;\n extern struct type scalar_char;\n \n+/* The one and only TYPE_CALLBACK.  */\n+extern struct type callback_type;\n+\n /* Test if a type is a union, either a plain one or a language\n    specific one.  */\n #define UNION_P(x)\t\t\t\t\t\\"}, {"sha": "7c998e9547311023e128cf7107e07025d6181cc9", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -246,6 +246,7 @@ saving_hasher::equal (const ptr_data *p1, const void *p2)\n }\n \n static hash_table<saving_hasher> *saving_htab;\n+static vec<void *> callback_vec;\n \n /* Register an object in the hash table.  */\n \n@@ -278,6 +279,23 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n   return 1;\n }\n \n+/* Register address of a callback pointer.  */\n+void\n+gt_pch_note_callback (void *obj, void *base)\n+{\n+  void *ptr;\n+  memcpy (&ptr, obj, sizeof (void *));\n+  if (ptr != NULL)\n+    {\n+      struct ptr_data *data\n+\t= (struct ptr_data *)\n+\t  saving_htab->find_with_hash (base, POINTER_HASH (base));\n+      gcc_assert (data);\n+      callback_vec.safe_push ((char *) data->new_addr\n+\t\t\t      + ((char *) obj - (char *) base));\n+    }\n+}\n+\n /* Register an object in the hash table.  */\n \n void\n@@ -576,10 +594,20 @@ gt_pch_save (FILE *f)\n   ggc_pch_finish (state.d, state.f);\n   gt_pch_fixup_stringpool ();\n \n+  unsigned num_callbacks = callback_vec.length ();\n+  void (*pch_save) (FILE *) = &gt_pch_save;\n+  if (fwrite (&pch_save, sizeof (pch_save), 1, f) != 1\n+      || fwrite (&num_callbacks, sizeof (num_callbacks), 1, f) != 1\n+      || (num_callbacks\n+\t  && fwrite (callback_vec.address (), sizeof (void *), num_callbacks,\n+\t\t     f) != num_callbacks))\n+    fatal_error (input_location, \"cannot write PCH file: %m\");\n+\n   XDELETE (state.ptrs);\n   XDELETE (this_object);\n   delete saving_htab;\n   saving_htab = NULL;\n+  callback_vec.release ();\n }\n \n /* Read the state of the compiler back in from F.  */\n@@ -661,6 +689,30 @@ gt_pch_restore (FILE *f)\n \n   gt_pch_restore_stringpool ();\n \n+  void (*pch_save) (FILE *);\n+  unsigned num_callbacks;\n+  if (fread (&pch_save, sizeof (pch_save), 1, f) != 1\n+      || fread (&num_callbacks, sizeof (num_callbacks), 1, f) != 1)\n+    fatal_error (input_location, \"cannot read PCH file: %m\");\n+  if (pch_save != &gt_pch_save)\n+    {\n+      uintptr_t bias = (uintptr_t) &gt_pch_save - (uintptr_t) pch_save;\n+      void **ptrs = XNEWVEC (void *, num_callbacks);\n+      unsigned i;\n+\n+      if (fread (ptrs, sizeof (void *), num_callbacks, f) != num_callbacks)\n+\tfatal_error (input_location, \"cannot read PCH file: %m\");\n+      for (i = 0; i < num_callbacks; ++i)\n+\t{\n+\t  memcpy (&pch_save, ptrs[i], sizeof (pch_save));\n+\t  pch_save = (void (*) (FILE *)) ((uintptr_t) pch_save + bias);\n+\t  memcpy (ptrs[i], &pch_save, sizeof (pch_save));\n+\t}\n+      XDELETE (ptrs);\n+    }\n+  else if (fseek (f, num_callbacks * sizeof (void *), SEEK_CUR) != 0)\n+    fatal_error (input_location, \"cannot read PCH file: %m\");\n+\n   /* Barring corruption of the PCH file, the restored line table should be\n      complete and usable.  */\n   line_table = new_line_table;"}, {"sha": "c005f7e04128af45635c8667b6e7b3aa3b2651c5", "filename": "gcc/ggc.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -46,6 +46,10 @@ typedef void (*gt_handle_reorder) (void *, void *, gt_pointer_operator,\n /* Used by the gt_pch_n_* routines.  Register an object in the hash table.  */\n extern int gt_pch_note_object (void *, void *, gt_note_pointers);\n \n+/* Used by the gt_pch_p_* routines.  Register address of a callback\n+   pointer.  */\n+extern void gt_pch_note_callback (void *, void *);\n+\n /* Used by the gt_pch_n_* routines.  Register that an object has a reorder\n    function.  */\n extern void gt_pch_note_reorder (void *, void *, gt_handle_reorder);"}, {"sha": "4a23795bf7e5b149a6fc45c33a27eadcf14538b0", "filename": "gcc/output.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -470,16 +470,16 @@ struct GTY(()) named_section {\n \n /* A callback that writes the assembly code for switching to an unnamed\n    section.  The argument provides callback-specific data.  */\n-typedef void (*unnamed_section_callback) (const void *);\n+typedef void (*unnamed_section_callback) (const char *);\n \n /* Information about a SECTION_UNNAMED section.  */\n struct GTY(()) unnamed_section {\n   struct section_common common;\n \n   /* The callback used to switch to the section, and the data that\n      should be passed to the callback.  */\n-  unnamed_section_callback GTY ((skip)) callback;\n-  const void *GTY ((skip)) data;\n+  unnamed_section_callback GTY ((callback)) callback;\n+  const char *data;\n \n   /* The next entry in the chain of unnamed sections.  */\n   section *next;\n@@ -503,7 +503,7 @@ struct GTY(()) noswitch_section {\n   struct section_common common;\n \n   /* The callback used to assemble decls in this section.  */\n-  noswitch_section_callback GTY ((skip)) callback;\n+  noswitch_section_callback GTY ((callback)) callback;\n };\n \n /* Information about a section, which may be named or unnamed.  */\n@@ -538,8 +538,8 @@ extern GTY(()) section *bss_noswitch_section;\n extern GTY(()) section *in_section;\n extern GTY(()) bool in_cold_section_p;\n \n-extern section *get_unnamed_section (unsigned int, void (*) (const void *),\n-\t\t\t\t     const void *);\n+extern section *get_unnamed_section (unsigned int, void (*) (const char *),\n+\t\t\t\t     const char *);\n extern section *get_section (const char *, unsigned int, tree,\n \t\t\t     bool not_existing = false);\n extern section *get_named_section (tree, const char *, int);\n@@ -561,7 +561,7 @@ extern section *get_cdtor_priority_section (int, bool);\n \n extern bool unlikely_text_section_p (section *);\n extern void switch_to_section (section *, tree = nullptr);\n-extern void output_section_asm_op (const void *);\n+extern void output_section_asm_op (const char *);\n \n extern void record_tm_clone_pair (tree, tree);\n extern void finish_tm_clone_pairs (void);"}, {"sha": "91ae5237d7eb44bd624e9a5f349b750ed87c1dfe", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -1961,7 +1961,7 @@ struct GTY(()) tree_function_decl {\n struct GTY(()) tree_translation_unit_decl {\n   struct tree_decl_common common;\n   /* Source language of this translation unit.  Used for DWARF output.  */\n-  const char * GTY((skip(\"\"))) language;\n+  const char *language;\n   /* TODO: Non-optimization used to build this translation unit.  */\n   /* TODO: Root of a partial DWARF tree for global types and decls.  */\n };"}, {"sha": "aff93ca5de91a5d0b8c2f8fbc27f0142e0594664", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -250,8 +250,8 @@ object_block_hasher::hash (object_block *old)\n /* Return a new unnamed section with the given fields.  */\n \n section *\n-get_unnamed_section (unsigned int flags, void (*callback) (const void *),\n-\t\t     const void *data)\n+get_unnamed_section (unsigned int flags, void (*callback) (const char *),\n+\t\t     const char *data)\n {\n   section *sect;\n \n@@ -7778,9 +7778,9 @@ file_end_indicate_split_stack (void)\n    a get_unnamed_section callback.  */\n \n void\n-output_section_asm_op (const void *directive)\n+output_section_asm_op (const char *directive)\n {\n-  fprintf (asm_out_file, \"%s\\n\", (const char *) directive);\n+  fprintf (asm_out_file, \"%s\\n\", directive);\n }\n \n /* Emit assembly code to switch to section NEW_SECTION.  Do nothing if"}, {"sha": "bc40e3335799afb3f17c028e7c50c85277e87167", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=fe7c3ecff1f9c0520090a77fa824d8c5d9dbec12", "patch": "@@ -803,11 +803,11 @@ class GTY(()) line_maps {\n   unsigned int max_column_hint;\n \n   /* The allocator to use when resizing 'maps', defaults to xrealloc.  */\n-  line_map_realloc reallocator;\n+  line_map_realloc GTY((callback)) reallocator;\n \n   /* The allocators' function used to know the actual size it\n      allocated, for a certain allocation size requested.  */\n-  line_map_round_alloc_size_func round_alloc_size;\n+  line_map_round_alloc_size_func GTY((callback)) round_alloc_size;\n \n   struct location_adhoc_data_map location_adhoc_data_map;\n "}]}