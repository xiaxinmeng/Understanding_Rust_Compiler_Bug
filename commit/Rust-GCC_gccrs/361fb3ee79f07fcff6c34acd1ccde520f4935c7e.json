{"sha": "361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxZmIzZWU3OWYwN2ZjZmY2YzM0YWNkMWNjZGU1MjBmNDkzNWM3ZQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-08-04T10:06:51Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-08-04T10:06:51Z"}, "message": "[AArch64][6/14] Implement TARGET_OPTION_SAVE/TARGET_OPTION_RESTORE\n\n\t* config/aarch64/aarch64.opt (explicit_tune_core): New TargetVariable.\n\t(explicit_arch): Likewise.\n\t(x_aarch64_isa_flags): Likewise.\n\t(mgeneral-regs-only): Mark as Save.\n\t(mfix-cortex-a53-835769): Likewise.\n\t(mcmodel=): Likewise.\n\t(mstrict-align): Likewise.\n\t(momit-leaf-frame-pointer): Likewise.\n\t(mtls-dialect): Likewise.\n\t(master=): Likewise.\n\t* config/aarch64/aarch64.h (ASM_DECLARE_FUNCTION_NAME): Define.\n\t(aarch64_isa_flags): Remove extern declaration.\n\t* config/aarch64/aarch64.c (aarch64_validate_mcpu): Return a bool\n\tto indicate success or failure.\n\t(aarch64_validate_march): Likewise.\n\t(aarch64_validate_mtune): Likewise.\n\t(aarch64_isa_flags): Delete.\n\t(aarch64_override_options_internal): Access opts->x_aarch64_isa_flags\n\tinstead of aarch64_isa_flags.\n\t(aarch64_get_tune_cpu): New function.\n\t(aarch64_get_arch): Likewise.\n\t(aarch64_override_options): Use above and set up explicit_tune_core\n\tand explicit_arch.\n\t(aarch64_print_extension): Move earlier in file.  Add isa_flags\n\targument and use that instead of the global aarch64_isa_flags.\n\t(aarch64_option_save): New function.\n\t(aarch64_option_restore): Likewise.\n\t(aarch64_option_print): Likewise.\n\t(aarch64_declare_function_name): Likewise.\n\t(aarch64_start_file): Delete.\n\t(TARGET_ASM_FILE_START): Do not define.\n\t(TARGET_OPTION_RESTORE, TARGET_OPTION_PRINT): Define.\n\t* config/aarch64/aarch64-protos.h (aarch64_declare_function_name):\n\tDeclare prototype.\n\nFrom-SVN: r226558", "tree": {"sha": "4824bb33ccf335f756474cf21ab91318ee4a0dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4824bb33ccf335f756474cf21ab91318ee4a0dc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bca541c364edc0f18e4edbb2f6918db5e5676ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca541c364edc0f18e4edbb2f6918db5e5676ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bca541c364edc0f18e4edbb2f6918db5e5676ac8"}], "stats": {"total": 301, "additions": 242, "deletions": 59}, "files": [{"sha": "985d7df8a80c819399509797c1593b98592fe225", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "patch": "@@ -1,3 +1,40 @@\n+2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.opt (explicit_tune_core): New TargetVariable.\n+\t(explicit_arch): Likewise.\n+\t(x_aarch64_isa_flags): Likewise.\n+\t(mgeneral-regs-only): Mark as Save.\n+\t(mfix-cortex-a53-835769): Likewise.\n+\t(mcmodel=): Likewise.\n+\t(mstrict-align): Likewise.\n+\t(momit-leaf-frame-pointer): Likewise.\n+\t(mtls-dialect): Likewise.\n+\t(master=): Likewise.\n+\t* config/aarch64/aarch64.h (ASM_DECLARE_FUNCTION_NAME): Define.\n+\t(aarch64_isa_flags): Remove extern declaration.\n+\t* config/aarch64/aarch64.c (aarch64_validate_mcpu): Return a bool\n+\tto indicate success or failure.\n+\t(aarch64_validate_march): Likewise.\n+\t(aarch64_validate_mtune): Likewise.\n+\t(aarch64_isa_flags): Delete.\n+\t(aarch64_override_options_internal): Access opts->x_aarch64_isa_flags\n+\tinstead of aarch64_isa_flags.\n+\t(aarch64_get_tune_cpu): New function.\n+\t(aarch64_get_arch): Likewise.\n+\t(aarch64_override_options): Use above and set up explicit_tune_core\n+\tand explicit_arch.\n+\t(aarch64_print_extension): Move earlier in file.  Add isa_flags\n+\targument and use that instead of the global aarch64_isa_flags.\n+\t(aarch64_option_save): New function.\n+\t(aarch64_option_restore): Likewise.\n+\t(aarch64_option_print): Likewise.\n+\t(aarch64_declare_function_name): Likewise.\n+\t(aarch64_start_file): Delete.\n+\t(TARGET_ASM_FILE_START): Do not define.\n+\t(TARGET_OPTION_RESTORE, TARGET_OPTION_PRINT): Define.\n+\t* config/aarch64/aarch64-protos.h (aarch64_declare_function_name):\n+\tDeclare prototype.\n+\n 2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.opt (momit-leaf-frame-pointer): Initialize"}, {"sha": "fc1cec75db223c5bf59a64cd6c370fe4697a3388", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "patch": "@@ -255,6 +255,7 @@ bool aarch64_gimple_fold_builtin (gimple_stmt_iterator *);\n bool aarch64_is_extend_from_extract (machine_mode, rtx, rtx);\n bool aarch64_is_long_call_p (rtx);\n bool aarch64_label_mentioned_p (rtx);\n+void aarch64_declare_function_name (FILE *, const char*, tree);\n bool aarch64_legitimate_pic_operand_p (rtx);\n bool aarch64_modes_tieable_p (machine_mode mode1,\n \t\t\t      machine_mode mode2);"}, {"sha": "caf50ea70e7a01cb9c54f58ec7a685a85469e9b2", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 181, "deletions": 52, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "patch": "@@ -158,9 +158,6 @@ unsigned aarch64_architecture_version;\n /* The processor for which instructions should be scheduled.  */\n enum aarch64_processor aarch64_tune = cortexa53;\n \n-/* Mask to specify which instructions we are allowed to generate.  */\n-unsigned long aarch64_isa_flags = 0;\n-\n /* Mask to specify which instruction scheduling options should be used.  */\n unsigned long aarch64_tune_flags = 0;\n \n@@ -531,8 +528,8 @@ static const struct processor all_cores[] =\n };\n \n \n-/* Target specification.  These are populated as commandline arguments\n-   are processed, or NULL if not specified.  */\n+/* Target specification.  These are populated by the -march, -mtune, -mcpu\n+   handling code or by target attributes.  */\n static const struct processor *selected_arch;\n static const struct processor *selected_cpu;\n static const struct processor *selected_tune;\n@@ -7552,7 +7549,7 @@ aarch64_override_options_internal (struct gcc_options *opts)\n       /* aarch64_parse_extension takes char* rather than const char* because\n \t it is usually called from within other parsing functions.  */\n       char tmp_str[] = \"+nofp\";\n-      aarch64_parse_extension (tmp_str, &aarch64_isa_flags);\n+      aarch64_parse_extension (tmp_str, &opts->x_aarch64_isa_flags);\n     }\n \n   initialize_aarch64_code_model (opts);\n@@ -7562,17 +7559,18 @@ aarch64_override_options_internal (struct gcc_options *opts)\n \n /* Validate a command-line -mcpu option.  Parse the cpu and extensions (if any)\n    specified in STR and throw errors if appropriate.  Put the results if\n-   they are valid in RES and ISA_FLAGS.  */\n+   they are valid in RES and ISA_FLAGS.  Return whether the option is\n+   valid.  */\n \n-static void\n+static bool\n aarch64_validate_mcpu (const char *str, const struct processor **res,\n \t\t       unsigned long *isa_flags)\n {\n   enum aarch64_parse_opt_result parse_res\n     = aarch64_parse_cpu (str, res, isa_flags);\n \n   if (parse_res == AARCH64_PARSE_OK)\n-    return;\n+    return true;\n \n   switch (parse_res)\n     {\n@@ -7588,21 +7586,24 @@ aarch64_validate_mcpu (const char *str, const struct processor **res,\n       default:\n \tgcc_unreachable ();\n     }\n+\n+  return false;\n }\n \n /* Validate a command-line -march option.  Parse the arch and extensions\n    (if any) specified in STR and throw errors if appropriate.  Put the\n-   results, if they are valid, in RES and ISA_FLAGS.  */\n+   results, if they are valid, in RES and ISA_FLAGS.  Return whether the\n+   option is valid.  */\n \n-static void\n+static bool\n aarch64_validate_march (const char *str, const struct processor **res,\n \t\t       unsigned long *isa_flags)\n {\n   enum aarch64_parse_opt_result parse_res\n     = aarch64_parse_arch (str, res, isa_flags);\n \n   if (parse_res == AARCH64_PARSE_OK)\n-    return;\n+    return true;\n \n   switch (parse_res)\n     {\n@@ -7618,20 +7619,23 @@ aarch64_validate_march (const char *str, const struct processor **res,\n       default:\n \tgcc_unreachable ();\n     }\n+\n+  return false;\n }\n \n /* Validate a command-line -mtune option.  Parse the cpu\n    specified in STR and throw errors if appropriate.  Put the\n-   result, if it is valid, in RES.  */\n+   result, if it is valid, in RES.  Return whether the option is\n+   valid.  */\n \n-static void\n+static bool\n aarch64_validate_mtune (const char *str, const struct processor **res)\n {\n   enum aarch64_parse_opt_result parse_res\n     = aarch64_parse_tune (str, res);\n \n   if (parse_res == AARCH64_PARSE_OK)\n-    return;\n+    return true;\n \n   switch (parse_res)\n     {\n@@ -7644,6 +7648,38 @@ aarch64_validate_mtune (const char *str, const struct processor **res)\n       default:\n \tgcc_unreachable ();\n     }\n+  return false;\n+}\n+\n+/* Return the CPU corresponding to the enum CPU.\n+   If it doesn't specify a cpu, return the default.  */\n+\n+static const struct processor *\n+aarch64_get_tune_cpu (enum aarch64_processor cpu)\n+{\n+  if (cpu != aarch64_none)\n+    return &all_cores[cpu];\n+\n+  /* The & 0x3f is to extract the bottom 6 bits that encode the\n+     default cpu as selected by the --with-cpu GCC configure option\n+     in config.gcc.\n+     ???: The whole TARGET_CPU_DEFAULT and AARCH64_CPU_DEFAULT_FLAGS\n+     flags mechanism should be reworked to make it more sane.  */\n+  return &all_cores[TARGET_CPU_DEFAULT & 0x3f];\n+}\n+\n+/* Return the architecture corresponding to the enum ARCH.\n+   If it doesn't specify a valid architecture, return the default.  */\n+\n+static const struct processor *\n+aarch64_get_arch (enum aarch64_arch arch)\n+{\n+  if (arch != aarch64_no_arch)\n+    return &all_architectures[arch];\n+\n+  const struct processor *cpu = &all_cores[TARGET_CPU_DEFAULT & 0x3f];\n+\n+  return &all_architectures[cpu->arch];\n }\n \n /* Implement TARGET_OPTION_OVERRIDE.  This is called once in the beginning\n@@ -7660,6 +7696,10 @@ aarch64_override_options (void)\n   unsigned long arch_isa = 0;\n   aarch64_isa_flags = 0;\n \n+  bool valid_cpu = true;\n+  bool valid_tune = true;\n+  bool valid_arch = true;\n+\n   selected_cpu = NULL;\n   selected_arch = NULL;\n   selected_tune = NULL;\n@@ -7668,13 +7708,15 @@ aarch64_override_options (void)\n      If either of -march or -mtune is given, they override their\n      respective component of -mcpu.  */\n   if (aarch64_cpu_string)\n-    aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu, &cpu_isa);\n+    valid_cpu = aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu,\n+\t\t\t\t\t&cpu_isa);\n \n   if (aarch64_arch_string)\n-    aarch64_validate_march (aarch64_arch_string, &selected_arch, &arch_isa);\n+    valid_arch = aarch64_validate_march (aarch64_arch_string, &selected_arch,\n+\t\t\t\t\t  &arch_isa);\n \n   if (aarch64_tune_string)\n-    aarch64_validate_mtune (aarch64_tune_string, &selected_tune);\n+    valid_tune = aarch64_validate_mtune (aarch64_tune_string, &selected_tune);\n \n   /* If the user did not specify a processor, choose the default\n      one for them.  This will be the CPU set during configuration using\n@@ -7685,12 +7727,17 @@ aarch64_override_options (void)\n \t{\n \t  selected_cpu = &all_cores[selected_arch->ident];\n \t  aarch64_isa_flags = arch_isa;\n+\t  explicit_arch = selected_arch->arch;\n \t}\n       else\n \t{\n-\t  selected_cpu = &all_cores[TARGET_CPU_DEFAULT & 0x3f];\n+\t  /* Get default configure-time CPU.  */\n+\t  selected_cpu = aarch64_get_tune_cpu (aarch64_none);\n \t  aarch64_isa_flags = TARGET_CPU_DEFAULT >> 6;\n \t}\n+\n+      if (selected_tune)\n+\texplicit_tune_core = selected_tune->ident;\n     }\n   /* If both -mcpu and -march are specified check that they are architecturally\n      compatible, warn if they're not and prefer the -march ISA flags.  */\n@@ -7703,11 +7750,19 @@ aarch64_override_options (void)\n \t\t       selected_arch->name);\n \t}\n       aarch64_isa_flags = arch_isa;\n+      explicit_arch = selected_arch->arch;\n+      explicit_tune_core = selected_tune ? selected_tune->ident\n+\t\t\t\t\t  : selected_cpu->ident;\n     }\n   else\n     {\n       /* -mcpu but no -march.  */\n       aarch64_isa_flags = cpu_isa;\n+      explicit_tune_core = selected_tune ? selected_tune->ident\n+\t\t\t\t\t  : selected_cpu->ident;\n+      gcc_assert (selected_cpu);\n+      selected_arch = &all_architectures[selected_cpu->arch];\n+      explicit_arch = selected_arch->arch;\n     }\n \n   /* Set the arch as well as we will need it when outputing\n@@ -7728,6 +7783,15 @@ aarch64_override_options (void)\n     error (\"Assembler does not support -mabi=ilp32\");\n #endif\n \n+  /* Make sure we properly set up the explicit options.  */\n+  if ((aarch64_cpu_string && valid_cpu)\n+       || (aarch64_tune_string && valid_tune))\n+    gcc_assert (explicit_tune_core != aarch64_none);\n+\n+  if ((aarch64_cpu_string && valid_cpu)\n+       || (aarch64_arch_string && valid_arch))\n+    gcc_assert (explicit_arch != aarch64_no_arch);\n+\n   aarch64_build_bitmask_table ();\n \n   aarch64_override_options_internal (&global_options);\n@@ -7794,6 +7858,59 @@ initialize_aarch64_code_model (struct gcc_options *opts)\n      aarch64_cmodel = opts->x_aarch64_cmodel_var;\n }\n \n+/* Print to F the architecture features specified by ISA_FLAGS.  */\n+\n+static void\n+aarch64_print_extension (FILE *f, unsigned long isa_flags)\n+{\n+  const struct aarch64_option_extension *opt = NULL;\n+\n+  for (opt = all_extensions; opt->name != NULL; opt++)\n+    if ((isa_flags & opt->flags_on) == opt->flags_on)\n+      asm_fprintf (f, \"+%s\", opt->name);\n+\n+  asm_fprintf (f, \"\\n\");\n+}\n+\n+/* Implement TARGET_OPTION_SAVE.  */\n+\n+static void\n+aarch64_option_save (struct cl_target_option *ptr, struct gcc_options *opts)\n+{\n+  ptr->x_aarch64_override_tune_string = opts->x_aarch64_override_tune_string;\n+}\n+\n+/* Implements TARGET_OPTION_RESTORE.  Restore the backend codegen decisions\n+   using the information saved in PTR.  */\n+\n+static void\n+aarch64_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)\n+{\n+  opts->x_explicit_tune_core = ptr->x_explicit_tune_core;\n+  selected_tune = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);\n+  opts->x_explicit_arch = ptr->x_explicit_arch;\n+  selected_arch = aarch64_get_arch (ptr->x_explicit_arch);\n+  opts->x_aarch64_override_tune_string = ptr->x_aarch64_override_tune_string;\n+\n+  aarch64_override_options_internal (opts);\n+}\n+\n+/* Implement TARGET_OPTION_PRINT.  */\n+\n+static void\n+aarch64_option_print (FILE *file, int indent, struct cl_target_option *ptr)\n+{\n+  const struct processor *cpu\n+    = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);\n+  unsigned long isa_flags = ptr->x_aarch64_isa_flags;\n+  const struct processor *arch = aarch64_get_arch (ptr->x_explicit_arch);\n+\n+  fprintf (file, \"%*sselected tune = %s\\n\", indent, \"\", cpu->name);\n+  fprintf (file, \"%*sselected arch = %s\", indent, \"\", arch->name);\n+  aarch64_print_extension (file, isa_flags);\n+}\n+\n+\n /* Return true if SYMBOL_REF X binds locally.  */\n \n static bool\n@@ -9805,6 +9922,42 @@ aarch64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)\n    return (global ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | type;\n }\n \n+/* Implement ASM_DECLARE_FUNCTION_NAME.  Output the ISA features used\n+   by the function fndecl.  */\n+\n+void\n+aarch64_declare_function_name (FILE *stream, const char* name,\n+\t\t\t\ttree fndecl)\n+{\n+  tree target_parts = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);\n+\n+  struct cl_target_option *targ_options;\n+  if (target_parts)\n+    targ_options = TREE_TARGET_OPTION (target_parts);\n+  else\n+    targ_options = TREE_TARGET_OPTION (target_option_current_node);\n+  gcc_assert (targ_options);\n+\n+  const struct processor *this_arch\n+    = aarch64_get_arch (targ_options->x_explicit_arch);\n+\n+  asm_fprintf (asm_out_file, \"\\t.arch %s\", this_arch->name);\n+  aarch64_print_extension (asm_out_file, targ_options->x_aarch64_isa_flags);\n+\n+  /* Print the cpu name we're tuning for in the comments, might be\n+     useful to readers of the generated asm.  */\n+\n+  const struct processor *this_tune\n+    = aarch64_get_tune_cpu (targ_options->x_explicit_tune_core);\n+\n+  asm_fprintf (asm_out_file, \"\\t\" ASM_COMMENT_START \".tune %s\\n\",\n+\t       this_tune->name);\n+\n+  /* Don't forget the type directive for ELF.  */\n+  ASM_OUTPUT_TYPE_DIRECTIVE (stream, name, \"function\");\n+  ASM_OUTPUT_LABEL (stream, name);\n+}\n+\n /* Emit load exclusive.  */\n \n static void\n@@ -10085,36 +10238,6 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n     aarch64_emit_post_barrier (model);\n }\n \n-static void\n-aarch64_print_extension (void)\n-{\n-  const struct aarch64_option_extension *opt = NULL;\n-\n-  for (opt = all_extensions; opt->name != NULL; opt++)\n-    if ((aarch64_isa_flags & opt->flags_on) == opt->flags_on)\n-      asm_fprintf (asm_out_file, \"+%s\", opt->name);\n-\n-  asm_fprintf (asm_out_file, \"\\n\");\n-}\n-\n-static void\n-aarch64_start_file (void)\n-{\n-  if (selected_arch)\n-    {\n-      asm_fprintf (asm_out_file, \"\\t.arch %s\", selected_arch->name);\n-      aarch64_print_extension ();\n-    }\n-  else if (selected_cpu)\n-    {\n-      const char *truncated_name\n-\t    = aarch64_rewrite_selected_cpu (selected_cpu->name);\n-      asm_fprintf (asm_out_file, \"\\t.cpu %s\", truncated_name);\n-      aarch64_print_extension ();\n-    }\n-  default_file_start();\n-}\n-\n static void\n aarch64_init_libfuncs (void)\n {\n@@ -12174,9 +12297,6 @@ aarch64_promoted_type (const_tree t)\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK \\\n   hook_bool_const_tree_hwi_hwi_const_tree_true\n \n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START aarch64_start_file\n-\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK aarch64_output_mi_thunk\n \n@@ -12296,6 +12416,15 @@ aarch64_promoted_type (const_tree t)\n #define TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE \\\n   aarch64_override_options_after_change\n \n+#undef TARGET_OPTION_SAVE\n+#define TARGET_OPTION_SAVE aarch64_option_save\n+\n+#undef TARGET_OPTION_RESTORE\n+#define TARGET_OPTION_RESTORE aarch64_option_restore\n+\n+#undef TARGET_OPTION_PRINT\n+#define TARGET_OPTION_PRINT aarch64_option_print\n+\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE aarch64_pass_by_reference\n "}, {"sha": "9333bdc1d5088456bd761d123f910d1bb38171b7", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "patch": "@@ -223,7 +223,7 @@ extern unsigned aarch64_architecture_version;\n    | AARCH64_FL_LOR | AARCH64_FL_RDMA)\n \n /* Macros to test ISA flags.  */\n-extern unsigned long aarch64_isa_flags;\n+\n #define AARCH64_ISA_CRC            (aarch64_isa_flags & AARCH64_FL_CRC)\n #define AARCH64_ISA_CRYPTO         (aarch64_isa_flags & AARCH64_FL_CRYPTO)\n #define AARCH64_ISA_FP             (aarch64_isa_flags & AARCH64_FL_FP)\n@@ -438,6 +438,10 @@ extern unsigned long aarch64_isa_flags;\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \\\n   aarch64_asm_preferred_eh_data_format ((CODE), (GLOBAL))\n \n+/* Output the assembly strings we want to add to a function definition.  */\n+#define ASM_DECLARE_FUNCTION_NAME(STR, NAME, DECL)\t\\\n+  aarch64_declare_function_name (STR, NAME, DECL)\n+\n /* The register that holds the return address in exception handlers.  */\n #define AARCH64_EH_STACKADJ_REGNUM\t(R0_REGNUM + 4)\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, AARCH64_EH_STACKADJ_REGNUM)"}, {"sha": "37c2c509fe2d38cd489e290c053cd32ad84270db", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361fb3ee79f07fcff6c34acd1ccde520f4935c7e/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=361fb3ee79f07fcff6c34acd1ccde520f4935c7e", "patch": "@@ -21,6 +21,18 @@\n HeaderInclude\n config/aarch64/aarch64-opts.h\n \n+TargetVariable\n+enum aarch64_processor explicit_tune_core = aarch64_none\n+\n+TargetVariable\n+enum aarch64_arch explicit_arch = aarch64_no_arch\n+\n+TargetSave\n+const char *x_aarch64_override_tune_string\n+\n+TargetVariable\n+unsigned long aarch64_isa_flags = 0\n+\n ; The TLS dialect names to use with -mtls-dialect.\n \n Enum\n@@ -53,11 +65,11 @@ Target Report RejectNegative Mask(BIG_END)\n Assume target CPU is configured as big endian\n \n mgeneral-regs-only\n-Target Report RejectNegative Mask(GENERAL_REGS_ONLY)\n+Target Report RejectNegative Mask(GENERAL_REGS_ONLY) Save\n Generate code which uses only the general registers\n \n mfix-cortex-a53-835769\n-Target Report Var(aarch64_fix_a53_err835769) Init(2)\n+Target Report Var(aarch64_fix_a53_err835769) Init(2) Save\n Workaround for ARM Cortex-A53 Erratum number 835769\n \n mfix-cortex-a53-843419\n@@ -69,19 +81,19 @@ Target Report RejectNegative InverseMask(BIG_END)\n Assume target CPU is configured as little endian\n \n mcmodel=\n-Target RejectNegative Joined Enum(cmodel) Var(aarch64_cmodel_var) Init(AARCH64_CMODEL_SMALL)\n+Target RejectNegative Joined Enum(cmodel) Var(aarch64_cmodel_var) Init(AARCH64_CMODEL_SMALL) Save\n Specify the code model\n \n mstrict-align\n-Target Report RejectNegative Mask(STRICT_ALIGN)\n+Target Report RejectNegative Mask(STRICT_ALIGN) Save\n Don't assume that unaligned accesses are handled by the system\n \n momit-leaf-frame-pointer\n-Target Report Save Var(flag_omit_leaf_frame_pointer) Init(2)\n+Target Report Var(flag_omit_leaf_frame_pointer) Init(2) Save\n Omit the frame pointer in leaf functions\n \n mtls-dialect=\n-Target RejectNegative Joined Enum(tls_type) Var(aarch64_tls_dialect) Init(TLS_DESCRIPTORS)\n+Target RejectNegative Joined Enum(tls_type) Var(aarch64_tls_dialect) Init(TLS_DESCRIPTORS) Save\n Specify TLS dialect\n \n march="}]}