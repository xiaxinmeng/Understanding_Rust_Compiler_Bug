{"sha": "ac932bfcd21e9523fa2b880ae8138aef79da7f54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5MzJiZmNkMjFlOTUyM2ZhMmI4ODBhZTgxMzhhZWY3OWRhN2Y1NA==", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2020-06-20T14:11:48Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2020-06-20T14:11:48Z"}, "message": "PR fortran/95687 - ICE in get_unique_hashed_string, at fortran/class.c:508\n\nWith submodules and PDTs, name mangling of interfaces may result in long\ninternal symbols overflowing a previously static internal buffer.  We now\nset the buffer size dynamically.\n\ngcc/fortran/\n\tPR fortran/95687\n\t* class.c (get_unique_type_string): Return a string with dynamic\n\tlength.\n\t(get_unique_hashed_string, gfc_hash_value): Use dynamic result\n\tfrom get_unique_type_string instead of static buffer.", "tree": {"sha": "86f87ceec028505517b4ae6b621a4e89aba71fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86f87ceec028505517b4ae6b621a4e89aba71fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac932bfcd21e9523fa2b880ae8138aef79da7f54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac932bfcd21e9523fa2b880ae8138aef79da7f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac932bfcd21e9523fa2b880ae8138aef79da7f54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac932bfcd21e9523fa2b880ae8138aef79da7f54/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c0c0ea7bfb6f8f6b8d767b05120cafb6823da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c0c0ea7bfb6f8f6b8d767b05120cafb6823da6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c0c0ea7bfb6f8f6b8d767b05120cafb6823da6"}], "stats": {"total": 62, "additions": 48, "deletions": 14}, "files": [{"sha": "2b760efe8d7f5ed88cb11b94a3304fcbb4a106e4", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac932bfcd21e9523fa2b880ae8138aef79da7f54/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac932bfcd21e9523fa2b880ae8138aef79da7f54/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=ac932bfcd21e9523fa2b880ae8138aef79da7f54", "patch": "@@ -476,22 +476,38 @@ gfc_class_initializer (gfc_typespec *ts, gfc_expr *init_expr)\n    and module name. This is used to construct unique names for the class\n    containers and vtab symbols.  */\n \n-static void\n-get_unique_type_string (char *string, gfc_symbol *derived)\n+static char *\n+get_unique_type_string (gfc_symbol *derived)\n {\n   const char *dt_name;\n+  char *string;\n+  size_t len;\n   if (derived->attr.unlimited_polymorphic)\n     dt_name = \"STAR\";\n   else\n     dt_name = gfc_dt_upper_string (derived->name);\n+  len = strlen (dt_name) + 2;\n   if (derived->attr.unlimited_polymorphic)\n-    sprintf (string, \"_%s\", dt_name);\n+    {\n+      string = XNEWVEC (char, len);\n+      sprintf (string, \"_%s\", dt_name);\n+    }\n   else if (derived->module)\n-    sprintf (string, \"%s_%s\", derived->module, dt_name);\n+    {\n+      string = XNEWVEC (char, strlen (derived->module) + len);\n+      sprintf (string, \"%s_%s\", derived->module, dt_name);\n+    }\n   else if (derived->ns->proc_name)\n-    sprintf (string, \"%s_%s\", derived->ns->proc_name->name, dt_name);\n+    {\n+      string = XNEWVEC (char, strlen (derived->ns->proc_name->name) + len);\n+      sprintf (string, \"%s_%s\", derived->ns->proc_name->name, dt_name);\n+    }\n   else\n-    sprintf (string, \"_%s\", dt_name);\n+    {\n+      string = XNEWVEC (char, len);\n+      sprintf (string, \"_%s\", dt_name);\n+    }\n+  return string;\n }\n \n \n@@ -502,10 +518,8 @@ static void\n get_unique_hashed_string (char *string, gfc_symbol *derived)\n {\n   /* Provide sufficient space to hold \"symbol.symbol_symbol\".  */\n-  char tmp[3*GFC_MAX_SYMBOL_LEN+3];\n-  get_unique_type_string (&tmp[0], derived);\n-  size_t len = strnlen (tmp, sizeof (tmp));\n-  gcc_assert (len < sizeof (tmp));\n+  char *tmp;\n+  tmp = get_unique_type_string (derived);\n   /* If string is too long, use hash value in hex representation (allow for\n      extra decoration, cf. gfc_build_class_symbol & gfc_find_derived_vtab).\n      We need space to for 15 characters \"__class_\" + symbol name + \"_%d_%da\",\n@@ -517,6 +531,7 @@ get_unique_hashed_string (char *string, gfc_symbol *derived)\n     }\n   else\n     strcpy (string, tmp);\n+  free (tmp);\n }\n \n \n@@ -527,16 +542,16 @@ gfc_hash_value (gfc_symbol *sym)\n {\n   unsigned int hash = 0;\n   /* Provide sufficient space to hold \"symbol.symbol_symbol\".  */\n-  char c[3*GFC_MAX_SYMBOL_LEN+3];\n+  char *c;\n   int i, len;\n \n-  get_unique_type_string (&c[0], sym);\n-  len = strnlen (c, sizeof (c));\n-  gcc_assert ((size_t) len < sizeof (c));\n+  c = get_unique_type_string (sym);\n+  len = strlen (c);\n \n   for (i = 0; i < len; i++)\n     hash = (hash << 6) + (hash << 16) - hash + c[i];\n \n+  free (c);\n   /* Return the hash but take the modulus for the sake of module read,\n      even though this slightly increases the chance of collision.  */\n   return (hash % 100000000);"}, {"sha": "a674533179ab60483699973003d96b0ee781a45d", "filename": "gcc/testsuite/gfortran.dg/pr95687.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac932bfcd21e9523fa2b880ae8138aef79da7f54/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr95687.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac932bfcd21e9523fa2b880ae8138aef79da7f54/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr95687.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr95687.f90?ref=ac932bfcd21e9523fa2b880ae8138aef79da7f54", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! { dg-options \"-fsecond-underscore\" }\n+! PR fortran/95687 - ICE in get_unique_hashed_string, at fortran/class.c:508\n+\n+module m2345678901234567890123456789012345678901234567890123456789_123\n+  interface\n+     module subroutine s2345678901234567890123456789012345678901234567890123456789_123\n+     end\n+  end interface\n+end\n+submodule(m2345678901234567890123456789012345678901234567890123456789_123) &\n+          n2345678901234567890123456789012345678901234567890123456789_123\n+  type t2345678901234567890123456789012345678901234567890123456789_123 &\n+      (a2345678901234567890123456789012345678901234567890123456789_123)\n+     integer, kind :: a2345678901234567890123456789012345678901234567890123456789_123 = 4\n+  end type\n+  class(t2345678901234567890123456789012345678901234567890123456789_123(3)), pointer :: &\n+        x2345678901234567890123456789012345678901234567890123456789_123\n+end"}]}