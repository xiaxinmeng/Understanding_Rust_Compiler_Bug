{"sha": "2851dd684b26170d5ac940428e775edb8b093a69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1MWRkNjg0YjI2MTcwZDVhYzk0MDQyOGU3NzVlZGI4YjA5M2E2OQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-06-28T10:16:00Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-06-28T10:16:00Z"}, "message": "fold-const.c (fold_cond_expr_with_comparison): Add ARG1 parameter.\n\n2004-06-28  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* fold-const.c (fold_cond_expr_with_comparison): Add ARG1\n\tparameter.  Use it instead of ARG00 to produce the result.\n\nFrom-SVN: r83768", "tree": {"sha": "8cf23b8377dd108ac84cfba77efc5e110b9cdab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cf23b8377dd108ac84cfba77efc5e110b9cdab3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2851dd684b26170d5ac940428e775edb8b093a69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2851dd684b26170d5ac940428e775edb8b093a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2851dd684b26170d5ac940428e775edb8b093a69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2851dd684b26170d5ac940428e775edb8b093a69/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "61c53cd36b8de4831ab57aa9607702bf9022362f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61c53cd36b8de4831ab57aa9607702bf9022362f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61c53cd36b8de4831ab57aa9607702bf9022362f"}], "stats": {"total": 68, "additions": 40, "deletions": 28}, "files": [{"sha": "985a65aad0079bb530a16af0421c00fd6ed37006", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2851dd684b26170d5ac940428e775edb8b093a69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2851dd684b26170d5ac940428e775edb8b093a69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2851dd684b26170d5ac940428e775edb8b093a69", "patch": "@@ -1,3 +1,8 @@\n+2004-06-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* fold-const.c (fold_cond_expr_with_comparison): Add ARG1\n+\tparameter.  Use it instead of ARG00 to produce the result.\n+\n 2004-06-28  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mn10300/mn10300-protos.h (legitimate_address_p): Declare."}, {"sha": "4bb42a4ce9e0359d85434d3eaee4a2a3afbfcc37", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2851dd684b26170d5ac940428e775edb8b093a69/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2851dd684b26170d5ac940428e775edb8b093a69/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2851dd684b26170d5ac940428e775edb8b093a69", "patch": "@@ -116,7 +116,7 @@ static tree build_range_check (tree, tree, int, tree, tree);\n static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n \t\t\t tree);\n static tree fold_range_test (tree);\n-static tree fold_cond_expr_with_comparison (tree, tree, tree);\n+static tree fold_cond_expr_with_comparison (tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n static tree fold_truthop (enum tree_code, tree, tree, tree);\n static tree optimize_minmax_comparison (tree);\n@@ -4115,20 +4115,23 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \f\n \n /* Subroutine of fold, looking inside expressions of the form\n-   A op B ? A : C, where ARG0 is A op B and ARG2 is C.  This\n-   function is being used also to optimize A op B ? C : A, by\n-   reversing the comparison first.\n+   A op B ? A : C, where ARG0, ARG1 and ARG2 are the three operands\n+   of the COND_EXPR.  This function is being used also to optimize\n+   A op B ? C : A, by reversing the comparison first.\n \n    Return a folded expression whose code is not a COND_EXPR\n    anymore, or NULL_TREE if no folding opportunity is found.  */\n \n static tree\n-fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n+fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n {\n   enum tree_code comp_code = TREE_CODE (arg0);\n   tree arg00 = TREE_OPERAND (arg0, 0);\n   tree arg01 = TREE_OPERAND (arg0, 1);\n+  tree arg1_type = TREE_TYPE (arg1);\n   tree tem;\n+\n+  STRIP_NOPS (arg1);\n   STRIP_NOPS (arg2);\n \n   /* If we have A op 0 ? A : -A, consider applying the following\n@@ -4154,26 +4157,27 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n        ? real_zerop (arg01)\n        : integer_zerop (arg01))\n       && TREE_CODE (arg2) == NEGATE_EXPR\n-      && operand_equal_p (TREE_OPERAND (arg2, 0), arg00, 0))\n+      && operand_equal_p (TREE_OPERAND (arg2, 0), arg1, 0))\n     switch (comp_code)\n       {\n       case EQ_EXPR:\n-\treturn fold_convert (type, negate_expr (arg00));\n+\ttem = fold_convert (arg1_type, arg1);\n+\treturn pedantic_non_lvalue (fold_convert (type, negate_expr (tem)));\n       case NE_EXPR:\n-\treturn pedantic_non_lvalue (fold_convert (type, arg00));\n+\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n       case GE_EXPR:\n       case GT_EXPR:\n-\tif (TYPE_UNSIGNED (TREE_TYPE (arg00)))\n-\t  arg00 = fold_convert (lang_hooks.types.signed_type\n-\t\t\t        (TREE_TYPE (arg00)), arg00);\n-\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg00), arg00));\n+\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n+\t  arg1 = fold_convert (lang_hooks.types.signed_type\n+\t\t\t       (TREE_TYPE (arg1)), arg1);\n+\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \treturn pedantic_non_lvalue (fold_convert (type, tem));\n       case LE_EXPR:\n       case LT_EXPR:\n-\tif (TYPE_UNSIGNED (TREE_TYPE (arg00)))\n-\t  arg00 = fold_convert (lang_hooks.types.signed_type\n-\t\t\t        (TREE_TYPE (arg00)), arg00);\n-\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg00), arg00));\n+\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n+\t  arg1 = fold_convert (lang_hooks.types.signed_type\n+\t\t\t       (TREE_TYPE (arg1)), arg1);\n+\ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \treturn negate_expr (fold_convert (type, tem));\n       default:\n \tabort ();\n@@ -4187,7 +4191,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n   if (integer_zerop (arg01) && integer_zerop (arg2))\n     {\n       if (comp_code == NE_EXPR)\n-\treturn pedantic_non_lvalue (fold_convert (type, arg00));\n+\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n       else if (comp_code == EQ_EXPR)\n \treturn pedantic_non_lvalue (fold_convert (type, integer_zero_node));\n     }\n@@ -4228,7 +4232,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n       if (TYPE_MAIN_VARIANT (comp_type) == TYPE_MAIN_VARIANT (type))\n \t{\n \t  comp_type = type;\n-\t  comp_op0 = arg00;\n+\t  comp_op0 = arg1;\n \t  comp_op1 = arg2;\n \t}\n \n@@ -4237,14 +4241,14 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n \tcase EQ_EXPR:\n \t  return pedantic_non_lvalue (fold_convert (type, arg2));\n \tcase NE_EXPR:\n-\t  return pedantic_non_lvalue (fold_convert (type, arg00));\n+\t  return pedantic_non_lvalue (fold_convert (type, arg1));\n \tcase LE_EXPR:\n \tcase LT_EXPR:\n \t  /* In C++ a ?: expression can be an lvalue, so put the\n \t     operand which will be used if they are equal first\n \t     so that we can convert this back to the\n \t     corresponding COND_EXPR.  */\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00))))\n+\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t    return pedantic_non_lvalue (\n \t\t     fold_convert (type, fold (build2 (MIN_EXPR, comp_type,\n \t\t\t\t         (comp_code == LE_EXPR\n@@ -4254,7 +4258,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n \t  break;\n \tcase GE_EXPR:\n \tcase GT_EXPR:\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00))))\n+\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t    return pedantic_non_lvalue (\n \t\t     fold_convert (type, fold (build2 (MAX_EXPR, comp_type,\n \t\t\t\t         (comp_code == GE_EXPR\n@@ -4280,8 +4284,8 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n       {\n       case EQ_EXPR:\n \t/* We can replace A with C1 in this case.  */\n-\targ00 = fold_convert (type, arg01);\n-\treturn fold (build3 (COND_EXPR, type, arg0, arg00, arg2));\n+\targ1 = fold_convert (type, arg01);\n+\treturn fold (build3 (COND_EXPR, type, arg0, arg1, arg2));\n \n       case LT_EXPR:\n \t/* If C1 is C2 + 1, this is min(A, C2).  */\n@@ -4292,7 +4296,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold (build2 (MIN_EXPR,\n-\t\t\t\t\t\t    type, arg00, arg2)));\n+\t\t\t\t\t\t    type, arg1, arg2)));\n \tbreak;\n \n       case LE_EXPR:\n@@ -4304,7 +4308,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold (build2 (MIN_EXPR,\n-\t\t\t\t\t\t    type, arg00, arg2)));\n+\t\t\t\t\t\t    type, arg1, arg2)));\n \tbreak;\n \n       case GT_EXPR:\n@@ -4316,7 +4320,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold (build2 (MAX_EXPR,\n-\t\t\t\t\t\t    type, arg00, arg2)));\n+\t\t\t\t\t\t    type, arg1, arg2)));\n \tbreak;\n \n       case GE_EXPR:\n@@ -4328,7 +4332,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg2)\n \t\t\t\t\t     integer_one_node, 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold (build2 (MAX_EXPR,\n-\t\t\t\t\t\t    type, arg00, arg2)));\n+\t\t\t\t\t\t    type, arg1, arg2)));\n \tbreak;\n       case NE_EXPR:\n \tbreak;\n@@ -8666,6 +8670,7 @@ fold (tree expr)\n \t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n \t{\n \t  tem = fold_cond_expr_with_comparison (type, arg0,\n+\t\t\t\t\t\tTREE_OPERAND (t, 1),\n \t\t\t\t\t\tTREE_OPERAND (t, 2));\n \t  if (tem)\n \t    return tem;\n@@ -8680,7 +8685,9 @@ fold (tree expr)\n \t  tem = invert_truthvalue (arg0);\n \t  if (TREE_CODE_CLASS (TREE_CODE (tem)) == '<')\n \t    {\n-\t      tem = fold_cond_expr_with_comparison (type, tem, arg1);\n+\t      tem = fold_cond_expr_with_comparison (type, tem,\n+\t\t\t\t\t\t    TREE_OPERAND (t, 2),\n+\t\t\t\t\t\t    TREE_OPERAND (t, 1));\n \t      if (tem)\n \t\treturn tem;\n \t    }"}]}