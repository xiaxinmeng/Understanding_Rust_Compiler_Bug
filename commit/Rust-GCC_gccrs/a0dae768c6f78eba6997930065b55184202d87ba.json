{"sha": "a0dae768c6f78eba6997930065b55184202d87ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkYWU3NjhjNmY3OGViYTY5OTc5MzAwNjViNTUxODQyMDJkODdiYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-29T09:23:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-04T13:57:45Z"}, "message": "Add explicit SLP_TREE_LANES\n\nThis adds an explicit number of scalar lanes to the SLP node\navoiding to dispatch between stmts/ops and eventually not require\nthose vectors at all.\n\n2020-05-27  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::lanes): New.\n\t(SLP_TREE_LANES): Likewise.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Use it.\n\t(vectorizable_reduction): Likewise.\n\t(vect_transform_cycle_phi): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t* tree-vect-slp.c (_slp_tree::_slp_tree): Initialize lanes.\n\t(vect_create_new_slp_node): Likewise.\n\t(slp_copy_subtree): Copy it.\n\t(vect_optimize_slp): Use it.\n\t(vect_slp_analyze_node_operations_1): Likewise.\n\t(vect_slp_convert_to_external): Likewise.\n\t(vect_bb_vectorization_profitable_p): Likewise.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\t(get_vectype_for_scalar_type): Likewise.", "tree": {"sha": "745fe20263889703d48e9d8673d29eb6687d6a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/745fe20263889703d48e9d8673d29eb6687d6a07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0dae768c6f78eba6997930065b55184202d87ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0dae768c6f78eba6997930065b55184202d87ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0dae768c6f78eba6997930065b55184202d87ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0dae768c6f78eba6997930065b55184202d87ba/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1008cd1d8504775e6a5e39325e396e61b39b84c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1008cd1d8504775e6a5e39325e396e61b39b84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1008cd1d8504775e6a5e39325e396e61b39b84c"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "e3fbf9fe28ac29d9ded1e7407b4f7c24c2254e67", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a0dae768c6f78eba6997930065b55184202d87ba", "patch": "@@ -4516,7 +4516,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   tree induction_index = NULL_TREE;\n \n   if (slp_node)\n-    group_size = SLP_TREE_SCALAR_STMTS (slp_node).length (); \n+    group_size = SLP_TREE_LANES (slp_node);\n \n   if (nested_in_vect_loop_p (loop, stmt_info))\n     {\n@@ -6594,7 +6594,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n \t which each SLP statement has its own initial value and in which\n \t that value needs to be repeated for every instance of the\n \t statement within the initial vector.  */\n-      unsigned int group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      unsigned int group_size = SLP_TREE_LANES (slp_node);\n       if (!neutral_op\n \t  && !can_duplicate_and_interleave_p (loop_vinfo, group_size,\n \t\t\t\t\t      TREE_TYPE (vectype_out)))\n@@ -7110,9 +7110,8 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n   if (slp_node)\n     {\n       /* The size vect_schedule_slp_instance computes is off for us.  */\n-      vec_num = vect_get_num_vectors\n-\t  (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t   * SLP_TREE_SCALAR_STMTS (slp_node).length (), vectype_in);\n+      vec_num = vect_get_num_vectors (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t\t\t\t      * SLP_TREE_LANES (slp_node), vectype_in);\n       ncopies = 1;\n     }\n   else\n@@ -7558,7 +7557,7 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t\t\t\t   new_vec, step_vectype, NULL);\n \n       /* Now generate the IVs.  */\n-      unsigned group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      unsigned group_size = SLP_TREE_LANES (slp_node);\n       unsigned nvects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       unsigned elts = const_nunits * nvects;\n       /* Compute the number of distinct IVs we need.  First reduce\n@@ -7999,7 +7998,7 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n     {\n       gcc_assert (slp_index >= 0);\n \n-      int num_scalar = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      int num_scalar = SLP_TREE_LANES (slp_node);\n       int num_vec = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n \n       /* Get the last occurrence of the scalar index from the concatenation of"}, {"sha": "65c49f5e1439bcc5387f2dc166067b4210fb9970", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a0dae768c6f78eba6997930065b55184202d87ba", "patch": "@@ -64,6 +64,7 @@ _slp_tree::_slp_tree ()\n   SLP_TREE_REPRESENTATIVE (this) = NULL;\n   this->refcnt = 1;\n   this->max_nunits = 1;\n+  this->lanes = 0;\n }\n \n /* Tear down a SLP node.  */\n@@ -134,6 +135,7 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n   SLP_TREE_REPRESENTATIVE (node) = scalar_stmts[0];\n+  SLP_TREE_LANES (node) = scalar_stmts.length ();\n \n   unsigned i;\n   stmt_vec_info stmt_info;\n@@ -151,6 +153,7 @@ vect_create_new_slp_node (vec<tree> ops)\n   slp_tree node = new _slp_tree;\n   SLP_TREE_SCALAR_OPS (node) = ops;\n   SLP_TREE_DEF_TYPE (node) = vect_external_def;\n+  SLP_TREE_LANES (node) = ops.length ();\n   return node;\n }\n \n@@ -1670,6 +1673,7 @@ slp_copy_subtree (slp_tree node, hash_map<slp_tree, slp_tree> &map)\n   SLP_TREE_DEF_TYPE (copy) = SLP_TREE_DEF_TYPE (node);\n   SLP_TREE_VECTYPE (copy) = SLP_TREE_VECTYPE (node);\n   SLP_TREE_REPRESENTATIVE (copy) = SLP_TREE_REPRESENTATIVE (node);\n+  SLP_TREE_LANES (copy) = SLP_TREE_LANES (node);\n   copy->max_nunits = node->max_nunits;\n   copy->refcnt = 0;\n   if (SLP_TREE_SCALAR_STMTS (node).exists ())\n@@ -2377,8 +2381,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t a gap either because the group is larger than the SLP\n \t\t group-size or because there is a gap between the groups.  */\n \t      && (known_eq (LOOP_VINFO_VECT_FACTOR (as_a <loop_vec_info> (vinfo)), 1U)\n-\t\t  || ((SLP_TREE_SCALAR_STMTS (node).length ()\n-\t\t       == DR_GROUP_SIZE (first_stmt_info))\n+\t\t  || ((SLP_TREE_LANES (node) == DR_GROUP_SIZE (first_stmt_info))\n \t\t      && DR_GROUP_GAP (first_stmt_info) == 0)))\n \t    {\n \t      SLP_TREE_LOAD_PERMUTATION (node).release ();\n@@ -2612,7 +2615,7 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n \tvf = loop_vinfo->vectorization_factor;\n       else\n \tvf = 1;\n-      unsigned int group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+      unsigned int group_size = SLP_TREE_LANES (node);\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n \t= vect_get_num_vectors (vf * group_size, vectype);\n@@ -2645,7 +2648,7 @@ vect_slp_convert_to_external (vec_info *vinfo, slp_tree node,\n   /* Don't remove and free the child nodes here, since they could be\n      referenced by other structures.  The analysis and scheduling phases\n      (need to) ignore child nodes of anything that isn't vect_internal_def.  */\n-  unsigned int group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+  unsigned int group_size = SLP_TREE_LANES (node);\n   SLP_TREE_DEF_TYPE (node) = vect_external_def;\n   SLP_TREE_SCALAR_OPS (node).safe_grow (group_size);\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n@@ -2955,8 +2958,7 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       auto_vec<bool, 20> life;\n-      life.safe_grow_cleared\n-\t(SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance)).length ());\n+      life.safe_grow_cleared (SLP_TREE_LANES (SLP_INSTANCE_TREE (instance)));\n       vect_bb_slp_scalar_cost (bb_vinfo,\n \t\t\t       SLP_INSTANCE_TREE (instance),\n \t\t\t       &life, &scalar_costs, visited);"}, {"sha": "4df1d90d5f33db20961eb22a681b5434e903aab1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a0dae768c6f78eba6997930065b55184202d87ba", "patch": "@@ -9225,7 +9225,7 @@ vectorizable_load (vec_info *vinfo,\n \t     unpermuted sequence.  In other cases we need to load the\n \t     whole group, not only the number of vector stmts the\n \t     permutation result fits in.  */\n-\t  unsigned scalar_lanes = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+\t  unsigned scalar_lanes = SLP_TREE_LANES (slp_node);\n \t  if (slp_perm\n \t      && (group_size != scalar_lanes \n \t\t  || !multiple_p (nunits, group_size)))\n@@ -11603,11 +11603,7 @@ get_vectype_for_scalar_type (vec_info *vinfo, tree scalar_type, slp_tree node)\n {\n   unsigned int group_size = 0;\n   if (node)\n-    {\n-      group_size = SLP_TREE_SCALAR_OPS (node).length ();\n-      if (group_size == 0)\n-\tgroup_size = SLP_TREE_SCALAR_STMTS (node).length ();\n-    }\n+    group_size = SLP_TREE_LANES (node);\n   return get_vectype_for_scalar_type (vinfo, scalar_type, group_size);\n }\n "}, {"sha": "1396da74e9d82a13bbb099d46d9f519eae2f4c55", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0dae768c6f78eba6997930065b55184202d87ba/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a0dae768c6f78eba6997930065b55184202d87ba", "patch": "@@ -155,6 +155,8 @@ struct _slp_tree {\n   bool two_operators;\n   /* The DEF type of this node.  */\n   enum vect_def_type def_type;\n+  /* The number of scalar lanes produced by this node.  */\n+  unsigned int lanes;\n };\n \n \n@@ -197,6 +199,7 @@ typedef class _slp_instance {\n #define SLP_TREE_DEF_TYPE(S)\t\t\t (S)->def_type\n #define SLP_TREE_VECTYPE(S)\t\t\t (S)->vectype\n #define SLP_TREE_REPRESENTATIVE(S)\t\t (S)->representative\n+#define SLP_TREE_LANES(S)\t\t\t (S)->lanes\n \n /* Key for map that records association between\n    scalar conditions and corresponding loop mask, and"}]}