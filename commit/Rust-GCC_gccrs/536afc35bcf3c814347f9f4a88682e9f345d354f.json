{"sha": "536afc35bcf3c814347f9f4a88682e9f345d354f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM2YWZjMzViY2YzYzgxNDM0N2Y5ZjRhODg2ODJlOWYzNDVkMzU0Zg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-11-24T22:22:40Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-11-24T22:22:40Z"}, "message": "re PR fortran/20880 (USE association of procedure's own interface)\n\n2006-11-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20880\n\t* parse.c (parse_interface): Error if procedure name is that of\n\tencompassing scope.\n\t* resolve.c (resolve_fl_procedure): Error if procedure is\n\tambiguous.\n\n\tPR fortran/29387\n\t* interface.c (compare_actual_formal): Add missing condition\n\tthat 'where' be present for error that asserts that actual\n\targuments be definable.\n\n2006-11-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20880\n\t* gfortran.dg/interface_3.f90: New test.\n\n\tPR fortran/29387\n\t* gfortran.dg/generic_8.f90: New test.\n\nFrom-SVN: r119173", "tree": {"sha": "e7282ffa93de4569b618b2f353edc62bd74a97eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7282ffa93de4569b618b2f353edc62bd74a97eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/536afc35bcf3c814347f9f4a88682e9f345d354f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/536afc35bcf3c814347f9f4a88682e9f345d354f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/536afc35bcf3c814347f9f4a88682e9f345d354f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/536afc35bcf3c814347f9f4a88682e9f345d354f/comments", "author": null, "committer": null, "parents": [{"sha": "e7c1c8d1a18a2551c91254fc2b92f69c788c077b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c1c8d1a18a2551c91254fc2b92f69c788c077b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c1c8d1a18a2551c91254fc2b92f69c788c077b"}], "stats": {"total": 122, "additions": 119, "deletions": 3}, "files": [{"sha": "aa1b037187696eeef6fc994b5069a7428c617424", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -1,3 +1,16 @@\n+2006-11-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20880\n+\t* parse.c (parse_interface): Error if procedure name is that of\n+\tencompassing scope.\n+\t* resolve.c (resolve_fl_procedure): Error if procedure is\n+\tambiguous.\n+\n+\tPR fortran/29387\n+\t* interface.c (compare_actual_formal): Add missing condition\n+\tthat 'where' be present for error that asserts that actual\n+\targuments be definable.\n+\n 2006-11-24  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* resolve.c (resolve_actual_arglist): Remove the special case for"}, {"sha": "80a773e936ab158f22f05fc151c4a881486d2539", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -1379,8 +1379,9 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \t     && (f->sym->attr.intent == INTENT_OUT\n \t\t   || f->sym->attr.intent == INTENT_INOUT))\n \t{\n-\t  gfc_error (\"Actual argument at %L must be definable to \"\n-\t\t     \"match dummy INTENT = OUT/INOUT\", &a->expr->where);\n+\t  if (where)\n+\t    gfc_error (\"Actual argument at %L must be definable to \"\n+\t\t       \"match dummy INTENT = OUT/INOUT\", &a->expr->where);\n           return 0;\n         }\n "}, {"sha": "eebe44833735c380654e66df571faa0be7330246", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -1694,6 +1694,7 @@ parse_interface (void)\n   gfc_interface_info save;\n   gfc_state_data s1, s2;\n   gfc_statement st;\n+  locus proc_locus;\n \n   accept_statement (ST_INTERFACE);\n \n@@ -1781,6 +1782,7 @@ parse_interface (void)\n   accept_statement (st);\n   prog_unit = gfc_new_block;\n   prog_unit->formal_ns = gfc_current_ns;\n+  proc_locus = gfc_current_locus;\n \n decl:\n   /* Read data declaration statements.  */\n@@ -1796,8 +1798,15 @@ parse_interface (void)\n \n   current_interface = save;\n   gfc_add_interface (prog_unit);\n-\n   pop_state ();\n+\n+  if (current_interface.ns\n+\t&& current_interface.ns->proc_name\n+\t&& strcmp (current_interface.ns->proc_name->name,\n+\t\t   prog_unit->name) == 0)\n+    gfc_error (\"INTERFACE procedure '%s' at %L has the same name as the \"\n+\t       \"enclosing procedure\", prog_unit->name, &proc_locus);\n+\n   goto loop;\n \n done:"}, {"sha": "a4d220ae744ae2b68ac509ba738b92f0ce13118d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -5516,11 +5516,20 @@ static try\n resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n {\n   gfc_formal_arglist *arg;\n+  gfc_symtree *st;\n \n   if (sym->attr.function\n \t&& resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;\n \n+  st = gfc_find_symtree (gfc_current_ns->sym_root, sym->name);\n+  if (st && st->ambiguous && !sym->attr.generic)\n+    {\n+      gfc_error (\"Procedure %s at %L is ambiguous\",\n+\t\t sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       gfc_charlen *cl = sym->ts.cl;"}, {"sha": "367d0fe0477dbe19d67560a411eda031231a65d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -1,3 +1,11 @@\n+2006-11-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20880\n+\t* gfortran.dg/interface_3.f90: New test.\n+\n+\tPR fortran/29387\n+\t* gfortran.dg/generic_8.f90: New test.\n+\n 2006-11-24  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* gfortran.dg/specifics_1.f90: Remove check for CHAR."}, {"sha": "bf2ff78101fff37280e32bbc6d360ae68ee587da", "filename": "gcc/testsuite/gfortran.dg/generic_8.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_8.f90?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! Tests the fix for PR29837, in which the following valid code\n+! would emit an error because of mistaken INTENT; the wrong\n+! specific interface would be used for the comparison.\n+!\n+! Contributed by \n+!\n+MODULE M\n+  IMPLICIT NONE\n+  INTERFACE A\n+    MODULE PROCEDURE A1,A2\n+  END INTERFACE\n+CONTAINS\n+\n+  SUBROUTINE A2(X)\n+    INTEGER, INTENT(INOUT) :: X\n+  END SUBROUTINE A2\n+\n+  SUBROUTINE A1(X,Y)\n+    INTEGER, INTENT(IN) :: X\n+    INTEGER, INTENT(OUT) :: Y\n+    Y=X\n+  END SUBROUTINE A1\n+\n+  SUBROUTINE T(X)\n+    INTEGER, INTENT(IN) :: X(:)\n+    INTEGER Y\n+    CALL A(MAXVAL(X),Y)\n+  END SUBROUTINE T\n+END MODULE M\n+! { dg-final { cleanup-modules \"M\" } }"}, {"sha": "38324152d202e1cce2fd98fcbbf8e526a85ebf27", "filename": "gcc/testsuite/gfortran.dg/interface_3.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/536afc35bcf3c814347f9f4a88682e9f345d354f/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_3.f90?ref=536afc35bcf3c814347f9f4a88682e9f345d354f", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+! Tests the fix for PR20880, which was due to failure to the failure\n+! to detect the USE association of a nameless interface for a\n+! procedure with the same name as the encompassing scope.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+module test_mod\n+interface\n+  subroutine my_sub (a)\n+    real a\n+  end subroutine\n+end interface\n+interface\n+  function my_fun (a)\n+    real a, my_fun\n+  end function\n+end interface\n+end module\n+\n+! This is the original PR\n+subroutine my_sub (a) ! { dg-error \"is ambiguous\" }\n+  use test_mod\n+  real a\n+  print *, a\n+end subroutine\n+\n+integer function my_fun (a) ! { dg-error \"is ambiguous\" }\n+  use test_mod\n+  real a\n+  print *, a\n+  my_fun = 1  ! { dg-error \"ambiguous reference\" }\n+end function\n+\n+! This was found whilst investigating => segfault\n+subroutine thy_sub (a)\n+  interface \n+    subroutine thy_sub (a) ! { dg-error \"enclosing procedure\" }\n+      real a\n+    end subroutine\n+  end interface\n+  real a\n+  print *, a\n+end subroutine\n+! { dg-final { cleanup-modules \"test_mod\" } }"}]}