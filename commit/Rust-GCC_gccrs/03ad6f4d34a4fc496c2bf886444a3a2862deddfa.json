{"sha": "03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNhZDZmNGQzNGE0ZmM0OTZjMmJmODg2NDQ0YTNhMjg2MmRlZGRmYQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-10T23:47:28Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-10T23:47:28Z"}, "message": "sparc.c (input_operand): Do not accept a LO_SUM MEM for TFmode when !v9.\n\n\t* config/sparc/sparc.c (input_operand): Do not accept a LO_SUM MEM\n\tfor TFmode when !v9.  We require offsettable memory addresses.\n\t* config/sparc/sparc.h (ALTER_HARD_SUBREG): Handle TFmode to\n\tDFmode register number conversions.\n\t* config/sparc/sparc.md (define_split DFmode moves): If register\n\tis a SUBREG do alter_subreg on it before using.\n\t(define_expand movtf): Fixup comment about alignment on v9.\n\t(define_split TFmode moves): Don't use gen_{high,low}part, create\n\texplicit SUBREGs instead.\n\nFrom-SVN: r21658", "tree": {"sha": "b6211a7b274880a94bf3bdeb3f061847710d0acb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6211a7b274880a94bf3bdeb3f061847710d0acb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/comments", "author": null, "committer": null, "parents": [{"sha": "b8d80a3a83398892f4914c8948a3becd59c8c394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d80a3a83398892f4914c8948a3becd59c8c394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d80a3a83398892f4914c8948a3becd59c8c394"}], "stats": {"total": 70, "additions": 52, "deletions": 18}, "files": [{"sha": "ee408a4e697bcc6821baad1ef8116c5a2a19e0a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "patch": "@@ -1,3 +1,15 @@\n+Mon Aug 10 22:39:09 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (input_operand): Do not accept a LO_SUM MEM\n+\tfor TFmode when !v9.  We require offsettable memory addresses.\n+\t* config/sparc/sparc.h (ALTER_HARD_SUBREG): Handle TFmode to\n+\tDFmode register number conversions.\n+\t* config/sparc/sparc.md (define_split DFmode moves): If register\n+\tis a SUBREG do alter_subreg on it before using.\n+\t(define_expand movtf): Fixup comment about alignment on v9.\n+\t(define_split TFmode moves): Don't use gen_{high,low}part, create\n+\texplicit SUBREGs instead.\n+\n Mon Aug 10 19:02:55 1998  John Carr  <jfc@mit.edu>\n \n \t* Makefile.in (mbchar.o): Depend on mbchar.c."}, {"sha": "94e86fa3aa795b021db9b5e3b56b53820275d6cf", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "patch": "@@ -1010,8 +1010,17 @@ input_operand (op, mode)\n       rtx inside = XEXP (op, 0);\n \n       if (GET_CODE (inside) == LO_SUM)\n-\treturn (register_operand (XEXP (inside, 0), Pmode)\n-\t\t&& CONSTANT_P (XEXP (inside, 1)));\n+\t{\n+\t  /* We can't allow these because all of the splits\n+\t     (eventually as they trickle down into DFmode\n+\t     splits) require offsettable memory references.  */\n+\t  if (! TARGET_V9\n+\t      && GET_MODE (op) == TFmode)\n+\t    return 0;\n+\n+\t  return (register_operand (XEXP (inside, 0), Pmode)\n+\t\t  && CONSTANT_P (XEXP (inside, 1)));\n+\t}\n       return memory_address_p (mode, inside);\n     }\n "}, {"sha": "110e987eadd4c8facf0149850d0f94673b0e9c10", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "patch": "@@ -980,15 +980,18 @@ while (0)\n \n /* A subreg in 64 bit mode will have the wrong offset for a floating point\n    register.  The least significant part is at offset 1, compared to 0 for\n-   integer registers.  This only applies when FMODE is a larger mode.  */\n+   integer registers.  This only applies when FMODE is a larger mode.\n+   We also need to handle a special case of TF-->DF conversions.  */\n #define ALTER_HARD_SUBREG(TMODE, WORD, FMODE, REGNO)\t\t\t\\\n      (TARGET_ARCH64\t\t\t\t\t\t\t\\\n       && (REGNO) >= SPARC_FIRST_FP_REG\t\t\t\t\t\\\n       && (REGNO) <= SPARC_LAST_V9_FP_REG\t\t\t\t\\\n       && (TMODE) == SImode\t\t\t\t\t\t\\\n       && !((FMODE) == QImode || (FMODE) == HImode)\t\t\t\\\n       ? ((REGNO) + 1)\t\t\t\t\t\t\t\\\n-      : ((REGNO) + (WORD)))\n+      : ((TMODE) == DFmode && (FMODE) == TFmode)\t\t\t\\\n+        ? ((REGNO) + ((WORD) * 2))\t\t\t\t\t\\\n+        : ((REGNO) + (WORD)))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    See sparc.c for how we initialize this.  */"}, {"sha": "e054d25db662ed32688c135b88fe5be32e0b0f4b", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ad6f4d34a4fc496c2bf886444a3a2862deddfa/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=03ad6f4d34a4fc496c2bf886444a3a2862deddfa", "patch": "@@ -2995,6 +2995,9 @@\n \n   self_reference = reg_mentioned_p (operands[0],\n                                     XEXP (XEXP (word1, 0), 0));\n+  if (GET_CODE (operands[0]) == SUBREG)\n+    operands[0] = alter_subreg (operands[0]);\n+\n   if (self_reference != 0\n       && WORDS_BIG_ENDIAN)\n     {\n@@ -3028,6 +3031,8 @@\n   rtx word1 = change_address (operands[0], SFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n \n+  if (GET_CODE (operands[1]) == SUBREG)\n+    operands[1] = alter_subreg (operands[1]);\n   emit_insn (gen_movsf (word0,\n \t\t\tgen_highpart (SFmode, operands[1])));\n   emit_insn (gen_movsf (word1,\n@@ -3054,8 +3059,8 @@\n                                                    operands[1]));\n     }\n \n-  /* Handle MEM cases first, note that even v9 only guarentees\n-     8-byte alignment for quads so... */\n+  /* Handle MEM cases first, note that only v9 guarentees\n+     full 16-byte alignment for quads. */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n       if (register_operand (operands[1], TFmode))\n@@ -3179,10 +3184,11 @@ movtf_is_ok:\n   if (GET_CODE (set_src) == SUBREG)\n     set_src = alter_subreg (set_src);\n \n-  dest1 = gen_highpart (DFmode, set_dest);\n-  dest2 = gen_lowpart (DFmode, set_dest);\n-  src1 = gen_highpart (DFmode, set_src);\n-  src2 = gen_lowpart (DFmode, set_src);\n+  /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n+  dest1 = gen_rtx_SUBREG (DFmode, set_dest, WORDS_BIG_ENDIAN == 0);\n+  dest2 = gen_rtx_SUBREG (DFmode, set_dest, WORDS_BIG_ENDIAN != 0);\n+  src1 = gen_rtx_SUBREG (DFmode, set_src, WORDS_BIG_ENDIAN == 0);\n+  src2 = gen_rtx_SUBREG (DFmode, set_src, WORDS_BIG_ENDIAN != 0);\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n@@ -3210,11 +3216,13 @@ movtf_is_ok:\n   rtx word0 = change_address (operands[1], DFmode, NULL_RTX);\n   rtx word1 = change_address (operands[1], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 8));\n+  rtx dest1, dest2;\n \n-  emit_insn (gen_movdf (gen_highpart (DFmode, operands[0]),\n-\t\t\tword0));\n-  emit_insn (gen_movdf (gen_lowpart (DFmode, operands[0]),\n-\t\t\tword1));\n+  /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n+  dest1 = gen_rtx_SUBREG (DFmode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  dest2 = gen_rtx_SUBREG (DFmode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  emit_insn (gen_movdf (dest1, word0));\n+  emit_insn (gen_movdf (dest2, word1));\n   DONE;\n }\")\n \n@@ -3229,11 +3237,13 @@ movtf_is_ok:\n   rtx word0 = change_address (operands[0], DFmode, NULL_RTX);\n   rtx word1 = change_address (operands[0], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 8));\n+  rtx src1, src2;\n \n-  emit_insn (gen_movdf (word0,\n-\t\t\tgen_highpart (DFmode, operands[1])));\n-  emit_insn (gen_movdf (word1,\n-\t\t\tgen_lowpart (DFmode, operands[1])));\n+  /* Ugly, but gen_highpart will crap out here for 32-bit targets.  */\n+  src1 = gen_rtx_SUBREG (DFmode, operands[1], WORDS_BIG_ENDIAN == 0);\n+  src2 = gen_rtx_SUBREG (DFmode, operands[1], WORDS_BIG_ENDIAN != 0);\n+  emit_insn (gen_movdf (word0, src1));\n+  emit_insn (gen_movdf (word1, src2));\n   DONE;\n }\")\n \f"}]}