{"sha": "c410d49e434d06e93c9163eda0a26891e6116a7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQxMGQ0OWU0MzRkMDZlOTNjOTE2M2VkYTBhMjY4OTFlNjExNmE3ZQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2002-02-22T00:07:06Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2002-02-22T00:07:06Z"}, "message": "expmed.c (store_bit_field): Try to simplify the subreg before generating a new one when...\n\n2002-02-21  Eric Christopher  <echristo@redhat.com>\n\n\t* expmed.c (store_bit_field): Try to simplify the subreg\n\tbefore generating a new one when when the mode size of\n\tvalue is less than maxmode.\n\nFrom-SVN: r49946", "tree": {"sha": "ff0ab79e68b30343387650ff7818d4ab3437afb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff0ab79e68b30343387650ff7818d4ab3437afb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c410d49e434d06e93c9163eda0a26891e6116a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c410d49e434d06e93c9163eda0a26891e6116a7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c410d49e434d06e93c9163eda0a26891e6116a7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c410d49e434d06e93c9163eda0a26891e6116a7e/comments", "author": null, "committer": null, "parents": [{"sha": "e3c8ea672563a4f8762b60f302a0a13c788405f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c8ea672563a4f8762b60f302a0a13c788405f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c8ea672563a4f8762b60f302a0a13c788405f7"}], "stats": {"total": 119, "additions": 67, "deletions": 52}, "files": [{"sha": "e4b437ceb2f5f7b44bcb18b0f93803846b9c0a3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c410d49e434d06e93c9163eda0a26891e6116a7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c410d49e434d06e93c9163eda0a26891e6116a7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c410d49e434d06e93c9163eda0a26891e6116a7e", "patch": "@@ -1,3 +1,9 @@\n+2002-02-21  Eric Christopher  <echristo@redhat.com>\n+\n+\t* expmed.c (store_bit_field): Try to simplify the subreg\n+\tbefore generating a new one when when the mode size of\n+\tvalue is less than maxmode.\n+\n 2002-02-21  Richard Henderson  <rth@redhat.com>\n \n \t* emit-rtl.c (offset_address): Use simplify_gen_binary rather\n@@ -95,7 +101,7 @@ Thu Feb 21 15:35:46 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \tbits of SImode const_int.\n \t(includes_rshift_p): Likewise.\n \t(print_operand): Call mask_operand and mask64_operand with correct\n-\tmode. \n+\tmode.\n \t(rs6000_output_function_epilogue): Pad traceback table to word.\n \t* config/rs6000/rs6000.h (MASK_64BIT): Correct comment.\n \t(EXTRA_CONSTRAINT, 'S' and 'T'): Call mask_operand and\n@@ -161,7 +167,7 @@ Thu Feb 21 15:35:46 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \t(ix86_expand_unop1_builtin): Likewise.\n \n 2002-02-20  Philip Blundell  <philb@gnu.org>\n-\t\n+\n \tPR 5705\n \t* config/arm/arm.h (HARD_REGNO_RENAME_OK): New macro.\n \n@@ -203,7 +209,7 @@ Wed Feb 20 00:03:25 EST 2002 Alan Matsuoka <alanm@redhat.com>\n \n \t* cppinit.c (init_dependency_output): Take deps output file\n \tfrom -o if none given with -MF.  Suppress normal output.\n-\t* gcc.c (cpp_unique_options): Have -M and -MM imply -E.\t\n+\t* gcc.c (cpp_unique_options): Have -M and -MM imply -E.\n \t* doc/cpp.texi, doc/invoke.texi: Update.\n \n 2002-02-19  Zack Weinberg  <zack@codesourcery.com>\n@@ -217,7 +223,7 @@ Wed Feb 20 00:03:25 EST 2002 Alan Matsuoka <alanm@redhat.com>\n \treally_call_used[VRSAVE_REGNO] if not Altivec.\n \n 2002-02-19  Alan Modra  <amodra@bigpond.net.au>\n-\t\n+\n \t* config/rs6000/rs6000.c (u_short_cint_operand): Mask op with\n \tMODE_MASK.\n \t(constant_pool_expr_1): Fix formatting.\n@@ -283,7 +289,7 @@ Tue Feb 19 20:13:57 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(arm_assemble_integer): Likewise.\n \t* config/arm/arm.h (ARM_ENCODE_CALL_TYPE): Allow any decl to be\n \tmarked local.\n-\t\n+\n 2002-02-19  matthew green  <mrg@eterna.com.au>\n \n \t* config.gcc (sparc-*-netbsdelf*): Enable target.\n@@ -465,7 +471,7 @@ Tue Feb 19 12:37:23 CET 2002  Jan Hubicka  <jh@suse.cz>\n \t(decode_rtx_const): Add case for vector.\n \n \t* config/rs6000/rs6000-protos.h: Add zero_constant.\n-\t\n+\n \t* config/rs6000/rs6000.c (rs6000_emit_move): Handle vector\n \tconstants.  Force easy vector constants into memory.\n \t(easy_vector_constant): New.\n@@ -537,7 +543,7 @@ Mon Feb 18 11:55:55 CET 2002  Jan Hubicka  <jh@suse.cz>\n 2002-02-18  David Billinghurst <David.Billinghurst@riotinto.com>\n \n \t* objc/objc-act.c (handle_impent): Remove leading '*'\n-\tfrom objc_class_name. \n+\tfrom objc_class_name.\n \n 2002-02-17  Richard Henderson  <rth@redhat.com>\n \n@@ -593,7 +599,7 @@ Mon Feb 18 11:55:55 CET 2002  Jan Hubicka  <jh@suse.cz>\n \t* config/arc/arc.c config/fr30/fr30.c config/m32r/m32r.c\n \tconfig/m88k/m88k.c : Adapt all calls to output_operand_lossage.\n \tUpdate copyright date where necessary.\n-\t\n+\n \t* config/i386/i386.c (print_operand): Likewise. Remove use of\n \tsprintf.\n \n@@ -662,15 +668,15 @@ Sat Feb 16 13:39:09 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2002-02-16  Ulrich Weigand  <uweigand@de.ibm.com>\n \n-\t* config/s390/s390.c (pool_stop_uid, other_chunk, far_away, \n+\t* config/s390/s390.c (pool_stop_uid, other_chunk, far_away,\n \tcheck_and_change_labels, s390_final_chunkify): Delete.\n \t(s390_split_branches, s390_chunkify_pool): New functions.\n \t(s390_function_prologue): Call them.\n-\t\n+\n \t* config/s390/s390.h (S390_REL_MAX): Delete.\n \t(S390_CHUNK_MAX, S390_CHUNK_OV): Adjust values.\n \n-\t* config/s390/s390.md (cjump, icjump, jump): Fix length \n+\t* config/s390/s390.md (cjump, icjump, jump): Fix length\n \tattribute calculation.\n \n "}, {"sha": "b3d94c2376f8a194684a37adb9adaac3cf87569e", "filename": "gcc/expmed.c", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c410d49e434d06e93c9163eda0a26891e6116a7e/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c410d49e434d06e93c9163eda0a26891e6116a7e/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c410d49e434d06e93c9163eda0a26891e6116a7e", "patch": "@@ -54,7 +54,7 @@ static void do_cmp_and_jump\t\tPARAMS ((rtx, rtx, enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx));\n \n /* Non-zero means divides or modulus operations are relatively cheap for\n-   powers of two, so don't use branches; emit the operation instead. \n+   powers of two, so don't use branches; emit the operation instead.\n    Usually, this will mean that the MD file will emit non-branch\n    sequences.  */\n \n@@ -333,7 +333,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n      If the target is memory, storing any naturally aligned field can be\n      done with a simple store.  For targets that support fast unaligned\n      memory, any naturally sized, unit aligned field can be done directly.  */\n-     \n+\n   byte_offset = (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n                 + (offset * UNITS_PER_WORD);\n \n@@ -576,7 +576,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n \t\t  && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n \t    goto insv_loses;\n \n-\t  /* Adjust address to point to the containing unit of that mode. \n+\t  /* Adjust address to point to the containing unit of that mode.\n \t     Compute offset as multiple of this unit, counting in bytes.  */\n \t  unit = GET_MODE_BITSIZE (bestmode);\n \t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n@@ -630,8 +630,17 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n \t\t if we must narrow it, be sure we do it correctly.  */\n \n \t      if (GET_MODE_SIZE (GET_MODE (value)) < GET_MODE_SIZE (maxmode))\n-\t\tvalue1 = simplify_gen_subreg (maxmode, value1,\n-\t\t\t\t\t      GET_MODE (value1), 0);\n+\t\t{\n+\t\t  rtx tmp;\n+\n+\t\t  tmp = simplify_subreg (maxmode, value1, GET_MODE (value), 0);\n+\t\t  if (! tmp)\n+\t\t    tmp = simplify_gen_subreg (maxmode,\n+\t\t\t\t\t       force_reg (GET_MODE (value),\n+\t\t\t\t\t\t\t  value1),\n+\t\t\t\t\t       GET_MODE (value), 0);\n+\t\t  value1 = tmp;\n+\t\t}\n \t      else\n \t\tvalue1 = gen_lowpart (maxmode, value1);\n \t    }\n@@ -712,7 +721,7 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value)\n     {\n       /* Get the proper mode to use for this field.  We want a mode that\n \t includes the entire field.  If such a mode would be larger than\n-\t a word, we won't be doing the extraction the normal way.  \n+\t a word, we won't be doing the extraction the normal way.\n \t We don't want a mode bigger than the destination.  */\n \n       mode = GET_MODE (op0);\n@@ -1061,7 +1070,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   /* ??? We currently assume TARGET is at least as big as BITSIZE.\n      If that's wrong, the solution is to test for it and set TARGET to 0\n      if needed.  */\n-  \n+\n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n@@ -1128,7 +1137,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     }\n \n   /* Handle fields bigger than a word.  */\n-  \n+\n   if (bitsize > BITS_PER_WORD)\n     {\n       /* Here we transfer the words of the field\n@@ -1200,14 +1209,14 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t   build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n \t\t\t   NULL_RTX, 0);\n     }\n-  \n+\n   /* From here on we know the desired field is smaller than a word.  */\n \n   /* Check if there is a correspondingly-sized integer field, so we can\n      safely extract it as one size of integer, if necessary; then\n      truncate or extend to the size that is wanted; then use SUBREGs or\n      convert_to_mode to get one of the modes we really wanted.  */\n-  \n+\n   int_mode = int_mode_for_mode (tmode);\n   if (int_mode == BLKmode)\n     int_mode = int_mode_for_mode (mode);\n@@ -1366,7 +1375,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t}\n       else\n       extzv_loses:\n-\ttarget = extract_fixed_bit_field (int_mode, op0, offset, bitsize, \n+\ttarget = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n \t\t\t\t\t  bitpos, target, 1);\n     }\n   else\n@@ -1492,10 +1501,10 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n \t\t\t\t\t\tbitpos, target, 0);\n \t    }\n-\t} \n+\t}\n       else\n       extv_loses:\n-\ttarget = extract_fixed_bit_field (int_mode, op0, offset, bitsize, \n+\ttarget = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n \t\t\t\t\t  bitpos, target, 0);\n     }\n   if (target == spec_target)\n@@ -1660,7 +1669,7 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n     }\n \n   return expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t       build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0), \n+\t\t       build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n \t\t       target, 0);\n }\n \f\n@@ -1685,7 +1694,7 @@ mask_rtx (mode, bitpos, bitsize, complement)\n   if (bitpos + bitsize < HOST_BITS_PER_WIDE_INT)\n     masklow &= ((unsigned HOST_WIDE_INT) -1\n \t\t>> (HOST_BITS_PER_WIDE_INT - bitpos - bitsize));\n-  \n+\n   if (bitpos <= HOST_BITS_PER_WIDE_INT)\n     maskhigh = -1;\n   else\n@@ -1975,7 +1984,7 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n \t      && (unsigned int) INTVAL (op1) < GET_MODE_BITSIZE (mode))\n \t    temp = expand_binop (mode,\n \t\t\t\t left ? rotr_optab : rotl_optab,\n-\t\t\t\t shifted, \n+\t\t\t\t shifted,\n \t\t\t\t GEN_INT (GET_MODE_BITSIZE (mode)\n \t\t\t\t\t  - INTVAL (op1)),\n \t\t\t\t target, unsignedp, methods);\n@@ -2006,7 +2015,7 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n \t}\n \n       /* We used to try extzv here for logical right shifts, but that was\n-\t only useful for one machine, the VAX, and caused poor code \n+\t only useful for one machine, the VAX, and caused poor code\n \t generation there for lshrdi3, so the code was deleted and a\n \t define_expand for lshrsi3 was added to vax.md.  */\n     }\n@@ -2147,7 +2156,7 @@ synth_mult (alg_out, t, cost_limit)\n       for (w = 1; (w & t) != 0; w <<= 1)\n \t;\n       /* If T was -1, then W will be zero after the loop.  This is another\n-\t case where T ends with ...111.  Handling this with (T + 1) and \n+\t case where T ends with ...111.  Handling this with (T + 1) and\n \t subtract 1 produces slightly better code and results in algorithm\n \t selection much faster than treating it like the ...0111 case\n \t below.  */\n@@ -2427,7 +2436,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t   && ! preserve)\n \t\t  ? target : 0;\n \t      rtx accum_target = preserve ? 0 : accum;\n-\t      \n+\n \t      switch (alg.op[opno])\n \t\t{\n \t\tcase alg_shift:\n@@ -2509,7 +2518,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t}\n \n \t      insn = get_last_insn ();\n-\t      set_unique_reg_note (insn, \n+\t      set_unique_reg_note (insn,\n \t      \t\t\t   REG_EQUAL,\n \t\t\t\t   gen_rtx_MULT (nmode, tem,\n \t\t\t\t   \t         GEN_INT (val_so_far)));\n@@ -2535,7 +2544,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \n   /* This used to use umul_optab if unsigned, but for non-widening multiply\n      there is no difference between signed and unsigned.  */\n-  op0 = expand_binop (mode, \n+  op0 = expand_binop (mode,\n \t\t      ! unsignedp\n                        && flag_trapv && (GET_MODE_CLASS(mode) == MODE_INT)\n                        ? smulv_optab : smul_optab,\n@@ -2823,7 +2832,7 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n     {\n       op1 = force_reg (mode, op1);\n       goto try;\n-    } \n+    }\n \n   /* Try widening the mode and perform a non-widening multiplication.  */\n   moptab = smul_optab;\n@@ -3230,7 +3239,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\tif (insn != last\n \t\t    && (set = single_set (insn)) != 0\n \t\t    && SET_DEST (set) == quotient)\n-\t\t  set_unique_reg_note (insn, \n+\t\t  set_unique_reg_note (insn,\n \t\t  \t\t       REG_EQUAL,\n \t\t\t\t       gen_rtx_UDIV (compute_mode, op0, op1));\n \t      }\n@@ -3318,7 +3327,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t    && SET_DEST (set) == quotient\n \t\t\t    && abs_d < ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t<< (HOST_BITS_PER_WIDE_INT - 1)))\n-\t\t\t  set_unique_reg_note (insn, \n+\t\t\t  set_unique_reg_note (insn,\n \t\t\t  \t\t       REG_EQUAL,\n \t\t\t\t\t       gen_rtx_DIV (compute_mode,\n \t\t\t\t\t\t\t    op0,\n@@ -3409,7 +3418,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\tif (insn != last\n \t\t    && (set = single_set (insn)) != 0\n \t\t    && SET_DEST (set) == quotient)\n-\t\t  set_unique_reg_note (insn, \n+\t\t  set_unique_reg_note (insn,\n \t\t  \t\t       REG_EQUAL,\n \t\t\t\t       gen_rtx_DIV (compute_mode, op0, op1));\n \t      }\n@@ -3902,7 +3911,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t    emit_label (label);\n \t  }\n \treturn gen_lowpart (mode, rem_flag ? remainder : quotient);\n-\t\n+\n       default:\n \tabort ();\n       }\n@@ -4056,42 +4065,42 @@ make_tree (type, x)\n \t    elt = CONST_VECTOR_ELT (x, i);\n \t    t = tree_cons (NULL_TREE, make_tree (type, elt), t);\n \t  }\n-\t\n+\n \treturn build_vector (type, t);\n       }\n \n     case PLUS:\n       return fold (build (PLUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n \t\t\t  make_tree (type, XEXP (x, 1))));\n-\t\t\t\t\t\t       \n+\n     case MINUS:\n       return fold (build (MINUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n \t\t\t  make_tree (type, XEXP (x, 1))));\n-\t\t\t\t\t\t       \n+\n     case NEG:\n       return fold (build1 (NEGATE_EXPR, type, make_tree (type, XEXP (x, 0))));\n \n     case MULT:\n       return fold (build (MULT_EXPR, type, make_tree (type, XEXP (x, 0)),\n \t\t\t  make_tree (type, XEXP (x, 1))));\n-\t\t\t\t\t\t      \n+\n     case ASHIFT:\n       return fold (build (LSHIFT_EXPR, type, make_tree (type, XEXP (x, 0)),\n \t\t\t  make_tree (type, XEXP (x, 1))));\n-\t\t\t\t\t\t      \n+\n     case LSHIFTRT:\n       return fold (convert (type,\n \t\t\t    build (RSHIFT_EXPR, unsigned_type (type),\n \t\t\t\t   make_tree (unsigned_type (type),\n \t\t\t\t\t      XEXP (x, 0)),\n \t\t\t\t   make_tree (type, XEXP (x, 1)))));\n-\t\t\t\t\t\t      \n+\n     case ASHIFTRT:\n       return fold (convert (type,\n \t\t\t    build (RSHIFT_EXPR, signed_type (type),\n \t\t\t\t   make_tree (signed_type (type), XEXP (x, 0)),\n \t\t\t\t   make_tree (type, XEXP (x, 1)))));\n-\t\t\t\t\t\t      \n+\n     case DIV:\n       if (TREE_CODE (type) != REAL_TYPE)\n \tt = signed_type (type);\n@@ -4182,7 +4191,7 @@ expand_and (mode, op0, op1, target)\n    Return 0 if that cannot be done.\n \n    MODE is the mode to use for OP0 and OP1 should they be CONST_INTs.  If\n-   it is VOIDmode, they cannot both be CONST_INT.  \n+   it is VOIDmode, they cannot both be CONST_INT.\n \n    UNSIGNEDP is for the case where we have to widen the operands\n    to perform the operation.  It says to use zero-extension.\n@@ -4230,7 +4239,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n   if (mode == VOIDmode)\n     mode = GET_MODE (op0);\n \n-  /* For some comparisons with 1 and -1, we can convert this to \n+  /* For some comparisons with 1 and -1, we can convert this to\n      comparisons with zero.  This will often produce more opportunities for\n      store-flag insns.  */\n \n@@ -4433,7 +4442,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \t  else\n \t    abort ();\n \n-\t  /* If we were converting to a smaller mode, do the \n+\t  /* If we were converting to a smaller mode, do the\n \t     conversion now.  */\n \t  if (target_mode != compare_mode)\n \t    {\n@@ -4478,7 +4487,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n       return tem;\n     }\n \n-  /* Some other cases we can do are EQ, NE, LE, and GT comparisons with \n+  /* Some other cases we can do are EQ, NE, LE, and GT comparisons with\n      the constant zero.  Reject all other comparisons at this point.  Only\n      do LE and GT if branches are expensive since they are expensive on\n      2-operand machines.  */\n@@ -4540,22 +4549,22 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n       tem = expand_binop (mode, sub_optab, tem, op0, subtarget, 0,\n \t\t\t  OPTAB_WIDEN);\n     }\n-\t\t\t\t    \n+\n   if (code == EQ || code == NE)\n     {\n       /* For EQ or NE, one way to do the comparison is to apply an operation\n \t that converts the operand into a positive number if it is non-zero\n \t or zero if it was originally zero.  Then, for EQ, we subtract 1 and\n \t for NE we negate.  This puts the result in the sign bit.  Then we\n-\t normalize with a shift, if needed. \n+\t normalize with a shift, if needed.\n \n \t Two operations that can do the above actions are ABS and FFS, so try\n \t them.  If that doesn't work, and MODE is smaller than a full word,\n \t we can use zero-extension to the wider mode (an unsigned conversion)\n \t as the operation.  */\n \n-      /* Note that ABS doesn't yield a positive number for INT_MIN, but \n-\t that is compensated by the subsequent overflow when subtracting \n+      /* Note that ABS doesn't yield a positive number for INT_MIN, but\n+\t that is compensated by the subsequent overflow when subtracting\n \t one / negating.  */\n \n       if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)"}]}