{"sha": "2a380e2ed0522b30070cf0b3f730f47eb1375976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzODBlMmVkMDUyMmIzMDA3MGNmMGIzZjczMGY0N2ViMTM3NTk3Ng==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2019-05-17T16:02:20Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2019-05-17T16:02:20Z"}, "message": "x86-64: Add vector vararg ABI tests\n\nWe can scan stack for return address to get vector arguments passed on\nstack.\n\nTested on Linux/x86-64 and Linux/x32.\n\n\t* gcc.target/x86_64/abi/test_varargs-m128.c: New file.\n\t* gcc.target/x86_64/abi/avx/test_varargs-m256.c: Likewise.\n\t* gcc.target/x86_64/abi/avx512f/test_varargs-m512.c: Likewise.\n\nFrom-SVN: r271329", "tree": {"sha": "0516c78535cc4569be5009b71850495f5016dff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0516c78535cc4569be5009b71850495f5016dff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a380e2ed0522b30070cf0b3f730f47eb1375976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a380e2ed0522b30070cf0b3f730f47eb1375976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a380e2ed0522b30070cf0b3f730f47eb1375976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a380e2ed0522b30070cf0b3f730f47eb1375976/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45641b316a7b2c9bdf1d7807631731457b8cc0f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45641b316a7b2c9bdf1d7807631731457b8cc0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45641b316a7b2c9bdf1d7807631731457b8cc0f1"}], "stats": {"total": 324, "additions": 324, "deletions": 0}, "files": [{"sha": "af5de86ae15765579c956e94aeb0f40a7a38bee7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2a380e2ed0522b30070cf0b3f730f47eb1375976", "patch": "@@ -1,3 +1,9 @@\n+2019-05-17  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/x86_64/abi/test_varargs-m128.c: New file.\n+\t* gcc.target/x86_64/abi/avx/test_varargs-m256.c: Likewise.\n+\t* gcc.target/x86_64/abi/avx512f/test_varargs-m512.c: Likewise.\n+\n 2019-05-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/90497"}, {"sha": "0c6d61f072f82424130f0ff4f5308af854ae9d2b", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/test_varargs-m256.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_varargs-m256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_varargs-m256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_varargs-m256.c?ref=2a380e2ed0522b30070cf0b3f730f47eb1375976", "patch": "@@ -0,0 +1,104 @@\n+/* Test variable number of 256-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"avx-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  YMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m256_varargs (__m256 i0, __m256 i1, __m256 i2,\n+\t\t\t\t__m256 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m256 *argp;\n+\n+  compare (values.i0, i0, __m256);\n+  compare (values.i1, i1, __m256);\n+  compare (values.i2, i2, __m256);\n+  compare (values.i3, i3, __m256);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m256 *) (((char *) fp) + 8);\n+\n+  /* Check __m256 arguments passed on stack.  */\n+  compare (values.i4, argp[0], __m256);\n+  compare (values.i5, argp[1], __m256);\n+  compare (values.i6, argp[2], __m256);\n+  compare (values.i7, argp[3], __m256);\n+  compare (values.i8, argp[4], __m256);\n+  compare (values.i9, argp[5], __m256);\n+\n+  /* Check register contents.  */\n+  compare (fregs.ymm0, ymm_regs[0], __m256);\n+  compare (fregs.ymm1, ymm_regs[1], __m256);\n+  compare (fregs.ymm2, ymm_regs[2], __m256);\n+  compare (fregs.ymm3, ymm_regs[3], __m256);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m256_varargs (void)\n+{\n+  __m256 x[10];\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m256){32+i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m256-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m256_varargs,\n+\t\t\t\t _m256);\n+}\n+\n+void\n+avx_test (void)\n+{\n+  test_m256_varargs ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "b2ba0e5ab225f0739b5a084038691da0e03fe72c", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512f/test_varargs-m512.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512f%2Ftest_varargs-m512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512f%2Ftest_varargs-m512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512f%2Ftest_varargs-m512.c?ref=2a380e2ed0522b30070cf0b3f730f47eb1375976", "patch": "@@ -0,0 +1,104 @@\n+/* Test variable number of 512-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"avx512f-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  ZMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m512_varargs (__m512 i0, __m512 i1, __m512 i2,\n+\t\t\t\t__m512 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m512 *argp;\n+\n+  compare (values.i0, i0, __m512);\n+  compare (values.i1, i1, __m512);\n+  compare (values.i2, i2, __m512);\n+  compare (values.i3, i3, __m512);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m512 *)(((char *) fp) + 8);\n+\n+  /* Check __m512 arguments passed on stack.  */\n+  compare (values.i4, argp[0], __m512);\n+  compare (values.i5, argp[1], __m512);\n+  compare (values.i6, argp[2], __m512);\n+  compare (values.i7, argp[3], __m512);\n+  compare (values.i8, argp[4], __m512);\n+  compare (values.i9, argp[5], __m512);\n+\n+  /* Check register contents.  */\n+  compare (fregs.zmm0, zmm_regs[0], __m512);\n+  compare (fregs.zmm1, zmm_regs[1], __m512);\n+  compare (fregs.zmm2, zmm_regs[2], __m512);\n+  compare (fregs.zmm3, zmm_regs[3], __m512);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m512_varargs (void)\n+{\n+  __m512 x[10];\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m512){32+i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m512-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m512_varargs,\n+\t\t\t\t _m512);\n+}\n+\n+void\n+avx512f_test (void)\n+{\n+  test_m512_varargs ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "307576874394c7271c98a42fcfd69fb4363334fc", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_varargs-m128.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_varargs-m128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a380e2ed0522b30070cf0b3f730f47eb1375976/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_varargs-m128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_varargs-m128.c?ref=2a380e2ed0522b30070cf0b3f730f47eb1375976", "patch": "@@ -0,0 +1,110 @@\n+/* Test variable number of 128-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  XMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m128_varargs (__m128 i0, __m128 i1, __m128 i2,\n+\t\t\t\t__m128 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m128 *argp;\n+\n+  compare (values.i0, i0, __m128);\n+  compare (values.i1, i1, __m128);\n+  compare (values.i2, i2, __m128);\n+  compare (values.i3, i3, __m128);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m128 *) (((char *) fp) + 8);\n+\n+  /* Check __m128 arguments passed on stack.  */\n+  compare (values.i8, argp[0], __m128);\n+  compare (values.i9, argp[1], __m128);\n+\n+  /* Check register contents.  */\n+  compare (fregs.xmm0, xmm_regs[0], __m128);\n+  compare (fregs.xmm1, xmm_regs[1], __m128);\n+  compare (fregs.xmm2, xmm_regs[2], __m128);\n+  compare (fregs.xmm3, xmm_regs[3], __m128);\n+  compare (fregs.xmm4, xmm_regs[4], __m128);\n+  compare (fregs.xmm5, xmm_regs[5], __m128);\n+  compare (fregs.xmm6, xmm_regs[6], __m128);\n+  compare (fregs.xmm7, xmm_regs[7], __m128);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_float_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m128_varargs (void)\n+{\n+  __m128 x[10];\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m128){32+i, 0, 0, 0};\n+  pass = \"m128-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m128_varargs,\n+\t\t\t\t _m128);\n+}\n+\n+int\n+main (void)\n+{\n+  test_m128_varargs ();\n+  if (failed)\n+    abort ();\n+  return 0;\n+}"}]}