{"sha": "bacf5b96edee976363fed3b78ab5923a62cd9bbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFjZjViOTZlZGVlOTc2MzYzZmVkM2I3OGFiNTkyM2E2MmNkOWJiYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-06-01T07:02:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-06-01T07:02:36Z"}, "message": "system.h (TARGET_OPTIONS, [...]): Poison.\n\n\t* system.h (TARGET_OPTIONS, TARGET_SWITCHES): Poison.\n\t* opts.h (print_filtered_help): Delete.\n\t* opts.c (handle_option, decode_options): Remove calls to\n\tset_target_switch.\n\t(print_target_help): New function.\n\t(common_option, print_help): Call print_target_help instead of\n\tdisplay_target_options.\n\t(print_filtered_help): Make static.\n\t* toplev.h (display_target_options, set_target_switch): Delete.\n\t* toplev.c (target_switches, target_options, display_target_options)\n\t(set_target_switch): Delete.\n\t(print_switch_values): Remove handling of TARGET_SWITCHES and\n\tTARGET_OPTIONS.\n\t(default_get_pch_validity): Likewise.  Only treat target_flags\n\tspecially if targetm.check_pch_target_flags is nonnull.\n\t(pch_option_mismatch): New function.\n\t(default_pch_valid_p): Use it.  Remove handling of TARGET_SWITCHES\n\tand TARGET_OPTIONS.  Only treat target_flags specially if\n\ttargetm.check_pch_target_flags is nonnull.\n\t* config/ia64/ia64.c (ia64_override_options): Don't mention\n\tTARGET_OPTIONS in comment.\n\t* config/m68k/m68k-none.h (CC1_SPEC): Likewise.\n\t* doc/invoke.texi: Remove a reference to TARGET_SWITCHES.\n\t* doc/tm.texi (TARGET_DEFAULT_TARGET_FLAGS): Don't mention the\n\tinteraction with TARGET_SWITCHES.\n\t(TARGET_@var{featurename}, TARGET_SWITCHES, TARGET_OPTIONS): Delete.\n\nFrom-SVN: r100432", "tree": {"sha": "9922e622538e517abd0e7cccf3bad8892f4e9118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9922e622538e517abd0e7cccf3bad8892f4e9118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bacf5b96edee976363fed3b78ab5923a62cd9bbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bacf5b96edee976363fed3b78ab5923a62cd9bbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bacf5b96edee976363fed3b78ab5923a62cd9bbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bacf5b96edee976363fed3b78ab5923a62cd9bbb/comments", "author": null, "committer": null, "parents": [{"sha": "7dd2f19b2fadf4edb3a7277563b5b1ee59f8723c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dd2f19b2fadf4edb3a7277563b5b1ee59f8723c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dd2f19b2fadf4edb3a7277563b5b1ee59f8723c"}], "stats": {"total": 547, "additions": 93, "deletions": 454}, "files": [{"sha": "0d59ffe23ad7aab344c1f5dcd17b2432797cf57e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -1,3 +1,32 @@\n+2005-06-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* system.h (TARGET_OPTIONS, TARGET_SWITCHES): Poison.\n+\t* opts.h (print_filtered_help): Delete.\n+\t* opts.c (handle_option, decode_options): Remove calls to\n+\tset_target_switch.\n+\t(print_target_help): New function.\n+\t(common_option, print_help): Call print_target_help instead of\n+\tdisplay_target_options.\n+\t(print_filtered_help): Make static.\n+\t* toplev.h (display_target_options, set_target_switch): Delete.\n+\t* toplev.c (target_switches, target_options, display_target_options)\n+\t(set_target_switch): Delete.\n+\t(print_switch_values): Remove handling of TARGET_SWITCHES and\n+\tTARGET_OPTIONS.\n+\t(default_get_pch_validity): Likewise.  Only treat target_flags\n+\tspecially if targetm.check_pch_target_flags is nonnull.\n+\t(pch_option_mismatch): New function.\n+\t(default_pch_valid_p): Use it.  Remove handling of TARGET_SWITCHES\n+\tand TARGET_OPTIONS.  Only treat target_flags specially if\n+\ttargetm.check_pch_target_flags is nonnull.\n+\t* config/ia64/ia64.c (ia64_override_options): Don't mention\n+\tTARGET_OPTIONS in comment.\n+\t* config/m68k/m68k-none.h (CC1_SPEC): Likewise.\n+\t* doc/invoke.texi: Remove a reference to TARGET_SWITCHES.\n+\t* doc/tm.texi (TARGET_DEFAULT_TARGET_FLAGS): Don't mention the\n+\tinteraction with TARGET_SWITCHES.\n+\t(TARGET_@var{featurename}, TARGET_SWITCHES, TARGET_OPTIONS): Delete.\n+\n 2005-06-01  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/sh/sh.c (multcosts): Check sh_multcost rather than"}, {"sha": "7b20280b746816bb9425ff0609efe4f00f5e8644", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -4865,7 +4865,7 @@ ia64_handle_option (size_t code, const char *arg, int value)\n     }\n }\n \n-/* Handle TARGET_OPTIONS switches.  */\n+/* Implement OVERRIDE_OPTIONS.  */\n \n void\n ia64_override_options (void)"}, {"sha": "378197d830899a110146c8b6731f2d810aa20b18", "filename": "gcc/config/m68k/m68k-none.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-none.h?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -86,8 +86,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \"\n \n /* cc1/cc1plus always receives all the -m flags. If the specs strings above \n-   are consistent with the TARGET_OPTIONS flags in m68k.h, there should be no\n-   need for any further cc1/cc1plus specs.  */\n+   are consistent with the flags in m68k.opt, there should be no need for\n+   any further cc1/cc1plus specs.  */\n \n #undef CC1_SPEC\n #define CC1_SPEC \"\""}, {"sha": "a6483e8eaa8633432243793d86b1d64734903afb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -6883,10 +6883,6 @@ Some configurations of the compiler also support additional special\n options, usually for compatibility with other compilers on the same\n platform.\n \n-These options are defined by the macro @code{TARGET_SWITCHES} in the\n-machine description.  The default for the options is also defined by\n-that macro, which enables you to change the defaults.\n-\n @c This list is ordered alphanumerically by subsection name.\n @c It should be the same order and spelling as these options are listed\n @c in Machine Dependent Options"}, {"sha": "a4adcb9db55b0ebe5d0ead87c011d23ef5e22bc3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 150, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -728,11 +728,11 @@ any target-specific headers.\n @deftypevar {Target Hook} int TARGET_DEFAULT_TARGET_FLAGS\n This variable specifies the initial value of @code{target_flags}.\n Its default setting is 0.\n-\n-If the target defines @code{TARGET_SWITCHES}, the null\n-@code{TARGET_SWITCHES} entry will override this value.\n @end deftypevar\n \n+@cindex optional hardware or system features\n+@cindex features, optional, in system conventions\n+\n @deftypefn {Target Hook} bool TARGET_HANDLE_OPTION (size_t @var{code}, const char *@var{arg}, int @var{value})\n This hook is called whenever the user specifies one of the\n target-specific options described by the @file{.opt} definition files\n@@ -750,153 +750,6 @@ argument.  Otherwise @var{value} is 1 if the positive form of the\n option was used and 0 if the ``no-'' form was.\n @end deftypefn\n \n-@cindex optional hardware or system features\n-@cindex features, optional, in system conventions\n-\n-@defmac TARGET_@var{featurename}\n-This series of macros is to allow compiler command arguments to\n-enable or disable the use of optional features of the target machine.\n-For example, one machine description serves both the 68000 and\n-the 68020; a command argument tells the compiler whether it should\n-use 68020-only instructions or not.  This command argument works\n-by means of a macro @code{TARGET_68020} that tests a bit in\n-@code{target_flags}.\n-\n-Define a macro @code{TARGET_@var{featurename}} for each such option.\n-Its definition should test a bit in @code{target_flags}.  It is\n-recommended that a helper macro @code{MASK_@var{featurename}}\n-is defined for each bit-value to test, and used in\n-@code{TARGET_@var{featurename}} and @code{TARGET_SWITCHES}.  For\n-example:\n-\n-@smallexample\n-#define TARGET_MASK_68020 1\n-#define TARGET_68020 (target_flags & MASK_68020)\n-@end smallexample\n-\n-One place where these macros are used is in the condition-expressions\n-of instruction patterns.  Note how @code{TARGET_68020} appears\n-frequently in the 68000 machine description file, @file{m68k.md}.\n-Another place they are used is in the definitions of the other\n-macros in the @file{@var{machine}.h} file.\n-@end defmac\n-\n-@defmac TARGET_SWITCHES\n-This macro defines names of command options to set and clear\n-bits in @code{target_flags}.  Its definition is an initializer\n-with a subgrouping for each command option.\n-\n-Each subgrouping contains a string constant, that defines the option\n-name, a number, which contains the bits to set in\n-@code{target_flags}, and a second string which is the description\n-displayed by @option{--help}.  If the number is negative then the bits specified\n-by the number are cleared instead of being set.  If the description\n-string is present but empty, then no help information will be displayed\n-for that option, but it will not count as an undocumented option.  The\n-actual option name is made by appending @samp{-m} to the specified name.\n-Non-empty description strings should be marked with @code{N_(@dots{})} for\n-@command{xgettext}.  Please do not mark empty strings because the empty\n-string is reserved by GNU gettext.  @code{gettext(\"\")} returns the header entry\n-of the message catalog with meta information, not the empty string.\n-\n-In addition to the description for @option{--help},\n-more detailed documentation for each option should be added to\n-@file{invoke.texi}.\n-\n-One of the subgroupings should have a null string.  The number in\n-this grouping is the default value for @code{target_flags}.  Any\n-target options act starting with that value.\n-\n-Here is an example which defines @option{-m68000} and @option{-m68020}\n-with opposite meanings, and picks the latter as the default:\n-\n-@smallexample\n-#define TARGET_SWITCHES \\\n-  @{ @{ \"68020\", MASK_68020, \"\" @},     \\\n-    @{ \"68000\", -MASK_68020,          \\\n-      N_(\"Compile for the 68000\") @}, \\\n-    @{ \"\", MASK_68020, \"\" @},          \\\n-  @}\n-@end smallexample\n-\n-This macro is being kept for compatibility with older backends.\n-New targets should use option definition files instead.\n-@xref{Back End}.\n-@end defmac\n-\n-@defmac TARGET_OPTIONS\n-This macro is similar to @code{TARGET_SWITCHES} but defines names of command\n-options that have values.  Its definition is an initializer with a\n-subgrouping for each command option.\n-\n-Each subgrouping contains a string constant, that defines the option\n-name, the address of a variable, a description string, and a value.\n-Non-empty description strings should be marked with @code{N_(@dots{})}\n-for @command{xgettext}.  Please do not mark empty strings because the\n-empty string is reserved by GNU gettext.  @code{gettext(\"\")} returns the\n-header entry of the message catalog with meta information, not the empty\n-string.\n-\n-If the value listed in the table is @code{NULL}, then the variable, type\n-@code{char *}, is set to the variable part of the given option if the\n-fixed part matches.  In other words, if the first part of the option\n-matches what's in the table, the variable will be set to point to the\n-rest of the option.  This allows the user to specify a value for that\n-option.  The actual option name is made by appending @samp{-m} to the\n-specified name.  Again, each option should also be documented in\n-@file{invoke.texi}.\n-\n-If the value listed in the table is non-@code{NULL}, then the option\n-must match the option in the table exactly (with @samp{-m}), and the\n-variable is set to point to the value listed in the table.\n-\n-Here is an example which defines @option{-mshort-data-@var{number}}.  If the\n-given option is @option{-mshort-data-512}, the variable @code{m88k_short_data}\n-will be set to the string @code{\"512\"}.\n-\n-@smallexample\n-extern char *m88k_short_data;\n-#define TARGET_OPTIONS \\\n- @{ @{ \"short-data-\", &m88k_short_data, \\\n-     N_(\"Specify the size of the short data section\"), 0 @} @}\n-@end smallexample\n-\n-Here is a variant of the above that allows the user to also specify\n-just @option{-mshort-data} where a default of @code{\"64\"} is used.\n-\n-@smallexample\n-extern char *m88k_short_data;\n-#define TARGET_OPTIONS \\\n- @{ @{ \"short-data-\", &m88k_short_data, \\\n-     N_(\"Specify the size of the short data section\"), 0 @} \\\n-    @{ \"short-data\", &m88k_short_data, \"\", \"64\" @},\n-    @}\n-@end smallexample\n-\n-Here is an example which defines @option{-mno-alu}, @option{-malu1}, and\n-@option{-malu2} as a three-state switch, along with suitable macros for\n-checking the state of the option (documentation is elided for brevity).\n-\n-@smallexample\n-[chip.c]\n-char *chip_alu = \"\"; /* @r{Specify default here.}  */\n-\n-[chip.h]\n-extern char *chip_alu;\n-#define TARGET_OPTIONS \\\n-  @{ @{ \"no-alu\", &chip_alu, \"\", \"\" @}, \\\n-     @{ \"alu1\", &chip_alu, \"\", \"1\" @}, \\\n-     @{ \"alu2\", &chip_alu, \"\", \"2\" @}, @}\n-#define TARGET_ALU (chip_alu[0] != '\\0')\n-#define TARGET_ALU1 (chip_alu[0] == '1')\n-#define TARGET_ALU2 (chip_alu[0] == '2')\n-@end smallexample\n-\n-This macro is being kept for compatibility with older backends.\n-New targets should use option definition files instead.\n-@xref{Back End}.\n-@end defmac\n-\n @defmac TARGET_VERSION\n This macro is a C statement to print on @code{stderr} a string\n describing the particular machine description choice.  Every machine"}, {"sha": "039e0f1208df3520ff6981eb05c388fc8a1a51b4", "filename": "gcc/opts.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -110,8 +110,10 @@ static void complain_wrong_lang (const char *, const struct cl_option *,\n \t\t\t\t unsigned int lang_mask);\n static void handle_options (unsigned int, const char **, unsigned int);\n static void wrap_help (const char *help, const char *item, unsigned int);\n+static void print_target_help (void);\n static void print_help (void);\n static void print_param_help (void);\n+static void print_filtered_help (unsigned int);\n static unsigned int print_switch (const char *text, unsigned int indent);\n static void set_debug_level (enum debug_info_type type, int extended,\n \t\t\t     const char *arg);\n@@ -294,16 +296,7 @@ handle_option (const char **argv, unsigned int lang_mask)\n     }\n \n   if (opt_index == cl_options_count)\n-    {\n-#if defined (TARGET_OPTIONS) || defined (TARGET_SWITCHES)\n-      if (opt[1] == 'm')\n-\t{\n-\t  set_target_switch (argv[0] + 2);\n-\t  result = 1;\n-\t}\n-#endif\n-      goto done;\n-    }\n+    goto done;\n \n   option = &cl_options[opt_index];\n \n@@ -633,7 +626,6 @@ decode_options (unsigned int argc, const char **argv)\n   /* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can\n      modify it.  */\n   target_flags = targetm.default_target_flags;\n-  set_target_switch (\"\");\n \n   /* Unwind tables are always present when a target has ABI-specified unwind\n      tables, so the default should be ON.  */\n@@ -726,7 +718,7 @@ common_handle_option (size_t scode, const char *arg, int value)\n       break;\n \n     case OPT__target_help:\n-      display_target_options ();\n+      print_target_help ();\n       exit_after_options = true;\n       break;\n \n@@ -1203,6 +1195,27 @@ set_debug_level (enum debug_info_type type, int extended, const char *arg)\n     }\n }\n \n+/* Display help for target options.  */\n+static void\n+print_target_help (void)\n+{\n+  unsigned int i;\n+  static bool displayed = false;\n+\n+  /* Avoid double printing for --help --target-help.  */\n+  if (displayed)\n+    return;\n+\n+  displayed = true;\n+  for (i = 0; i < cl_options_count; i++)\n+    if ((cl_options[i].flags & (CL_TARGET | CL_UNDOCUMENTED)) == CL_TARGET)\n+      {\n+\tprintf (_(\"\\nTarget specific options:\\n\"));\n+\tprint_filtered_help (CL_TARGET);\n+\tbreak;\n+      }\n+}\n+\n /* Output --help text.  */\n static void\n print_help (void)\n@@ -1229,8 +1242,7 @@ print_help (void)\n \t      lang_names[i]);\n       print_filtered_help (1U << i);\n     }\n-\n-  display_target_options ();\n+  print_target_help ();\n }\n \n /* Print the help for --param.  */\n@@ -1259,7 +1271,7 @@ print_param_help (void)\n }\n \n /* Print help for a specific front-end, etc.  */\n-void\n+static void\n print_filtered_help (unsigned int flag)\n {\n   unsigned int i, len, filter, indent = 0;"}, {"sha": "bc05ac979579ad5c8480a47ffbc7232e5019946b", "filename": "gcc/opts.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -86,6 +86,5 @@ extern unsigned num_in_fnames;\n extern void decode_options (unsigned int argc, const char **argv);\n extern int option_enabled (int opt_idx);\n extern bool get_option_state (int, struct cl_option_state *);\n-extern void print_filtered_help (unsigned int);\n \n #endif"}, {"sha": "6b0919f2bc8dd50930a8d010760ababda128975b", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -738,7 +738,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tNON_SAVING_SETJMP TARGET_LATE_RTL_PROLOGUE_EPILOGUE\t\t   \\\n \tCASE_DROPS_THROUGH TARGET_BELL TARGET_BS TARGET_CR TARGET_DIGIT0   \\\n         TARGET_ESC TARGET_FF TARGET_NEWLINE TARGET_TAB TARGET_VT\t   \\\n-        LINK_LIBGCC_SPECIAL DONT_ACCESS_GBLS_AFTER_EPILOGUE\n+        LINK_LIBGCC_SPECIAL DONT_ACCESS_GBLS_AFTER_EPILOGUE\t\t   \\\n+\tTARGET_OPTIONS TARGET_SWITCHES\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "b26d767a19412b9232391b914be19d63ef6b80c6", "filename": "gcc/toplev.c", "status": "modified", "additions": 29, "deletions": 278, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -374,35 +374,6 @@ static const param_info lang_independent_params[] = {\n   { NULL, 0, 0, 0, NULL }\n };\n \n-#ifdef TARGET_SWITCHES\n-/* Here is a table, controlled by the tm.h file, listing each -m switch\n-   and which bits in `target_switches' it should set or clear.\n-   If VALUE is positive, it is bits to set.\n-   If VALUE is negative, -VALUE is bits to clear.\n-   (The sign bit is not used so there is no confusion.)  */\n-\n-static const struct\n-{\n-  const char *const name;\n-  const int value;\n-  const char *const description;\n-}\n-target_switches[] = TARGET_SWITCHES;\n-#endif\n-\n-/* This table is similar, but allows the switch to have a value.  */\n-\n-#ifdef TARGET_OPTIONS\n-static const struct\n-{\n-  const char *const prefix;\n-  const char **const variable;\n-  const char *const description;\n-  const char *const value;\n-}\n-target_options[] = TARGET_OPTIONS;\n-#endif\n-\n /* Output files for assembler code (real compiler output)\n    and debugging dumps.  */\n \n@@ -1057,92 +1028,6 @@ compile_file (void)\n   targetm.asm_out.file_end ();\n }\n \n-/* Display help for target options.  */\n-void\n-display_target_options (void)\n-{\n-  int undoc;\n-#if defined (TARGET_SWITCHES) || defined (TARGET_OPTIONS)\n-  int i;\n-#endif\n-  unsigned int cli;\n-  static bool displayed = false;\n-\n-  /* Avoid double printing for --help --target-help.  */\n-  if (displayed)\n-    return;\n-\n-  displayed = true;\n-\n-  for (cli = 0; cli < cl_options_count; cli++)\n-    if ((cl_options[cli].flags & (CL_TARGET | CL_UNDOCUMENTED)) == CL_TARGET)\n-      break;\n-\n-  if (cli < cl_options_count\n-#ifdef TARGET_SWITCHES\n-      || ARRAY_SIZE (target_switches) > 1\n-#endif\n-#ifdef TARGET_OPTIONS\n-      || ARRAY_SIZE (target_options) > 1\n-#endif\n-      )\n-    {\n-      int doc = cli < cl_options_count;\n-\n-      undoc = 0;\n-\n-      printf (_(\"\\nTarget specific options:\\n\"));\n-\n-#ifdef TARGET_SWITCHES\n-      for (i = ARRAY_SIZE (target_switches); i--;)\n-\t{\n-\t  const char *option      = target_switches[i].name;\n-\t  const char *description = target_switches[i].description;\n-\n-\t  if (option == NULL || *option == 0)\n-\t    continue;\n-\t  else if (description == NULL)\n-\t    {\n-\t      undoc = 1;\n-\n-\t      if (extra_warnings)\n-\t\tprintf (_(\"  -m%-23s [undocumented]\\n\"), option);\n-\t    }\n-\t  else if (*description != 0)\n-\t    doc += printf (\"  -m%-23s %s\\n\", option, _(description));\n-\t}\n-#endif\n-\n-#ifdef TARGET_OPTIONS\n-      for (i = ARRAY_SIZE (target_options); i--;)\n-\t{\n-\t  const char *option      = target_options[i].prefix;\n-\t  const char *description = target_options[i].description;\n-\n-\t  if (option == NULL || *option == 0)\n-\t    continue;\n-\t  else if (description == NULL)\n-\t    {\n-\t      undoc = 1;\n-\n-\t      if (extra_warnings)\n-\t\tprintf (_(\"  -m%-23s [undocumented]\\n\"), option);\n-\t    }\n-\t  else if (*description != 0)\n-\t    doc += printf (\"  -m%-23s %s\\n\", option, _(description));\n-\t}\n-#endif\n-      print_filtered_help (CL_TARGET);\n-      if (undoc)\n-\t{\n-\t  if (doc)\n-\t    printf (_(\"\\nThere are undocumented target specific options as well.\\n\"));\n-\t  else\n-\t    printf (_(\"  They exist, but they are not documented.\\n\"));\n-\t}\n-    }\n-}\n-\n /* Parse a -d... command line switch.  */\n \n void\n@@ -1193,64 +1078,6 @@ const char *const debug_type_names[] =\n   \"none\", \"stabs\", \"coff\", \"dwarf-2\", \"xcoff\", \"vms\"\n };\n \n-/* Decode -m switches.  */\n-/* Decode the switch -mNAME.  */\n-\n-void\n-set_target_switch (const char *name)\n-{\n-#if defined (TARGET_SWITCHES) || defined (TARGET_OPTIONS)\n-  size_t j;\n-#endif\n-  int valid_target_option = 0;\n-\n-#ifdef TARGET_SWITCHES\n-  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n-    if (!strcmp (target_switches[j].name, name))\n-      {\n-\tif (target_switches[j].value < 0)\n-\t  target_flags &= ~-target_switches[j].value;\n-\telse\n-\t  target_flags |= target_switches[j].value;\n-\tif (name[0] != 0)\n-\t  {\n-\t    if (target_switches[j].value < 0)\n-\t      target_flags_explicit |= -target_switches[j].value;\n-\t    else\n-\t      target_flags_explicit |= target_switches[j].value;\n-\t  }\n-\tvalid_target_option = 1;\n-      }\n-#endif\n-\n-#ifdef TARGET_OPTIONS\n-  if (!valid_target_option)\n-    for (j = 0; j < ARRAY_SIZE (target_options); j++)\n-      {\n-\tint len = strlen (target_options[j].prefix);\n-\tif (target_options[j].value)\n-\t  {\n-\t    if (!strcmp (target_options[j].prefix, name))\n-\t      {\n-\t\t*target_options[j].variable = target_options[j].value;\n-\t\tvalid_target_option = 1;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    if (!strncmp (target_options[j].prefix, name, len))\n-\t      {\n-\t\t*target_options[j].variable = name + len;\n-\t\tvalid_target_option = 1;\n-\t      }\n-\t  }\n-      }\n-#endif\n-\n-  if (name[0] != 0 && !valid_target_option)\n-    error (\"invalid option %qs\", name);\n-}\n-\n /* Print version information to FILE.\n    Each line begins with INDENT (for the case where FILE is the\n    assembler output file).  */\n@@ -1359,31 +1186,6 @@ print_switch_values (FILE *file, int pos, int max,\n       pos = print_single_switch (file, pos, max, indent, sep, term,\n \t\t\t\t \"\", cl_options[j].opt_text);\n \n-  /* Print target specific options.  */\n-\n-#ifdef TARGET_SWITCHES\n-  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n-    if (target_switches[j].name[0] != '\\0'\n-\t&& target_switches[j].value > 0\n-\t&& ((target_switches[j].value & target_flags)\n-\t    == target_switches[j].value))\n-      {\n-\tpos = print_single_switch (file, pos, max, indent, sep, term,\n-\t\t\t\t   \"-m\", target_switches[j].name);\n-      }\n-#endif\n-\n-#ifdef TARGET_OPTIONS\n-  for (j = 0; j < ARRAY_SIZE (target_options); j++)\n-    if (*target_options[j].variable != NULL)\n-      {\n-\tchar prefix[256];\n-\tsprintf (prefix, \"-m%s\", target_options[j].prefix);\n-\tpos = print_single_switch (file, pos, max, indent, sep, term,\n-\t\t\t\t   prefix, *target_options[j].variable);\n-      }\n-#endif\n-\n   fprintf (file, \"%s\", term);\n }\n \n@@ -1460,15 +1262,9 @@ default_get_pch_validity (size_t *len)\n   size_t i;\n   char *result, *r;\n \n-  *len = sizeof (target_flags) + 2;\n-#ifdef TARGET_OPTIONS\n-  for (i = 0; i < ARRAY_SIZE (target_options); i++)\n-    {\n-      *len += 1;\n-      if (*target_options[i].variable)\n-\t*len += strlen (*target_options[i].variable);\n-    }\n-#endif\n+  *len = 2;\n+  if (targetm.check_pch_target_flags)\n+    *len += sizeof (target_flags);\n   for (i = 0; i < cl_options_count; i++)\n     if (option_affects_pch_p (i, &state))\n       *len += state.size;\n@@ -1477,21 +1273,12 @@ default_get_pch_validity (size_t *len)\n   r[0] = flag_pic;\n   r[1] = flag_pie;\n   r += 2;\n-  memcpy (r, &target_flags, sizeof (target_flags));\n-  r += sizeof (target_flags);\n-\n-#ifdef TARGET_OPTIONS\n-  for (i = 0; i < ARRAY_SIZE (target_options); i++)\n+  if (targetm.check_pch_target_flags)\n     {\n-      const char *str = *target_options[i].variable;\n-      size_t l;\n-      if (! str)\n-\tstr = \"\";\n-      l = strlen (str) + 1;\n-      memcpy (r, str, l);\n-      r += l;\n+      memcpy (r, &target_flags, sizeof (target_flags));\n+      r += sizeof (target_flags);\n     }\n-#endif\n+\n   for (i = 0; i < cl_options_count; i++)\n     if (option_affects_pch_p (i, &state))\n       {\n@@ -1502,16 +1289,28 @@ default_get_pch_validity (size_t *len)\n   return result;\n }\n \n+/* Return a message which says that a PCH file was created with a different\n+   setting of OPTION.  */\n+\n+static const char *\n+pch_option_mismatch (const char *option)\n+{\n+  char *r;\n+\n+  asprintf (&r, _(\"created and used with differing settings of '%s'\"), option);\n+  if (r == NULL)\n+    return _(\"out of memory\");\n+  return r;\n+}\n+\n /* Default version of pch_valid_p.  */\n \n const char *\n default_pch_valid_p (const void *data_p, size_t len)\n {\n   struct cl_option_state state;\n   const char *data = (const char *)data_p;\n-  const char *flag_that_differs = NULL;\n   size_t i;\n-  int tf;\n \n   /* -fpic and -fpie also usually make a PCH invalid.  */\n   if (data[0] != flag_pic)\n@@ -1521,77 +1320,29 @@ default_pch_valid_p (const void *data_p, size_t len)\n   data += 2;\n \n   /* Check target_flags.  */\n-  memcpy (&tf, data, sizeof (target_flags));\n   if (targetm.check_pch_target_flags)\n     {\n-      const char *r = targetm.check_pch_target_flags (tf);\n+      int tf;\n+      const char *r;\n+\n+      memcpy (&tf, data, sizeof (target_flags));\n+      data += sizeof (target_flags);\n+      len -= sizeof (target_flags);\n+      r = targetm.check_pch_target_flags (tf);\n       if (r != NULL)\n \treturn r;\n     }\n-#ifdef TARGET_SWITCHES\n-  else if (tf != target_flags)\n-    {\n-      for (i = 0; i < ARRAY_SIZE (target_switches); i++)\n-\t{\n-\t  int bits;\n-\n-\t  bits = target_switches[i].value;\n-\t  if (bits < 0)\n-\t    bits = -bits;\n-\t  if ((target_flags & bits) != (tf & bits))\n-\t    {\n-\t      flag_that_differs = target_switches[i].name;\n-\t      goto make_message;\n-\t    }\n-\t}\n-      gcc_unreachable ();\n-    }\n-#endif\n-  data += sizeof (target_flags);\n-  len -= sizeof (target_flags);\n-\n-  /* Check string options.  */\n-#ifdef TARGET_OPTIONS\n-  for (i = 0; i < ARRAY_SIZE (target_options); i++)\n-    {\n-      const char *str = *target_options[i].variable;\n-      size_t l;\n-      if (! str)\n-\tstr = \"\";\n-      l = strlen (str) + 1;\n-      if (len < l || memcmp (data, str, l) != 0)\n-\t{\n-\t  flag_that_differs = target_options[i].prefix;\n-\t  goto make_message;\n-\t}\n-      data += l;\n-      len -= l;\n-    }\n-#endif\n \n   for (i = 0; i < cl_options_count; i++)\n     if (option_affects_pch_p (i, &state))\n       {\n \tif (memcmp (data, state.data, state.size) != 0)\n-\t  {\n-\t    flag_that_differs = cl_options[i].opt_text + 2;\n-\t    goto make_message;\n-\t  }\n+\t  return pch_option_mismatch (cl_options[i].opt_text);\n \tdata += state.size;\n \tlen -= state.size;\n       }\n \n   return NULL;\n-\n- make_message:\n-  {\n-    char *r;\n-    asprintf (&r, _(\"created and used with differing settings of '-m%s'\"),\n-\t\t  flag_that_differs);\n-    if (r == NULL)\n-      return _(\"out of memory\");\n-    return r;\n-  }\n }\n \n /* Default tree printer.   Handles declarations only.  */"}, {"sha": "7e759e16c63d4569696c12dc55d440888f86c413", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bacf5b96edee976363fed3b78ab5923a62cd9bbb/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=bacf5b96edee976363fed3b78ab5923a62cd9bbb", "patch": "@@ -138,9 +138,7 @@ extern int time_report;\n extern int flag_tree_based_profiling;\n \n /* Things to do with target switches.  */\n-extern void display_target_options (void);\n extern void print_version (FILE *, const char *);\n-extern void set_target_switch (const char *);\n extern void * default_get_pch_validity (size_t *);\n extern const char * default_pch_valid_p (const void *, size_t);\n "}]}