{"sha": "a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZiMjJlZWE1YjA1OWY5ZWFiMWE2YjEzZTJiZWE4NmJjMzA3NzkwNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-11-19T19:50:50Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-11-19T19:50:50Z"}, "message": "re PR fortran/78990 (ICE when assigning polymorphic array function result)\n\n2017-11-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/78990\n\t* expr.c (gfc_is_class_array_function): Renamed from\n\t'gfc_is_alloc_class_array_function' and modified to return true\n\tfor pointers as well as allocatable results.\n\t* gfortran.h : Change of name for prototype of above function.\n\t* trans-array.c (gfc_add_loop_ss_code): Force finalization of\n\tclass array results.\n\t(build_class_array_ref): Change assertion into a condition.\n\t(build_class_array_ref): Set the se class_vptr for class array\n\tfunction results.\n\t(gfc_walk_function_expr): Reference gfc_is_class_array_function\n\tas above.\n\t* trans-decl.c (get_proc_result): Move it up before\n\tgfc_trans_deferred_vars.\n\t(gfc_trans_deferred_vars): Nullify explicit return class arrays\n\ton entry.\n\t* trans-expr.c (gfc_conv_class_to_class): Allow conversion of\n\tclass array functions that have an se class_vptr and use it\n\tfor the result vptr.\n\t(gfc_conv_subref_array_arg): Rename reference to the above\n\tfunction.\n\t(gfc_conv_procedure_call): Ditto. Add the se pre block to the\n\tloop pre block before the function is evaluated. Do not\n\tfinalize class pointer results.\n\t(arrayfunc_assign_needs_temporary, gfc_trans_assignment_1) More\n\trenamed references.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_size): Ditto.\n\n2017-11-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/78990\n\t* gfortran.dg/class_67.f90: New test.\n\nFrom-SVN: r254936", "tree": {"sha": "40b3d92cc98089c0203d785b23eff11fa4d4902b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40b3d92cc98089c0203d785b23eff11fa4d4902b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/comments", "author": null, "committer": null, "parents": [{"sha": "77459763f49af6171d5512f71576f4d4d7640b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77459763f49af6171d5512f71576f4d4d7640b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77459763f49af6171d5512f71576f4d4d7640b28"}], "stats": {"total": 206, "additions": 168, "deletions": 38}, "files": [{"sha": "5dea20437e24b9484257b57df67889d495b978f0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -1,3 +1,33 @@\n+2017-11-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/78990\n+\t* expr.c (gfc_is_class_array_function): Renamed from\n+\t'gfc_is_alloc_class_array_function' and modified to return true\n+\tfor pointers as well as allocatable results.\n+\t* gfortran.h : Change of name for prototype of above function.\n+\t* trans-array.c (gfc_add_loop_ss_code): Force finalization of\n+\tclass array results.\n+\t(build_class_array_ref): Change assertion into a condition.\n+\t(build_class_array_ref): Set the se class_vptr for class array\n+\tfunction results.\n+\t(gfc_walk_function_expr): Reference gfc_is_class_array_function\n+\tas above.\n+\t* trans-decl.c (get_proc_result): Move it up before\n+\tgfc_trans_deferred_vars.\n+\t(gfc_trans_deferred_vars): Nullify explicit return class arrays\n+\ton entry.\n+\t* trans-expr.c (gfc_conv_class_to_class): Allow conversion of\n+\tclass array functions that have an se class_vptr and use it\n+\tfor the result vptr.\n+\t(gfc_conv_subref_array_arg): Rename reference to the above\n+\tfunction.\n+\t(gfc_conv_procedure_call): Ditto. Add the se pre block to the\n+\tloop pre block before the function is evaluated. Do not\n+\tfinalize class pointer results.\n+\t(arrayfunc_assign_needs_temporary, gfc_trans_assignment_1) More\n+\trenamed references.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_size): Ditto.\n+\n 2017-11-18  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/83036"}, {"sha": "428fce1ad045af2276465b1ab6bd37265b902626", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -4844,14 +4844,15 @@ gfc_is_alloc_class_scalar_function (gfc_expr *expr)\n /* Determine if an expression is a function with an allocatable class array\n    result.  */\n bool\n-gfc_is_alloc_class_array_function (gfc_expr *expr)\n+gfc_is_class_array_function (gfc_expr *expr)\n {\n   if (expr->expr_type == EXPR_FUNCTION\n       && expr->value.function.esym\n       && expr->value.function.esym->result\n       && expr->value.function.esym->result->ts.type == BT_CLASS\n       && CLASS_DATA (expr->value.function.esym->result)->attr.dimension\n-      && CLASS_DATA (expr->value.function.esym->result)->attr.allocatable)\n+      && (CLASS_DATA (expr->value.function.esym->result)->attr.allocatable\n+\t  || CLASS_DATA (expr->value.function.esym->result)->attr.pointer))\n     return true;\n \n   return false;"}, {"sha": "97db5b054e4cc705469e2b6fd11ea3e8b004820a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -3195,7 +3195,7 @@ gfc_param_spec_type gfc_spec_list_type (gfc_actual_arglist *, gfc_symbol *);\n gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);\n bool gfc_is_proc_ptr_comp (gfc_expr *);\n bool gfc_is_alloc_class_scalar_function (gfc_expr *);\n-bool gfc_is_alloc_class_array_function (gfc_expr *);\n+bool gfc_is_class_array_function (gfc_expr *);\n \n bool gfc_ref_this_image (gfc_ref *ref);\n bool gfc_is_coindexed (gfc_expr *);"}, {"sha": "9a814017c36237da2e099750d30ef31aa6a4b1b5", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -8740,6 +8740,9 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \tcode->expr1->symtree->n.sym->ts = code->expr2->ts;\n       selector_type = CLASS_DATA (code->expr2)->ts.u.derived;\n \n+      if (code->expr2->rank && CLASS_DATA (code->expr1)->as)\n+\tCLASS_DATA (code->expr1)->as->rank = code->expr2->rank;\n+\n       /* F2008: C803 The selector expression must not be coindexed.  */\n       if (gfc_is_coindexed (code->expr2))\n \t{"}, {"sha": "789e81ac92938f5ab9205bdcfca644e4b1d81e45", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -2791,6 +2791,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gfc_init_se (&se, NULL);\n \t  se.loop = loop;\n \t  se.ss = ss;\n+\t  if (gfc_is_class_array_function (expr))\n+\t    expr->must_finalize = 1;\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n@@ -3241,7 +3243,7 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n     {\n       if (expr == NULL\n \t  || (expr->ts.type != BT_CLASS\n-\t      && !gfc_is_alloc_class_array_function (expr)\n+\t      && !gfc_is_class_array_function (expr)\n \t      && !gfc_is_class_array_ref (expr, NULL)))\n \treturn false;\n \n@@ -3271,12 +3273,12 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n     }\n \n   if (class_ref == NULL && expr && expr->symtree->n.sym->attr.function\n-      && expr->symtree->n.sym == expr->symtree->n.sym->result)\n+      && expr->symtree->n.sym == expr->symtree->n.sym->result\n+      && expr->symtree->n.sym->backend_decl == current_function_decl)\n     {\n-      gcc_assert (expr->symtree->n.sym->backend_decl == current_function_decl);\n       decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);\n     }\n-  else if (expr && gfc_is_alloc_class_array_function (expr))\n+  else if (expr && gfc_is_class_array_function (expr))\n     {\n       size = NULL_TREE;\n       decl = NULL_TREE;\n@@ -3299,6 +3301,8 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n \n       if (decl == NULL_TREE)\n \treturn false;\n+\n+      se->class_vptr = gfc_evaluate_now (gfc_class_vptr_get (decl), &se->pre);\n     }\n   else if (class_ref == NULL)\n     {\n@@ -10527,7 +10531,7 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n   if (!sym)\n     sym = expr->symtree->n.sym;\n \n-  if (gfc_is_alloc_class_array_function (expr))\n+  if (gfc_is_class_array_function (expr))\n     return gfc_get_array_ss (ss, expr,\n \t\t\t     CLASS_DATA (expr->value.function.esym->result)->as->rank,\n \t\t\t     GFC_SS_FUNCTION);"}, {"sha": "5c248d06e57803186975ecb882794cd29cab5413", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -4161,6 +4161,24 @@ gfc_null_and_pass_deferred_len (gfc_symbol *sym, stmtblock_t *init,\n   return tmp;\n }\n \n+\n+/* Get the result expression for a procedure.  */\n+\n+static tree\n+get_proc_result (gfc_symbol* sym)\n+{\n+  if (sym->attr.subroutine || sym == sym->result)\n+    {\n+      if (current_fake_result_decl != NULL)\n+\treturn TREE_VALUE (current_fake_result_decl);\n+\n+      return NULL_TREE;\n+    }\n+\n+  return sym->result->backend_decl;\n+}\n+\n+\n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n     Allocation and initialization of array variables.\n@@ -4271,6 +4289,21 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n       else\n \tgcc_assert (flag_f2c && proc_sym->ts.type == BT_COMPLEX);\n     }\n+  else if (proc_sym == proc_sym->result && IS_CLASS_ARRAY (proc_sym))\n+    {\n+      /* Nullify explicit return class arrays on entry.  */\n+      tree type;\n+      tmp = get_proc_result (proc_sym);\n+\tif (tmp && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+\t  {\n+\t    gfc_start_block (&init);\n+\t    tmp = gfc_class_data_get (tmp);\n+\t    type = TREE_TYPE (gfc_conv_descriptor_data_get (tmp));\n+\t    gfc_conv_descriptor_data_set (&init, tmp, build_int_cst (type, 0));\n+\t    gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n+\t  }\n+    }\n+\n \n   /* Initialize the INTENT(OUT) derived type dummy arguments.  This\n      should be done here so that the offsets and lbounds of arrays\n@@ -6067,23 +6100,6 @@ create_main_function (tree fndecl)\n }\n \n \n-/* Get the result expression for a procedure.  */\n-\n-static tree\n-get_proc_result (gfc_symbol* sym)\n-{\n-  if (sym->attr.subroutine || sym == sym->result)\n-    {\n-      if (current_fake_result_decl != NULL)\n-\treturn TREE_VALUE (current_fake_result_decl);\n-\n-      return NULL_TREE;\n-    }\n-\n-  return sym->result->backend_decl;\n-}\n-\n-\n /* Generate an appropriate return-statement for a procedure.  */\n \n tree"}, {"sha": "92d37ec090199c90246ff044a5e658de3dda870e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -960,6 +960,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n     }\n \n   if ((ref == NULL || class_ref == ref)\n+      && !(gfc_is_class_array_function (e) && parmse->class_vptr != NULL_TREE)\n       && (!class_ts.u.derived->components->as\n \t  || class_ts.u.derived->components->as->rank != -1))\n     return;\n@@ -1030,8 +1031,11 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n      First we have to find the corresponding class reference.  */\n \n   tmp = NULL_TREE;\n-  if (class_ref == NULL\n-\t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n+  if (gfc_is_class_array_function (e)\n+      && parmse->class_vptr != NULL_TREE)\n+    tmp = parmse->class_vptr;\n+  else if (class_ref == NULL\n+\t   && e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n     {\n       tmp = e->symtree->n.sym->backend_decl;\n \n@@ -1063,7 +1067,11 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n   if (TREE_CODE (TREE_TYPE (tmp)) == REFERENCE_TYPE)\n     tmp = build_fold_indirect_ref_loc (input_location, tmp);\n \n-  vptr = gfc_class_vptr_get (tmp);\n+  if (!(gfc_is_class_array_function (e) && parmse->class_vptr))\n+    vptr = gfc_class_vptr_get (tmp);\n+  else\n+    vptr = tmp;\n+\n   gfc_add_modify (&block, ctree,\n \t\t  fold_convert (TREE_TYPE (ctree), vptr));\n \n@@ -4435,7 +4443,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   /* Reset the offset for the function call since the loop\n      is zero based on the data pointer.  Note that the temp\n      comes first in the loop chain since it is added second.  */\n-  if (gfc_is_alloc_class_array_function (expr))\n+  if (gfc_is_class_array_function (expr))\n     {\n       tmp = loop.ss->loop_chain->info->data.array.descriptor;\n       gfc_conv_descriptor_offset_set (&loop.pre, tmp,\n@@ -4484,7 +4492,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   dimen = rse.ss->dimen;\n \n   /* Skip the write-out loop for this case.  */\n-  if (gfc_is_alloc_class_array_function (expr))\n+  if (gfc_is_class_array_function (expr))\n     goto class_array_fcn;\n \n   /* Calculate the bounds of the scalarization.  */\n@@ -4778,7 +4786,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      gcc_assert ((!comp && gfc_return_by_reference (sym)\n \t\t\t   && sym->result->attr.dimension)\n \t\t\t  || (comp && comp->attr.dimension)\n-\t\t\t  || gfc_is_alloc_class_array_function (expr));\n+\t\t\t  || gfc_is_class_array_function (expr));\n \t      gcc_assert (se->loop != NULL);\n \t      /* Access the previously obtained result.  */\n \t      gfc_conv_tmp_array_ref (se);\n@@ -5462,7 +5470,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n \n-\t      else if (gfc_is_alloc_class_array_function (e)\n+\t      else if (gfc_is_class_array_function (e)\n \t\t\t && fsym && fsym->ts.type == BT_DERIVED)\n \t\t/* See previous comment.  For function actual argument,\n \t\t   the write out is not needed so the intent is set as\n@@ -6304,7 +6312,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t call the finalization function of the temporary. Note that the\n \t nullification of allocatable components needed by the result\n \t is done in gfc_trans_assignment_1.  */\n-      if (expr && ((gfc_is_alloc_class_array_function (expr)\n+      if (expr && ((gfc_is_class_array_function (expr)\n \t\t    && se->ss && se->ss->loop)\n \t\t   || gfc_is_alloc_class_scalar_function (expr))\n \t  && se->expr && GFC_CLASS_TYPE_P (TREE_TYPE (se->expr))\n@@ -6315,6 +6323,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  int n;\n \t  if (se->ss && se->ss->loop)\n \t    {\n+\t      gfc_add_block_to_block (&se->ss->loop->pre, &se->pre);\n \t      se->expr = gfc_evaluate_now (se->expr, &se->ss->loop->pre);\n \t      tmp = gfc_class_data_get (se->expr);\n \t      info->descriptor = tmp;\n@@ -6337,6 +6346,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\tCLASS_DATA (expr->value.function.esym->result)->attr);\n \t    }\n \n+\t  if ((gfc_is_class_array_function (expr)\n+\t       || gfc_is_alloc_class_scalar_function (expr))\n+\t      && CLASS_DATA (expr->value.function.esym->result)->attr.pointer)\n+\t    goto no_finalization;\n+\n \t  final_fndecl = gfc_class_vtab_final_get (se->expr);\n \t  is_final = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t      logical_type_node,\n@@ -6367,6 +6381,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      tmp = gfc_call_free (tmp);\n \t      gfc_add_expr_to_block (&se->post, tmp);\n \t    }\n+\n+no_finalization:\n \t  expr->must_finalize = 0;\n \t}\n \n@@ -8887,7 +8903,7 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_symbol *sym = expr1->symtree->n.sym;\n \n   /* Play it safe with class functions assigned to a derived type.  */\n-  if (gfc_is_alloc_class_array_function (expr2)\n+  if (gfc_is_class_array_function (expr2)\n       && expr1->ts.type == BT_DERIVED)\n     return true;\n \n@@ -9894,7 +9910,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   rss = NULL;\n \n   if ((expr1->ts.type == BT_DERIVED)\n-      && (gfc_is_alloc_class_array_function (expr2)\n+      && (gfc_is_class_array_function (expr2)\n \t  || gfc_is_alloc_class_scalar_function (expr2)))\n     expr2->must_finalize = 1;\n \n@@ -10101,7 +10117,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n      a scalar to array assignment, this is done in gfc_trans_scalar_assign\n      as part of the deep copy.  */\n   if (!scalar_to_array && expr1->ts.type == BT_DERIVED\n-\t\t       && (gfc_is_alloc_class_array_function (expr2)\n+\t\t       && (gfc_is_class_array_function (expr2)\n \t\t\t   || gfc_is_alloc_class_scalar_function (expr2)))\n     {\n       tmp = rse.expr;"}, {"sha": "b7c57210b8cff3d4dd8f3e5ce7421490f972f2a2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -6603,7 +6603,7 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n     gfc_add_class_array_ref (actual->expr);\n \n   argse.data_not_needed = 1;\n-  if (gfc_is_alloc_class_array_function (actual->expr))\n+  if (gfc_is_class_array_function (actual->expr))\n     {\n       /* For functions that return a class array conv_expr_descriptor is not\n \t able to get the descriptor right.  Therefore this special case.  */"}, {"sha": "ebdf42bea5f01c8e7ccae53746315644cab9d4ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -1,3 +1,8 @@\n+2017-11-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/78990\n+\t* gfortran.dg/class_67.f90: New test.\n+\n 2017-11-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR target/82713\n@@ -270,7 +275,7 @@\n \t* g++.dg/torture/pr82985.C: Likewise.\n \n 2017-11-15  Sebastian Peryt  <sebastian.peryt@intel.com>\n-\t\n+\n \tPR target/82941\n \tPR target/82942\n \t* gcc.target/i386/pr82941-1.c: New test."}, {"sha": "20029939d641ec4e0850662752550fdb563b788e", "filename": "gcc/testsuite/gfortran.dg/class_67.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_67.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b22eea5b059f9eab1a6b13e2bea86bc3077906/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_67.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_67.f90?ref=a6b22eea5b059f9eab1a6b13e2bea86bc3077906", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR78990 in which the scalarization of the assignment\n+! in the main program failed for two reasons: (i) The conversion of 'v1'\n+! into a class actual was being done after the call to 'return_t1', giving\n+! rise to the ICE reported in comment #1; and (ii) The 'info' descriptor,\n+! required for scalarization was not set, which gave rise to the ICE noted\n+! by the contributor.\n+!\n+! Contributed by Chris Macmackin  <cmacmackin@gmail.com>\n+!\n+module test_type\n+  implicit none\n+\n+  type t1\n+     integer :: i\n+   contains\n+     procedure :: assign\n+     generic :: assignment(=) => assign\n+  end type t1\n+\n+contains\n+\n+  elemental subroutine assign(this,rhs)\n+    class(t1), intent(inout) :: this\n+    class(t1), intent(in) :: rhs\n+    this%i = rhs%i\n+  end subroutine assign\n+\n+  function return_t1(arg)\n+    class(t1), dimension(:), intent(in) :: arg\n+    class(t1), dimension(:), allocatable :: return_t1\n+    allocate(return_t1(size(arg)), source=arg)\n+  end function return_t1\n+\n+  function return_t1_p(arg)\n+    class(t1), dimension(:), intent(in), target :: arg\n+    class(t1), dimension(:), pointer :: return_t1_p\n+    return_t1_p => arg\n+  end function return_t1_p\n+end module test_type\n+\n+program test\n+  use test_type\n+  implicit none\n+\n+  type(t1), dimension(3) :: v1, v2\n+  v1%i = [1,2,3]\n+  v2 = return_t1(v1)\n+  if (any (v2%i .ne. v1%i)) call abort\n+\n+  v1%i = [4,5,6]\n+  v2 = return_t1_p(v1)\n+  if (any (v2%i .ne. v1%i)) call abort\n+end program test"}]}