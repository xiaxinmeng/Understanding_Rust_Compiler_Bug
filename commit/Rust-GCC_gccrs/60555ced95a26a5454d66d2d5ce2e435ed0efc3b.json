{"sha": "60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA1NTVjZWQ5NWEyNmE1NDU0ZDY2ZDJkNWNlMmU0MzVlZDBlZmMzYg==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-04-16T12:54:01Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-04-16T12:54:01Z"}, "message": "tree-vect-analyze.c (vect_analyze_operations): Reorganize calls to vectorizable_* functions.\n\n        * tree-vect-analyze.c (vect_analyze_operations): Reorganize calls to\n        vectorizable_* functions.\n        * tree-vect-transform.c (vectorizable_call): Add check for\n        STMT_VINFO_RELEVANT_P, STMT_VINFO_DEF_TYPE and STMT_VINFO_LIVE_P.\n        (vectorizable_store): likewise.\n        (vectorizable_conversion): Add check for STMT_VINFO_DEF_TYPE.\n        Add comments.\n        (vectorizable_operation, vectorizable_type_demotion): Likewise.\n        (vectorizable_type_promotion, vectorizable_load): Likewise.\n        (vectorizable_live_operation, vectorizable_condition): Likewise.\n        (vectorizable_assignment): Add check for STMT_VINFO_DEF_TYPE and\n        STMT_VINFO_LIVE_P.\n        (vect_transform_stmt): Reorganize calls to vectorizable_* functions.\n\nFrom-SVN: r123861", "tree": {"sha": "17cc8ff8ac97ad1036c69119e83024551d63d5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17cc8ff8ac97ad1036c69119e83024551d63d5ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/comments", "author": null, "committer": null, "parents": [{"sha": "20280c6f0e16d5b34263482e813c570f47b359e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20280c6f0e16d5b34263482e813c570f47b359e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20280c6f0e16d5b34263482e813c570f47b359e4"}], "stats": {"total": 380, "additions": 219, "deletions": 161}, "files": [{"sha": "ecce3615016e3273c7bae1f69d8b64fb1d068aed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "patch": "@@ -1,3 +1,19 @@\n+2007-04-16  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (vect_analyze_operations): Reorganize calls to\n+\tvectorizable_* functions.\n+\t* tree-vect-transform.c (vectorizable_call): Add check for\n+\tSTMT_VINFO_RELEVANT_P, STMT_VINFO_DEF_TYPE and STMT_VINFO_LIVE_P.\n+\t(vectorizable_store): likewise.\n+\t(vectorizable_conversion): Add check for STMT_VINFO_DEF_TYPE.\n+\tAdd comments.\n+\t(vectorizable_operation, vectorizable_type_demotion): Likewise.\n+\t(vectorizable_type_promotion, vectorizable_load): Likewise.\n+\t(vectorizable_live_operation, vectorizable_condition): Likewise.\n+\t(vectorizable_assignment): Add check for STMT_VINFO_DEF_TYPE and\n+\tSTMT_VINFO_LIVE_P.\n+\t(vect_transform_stmt): Reorganize calls to vectorizable_* functions.\n+\n 2007-04-15  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/m68k/linux.h (FUNCTION_VALUE_REGNO_P): Use macros for"}, {"sha": "e7dff736325b98cebb309333aaca76c041162bf1", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "patch": "@@ -325,8 +325,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      /* FORNOW: not yet supported.  */\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\tfprintf (vect_dump, \"not vectorized: value used after loop.\");\n-\t    return false;\n-\t  }\n+\t      return false;\n+\t    }\n \n \t  if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_loop\n \t      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n@@ -337,12 +337,16 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t        fprintf (vect_dump, \"not vectorized: unsupported pattern.\");\n  \t     return false;\n \t    }\n+\n+\t  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+\t    need_to_vectorize = true;\n \t}\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  enum vect_def_type relevance = STMT_VINFO_RELEVANT (stmt_info);\n \n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n@@ -367,55 +371,57 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      continue;\n \t    }\n \n-          if (STMT_VINFO_RELEVANT_P (stmt_info))\n-            {\n-              gcc_assert (GIMPLE_STMT_P (stmt)\n-\t\t  \t  || !VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n-              gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n-\n-\t      ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n-\t\t    || vectorizable_type_demotion (stmt, NULL, NULL)\n-\t\t    || vectorizable_conversion (stmt, NULL, NULL)\n-\t\t    || vectorizable_operation (stmt, NULL, NULL)\n-\t\t    || vectorizable_assignment (stmt, NULL, NULL)\n-\t\t    || vectorizable_load (stmt, NULL, NULL)\n-\t\t    || vectorizable_call (stmt, NULL, NULL)\n-\t\t    || vectorizable_store (stmt, NULL, NULL)\n-\t\t    || vectorizable_condition (stmt, NULL, NULL));\n-\n-\t      if (!ok)\n-\t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t\t    {\n-\t\t      fprintf (vect_dump, \n-\t\t\t       \"not vectorized: relevant stmt not supported: \");\n-\t\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t    }\n-\t\t  return false;\n-\t\t}\t\n-\t      need_to_vectorize = true;\n-            }\n-\n-\t  if (STMT_VINFO_LIVE_P (stmt_info))\n+\t  switch (STMT_VINFO_DEF_TYPE (stmt_info))\n \t    {\n-\t      ok = vectorizable_reduction (stmt, NULL, NULL);\n+ \t    case vect_loop_def:\n+\t      break;\n+\t\n+\t    case vect_reduction_def:\n+\t      gcc_assert (relevance == vect_unused_in_loop);\n+\t      break;\t\n+\n+\t    case vect_induction_def:\n+\t    case vect_constant_def:\n+\t    case vect_invariant_def:\n+\t    case vect_unknown_def_type:\n+\t    default:\n+\t      gcc_unreachable ();\t\n+\t    }\n \n-\t      if (ok)\n-                need_to_vectorize = true;\n-              else\n-\t        ok = vectorizable_live_operation (stmt, NULL, NULL);\n+\t  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+\t    {\n+\t      gcc_assert (GIMPLE_STMT_P (stmt)\n+\t\t\t  || !VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))));\n+\t      gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n+\t      need_to_vectorize = true;\n+\t    }\n \n-\t      if (!ok)\n+\t  ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n+\t\t|| vectorizable_type_demotion (stmt, NULL, NULL)\n+\t\t|| vectorizable_conversion (stmt, NULL, NULL)\n+\t\t|| vectorizable_operation (stmt, NULL, NULL)\n+\t\t|| vectorizable_assignment (stmt, NULL, NULL)\n+\t\t|| vectorizable_load (stmt, NULL, NULL)\n+\t\t|| vectorizable_call (stmt, NULL, NULL)\n+\t\t|| vectorizable_store (stmt, NULL, NULL)\n+\t\t|| vectorizable_condition (stmt, NULL, NULL)\n+\t\t|| vectorizable_reduction (stmt, NULL, NULL));\n+\n+\t  /* Stmts that are (also) \"live\" (i.e. - that are used out of the loop)\n+\t     need extra handling, except for vectorizable reductions.  */\n+\t  if (STMT_VINFO_LIVE_P (stmt_info)\n+\t      && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type) \n+\t    ok |= vectorizable_live_operation (stmt, NULL, NULL);\n+\n+\t  if (!ok)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t\t    {\n-\t\t      fprintf (vect_dump, \n-\t\t\t       \"not vectorized: live stmt not supported: \");\n-\t\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t    }\n-\t\t  return false;\n+\t\t  fprintf (vect_dump, \"not vectorized: stmt not supported: \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t\t}\n-\t    }\n+\t      return false;\n+\t    }\t\n \t} /* stmts in bb */\n     } /* bbs */\n "}, {"sha": "32fe626180ce40345d6254d86cfc7f111c7251e4", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 151, "deletions": 115, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60555ced95a26a5454d66d2d5ce2e435ed0efc3b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=60555ced95a26a5454d66d2d5ce2e435ed0efc3b", "patch": "@@ -1816,6 +1816,20 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int ncopies, j, nargs;\n   call_expr_arg_iterator iter;\n \n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n+\n+  /* FORNOW: not yet supported.  */\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n   /* Is STMT a vectorizable call?   */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n@@ -1994,7 +2008,8 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n \n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n@@ -2134,12 +2149,21 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (ncopies > 1)\n     return false; /* FORNOW */\n \n-  /* Is vectorizable assignment?  */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n+\n+  /* FORNOW: not yet supported.  */\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n \n+  /* Is vectorizable assignment?  */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n@@ -2246,20 +2270,21 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   gcc_assert (ncopies >= 1);\n \n-  /* Is STMT a vectorizable binary/unary operation?   */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n \n+  /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      /* FORNOW: not yet supported.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n \n+  /* Is STMT a vectorizable binary/unary operation?   */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n@@ -2514,21 +2539,21 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   optab optab;\n   enum machine_mode vec_mode;\n                                                                                 \n-  /* Is STMT a vectorizable type-demotion operation?  */\n-                                                                                \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n-                                                                                \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n-                                                                                \n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n+\n+  /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      /* FORNOW: not yet supported.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n                                                                                 \n+  /* Is STMT a vectorizable type-demotion operation?  */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n                                                                                 \n@@ -2723,21 +2748,21 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   int j;\n   tree vectype_in;\n   \n-  /* Is STMT a vectorizable type-promotion operation?  */\n-\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n \n+  /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      /* FORNOW: not yet supported.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"value used after loop.\");\n+        fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n \n+  /* Is STMT a vectorizable type-promotion operation?  */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n@@ -3064,6 +3089,19 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   VEC(tree,heap) *dr_chain = NULL, *oprnds = NULL, *result_chain = NULL;\n   gcc_assert (ncopies >= 1);\n \n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n   /* Is vectorizable store? */\n \n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n@@ -3710,20 +3748,21 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   bool strided_load = false;\n   tree first_stmt;\n \n-  /* Is vectorizable load? */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n \n+  /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      /* FORNOW: not yet supported.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n \n+  /* Is vectorizable load? */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n@@ -4010,7 +4049,9 @@ vectorizable_live_operation (tree stmt,\n   tree def, def_stmt;\n   enum vect_def_type dt; \n \n-  if (!STMT_VINFO_LIVE_P (stmt_info))\n+  gcc_assert (STMT_VINFO_LIVE_P (stmt_info));\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n     return false;\n \n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n@@ -4123,16 +4164,18 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_loop_def);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+    return false;\n \n+  /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      /* FORNOW: not yet supported.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n \n+  /* Is vectorizable conditional operation?  */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n \n@@ -4225,110 +4268,103 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n   tree orig_stmt_in_pattern;\n   bool done;\n \n-  if (STMT_VINFO_RELEVANT_P (stmt_info))\n+  switch (STMT_VINFO_TYPE (stmt_info))\n     {\n-      switch (STMT_VINFO_TYPE (stmt_info))\n-      {\n-      case type_demotion_vec_info_type:\n-        done = vectorizable_type_demotion (stmt, bsi, &vec_stmt);\n-        gcc_assert (done);\n-        break;\n+    case type_demotion_vec_info_type:\n+      done = vectorizable_type_demotion (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n                                                                                 \n-      case type_promotion_vec_info_type:\n-\tdone = vectorizable_type_promotion (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tbreak;\n-\n-      case type_conversion_vec_info_type:\n-\tdone = vectorizable_conversion (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tbreak;\n-\n-      case op_vec_info_type:\n-\tdone = vectorizable_operation (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tbreak;\n-\n-      case assignment_vec_info_type:\n-\tdone = vectorizable_assignment (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tbreak;\n-\n-      case load_vec_info_type:\n-\tdone = vectorizable_load (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tbreak;\n-\n-      case store_vec_info_type:\n-\tdone = vectorizable_store (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tif (DR_GROUP_FIRST_DR (stmt_info))\n-\t  {\n-\t    /* In case of interleaving, the whole chain is vectorized when the\n-\t       last store in the chain is reached. Store stmts before the last\n-\t       one are skipped, and there vec_stmt_info shouldn't be freed\n-\t       meanwhile.  */\n-\t    *strided_store = true;\n-\t    if (STMT_VINFO_VEC_STMT (stmt_info))\n-\t      is_store = true;\n+    case type_promotion_vec_info_type:\n+      done = vectorizable_type_promotion (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case type_conversion_vec_info_type:\n+      done = vectorizable_conversion (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case op_vec_info_type:\n+      done = vectorizable_operation (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case assignment_vec_info_type:\n+      done = vectorizable_assignment (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case load_vec_info_type:\n+      done = vectorizable_load (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case store_vec_info_type:\n+      done = vectorizable_store (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      if (DR_GROUP_FIRST_DR (stmt_info))\n+\t{\n+\t  /* In case of interleaving, the whole chain is vectorized when the\n+\t     last store in the chain is reached. Store stmts before the last\n+\t     one are skipped, and there vec_stmt_info shouldn't be freed\n+\t     meanwhile.  */\n+\t  *strided_store = true;\n+\t  if (STMT_VINFO_VEC_STMT (stmt_info))\n+\t    is_store = true;\n \t  }\n-\telse\n-\t  is_store = true;\n-\tbreak;\n+      else\n+\tis_store = true;\n+      break;\n \n-      case condition_vec_info_type:\n-\tdone = vectorizable_condition (stmt, bsi, &vec_stmt);\n-\tgcc_assert (done);\n-\tbreak;\n+    case condition_vec_info_type:\n+      done = vectorizable_condition (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n \n-      case call_vec_info_type:\n-\tdone = vectorizable_call (stmt, bsi, &vec_stmt);\n-\tbreak;\n+    case call_vec_info_type:\n+      done = vectorizable_call (stmt, bsi, &vec_stmt);\n+      break;\n \n-      default:\n-\tif (vect_print_dump_info (REPORT_DETAILS))\n-\t  fprintf (vect_dump, \"stmt not supported.\");\n-\tgcc_unreachable ();\n-      }\n+    case reduc_vec_info_type:\n+      done = vectorizable_reduction (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n \n-      gcc_assert (vec_stmt || *strided_store);\n-      if (vec_stmt)\n+    default:\n+      if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{\n-\t  STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n-\t  orig_stmt_in_pattern = STMT_VINFO_RELATED_STMT (stmt_info);\n-\t  if (orig_stmt_in_pattern)\n-\t    {\n-\t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt_in_pattern);\n-\t      if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-\t\t{\n-\t\t  gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n-\t\t  \n-\t\t  /* STMT was inserted by the vectorizer to replace a \n-\t\t     computation idiom.  ORIG_STMT_IN_PATTERN is a stmt in the \n-\t\t     original sequence that computed this idiom.  We need to \n-\t\t     record a pointer to VEC_STMT in the stmt_info of \n-\t\t     ORIG_STMT_IN_PATTERN.  See more details in the \n-\t\t     documentation of vect_pattern_recog.  */\n-\n-\t\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = vec_stmt;\n-\t\t}\n-\t    }\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"stmt not supported.\");\n+\t  gcc_unreachable ();\n \t}\n     }\n \n-  if (STMT_VINFO_LIVE_P (stmt_info))\n+  if (STMT_VINFO_LIVE_P (stmt_info)\n+      && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n     {\n-      switch (STMT_VINFO_TYPE (stmt_info))\n-      {\n-      case reduc_vec_info_type:\n-        done = vectorizable_reduction (stmt, bsi, &vec_stmt);\n-        gcc_assert (done);\n-        break;\n-\n-      default:\n-        done = vectorizable_live_operation (stmt, bsi, &vec_stmt);\n-        gcc_assert (done);\n-      }\n+      done = vectorizable_live_operation (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+    }\n+\n+  if (vec_stmt)\n+    {\n+      STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+      orig_stmt_in_pattern = STMT_VINFO_RELATED_STMT (stmt_info);\n+      if (orig_stmt_in_pattern)\n+\t{\n+\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt_in_pattern);\n+\t  /* STMT was inserted by the vectorizer to replace a computation idiom.\n+\t     ORIG_STMT_IN_PATTERN is a stmt in the original sequence that \n+\t     computed this idiom.  We need to record a pointer to VEC_STMT in \n+\t     the stmt_info of ORIG_STMT_IN_PATTERN.  See more details in the \n+\t     documentation of vect_pattern_recog.  */\n+\t  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+\t    {\n+\t      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n+\t      STMT_VINFO_VEC_STMT (stmt_vinfo) = vec_stmt;\n+\t    }\n+\t}\n     }\n \n   return is_store; "}]}