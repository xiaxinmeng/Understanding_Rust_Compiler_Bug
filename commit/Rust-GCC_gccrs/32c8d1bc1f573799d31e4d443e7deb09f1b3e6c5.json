{"sha": "32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJjOGQxYmMxZjU3Mzc5OWQzMWU0ZDQ0M2U3ZGViMDlmMWIzZTZjNQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-11-05T23:07:21Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-11-05T23:07:21Z"}, "message": "global.c (EXECUTE_IF_SET_IN_ALLOCNO_SET): New macro.\n\n\t* global.c (EXECUTE_IF_SET_IN_ALLOCNO_SET): New macro.\n\t(EXECUTE_IF_CONFLICT): Likewise.\n\t(ALLOCNO_LIVE_P): Avoid signed division.\n\t(SET_ALLOCNO_LIVE, CLEAR_ALLOCNO_LIVE): Likewise.\n\t(prune_preferences, find_reg): Use EXECUTE_IF_CONFLICT.\n\t(record_one_conflict): Use EXECUTE_IF_SET_IN_ALLOCNO_SET.\n\nFrom-SVN: r30425", "tree": {"sha": "ab832ecfe98c529ce16c65763ef02f8cd813bdbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab832ecfe98c529ce16c65763ef02f8cd813bdbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5/comments", "author": null, "committer": null, "parents": [{"sha": "36a6e29fbb22ddc000f5d53c202dbd987fa0c188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a6e29fbb22ddc000f5d53c202dbd987fa0c188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a6e29fbb22ddc000f5d53c202dbd987fa0c188"}], "stats": {"total": 96, "additions": 62, "deletions": 34}, "files": [{"sha": "50ef7930104509dfb233fc73a37e49e26cd663aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "patch": "@@ -1,3 +1,12 @@\n+Fri Nov  5 18:33:39 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* global.c (EXECUTE_IF_SET_IN_ALLOCNO_SET): New macro.\n+\t(EXECUTE_IF_CONFLICT): Likewise.\n+\t(ALLOCNO_LIVE_P): Avoid signed division.\n+\t(SET_ALLOCNO_LIVE, CLEAR_ALLOCNO_LIVE): Likewise.\n+\t(prune_preferences, find_reg): Use EXECUTE_IF_CONFLICT.\n+\t(record_one_conflict): Use EXECUTE_IF_SET_IN_ALLOCNO_SET.\n+\n Fri Nov  5 12:04:02 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* haifa-sched.c (schedule_block): Don't crash if there's no"}, {"sha": "b36cb1b97ab934cf6cff91ed30712c03a66fc721", "filename": "gcc/global.c", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=32c8d1bc1f573799d31e4d443e7deb09f1b3e6c5", "patch": "@@ -133,6 +133,34 @@ static int allocno_row_words;\n  (conflicts[(I) * allocno_row_words + (unsigned)(J) / INT_BITS]\t\\\n   |= ((INT_TYPE) 1 << ((unsigned)(J) % INT_BITS)))\n \n+/* For any allocno set in ALLOCNO_SET, set ALLOCNO to that allocno,\n+   and execute CODE.  */\n+#define EXECUTE_IF_SET_IN_ALLOCNO_SET(ALLOCNO_SET, ALLOCNO, CODE)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  int i_;\t\t\t\t\t\t\t\t\\\n+  int allocno_;\t\t\t\t\t\t\t\t\\\n+  INT_TYPE *p_ = (ALLOCNO_SET);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (i_ = allocno_row_words - 1, allocno_ = 0; i_ >= 0;\t\t\\\n+       i_--, allocno_ += INT_BITS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      unsigned INT_TYPE word_ = (unsigned INT_TYPE) *p_++;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for ((ALLOCNO) = allocno_; word_; word_ >>= 1, (ALLOCNO)++)\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (word_ & 1)\t\t\t\t\t\t\\\n+\t    CODE;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* For any allocno that conflicts with IN_ALLOCNO, set OUT_ALLOCNO to\n+   the conflicting allocno, and execute CODE.  This macro assumes that\n+   mirror_conflicts has been run.  */\n+#define EXECUTE_IF_CONFLICT(IN_ALLOCNO, OUT_ALLOCNO, CODE)\\\n+  EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + (IN_ALLOCNO) * allocno_row_words,\\\n+\t\t\t\t OUT_ALLOCNO, CODE)\n+\n /* Set of hard regs currently live (during scan of all insns).  */\n \n static HARD_REG_SET hard_regs_live;\n@@ -212,14 +240,17 @@ static INT_TYPE *allocnos_live;\n /* Test, set or clear bit number I in allocnos_live,\n    a bit vector indexed by allocno.  */\n \n-#define ALLOCNO_LIVE_P(I) \\\n-  (allocnos_live[(I) / INT_BITS] & ((INT_TYPE) 1 << ((I) % INT_BITS)))\n+#define ALLOCNO_LIVE_P(I)\t\t\t\t\\\n+  (allocnos_live[(unsigned)(I) / INT_BITS]\t\t\\\n+   & ((INT_TYPE) 1 << ((unsigned)(I) % INT_BITS)))\n \n-#define SET_ALLOCNO_LIVE(I) \\\n-  (allocnos_live[(I) / INT_BITS] |= ((INT_TYPE) 1 << ((I) % INT_BITS)))\n+#define SET_ALLOCNO_LIVE(I)\t\t\t\t\\\n+  (allocnos_live[(unsigned)(I) / INT_BITS]\t\t\\\n+     |= ((INT_TYPE) 1 << ((unsigned)(I) % INT_BITS)))\n \n-#define CLEAR_ALLOCNO_LIVE(I) \\\n-  (allocnos_live[(I) / INT_BITS] &= ~((INT_TYPE) 1 << ((I) % INT_BITS)))\n+#define CLEAR_ALLOCNO_LIVE(I)\t\t\t\t\\\n+  (allocnos_live[(unsigned)(I) / INT_BITS]\t\t\\\n+     &= ~((INT_TYPE) 1 << ((unsigned)(I) % INT_BITS)))\n \n /* This is turned off because it doesn't work right for DImode.\n    (And it is only used for DImode, so the other cases are worthless.)\n@@ -854,7 +885,7 @@ expand_preferences ()\n static void\n prune_preferences ()\n {\n-  int i, j;\n+  int i;\n   int allocno;\n   int *allocno_to_order = (int *) xmalloc (max_allocno * sizeof (int));\n   \n@@ -893,33 +924,23 @@ prune_preferences ()\n \t we want to give the lower-priority allocno the first chance for\n \t these registers).  */\n       HARD_REG_SET temp, temp2;\n-      INT_TYPE *p;\n-      int allocno2, allocno3;\n+      int allocno2;\n \n       allocno = allocno_order[i];\n-      p = conflicts + allocno * allocno_row_words;\n \n       CLEAR_HARD_REG_SET (temp);\n       CLEAR_HARD_REG_SET (temp2);\n \n-      for (j = allocno_row_words - 1, allocno2 = 0; j >= 0;\n-\t   j--, allocno2 += INT_BITS)\n+      EXECUTE_IF_CONFLICT (allocno, allocno2,\n \t{\n-\t  unsigned INT_TYPE word = (unsigned INT_TYPE) *p++;\n-\n-\t  for (allocno3 = allocno2; word; word >>= 1, allocno3++)\n+\t  if (allocno_to_order[allocno2] > i)\n \t    {\n-\t      if ((word & 1) && allocno_to_order[allocno3] > i)\n-\t\t{\n-\t\t  if (allocno_size[allocno3] <= allocno_size[allocno])\n-\t\t    IOR_HARD_REG_SET (temp,\n-\t\t\t\t      hard_reg_full_preferences[allocno3]);\n-\t\t  else\n-\t\t    IOR_HARD_REG_SET (temp2,\n-\t\t\t\t      hard_reg_full_preferences[allocno3]);\n-\t\t}\n+\t      if (allocno_size[allocno2] <= allocno_size[allocno])\n+\t\tIOR_HARD_REG_SET (temp, hard_reg_full_preferences[allocno2]);\n+\t      else\n+\t\tIOR_HARD_REG_SET (temp2, hard_reg_full_preferences[allocno2]);\n \t    }\n-\t}\n+\t});\n \n       AND_COMPL_HARD_REG_SET (temp, hard_reg_full_preferences[allocno]);\n       IOR_HARD_REG_SET (temp, temp2);\n@@ -1240,11 +1261,10 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n       /* For each other pseudo-reg conflicting with this one,\n \t mark it as conflicting with the hard regs this one occupies.  */\n       lim = allocno;\n-      for (j = 0; j < max_allocno; j++)\n-\tif (CONFLICTP (j, lim))\n-\t  {\n-\t    IOR_HARD_REG_SET (hard_reg_conflicts[j], this_reg);\n-\t  }\n+      EXECUTE_IF_CONFLICT (lim, j,\n+\t{\n+\t  IOR_HARD_REG_SET (hard_reg_conflicts[j], this_reg);\n+\t});\n     }\n }\n \f\n@@ -1297,11 +1317,10 @@ record_one_conflict (regno)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     /* When a hard register becomes live,\n        record conflicts with live pseudo regs.  */\n-    for (j = 0; j < max_allocno; j++)\n+    EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, j,\n       {\n-\tif (ALLOCNO_LIVE_P (j))\n-\t  SET_HARD_REG_BIT (hard_reg_conflicts[j], regno);\n-      }\n+\tSET_HARD_REG_BIT (hard_reg_conflicts[j], regno);\n+      });\n   else\n     /* When a pseudo-register becomes live,\n        record conflicts first with hard regs,"}]}