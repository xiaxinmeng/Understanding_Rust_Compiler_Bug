{"sha": "f46faa08530f834488a7ab292af8946005d3b153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ2ZmFhMDg1MzBmODM0NDg4YTdhYjI5MmFmODk0NjAwNWQzYjE1Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:45:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:45:00Z"}, "message": "[multiple changes]\n\n2011-08-04  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch7.adb (Expand_N_Package_Body, Expand_N_Package_Declaration):\n\tRemove code which takes care of building TSDs.\n\t* rtsfind.ads (RE_Check_Interface_Conversion): New entity.\n\t* exp_ch4.adb (Apply_Accessibility_Check): Add support for generating\n\tthe accessibility check in VM targets.\n\t* exp_disp.adb (Make_VM_TSD): Spec moved to exp_disp.ads\n\t(Building_Static_DT): Now returns false for VM targets.\n\t(Build_VM_TSDs): Removed.\n\t(Expand_Interface_Conversion): Generate missing runtime check for\n\tconversions to interface types whose target type is unknown at compile\n\ttime.\n\t(Make_VM_TSD): Add missing code to disable the generation of calls to\n\tCheck_TSD if the tagged type is not defined at library level, or not\n\thas a representation clause specifying its external tag, or -gnatdQ is\n\tactive.\n\t* exp_disp.ads (Build_VM_TSDs): Removed.\n\t(Make_VM_TSDs): Spec relocated from exp_disp.adb\n\t* sem_disp.adb (Check_Dispatching_Operation): No code required to\n\tregister primitives in the dispatch tables in VM targets.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Remove wrong expansion of\n\tinitialization of class-wide interface objects in VM targets.\n\t(Expand_Freeze_Record_Type): For VM targets call Make_VM_TSD (instead\n\tof Make_DT).\n\n2011-08-04  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* gnatlink.adb (Gnatlink): Correct missleading error message displayed\n\twhen dotnet-ld cannot be found.\n\n2011-08-04  Arnaud Charlet  <charlet@adacore.com>\n\n\t* bindgen.adb: Simplify significantly generation of binder body file in\n\tCodePeer mode.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Prevent assert failure\n\twhen compiling binder generated file in CodePeer mode (xxx'Elab_Spec\n\tnot expanded).\n\nFrom-SVN: r177387", "tree": {"sha": "710e2f1e08527a3afb606e3c5eae2c17bf88a373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/710e2f1e08527a3afb606e3c5eae2c17bf88a373"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f46faa08530f834488a7ab292af8946005d3b153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46faa08530f834488a7ab292af8946005d3b153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46faa08530f834488a7ab292af8946005d3b153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46faa08530f834488a7ab292af8946005d3b153/comments", "author": null, "committer": null, "parents": [{"sha": "2ba7e31e7e1c77b639c88aff631900ab7db5958b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba7e31e7e1c77b639c88aff631900ab7db5958b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba7e31e7e1c77b639c88aff631900ab7db5958b"}], "stats": {"total": 633, "additions": 279, "deletions": 354}, "files": [{"sha": "9e1dd4078a07ac3d0dc4b21f2940df65d90fa728", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -1,3 +1,42 @@\n+2011-08-04  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch7.adb (Expand_N_Package_Body, Expand_N_Package_Declaration):\n+\tRemove code which takes care of building TSDs.\n+\t* rtsfind.ads (RE_Check_Interface_Conversion): New entity.\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Add support for generating\n+\tthe accessibility check in VM targets.\n+\t* exp_disp.adb (Make_VM_TSD): Spec moved to exp_disp.ads\n+\t(Building_Static_DT): Now returns false for VM targets.\n+\t(Build_VM_TSDs): Removed.\n+\t(Expand_Interface_Conversion): Generate missing runtime check for\n+\tconversions to interface types whose target type is unknown at compile\n+\ttime.\n+\t(Make_VM_TSD): Add missing code to disable the generation of calls to\n+\tCheck_TSD if the tagged type is not defined at library level, or not\n+\thas a representation clause specifying its external tag, or -gnatdQ is\n+\tactive.\n+\t* exp_disp.ads (Build_VM_TSDs): Removed.\n+\t(Make_VM_TSDs): Spec relocated from exp_disp.adb\n+\t* sem_disp.adb (Check_Dispatching_Operation): No code required to\n+\tregister primitives in the dispatch tables in VM targets.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Remove wrong expansion of\n+\tinitialization of class-wide interface objects in VM targets.\n+\t(Expand_Freeze_Record_Type): For VM targets call Make_VM_TSD (instead\n+\tof Make_DT).\n+\n+2011-08-04  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* gnatlink.adb (Gnatlink): Correct missleading error message displayed\n+\twhen dotnet-ld cannot be found.\n+\n+2011-08-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* bindgen.adb: Simplify significantly generation of binder body file in\n+\tCodePeer mode.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Prevent assert failure\n+\twhen compiling binder generated file in CodePeer mode (xxx'Elab_Spec\n+\tnot expanded).\n+\n 2011-08-04  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb, sem.ads: Code cleanup."}, {"sha": "47e1d1b7f8ff4d9f4fef9081b2c3f67275325a92", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 134, "deletions": 80, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -435,23 +435,29 @@ package body Bindgen is\n    begin\n       WBI (\"   procedure \" & Ada_Final_Name.all & \" is\");\n \n-      if VM_Target = No_VM and then Bind_Main_Program then\n+      if VM_Target = No_VM\n+        and Bind_Main_Program\n+        and not CodePeer_Mode\n+      then\n          WBI (\"      procedure s_stalib_adafinal;\");\n          Set_String (\"      pragma Import (C, s_stalib_adafinal, \");\n          Set_String (\"\"\"system__standard_library__adafinal\"\");\");\n          Write_Statement_Buffer;\n       end if;\n \n       WBI (\"   begin\");\n-      WBI (\"      if not Is_Elaborated then\");\n-      WBI (\"         return;\");\n-      WBI (\"      end if;\");\n-      WBI (\"      Is_Elaborated := False;\");\n+\n+      if not CodePeer_Mode then\n+         WBI (\"      if not Is_Elaborated then\");\n+         WBI (\"         return;\");\n+         WBI (\"      end if;\");\n+         WBI (\"      Is_Elaborated := False;\");\n+      end if;\n \n       --  On non-virtual machine targets, finalization is done differently\n       --  depending on whether this is the main program or a library.\n \n-      if VM_Target = No_VM then\n+      if VM_Target = No_VM and then not CodePeer_Mode then\n          if Bind_Main_Program then\n             WBI (\"      s_stalib_adafinal;\");\n          elsif Lib_Final_Built then\n@@ -462,6 +468,7 @@ package body Bindgen is\n \n       --  Pragma Import C cannot be used on virtual machine targets, therefore\n       --  call the runtime finalization routine directly.\n+      --  Similarly in CodePeer mode, where imported functions are ignored.\n \n       else\n          WBI (\"      System.Standard_Library.Adafinal;\");\n@@ -516,6 +523,7 @@ package body Bindgen is\n \n       if not Suppress_Standard_Library_On_Target\n         and then VM_Target = No_VM\n+        and then not CodePeer_Mode\n         and then not Configurable_Run_Time_On_Target\n       then\n          WBI (\"   type No_Param_Proc is access procedure;\");\n@@ -524,11 +532,17 @@ package body Bindgen is\n \n       WBI (\"   procedure \" & Ada_Init_Name.all & \" is\");\n \n+      --  In CodePeer mode, simplify adainit procedure by only calling\n+      --  elaboration procedures.\n+\n+      if CodePeer_Mode then\n+         WBI (\"   begin\");\n+\n       --  If the standard library is suppressed, then the only global variables\n       --  that might be needed (by the Ravenscar profile) are the priority and\n       --  the processor for the environment task.\n \n-      if Suppress_Standard_Library_On_Target then\n+      elsif Suppress_Standard_Library_On_Target then\n          if Main_Priority /= No_Main_Priority then\n             WBI (\"      Main_Priority : Integer;\");\n             WBI (\"      pragma Import (C, Main_Priority,\" &\n@@ -717,7 +731,6 @@ package body Bindgen is\n          end if;\n \n          WBI (\"   begin\");\n-\n          WBI (\"      if Is_Elaborated then\");\n          WBI (\"         return;\");\n          WBI (\"      end if;\");\n@@ -904,12 +917,17 @@ package body Bindgen is\n          WBI (\"      Initialize_Stack_Limit;\");\n       end if;\n \n+      --  On CodePeer, the finalization of library objects is not relevant\n+\n+      if CodePeer_Mode then\n+         null;\n+\n       --  On virtual machine targets, or on non-virtual machine ones if this\n       --  is the main program case, attach finalize_library to the soft link.\n       --  Do it only when not using a restricted run time, in which case tasks\n       --  are non-terminating, so we do not want library-level finalization.\n \n-      if (VM_Target /= No_VM or else Bind_Main_Program)\n+      elsif (VM_Target /= No_VM or else Bind_Main_Program)\n         and then not Configurable_Run_Time_On_Target\n         and then not Suppress_Standard_Library_On_Target\n       then\n@@ -942,7 +960,10 @@ package body Bindgen is\n \n       --  Generate elaboration calls\n \n-      WBI (\"\");\n+      if not CodePeer_Mode then\n+         WBI (\"\");\n+      end if;\n+\n       Gen_Elab_Calls_Ada;\n \n       --  Case of main program is CIL function or procedure\n@@ -1257,6 +1278,10 @@ package body Bindgen is\n \n    procedure Gen_Elab_Externals_Ada is\n    begin\n+      if CodePeer_Mode then\n+         return;\n+      end if;\n+\n       for E in Elab_Order.First .. Elab_Order.Last loop\n          declare\n             Unum : constant Unit_Id := Elab_Order.Table (E);\n@@ -1380,6 +1405,7 @@ package body Bindgen is\n    ------------------------\n \n    procedure Gen_Elab_Calls_Ada is\n+      Check_Elab_Flag : Boolean;\n    begin\n       for E in Elab_Order.First .. Elab_Order.Last loop\n          declare\n@@ -1420,6 +1446,7 @@ package body Bindgen is\n \n                if U.Utype = Is_Body\n                  and then Units.Table (Unum_Spec).Set_Elab_Entity\n+                 and then not CodePeer_Mode\n                then\n                   Set_String (\"      E\");\n                   Set_Unit_Number (Unum_Spec);\n@@ -1449,10 +1476,13 @@ package body Bindgen is\n             --  elaboration subprogram is needed by CodePeer.\n \n             elsif U.Unit_Kind /= 's' or else not CodePeer_Mode then\n-               if Force_Checking_Of_Elaboration_Flags\n-                 or Interface_Library_Unit\n-                 or not Bind_Main_Program\n-               then\n+               Check_Elab_Flag :=\n+                 not CodePeer_Mode\n+                 and then (Force_Checking_Of_Elaboration_Flags\n+                            or Interface_Library_Unit\n+                            or not Bind_Main_Program);\n+\n+               if Check_Elab_Flag then\n                   Set_String (\"      if E\");\n                   Set_Unit_Number (Unum_Spec);\n                   Set_String (\" = 0 then\");\n@@ -1491,14 +1521,13 @@ package body Bindgen is\n                Set_Char (';');\n                Write_Statement_Buffer;\n \n-               if Force_Checking_Of_Elaboration_Flags\n-                 or Interface_Library_Unit\n-                 or not Bind_Main_Program\n-               then\n+               if Check_Elab_Flag then\n                   WBI (\"      end if;\");\n                end if;\n \n-               if U.Utype /= Is_Spec then\n+               if U.Utype /= Is_Spec\n+                 and then not CodePeer_Mode\n+               then\n                   Set_String (\"      E\");\n                   Set_Unit_Number (Unum_Spec);\n                   Set_String (\" := E\");\n@@ -1717,6 +1746,10 @@ package body Bindgen is\n    --  Start of processing for Gen_Finalize_Library_Ada\n \n    begin\n+      if CodePeer_Mode then\n+         return;\n+      end if;\n+\n       for E in reverse Elab_Order.First .. Elab_Order.Last loop\n          Unum := Elab_Order.Table (E);\n          U    := Units.Table (Unum);\n@@ -2211,7 +2244,9 @@ package body Bindgen is\n \n       --  Initialize and Finalize\n \n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n+      if not CodePeer_Mode\n+        and then not Cumulative_Restrictions.Set (No_Finalization)\n+      then\n          WBI (\"      procedure Initialize (Addr : System.Address);\");\n          WBI (\"      pragma Import (C, Initialize, \"\"__gnat_initialize\"\");\");\n          WBI (\"\");\n@@ -2238,44 +2273,50 @@ package body Bindgen is\n       --  Deal with declarations for main program case\n \n       if not No_Main_Subprogram then\n+         if CodePeer_Mode then\n+            if ALIs.Table (ALIs.First).Main_Program = Func then\n+               WBI (\"      Result : Integer;\");\n+            end if;\n+         else\n+            --  To call the main program, we declare it using a pragma Import\n+            --  Ada with the right link name.\n \n-         --  To call the main program, we declare it using a pragma Import\n-         --  Ada with the right link name.\n-\n-         --  It might seem more obvious to \"with\" the main program, and call\n-         --  it in the normal Ada manner. We do not do this for three reasons:\n-\n-         --    1. It is more efficient not to recompile the main program\n-         --    2. We are not entitled to assume the source is accessible\n-         --    3. We don't know what options to use to compile it\n+            --  It might seem more obvious to \"with\" the main program, and call\n+            --  it in the normal Ada manner. We do not do this for three\n+            --  reasons:\n \n-         --  It is really reason 3 that is most critical (indeed we used\n-         --  to generate the \"with\", but several regression tests failed).\n+            --    1. It is more efficient not to recompile the main program\n+            --    2. We are not entitled to assume the source is accessible\n+            --    3. We don't know what options to use to compile it\n \n-         WBI (\"\");\n+            --  It is really reason 3 that is most critical (indeed we used\n+            --  to generate the \"with\", but several regression tests failed).\n \n-         if ALIs.Table (ALIs.First).Main_Program = Func then\n-            WBI (\"      Result : Integer;\");\n             WBI (\"\");\n-            WBI (\"      function Ada_Main_Program return Integer;\");\n \n-         else\n-            WBI (\"      procedure Ada_Main_Program;\");\n-         end if;\n+            if ALIs.Table (ALIs.First).Main_Program = Func then\n+               WBI (\"      Result : Integer;\");\n+               WBI (\"\");\n+               WBI (\"      function Ada_Main_Program return Integer;\");\n \n-         Set_String (\"      pragma Import (Ada, Ada_Main_Program, \"\"\");\n-         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-         Set_Main_Program_Name;\n-         Set_String (\"\"\");\");\n+            else\n+               WBI (\"      procedure Ada_Main_Program;\");\n+            end if;\n \n-         Write_Statement_Buffer;\n-         WBI (\"\");\n+            Set_String (\"      pragma Import (Ada, Ada_Main_Program, \"\"\");\n+            Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+            Set_Main_Program_Name;\n+            Set_String (\"\"\");\");\n \n-         if Bind_Main_Program\n-           and then not Suppress_Standard_Library_On_Target\n-         then\n-            WBI (\"      SEH : aliased array (1 .. 2) of Integer;\");\n+            Write_Statement_Buffer;\n             WBI (\"\");\n+\n+            if Bind_Main_Program\n+              and then not Suppress_Standard_Library_On_Target\n+            then\n+               WBI (\"      SEH : aliased array (1 .. 2) of Integer;\");\n+               WBI (\"\");\n+            end if;\n          end if;\n       end if;\n \n@@ -2289,7 +2330,7 @@ package body Bindgen is\n       --  with a pragma Volatile in order to tell the compiler to preserve\n       --  this variable at any level of optimization.\n \n-      if Bind_Main_Program then\n+      if Bind_Main_Program and then not CodePeer_Mode then\n          WBI\n            (\"      Ensure_Reference : aliased System.Address := \" &\n             \"Ada_Main_Program_Name'Address;\");\n@@ -2301,7 +2342,10 @@ package body Bindgen is\n \n       --  Acquire command line arguments if present on target\n \n-      if Command_Line_Args_On_Target then\n+      if CodePeer_Mode then\n+         null;\n+\n+      elsif Command_Line_Args_On_Target then\n          WBI (\"      gnat_argc := argc;\");\n          WBI (\"      gnat_argv := argv;\");\n          WBI (\"      gnat_envp := envp;\");\n@@ -2339,7 +2383,9 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization)\n+        and then not CodePeer_Mode\n+      then\n          if not No_Main_Subprogram\n            and then Bind_Main_Program\n            and then not Suppress_Standard_Library_On_Target\n@@ -2383,7 +2429,9 @@ package body Bindgen is\n \n       --  Finalize is only called if we have a run time\n \n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization)\n+        and then not CodePeer_Mode\n+      then\n          WBI (\"      Finalize;\");\n       end if;\n \n@@ -2986,13 +3034,16 @@ package body Bindgen is\n       Resolve_Binder_Options;\n \n       --  Usually, adafinal is called using a pragma Import C. Since Import C\n-      --  doesn't have the same semantics for JGNAT, we use standard Ada.\n+      --  doesn't have the same semantics for VMs or CodePeer, use standard\n+      --  Ada.\n \n-      if VM_Target /= No_VM\n-        and then not Suppress_Standard_Library_On_Target\n-      then\n-         WBI (\"with System.Soft_Links;\");\n-         WBI (\"with System.Standard_Library;\");\n+      if not Suppress_Standard_Library_On_Target then\n+         if CodePeer_Mode then\n+            WBI (\"with System.Standard_Library;\");\n+         elsif VM_Target /= No_VM then\n+            WBI (\"with System.Soft_Links;\");\n+            WBI (\"with System.Standard_Library;\");\n+         end if;\n       end if;\n \n       WBI (\"package \" & Ada_Main & \" is\");\n@@ -3212,38 +3263,41 @@ package body Bindgen is\n \n       Gen_Elab_Externals_Ada;\n \n-      if not Suppress_Standard_Library_On_Target then\n+      if not CodePeer_Mode then\n+         if not Suppress_Standard_Library_On_Target then\n \n-         --  Generate Priority_Specific_Dispatching pragma string\n+            --  Generate Priority_Specific_Dispatching pragma string\n \n-         Set_String\n-           (\"   Local_Priority_Specific_Dispatching : constant String := \"\"\");\n+            Set_String\n+              (\"   Local_Priority_Specific_Dispatching : \" &\n+               \"constant String := \"\"\");\n \n-         for J in 0 .. PSD_Pragma_Settings.Last loop\n-            Set_Char (PSD_Pragma_Settings.Table (J));\n-         end loop;\n+            for J in 0 .. PSD_Pragma_Settings.Last loop\n+               Set_Char (PSD_Pragma_Settings.Table (J));\n+            end loop;\n \n-         Set_String (\"\"\";\");\n-         Write_Statement_Buffer;\n+            Set_String (\"\"\";\");\n+            Write_Statement_Buffer;\n \n-         --  Generate Interrupt_State pragma string\n+            --  Generate Interrupt_State pragma string\n \n-         Set_String (\"   Local_Interrupt_States : constant String := \"\"\");\n+            Set_String (\"   Local_Interrupt_States : constant String := \"\"\");\n \n-         for J in 0 .. IS_Pragma_Settings.Last loop\n-            Set_Char (IS_Pragma_Settings.Table (J));\n-         end loop;\n+            for J in 0 .. IS_Pragma_Settings.Last loop\n+               Set_Char (IS_Pragma_Settings.Table (J));\n+            end loop;\n \n-         Set_String (\"\"\";\");\n-         Write_Statement_Buffer;\n-         WBI (\"\");\n-      end if;\n+            Set_String (\"\"\";\");\n+            Write_Statement_Buffer;\n+            WBI (\"\");\n+         end if;\n \n-      --  The B.1 (39) implementation advice says that the adainit/adafinal\n-      --  routines should be idempotent. Generate a flag to ensure that.\n+         --  The B.1 (39) implementation advice says that the adainit/adafinal\n+         --  routines should be idempotent. Generate a flag to ensure that.\n \n-      WBI (\"   Is_Elaborated : Boolean := False;\");\n-      WBI (\"\");\n+         WBI (\"   Is_Elaborated : Boolean := False;\");\n+         WBI (\"\");\n+      end if;\n \n       --  Generate the adafinal routine unless there is no finalization to do\n "}, {"sha": "eafb238a6ed225d03a04f8bb583c292ed63dbb3a", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -5022,27 +5022,6 @@ package body Exp_Ch3 is\n                   Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));\n                   Exchange_Entities (Defining_Identifier (N), Def_Id);\n                end;\n-\n-            --  Handle initialization of class-wide interface object in VM\n-            --  targets\n-\n-            elsif not Tagged_Type_Expansion then\n-\n-               --  Replace\n-               --     CW : I'Class := Obj;\n-               --  by\n-               --     CW : I'Class;\n-               --     CW := I'Class (Obj); [1]\n-\n-               --  The assignment [1] is later expanded in a dispatching\n-               --  call to _assign\n-\n-               Set_Expression (N, Empty);\n-\n-               Insert_Action (N,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       => New_Reference_To (Def_Id, Loc),\n-                   Expression => Convert_To (Typ, Relocate_Node (Expr))));\n             end if;\n \n             return;\n@@ -6170,6 +6149,9 @@ package body Exp_Ch3 is\n                if not Building_Static_DT (Def_Id) then\n                   Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n                end if;\n+\n+            elsif VM_Target /= No_VM then\n+               Append_Freeze_Actions (Def_Id, Make_VM_TSD (Def_Id));\n             end if;\n \n             --  If the type has unknown discriminants, propagate dispatching"}, {"sha": "d2852e3dd807819dc0ee3b29b6a96bd1c698eea5", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -629,14 +629,10 @@ package body Exp_Ch4 is\n         (Ref            : Node_Id;\n          Built_In_Place : Boolean := False)\n       is\n-         Ref_Node : Node_Id;\n+         New_Node : Node_Id;\n \n       begin\n-         --  Note: we skip the accessibility check for the VM case, since\n-         --  there does not seem to be any practical way of implementing it.\n-\n          if Ada_Version >= Ada_2005\n-           and then Tagged_Type_Expansion\n            and then Is_Class_Wide_Type (DesigT)\n            and then not Scope_Suppress (Accessibility_Check)\n            and then\n@@ -652,20 +648,37 @@ package body Exp_Ch4 is\n             --  address of the allocated object.\n \n             if Built_In_Place then\n-               Ref_Node := New_Copy (Ref);\n+               New_Node := New_Copy (Ref);\n             else\n-               Ref_Node := New_Reference_To (Ref, Loc);\n+               New_Node := New_Reference_To (Ref, Loc);\n+            end if;\n+\n+            New_Node :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Node,\n+                Attribute_Name => Name_Tag);\n+\n+            if Tagged_Type_Expansion then\n+               New_Node :=\n+                 Build_Get_Access_Level (Loc, New_Node);\n+\n+            elsif VM_Target /= No_VM then\n+               New_Node :=\n+                 Make_Function_Call (Loc,\n+                   Name => New_Reference_To (RTE (RE_Get_Access_Level), Loc),\n+                   Parameter_Associations => New_List (New_Node));\n+\n+            --  Cannot generate the runtime check\n+\n+            else\n+               return;\n             end if;\n \n             Insert_Action (N,\n               Make_Raise_Program_Error (Loc,\n                 Condition =>\n                   Make_Op_Gt (Loc,\n-                    Left_Opnd  =>\n-                      Build_Get_Access_Level (Loc,\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         => Ref_Node,\n-                          Attribute_Name => Name_Tag)),\n+                    Left_Opnd  => New_Node,\n                     Right_Opnd =>\n                       Make_Integer_Literal (Loc, Type_Access_Level (PtrT))),\n                 Reason => PE_Accessibility_Check_Failed));\n@@ -2594,6 +2607,8 @@ package body Exp_Ch4 is\n       Clen     : Node_Id;\n       Set      : Boolean;\n \n+   --  Start of processing for Expand_Concatenate\n+\n    begin\n       --  Choose an appropriate computational type\n "}, {"sha": "cb6a6543ca4f47afea1b9756ad5fe93ef5bcd0f4", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -5382,21 +5382,6 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_N_Subprogram_Body\n \n    begin\n-      --  If this is the main compilation unit, and we are generating code for\n-      --  VM targets, we now generate the Type Specific Data record of all the\n-      --  enclosing tagged type declarations.\n-\n-      --  If the runtime package Ada_Tags has not been loaded then this\n-      --  subprogram does not have tagged type declarations and there is no\n-      --  need to search for tagged types to generate their TSDs.\n-\n-      if not Tagged_Type_Expansion\n-        and then Unit (Cunit (Main_Unit)) = N\n-        and then RTU_Loaded (Ada_Tags)\n-      then\n-         Build_VM_TSDs (N);\n-      end if;\n-\n       --  Set L to either the list of declarations if present, or to the list\n       --  of statements if no declarations are present. This is used to insert\n       --  new stuff at the start."}, {"sha": "c31682caec7717e1a21e272d16ddb0f0b3488b48", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 10, "deletions": 54, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -1261,7 +1261,7 @@ package body Exp_Ch7 is\n       --  objects that need finalization. When flag Preprocess is set, the\n       --  routine will simply count the total number of controlled objects in\n       --  Decls. Flag Top_Level denotes whether the processing is done for\n-      --  objects in nested package decparations or instances.\n+      --  objects in nested package declarations or instances.\n \n       procedure Process_Object_Declaration\n         (Decl         : Node_Id;\n@@ -3810,24 +3810,10 @@ package body Exp_Ch7 is\n \n          --  Build dispatch tables of library level tagged types\n \n-         if Is_Library_Level_Entity (Spec_Ent) then\n-            if Tagged_Type_Expansion then\n-               Build_Static_Dispatch_Tables (N);\n-\n-            --  In VM targets there is no need to build dispatch tables but\n-            --  we must generate the corresponding Type Specific Data record.\n-\n-            elsif Unit (Cunit (Main_Unit)) = N then\n-\n-               --  If the runtime package Ada_Tags has not been loaded then\n-               --  this package does not have tagged type declarations and\n-               --  there is no need to search for tagged types to generate\n-               --  their TSDs.\n-\n-               if RTU_Loaded (Ada_Tags) then\n-                  Build_VM_TSDs (N);\n-               end if;\n-            end if;\n+         if Tagged_Type_Expansion\n+           and then Is_Library_Level_Entity (Spec_Ent)\n+         then\n+            Build_Static_Dispatch_Tables (N);\n          end if;\n \n          Build_Task_Activation_Call (N);\n@@ -3948,42 +3934,12 @@ package body Exp_Ch7 is\n \n       --  Build dispatch tables of library level tagged types\n \n-      if Is_Compilation_Unit (Id)\n-        or else (Is_Generic_Instance (Id)\n-                  and then Is_Library_Level_Entity (Id))\n+      if Tagged_Type_Expansion\n+        and then (Is_Compilation_Unit (Id)\n+                    or else (Is_Generic_Instance (Id)\n+                               and then Is_Library_Level_Entity (Id)))\n       then\n-         if Tagged_Type_Expansion then\n-            Build_Static_Dispatch_Tables (N);\n-\n-         --  In VM targets there is no need to build dispatch tables, but we\n-         --  must generate the corresponding Type Specific Data record.\n-\n-         elsif Unit (Cunit (Main_Unit)) = N then\n-\n-            --  If the runtime package Ada_Tags has not been loaded then\n-            --  this package does not have tagged types and there is no need\n-            --  to search for tagged types to generate their TSDs.\n-\n-            if RTU_Loaded (Ada_Tags) then\n-\n-               --  Enter the scope of the package because the new declarations\n-               --  are appended at the end of the package and must be analyzed\n-               --  in that context.\n-\n-               Push_Scope (Id);\n-\n-               if Is_Generic_Instance (Main_Unit_Entity) then\n-                  if Package_Instantiation (Main_Unit_Entity) = N then\n-                     Build_VM_TSDs (N);\n-                  end if;\n-\n-               else\n-                  Build_VM_TSDs (N);\n-               end if;\n-\n-               Pop_Scope;\n-            end if;\n-         end if;\n+         Build_Static_Dispatch_Tables (N);\n       end if;\n \n       --  Note: it is not necessary to worry about generating a subprogram"}, {"sha": "a9ae2c55172aea039d9d63a74e67e0e81a5d1797", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 46, "deletions": 164, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -61,6 +61,7 @@ with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with SCIL_LL;  use SCIL_LL;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -82,10 +83,6 @@ package body Exp_Disp is\n    --  Returns true if Prim is not a predefined dispatching primitive but it is\n    --  an alias of a predefined dispatching primitive (i.e. through a renaming)\n \n-   function Make_VM_TSD (Typ : Entity_Id) return List_Id;\n-   --  Build the Type Specific Data record associated with tagged type Typ.\n-   --  Invoked only when generating code for VM targets.\n-\n    function New_Value (From : Node_Id) return Node_Id;\n    --  From is the original Expression. New_Value is equivalent to a call\n    --  to Duplicate_Subexpr with an explicit dereference when From is an\n@@ -298,6 +295,7 @@ package body Exp_Disp is\n \n       return Static_Dispatch_Tables\n         and then Is_Library_Level_Tagged_Type (Typ)\n+        and then VM_Target = No_VM\n \n          --  If the type is derived from a CPP class we cannot statically\n          --  build the dispatch tables because we must inherit primitives\n@@ -468,156 +466,6 @@ package body Exp_Disp is\n       end if;\n    end Build_Static_Dispatch_Tables;\n \n-   -------------------\n-   -- Build_VM_TSDs --\n-   -------------------\n-\n-   procedure Build_VM_TSDs (N : Entity_Id) is\n-      Target_List : List_Id := No_List;\n-\n-      procedure Build_TSDs (List : List_Id);\n-      --  Build the static dispatch table of tagged types found in the list of\n-      --  declarations. Add the generated nodes to the end of Target_List.\n-\n-      procedure Build_Package_TSDs (N : Node_Id);\n-      --  Build static dispatch tables associated with package declaration N\n-\n-      ---------------------------\n-      -- Build_Dispatch_Tables --\n-      ---------------------------\n-\n-      procedure Build_TSDs (List : List_Id) is\n-         D : Node_Id;\n-\n-      begin\n-         D := First (List);\n-         while Present (D) loop\n-\n-            --  Handle nested packages and package bodies recursively. The\n-            --  generated code is placed on the Target_List established for\n-            --  the enclosing compilation unit.\n-\n-            if Nkind (D) = N_Package_Declaration then\n-               Build_Package_TSDs (D);\n-\n-            elsif Nkind_In (D, N_Package_Body,\n-                               N_Subprogram_Body)\n-            then\n-               Build_TSDs (Declarations (D));\n-\n-            elsif Nkind (D) = N_Package_Body_Stub\n-              and then Present (Library_Unit (D))\n-            then\n-               Build_TSDs\n-                 (Declarations (Proper_Body (Unit (Library_Unit (D)))));\n-\n-            --  Handle full type declarations and derivations of library\n-            --  level tagged types\n-\n-            elsif Nkind_In (D, N_Full_Type_Declaration,\n-                               N_Derived_Type_Definition)\n-              and then Ekind (Defining_Entity (D)) /= E_Record_Subtype\n-              and then Is_Tagged_Type (Defining_Entity (D))\n-              and then not Is_Private_Type (Defining_Entity (D))\n-            then\n-               --  Do not generate TSDs for the internal types created for\n-               --  a type extension with unknown discriminants. The needed\n-               --  information is shared with the source type.\n-               --  See Expand_N_Record_Extension.\n-\n-               if Is_Underlying_Record_View (Defining_Entity (D))\n-                 or else\n-                  (not Comes_From_Source (Defining_Entity (D))\n-                     and then\n-                       Has_Unknown_Discriminants (Etype (Defining_Entity (D)))\n-                     and then\n-                       not Comes_From_Source\n-                             (First_Subtype (Defining_Entity (D))))\n-               then\n-                  null;\n-\n-               else\n-                  if No (Target_List) then\n-                     Target_List := New_List;\n-                  end if;\n-\n-                  Append_List_To (Target_List,\n-                    Make_VM_TSD (Defining_Entity (D)));\n-               end if;\n-            end if;\n-\n-            Next (D);\n-         end loop;\n-      end Build_TSDs;\n-\n-      ------------------------\n-      -- Build_Package_TSDs --\n-      ------------------------\n-\n-      procedure Build_Package_TSDs (N : Node_Id) is\n-         Spec       : constant Node_Id := Specification (N);\n-         Vis_Decls  : constant List_Id := Visible_Declarations (Spec);\n-         Priv_Decls : constant List_Id := Private_Declarations (Spec);\n-\n-      begin\n-         if Present (Priv_Decls) then\n-            Build_TSDs (Vis_Decls);\n-            Build_TSDs (Priv_Decls);\n-\n-         elsif Present (Vis_Decls) then\n-            Build_TSDs (Vis_Decls);\n-         end if;\n-      end Build_Package_TSDs;\n-\n-   --  Start of processing for Build_VM_TSDs\n-\n-   begin\n-      if not Expander_Active\n-        or else No_Run_Time_Mode\n-        or else Tagged_Type_Expansion\n-        or else not RTE_Available (RE_Type_Specific_Data)\n-      then\n-         return;\n-      end if;\n-\n-      if Nkind (N) = N_Package_Declaration then\n-         declare\n-            Spec       : constant Node_Id := Specification (N);\n-            Vis_Decls  : constant List_Id := Visible_Declarations (Spec);\n-            Priv_Decls : constant List_Id := Private_Declarations (Spec);\n-\n-         begin\n-            Build_Package_TSDs (N);\n-\n-            if Present (Target_List) then\n-               Analyze_List (Target_List);\n-\n-               if Present (Priv_Decls)\n-                 and then Is_Non_Empty_List (Priv_Decls)\n-               then\n-                  Append_List (Target_List, Priv_Decls);\n-               else\n-                  Append_List (Target_List, Vis_Decls);\n-               end if;\n-            end if;\n-         end;\n-\n-      elsif Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n-         if Is_Non_Empty_List (Declarations (N)) then\n-            Build_TSDs (Declarations (N));\n-\n-            if Nkind (N) = N_Subprogram_Body then\n-               Build_TSDs (Statements (Handled_Statement_Sequence (N)));\n-            end if;\n-\n-            if Present (Target_List) then\n-               Analyze_List (Target_List);\n-               Append_List  (Target_List, Declarations (N));\n-            end if;\n-         end if;\n-      end if;\n-   end Build_VM_TSDs;\n-\n    ------------------------------\n    -- Convert_Tag_To_Interface --\n    ------------------------------\n@@ -1278,11 +1126,37 @@ package body Exp_Disp is\n                   and then Is_Interface (Iface_Typ)));\n \n       if not Tagged_Type_Expansion then\n+         if VM_Target /= No_VM then\n+            if Is_Access_Type (Operand_Typ) then\n+               Operand_Typ := Designated_Type (Operand_Typ);\n+            end if;\n \n-         --  For VM, just do a conversion ???\n+            if Is_Class_Wide_Type (Operand_Typ) then\n+               Operand_Typ := Root_Type (Operand_Typ);\n+            end if;\n+\n+            if not Is_Static\n+              and then Operand_Typ /= Iface_Typ\n+            then\n+               Insert_Action (N,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Occurrence_Of\n+                            (RTE (RE_Check_Interface_Conversion), Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => Duplicate_Subexpr (Expression (N)),\n+                       Attribute_Name => Name_Tag),\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Reference_To (Iface_Typ, Loc),\n+                       Attribute_Name => Name_Tag))));\n+            end if;\n+\n+            --  Just do a conversion ???\n+\n+            Rewrite (N, Unchecked_Convert_To (Etype (N), N));\n+            Analyze (N);\n+         end if;\n \n-         Rewrite (N, Unchecked_Convert_To (Etype (N), N));\n-         Analyze (N);\n          return;\n       end if;\n \n@@ -6764,13 +6638,20 @@ package body Exp_Disp is\n       --     Check_TSD\n       --       (TSD => TSD'Unrestricted_Access);\n \n-      Append_To (Result,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Reference_To (RTE (RE_Check_TSD), Loc),\n-          Parameter_Associations => New_List (\n-            Make_Attribute_Reference (Loc,\n-              Prefix => New_Reference_To (TSD, Loc),\n-              Attribute_Name => Name_Unrestricted_Access))));\n+      if Ada_Version >= Ada_2005\n+        and then Is_Library_Level_Entity (Typ)\n+        and then Has_External_Tag_Rep_Clause (Typ)\n+        and then RTE_Available (RE_Check_TSD)\n+        and then not Debug_Flag_QQ\n+      then\n+         Append_To (Result,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Check_TSD), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => New_Reference_To (TSD, Loc),\n+                 Attribute_Name => Name_Unrestricted_Access))));\n+      end if;\n \n       --  Generate:\n       --     Register_TSD (TSD'Unrestricted_Access);\n@@ -7653,6 +7534,7 @@ package body Exp_Disp is\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+      pragma Assert (VM_Target = No_VM);\n \n       --  Do not register in the dispatch table eliminated primitives\n "}, {"sha": "306cec228efb921f1ee0966305c7b6d94343ad02", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -186,11 +186,6 @@ package Exp_Disp is\n    --  bodies they are added to the end of the list of declarations of the\n    --  package body.\n \n-   procedure Build_VM_TSDs (N : Entity_Id);\n-   --  N is a library level package declaration, a library level package body\n-   --  or a library level subprogram body. Build the runtime Type Specific\n-   --  Data record of all the tagged types declared inside N.\n-\n    function Convert_Tag_To_Interface\n      (Typ : Entity_Id; Expr : Node_Id) return Node_Id;\n    pragma Inline (Convert_Tag_To_Interface);\n@@ -353,6 +348,10 @@ package Exp_Disp is\n    --  tagged types this routine imports the forward declaration of the tag\n    --  entity, that will be declared and exported by Make_DT.\n \n+   function Make_VM_TSD (Typ : Entity_Id) return List_Id;\n+   --  Build the Type Specific Data record associated with tagged type Typ.\n+   --  Invoked only when generating code for VM targets.\n+\n    function Register_Primitive\n      (Loc     : Source_Ptr;\n       Prim    : Entity_Id) return List_Id;"}, {"sha": "946c7b5417735f02dc46506e63e9b906b0f776aa", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -1717,7 +1717,7 @@ begin\n          Linker_Path := System.OS_Lib.Locate_Exec_On_Path (\"dotnet-ld\");\n \n          if Linker_Path = null then\n-            Exit_With_Error (\"Couldn't locate ilasm\");\n+            Exit_With_Error (\"Couldn't locate dotnet-ld\");\n          end if;\n \n       elsif RTX_RTSS_Kernel_Module_On_Target then"}, {"sha": "d60de40b6439b1a806d8f420623dcd0f7ec98944", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -561,6 +561,7 @@ package Rtsfind is\n      RE_Address_Array,                   -- Ada.Tags\n      RE_Addr_Ptr,                        -- Ada.Tags\n      RE_Base_Address,                    -- Ada.Tags\n+     RE_Check_Interface_Conversion,      -- Ada.Tags\n      RE_Check_TSD,                       -- Ada.Tags\n      RE_Cstring_Ptr,                     -- Ada.Tags\n      RE_Descendant_Tag,                  -- Ada.Tags\n@@ -1743,6 +1744,7 @@ package Rtsfind is\n      RE_Address_Array                    => Ada_Tags,\n      RE_Addr_Ptr                         => Ada_Tags,\n      RE_Base_Address                     => Ada_Tags,\n+     RE_Check_Interface_Conversion       => Ada_Tags,\n      RE_Check_TSD                        => Ada_Tags,\n      RE_Cstring_Ptr                      => Ada_Tags,\n      RE_Descendant_Tag                   => Ada_Tags,"}, {"sha": "986a1e867f2ec45ea3fc7ed29e832fc980f0b41a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -2849,7 +2849,8 @@ package body Sem_Ch6 is\n                      --  raises an exception, but in any case it is not coming\n                      --  back here, so turn on the flag.\n \n-                     if Ekind (Ent) = E_Procedure\n+                     if Present (Ent)\n+                       and then Ekind (Ent) = E_Procedure\n                        and then No_Return (Ent)\n                      then\n                         Set_Trivial_Subprogram (Stm);"}, {"sha": "66fcb07e0aba07b7de86768b434d60f75de96a29", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46faa08530f834488a7ab292af8946005d3b153/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=f46faa08530f834488a7ab292af8946005d3b153", "patch": "@@ -49,6 +49,7 @@ with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Sinfo;    use Sinfo;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -1028,6 +1029,12 @@ package body Sem_Disp is\n                                     \" the type!\", Subp);\n                               end if;\n \n+                           --  No code required to register primitives in VM\n+                           --  targets\n+\n+                           elsif VM_Target /= No_VM then\n+                              null;\n+\n                            else\n                               Insert_Actions_After (Subp_Body,\n                                 Register_Primitive (Sloc (Subp_Body),\n@@ -1158,10 +1165,13 @@ package body Sem_Disp is\n                   while Present (Elmt) loop\n                      Prim := Node (Elmt);\n \n+                     --  No code required to register primitives in VM targets\n+\n                      if Present (Alias (Prim))\n                        and then Present (Interface_Alias (Prim))\n                        and then Alias (Prim) = Subp\n                        and then not Building_Static_DT (Tagged_Type)\n+                       and then VM_Target = No_VM\n                      then\n                         Insert_Actions_After (Subp_Body,\n                           Register_Primitive (Sloc (Subp_Body), Prim => Prim));"}]}