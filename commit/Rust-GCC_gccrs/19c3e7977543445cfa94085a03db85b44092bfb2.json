{"sha": "19c3e7977543445cfa94085a03db85b44092bfb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTljM2U3OTc3NTQzNDQ1Y2ZhOTQwODVhMDNkYjg1YjQ0MDkyYmZiMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-09-24T03:35:46Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-09-24T03:35:46Z"}, "message": "0;261;0c2013-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_vector_reload): Delete, combine\n\treload helper function arrays into a single array reg_addr.\n\t(reload_fpr_gpr): Likewise.\n\t(reload_gpr_vsx): Likewise.\n\t(reload_vsx_gpr): Likewise.\n\t(struct rs6000_reg_addr): Likewise.\n\t(reg_addr): Likewise.\n\t(rs6000_debug_reg_global): Change rs6000_vector_reload,\n\treload_fpr_gpr, reload_gpr_vsx, reload_vsx_gpr uses to reg_addr.\n\t(rs6000_init_hard_regno_mode_ok): Likewise.\n\t(rs6000_secondary_reload_direct_move): Likewise.\n\t(rs6000_secondary_reload): Likewise.\n\nFrom-SVN: r202859", "tree": {"sha": "6f848f1c06ba6503cda67c020bedbca63f5bb0b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f848f1c06ba6503cda67c020bedbca63f5bb0b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19c3e7977543445cfa94085a03db85b44092bfb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c3e7977543445cfa94085a03db85b44092bfb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c3e7977543445cfa94085a03db85b44092bfb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c3e7977543445cfa94085a03db85b44092bfb2/comments", "author": null, "committer": null, "parents": [{"sha": "c2669da93de6bb84df96b14167429f2046acf4b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2669da93de6bb84df96b14167429f2046acf4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2669da93de6bb84df96b14167429f2046acf4b8"}], "stats": {"total": 205, "additions": 109, "deletions": 96}, "files": [{"sha": "1d66177e86abebe44b6148b74bdcd175af53b535", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3e7977543445cfa94085a03db85b44092bfb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3e7977543445cfa94085a03db85b44092bfb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19c3e7977543445cfa94085a03db85b44092bfb2", "patch": "@@ -1,5 +1,18 @@\n 2013-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n+\t* config/rs6000/rs6000.c (rs6000_vector_reload): Delete, combine\n+\treload helper function arrays into a single array reg_addr.\n+\t(reload_fpr_gpr): Likewise.\n+\t(reload_gpr_vsx): Likewise.\n+\t(reload_vsx_gpr): Likewise.\n+\t(struct rs6000_reg_addr): Likewise.\n+\t(reg_addr): Likewise.\n+\t(rs6000_debug_reg_global): Change rs6000_vector_reload,\n+\treload_fpr_gpr, reload_gpr_vsx, reload_vsx_gpr uses to reg_addr.\n+\t(rs6000_init_hard_regno_mode_ok): Likewise.\n+\t(rs6000_secondary_reload_direct_move): Likewise.\n+\t(rs6000_secondary_reload): Likewise.\n+\n \t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add new\n \tconstraints: wu, ww, and wy.  Repurpose wv constraint added during\n \tpower8 changes.  Put wg constraint in alphabetical order."}, {"sha": "1f98c668e744406002ced73b89556ae3e7fd766b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3e7977543445cfa94085a03db85b44092bfb2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3e7977543445cfa94085a03db85b44092bfb2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=19c3e7977543445cfa94085a03db85b44092bfb2", "patch": "@@ -189,9 +189,6 @@ unsigned char rs6000_hard_regno_nregs[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n /* Map register number to register class.  */\n enum reg_class rs6000_regno_regclass[FIRST_PSEUDO_REGISTER];\n \n-/* Reload functions based on the type and the vector unit.  */\n-static enum insn_code rs6000_vector_reload[NUM_MACHINE_MODES][2];\n-\n static int dbg_cost_ctrl;\n \n /* Built in types.  */\n@@ -316,11 +313,16 @@ static enum rs6000_reg_type reg_class_to_reg_type[N_REG_CLASSES];\n \n #define IS_FP_VECT_REG_TYPE(RTYPE) IN_RANGE(RTYPE, VSX_REG_TYPE, FPR_REG_TYPE)\n \n-/* Direct moves to/from vsx/gpr registers that need an additional register to\n-   do the move.  */\n-static enum insn_code reload_fpr_gpr[NUM_MACHINE_MODES];\n-static enum insn_code reload_gpr_vsx[NUM_MACHINE_MODES];\n-static enum insn_code reload_vsx_gpr[NUM_MACHINE_MODES];\n+/* Register type masks based on the type, of valid addressing modes.  */\n+struct rs6000_reg_addr {\n+  enum insn_code reload_load;\t\t/* INSN to reload for loading. */\n+  enum insn_code reload_store;\t\t/* INSN to reload for storing.  */\n+  enum insn_code reload_fpr_gpr;\t/* INSN to move from FPR to GPR.  */\n+  enum insn_code reload_gpr_vsx;\t/* INSN to move from GPR to VSX.  */\n+  enum insn_code reload_vsx_gpr;\t/* INSN to move from VSX to GPR.  */\n+};\n+\n+static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];\n \n \f\n /* Target cpu costs.  */\n@@ -1919,8 +1921,8 @@ rs6000_debug_reg_global (void)\n \n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n     if (rs6000_vector_unit[m] || rs6000_vector_mem[m]\n-\t|| (rs6000_vector_reload[m][0] != CODE_FOR_nothing)\n-\t|| (rs6000_vector_reload[m][1] != CODE_FOR_nothing))\n+\t|| (reg_addr[m].reload_load != CODE_FOR_nothing)\n+\t|| (reg_addr[m].reload_store != CODE_FOR_nothing))\n       {\n \tnl = \"\\n\";\n \tfprintf (stderr,\n@@ -1929,8 +1931,8 @@ rs6000_debug_reg_global (void)\n \t\t GET_MODE_NAME (m),\n \t\t rs6000_debug_vector_unit[ rs6000_vector_unit[m] ],\n \t\t rs6000_debug_vector_unit[ rs6000_vector_mem[m] ],\n-\t\t (rs6000_vector_reload[m][0] != CODE_FOR_nothing) ? 'y' : 'n',\n-\t\t (rs6000_vector_reload[m][1] != CODE_FOR_nothing) ? 'y' : 'n');\n+\t\t (reg_addr[m].reload_store != CODE_FOR_nothing) ? 'y' : 'n',\n+\t\t (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'y' : 'n');\n       }\n \n   if (nl)\n@@ -2239,13 +2241,17 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       reg_class_to_reg_type[(int)ALTIVEC_REGS] = ALTIVEC_REG_TYPE;\n     }\n \n-  /* Precalculate vector information, this must be set up before the\n-     rs6000_hard_regno_nregs_internal below.  */\n+  /* Precalculate the valid memory formats as well as the vector information,\n+     this must be set up before the rs6000_hard_regno_nregs_internal calls\n+     below.  */\n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n     {\n       rs6000_vector_unit[m] = rs6000_vector_mem[m] = VECTOR_NONE;\n-      rs6000_vector_reload[m][0] = CODE_FOR_nothing;\n-      rs6000_vector_reload[m][1] = CODE_FOR_nothing;\n+      reg_addr[m].reload_load = CODE_FOR_nothing;\n+      reg_addr[m].reload_store = CODE_FOR_nothing;\n+      reg_addr[m].reload_fpr_gpr = CODE_FOR_nothing;\n+      reg_addr[m].reload_gpr_vsx = CODE_FOR_nothing;\n+      reg_addr[m].reload_vsx_gpr = CODE_FOR_nothing;\n     }\n \n   for (c = 0; c < (int)(int)RS6000_CONSTRAINT_MAX; c++)\n@@ -2421,112 +2427,104 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_LFIWZX)\n     rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\n \n-  /* Setup the direct move combinations.  */\n-  for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-    {\n-      reload_fpr_gpr[m] = CODE_FOR_nothing;\n-      reload_gpr_vsx[m] = CODE_FOR_nothing;\n-      reload_vsx_gpr[m] = CODE_FOR_nothing;\n-    }\n-\n   /* Set up the reload helper and direct move functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n     {\n       if (TARGET_64BIT)\n \t{\n-\t  rs6000_vector_reload[V16QImode][0] = CODE_FOR_reload_v16qi_di_store;\n-\t  rs6000_vector_reload[V16QImode][1] = CODE_FOR_reload_v16qi_di_load;\n-\t  rs6000_vector_reload[V8HImode][0]  = CODE_FOR_reload_v8hi_di_store;\n-\t  rs6000_vector_reload[V8HImode][1]  = CODE_FOR_reload_v8hi_di_load;\n-\t  rs6000_vector_reload[V4SImode][0]  = CODE_FOR_reload_v4si_di_store;\n-\t  rs6000_vector_reload[V4SImode][1]  = CODE_FOR_reload_v4si_di_load;\n-\t  rs6000_vector_reload[V2DImode][0]  = CODE_FOR_reload_v2di_di_store;\n-\t  rs6000_vector_reload[V2DImode][1]  = CODE_FOR_reload_v2di_di_load;\n-\t  rs6000_vector_reload[V4SFmode][0]  = CODE_FOR_reload_v4sf_di_store;\n-\t  rs6000_vector_reload[V4SFmode][1]  = CODE_FOR_reload_v4sf_di_load;\n-\t  rs6000_vector_reload[V2DFmode][0]  = CODE_FOR_reload_v2df_di_store;\n-\t  rs6000_vector_reload[V2DFmode][1]  = CODE_FOR_reload_v2df_di_load;\n+\t  reg_addr[V16QImode].reload_store = CODE_FOR_reload_v16qi_di_store;\n+\t  reg_addr[V16QImode].reload_load  = CODE_FOR_reload_v16qi_di_load;\n+\t  reg_addr[V8HImode].reload_store  = CODE_FOR_reload_v8hi_di_store;\n+\t  reg_addr[V8HImode].reload_load   = CODE_FOR_reload_v8hi_di_load;\n+\t  reg_addr[V4SImode].reload_store  = CODE_FOR_reload_v4si_di_store;\n+\t  reg_addr[V4SImode].reload_load   = CODE_FOR_reload_v4si_di_load;\n+\t  reg_addr[V2DImode].reload_store  = CODE_FOR_reload_v2di_di_store;\n+\t  reg_addr[V2DImode].reload_load   = CODE_FOR_reload_v2di_di_load;\n+\t  reg_addr[V4SFmode].reload_store  = CODE_FOR_reload_v4sf_di_store;\n+\t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_di_load;\n+\t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_di_store;\n+\t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_di_load;\n \t  if (TARGET_VSX && TARGET_UPPER_REGS_DF)\n \t    {\n-\t      rs6000_vector_reload[DFmode][0]  = CODE_FOR_reload_df_di_store;\n-\t      rs6000_vector_reload[DFmode][1]  = CODE_FOR_reload_df_di_load;\n-\t      rs6000_vector_reload[DDmode][0]  = CODE_FOR_reload_dd_di_store;\n-\t      rs6000_vector_reload[DDmode][1]  = CODE_FOR_reload_dd_di_load;\n+\t      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_di_store;\n+\t      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_di_load;\n+\t      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_di_store;\n+\t      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_di_load;\n \t    }\n \t  if (TARGET_P8_VECTOR)\n \t    {\n-\t      rs6000_vector_reload[SFmode][0]  = CODE_FOR_reload_sf_di_store;\n-\t      rs6000_vector_reload[SFmode][1]  = CODE_FOR_reload_sf_di_load;\n-\t      rs6000_vector_reload[SDmode][0]  = CODE_FOR_reload_sd_di_store;\n-\t      rs6000_vector_reload[SDmode][1]  = CODE_FOR_reload_sd_di_load;\n+\t      reg_addr[SFmode].reload_store  = CODE_FOR_reload_sf_di_store;\n+\t      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_di_load;\n+\t      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_di_store;\n+\t      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_di_load;\n \t    }\n \t  if (TARGET_VSX_TIMODE)\n \t    {\n-\t      rs6000_vector_reload[TImode][0]  = CODE_FOR_reload_ti_di_store;\n-\t      rs6000_vector_reload[TImode][1]  = CODE_FOR_reload_ti_di_load;\n+\t      reg_addr[TImode].reload_store  = CODE_FOR_reload_ti_di_store;\n+\t      reg_addr[TImode].reload_load   = CODE_FOR_reload_ti_di_load;\n \t    }\n \t  if (TARGET_DIRECT_MOVE)\n \t    {\n \t      if (TARGET_POWERPC64)\n \t\t{\n-\t\t  reload_gpr_vsx[TImode]    = CODE_FOR_reload_gpr_from_vsxti;\n-\t\t  reload_gpr_vsx[V2DFmode]  = CODE_FOR_reload_gpr_from_vsxv2df;\n-\t\t  reload_gpr_vsx[V2DImode]  = CODE_FOR_reload_gpr_from_vsxv2di;\n-\t\t  reload_gpr_vsx[V4SFmode]  = CODE_FOR_reload_gpr_from_vsxv4sf;\n-\t\t  reload_gpr_vsx[V4SImode]  = CODE_FOR_reload_gpr_from_vsxv4si;\n-\t\t  reload_gpr_vsx[V8HImode]  = CODE_FOR_reload_gpr_from_vsxv8hi;\n-\t\t  reload_gpr_vsx[V16QImode] = CODE_FOR_reload_gpr_from_vsxv16qi;\n-\t\t  reload_gpr_vsx[SFmode]    = CODE_FOR_reload_gpr_from_vsxsf;\n-\n-\t\t  reload_vsx_gpr[TImode]    = CODE_FOR_reload_vsx_from_gprti;\n-\t\t  reload_vsx_gpr[V2DFmode]  = CODE_FOR_reload_vsx_from_gprv2df;\n-\t\t  reload_vsx_gpr[V2DImode]  = CODE_FOR_reload_vsx_from_gprv2di;\n-\t\t  reload_vsx_gpr[V4SFmode]  = CODE_FOR_reload_vsx_from_gprv4sf;\n-\t\t  reload_vsx_gpr[V4SImode]  = CODE_FOR_reload_vsx_from_gprv4si;\n-\t\t  reload_vsx_gpr[V8HImode]  = CODE_FOR_reload_vsx_from_gprv8hi;\n-\t\t  reload_vsx_gpr[V16QImode] = CODE_FOR_reload_vsx_from_gprv16qi;\n-\t\t  reload_vsx_gpr[SFmode]    = CODE_FOR_reload_vsx_from_gprsf;\n+\t\t  reg_addr[TImode].reload_gpr_vsx    = CODE_FOR_reload_gpr_from_vsxti;\n+\t\t  reg_addr[V2DFmode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv2df;\n+\t\t  reg_addr[V2DImode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv2di;\n+\t\t  reg_addr[V4SFmode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv4sf;\n+\t\t  reg_addr[V4SImode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv4si;\n+\t\t  reg_addr[V8HImode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv8hi;\n+\t\t  reg_addr[V16QImode].reload_gpr_vsx = CODE_FOR_reload_gpr_from_vsxv16qi;\n+\t\t  reg_addr[SFmode].reload_gpr_vsx    = CODE_FOR_reload_gpr_from_vsxsf;\n+\n+\t\t  reg_addr[TImode].reload_vsx_gpr    = CODE_FOR_reload_vsx_from_gprti;\n+\t\t  reg_addr[V2DFmode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv2df;\n+\t\t  reg_addr[V2DImode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv2di;\n+\t\t  reg_addr[V4SFmode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv4sf;\n+\t\t  reg_addr[V4SImode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv4si;\n+\t\t  reg_addr[V8HImode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv8hi;\n+\t\t  reg_addr[V16QImode].reload_vsx_gpr = CODE_FOR_reload_vsx_from_gprv16qi;\n+\t\t  reg_addr[SFmode].reload_vsx_gpr    = CODE_FOR_reload_vsx_from_gprsf;\n \t\t}\n \t      else\n \t\t{\n-\t\t  reload_fpr_gpr[DImode] = CODE_FOR_reload_fpr_from_gprdi;\n-\t\t  reload_fpr_gpr[DDmode] = CODE_FOR_reload_fpr_from_gprdd;\n-\t\t  reload_fpr_gpr[DFmode] = CODE_FOR_reload_fpr_from_gprdf;\n+\t\t  reg_addr[DImode].reload_fpr_gpr = CODE_FOR_reload_fpr_from_gprdi;\n+\t\t  reg_addr[DDmode].reload_fpr_gpr = CODE_FOR_reload_fpr_from_gprdd;\n+\t\t  reg_addr[DFmode].reload_fpr_gpr = CODE_FOR_reload_fpr_from_gprdf;\n \t\t}\n \t    }\n \t}\n       else\n \t{\n-\t  rs6000_vector_reload[V16QImode][0] = CODE_FOR_reload_v16qi_si_store;\n-\t  rs6000_vector_reload[V16QImode][1] = CODE_FOR_reload_v16qi_si_load;\n-\t  rs6000_vector_reload[V8HImode][0]  = CODE_FOR_reload_v8hi_si_store;\n-\t  rs6000_vector_reload[V8HImode][1]  = CODE_FOR_reload_v8hi_si_load;\n-\t  rs6000_vector_reload[V4SImode][0]  = CODE_FOR_reload_v4si_si_store;\n-\t  rs6000_vector_reload[V4SImode][1]  = CODE_FOR_reload_v4si_si_load;\n-\t  rs6000_vector_reload[V2DImode][0]  = CODE_FOR_reload_v2di_si_store;\n-\t  rs6000_vector_reload[V2DImode][1]  = CODE_FOR_reload_v2di_si_load;\n-\t  rs6000_vector_reload[V4SFmode][0]  = CODE_FOR_reload_v4sf_si_store;\n-\t  rs6000_vector_reload[V4SFmode][1]  = CODE_FOR_reload_v4sf_si_load;\n-\t  rs6000_vector_reload[V2DFmode][0]  = CODE_FOR_reload_v2df_si_store;\n-\t  rs6000_vector_reload[V2DFmode][1]  = CODE_FOR_reload_v2df_si_load;\n+\t  reg_addr[V16QImode].reload_store = CODE_FOR_reload_v16qi_si_store;\n+\t  reg_addr[V16QImode].reload_load  = CODE_FOR_reload_v16qi_si_load;\n+\t  reg_addr[V8HImode].reload_store  = CODE_FOR_reload_v8hi_si_store;\n+\t  reg_addr[V8HImode].reload_load   = CODE_FOR_reload_v8hi_si_load;\n+\t  reg_addr[V4SImode].reload_store  = CODE_FOR_reload_v4si_si_store;\n+\t  reg_addr[V4SImode].reload_load   = CODE_FOR_reload_v4si_si_load;\n+\t  reg_addr[V2DImode].reload_store  = CODE_FOR_reload_v2di_si_store;\n+\t  reg_addr[V2DImode].reload_load   = CODE_FOR_reload_v2di_si_load;\n+\t  reg_addr[V4SFmode].reload_store  = CODE_FOR_reload_v4sf_si_store;\n+\t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_si_load;\n+\t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_si_store;\n+\t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_si_load;\n \t  if (TARGET_VSX && TARGET_UPPER_REGS_DF)\n \t    {\n-\t      rs6000_vector_reload[DFmode][0]  = CODE_FOR_reload_df_si_store;\n-\t      rs6000_vector_reload[DFmode][1]  = CODE_FOR_reload_df_si_load;\n-\t      rs6000_vector_reload[DDmode][0]  = CODE_FOR_reload_dd_si_store;\n-\t      rs6000_vector_reload[DDmode][1]  = CODE_FOR_reload_dd_si_load;\n+\t      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_si_store;\n+\t      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_si_load;\n+\t      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_si_store;\n+\t      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_si_load;\n \t    }\n \t  if (TARGET_P8_VECTOR)\n \t    {\n-\t      rs6000_vector_reload[SFmode][0]  = CODE_FOR_reload_sf_si_store;\n-\t      rs6000_vector_reload[SFmode][1]  = CODE_FOR_reload_sf_si_load;\n-\t      rs6000_vector_reload[SDmode][0]  = CODE_FOR_reload_sd_si_store;\n-\t      rs6000_vector_reload[SDmode][1]  = CODE_FOR_reload_sd_si_load;\n+\t      reg_addr[SFmode].reload_store  = CODE_FOR_reload_sf_si_store;\n+\t      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_si_load;\n+\t      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_si_store;\n+\t      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_si_load;\n \t    }\n \t  if (TARGET_VSX_TIMODE)\n \t    {\n-\t      rs6000_vector_reload[TImode][0]  = CODE_FOR_reload_ti_si_store;\n-\t      rs6000_vector_reload[TImode][1]  = CODE_FOR_reload_ti_si_load;\n+\t      reg_addr[TImode].reload_store  = CODE_FOR_reload_ti_si_store;\n+\t      reg_addr[TImode].reload_load   = CODE_FOR_reload_ti_si_load;\n \t    }\n \t}\n     }\n@@ -14745,7 +14743,7 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n \t  if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n \t    {\n \t      cost = 3;\t\t\t/* 2 mtvsrd's, 1 xxpermdi.  */\n-\t      icode = reload_vsx_gpr[(int)mode];\n+\t      icode = reg_addr[mode].reload_vsx_gpr;\n \t    }\n \n \t  /* Handle moving 128-bit values from VSX point registers to GPRs on\n@@ -14754,7 +14752,7 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n \t  else if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n \t    {\n \t      cost = 3;\t\t\t/* 2 mfvsrd's, 1 xxpermdi.  */\n-\t      icode = reload_gpr_vsx[(int)mode];\n+\t      icode = reg_addr[mode].reload_gpr_vsx;\n \t    }\n \t}\n \n@@ -14763,13 +14761,13 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n \t  if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n \t    {\n \t      cost = 3;\t\t\t/* xscvdpspn, mfvsrd, and.  */\n-\t      icode = reload_gpr_vsx[(int)mode];\n+\t      icode = reg_addr[mode].reload_gpr_vsx;\n \t    }\n \n \t  else if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n \t    {\n \t      cost = 2;\t\t\t/* mtvsrz, xscvspdpn.  */\n-\t      icode = reload_vsx_gpr[(int)mode];\n+\t      icode = reg_addr[mode].reload_vsx_gpr;\n \t    }\n \t}\n     }\n@@ -14782,7 +14780,7 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n       if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n \t{\n \t  cost = 3;\t\t\t/* 2 mtvsrd's, 1 xxpermdi.  */\n-\t  icode = reload_vsx_gpr[(int)mode];\n+\t  icode = reg_addr[mode].reload_vsx_gpr;\n \t}\n \n       /* Handle moving 128-bit values from VSX point registers to GPRs on\n@@ -14791,7 +14789,7 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n       else if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n \t{\n \t  cost = 3;\t\t\t/* 2 mfvsrd's, 1 xxpermdi.  */\n-\t  icode = reload_gpr_vsx[(int)mode];\n+\t  icode = reg_addr[mode].reload_gpr_vsx;\n \t}\n     }\n \n@@ -14807,7 +14805,7 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n       if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE && !altivec_p)\n \t{\n \t  cost = 3;\t\t\t/* 2 mtvsrwz's, 1 fmrgow.  */\n-\t  icode = reload_fpr_gpr[(int)mode];\n+\t  icode = reg_addr[mode].reload_fpr_gpr;\n \t}\n     }\n \n@@ -14890,7 +14888,9 @@ rs6000_secondary_reload (bool in_p,\n   bool default_p = false;\n \n   sri->icode = CODE_FOR_nothing;\n-  icode = rs6000_vector_reload[mode][in_p != false];\n+  icode = ((in_p)\n+\t   ? reg_addr[mode].reload_load\n+\t   : reg_addr[mode].reload_store);\n \n   if (REG_P (x) || register_operand (x, mode))\n     {"}]}