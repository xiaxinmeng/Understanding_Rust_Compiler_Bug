{"sha": "2b21299c80f98e22732559357c4af025c2749283", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIyMTI5OWM4MGY5OGUyMjczMjU1OTM1N2M0YWYwMjVjMjc0OTI4Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-06-21T16:27:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-06-21T16:27:25Z"}, "message": "Makefile.in (cfgexpand.o): Depend on $(INSN_ATTR_H).\n\n\t* Makefile.in (cfgexpand.o): Depend on $(INSN_ATTR_H).\n\t* genattrtab.c (check_tune_attr, find_tune_attr): New functions.\n\t(make_automaton_attrs): If find_tune_attr returns non-NULL,\n\twrite separate internal_dfa_insn_code_* and insn_default_latency_*\n\tfunctions for each attribute's value and emit init_sched_attrs\n\tfunction and function pointers.\n\t* genattr.c (const_attrs, reservations): New variables.\n\t(gen_attr): Add const attributes to const_attrs vector.\n\t(check_tune_attr, find_tune_attr): New functions.\n\t(main): Add reservations to reservations vector.  If find_tune_attr\n\treturns true, add prototype for init_sched_attrs and make\n\tinternal_dfa_insn_code and insn_default_latency function pointers,\n\totherwise define init_sched_attrs as dummy macro.\n\t* cfgexpand.c: Include insn-attr.h.\n\t(gimple_expand_cfg): Call init_sched_attrs.\n\nFrom-SVN: r161093", "tree": {"sha": "d02a0fa1435d00b56e4bf4f124a0e6956229dce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d02a0fa1435d00b56e4bf4f124a0e6956229dce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b21299c80f98e22732559357c4af025c2749283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b21299c80f98e22732559357c4af025c2749283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b21299c80f98e22732559357c4af025c2749283", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b21299c80f98e22732559357c4af025c2749283/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6747788144887b569ab4fe3e986043e09c986963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6747788144887b569ab4fe3e986043e09c986963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6747788144887b569ab4fe3e986043e09c986963"}], "stats": {"total": 343, "additions": 319, "deletions": 24}, "files": [{"sha": "a5534853863b67f36fec33f9f09aa1169e2859a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b21299c80f98e22732559357c4af025c2749283/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b21299c80f98e22732559357c4af025c2749283/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b21299c80f98e22732559357c4af025c2749283", "patch": "@@ -1,5 +1,21 @@\n 2010-06-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* Makefile.in (cfgexpand.o): Depend on $(INSN_ATTR_H).\n+\t* genattrtab.c (check_tune_attr, find_tune_attr): New functions.\n+\t(make_automaton_attrs): If find_tune_attr returns non-NULL,\n+\twrite separate internal_dfa_insn_code_* and insn_default_latency_*\n+\tfunctions for each attribute's value and emit init_sched_attrs\n+\tfunction and function pointers.\n+\t* genattr.c (const_attrs, reservations): New variables.\n+\t(gen_attr): Add const attributes to const_attrs vector.\n+\t(check_tune_attr, find_tune_attr): New functions.\n+\t(main): Add reservations to reservations vector.  If find_tune_attr\n+\treturns true, add prototype for init_sched_attrs and make\n+\tinternal_dfa_insn_code and insn_default_latency function pointers,\n+\totherwise define init_sched_attrs as dummy macro.\n+\t* cfgexpand.c: Include insn-attr.h.\n+\t(gimple_expand_cfg): Call init_sched_attrs.\n+\n \t* stmt.c (resolve_asm_operand_names): Fix handling\n \tof %%.\n "}, {"sha": "30ef1efb523b59c34c8cc5b153a6ec69e874129d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b21299c80f98e22732559357c4af025c2749283/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b21299c80f98e22732559357c4af025c2749283/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2b21299c80f98e22732559357c4af025c2749283", "patch": "@@ -3193,7 +3193,7 @@ cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(TREE_PASS_H) $(RTL_H) \\\n    $(DIAGNOSTIC_H) $(TOPLEV_H) $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H) \\\n    value-prof.h $(TREE_INLINE_H) $(TARGET_H) $(SSAEXPAND_H) \\\n-   tree-pretty-print.h gimple-pretty-print.h $(BITMAP_H) sbitmap.h\n+   tree-pretty-print.h gimple-pretty-print.h $(BITMAP_H) sbitmap.h $(INSN_ATTR_H)\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(TOPLEV_H) $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) $(INSN_ATTR_H) \\"}, {"sha": "f78badf30006756b8489aa1dd4317c39a0aa239e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b21299c80f98e22732559357c4af025c2749283/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b21299c80f98e22732559357c4af025c2749283/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2b21299c80f98e22732559357c4af025c2749283", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssaexpand.h\"\n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n+#include \"insn-attr.h\" /* For INSN_SCHEDULING.  */\n \n /* This variable holds information helping the rewriting of SSA trees\n    into RTL.  */\n@@ -3761,6 +3762,10 @@ gimple_expand_cfg (void)\n   set_curr_insn_block (DECL_INITIAL (current_function_decl));\n   prologue_locator = curr_insn_locator ();\n \n+#ifdef INSN_SCHEDULING\n+  init_sched_attrs ();\n+#endif\n+\n   /* Make sure first insn is a note even if we don't want linenums.\n      This makes sure the first insn will never be deleted.\n      Also, final expects a note to appear there.  */"}, {"sha": "4fd22e219e328eb7aa48afd6cf1ce2ff6c124cbd", "filename": "gcc/genattr.c", "status": "modified", "additions": 94, "deletions": 7, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b21299c80f98e22732559357c4af025c2749283/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b21299c80f98e22732559357c4af025c2749283/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=2b21299c80f98e22732559357c4af025c2749283", "patch": "@@ -1,6 +1,6 @@\n /* Generate attribute information (insn-attr.h) from machine description.\n-   Copyright (C) 1991, 1994, 1996, 1998, 1999, 2000, 2003, 2004, 2007, 2008\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1994, 1996, 1998, 1999, 2000, 2003, 2004, 2007, 2008,\n+   2010  Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GCC.\n@@ -40,12 +40,18 @@ write_upcase (const char *str)\n     putchar (TOUPPER(*str));\n }\n \n+static VEC (rtx, heap) *const_attrs, *reservations;\n+\n+\n static void\n gen_attr (rtx attr)\n {\n   const char *p, *tag;\n   int is_const = GET_CODE (XEXP (attr, 2)) == CONST;\n \n+  if (is_const)\n+    VEC_safe_push (rtx, heap, const_attrs, attr);\n+\n   printf (\"#define HAVE_ATTR_%s\\n\", XSTR (attr, 0));\n \n   /* If numeric attribute, don't need to write an enum.  */\n@@ -92,6 +98,68 @@ extern int insn_current_length (rtx);\\n\\n\\\n     }\n }\n \n+/* Check that attribute NAME is used in define_insn_reservation condition\n+   EXP.  Return true if it is.  */\n+static bool\n+check_tune_attr (const char *name, rtx exp)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+      if (check_tune_attr (name, XEXP (exp, 0)))\n+\treturn true;\n+      return check_tune_attr (name, XEXP (exp, 1));\n+\n+    case IOR:\n+      return (check_tune_attr (name, XEXP (exp, 0))\n+\t      && check_tune_attr (name, XEXP (exp, 1)));\n+\n+    case EQ_ATTR:\n+      return strcmp (XSTR (exp, 0), name) == 0;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to find a const attribute (usually cpu or tune) that is used\n+   in all define_insn_reservation conditions.  */\n+static bool\n+find_tune_attr (rtx exp)\n+{\n+  unsigned int i;\n+  rtx attr;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+    case IOR:\n+      if (find_tune_attr (XEXP (exp, 0)))\n+\treturn true;\n+      return find_tune_attr (XEXP (exp, 1));\n+\n+    case EQ_ATTR:\n+      if (strcmp (XSTR (exp, 0), \"alternative\") == 0)\n+\treturn false;\n+\n+      for (i = 0; VEC_iterate (rtx, const_attrs, i, attr); i++)\n+\tif (strcmp (XSTR (attr, 0), XSTR (exp, 0)) == 0)\n+\t  {\n+\t    unsigned int j;\n+\t    rtx resv;\n+\n+\t    for (j = 0; VEC_iterate (rtx, reservations, j, resv); j++)\n+\t      if (! check_tune_attr (XSTR (attr, 0), XEXP (resv, 2)))\n+\t\treturn false;\n+\t    return true;\n+\t  }\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n int\n main (int argc, char **argv)\n {\n@@ -162,11 +230,16 @@ main (int argc, char **argv)\n         }\n \n       else if (GET_CODE (desc) == DEFINE_INSN_RESERVATION)\n-\tnum_insn_reservations++;\n+\t{\n+\t  num_insn_reservations++;\n+\t  VEC_safe_push (rtx, heap, reservations, desc);\n+\t}\n     }\n \n   if (num_insn_reservations > 0)\n     {\n+      bool has_tune_attr\n+\t= find_tune_attr (XEXP (VEC_index (rtx, reservations, 0), 2));\n       /* Output interface for pipeline hazards recognition based on\n \t DFA (deterministic finite state automata.  */\n       printf (\"\\n#define INSN_SCHEDULING\\n\");\n@@ -181,10 +254,24 @@ main (int argc, char **argv)\n       printf (\"#define CPU_UNITS_QUERY 0\\n\");\n       printf (\"#endif\\n\\n\");\n       /* Interface itself: */\n-      printf (\"/* Internal insn code number used by automata.  */\\n\");\n-      printf (\"extern int internal_dfa_insn_code (rtx);\\n\\n\");\n-      printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n-      printf (\"extern int insn_default_latency (rtx);\\n\\n\");\n+      if (has_tune_attr)\n+\t{\n+\t  printf (\"/* Initialize fn pointers for internal_dfa_insn_code\\n\");\n+\t  printf (\"   and insn_default_latency.  */\\n\");\n+\t  printf (\"extern void init_sched_attrs (void);\\n\\n\");\n+\t  printf (\"/* Internal insn code number used by automata.  */\\n\");\n+\t  printf (\"extern int (*internal_dfa_insn_code) (rtx);\\n\\n\");\n+\t  printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n+\t  printf (\"extern int (*insn_default_latency) (rtx);\\n\\n\");\n+\t}\n+      else\n+\t{\n+\t  printf (\"#define init_sched_attrs() do { } while (0)\\n\\n\");\n+\t  printf (\"/* Internal insn code number used by automata.  */\\n\");\n+\t  printf (\"extern int internal_dfa_insn_code (rtx);\\n\\n\");\n+\t  printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n+\t  printf (\"extern int insn_default_latency (rtx);\\n\\n\");\n+\t}\n       printf (\"/* Return nonzero if there is a bypass for given insn\\n\");\n       printf (\"   which is a data producer.  */\\n\");\n       printf (\"extern int bypass_p (rtx);\\n\\n\");"}, {"sha": "33b66f34009429f91f946724147429f5e12fa171", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 203, "deletions": 16, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b21299c80f98e22732559357c4af025c2749283/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b21299c80f98e22732559357c4af025c2749283/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2b21299c80f98e22732559357c4af025c2749283", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to compute values of attributes.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n@@ -4372,35 +4372,224 @@ process_bypasses (void)\n \tr->bypassed = true;\n }\n \n+/* Check that attribute NAME is used in define_insn_reservation condition\n+   EXP.  Return true if it is.  */\n+static bool\n+check_tune_attr (const char *name, rtx exp)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+      if (check_tune_attr (name, XEXP (exp, 0)))\n+\treturn true;\n+      return check_tune_attr (name, XEXP (exp, 1));\n+\n+    case IOR:\n+      return (check_tune_attr (name, XEXP (exp, 0))\n+\t      && check_tune_attr (name, XEXP (exp, 1)));\n+\n+    case EQ_ATTR:\n+      return XSTR (exp, 0) == name;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Try to find a const attribute (usually cpu or tune) that is used\n+   in all define_insn_reservation conditions.  */\n+static struct attr_desc *\n+find_tune_attr (rtx exp)\n+{\n+  struct attr_desc *attr;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+    case IOR:\n+      attr = find_tune_attr (XEXP (exp, 0));\n+      if (attr)\n+\treturn attr;\n+      return find_tune_attr (XEXP (exp, 1));\n+\n+    case EQ_ATTR:\n+      if (XSTR (exp, 0) == alternative_name)\n+\treturn NULL;\n+\n+      attr = find_attr (&XSTR (exp, 0), 0);\n+      gcc_assert (attr);\n+\n+      if (attr->is_const && !attr->is_special)\n+\t{\n+\t  struct insn_reserv *decl;\n+\n+\t  for (decl = all_insn_reservs; decl; decl = decl->next)\n+\t    if (! check_tune_attr (attr->name, decl->condexp))\n+\t      return NULL;\n+\t  return attr;\n+\t}\n+      return NULL;\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n /* Create all of the attributes that describe automaton properties.  */\n static void\n make_automaton_attrs (void)\n {\n   int i;\n   struct insn_reserv *decl;\n   rtx code_exp, lats_exp, byps_exp;\n+  struct attr_desc *tune_attr;\n \n   if (n_insn_reservs == 0)\n     return;\n \n-  code_exp = rtx_alloc (COND);\n-  lats_exp = rtx_alloc (COND);\n+  tune_attr = find_tune_attr (all_insn_reservs->condexp);\n+  if (tune_attr != NULL)\n+    {\n+      rtx *condexps = XNEWVEC (rtx, n_insn_reservs * 3);\n+      struct attr_value *val;\n+      bool first = true;\n+\n+      gcc_assert (tune_attr->is_const\n+\t\t  && !tune_attr->is_special\n+\t\t  && !tune_attr->is_numeric);\n+      for (val = tune_attr->first_value; val; val = val->next)\n+\t{\n+\t  if (val == tune_attr->default_val)\n+\t    continue;\n+\t  gcc_assert (GET_CODE (val->value) == CONST_STRING);\n+\t  printf (\"static int internal_dfa_insn_code_%s (rtx);\\n\"\n+\t\t  \"static int insn_default_latency_%s (rtx);\\n\",\n+\t\t  XSTR (val->value, 0), XSTR (val->value, 0));\n+\t}\n+\n+      printf (\"\\n\");\n+      printf (\"int (*internal_dfa_insn_code) (rtx);\\n\");\n+      printf (\"int (*insn_default_latency) (rtx);\\n\");\n+      printf (\"\\n\");\n+      printf (\"void\\n\");\n+      printf (\"init_sched_attrs (void)\\n\");\n+      printf (\"{\\n\");\n+\n+      for (val = tune_attr->first_value; val; val = val->next)\n+\t{\n+\t  int j;\n+\t  char *name;\n+\t  rtx test = attr_rtx (EQ_ATTR, tune_attr->name, XSTR (val->value, 0));\n+\n+\t  if (val == tune_attr->default_val)\n+\t    continue;\n+\t  for (decl = all_insn_reservs, i = 0;\n+\t       decl;\n+\t       decl = decl->next)\n+\t    {\n+\t      rtx ctest = test;\n+\t      rtx condexp\n+\t\t= simplify_and_tree (decl->condexp, &ctest, -2, 0);\n+\t      if (condexp == false_rtx)\n+\t\tcontinue;\n+\t      if (condexp == true_rtx)\n+\t\tbreak;\n+\t      condexps[i] = condexp;\n+\t      condexps[i + 1] = make_numeric_value (decl->insn_num);\n+\t      condexps[i + 2] = make_numeric_value (decl->default_latency);\n+\t      i += 3;\n+\t    }\n+\n+\t  code_exp = rtx_alloc (COND);\n+\t  lats_exp = rtx_alloc (COND);\n+\n+\t  j = i / 3 * 2;\n+\t  XVEC (code_exp, 0) = rtvec_alloc (j);\n+\t  XVEC (lats_exp, 0) = rtvec_alloc (j);\n+\n+\t  if (decl)\n+\t    {\n+\t      XEXP (code_exp, 1) = make_numeric_value (decl->insn_num);\n+\t      XEXP (lats_exp, 1) = make_numeric_value (decl->default_latency);\n+\t    }\n+\t  else\n+\t    {\n+\t      XEXP (code_exp, 1) = make_numeric_value (n_insn_reservs + 1);\n+\t      XEXP (lats_exp, 1) = make_numeric_value (0);\n+\t    }\n+\n+\t  while (i > 0)\n+\t    {\n+\t      i -= 3;\n+\t      j -= 2;\n+\t      XVECEXP (code_exp, 0, j) = condexps[i];\n+\t      XVECEXP (lats_exp, 0, j) = condexps[i];\n+\n+\t      XVECEXP (code_exp, 0, j + 1) = condexps[i + 1];\n+\t      XVECEXP (lats_exp, 0, j + 1) = condexps[i + 2];\n+\t    }\n \n-  XVEC (code_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n-  XVEC (lats_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n+\t  name = XNEWVEC (char,\n+\t\t\t  sizeof (\"*internal_dfa_insn_code_\")\n+\t\t\t  + strlen (XSTR (val->value, 0)));\n+\t  strcpy (name, \"*internal_dfa_insn_code_\");\n+\t  strcat (name, XSTR (val->value, 0));\n+\t  make_internal_attr (name, code_exp, ATTR_NONE);\n+\t  strcpy (name, \"*insn_default_latency_\");\n+\t  strcat (name, XSTR (val->value, 0));\n+\t  make_internal_attr (name, lats_exp, ATTR_NONE);\n+\t  XDELETEVEC (name);\n+\n+\t  if (first)\n+\t    {\n+\t      printf (\"  if (\");\n+\t      first = false;\n+\t    }\n+\t  else\n+\t    printf (\"  else if (\");\n+\t  write_test_expr (test, 0);\n+\t  printf (\")\\n\");\n+\t  printf (\"    {\\n\");\n+\t  printf (\"      internal_dfa_insn_code\\n\");\n+\t  printf (\"        = internal_dfa_insn_code_%s;\\n\",\n+\t\t  XSTR (val->value, 0));\n+\t  printf (\"      insn_default_latency\\n\");\n+\t  printf (\"        = insn_default_latency_%s;\\n\",\n+\t\t  XSTR (val->value, 0));\n+\t  printf (\"    }\\n\");\n+\t}\n \n-  XEXP (code_exp, 1) = make_numeric_value (n_insn_reservs + 1);\n-  XEXP (lats_exp, 1) = make_numeric_value (0);\n+      printf (\"  else\\n\");\n+      printf (\"    gcc_unreachable ();\\n\");\n+      printf (\"}\\n\");\n+      printf (\"\\n\");\n \n-  for (decl = all_insn_reservs, i = 0;\n-       decl;\n-       decl = decl->next, i += 2)\n+      XDELETEVEC (condexps);\n+    }\n+  else\n     {\n-      XVECEXP (code_exp, 0, i)   = decl->condexp;\n-      XVECEXP (lats_exp, 0, i)   = decl->condexp;\n+      code_exp = rtx_alloc (COND);\n+      lats_exp = rtx_alloc (COND);\n+\n+      XVEC (code_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n+      XVEC (lats_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n \n-      XVECEXP (code_exp, 0, i+1) = make_numeric_value (decl->insn_num);\n-      XVECEXP (lats_exp, 0, i+1) = make_numeric_value (decl->default_latency);\n+      XEXP (code_exp, 1) = make_numeric_value (n_insn_reservs + 1);\n+      XEXP (lats_exp, 1) = make_numeric_value (0);\n+\n+      for (decl = all_insn_reservs, i = 0;\n+\t   decl;\n+\t   decl = decl->next, i += 2)\n+\t{\n+\t  XVECEXP (code_exp, 0, i)   = decl->condexp;\n+\t  XVECEXP (lats_exp, 0, i)   = decl->condexp;\n+\n+\t  XVECEXP (code_exp, 0, i+1) = make_numeric_value (decl->insn_num);\n+\t  XVECEXP (lats_exp, 0, i+1)\n+\t    = make_numeric_value (decl->default_latency);\n+\t}\n+      make_internal_attr (\"*internal_dfa_insn_code\", code_exp, ATTR_NONE);\n+      make_internal_attr (\"*insn_default_latency\",   lats_exp, ATTR_NONE);\n     }\n \n   if (n_bypasses == 0)\n@@ -4423,8 +4612,6 @@ make_automaton_attrs (void)\n \t  }\n     }\n \n-  make_internal_attr (\"*internal_dfa_insn_code\", code_exp, ATTR_NONE);\n-  make_internal_attr (\"*insn_default_latency\",   lats_exp, ATTR_NONE);\n   make_internal_attr (\"*bypass_p\",               byps_exp, ATTR_NONE);\n }\n "}]}