{"sha": "75ce74bbdd695ae793c03f93cfd55842806651e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVjZTc0YmJkZDY5NWFlNzkzYzAzZjkzY2ZkNTU4NDI4MDY2NTFlNg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-01-10T16:59:02Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-01-10T16:59:02Z"}, "message": "2018-01-10  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/forward_list.h\n\t(_Fwd_list_node_base(_Fwd_list_node_base&&)): New.\n\t(_Fwd_list_node_base& operator=(_Fwd_list_node_base&&)): New.\n\t(_Fwd_list_node_base(const _Fwd_list_node_base&)): Explicit delete.\n\t(_Fwd_list_node_base& operator=(const _Fwd_list_node_base&)): Likewise.\n\t(_Fwd_list_impl()): Add noexcept qualification.\n\t(_Fwd_list_impl(const _Node_alloc_type&)): Delete.\n\t(_Fwd_list_impl(_Fwd_list_impl&&)): New, default.\n\t(_Fwd_list_impl(_Fwd_list_impl&&, _Node_alloc_type&&)): New.\n\t(_Fwd_list_base()): Default.\n\t(_Fwd_list_base(_Fwd_list_base&&, _Node_alloc_type&&, true_type)): New.\n\t(_Fwd_list_base(_Fwd_list_base&&)): Default.\n\t(forward_list<>()): Default.\n\t(forward_list<>(forward_list&&)): Default.\n\t(forward_list(forward_list&&, _Node_alloc_type&&, false_type)): New.\n\t(forward_list(forward_list&&, _Node_alloc_type&&, true_type)): New.\n\t(forward_list(forward_list&&, const _Alloc&)): Adapt to use latters.\n\t* include/bits/forward_list.tcc\n\t(_Fwd_list_base(_Fwd_list_base&&, _Node_alloc_type&&)): Adapt to use\n\t_M_impl._M_head move assignment.\n\t(forward_list<>::merge(forward_list<>&&, _Comp)): Likewise.\n\t* testsuite/23_containers/forward_list/allocator/default_init.cc: New.\n\nFrom-SVN: r256439", "tree": {"sha": "9a078f499707649f24ff4deeda4b3985c3ac8c93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a078f499707649f24ff4deeda4b3985c3ac8c93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75ce74bbdd695ae793c03f93cfd55842806651e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ce74bbdd695ae793c03f93cfd55842806651e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75ce74bbdd695ae793c03f93cfd55842806651e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ce74bbdd695ae793c03f93cfd55842806651e6/comments", "author": null, "committer": null, "parents": [{"sha": "143aa5cc4ae329f6f0720d091569c71e1fc8db73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143aa5cc4ae329f6f0720d091569c71e1fc8db73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143aa5cc4ae329f6f0720d091569c71e1fc8db73"}], "stats": {"total": 874, "additions": 492, "deletions": 382}, "files": [{"sha": "46908d32ef64f770e146a6c013ac304914897fea", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=75ce74bbdd695ae793c03f93cfd55842806651e6", "patch": "@@ -1,3 +1,28 @@\n+2018-01-10  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/forward_list.h\n+\t(_Fwd_list_node_base(_Fwd_list_node_base&&)): New.\n+\t(_Fwd_list_node_base& operator=(_Fwd_list_node_base&&)): New.\n+\t(_Fwd_list_node_base(const _Fwd_list_node_base&)): Explicit delete.\n+\t(_Fwd_list_node_base& operator=(const _Fwd_list_node_base&)): Likewise.\n+\t(_Fwd_list_impl()): Add noexcept qualification.\n+\t(_Fwd_list_impl(const _Node_alloc_type&)): Delete.\n+\t(_Fwd_list_impl(_Fwd_list_impl&&)): New, default.\n+\t(_Fwd_list_impl(_Fwd_list_impl&&, _Node_alloc_type&&)): New.\n+\t(_Fwd_list_base()): Default.\n+\t(_Fwd_list_base(_Fwd_list_base&&, _Node_alloc_type&&, true_type)): New.\n+\t(_Fwd_list_base(_Fwd_list_base&&)): Default.\n+\t(forward_list<>()): Default.\n+\t(forward_list<>(forward_list&&)): Default.\n+\t(forward_list(forward_list&&, _Node_alloc_type&&, false_type)): New.\n+\t(forward_list(forward_list&&, _Node_alloc_type&&, true_type)): New.\n+\t(forward_list(forward_list&&, const _Alloc&)): Adapt to use latters.\n+\t* include/bits/forward_list.tcc\n+\t(_Fwd_list_base(_Fwd_list_base&&, _Node_alloc_type&&)): Adapt to use\n+\t_M_impl._M_head move assignment.\n+\t(forward_list<>::merge(forward_list<>&&, _Comp)): Likewise.\n+\t* testsuite/23_containers/forward_list/allocator/default_init.cc: New.\n+\n 2018-01-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/80276"}, {"sha": "b40256bd1040f27e01d2fe959c09d7291beceb59", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "modified", "additions": 215, "deletions": 189, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=75ce74bbdd695ae793c03f93cfd55842806651e6", "patch": "@@ -54,6 +54,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   struct _Fwd_list_node_base\n   {\n     _Fwd_list_node_base() = default;\n+    _Fwd_list_node_base(_Fwd_list_node_base&& __x) noexcept\n+      : _M_next(__x._M_next)\n+    { __x._M_next = nullptr; }\n+\n+    _Fwd_list_node_base(const _Fwd_list_node_base&) = delete;\n+    _Fwd_list_node_base& operator=(const _Fwd_list_node_base&) = delete;\n+\n+    _Fwd_list_node_base&\n+    operator=(_Fwd_list_node_base&& __x) noexcept\n+    {\n+      _M_next = __x._M_next;\n+      __x._M_next = nullptr;\n+      return *this;\n+    }\n \n     _Fwd_list_node_base* _M_next = nullptr;\n \n@@ -68,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  __end->_M_next = _M_next;\n \t}\n       else\n-\t__begin->_M_next = 0;\n+\t__begin->_M_next = nullptr;\n       _M_next = __keep;\n       return __end;\n     }\n@@ -114,20 +128,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n   /**\n    *   @brief A forward_list::iterator.\n-   * \n+   *\n    *   All the functions are op overloads.\n    */\n   template<typename _Tp>\n     struct _Fwd_list_iterator\n     {\n-      typedef _Fwd_list_iterator<_Tp>            _Self;\n-      typedef _Fwd_list_node<_Tp>                _Node;\n+      typedef _Fwd_list_iterator<_Tp>\t\t_Self;\n+      typedef _Fwd_list_node<_Tp>\t\t_Node;\n \n-      typedef _Tp                                value_type;\n-      typedef _Tp*                               pointer;\n-      typedef _Tp&                               reference;\n-      typedef ptrdiff_t                          difference_type;\n-      typedef std::forward_iterator_tag          iterator_category;\n+      typedef _Tp\t\t\t\tvalue_type;\n+      typedef _Tp*\t\t\t\tpointer;\n+      typedef _Tp&\t\t\t\treference;\n+      typedef ptrdiff_t\t\t\t\tdifference_type;\n+      typedef std::forward_iterator_tag\t\titerator_category;\n \n       _Fwd_list_iterator() noexcept\n       : _M_node() { }\n@@ -147,16 +161,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Self&\n       operator++() noexcept\n       {\n-        _M_node = _M_node->_M_next;\n-        return *this;\n+\t_M_node = _M_node->_M_next;\n+\treturn *this;\n       }\n \n       _Self\n       operator++(int) noexcept\n       {\n-        _Self __tmp(*this);\n-        _M_node = _M_node->_M_next;\n-        return __tmp;\n+\t_Self __tmp(*this);\n+\t_M_node = _M_node->_M_next;\n+\treturn __tmp;\n       }\n \n       bool\n@@ -170,32 +184,32 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Self\n       _M_next() const noexcept\n       {\n-        if (_M_node)\n-          return _Fwd_list_iterator(_M_node->_M_next);\n-        else\n-          return _Fwd_list_iterator(0);\n+\tif (_M_node)\n+\t  return _Fwd_list_iterator(_M_node->_M_next);\n+\telse\n+\t  return _Fwd_list_iterator(nullptr);\n       }\n \n       _Fwd_list_node_base* _M_node;\n     };\n \n   /**\n    *   @brief A forward_list::const_iterator.\n-   * \n+   *\n    *   All the functions are op overloads.\n    */\n   template<typename _Tp>\n     struct _Fwd_list_const_iterator\n     {\n-      typedef _Fwd_list_const_iterator<_Tp>      _Self;\n-      typedef const _Fwd_list_node<_Tp>          _Node;\n-      typedef _Fwd_list_iterator<_Tp>            iterator;\n+      typedef _Fwd_list_const_iterator<_Tp>\t_Self;\n+      typedef const _Fwd_list_node<_Tp>\t\t_Node;\n+      typedef _Fwd_list_iterator<_Tp>\t\titerator;\n \n-      typedef _Tp                                value_type;\n-      typedef const _Tp*                         pointer;\n-      typedef const _Tp&                         reference;\n-      typedef ptrdiff_t                          difference_type;\n-      typedef std::forward_iterator_tag          iterator_category;\n+      typedef _Tp\t\t\t\tvalue_type;\n+      typedef const _Tp*\t\t\tpointer;\n+      typedef const _Tp&\t\t\treference;\n+      typedef ptrdiff_t\t\t\t\tdifference_type;\n+      typedef std::forward_iterator_tag\t\titerator_category;\n \n       _Fwd_list_const_iterator() noexcept\n       : _M_node() { }\n@@ -218,16 +232,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Self&\n       operator++() noexcept\n       {\n-        _M_node = _M_node->_M_next;\n-        return *this;\n+\t_M_node = _M_node->_M_next;\n+\treturn *this;\n       }\n \n       _Self\n       operator++(int) noexcept\n       {\n-        _Self __tmp(*this);\n-        _M_node = _M_node->_M_next;\n-        return __tmp;\n+\t_Self __tmp(*this);\n+\t_M_node = _M_node->_M_next;\n+\treturn __tmp;\n       }\n \n       bool\n@@ -241,10 +255,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Self\n       _M_next() const noexcept\n       {\n-        if (this->_M_node)\n-          return _Fwd_list_const_iterator(_M_node->_M_next);\n-        else\n-          return _Fwd_list_const_iterator(0);\n+\tif (this->_M_node)\n+\t  return _Fwd_list_const_iterator(_M_node->_M_next);\n+\telse\n+\t  return _Fwd_list_const_iterator(nullptr);\n       }\n \n       const _Fwd_list_node_base* _M_node;\n@@ -256,7 +270,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp>\n     inline bool\n     operator==(const _Fwd_list_iterator<_Tp>& __x,\n-               const _Fwd_list_const_iterator<_Tp>& __y) noexcept\n+\t       const _Fwd_list_const_iterator<_Tp>& __y) noexcept\n     { return __x._M_node == __y._M_node; }\n \n   /**\n@@ -265,7 +279,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp>\n     inline bool\n     operator!=(const _Fwd_list_iterator<_Tp>& __x,\n-               const _Fwd_list_const_iterator<_Tp>& __y) noexcept\n+\t       const _Fwd_list_const_iterator<_Tp>& __y) noexcept\n     { return __x._M_node != __y._M_node; }\n \n   /**\n@@ -279,30 +293,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef __alloc_rebind<_Alloc, _Fwd_list_node<_Tp>> _Node_alloc_type;\n       typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;\n \n-      struct _Fwd_list_impl \n+      struct _Fwd_list_impl\n       : public _Node_alloc_type\n       {\n-        _Fwd_list_node_base _M_head;\n+\t_Fwd_list_node_base _M_head;\n+\n+\t_Fwd_list_impl()\n+\t  noexcept( noexcept(_Node_alloc_type()) )\n+\t: _Node_alloc_type(), _M_head()\n+\t{ }\n \n-        _Fwd_list_impl()\n-        : _Node_alloc_type(), _M_head()\n-        { }\n+\t_Fwd_list_impl(_Fwd_list_impl&&) = default;\n \n-        _Fwd_list_impl(const _Node_alloc_type& __a)\n-        : _Node_alloc_type(__a), _M_head()\n-        { }\n+\t_Fwd_list_impl(_Fwd_list_impl&& __fl, _Node_alloc_type&& __a)\n+\t: _Node_alloc_type(std::move(__a)), _M_head(std::move(__fl._M_head))\n+\t{ }\n \n-        _Fwd_list_impl(_Node_alloc_type&& __a)\n+\t_Fwd_list_impl(_Node_alloc_type&& __a)\n \t: _Node_alloc_type(std::move(__a)), _M_head()\n-        { }\n+\t{ }\n       };\n \n       _Fwd_list_impl _M_impl;\n \n     public:\n-      typedef _Fwd_list_iterator<_Tp>                 iterator;\n-      typedef _Fwd_list_const_iterator<_Tp>           const_iterator;\n-      typedef _Fwd_list_node<_Tp>                     _Node;\n+      typedef _Fwd_list_iterator<_Tp>\t\titerator;\n+      typedef _Fwd_list_const_iterator<_Tp>\tconst_iterator;\n+      typedef _Fwd_list_node<_Tp>\t\t_Node;\n \n       _Node_alloc_type&\n       _M_get_Node_allocator() noexcept\n@@ -312,26 +329,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_get_Node_allocator() const noexcept\n       { return this->_M_impl; }\n \n-      _Fwd_list_base()\n-      : _M_impl() { }\n+      _Fwd_list_base() = default;\n \n       _Fwd_list_base(_Node_alloc_type&& __a)\n       : _M_impl(std::move(__a)) { }\n \n+      // When allocators are always equal.\n+      _Fwd_list_base(_Fwd_list_base&& __lst, _Node_alloc_type&& __a,\n+\t\t     std::true_type)\n+      : _M_impl(std::move(__lst._M_impl), std::move(__a))\n+      { }\n+\n+      // When allocators are not always equal.\n       _Fwd_list_base(_Fwd_list_base&& __lst, _Node_alloc_type&& __a);\n \n-      _Fwd_list_base(_Fwd_list_base&& __lst)\n-      : _M_impl(std::move(__lst._M_get_Node_allocator()))\n-      {\n-\tthis->_M_impl._M_head._M_next = __lst._M_impl._M_head._M_next;\n-\t__lst._M_impl._M_head._M_next = 0;\n-      }\n+      _Fwd_list_base(_Fwd_list_base&&) = default;\n \n       ~_Fwd_list_base()\n-      { _M_erase_after(&_M_impl._M_head, 0); }\n+      { _M_erase_after(&_M_impl._M_head, nullptr); }\n \n     protected:\n-\n       _Node*\n       _M_get_node()\n       {\n@@ -340,29 +357,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n       template<typename... _Args>\n-        _Node*\n-        _M_create_node(_Args&&... __args)\n-        {\n-          _Node* __node = this->_M_get_node();\n-          __try\n-            {\n+\t_Node*\n+\t_M_create_node(_Args&&... __args)\n+\t{\n+\t  _Node* __node = this->_M_get_node();\n+\t  __try\n+\t    {\n \t      _Tp_alloc_type __a(_M_get_Node_allocator());\n \t      typedef allocator_traits<_Tp_alloc_type> _Alloc_traits;\n \t      ::new ((void*)__node) _Node;\n \t      _Alloc_traits::construct(__a, __node->_M_valptr(),\n \t\t\t\t       std::forward<_Args>(__args)...);\n-            }\n-          __catch(...)\n-            {\n-              this->_M_put_node(__node);\n-              __throw_exception_again;\n-            }\n-          return __node;\n-        }\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      this->_M_put_node(__node);\n+\t      __throw_exception_again;\n+\t    }\n+\t  return __node;\n+\t}\n \n       template<typename... _Args>\n-        _Fwd_list_node_base*\n-        _M_insert_after(const_iterator __pos, _Args&&... __args);\n+\t_Fwd_list_node_base*\n+\t_M_insert_after(const_iterator __pos, _Args&&... __args);\n \n       void\n       _M_put_node(_Node* __p)\n@@ -376,8 +393,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_erase_after(_Fwd_list_node_base* __pos);\n \n       _Fwd_list_node_base*\n-      _M_erase_after(_Fwd_list_node_base* __pos, \n-                     _Fwd_list_node_base* __last);\n+      _M_erase_after(_Fwd_list_node_base* __pos,\n+\t\t     _Fwd_list_node_base* __last);\n     };\n \n   /**\n@@ -417,37 +434,34 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #endif\n \n     private:\n-      typedef _Fwd_list_base<_Tp, _Alloc>                  _Base;\n-      typedef _Fwd_list_node<_Tp>                          _Node;\n-      typedef _Fwd_list_node_base                          _Node_base;\n-      typedef typename _Base::_Tp_alloc_type               _Tp_alloc_type;\n-      typedef typename _Base::_Node_alloc_type             _Node_alloc_type;\n-      typedef typename _Base::_Node_alloc_traits           _Node_alloc_traits;\n-      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>    _Alloc_traits;\n+      typedef _Fwd_list_base<_Tp, _Alloc>\t\t_Base;\n+      typedef _Fwd_list_node<_Tp>\t\t\t_Node;\n+      typedef _Fwd_list_node_base\t\t\t_Node_base;\n+      typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;\n+      typedef typename _Base::_Node_alloc_type\t\t_Node_alloc_type;\n+      typedef typename _Base::_Node_alloc_traits\t_Node_alloc_traits;\n+      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>\t_Alloc_traits;\n \n     public:\n       // types:\n-      typedef _Tp                                          value_type;\n-      typedef typename _Alloc_traits::pointer              pointer;\n-      typedef typename _Alloc_traits::const_pointer        const_pointer;\n-      typedef value_type&\t\t\t\t   reference;\n-      typedef const value_type&\t\t\t\t   const_reference;\n- \n-      typedef _Fwd_list_iterator<_Tp>                      iterator;\n-      typedef _Fwd_list_const_iterator<_Tp>                const_iterator;\n-      typedef std::size_t                                  size_type;\n-      typedef std::ptrdiff_t                               difference_type;\n-      typedef _Alloc                                       allocator_type;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef typename _Alloc_traits::pointer\t\tpointer;\n+      typedef typename _Alloc_traits::const_pointer\tconst_pointer;\n+      typedef value_type&\t\t\t\treference;\n+      typedef const value_type&\t\t\t\tconst_reference;\n+\n+      typedef _Fwd_list_iterator<_Tp>\t\t\titerator;\n+      typedef _Fwd_list_const_iterator<_Tp>\t\tconst_iterator;\n+      typedef std::size_t\t\t\t\tsize_type;\n+      typedef std::ptrdiff_t\t\t\t\tdifference_type;\n+      typedef _Alloc\t\t\t\t\tallocator_type;\n \n       // 23.3.4.2 construct/copy/destroy:\n \n       /**\n        *  @brief  Creates a %forward_list with no elements.\n        */\n-      forward_list()\n-      noexcept(is_nothrow_default_constructible<_Node_alloc_type>::value)\n-      : _Base()\n-      { }\n+      forward_list() = default;\n \n       /**\n        *  @brief  Creates a %forward_list with no elements.\n@@ -458,7 +472,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       : _Base(_Node_alloc_type(__al))\n       { }\n \n-\n       /**\n        *  @brief  Copy constructor with allocator argument.\n        *  @param  __list  Input list to copy.\n@@ -468,14 +481,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       : _Base(_Node_alloc_type(__al))\n       { _M_range_initialize(__list.begin(), __list.end()); }\n \n-      /**\n-       *  @brief  Move constructor with allocator argument.\n-       *  @param  __list  Input list to move.\n-       *  @param  __al    An allocator object.\n-       */\n-      forward_list(forward_list&& __list, const _Alloc& __al)\n-      noexcept(_Node_alloc_traits::_S_always_equal())\n-      : _Base(std::move(__list), _Node_alloc_type(__al))\n+    private:\n+      forward_list(forward_list&& __list, _Node_alloc_type&& __al,\n+\t\t   false_type)\n+      : _Base(std::move(__list), std::move(__al))\n       {\n \t// If __list is not empty it means its allocator is not equal to __a,\n \t// so we need to move from each element individually.\n@@ -484,6 +493,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t     std::__make_move_if_noexcept_iterator(__list.end()));\n       }\n \n+      forward_list(forward_list&& __list, _Node_alloc_type&& __al,\n+\t\t   true_type)\n+      noexcept\n+      : _Base(std::move(__list), _Node_alloc_type(__al), true_type{})\n+      { }\n+\n+    public:\n+      /**\n+       *  @brief  Move constructor with allocator argument.\n+       *  @param  __list  Input list to move.\n+       *  @param  __al    An allocator object.\n+       */\n+      forward_list(forward_list&& __list, const _Alloc& __al)\n+      noexcept(_Node_alloc_traits::_S_always_equal())\n+      : forward_list(std::move(__list), _Node_alloc_type(__al),\n+\t\t     typename _Node_alloc_traits::is_always_equal{})\n+      { }\n+\n       /**\n        *  @brief  Creates a %forward_list with default constructed elements.\n        *  @param  __n   The number of elements to initially create.\n@@ -507,7 +534,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @a __value.\n        */\n       forward_list(size_type __n, const _Tp& __value,\n-                   const _Alloc& __al = _Alloc())\n+\t\t   const _Alloc& __al = _Alloc())\n       : _Base(_Node_alloc_type(__al))\n       { _M_fill_initialize(__n, __value); }\n \n@@ -523,10 +550,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        forward_list(_InputIterator __first, _InputIterator __last,\n-                     const _Alloc& __al = _Alloc())\n+\tforward_list(_InputIterator __first, _InputIterator __last,\n+\t\t     const _Alloc& __al = _Alloc())\n \t: _Base(_Node_alloc_type(__al))\n-        { _M_range_initialize(__first, __last); }\n+\t{ _M_range_initialize(__first, __last); }\n \n       /**\n        *  @brief  The %forward_list copy constructor.\n@@ -535,20 +562,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       forward_list(const forward_list& __list)\n       : _Base(_Node_alloc_traits::_S_select_on_copy(\n-                __list._M_get_Node_allocator()))\n+\t\t__list._M_get_Node_allocator()))\n       { _M_range_initialize(__list.begin(), __list.end()); }\n \n       /**\n        *  @brief  The %forward_list move constructor.\n        *  @param  __list  A %forward_list of identical element and allocator\n        *                  types.\n        *\n-       *  The newly-created %forward_list contains the exact contents of @a\n-       *  __list. The contents of @a __list are a valid, but unspecified\n-       *  %forward_list.\n+       *  The newly-created %forward_list contains the exact contents of the\n+       *  moved instance. The contents of the moved instance are a valid, but\n+       *  unspecified %forward_list.\n        */\n-      forward_list(forward_list&& __list) noexcept\n-      : _Base(std::move(__list)) { }\n+      forward_list(forward_list&&) = default;\n \n       /**\n        *  @brief  Builds a %forward_list from an initializer_list\n@@ -559,7 +585,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  in the initializer_list @a __il.  This is linear in __il.size().\n        */\n       forward_list(std::initializer_list<_Tp> __il,\n-                   const _Alloc& __al = _Alloc())\n+\t\t   const _Alloc& __al = _Alloc())\n       : _Base(_Node_alloc_type(__al))\n       { _M_range_initialize(__il.begin(), __il.end()); }\n \n@@ -597,10 +623,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       operator=(forward_list&& __list)\n       noexcept(_Node_alloc_traits::_S_nothrow_move())\n       {\n-        constexpr bool __move_storage =\n-          _Node_alloc_traits::_S_propagate_on_move_assign()\n-          || _Node_alloc_traits::_S_always_equal();\n-        _M_move_assign(std::move(__list), __bool_constant<__move_storage>());\n+\tconstexpr bool __move_storage =\n+\t  _Node_alloc_traits::_S_propagate_on_move_assign()\n+\t  || _Node_alloc_traits::_S_always_equal();\n+\t_M_move_assign(std::move(__list), __bool_constant<__move_storage>());\n \treturn *this;\n       }\n \n@@ -615,8 +641,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       forward_list&\n       operator=(std::initializer_list<_Tp> __il)\n       {\n-        assign(__il);\n-        return *this;\n+\tassign(__il);\n+\treturn *this;\n       }\n \n       /**\n@@ -634,8 +660,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \tvoid\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  typedef is_assignable<_Tp, decltype(*__first)> __assignable;\n \t  _M_assign(__first, __last, __assignable());\n \t}\n@@ -714,7 +740,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       iterator\n       end() noexcept\n-      { return iterator(0); }\n+      { return iterator(nullptr); }\n \n       /**\n        *  Returns a read-only iterator that points one past the last\n@@ -723,7 +749,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       const_iterator\n       end() const noexcept\n-      { return const_iterator(0); }\n+      { return const_iterator(nullptr); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n@@ -750,15 +776,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       const_iterator\n       cend() const noexcept\n-      { return const_iterator(0); }\n+      { return const_iterator(nullptr); }\n \n       /**\n        *  Returns true if the %forward_list is empty.  (Thus begin() would\n        *  equal end().)\n        */\n       bool\n       empty() const noexcept\n-      { return this->_M_impl._M_head._M_next == 0; }\n+      { return this->_M_impl._M_head._M_next == nullptr; }\n \n       /**\n        *  Returns the largest possible number of elements of %forward_list.\n@@ -776,8 +802,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       reference\n       front()\n       {\n-        _Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n-        return *__front->_M_valptr();\n+\t_Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+\treturn *__front->_M_valptr();\n       }\n \n       /**\n@@ -787,8 +813,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_reference\n       front() const\n       {\n-        _Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n-        return *__front->_M_valptr();\n+\t_Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+\treturn *__front->_M_valptr();\n       }\n \n       // 23.3.4.5 modi\ufb01ers:\n@@ -806,14 +832,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       template<typename... _Args>\n #if __cplusplus > 201402L\n-        reference\n+\treference\n #else\n \tvoid\n #endif\n-        emplace_front(_Args&&... __args)\n-        {\n+\templace_front(_Args&&... __args)\n+\t{\n \t  this->_M_insert_after(cbefore_begin(),\n-                                std::forward<_Args>(__args)...);\n+\t\t\t\tstd::forward<_Args>(__args)...);\n #if __cplusplus > 201402L\n \t  return front();\n #endif\n@@ -870,10 +896,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  and references.\n        */\n       template<typename... _Args>\n-        iterator\n-        emplace_after(const_iterator __pos, _Args&&... __args)\n-        { return iterator(this->_M_insert_after(__pos,\n-                                          std::forward<_Args>(__args)...)); }\n+\titerator\n+\templace_after(const_iterator __pos, _Args&&... __args)\n+\t{ return iterator(this->_M_insert_after(__pos,\n+\t\t\t\t\t  std::forward<_Args>(__args)...)); }\n \n       /**\n        *  @brief  Inserts given value into %forward_list after specified\n@@ -933,9 +959,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        iterator\n-        insert_after(const_iterator __pos,\n-                     _InputIterator __first, _InputIterator __last);\n+\titerator\n+\tinsert_after(const_iterator __pos,\n+\t\t     _InputIterator __first, _InputIterator __last);\n \n       /**\n        *  @brief  Inserts the contents of an initializer_list into\n@@ -1018,10 +1044,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       void\n       swap(forward_list& __list) noexcept\n       {\n-        std::swap(this->_M_impl._M_head._M_next,\n+\tstd::swap(this->_M_impl._M_head._M_next,\n \t\t  __list._M_impl._M_head._M_next);\n \t_Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),\n-                                       __list._M_get_Node_allocator());\n+\t\t\t\t       __list._M_get_Node_allocator());\n       }\n \n       /**\n@@ -1063,7 +1089,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       clear() noexcept\n-      { this->_M_erase_after(&this->_M_impl._M_head, 0); }\n+      { this->_M_erase_after(&this->_M_impl._M_head, nullptr); }\n \n       // 23.3.4.6 forward_list operations:\n \n@@ -1101,11 +1127,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       splice_after(const_iterator __pos, forward_list&& __list,\n-                   const_iterator __i) noexcept;\n+\t\t   const_iterator __i) noexcept;\n \n       void\n       splice_after(const_iterator __pos, forward_list& __list,\n-                   const_iterator __i) noexcept\n+\t\t   const_iterator __i) noexcept\n       { splice_after(__pos, std::move(__list), __i); }\n \n       /**\n@@ -1124,12 +1150,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       splice_after(const_iterator __pos, forward_list&&,\n-                   const_iterator __before, const_iterator __last) noexcept\n+\t\t   const_iterator __before, const_iterator __last) noexcept\n       { _M_splice_after(__pos, __before, __last); }\n \n       void\n       splice_after(const_iterator __pos, forward_list&,\n-                   const_iterator __before, const_iterator __last) noexcept\n+\t\t   const_iterator __before, const_iterator __last) noexcept\n       { _M_splice_after(__pos, __before, __last); }\n       // @}\n \n@@ -1159,8 +1185,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  responsibility.\n        */\n       template<typename _Pred>\n-        void\n-        remove_if(_Pred __pred);\n+\tvoid\n+\tremove_if(_Pred __pred);\n \n       /**\n        *  @brief  Remove consecutive duplicate elements.\n@@ -1189,8 +1215,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Managing the pointer is the user's responsibility.\n        */\n       template<typename _BinPred>\n-        void\n-        unique(_BinPred __binary_pred);\n+\tvoid\n+\tunique(_BinPred __binary_pred);\n \n       /**\n        *  @brief  Merge sorted lists.\n@@ -1221,13 +1247,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  according to comp().\n        */\n       template<typename _Comp>\n-        void\n-        merge(forward_list&& __list, _Comp __comp);\n+\tvoid\n+\tmerge(forward_list&& __list, _Comp __comp);\n \n       template<typename _Comp>\n-        void\n-        merge(forward_list& __list, _Comp __comp)\n-        { merge(std::move(__list), __comp); }\n+\tvoid\n+\tmerge(forward_list& __list, _Comp __comp)\n+\t{ merge(std::move(__list), __comp); }\n \n       /**\n        *  @brief  Sort the elements of the list.\n@@ -1246,8 +1272,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  elements remain in list order.\n        */\n       template<typename _Comp>\n-        void\n-        sort(_Comp __comp);\n+\tvoid\n+\tsort(_Comp __comp);\n \n       /**\n        *  @brief  Reverse the elements in list.\n@@ -1261,8 +1287,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     private:\n       // Called by the range constructor to implement [23.3.4.2]/9\n       template<typename _InputIterator>\n-        void\n-        _M_range_initialize(_InputIterator __first, _InputIterator __last);\n+\tvoid\n+\t_M_range_initialize(_InputIterator __first, _InputIterator __last);\n \n       // Called by forward_list(n,v,a), and the range constructor when it\n       // turns out to be the same thing.\n@@ -1284,22 +1310,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by operator=(forward_list&&)\n       void\n-      _M_move_assign(forward_list&& __list, std::true_type) noexcept\n+      _M_move_assign(forward_list&& __list, true_type) noexcept\n       {\n-        clear();\n-        this->_M_impl._M_head._M_next = __list._M_impl._M_head._M_next;\n-        __list._M_impl._M_head._M_next = nullptr;\n-        std::__alloc_on_move(this->_M_get_Node_allocator(),\n-                             __list._M_get_Node_allocator());\n+\tclear();\n+\tthis->_M_impl._M_head._M_next = __list._M_impl._M_head._M_next;\n+\t__list._M_impl._M_head._M_next = nullptr;\n+\tstd::__alloc_on_move(this->_M_get_Node_allocator(),\n+\t\t\t     __list._M_get_Node_allocator());\n       }\n \n       // Called by operator=(forward_list&&)\n       void\n-      _M_move_assign(forward_list&& __list, std::false_type)\n+      _M_move_assign(forward_list&& __list, false_type)\n       {\n-        if (__list._M_get_Node_allocator() == this->_M_get_Node_allocator())\n-          _M_move_assign(std::move(__list), std::true_type());\n-        else\n+\tif (__list._M_get_Node_allocator() == this->_M_get_Node_allocator())\n+\t  _M_move_assign(std::move(__list), true_type());\n+\telse\n \t  // The rvalue's allocator cannot be moved, or is not equal,\n \t  // so we need to individually move each element.\n \t  this->assign(std::__make_move_if_noexcept_iterator(__list.begin()),\n@@ -1310,7 +1336,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // CopyAssignable.\n       template<typename _InputIterator>\n \tvoid\n-        _M_assign(_InputIterator __first, _InputIterator __last, true_type)\n+\t_M_assign(_InputIterator __first, _InputIterator __last, true_type)\n \t{\n \t  auto __prev = before_begin();\n \t  auto __curr = begin();\n@@ -1326,13 +1352,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    insert_after(__prev, __first, __last);\n \t  else if (__curr != __end)\n \t    erase_after(__prev, __end);\n-        }\n+\t}\n \n       // Called by assign(_InputIterator, _InputIterator) if _Tp is not\n       // CopyAssignable.\n       template<typename _InputIterator>\n \tvoid\n-        _M_assign(_InputIterator __first, _InputIterator __last, false_type)\n+\t_M_assign(_InputIterator __first, _InputIterator __last, false_type)\n \t{\n \t  clear();\n \t  insert_after(cbefore_begin(), __first, __last);\n@@ -1383,22 +1409,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  @param  __ly  A %forward_list of the same type as @a __lx.\n    *  @return  True iff the elements of the forward lists are equal.\n    *\n-   *  This is an equivalence relation.  It is linear in the number of \n+   *  This is an equivalence relation.  It is linear in the number of\n    *  elements of the forward lists.  Deques are considered equivalent\n    *  if corresponding elements compare equal.\n    */\n   template<typename _Tp, typename _Alloc>\n     bool\n     operator==(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly);\n+\t       const forward_list<_Tp, _Alloc>& __ly);\n \n   /**\n    *  @brief  Forward list ordering relation.\n    *  @param  __lx  A %forward_list.\n    *  @param  __ly  A %forward_list of the same type as @a __lx.\n    *  @return  True iff @a __lx is lexicographically less than @a __ly.\n    *\n-   *  This is a total ordering relation.  It is linear in the number of \n+   *  This is a total ordering relation.  It is linear in the number of\n    *  elements of the forward lists.  The elements must be comparable\n    *  with @c <.\n    *\n@@ -1407,36 +1433,36 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const forward_list<_Tp, _Alloc>& __lx,\n-              const forward_list<_Tp, _Alloc>& __ly)\n+\t      const forward_list<_Tp, _Alloc>& __ly)\n     { return std::lexicographical_compare(__lx.cbegin(), __lx.cend(),\n \t\t\t\t\t  __ly.cbegin(), __ly.cend()); }\n \n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__lx == __ly); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const forward_list<_Tp, _Alloc>& __lx,\n-              const forward_list<_Tp, _Alloc>& __ly)\n+\t      const forward_list<_Tp, _Alloc>& __ly)\n     { return (__ly < __lx); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__lx < __ly); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__ly < __lx); }\n \n   /// See std::forward_list::swap()."}, {"sha": "3e12cd531d47773dfeaaaff7382eee72270d4a82", "filename": "libstdc++-v3/include/bits/forward_list.tcc", "status": "modified", "additions": 185, "deletions": 193, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc?ref=75ce74bbdd695ae793c03f93cfd55842806651e6", "patch": "@@ -41,12 +41,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     : _M_impl(std::move(__a))\n     {\n       if (__lst._M_get_Node_allocator() == _M_get_Node_allocator())\n-\t{\n-\t  this->_M_impl._M_head._M_next = __lst._M_impl._M_head._M_next;\n-\t  __lst._M_impl._M_head._M_next = 0;\n-\t}\n-      else\n-\tthis->_M_impl._M_head._M_next = 0;\n+\tthis->_M_impl._M_head = std::move(__lst._M_impl._M_head);\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -55,12 +50,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Fwd_list_base<_Tp, _Alloc>::\n       _M_insert_after(const_iterator __pos, _Args&&... __args)\n       {\n-        _Fwd_list_node_base* __to\n+\t_Fwd_list_node_base* __to\n \t  = const_cast<_Fwd_list_node_base*>(__pos._M_node);\n \t_Node* __thing = _M_create_node(std::forward<_Args>(__args)...);\n-        __thing->_M_next = __to->_M_next;\n-        __to->_M_next = __thing;\n-        return __to->_M_next;\n+\t__thing->_M_next = __to->_M_next;\n+\t__to->_M_next = __thing;\n+\treturn __to->_M_next;\n       }\n \n   template<typename _Tp, typename _Alloc>\n@@ -80,19 +75,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc>\n     _Fwd_list_node_base*\n     _Fwd_list_base<_Tp, _Alloc>::\n-    _M_erase_after(_Fwd_list_node_base* __pos, \n-                   _Fwd_list_node_base* __last)\n+    _M_erase_after(_Fwd_list_node_base* __pos,\n+\t\t   _Fwd_list_node_base* __last)\n     {\n       _Node* __curr = static_cast<_Node*>(__pos->_M_next);\n       while (__curr != __last)\n-        {\n-          _Node* __temp = __curr;\n-          __curr = static_cast<_Node*>(__curr->_M_next);\n+\t{\n+\t  _Node* __temp = __curr;\n+\t  __curr = static_cast<_Node*>(__curr->_M_next);\n \t  _Tp_alloc_type __a(_M_get_Node_allocator());\n \t  allocator_traits<_Tp_alloc_type>::destroy(__a, __temp->_M_valptr());\n \t  __temp->~_Node();\n-          _M_put_node(__temp);\n-        }\n+\t  _M_put_node(__temp);\n+\t}\n       __pos->_M_next = __last;\n       return __last;\n     }\n@@ -104,12 +99,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       forward_list<_Tp, _Alloc>::\n       _M_range_initialize(_InputIterator __first, _InputIterator __last)\n       {\n-        _Node_base* __to = &this->_M_impl._M_head;\n-        for (; __first != __last; ++__first)\n-          {\n-            __to->_M_next = this->_M_create_node(*__first);\n-            __to = __to->_M_next;\n-          }\n+\t_Node_base* __to = &this->_M_impl._M_head;\n+\tfor (; __first != __last; ++__first)\n+\t  {\n+\t    __to->_M_next = this->_M_create_node(*__first);\n+\t    __to = __to->_M_next;\n+\t  }\n       }\n \n   // Called by forward_list(n,v,a).\n@@ -120,10 +115,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     {\n       _Node_base* __to = &this->_M_impl._M_head;\n       for (; __n; --__n)\n-        {\n-          __to->_M_next = this->_M_create_node(__value);\n-          __to = __to->_M_next;\n-        }\n+\t{\n+\t  __to->_M_next = this->_M_create_node(__value);\n+\t  __to = __to->_M_next;\n+\t}\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -133,10 +128,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     {\n       _Node_base* __to = &this->_M_impl._M_head;\n       for (; __n; --__n)\n-        {\n-          __to->_M_next = this->_M_create_node();\n-          __to = __to->_M_next;\n-        }\n+\t{\n+\t  __to->_M_next = this->_M_create_node();\n+\t  __to = __to->_M_next;\n+\t}\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -145,21 +140,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator=(const forward_list& __list)\n     {\n       if (std::__addressof(__list) != this)\n-        {\n+\t{\n \t  if (_Node_alloc_traits::_S_propagate_on_copy_assign())\n \t    {\n-              auto& __this_alloc = this->_M_get_Node_allocator();\n-              auto& __that_alloc = __list._M_get_Node_allocator();\n-              if (!_Node_alloc_traits::_S_always_equal()\n-\t          && __this_alloc != __that_alloc)\n-\t        {\n+\t      auto& __this_alloc = this->_M_get_Node_allocator();\n+\t      auto& __that_alloc = __list._M_get_Node_allocator();\n+\t      if (!_Node_alloc_traits::_S_always_equal()\n+\t\t  && __this_alloc != __that_alloc)\n+\t\t{\n \t\t  // replacement allocator cannot free existing storage\n \t\t  clear();\n \t\t}\n \t      std::__alloc_on_copy(__this_alloc, __that_alloc);\n-            }\n+\t    }\n \t  assign(__list.cbegin(), __list.cend());\n-        }\n+\t}\n       return *this;\n     }\n \n@@ -190,12 +185,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       size_type __len = 0;\n       while (__k._M_next() != end() && __len < __sz)\n-        {\n-          ++__k;\n-          ++__len;\n-        }\n+\t{\n+\t  ++__k;\n+\t  ++__len;\n+\t}\n       if (__len == __sz)\n-        erase_after(__k, end());\n+\terase_after(__k, end());\n       else\n \t_M_default_insert_after(__k, __sz - __len);\n     }\n@@ -209,14 +204,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       size_type __len = 0;\n       while (__k._M_next() != end() && __len < __sz)\n-        {\n-          ++__k;\n-          ++__len;\n-        }\n+\t{\n+\t  ++__k;\n+\t  ++__len;\n+\t}\n       if (__len == __sz)\n-        erase_after(__k, end());\n+\terase_after(__k, end());\n       else\n-        insert_after(__k, __sz - __len, __val);\n+\tinsert_after(__k, __sz - __len, __val);\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -233,7 +228,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t__end = __end->_M_next;\n \n       if (__b != __end)\n-\treturn iterator(__tmp->_M_transfer_after(__b, __end));      \n+\treturn iterator(__tmp->_M_transfer_after(__b, __end));\n       else\n \treturn iterator(__tmp);\n     }\n@@ -292,8 +287,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _Node_base* __extra = nullptr;\n \n       while (_Node* __tmp = static_cast<_Node*>(__curr->_M_next))\n-        {\n-          if (*__tmp->_M_valptr() == __val)\n+\t{\n+\t  if (*__tmp->_M_valptr() == __val)\n \t    {\n \t      if (__tmp->_M_valptr() != std::__addressof(__val))\n \t\t{\n@@ -304,7 +299,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t__extra = __curr;\n \t    }\n \t  __curr = __curr->_M_next;\n-        }\n+\t}\n \n       if (__extra)\n \tthis->_M_erase_after(__extra);\n@@ -317,13 +312,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       remove_if(_Pred __pred)\n       {\n \t_Node_base* __curr = &this->_M_impl._M_head;\n-        while (_Node* __tmp = static_cast<_Node*>(__curr->_M_next))\n-          {\n-            if (__pred(*__tmp->_M_valptr()))\n-              this->_M_erase_after(__curr);\n-            else\n-              __curr = __curr->_M_next;\n-          }\n+\twhile (_Node* __tmp = static_cast<_Node*>(__curr->_M_next))\n+\t  {\n+\t    if (__pred(*__tmp->_M_valptr()))\n+\t      this->_M_erase_after(__curr);\n+\t    else\n+\t      __curr = __curr->_M_next;\n+\t  }\n       }\n \n   template<typename _Tp, typename _Alloc>\n@@ -332,19 +327,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       forward_list<_Tp, _Alloc>::\n       unique(_BinPred __binary_pred)\n       {\n-        iterator __first = begin();\n-        iterator __last = end();\n-        if (__first == __last)\n-          return;\n-        iterator __next = __first;\n-        while (++__next != __last)\n-        {\n-          if (__binary_pred(*__first, *__next))\n-            erase_after(__first);\n-          else\n-            __first = __next;\n-          __next = __first;\n-        }\n+\titerator __first = begin();\n+\titerator __last = end();\n+\tif (__first == __last)\n+\t  return;\n+\titerator __next = __first;\n+\twhile (++__next != __last)\n+\t{\n+\t  if (__binary_pred(*__first, *__next))\n+\t    erase_after(__first);\n+\t  else\n+\t    __first = __next;\n+\t  __next = __first;\n+\t}\n       }\n \n   template<typename _Tp, typename _Alloc>\n@@ -353,44 +348,42 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       forward_list<_Tp, _Alloc>::\n       merge(forward_list&& __list, _Comp __comp)\n       {\n-        _Node_base* __node = &this->_M_impl._M_head;\n-        while (__node->_M_next && __list._M_impl._M_head._M_next)\n-          {\n-            if (__comp(*static_cast<_Node*>\n-                       (__list._M_impl._M_head._M_next)->_M_valptr(),\n-                       *static_cast<_Node*>\n-                       (__node->_M_next)->_M_valptr()))\n-              __node->_M_transfer_after(&__list._M_impl._M_head,\n-                                        __list._M_impl._M_head._M_next);\n-            __node = __node->_M_next;\n-          }\n-        if (__list._M_impl._M_head._M_next)\n-          {\n-            __node->_M_next = __list._M_impl._M_head._M_next;\n-            __list._M_impl._M_head._M_next = 0;\n-          }\n+\t_Node_base* __node = &this->_M_impl._M_head;\n+\twhile (__node->_M_next && __list._M_impl._M_head._M_next)\n+\t  {\n+\t    if (__comp(*static_cast<_Node*>\n+\t\t       (__list._M_impl._M_head._M_next)->_M_valptr(),\n+\t\t       *static_cast<_Node*>\n+\t\t       (__node->_M_next)->_M_valptr()))\n+\t      __node->_M_transfer_after(&__list._M_impl._M_head,\n+\t\t\t\t\t__list._M_impl._M_head._M_next);\n+\t    __node = __node->_M_next;\n+\t  }\n+\n+\tif (__list._M_impl._M_head._M_next)\n+\t  *__node = std::move(__list._M_impl._M_head);\n       }\n \n   template<typename _Tp, typename _Alloc>\n     bool\n     operator==(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     {\n       //  We don't have size() so we need to walk through both lists\n       //  making sure both iterators are valid.\n       auto __ix = __lx.cbegin();\n       auto __iy = __ly.cbegin();\n       while (__ix != __lx.cend() && __iy != __ly.cend())\n-        {\n-          if (*__ix != *__iy)\n-            return false;\n-          ++__ix;\n-          ++__iy;\n-        }\n+\t{\n+\t  if (*__ix != *__iy)\n+\t    return false;\n+\t  ++__ix;\n+\t  ++__iy;\n+\t}\n       if (__ix == __lx.cend() && __iy == __ly.cend())\n-        return true;\n+\treturn true;\n       else\n-        return false;\n+\treturn false;\n     }\n \n   template<typename _Tp, class _Alloc>\n@@ -399,103 +392,102 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       forward_list<_Tp, _Alloc>::\n       sort(_Comp __comp)\n       {\n-        // If `next' is 0, return immediately.\n-        _Node* __list = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n-        if (!__list)\n-          return;\n-\n-        unsigned long __insize = 1;\n-\n-        while (1)\n-          {\n-            _Node* __p = __list;\n-            __list = 0;\n-            _Node* __tail = 0;\n-\n-            // Count number of merges we do in this pass.\n-            unsigned long __nmerges = 0;\n-\n-            while (__p)\n-              {\n-                ++__nmerges;\n-                // There exists a merge to be done.\n-                // Step `insize' places along from p.\n-                _Node* __q = __p;\n-                unsigned long __psize = 0;\n-                for (unsigned long __i = 0; __i < __insize; ++__i)\n-                  {\n-                    ++__psize;\n-                    __q = static_cast<_Node*>(__q->_M_next);\n-                    if (!__q)\n-                      break;\n-                  }\n-\n-                // If q hasn't fallen off end, we have two lists to merge.\n-                unsigned long __qsize = __insize;\n-\n-                // Now we have two lists; merge them.\n-                while (__psize > 0 || (__qsize > 0 && __q))\n-                  {\n-                    // Decide whether next node of merge comes from p or q.\n-                    _Node* __e;\n-                    if (__psize == 0)\n-                      {\n-                        // p is empty; e must come from q.\n-                        __e = __q;\n-                        __q = static_cast<_Node*>(__q->_M_next);\n-                        --__qsize;\n-                      }\n-                    else if (__qsize == 0 || !__q)\n-                      {\n-                        // q is empty; e must come from p.\n-                        __e = __p;\n-                        __p = static_cast<_Node*>(__p->_M_next);\n-                        --__psize;\n-                      }\n-                    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))\n-                      {\n-                        // First node of p is lower; e must come from p.\n-                        __e = __p;\n-                        __p = static_cast<_Node*>(__p->_M_next);\n-                        --__psize;\n-                      }\n-                    else\n-                      {\n-                        // First node of q is lower; e must come from q.\n-                        __e = __q;\n-                        __q = static_cast<_Node*>(__q->_M_next);\n-                        --__qsize;\n-                      }\n-\n-                    // Add the next node to the merged list.\n-                    if (__tail)\n-                      __tail->_M_next = __e;\n-                    else\n-                      __list = __e;\n-                    __tail = __e;\n-                  }\n-\n-                // Now p has stepped `insize' places along, and q has too.\n-                __p = __q;\n-              }\n-            __tail->_M_next = 0;\n-\n-            // If we have done only one merge, we're finished.\n-            // Allow for nmerges == 0, the empty list case.\n-            if (__nmerges <= 1)\n-              {\n-                this->_M_impl._M_head._M_next = __list;\n-                return;\n-              }\n-\n-            // Otherwise repeat, merging lists twice the size.\n-            __insize *= 2;\n-          }\n+\t// If `next' is nullptr, return immediately.\n+\t_Node* __list = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+\tif (!__list)\n+\t  return;\n+\n+\tunsigned long __insize = 1;\n+\n+\twhile (1)\n+\t  {\n+\t    _Node* __p = __list;\n+\t    __list = nullptr;\n+\t    _Node* __tail = nullptr;\n+\n+\t    // Count number of merges we do in this pass.\n+\t    unsigned long __nmerges = 0;\n+\n+\t    while (__p)\n+\t      {\n+\t\t++__nmerges;\n+\t\t// There exists a merge to be done.\n+\t\t// Step `insize' places along from p.\n+\t\t_Node* __q = __p;\n+\t\tunsigned long __psize = 0;\n+\t\tfor (unsigned long __i = 0; __i < __insize; ++__i)\n+\t\t  {\n+\t\t    ++__psize;\n+\t\t    __q = static_cast<_Node*>(__q->_M_next);\n+\t\t    if (!__q)\n+\t\t      break;\n+\t\t  }\n+\n+\t\t// If q hasn't fallen off end, we have two lists to merge.\n+\t\tunsigned long __qsize = __insize;\n+\n+\t\t// Now we have two lists; merge them.\n+\t\twhile (__psize > 0 || (__qsize > 0 && __q))\n+\t\t  {\n+\t\t    // Decide whether next node of merge comes from p or q.\n+\t\t    _Node* __e;\n+\t\t    if (__psize == 0)\n+\t\t      {\n+\t\t\t// p is empty; e must come from q.\n+\t\t\t__e = __q;\n+\t\t\t__q = static_cast<_Node*>(__q->_M_next);\n+\t\t\t--__qsize;\n+\t\t      }\n+\t\t    else if (__qsize == 0 || !__q)\n+\t\t      {\n+\t\t\t// q is empty; e must come from p.\n+\t\t\t__e = __p;\n+\t\t\t__p = static_cast<_Node*>(__p->_M_next);\n+\t\t\t--__psize;\n+\t\t      }\n+\t\t    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))\n+\t\t      {\n+\t\t\t// First node of p is lower; e must come from p.\n+\t\t\t__e = __p;\n+\t\t\t__p = static_cast<_Node*>(__p->_M_next);\n+\t\t\t--__psize;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t// First node of q is lower; e must come from q.\n+\t\t\t__e = __q;\n+\t\t\t__q = static_cast<_Node*>(__q->_M_next);\n+\t\t\t--__qsize;\n+\t\t      }\n+\n+\t\t    // Add the next node to the merged list.\n+\t\t    if (__tail)\n+\t\t      __tail->_M_next = __e;\n+\t\t    else\n+\t\t      __list = __e;\n+\t\t    __tail = __e;\n+\t\t  }\n+\n+\t\t// Now p has stepped `insize' places along, and q has too.\n+\t\t__p = __q;\n+\t      }\n+\t    __tail->_M_next = nullptr;\n+\n+\t    // If we have done only one merge, we're finished.\n+\t    // Allow for nmerges == 0, the empty list case.\n+\t    if (__nmerges <= 1)\n+\t      {\n+\t\tthis->_M_impl._M_head._M_next = __list;\n+\t\treturn;\n+\t      }\n+\n+\t    // Otherwise repeat, merging lists twice the size.\n+\t    __insize *= 2;\n+\t  }\n       }\n- \n+\n _GLIBCXX_END_NAMESPACE_CONTAINER\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #endif /* _FORWARD_LIST_TCC */\n-"}, {"sha": "804ba339db6da04e8accb9a8acbe2b7d4ff0682b", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/allocator/default_init.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fdefault_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ce74bbdd695ae793c03f93cfd55842806651e6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fdefault_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fdefault_init.cc?ref=75ce74bbdd695ae793c03f93cfd55842806651e6", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O0\" }\n+// { dg-xfail-run-if \"PR c++/65816\" { *-*-* } }\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+#include <ext/aligned_buffer.h>\n+\n+using T = int;\n+\n+using __gnu_test::default_init_allocator;\n+\n+void test01()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::forward_list<T, alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type;\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+void test02()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::forward_list<T, alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type();\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}