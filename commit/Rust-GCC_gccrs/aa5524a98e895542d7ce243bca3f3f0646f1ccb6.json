{"sha": "aa5524a98e895542d7ce243bca3f3f0646f1ccb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1NTI0YTk4ZTg5NTU0MmQ3Y2UyNDNiY2EzZjNmMDY0NmYxY2NiNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-03-09T16:01:10Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-03-09T16:01:10Z"}, "message": "Fix suboptimal code generation by register elimination\n\nFrom-SVN: r32446", "tree": {"sha": "2920d7b1f8f838a3962928b1195fa0fa7e34ca41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2920d7b1f8f838a3962928b1195fa0fa7e34ca41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa5524a98e895542d7ce243bca3f3f0646f1ccb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5524a98e895542d7ce243bca3f3f0646f1ccb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa5524a98e895542d7ce243bca3f3f0646f1ccb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5524a98e895542d7ce243bca3f3f0646f1ccb6/comments", "author": null, "committer": null, "parents": [{"sha": "fb863f625e01b70f4e8335b81c66d5f41c2dc54a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb863f625e01b70f4e8335b81c66d5f41c2dc54a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb863f625e01b70f4e8335b81c66d5f41c2dc54a"}], "stats": {"total": 85, "additions": 53, "deletions": 32}, "files": [{"sha": "c721bf51e8b8c9146927541fb8777b6b9ec52c18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa5524a98e895542d7ce243bca3f3f0646f1ccb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa5524a98e895542d7ce243bca3f3f0646f1ccb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa5524a98e895542d7ce243bca3f3f0646f1ccb6", "patch": "@@ -1,3 +1,8 @@\n+2000-03-09  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload1.c (eliminate_regs_in_insn): Handle additions of eliminable\n+\tregister and a constant specially.\n+\n 2000-03-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* libgcc2.h: New file."}, {"sha": "a716b132d72785af31064c4dec7aa6ff977a572d", "filename": "gcc/reload1.c", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa5524a98e895542d7ce243bca3f3f0646f1ccb6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa5524a98e895542d7ce243bca3f3f0646f1ccb6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=aa5524a98e895542d7ce243bca3f3f0646f1ccb6", "patch": "@@ -2903,41 +2903,57 @@ eliminate_regs_in_insn (insn, replace)\n \t    val = 1;\n \t    goto done;\n \t  }\n+    }\n \n-      /* Check for (set (reg) (plus (reg from) (offset))) where the offset\n-\t in the insn is the negative of the offset in FROM.  Substitute\n-\t (set (reg) (reg to)) for the insn and change its code.\n+  /* We allow one special case which happens to work on all machines we\n+     currently support: a single set with the source being a PLUS of an\n+     eliminable register and a constant.  */\n+  if (old_set\n+      && GET_CODE (SET_SRC (old_set)) == PLUS\n+      && GET_CODE (XEXP (SET_SRC (old_set), 0)) == REG\n+      && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT\n+      && REGNO (XEXP (SET_SRC (old_set), 0)) < FIRST_PSEUDO_REGISTER)\n+    {\n+      rtx reg = XEXP (SET_SRC (old_set), 0);\n+      int offset = INTVAL (XEXP (SET_SRC (old_set), 1));\n \n-\t We have to do this here, rather than in eliminate_regs, so that we can\n-\t change the insn code.  */\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->from_rtx == reg && ep->can_eliminate)\n+\t  {\n+\t    offset += ep->offset;\n \n-      if (GET_CODE (SET_SRC (old_set)) == PLUS\n-\t  && GET_CODE (XEXP (SET_SRC (old_set), 0)) == REG\n-\t  && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT)\n-\tfor (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n-\t     ep++)\n-\t  if (ep->from_rtx == XEXP (SET_SRC (old_set), 0)\n-\t      && ep->can_eliminate)\n-\t    {\n-\t      /* We must stop at the first elimination that will be used.\n-\t\t If this one would replace the PLUS with a REG, do it\n-\t\t now.  Otherwise, quit the loop and let eliminate_regs\n-\t\t do its normal replacement.  */\n-\t      if (ep->offset == - INTVAL (XEXP (SET_SRC (old_set), 1)))\n-\t\t{\n-\t\t  /* We assume here that we don't need a PARALLEL of\n-\t\t     any CLOBBERs for this assignment.  There's not\n-\t\t     much we can do if we do need it.  */\n-\t\t  PATTERN (insn) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t\tSET_DEST (old_set),\n-\t\t\t\t\t\tep->to_rtx);\n-\t\t  INSN_CODE (insn) = -1;\n-\t\t  val = 1;\n-\t\t  goto done;\n-\t\t}\n+\t    if (offset == 0)\n+\t      {\n+\t\t/* We assume here that we don't need a PARALLEL of\n+\t\t   any CLOBBERs for this assignment.  There's not\n+\t\t   much we can do if we do need it.  */\n+\t\tPATTERN (insn) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t      SET_DEST (old_set),\n+\t\t\t\t\t      ep->to_rtx);\n+\t\tINSN_CODE (insn) = recog (PATTERN (insn), insn, 0);\n+\t\tif (INSN_CODE (insn) < 0)\n+\t\t  abort ();\n+\t      }\n+\t    else\n+\t      {\n+\t\tnew_body = old_body;\n+\t\tif (! replace)\n+\t\t  {\n+\t\t    new_body = copy_insn (old_body);\n+\t\t    if (REG_NOTES (insn))\n+\t\t      REG_NOTES (insn) = copy_insn_1 (REG_NOTES (insn));\n+\t\t  }\n+\t\tPATTERN (insn) = new_body;\n+\t\told_set = single_set (insn);\n \n-\t      break;\n-\t    }\n+\t\tXEXP (SET_SRC (old_set), 0) = ep->to_rtx;\n+\t\tXEXP (SET_SRC (old_set), 1) = GEN_INT (offset);\n+\t      }\n+\t    val = 1;\n+\t    /* This can't have an effect on elimination offsets, so skip right\n+\t       to the end.  */\n+\t    goto done;\n+\t  }\n     }\n \n   /* Determine the effects of this insn on elimination offsets.  */\n@@ -2990,7 +3006,7 @@ eliminate_regs_in_insn (insn, replace)\n \n   for (i = 0; i < recog_data.n_dups; i++)\n     *recog_data.dup_loc[i]\n-\t= *recog_data.operand_loc[(int)recog_data.dup_num[i]];\n+      = *recog_data.operand_loc[(int)recog_data.dup_num[i]];\n \n   /* If any eliminable remain, they aren't eliminable anymore.  */\n   check_eliminable_occurrences (old_body);"}]}