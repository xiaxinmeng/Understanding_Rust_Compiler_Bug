{"sha": "566d377a296f571eed3af6609f75d57e9bb5eb13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY2ZDM3N2EyOTZmNTcxZWVkM2FmNjYwOWY3NWQ1N2U5YmI1ZWIxMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-01-30T09:22:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-01-30T09:22:17Z"}, "message": "re PR tree-optimization/64829 ([ARM] ICE at -O3 in vect_get_vec_def_for_stmt_copy)\n\n2015-01-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/64829\n\t* tree-vect-patterns.c (vect_handle_widen_op_by_const): Do\n\tnot add a widening conversion pattern but hand off extra\n\twidenings to callers.\n\t(vect_recog_widen_mult_pattern): Handle extra widening produced\n\tby vect_handle_widen_op_by_const.\n\t(vect_recog_widen_shift_pattern): Likewise.\n\t(vect_pattern_recog_1): Remove excess vertical space in dumping.\n\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Likewise.\n\t(vect_init_vector_1): Likewise.\n\t(vect_get_vec_def_for_operand): Likewise.\n\t(vect_finish_stmt_generation): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vect_analyze_stmt): Likewise.\n\t(vect_is_simple_use): Likewise.\n\n\t* gcc.dg/vect/pr64829.c: New testcase.\n\nFrom-SVN: r220275", "tree": {"sha": "289135d8ede5314f55c8ecdb94b2c845dc69ca21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289135d8ede5314f55c8ecdb94b2c845dc69ca21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/566d377a296f571eed3af6609f75d57e9bb5eb13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566d377a296f571eed3af6609f75d57e9bb5eb13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/566d377a296f571eed3af6609f75d57e9bb5eb13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566d377a296f571eed3af6609f75d57e9bb5eb13/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "445e588866137e1e26d9e69f5d657382f3d91006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445e588866137e1e26d9e69f5d657382f3d91006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445e588866137e1e26d9e69f5d657382f3d91006"}], "stats": {"total": 164, "additions": 117, "deletions": 47}, "files": [{"sha": "6ddbc93bcb0f0645c39c9c8d61b0851a5748b443", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=566d377a296f571eed3af6609f75d57e9bb5eb13", "patch": "@@ -1,3 +1,21 @@\n+2015-01-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64829\n+\t* tree-vect-patterns.c (vect_handle_widen_op_by_const): Do\n+\tnot add a widening conversion pattern but hand off extra\n+\twidenings to callers.\n+\t(vect_recog_widen_mult_pattern): Handle extra widening produced\n+\tby vect_handle_widen_op_by_const.\n+\t(vect_recog_widen_shift_pattern): Likewise.\n+\t(vect_pattern_recog_1): Remove excess vertical space in dumping.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vect_init_vector_1): Likewise.\n+\t(vect_get_vec_def_for_operand): Likewise.\n+\t(vect_finish_stmt_generation): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vect_analyze_stmt): Likewise.\n+\t(vect_is_simple_use): Likewise.\n+\n 2015-01-29  Jeff Law  <law@redhat.com>\n \n \t* combine.c (try_combine): Fix typo in comment."}, {"sha": "5ce99e61dbf2e8537af0acd47694200b162fd89f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=566d377a296f571eed3af6609f75d57e9bb5eb13", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64829\n+\t* gcc.dg/vect/pr64829.c: New testcase.\n+\n 2015-01-29  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/64709"}, {"sha": "9b8e3b6a7a48eee76f3e339d8d7fb760a7793fcb", "filename": "gcc/testsuite/gcc.dg/vect/pr64829.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr64829.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr64829.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr64829.c?ref=566d377a296f571eed3af6609f75d57e9bb5eb13", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+\n+typedef unsigned char Uint8;\n+typedef int Sint32;\n+typedef unsigned int Uint32;\n+\n+typedef union RMColorDataRef\n+{\n+  Uint8* data8;\n+} RMColorDataRef;\n+\n+typedef struct RMColorData\n+{\n+  Uint32 dataCount;\n+  RMColorDataRef dataRef;\n+} RMColorData;\n+\n+typedef struct RMColorTable\n+{\n+  Uint8 dataCompsOut;\n+  RMColorDataRef dataRef;\n+} RMColorTable;\n+\n+int fail ( const RMColorData * pInColor,\n+\t   RMColorData * pOutColor,\n+\t   const RMColorTable * pColorTable )\n+{\n+  Uint32 comp;\n+  Uint8 nCompOut;\n+\n+  Sint32 result;\n+\n+  Uint32 interpFrac1, interpFrac2, interpFrac3;\n+  Sint32 val0, val1, val2, val3;\n+\n+  Uint8 * pOut;\n+\n+  const Uint8 * pClutData;\n+  const Uint8 * pCornerPoint0;\n+\n+  Uint8 lastOut[((8) > (4) ? (8) : (4))];\n+\n+  pOut = pOutColor->dataRef.data8;\n+  pClutData = pColorTable->dataRef.data8;\n+\n+  nCompOut = pColorTable->dataCompsOut;\n+\n+  pCornerPoint0 = pClutData;\n+\n+  for (comp = 0; comp < nCompOut; comp++)\n+    {\n+      val0 = *pCornerPoint0++;\n+\n+      result = val0 << 4;\n+\n+      result += (val1 - val0) * interpFrac1;\n+      result += (val2 - val1) * interpFrac2;\n+      result += (val3 - val2) * interpFrac3;\n+\n+      *pOut++ = lastOut[comp] = (Uint8)(result >> 4);\n+    }\n+\n+  return (0);\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "86d2447361b4d9c0e160bfa1afa26332b5bc2e59", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=566d377a296f571eed3af6609f75d57e9bb5eb13", "patch": "@@ -721,16 +721,15 @@ vect_recog_sad_pattern (vec<gimple> *stmts, tree *type_in,\n    HALF_TYPE, and there is an intermediate type (2 times smaller than TYPE)\n    that satisfies the above restrictions,  we can perform a widening opeartion\n    from the intermediate type to TYPE and replace a_T = (TYPE) a_t;\n-   with a_it = (interm_type) a_t;  */\n+   with a_it = (interm_type) a_t;  Store such operation in *WSTMT.  */\n \n static bool\n vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n \t\t               tree const_oprnd, tree *oprnd,\n-   \t\t               vec<gimple> *stmts, tree type,\n+   \t\t               gimple *wstmt, tree type,\n \t\t\t       tree *half_type, gimple def_stmt)\n {\n   tree new_type, new_oprnd;\n-  gimple new_stmt;\n \n   if (code != MULT_EXPR && code != LSHIFT_EXPR)\n     return false;\n@@ -761,29 +760,11 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n           && compare_tree_int (const_oprnd, TYPE_PRECISION (new_type)) == 1))\n     return false;\n \n-  /* Use NEW_TYPE for widening operation.  */\n-  if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)))\n-    {\n-      new_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n-      /* Check if the already created pattern stmt is what we need.  */\n-      if (!is_gimple_assign (new_stmt)\n-          || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (new_stmt))\n-          || TREE_TYPE (gimple_assign_lhs (new_stmt)) != new_type)\n-        return false;\n-\n-      stmts->safe_push (def_stmt);\n-      *oprnd = gimple_assign_lhs (new_stmt);\n-    }\n-  else\n-    {\n-      /* Create a_T = (NEW_TYPE) a_t;  */\n-      *oprnd = gimple_assign_rhs1 (def_stmt);\n-      new_oprnd = make_ssa_name (new_type);\n-      new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, *oprnd);\n-      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n-      stmts->safe_push (def_stmt);\n-      *oprnd = new_oprnd;\n-    }\n+  /* Use NEW_TYPE for widening operation and create a_T = (NEW_TYPE) a_t;  */\n+  *oprnd = gimple_assign_rhs1 (def_stmt);\n+  new_oprnd = make_ssa_name (new_type);\n+  *wstmt = gimple_build_assign (new_oprnd, NOP_EXPR, *oprnd);\n+  *oprnd = new_oprnd;\n \n   *half_type = new_type;\n   return true;\n@@ -920,7 +901,7 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n       if (TREE_CODE (oprnd1) == INTEGER_CST\n           && TREE_CODE (half_type0) == INTEGER_TYPE\n           && vect_handle_widen_op_by_const (last_stmt, MULT_EXPR, oprnd1,\n-\t\t                            &oprnd0, stmts, type,\n+\t\t                            &oprnd0, &new_stmt, type,\n \t\t\t\t\t    &half_type0, def_stmt0))\n \t{\n \t  half_type1 = half_type0;\n@@ -934,6 +915,10 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n      the smaller type into the larger type.  */\n   if (TYPE_PRECISION (half_type0) != TYPE_PRECISION (half_type1))\n     {\n+      /* If we already used up the single-stmt slot give up.  */\n+      if (new_stmt)\n+\treturn NULL;\n+\n       tree* oprnd = NULL;\n       gimple def_stmt = NULL;\n \n@@ -1734,7 +1719,7 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,\n \n   /* Check operand 0: it has to be defined by a type promotion.  */\n   if (!type_conversion_p (oprnd0, last_stmt, false, &half_type0, &def_stmt0,\n-                          &promotion)\n+\t\t\t  &promotion)\n       || !promotion)\n      return NULL;\n \n@@ -1764,8 +1749,9 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,\n     }\n \n   /* Check if this a widening operation.  */\n+  gimple wstmt = NULL;\n   if (!vect_handle_widen_op_by_const (last_stmt, LSHIFT_EXPR, oprnd1,\n-       \t\t\t\t      &oprnd0, stmts,\n+       \t\t\t\t      &oprnd0, &wstmt,\n \t                              type, &half_type0, def_stmt0))\n     return NULL;\n \n@@ -1793,6 +1779,17 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,\n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt =\n     gimple_build_assign (var, WIDEN_LSHIFT_EXPR, oprnd0, oprnd1);\n+  if (wstmt)\n+    {\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+      bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+      new_pattern_def_seq (stmt_vinfo, wstmt);\n+      stmt_vec_info new_stmt_info\n+\t= new_stmt_vec_info (wstmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (wstmt, new_stmt_info);\n+      STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n+    }\n \n   if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n@@ -3414,7 +3411,6 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"pattern recognized: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* Mark the stmts that are involved in the pattern. */\n@@ -3441,7 +3437,6 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"additional pattern stmt: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);"}, {"sha": "aa9d43f0fca38bfae74f556814e1b5e9169208fe", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566d377a296f571eed3af6609f75d57e9bb5eb13/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=566d377a296f571eed3af6609f75d57e9bb5eb13", "patch": "@@ -676,7 +676,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n@@ -689,7 +688,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: stmt relevant? \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant, &live_p))\n@@ -708,7 +706,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"worklist: examine stmt: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       /* Examine the USEs of STMT. For each USE, mark the stmt that defines it\n@@ -809,7 +806,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t\t\t\t    live_p, relevant, &worklist, false)\n \t\t      || !process_use (stmt, TREE_OPERAND (op, 1), loop_vinfo,\n \t\t\t\t       live_p, relevant, &worklist, false))\n-        return false;\n+\t\t    return false;\n \t\t  i = 2;\n \t\t}\n \t      for (; i < gimple_num_ops (stmt); i++)\n@@ -847,7 +844,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t  gcc_assert (decl);\n \t  if (!process_use (stmt, off, loop_vinfo, live_p, relevant,\n \t\t\t    &worklist, true))\n-      return false;\n+\t    return false;\n \t}\n     } /* while worklist */\n \n@@ -1319,7 +1316,6 @@ vect_init_vector_1 (gimple stmt, gimple new_stmt, gimple_stmt_iterator *gsi)\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"created new init_stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n-      dump_printf (MSG_NOTE, \"\\n\");\n     }\n }\n \n@@ -1423,7 +1419,6 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n           else\n             dump_printf_loc (MSG_NOTE, vect_location, \"  def_stmt =  \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n-          dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n \n@@ -1720,7 +1715,6 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n-      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   gimple_set_location (vec_stmt, gimple_location (stmt));\n@@ -6584,7 +6578,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t   \"hoisting out of the vectorized \"\n \t\t\t\t\t   \"loop: \");\n \t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t\t\t  dump_printf (MSG_NOTE, \"\\n\");\n \t\t\t}\n \t\t      tree tem = copy_ssa_name (scalar_dest);\n \t\t      gsi_insert_on_edge_immediate\n@@ -6999,7 +6992,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   if (gimple_has_volatile_ops (stmt))\n@@ -7042,7 +7034,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n               dump_printf_loc (MSG_NOTE, vect_location,\n                                \"==> examining pattern statement: \");\n               dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-              dump_printf (MSG_NOTE, \"\\n\");\n             }\n         }\n       else\n@@ -7065,7 +7056,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"==> examining pattern statement: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node))\n@@ -7090,7 +7080,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"==> examining pattern def statement: \");\n \t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_def_stmt, 0);\n-                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n \t      if (!vect_analyze_stmt (pattern_def_stmt,\n@@ -7202,7 +7191,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                            \"not vectorized: relevant stmt not \");\n           dump_printf (MSG_MISSED_OPTIMIZATION, \"supported: \");\n           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       return false;\n@@ -7225,7 +7213,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                            \"not vectorized: live stmt not \");\n           dump_printf (MSG_MISSED_OPTIMIZATION,  \"supported: \");\n           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n        return false;\n@@ -7727,7 +7714,6 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"def_stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, *def_stmt, 0);\n-      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* Empty stmt is expected only in case of a function argument."}]}