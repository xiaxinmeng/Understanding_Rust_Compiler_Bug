{"sha": "d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU4MDNiOTg3NmIzZDExYzkzZDFhMTBmYWJiM2ZiYjFjNGExNGJkNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-07-20T18:06:18Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-07-20T18:08:58Z"}, "message": "Correct handling of constant representations containing embedded nuls.\n\nResolves:\nPR middle-end/95189 - memcmp being wrongly stripped like strcm\nPR middle-end/95886 - suboptimal memcpy with embedded zero bytes\n\ngcc/ChangeLog:\n\n\tPR middle-end/95189\n\tPR middle-end/95886\n\t* builtins.c (inline_expand_builtin_string_cmp): Rename...\n\t(inline_expand_builtin_bytecmp): ...to this.\n\t(builtin_memcpy_read_str): Don't expect data to be nul-terminated.\n\t(expand_builtin_memory_copy_args): Handle object representations\n\twith embedded nul bytes.\n\t(expand_builtin_memcmp): Same.\n\t(expand_builtin_strcmp): Adjust call to naming change.\n\t(expand_builtin_strncmp): Same.\n\t* expr.c (string_constant): Create empty strings with nonzero size.\n\t* fold-const.c (c_getstr): Rename locals and update comments.\n\t* tree.c (build_string): Accept null pointer argument.\n\t(build_string_literal): Same.\n\t* tree.h (build_string): Provide a default.\n\t(build_string_literal): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/95189\n\tPR middle-end/95886\n\t* gcc.dg/memcmp-pr95189.c: New test.\n\t* gcc.dg/strncmp-3.c: New test.\n\t* gcc.target/i386/memcpy-pr95886.c: New test.", "tree": {"sha": "21c9c55bfd9003436d22c960d3578579af9dd744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21c9c55bfd9003436d22c960d3578579af9dd744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e99ed65cbedf7a6c0abb9cd63c191326995fd34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e99ed65cbedf7a6c0abb9cd63c191326995fd34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e99ed65cbedf7a6c0abb9cd63c191326995fd34"}], "stats": {"total": 455, "additions": 345, "deletions": 110}, "files": [{"sha": "228db78f32bfdcce31e23850e878843d7a45adcc", "filename": "gcc/builtins.c", "status": "modified", "additions": 90, "deletions": 63, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -122,7 +122,7 @@ static rtx expand_builtin_next_arg (void);\n static rtx expand_builtin_va_start (tree);\n static rtx expand_builtin_va_end (tree);\n static rtx expand_builtin_va_copy (tree);\n-static rtx inline_expand_builtin_string_cmp (tree, rtx);\n+static rtx inline_expand_builtin_bytecmp (tree, rtx);\n static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n@@ -3230,20 +3230,18 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n }\n \n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n-   bytes from constant string DATA + OFFSET and return it as target\n-   constant.  */\n+   bytes from bytes at DATA + OFFSET and return it reinterpreted as\n+   a target constant.  */\n \n static rtx\n builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n \t\t\t scalar_int_mode mode)\n {\n-  const char *str = (const char *) data;\n+  /* The REPresentation pointed to by DATA need not be a nul-terminated\n+     string but the caller guarantees it's large enough for MODE.  */\n+  const char *rep = (const char *) data;\n \n-  gcc_assert (offset >= 0\n-\t      && ((unsigned HOST_WIDE_INT) offset + GET_MODE_SIZE (mode)\n-\t\t  <= strlen (str) + 1));\n-\n-  return c_readstr (str + offset, mode);\n+  return c_readstr (rep + offset, mode, /*nul_terminated=*/false);\n }\n \n /* LEN specify length of the block of memcpy/memset operation.\n@@ -4414,7 +4412,6 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n \t\t\t\t rtx target, tree exp, memop_ret retmode,\n \t\t\t\t bool might_overlap)\n {\n-  const char *src_str;\n   unsigned int src_align = get_pointer_alignment (src);\n   unsigned int dest_align = get_pointer_alignment (dest);\n   rtx dest_mem, src_mem, dest_addr, len_rtx;\n@@ -4446,24 +4443,29 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n   len_rtx = expand_normal (len);\n   determine_block_size (len, len_rtx, &min_size, &max_size,\n \t\t\t&probable_max_size);\n-  src_str = c_getstr (src);\n-\n-  /* If SRC is a string constant and block move would be done by\n-     pieces, we can avoid loading the string from memory and only\n-     stored the computed constants.  This works in the overlap\n-     (memmove) case as well because store_by_pieces just generates a\n-     series of stores of constants from the string constant returned\n-     by c_getstr().  */\n-  if (src_str\n+\n+  /* Try to get the byte representation of the constant SRC points to,\n+     with its byte size in NBYTES.  */\n+  unsigned HOST_WIDE_INT nbytes;\n+  const char *rep = c_getstr (src, &nbytes);\n+\n+  /* If the function's constant bound LEN_RTX is less than or equal\n+     to the byte size of the representation of the constant argument,\n+     and if block move would be done by pieces, we can avoid loading\n+     the bytes from memory and only store the computed constant.\n+     This works in the overlap (memmove) case as well because\n+     store_by_pieces just generates a series of stores of constants\n+     from the representation returned by c_getstr().  */\n+  if (rep\n       && CONST_INT_P (len_rtx)\n-      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= nbytes\n       && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t      CONST_CAST (char *, rep),\n \t\t\t      dest_align, false))\n     {\n       dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n \t\t\t\t  builtin_memcpy_read_str,\n-\t\t\t\t  CONST_CAST (char *, src_str),\n+\t\t\t\t  CONST_CAST (char *, rep),\n \t\t\t\t  dest_align, false, retmode);\n       dest_mem = force_operand (XEXP (dest_mem, 0), target);\n       dest_mem = convert_memory_address (ptr_mode, dest_mem);\n@@ -4487,7 +4489,8 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n   dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx, method,\n \t\t\t\t     expected_align, expected_size,\n \t\t\t\t     min_size, max_size, probable_max_size,\n-\t\t\t\t     use_mempcpy_call, &is_move_done, might_overlap);\n+\t\t\t\t     use_mempcpy_call, &is_move_done,\n+\t\t\t\t     might_overlap);\n \n   /* Bail out when a mempcpy call would be expanded as libcall and when\n      we have a target that provides a fast implementation\n@@ -5322,7 +5325,7 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n \n   if (!result_eq && fcode != BUILT_IN_BCMP)\n     {\n-      result = inline_expand_builtin_string_cmp (exp, target);\n+      result = inline_expand_builtin_bytecmp (exp, target);\n       if (result)\n \treturn result;\n     }\n@@ -5350,26 +5353,32 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n \n   by_pieces_constfn constfn = NULL;\n \n-  const char *src_str = c_getstr (arg2);\n-  if (result_eq && src_str == NULL)\n+  /* Try to get the byte representation of the constant ARG2 (or, only\n+     when the function's result is used for equality to zero, ARG1)\n+     points to, with its byte size in NBYTES.  */\n+  unsigned HOST_WIDE_INT nbytes;\n+  const char *rep = c_getstr (arg2, &nbytes);\n+  if (result_eq && rep == NULL)\n     {\n-      src_str = c_getstr (arg1);\n-      if (src_str != NULL)\n+      /* For equality to zero the arguments are interchangeable.  */\n+      rep = c_getstr (arg1, &nbytes);\n+      if (rep != NULL)\n \tstd::swap (arg1_rtx, arg2_rtx);\n     }\n \n-  /* If SRC is a string constant and block move would be done\n-     by pieces, we can avoid loading the string from memory\n-     and only stored the computed constants.  */\n-  if (src_str\n+  /* If the function's constant bound LEN_RTX is less than or equal\n+     to the byte size of the representation of the constant argument,\n+     and if block move would be done by pieces, we can avoid loading\n+     the bytes from memory and only store the computed constant result.  */\n+  if (rep\n       && CONST_INT_P (len_rtx)\n-      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1)\n+      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= nbytes)\n     constfn = builtin_memcpy_read_str;\n \n   result = emit_block_cmp_hints (arg1_rtx, arg2_rtx, len_rtx,\n \t\t\t\t TREE_TYPE (len), target,\n \t\t\t\t result_eq, constfn,\n-\t\t\t\t CONST_CAST (char *, src_str));\n+\t\t\t\t CONST_CAST (char *, rep));\n \n   if (result)\n     {\n@@ -5408,7 +5417,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n \n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n-  result = inline_expand_builtin_string_cmp (exp, target);\n+  result = inline_expand_builtin_bytecmp (exp, target);\n   if (result)\n     return result;\n \n@@ -5532,7 +5541,7 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n-  result = inline_expand_builtin_string_cmp (exp, target);\n+  result = inline_expand_builtin_bytecmp (exp, target);\n   if (result)\n     return result;\n \n@@ -7765,18 +7774,18 @@ inline_string_cmp (rtx target, tree var_str, const char *const_str,\n   return result;\n }\n \n-/* Inline expansion a call to str(n)cmp, with result going to\n-   TARGET if that's convenient.\n+/* Inline expansion of a call to str(n)cmp and memcmp, with result going\n+   to TARGET if that's convenient.\n    If the call is not been inlined, return NULL_RTX.  */\n+\n static rtx\n-inline_expand_builtin_string_cmp (tree exp, rtx target)\n+inline_expand_builtin_bytecmp (tree exp, rtx target)\n {\n   tree fndecl = get_callee_fndecl (exp);\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  unsigned HOST_WIDE_INT length = 0;\n   bool is_ncmp = (fcode == BUILT_IN_STRNCMP || fcode == BUILT_IN_MEMCMP);\n \n-  /* Do NOT apply this inlining expansion when optimizing for size or \n+  /* Do NOT apply this inlining expansion when optimizing for size or\n      optimization level below 2.  */\n   if (optimize < 2 || optimize_insn_for_size_p ())\n     return NULL_RTX;\n@@ -7799,29 +7808,47 @@ inline_expand_builtin_string_cmp (tree exp, rtx target)\n   unsigned HOST_WIDE_INT len2 = 0;\n   unsigned HOST_WIDE_INT len3 = 0;\n \n-  const char *src_str1 = c_getstr (arg1, &len1);\n-  const char *src_str2 = c_getstr (arg2, &len2);\n+  /* Get the object representation of the initializers of ARG1 and ARG2\n+     as strings, provided they refer to constant objects, with their byte\n+     sizes in LEN1 and LEN2, respectively.  */\n+  const char *bytes1 = c_getstr (arg1, &len1);\n+  const char *bytes2 = c_getstr (arg2, &len2);\n \n-  /* If neither strings is constant string, the call is not qualify.  */\n-  if (!src_str1 && !src_str2)\n+  /* Fail if neither argument refers to an initialized constant.  */\n+  if (!bytes1 && !bytes2)\n     return NULL_RTX;\n \n-  /* For strncmp, if the length is not a const, not qualify.  */\n   if (is_ncmp)\n     {\n+      /* Fail if the memcmp/strncmp bound is not a constant.  */\n       if (!tree_fits_uhwi_p (len3_tree))\n \treturn NULL_RTX;\n-      else\n-\tlen3 = tree_to_uhwi (len3_tree);\n-    }\n \n-  if (src_str1 != NULL)\n-    len1 = strnlen (src_str1, len1) + 1;\n+      len3 = tree_to_uhwi (len3_tree);\n \n-  if (src_str2 != NULL)\n-    len2 = strnlen (src_str2, len2) + 1;\n+      if (fcode == BUILT_IN_MEMCMP)\n+\t{\n+\t  /* Fail if the memcmp bound is greater than the size of either\n+\t     of the two constant objects.  */\n+\t  if ((bytes1 && len1 < len3)\n+\t      || (bytes2 && len2 < len3))\n+\t    return NULL_RTX;\n+\t}\n+    }\n \n-  int const_str_n = 0;\n+  if (fcode != BUILT_IN_MEMCMP)\n+    {\n+      /* For string functions (i.e., strcmp and strncmp) reduce LEN1\n+\t and LEN2 to the length of the nul-terminated string stored\n+\t in each.  */\n+      if (bytes1 != NULL)\n+\tlen1 = strnlen (bytes1, len1) + 1;\n+      if (bytes2 != NULL)\n+\tlen2 = strnlen (bytes2, len2) + 1;\n+    }\n+\n+  /* See inline_string_cmp.  */\n+  int const_str_n;\n   if (!len1)\n     const_str_n = 2;\n   else if (!len2)\n@@ -7831,23 +7858,23 @@ inline_expand_builtin_string_cmp (tree exp, rtx target)\n   else\n     const_str_n = 2;\n \n-  gcc_checking_assert (const_str_n > 0);\n-  length = (const_str_n == 1) ? len1 : len2;\n-\n-  if (is_ncmp && len3 < length)\n-    length = len3;\n+  /* For strncmp only, compute the new bound as the smallest of\n+     the lengths of the two strings (plus 1) and the bound provided\n+     to the function.  */\n+  unsigned HOST_WIDE_INT bound = (const_str_n == 1) ? len1 : len2;\n+  if (is_ncmp && len3 < bound)\n+    bound = len3;\n \n-  /* If the length of the comparision is larger than the threshold,\n+  /* If the bound of the comparison is larger than the threshold,\n      do nothing.  */\n-  if (length > (unsigned HOST_WIDE_INT)\n-\t       param_builtin_string_cmp_inline_length)\n+  if (bound > (unsigned HOST_WIDE_INT) param_builtin_string_cmp_inline_length)\n     return NULL_RTX;\n \n   machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n \n   /* Now, start inline expansion the call.  */\n   return inline_string_cmp (target, (const_str_n == 1) ? arg2 : arg1,\n-\t\t\t    (const_str_n == 1) ? src_str1 : src_str2, length,\n+\t\t\t    (const_str_n == 1) ? bytes1 : bytes2, bound,\n \t\t\t    const_str_n, mode);\n }\n "}, {"sha": "b4bbeffe3ce095674e8528286e8f013cc72de32e", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -11829,12 +11829,12 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n       while (TREE_CODE (chartype) == ARRAY_TYPE)\n \tchartype = TREE_TYPE (chartype);\n       /* Convert a char array to an empty STRING_CST having an array\n-\t of the expected type.  */\n+\t of the expected type and size.  */\n       if (!initsize)\n \t  initsize = integer_zero_node;\n \n       unsigned HOST_WIDE_INT size = tree_to_uhwi (initsize);\n-      init = build_string_literal (size ? 1 : 0, \"\", chartype, size);\n+      init = build_string_literal (size, NULL, chartype, size);\n       init = TREE_OPERAND (init, 0);\n       init = TREE_OPERAND (init, 0);\n "}, {"sha": "300d959278b0739eb4f033c5b8dc9e3ba7df2e25", "filename": "gcc/fold-const.c", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -15487,24 +15487,29 @@ fold_build_pointer_plus_hwi_loc (location_t loc, tree ptr, HOST_WIDE_INT off)\n \t\t\t  ptr, size_int (off));\n }\n \n-/* Return a pointer P to a NUL-terminated string representing the sequence\n-   of constant characters referred to by SRC (or a subsequence of such\n-   characters within it if SRC is a reference to a string plus some\n-   constant offset).  If STRLEN is non-null, store the number of bytes\n-   in the string constant including the terminating NUL char.  *STRLEN is\n-   typically strlen(P) + 1 in the absence of embedded NUL characters.  */\n+/* Return a pointer P to a NUL-terminated string containing the sequence\n+   of bytes corresponding to the representation of the object referred to\n+   by SRC (or a subsequence of such bytes within it if SRC is a reference\n+   to an initialized constant array plus some constant offset).\n+   If STRSIZE is non-null, store the number of bytes in the constant\n+   sequence including the terminating NUL byte.  *STRSIZE is equal to\n+   sizeof(A) - OFFSET where A is the array that stores the constant\n+   sequence that SRC points to and OFFSET is the byte offset of SRC from\n+   the beginning of A.  SRC need not point to a string or even an array\n+   of characters but may point to an object of any type.  */\n \n const char *\n-c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */)\n+c_getstr (tree src, unsigned HOST_WIDE_INT *strsize /* = NULL */)\n {\n+  /* The offset into the array A storing the string, and A's byte size.  */\n   tree offset_node;\n   tree mem_size;\n \n-  if (strlen)\n-    *strlen = 0;\n+  if (strsize)\n+    *strsize = 0;\n \n   src = string_constant (src, &offset_node, &mem_size, NULL);\n-  if (src == 0)\n+  if (!src)\n     return NULL;\n \n   unsigned HOST_WIDE_INT offset = 0;\n@@ -15519,46 +15524,56 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */)\n   if (!tree_fits_uhwi_p (mem_size))\n     return NULL;\n \n-  /* STRING_LENGTH is the size of the string literal, including any\n-     embedded NULs.  STRING_SIZE is the size of the array the string\n-     literal is stored in.  */\n-  unsigned HOST_WIDE_INT string_length = TREE_STRING_LENGTH (src);\n-  unsigned HOST_WIDE_INT string_size = tree_to_uhwi (mem_size);\n+  /* ARRAY_SIZE is the byte size of the array the constant sequence\n+     is stored in and equal to sizeof A.  INIT_BYTES is the number\n+     of bytes in the constant sequence used to initialize the array,\n+     including any embedded NULs as well as the terminating NUL (for\n+     strings), but not including any trailing zeros/NULs past\n+     the terminating one appended implicitly to a string literal to\n+     zero out the remainder of the array it's stored in.  For example,\n+     given:\n+       const char a[7] = \"abc\\0d\";\n+       n = strlen (a + 1);\n+     ARRAY_SIZE is 7, INIT_BYTES is 6, and OFFSET is 1.  For a valid\n+     (i.e., nul-terminated) string with no embedded nuls, INIT_BYTES\n+     is equal to strlen (A) + 1.  */\n+  const unsigned HOST_WIDE_INT array_size = tree_to_uhwi (mem_size);\n+  unsigned HOST_WIDE_INT init_bytes = TREE_STRING_LENGTH (src);\n \n   /* Ideally this would turn into a gcc_checking_assert over time.  */\n-  if (string_length > string_size)\n-    string_length = string_size;\n+  if (init_bytes > array_size)\n+    init_bytes = array_size;\n \n   const char *string = TREE_STRING_POINTER (src);\n \n   /* Ideally this would turn into a gcc_checking_assert over time.  */\n-  if (string_length > string_size)\n-    string_length = string_size;\n+  if (init_bytes > array_size)\n+    init_bytes = array_size;\n \n-  if (string_length == 0\n-      || offset >= string_size)\n+  if (init_bytes == 0 || offset >= array_size)\n     return NULL;\n \n-  if (strlen)\n+  if (strsize)\n     {\n-      /* Compute and store the length of the substring at OFFSET.\n-\t All offsets past the initial length refer to null strings.  */\n-      if (offset < string_length)\n-\t*strlen = string_length - offset;\n+      /* Compute and store the number of characters from the beginning\n+\t of the substring at OFFSET to the end, including the terminating\n+\t nul.  Offsets past the initial length refer to null strings.  */\n+      if (offset < init_bytes)\n+\t*strsize = init_bytes - offset;\n       else\n-\t*strlen = 1;\n+\t*strsize = 1;\n     }\n   else\n     {\n       tree eltype = TREE_TYPE (TREE_TYPE (src));\n       /* Support only properly NUL-terminated single byte strings.  */\n       if (tree_to_uhwi (TYPE_SIZE_UNIT (eltype)) != 1)\n \treturn NULL;\n-      if (string[string_length - 1] != '\\0')\n+      if (string[init_bytes - 1] != '\\0')\n \treturn NULL;\n     }\n \n-  return offset < string_length ? string + offset : \"\";\n+  return offset < init_bytes ? string + offset : \"\";\n }\n \n /* Given a tree T, compute which bits in T may be nonzero.  */"}, {"sha": "d8250ecfc9879ef85cec2c8392c70347791f46be", "filename": "gcc/testsuite/gcc.dg/memcmp-pr95189.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-pr95189.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-pr95189.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-pr95189.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -0,0 +1,28 @@\n+/* PR middle-end/95189 - memcmp being wrongly stripped like strcmp\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+char a4[] = \"\\0abc\";\n+char a8[] = \"\\0abcdefg\";\n+char a16[] = \"\\0abcdefghijklmno\";\n+\n+int cmp4 (void)\n+{\n+  return __builtin_memcmp (a4, \"\\0\\0\\0\\0\", 4);\n+}\n+\n+int cmp8 (void)\n+{\n+  return __builtin_memcmp (a8, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 8);\n+}\n+\n+int cmp16 (void)\n+{\n+  return __builtin_memcmp (a16, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 16);\n+}\n+\n+int main (void)\n+{\n+  if (cmp4 () < 1 || cmp8 () < 1 || cmp16 () < 1)\n+    __builtin_abort ();\n+}"}, {"sha": "0e8101cd61b0df3926ac5ccbca6cdb0f28bf7f74", "filename": "gcc/testsuite/gcc.dg/strncmp-3.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-3.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -0,0 +1,57 @@\n+/* PR middle-end/95189 - memcmp being wrongly stripped like strcmp\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define AB_D \"ab\\0d\"\n+#define ABCDEF_H \"abcdef\\0h\"\n+#define ABCDEFGHIJKLMN_P \"abcdefghijklmn\\0p\"\n+\n+char ab_d[] = AB_D;\n+char abcdef_h[] = ABCDEF_H;\n+\n+extern int strncmp (const char*, const char*, __SIZE_TYPE__);\n+\n+__attribute__((noipa)) void sink (const void *p, ...) { (void)&p; }\n+\n+#define strncmp(a, b, n) (sink (a, b), strncmp (a, b, n))\n+\n+int main (void)\n+{\n+  int zero = 0;\n+\n+  zero += strncmp (ab_d, AB_D, 1);\n+  zero += strncmp (ab_d, AB_D, 2);\n+  zero += strncmp (ab_d, AB_D, 3);\n+  zero += strncmp (ab_d, AB_D, 4);\n+  zero += strncmp (ab_d, AB_D, 5);\n+\n+  zero += strncmp (ab_d, ABCDEF_H, 1);\n+  zero += strncmp (ab_d, ABCDEF_H, 2);\n+\n+  zero += strncmp (abcdef_h, AB_D, 2);\n+\n+  zero += strncmp (abcdef_h, ABCDEF_H, 2);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 3);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 4);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 5);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 6);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 7);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 8);\n+  zero += strncmp (abcdef_h, ABCDEF_H, 9);\n+\n+  if (zero != 0)\n+    __builtin_abort ();\n+\n+  int neg = 0;\n+\n+  neg -= strncmp (ab_d, ABCDEF_H, 3) < 0;\n+  neg -= strncmp (ab_d, ABCDEF_H, 4) < 0;\n+  neg -= strncmp (ab_d, ABCDEF_H, 5) < 0;\n+  neg -= strncmp (ab_d, ABCDEF_H, 6) < 0;\n+  neg -= strncmp (ab_d, ABCDEF_H, 7) < 0;\n+  neg -= strncmp (ab_d, ABCDEF_H, 8) < 0;\n+  neg -= strncmp (ab_d, ABCDEF_H, 9) < 0;\n+\n+  if (neg != -7)\n+    __builtin_abort ();\n+}"}, {"sha": "c0a04d27fac0db21fc5c43edb296915927b37d71", "filename": "gcc/testsuite/gcc.target/i386/memcpy-pr95886.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-pr95886.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-pr95886.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-pr95886.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -0,0 +1,107 @@\n+/* PR middle-end/95886 - suboptimal memcpy with embedded zero bytes\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-rtl-expand\" } */\n+\n+const char a1234567890[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+\n+void cpy_123456789 (void *d)\n+{\n+  /* Expands into:\n+       movabsq  $578437695752307201, %rax\n+       movb     $9, 8(%rdi)\n+       movq     %rax, (%rdi)  */\n+  __builtin_memcpy (d, a1234567890, 9);\n+}\n+\n+const char a1234567800[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n+\n+void cpy_1234567800 (void *d)\n+{\n+  /* Expands into:\n+       movabsq  $578437695752307201, %rax\n+       movb     $0, 8(%rdi)\n+       movq     %rax, (%rdi)  */\n+  __builtin_memcpy (d, a1234567800, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578437695752307201\" 2 \"expand\"} } */\n+\n+\n+const char a0234567890[10] = { 0, 2, 3, 4, 5, 6, 7, 8, 9 };\n+\n+void cpy_023456789 (void *d)\n+{\n+  __builtin_memcpy (d, a0234567890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578437695752307200\" 1 \"expand\"} } */\n+\n+\n+const char a1034567890[10] = { 1, 0, 3, 4, 5, 6, 7, 8, 9 };\n+\n+void cpy_103456789 (void *d)\n+{\n+  __builtin_memcpy (d, a1034567890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578437695752306689\" 1 \"expand\"} } */\n+\n+\n+const char a1204567890[10] = { 1, 2, 0, 4, 5, 6, 7, 8, 9 };\n+\n+void cpy_120456789 (void *d)\n+{\n+  __builtin_memcpy (d, a1204567890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578437695752110593\" 1 \"expand\"} } */\n+\n+\n+const char a1230567890[10] = { 1, 2, 3, 0, 5, 6, 7, 8, 9 };\n+\n+void cpy_123056789 (void *d)\n+{\n+  __builtin_memcpy (d, a1230567890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578437695685198337\" 1 \"expand\"} } */\n+\n+\n+const char a1234067890[10] = { 1, 2, 3, 4, 0, 6, 7, 8, 9 };\n+\n+void cpy_123406789 (void *d)\n+{\n+  __builtin_memcpy (d, a1234067890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578437695685198337\" 1 \"expand\"} } */\n+\n+\n+const char a1234507890[10] = { 1, 2, 3, 4, 5, 0, 7, 8, 9 };\n+\n+void cpy_123450789 (void *d)\n+{\n+  __builtin_memcpy (d, a1234507890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 578431098682540545\" 1 \"expand\"} } */\n+\n+\n+const char a1234560890[10] = { 1, 2, 3, 4, 5, 6, 0, 8, 9 };\n+\n+void cpy_123456089 (void *d)\n+{\n+  __builtin_memcpy (d, a1234560890, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 576467370915332609\" 1 \"expand\"} } */\n+\n+\n+const char a1234567090[10] = { 1, 2, 3, 4, 5, 6, 7, 0, 9 };\n+\n+void cpy_123456709 (void *d)\n+{\n+  __builtin_memcpy (d, a1234567090, 9);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"const_int 1976943448883713\" 1 \"expand\"} } */"}, {"sha": "6522a089ddfe742e120e91666e651111a572ebb0", "filename": "gcc/tree.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -2206,29 +2206,29 @@ build_real_from_int_cst (tree type, const_tree i)\n   return v;\n }\n \n-/* Return a newly constructed STRING_CST node whose value is\n-   the LEN characters at STR.\n+/* Return a newly constructed STRING_CST node whose value is the LEN\n+   characters at STR when STR is nonnull, or all zeros otherwise.\n    Note that for a C string literal, LEN should include the trailing NUL.\n    The TREE_TYPE is not initialized.  */\n \n tree\n-build_string (int len, const char *str)\n+build_string (unsigned len, const char *str /*= NULL */)\n {\n-  tree s;\n-  size_t length;\n-\n   /* Do not waste bytes provided by padding of struct tree_string.  */\n-  length = len + offsetof (struct tree_string, str) + 1;\n+  unsigned size = len + offsetof (struct tree_string, str) + 1;\n \n-  record_node_allocation_statistics (STRING_CST, length);\n+  record_node_allocation_statistics (STRING_CST, size);\n \n-  s = (tree) ggc_internal_alloc (length);\n+  tree s = (tree) ggc_internal_alloc (size);\n \n   memset (s, 0, sizeof (struct tree_typed));\n   TREE_SET_CODE (s, STRING_CST);\n   TREE_CONSTANT (s) = 1;\n   TREE_STRING_LENGTH (s) = len;\n-  memcpy (s->string.str, str, len);\n+  if (str)\n+    memcpy (s->string.str, str, len);\n+  else\n+    memset (s->string.str, 0, len);\n   s->string.str[len] = '\\0';\n \n   return s;\n@@ -11572,12 +11572,12 @@ build_alloca_call_expr (tree size, unsigned int align, HOST_WIDE_INT max_size)\n \n /* Create a new constant string literal of type ELTYPE[SIZE] (or LEN\n    if SIZE == -1) and return a tree node representing char* pointer to\n-   it as an ADDR_EXPR (ARRAY_REF (ELTYPE, ...)).  The STRING_CST value\n-   is the LEN bytes at STR (the representation of the string, which may\n-   be wide).  */\n+   it as an ADDR_EXPR (ARRAY_REF (ELTYPE, ...)).  When STR is nonnull\n+   the STRING_CST value is the LEN bytes at STR (the representation\n+   of the string, which may be wide).  Otherwise it's all zeros.  */\n \n tree\n-build_string_literal (int len, const char *str,\n+build_string_literal (unsigned len, const char *str /* = NULL */,\n \t\t      tree eltype /* = char_type_node */,\n \t\t      unsigned HOST_WIDE_INT size /* = -1 */)\n {"}, {"sha": "8adc28e8b915039db507ca55c41306d95c3d67d6", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d5803b9876b3d11c93d1a10fabb3fbb1c4a14bd6", "patch": "@@ -4425,7 +4425,7 @@ extern tree build_one_cst (tree);\n extern tree build_minus_one_cst (tree);\n extern tree build_all_ones_cst (tree);\n extern tree build_zero_cst (tree);\n-extern tree build_string (int, const char *);\n+extern tree build_string (unsigned, const char * = NULL);\n extern tree build_poly_int_cst (tree, const poly_wide_int_ref &);\n extern tree build_tree_list (tree, tree CXX_MEM_STAT_INFO);\n extern tree build_tree_list_vec (const vec<tree, va_gc> * CXX_MEM_STAT_INFO);\n@@ -4456,7 +4456,8 @@ extern tree build_call_expr_internal_loc_array (location_t, enum internal_fn,\n extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,\n \t\t\t\t       int, ...);\n extern tree build_alloca_call_expr (tree, unsigned int, HOST_WIDE_INT);\n-extern tree build_string_literal (int, const char *, tree = char_type_node,\n+extern tree build_string_literal (unsigned, const char * = NULL,\n+\t\t\t\t  tree = char_type_node,\n \t\t\t\t  unsigned HOST_WIDE_INT = HOST_WIDE_INT_M1U);\n \n /* Construct various nodes representing data types.  */"}]}