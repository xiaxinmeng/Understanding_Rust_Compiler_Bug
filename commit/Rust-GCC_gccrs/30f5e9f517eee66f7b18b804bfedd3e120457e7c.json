{"sha": "30f5e9f517eee66f7b18b804bfedd3e120457e7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBmNWU5ZjUxN2VlZTY2ZjdiMThiODA0YmZlZGQzZTEyMDQ1N2U3Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-16T12:53:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-16T12:53:07Z"}, "message": "(final_scan_insn): Allow removal of redundant test and compare\ninstructions that use clobbers.\n\nFrom-SVN: r11806", "tree": {"sha": "eb1f039e38582db96b5040549b3b8f269eb41c25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb1f039e38582db96b5040549b3b8f269eb41c25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30f5e9f517eee66f7b18b804bfedd3e120457e7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f5e9f517eee66f7b18b804bfedd3e120457e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f5e9f517eee66f7b18b804bfedd3e120457e7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f5e9f517eee66f7b18b804bfedd3e120457e7c/comments", "author": null, "committer": null, "parents": [{"sha": "b089937ac0257754ccc1eb0e9c9c88e4b77f610c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b089937ac0257754ccc1eb0e9c9c88e4b77f610c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b089937ac0257754ccc1eb0e9c9c88e4b77f610c"}], "stats": {"total": 56, "additions": 30, "deletions": 26}, "files": [{"sha": "70aa819d0583e9dd5ae0beed1817a1c7a3d30ee1", "filename": "gcc/final.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f5e9f517eee66f7b18b804bfedd3e120457e7c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f5e9f517eee66f7b18b804bfedd3e120457e7c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=30f5e9f517eee66f7b18b804bfedd3e120457e7c", "patch": "@@ -1756,35 +1756,39 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t   and the next statement should reexamine the variable\n \t   to compute the condition codes.  */\n \n-\tif (optimize\n-\t    && GET_CODE (body) == SET\n-\t    && GET_CODE (SET_DEST (body)) == CC0\n-\t    && insn != last_ignored_compare)\n+\tif (optimize)\n \t  {\n-\t    if (GET_CODE (SET_SRC (body)) == SUBREG)\n-\t      SET_SRC (body) = alter_subreg (SET_SRC (body));\n-\t    else if (GET_CODE (SET_SRC (body)) == COMPARE)\n-\t      {\n-\t\tif (GET_CODE (XEXP (SET_SRC (body), 0)) == SUBREG)\n-\t\t  XEXP (SET_SRC (body), 0)\n-\t\t    = alter_subreg (XEXP (SET_SRC (body), 0));\n-\t\tif (GET_CODE (XEXP (SET_SRC (body), 1)) == SUBREG)\n-\t\t  XEXP (SET_SRC (body), 1)\n-\t\t    = alter_subreg (XEXP (SET_SRC (body), 1));\n-\t      }\n-\t    if ((cc_status.value1 != 0\n-\t\t && rtx_equal_p (SET_SRC (body), cc_status.value1))\n-\t\t|| (cc_status.value2 != 0\n-\t\t    && rtx_equal_p (SET_SRC (body), cc_status.value2)))\n+\t    rtx set = single_set(insn);\n+\n+\t    if (set\n+\t\t&& GET_CODE (SET_DEST (set)) == CC0\n+\t\t&& insn != last_ignored_compare)\n \t      {\n-\t\t/* Don't delete insn if it has an addressing side-effect.  */\n-\t\tif (! FIND_REG_INC_NOTE (insn, 0)\n-\t\t    /* or if anything in it is volatile.  */\n-\t\t    && ! volatile_refs_p (PATTERN (insn)))\n+\t\tif (GET_CODE (SET_SRC (set)) == SUBREG)\n+\t\t  SET_SRC (set) = alter_subreg (SET_SRC (set));\n+\t\telse if (GET_CODE (SET_SRC (set)) == COMPARE)\n \t\t  {\n-\t\t    /* We don't really delete the insn; just ignore it.  */\n-\t\t    last_ignored_compare = insn;\n-\t\t    break;\n+\t\t    if (GET_CODE (XEXP (SET_SRC (set), 0)) == SUBREG)\n+\t\t      XEXP (SET_SRC (set), 0)\n+\t\t\t= alter_subreg (XEXP (SET_SRC (set), 0));\n+\t\t    if (GET_CODE (XEXP (SET_SRC (set), 1)) == SUBREG)\n+\t\t      XEXP (SET_SRC (set), 1)\n+\t\t\t= alter_subreg (XEXP (SET_SRC (set), 1));\n+\t\t  }\n+\t\tif ((cc_status.value1 != 0\n+\t\t     && rtx_equal_p (SET_SRC (set), cc_status.value1))\n+\t\t    || (cc_status.value2 != 0\n+\t\t\t&& rtx_equal_p (SET_SRC (set), cc_status.value2)))\n+\t\t  {\n+\t\t    /* Don't delete insn if it has an addressing side-effect.  */\n+\t\t    if (! FIND_REG_INC_NOTE (insn, 0)\n+\t\t\t/* or if anything in it is volatile.  */\n+\t\t\t&& ! volatile_refs_p (PATTERN (insn)))\n+\t\t      {\n+\t\t\t/* We don't really delete the insn; just ignore it.  */\n+\t\t\tlast_ignored_compare = insn;\n+\t\t\tbreak;\n+\t\t      }\n \t\t  }\n \t      }\n \t  }"}]}