{"sha": "44a76fc8563b63bbd0ce06e607136746841f4d8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRhNzZmYzg1NjNiNjNiYmQwY2UwNmU2MDcxMzY3NDY4NDFmNGQ4Zg==", "commit": {"author": {"name": "Anthony Green", "email": "green@cygnus.com", "date": "2000-02-26T02:54:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-02-26T02:54:36Z"}, "message": "toplev.c (rest_of_compilation): Rebuild jump labels if combine_instructions has created a new direct jump.\n\n\t* toplev.c (rest_of_compilation): Rebuild jump labels if\n\tcombine_instructions has created a new direct jump.\n\t* combine.c (try_combine): Add new_direct_jump_p argument.  Set it\n\twhen appropriate.\n\t(combine_instructions): Call try_combine with new argument.\n\tReturn non-null value when new direct jump instruction is created.\n\t* rtl.h: combine_instructions returns an int.\n\nFrom-SVN: r32162", "tree": {"sha": "a130b6dc3441ac75d72a58d539e738978bf10bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a130b6dc3441ac75d72a58d539e738978bf10bb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44a76fc8563b63bbd0ce06e607136746841f4d8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a76fc8563b63bbd0ce06e607136746841f4d8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a76fc8563b63bbd0ce06e607136746841f4d8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a76fc8563b63bbd0ce06e607136746841f4d8f/comments", "author": null, "committer": null, "parents": [{"sha": "0e9137bb1ffffa72428077af6678e11e440c6e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9137bb1ffffa72428077af6678e11e440c6e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e9137bb1ffffa72428077af6678e11e440c6e4b"}], "stats": {"total": 89, "additions": 69, "deletions": 20}, "files": [{"sha": "0823934d1d4847b29d73c95817eaabe98a6f6b99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44a76fc8563b63bbd0ce06e607136746841f4d8f", "patch": "@@ -1,3 +1,13 @@\n+2000-02-25  Anthony Green  <green@cygnus.com>\n+\n+\t* toplev.c (rest_of_compilation): Rebuild jump labels if\n+\tcombine_instructions has created a new direct jump.\n+\t* combine.c (try_combine): Add new_direct_jump_p argument.  Set it\n+\twhen appropriate.\n+\t(combine_instructions): Call try_combine with new argument.\n+\tReturn non-null value when new direct jump instruction is created.\n+\t* rtl.h: combine_instructions returns an int.\n+\n Fri Feb 25 19:49:08 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* cse.c (cse_insn): Replace the PATTERN of the insn with an new"}, {"sha": "d24ef18328c13c41e69ac294b64abd5318febff8", "filename": "gcc/combine.c", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=44a76fc8563b63bbd0ce06e607136746841f4d8f", "patch": "@@ -359,7 +359,7 @@ static int can_combine_p\tPARAMS ((rtx, rtx, rtx, rtx, rtx *, rtx *));\n static int sets_function_arg_p\tPARAMS ((rtx));\n static int combinable_i3pat\tPARAMS ((rtx, rtx *, rtx, rtx, int, rtx *));\n static int contains_muldiv\tPARAMS ((rtx));\n-static rtx try_combine\t\tPARAMS ((rtx, rtx, rtx));\n+static rtx try_combine\t\tPARAMS ((rtx, rtx, rtx, int *));\n static void undo_all\t\tPARAMS ((void));\n static void undo_commit\t\tPARAMS ((void));\n static rtx *find_split_point\tPARAMS ((rtx *, rtx));\n@@ -480,9 +480,11 @@ do_SUBST_INT(into, newval)\n #define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n \f\n /* Main entry point for combiner.  F is the first insn of the function.\n-   NREGS is the first unused pseudo-reg number.  */\n+   NREGS is the first unused pseudo-reg number. \n \n-void\n+   Return non-zero if the combiner has turned an indirect jump\n+   instruction into a direct jump.  */\n+int\n combine_instructions (f, nregs)\n      rtx f;\n      int nregs;\n@@ -494,6 +496,8 @@ combine_instructions (f, nregs)\n   register int i;\n   register rtx links, nextlinks;\n \n+  int new_direct_jump_p = 0;\n+\n   combine_attempts = 0;\n   combine_merges = 0;\n   combine_extras = 0;\n@@ -617,7 +621,8 @@ combine_instructions (f, nregs)\n \t  /* Try this insn with each insn it links back to.  */\n \n \t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t    if ((next = try_combine (insn, XEXP (links, 0), NULL_RTX)) != 0)\n+\t    if ((next = try_combine (insn, XEXP (links, 0), \n+\t\t\t\t     NULL_RTX, &new_direct_jump_p)) != 0)\n \t      goto retry;\n \n \t  /* Try each sequence of three linked insns ending with this one.  */\n@@ -626,7 +631,8 @@ combine_instructions (f, nregs)\n \t    for (nextlinks = LOG_LINKS (XEXP (links, 0)); nextlinks;\n \t\t nextlinks = XEXP (nextlinks, 1))\n \t      if ((next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t       XEXP (nextlinks, 0))) != 0)\n+\t\t\t\t       XEXP (nextlinks, 0),\n+\t\t\t\t       &new_direct_jump_p)) != 0)\n \t\tgoto retry;\n \n #ifdef HAVE_cc0\n@@ -642,13 +648,15 @@ combine_instructions (f, nregs)\n \t      && GET_CODE (prev) == INSN\n \t      && sets_cc0_p (PATTERN (prev)))\n \t    {\n-\t      if ((next = try_combine (insn, prev, NULL_RTX)) != 0)\n+\t      if ((next = try_combine (insn, prev, \n+\t\t\t\t       NULL_RTX, &new_direct_jump_p)) != 0)\n \t\tgoto retry;\n \n \t      for (nextlinks = LOG_LINKS (prev); nextlinks;\n \t\t   nextlinks = XEXP (nextlinks, 1))\n \t\tif ((next = try_combine (insn, prev,\n-\t\t\t\t\t XEXP (nextlinks, 0))) != 0)\n+\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n \t    }\n \n@@ -660,13 +668,15 @@ combine_instructions (f, nregs)\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n \t    {\n-\t      if ((next = try_combine (insn, prev, NULL_RTX)) != 0)\n+\t      if ((next = try_combine (insn, prev, \n+\t\t\t\t       NULL_RTX, &new_direct_jump_p)) != 0)\n \t\tgoto retry;\n \n \t      for (nextlinks = LOG_LINKS (prev); nextlinks;\n \t\t   nextlinks = XEXP (nextlinks, 1))\n \t\tif ((next = try_combine (insn, prev,\n-\t\t\t\t\t XEXP (nextlinks, 0))) != 0)\n+\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n \t    }\n \n@@ -680,7 +690,8 @@ combine_instructions (f, nregs)\n \t\t&& (prev = prev_nonnote_insn (XEXP (links, 0))) != 0\n \t\t&& GET_CODE (prev) == INSN\n \t\t&& sets_cc0_p (PATTERN (prev))\n-\t\t&& (next = try_combine (insn, XEXP (links, 0), prev)) != 0)\n+\t\t&& (next = try_combine (insn, XEXP (links, 0), \n+\t\t\t\t\tprev, &new_direct_jump_p)) != 0)\n \t      goto retry;\n #endif\n \n@@ -690,7 +701,8 @@ combine_instructions (f, nregs)\n \t    for (nextlinks = XEXP (links, 1); nextlinks;\n \t\t nextlinks = XEXP (nextlinks, 1))\n \t      if ((next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t       XEXP (nextlinks, 0))) != 0)\n+\t\t\t\t       XEXP (nextlinks, 0),\n+\t\t\t\t       &new_direct_jump_p)) != 0)\n \t\tgoto retry;\n \n \t  if (GET_CODE (insn) != NOTE)\n@@ -742,6 +754,8 @@ combine_instructions (f, nregs)\n \n   /* Make recognizer allow volatile MEMs again.  */\n   init_recog ();\n+\n+  return new_direct_jump_p;\n }\n \n /* Wipe the reg_last_xxx arrays in preparation for another pass.  */\n@@ -1426,11 +1440,15 @@ contains_muldiv (x)\n \n    Return 0 if the combination does not work.  Then nothing is changed. \n    If we did the combination, return the insn at which combine should\n-   resume scanning.  */\n+   resume scanning.  \n+   \n+   Set NEW_DIRECT_JUMP_P to a non-zero value if try_combine creates a\n+   new direct jump instruction.  */\n \n static rtx\n-try_combine (i3, i2, i1)\n+try_combine (i3, i2, i1, new_direct_jump_p)\n      register rtx i3, i2, i1;\n+     register int *new_direct_jump_p;\n {\n   /* New patterns for I3 and I3, respectively.  */\n   rtx newpat, newi2pat = 0;\n@@ -2684,14 +2702,21 @@ try_combine (i3, i2, i1)\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n \n-    /* If I3 is now an unconditional jump, ensure that it has a \n+    /* Set new_direct_jump_p if a new return or simple jump instruction\n+       has been created.\n+\n+       If I3 is now an unconditional jump, ensure that it has a \n        BARRIER following it since it may have initially been a\n        conditional jump.  It may also be the last nonnote insn.  */\n+    \n+    if (GET_CODE (newpat) == RETURN || simplejump_p (i3))\n+      {\n+\t*new_direct_jump_p = 1;\n \n-    if ((GET_CODE (newpat) == RETURN || simplejump_p (i3))\n-\t&& ((temp = next_nonnote_insn (i3)) == NULL_RTX\n-\t    || GET_CODE (temp) != BARRIER))\n-      emit_barrier_after (i3);\n+\tif ((temp = next_nonnote_insn (i3)) == NULL_RTX\n+\t    || GET_CODE (temp) != BARRIER)\n+\t  emit_barrier_after (i3);\n+      }\n   }\n \n   combine_successes++;"}, {"sha": "af67efb74cdcb81b412fae5e13b718fec899edd0", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=44a76fc8563b63bbd0ce06e607136746841f4d8f", "patch": "@@ -1470,7 +1470,7 @@ extern void remove_unncessary_notes             PARAMS ((void));\n extern void add_clobbers\t\tPARAMS ((rtx, int));\n \n /* In combine.c */\n-extern void combine_instructions\tPARAMS ((rtx, int));\n+extern int combine_instructions\tPARAMS ((rtx, int));\n extern int extended_count\t\tPARAMS ((rtx, enum machine_mode, int));\n extern rtx remove_death\t\t\tPARAMS ((int, rtx));\n #ifdef BUFSIZ"}, {"sha": "058ccfa55c9e471da0ce6b37b267eba7eb315462", "filename": "gcc/toplev.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a76fc8563b63bbd0ce06e607136746841f4d8f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=44a76fc8563b63bbd0ce06e607136746841f4d8f", "patch": "@@ -3311,7 +3311,21 @@ rest_of_compilation (decl)\n \n   if (optimize > 0)\n     {\n-      TIMEVAR (combine_time, combine_instructions (insns, max_reg_num ()));\n+      int rebuild_jump_labels_after_combine = 0;\n+\n+      TIMEVAR (combine_time, \n+\t       {\n+\t\t rebuild_jump_labels_after_combine = \n+\t\t   combine_instructions (insns, max_reg_num ());\n+\t       });\n+      \n+      /* Combining insns may have turned an indirect jump into a\n+\t direct jump.  Rebuid the JUMP_LABEL fields of jumping\n+\t instructions.  */\n+      if (rebuild_jump_labels_after_combine)\n+\t{\n+\t  TIMEVAR (jump_time, rebuild_jump_labels (insns));\n+\t}\n \n       /* Dump rtl code after insn combination.  */\n "}]}