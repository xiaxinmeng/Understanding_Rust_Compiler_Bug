{"sha": "611ad29eedae3ce061de881cc19bd634220e0fe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExYWQyOWVlZGFlM2NlMDYxZGU4ODFjYzE5YmQ2MzQyMjBlMGZlOQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-02-02T06:04:58Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-02-02T06:04:58Z"}, "message": "pa-protos.h (attr_length_millicode_call): Remove second argument.\n\n\t* pa-protos.h (attr_length_millicode_call): Remove second argument.\n\t(attr_length_indirect_call, attr_length_indirect_call,\n\tattr_length_save_restore_dltp): New prototypes.\n\t* pa.c (attr_length_millicode_call): Remove second argument.  Check\n\tINSN_ADDRESSES_SET_P in distance calculation.\n\t(output_millicode_call): Check INSN_ADDRESSES_SET_P before using\n\tINSN_ADDRESSES.\n\t(attr_length_call): Check INSN_ADDRESSES_SET_P in distance calculation.\n\t(output_call): Check INSN_ADDRESSES_SET_P before using INSN_ADDRESSES.\n\tCall attr_length_call directly.\n\t(attr_length_indirect_call, output_indirect_call,\n\tattr_length_save_restore_dltp): New functions.\n\t* pa.md (attr_length_millicode_call): Drop second argument from all\n\tpatterns.\n\t(return_internal_pic): Delete.\n\t(return_external_pic): Remove use of PIC register and pic operand and\n\tflag checks.\n\t(epilogue): Use return_internal for both normal and pic code.\n\t(call, call_value): Emit new 32-bit pic patterns for symref and\n\tindirect calls.  Remove uses for arg pointer and pic register.\n\t(call_symref_pic, call_symref_pic_post_reload, call_reg_pic,\n\tcall_reg_pic_post_reload, call_val_symref_pic,\n\tcall_val_symref_pic_post_reload, call_val_reg_pic,\n\tcall_val_reg_pic_post_reload): New pre and post reload insn patterns.\n\tImplement define_split and define_peephole2 patterns for pre reload\n\tpatterns.\n\t(call_symref_64bit, call_internal_reg_64bit, call_value_symref_64bit,\n\tcall_value_internal_reg_64bit): Shorten names.\n\t(all call patterns): Explicitly indicate registers used and clobbered.\n\tUse attr_length_indirect_call and attr_length_save_restore_dltp for\n\tattribute length calculation.  Move code generation for indirect calls\n\tto output_indirect_call.\n\t(sibcall, sibcall_value): Don't restore PIC register.\n\t(exception_receiver, builtin_setjmp_receiver): Add blockage after PIC\n\tregister retore.\n\nFrom-SVN: r62272", "tree": {"sha": "6167204bfd21b05f4b23a322640996c4092e1174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6167204bfd21b05f4b23a322640996c4092e1174"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/611ad29eedae3ce061de881cc19bd634220e0fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611ad29eedae3ce061de881cc19bd634220e0fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611ad29eedae3ce061de881cc19bd634220e0fe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611ad29eedae3ce061de881cc19bd634220e0fe9/comments", "author": null, "committer": null, "parents": [{"sha": "8cacda7c8bb67fdaa79d428b2fe95fdf0dd5a2f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cacda7c8bb67fdaa79d428b2fe95fdf0dd5a2f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cacda7c8bb67fdaa79d428b2fe95fdf0dd5a2f7"}], "stats": {"total": 1331, "additions": 1026, "deletions": 305}, "files": [{"sha": "e9ec0a6d710d3c9143c906cd5bfd666a6f6661c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=611ad29eedae3ce061de881cc19bd634220e0fe9", "patch": "@@ -1,3 +1,41 @@\n+2003-02-02  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa-protos.h (attr_length_millicode_call): Remove second argument.\n+\t(attr_length_indirect_call, attr_length_indirect_call,\n+\tattr_length_save_restore_dltp): New prototypes.\n+\t* pa.c (attr_length_millicode_call): Remove second argument.  Check\n+\tINSN_ADDRESSES_SET_P in distance calculation.\n+\t(output_millicode_call): Check INSN_ADDRESSES_SET_P before using\n+\tINSN_ADDRESSES.\n+\t(attr_length_call): Check INSN_ADDRESSES_SET_P in distance calculation.\n+\t(output_call): Check INSN_ADDRESSES_SET_P before using INSN_ADDRESSES.\n+\tCall attr_length_call directly.\n+\t(attr_length_indirect_call, output_indirect_call,\n+\tattr_length_save_restore_dltp): New functions.\n+\t* pa.md (attr_length_millicode_call): Drop second argument from all\n+\tpatterns.\n+\t(return_internal_pic): Delete.\n+\t(return_external_pic): Remove use of PIC register and pic operand and\n+\tflag checks.\n+\t(epilogue): Use return_internal for both normal and pic code.\n+\t(call, call_value): Emit new 32-bit pic patterns for symref and\n+\tindirect calls.  Remove uses for arg pointer and pic register.\n+\t(call_symref_pic, call_symref_pic_post_reload, call_reg_pic,\n+\tcall_reg_pic_post_reload, call_val_symref_pic,\n+\tcall_val_symref_pic_post_reload, call_val_reg_pic,\n+\tcall_val_reg_pic_post_reload): New pre and post reload insn patterns.\n+\tImplement define_split and define_peephole2 patterns for pre reload\n+\tpatterns.\n+\t(call_symref_64bit, call_internal_reg_64bit, call_value_symref_64bit,\n+\tcall_value_internal_reg_64bit): Shorten names.\n+\t(all call patterns): Explicitly indicate registers used and clobbered.\n+\tUse attr_length_indirect_call and attr_length_save_restore_dltp for\n+\tattribute length calculation.  Move code generation for indirect calls\n+\tto output_indirect_call.\n+\t(sibcall, sibcall_value): Don't restore PIC register.\n+\t(exception_receiver, builtin_setjmp_receiver): Add blockage after PIC\n+\tregister retore.\n+\n 2003-02-02  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* doc/install.texi (Testing): Simplify and compress instructions"}, {"sha": "248e1a7d05e3049b78ee50fc1cfdee03853a4ebb", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=611ad29eedae3ce061de881cc19bd634220e0fe9", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for pa.c functions used in the md file & elsewhere.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -51,6 +51,7 @@ extern const char *output_movb PARAMS ((rtx *, rtx, int, int));\n extern const char *output_parallel_movb PARAMS ((rtx *, int));\n extern const char *output_parallel_addb PARAMS ((rtx *, int));\n extern const char *output_call PARAMS ((rtx, rtx, int));\n+extern const char *output_indirect_call PARAMS ((rtx, rtx));\n extern const char *output_millicode_call PARAMS ((rtx, rtx));\n extern const char *output_mul_insn PARAMS ((int, rtx));\n extern const char *output_div_insn PARAMS ((rtx *, int, rtx));\n@@ -104,8 +105,10 @@ extern int jump_in_call_delay PARAMS ((rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode, rtx));\n extern int hppa_fpstore_bypass_p PARAMS ((rtx, rtx));\n-extern int attr_length_millicode_call PARAMS ((rtx, int));\n+extern int attr_length_millicode_call PARAMS ((rtx));\n extern int attr_length_call PARAMS ((rtx, int));\n+extern int attr_length_indirect_call PARAMS ((rtx));\n+extern int attr_length_save_restore_dltp PARAMS ((rtx));\n \n /* Declare functions defined in pa.c and used in templates.  */\n "}, {"sha": "80c86e06f84da706b769bf160405c3feed666738", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 158, "deletions": 32, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=611ad29eedae3ce061de881cc19bd634220e0fe9", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for HPPA.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002 Free Software Foundation, Inc.\n+   2002, 2003 Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c\n \n This file is part of GNU CC.\n@@ -6279,37 +6279,42 @@ length_fp_args (insn)\n   return length;\n }\n \n-/* We include the delay slot in the returned length as it is better to\n+/* Return the attribute length for the millicode call instruction INSN.\n+   The length must match the code generated by output_millicode_call.\n+   We include the delay slot in the returned length as it is better to\n    over estimate the length than to under estimate it.  */\n \n int\n-attr_length_millicode_call (insn, length)\n+attr_length_millicode_call (insn)\n      rtx insn;\n-     int length;\n {\n-  unsigned long distance = total_code_bytes + INSN_ADDRESSES (INSN_UID (insn));\n+  unsigned long distance = -1;\n \n-  if (distance < total_code_bytes)\n-    distance = -1;\n+  if (INSN_ADDRESSES_SET_P ())\n+    {\n+      distance = (total_code_bytes + insn_current_reference_address (insn));\n+      if (distance < total_code_bytes)\n+\tdistance = -1;\n+    }\n \n   if (TARGET_64BIT)\n     {\n       if (!TARGET_LONG_CALLS && distance < 7600000)\n-\treturn length + 8;\n+\treturn 8;\n \n-      return length + 20;\n+      return 20;\n     }\n   else if (TARGET_PORTABLE_RUNTIME)\n-    return length + 24;\n+    return 24;\n   else\n     {\n       if (!TARGET_LONG_CALLS && distance < 240000)\n-\treturn length + 8;\n+\treturn 8;\n \n       if (TARGET_LONG_ABS_CALL && !flag_pic)\n-\treturn length + 12;\n+\treturn 12;\n \n-      return length + 24;\n+      return 24;\n     }\n }\n \n@@ -6439,16 +6444,22 @@ output_millicode_call (insn, call_dest)\n \n   /* See if the return address can be adjusted.  Use the containing\n      sequence insn's address.  */\n-  seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n-  distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n-\t      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n-\n-  if (VAL_14_BITS_P (distance))\n+  if (INSN_ADDRESSES_SET_P ())\n     {\n-      xoperands[1] = gen_label_rtx ();\n-      output_asm_insn (\"ldo %0-%1(%2),%2\", xoperands);\n-      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+      seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+      distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n+\t\t  - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n+\n+      if (VAL_14_BITS_P (distance))\n+\t{\n+\t  xoperands[1] = gen_label_rtx ();\n+\t  output_asm_insn (\"ldo %0-%1(%2),%2\", xoperands);\n+\t  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n+\t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t}\n+      else\n+\t/* ??? This branch may not reach its target.  */\n+\toutput_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n     }\n   else\n     /* ??? This branch may not reach its target.  */\n@@ -6462,18 +6473,25 @@ output_millicode_call (insn, call_dest)\n   return \"\";\n }\n \n-/* We include the delay slot in the returned length as it is better to\n-   over estimate the length than to under estimate it.  */\n+/* Return the attribute length of the call instruction INSN.  The SIBCALL\n+   flag indicates whether INSN is a regular call or a sibling call.  The\n+   length must match the code generated by output_call.  We include the delay\n+   slot in the returned length as it is better to over estimate the length\n+   than to under estimate it.  */\n \n int\n attr_length_call (insn, sibcall)\n      rtx insn;\n      int sibcall;\n {\n-  unsigned long distance = total_code_bytes + INSN_ADDRESSES (INSN_UID (insn));\n+  unsigned long distance = -1;\n \n-  if (distance < total_code_bytes)\n-    distance = -1;\n+  if (INSN_ADDRESSES_SET_P ())\n+    {\n+      distance = (total_code_bytes + insn_current_reference_address (insn));\n+      if (distance < total_code_bytes)\n+\tdistance = -1;\n+    }\n \n   if (TARGET_64BIT)\n     {\n@@ -6535,17 +6553,14 @@ output_call (insn, call_dest, sibcall)\n {\n   int delay_insn_deleted = 0;\n   int delay_slot_filled = 0;\n-  int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n   rtx xoperands[2];\n \n   xoperands[0] = call_dest;\n \n   /* Handle the common case where we're sure that the branch will reach\n      the beginning of the $CODE$ subspace.  */\n-  if (!TARGET_LONG_CALLS\n-      && ((seq_length == 0 && attr_length == 12)\n-\t  || (seq_length != 0 && attr_length == 8)))\n+  if (!TARGET_LONG_CALLS && attr_length_call (insn, sibcall) == 8)\n     {\n       xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n       output_asm_insn (\"{bl|b,l} %0,%1\", xoperands);\n@@ -6773,7 +6788,7 @@ output_call (insn, call_dest, sibcall)\n   /* This call has an unconditional jump in its delay slot.  */\n   xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n \n-  if (!delay_slot_filled)\n+  if (!delay_slot_filled && INSN_ADDRESSES_SET_P ())\n     {\n       /* See if the return address can be adjusted.  Use the containing\n          sequence insn's address.  */\n@@ -6804,6 +6819,117 @@ output_call (insn, call_dest, sibcall)\n   return \"\";\n }\n \n+/* Return the attribute length of the indirect call instruction INSN.\n+   The length must match the code generated by output_indirect call.\n+   The returned length includes the delay slot.  Currently, the delay\n+   slot of an indirect call sequence is not exposed and it is used by\n+   the sequence itself.  */\n+\n+int\n+attr_length_indirect_call (insn)\n+     rtx insn;\n+{\n+  unsigned long distance = -1;\n+\n+  if (INSN_ADDRESSES_SET_P ())\n+    {\n+      distance = (total_code_bytes + insn_current_reference_address (insn));\n+      if (distance < total_code_bytes)\n+\tdistance = -1;\n+    }\n+\n+  if (TARGET_64BIT)\n+    return 12;\n+\n+  if (TARGET_FAST_INDIRECT_CALLS\n+      || (!TARGET_PORTABLE_RUNTIME\n+\t  && ((TARGET_PA_20 && distance < 7600000) || distance < 240000)))\n+    return 8;\n+\n+  if (flag_pic)\n+    return 24;\n+\n+  if (TARGET_PORTABLE_RUNTIME)\n+    return 20;\n+\n+  /* Out of reach, can use ble.  */\n+  return 12;\n+}\n+\n+const char *\n+output_indirect_call (insn, call_dest)\n+     rtx insn;\n+     rtx call_dest;\n+{\n+  rtx xoperands[1];\n+\n+  if (TARGET_64BIT)\n+    {\n+      xoperands[0] = call_dest;\n+      output_asm_insn (\"ldd 16(%0),%%r2\", xoperands);\n+      output_asm_insn (\"bve,l (%%r2),%%r2\\n\\tldd 24(%0),%%r27\", xoperands);\n+      return \"\";\n+    }\n+\n+  /* First the special case for kernels, level 0 systems, etc.  */\n+  if (TARGET_FAST_INDIRECT_CALLS)\n+    return \"ble 0(%%sr4,%%r22)\\n\\tcopy %%r31,%%r2\"; \n+\n+  /* Now the normal case -- we can reach $$dyncall directly or\n+     we're sure that we can get there via a long-branch stub. \n+\n+     No need to check target flags as the length uniquely identifies\n+     the remaining cases.  */\n+  if (attr_length_indirect_call (insn) == 8)\n+    return \".CALL\\tARGW0=GR\\n\\t{bl|b,l} $$dyncall,%%r31\\n\\tcopy %%r31,%%r2\";\n+\n+  /* Long millicode call, but we are not generating PIC or portable runtime\n+     code.  */\n+  if (attr_length_indirect_call (insn) == 12)\n+    return \".CALL\\tARGW0=GR\\n\\tldil L'$$dyncall,%%r2\\n\\tble R'$$dyncall(%%sr4,%%r2)\\n\\tcopy %%r31,%%r2\";\n+\n+  /* Long millicode call for portable runtime.  */\n+  if (attr_length_indirect_call (insn) == 20)\n+    return \"ldil L'$$dyncall,%%r31\\n\\tldo R'$$dyncall(%%r31),%%r31\\n\\tblr %%r0,%%r2\\n\\tbv,n %%r0(%%r31)\\n\\tnop\";\n+\n+  /* We need a long PIC call to $$dyncall.  */\n+  xoperands[0] = NULL_RTX;\n+  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+  if (TARGET_SOM || !TARGET_GAS)\n+    {\n+      xoperands[0] = gen_label_rtx ();\n+      output_asm_insn (\"addil L'$$dyncall-%0,%%r1\", xoperands);\n+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n+\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[0]));\n+      output_asm_insn (\"ldo R'$$dyncall-%0(%%r1),%%r1\", xoperands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\"addil L'$$dyncall-$PIC_pcrel$0+4,%%r1\", xoperands);\n+      output_asm_insn (\"ldo R'$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\",\n+\t\t       xoperands);\n+    }\n+  output_asm_insn (\"blr %%r0,%%r2\", xoperands);\n+  output_asm_insn (\"bv,n %%r0(%%r1)\\n\\tnop\", xoperands);\n+  return \"\";\n+}\n+\n+/* Return the total length of the save and restore instructions needed for\n+   the data linkage table pointer (i.e., the PIC register) across the call\n+   instruction INSN.  No-return calls do not require a save and restore.\n+   In addition, we may be able to avoid the save and restore for calls\n+   within the same translation unit.  */\n+\n+int\n+attr_length_save_restore_dltp (insn)\n+     rtx insn;\n+{\n+  if (find_reg_note (insn, REG_NORETURN, NULL_RTX))\n+    return 0;\n+\n+  return 8;\n+}\n+\n /* In HPUX 8.0's shared library scheme, special relocations are needed\n    for function labels if they might be passed to a function\n    in a shared library (because shared libraries don't live in code"}, {"sha": "85db0bf137a208f4d1ff0892317e9ac8a17ce5ad", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 825, "deletions": 271, "changes": 1096, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611ad29eedae3ce061de881cc19bd634220e0fe9/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=611ad29eedae3ce061de881cc19bd634220e0fe9", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for HP PA-RISC architecture for GNU C compiler\n ;;   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-;;   2002 Free Software Foundation, Inc.\n+;;   2002, 2003 Free Software Foundation, Inc.\n ;;   Contributed by the Center for Software Science at the University\n ;;   of Utah.\n \n@@ -4086,7 +4086,7 @@\n   \"!TARGET_64BIT\"\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n@@ -4097,7 +4097,7 @@\n   \"TARGET_64BIT\"\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4188,7 +4188,7 @@\n   \"*\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29)\n@@ -4202,7 +4202,7 @@\n   \"*\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4245,7 +4245,7 @@\n   \"*\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29)\n@@ -4259,7 +4259,7 @@\n   \"*\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4298,7 +4298,7 @@\n   \"*\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n@@ -4311,7 +4311,7 @@\n   \"*\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4350,7 +4350,7 @@\n   \"*\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n@@ -4363,7 +4363,7 @@\n   \"*\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n \n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n@@ -5614,23 +5614,7 @@\n   [(return)\n    (use (reg:SI 2))\n    (const_int 1)]\n-  \"! flag_pic\"\n-  \"*\n-{\n-  if (TARGET_PA_20)\n-    return \\\"bve%* (%%r2)\\\";\n-  return \\\"bv%* %%r0(%%r2)\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; Use the PIC register to ensure it's restored after a\n-;; call in PIC mode.\n-(define_insn \"return_internal_pic\"\n-  [(return)\n-   (use (match_operand 0 \"register_operand\" \"r\"))\n-   (use (reg:SI 2))]\n-  \"flag_pic && true_regnum (operands[0]) == PIC_OFFSET_TABLE_REGNUM\"\n+  \"\"\n   \"*\n {\n   if (TARGET_PA_20)\n@@ -5640,17 +5624,12 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n-;; Use the PIC register to ensure it's restored after a\n-;; call in PIC mode.  This is used for eh returns which\n-;; bypass the return stub.\n+;; This is used for eh returns which bypass the return stub.\n (define_insn \"return_external_pic\"\n   [(return)\n-   (use (match_operand 0 \"register_operand\" \"r\"))\n-   (use (reg:SI 2))\n-   (clobber (reg:SI 1))]\n-  \"flag_pic\n-   && current_function_calls_eh_return\n-   && true_regnum (operands[0]) == PIC_OFFSET_TABLE_REGNUM\"\n+   (clobber (reg:SI 1))\n+   (use (reg:SI 2))]\n+  \"flag_pic && current_function_calls_eh_return\"\n   \"ldsid (%%sr0,%%r2),%%r1\\;mtsp %%r1,%%sr0\\;be%* 0(%%sr0,%%r2)\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"12\")])\n@@ -5683,20 +5662,15 @@\n       rtx x;\n \n       hppa_expand_epilogue ();\n-      if (flag_pic)\n-\t{\n-\t  rtx pic = gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM);\n \n-\t  /* EH returns bypass the normal return stub.  Thus, we must do an\n-\t     interspace branch to return from functions that call eh_return.\n-\t     This is only a problem for returns from shared code.  */\n-\t  if (current_function_calls_eh_return)\n-\t    x = gen_return_external_pic (pic);\n-\t  else\n-\t    x = gen_return_internal_pic (pic);\n-\t}\n+      /* EH returns bypass the normal return stub.  Thus, we must do an\n+\t interspace branch to return from functions that call eh_return.\n+\t This is only a problem for returns from shared code.  */\n+      if (flag_pic && current_function_calls_eh_return)\n+\tx = gen_return_external_pic ();\n       else\n \tx = gen_return_internal ();\n+\n       emit_jump_insn (x);\n     }\n   DONE;\n@@ -5901,8 +5875,8 @@\n   \"\"\n   \"\n {\n-  rtx op;\n-  rtx call_insn;\n+  rtx op, call_insn;\n+  rtx nb = operands[1];\n \n   if (TARGET_PORTABLE_RUNTIME)\n     op = force_reg (SImode, XEXP (operands[0], 0));\n@@ -5918,43 +5892,105 @@\n      and calls through function pointers.  This is necessary as these two\n      types of calls use different calling conventions, and CSE might try\n      to change the named call into an indirect call in some cases (using\n-     two patterns keeps CSE from performing this optimization).  */\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    call_insn = emit_call_insn (gen_call_internal_symref (op, operands[1]));\n-  else if (TARGET_64BIT)\n+     two patterns keeps CSE from performing this optimization).\n+     \n+     We now use even more call patterns as there was a subtle bug in\n+     attempting to restore the pic register after a call using a simple\n+     move insn.  During reload, a instruction involving a pseudo register\n+     with no explicit dependence on the PIC register can be converted\n+     to an equivalent load from memory using the PIC register.  If we\n+     emit a simple move to restore the PIC register in the initial rtl\n+     generation, then it can potentially be repositioned during scheduling.\n+     and an instruction that eventually uses the PIC register may end up\n+     between the call and the PIC register restore.\n+     \n+     This only worked because there is a post call group of instructions\n+     that are scheduled with the call.  These instructions are included\n+     in the same basic block as the call.  However, calls can throw in\n+     C++ code and a basic block has to terminate at the call if the call\n+     can throw.  This results in the PIC register restore being scheduled\n+     independently from the call.  So, we now hide the save and restore\n+     of the PIC register in the call pattern until after reload.  Then,\n+     we split the moves out.  A small side benefit is that we now don't\n+     need to have a use of the PIC register in the return pattern and\n+     the final save/restore operation is not needed.\n+     \n+     I elected to just clobber %r4 in the PIC patterns and use it instead\n+     of trying to force hppa_pic_save_rtx () to a callee saved register.\n+     This might have required a new register class and constraint.  It\n+     was also simpler to just handle the restore from a register than a\n+     generic pseudo.  */\n+  if (TARGET_64BIT)\n     {\n-      rtx tmpreg = force_reg (word_mode, op);\n-      call_insn = emit_call_insn (gen_call_internal_reg_64bit (tmpreg,\n-\t\t\t\t\t\t\t       operands[1]));\n+      if (GET_CODE (op) == SYMBOL_REF)\n+\tcall_insn = emit_call_insn (gen_call_symref_64bit (op, nb));\n+      else\n+\t{\n+\t  op = force_reg (word_mode, op);\n+\t  call_insn = emit_call_insn (gen_call_reg_64bit (op, nb));\n+\t}\n     }\n   else\n     {\n-      rtx tmpreg = gen_rtx_REG (word_mode, 22);\n-      emit_move_insn (tmpreg, force_reg (word_mode, op));\n-      call_insn = emit_call_insn (gen_call_internal_reg (operands[1]));\n-    }\n-\n-  if (TARGET_64BIT)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n-\n-  if (flag_pic)\n-    {\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+      if (GET_CODE (op) == SYMBOL_REF)\n+\t{\n+\t  if (flag_pic)\n+\t    call_insn = emit_call_insn (gen_call_symref_pic (op, nb));\n+\t  else\n+\t    call_insn = emit_call_insn (gen_call_symref (op, nb));\n+\t}\n+      else\n+\t{\n+\t  rtx tmpreg = gen_rtx_REG (word_mode, 22);\n \n-      /* After each call we must restore the PIC register, even if it\n-\t doesn't appear to be used.  */\n-      emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n+\t  emit_move_insn (tmpreg, force_reg (word_mode, op));\n+\t  if (flag_pic)\n+\t    call_insn = emit_call_insn (gen_call_reg_pic (nb));\n+\t  else\n+\t    call_insn = emit_call_insn (gen_call_reg (nb));\n+\t}\n     }\n+\n   DONE;\n }\")\n \n-(define_insn \"call_internal_symref\"\n+;; We use function calls to set the attribute length of calls and millicode\n+;; calls.  This is necessary because of the large variety of call sequences.\n+;; Implementing the calculation in rtl is difficult as well as ugly.  As\n+;; we need the same calculation in several places, maintenance becomes a\n+;; nightmare.\n+;;\n+;; However, this has a subtle impact on branch shortening.  When the\n+;; expression used to set the length attribute of an instruction depends\n+;; on a relative address (e.g., pc or a branch address), genattrtab\n+;; notes that the insn's length is variable, and attempts to determine a\n+;; worst-case default length and code to compute an insn's current length.\n+\n+;; The use of a function call hides the variable dependence of our calls\n+;; and millicode calls.  The result is genattrtab doesn't treat the operation\n+;; as variable and it only generates code for the default case using our\n+;; function call.  Because of this, calls and millicode calls have a fixed\n+;; length in the branch shortening pass, and some branches will use a longer\n+;; code sequence than necessary.  However, the length of any given call\n+;; will still reflect its final code location and it may be shorter than\n+;; the initial length estimate.\n+\n+;; It's possible to trick genattrtab by adding an expression involving `pc'\n+;; in the set.  However, when genattrtab hits a function call in its attempt\n+;; to compute the default length, it marks the result as unknown and sets\n+;; the default result to MAX_INT ;-(  One possible fix that would allow\n+;; calls to participate in branch shortening would be to make the call to\n+;; insn_default_length a target option.  Then, we could massage unknown\n+;; results.  Another fix might be to change genattrtab so that it just does\n+;; the call in the variable case as it already does for the fixed case.\n+\n+(define_insn \"call_symref\"\n   [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (use (const_int 0))]\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n   output_arg_descriptor (insn);\n@@ -5963,102 +5999,339 @@\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n \n-(define_insn \"call_internal_reg_64bit\"\n-  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n+(define_insn \"call_symref_pic\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (use (const_int 1))]\n+   (clobber (reg:SI 4))\n+   (use (reg:SI 19))\n+   (use (const_int 0))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[0], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n+\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:SI 4) (reg:SI 19))\n+   (parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])\n+   (set (reg:SI 19) (reg:SI 4))]\n+  \"\")\n+\n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\"\n+  [(parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])]\n+  \"\")\n+\n+(define_insn \"*call_symref_pic_post_reload\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (use (reg:SI 19))\n+   (use (const_int 0))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[0], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+\n+;; This pattern is split if it is necessary to save and restore the\n+;; PIC register.\n+(define_insn \"call_symref_64bit\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DI 4))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 0))]\n   \"TARGET_64BIT\"\n   \"*\n {\n-  /* ??? Needs more work.  Length computation, split into multiple insns,\n-     expose delay slot.  */\n-  return \\\"ldd 16(%0),%%r2\\;bve,l (%%r2),%%r2\\;ldd 24(%0),%%r27\\\";\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[0], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n+\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])]\n+  \"TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:DI 4) (reg:DI 27))\n+   (parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])\n+   (set (reg:DI 27) (reg:DI 4))]\n+  \"\")\n+\n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])]\n+  \"\")\n+\n+(define_insn \"*call_symref_64bit_post_reload\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[0], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+\n+(define_insn \"call_reg\"\n+  [(call (mem:SI (reg:SI 22))\n+\t (match_operand 0 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (use (const_int 1))]\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (const_int 12))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n \n-(define_insn \"call_internal_reg\"\n+;; This pattern is split if it is necessary to save and restore the\n+;; PIC register.\n+(define_insn \"call_reg_pic\"\n   [(call (mem:SI (reg:SI 22))\n \t (match_operand 0 \"\" \"i\"))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n+   (clobber (reg:SI 4))\n+   (use (reg:SI 19))\n    (use (const_int 1))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n-  rtx xoperands[2];\n+  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n \n-  /* First the special case for kernels, level 0 systems, etc.  */\n-  if (TARGET_FAST_INDIRECT_CALLS)\n-    return \\\"ble 0(%%sr4,%%r22)\\;copy %%r31,%%r2\\\";\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(call (mem:SI (reg:SI 22))\n+\t\t    (match_operand 0 \"\" \"\"))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"!TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:SI 4) (reg:SI 19))\n+   (parallel [(call (mem:SI (reg:SI 22))\n+\t\t    (match_dup 0))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])\n+   (set (reg:SI 19) (reg:SI 4))]\n+  \"\")\n \n-  /* Now the normal case -- we can reach $$dyncall directly or\n-     we're sure that we can get there via a long-branch stub. \n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(call (mem:SI (reg:SI 22))\n+\t\t    (match_operand 0 \"\" \"\"))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"!TARGET_64BIT && reload_completed\"\n+  [(parallel [(call (mem:SI (reg:SI 22))\n+\t\t    (match_dup 0))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"\")\n \n-     No need to check target flags as the length uniquely identifies\n-     the remaining cases.  */\n-  if (get_attr_length (insn) == 8)\n-    return \\\".CALL\\\\tARGW0=GR\\;{bl|b,l} $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n+(define_insn \"*call_reg_pic_post_reload\"\n+  [(call (mem:SI (reg:SI 22))\n+\t (match_operand 0 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (use (reg:SI 19))\n+   (use (const_int 1))]\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+\n+;; This pattern is split if it is necessary to save and restore the\n+;; PIC register.\n+(define_insn \"call_reg_64bit\"\n+  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DI 4))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, operands[0]);\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n \n-  /* Long millicode call, but we are not generating PIC or portable runtime\n-     code.  */\n-  if (get_attr_length (insn) == 12)\n-    return \\\".CALL\\\\tARGW0=GR\\;ldil L%%$$dyncall,%%r2\\;ble R%%$$dyncall(%%sr4,%%r2)\\;copy %%r31,%%r2\\\";\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(call (mem:SI (match_operand 0 \"register_operand\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:DI 4) (reg:DI 27))\n+   (parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])\n+   (set (reg:DI 27) (reg:DI 4))]\n+  \"\")\n \n-  /* Long millicode call for portable runtime.  */\n-  if (get_attr_length (insn) == 20)\n-    return \\\"ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr %%r0,%%r2\\;bv,n %%r0(%%r31)\\;nop\\\";\n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(call (mem:SI (match_operand 0 \"register_operand\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(call (mem:SI (match_dup 0))\n+\t\t    (match_dup 1))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"\")\n \n-  /* If we're generating PIC code.  */\n-  xoperands[0] = operands[0];\n-  if (TARGET_SOM || ! TARGET_GAS)\n-    xoperands[1] = gen_label_rtx ();\n-  output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\", xoperands);\n-  if (TARGET_SOM || ! TARGET_GAS)\n-    {\n-      output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n-      (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n-\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n-      output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n-    }\n-  else\n-    {\n-      output_asm_insn (\\\"addil L%%$$dyncall-$PIC_pcrel$0+4,%%r1\\\", xoperands);\n-      output_asm_insn (\\\"ldo R%%$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\\\",\n-      \t\t       xoperands);\n-    }\n-  output_asm_insn (\\\"blr %%r0,%%r2\\\", xoperands);\n-  output_asm_insn (\\\"bv,n %%r0(%%r1)\\\\n\\\\tnop\\\", xoperands);\n-  return \\\"\\\";\n+(define_insn \"*call_reg_64bit_post_reload\"\n+  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:DI 2))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, operands[0]);\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\")\n-     (cond [\n-;; First FAST_INDIRECT_CALLS\n-\t    (ne (symbol_ref \"TARGET_FAST_INDIRECT_CALLS\")\n-\t\t(const_int 0))\n-\t    (const_int 8)\n-\n-;; Target (or stub) within reach\n-\t    (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-\t\t     (const_int 240000))\n-\t\t (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t     (const_int 0)))\n-\t    (const_int 8)\n-\n-;; Out of reach PIC\n-\t    (ne (symbol_ref \"flag_pic\")\n-\t\t(const_int 0))\n-\t    (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t(const_int 0))\n-\t    (const_int 20)]\n-\n-;; Out of reach, can use ble\n-\t  (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -6068,11 +6341,12 @@\n   \"\"\n   \"\n {\n-  rtx op;\n-  rtx call_insn;\n+  rtx op, call_insn;\n+  rtx dst = operands[0];\n+  rtx nb = operands[2];\n \n   if (TARGET_PORTABLE_RUNTIME)\n-    op = force_reg (word_mode, XEXP (operands[1], 0));\n+    op = force_reg (SImode, XEXP (operands[1], 0));\n   else\n     op = XEXP (operands[1], 0);\n \n@@ -6085,50 +6359,76 @@\n      and calls through function pointers.  This is necessary as these two\n      types of calls use different calling conventions, and CSE might try\n      to change the named call into an indirect call in some cases (using\n-     two patterns keeps CSE from performing this optimization).  */\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    call_insn = emit_call_insn (gen_call_value_internal_symref (operands[0],\n-\t\t\t\t\t\t\t\top,\n-\t\t\t\t\t\t\t\toperands[2]));\n-  else if (TARGET_64BIT)\n+     two patterns keeps CSE from performing this optimization).\n+\n+     We now use even more call patterns as there was a subtle bug in\n+     attempting to restore the pic register after a call using a simple\n+     move insn.  During reload, a instruction involving a pseudo register\n+     with no explicit dependence on the PIC register can be converted\n+     to an equivalent load from memory using the PIC register.  If we\n+     emit a simple move to restore the PIC register in the initial rtl\n+     generation, then it can potentially be repositioned during scheduling.\n+     and an instruction that eventually uses the PIC register may end up\n+     between the call and the PIC register restore.\n+     \n+     This only worked because there is a post call group of instructions\n+     that are scheduled with the call.  These instructions are included\n+     in the same basic block as the call.  However, calls can throw in\n+     C++ code and a basic block has to terminate at the call if the call\n+     can throw.  This results in the PIC register restore being scheduled\n+     independently from the call.  So, we now hide the save and restore\n+     of the PIC register in the call pattern until after reload.  Then,\n+     we split the moves out.  A small side benefit is that we now don't\n+     need to have a use of the PIC register in the return pattern and\n+     the final save/restore operation is not needed.\n+     \n+     I elected to just clobber %r4 in the PIC patterns and use it instead\n+     of trying to force hppa_pic_save_rtx () to a callee saved register.\n+     This might have required a new register class and constraint.  It\n+     was also simpler to just handle the restore from a register than a\n+     generic pseudo.  */\n+  if (TARGET_64BIT)\n     {\n-      rtx tmpreg = force_reg (word_mode, op);\n-      call_insn\n-\t= emit_call_insn (gen_call_value_internal_reg_64bit (operands[0],\n-\t\t\t\t\t\t\t     tmpreg,\n-\t\t\t\t\t\t\t     operands[2]));\n+      if (GET_CODE (op) == SYMBOL_REF)\n+\tcall_insn = emit_call_insn (gen_call_val_symref_64bit (dst, op, nb));\n+      else\n+\t{\n+\t  op = force_reg (word_mode, op);\n+\t  call_insn = emit_call_insn (gen_call_val_reg_64bit (dst, op, nb));\n+\t}\n     }\n   else\n     {\n-      rtx tmpreg = gen_rtx_REG (word_mode, 22);\n-      emit_move_insn (tmpreg, force_reg (word_mode, op));\n-      call_insn = emit_call_insn (gen_call_value_internal_reg (operands[0],\n-\t\t\t\t\t\t\t       operands[2]));\n-    }\n-\n-  if (TARGET_64BIT)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n-\n-  if (flag_pic)\n-    {\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+      if (GET_CODE (op) == SYMBOL_REF)\n+\t{\n+\t  if (flag_pic)\n+\t    call_insn = emit_call_insn (gen_call_val_symref_pic (dst, op, nb));\n+\t  else\n+\t    call_insn = emit_call_insn (gen_call_val_symref (dst, op, nb));\n+\t}\n+      else\n+\t{\n+\t  rtx tmpreg = gen_rtx_REG (word_mode, 22);\n \n-      /* After each call we must restore the PIC register, even if it\n-\t doesn't appear to be used.  */\n-      emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n+\t  emit_move_insn (tmpreg, force_reg (word_mode, op));\n+\t  if (flag_pic)\n+\t    call_insn = emit_call_insn (gen_call_val_reg_pic (dst, nb));\n+\t  else\n+\t    call_insn = emit_call_insn (gen_call_val_reg (dst, nb));\n+\t}\n     }\n+\n   DONE;\n }\")\n \n-(define_insn \"call_value_internal_symref\"\n+(define_insn \"call_val_symref\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t      (match_operand 2 \"\" \"i\")))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (use (const_int 0))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n   output_arg_descriptor (insn);\n@@ -6137,104 +6437,364 @@\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n \n-(define_insn \"call_value_internal_reg_64bit\"\n+(define_insn \"call_val_symref_pic\"\n   [(set (match_operand 0 \"\" \"\")\n-         (call (mem:SI (match_operand:DI 1 \"register_operand\" \"r\"))\n-\t       (match_operand 2 \"\" \"i\")))\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (use (const_int 1))]\n+   (clobber (reg:SI 4))\n+   (use (reg:SI 19))\n+   (use (const_int 0))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n+\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:SI 4) (reg:SI 19))\n+   (parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])\n+   (set (reg:SI 19) (reg:SI 4))]\n+  \"\")\n+\n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 0))])]\n+  \"\")\n+\n+(define_insn \"*call_val_symref_pic_post_reload\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (use (reg:SI 19))\n+   (use (const_int 0))]\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+\n+;; This pattern is split if it is necessary to save and restore the\n+;; PIC register.\n+(define_insn \"call_val_symref_64bit\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DI 4))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 0))]\n   \"TARGET_64BIT\"\n   \"*\n {\n-  /* ??? Needs more work.  Length computation, split into multiple insns,\n-     expose delay slot.  */\n-  return \\\"ldd 16(%1),%%r2\\;bve,l (%%r2),%%r2\\;ldd 24(%1),%%r27\\\";\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n+\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])]\n+  \"TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:DI 4) (reg:DI 27))\n+   (parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])\n+   (set (reg:DI 27) (reg:DI 4))]\n+  \"\")\n+\n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t\t    (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t      (call (mem:SI (match_dup 1))\n+\t\t    (match_dup 2)))\n+\t      (clobber (reg:DI 1))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 0))])]\n+  \"\")\n+\n+(define_insn \"*call_val_symref_64bit_post_reload\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[1], 0);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+\n+(define_insn \"call_val_reg\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (reg:SI 22))\n+\t      (match_operand 1 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (use (const_int 1))]\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (const_int 12))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n \n-(define_insn \"call_value_internal_reg\"\n+;; This pattern is split if it is necessary to save and restore the\n+;; PIC register.\n+(define_insn \"call_val_reg_pic\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (reg:SI 22))\n \t      (match_operand 1 \"\" \"i\")))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n+   (clobber (reg:SI 4))\n+   (use (reg:SI 19))\n    (use (const_int 1))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n-  rtx xoperands[2];\n+  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n \n-  /* First the special case for kernels, level 0 systems, etc.  */\n-  if (TARGET_FAST_INDIRECT_CALLS)\n-    return \\\"ble 0(%%sr4,%%r22)\\;copy %%r31,%%r2\\\";\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (reg:SI 22))\n+\t\t\t (match_operand 1 \"\" \"\")))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"!TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:SI 4) (reg:SI 19))\n+   (parallel [(set (match_dup 0)\n+\t\t   (call (mem:SI (reg:SI 22))\n+\t\t\t (match_dup 1)))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])\n+   (set (reg:SI 19) (reg:SI 4))]\n+  \"\")\n \n-  /* Now the normal case -- we can reach $$dyncall directly or\n-     we're sure that we can get there via a long-branch stub. \n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (reg:SI 22))\n+\t\t\t (match_operand 1 \"\" \"\")))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 4))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"!TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (call (mem:SI (reg:SI 22))\n+\t\t\t (match_dup 1)))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (use (reg:SI 19))\n+\t      (use (const_int 1))])]\n+  \"\")\n \n-     No need to check target flags as the length uniquely identifies\n-     the remaining cases.  */\n-  if (get_attr_length (insn) == 8)\n-    return \\\".CALL\\\\tARGW0=GR\\;{bl|b,l} $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n+(define_insn \"*call_val_reg_pic_post_reload\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (reg:SI 22))\n+\t      (match_operand 1 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (use (reg:SI 19))\n+   (use (const_int 1))]\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n \n-  /* Long millicode call, but we are not generating PIC or portable runtime\n-     code.  */\n-  if (get_attr_length (insn) == 12)\n-    return \\\".CALL\\\\tARGW0=GR\\;ldil L%%$$dyncall,%%r2\\;ble R%%$$dyncall(%%sr4,%%r2)\\;copy %%r31,%%r2\\\";\n+;; This pattern is split if it is necessary to save and restore the\n+;; PIC register.\n+(define_insn \"call_val_reg_64bit\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DI 4))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, operands[1]);\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n+\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n \n-  /* Long millicode call for portable runtime.  */\n-  if (get_attr_length (insn) == 20)\n-    return \\\"ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr %%r0,%%r2\\;bv,n %%r0(%%r31)\\;nop\\\";\n+;; Split out the PIC register save and restore after reload.  This is\n+;; done if the function doesn't return.\n+(define_split\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (match_operand:DI 1 \"register_operand\" \"\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"TARGET_64BIT\n+   && reload_completed\n+   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (reg:DI 4) (reg:DI 27))\n+   (parallel [(set (match_dup 0)\n+\t\t   (call (mem:SI (match_dup 1))\n+\t\t\t (match_dup 2)))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])\n+   (set (reg:DI 27) (reg:DI 4))]\n+  \"\")\n \n-  /* If we're generating PIC code.  */\n-  xoperands[0] = operands[1];\n-  if (TARGET_SOM || ! TARGET_GAS)\n-    xoperands[1] = gen_label_rtx ();\n-  output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\", xoperands);\n-  if (TARGET_SOM || ! TARGET_GAS)\n-    {\n-      output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n-      (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n-\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n-      output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n-    }\n-  else\n-    {\n-      output_asm_insn (\\\"addil L%%$$dyncall-$PIC_pcrel$0+4,%%r1\\\", xoperands);\n-      output_asm_insn (\\\"ldo R%%$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\\\",\n-      \t\t       xoperands);\n-    }\n-  output_asm_insn (\\\"blr %%r0,%%r2\\\", xoperands);\n-  output_asm_insn (\\\"bv,n %%r0(%%r1)\\\\n\\\\tnop\\\", xoperands);\n-  return \\\"\\\";\n+;; Remove the clobber of register 4 when optimizing.  This has to be\n+;; done with a peephole optimization rather than a split because the\n+;; split sequence for a call must be longer than one instruction.\n+(define_peephole2\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (match_operand:DI 1 \"register_operand\" \"\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 2))\n+\t      (clobber (reg:DI 4))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (call (mem:SI (match_dup 1))\n+\t\t\t (match_dup 2)))\n+\t      (clobber (reg:DI 2))\n+\t      (use (reg:DI 27))\n+\t      (use (reg:DI 29))\n+\t      (use (const_int 1))])]\n+  \"\")\n+\n+(define_insn \"*call_val_reg_64bit_post_reload\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 2))\n+   (use (reg:DI 27))\n+   (use (reg:DI 29))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_indirect_call (insn, operands[1]);\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\")\n-     (cond [\n-;; First FAST_INDIRECT_CALLS\n-\t    (ne (symbol_ref \"TARGET_FAST_INDIRECT_CALLS\")\n-\t\t(const_int 0))\n-\t    (const_int 8)\n-\n-;; Target (or stub) within reach\n-\t    (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-\t\t     (const_int 240000))\n-\t\t (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t     (const_int 0)))\n-\t    (const_int 8)\n-\n-;; Out of reach PIC\n-\t    (ne (symbol_ref \"flag_pic\")\n-\t\t(const_int 0))\n-\t    (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t(const_int 0))\n-\t    (const_int 20)]\n-\n-;; Out of reach, can use ble\n-\t  (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n \n ;; Call subroutine returning any type.\n \n@@ -6292,14 +6852,10 @@\n   if (TARGET_64BIT)\n     use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n+  /* We don't have to restore the PIC register.  */\n   if (flag_pic)\n-    {\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n \n-      /* After each call we must restore the PIC register, even if it\n-\t doesn't appear to be used.  */\n-      emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n-    }\n   DONE;\n }\")\n \n@@ -6321,9 +6877,8 @@\n (define_insn \"sibcall_internal_symref_64bit\"\n   [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n-   (clobber (reg:SI 1))\n-   (clobber (reg:SI 27))\n-   (use (reg:SI 2))\n+   (clobber (reg:DI 1))\n+   (use (reg:DI 2))\n    (use (const_int 0))]\n   \"TARGET_64BIT\"\n   \"*\n@@ -6364,14 +6919,10 @@\n   if (TARGET_64BIT)\n     use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n+  /* We don't have to restore the PIC register.  */\n   if (flag_pic)\n-    {\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n \n-      /* After each call we must restore the PIC register, even if it\n-\t doesn't appear to be used.  */\n-      emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n-    }\n   DONE;\n }\")\n \n@@ -6395,9 +6946,8 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t      (match_operand 2 \"\" \"i\")))\n-   (clobber (reg:SI 1))\n-   (clobber (reg:SI 27))\n-   (use (reg:SI 2))\n+   (clobber (reg:DI 1))\n+   (use (reg:DI 2))\n    (use (const_int 0))]\n   \"TARGET_64BIT\"\n   \"*\n@@ -7340,7 +7890,9 @@\n \t\t\t\t\t\t    \\\"$$sh_func_adrs\\\"));\n }\"\n   [(set_attr \"type\" \"multi\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 20)\"))])\n+   (set (attr \"length\")\n+\t(plus (symbol_ref \"attr_length_millicode_call (insn)\")\n+\t      (const_int 20)))])\n \n ;; On the PA, the PIC register is call clobbered, so it must\n ;; be saved & restored around calls by the caller.  If the call\n@@ -7361,6 +7913,7 @@\n   /* Restore the PIC register using hppa_pic_save_rtx ().  The\n      PIC register is not saved in the frame in 64-bit ABI.  */\n   emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n+  emit_insn (gen_blockage ());\n   DONE;\n }\")\n \n@@ -7375,5 +7928,6 @@\n      a stack slot.  The only registers that are valid after a\n      builtin_longjmp are the stack and frame pointers.  */\n   emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n+  emit_insn (gen_blockage ());\n   DONE;\n }\")"}]}