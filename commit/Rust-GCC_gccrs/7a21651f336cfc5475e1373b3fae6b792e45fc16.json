{"sha": "7a21651f336cfc5475e1373b3fae6b792e45fc16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyMTY1MWYzMzZjZmM1NDc1ZTEzNzNiM2ZhZTZiNzkyZTQ1ZmMxNg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-06-12T18:57:02Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-16T09:18:18Z"}, "message": "[Ada] Ongoing work for AI12-0212 : container aggregates\n\ngcc/ada/\n\n\t* sem_aggr.adb (Resolve_Container_Aggregate): Add semantic\n\tchecks for indexed aggregates, including component associations\n\tand iterated component associations.\n\t* exp_aggr.adb (Expand_Iterated_Component): New subprogram,\n\tsubsidiary of Expand_Container_Aggreggate, used for positional,\n\tnamed, and indexed aggregates.\n\t(Aggregate_Size): New subprogram to precompute the size of an\n\tindexed aggregate prior to call to allocate it.\n\t(Expand_Range_Component): New subprogram so generate loop for a\n\tcomponent association given by a range or a subtype name in an\n\tindexed aggregate.", "tree": {"sha": "27ef3e9c53ab81c3002ae543c99c4d161bd95e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27ef3e9c53ab81c3002ae543c99c4d161bd95e80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a21651f336cfc5475e1373b3fae6b792e45fc16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a21651f336cfc5475e1373b3fae6b792e45fc16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a21651f336cfc5475e1373b3fae6b792e45fc16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a21651f336cfc5475e1373b3fae6b792e45fc16/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81fcf43389ea53b223e1c16d60b6d8e735e0a4e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fcf43389ea53b223e1c16d60b6d8e735e0a4e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fcf43389ea53b223e1c16d60b6d8e735e0a4e4"}], "stats": {"total": 308, "additions": 301, "deletions": 7}, "files": [{"sha": "102844f8c901be85f7a269211f104a2bbdbe5682", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 248, "deletions": 5, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a21651f336cfc5475e1373b3fae6b792e45fc16/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a21651f336cfc5475e1373b3fae6b792e45fc16/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7a21651f336cfc5475e1373b3fae6b792e45fc16", "patch": "@@ -6878,15 +6878,19 @@ package body Exp_Aggr is\n       New_Indexed_Subp    : Node_Id := Empty;\n       Assign_Indexed_Subp : Node_Id := Empty;\n \n-      procedure Expand_Iterated_Component (Comp : Node_Id);\n-\n       Aggr_Code : constant List_Id   := New_List;\n       Temp      : constant Entity_Id := Make_Temporary (Loc, 'C', N);\n \n       Comp      : Node_Id;\n       Decl      : Node_Id;\n       Init_Stat : Node_Id;\n \n+      procedure Expand_Iterated_Component (Comp : Node_Id);\n+      --  Handle iterated_component_association and iterated_Element\n+      --  association by generating a loop over the specified range,\n+      --  given either by a loop parameter specification or an iterator\n+      --  specification.\n+\n       -------------------------------\n       -- Expand_Iterated_Component --\n       -------------------------------\n@@ -6946,6 +6950,7 @@ package body Exp_Aggr is\n                           Iteration_Scheme => L_Iteration_Scheme,\n                           Statements       => Stats);\n          Append (Loop_Stat, Aggr_Code);\n+\n       end Expand_Iterated_Component;\n \n    begin\n@@ -6968,11 +6973,16 @@ package body Exp_Aggr is\n            Name => New_Occurrence_Of (Temp, Loc),\n            Expression => New_Occurrence_Of (Entity (Empty_Subp), Loc));\n       end if;\n+\n       Append (Init_Stat, Aggr_Code);\n \n-      --  First case: positional aggregate\n+      ---------------------------\n+      --  Positional aggregate --\n+      ---------------------------\n \n-      if Present (Add_Unnamed_Subp) then\n+      if Present (Add_Unnamed_Subp)\n+        and then No (Assign_Indexed_Subp)\n+      then\n          if Present (Expressions (N)) then\n             declare\n                Insert : constant Entity_Id := Entity (Add_Unnamed_Subp);\n@@ -6993,14 +7003,18 @@ package body Exp_Aggr is\n             end;\n          end if;\n \n-         --  iterated component associations may be present.\n+         --  Iterated component associations may also be present.\n \n          Comp := First (Component_Associations (N));\n          while Present (Comp) loop\n             Expand_Iterated_Component (Comp);\n             Next (Comp);\n          end loop;\n \n+      ---------------------\n+      -- Named_Aggregate --\n+      ---------------------\n+\n       elsif Present (Add_Named_Subp) then\n          declare\n             Insert : constant Entity_Id := Entity (Add_Named_Subp);\n@@ -7034,6 +7048,235 @@ package body Exp_Aggr is\n                Next (Comp);\n             end loop;\n          end;\n+\n+      -----------------------\n+      -- Indexed_Aggregate --\n+      -----------------------\n+\n+      elsif Present (Assign_Indexed_Subp) then\n+         declare\n+            Insert : constant Entity_Id := Entity (Assign_Indexed_Subp);\n+            Index_Type : constant Entity_Id :=\n+               Etype (Next_Formal (First_Formal (Insert)));\n+\n+            function Aggregate_Size return Int;\n+            --  Compute number of entries in aggregate, including choices\n+            --  that cover a range, as well as iterated constructs.\n+\n+            function  Expand_Range_Component\n+              (Rng  : Node_Id;\n+               Expr : Node_Id) return Node_Id;\n+            --  Transform a component assoication with a range into an\n+            --  explicit loop. If the choice is a subtype name, it is\n+            --  rewritten as a range with the corresponding bounds, which\n+            --  are known to be static.\n+\n+            Comp   : Node_Id;\n+            Index  : Node_Id;\n+            Pos    : Int := 0;\n+            Stat   : Node_Id;\n+            Key    : Node_Id;\n+            Size   : Int := 0;\n+\n+            -----------------------------\n+            -- Expand_Raange_Component --\n+            -----------------------------\n+\n+            function Expand_Range_Component\n+              (Rng  : Node_Id;\n+               Expr : Node_Id) return Node_Id\n+            is\n+               Loop_Id : constant Entity_Id :=\n+                 Make_Temporary (Loc, 'T');\n+\n+               L_Iteration_Scheme : Node_Id;\n+               Stats              : List_Id;\n+\n+            begin\n+               L_Iteration_Scheme :=\n+                 Make_Iteration_Scheme (Loc,\n+                   Loop_Parameter_Specification =>\n+                     Make_Loop_Parameter_Specification (Loc,\n+                       Defining_Identifier => Loop_Id,\n+                       Discrete_Subtype_Definition => New_Copy_Tree (Rng)));\n+\n+               Stats := New_List\n+                 (Make_Procedure_Call_Statement (Loc,\n+                    Name =>\n+                      New_Occurrence_Of (Entity (Assign_Indexed_Subp), Loc),\n+                    Parameter_Associations =>\n+                      New_List (New_Occurrence_Of (Temp, Loc),\n+                        New_Occurrence_Of (Loop_Id, Loc),\n+                        New_Copy_Tree (Expr))));\n+\n+               return  Make_Implicit_Loop_Statement\n+                         (Node             => N,\n+                          Identifier       => Empty,\n+                          Iteration_Scheme => L_Iteration_Scheme,\n+                          Statements       => Stats);\n+            end Expand_Range_Component;\n+\n+            --------------------\n+            -- Aggregate_Size --\n+            --------------------\n+\n+            function Aggregate_Size return Int is\n+               Comp   : Node_Id;\n+               Choice : Node_Id;\n+               Lo, Hi : Node_Id;\n+               Siz     : Int := 0;\n+\n+               procedure Add_Range_Size;\n+               --  Compute size of component association given by\n+               --  range or subtype name.\n+\n+               procedure Add_Range_Size is\n+               begin\n+                  if Nkind (Lo) = N_Integer_Literal then\n+                     Siz := Siz + UI_To_Int (Intval (Hi))\n+                       - UI_To_Int (Intval (Lo)) + 1;\n+                  end if;\n+               end Add_Range_Size;\n+\n+            begin\n+               if Present (Expressions (N)) then\n+                  Siz := List_Length (Expressions (N));\n+               end if;\n+\n+               if Present (Component_Associations (N)) then\n+                  Comp := First (Component_Associations (N));\n+                  while Present (Comp) loop\n+                     Choice := First (Choices (Comp));\n+\n+                     while Present (Choice) loop\n+                        Analyze (Choice);\n+\n+                        if Nkind (Choice) = N_Range then\n+                           Lo := Low_Bound (Choice);\n+                           Hi := High_Bound (Choice);\n+                           Add_Range_Size;\n+\n+                        elsif Is_Entity_Name (Choice)\n+                          and then Is_Type (Entity (Choice))\n+                        then\n+                           Lo := Type_Low_Bound (Entity (Choice));\n+                           Hi := Type_High_Bound (Entity (Choice));\n+                           Add_Range_Size;\n+                           Rewrite (Choice,\n+                             Make_Range (Loc,\n+                               New_Copy_Tree (Lo),\n+                               New_Copy_Tree (Hi)));\n+\n+                        else\n+                           Resolve (Choice, Index_Type);\n+                           Siz := Siz + 1;\n+                        end if;\n+\n+                        Next (Choice);\n+                     end loop;\n+                     Next (Comp);\n+                  end loop;\n+               end if;\n+\n+               return Siz;\n+            end Aggregate_Size;\n+\n+         begin\n+            Size := Aggregate_Size;\n+            if Size > 0 then\n+\n+               --  Modify the call to the constructor to allocate the\n+               --  required size for the aggregwte : call the provided\n+               --  constructor rather than the Empty aggregate.\n+\n+               Index :=  Make_Op_Add (Loc,\n+                 Left_Opnd => New_Copy_Tree (Type_Low_Bound (Index_Type)),\n+                 Right_Opnd => Make_Integer_Literal (Loc, Size - 1));\n+\n+               Set_Expression (Init_Stat,\n+                  Make_Function_Call (Loc,\n+                    Name =>\n+                      New_Occurrence_Of (Entity (New_Indexed_Subp), Loc),\n+                    Parameter_Associations =>\n+                      New_List (\n+                         New_Copy_Tree (Type_Low_Bound (Index_Type)),\n+                         Index)));\n+            end if;\n+\n+            if Present (Expressions (N)) then\n+               Comp := First (Expressions (N));\n+\n+               while Present (Comp) loop\n+\n+                  --  Compute index position for successive components\n+                  --  in the list of expressions, and use the indexed\n+                  --  assignment procedure for each.\n+\n+                  Index := Make_Op_Add (Loc,\n+                    Left_Opnd => Type_Low_Bound (Index_Type),\n+                    Right_Opnd => Make_Integer_Literal (Loc, Pos));\n+\n+                  Stat := Make_Procedure_Call_Statement (Loc,\n+                    Name => New_Occurrence_Of (Insert, Loc),\n+                    Parameter_Associations =>\n+                      New_List (New_Occurrence_Of (Temp, Loc),\n+                      Index,\n+                      New_Copy_Tree (Comp)));\n+\n+                  Pos := Pos + 1;\n+\n+                  Append (Stat, Aggr_Code);\n+                  Next (Comp);\n+               end loop;\n+            end if;\n+\n+            if Present (Component_Associations (N)) then\n+               Comp := First (Component_Associations (N));\n+\n+               --  The choice may be a static value, or a range with\n+               --  static bounds.\n+\n+               while Present (Comp) loop\n+                  if Nkind (Comp) = N_Component_Association then\n+                     Key := First (Choices (Comp));\n+                     while Present (Key) loop\n+\n+                        --  If the expression is a box, the corresponding\n+                        --  component (s) is left uninitialized.\n+\n+                        if Box_Present (Comp) then\n+                           goto Next_Key;\n+\n+                        elsif Nkind (Key) = N_Range then\n+\n+                           --  Create loop for tne specified range,\n+                           --  with copies of the expression.\n+\n+                           Stat :=\n+                             Expand_Range_Component (Key, Expression (Comp));\n+\n+                        else\n+                           Stat := Make_Procedure_Call_Statement (Loc,\n+                             Name => New_Occurrence_Of\n+                                (Entity (Assign_Indexed_Subp), Loc),\n+                                Parameter_Associations =>\n+                                  New_List (New_Occurrence_Of (Temp, Loc),\n+                                  New_Copy_Tree (Key),\n+                                  New_Copy_Tree (Expression (Comp))));\n+                        end if;\n+\n+                        Append (Stat, Aggr_Code);\n+\n+                        <<Next_Key>>\n+                        Next (Key);\n+                     end loop;\n+                  else\n+                     Error_Msg_N (\"iterated associations peding\", N);\n+                  end if;\n+                  Next (Comp);\n+               end loop;\n+            end if;\n+         end;\n       end if;\n \n       Insert_Actions (N, Aggr_Code);"}, {"sha": "1f5ad3e70ee9508d1896bb23cd8ec06f4a3c929b", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a21651f336cfc5475e1373b3fae6b792e45fc16/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a21651f336cfc5475e1373b3fae6b792e45fc16/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=7a21651f336cfc5475e1373b3fae6b792e45fc16", "patch": "@@ -2760,7 +2760,9 @@ package body Sem_Aggr is\n         Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n         New_Indexed_Subp, Assign_Indexed_Subp);\n \n-      if Present (Add_Unnamed_Subp) then\n+      if Present (Add_Unnamed_Subp)\n+        and then No (New_Indexed_Subp)\n+      then\n          declare\n             Elmt_Type : constant Entity_Id :=\n               Etype (Next_Formal\n@@ -2824,6 +2826,10 @@ package body Sem_Aggr is\n \n                   while Present (Choice) loop\n                      Analyze_And_Resolve (Choice, Key_Type);\n+                     if not Is_Static_Expression (Choice) then\n+                        Error_Msg_N (\"Choice must be static\", Choice);\n+                     end if;\n+\n                      Next (Choice);\n                   end loop;\n \n@@ -2837,8 +2843,53 @@ package body Sem_Aggr is\n                Next (Comp);\n             end loop;\n          end;\n+\n       else\n-         Error_Msg_N (\"indexed aggregates are forthcoming\", N);\n+         --  Indexed Aggregate. Both positional and indexed component\n+         --  can be present. Choices must be static values or ranges\n+         --  with static bounds.\n+\n+         declare\n+            Container : constant Entity_Id :=\n+              First_Formal (Entity (Assign_Indexed_Subp));\n+            Index_Type : constant Entity_Id := Etype (Next_Formal (Container));\n+            Comp_Type  : constant Entity_Id :=\n+                                 Etype (Next_Formal (Next_Formal (Container)));\n+            Comp   : Node_Id;\n+            Choice : Node_Id;\n+\n+         begin\n+            if Present (Expressions (N)) then\n+               Comp := First (Expressions (N));\n+               while Present (Comp) loop\n+                  Analyze_And_Resolve (Comp, Comp_Type);\n+                  Next (Comp);\n+               end loop;\n+            end if;\n+\n+            if Present (Component_Associations (N)) then\n+               Comp := First (Expressions (N));\n+\n+               while Present (Comp) loop\n+                  if Nkind (Comp) = N_Component_Association then\n+                     Choice := First (Choices (Comp));\n+\n+                     while Present (Choice) loop\n+                        Analyze_And_Resolve (Choice, Index_Type);\n+                        Next (Choice);\n+                     end loop;\n+\n+                     Analyze_And_Resolve (Expression (Comp), Comp_Type);\n+\n+                  elsif Nkind (Comp) = N_Iterated_Component_Association then\n+                     Resolve_Iterated_Component_Association\n+                       (Comp, Index_Type, Comp_Type);\n+                  end if;\n+\n+                  Next (Comp);\n+               end loop;\n+            end if;\n+         end;\n       end if;\n    end Resolve_Container_Aggregate;\n "}]}