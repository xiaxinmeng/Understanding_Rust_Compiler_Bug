{"sha": "fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmExYWVjYzFjMjE4ZWNhOGExYjU2NDNlOTI3NmJmZmU0ODVmNmU2Nw==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2014-04-14T08:27:56Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2014-04-14T08:27:56Z"}, "message": "sh.md (setmemqi): New expand pattern.\n\n2014-04-14  Christian Bruel  <christian.bruel@st.com>\n\n       * config/sh/sh.md (setmemqi): New expand pattern.\n       * config/sh/sh.h (CLEAR_RATIO): Define.\n       * config/sh/sh-mem.cc (sh_expand_setmem): Define.\n       * config/sh/sh-protos.h (sh_expand_setmem): Declare.\n\nFrom-SVN: r209357", "tree": {"sha": "81398b547687d90b41283bf728cb8c51c4669e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81398b547687d90b41283bf728cb8c51c4669e61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/comments", "author": null, "committer": null, "parents": [{"sha": "a3c77ce941aeee074370680b38de3704d59983c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c77ce941aeee074370680b38de3704d59983c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3c77ce941aeee074370680b38de3704d59983c6"}], "stats": {"total": 147, "additions": 147, "deletions": 0}, "files": [{"sha": "cc2b92e29102a2e6b6121d7216c1db32f3c20c08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -1,3 +1,10 @@\n+2014-04-14  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* config/sh/sh.md (setmemqi): New expand pattern.\n+\t* config/sh/sh.h (CLEAR_RATIO): Define.\n+\t* config/sh/sh-mem.cc (sh_expand_setmem): Define.\n+\t* config/sh/sh-protos.h (sh_expand_setmem): Declare.\n+\n 2014-04-14  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/55022"}, {"sha": "d499b3b5871d00a4c6779ddb01adfb498b373f35", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -608,3 +608,106 @@ sh_expand_strlen (rtx *operands)\n \n   return true;\n }\n+\n+/* Emit code to perform a memset\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the size;\n+   OPERANDS[2] is the char to search.\n+   OPERANDS[3] is the alignment.  */\n+void\n+sh_expand_setmem (rtx *operands)\n+{\n+  rtx L_loop_byte = gen_label_rtx ();\n+  rtx L_loop_word = gen_label_rtx ();\n+  rtx L_return = gen_label_rtx ();\n+  rtx jump;\n+  rtx dest = copy_rtx (operands[0]);\n+  rtx dest_addr = copy_addr_to_reg (XEXP (dest, 0));\n+  rtx val = force_reg (SImode, operands[2]);\n+  int align = INTVAL (operands[3]);\n+  int count = 0;\n+  rtx len = force_reg (SImode, operands[1]);\n+\n+  if (! CONST_INT_P (operands[1]))\n+    return;\n+\n+  count = INTVAL (operands[1]);\n+\n+  if (CONST_INT_P (operands[2])\n+      && (INTVAL (operands[2]) == 0 || INTVAL (operands[2]) == -1) && count > 8)\n+    {\n+      rtx lenw = gen_reg_rtx (SImode);\n+\n+      if (align < 4)\n+        {\n+          emit_insn (gen_tstsi_t (GEN_INT (3), dest_addr));\n+          jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+          add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+        }\n+\n+      /* word count. Do we have iterations ? */\n+      emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));\n+\n+      dest = adjust_automodify_address (dest, SImode, dest_addr, 0);\n+\n+      /* start loop.  */\n+      emit_label (L_loop_word);\n+\n+      if (TARGET_SH2)\n+        emit_insn (gen_dect (lenw, lenw));\n+      else\n+        {\n+          emit_insn (gen_addsi3 (lenw, lenw, GEN_INT (-1)));\n+          emit_insn (gen_tstsi_t (lenw, lenw));\n+        }\n+\n+      emit_move_insn (dest, val);\n+      emit_move_insn (dest_addr, plus_constant (Pmode, dest_addr,\n+                                                GET_MODE_SIZE (SImode)));\n+\n+\n+      jump = emit_jump_insn (gen_branch_false (L_loop_word));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+      count = count % 4;\n+\n+      dest = adjust_address (dest, QImode, 0);\n+\n+      val = gen_lowpart (QImode, val);\n+\n+      while (count--)\n+        {\n+          emit_move_insn (dest, val);\n+          emit_move_insn (dest_addr, plus_constant (Pmode, dest_addr,\n+                                                    GET_MODE_SIZE (QImode)));\n+        }\n+\n+      jump = emit_jump_insn (gen_jump_compact (L_return));\n+      emit_barrier_after (jump);\n+    }\n+\n+  dest = adjust_automodify_address (dest, QImode, dest_addr, 0);\n+\n+  /* start loop.  */\n+  emit_label (L_loop_byte);\n+\n+  if (TARGET_SH2)\n+    emit_insn (gen_dect (len, len));\n+  else\n+    {\n+      emit_insn (gen_addsi3 (len, len, GEN_INT (-1)));\n+      emit_insn (gen_tstsi_t (len, len));\n+    }\n+\n+  val = gen_lowpart (QImode, val);\n+  emit_move_insn (dest, val);\n+  emit_move_insn (dest_addr, plus_constant (Pmode, dest_addr,\n+                                            GET_MODE_SIZE (QImode)));\n+\n+  jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+\n+  emit_label (L_return);\n+\n+  return;\n+}"}, {"sha": "685cd23207cf119b3c80cbfc70b5edad5e3486c6", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -119,6 +119,7 @@ extern void prepare_move_operands (rtx[], enum machine_mode mode);\n extern bool sh_expand_cmpstr (rtx *);\n extern bool sh_expand_cmpnstr (rtx *);\n extern bool sh_expand_strlen  (rtx *);\n+extern void sh_expand_setmem (rtx *);\n extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,\n \t\t\t\t\t       enum rtx_code comparison);\n extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);"}, {"sha": "8c30e5c14bd3dd1855b30793baa26047df7a0bbd", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -1594,6 +1594,11 @@ struct sh_args {\n \n #define SET_BY_PIECES_P(SIZE, ALIGN) STORE_BY_PIECES_P(SIZE, ALIGN)\n \n+/* If a memory clear move would take CLEAR_RATIO or more simple\n+   move-instruction pairs, we will do a setmem instead.  */\n+\n+#define CLEAR_RATIO(speed) ((speed) ? 15 : 3)\n+\n /* Macros to check register numbers against specific register classes.  */\n \n /* These assume that REGNO is a hard or pseudo reg number."}, {"sha": "9035bfcb1a8c36d1ea6a5f83b179d9ea4cdd5145", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -12089,6 +12089,20 @@ label:\n    FAIL;\n })\n \n+(define_expand \"setmemqi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\")\n+                   (match_operand 2 \"const_int_operand\"))\n+              (use (match_operand:QI 1 \"const_int_operand\"))\n+              (use (match_operand:QI 3 \"const_int_operand\"))])]\n+  \"TARGET_SH1 && optimize\"\n+  {\n+    if (optimize_insn_for_size_p ())\n+       FAIL;\n+\n+    sh_expand_setmem (operands);\n+    DONE;\n+  })\n+\n \f\n ;; -------------------------------------------------------------------------\n ;; Floating point instructions."}, {"sha": "3b85529b8fcb399477b69e4040c7f27bfb7d0ef5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -1,3 +1,7 @@\n+2014-01-20  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc.target/sh/memset.c: New test.\n+\n 2014-04-14  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/55022"}, {"sha": "4695db3aefaf882dcceca7a77efea5d869c9b7d1", "filename": "gcc/testsuite/gcc.target/sh/memset.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1aecc1c218eca8a1b5643e9276bffe485f6e67/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fmemset.c?ref=fa1aecc1c218eca8a1b5643e9276bffe485f6e67", "patch": "@@ -0,0 +1,13 @@\n+/* Check that the __builtin_memset function is inlined when\n+   optimizing for speed.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"jmp\" } } */\n+\n+void\n+test00(char *dstb)\n+{\n+  __builtin_memset (dstb, 0, 15);\n+}\n+"}]}