{"sha": "d4506961cd58fde924aa6561e8896e18161b82ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ1MDY5NjFjZDU4ZmRlOTI0YWE2NTYxZTg4OTZlMTgxNjFiODJhZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-06-28T19:03:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-06-28T19:03:08Z"}, "message": "cppfiles.c (open_include_file): If open(2) returns EMFILE or ENFILE...\n\n\t* cppfiles.c (open_include_file): If open(2) returns EMFILE or\n\tENFILE, close all cached file descriptors and try again.\n\t(_cpp_execute_include): Keep a count of the number of times\n\teach header is included.\n\t(close_cached_fd): New function.\n\t* cpphash.h (struct include_file): Rename before to\n\tinclude_count; all users updated.  Make include_count and sysp\n\tunsigned short.\n\t* cppinit.c (cpp_finish): If -H, report headers that could use\n\treinclude guards.\n\t(report_missing_guard): New function.\n\nFrom-SVN: r34760", "tree": {"sha": "82b11e25ea2057714b83389ff3651dad11f94f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b11e25ea2057714b83389ff3651dad11f94f5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4506961cd58fde924aa6561e8896e18161b82ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4506961cd58fde924aa6561e8896e18161b82ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4506961cd58fde924aa6561e8896e18161b82ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4506961cd58fde924aa6561e8896e18161b82ad/comments", "author": null, "committer": null, "parents": [{"sha": "47ec19c5bb9a7992d1a5f2a561df3b47dd6ea539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ec19c5bb9a7992d1a5f2a561df3b47dd6ea539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ec19c5bb9a7992d1a5f2a561df3b47dd6ea539"}], "stats": {"total": 86, "additions": 81, "deletions": 5}, "files": [{"sha": "dbe08c92841b176695541a15394205602c66a220", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4506961cd58fde924aa6561e8896e18161b82ad", "patch": "@@ -1,3 +1,17 @@\n+2000-06-28  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c (open_include_file): If open(2) returns EMFILE or\n+\tENFILE, close all cached file descriptors and try again.      \n+\t(_cpp_execute_include): Keep a count of the number of times\n+\teach header is included.\n+\t(close_cached_fd): New function.\n+\t* cpphash.h (struct include_file): Rename before to\n+\tinclude_count; all users updated.  Make include_count and sysp\n+\tunsigned short.\n+\t* cppinit.c (cpp_finish): If -H, report headers that could use\n+\treinclude guards.\n+\t(report_missing_guard): New function.\n+\n Wed Jun 28 14:46:58 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (prologue_set_got): Set length_immediate field."}, {"sha": "35d1aa6b0aeec91acaf7d2a792281378b2f5813b", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=d4506961cd58fde924aa6561e8896e18161b82ad", "patch": "@@ -60,6 +60,7 @@ static ssize_t read_with_read\tPARAMS ((cpp_buffer *, int, ssize_t));\n static ssize_t read_file\tPARAMS ((cpp_buffer *, int, ssize_t));\n \n static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n+static int close_cached_fd\tPARAMS ((splay_tree_node, void *));\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n@@ -87,6 +88,20 @@ destroy_include_file_node (v)\n     }\n }\n \n+static int\n+close_cached_fd (n, dummy)\n+     splay_tree_node n;\n+     void *dummy ATTRIBUTE_UNUSED;\n+{\n+  struct include_file *f = (struct include_file *)n->value;\n+  if (f && f->fd != -1)\n+    {\n+      close (f->fd);\n+      f->fd = -1;\n+    }\n+  return 0;\n+}\n+\n void\n _cpp_init_include_table (pfile)\n      cpp_reader *pfile;\n@@ -153,6 +168,8 @@ open_include_file (pfile, filename)\n      ourselves.\n \n      Special case: the empty string is translated to stdin.  */\n+ retry:\n+\n   if (filename[0] == '\\0')\n     fd = 0;\n   else\n@@ -167,6 +184,21 @@ open_include_file (pfile, filename)\n \t\t     filename);\n \t}\n #endif\n+      if (0\n+#ifdef EMFILE\n+\t  || errno == EMFILE\n+#endif\n+#ifdef ENFILE\n+\t  || errno == ENFILE\n+#endif\n+\t  )\n+\t{\n+\t  /* Too many files open.  Close all cached file descriptors and\n+\t     try again.  */\n+\t  splay_tree_foreach (pfile->all_include_files, close_cached_fd, 0);\n+\t  goto retry;\n+\t}\n+\n       /* Nonexistent or inaccessible file.  Create a negative node for it.  */\n       if (nd)\n \t{\n@@ -185,7 +217,7 @@ open_include_file (pfile, filename)\n     {\n       file = xnew (struct include_file);\n       file->cmacro = 0;\n-      file->before = 0;\n+      file->include_count = 0;\n       file->sysp = 0;\n       file->foundhere = 0;\n       file->name = xstrdup (filename);\n@@ -367,9 +399,9 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n \treturn;\n \n       /* For -M, add the file to the dependencies on its first inclusion. */\n-      if (!inc->before && PRINT_THIS_DEP (pfile, angle_brackets))\n+      if (!inc->include_count && PRINT_THIS_DEP (pfile, angle_brackets))\n \tdeps_add_dep (pfile->deps, inc->name);\n-      inc->before = 1;\n+      inc->include_count++;\n \n       /* Handle -H option.  */\n       if (CPP_OPTION (pfile, print_include_names))"}, {"sha": "f3e19d3ecca890c78d49f6df326c33fc1ba75f66", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d4506961cd58fde924aa6561e8896e18161b82ad", "patch": "@@ -62,8 +62,8 @@ struct include_file\n \t\t\t\t/* location in search path where file was\n \t\t\t\t   found, for #include_next */\n   int fd;\t\t\t/* file descriptor possibly open on file */\n-  unsigned char before;\t\t/* file has been included before */\n-  unsigned char sysp;\t\t/* file is a system header */\n+  unsigned short include_count;\t/* number of times file has been read */\n+  unsigned short sysp;\t\t/* file is a system header */\n };\n \n /* The cmacro works like this: If it's NULL, the file is to be"}, {"sha": "0cbccaedbd8ca476c369b944a3f61af486d44762", "filename": "gcc/cppinit.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4506961cd58fde924aa6561e8896e18161b82ad/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=d4506961cd58fde924aa6561e8896e18161b82ad", "patch": "@@ -227,6 +227,7 @@ static int opt_comp\t\t\tPARAMS ((const void *, const void *));\n #endif\n static int parse_option\t\t\tPARAMS ((const char *));\n static int handle_option\t\tPARAMS ((cpp_reader *, int, char **));\n+static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n \n /* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n@@ -1003,6 +1004,27 @@ cpp_start_read (pfile, print, fname)\n   return 1;\n }\n \n+static int\n+report_missing_guard (n, b)\n+     splay_tree_node n;\n+     void *b;\n+{\n+  struct include_file *f = (struct include_file *) n->value;\n+  int *bannerp = (int *)b;\n+\n+  if (f && f->cmacro == 0 && f->include_count == 1)\n+    {\n+      if (*bannerp == 0)\n+\t{\n+\t  fputs (_(\"Multiple include guards may be useful for:\\n\"), stderr);\n+\t  *bannerp = 1;\n+\t}\n+      fputs (f->name, stderr);\n+      putc ('\\n', stderr);\n+    }\n+  return 0;\n+}\n+\n /* This is called at the end of preprocessing.  It pops the\n    last buffer and writes dependency output.  It should also\n    clear macro definitions, such that you could call cpp_start_read\n@@ -1055,6 +1077,14 @@ cpp_finish (pfile, print)\n       if (ferror (print->outf) || fclose (print->outf))\n \tcpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n     }\n+\n+  /* Report on headers that could use multiple include guards.  */\n+  if (CPP_OPTION (pfile, print_include_names))\n+    {\n+      int banner = 0;\n+      splay_tree_foreach (pfile->all_include_files, report_missing_guard,\n+\t\t\t  (void *) &banner);\n+    }\n }\n \n static void"}]}