{"sha": "14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "node_id": "C_kwDOANBUbNoAKDE0ZjVlNTZhOGE3NjZjNmY0OGMyYTA3YjMwMWZjZTJkYjFhMTlhM2M", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-10T16:55:44Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-10T16:55:44Z"}, "message": "analyzer: fix leak false +ve seen in haproxy's cfgparse.c [PR109059]\n\nIf a bound region gets overwritten with UNKNOWN due to being\npossibly-aliased during a write, that could have been the only\nregion keeping its value live, in which case we could falsely report\na leak.  This is hidden somewhat by the \"uncertainty\" mechanism for\ncases where the write happens in the same stmt as the last reference\nto the value goes away, but not in the general case, which occurs\nin PR analyzer/109059, which falsely complains about a leak whilst\nhaproxy updates a doubly-linked list.\n\nThe whole \"uncertainty_t\" class seems broken to me now; I think we need\nto track (in the store) what values could have escaped to the external\npart of the program.  We do this to some extent for pointers by tracking\nthe region as escaped, though we're failing to do this for this case:\neven though there could still be other pointers to the region,\neventually they go away; we want to capture the fact that the external\npart of the state is still keeping it live.  Also, this doesn't work for\nnon-pointer svalues, such as for detecting file-descriptor leaks.\n\nAs both a workaround and a step towards eventually removing\n\"class uncertainty_t\" this patch updates the \"mark_region_as_unknown\"\ncode called by possibly-aliased set_value so that when old values are\nremoved, any base region pointed to them is marked as escaped, fixing\nthe leak false positive.\n\nThe patch has this effect on my integration tests of -fanalyzer:\n\n  Comparison:\n    GOOD: 129        (19.20% -> 20.22%)\n     BAD: 543 -> 509 (-34)\n\nwhere there's a big improvement in -Wanalyzer-malloc-leak:\n\n  -Wanalyzer-malloc-leak:\n    GOOD: 61       (45.19% -> 54.95%)\n     BAD: 74 -> 50 (-24)\n     Known false positives: 25 -> 2 (-23)\n       haproxy-2.7.1: 24 ->  1 (-23)\n     Suspected false positives: 49 -> 48 (-1)\n       coreutils-9.1: 32 -> 31 (-1)\n\nand some churn in the other warnings:\n\n  -Wanalyzer-use-of-uninitialized-value:\n     GOOD: 0\n      BAD: 81 -> 80 (-1)\n  -Wanalyzer-file-leak:\n     GOOD: 0\n      BAD: 10 -> 11 (+1)\n  -Wanalyzer-out-of-bounds:\n     GOOD: 0\n      BAD: 24 -> 22 (-2)\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/109059\n\t* region-model.cc (region_model::mark_region_as_unknown): Gather a\n\tset of maybe-live svalues and call on_maybe_live_values with it.\n\t* store.cc (binding_map::remove_overlapping_bindings): Add new\n\t\"maybe_live_values\" param; add any removed svalues to it.\n\t(binding_cluster::clobber_region): Add NULL as new param of\n\tremove_overlapping_bindings.\n\t(binding_cluster::mark_region_as_unknown): Add \"maybe_live_values\"\n\tparam and pass it to remove_overlapping_bindings.\n\t(binding_cluster::maybe_get_compound_binding): Add NULL for new\n\tparam of binding_map::remove_overlapping_bindings.\n\t(binding_cluster::remove_overlapping_bindings): Add\n\t\"maybe_live_values\" param and pass to\n\tbinding_map::remove_overlapping_bindings.\n\t(store::set_value): Capture a set of maybe-live svalues, and call\n\ton_maybe_live_values with it.\n\t(store::on_maybe_live_values): New.\n\t(store::mark_region_as_unknown): Add \"maybe_live_values\" param\n\tand pass it to binding_cluster::mark_region_as_unknown.\n\t(store::remove_overlapping_bindings): Pass NULL for new param of\n\tbinding_cluster::remove_overlapping_bindings.\n\t* store.h (binding_map::remove_overlapping_bindings): Add\n\t\"maybe_live_values\" param.\n\t(binding_cluster::mark_region_as_unknown): Likewise.\n\t(binding_cluster::remove_overlapping_bindings): Likewise.\n\t(store::mark_region_as_unknown): Likewise.\n\t(store::on_maybe_live_values): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/109059\n\t* gcc.dg/analyzer/flex-with-call-summaries.c: Remove xfail.\n\t* gcc.dg/analyzer/leak-pr109059-1.c: New test.\n\t* gcc.dg/analyzer/leak-pr109059-2.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "849a273f33dcfe0ece6f2d4ab737ae03b8cc656a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/849a273f33dcfe0ece6f2d4ab737ae03b8cc656a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b2340e236c0bba8aaca358ea25a5accd8249fbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2340e236c0bba8aaca358ea25a5accd8249fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b2340e236c0bba8aaca358ea25a5accd8249fbd"}], "stats": {"total": 176, "additions": 158, "deletions": 18}, "files": [{"sha": "56beaa82f959c2c5695502386f7795620e043b13", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "patch": "@@ -3296,8 +3296,10 @@ void\n region_model::mark_region_as_unknown (const region *reg,\n \t\t\t\t      uncertainty_t *uncertainty)\n {\n+  svalue_set maybe_live_values;\n   m_store.mark_region_as_unknown (m_mgr->get_store_manager(), reg,\n-\t\t\t\t  uncertainty);\n+\t\t\t\t  uncertainty, &maybe_live_values);\n+  m_store.on_maybe_live_values (maybe_live_values);\n }\n \n /* Determine what is known about the condition \"LHS_SVAL OP RHS_SVAL\" within"}, {"sha": "e8c927b9fe9bc40b7c2c8dad04e0a458df8eaeea", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "patch": "@@ -1078,6 +1078,9 @@ binding_map::get_overlapping_bindings (const binding_key *key,\n    If UNCERTAINTY is non-NULL, use it to record any svalues that\n    were removed, as being maybe-bound.\n \n+   If MAYBE_LIVE_VALUES is non-NULL, then use it to record any svalues that\n+   were removed as being maybe-live.\n+\n    If ALWAYS_OVERLAP, then assume that DROP_KEY can overlap anything\n    in the map, due to one or both of the underlying clusters being\n    symbolic (but not the same symbolic region).  Hence even if DROP_KEY is a\n@@ -1089,6 +1092,7 @@ void\n binding_map::remove_overlapping_bindings (store_manager *mgr,\n \t\t\t\t\t  const binding_key *drop_key,\n \t\t\t\t\t  uncertainty_t *uncertainty,\n+\t\t\t\t\t  svalue_set *maybe_live_values,\n \t\t\t\t\t  bool always_overlap)\n {\n   /* Get the bindings of interest within this map.  */\n@@ -1123,6 +1127,11 @@ binding_map::remove_overlapping_bindings (store_manager *mgr,\n \t      || always_overlap))\n \tuncertainty->on_maybe_bound_sval (old_sval);\n \n+      /* Record any svalues that were removed to *MAYBE_LIVE_VALUES as being\n+\t maybe-live. */\n+      if (maybe_live_values)\n+\tmaybe_live_values->add (old_sval);\n+\n       /* Begin by removing the old binding. */\n       m_map.remove (iter_binding);\n \n@@ -1416,7 +1425,7 @@ binding_cluster::bind_compound_sval (store_manager *mgr,\n void\n binding_cluster::clobber_region (store_manager *mgr, const region *reg)\n {\n-  remove_overlapping_bindings (mgr, reg, NULL);\n+  remove_overlapping_bindings (mgr, reg, NULL, NULL);\n }\n \n /* Remove any bindings for REG within this cluster.  */\n@@ -1464,6 +1473,8 @@ binding_cluster::zero_fill_region (store_manager *mgr, const region *reg)\n    Remove any bindings overlapping REG_FOR_OVERLAP.\n    If UNCERTAINTY is non-NULL, use it to record any svalues that\n    had bindings to them removed, as being maybe-bound.\n+   If MAYBE_LIVE_VALUES is non-NULL, use it to record any svalues that\n+   had bindings to them removed, as being maybe-live.\n \n    REG_TO_BIND and REG_FOR_OVERLAP are the same for\n    store::mark_region_as_unknown, but are different in\n@@ -1474,12 +1485,14 @@ void\n binding_cluster::mark_region_as_unknown (store_manager *mgr,\n \t\t\t\t\t const region *reg_to_bind,\n \t\t\t\t\t const region *reg_for_overlap,\n-\t\t\t\t\t uncertainty_t *uncertainty)\n+\t\t\t\t\t uncertainty_t *uncertainty,\n+\t\t\t\t\t svalue_set *maybe_live_values)\n {\n   if (reg_to_bind->empty_p ())\n     return;\n \n-  remove_overlapping_bindings (mgr, reg_for_overlap, uncertainty);\n+  remove_overlapping_bindings (mgr, reg_for_overlap, uncertainty,\n+\t\t\t       maybe_live_values);\n \n   /* Add a default binding to \"unknown\".  */\n   region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n@@ -1748,7 +1761,7 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n \t\t it overlaps with offset_concrete_key.  */\n \t      default_map.remove_overlapping_bindings (mgr,\n \t\t\t\t\t\t       offset_concrete_key,\n-\t\t\t\t\t\t       NULL, false);\n+\t\t\t\t\t\t       NULL, NULL, false);\n \t    }\n \t  else if (bound_range.contains_p (reg_range, &subrange))\n \t    {\n@@ -1782,7 +1795,7 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n \t\t it overlaps with overlap_concrete_key.  */\n \t      default_map.remove_overlapping_bindings (mgr,\n \t\t\t\t\t\t       overlap_concrete_key,\n-\t\t\t\t\t\t       NULL, false);\n+\t\t\t\t\t\t       NULL, NULL, false);\n \t    }\n \t}\n       else\n@@ -1813,12 +1826,16 @@ binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n    in the map.\n \n    If UNCERTAINTY is non-NULL, use it to record any svalues that\n-   were removed, as being maybe-bound.  */\n+   were removed, as being maybe-bound.\n+\n+   If MAYBE_LIVE_VALUES is non-NULL, use it to record any svalues that\n+   were removed, as being maybe-live.  */\n \n void\n binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n \t\t\t\t\t      const region *reg,\n-\t\t\t\t\t      uncertainty_t *uncertainty)\n+\t\t\t\t\t      uncertainty_t *uncertainty,\n+\t\t\t\t\t      svalue_set *maybe_live_values)\n {\n   if (reg->empty_p ())\n     return;\n@@ -1836,6 +1853,7 @@ binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n \t\t\t && (cluster_base_reg->get_kind () == RK_SYMBOLIC\n \t\t\t     || other_base_reg->get_kind () == RK_SYMBOLIC));\n   m_map.remove_overlapping_bindings (mgr, reg_binding, uncertainty,\n+\t\t\t\t     maybe_live_values,\n \t\t\t\t     always_overlap);\n }\n \n@@ -2600,7 +2618,10 @@ store::set_value (store_manager *mgr, const region *lhs_reg,\n      Writes to symbolic clusters can affect both concrete and symbolic\n      clusters.\n      Invalidate our knowledge of other clusters that might have been\n-     affected by the write.  */\n+     affected by the write.\n+     Gather the set of all svalues that might still be live even if\n+     the store doesn't refer to them.  */\n+  svalue_set maybe_live_values;\n   for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n        iter != m_cluster_map.end (); ++iter)\n     {\n@@ -2637,7 +2658,8 @@ store::set_value (store_manager *mgr, const region *lhs_reg,\n \t\t(mgr,\n \t\t iter_base_reg, /* reg_to_bind */\n \t\t lhs_reg, /* reg_for_overlap */\n-\t\t uncertainty);\n+\t\t uncertainty,\n+\t\t &maybe_live_values);\n \t      break;\n \n \t    case tristate::TS_TRUE:\n@@ -2651,6 +2673,11 @@ store::set_value (store_manager *mgr, const region *lhs_reg,\n \t    }\n \t}\n     }\n+  /* Given the set of svalues that might still be live, process them\n+     (e.g. marking regions as escaped).\n+     We do this after the iteration to avoid potentially changing\n+     m_cluster_map whilst iterating over it.  */\n+  on_maybe_live_values (maybe_live_values);\n }\n \n /* Determine if BASE_REG_A could be an alias of BASE_REG_B.  */\n@@ -2731,6 +2758,21 @@ store::eval_alias_1 (const region *base_reg_a,\n   return tristate::TS_UNKNOWN;\n }\n \n+/* Record all of the values in MAYBE_LIVE_VALUES as being possibly live.  */\n+\n+void\n+store::on_maybe_live_values (const svalue_set &maybe_live_values)\n+{\n+  for (auto sval : maybe_live_values)\n+    {\n+      if (const region_svalue *ptr_sval = sval->dyn_cast_region_svalue ())\n+\t{\n+\t  const region *base_reg = ptr_sval->get_pointee ()->get_base_region ();\n+\t  mark_as_escaped (base_reg);\n+\t}\n+    }\n+}\n+\n /* Remove all bindings overlapping REG within this store.  */\n \n void\n@@ -2798,14 +2840,16 @@ store::zero_fill_region (store_manager *mgr, const region *reg)\n \n void\n store::mark_region_as_unknown (store_manager *mgr, const region *reg,\n-\t\t\t       uncertainty_t *uncertainty)\n+\t\t\t       uncertainty_t *uncertainty,\n+\t\t\t       svalue_set *maybe_live_values)\n {\n   const region *base_reg = reg->get_base_region ();\n   if (base_reg->symbolic_for_unknown_ptr_p ()\n       || !base_reg->tracked_p ())\n     return;\n   binding_cluster *cluster = get_or_create_cluster (base_reg);\n-  cluster->mark_region_as_unknown (mgr, reg, reg, uncertainty);\n+  cluster->mark_region_as_unknown (mgr, reg, reg, uncertainty,\n+\t\t\t\t   maybe_live_values);\n }\n \n /* Purge state involving SVAL.  */\n@@ -3052,7 +3096,9 @@ store::remove_overlapping_bindings (store_manager *mgr, const region *reg,\n \t  delete cluster;\n \t  return;\n \t}\n-      cluster->remove_overlapping_bindings (mgr, reg, uncertainty);\n+      /* Pass NULL for the maybe_live_values here, as we don't want to\n+\t record the old svalues as being maybe-bound.  */\n+      cluster->remove_overlapping_bindings (mgr, reg, uncertainty, NULL);\n     }\n }\n "}, {"sha": "7ded650b60885e11f44762722866b03b9a8130b4", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "patch": "@@ -541,6 +541,7 @@ class binding_map\n   void remove_overlapping_bindings (store_manager *mgr,\n \t\t\t\t    const binding_key *drop_key,\n \t\t\t\t    uncertainty_t *uncertainty,\n+\t\t\t\t    svalue_set *maybe_live_values,\n \t\t\t\t    bool always_overlap);\n \n private:\n@@ -607,7 +608,8 @@ class binding_cluster\n   void mark_region_as_unknown (store_manager *mgr,\n \t\t\t       const region *reg_to_bind,\n \t\t\t       const region *reg_for_overlap,\n-\t\t\t       uncertainty_t *uncertainty);\n+\t\t\t       uncertainty_t *uncertainty,\n+\t\t\t       svalue_set *maybe_live_values);\n   void purge_state_involving (const svalue *sval,\n \t\t\t      region_model_manager *sval_mgr);\n \n@@ -620,7 +622,8 @@ class binding_cluster\n \t\t\t\t\t     const region *reg) const;\n \n   void remove_overlapping_bindings (store_manager *mgr, const region *reg,\n-\t\t\t\t    uncertainty_t *uncertainty);\n+\t\t\t\t    uncertainty_t *uncertainty,\n+\t\t\t\t    svalue_set *maybe_live_values);\n \n   template <typename T>\n   void for_each_value (void (*cb) (const svalue *sval, T user_data),\n@@ -746,7 +749,8 @@ class store\n   void fill_region (store_manager *mgr, const region *reg, const svalue *sval);\n   void zero_fill_region (store_manager *mgr, const region *reg);\n   void mark_region_as_unknown (store_manager *mgr, const region *reg,\n-\t\t\t       uncertainty_t *uncertainty);\n+\t\t\t       uncertainty_t *uncertainty,\n+\t\t\t       svalue_set *maybe_live_values);\n   void purge_state_involving (const svalue *sval,\n \t\t\t      region_model_manager *sval_mgr);\n \n@@ -801,6 +805,7 @@ class store\n   void replay_call_summary_cluster (call_summary_replay &r,\n \t\t\t\t    const store &summary,\n \t\t\t\t    const region *base_reg);\n+  void on_maybe_live_values (const svalue_set &maybe_live_values);\n \n private:\n   void remove_overlapping_bindings (store_manager *mgr, const region *reg,"}, {"sha": "79f2f8e1879ec2d4bbb5f786650951dc72f6b5a1", "filename": "gcc/testsuite/gcc.dg/analyzer/flex-with-call-summaries.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-with-call-summaries.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-with-call-summaries.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-with-call-summaries.c?ref=14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "patch": "@@ -1469,8 +1469,7 @@ YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )\n \t */\n \tb->yy_is_our_buffer = 1;\n \n-\treturn b;  /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n-\t/* TODO: leak false positive: PR analyzer/103546.  */\n+\treturn b;  /* { dg-bogus \"leak\" } */\n }\n \n #ifndef YY_EXIT_FAILURE"}, {"sha": "033ab79460e6d7da82ad64dfa88e79b311231e9b", "filename": "gcc/testsuite/gcc.dg/analyzer/leak-pr109059-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr109059-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr109059-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr109059-1.c?ref=14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "patch": "@@ -0,0 +1,46 @@\n+/* Reduced from haproxy-2.7.1's cfgparse.c.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void*\n+calloc(size_t __nmemb, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__malloc__)) __attribute__((__alloc_size__(1, 2)));\n+\n+struct list\n+{\n+  struct list* n;\n+  struct list* p;\n+};\n+\n+struct cfg_postparser\n+{\n+  struct list list;\n+  char* name;\n+  int (*func)();\n+};\n+\n+extern struct list postparsers;\n+\n+int\n+cfg_register_postparser(char* name, int (*func)())\n+{\n+  struct cfg_postparser* cp;\n+\n+  cp = calloc(1, sizeof(*cp));\n+  if (!cp) {\n+    /* [...snip...] */\n+    return 0;\n+  }\n+  cp->name = name;\n+  cp->func = func;\n+\n+  ({\n+    (&cp->list)->p = (&postparsers)->p;\n+    (&cp->list)->p->n = (&postparsers)->p = (&cp->list);\n+    (&cp->list)->n = (&postparsers);\n+    (&cp->list);\n+  });\n+\n+  return 1; /* { dg-bogus \"leak of 'cp'\" } */\n+}"}, {"sha": "125bce84864f97142a51d37cbebe252586d64a5b", "filename": "gcc/testsuite/gcc.dg/analyzer/leak-pr109059-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr109059-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr109059-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-pr109059-2.c?ref=14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "patch": "@@ -0,0 +1,42 @@\n+/* Reduced from haproxy-2.7.1's cfgparse.c.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void*\n+calloc(size_t __nmemb, size_t __size)\n+  __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__malloc__)) __attribute__((__alloc_size__(1, 2)));\n+\n+struct list\n+{\n+  struct list* n;\n+  struct list* p;\n+};\n+\n+struct cfg_postparser\n+{\n+  struct list list;\n+  char* name;\n+};\n+\n+extern struct list postparsers;\n+\n+int\n+test_1 (char* name)\n+{\n+  struct cfg_postparser* cp;\n+\n+  cp = calloc(1, sizeof(*cp));\n+  if (!cp) {\n+    /* [...snip...] */\n+    return 0;\n+  }\n+  cp->name = name;\n+\n+  (&cp->list)->p = (&postparsers)->p;\n+  (&postparsers)->p = (&cp->list);\n+  (&cp->list)->p->n = (&postparsers)->p;\n+  (&cp->list)->n = (&postparsers);\n+\n+  return 1; /* { dg-bogus \"leak of 'cp'\" } */\n+}"}]}