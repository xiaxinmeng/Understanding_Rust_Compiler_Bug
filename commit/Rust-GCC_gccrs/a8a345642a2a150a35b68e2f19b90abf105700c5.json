{"sha": "a8a345642a2a150a35b68e2f19b90abf105700c5", "node_id": "C_kwDOANBUbNoAKGE4YTM0NTY0MmEyYTE1MGEzNWI2OGUyZjE5YjkwYWJmMTA1NzAwYzU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-16T15:23:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-16T15:23:39Z"}, "message": "Merge #839\n\n839: Add typechecking for match-expr r=philberty a=philberty\n\nThis adds in the type checking pass for the match expression including static\r\nanalysis for errors such as:\r\n\r\n - error[E0532]: expected tuple struct or tuple variant, found struct variant `Foo::D`\r\n - error[E0027]: pattern does not mention fields `x`, `y`\r\n - error[E0026]: variant `Foo::D` does not have a field named `b`\r\n - error[E0532]: expected tuple struct or tuple variant, found struct variant `Foo::D`\r\n\r\nAddresses #190 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "cab130a5d112eac9d1490a98139831cfd8f3a717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cab130a5d112eac9d1490a98139831cfd8f3a717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8a345642a2a150a35b68e2f19b90abf105700c5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhu1n7CRBK7hj4Ov3rIwAARowIADt/dureHS6QhcAfQyw+G03t\ntN0qYtCxwYNJW0KXtLbLEht/t/jo8hEZ0G9J9JKmad/y5zHDJbf9Soh8K1Jy+gpC\nBMtCB8vIwlhIKePucIg7zul/iku5mYSePZxbRBcZ0yTDN31vCZMzx7aTcNRKqpUu\n5+gLFJTHjmx5z6YnmYcEeTFgshKbDC8DprCRTKWX1I9uWovWcmTFb4dzuiy2AXIK\nmxYq/w0ksgvcj8L8Txx2j5xwdepdDFwqcGImrQjbQLVmHlg+rt/MCRP8Dp7GArKo\nU+/pUtSouJr+DxNZuQNTiWUdVuOTrd8yHqN52TOORYn79k1ejl5+2yApTrynk6E=\n=ROPs\n-----END PGP SIGNATURE-----\n", "payload": "tree cab130a5d112eac9d1490a98139831cfd8f3a717\nparent e8d91e9e0825b4d1a4e46531142fdc0c83c761db\nparent 45edfc2b265cffab529d2cd70b37af559bd02c21\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639668219 +0000\ncommitter GitHub <noreply@github.com> 1639668219 +0000\n\nMerge #839\n\n839: Add typechecking for match-expr r=philberty a=philberty\n\nThis adds in the type checking pass for the match expression including static\r\nanalysis for errors such as:\r\n\r\n - error[E0532]: expected tuple struct or tuple variant, found struct variant `Foo::D`\r\n - error[E0027]: pattern does not mention fields `x`, `y`\r\n - error[E0026]: variant `Foo::D` does not have a field named `b`\r\n - error[E0532]: expected tuple struct or tuple variant, found struct variant `Foo::D`\r\n\r\nAddresses #190 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a345642a2a150a35b68e2f19b90abf105700c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8a345642a2a150a35b68e2f19b90abf105700c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a345642a2a150a35b68e2f19b90abf105700c5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d91e9e0825b4d1a4e46531142fdc0c83c761db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8d91e9e0825b4d1a4e46531142fdc0c83c761db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8d91e9e0825b4d1a4e46531142fdc0c83c761db"}, {"sha": "45edfc2b265cffab529d2cd70b37af559bd02c21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45edfc2b265cffab529d2cd70b37af559bd02c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45edfc2b265cffab529d2cd70b37af559bd02c21"}], "stats": {"total": 486, "additions": 474, "deletions": 12}, "files": [{"sha": "391151f1af08f8d21fd8e155396bbf32e357d837", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -89,6 +89,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-address-taken.o \\\n+    rust/rust-hir-type-check-pattern.o \\\n     rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\"}, {"sha": "e50e210b617d3cea64814fe845c905645336bed0", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -3614,15 +3614,9 @@ struct MatchArm\n {\n private:\n   AST::AttrVec outer_attrs;\n-  // MatchArmPatterns patterns;\n-  std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n-\n-  // bool has_match_arm_guard;\n-  // inlined from MatchArmGuard\n+  std::vector<std::unique_ptr<Pattern> > match_arm_patterns;\n   std::unique_ptr<Expr> guard_expr;\n \n-  // TODO: should this store location data?\n-\n public:\n   // Returns whether the MatchArm has a match arm guard expression\n   bool has_match_arm_guard () const { return guard_expr != nullptr; }\n@@ -3679,6 +3673,11 @@ struct MatchArm\n   }\n \n   std::string as_string () const;\n+\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns ()\n+  {\n+    return match_arm_patterns;\n+  }\n };\n \n /* A \"match case\" - a correlated match arm and resulting expression. Not\n@@ -3718,6 +3717,9 @@ struct MatchCase\n   std::string as_string () const;\n \n   Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  MatchArm &get_arm () { return arm; }\n+  std::unique_ptr<Expr> &get_expr () { return expr; }\n };\n \n #if 0\n@@ -3868,6 +3870,15 @@ class MatchExpr : public ExprWithBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_scrutinee_expr ()\n+  {\n+    rust_assert (branch_value != nullptr);\n+    return branch_value;\n+  }\n+\n+  const std::vector<MatchCase> &get_match_cases () const { return match_arms; }\n+  std::vector<MatchCase> &get_match_cases () { return match_arms; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "f3555413439b5aac006fabafdbafb2512a34e263", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -49,7 +49,7 @@ PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n \tfor (auto &inner_pattern : items_no_range.get_patterns ())\n \t  {\n \t    PatternDeclaration::go (inner_pattern.get (),\n-\t\t\t\t    pattern.get_node_id ());\n+\t\t\t\t    inner_pattern->get_pattern_node_id ());\n \t  }\n       }\n       break;\n@@ -85,10 +85,10 @@ PatternDeclaration::visit (AST::StructPattern &pattern)\n \t    resolver->get_name_scope ().insert (\n \t      CanonicalPath::new_seg (ident.get_node_id (),\n \t\t\t\t      ident.get_identifier ()),\n-\t      ident.get_node_id (), pattern.get_locus ());\n-\t    resolver->insert_new_definition (\n-\t      ident.get_node_id (),\n-\t      Definition{ident.get_node_id (), pattern.get_node_id ()});\n+\t      ident.get_node_id (), ident.get_locus ());\n+\t    resolver->insert_new_definition (ident.get_node_id (),\n+\t\t\t\t\t     Definition{ident.get_node_id (),\n+\t\t\t\t\t\t\tident.get_node_id ()});\n \t    resolver->mark_decl_mutability (ident.get_node_id (),\n \t\t\t\t\t    ident.is_mut ());\n \t  }"}, {"sha": "8de736db542a8cb2f0332cc59c78ce08abb72757", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -32,6 +32,7 @@\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n #include \"rust-hir-address-taken.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -51,6 +52,9 @@ class TypeCheckExpr : public TypeCheckBase\n \n     if (resolver.infered == nullptr)\n       {\n+\t// FIXME\n+\t// this is an internal error message for debugging and should be removed\n+\t// at some point\n \trust_error_at (expr->get_locus (), \"failed to type resolve expression\");\n \treturn new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n       }\n@@ -540,6 +544,8 @@ class TypeCheckExpr : public TypeCheckBase\n \tDefinition def;\n \tif (!resolver->lookup_definition (ref_node_id, &def))\n \t  {\n+\t    // FIXME\n+\t    // this is an internal error\n \t    rust_error_at (expr.get_locus (),\n \t\t\t   \"unknown reference for resolved name\");\n \t    return;\n@@ -548,6 +554,8 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n     else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n       {\n+\t// FIXME\n+\t// this is an internal error\n \trust_error_at (expr.get_locus (),\n \t\t       \"Failed to lookup type reference for node: %s\",\n \t\t       expr.as_string ().c_str ());\n@@ -556,6 +564,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n     if (ref_node_id == UNKNOWN_NODEID)\n       {\n+\t// FIXME\n+\t// this is an internal error\n \trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n@@ -566,6 +576,8 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref_node_id, &ref))\n       {\n+\t// FIXME\n+\t// this is an internal error\n \trust_error_at (expr.get_locus (), \"123 reverse lookup failure\");\n \treturn;\n       }\n@@ -574,6 +586,8 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::BaseType *lookup;\n     if (!context->lookup_type (ref, &lookup))\n       {\n+\t// FIXME\n+\t// this is an internal error\n \trust_error_at (mappings->lookup_location (ref),\n \t\t       \"Failed to resolve IdentifierExpr type: %s\",\n \t\t       expr.as_string ().c_str ());\n@@ -1265,6 +1279,50 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = expr_to_convert->cast (tyty_to_convert_to);\n   }\n \n+  void visit (HIR::MatchExpr &expr) override\n+  {\n+    // this needs to perform a least upper bound coercion on the blocks and then\n+    // unify the scruintee and arms\n+    TyTy::BaseType *scrutinee_tyty\n+      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get (), false);\n+\n+    std::vector<TyTy::BaseType *> kase_block_tys;\n+    for (auto &kase : expr.get_match_cases ())\n+      {\n+\t// lets check the arms\n+\tHIR::MatchArm &kase_arm = kase.get_arm ();\n+\tfor (auto &pattern : kase_arm.get_patterns ())\n+\t  {\n+\t    TyTy::BaseType *kase_arm_ty\n+\t      = TypeCheckPattern::Resolve (pattern.get ());\n+\n+\t    TyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n+\t    if (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+\n+\t// check the kase type\n+\tTyTy::BaseType *kase_block_ty\n+\t  = TypeCheckExpr::Resolve (kase.get_expr ().get (), false);\n+\tkase_block_tys.push_back (kase_block_ty);\n+      }\n+\n+    if (kase_block_tys.size () == 0)\n+      {\n+\tinfered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+\treturn;\n+      }\n+\n+    infered = kase_block_tys.at (0);\n+    for (size_t i = 1; i < kase_block_tys.size (); i++)\n+      {\n+\tTyTy::BaseType *kase_ty = kase_block_tys.at (i);\n+\tinfered = infered->unify (kase_ty);\n+\tif (infered->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+  }\n+\n protected:\n   bool\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,"}, {"sha": "2b939585b828aa04c953c55945df0dbfe8b7e0df", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,223 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckPattern::visit (HIR::PathInExpression &pattern)\n+{\n+  infered = TypeCheckExpr::Resolve (&pattern, false);\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::TupleStructPattern &pattern)\n+{\n+  infered = TypeCheckExpr::Resolve (&pattern.get_path (), false);\n+  if (infered->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  rust_assert (infered->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (infered);\n+  rust_assert (adt->is_enum ());\n+\n+  // what variant is this?\n+  HirId variant_id;\n+  bool ok = context->lookup_variant_definition (\n+    pattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+  rust_assert (ok);\n+\n+  TyTy::VariantDef *variant = nullptr;\n+  ok = adt->lookup_variant_by_id (variant_id, &variant);\n+  rust_assert (ok);\n+\n+  // error[E0532]: expected tuple struct or tuple variant, found struct variant\n+  // `Foo::D`\n+  if (variant->get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n+    {\n+      std::string variant_type\n+\t= TyTy::VariantDef::variant_type_string (variant->get_variant_type ());\n+\n+      rust_error_at (\n+\tpattern.get_locus (),\n+\t\"expected tuple struct or tuple variant, found %s variant %s::%s\",\n+\tvariant_type.c_str (), adt->get_name ().c_str (),\n+\tvariant->get_identifier ().c_str ());\n+      return;\n+    }\n+\n+  // check the elements\n+  // error[E0023]: this pattern has 2 fields, but the corresponding tuple\n+  // variant has 1 field\n+  // error[E0023]: this pattern has 0 fields, but the corresponding tuple\n+  // variant has 1 field\n+\n+  std::unique_ptr<HIR::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case HIR::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case HIR::TupleStructItems::NO_RANGE: {\n+\tHIR::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<HIR::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tif (items_no_range.get_patterns ().size () != variant->num_fields ())\n+\t  {\n+\t    rust_error_at (pattern.get_locus (),\n+\t\t\t   \"this pattern has %lu fields but the corresponding \"\n+\t\t\t   \"tuple variant has %lu field\",\n+\t\t\t   items_no_range.get_patterns ().size (),\n+\t\t\t   variant->num_fields ());\n+\t    // we continue on to try and setup the types as best we can for\n+\t    // type checking\n+\t  }\n+\n+\t// iterate the fields and set them up, I wish we had ZIP\n+\tsize_t i = 0;\n+\tfor (auto &pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    if (i >= variant->num_fields ())\n+\t      break;\n+\n+\t    TyTy::StructFieldType *field = variant->get_field_at_index (i++);\n+\t    TyTy::BaseType *fty = field->get_field_type ();\n+\n+\t    // setup the type on this pattern type\n+\t    context->insert_type (pattern->get_pattern_mappings (), fty);\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::StructPattern &pattern)\n+{\n+  infered = TypeCheckExpr::Resolve (&pattern.get_path (), false);\n+  if (infered->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  rust_assert (infered->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (infered);\n+  rust_assert (adt->is_enum ());\n+\n+  // what variant is this?\n+  HirId variant_id;\n+  bool ok = context->lookup_variant_definition (\n+    pattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+  rust_assert (ok);\n+\n+  TyTy::VariantDef *variant = nullptr;\n+  ok = adt->lookup_variant_by_id (variant_id, &variant);\n+  rust_assert (ok);\n+\n+  // error[E0532]: expected tuple struct or tuple variant, found struct variant\n+  // `Foo::D`\n+  if (variant->get_variant_type () != TyTy::VariantDef::VariantType::STRUCT)\n+    {\n+      std::string variant_type\n+\t= TyTy::VariantDef::variant_type_string (variant->get_variant_type ());\n+      rust_error_at (pattern.get_locus (),\n+\t\t     \"expected struct variant, found %s variant %s\",\n+\t\t     variant_type.c_str (),\n+\t\t     variant->get_identifier ().c_str ());\n+      return;\n+    }\n+\n+  // check the elements\n+  // error[E0027]: pattern does not mention fields `x`, `y`\n+  // error[E0026]: variant `Foo::D` does not have a field named `b`\n+\n+  std::vector<std::string> named_fields;\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case HIR::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT: {\n+\t    HIR::StructPatternFieldIdent &ident\n+\t      = static_cast<HIR::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    TyTy::StructFieldType *field = nullptr;\n+\t    if (!variant->lookup_field (ident.get_identifier (), &field,\n+\t\t\t\t\tnullptr))\n+\t      {\n+\t\trust_error_at (ident.get_locus (),\n+\t\t\t       \"variant %s does not have a field named %s\",\n+\t\t\t       variant->get_identifier ().c_str (),\n+\t\t\t       ident.get_identifier ().c_str ());\n+\t\tbreak;\n+\t      }\n+\t    named_fields.push_back (ident.get_identifier ());\n+\n+\t    // setup the type on this pattern\n+\t    TyTy::BaseType *fty = field->get_field_type ();\n+\t    context->insert_type (ident.get_mappings (), fty);\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  if (named_fields.size () != variant->num_fields ())\n+    {\n+      std::map<std::string, bool> missing_names;\n+\n+      // populate with all fields\n+      for (auto &field : variant->get_fields ())\n+\tmissing_names[field->get_name ()] = true;\n+\n+      // then eliminate with named_fields\n+      for (auto &named : named_fields)\n+\tmissing_names.erase (named);\n+\n+      // then get the list of missing names\n+      size_t i = 0;\n+      std::string missing_fields_str;\n+      for (auto it = missing_names.begin (); it != missing_names.end (); it++)\n+\t{\n+\t  bool has_next = (i + 1) < missing_names.size ();\n+\t  missing_fields_str += it->first + (has_next ? \", \" : \"\");\n+\t  i++;\n+\t}\n+\n+      rust_error_at (pattern.get_locus (), \"pattern does not mention fields %s\",\n+\t\t     missing_fields_str.c_str ());\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "ac348fb129711197b6358b06ab447c22206fe421", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,60 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_PATTERN\n+#define RUST_HIR_TYPE_CHECK_PATTERN\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckPattern : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static TyTy::BaseType *Resolve (HIR::Pattern *pattern)\n+  {\n+    TypeCheckPattern resolver;\n+    pattern->accept_vis (resolver);\n+\n+    // FIXME need to check how we do mappings here\n+    if (resolver.infered == nullptr)\n+      return new TyTy::ErrorType (1);\n+\n+    return resolver.infered;\n+  }\n+\n+  void visit (HIR::PathInExpression &pattern) override;\n+\n+  void visit (HIR::StructPattern &pattern) override;\n+\n+  void visit (HIR::TupleStructPattern &pattern) override;\n+\n+private:\n+  TypeCheckPattern () : TypeCheckBase (), infered (nullptr) {}\n+\n+  TyTy::BaseType *infered;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_PATTERN"}, {"sha": "012e8464ee283dbfd54155c53f00f6eb4f90d1a0", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -1018,6 +1018,21 @@ class VariantDef\n     STRUCT\n   };\n \n+  static std::string variant_type_string (VariantType type)\n+  {\n+    switch (type)\n+      {\n+      case NUM:\n+\treturn \"enumeral\";\n+      case TUPLE:\n+\treturn \"tuple\";\n+      case STRUCT:\n+\treturn \"struct\";\n+      }\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n+\n   VariantDef (HirId id, std::string identifier, int discriminant)\n     : id (id), identifier (identifier), discriminant (discriminant)\n   {"}, {"sha": "f649f3a19313175622f672e262cd6370d1936cf9", "filename": "gcc/testsuite/rust/compile/match1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch1.rs?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,16 @@\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => {}\n+        Foo::B => {}\n+        Foo::C(a, b) => {}\n+        // { dg-error \"this pattern has 2 fields but the corresponding tuple variant has 1 field\" \"\" { target *-*-* } .-1 }\n+        Foo::D { x, y } => {}\n+    }\n+}"}, {"sha": "359936a187cdc82e22c7c8b01b773e25122094c0", "filename": "gcc/testsuite/rust/compile/match2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch2.rs?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,15 @@\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => {}\n+        Foo::B => {}\n+        Foo::C(x) => {}\n+        Foo::D { y } => {} // { dg-error \"pattern does not mention fields x\" }\n+    }\n+}"}, {"sha": "98181e85197c99d011dba37355dceadc89cd29fe", "filename": "gcc/testsuite/rust/compile/match3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch3.rs?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,16 @@\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => {}\n+        Foo::B => {}\n+        Foo::C(x) => {}\n+        Foo::D { z } => {} // { dg-error \"variant D does not have a field named z\" }\n+                           // { dg-error \"pattern does not mention fields x, y\" \"\" { target *-*-* } .-1 }\n+    }\n+}"}, {"sha": "35b90a64fa5f9933b445cc79dc9daaf3d1334aa4", "filename": "gcc/testsuite/rust/compile/match4.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch4.rs?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,16 @@\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => {}\n+        Foo::B => {}\n+        Foo::C { a } => {}\n+        // { dg-error \"expected struct variant, found tuple variant C\" \"\" { target *-*-* } .-1 }\n+        Foo::D { x, y } => {}\n+    }\n+}"}, {"sha": "6f3d6e4c46ae1eab7ec57f309910097fbd1f20da", "filename": "gcc/testsuite/rust/compile/match5.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmatch5.rs?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,15 @@\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => {}\n+        Foo::B => {}\n+        Foo::C(a) => {}\n+        Foo::D(x, y) => {} // { dg-error \"expected tuple struct or tuple variant, found struct variant Foo::D\" }\n+    }\n+}"}, {"sha": "916b11a3194857734d26c1ffb4683c8dbe1d781a", "filename": "gcc/testsuite/rust/compile/torture/match1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmatch1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a345642a2a150a35b68e2f19b90abf105700c5/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmatch1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmatch1.rs?ref=a8a345642a2a150a35b68e2f19b90abf105700c5", "patch": "@@ -0,0 +1,16 @@\n+// { dg-additional-options \"-w\" }\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => {}\n+        Foo::B => {}\n+        Foo::C(x) => {}\n+        Foo::D { x, y } => {}\n+    }\n+}"}]}