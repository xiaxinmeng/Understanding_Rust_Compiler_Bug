{"sha": "5c558dd939b4980abd39ab1817b1ceb2c92fde70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1NThkZDkzOWI0OTgwYWJkMzlhYjE4MTdiMWNlYjJjOTJmZGU3MA==", "commit": {"author": {"name": "Florian Weimer", "email": "fw@deneb.enyo.de", "date": "2002-04-21T07:10:12Z"}, "committer": {"name": "Florian Weimer", "email": "fw@gcc.gnu.org", "date": "2002-04-21T07:10:12Z"}, "message": "gnat_rm.texi: Do not include texiplus.texi.\n\n\t* gnat_rm.texi: Do not include texiplus.texi.  Include fdl.texi\n\tinstead of gfdl.texi\n\n\t* xgnatug.adb, ug_words: New files.\n\n\t* Makefile.in (doc, dvi): New targets.  Build gnat_ug_*,\n        gnat_rm and gnat-style manuals.\n\nFrom-SVN: r52569", "tree": {"sha": "c9e0a1f1bc476e0084f833fdc7665b830c079c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9e0a1f1bc476e0084f833fdc7665b830c079c53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c558dd939b4980abd39ab1817b1ceb2c92fde70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c558dd939b4980abd39ab1817b1ceb2c92fde70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c558dd939b4980abd39ab1817b1ceb2c92fde70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c558dd939b4980abd39ab1817b1ceb2c92fde70/comments", "author": {"login": "fweimer", "id": 2729073, "node_id": "MDQ6VXNlcjI3MjkwNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2729073?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer", "html_url": "https://github.com/fweimer", "followers_url": "https://api.github.com/users/fweimer/followers", "following_url": "https://api.github.com/users/fweimer/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer/subscriptions", "organizations_url": "https://api.github.com/users/fweimer/orgs", "repos_url": "https://api.github.com/users/fweimer/repos", "events_url": "https://api.github.com/users/fweimer/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dda4cc8996f28d5abc0c092de8b74883b9a85e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dda4cc8996f28d5abc0c092de8b74883b9a85e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dda4cc8996f28d5abc0c092de8b74883b9a85e6"}], "stats": {"total": 1432, "additions": 1429, "deletions": 3}, "files": [{"sha": "a17d36093e6256a7e25ff8f124041b3271fb33f1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5c558dd939b4980abd39ab1817b1ceb2c92fde70", "patch": "@@ -1,3 +1,13 @@\n+2002-04-21  Florian Weimer  <fw@deneb.enyo.de>\n+\n+\t* gnat_rm.texi: Do not include texiplus.texi.  Include fdl.texi\n+\tinstead of gfdl.texi\n+\n+\t* xgnatug.adb, ug_words: New files.\n+\n+\t* Makefile.in (doc, dvi): New targets.  Build gnat_ug_*,\n+        gnat_rm and gnat-style manuals.\n+\n 2002-04-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* gigi.h (incomplete_type_error): Remove."}, {"sha": "4d73f9ca7689e922d9db93df2dbe3b2b03df1fdf", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=5c558dd939b4980abd39ab1817b1ceb2c92fde70", "patch": "@@ -2140,6 +2140,42 @@ nmake.ads :  sinfo.ads nmake.adt xnmake.adb\n \t$(CP) $^ bldtools\n \t(cd bldtools; gnatmake -q xnmake ; ./xnmake -s ../nmake.ads )\n \n+# We remove the generated .texi files to force regeneration.\n+doctools/xgnatug : xgnatug.adb\n+\t-$(MKDIR) doctools\n+\t$(CP) $^ doctools\n+\t(cd doctools ; gnatmake -q xgnatug)\n+\t-rm gnat_ug_*.texi\n+\n+# We cannot list the dependency on the xgnatug binary here because we\n+# have to (a) use the VPATH feature, and (b) include the target flag.\n+gnat_ug_vms.texi : gnat_ug.texi ug_words\n+\tdoctools/xgnatug vms $^\n+\n+gnat_ug_wnt.texi : gnat_ug.texi ug_words\n+\tdoctools/xgnatug wnt $^\n+\n+gnat_ug_unx.texi : gnat_ug.texi ug_words\n+\tdoctools/xgnatug unx $^\n+\n+gnat_ug_vxw.texi : gnat_ug.texi ug_words\n+\tdoctools/xgnatug vxworks $^\n+\n+%.info : %.texi\n+\t$(MAKEINFO) -I $(srcdir)/../doc/include -o $@ $<\n+\n+%.dvi : %.texi\n+\t$(TEXI2DVI) -I $(srcdir)/../doc/include $<\n+\n+# List the dependency on the xgnatug binary explicitly (see above).\n+doc : doctools/xgnatug \\\n+\tgnat_ug_vms.info gnat_ug_wnt.info gnat_ug_unx.info gnat_ug_vxw.info \\\n+\tgnat_rm.info gnat-style.info\n+\n+dvi : doctools/xgnatug \\\n+\tgnat_ug_vms.dvi gnat_ug_wnt.dvi gnat_ug_unx.dvi gnat_ug_vxw.dvi \\\n+\tgnat_rm.dvi gnat-style.dvi\n+\n update-sources : treeprs.ads einfo.h sinfo.h nmake.adb nmake.ads\n \t$(CP) $^ $(srcdir)\n "}, {"sha": "7d27ca9f6426d34aad3658fd025938e6047f16d1", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5c558dd939b4980abd39ab1817b1ceb2c92fde70", "patch": "@@ -1,5 +1,4 @@\n \\input texinfo   @c -*-texinfo-*-\n-@input texiplus\n \n @c %**start of header\n \n@@ -9,7 +8,7 @@\n @c                                                                            o\n @c                              G N A T _ RM                                  o\n @c                                                                            o\n-@c                            $Revision: 1.254 $\n+@c                            $Revision: 1.5 $\n @c                                                                            o\n @c              Copyright (C) 1995-2002 Free Software Foundation              o\n @c                                                                            o\n@@ -11980,7 +11979,7 @@ attributes are recognized, although only a subset of them can sensibly\n be implemented.  The description of pragmas in this reference manual\n indicates whether or not they are applicable to non-VMS systems.\n \n-@include gfdl.texi\n+@include fdl.texi\n @c GNU Free Documentation License\n \n @node Index,,GNU Free Documentation License, Top"}, {"sha": "708a7fe48bc050a219e5cb3076b506bde1545b0b", "filename": "gcc/ada/ug_words", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2Fug_words", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2Fug_words", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fug_words?ref=5c558dd939b4980abd39ab1817b1ceb2c92fde70", "patch": "@@ -0,0 +1,134 @@\n+Ada_Switches            ^ Ada_Qualifiers\n+b_                      ^ B_\n+b~                      ^ B$\n+cc1                     ^ CC1\n+Cc1                     ^ CC1\n+Default_Switches        ^ Default_Qualifiers\n+emacs                   ^ EMACS\n+Emacs                   ^ EMACS\n+gdb                     ^ GDB\n+Gdb                     ^ GDB\n+gnat1                   ^ GNAT1\n+Gnat1                   ^ GNAT1\n+gnatbind                ^ GNAT BIND\n+Gnatbind                ^ GNAT BIND\n+gnatchop                ^ GNAT CHOP\n+Gnatchop                ^ GNAT CHOP\n+gnatelim                ^ GNAT ELIM\n+Gnatelim                ^ GNAT ELIM\n+gnatf                   ^ GNAT XREF\n+Gnatf                   ^ GNAT XREF\n+gnatfind                ^ GNAT FIND\n+Gnatfind                ^ GNAT FIND\n+gnatkr                  ^ GNAT KRUNCH\n+Gnatkr                  ^ GNAT KRUNCH\n+gnatlbr                 ^ GNAT LIBRARY\n+Gnatlbr                 ^ GNAT LIBRARY\n+gnatlink                ^ GNAT LINK\n+Gnatlink                ^ GNAT LINK\n+gnatls                  ^ GNAT LIST\n+Gnatls                  ^ GNAT LIST\n+gnatmake                ^ GNAT MAKE\n+Gnatmake                ^ GNAT MAKE\n+gnatprep                ^ GNAT PREPROCESS\n+Gnatprep                ^ GNAT PREPROCESS\n+gnatpsta                ^ GNAT STANDARD\n+Gnatpsta                ^ GNAT STANDARD\n+gnatstub                ^ GNAT STUB\n+Gnatstub                ^ GNAT STUB\n+gnatxref                ^ GNAT XREF\n+Gnatxref                ^ GNAT XREF\n+gcc                     ^ GNAT COMPILE\n+gcc -c                  ^ GNAT COMPILE\n+-gnata                  ^ /CHECKS=ASSERTIONS\n+-gnatb                  ^ /WARNINGS=BRIEF\n+-gnatc                  ^ /NOLOAD\n+-gnatdc                 ^ /TRACE_UNITS\n+-gnatdO                 ^ /REPORT_ERRORS=IMMEDIATE\n+-gnatC                  ^ /COMPRESS_NAMES\n+-gnatD                  ^ /XDEBUG\n+-gnatE                  ^ /CHECKS=ELABORATION\n+-gnatf                  ^ /REPORT_ERRORS=FULL\n+-gnatF                  ^ /UPPERCASE_EXTERNALS\n+-gnatg                  ^ /STYLE=GNAT\n+-gnatG                  ^ /EXPAND_SOURCE\n+-gnatk                  ^ /FILE_NAME_MAX_LENGTH\n+-gnatl                  ^ /LIST\n+-gnatm                  ^ /ERROR_LIMIT\n+-gnatm2                 ^ /ERROR_LIMIT=2\n+-gnatn                  ^ /INLINE=PRAGMA\n+-gnato                  ^ /CHECKS=OVERFLOW\n+-gnatp                  ^ /CHECKS=SUPPRESS_ALL\n+-gnatP                  ^ /POLLING_ENABLE\n+-gnatr                  ^ /STYLE=REFERENCE_MANUAL\n+-gnatR                  ^ /REPRESENTATION_INFO\n+-gnatR0                 ^ /REPRESENTATION_INFO=NONE\n+-gnatR1                 ^ /REPRESENTATION_INFO=ARRAYS\n+-gnatR2                 ^ /REPRESENTATION_INFO=OBJECTS\n+-gnatR3                 ^ /REPRESENTATION_INFO=SYMBOLIC\n+-gnatq                  ^ /TRY_SEMANTICS\n+-gnatQ                  ^ /FORCE_ALI\n+-gnats                  ^ /SYNTAX_ONLY\n+-gnatt                  ^ /TREE_OUTPUT\n+-gnatu                  ^ /UNITS_LIST\n+-gnatU                  ^ /UNIQUE_ERROR_TAG\n+-gnatv                  ^ /REPORT_ERRORS=VERBOSE\n+-gnatV                  ^ /VALIDITY_CHECKING\n+-gnatV0                 ^ /VALIDITY_CHECKING=NONE\n+-gnatVd                 ^ /VALIDITY_CHECKING=RM\n+-gnatVf                 ^ /VALIDITY_CHECKING=FULL\n+-gnatwa                 ^ /WARNINGS=OPTIONAL\n+-gnatwA                 ^ /WARNINGS=NOOPTIONAL\n+-gnatwb                 ^ /WARNINGS=BIASED_ROUNDING\n+-gnatwB                 ^ /WARNINGS=NOBIASED_ROUNDING\n+-gnatwc                 ^ /WARNINGS=CONDITIONALS\n+-gnatwC                 ^ /WARNINGS=NOCONDITIONALS\n+-gnatwd                 ^ /WARNINGS=IMPLICIT_DEREFERENCE\n+-gnatwD                 ^ /WARNINGS=NOIMPLICIT_DEREFERENCE\n+-gnatwe                 ^ /WARNINGS=ERROR\n+-gnatwf                 ^ /WARNINGS=UNREFERENCED_FORMALS\n+-gnatwF                 ^ /WARNINGS=NOUNREFERENCED_FORMALS\n+-gnatwh                 ^ /WARNINGS=HIDING\n+-gnatwH                 ^ /WARNINGS=NOHIDING\n+-gnatwi                 ^ /WARNINGS=IMPLEMENTATION\n+-gnatwI                 ^ /WARNINGS=NOIMPLEMENTATION\n+-gnatwl                 ^ /WARNINGS=ELABORATION\n+-gnatwL                 ^ /WARNINGS=NOELABORATION\n+-gnatwo                 ^ /WARNINGS=OVERLAYS\n+-gnatwO                 ^ /WARNINGS=NOOVERLAYS\n+-gnatwr                 ^ /WARNINGS=REDUNDANT\n+-gnatwR                 ^ /WARNINGS=NOREDUNDANT\n+-gnatws                 ^ /WARNINGS=SUPPRESS\n+-gnatwu                 ^ /WARNINGS=UNUSED\n+-gnatwU                 ^ /WARNINGS=NOUNUSED\n+-gnatW8                 ^ /WIDE_CHARACTER_ENCODING=UTF8\n+-gnatW?                 ^ /WIDE_CHARACTER_ENCODING=?\n+-gnaty                  ^ /STYLE=\n+-gnatzr                 ^ /DISTRIBUTION_STUBS=RECEIVER\n+-gnatzs                 ^ /DISTRIBUTION_STUBS=SENDER\n+-gnat83                 ^ /83\n+-gnat95                 ^ /95\n+-gnatx                  ^ /XREF=SUPPRESS\n+-gnatX                  ^ /EXTENSIONS_ALLOWED\n+--RTS                   ^ /RUNTIME_SYSTEM\n+mode_switches           ^ mode_qualifiers\n+switch                  ^ qualifier\n+switches                ^ qualifiers\n+Switch                  ^ Qualifier\n+Switches                ^ Qualifiers\n+switch-related          ^ qualifier-related\n+stdout                  ^ SYS$OUTPUT\n+stderr                  ^ SYS$ERROR\n+-bargs                  ^ /BINDER_QUALIFIERS\n+-cargs                  ^ /COMPILER_QUALIFIERS\n+-largs                  ^ /LINKER_QUALIFIERS\n+-aIDIR                  ^ /SOURCE_SEARCH=direc\n+-aODIR                  ^ /OBJECT_SEARCH=direc\n+-IDIR                   ^ /SEARCH=direc\n+-nostdinc               ^ /NOSTD_INCLUDES\n+-nostdlib               ^ /NOSTD_LIBRARIES\n+-pFILE                  ^ /PROJECT=file\n+-O0                     ^ /OPTIMIZE=NONE\n+-O1                     ^ /OPTIMIZE=SOME\n+-O2                     ^ /OPTIMIZE=ALL\n+-O3                     ^ /OPTIMIZE=INLINING"}, {"sha": "81f94394ab0f296ca8169914dd14ef215a890a5e", "filename": "gcc/ada/xgnatug.adb", "status": "added", "additions": 1247, "deletions": 0, "changes": 1247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2Fxgnatug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c558dd939b4980abd39ab1817b1ceb2c92fde70/gcc%2Fada%2Fxgnatug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxgnatug.adb?ref=5c558dd939b4980abd39ab1817b1ceb2c92fde70", "patch": "@@ -0,0 +1,1247 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT SYSTEM UTILITIES                           --\n+--                                                                          --\n+--                              X G N A T U G                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2002 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This utility is used to process the source of gnat_ug.texi to make a\n+--  version suitable for running through standard Texinfo processor. It takes\n+--  three arguments. The first one is the target type of the manual, which\n+--  can be one of:\n+--\n+--     unx       GNU\n+--     vms       OpenVMS\n+--     wnt       Mirosoft Windows\n+--     vxworks   Embedded Platforms\n+--\n+--  The second parameter is the file name of the Texinfo file to be\n+--  preprocessed.\n+--\n+--  The third parameter is the name of the word list.  This file is used for\n+--  rewriting the VMS edition.  Each line contains a word mapping: The source\n+--  word in the first column, the target words in the second column.  The\n+--  columns are separated by a '^' character.  When preprocessing for VMS, the\n+--  first word is replaced with the second.  (Words consist of letters,\n+--  digits, and the four characters \"?-_~\". A sequence of multiple words can\n+--  be replaced if they listed in the first column, separated by a single\n+--  space character.  If multiple words are to be replaced, there has to be\n+--  replacement for each prefix.)\n+--\n+--  The fourth parameter is the name of the output file.  It defaults to\n+--  gnat_ug_unx.texi, gnat_ug_vms.texi, gnat_ug_wnt.texi or gnat_ug_vxw.texi,\n+--  depending on the target.\n+--\n+--  The following steps are performed:\n+--\n+--     In VMS mode\n+--\n+--       Any occurrences of ^alpha^beta^ are replaced by beta. The sequence\n+--       must fit on a single line, and there can only be one occurrence on a\n+--       line.\n+--\n+--       Any occurrences of a word in the Ug_Words list are replaced by the\n+--       appropriate vms equivalents. Note that replacements do not occur\n+--       within ^alpha^beta^ sequences.\n+--\n+--       Any occurence of [filename].extension, where extension one of the\n+--       following:\n+--\n+--           \"o\", \"ads\", \"adb\", \"ali\", \"ada\", \"atb\", \"ats\", \"adc\", \"c\"\n+--\n+--\n+--       replaced by the appropriate VMS names (all upper case with .o\n+--       replaced .OBJ). Note that replacements do not occur within\n+--       ^alpha^beta^ sequences.\n+--\n+--     In UNX, VXWORKS or WNT mode\n+--\n+--       Any occurrences of ^alpha^beta^ are replaced by alpha. The sequence\n+--       must fit on a single line.\n+--\n+--     In all modes\n+--\n+--       The sequence ^^^ is replaced by a single ^. This escape sequence\n+--       must be used if the literal character ^ is to appear in the\n+--       output. A line containing this escape sequence may not also contain\n+--       a ^alpha^beta^ sequence.\n+--\n+--       Recognize @ifset and @ifclear (this is because we have menu problems\n+--       if we let makeinfo handle the ifset/ifclear pairs\n+\n+with Ada.Command_Line; use Ada.Command_Line;\n+with Ada.Strings; use Ada.Strings;\n+with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n+with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n+with Ada.Strings.Maps; use Ada.Strings.Maps;\n+with Ada.Strings.Maps.Constants; use Ada.Strings.Maps.Constants;\n+with Ada.Text_IO; use Ada.Text_IO;\n+with GNAT.Spitbol; use GNAT.Spitbol;\n+with GNAT.Spitbol.Table_VString; use GNAT.Spitbol.Table_VString;\n+\n+procedure Xgnatug is\n+\n+   procedure Usage;\n+   --  Print usage information.  Invoked if an invalid command line is\n+   --  encountered.\n+\n+   Output_File : File_Type;\n+   --  The preprocessed output is written to this file.\n+\n+   type Input_File is record\n+      Name : VString;\n+      Data : File_Type;\n+      Line : Natural := 0;\n+   end record;\n+   --  Records information on an input file.  Name and Line are used\n+   --  in error messages, Line is updated automatically by Get_Line.\n+\n+   function Get_Line (Input : access Input_File) return String;\n+   --  Returns a line from Input and performs the necessary\n+   --  line-oriented checks (length, character set, trailing spaces).\n+\n+   Have_Errors : Boolean := False;\n+   procedure Error\n+     (Input        : Input_File;\n+      At_Character : Natural;\n+      Message      : String);\n+   procedure Error\n+     (Input        : Input_File;\n+      Message      : String);\n+   --  Prints a message reporting an error on line Input.Line.  If\n+   --  At_Character is not 0, indicate the exact character at which\n+   --  the error occurs.\n+\n+   procedure Warning\n+     (Input        : Input_File;\n+      At_Character : Natural;\n+      Message      : String);\n+   procedure Warning\n+     (Input        : Input_File;\n+      Message      : String);\n+   --  Like Error, but just print a warning message.\n+\n+   Dictionary_File : aliased Input_File;\n+   procedure Read_Dictionary_File;\n+   --  Dictionary_File is opened using the name given on the command\n+   --  line.  It contains the replacements for the Ug_Words list.\n+   --  Read_Dictionary_File reads Dictionary_File and fills the\n+   --  Ug_Words table.\n+\n+   Source_File : aliased Input_File;\n+   procedure Process_Source_File;\n+   --  Source_File is opened using the name given on the command line.\n+   --  It contains the Texinfo source code.  Process_Source_File\n+   --  performs the necessary replacements.\n+\n+   type Target_Type is (VMS, WNT, UNX, VXWORKS);\n+   Target : Target_Type;\n+   --  The target for which preprocessing is performed: VMS, Windows,\n+   --  GNU, and embedded platforms (\"UNX\" and \"VXWORKS\" are misnomers).\n+   --  The Target avariable is initialized using the command line.\n+\n+   Valid_Characters : constant Character_Set\n+     := To_Set (Span => (' ',  '~'));\n+   --  This array controls which characters are permitted in the input\n+   --  file (after line breaks have been removed).  Valid characters\n+   --  are all printable ASCII characters and the space character.\n+\n+   Word_Characters : constant Character_Set\n+     := (To_Set (Ranges => (('0', '9'), ('a', 'z'), ('A', 'Z')))\n+         or To_Set (\"?-_~\"));\n+   --  The characters which are permitted in words.  Other (valid)\n+   --  characters are assumed to be delimiters between words.  Note that\n+   --  this set has to include all characters of the source words of the\n+   --  Ug_Words dictionary.\n+\n+   Reject_Trailing_Spaces : constant Boolean := True;\n+   --  Controls whether Xgnatug rejects superfluous space characters\n+   --  at the end of lines.\n+\n+   Maximum_Line_Length : constant Positive := 2000;\n+   Fatal_Line_Length_Limit : constant Positive := 5000;\n+   Fatal_Line_Length : exception;\n+   --  If Maximum_Line_Length is exceeded in an input file, an error\n+   --  message is printed.  If Fatal_Line_Length is exceeded,\n+   --  execution terminates with a Fatal_Line_Length exception.\n+\n+   VMS_Escape_Character : constant Character := '^';\n+   --  The character used to mark VMS alternatives (^alpha^beta^).\n+\n+   Extensions : GNAT.Spitbol.Table_VString.Table (20);\n+   procedure Initialize_Extensions;\n+   --  This table records extensions and their replacement for\n+   --  rewriting filenames in the VMS version of the manual.\n+\n+   function Is_Extension (Extension : String) return Boolean;\n+   function Get_Replacement_Extension (Extension : String) return String;\n+   --  These functions query the replacement table.  Is_Extension\n+   --  checks if the given string is a known extension.\n+   --  Get_Replacement returns the replacement extension.\n+\n+   Ug_Words : GNAT.Spitbol.Table_VString.Table (200);\n+   function Is_Known_Word (Word : String) return Boolean;\n+   function Get_Replacement_Word (Word : String) return String;\n+   --  The Ug_Words table lists replacement words for the VMS version\n+   --  of the manual.  Is_Known_Word and Get_Replacement_Word query\n+   --  this table.  The table is filled using Read_Dictionary_File.\n+\n+   function Rewrite_Source_Line (Line : String) return String;\n+   --  This subprogram takes a line and rewrites it according to Target.\n+   --  It relies on information in Source_File to generate error messages.\n+\n+   type Conditional is (Set, Clear);\n+   procedure Push_Conditional (Cond : Conditional; Flag : Target_Type);\n+   procedure Pop_Conditional (Cond : Conditional);\n+   --  These subprograms deal with conditional processing (@ifset/@ifclear).\n+   --  They rely on information in Source_File to generate error messages.\n+\n+   function Currently_Excluding return Boolean;\n+   --  Returns true if conditional processing directives imply that the\n+   --  current line should not be included in the output.\n+\n+   function VMS_Context_Determined return Boolean;\n+   --  Returns true if, in the current conditional preprocessing context, we\n+   --  always have a VMS or a non-VMS version, regardless of the value of\n+   --  Target.\n+\n+   procedure Check_No_Pending_Conditional;\n+   --  Checks that all preprocessing directives have been properly matched by\n+   --  their @end counterpart.  If this is not the case, print an error\n+   --  message.\n+\n+   --  The following definitions implement a stack to track the conditional\n+   --  preprocessing context.\n+\n+   type Conditional_Context is record\n+      Starting_Line : Positive;\n+      Cond          : Conditional;\n+      Flag          : Target_Type;\n+      Excluding     : Boolean;\n+   end record;\n+\n+   Conditional_Stack_Depth : constant := 3;\n+   Conditional_Stack : array (1 .. Conditional_Stack_Depth)\n+     of Conditional_Context;\n+   Conditional_TOS : Natural := 0;\n+   --  Pointer to the Top Of Stack for Conditional_Stack.\n+\n+   -----------------------------------\n+   -- Implementation of Subprograms --\n+   -----------------------------------\n+\n+   -----------\n+   -- Usage --\n+   -----------\n+\n+   procedure Usage is\n+   begin\n+      Put_Line (Standard_Error,\n+                \"usage: xgnatug TARGET SOURCE DICTIONARY [OUTFILE]\");\n+      New_Line;\n+      Put_Line (Standard_Error, \"TARGET is one of:\");\n+      for T in Target_Type'Range loop\n+         Put_Line (Standard_Error, \"  \" & Target_Type'Image (T));\n+      end loop;\n+      New_Line;\n+      Put_Line (Standard_Error, \"SOURCE is the source file to process.\");\n+      New_Line;\n+      Put_Line (Standard_Error, \"DICTIONARY is the name of a file \"\n+                & \"that contains word replacements\");\n+      Put_Line (Standard_Error, \"for the VMS version.\");\n+      New_Line;\n+      Put_Line (Standard_Error,\n+                \"OUT-FILE, if present, is the output file to be created;\");\n+      Put_Line (Standard_Error,\n+                \"If OUT-FILE is absent, the output file is one of \" &\n+                \"gnat_ug_unx.texi, \");\n+      Put_Line (Standard_Error,\n+                \"gnat_ug_vms.texi, gnat_ug_wnt.texi or gnat_ug_vxw.texi, \" &\n+                \"depending on TARGET.\");\n+   end Usage;\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   function Get_Line (Input : access Input_File) return String is\n+      Line_Buffer : String (1 .. Fatal_Line_Length_Limit);\n+      Last        : Natural;\n+\n+   begin\n+      Input.Line := Input.Line + 1;\n+      Get_Line (Input.Data, Line_Buffer, Last);\n+      if Last = Line_Buffer'Last then\n+         Error (Input.all, \"line exceeds fatal line length limit\");\n+         raise Fatal_Line_Length;\n+      end if;\n+\n+      declare\n+         Line : String renames Line_Buffer (Line_Buffer'First .. Last);\n+\n+      begin\n+         for J in Line'Range loop\n+            if not Is_In (Line (J), Valid_Characters) then\n+               Error (Input.all, J, \"invalid character\");\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if Line'Length > Maximum_Line_Length then\n+            Warning (Input.all, Maximum_Line_Length + 1, \"line too long\");\n+         end if;\n+\n+         if Reject_Trailing_Spaces\n+           and then Line'Length > 0\n+           and then Line (Line'Last) = ' '\n+         then\n+            Error (Input.all, Line'Last, \"trailing space character\");\n+         end if;\n+\n+         return Trim (Line, Right);\n+      end;\n+   end Get_Line;\n+\n+   -----------\n+   -- Error --\n+   -----------\n+\n+   procedure Error\n+     (Input        : Input_File;\n+      Message      : String)\n+   is\n+   begin\n+      Error (Input, 0, Message);\n+   end Error;\n+\n+   procedure Error\n+     (Input        : Input_File;\n+      At_Character : Natural;\n+      Message      : String)\n+   is\n+      Line_Image : constant String := Integer'Image (Input.Line);\n+      At_Character_Image : constant String := Integer'Image (At_Character);\n+      --  These variables are required because we have to drop the leading\n+      --  space character.\n+\n+   begin\n+      Have_Errors := True;\n+      if At_Character > 0 then\n+         Put_Line (Standard_Error,\n+                   S (Input.Name) & ':'\n+                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last) & ':'\n+                   & At_Character_Image (At_Character_Image'First + 1\n+                                         .. At_Character_Image'Last)\n+                   & \": \"\n+                   & Message);\n+      else\n+         Put_Line (Standard_Error,\n+                   S (Input.Name) & ':'\n+                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last)\n+                   & \": \"\n+                   & Message);\n+      end if;\n+   end Error;\n+\n+   -------------\n+   -- Warning --\n+   -------------\n+\n+   procedure Warning\n+     (Input        : Input_File;\n+      Message      : String)\n+   is\n+   begin\n+      Warning (Input, 0, Message);\n+   end Warning;\n+\n+   procedure Warning\n+     (Input        : Input_File;\n+      At_Character : Natural;\n+      Message      : String)\n+   is\n+      Line_Image : constant String := Integer'Image (Input.Line);\n+      At_Character_Image : constant String := Integer'Image (At_Character);\n+      --  These variables are required because we have to drop the leading\n+      --  space character.\n+\n+   begin\n+      if At_Character > 0 then\n+         Put_Line (Standard_Error,\n+                   S (Input.Name) & ':'\n+                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last) & ':'\n+                   & At_Character_Image (At_Character_Image'First + 1\n+                                         .. At_Character_Image'Last)\n+                   & \": warning: \"\n+                   & Message);\n+      else\n+         Put_Line (Standard_Error,\n+                   S (Input.Name) & ':'\n+                   & Line_Image (Line_Image'First + 1 .. Line_Image'Last)\n+                   & \": warning: \"\n+                   & Message);\n+      end if;\n+   end Warning;\n+\n+   --------------------------\n+   -- Read_Dictionary_File --\n+   --------------------------\n+\n+   procedure Read_Dictionary_File is\n+   begin\n+      while not End_Of_File (Dictionary_File.Data) loop\n+         declare\n+            Line  : String := Get_Line (Dictionary_File'Access);\n+            Split : Natural := Index (Line, (1 => VMS_Escape_Character));\n+\n+         begin\n+            if Line'Length = 0 then\n+               Error (Dictionary_File, \"empty line in dictionary file\");\n+            elsif Line (Line'First) = ' ' then\n+               Error (Dictionary_File, 1, \"line starts with space character\");\n+            elsif Split = 0 then\n+               Error (Dictionary_File, \"line does not contain \"\n+                      & VMS_Escape_Character & \" character\");\n+            else\n+               declare\n+                  Source : constant String\n+                    := Trim (Line (1 .. Split - 1), Both);\n+                  Target : constant String\n+                    := Trim (Line (Split + 1 .. Line'Last), Both);\n+                  Two_Spaces : constant Natural\n+                    := Index (Source, \"  \");\n+                  Non_Word_Character : constant Natural\n+                    := Index (Source, Word_Characters or To_Set (\" \"),\n+                              Outside);\n+\n+               begin\n+                  if Two_Spaces /= 0 then\n+                     Error (Dictionary_File, Two_Spaces,\n+                            \"multiple space characters in source word\");\n+                  end if;\n+\n+                  if Non_Word_Character /= 0 then\n+                     Error (Dictionary_File, Non_Word_Character,\n+                            \"illegal character in source word\");\n+                  end if;\n+\n+                  if Source'Length = 0 then\n+                     Error (Dictionary_File, \"source is empty\");\n+                  elsif Target'Length = 0 then\n+                     Error (Dictionary_File, \"target is empty\");\n+                  else\n+                     Set (Ug_Words, Source, V (Target));\n+\n+                     --  Ensure that if Source is a sequence of words\n+                     --  \"WORD1 WORD2 ...\", we already have a mapping for\n+                     --  \"WORD1\".\n+\n+                     for J in Source'Range loop\n+                        if Source (J) = ' ' then\n+                           declare\n+                              Prefix : String renames Source (Source'First\n+                                                              .. J - 1);\n+\n+                           begin\n+                              if not Is_Known_Word (Prefix) then\n+                                 Error (Dictionary_File,\n+                                        \"prefix '\" & Prefix\n+                                        & \"' not known at this point\");\n+                              end if;\n+                           end;\n+                        end if;\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+      end loop;\n+   end Read_Dictionary_File;\n+\n+   -------------------------\n+   -- Process_Source_Line --\n+   -------------------------\n+\n+   function Rewrite_Source_Line (Line : String) return String is\n+\n+      --  We use a simple lexer to split the line into tokens:\n+      --\n+      --    Word             consisting entirely of Word_Characters\n+      --    VMS_Alternative  ^alpha^beta^ replacement (but not ^^^)\n+      --    Space            a space character\n+      --    Other            everything else (sequence of non-word characters)\n+      --    VMS_Error        incomplete VMS alternative\n+      --    End_Of_Line      no more characters on this line\n+      --\n+      --   A sequence of three VMS_Escape_Characters is automatically\n+      --   collapsed to an Other token.\n+\n+      type Token_Span is record\n+         First, Last : Positive;\n+      end record;\n+      --  The character range covered by a token in Line.\n+\n+      type Token_Kind is (End_Of_Line, Word, Other,\n+                          VMS_Alternative, VMS_Error);\n+      type Token_Record (Kind : Token_Kind := End_Of_Line) is record\n+         First : Positive;\n+         case Kind is\n+            when Word | Other =>\n+               Span : Token_Span;\n+            when VMS_Alternative =>\n+               Non_VMS, VMS : Token_Span;\n+            when VMS_Error | End_Of_Line =>\n+               null;\n+         end case;\n+      end record;\n+\n+      Input_Position : Positive := Line'First;\n+      Token : Token_Record;\n+      --  The position of the next character to be processed by Next_Token.\n+\n+      procedure Next_Token;\n+      --  Returns the next token in Line, starting at Input_Position.\n+\n+      Rewritten_Line : VString;\n+      --  Collects the line as it is rewritten.\n+\n+      procedure Rewrite_Word;\n+      --  The current token is assumed to be a Word.  When processing the VMS\n+      --  version of the manual, additional tokens are gathered to check if\n+      --  we have a file name or a sequence of known words.\n+\n+      procedure Maybe_Rewrite_Extension;\n+      --  The current token is assumed to be Other.  When processing the VMS\n+      --  version of the manual and the token represents a single dot \".\",\n+      --  the following word is rewritten according to the rules for\n+      --  extensions.\n+\n+      VMS_Token_Seen : Boolean := False;\n+      --  This is set to true if a VMS_Alternative has been encountered, or a\n+      --  ^^^ token.\n+\n+      procedure Next_Token is\n+         Remaining_Line : String renames Line (Input_Position .. Line'Last);\n+         Last_Character : Natural;\n+\n+      begin\n+         if Remaining_Line'Length = 0 then\n+            Token := (End_Of_Line, Remaining_Line'First);\n+            return;\n+         end if;\n+\n+         --  ^alpha^beta^, the VMS_Alternative case.\n+\n+         if Remaining_Line (Remaining_Line'First) = VMS_Escape_Character then\n+            declare\n+               VMS_Second_Character, VMS_Third_Character : Natural;\n+\n+            begin\n+               if VMS_Token_Seen then\n+                  Error (Source_File, Remaining_Line'First,\n+                         \"multiple \" & VMS_Escape_Character\n+                         & \" characters on a single line\");\n+               else\n+                  VMS_Token_Seen := True;\n+               end if;\n+\n+               --  Find the second and third escape character.  If one of\n+               --  them is not present, generate an error token.\n+\n+               VMS_Second_Character\n+                 := Index (Remaining_Line (Remaining_Line'First + 1\n+                                           .. Remaining_Line'Last),\n+                           (1 => VMS_Escape_Character));\n+               if VMS_Second_Character = 0 then\n+                  Input_Position := Remaining_Line'Last + 1;\n+                  Token := (VMS_Error, Remaining_Line'First);\n+                  return;\n+               end if;\n+\n+               VMS_Third_Character\n+                 := Index (Remaining_Line (VMS_Second_Character + 1\n+                                           .. Remaining_Line'Last),\n+                           (1 => VMS_Escape_Character));\n+               if VMS_Third_Character = 0 then\n+                  Input_Position := Remaining_Line'Last + 1;\n+                  Token := (VMS_Error, Remaining_Line'First);\n+                  return;\n+               end if;\n+\n+               --  Consume all the characters we are about to include in\n+               --  the token.\n+\n+               Input_Position := VMS_Third_Character + 1;\n+\n+               --  Check if we are in a ^^^ situation, and return an Other\n+               --  token in this case.\n+\n+               if Remaining_Line'First + 1 = VMS_Second_Character\n+                 and then Remaining_Line'First + 2 = VMS_Third_Character\n+               then\n+                  Token := (Other, Remaining_Line'First,\n+                            (Remaining_Line'First, Remaining_Line'First));\n+                  return;\n+               end if;\n+\n+               Token := (VMS_Alternative, Remaining_Line'First,\n+                         (Remaining_Line'First + 1, VMS_Second_Character - 1),\n+                         (VMS_Second_Character + 1, VMS_Third_Character - 1));\n+               return;\n+            end;\n+         end if;                        --  VMS_Alternative\n+\n+         --  The Word case.  Search for characters not in Word_Characters.\n+         --  We have found a word if the first non-word character is not\n+         --  the first character in Remaining_Line, i.e. if Remaining_Line\n+         --  starts with a word character.\n+\n+         Last_Character := Index (Remaining_Line, Word_Characters, Outside);\n+         if Last_Character /= Remaining_Line'First then\n+\n+\n+            --  If we haven't found a character which is not in\n+            --  Word_Characters, all remaining characters are part of the\n+            --  current Word token.\n+\n+            if Last_Character = 0 then\n+               Last_Character := Remaining_Line'Last + 1;\n+            end if;\n+\n+            Input_Position := Last_Character;\n+            Token := (Word, Remaining_Line'First,\n+                      (Remaining_Line'First, Last_Character - 1));\n+            return;\n+         end if;\n+\n+         --  Remaining characters are in the Other category.  To speed\n+         --  up processing, we collect them together if there are several\n+         --  of them.\n+\n+         Input_Position := Last_Character + 1;\n+         Token :=  (Other, Remaining_Line'First,\n+                    (Remaining_Line'First, Last_Character));\n+      end Next_Token;\n+\n+      procedure Rewrite_Word is\n+         First_Word : String\n+           renames Line (Token.Span.First .. Token.Span.Last);\n+\n+      begin\n+         --  We do not perform any error checking below, so we can just skip\n+         --  all processing for the non-VMS version.\n+\n+         if Target /= VMS then\n+            Append (Rewritten_Line, First_Word);\n+            Next_Token;\n+            return;\n+         end if;\n+\n+         if Is_Known_Word (First_Word) then\n+\n+            --  If we have a word from the dictionary, we look for the\n+            --  longest possible sequence we can rewrite.\n+\n+            declare\n+               Seq : Token_Span := Token.Span;\n+               Lost_Space : Boolean := False;\n+\n+            begin\n+               Next_Token;\n+               loop\n+                  if Token.Kind = Other\n+                    and then Line (Token.Span.First .. Token.Span.Last) = \" \"\n+                  then\n+                     Next_Token;\n+                     if Token.Kind /= Word\n+                       or else not Is_Known_Word (Line (Seq.First\n+                                                        .. Token.Span.Last))\n+                     then\n+                        --  When we reach this point, the following\n+                        --  conditions are true:\n+                        --\n+                        --  Seq is a known word.\n+                        --  The previous token was a space character.\n+                        --  Seq extended to the current token is not a\n+                        --  known word.\n+\n+                        Lost_Space := True;\n+                        exit;\n+\n+                     else\n+\n+                        --  Extend Seq to cover the current (known) word.\n+\n+                        Seq.Last := Token.Span.Last;\n+                        Next_Token;\n+                     end if;\n+\n+                  else\n+                     --  When we reach this point, the following conditions\n+                     --  are true:\n+                     --\n+                     --  Seq is a known word.\n+                     --  The previous token was a word.\n+                     --  The current token is not a space character.\n+\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               --  Rewrite Seq, and add the lost space if necessary.\n+\n+               Append (Rewritten_Line,\n+                       Get_Replacement_Word (Line (Seq.First .. Seq.Last)));\n+               if Lost_Space then\n+                  Append (Rewritten_Line, ' ');\n+               end if;\n+\n+               --  The unknown token will be processed during the\n+               --  next iteration of the main loop.\n+               return;\n+            end;\n+         end if;\n+\n+         Next_Token;\n+         if Token.Kind = Other\n+           and then Line (Token.Span.First .. Token.Span.Last) = \".\"\n+         then\n+\n+            --  Deal with extensions.\n+\n+            Next_Token;\n+            if Token.Kind = Word\n+              and then Is_Extension (Line (Token.Span.First\n+                                           .. Token.Span.Last))\n+            then\n+               --  We have discovered a file extension.  Convert the file\n+               --  name to upper case.\n+\n+               Append (Rewritten_Line,\n+                       Translate (First_Word, Upper_Case_Map) & '.');\n+               Append (Rewritten_Line,\n+                       Get_Replacement_Extension\n+                       (Line (Token.Span.First .. Token.Span.Last)));\n+               Next_Token;\n+            else\n+               --  We already have: Word \".\", followed by an unknown\n+               --  token.\n+\n+               Append (Rewritten_Line, First_Word & '.');\n+\n+               --  The unknown token will be processed during the next\n+               --  iteration of the main loop.\n+            end if;\n+\n+\n+         else\n+            --  We have an unknown Word, followed by an unknown token.\n+            --  The unknown token will be processed by the outer loop.\n+\n+            Append (Rewritten_Line, First_Word);\n+         end if;\n+      end Rewrite_Word;\n+\n+      procedure Maybe_Rewrite_Extension is\n+      begin\n+         --  Again, we need no special processing in the non-VMS case.\n+\n+         if Target = VMS\n+           and then Line (Token.Span.First .. Token.Span.Last) = \".\"\n+         then\n+            --  This extension is not preceded by a word, otherwise\n+            --  Rewrite_Word would have handled it.\n+\n+            Next_Token;\n+            if Token.Kind = Word\n+              and then Is_Extension (Line (Token.Span.First\n+                                           .. Token.Span.Last))\n+            then\n+               Append (Rewritten_Line, '.' & Get_Replacement_Extension\n+                       (Line (Token.Span.First .. Token.Span.Last)));\n+               Next_Token;\n+            else\n+               Append (Rewritten_Line, '.');\n+            end if;\n+         else\n+            Append (Rewritten_Line, Line (Token.Span.First\n+                                          .. Token.Span.Last));\n+            Next_Token;\n+         end if;\n+      end Maybe_Rewrite_Extension;\n+\n+      --  Start of processing for Process_Source_Line\n+\n+   begin\n+      --  The following parser recognizes the following special token\n+      --  sequences:\n+      --\n+      --     Word \".\" Word    rewrite as file name if second word is extension\n+      --     Word \" \" Word    rewrite as a single word using Ug_Words table\n+\n+      Next_Token;\n+      loop\n+         case Token.Kind is\n+            when End_Of_Line =>\n+               exit;\n+\n+            when Word  =>\n+               Rewrite_Word;\n+\n+            when Other =>\n+               Maybe_Rewrite_Extension;\n+\n+            when VMS_Alternative =>\n+               if VMS_Context_Determined then\n+                  Warning (Source_File, Token.First,\n+                           \"VMS alternative already determined \"\n+                           & \"by conditionals\");\n+               end if;\n+               if Target = VMS then\n+                  Append (Rewritten_Line, Line (Token.VMS.First\n+                                                .. Token.VMS.Last));\n+               else\n+                  Append (Rewritten_Line, Line (Token.Non_VMS.First\n+                                                .. Token.Non_VMS.Last));\n+               end if;\n+               Next_Token;\n+\n+            when VMS_Error =>\n+               Error (Source_File, Token.First, \"invalid VMS alternative\");\n+               Next_Token;\n+         end case;\n+      end loop;\n+      return S (Rewritten_Line);\n+   end Rewrite_Source_Line;\n+\n+   -------------------------\n+   -- Process_Source_File --\n+   -------------------------\n+\n+   procedure Process_Source_File is\n+      Ifset : constant String := \"@ifset \";\n+      Ifclear : constant String := \"@ifclear \";\n+      Endsetclear : constant String := \"@end \";\n+      --  Strings to be recognized for conditional processing.\n+\n+   begin\n+      while not End_Of_File (Source_File.Data) loop\n+         declare\n+            Line : constant String := Get_Line (Source_File'Access);\n+            Rewritten : constant String := Rewrite_Source_Line (Line);\n+            --  We unconditionally rewrite the line so that we can check the\n+            --  syntax of all lines, and not only those which are actually\n+            --  included in the output.\n+\n+            Have_Conditional : Boolean := False;\n+            --  True if we have encountered a conditional preprocessing\n+            --  directive.\n+            Cond : Conditional;\n+            --  The kind of the directive.\n+            Flag : Target_Type;\n+            --  Its flag.\n+\n+         begin\n+            --  If the line starts with @ifset or @ifclear, we try to convert\n+            --  the following flag to one of our target types.  If we fail,\n+            --  Have_Conditional remains False.\n+\n+            if Line'Length >= Ifset'Length\n+              and then Line (1 .. Ifset'Length) = Ifset\n+            then\n+               Cond := Set;\n+               declare\n+                  Arg : constant String\n+                    := Trim (Line (Ifset'Length + 1 .. Line'Last), Both);\n+\n+               begin\n+                  Flag := Target_Type'Value (Arg);\n+                  if Translate (Target_Type'Image (Flag), Lower_Case_Map)\n+                    /= Arg\n+                  then\n+                     Error (Source_File, \"flag has to be lowercase\");\n+                  end if;\n+                  Have_Conditional := True;\n+               exception\n+                  when Constraint_Error =>\n+                     Error (Source_File, \"unknown flag for '@ifset'\");\n+               end;\n+\n+            elsif Line'Length >= Ifclear'Length\n+              and then Line (1 .. Ifclear'Length) = Ifclear\n+            then\n+               Cond := Clear;\n+               declare\n+                  Arg : constant String\n+                    := Trim (Line (Ifclear'Length + 1 .. Line'Last), Both);\n+\n+               begin\n+                  Flag := Target_Type'Value (Arg);\n+                  if Translate (Target_Type'Image (Flag), Lower_Case_Map)\n+                    /= Arg\n+                  then\n+                     Error (Source_File, \"flag has to be lowercase\");\n+                  end if;\n+                  Have_Conditional := True;\n+               exception\n+                  when Constraint_Error =>\n+                     Error (Source_File, \"unknown flag for '@ifclear'\");\n+               end;\n+            end if;\n+\n+            if Have_Conditional then\n+               --  We create a new conditional context and suppress the\n+               --  directive in the output.\n+\n+               Push_Conditional (Cond, Flag);\n+\n+            elsif Line'Length >= Endsetclear'Length\n+              and then Line (1 .. Endsetclear'Length) = Endsetclear\n+            then\n+               --  The '@end ifset'/'@end ifclear' case is handled here.  We\n+               --  have to pop the conditional context.\n+\n+               declare\n+                  First, Last : Natural;\n+               begin\n+                  Find_Token (Source => Line (Endsetclear'Length + 1\n+                                              .. Line'Length),\n+                              Set    => Letter_Set,\n+                              Test   => Inside,\n+                              First  => First,\n+                              Last   => Last);\n+                  if Last = 0 then\n+                     Error (Source_File, \"'@end' without argument\");\n+                  else\n+                     if Line (First .. Last) = \"ifset\" then\n+                        Have_Conditional := True;\n+                        Cond := Set;\n+                     elsif Line (First .. Last) = \"ifclear\" then\n+                        Have_Conditional := True;\n+                        Cond := Clear;\n+                     end if;\n+\n+                     if Have_Conditional then\n+                        Pop_Conditional (Cond);\n+                     end if;\n+\n+                     --  We fall through to the ordinary case for other @end\n+                     --  directives.\n+                  end if;               --  @end without argument\n+               end;\n+            end if;                     --  Have_Conditional\n+\n+            if not Have_Conditional then\n+               --  The ordinary case.\n+               if not Currently_Excluding then\n+                  Put_Line (Output_File, Rewritten);\n+               end if;\n+            end if;\n+         end;\n+      end loop;\n+      Check_No_Pending_Conditional;\n+   end Process_Source_File;\n+\n+   ---------------------------\n+   -- Initialize_Extensions --\n+   ---------------------------\n+\n+   procedure Initialize_Extensions is\n+\n+      procedure Add (Extension : String);\n+      --  Adds an extension which is replaced with itself (in upper\n+      --  case).\n+\n+      procedure Add (Extension, Replacement : String);\n+      --  Adds an extension with a custom replacement.\n+\n+      procedure Add (Extension : String) is\n+      begin\n+         Add (Extension, Translate (Extension, Upper_Case_Map));\n+      end Add;\n+\n+      procedure Add (Extension, Replacement : String) is\n+      begin\n+         Set (Extensions, Extension, V (Replacement));\n+      end Add;\n+\n+      --  Start of processing for Initialize_Extensions\n+\n+   begin\n+      --  To avoid performance degradation, increase the constant in the\n+      --  definition of Extensions above if you add more extensions here.\n+\n+      Add (\"o\", \"OBJ\");\n+      Add (\"ads\");\n+      Add (\"adb\");\n+      Add (\"ali\");\n+      Add (\"ada\");\n+      Add (\"atb\");\n+      Add (\"ats\");\n+      Add (\"adc\");\n+      Add (\"c\");\n+   end Initialize_Extensions;\n+\n+   ------------------\n+   -- Is_Extension --\n+   ------------------\n+\n+   function Is_Extension (Extension : String) return Boolean is\n+   begin\n+      return Present (Extensions, Extension);\n+   end Is_Extension;\n+\n+   -------------------------------\n+   -- Get_Replacement_Extension --\n+   -------------------------------\n+\n+   function Get_Replacement_Extension (Extension : String) return String is\n+   begin\n+      return S (Get (Extensions, Extension));\n+   end Get_Replacement_Extension;\n+\n+   -------------------\n+   -- Is_Known_Word --\n+   -------------------\n+\n+   function Is_Known_Word (Word : String) return Boolean is\n+   begin\n+      return Present (Ug_Words, Word);\n+   end Is_Known_Word;\n+\n+   --------------------------\n+   -- Get_Replacement_Word --\n+   --------------------------\n+\n+   function Get_Replacement_Word (Word : String) return String is\n+   begin\n+      return S (Get (Ug_Words, Word));\n+   end Get_Replacement_Word;\n+\n+   ----------------------\n+   -- Push_Conditional --\n+   ----------------------\n+\n+   procedure Push_Conditional (Cond : Conditional; Flag : Target_Type) is\n+      Will_Exclude : Boolean;\n+   begin\n+      --  If we are already in an excluding context, inherit this property,\n+      --  otherwise calculate it from scratch.\n+\n+      if Conditional_TOS > 0\n+        and then Conditional_Stack (Conditional_TOS).Excluding\n+      then\n+         Will_Exclude := True;\n+      else\n+         case Cond is\n+            when Set =>\n+               Will_Exclude := Flag /= Target;\n+            when Clear =>\n+               Will_Exclude := Flag = Target;\n+         end case;\n+      end if;\n+\n+      --  Check if the current directive is pointless because of a previous,\n+      --  enclosing directive.\n+\n+      for J in 1 .. Conditional_TOS loop\n+         if Conditional_Stack (J).Flag = Flag then\n+            Warning (Source_File, \"directive without effect because of line\"\n+                     & Integer'Image (Conditional_Stack (J).Starting_Line));\n+         end if;\n+      end loop;\n+      Conditional_TOS := Conditional_TOS + 1;\n+      Conditional_Stack (Conditional_TOS)\n+        := (Starting_Line => Source_File.Line,\n+            Cond          => Cond,\n+            Flag          => Flag,\n+            Excluding     => Will_Exclude);\n+   end Push_Conditional;\n+\n+   ---------------------\n+   -- Pop_Conditional --\n+   ---------------------\n+\n+   procedure Pop_Conditional (Cond : Conditional) is\n+   begin\n+      if Conditional_TOS > 0 then\n+         case Cond is\n+            when Set =>\n+               if Conditional_Stack (Conditional_TOS).Cond /= Set then\n+                  Error (Source_File,\n+                         \"'@end ifset' does not match '@ifclear' at line\"\n+                         & Integer'Image (Conditional_Stack\n+                                          (Conditional_TOS).Starting_Line));\n+               end if;\n+            when Clear =>\n+               if Conditional_Stack (Conditional_TOS).Cond /= Clear then\n+                  Error (Source_File,\n+                         \"'@end ifclear' does not match '@ifset' at line\"\n+                         & Integer'Image (Conditional_Stack\n+                                          (Conditional_TOS).Starting_Line));\n+               end if;\n+         end case;\n+         Conditional_TOS := Conditional_TOS - 1;\n+      else\n+         case Cond is\n+            when Set =>\n+               Error (Source_File,\n+                      \"'@end ifset' without corresponding '@ifset'\");\n+            when Clear =>\n+               Error (Source_File,\n+                      \"'@end ifclear' without corresponding '@ifclear'\");\n+         end case;\n+      end if;\n+   end Pop_Conditional;\n+\n+   -------------------------\n+   -- Currently_Excluding --\n+   -------------------------\n+\n+   function Currently_Excluding return Boolean is\n+   begin\n+      return Conditional_TOS > 0\n+        and then Conditional_Stack (Conditional_TOS).Excluding;\n+   end Currently_Excluding;\n+\n+   ----------------------------\n+   -- VMS_Context_Determined --\n+   ----------------------------\n+\n+   function VMS_Context_Determined return Boolean is\n+   begin\n+      for J in 1 .. Conditional_TOS loop\n+         if Conditional_Stack (J).Flag = VMS then\n+            return True;\n+         end if;\n+      end loop;\n+      return False;\n+   end VMS_Context_Determined;\n+\n+   ----------------------------------\n+   -- Check_No_Pending_Conditional --\n+   ----------------------------------\n+\n+   procedure Check_No_Pending_Conditional is\n+   begin\n+      for J in 1 .. Conditional_TOS loop\n+         case Conditional_Stack (J).Cond is\n+            when Set =>\n+               Error (Source_File, \"Missing '@end ifset' for '@ifset' at line\"\n+                      & Integer'Image (Conditional_Stack (J).Starting_Line));\n+            when Clear =>\n+               Error (Source_File,\n+                      \"Missing '@end ifclear' for '@ifclear' at line\"\n+                      & Integer'Image (Conditional_Stack (J).Starting_Line));\n+         end case;\n+      end loop;\n+   end Check_No_Pending_Conditional;\n+\n+   ------------------\n+   -- Main Program --\n+   ------------------\n+\n+   Valid_Command_Line : Boolean;\n+   Output_File_Name   : VString;\n+\n+begin\n+   Initialize_Extensions;\n+\n+   Valid_Command_Line := Argument_Count in 3 .. 4;\n+\n+   --  First argument: Target.\n+\n+   if Valid_Command_Line then\n+      begin\n+         Target := Target_Type'Value (Argument (1));\n+      exception\n+         when Constraint_Error =>\n+            Valid_Command_Line := False;\n+      end;\n+   end if;\n+\n+   --  Second argument: Source_File.\n+\n+   if Valid_Command_Line then\n+      begin\n+         Source_File.Name := V (Argument (2));\n+         Open (Source_File.Data, In_File, Argument (2));\n+      exception\n+         when Name_Error =>\n+            Valid_Command_Line := False;\n+      end;\n+   end if;\n+\n+   --  Third argument: Dictionary_File.\n+\n+   if Valid_Command_Line then\n+      begin\n+         Dictionary_File.Name := V (Argument (3));\n+         Open (Dictionary_File.Data, In_File, Argument (3));\n+      exception\n+         when Name_Error =>\n+            Valid_Command_Line := False;\n+      end;\n+   end if;\n+\n+   --  Fourth argument: Output_File.\n+\n+   if Valid_Command_Line then\n+      if Argument_Count = 4 then\n+         Output_File_Name := V (Argument (4));\n+      else\n+         case Target is\n+            when VMS =>\n+               Output_File_Name := V (\"gnat_ug_vms.texi\");\n+            when WNT =>\n+               Output_File_Name := V (\"gnat_ug_wnt.texi\");\n+            when UNX =>\n+               Output_File_Name := V (\"gnat_ug_unx.texi\");\n+            when VXWORKS =>\n+               Output_File_Name := V (\"gnat_ug_vxw.texi\");\n+         end case;\n+      end if;\n+\n+      begin\n+         Create (Output_File, Out_File, S (Output_File_Name));\n+      exception\n+         when Name_Error | Use_Error =>\n+            Valid_Command_Line := False;\n+      end;\n+   end if;\n+\n+   if not Valid_Command_Line then\n+      Usage;\n+      Set_Exit_Status (Failure);\n+   else\n+      Read_Dictionary_File;\n+      Close (Dictionary_File.Data);\n+\n+      --  Main processing starts here.\n+\n+      Process_Source_File;\n+      Close (Output_File);\n+      Close (Source_File.Data);\n+      if Have_Errors then\n+         Set_Exit_Status (Failure);\n+      else\n+         Set_Exit_Status (Success);\n+      end if;\n+   end if;\n+end Xgnatug;"}]}