{"sha": "b03a10b0b25cef4928ccead4c8a461d3674dbe86", "node_id": "C_kwDOANBUbNoAKGIwM2ExMGIwYjI1Y2VmNDkyOGNjZWFkNGM4YTQ2MWQzNjc0ZGJlODY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-02-15T19:52:02Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-02-15T19:53:14Z"}, "message": "analyzer: fix uninit false +ves [PR108664,PR108666,PR108725]\n\nThis patch updates poisoned_value_diagnostic so that, where possible,\nit checks to see if the value is still poisoned along the execution\npath seen during feasibility analysis, rather than just that seen\nin the exploded graph.\n\nIntegration testing shows this reduction in the number of\nfalse positives:\n  -Wanalyzer-use-of-uninitialized-value: 191 -> 153 (-38)\nwhere the changes happen in:\n      coreutils-9.1: 34 -> 20 (-14)\n         qemu-7.2.0: 78 -> 54 (-24)\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108664\n\tPR analyzer/108666\n\tPR analyzer/108725\n\t* diagnostic-manager.cc (epath_finder::get_best_epath): Add\n\t\"target_stmt\" param.\n\t(epath_finder::explore_feasible_paths): Likewise.\n\t(epath_finder::process_worklist_item): Likewise.\n\t(saved_diagnostic::calc_best_epath): Pass m_stmt to\n\tepath_finder::get_best_epath.\n\t* engine.cc (feasibility_state::maybe_update_for_edge): Move\n\tper-stmt logic to...\n\t(feasibility_state::update_for_stmt): ...this new function.\n\t* exploded-graph.h (feasibility_state::update_for_stmt): New decl.\n\t* feasible-graph.cc (feasible_node::get_state_at_stmt): New.\n\t* feasible-graph.h: Include \"analyzer/exploded-graph.h\".\n\t(feasible_node::get_state_at_stmt): New decl.\n\t* infinite-recursion.cc\n\t(infinite_recursion_diagnostic::check_valid_fpath_p): Update for\n\tvfunc signature change.\n\t* pending-diagnostic.h (pending_diagnostic::check_valid_fpath_p):\n\tConvert first param to a reference.  Add stmt param.\n\t* region-model.cc: Include \"analyzer/feasible-graph.h\".\n\t(poisoned_value_diagnostic::poisoned_value_diagnostic): Add\n\t\"check_expr\" param.\n\t(poisoned_value_diagnostic::check_valid_fpath_p): New.\n\t(poisoned_value_diagnostic::m_check_expr): New field.\n\t(region_model::check_for_poison): Attempt to supply a check_expr\n\tto the diagnostic\n\t(region_model::deref_rvalue): Add NULL for new check_expr param\n\tof poisoned_value_diagnostic.\n\t(region_model::get_or_create_region_for_heap_alloc): Don't reuse\n\tregions that are marked as TOUCHED.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108664\n\tPR analyzer/108666\n\tPR analyzer/108725\n\t* gcc.dg/analyzer/coreutils-cksum-pr108664.c: New test.\n\t* gcc.dg/analyzer/coreutils-sum-pr108666.c: New test.\n\t* gcc.dg/analyzer/torture/uninit-pr108725.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "b4eb3fb39d6340de1de519e2837cfd1e9843444f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4eb3fb39d6340de1de519e2837cfd1e9843444f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b03a10b0b25cef4928ccead4c8a461d3674dbe86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03a10b0b25cef4928ccead4c8a461d3674dbe86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03a10b0b25cef4928ccead4c8a461d3674dbe86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03a10b0b25cef4928ccead4c8a461d3674dbe86/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0979973c8ea33dd357beb37bd124c1e81cc05970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0979973c8ea33dd357beb37bd124c1e81cc05970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0979973c8ea33dd357beb37bd124c1e81cc05970"}], "stats": {"total": 367, "additions": 343, "deletions": 24}, "files": [{"sha": "0a447f7ba26c2bbf7c43c0a29cb1ef91ad22e196", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -88,6 +88,7 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   get_best_epath (const exploded_node *target_enode,\n+\t\t  const gimple *target_stmt,\n \t\t  const pending_diagnostic &pd,\n \t\t  const char *desc, unsigned diag_idx,\n \t\t  std::unique_ptr<feasibility_problem> *out_problem);\n@@ -97,13 +98,15 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t  const gimple *target_stmt,\n \t\t\t  const pending_diagnostic &pd,\n \t\t\t  const char *desc, unsigned diag_idx);\n   bool\n   process_worklist_item (feasible_worklist *worklist,\n \t\t\t const trimmed_graph &tg,\n \t\t\t feasible_graph *fg,\n \t\t\t const exploded_node *target_enode,\n+\t\t\t const gimple *target_stmt,\n \t\t\t const pending_diagnostic &pd,\n \t\t\t unsigned diag_idx,\n \t\t\t std::unique_ptr<exploded_path> *out_best_path) const;\n@@ -128,6 +131,9 @@ class epath_finder\n /* Get the \"best\" exploded_path for reaching ENODE from the origin,\n    returning ownership of it to the caller.\n \n+   If TARGET_STMT is non-NULL, then check for reaching that stmt\n+   within ENODE.\n+\n    Ideally we want to report the shortest feasible path.\n    Return NULL if we could not find a feasible path\n    (when flag_analyzer_feasibility is true).\n@@ -141,6 +147,7 @@ class epath_finder\n \n std::unique_ptr<exploded_path>\n epath_finder::get_best_epath (const exploded_node *enode,\n+\t\t\t      const gimple *target_stmt,\n \t\t\t      const pending_diagnostic &pd,\n \t\t\t      const char *desc, unsigned diag_idx,\n \t\t\t      std::unique_ptr<feasibility_problem> *out_problem)\n@@ -165,7 +172,7 @@ epath_finder::get_best_epath (const exploded_node *enode,\n       if (logger)\n \tlogger->log (\"trying to find shortest feasible path\");\n       if (std::unique_ptr<exploded_path> epath\n-\t    = explore_feasible_paths (enode, pd, desc, diag_idx))\n+\t    = explore_feasible_paths (enode, target_stmt, pd, desc, diag_idx))\n \t{\n \t  if (logger)\n \t    logger->log (\"accepting %qs at EN: %i, SN: %i (sd: %i)\"\n@@ -335,6 +342,9 @@ class auto_checking_feasibility\n    TARGET_ENODE by iteratively building a feasible_graph, in which\n    every path to a feasible_node is feasible by construction.\n \n+   If TARGET_STMT is non-NULL, then check for reaching that stmt\n+   within TARGET_ENODE.\n+\n    We effectively explore the tree of feasible paths in order of shortest\n    path until we either find a feasible path to TARGET_ENODE, or hit\n    a limit and give up.\n@@ -378,6 +388,7 @@ class auto_checking_feasibility\n \n std::unique_ptr<exploded_path>\n epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t\t      const gimple *target_stmt,\n \t\t\t\t      const pending_diagnostic &pd,\n \t\t\t\t      const char *desc, unsigned diag_idx)\n {\n@@ -420,8 +431,8 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   {\n     auto_checking_feasibility sentinel (mgr);\n \n-    while (process_worklist_item (&worklist, tg, &fg, target_enode, pd,\n-\t\t\t\t  diag_idx, &best_path))\n+    while (process_worklist_item (&worklist, tg, &fg, target_enode, target_stmt,\n+\t\t\t\t  pd, diag_idx, &best_path))\n       {\n \t/* Empty; the work is done within process_worklist_item.  */\n       }\n@@ -465,6 +476,7 @@ process_worklist_item (feasible_worklist *worklist,\n \t\t       const trimmed_graph &tg,\n \t\t       feasible_graph *fg,\n \t\t       const exploded_node *target_enode,\n+\t\t       const gimple *target_stmt,\n \t\t       const pending_diagnostic &pd,\n \t\t       unsigned diag_idx,\n \t\t       std::unique_ptr<exploded_path> *out_best_path) const\n@@ -523,7 +535,7 @@ process_worklist_item (feasible_worklist *worklist,\n \t\t\t     \" (length: %i)\",\n \t\t\t     target_enode->m_index, diag_idx,\n \t\t\t     succ_fnode->get_path_length ());\n-\t      if (!pd.check_valid_fpath_p (succ_fnode))\n+\t      if (!pd.check_valid_fpath_p (*succ_fnode, target_stmt))\n \t\t{\n \t\t  if (logger)\n \t\t    logger->log (\"rejecting feasible path due to\"\n@@ -824,7 +836,8 @@ saved_diagnostic::calc_best_epath (epath_finder *pf)\n   LOG_SCOPE (logger);\n   m_problem = NULL;\n \n-  m_best_epath = pf->get_best_epath (m_enode, *m_d, m_d->get_kind (), m_idx,\n+  m_best_epath = pf->get_best_epath (m_enode, m_stmt,\n+\t\t\t\t     *m_d, m_d->get_kind (), m_idx,\n \t\t\t\t     &m_problem);\n \n   /* Handle failure to find a feasible path.  */"}, {"sha": "24ded2670197901c5d64efce85dd07ff7fa9a2f3", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -4823,17 +4823,7 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n       auto_cfun sentinel (src_point.get_function ());\n       input_location = stmt->location;\n \n-      if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n-\tm_model.on_assignment (assign, NULL);\n-      else if (const gasm *asm_stmt = dyn_cast <const gasm *> (stmt))\n-\tm_model.on_asm_stmt (asm_stmt, NULL);\n-      else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n-\t{\n-\t  bool unknown_side_effects = m_model.on_call_pre (call, NULL);\n-\t  m_model.on_call_post (call, unknown_side_effects, NULL);\n-\t}\n-      else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n-\tm_model.on_return (return_, NULL);\n+      update_for_stmt (stmt);\n     }\n \n   const superedge *sedge = eedge->m_sedge;\n@@ -4910,6 +4900,24 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n   return true;\n }\n \n+/* Update this object for the effects of STMT.  */\n+\n+void\n+feasibility_state::update_for_stmt (const gimple *stmt)\n+{\n+  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n+    m_model.on_assignment (assign, NULL);\n+  else if (const gasm *asm_stmt = dyn_cast <const gasm *> (stmt))\n+    m_model.on_asm_stmt (asm_stmt, NULL);\n+  else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    {\n+      bool unknown_side_effects = m_model.on_call_pre (call, NULL);\n+      m_model.on_call_post (call, unknown_side_effects, NULL);\n+    }\n+  else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n+    m_model.on_return (return_, NULL);\n+}\n+\n /* Dump this object to PP.  */\n \n void"}, {"sha": "4a4ef9d12b486326c0a7154fa13f493746049d9d", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -973,6 +973,7 @@ class feasibility_state\n   bool maybe_update_for_edge (logger *logger,\n \t\t\t      const exploded_edge *eedge,\n \t\t\t      rejected_constraint **out_rc);\n+  void update_for_stmt (const gimple *stmt);\n \n   const region_model &get_model () const { return m_model; }\n   const auto_sbitmap &get_snodes_visited () const { return m_snodes_visited; }"}, {"sha": "d6ff1a3694ae60259add019bb69e8fdfac54c03b", "filename": "gcc/analyzer/feasible-graph.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Ffeasible-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Ffeasible-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.cc?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -104,6 +104,36 @@ feasible_node::dump_dot (graphviz_out *gv,\n   pp_flush (pp);\n }\n \n+/* Attempt to get the region_model for this node's state at TARGET_STMT.\n+   Return true and write to *OUT if found.\n+   Return false if there's a problem.  */\n+\n+bool\n+feasible_node::get_state_at_stmt (const gimple *target_stmt,\n+\t\t\t\t  region_model *out) const\n+{\n+  if (!target_stmt)\n+    return false;\n+\n+  feasibility_state result (m_state);\n+\n+  /* Update state for the stmts that were processed in each enode.  */\n+  for (unsigned stmt_idx = 0; stmt_idx < m_inner_node->m_num_processed_stmts;\n+       stmt_idx++)\n+    {\n+      const gimple *stmt = m_inner_node->get_processed_stmt (stmt_idx);\n+      if (stmt == target_stmt)\n+\t{\n+\t  *out = result.get_model ();\n+\t  return true;\n+\t}\n+      result.update_for_stmt (stmt);\n+    }\n+\n+  /* TARGET_STMT not found; wrong node?  */\n+  return false;\n+}\n+\n /* Implementation of dump_dot vfunc for infeasible_node.\n    In particular, show the rejected constraint.  */\n "}, {"sha": "0da7265979beb4b3b6610c82ed524175a7e8316d", "filename": "gcc/analyzer/feasible-graph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Ffeasible-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Ffeasible-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.h?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_FEASIBLE_GRAPH_H\n #define GCC_ANALYZER_FEASIBLE_GRAPH_H\n \n+#include \"analyzer/exploded-graph.h\"\n+\n namespace ana {\n \n /* Forward decls.  */\n@@ -102,6 +104,9 @@ class feasible_node : public base_feasible_node\n \n   unsigned get_path_length () const { return m_path_length; }\n \n+  bool get_state_at_stmt (const gimple *target_stmt,\n+\t\t\t  region_model *out) const;\n+\n private:\n   feasibility_state m_state;\n   unsigned m_path_length;"}, {"sha": "1886534313eb6083955ecf99da005ab70c271686", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -203,18 +203,19 @@ class infinite_recursion_diagnostic\n   /* Reject paths in which conjured svalues have affected control flow\n      since m_prev_entry_enode.  */\n \n-  bool check_valid_fpath_p (const feasible_node *final_fnode)\n+  bool check_valid_fpath_p (const feasible_node &final_fnode,\n+\t\t\t    const gimple *)\n     const final override\n   {\n     /* Reject paths in which calls with unknown side effects have occurred\n        since m_prev_entry_enode.\n        Find num calls with side effects.  Walk backward until we reach the\n        pref */\n-    gcc_assert (final_fnode->get_inner_node () == m_new_entry_enode);\n+    gcc_assert (final_fnode.get_inner_node () == m_new_entry_enode);\n \n     /* FG is actually a tree.  Walk backwards from FINAL_FNODE until we\n        reach the prev_entry_enode (or the origin).  */\n-    const feasible_node *iter_fnode = final_fnode;\n+    const feasible_node *iter_fnode = &final_fnode;\n     while (iter_fnode->get_inner_node ()->m_index != 0)\n       {\n \tgcc_assert (iter_fnode->m_preds.length () == 1);"}, {"sha": "d9e9e7f89052b15fa148fc4e0409c1198dd98273", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -351,7 +351,8 @@ class pending_diagnostic\n   /* Vfunc to give diagnostic subclasses the opportunity to reject diagnostics\n      by imposing their own additional feasibility checks on the path to a\n      given feasible_node.  */\n-  virtual bool check_valid_fpath_p (const feasible_node *) const\n+  virtual bool check_valid_fpath_p (const feasible_node &,\n+\t\t\t\t    const gimple *) const\n   {\n     /* Default implementation: accept this path.  */\n     return true;"}, {"sha": "424d83c191f94ac5f6d58ee0a4221e2d57bae605", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcc-rich-location.h\"\n #include \"analyzer/checker-event.h\"\n #include \"analyzer/checker-path.h\"\n+#include \"analyzer/feasible-graph.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -468,9 +469,11 @@ class poisoned_value_diagnostic\n {\n public:\n   poisoned_value_diagnostic (tree expr, enum poison_kind pkind,\n-\t\t\t     const region *src_region)\n+\t\t\t     const region *src_region,\n+\t\t\t     tree check_expr)\n   : m_expr (expr), m_pkind (pkind),\n-    m_src_region (src_region)\n+    m_src_region (src_region),\n+    m_check_expr (check_expr)\n   {}\n \n   const char *get_kind () const final override { return \"poisoned_value_diagnostic\"; }\n@@ -563,10 +566,47 @@ class poisoned_value_diagnostic\n       interest->add_region_creation (m_src_region);\n   }\n \n+  /* Attempt to suppress false positives.\n+     Reject paths where the value of the underlying region isn't poisoned.\n+     This can happen due to state merging when exploring the exploded graph,\n+     where the more precise analysis during feasibility analysis finds that\n+     the region is in fact valid.\n+     To do this we need to get the value from the fgraph.  Unfortunately\n+     we can't simply query the state of m_src_region (from the enode),\n+     since it might be a different region in the fnode state (e.g. with\n+     heap-allocated regions, the numbering could be different).\n+     Hence we access m_check_expr, if available.  */\n+\n+  bool check_valid_fpath_p (const feasible_node &fnode,\n+\t\t\t    const gimple *emission_stmt)\n+    const final override\n+  {\n+    if (!m_check_expr)\n+      return true;\n+\n+    /* We've reached the enode, but not necessarily the right function_point.\n+       Try to get the state at the correct stmt.  */\n+    region_model emission_model (fnode.get_model ().get_manager());\n+    if (!fnode.get_state_at_stmt (emission_stmt, &emission_model))\n+      /* Couldn't get state; accept this diagnostic.  */\n+      return true;\n+\n+    const svalue *fsval = emission_model.get_rvalue (m_check_expr, NULL);\n+    /* Check to see if the expr is also poisoned in FNODE (and in the\n+       same way).  */\n+    const poisoned_svalue * fspval = fsval->dyn_cast_poisoned_svalue ();\n+    if (!fspval)\n+      return false;\n+    if (fspval->get_poison_kind () != m_pkind)\n+      return false;\n+    return true;\n+  }\n+\n private:\n   tree m_expr;\n   enum poison_kind m_pkind;\n   const region *m_src_region;\n+  tree m_check_expr;\n };\n \n /* A subclass of pending_diagnostic for complaining about shifts\n@@ -1050,9 +1090,22 @@ region_model::check_for_poison (const svalue *sval,\n       tree diag_arg = fixup_tree_for_diagnostic (expr);\n       if (src_region == NULL && pkind == POISON_KIND_UNINIT)\n \tsrc_region = get_region_for_poisoned_expr (expr);\n+\n+      /* Can we reliably get the poisoned value from \"expr\"?\n+\t This is for use by poisoned_value_diagnostic::check_valid_fpath_p.\n+\t Unfortunately, we might not have a reliable value for EXPR.\n+\t Hence we only query its value now, and only use it if we get the\n+\t poisoned value back again.  */\n+      tree check_expr = expr;\n+      const svalue *foo_sval = get_rvalue (expr, NULL);\n+      if (foo_sval == sval)\n+\tcheck_expr = expr;\n+      else\n+\tcheck_expr = NULL;\n       if (ctxt->warn (make_unique<poisoned_value_diagnostic> (diag_arg,\n \t\t\t\t\t\t\t      pkind,\n-\t\t\t\t\t\t\t      src_region)))\n+\t\t\t\t\t\t\t      src_region,\n+\t\t\t\t\t\t\t      check_expr)))\n \t{\n \t  /* We only want to report use of a poisoned value at the first\n \t     place it gets used; return an unknown value to avoid generating\n@@ -2486,7 +2539,7 @@ region_model::deref_rvalue (const svalue *ptr_sval, tree ptr_tree,\n \t\t  = as_a <const poisoned_svalue *> (ptr_sval);\n \t\tenum poison_kind pkind = poisoned_sval->get_poison_kind ();\n \t\tctxt->warn (make_unique<poisoned_value_diagnostic>\n-\t\t\t      (ptr, pkind, NULL));\n+\t\t\t      (ptr, pkind, NULL, NULL));\n \t      }\n \t  }\n       }\n@@ -5010,6 +5063,16 @@ region_model::get_or_create_region_for_heap_alloc (const svalue *size_in_bytes,\n      this path.  */\n   auto_bitmap base_regs_in_use;\n   get_referenced_base_regions (base_regs_in_use);\n+\n+  /* Don't reuse regions that are marked as TOUCHED.  */\n+  for (store::cluster_map_t::iterator iter = m_store.begin ();\n+       iter != m_store.end (); ++iter)\n+    if ((*iter).second->touched_p ())\n+      {\n+\tconst region *base_reg = (*iter).first;\n+\tbitmap_set_bit (base_regs_in_use, base_reg->get_id ());\n+      }\n+\n   const region *reg\n     = m_mgr->get_or_create_region_for_heap_alloc (base_regs_in_use);\n   if (size_in_bytes)"}, {"sha": "27eef8369e2f83fa9e07b14a39ec4b61b434e116", "filename": "gcc/testsuite/gcc.dg/analyzer/coreutils-cksum-pr108664.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcoreutils-cksum-pr108664.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcoreutils-cksum-pr108664.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcoreutils-cksum-pr108664.c?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -0,0 +1,80 @@\n+/* Reduced from coreutils's cksum.c: cksum_slice8 */\n+\n+typedef long unsigned int size_t;\n+typedef unsigned int __uint32_t;\n+typedef unsigned long int __uintmax_t;\n+typedef struct _IO_FILE FILE;\n+extern size_t\n+fread_unlocked(void* __restrict __ptr,\n+               size_t __size,\n+               size_t __n,\n+               FILE* __restrict __stream);\n+extern int\n+feof_unlocked(FILE* __stream) __attribute__((__nothrow__, __leaf__));\n+extern int\n+ferror_unlocked(FILE* __stream) __attribute__((__nothrow__, __leaf__));\n+static __inline __uint32_t\n+__bswap_32(__uint32_t __bsx)\n+{\n+\n+  return __builtin_bswap32(__bsx);\n+}\n+typedef __uint32_t uint32_t;\n+typedef unsigned long int uint_fast32_t;\n+typedef __uintmax_t uintmax_t;\n+extern int*\n+__errno_location(void) __attribute__((__nothrow__, __leaf__))\n+__attribute__((__const__));\n+extern uint_fast32_t const crctab[8][256];\n+\n+static _Bool\n+cksum_slice8(FILE* fp, uint_fast32_t* crc_out, uintmax_t* length_out)\n+{\n+  uint32_t buf[(1 << 16) / sizeof(uint32_t)];\n+  uint_fast32_t crc = 0;\n+  uintmax_t length = 0;\n+  size_t bytes_read;\n+\n+  if (!fp || !crc_out || !length_out)\n+    return 0;\n+\n+  while ((bytes_read = fread_unlocked(buf, 1, (1 << 16), fp)) > 0) {\n+    uint32_t* datap;\n+\n+    if (length + bytes_read < length) {\n+\n+      (*__errno_location()) = 75;\n+      return 0;\n+    }\n+    length += bytes_read;\n+\n+    if (bytes_read == 0) {\n+      if (ferror_unlocked(fp))\n+        return 0;\n+    }\n+\n+    datap = (uint32_t*)buf;\n+    while (bytes_read >= 8) {\n+      uint32_t first = *datap++, second = *datap++; /* { dg-bogus \"use of uninitialized value\" \"PR analyzer/108664\" } */\n+      crc ^= __bswap_32(first);\n+      second = __bswap_32(second);\n+      crc =\n+        (crctab[7][(crc >> 24) & 0xFF] ^ crctab[6][(crc >> 16) & 0xFF] ^\n+         crctab[5][(crc >> 8) & 0xFF] ^ crctab[4][(crc)&0xFF] ^\n+         crctab[3][(second >> 24) & 0xFF] ^ crctab[2][(second >> 16) & 0xFF] ^\n+         crctab[1][(second >> 8) & 0xFF] ^ crctab[0][(second)&0xFF]);\n+      bytes_read -= 8;\n+    }\n+\n+    unsigned char* cp = (unsigned char*)datap;\n+    while (bytes_read--)\n+      crc = (crc << 8) ^ crctab[0][((crc >> 24) ^ *cp++) & 0xFF];\n+    if (feof_unlocked(fp))\n+      break;\n+  }\n+\n+  *crc_out = crc;\n+  *length_out = length;\n+\n+  return 1;\n+}"}, {"sha": "9d13fce853191b2cd4cf10dd4ec8964e8d06cd20", "filename": "gcc/testsuite/gcc.dg/analyzer/coreutils-sum-pr108666.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcoreutils-sum-pr108666.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcoreutils-sum-pr108666.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcoreutils-sum-pr108666.c?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -0,0 +1,98 @@\n+/* Reduced from coreutils's sum.c: bsd_sum_stream */\n+\n+typedef long unsigned int size_t;\n+typedef unsigned char __uint8_t;\n+typedef unsigned long int __uintmax_t;\n+typedef struct _IO_FILE FILE;\n+extern size_t\n+fread_unlocked(void* __restrict __ptr,\n+               size_t __size,\n+               size_t __n,\n+               FILE* __restrict __stream);\n+extern int\n+feof_unlocked(FILE* __stream) __attribute__((__nothrow__, __leaf__));\n+extern int\n+ferror_unlocked(FILE* __stream) __attribute__((__nothrow__, __leaf__));\n+extern void*\n+memcpy(void* __restrict __dest, const void* __restrict __src, size_t __n)\n+  __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(1, 2)));\n+extern void\n+rpl_free(void*);\n+extern int*\n+__errno_location(void) __attribute__((__nothrow__, __leaf__))\n+__attribute__((__const__));\n+extern void*\n+malloc(size_t __size) __attribute__((__nothrow__, __leaf__))\n+__attribute__((__malloc__)) __attribute__((__alloc_size__(1)));\n+typedef __uint8_t uint8_t;\n+typedef __uintmax_t uintmax_t;\n+\n+int\n+bsd_sum_stream(FILE* stream, void* resstream, uintmax_t* length)\n+{\n+  int ret = -1;\n+  size_t sum, n;\n+  int checksum = 0;\n+  uintmax_t total_bytes = 0;\n+  static const size_t buffer_length = 32768;\n+  uint8_t* buffer = malloc(buffer_length);\n+\n+  if (!buffer)\n+    return -1;\n+\n+  while (1) {\n+    sum = 0;\n+\n+    while (1) {\n+      n = fread_unlocked(buffer + sum, 1, buffer_length - sum, stream);\n+      sum += n;\n+\n+      if (buffer_length == sum)\n+        break;\n+\n+      if (n == 0) {\n+        if (ferror_unlocked(stream))\n+          goto cleanup_buffer;\n+        goto final_process;\n+      }\n+\n+      if (feof_unlocked(stream))\n+        goto final_process;\n+    }\n+\n+    for (size_t i = 0; i < sum; i++) {\n+      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n+      checksum += buffer[i]; /* { dg-bogus \"use of uninitialized value\" \"PR analyzer/108666\" } */\n+      checksum &= 0xffff;\n+    }\n+    if (total_bytes + sum < total_bytes) {\n+\n+      (*__errno_location()) = 75;\n+      goto cleanup_buffer;\n+    }\n+    total_bytes += sum;\n+  }\n+\n+final_process:;\n+\n+  for (size_t i = 0; i < sum; i++) {\n+    checksum = (checksum >> 1) + ((checksum & 1) << 15);\n+    checksum += buffer[i];  /* { dg-bogus \"use of uninitialized value\" \"PR analyzer/108666\" } */\n+    checksum &= 0xffff;\n+  }\n+  if (total_bytes + sum < total_bytes) {\n+\n+    (*__errno_location()) = 75;\n+    goto cleanup_buffer;\n+  }\n+  total_bytes += sum;\n+\n+  memcpy(resstream, &checksum, sizeof checksum);\n+  *length = total_bytes;\n+  ret = 0;\n+cleanup_buffer:\n+\n+  rpl_free(buffer);\n+  return ret;\n+}\n+"}, {"sha": "33982f0078b54efedf9225d8f7f786271b2ba7f9", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/uninit-pr108725.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Funinit-pr108725.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03a10b0b25cef4928ccead4c8a461d3674dbe86/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Funinit-pr108725.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Funinit-pr108725.c?ref=b03a10b0b25cef4928ccead4c8a461d3674dbe86", "patch": "@@ -0,0 +1,19 @@\n+/* Reduced from an example in qemu-7.2.0: dump/win_dump.c  */\n+\n+#include <stdbool.h>\n+#include <stdint.h>\n+\n+extern int cpu_memory_rw_debug (bool x64, void *ptr);\n+\n+int cpu_read_ptr(bool x64, uint64_t *ptr)\n+{\n+    int ret;\n+    uint32_t ptr32;\n+    uint64_t ptr64;\n+\n+    ret = cpu_memory_rw_debug(x64, x64 ? (void *)&ptr64 : (void *)&ptr32);\n+\n+    *ptr = x64 ? ptr64 : ptr32; /* { dg-bogus \"use of uninitialized value\" } */\n+\n+    return ret;\n+}"}]}