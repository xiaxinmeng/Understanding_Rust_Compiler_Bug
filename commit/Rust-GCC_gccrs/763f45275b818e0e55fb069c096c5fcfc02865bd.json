{"sha": "763f45275b818e0e55fb069c096c5fcfc02865bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYzZjQ1Mjc1YjgxOGUwZTU1ZmIwNjljMDk2YzVmY2ZjMDI4NjViZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-05-01T19:42:01Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-05-01T19:42:01Z"}, "message": "re PR tree-optimization/27144 (segfault with -O2 on x86_64 (and powerpc64))\n\n\tPR tree-optimization/27144\n\t* tree-ssa-loop-niter.c (derive_constant_upper_bound): New function.\n\t(record_estimate): Only record constant upper bound.\n\t(infer_loop_bounds_from_undefined): Call\n\tcompute_estimated_nb_iterations just once.\n\t(proved_non_wrapping_p): Renamed to ...\n\t(n_of_executions_at_most): ... this.  Expect bound to be a constant.\n\t(convert_step_widening, scev_probably_wraps_p): Call\n\tn_of_executions_at_most instead of proved_non_wrapping_p.\n\t(substitute_in_loop_info): Do not replace values in bounds.\n\t* cfgloop.h (struct nb_iter_bound): Remove \"additional\" field.  Update\n\tcomments.\n\n\t* gcc.dg/tree-ssa/loop-16.c: New test.\n\nFrom-SVN: r113425", "tree": {"sha": "f83e87a7a029c987be249cb29870fa982d3c752d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f83e87a7a029c987be249cb29870fa982d3c752d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/763f45275b818e0e55fb069c096c5fcfc02865bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763f45275b818e0e55fb069c096c5fcfc02865bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/763f45275b818e0e55fb069c096c5fcfc02865bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763f45275b818e0e55fb069c096c5fcfc02865bd/comments", "author": null, "committer": null, "parents": [{"sha": "2a83cc52548482af48cd2cebcf9e5248c81d2499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a83cc52548482af48cd2cebcf9e5248c81d2499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a83cc52548482af48cd2cebcf9e5248c81d2499"}], "stats": {"total": 178, "additions": 101, "deletions": 77}, "files": [{"sha": "b7d9e5fbdfa50b3eeccc51e44efc0912e75373ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=763f45275b818e0e55fb069c096c5fcfc02865bd", "patch": "@@ -1,3 +1,18 @@\n+2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27144\n+\t* tree-ssa-loop-niter.c (derive_constant_upper_bound): New function.\n+\t(record_estimate): Only record constant upper bound.\n+\t(infer_loop_bounds_from_undefined): Call\n+\tcompute_estimated_nb_iterations just once.\n+\t(proved_non_wrapping_p): Renamed to ...\n+\t(n_of_executions_at_most): ... this.  Expect bound to be a constant.\n+\t(convert_step_widening, scev_probably_wraps_p): Call\n+\tn_of_executions_at_most instead of proved_non_wrapping_p.\n+\t(substitute_in_loop_info): Do not replace values in bounds.\n+\t* cfgloop.h (struct nb_iter_bound): Remove \"additional\" field.  Update\n+\tcomments.\n+\n 2006-05-01  Richard Henderson  <rth@redhat.com>\n \n \tPR c/27358"}, {"sha": "f04c5d6812cb6fd1997101a2928e7ee53f441423", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=763f45275b818e0e55fb069c096c5fcfc02865bd", "patch": "@@ -47,12 +47,10 @@ struct lpt_decision\n \n struct nb_iter_bound\n {\n-  tree bound;\t\t/* The expression whose value is an upper bound on the\n-\t\t\t   number of executions of anything after ...  */\n-  tree at_stmt;\t\t/* ... this statement during one execution of loop.  */\n-  tree additional;\t/* A conjunction of conditions the operands of BOUND\n-\t\t\t   satisfy.  The additional information about the value\n-\t\t\t   of the bound may be derived from it.  */\n+  tree bound;\t\t/* The constant expression whose value is an upper\n+\t\t\t   bound on the number of executions of ...  */\n+  tree at_stmt;\t\t/* ... this statement during one execution of\n+\t\t\t   a loop.  */\n   struct nb_iter_bound *next;\n \t\t\t/* The next bound in a list.  */\n };"}, {"sha": "42c96f1005b583ed6fcbc72d5271e733b8750476", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=763f45275b818e0e55fb069c096c5fcfc02865bd", "patch": "@@ -1,3 +1,7 @@\n+2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-16.c: New test.\n+\n 2006-05-01  Roger Sayle  <roger@eyesopen.com>\n \t    Joseph S. Myers  <joseph@codesourcery.com>\n "}, {"sha": "50fa333303be3e1795215dfd1b6d616b6534786d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-16.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-16.c?ref=763f45275b818e0e55fb069c096c5fcfc02865bd", "patch": "@@ -0,0 +1,24 @@\n+/* A test for # of iterations estimation.  We know that the loop is executed\n+   at most 100 times, thus the (32-bit) induction variables do not overflow,\n+   and we may use 64-bit variable to represent them.  */\n+\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-do compile { target x86_64-*-* } } */\n+\n+unsigned a[100];\n+\n+void foo(unsigned n)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = 4 * i;\n+}\n+\n+/* Check that the memory reference was replaced with MEM, and that there is no\n+   multiplication.  */\n+\n+/* { dg-final { scan-tree-dump-times \"MEM\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\[^\\\\n\\\\r\\]*= \\\\* \" 0 \"optimized\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6404c7552e373add51b5f63999a8b68304cd4818", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 54, "deletions": 71, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/763f45275b818e0e55fb069c096c5fcfc02865bd/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=763f45275b818e0e55fb069c096c5fcfc02865bd", "patch": "@@ -1464,26 +1464,46 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n \n */\n \n+/* Returns a constant upper bound on the value of expression VAL.  The\n+   condition ADDITIONAL must be satisfied (for example, if VAL is\n+   \"(unsigned) n\" and ADDITIONAL is \"n > 0\", then we can derive that\n+   VAL is at most (unsigned) MAX_INT).\n+ \n+   TODO -- actually do something nontrivial here.  */\n+\n+static tree\n+derive_constant_upper_bound (tree val, tree additional ATTRIBUTE_UNUSED)\n+{\n+  tree type = TREE_TYPE (val);\n+  tree unsigned_type = unsigned_type_for (type);\n+\n+  if (TREE_CODE (val) != INTEGER_CST)\n+    val = upper_bound_in_type (type, type);\n+  return fold_convert (unsigned_type, val);\n+}\n+\n /* Records that AT_STMT is executed at most BOUND times in LOOP.  The\n    additional condition ADDITIONAL is recorded with the bound.  */\n \n void\n record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt)\n {\n   struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n+  tree c_bound = derive_constant_upper_bound (bound, additional);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Statements after \");\n       print_generic_expr (dump_file, at_stmt, TDF_SLIM);\n       fprintf (dump_file, \" are executed at most \");\n       print_generic_expr (dump_file, bound, TDF_SLIM);\n-      fprintf (dump_file, \" times in loop %d.\\n\", loop->num);\n+      fprintf (dump_file, \" (bounded by \");\n+      print_generic_expr (dump_file, c_bound, TDF_SLIM);\n+      fprintf (dump_file, \") times in loop %d.\\n\", loop->num);\n     }\n \n-  elt->bound = bound;\n+  elt->bound = c_bound;\n   elt->at_stmt = at_stmt;\n-  elt->additional = additional;\n   elt->next = loop->bounds;\n   loop->bounds = elt;\n }\n@@ -1497,12 +1517,16 @@ compute_estimated_nb_iterations (struct loop *loop)\n   struct nb_iter_bound *bound;\n   \n   for (bound = loop->bounds; bound; bound = bound->next)\n-    if (TREE_CODE (bound->bound) == INTEGER_CST\n-\t/* Update only when there is no previous estimation.  */\n-\t&& (chrec_contains_undetermined (loop->estimated_nb_iterations)\n-\t    /* Or when the current estimation is smaller.  */\n-\t    || tree_int_cst_lt (bound->bound, loop->estimated_nb_iterations)))\n-      loop->estimated_nb_iterations = bound->bound;\n+    {\n+      if (TREE_CODE (bound->bound) != INTEGER_CST)\n+\tcontinue;\n+\n+      /* Update only when there is no previous estimation, or when the current\n+\t estimation is smaller.  */\n+      if (chrec_contains_undetermined (loop->estimated_nb_iterations)\n+\t  || tree_int_cst_lt (bound->bound, loop->estimated_nb_iterations))\n+\tloop->estimated_nb_iterations = bound->bound;\n+    }\n }\n \n /* The following analyzers are extracting informations on the bounds\n@@ -1611,11 +1635,9 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n \t      break;\n \t    }\n \t}\n-\n-      if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n-\tcompute_estimated_nb_iterations (loop);\n     }\n \n+  compute_estimated_nb_iterations (loop);\n   free (bbs);\n }\n \n@@ -1729,73 +1751,41 @@ stmt_dominates_stmt_p (tree s1, tree s2)\n   return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n }\n \n-/* Return true when it is possible to prove that the induction\n-   variable does not wrap: vary outside the type specified bounds.\n-   Checks whether BOUND < VALID_NITER that means in the context of iv\n-   conversion that all the iterations in the loop are safe: not\n-   producing wraps.\n-\n-   The statement NITER_BOUND->AT_STMT is executed at most\n-   NITER_BOUND->BOUND times in the loop.\n-   \n-   NITER_BOUND->ADDITIONAL is the additional condition recorded for\n-   operands of the bound.  This is useful in the following case,\n-   created by loop header copying:\n-\n-   i = 0;\n-   if (n > 0)\n-     do\n-       {\n-         something;\n-       } while (++i < n)\n-\n-   If the n > 0 condition is taken into account, the number of iterations of the\n-   loop can be expressed as n - 1.  If the type of n is signed, the ADDITIONAL\n-   assumption \"n > 0\" says us that the value of the number of iterations is at\n-   most MAX_TYPE - 1 (without this assumption, it might overflow).  */\n+/* Returns true when we can prove that the number of executions of\n+   STMT in the loop is at most NITER, according to the fact\n+   that the statement NITER_BOUND->at_stmt is executed at most\n+   NITER_BOUND->bound times.  */\n \n static bool\n-proved_non_wrapping_p (tree at_stmt,\n-\t\t       struct nb_iter_bound *niter_bound, \n-\t\t       tree new_type,\n-\t\t       tree valid_niter)\n+n_of_executions_at_least (tree stmt,\n+\t\t\t  struct nb_iter_bound *niter_bound, \n+\t\t\t  tree niter)\n {\n   tree cond;\n   tree bound = niter_bound->bound;\n+  tree bound_type = TREE_TYPE (bound);\n+  tree nit_type = TREE_TYPE (niter);\n   enum tree_code cmp;\n \n-  if (TYPE_PRECISION (new_type) > TYPE_PRECISION (TREE_TYPE (bound)))\n-    bound = fold_convert (unsigned_type_for (new_type), bound);\n+  gcc_assert (TYPE_UNSIGNED (bound_type)\n+\t      && TYPE_UNSIGNED (nit_type)\n+\t      && is_gimple_min_invariant (bound));\n+  if (TYPE_PRECISION (nit_type) > TYPE_PRECISION (bound_type))\n+    bound = fold_convert (nit_type, bound);\n   else\n-    valid_niter = fold_convert (TREE_TYPE (bound), valid_niter);\n-\n-  /* Give up if BOUND was not folded to an INTEGER_CST, as in PR23434.  */\n-  if (TREE_CODE (bound) != INTEGER_CST)\n-    return false;\n+    niter = fold_convert (bound_type, niter);\n \n   /* After the statement niter_bound->at_stmt we know that anything is\n      executed at most BOUND times.  */\n-  if (at_stmt && stmt_dominates_stmt_p (niter_bound->at_stmt, at_stmt))\n+  if (stmt && stmt_dominates_stmt_p (niter_bound->at_stmt, stmt))\n     cmp = GE_EXPR;\n   /* Before the statement niter_bound->at_stmt we know that anything\n      is executed at most BOUND + 1 times.  */\n   else\n     cmp = GT_EXPR;\n \n-  cond = fold_binary (cmp, boolean_type_node, valid_niter, bound);\n-  if (nonzero_p (cond))\n-    return true;\n-\n-  cond = build2 (cmp, boolean_type_node, valid_niter, bound);\n-  /* Try taking additional conditions into account.  */\n-  cond = fold_binary (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t      invert_truthvalue (niter_bound->additional),\n-\t\t      cond);\n-\n-  if (nonzero_p (cond))\n-    return true;\n-\n-  return false;\n+  cond = fold_binary (cmp, boolean_type_node, niter, bound);\n+  return nonzero_p (cond);\n }\n \n /* Checks whether it is correct to count the induction variable BASE +\n@@ -1873,7 +1863,7 @@ convert_step_widening (struct loop *loop, tree new_type, tree base, tree step,\n \n   estimate_numbers_of_iterations_loop (loop);\n   for (bound = loop->bounds; bound; bound = bound->next)\n-    if (proved_non_wrapping_p (at_stmt, bound, new_type, valid_niter))\n+    if (n_of_executions_at_least (at_stmt, bound, valid_niter))\n       return step_in_new_type;\n \n   /* Fail when the loop has no bound estimations, or when no bound can\n@@ -2077,7 +2067,7 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n \n   estimate_numbers_of_iterations_loop (loop);\n   for (bound = loop->bounds; bound; bound = bound->next)\n-    if (proved_non_wrapping_p (at_stmt, bound, type, valid_niter))\n+    if (n_of_executions_at_least (at_stmt, bound, valid_niter))\n       return false;\n \n   /* At this point we still don't have a proof that the iv does not\n@@ -2162,14 +2152,7 @@ free_numbers_of_iterations_estimates (struct loops *loops)\n void\n substitute_in_loop_info (struct loop *loop, tree name, tree val)\n {\n-  struct nb_iter_bound *bound;\n-\n   loop->nb_iterations = simplify_replace_tree (loop->nb_iterations, name, val);\n   loop->estimated_nb_iterations\n \t  = simplify_replace_tree (loop->estimated_nb_iterations, name, val);\n-  for (bound = loop->bounds; bound; bound = bound->next)\n-    {\n-      bound->bound = simplify_replace_tree (bound->bound, name, val);\n-      bound->additional = simplify_replace_tree (bound->additional, name, val);\n-    }\n }"}]}