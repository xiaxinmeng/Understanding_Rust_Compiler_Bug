{"sha": "87afc7b81cd44d04997add383856b2504af3afe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdhZmM3YjgxY2Q0NGQwNDk5N2FkZDM4Mzg1NmIyNTA0YWYzYWZlNg==", "commit": {"author": {"name": "Hongyu Wang", "email": "hongyu.wang@intel.com", "date": "2021-08-17T08:53:46Z"}, "committer": {"name": "Hongyu Wang", "email": "hongyu.wang@intel.com", "date": "2021-08-25T09:03:46Z"}, "message": "i386: Optimize lea with zero-extend. [PR 101716]\n\nFor ASHIFT + ZERO_EXTEND pattern, combine pass failed to\nmatch it to lea since it will generate non-canonical\nzero-extend. Adjust predicate and cost_model to allow combine\nfor lea.\n\ngcc/ChangeLog:\n\n\tPR target/101716\n\t* config/i386/i386.c (ix86_live_on_entry): Adjust comment.\n\t(ix86_decompose_address): Remove retval check for ASHIFT,\n\tallow non-canonical zero extend if AND mask covers ASHIFT\n\tcount.\n\t(ix86_legitimate_address_p): Adjust condition for decompose.\n\t(ix86_rtx_costs): Adjust cost for lea with non-canonical\n\tzero-extend.\n\n\tCo-Authored by: Uros Bizjak <ubizjak@gmail.com>\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/101716\n\t* gcc.target/i386/pr101716.c: New test.", "tree": {"sha": "14de7ac8597c4f85f059fe75a1564ce34df40fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14de7ac8597c4f85f059fe75a1564ce34df40fd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87afc7b81cd44d04997add383856b2504af3afe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87afc7b81cd44d04997add383856b2504af3afe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87afc7b81cd44d04997add383856b2504af3afe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87afc7b81cd44d04997add383856b2504af3afe6/comments", "author": {"login": "wwwhhhyyy", "id": 5366075, "node_id": "MDQ6VXNlcjUzNjYwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5366075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wwwhhhyyy", "html_url": "https://github.com/wwwhhhyyy", "followers_url": "https://api.github.com/users/wwwhhhyyy/followers", "following_url": "https://api.github.com/users/wwwhhhyyy/following{/other_user}", "gists_url": "https://api.github.com/users/wwwhhhyyy/gists{/gist_id}", "starred_url": "https://api.github.com/users/wwwhhhyyy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wwwhhhyyy/subscriptions", "organizations_url": "https://api.github.com/users/wwwhhhyyy/orgs", "repos_url": "https://api.github.com/users/wwwhhhyyy/repos", "events_url": "https://api.github.com/users/wwwhhhyyy/events{/privacy}", "received_events_url": "https://api.github.com/users/wwwhhhyyy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wwwhhhyyy", "id": 5366075, "node_id": "MDQ6VXNlcjUzNjYwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5366075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wwwhhhyyy", "html_url": "https://github.com/wwwhhhyyy", "followers_url": "https://api.github.com/users/wwwhhhyyy/followers", "following_url": "https://api.github.com/users/wwwhhhyyy/following{/other_user}", "gists_url": "https://api.github.com/users/wwwhhhyyy/gists{/gist_id}", "starred_url": "https://api.github.com/users/wwwhhhyyy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wwwhhhyyy/subscriptions", "organizations_url": "https://api.github.com/users/wwwhhhyyy/orgs", "repos_url": "https://api.github.com/users/wwwhhhyyy/repos", "events_url": "https://api.github.com/users/wwwhhhyyy/events{/privacy}", "received_events_url": "https://api.github.com/users/wwwhhhyyy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075"}], "stats": {"total": 47, "additions": 41, "deletions": 6}, "files": [{"sha": "ddbbbceded160d559e9cbd273cf1756ea858b32b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87afc7b81cd44d04997add383856b2504af3afe6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87afc7b81cd44d04997add383856b2504af3afe6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=87afc7b81cd44d04997add383856b2504af3afe6", "patch": "@@ -10018,8 +10018,7 @@ ix86_live_on_entry (bitmap regs)\n \f\n /* Extract the parts of an RTL expression that is a valid memory address\n    for an instruction.  Return 0 if the structure of the address is\n-   grossly off.  Return -1 if the address contains ASHIFT, so it is not\n-   strictly valid, but still used for computing length of lea instruction.  */\n+   grossly off.  */\n \n int\n ix86_decompose_address (rtx addr, struct ix86_address *out)\n@@ -10029,7 +10028,6 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n   HOST_WIDE_INT scale = 1;\n   rtx scale_rtx = NULL_RTX;\n   rtx tmp;\n-  int retval = 1;\n   addr_space_t seg = ADDR_SPACE_GENERIC;\n \n   /* Allow zero-extended SImode addresses,\n@@ -10053,6 +10051,27 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t  if (CONST_INT_P (addr))\n \t    return 0;\n \t}\n+      else if (GET_CODE (addr) == AND)\n+\t{\n+\t  /* For ASHIFT inside AND, combine will not generate\n+\t     canonical zero-extend. Merge mask for AND and shift_count\n+\t     to check if it is canonical zero-extend.  */\n+\t  tmp = XEXP (addr, 0);\n+\t  rtx mask = XEXP (addr, 1);\n+\t  if (tmp && GET_CODE(tmp) == ASHIFT)\n+\t    {\n+\t      rtx shift_val = XEXP (tmp, 1);\n+\t      if (CONST_INT_P (mask) && CONST_INT_P (shift_val)\n+\t\t  && (((unsigned HOST_WIDE_INT) INTVAL(mask)\n+\t\t      | ((HOST_WIDE_INT_1U << INTVAL(shift_val)) - 1))\n+\t\t      == 0xffffffff))\n+\t\t{\n+\t\t  addr = lowpart_subreg (SImode, XEXP (addr, 0),\n+\t\t\t\t\t DImode);\n+\t\t}\n+\t    }\n+\n+\t}\n     }\n \n   /* Allow SImode subregs of DImode addresses,\n@@ -10179,7 +10198,6 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n       if ((unsigned HOST_WIDE_INT) scale > 3)\n \treturn 0;\n       scale = 1 << scale;\n-      retval = -1;\n     }\n   else\n     disp = addr;\t\t\t/* displacement */\n@@ -10252,7 +10270,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n   out->scale = scale;\n   out->seg = seg;\n \n-  return retval;\n+  return 1;\n }\n \f\n /* Return cost of the memory address x.\n@@ -10765,7 +10783,7 @@ ix86_legitimate_address_p (machine_mode, rtx addr, bool strict)\n   HOST_WIDE_INT scale;\n   addr_space_t seg;\n \n-  if (ix86_decompose_address (addr, &parts) <= 0)\n+  if (ix86_decompose_address (addr, &parts) == 0)\n     /* Decomposition failed.  */\n     return false;\n \n@@ -20419,6 +20437,12 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t               << (GET_MODE (XEXP (x, 1)) != DImode)));\n \t  return true;\n \t}\n+      else if (code == AND\n+\t       && address_no_seg_operand (x, mode))\n+\t{\n+\t  *total = cost->lea;\n+\t  return true;\n+\t}\n       /* FALLTHRU */\n \n     case NEG:"}, {"sha": "5e3ea64a3201abf2086e464e2c6b2b930c133bb1", "filename": "gcc/testsuite/gcc.target/i386/pr101716.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87afc7b81cd44d04997add383856b2504af3afe6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101716.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87afc7b81cd44d04997add383856b2504af3afe6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101716.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101716.c?ref=87afc7b81cd44d04997add383856b2504af3afe6", "patch": "@@ -0,0 +1,11 @@\n+/* PR target/101716 */\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+/* { dg-final { scan-assembler \"leal\\[\\\\t \\]\\[^\\\\n\\]*eax\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[\\\\t \\]\\[^\\\\n\\]*eax\" } } */\n+\n+unsigned long long sample1(unsigned long long m) {\n+    unsigned int t = -1;\n+    return (m << 1) & t;\n+}"}]}