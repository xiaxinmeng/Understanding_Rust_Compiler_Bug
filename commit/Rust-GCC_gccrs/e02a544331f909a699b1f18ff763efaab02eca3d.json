{"sha": "e02a544331f909a699b1f18ff763efaab02eca3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyYTU0NDMzMWY5MDlhNjk5YjFmMThmZjc2M2VmYWFiMDJlY2EzZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-11-22T00:40:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-11-22T00:40:47Z"}, "message": "functional (is_placeholder, [...]): Add partial specializations for cv-qualified types.\n\n\t* include/std/functional (is_placeholder, is_bind_expression): Add\n\tpartial specializations for cv-qualified types.\n\t* include/tr1/functional (is_placeholder, is_bind_expression): Add\n\tpartial specializations for std::bind and std::placeholders and for\n\tcv-qualified types.\n\t* testsuite/20_util/bind/cv_quals_3.cc: New.\n\t* testsuite/tr1/3_function_objects/bind/cv_quals.cc: New.\n\t* testsuite/tr1/3_function_objects/bind/mixed.cc: New.\n\nFrom-SVN: r181607", "tree": {"sha": "ff0ebe47c171d37657b22137dfb8a390314ff92b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff0ebe47c171d37657b22137dfb8a390314ff92b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e02a544331f909a699b1f18ff763efaab02eca3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02a544331f909a699b1f18ff763efaab02eca3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02a544331f909a699b1f18ff763efaab02eca3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02a544331f909a699b1f18ff763efaab02eca3d/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "284953181c8c0d879569bbd6f0a25159026d39b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284953181c8c0d879569bbd6f0a25159026d39b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284953181c8c0d879569bbd6f0a25159026d39b2"}], "stats": {"total": 513, "additions": 500, "deletions": 13}, "files": [{"sha": "3cdc64d9e93f7f0459908e642d0f09626a80c476", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e02a544331f909a699b1f18ff763efaab02eca3d", "patch": "@@ -1,3 +1,14 @@\n+2011-11-21  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/std/functional (is_placeholder, is_bind_expression): Add\n+\tpartial specializations for cv-qualified types.\n+\t* include/tr1/functional (is_placeholder, is_bind_expression): Add\n+\tpartial specializations for std::bind and std::placeholders and for\n+\tcv-qualified types.\n+\t* testsuite/20_util/bind/cv_quals_3.cc: New.\n+\t* testsuite/tr1/3_function_objects/bind/cv_quals.cc: New.\n+\t* testsuite/tr1/3_function_objects/bind/mixed.cc: New.\n+\n 2011-11-21  Andreas Tobler  <andreast@fgznet.ch>\n \n \t* configure: Regenerate."}, {"sha": "465fc569b23cfde5afb437888812b6e30c3ad3d1", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=e02a544331f909a699b1f18ff763efaab02eca3d", "patch": "@@ -843,22 +843,24 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     : public integral_constant<int, 0>\n     { };\n \n-  /// The type of placeholder objects defined by libstdc++.\n+  /** @brief The type of placeholder objects defined by libstdc++.\n+   *  @ingroup binders\n+   */\n   template<int _Num> struct _Placeholder { };\n \n   _GLIBCXX_END_NAMESPACE_VERSION\n \n   /** @namespace std::placeholders\n-   *  @brief ISO C++ 0x entities sub namespace for functional.\n+   *  @brief ISO C++11 entities sub-namespace for functional.\n    *  @ingroup binders\n-   *\n-   *  Define a large number of placeholders. There is no way to\n-   *  simplify this with variadic templates, because we're introducing\n-   *  unique names for each.\n    */\n   namespace placeholders\n   {\n   _GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  /* Define a large number of placeholders. There is no way to\n+   * simplify this with variadic templates, because we're introducing\n+   * unique names for each.\n+   */\n     extern const _Placeholder<1> _1;\n     extern const _Placeholder<2> _2;\n     extern const _Placeholder<3> _3;\n@@ -903,6 +905,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     : public integral_constant<int, _Num>\n     { };\n \n+  template<int _Num>\n+    struct is_placeholder<const _Placeholder<_Num> >\n+    : public integral_constant<int, _Num>\n+    { };\n+\n   /**\n    * Used by _Safe_tuple_element to indicate that there is no tuple\n    * element at this position.\n@@ -1424,8 +1431,56 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    *  @brief Class template _Bind is always a bind expression.\n    *  @ingroup binders\n    */\n+  template<typename _Signature>\n+    struct is_bind_expression<const _Bind<_Signature> >\n+    : public true_type { };\n+\n+  /**\n+   *  @brief Class template _Bind is always a bind expression.\n+   *  @ingroup binders\n+   */\n+  template<typename _Signature>\n+    struct is_bind_expression<volatile _Bind<_Signature> >\n+    : public true_type { };\n+\n+  /**\n+   *  @brief Class template _Bind is always a bind expression.\n+   *  @ingroup binders\n+   */\n+  template<typename _Signature>\n+    struct is_bind_expression<const volatile _Bind<_Signature>>\n+    : public true_type { };\n+\n+  /**\n+   *  @brief Class template _Bind_result is always a bind expression.\n+   *  @ingroup binders\n+   */\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<_Bind_result<_Result, _Signature>>\n+    : public true_type { };\n+\n+  /**\n+   *  @brief Class template _Bind_result is always a bind expression.\n+   *  @ingroup binders\n+   */\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<const _Bind_result<_Result, _Signature>>\n+    : public true_type { };\n+\n+  /**\n+   *  @brief Class template _Bind_result is always a bind expression.\n+   *  @ingroup binders\n+   */\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>\n+    : public true_type { };\n+\n+  /**\n+   *  @brief Class template _Bind_result is always a bind expression.\n+   *  @ingroup binders\n+   */\n   template<typename _Result, typename _Signature>\n-    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n+    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>\n     : public true_type { };\n \n   // Trait type used to remove std::bind() from overload set via SFINAE"}, {"sha": "ff2bd2a7134b2b4acd5a3cc954e617a1f598f9ff", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 170, "deletions": 6, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=e02a544331f909a699b1f18ff763efaab02eca3d", "patch": "@@ -43,9 +43,20 @@\n #include <tr1/functional_hash.h>\n #include <ext/type_traits.h>\n #include <bits/move.h> // for std::__addressof\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  include <type_traits> // for integral_constant, true_type, false_type\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<int> struct _Placeholder;\n+  template<typename> class _Bind;\n+  template<typename, typename> class _Bind_result;\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif\n+\n namespace tr1\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -847,16 +858,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n _GLIBCXX_END_NAMESPACE_VERSION\n \n-  /** @namespace std::placeholders\n-   *  @brief ISO C++ 0x entities sub namespace for functional.\n-   *\n-   *  Define a large number of placeholders. There is no way to\n-   *  simplify this with variadic templates, because we're introducing\n-   *  unique names for each.\n+  /** @namespace std::tr1::placeholders\n+   *  @brief Sub-namespace for tr1/functional.\n    */\n   namespace placeholders \n   { \n   _GLIBCXX_BEGIN_NAMESPACE_VERSION\n+    /*  Define a large number of placeholders. There is no way to\n+     *  simplify this with variadic templates, because we're introducing\n+     *  unique names for each.\n+     */\n     namespace \n     {\n       _Placeholder<1> _1;\n@@ -904,6 +915,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<int _Num>\n     const int is_placeholder<_Placeholder<_Num> >::value;\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<int _Num>\n+    struct is_placeholder<std::_Placeholder<_Num>>\n+    : std::integral_constant<int, _Num>\n+    { };\n+\n+  template<int _Num>\n+    struct is_placeholder<const std::_Placeholder<_Num>>\n+    : std::integral_constant<int, _Num>\n+    { };\n+#endif\n+\n   /**\n    * Stores a tuple of indices. Used by bind() to extract the elements\n    * in a tuple. \n@@ -1347,6 +1370,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Signature>\n     const bool is_bind_expression<_Bind<_Signature> >::value;\n \n+  /// Class template _Bind is always a bind expression.\n+  template<typename _Signature>\n+    struct is_bind_expression<const _Bind<_Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Signature>\n+    const bool is_bind_expression<const _Bind<_Signature> >::value;\n+\n+  /// Class template _Bind is always a bind expression.\n+  template<typename _Signature>\n+    struct is_bind_expression<volatile _Bind<_Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Signature>\n+    const bool is_bind_expression<volatile _Bind<_Signature> >::value;\n+\n+  /// Class template _Bind is always a bind expression.\n+  template<typename _Signature>\n+    struct is_bind_expression<const volatile _Bind<_Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Signature>\n+    const bool is_bind_expression<const volatile _Bind<_Signature> >::value;\n+\n   /// Class template _Bind_result is always a bind expression.\n   template<typename _Result, typename _Signature>\n     struct is_bind_expression<_Bind_result<_Result, _Signature> >\n@@ -1355,6 +1402,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Result, typename _Signature>\n     const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n \n+  /// Class template _Bind_result is always a bind expression.\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<const _Bind_result<_Result, _Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Result, typename _Signature>\n+    const bool\n+    is_bind_expression<const _Bind_result<_Result, _Signature> >::value;\n+\n+  /// Class template _Bind_result is always a bind expression.\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<volatile _Bind_result<_Result, _Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Result, typename _Signature>\n+    const bool\n+    is_bind_expression<volatile _Bind_result<_Result, _Signature> >::value;\n+\n+  /// Class template _Bind_result is always a bind expression.\n+  template<typename _Result, typename _Signature>\n+    struct\n+    is_bind_expression<const volatile _Bind_result<_Result, _Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Result, typename _Signature>\n+    const bool\n+    is_bind_expression<const volatile _Bind_result<_Result,\n+                                                   _Signature> >::value;\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Signature>\n+    struct is_bind_expression<std::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<const std::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<volatile std::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<const volatile std::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<std::_Bind_result<_Result, _Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<const std::_Bind_result<_Result, _Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<volatile std::_Bind_result<_Result, _Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<const volatile std::_Bind_result<_Result,\n+                                                               _Signature>>\n+    : true_type { };\n+#endif\n+\n   /// bind\n   template<typename _Functor, typename... _ArgTypes>\n     inline\n@@ -2147,6 +2258,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n _GLIBCXX_END_NAMESPACE_VERSION\n }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename> struct is_placeholder;\n+\n+  template<int _Num>\n+    struct is_placeholder<tr1::_Placeholder<_Num>>\n+    : integral_constant<int, _Num>\n+    { };\n+\n+  template<int _Num>\n+    struct is_placeholder<const tr1::_Placeholder<_Num>>\n+    : integral_constant<int, _Num>\n+    { };\n+\n+  template<typename> struct is_bind_expression;\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<tr1::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<const tr1::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<volatile tr1::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Signature>\n+    struct is_bind_expression<const volatile tr1::_Bind<_Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<tr1::_Bind_result<_Result, _Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<const tr1::_Bind_result<_Result, _Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<volatile tr1::_Bind_result<_Result, _Signature>>\n+    : true_type { };\n+\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<const volatile tr1::_Bind_result<_Result,\n+                                                               _Signature>>\n+    : true_type { };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif\n }\n \n #endif // _GLIBCXX_TR1_FUNCTIONAL"}, {"sha": "6affa1168e23fe956f8a14ce093e0933eabca8a2", "filename": "libstdc++-v3/testsuite/20_util/bind/cv_quals_3.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals_3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals_3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals_3.cc?ref=e02a544331f909a699b1f18ff763efaab02eca3d", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+\n+struct X\n+{\n+  int operator()() const { return 0; }\n+  int operator()() volatile { return 1; }\n+  int operator()() const volatile { return 2; }\n+  void operator()() { };\n+};\n+\n+void test01()\n+{\n+  static_assert( std::is_placeholder<decltype(std::placeholders::_1)>::value,\n+                 \"decltype(_1) is a placeholder type\" );\n+\n+  const auto b0 = std::bind(X());\n+  static_assert( std::is_bind_expression<decltype(b0)>::value,\n+                 \"const-qualified wrapper is a bind expression\" );\n+\n+  volatile auto b1 = std::bind(X());\n+  static_assert( std::is_bind_expression<decltype(b1)>::value,\n+                 \"volatile-qualified wrapper is a bind expression\" );\n+\n+  const volatile auto b2 = std::bind(X());\n+  static_assert( std::is_bind_expression<decltype(b2)>::value,\n+                 \"const-volatile-qualified wrapper is a bind expression\" );\n+\n+  const auto b3 = std::bind<int>(X());\n+  static_assert( std::is_bind_expression<decltype(b3)>::value,\n+                 \"const-qualified wrapper is a bind expression\" );\n+\n+  volatile auto b4 = std::bind<int>(X());\n+  static_assert( std::is_bind_expression<decltype(b4)>::value,\n+                 \"volatile-qualified wrapper is a bind expression\" );\n+\n+  const volatile auto b5 = std::bind<int>(X());\n+  static_assert( std::is_bind_expression<decltype(b5)>::value,\n+                 \"const-volatile-qualified wrapper is a bind expression\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "5ea373647fcf5fb6b9bb6996f3a0cbbedacbeebc", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/bind/cv_quals.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fbind%2Fcv_quals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fbind%2Fcv_quals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fbind%2Fcv_quals.cc?ref=e02a544331f909a699b1f18ff763efaab02eca3d", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <tr1/functional>\n+\n+struct X\n+{\n+  int operator()() const { return 0; }\n+  int operator()() volatile { return 1; }\n+  int operator()() const volatile { return 2; }\n+  void operator()() { };\n+};\n+\n+void test01()\n+{\n+  static_assert( std::tr1::is_placeholder<__typeof(std::tr1::placeholders::_1)>::value,\n+                 \"decltype(_1) is a placeholder type\" );\n+\n+  const auto b0 = std::tr1::bind(X());\n+  static_assert( std::tr1::is_bind_expression<__typeof(b0)>::value,\n+                 \"const-qualified wrapper is a bind expression\" );\n+\n+  volatile auto b1 = std::tr1::bind(X());\n+  static_assert( std::tr1::is_bind_expression<__typeof(b1)>::value,\n+                 \"volatile-qualified wrapper is a bind expression\" );\n+\n+  const volatile auto b2 = std::tr1::bind(X());\n+  static_assert( std::tr1::is_bind_expression<__typeof(b2)>::value,\n+                 \"const-volatile-qualified wrapper is a bind expression\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2d96bb7ec86a65c893bfd6965b02271453a6463c", "filename": "libstdc++-v3/testsuite/tr1/3_function_objects/bind/mixed.cc", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fbind%2Fmixed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02a544331f909a699b1f18ff763efaab02eca3d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fbind%2Fmixed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F3_function_objects%2Fbind%2Fmixed.cc?ref=e02a544331f909a699b1f18ff763efaab02eca3d", "patch": "@@ -0,0 +1,139 @@\n+// { dg-options \"-std=gnu++11\" }\n+// 2011-11-20 Jonathan Wakely <jwakely.gcc -at- gmail.com>\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 3.6 function object binders\n+#include <tr1/functional>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+// std::tr1::bind and std::bind should work together\n+\n+namespace p1 = std::placeholders;\n+namespace p2 = std::tr1::placeholders;\n+\n+using std::multiplies;\n+using std::minus;\n+\n+void test01()\n+{\n+  static_assert( std::is_placeholder<decltype(p2::_2)>::value == 2,\n+      \"TR1 placeholder is a std placeholder\" );\n+  static_assert( std::tr1::is_placeholder<decltype(p1::_1)>::value == 1,\n+      \"std placeholder is a TR2 placeholder\" );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  auto b1 = std::bind(minus<int>(), 6, p2::_2);\n+  auto b2 = std::tr1::bind(minus<int>(), 6, p1::_2);\n+\n+  int five = 5;\n+  int seven = 7;\n+\n+  VERIFY( std::tr1::bind(multiplies<int>(), p1::_1, b1)(five, seven) == -5 );\n+  VERIFY( std::bind(multiplies<int>(), p2::_1, b2)(seven, five) == 7 );\n+\n+  VERIFY( std::tr1::bind<int>(multiplies<int>(), p1::_1, b1)(five, seven) == -5 );\n+  VERIFY( std::bind<int>(multiplies<int>(), p2::_1, b2)(seven, five) == 7 );\n+\n+  static_assert( std::is_bind_expression<decltype(b2)>::value,\n+      \"TR1 bind expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(b1)>::value,\n+      \"std bind expression is a TR2 bind expression\" );\n+\n+  const auto c1 = b1;\n+  const auto c2 = b2;\n+\n+  static_assert( std::is_bind_expression<decltype(c2)>::value,\n+      \"const TR1 bind expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(c1)>::value,\n+      \"const std bind expression is a TR2 bind expression\" );\n+\n+  volatile auto v1 = b1;\n+  volatile auto v2 = b2;\n+\n+  static_assert( std::is_bind_expression<decltype(v2)>::value,\n+      \"volatile TR1 bind expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(v1)>::value,\n+      \"volatile std bind expression is a TR2 bind expression\" );\n+\n+  const volatile auto cv1 = b1;\n+  const volatile auto cv2 = b2;\n+\n+  static_assert( std::is_bind_expression<decltype(cv2)>::value,\n+      \"const volatile TR1 bind expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(cv1)>::value,\n+      \"const volatile std bind expression is a TR2 bind expression\" );\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  auto b1 = std::bind<int>(minus<int>(), 6, p2::_2);\n+  auto b2 = std::tr1::bind<int>(minus<int>(), 6, p1::_2);\n+\n+  int five = 5;\n+  int seven = 7;\n+  VERIFY( std::tr1::bind(multiplies<int>(), p1::_1, b1)(five, seven) == -5 );\n+  VERIFY( std::bind(multiplies<int>(), p2::_1, b2)(seven, five) == 7 );\n+\n+  VERIFY( std::tr1::bind<int>(multiplies<int>(), p1::_1, b1)(five, seven) == -5 );\n+  VERIFY( std::bind<int>(multiplies<int>(), p2::_1, b2)(seven, five) == 7 );\n+\n+  static_assert( std::is_bind_expression<decltype(b2)>::value,\n+      \"TR1 bind<R> expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(b1)>::value,\n+      \"std bind<R> expression is a TR2 bind expression\" );\n+\n+  const auto c1 = b1;\n+  const auto c2 = b2;\n+\n+  static_assert( std::is_bind_expression<decltype(c2)>::value,\n+      \"const TR1 bind<R> expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(c1)>::value,\n+      \"const std bind<R> expression is a TR2 bind expression\" );\n+\n+  volatile auto v1 = b1;\n+  volatile auto v2 = b2;\n+\n+  static_assert( std::is_bind_expression<decltype(v2)>::value,\n+      \"volatile TR1 bind<R> expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(v1)>::value,\n+      \"volatile std bind<R> expression is a TR2 bind expression\" );\n+\n+  const volatile auto cv1 = b1;\n+  const volatile auto cv2 = b2;\n+\n+  static_assert( std::is_bind_expression<decltype(cv2)>::value,\n+      \"const volatile TR1 bind<R> expression is a std bind expression\" );\n+  static_assert( std::tr1::is_bind_expression<decltype(cv1)>::value,\n+      \"const volatile std bind<R> expression is a TR2 bind expression\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}]}