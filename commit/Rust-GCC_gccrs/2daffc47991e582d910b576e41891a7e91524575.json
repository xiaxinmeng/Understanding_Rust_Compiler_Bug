{"sha": "2daffc47991e582d910b576e41891a7e91524575", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRhZmZjNDc5OTFlNTgyZDkxMGI1NzZlNDE4OTFhN2U5MTUyNDU3NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-08-21T06:54:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-08-21T06:54:01Z"}, "message": "re PR fortran/48636 (Enable more inlining with -O2 and higher)\n\n\tPR fortran/48636\n\t* ipa-inline.c (want_inline_small_function_p): Take loop_iterations hint.\n\t(edge_badness): Likewise.\n\t* ipa-inline.h (inline_hints_vals): Add INLINE_HINT_loop_iterations.\n\t(inline_summary): Add loop_iterations.\n\t* ipa-inline-analysis.c: Include tree-scalar-evolution.h.\n\t(dump_inline_hints): Dump loop_iterations.\n\t(reset_inline_summary): Free loop_iterations.\n\t(inline_node_duplication_hook): Update loop_iterations.\n\t(dump_inline_summary): Dump loop_iterations.\n\t(will_be_nonconstant_expr_predicate): New function.\n\t(estimate_function_body_sizes): Analyze loops.\n\t(estimate_node_size_and_time): Set hint loop_iterations.\n\t(inline_merge_summary): Merge loop iterations.\n\t(inline_read_section): Stream in loop_iterations.\n\t(inline_write_summary): Stream out loop_iterations.\n\nFrom-SVN: r190556", "tree": {"sha": "ea6cdcf31028e9bf0f6d2317cb87f6e7a3668c5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea6cdcf31028e9bf0f6d2317cb87f6e7a3668c5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2daffc47991e582d910b576e41891a7e91524575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2daffc47991e582d910b576e41891a7e91524575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2daffc47991e582d910b576e41891a7e91524575", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2daffc47991e582d910b576e41891a7e91524575/comments", "author": null, "committer": null, "parents": [{"sha": "e162e288ecf5a5eb16bd6c0cb432afa233e1e10b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e162e288ecf5a5eb16bd6c0cb432afa233e1e10b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e162e288ecf5a5eb16bd6c0cb432afa233e1e10b"}], "stats": {"total": 226, "additions": 220, "deletions": 6}, "files": [{"sha": "477111f1ebac2cdf1681282f87e8cd8c6decadb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2daffc47991e582d910b576e41891a7e91524575/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2daffc47991e582d910b576e41891a7e91524575/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2daffc47991e582d910b576e41891a7e91524575", "patch": "@@ -1,3 +1,22 @@\n+2012-08-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR fortran/48636\n+\t* ipa-inline.c (want_inline_small_function_p): Take loop_iterations hint.\n+\t(edge_badness): Likewise.\n+\t* ipa-inline.h (inline_hints_vals): Add INLINE_HINT_loop_iterations.\n+\t(inline_summary): Add loop_iterations.\n+\t* ipa-inline-analysis.c: Include tree-scalar-evolution.h.\n+\t(dump_inline_hints): Dump loop_iterations.\n+\t(reset_inline_summary): Free loop_iterations.\n+\t(inline_node_duplication_hook): Update loop_iterations.\n+\t(dump_inline_summary): Dump loop_iterations.\n+\t(will_be_nonconstant_expr_predicate): New function.\n+\t(estimate_function_body_sizes): Analyze loops.\n+\t(estimate_node_size_and_time): Set hint loop_iterations.\n+\t(inline_merge_summary): Merge loop iterations.\n+\t(inline_read_section): Stream in loop_iterations.\n+\t(inline_write_summary): Stream out loop_iterations.\n+\n 2012-08-20  Florian Weimer  <fweimer@redhat.com>\n \n \tPR c++/19351"}, {"sha": "ca80a8b88ba4fbcea2c77513563830d5fb8e0df2", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 170, "deletions": 3, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2daffc47991e582d910b576e41891a7e91524575/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2daffc47991e582d910b576e41891a7e91524575/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=2daffc47991e582d910b576e41891a7e91524575", "patch": "@@ -88,6 +88,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"alloc-pool.h\"\n #include \"cfgloop.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n \n /* Estimate runtime of function can easilly run into huge numbers with many\n    nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE * 2 in an\n@@ -627,6 +629,11 @@ dump_inline_hints (FILE *f, inline_hints hints)\n       hints &= ~INLINE_HINT_indirect_call;\n       fprintf (f, \" indirect_call\");\n     }\n+  if (hints & INLINE_HINT_loop_iterations)\n+    {\n+      hints &= ~INLINE_HINT_loop_iterations;\n+      fprintf (f, \" loop_iterations\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -941,6 +948,11 @@ reset_inline_summary (struct cgraph_node *node)\n   info->stack_frame_offset = 0;\n   info->size = 0;\n   info->time = 0;\n+  if (info->loop_iterations)\n+    {\n+      pool_free (edge_predicate_pool, info->loop_iterations);\n+      info->loop_iterations = NULL;\n+    }\n   VEC_free (condition, gc, info->conds);\n   VEC_free (size_time_entry,gc, info->entry);\n   for (e = node->callees; e; e = e->next_callee)\n@@ -1078,7 +1090,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t\t     * edge->frequency);\n \t      edge->frequency = 0;\n \t    }\n-\t  *es->predicate = new_predicate;\n+\t  edge_set_predicate (edge, &new_predicate);\n \t}\n \n       /* Remap indirect edge predicates with the same simplificaiton as above. \n@@ -1110,7 +1122,29 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t\t     * edge->frequency);\n \t      edge->frequency = 0;\n \t    }\n-\t  *es->predicate = new_predicate;\n+\t  edge_set_predicate (edge, &new_predicate);\n+\t}\n+      if (info->loop_iterations)\n+\t{\n+\t  struct predicate new_predicate = true_predicate ();\n+\n+\t  for (j = 0; info->loop_iterations->clause[j]; j++)\n+\t    if (!(possible_truths & info->loop_iterations->clause[j]))\n+\t      {\n+\t\tnew_predicate = false_predicate ();\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      add_clause (info->conds, &new_predicate,\n+\t\t\t  possible_truths & info->loop_iterations->clause[j]);\n+\t  if (false_predicate_p (&new_predicate)\n+\t      || true_predicate_p (&new_predicate))\n+\t    info->loop_iterations = NULL;\n+\t  else\n+\t    {\n+\t      info->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n+\t      *info->loop_iterations = new_predicate;\n+\t    }\n \t}\n \n       /* If inliner or someone after inliner will ever start producing\n@@ -1136,7 +1170,15 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \tinfo->self_time = 0;\n     }\n   else\n-    info->entry = VEC_copy (size_time_entry, gc, info->entry);\n+    {\n+      info->entry = VEC_copy (size_time_entry, gc, info->entry);\n+      if (info->loop_iterations)\n+\t{\n+\t  predicate p = *info->loop_iterations;\n+\t  info->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n+\t  *info->loop_iterations = p;\n+\t}\n+    }\n }\n \n \n@@ -1308,6 +1350,11 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \t\t   (double) e->time / INLINE_TIME_SCALE);\n \t  dump_predicate (f, s->conds, &e->predicate);\n \t}\n+      if (s->loop_iterations)\n+\t{\n+\t  fprintf (f, \"  loop iterations:\");\n+\t  dump_predicate (f, s->conds, s->loop_iterations);\n+\t}\n       fprintf (f, \"  calls:\\n\");\n       dump_inline_edge_summary (f, 4, node, s);\n       fprintf (f, \"\\n\");\n@@ -1780,6 +1827,46 @@ compute_bb_predicates (struct cgraph_node *node,\n typedef struct predicate predicate_t;\n DEF_VEC_O (predicate_t);\n DEF_VEC_ALLOC_O (predicate_t, heap);\n+/* Return predicate specifying when the STMT might have result that is not\n+   a compile time constant.  */\n+\n+static struct predicate\n+will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n+\t\t\t            struct inline_summary *summary,\n+\t\t\t            tree expr,\n+\t\t\t            VEC (predicate_t, heap) *nonconstant_names)\n+{\n+  tree parm;\n+  int index;\n+\n+  while (UNARY_CLASS_P (expr))\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  parm = unmodified_parm (NULL, expr);\n+  if (parm\n+      && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n+    return add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n+  if (is_gimple_min_invariant (expr))\n+    return false_predicate ();\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    return VEC_index (predicate_t, nonconstant_names,\n+                      SSA_NAME_VERSION (expr));\n+  if (BINARY_CLASS_P (expr))\n+    {\n+      struct predicate p1 =  will_be_nonconstant_expr_predicate (info, summary, TREE_OPERAND (expr, 0), nonconstant_names);\n+      struct predicate p2;\n+      if (true_predicate_p (&p1))\n+\treturn p1;\n+      p2 = will_be_nonconstant_expr_predicate (info, summary, TREE_OPERAND (expr, 0), nonconstant_names);\n+      return or_predicates (summary->conds, &p1, &p2);\n+    }\n+  else\n+    {\n+      debug_tree (expr);\n+      gcc_unreachable ();\n+    }\n+  return false_predicate ();\n+}\n \n \n /* Return predicate specifying when the STMT might have result that is not\n@@ -2176,6 +2263,51 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   if (time > MAX_TIME)\n     time = MAX_TIME;\n+\n+  if (!early && nonconstant_names)\n+    {\n+      struct loop *loop;\n+      loop_iterator li;\n+      predicate loop_iterations = true_predicate ();\n+\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      loop_optimizer_init (LOOPS_NORMAL\n+\t\t\t   | LOOPS_HAVE_RECORDED_EXITS);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tflow_loops_dump (dump_file, NULL, 0);\n+      scev_initialize ();\n+      FOR_EACH_LOOP (li, loop, 0)\n+\t{\n+          VEC (edge, heap) *exits;\n+          edge ex;\n+\t  unsigned int j;\n+\t  struct tree_niter_desc niter_desc;\n+\n+\t  exits = get_loop_exit_edges (loop);\n+          FOR_EACH_VEC_ELT (edge, exits, j, ex)\n+\t    if (number_of_iterations_exit (loop, ex, &niter_desc, false)\n+\t\t&& !is_gimple_min_invariant (niter_desc.niter))\n+\t      {\n+\t\tpredicate will_be_nonconstant\n+\t\t = will_be_nonconstant_expr_predicate (parms_info, info,\n+\t\t\t\t\t\t       niter_desc.niter, nonconstant_names);\n+\t\tif (!true_predicate_p (&will_be_nonconstant)\n+\t\t    && !false_predicate_p (&will_be_nonconstant))\n+\t\t  /* This is slightly inprecise.  We may want to represent each loop with\n+\t\t     independent predicate.  */\n+\t\t  loop_iterations = and_predicates (info->conds, &loop_iterations, &will_be_nonconstant);\n+\t      }\n+          VEC_free (edge, heap, exits);\n+\t}\n+      if (!true_predicate_p (&loop_iterations))\n+\t{\n+          inline_summary (node)->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n+          *inline_summary (node)->loop_iterations = loop_iterations;\n+\t}\n+      scev_finalize ();\n+      loop_optimizer_finalize ();\n+      free_dominance_info (CDI_DOMINATORS);\n+    }\n   inline_summary (node)->self_time = time;\n   inline_summary (node)->self_size = size;\n   VEC_free (predicate_t, heap, nonconstant_names);\n@@ -2459,6 +2591,10 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t\t         \n       }\n \n+  if (info->loop_iterations\n+      && !evaluate_predicate (info->loop_iterations, possible_truths))\n+    hints |=INLINE_HINT_loop_iterations;\n+\n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n \n@@ -2842,6 +2978,28 @@ inline_merge_summary (struct cgraph_edge *edge)\n     }\n   remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n \t\t\toffset_map, clause, &toplev_predicate);\n+  if (callee_info->loop_iterations)\n+    {\n+      predicate p = remap_predicate (info, callee_info,\n+\t\t\t\t     callee_info->loop_iterations,\n+\t\t\t\t     operand_map, offset_map,\n+\t\t\t\t     clause,\n+\t\t\t\t     &toplev_predicate);\n+      if (!false_predicate_p (&p)\n+\t  && !true_predicate_p (&p))\n+\t{\n+\t  if (!info->loop_iterations)\n+\t    {\n+\t      info->loop_iterations\n+\t\t = (struct predicate *)pool_alloc (edge_predicate_pool);\n+\t      *info->loop_iterations = p;\n+\t    }\n+\t  else\n+\t    *info->loop_iterations = and_predicates (info->conds, \n+\t\t\t\t\t\t     info->loop_iterations,\n+\t\t\t\t\t\t     &p);\n+\t}\n+    }\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -3269,6 +3427,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n+      predicate p;\n \n       index = streamer_read_uhwi (&ib);\n       encoder = file_data->symtab_node_encoder;\n@@ -3310,6 +3469,13 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n \t  VEC_safe_push (size_time_entry, gc, info->entry, &e);\n \t}\n+     \n+      p = read_predicate (&ib);\n+      if (!true_predicate_p (&p))\n+\t{\n+\t  info->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n+\t  *info->loop_iterations = p;\n+\t}\n       for (e = node->callees; e; e = e->next_callee)\n \tread_inline_edge_summary (&ib, e);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -3456,6 +3622,7 @@ inline_write_summary (void)\n \t      streamer_write_uhwi (ob, e->time);\n \t      write_predicate (ob, &e->predicate);\n \t    }\n+\t  write_predicate (ob, info->loop_iterations);\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    write_inline_edge_summary (ob, edge);\n \t  for (edge = node->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "a1d703a6b7f90c5e157e7144a65dcfdde219f060", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2daffc47991e582d910b576e41891a7e91524575/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2daffc47991e582d910b576e41891a7e91524575/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2daffc47991e582d910b576e41891a7e91524575", "patch": "@@ -480,7 +480,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t hints suggests that inlining given function is very profitable.  */\n       else if (DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE\n-\t       && !(hints & INLINE_HINT_indirect_call))\n+\t       && !(hints & (INLINE_HINT_indirect_call\n+\t\t\t     | INLINE_HINT_loop_iterations)))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n@@ -863,7 +864,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t  if (dump)\n \t    fprintf (dump_file, \"Badness overflow\\n\");\n \t}\n-      if (hints & INLINE_HINT_indirect_call)\n+      if (hints & (INLINE_HINT_indirect_call\n+\t\t   | INLINE_HINT_loop_iterations))\n \tbadness /= 8;\n       if (dump)\n \t{"}, {"sha": "839bc237f2aa347cea9943baa1a110ca502455d4", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2daffc47991e582d910b576e41891a7e91524575/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2daffc47991e582d910b576e41891a7e91524575/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=2daffc47991e582d910b576e41891a7e91524575", "patch": "@@ -45,7 +45,8 @@ typedef struct GTY(()) condition\n /* Inline hints are reasons why inline heuristics should preffer inlining given function.\n    They are represtented as bitmap of the following values.  */\n enum inline_hints_vals {\n-  INLINE_HINT_indirect_call = 1\n+  INLINE_HINT_indirect_call = 1,\n+  INLINE_HINT_loop_iterations = 2\n };\n typedef int inline_hints;\n \n@@ -118,6 +119,10 @@ struct GTY(()) inline_summary\n      merged during inlining.  */\n   conditions conds;\n   VEC(size_time_entry,gc) *entry;\n+\n+  /* Predicate on when some loop in the function sbecomes to have known\n+     bounds.   */\n+  struct predicate * GTY((skip)) loop_iterations;\n };\n \n "}, {"sha": "f6151fcca7b162fd91d6f80f3b635203861c7cac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2daffc47991e582d910b576e41891a7e91524575/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2daffc47991e582d910b576e41891a7e91524575/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2daffc47991e582d910b576e41891a7e91524575", "patch": "@@ -1,3 +1,8 @@\n+2012-08-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR fortran/48636\n+\t* gcc.dg/ipa/inlinehint-1.c: New.\n+\n 2012-08-20  Florian Weimer  <fweimer@redhat.com>\n \n \tPR c++/19351"}, {"sha": "9810e25c19b2ec81b88881dcd3cfc6b0e6bfaf7c", "filename": "gcc/testsuite/gcc.dg/ipa/inlinehint-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2daffc47991e582d910b576e41891a7e91524575/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2daffc47991e582d910b576e41891a7e91524575/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-1.c?ref=2daffc47991e582d910b576e41891a7e91524575", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O3 -c -fdump-ipa-inline-details -fno-early-inlining -fno-ipa-cp\"  } */\n+test (int a)\n+{\n+   int i;\n+   for (i=0; i<a; i++)\n+{\n+     test2(a);\n+     test2(a);\n+}\n+}\n+m()\n+{\n+  test (10);\n+}\n+/* { dg-final { scan-ipa-dump \"loop_iterations\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}