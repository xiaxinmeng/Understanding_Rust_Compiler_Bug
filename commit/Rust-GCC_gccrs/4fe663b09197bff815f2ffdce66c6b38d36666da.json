{"sha": "4fe663b09197bff815f2ffdce66c6b38d36666da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlNjYzYjA5MTk3YmZmODE1ZjJmZmRjZTY2YzZiMzhkMzY2NjZkYQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2008-04-11T15:52:19Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-04-11T15:52:19Z"}, "message": "re PR middle-end/35897 (DSE doesn't support targets with wide registers)\n\n2008-04-11  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR middle-end/35897\n\t* dse.c (store_info): Change positions_needed to unsigned\n\tHOST_WIDE_INT.\n\t(lowpart_bitmask): New.\n\t(record_store): Cast to unsigned HOST_WIDE_INT for\n\tpositions_needed.  Assert width <= size of positions_needed *\n\tCHAR_BIT.  Call lowpart_bitmask to initialize positions_needed.\n\t(check_mem_read_rtx): Use unsigned HOST_WIDE_INT on mask.  Call\n\tlowpart_bitmask to set mask.\n\nFrom-SVN: r134199", "tree": {"sha": "94834110a3a0797467e7552d74ac1d9196e49a9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94834110a3a0797467e7552d74ac1d9196e49a9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe663b09197bff815f2ffdce66c6b38d36666da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe663b09197bff815f2ffdce66c6b38d36666da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe663b09197bff815f2ffdce66c6b38d36666da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe663b09197bff815f2ffdce66c6b38d36666da/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fdd7520f9094f83012c8a0617f9d5e80bdd2662", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fdd7520f9094f83012c8a0617f9d5e80bdd2662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fdd7520f9094f83012c8a0617f9d5e80bdd2662"}], "stats": {"total": 47, "additions": 37, "deletions": 10}, "files": [{"sha": "8c5bcff459cd5e9e7f8ca1474eda8d58ea84cac4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe663b09197bff815f2ffdce66c6b38d36666da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe663b09197bff815f2ffdce66c6b38d36666da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fe663b09197bff815f2ffdce66c6b38d36666da", "patch": "@@ -1,3 +1,15 @@\n+2008-04-11  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR middle-end/35897\n+\t* dse.c (store_info): Change positions_needed to unsigned\n+\tHOST_WIDE_INT.\n+\t(lowpart_bitmask): New.\n+\t(record_store): Cast to unsigned HOST_WIDE_INT for\n+\tpositions_needed.  Assert width <= size of positions_needed *\n+\tCHAR_BIT.  Call lowpart_bitmask to initialize positions_needed.\n+\t(check_mem_read_rtx): Use unsigned HOST_WIDE_INT on mask.  Call\n+\tlowpart_bitmask to set mask.\n+\n 2008-04-11  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/constraints.md: New file."}, {"sha": "4394600c9c340dd9c4afc0cd4f070d798bd03285", "filename": "gcc/dse.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe663b09197bff815f2ffdce66c6b38d36666da/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe663b09197bff815f2ffdce66c6b38d36666da/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=4fe663b09197bff815f2ffdce66c6b38d36666da", "patch": "@@ -229,7 +229,7 @@ struct store_info\n   /* An bitmask as wide as the number of bytes in the word that\n      contains a 1 if the byte may be needed.  The store is unused if\n      all of the bits are 0.  */\n-  long positions_needed;\n+  unsigned HOST_WIDE_INT positions_needed;\n \n   /* The next store info for this insn.  */\n   struct store_info *next;\n@@ -240,6 +240,15 @@ struct store_info\n   rtx rhs;  \n };\n \n+/* Return a bitmask with the first N low bits set.  */\n+\n+static unsigned HOST_WIDE_INT\n+lowpart_bitmask (int n)\n+{\n+  unsigned HOST_WIDE_INT mask = ~(unsigned HOST_WIDE_INT) 0;\n+  return mask >> (HOST_BITS_PER_WIDE_INT - n);\n+}\n+\n typedef struct store_info *store_info_t;\n static alloc_pool cse_store_info_pool;\n static alloc_pool rtx_store_info_pool;\n@@ -1308,7 +1317,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t      && (GET_MODE (mem) == entry->mode))\n \t    {\n \t      delete = true;\n-\t      s_info->positions_needed = 0;\n+\t      s_info->positions_needed = (unsigned HOST_WIDE_INT) 0;\n \t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    trying spill store in insn=%d alias_set=%d\\n\",\n@@ -1324,7 +1333,8 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t     (int)s_info->begin, (int)s_info->end);\n \t  for (i = offset; i < offset+width; i++)\n \t    if (i >= s_info->begin && i < s_info->end)\n-\t      s_info->positions_needed &= ~(1L << (i - s_info->begin));\n+\t      s_info->positions_needed\n+\t\t&= ~(((unsigned HOST_WIDE_INT) 1) << (i - s_info->begin));\n \t}\n       else if (s_info->rhs)\n \t/* Need to see if it is possible for this store to overwrite\n@@ -1340,7 +1350,7 @@ record_store (rtx body, bb_info_t bb_info)\n       \n       /* An insn can be deleted if every position of every one of\n \t its s_infos is zero.  */\n-      if (s_info->positions_needed != 0)\n+      if (s_info->positions_needed != (unsigned HOST_WIDE_INT) 0)\n \tdelete = false;\n       \n       if (delete)\n@@ -1360,7 +1370,8 @@ record_store (rtx body, bb_info_t bb_info)\n       ptr = next;\n     }\n   \n-  gcc_assert ((unsigned) width < sizeof (store_info->positions_needed) * CHAR_BIT);\n+  gcc_assert ((unsigned) width\n+\t      <= sizeof (store_info->positions_needed) * CHAR_BIT);\n   \n   /* Finish filling in the store_info.  */\n   store_info->next = insn_info->store_rec;\n@@ -1369,7 +1380,7 @@ record_store (rtx body, bb_info_t bb_info)\n   store_info->alias_set = spill_alias_set;\n   store_info->mem_addr = get_addr (XEXP (mem, 0));\n   store_info->cse_base = base;\n-  store_info->positions_needed = (1L << width) - 1;\n+  store_info->positions_needed = lowpart_bitmask (width);\n   store_info->group_id = group_id;\n   store_info->begin = offset;\n   store_info->end = offset + width;\n@@ -1801,8 +1812,10 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t\t      && (offset >= store_info->begin)\n \t\t      && (offset + width <= store_info->end))\n \t\t    {\n-\t\t      int mask = ((1L << width) - 1) << (offset - store_info->begin);\n-\t\t      \n+\t\t      unsigned HOST_WIDE_INT mask\n+\t\t\t= (lowpart_bitmask (width)\n+\t\t\t   << (offset - store_info->begin));\n+\n \t\t      if ((store_info->positions_needed & mask) == mask\n \t\t\t  && replace_read (store_info, i_ptr, \n \t\t\t\t\t   read_info, insn_info, loc))\n@@ -1868,8 +1881,10 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t      && (offset >= store_info->begin)\n \t      && (offset + width <= store_info->end))\n \t    {\n-\t      int mask = ((1L << width) - 1) << (offset - store_info->begin);\n-\t      \n+\t      unsigned HOST_WIDE_INT mask\n+\t\t= (lowpart_bitmask (width)\n+\t\t   << (offset - store_info->begin));\n+\n \t      if ((store_info->positions_needed & mask) == mask\n \t\t  && replace_read (store_info, i_ptr, \n \t\t\t\t   read_info, insn_info, loc))"}]}