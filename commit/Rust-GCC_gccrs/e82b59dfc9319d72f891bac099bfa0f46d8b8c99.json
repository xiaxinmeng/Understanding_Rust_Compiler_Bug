{"sha": "e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "node_id": "C_kwDOANBUbNoAKGU4MmI1OWRmYzkzMTlkNzJmODkxYmFjMDk5YmZhMGY0NmQ4YjhjOTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-01T11:36:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-01T11:36:13Z"}, "message": "Merge #981\n\n981: macro-expand: Add SubstitutionCtx class in its own file r=CohenArthur a=CohenArthur\n\nThe `MacroExpander` class had multiple static functions which were constantly passing the same parameters around for expansion. This refactor adds a new `SubstituteCtx` class which keeps track of the three common arguments given to the substitute functions, and offers these implementations in a new source file to keep the original expander light.\r\n\r\nCloses #957 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "a91c15fb63b9543661d892efb5fbe94dbe73ee52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a91c15fb63b9543661d892efb5fbe94dbe73ee52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiHgUtCRBK7hj4Ov3rIwAAtXsIAEo+ZjFKum+pRkUdJ5yvXTxO\nC9XXUye6BJlHfBBwR8UJIJeaRIITH5IoDJSMs4zu6oF8Fy1fpMJePzeZtTJlFeD+\nSj/bCtHTU2Ew+IttRWw7pbNMUlyfiKUHwxgjw6hLxJBIWSFLE4V143OqIOK3WKyC\n/JcW2EJuTjybr3j+B3XChPZjqZ1qPn8xdkb7vkToX1KGnKFU+e1R4maLzEenKjfn\nnVQ0jlY4FaHlj6XnNueclt14GZ+xyDUodNqwfZ4CSYKtfp0DjFaxAq1DxPvfnf3f\nJ13PvfTxTQugA5qJv7OLzg6GqspsyOFAb80Hy1Kt4bsMD14zTISSIPcBHyjKLoY=\n=/EY8\n-----END PGP SIGNATURE-----\n", "payload": "tree a91c15fb63b9543661d892efb5fbe94dbe73ee52\nparent ed1a4dc33fa78808fefaf020015b2177d7cdc1ce\nparent 27be628911a8df4d83b3770f9c5491bc7b410c2f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646134573 +0000\ncommitter GitHub <noreply@github.com> 1646134573 +0000\n\nMerge #981\n\n981: macro-expand: Add SubstitutionCtx class in its own file r=CohenArthur a=CohenArthur\n\nThe `MacroExpander` class had multiple static functions which were constantly passing the same parameters around for expansion. This refactor adds a new `SubstituteCtx` class which keeps track of the three common arguments given to the substitute functions, and offers these implementations in a new source file to keep the original expander light.\r\n\r\nCloses #957 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed1a4dc33fa78808fefaf020015b2177d7cdc1ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1a4dc33fa78808fefaf020015b2177d7cdc1ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1a4dc33fa78808fefaf020015b2177d7cdc1ce"}, {"sha": "27be628911a8df4d83b3770f9c5491bc7b410c2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27be628911a8df4d83b3770f9c5491bc7b410c2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27be628911a8df4d83b3770f9c5491bc7b410c2f"}], "stats": {"total": 566, "additions": 291, "deletions": 275}, "files": [{"sha": "b43f0f31607c82f3b6faf74cdb87d45572f70405", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "patch": "@@ -75,6 +75,7 @@ GRS_OBJS = \\\n     rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-macro-invoc-lexer.o \\\n+    rust/rust-macro-substitute-ctx.o \\\n     rust/rust-macro-builtins.o \\\n     rust/rust-hir-full-test.o \\\n     rust/rust-hir-map.o \\"}, {"sha": "a4ed36b0c6eec6c9aa8a52a35fa4426b57ad29df", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 4, "deletions": 217, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-macro-expand.h\"\n+#include \"rust-macro-substitute-ctx.h\"\n #include \"rust-ast-full.h\"\n #include \"rust-ast-visitor.h\"\n #include \"rust-diagnostics.h\"\n@@ -3773,8 +3774,10 @@ MacroExpander::transcribe_rule (\n   auto invoc_stream = invoc_token_tree.to_token_stream ();\n   auto macro_rule_tokens = transcribe_tree.to_token_stream ();\n \n+  auto substitute_context\n+    = SubstituteCtx (invoc_stream, macro_rule_tokens, matched_fragments);\n   std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n-    = substitute_tokens (invoc_stream, macro_rule_tokens, matched_fragments);\n+    = substitute_context.substitute_tokens ();\n \n   // // handy for debugging\n   // for (auto &tok : substituted_tokens)\n@@ -3896,220 +3899,4 @@ MacroExpander::transcribe_rule (\n \n   return AST::ASTFragment (std::move (nodes));\n }\n-\n-std::vector<std::unique_ptr<AST::Token>>\n-MacroExpander::substitute_metavar (\n-  std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::map<std::string, std::vector<MatchedFragment>> &fragments,\n-  std::unique_ptr<AST::Token> &metavar)\n-{\n-  auto metavar_name = metavar->get_str ();\n-\n-  std::vector<std::unique_ptr<AST::Token>> expanded;\n-  auto it = fragments.find (metavar_name);\n-  if (it == fragments.end ())\n-    {\n-      // Return a copy of the original token\n-      expanded.push_back (metavar->clone_token ());\n-    }\n-  else\n-    {\n-      // Replace\n-      // We only care about the vector when expanding repetitions. Just access\n-      // the first element of the vector.\n-      // FIXME: Clean this up so it makes more sense\n-      auto &frag = it->second[0];\n-      for (size_t offs = frag.token_offset_begin; offs < frag.token_offset_end;\n-\t   offs++)\n-\t{\n-\t  auto &tok = input.at (offs);\n-\t  expanded.push_back (tok->clone_token ());\n-\t}\n-    }\n-\n-  return expanded;\n-}\n-\n-std::vector<std::unique_ptr<AST::Token>>\n-MacroExpander::substitute_repetition (\n-  std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::vector<std::unique_ptr<AST::Token>> &macro,\n-  std::map<std::string, std::vector<MatchedFragment>> &fragments,\n-  size_t pattern_start, size_t pattern_end)\n-{\n-  rust_assert (pattern_end < macro.size ());\n-\n-  rust_debug (\"pattern start: %lu\", pattern_start);\n-  rust_debug (\"pattern end: %lu\", pattern_end);\n-\n-  std::vector<std::unique_ptr<AST::Token>> expanded;\n-\n-  // Find the first fragment and get the amount of repetitions that we should\n-  // perform\n-  size_t repeat_amount = 0;\n-  for (size_t i = pattern_start; i < pattern_end; i++)\n-    {\n-      if (macro.at (i)->get_id () == DOLLAR_SIGN)\n-\t{\n-\t  auto &frag_token = macro.at (i + 1);\n-\t  if (frag_token->get_id () == IDENTIFIER)\n-\t    {\n-\t      auto it = fragments.find (frag_token->get_str ());\n-\t      if (it == fragments.end ())\n-\t\t{\n-\t\t  // If the repetition is not anything we know (ie no declared\n-\t\t  // metavars, or metavars which aren't present in the\n-\t\t  // fragment), we can just error out. No need to paste the\n-\t\t  // tokens as if nothing had happened.\n-\t\t  rust_error_at (frag_token->get_locus (),\n-\t\t\t\t \"metavar %s used in repetition does not exist\",\n-\t\t\t\t frag_token->get_str ().c_str ());\n-\t\t  // FIXME:\n-\t\t  return expanded;\n-\t\t}\n-\n-\t      // FIXME: Refactor, ugly\n-\t      repeat_amount = it->second[0].match_amount;\n-\t    }\n-\t}\n-    }\n-\n-  rust_debug (\"repetition amount to use: %lu\", repeat_amount);\n-  std::vector<std::unique_ptr<AST::Token>> new_macro;\n-\n-  // We want to generate a \"new macro\" to substitute with. This new macro\n-  // should contain only the tokens inside the pattern\n-  for (size_t tok_idx = pattern_start; tok_idx < pattern_end; tok_idx++)\n-    new_macro.emplace_back (macro.at (tok_idx)->clone_token ());\n-\n-  // Then, we want to create a subset of the matches so that\n-  // `substitute_tokens()` can only see one fragment per metavar. Let's say we\n-  // have the following user input: (1 145 'h')\n-  // on the following match arm: ($($lit:literal)*)\n-  // which causes the following matches: { \"lit\": [1, 145, 'h'] }\n-  //\n-  // The pattern (new_macro) is `$lit:literal`\n-  // The first time we expand it, we want $lit to have the following token: 1\n-  // The second time, 145\n-  // The third and final time, 'h'\n-  //\n-  // In order to do so we must create \"sub maps\", which only contain parts of\n-  // the original matches\n-  // sub-maps: [ { \"lit\": 1 }, { \"lit\": 145 }, { \"lit\": 'h' } ]\n-  //\n-  // and give them to `substitute_tokens` one by one.\n-\n-  for (size_t i = 0; i < repeat_amount; i++)\n-    {\n-      std::map<std::string, std::vector<MatchedFragment>> sub_map;\n-      for (auto &kv_match : fragments)\n-\t{\n-\t  std::vector<MatchedFragment> sub_vec;\n-\t  sub_vec.emplace_back (kv_match.second[i]);\n-\n-\t  sub_map.insert ({kv_match.first, sub_vec});\n-\t}\n-\n-      auto new_tokens = substitute_tokens (input, new_macro, sub_map);\n-\n-      for (auto &new_token : new_tokens)\n-\texpanded.emplace_back (new_token->clone_token ());\n-    }\n-\n-  // FIXME: We also need to make sure that all subsequent fragments\n-  // contain the same amount of repetitions as the first one\n-\n-  return expanded;\n-}\n-\n-std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n-MacroExpander::substitute_token (\n-  std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::vector<std::unique_ptr<AST::Token>> &macro,\n-  std::map<std::string, std::vector<MatchedFragment>> &fragments,\n-  size_t token_idx)\n-{\n-  auto &token = macro.at (token_idx);\n-  switch (token->get_id ())\n-    {\n-    case IDENTIFIER:\n-      rust_debug (\"expanding metavar: %s\", token->get_str ().c_str ());\n-      return {substitute_metavar (input, fragments, token), 1};\n-      case LEFT_PAREN: {\n-\t// We need to parse up until the closing delimiter and expand this\n-\t// fragment->n times.\n-\trust_debug (\"expanding repetition\");\n-\tstd::vector<std::unique_ptr<AST::Token>> repetition_pattern;\n-\tsize_t pattern_start = token_idx + 1;\n-\tsize_t pattern_end = pattern_start;\n-\tfor (; pattern_end < macro.size ()\n-\t       && macro.at (pattern_end)->get_id () != RIGHT_PAREN;\n-\t     pattern_end++)\n-\t  ;\n-\n-\t// FIXME: This skips whitespaces... Is that okay??\n-\t// FIXME: Is there any existing parsing function that allows us to parse\n-\t// a macro pattern?\n-\n-\t// FIXME: Add error handling in the case we haven't found a matching\n-\t// closing delimiter\n-\n-\t// FIXME: We need to parse the repetition token now\n-\n-\treturn {\n-\t  substitute_repetition (input, macro, fragments, pattern_start,\n-\t\t\t\t pattern_end),\n-\t  // + 2 for the opening and closing parentheses which are mandatory\n-\t  // + 1 for the repetitor (+, *, ?)\n-\t  pattern_end - pattern_start + 3};\n-      }\n-      // TODO: We need to check if the $ was alone. In that case, do\n-      // not error out: Simply act as if there was an empty identifier\n-      // with no associated fragment and paste the dollar sign in the\n-      // transcription. Unsure how to do that since we always have at\n-      // least the closing curly brace after an empty $...\n-    default:\n-      rust_error_at (token->get_locus (),\n-\t\t     \"unexpected token in macro transcribe: expected \"\n-\t\t     \"%<(%> or identifier after %<$%>, got %<%s%>\",\n-\t\t     get_token_description (token->get_id ()));\n-    }\n-\n-  // FIXME: gcc_unreachable() error case?\n-  return {std::vector<std::unique_ptr<AST::Token>> (), 0};\n-}\n-\n-std::vector<std::unique_ptr<AST::Token>>\n-MacroExpander::substitute_tokens (\n-  std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::vector<std::unique_ptr<AST::Token>> &macro,\n-  std::map<std::string, std::vector<MatchedFragment>> &fragments)\n-{\n-  std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n-\n-  for (size_t i = 0; i < macro.size (); i++)\n-    {\n-      auto &tok = macro.at (i);\n-      if (tok->get_id () == DOLLAR_SIGN)\n-\t{\n-\t  // Aaaaah, if only we had C++17 :)\n-\t  // auto [expanded, tok_to_skip] = ...\n-\t  auto p = substitute_token (input, macro, fragments, i + 1);\n-\t  auto expanded = std::move (p.first);\n-\t  auto tok_to_skip = p.second;\n-\n-\t  i += tok_to_skip;\n-\n-\t  for (auto &token : expanded)\n-\t    replaced_tokens.emplace_back (token->clone_token ());\n-\t}\n-      else\n-\t{\n-\t  replaced_tokens.emplace_back (tok->clone_token ());\n-\t}\n-    }\n-\n-  return replaced_tokens;\n-}\n-\n } // namespace Rust"}, {"sha": "9309323a42645383c445d03b1273f5c56e670254", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "patch": "@@ -213,64 +213,6 @@ struct MacroExpander\n \t\t\tsize_t &match_amount, size_t lo_bound = 0,\n \t\t\tsize_t hi_bound = 0);\n \n-  /**\n-   * Substitute a metavariable by its given fragment in a transcribing context,\n-   * i.e. replacing $var with the associated fragment.\n-   *\n-   * @param input Tokens given to the transcribing context\n-   * @param fragments Fragments given to the macro substitution\n-   * @param metavar Metavariable to try and replace\n-   *\n-   * @return A token containing the associated fragment expanded into tokens if\n-   * any, or the cloned token if no fragment was associated\n-   */\n-  static std::vector<std::unique_ptr<AST::Token>> substitute_metavar (\n-    std::vector<std::unique_ptr<AST::Token>> &input,\n-    std::map<std::string, std::vector<MatchedFragment>> &fragments,\n-    std::unique_ptr<AST::Token> &metavar);\n-\n-  /**\n-   * Substitute a macro repetition by its given fragments\n-   *\n-   * @param input Tokens given to the transcribing context\n-   * @param fragments Fragments given to the macro substitution\n-   * @param pattern_start Start index of the pattern tokens\n-   * @param pattern_end Index  Amount of tokens in the pattern\n-   *\n-   * @return A vector containing the repeated pattern\n-   */\n-  static std::vector<std::unique_ptr<AST::Token>> substitute_repetition (\n-    std::vector<std::unique_ptr<AST::Token>> &input,\n-    std::vector<std::unique_ptr<AST::Token>> &macro,\n-    std::map<std::string, std::vector<MatchedFragment>> &fragments,\n-    size_t pattern_start, size_t pattern_end);\n-\n-  /**\n-   * Substitute a given token by its appropriate representation\n-   *\n-   * @param macro Tokens used in the macro declaration\n-   * @param input Tokens given to the transcribing context\n-   * @param fragments Fragments given to the macro substitution\n-   * @param token Current token to try and substitute\n-   *\n-   * @return A token containing the associated fragment expanded into tokens if\n-   * any, or the cloned token if no fragment was associated, as well as the\n-   * amount of tokens that should be skipped before the next invocation. Since\n-   * this function may consume more than just one token, it is important to skip\n-   * ahead of the input to avoid mis-substitutions\n-   */\n-  static std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n-  substitute_token (\n-    std::vector<std::unique_ptr<AST::Token>> &input,\n-    std::vector<std::unique_ptr<AST::Token>> &macro,\n-    std::map<std::string, std::vector<MatchedFragment>> &fragments,\n-    size_t token_idx);\n-\n-  static std::vector<std::unique_ptr<AST::Token>> substitute_tokens (\n-    std::vector<std::unique_ptr<AST::Token>> &input,\n-    std::vector<std::unique_ptr<AST::Token>> &macro,\n-    std::map<std::string, std::vector<MatchedFragment>> &fragments);\n-\n   void push_context (ContextType t) { context.push_back (t); }\n \n   ContextType pop_context ()"}, {"sha": "8542614fb604335592b27187b87e99f5bf779876", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.cc", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc?ref=e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "patch": "@@ -0,0 +1,206 @@\n+#include \"rust-macro-substitute-ctx.h\"\n+\n+namespace Rust {\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+SubstituteCtx::substitute_metavar (std::unique_ptr<AST::Token> &metavar)\n+{\n+  auto metavar_name = metavar->get_str ();\n+\n+  std::vector<std::unique_ptr<AST::Token>> expanded;\n+  auto it = fragments.find (metavar_name);\n+  if (it == fragments.end ())\n+    {\n+      // Return a copy of the original token\n+      expanded.push_back (metavar->clone_token ());\n+    }\n+  else\n+    {\n+      // Replace\n+      // We only care about the vector when expanding repetitions. Just access\n+      // the first element of the vector.\n+      // FIXME: Clean this up so it makes more sense\n+      auto &frag = it->second[0];\n+      for (size_t offs = frag.token_offset_begin; offs < frag.token_offset_end;\n+\t   offs++)\n+\t{\n+\t  auto &tok = input.at (offs);\n+\t  expanded.push_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return expanded;\n+}\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+SubstituteCtx::substitute_repetition (size_t pattern_start, size_t pattern_end)\n+{\n+  rust_assert (pattern_end < macro.size ());\n+\n+  rust_debug (\"pattern start: %lu\", pattern_start);\n+  rust_debug (\"pattern end: %lu\", pattern_end);\n+\n+  std::vector<std::unique_ptr<AST::Token>> expanded;\n+\n+  // Find the first fragment and get the amount of repetitions that we should\n+  // perform\n+  size_t repeat_amount = 0;\n+  for (size_t i = pattern_start; i < pattern_end; i++)\n+    {\n+      if (macro.at (i)->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  auto &frag_token = macro.at (i + 1);\n+\t  if (frag_token->get_id () == IDENTIFIER)\n+\t    {\n+\t      auto it = fragments.find (frag_token->get_str ());\n+\t      if (it == fragments.end ())\n+\t\t{\n+\t\t  // If the repetition is not anything we know (ie no declared\n+\t\t  // metavars, or metavars which aren't present in the\n+\t\t  // fragment), we can just error out. No need to paste the\n+\t\t  // tokens as if nothing had happened.\n+\t\t  rust_error_at (frag_token->get_locus (),\n+\t\t\t\t \"metavar %s used in repetition does not exist\",\n+\t\t\t\t frag_token->get_str ().c_str ());\n+\t\t  // FIXME:\n+\t\t  return expanded;\n+\t\t}\n+\n+\t      // FIXME: Refactor, ugly\n+\t      repeat_amount = it->second[0].match_amount;\n+\t    }\n+\t}\n+    }\n+\n+  rust_debug (\"repetition amount to use: %lu\", repeat_amount);\n+  std::vector<std::unique_ptr<AST::Token>> new_macro;\n+\n+  // We want to generate a \"new macro\" to substitute with. This new macro\n+  // should contain only the tokens inside the pattern\n+  for (size_t tok_idx = pattern_start; tok_idx < pattern_end; tok_idx++)\n+    new_macro.emplace_back (macro.at (tok_idx)->clone_token ());\n+\n+  // Then, we want to create a subset of the matches so that\n+  // `substitute_tokens()` can only see one fragment per metavar. Let's say we\n+  // have the following user input: (1 145 'h')\n+  // on the following match arm: ($($lit:literal)*)\n+  // which causes the following matches: { \"lit\": [1, 145, 'h'] }\n+  //\n+  // The pattern (new_macro) is `$lit:literal`\n+  // The first time we expand it, we want $lit to have the following token: 1\n+  // The second time, 145\n+  // The third and final time, 'h'\n+  //\n+  // In order to do so we must create \"sub maps\", which only contain parts of\n+  // the original matches\n+  // sub-maps: [ { \"lit\": 1 }, { \"lit\": 145 }, { \"lit\": 'h' } ]\n+  //\n+  // and give them to `substitute_tokens` one by one.\n+\n+  for (size_t i = 0; i < repeat_amount; i++)\n+    {\n+      std::map<std::string, std::vector<MatchedFragment>> sub_map;\n+      for (auto &kv_match : fragments)\n+\t{\n+\t  std::vector<MatchedFragment> sub_vec;\n+\t  sub_vec.emplace_back (kv_match.second[i]);\n+\n+\t  sub_map.insert ({kv_match.first, sub_vec});\n+\t}\n+\n+      auto substitute_context = SubstituteCtx (input, new_macro, sub_map);\n+      auto new_tokens = substitute_context.substitute_tokens ();\n+\n+      for (auto &new_token : new_tokens)\n+\texpanded.emplace_back (new_token->clone_token ());\n+    }\n+\n+  // FIXME: We also need to make sure that all subsequent fragments\n+  // contain the same amount of repetitions as the first one\n+\n+  return expanded;\n+}\n+\n+std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n+SubstituteCtx::substitute_token (size_t token_idx)\n+{\n+  auto &token = macro.at (token_idx);\n+  switch (token->get_id ())\n+    {\n+    case IDENTIFIER:\n+      rust_debug (\"expanding metavar: %s\", token->get_str ().c_str ());\n+      return {substitute_metavar (token), 1};\n+      case LEFT_PAREN: {\n+\t// We need to parse up until the closing delimiter and expand this\n+\t// fragment->n times.\n+\trust_debug (\"expanding repetition\");\n+\tstd::vector<std::unique_ptr<AST::Token>> repetition_pattern;\n+\tsize_t pattern_start = token_idx + 1;\n+\tsize_t pattern_end = pattern_start;\n+\tfor (; pattern_end < macro.size ()\n+\t       && macro.at (pattern_end)->get_id () != RIGHT_PAREN;\n+\t     pattern_end++)\n+\t  ;\n+\n+\t// FIXME: This skips whitespaces... Is that okay??\n+\t// FIXME: Is there any existing parsing function that allows us to parse\n+\t// a macro pattern?\n+\n+\t// FIXME: Add error handling in the case we haven't found a matching\n+\t// closing delimiter\n+\n+\t// FIXME: We need to parse the repetition token now\n+\n+\treturn {\n+\t  substitute_repetition (pattern_start, pattern_end),\n+\t  // + 2 for the opening and closing parentheses which are mandatory\n+\t  // + 1 for the repetitor (+, *, ?)\n+\t  pattern_end - pattern_start + 3};\n+      }\n+      // TODO: We need to check if the $ was alone. In that case, do\n+      // not error out: Simply act as if there was an empty identifier\n+      // with no associated fragment and paste the dollar sign in the\n+      // transcription. Unsure how to do that since we always have at\n+      // least the closing curly brace after an empty $...\n+    default:\n+      rust_error_at (token->get_locus (),\n+\t\t     \"unexpected token in macro transcribe: expected \"\n+\t\t     \"%<(%> or identifier after %<$%>, got %<%s%>\",\n+\t\t     get_token_description (token->get_id ()));\n+    }\n+\n+  // FIXME: gcc_unreachable() error case?\n+  return {std::vector<std::unique_ptr<AST::Token>> (), 0};\n+}\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+SubstituteCtx::substitute_tokens ()\n+{\n+  std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n+\n+  for (size_t i = 0; i < macro.size (); i++)\n+    {\n+      auto &tok = macro.at (i);\n+      if (tok->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  // Aaaaah, if only we had C++17 :)\n+\t  // auto [expanded, tok_to_skip] = ...\n+\t  auto p = substitute_token (i + 1);\n+\t  auto expanded = std::move (p.first);\n+\t  auto tok_to_skip = p.second;\n+\n+\t  i += tok_to_skip;\n+\n+\t  for (auto &token : expanded)\n+\t    replaced_tokens.emplace_back (token->clone_token ());\n+\t}\n+      else\n+\t{\n+\t  replaced_tokens.emplace_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return replaced_tokens;\n+}\n+\n+} // namespace Rust"}, {"sha": "d51fb81c2c7756004997a76d8ac3521fff83b5fc", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82b59dfc9319d72f891bac099bfa0f46d8b8c99/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h?ref=e82b59dfc9319d72f891bac099bfa0f46d8b8c99", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast.h\"\n+#include \"rust-macro-expand.h\"\n+\n+namespace Rust {\n+class SubstituteCtx\n+{\n+  std::vector<std::unique_ptr<AST::Token>> &input;\n+  std::vector<std::unique_ptr<AST::Token>> &macro;\n+  std::map<std::string, std::vector<MatchedFragment>> &fragments;\n+\n+public:\n+  SubstituteCtx (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t std::vector<std::unique_ptr<AST::Token>> &macro,\n+\t\t std::map<std::string, std::vector<MatchedFragment>> &fragments)\n+    : input (input), macro (macro), fragments (fragments)\n+  {}\n+\n+  /**\n+   * Substitute a metavariable by its given fragment in a transcribing context,\n+   * i.e. replacing $var with the associated fragment.\n+   *\n+   * @param metavar Metavariable to try and replace\n+   *\n+   * @return A token containing the associated fragment expanded into tokens if\n+   * any, or the cloned token if no fragment was associated\n+   */\n+  std::vector<std::unique_ptr<AST::Token>>\n+  substitute_metavar (std::unique_ptr<AST::Token> &metavar);\n+\n+  /**\n+   * Substitute a macro repetition by its given fragments\n+   *\n+   * @param pattern_start Start index of the pattern tokens\n+   * @param pattern_end Index  Amount of tokens in the pattern\n+   *\n+   * @return A vector containing the repeated pattern\n+   */\n+  std::vector<std::unique_ptr<AST::Token>>\n+  substitute_repetition (size_t pattern_start, size_t pattern_end);\n+\n+  /**\n+   * Substitute a given token by its appropriate representation\n+   *\n+   * @param token_idx Current token to try and substitute\n+   *\n+   * @return A token containing the associated fragment expanded into tokens if\n+   * any, or the cloned token if no fragment was associated, as well as the\n+   * amount of tokens that should be skipped before the next invocation. Since\n+   * this function may consume more than just one token, it is important to skip\n+   * ahead of the input to avoid mis-substitutions\n+   */\n+  std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n+  substitute_token (size_t token_idx);\n+\n+  /**\n+   * Substitute all tokens by their appropriate representation\n+   *\n+   * @return A vector containing the substituted tokens\n+   */\n+  std::vector<std::unique_ptr<AST::Token>> substitute_tokens ();\n+};\n+} // namespace Rust"}]}