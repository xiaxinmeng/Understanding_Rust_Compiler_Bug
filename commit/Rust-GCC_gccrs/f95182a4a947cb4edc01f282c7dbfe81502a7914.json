{"sha": "f95182a4a947cb4edc01f282c7dbfe81502a7914", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk1MTgyYTRhOTQ3Y2I0ZWRjMDFmMjgyYzdkYmZlODE1MDJhNzkxNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-12-13T01:00:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-12-13T01:00:49Z"}, "message": "Check SMALL_REGISTER_CLASSES at runtime\n\nFrom-SVN: r13302", "tree": {"sha": "caede46b00bcf364b560a6857aad030dd987eaad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caede46b00bcf364b560a6857aad030dd987eaad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f95182a4a947cb4edc01f282c7dbfe81502a7914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95182a4a947cb4edc01f282c7dbfe81502a7914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95182a4a947cb4edc01f282c7dbfe81502a7914", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95182a4a947cb4edc01f282c7dbfe81502a7914/comments", "author": null, "committer": null, "parents": [{"sha": "6b9300aa7077c95105d86f66826e33ced678a1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9300aa7077c95105d86f66826e33ced678a1c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9300aa7077c95105d86f66826e33ced678a1c0"}], "stats": {"total": 168, "additions": 102, "deletions": 66}, "files": [{"sha": "b144845c7cd66d550101c0aab352e27f23eed40f", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -271,10 +271,11 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n #ifdef SMALL_REGISTER_CLASSES\n     /* If we are using registers for parameters, force the\n \t function address into a register now.  */\n-      reg_parm_seen ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n-\t\t    :\n+      (SMALL_REGISTER_CLASSES && reg_parm_seen)\n+       ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n+       :\n #endif\n-\t\t      memory_address (FUNCTION_MODE, funexp);\n+         memory_address (FUNCTION_MODE, funexp);\n   else\n     {\n #ifndef NO_FUNCTION_CSE\n@@ -1657,7 +1658,8 @@ expand_call (exp, target, ignore)\n \t    && args[i].mode != BLKmode\n \t    && rtx_cost (args[i].value, SET) > 2\n #ifdef SMALL_REGISTER_CLASSES\n-\t    && (reg_parm_seen || preserve_subexpressions_p ())\n+\t    && ((SMALL_REGISTER_CLASSES && reg_parm_seen)\n+\t\t|| preserve_subexpressions_p ())\n #else\n \t    && preserve_subexpressions_p ()\n #endif"}, {"sha": "38641104f19590dd11822b881e2d0f872fb12ae8", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -967,9 +967,10 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t      || (REGNO (src) < FIRST_PSEUDO_REGISTER\n \t\t  && (! HARD_REGNO_MODE_OK (REGNO (src), GET_MODE (src))\n #ifdef SMALL_REGISTER_CLASSES\n-\t\t      || (! all_adjacent && ! REG_USERVAR_P (src))\n-\t\t      || (FUNCTION_VALUE_REGNO_P (REGNO (src))\n-\t\t\t  && ! REG_USERVAR_P (src))\n+\t\t      || (SMALL_REGISTER_CLASSES\n+\t\t\t  && ((! all_adjacent && ! REG_USERVAR_P (src))\n+\t\t\t      || (FUNCTION_VALUE_REGNO_P (REGNO (src))\n+\t\t\t\t  && ! REG_USERVAR_P (src))))\n #endif\n \t\t      ))))\n \treturn 0;\n@@ -1152,7 +1153,8 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n \t      && (! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n \t\t\t\t\tGET_MODE (inner_dest))\n #ifdef SMALL_REGISTER_CLASSES\n-\t\t || (GET_CODE (src) != CALL && ! REG_USERVAR_P (inner_dest)\n+\t\t || (SMALL_REGISTER_CLASSES\n+\t\t     && GET_CODE (src) != CALL && ! REG_USERVAR_P (inner_dest)\n \t\t     && FUNCTION_VALUE_REGNO_P (REGNO (inner_dest)))\n #endif\n \t\t  ))\n@@ -1296,7 +1298,8 @@ try_combine (i3, i2, i1)\n       && GET_CODE (SET_SRC (PATTERN (i3))) == REG\n       && REGNO (SET_SRC (PATTERN (i3))) >= FIRST_PSEUDO_REGISTER\n #ifdef SMALL_REGISTER_CLASSES\n-      && (GET_CODE (SET_DEST (PATTERN (i3))) != REG\n+      && (! SMALL_REGISTER_CLASSES\n+\t  || GET_CODE (SET_DEST (PATTERN (i3))) != REG\n \t  || REGNO (SET_DEST (PATTERN (i3))) >= FIRST_PSEUDO_REGISTER\n \t  || REG_USERVAR_P (SET_DEST (PATTERN (i3))))\n #endif"}, {"sha": "e6c7e9f5e6e88f7f8bfea77a1eb74d9ec1fb6f9a", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -1891,7 +1891,8 @@ canon_hash (x, mode)\n \tif (regno < FIRST_PSEUDO_REGISTER\n \t    && (global_regs[regno]\n #ifdef SMALL_REGISTER_CLASSES\n-\t\t|| (! fixed_regs[regno]\n+\t\t|| (SMALL_REGISTER_CLASSES\n+\t\t    && ! fixed_regs[regno]\n \t\t    && regno != FRAME_POINTER_REGNUM\n \t\t    && regno != HARD_FRAME_POINTER_REGNUM\n \t\t    && regno != ARG_POINTER_REGNUM"}, {"sha": "d488be1936c1acb92bc7cf4981216e1d17f79235", "filename": "gcc/function.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -1578,27 +1578,30 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \t\t of the CALL_INSN and see if the next insn uses both that\n \t\t and VAR.  */\n \n-\t      if (call_dest != 0 && GET_CODE (insn) == INSN\n-\t\t  && reg_mentioned_p (var, PATTERN (insn))\n-\t\t  && reg_mentioned_p (call_dest, PATTERN (insn)))\n+\t      if (SMALL_REGISTER_CLASSES)\n \t\t{\n-\t\t  rtx temp = gen_reg_rtx (GET_MODE (call_dest));\n+\t\t  if (call_dest != 0 && GET_CODE (insn) == INSN\n+\t\t      && reg_mentioned_p (var, PATTERN (insn))\n+\t\t      && reg_mentioned_p (call_dest, PATTERN (insn)))\n+\t\t    {\n+\t\t      rtx temp = gen_reg_rtx (GET_MODE (call_dest));\n \n-\t\t  emit_insn_before (gen_move_insn (temp, call_dest), insn);\n+\t\t      emit_insn_before (gen_move_insn (temp, call_dest), insn);\n \n-\t\t  PATTERN (insn) = replace_rtx (PATTERN (insn),\n-\t\t\t\t\t\tcall_dest, temp);\n-\t\t}\n+\t\t      PATTERN (insn) = replace_rtx (PATTERN (insn),\n+\t\t\t\t\t\t    call_dest, temp);\n+\t\t    }\n \t      \n-\t      if (GET_CODE (insn) == CALL_INSN\n-\t\t  && GET_CODE (PATTERN (insn)) == SET)\n-\t\tcall_dest = SET_DEST (PATTERN (insn));\n-\t      else if (GET_CODE (insn) == CALL_INSN\n-\t\t       && GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t\tcall_dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n-\t      else\n-\t\tcall_dest = 0;\n+\t\t  if (GET_CODE (insn) == CALL_INSN\n+\t\t      && GET_CODE (PATTERN (insn)) == SET)\n+\t\t    call_dest = SET_DEST (PATTERN (insn));\n+\t\t  else if (GET_CODE (insn) == CALL_INSN\n+\t\t\t   && GET_CODE (PATTERN (insn)) == PARALLEL\n+\t\t\t   && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n+\t\t    call_dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t\t  else\n+\t\t    call_dest = 0;\n+\t\t}\n #endif\n \n \t      /* See if we have to do anything to INSN now that VAR is in\n@@ -5163,7 +5166,8 @@ expand_function_start (subr, parms_have_cleanups)\n #ifdef SMALL_REGISTER_CLASSES\n       /* Delay copying static chain if it is not a register to avoid\n \t conflicts with regs used for parameters.  */\n-      if (GET_CODE (static_chain_incoming_rtx) == REG)\n+      if (! SMALL_REGISTER_CLASSES\n+\t  || GET_CODE (static_chain_incoming_rtx) == REG)\n #endif\n         emit_move_insn (last_ptr, static_chain_incoming_rtx);\n     }\n@@ -5277,7 +5281,7 @@ expand_function_start (subr, parms_have_cleanups)\n   /* Copy the static chain now if it wasn't a register.  The delay is to\n      avoid conflicts with the parameter passing registers.  */\n \n-  if (current_function_needs_context)\n+  if (SMALL_REGISTER_CLASSES && current_function_needs_context)\n       if (GET_CODE (static_chain_incoming_rtx) != REG)\n         emit_move_insn (last_ptr, static_chain_incoming_rtx);\n #endif\n@@ -5319,7 +5323,8 @@ expand_function_start (subr, parms_have_cleanups)\n \t  /* If the static chain originally came in a register, put it back\n \t     there, then move it out in the next insn.  The reason for\n \t     this peculiar code is to satisfy function integration.  */\n-\t  if (GET_CODE (static_chain_incoming_rtx) == REG)\n+\t  if (SMALL_REGISTER_CLASSES\n+\t      && GET_CODE (static_chain_incoming_rtx) == REG)\n \t    emit_move_insn (static_chain_incoming_rtx, last_ptr);\n #endif\n "}, {"sha": "5353c58fdccea0d2ac8a229faa021961fe67c021", "filename": "gcc/jump.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -761,7 +761,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && (temp4 = single_set (temp3)) != 0\n \t      && GET_CODE (temp1 = SET_DEST (temp4)) == REG\n #ifdef SMALL_REGISTER_CLASSES\n-\t      && REGNO (temp1) >= FIRST_PSEUDO_REGISTER\n+\t      && (! SMALL_REGISTER_CLASSES\n+\t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t      && (temp2 = next_active_insn (insn)) != 0\n \t      && GET_CODE (temp2) == INSN\n@@ -898,7 +899,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && (temp4 = single_set (temp2)) != 0\n \t      && GET_CODE (temp1 = SET_DEST (temp4)) == REG\n #ifdef SMALL_REGISTER_CLASSES\n-\t      && REGNO (temp1) >= FIRST_PSEUDO_REGISTER\n+\t      && (! SMALL_REGISTER_CLASSES\n+\t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n #endif\n \n \t      && (temp3 = prev_active_insn (insn)) != 0\n@@ -987,7 +989,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && (temp2 = SET_DEST (temp1), GET_CODE (temp2) == REG)\n \t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n #ifdef SMALL_REGISTER_CLASSES\n-\t      && REGNO (temp2) >= FIRST_PSEUDO_REGISTER\n+\t      && (! SMALL_REGISTER_CLASSES\n+\t\t  || REGNO (temp2) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t      && GET_CODE (SET_SRC (temp1)) != REG\n \t      && GET_CODE (SET_SRC (temp1)) != SUBREG\n@@ -1029,7 +1032,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && (temp2 = SET_DEST (temp1), GET_CODE (temp2) == REG)\n \t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n #ifdef SMALL_REGISTER_CLASSES\n-\t      && REGNO (temp2) >= FIRST_PSEUDO_REGISTER\n+\t      && (! SMALL_REGISTER_CLASSES\n+\t\t  || REGNO (temp2) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t      && ! side_effects_p (SET_SRC (temp1))\n \t      && ! may_trap_p (SET_SRC (temp1))\n@@ -1090,7 +1094,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && (temp2 = SET_DEST (temp4), GET_CODE (temp2) == REG)\n \t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n #ifdef SMALL_REGISTER_CLASSES\n-\t      && REGNO (temp2) >= FIRST_PSEUDO_REGISTER\n+\t      && (! SMALL_REGISTER_CLASSES\n+\t\t  || REGNO (temp2) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t      && rtx_equal_p (SET_DEST (temp4), temp2)\n \t      && ! side_effects_p (SET_SRC (temp4))\n@@ -1143,7 +1148,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && GET_CODE (PATTERN (temp)) == SET\n \t      && GET_CODE (temp1 = SET_DEST (PATTERN (temp))) == REG\n #ifdef SMALL_REGISTER_CLASSES\n-\t      && REGNO (temp1) >= FIRST_PSEUDO_REGISTER\n+\t      && (! SMALL_REGISTER_CLASSES\n+\t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n #endif\n \t      && (GET_CODE (temp2 = SET_SRC (PATTERN (temp))) == REG\n \t\t  || GET_CODE (temp2) == SUBREG"}, {"sha": "b41a99b75f9892d59d884b9f62079e16c3df2a88", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -715,7 +715,9 @@ optimize_reg_copy_1 (insn, dest, src)\n   if (sregno == dregno\n #ifdef SMALL_REGISTER_CLASSES\n       /* We don't want to mess with hard regs if register classes are small. */\n-      || sregno < FIRST_PSEUDO_REGISTER || dregno < FIRST_PSEUDO_REGISTER\n+      || (SMALL_REGISTER_CLASSES\n+\t  && (sregno < FIRST_PSEUDO_REGISTER\n+\t      || dregno < FIRST_PSEUDO_REGISTER))\n #endif\n       /* We don't see all updates to SP if they are in an auto-inc memory\n \t reference, so we must disallow this optimization on them.  */"}, {"sha": "2ffad5fe41d302fe3b715ecae9773f30442a0b5e", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -742,7 +742,8 @@ scan_loop (loop_start, end, nregs)\n \t\t  && ! side_effects_p (SET_SRC (set))\n \t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n #ifdef SMALL_REGISTER_CLASSES\n-\t\t  && ! (GET_CODE (SET_SRC (set)) == REG\n+\t\t  && ! (SMALL_REGISTER_CLASSES\n+\t\t\t&& GET_CODE (SET_SRC (set)) == REG\n \t\t\t&& REGNO (SET_SRC (set)) < FIRST_PSEUDO_REGISTER)\n #endif\n \t\t  /* This test is not redundant; SET_SRC (set) might be\n@@ -4257,9 +4258,13 @@ valid_initial_value_p (x, insn, call_seen, loop_start)\n   /* Don't use call-clobbered registers across a call which clobbers it.  On\n      some machines, don't use any hard registers at all.  */\n   if (REGNO (x) < FIRST_PSEUDO_REGISTER\n-#ifndef SMALL_REGISTER_CLASSES\n-      && call_used_regs[REGNO (x)] && call_seen\n+      && (\n+#ifdef SMALL_REGISTER_CLASSES\n+          SMALL_REGISTER_CLASSES\n+#else\n+\t  0\n #endif\n+\t    || (call_used_regs[REGNO (x)] && call_seen))\n       )\n     return 0;\n "}, {"sha": "6d8b2b9a5c4721a43c387de4b8a58db91d221175", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -477,7 +477,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t\t\t      == CODE_FOR_nothing)))\n \t    && (reg_class_size[(int) t_class] == 1\n #ifdef SMALL_REGISTER_CLASSES\n-\t\t|| 1\n+\t\t|| SMALL_REGISTER_CLASSES\n #endif\n \t\t)\n \t    && MERGABLE_RELOADS (secondary_type,\n@@ -538,7 +538,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t    || (! in_p && reload_secondary_out_icode[s_reload] == t_icode))\n \t&& (reg_class_size[(int) class] == 1\n #ifdef SMALL_REGISTER_CLASSES\n-\t    || 1\n+\t    || SMALL_REGISTER_CLASSES\n #endif\n \t    )\n \t&& MERGABLE_RELOADS (secondary_type, reload_when_needed[s_reload],\n@@ -1157,7 +1157,7 @@ push_reload (in, out, inloc, outloc, class,\n \t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in))))\n \t&& (reg_class_size[(int) class] == 1\n #ifdef SMALL_REGISTER_CLASSES\n-\t    || 1\n+\t    || SMALL_REGISTER_CLASSES\n #endif\n \t    )\n \t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n@@ -1193,7 +1193,7 @@ push_reload (in, out, inloc, outloc, class,\n \t       && MATCHES (XEXP (in, 0), reload_in[i])))\n \t  && (reg_class_size[(int) class] == 1\n #ifdef SMALL_REGISTER_CLASSES\n-\t      || 1\n+\t      || SMALL_REGISTER_CLASSES\n #endif\n \t      )\n \t  && MERGABLE_RELOADS (type, reload_when_needed[i],\n@@ -1534,14 +1534,17 @@ combine_reloads ()\n \t    || rtx_equal_p (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]],\n \t\t\t    secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]]))\n #endif\n+\t&& (\n #ifdef SMALL_REGISTER_CLASSES\n-\t&& reload_reg_class[i] == reload_reg_class[output_reload]\n+\t    SMALL_REGISTER_CLASSES\n #else\n-\t&& (reg_class_subset_p (reload_reg_class[i],\n-\t\t\t\treload_reg_class[output_reload])\n-\t    || reg_class_subset_p (reload_reg_class[output_reload],\n-\t\t\t\t   reload_reg_class[i]))\n+\t    0\n #endif\n+\t      ? reload_reg_class[i] == reload_reg_class[output_reload]\n+\t      : (reg_class_subset_p (reload_reg_class[i],\n+\t\t\t\t     reload_reg_class[output_reload])\n+\t\t || reg_class_subset_p (reload_reg_class[output_reload],\n+\t\t\t\t\treload_reg_class[i])))\n \t&& (MATCHES (reload_in[i], reload_out[output_reload])\n \t    /* Args reversed because the first arg seems to be\n \t       the one that we imagine being modified\n@@ -1559,7 +1562,7 @@ combine_reloads ()\n \t\t\t\t\t\t\t     reload_out[output_reload]))))\n \t&& (reg_class_size[(int) reload_reg_class[i]]\n #ifdef SMALL_REGISTER_CLASSES\n-\t     || 1\n+\t     || SMALL_REGISTER_CLASSES\n #endif\n \t    )\n \t/* We will allow making things slightly worse by combining an"}, {"sha": "a102ccbaa0c881b5cc157b2d604645116b8c8e78", "filename": "gcc/reload1.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95182a4a947cb4edc01f282c7dbfe81502a7914/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f95182a4a947cb4edc01f282c7dbfe81502a7914", "patch": "@@ -544,7 +544,8 @@ reload (first, global, dumpfile)\n   bzero (cannot_omit_stores, max_regno);\n \n #ifdef SMALL_REGISTER_CLASSES\n-  CLEAR_HARD_REG_SET (forbidden_regs);\n+  if (SMALL_REGISTER_CLASSES)\n+    CLEAR_HARD_REG_SET (forbidden_regs);\n #endif\n \n   /* Look for REG_EQUIV notes; record what each pseudo is equivalent to.\n@@ -722,9 +723,10 @@ reload (first, global, dumpfile)\n      rtl as a spill register.  But on some, we have to.  Those will have\n      taken care to keep the life of hard regs as short as possible.  */\n \n-#ifndef SMALL_REGISTER_CLASSES\n-  COPY_HARD_REG_SET (forbidden_regs, bad_spill_regs);\n+#ifdef SMALL_REGISTER_CLASSES\n+  if (! SMALL_REGISTER_CLASSES)\n #endif\n+    COPY_HARD_REG_SET (forbidden_regs, bad_spill_regs);\n \n   /* Spill any hard regs that we know we can't eliminate.  */\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n@@ -986,7 +988,7 @@ reload (first, global, dumpfile)\n #ifdef SMALL_REGISTER_CLASSES\n \t      /* Set avoid_return_reg if this is an insn\n \t\t that might use the value of a function call.  */\n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (SMALL_REGISTER_CLASSES && GET_CODE (insn) == CALL_INSN)\n \t\t{\n \t\t  if (GET_CODE (PATTERN (insn)) == SET)\n \t\t    after_call = SET_DEST (PATTERN (insn));\n@@ -996,7 +998,8 @@ reload (first, global, dumpfile)\n \t\t  else\n \t\t    after_call = 0;\n \t\t}\n-\t      else if (after_call != 0\n+\t      else if (SMALL_REGISTER_CLASSES\n+\t\t       && after_call != 0\n \t\t       && !(GET_CODE (PATTERN (insn)) == SET\n \t\t\t    && SET_DEST (PATTERN (insn)) == stack_pointer_rtx))\n \t\t{\n@@ -1344,7 +1347,7 @@ reload (first, global, dumpfile)\n \t\t This makes sure we have a register available that does\n \t\t not overlap the return value.  */\n \n-\t      if (avoid_return_reg)\n+\t      if (SMALL_REGISTER_CLASSES && avoid_return_reg)\n \t\t{\n \t\t  int regno = REGNO (avoid_return_reg);\n \t\t  int nregs\n@@ -1702,7 +1705,7 @@ reload (first, global, dumpfile)\n \t\t  /* We can't complete a group, so start one.  */\n #ifdef SMALL_REGISTER_CLASSES\n \t\t  /* Look for a pair neither of which is explicitly used.  */\n-\t\t  if (i == FIRST_PSEUDO_REGISTER)\n+\t\t  if (SMALL_REGISTER_CLASSES && i == FIRST_PSEUDO_REGISTER)\n \t\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t      {\n \t\t\tint k;\n@@ -3584,7 +3587,9 @@ scan_paradoxical_subregs (x)\n     {\n     case REG:\n #ifdef SMALL_REGISTER_CLASSES\n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER && REG_USERVAR_P (x))\n+      if (SMALL_REGISTER_CLASSES\n+\t  && REGNO (x) < FIRST_PSEUDO_REGISTER\n+\t  && REG_USERVAR_P (x))\n \tSET_HARD_REG_BIT (forbidden_regs, REGNO (x));\n #endif\n       return;\n@@ -3698,14 +3703,15 @@ order_regs_for_reload (global)\n       else if (regs_explicitly_used[i])\n \t{\n \t  hard_reg_n_uses[i].uses += large + 1;\n-#ifndef SMALL_REGISTER_CLASSES\n \t  /* ??? We are doing this here because of the potential that\n \t     bad code may be generated if a register explicitly used in\n \t     an insn was used as a spill register for that insn.  But\n \t     not using these are spill registers may lose on some machine.\n \t     We'll have to see how this works out.  */\n-\t  SET_HARD_REG_BIT (bad_spill_regs, i);\n+#ifdef SMALL_REGISTER_CLASSES\n+\t  if (! SMALL_REGISTER_CLASSES)\n #endif\n+\t    SET_HARD_REG_BIT (bad_spill_regs, i);\n \t}\n     }\n   hard_reg_n_uses[HARD_FRAME_POINTER_REGNUM].uses += 2 * large + 2;\n@@ -3859,7 +3865,7 @@ reload_as_needed (first, live_known)\n #ifdef SMALL_REGISTER_CLASSES\n \t  /* Set avoid_return_reg if this is an insn\n \t     that might use the value of a function call.  */\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (SMALL_REGISTER_CLASSES && GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == SET)\n \t\tafter_call = SET_DEST (PATTERN (insn));\n@@ -3869,7 +3875,8 @@ reload_as_needed (first, live_known)\n \t      else\n \t\tafter_call = 0;\n \t    }\n-\t  else if (after_call != 0\n+\t  else if (SMALL_REGISTER_CLASSES\n+\t\t   && after_call != 0\n \t\t   && !(GET_CODE (PATTERN (insn)) == SET\n \t\t\t&& SET_DEST (PATTERN (insn)) == stack_pointer_rtx))\n \t    {\n@@ -3947,7 +3954,8 @@ reload_as_needed (first, live_known)\n \t      /* Merge any reloads that we didn't combine for fear of \n \t\t increasing the number of spill registers needed but now\n \t\t discover can be safely merged.  */\n-\t      merge_assigned_reloads (insn);\n+\t      if (SMALL_REGISTER_CLASSES)\n+\t\tmerge_assigned_reloads (insn);\n #endif\n \n \t      /* Generate the insns to reload operands into or out of\n@@ -4991,7 +4999,7 @@ choose_reload_regs (insn, avoid_return_reg)\n #ifdef SMALL_REGISTER_CLASSES\n   /* Don't bother with avoiding the return reg\n      if we have no mandatory reload that could use it.  */\n-  if (avoid_return_reg)\n+  if (SMALL_REGISTER_CLASSES && avoid_return_reg)\n     {\n       int do_avoid = 0;\n       int regno = REGNO (avoid_return_reg);\n@@ -5024,7 +5032,8 @@ choose_reload_regs (insn, avoid_return_reg)\n   {\n     int tem = 0;\n #ifdef SMALL_REGISTER_CLASSES\n-    int tem = (avoid_return_reg != 0);\n+    if (SMALL_REGISTER_CLASSES)\n+      tem = (avoid_return_reg != 0);\n #endif\n     for (j = 0; j < n_reloads; j++)\n       if (! reload_optional[j]\n@@ -5041,7 +5050,7 @@ choose_reload_regs (insn, avoid_return_reg)\n #ifdef SMALL_REGISTER_CLASSES\n   /* Don't use the subroutine call return reg for a reload\n      if we are supposed to avoid it.  */\n-  if (avoid_return_reg)\n+  if (SMALL_REGISTER_CLASSES && avoid_return_reg)\n     {\n       int regno = REGNO (avoid_return_reg);\n       int nregs"}]}