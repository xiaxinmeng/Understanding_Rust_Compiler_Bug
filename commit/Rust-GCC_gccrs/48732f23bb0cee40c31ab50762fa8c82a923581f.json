{"sha": "48732f23bb0cee40c31ab50762fa8c82a923581f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg3MzJmMjNiYjBjZWU0MGMzMWFiNTA3NjJmYThjODJhOTIzNTgxZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-15T04:38:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-15T04:38:04Z"}, "message": "tree-ssa-dom.c (avail_exprs_stack): New global varray.\n\n        * tree-ssa-dom.c (avail_exprs_stack): New global varray.\n        (struct dom_walk_block_data): Remove avail_exprs member.\n        (tree_ssa_dominator_optimize): Initialize avail_exprs_stack.\n        (lookup_avail_expr): No longer need to pass in address of\n        the block local available exprs stack.  All callers changed.\n        (simplify_cond_and_lookup_avail_expr): Similarly.\n        (simplify_switch_and_lookup_avail_expr): Similarly.\n        (get_eq_expr_value, record_cond): Likewise.\n        (record_dominating_conditions): Likewise.\n        (update_rhs_and_lookup_avail_expr): Likewise.\n        (record_equivalences_from_stmt): Likewise.\n        (dom_opt_initialize_block_local_data): No longer test state of\n        block local avail_exprs.\n        (dom_opt_initialize_block): Mark unwind point in the global\n        avail_expr stack.\n        (remove_expressions_from_table): Update to unwind to the\n        most recent unwind marker in the global avail_expr stack.\n        All callers changed.\n        (dom_opt_finalize_block): Mark unwind point in the global\n        avail_expr stack as needed.\n        (record_cond): Push elements into the global avail_exprs stack.\n\nFrom-SVN: r87532", "tree": {"sha": "d41c1426ceec349a5a90d87f18951c39d426d0b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d41c1426ceec349a5a90d87f18951c39d426d0b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48732f23bb0cee40c31ab50762fa8c82a923581f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48732f23bb0cee40c31ab50762fa8c82a923581f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48732f23bb0cee40c31ab50762fa8c82a923581f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48732f23bb0cee40c31ab50762fa8c82a923581f/comments", "author": null, "committer": null, "parents": [{"sha": "a5c965c17ef36c215673c1b3bc01eff0780b3fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c965c17ef36c215673c1b3bc01eff0780b3fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c965c17ef36c215673c1b3bc01eff0780b3fcc"}], "stats": {"total": 285, "additions": 122, "deletions": 163}, "files": [{"sha": "481f600082bc55065b6c3bf5a3c244ebb7741efd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48732f23bb0cee40c31ab50762fa8c82a923581f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48732f23bb0cee40c31ab50762fa8c82a923581f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48732f23bb0cee40c31ab50762fa8c82a923581f", "patch": "@@ -1,5 +1,27 @@\n 2004-09-14 Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-dom.c (avail_exprs_stack): New global varray.\n+\t(struct dom_walk_block_data): Remove avail_exprs member.\n+\t(tree_ssa_dominator_optimize): Initialize avail_exprs_stack.\n+\t(lookup_avail_expr): No longer need to pass in address of\n+\tthe block local available exprs stack.  All callers changed.\n+\t(simplify_cond_and_lookup_avail_expr): Similarly.\n+\t(simplify_switch_and_lookup_avail_expr): Similarly.\n+\t(get_eq_expr_value, record_cond): Likewise.\n+\t(record_dominating_conditions): Likewise.\n+\t(update_rhs_and_lookup_avail_expr): Likewise.\n+\t(record_equivalences_from_stmt): Likewise.\n+\t(dom_opt_initialize_block_local_data): No longer test state of\n+\tblock local avail_exprs.\n+\t(dom_opt_initialize_block): Mark unwind point in the global\n+\tavail_expr stack.\n+\t(remove_expressions_from_table): Update to unwind to the\n+\tmost recent unwind marker in the global avail_expr stack.\n+\tAll callers changed.\n+\t(dom_opt_finalize_block): Mark unwind point in the global\n+\tavail_expr stack as needed.\n+\t(record_cond): Push elements into the global avail_exprs stack.\n+\n \t* tree-dfa.c (free_df_for_stmt): No longer static.\n \t(free_df): Update comments.\n \t* tree-flow.h (free_df_for_stmt): Prototype."}, {"sha": "f090c8738d1abb20c40da5695c20fd433b6e6673", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 100, "deletions": 163, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48732f23bb0cee40c31ab50762fa8c82a923581f/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48732f23bb0cee40c31ab50762fa8c82a923581f/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=48732f23bb0cee40c31ab50762fa8c82a923581f", "patch": "@@ -53,6 +53,13 @@ Boston, MA 02111-1307, USA.  */\n    in this table.  */\n static htab_t avail_exprs;\n \n+/* Stack of available expressions in AVAIL_EXPRs.  Each block pushes any\n+   expressions it enters into the hash table along with a marker entry\n+   (null).  When we finsh processing the block, we pop off entries and\n+   remove the expressions from the global hash table until we hit the\n+   marker.  */\n+static varray_type avail_exprs_stack;\n+\n /* Stack of statements we need to rescan during finalization for newly\n    exposed variables.\n \n@@ -180,12 +187,6 @@ static varray_type vrp_data;\n \n struct dom_walk_block_data\n {\n-  /* Array of all the expressions entered into the global expression\n-     hash table by this block.  During finalization we use this array to\n-     know what expressions to remove from the global expression hash\n-     table.  */\n-  varray_type avail_exprs;\n-\n   /* Array of dest, src pairs that need to be restored during finalization\n      into the global const/copies table during finalization.  */\n   varray_type const_and_copies;\n@@ -217,23 +218,22 @@ static void optimize_stmt (struct dom_walk_data *,\n \t\t\t   block_stmt_iterator);\n static inline tree get_value_for (tree, varray_type table);\n static inline void set_value_for (tree, tree, varray_type table);\n-static tree lookup_avail_expr (tree, varray_type *, bool);\n-static struct eq_expr_value get_eq_expr_value (tree, int, varray_type *,\n+static tree lookup_avail_expr (tree, bool);\n+static struct eq_expr_value get_eq_expr_value (tree, int,\n \t\t\t\t\t       basic_block, varray_type *);\n static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n static void htab_statistics (FILE *, htab_t);\n-static void record_cond (tree, tree, varray_type *);\n-static void record_dominating_conditions (tree, varray_type *);\n+static void record_cond (tree, tree);\n+static void record_dominating_conditions (tree);\n static void record_const_or_copy (tree, tree, varray_type *);\n static void record_equality (tree, tree, varray_type *);\n-static tree update_rhs_and_lookup_avail_expr (tree, tree, varray_type *, bool);\n+static tree update_rhs_and_lookup_avail_expr (tree, tree, bool);\n static tree simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *,\n \t\t\t\t\t\ttree, int);\n-static tree simplify_cond_and_lookup_avail_expr (tree, varray_type *,\n-\t\t\t\t\t\t stmt_ann_t, int);\n-static tree simplify_switch_and_lookup_avail_expr (tree, varray_type *, int);\n+static tree simplify_cond_and_lookup_avail_expr (tree, stmt_ann_t, int);\n+static tree simplify_switch_and_lookup_avail_expr (tree, int);\n static tree find_equivalent_equality_comparison (tree);\n static void record_range (tree, basic_block, varray_type *);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n@@ -242,17 +242,15 @@ static void record_equivalences_from_incoming_edge (struct dom_walk_data *,\n \t\t\t\t\t\t    basic_block);\n static bool eliminate_redundant_computations (struct dom_walk_data *,\n \t\t\t\t\t      tree, stmt_ann_t);\n-static void record_equivalences_from_stmt (tree, varray_type *, varray_type *,\n+static void record_equivalences_from_stmt (tree, varray_type *,\n \t\t\t\t\t   int, stmt_ann_t);\n static void thread_across_edge (struct dom_walk_data *, edge);\n static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n static void dom_opt_initialize_block_local_data (struct dom_walk_data *,\n \t\t\t\t\t\t basic_block, bool);\n static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n static void cprop_into_phis (struct dom_walk_data *, basic_block);\n-static void remove_local_expressions_from_table (varray_type locals,\n-\t\t\t\t\t\t unsigned limit,\n-\t\t\t\t\t\t htab_t table);\n+static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (varray_type locals,\n \t\t\t\t\t    unsigned limit, \n \t\t\t\t\t    varray_type table);\n@@ -314,6 +312,7 @@ tree_ssa_dominator_optimize (void)\n \n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n+  VARRAY_TREE_INIT (avail_exprs_stack, 20, \"Available expression stack\");\n   VARRAY_TREE_INIT (const_and_copies, num_ssa_names, \"const_and_copies\");\n   nonzero_vars = BITMAP_XMALLOC ();\n   VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n@@ -489,7 +488,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       if (TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME)\n \tcached_lhs = TREE_OPERAND (stmt, 1);\n       else\n-\tcached_lhs = lookup_avail_expr (stmt, NULL, false);\n+\tcached_lhs = lookup_avail_expr (stmt, false);\n \n       lhs = TREE_OPERAND (stmt, 0);\n \n@@ -535,7 +534,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t    }\n \n \t  /* Try to lookup the new expression.  */\n-\t  cached_lhs = lookup_avail_expr (stmt, NULL, false);\n+\t  cached_lhs = lookup_avail_expr (stmt, false);\n \n \t  /* Restore the statement's original uses/defs.  */\n \t  for (i = 0; i < NUM_USES (uses); i++)\n@@ -654,11 +653,10 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t     otherwise look it up in the hash tables.  */\n \t  cached_lhs = local_fold (COND_EXPR_COND (dummy_cond));\n \t  if (! is_gimple_min_invariant (cached_lhs))\n-\t    cached_lhs = lookup_avail_expr (dummy_cond, NULL, false);\n+\t    cached_lhs = lookup_avail_expr (dummy_cond, false);\n  \t  if (!cached_lhs || ! is_gimple_min_invariant (cached_lhs))\n \t    {\n \t      cached_lhs = simplify_cond_and_lookup_avail_expr (dummy_cond,\n-\t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\tfalse);\n \t    }\n@@ -674,7 +672,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t    cached_lhs = 0;\n \t}\n       else\n-\tcached_lhs = lookup_avail_expr (stmt, NULL, false);\n+\tcached_lhs = lookup_avail_expr (stmt, false);\n \n       if (cached_lhs)\n \t{\n@@ -730,8 +728,6 @@ dom_opt_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n      make sure we clear them before using them!  */\n   if (recycled)\n     {\n-      gcc_assert (!bd->avail_exprs\n-\t\t  || VARRAY_ACTIVE_SIZE (bd->avail_exprs) == 0);\n       gcc_assert (!bd->const_and_copies\n \t\t  || VARRAY_ACTIVE_SIZE (bd->const_and_copies) == 0);\n       gcc_assert (!bd->nonzero_vars\n@@ -753,6 +749,10 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n \n+  /* Push a marker on AVAIL_EXPRS_STACK so that we know how far to unwind\n+     when we finalize this blcok.  */\n+  VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n+\n   record_equivalences_from_incoming_edge (walk_data, bb);\n \n   /* PHI nodes can create equivalences too.  */\n@@ -805,22 +805,20 @@ initialize_hash_element (tree expr, tree lhs, struct expr_hash_elt *element)\n    LIMIT entries left in LOCALs.  */\n \n static void\n-remove_local_expressions_from_table (varray_type locals,\n-\t\t\t\t     unsigned limit,\n-\t\t\t\t     htab_t table)\n+remove_local_expressions_from_table (void)\n {\n-  if (! locals)\n-    return;\n-\n   /* Remove all the expressions made available in this block.  */\n-  while (VARRAY_ACTIVE_SIZE (locals) > limit)\n+  while (VARRAY_ACTIVE_SIZE (avail_exprs_stack) > 0)\n     {\n       struct expr_hash_elt element;\n-      tree expr = VARRAY_TOP_TREE (locals);\n-      VARRAY_POP (locals);\n+      tree expr = VARRAY_TOP_TREE (avail_exprs_stack);\n+      VARRAY_POP (avail_exprs_stack);\n+\n+      if (expr == NULL_TREE)\n+\tbreak;\n \n       initialize_hash_element (expr, NULL, &element);\n-      htab_remove_elt_with_hash (table, &element, element.hash);\n+      htab_remove_elt_with_hash (avail_exprs, &element, element.hash);\n     }\n }\n \n@@ -953,24 +951,26 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n       if (get_immediate_dominator (CDI_DOMINATORS, true_edge->dest) != bb\n \t  || phi_nodes (true_edge->dest))\n \t{\n-\t  unsigned avail_expr_limit;\n \t  unsigned const_and_copies_limit;\n \t  unsigned currdefs_limit;\n \n-\t  avail_expr_limit\n-\t    = bd->avail_exprs ? VARRAY_ACTIVE_SIZE (bd->avail_exprs) : 0;\n \t  const_and_copies_limit\n \t    = bd->const_and_copies ? VARRAY_ACTIVE_SIZE (bd->const_and_copies)\n \t\t\t\t   : 0;\n \t  currdefs_limit\n \t    = bd->block_defs ? VARRAY_ACTIVE_SIZE (bd->block_defs) : 0;\n \n+\t  /* Push a marker onto the available expression stack so that we\n+\t     unwind any expressions related to the TRUE arm before processing\n+\t     the false arm below.  */\n+\t  VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n+\n \t  /* Record any equivalences created by following this edge.  */\n \t  if (TREE_CODE_CLASS (cond_code) == '<')\n \t    {\n-\t      record_cond (cond, boolean_true_node, &bd->avail_exprs);\n-\t      record_dominating_conditions (cond, &bd->avail_exprs);\n-\t      record_cond (inverted, boolean_false_node, &bd->avail_exprs);\n+\t      record_cond (cond, boolean_true_node);\n+\t      record_dominating_conditions (cond);\n+\t      record_cond (inverted, boolean_false_node);\n \t    }\n \t  else if (cond_code == SSA_NAME)\n \t    record_const_or_copy (cond, boolean_true_node,\n@@ -981,9 +981,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n \t  /* And restore the various tables to their state before\n \t     we threaded this edge.  */\n-\t  remove_local_expressions_from_table (bd->avail_exprs,\n-\t\t\t\t\t       avail_expr_limit,\n-\t\t\t\t\t       avail_exprs);\n+\t  remove_local_expressions_from_table ();\n \t  restore_vars_to_original_value (bd->const_and_copies,\n \t\t\t\t\t  const_and_copies_limit,\n \t\t\t\t\t  const_and_copies);\n@@ -997,9 +995,9 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  /* Record any equivalences created by following this edge.  */\n \t  if (TREE_CODE_CLASS (cond_code) == '<')\n \t    {\n-\t      record_cond (cond, boolean_false_node, &bd->avail_exprs);\n-\t      record_cond (inverted, boolean_true_node, &bd->avail_exprs);\n-\t      record_dominating_conditions (inverted, &bd->avail_exprs);\n+\t      record_cond (cond, boolean_false_node);\n+\t      record_cond (inverted, boolean_true_node);\n+\t      record_dominating_conditions (inverted);\n \t    }\n \t  else if (cond_code == SSA_NAME)\n \t    record_const_or_copy (cond, boolean_false_node,\n@@ -1013,7 +1011,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t}\n     }\n \n-  remove_local_expressions_from_table (bd->avail_exprs, 0, avail_exprs);\n+  remove_local_expressions_from_table ();\n   restore_nonzero_vars_to_original_value (bd->nonzero_vars, 0, nonzero_vars);\n   restore_vars_to_original_value (bd->const_and_copies, 0, const_and_copies);\n   restore_currdefs_to_original_value (bd->block_defs, 0);\n@@ -1228,7 +1226,6 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n       && (edge_flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n     eq_expr_value = get_eq_expr_value (parent_block_last_stmt,\n \t\t\t\t       (edge_flags & EDGE_TRUE_VALUE) != 0,\n-\t\t\t\t       &bd->avail_exprs,\n \t\t\t\t       bb,\n \t\t\t\t       &bd->vrp_variables);\n   /* Similarly when the parent block ended in a SWITCH_EXPR.\n@@ -1358,7 +1355,7 @@ record_var_is_nonzero (tree var, varray_type *block_nonzero_vars_p)\n    that the condition COND has the value VALUE.  */\n \n static void\n-record_cond (tree cond, tree value, varray_type *block_avail_exprs_p)\n+record_cond (tree cond, tree value)\n {\n   struct expr_hash_elt *element = xmalloc (sizeof (struct expr_hash_elt));\n   void **slot;\n@@ -1370,9 +1367,7 @@ record_cond (tree cond, tree value, varray_type *block_avail_exprs_p)\n   if (*slot == NULL)\n     {\n       *slot = (void *) element;\n-      if (! *block_avail_exprs_p)\n-\tVARRAY_TREE_INIT (*block_avail_exprs_p, 20, \"block_avail_exprs\");\n-      VARRAY_PUSH_TREE (*block_avail_exprs_p, cond);\n+      VARRAY_PUSH_TREE (avail_exprs_stack, cond);\n     }\n   else\n     free (element);\n@@ -1384,166 +1379,140 @@ record_cond (tree cond, tree value, varray_type *block_avail_exprs_p)\n    For example, if a < b is true, then a <= b must also be true.  */\n \n static void\n-record_dominating_conditions (tree cond, varray_type *block_avail_exprs_p)\n+record_dominating_conditions (tree cond)\n {\n   switch (TREE_CODE (cond))\n     {\n     case LT_EXPR:\n       record_cond (build2 (LE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (NE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (LTGT_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case GT_EXPR:\n       record_cond (build2 (GE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (NE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (LTGT_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case GE_EXPR:\n     case LE_EXPR:\n       record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case EQ_EXPR:\n       record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (LE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (GE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case UNORDERED_EXPR:\n       record_cond (build2 (NE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (UNLE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (UNGE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (UNEQ_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (UNLT_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (UNGT_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case UNLT_EXPR:\n       record_cond (build2 (UNLE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (NE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case UNGT_EXPR:\n       record_cond (build2 (UNGE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (NE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case UNEQ_EXPR:\n       record_cond (build2 (UNLE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (UNGE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       break;\n \n     case LTGT_EXPR:\n       record_cond (build2 (NE_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n       record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n \t\t\t   TREE_OPERAND (cond, 0),\n \t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node,\n-\t\t   block_avail_exprs_p);\n+\t\t   boolean_true_node);\n \n     default:\n       break;\n@@ -1638,8 +1607,6 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n   tree rhs = TREE_OPERAND (stmt, 1);\n   enum tree_code rhs_code = TREE_CODE (rhs);\n   tree result = NULL;\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   /* If we have lhs = ~x, look and see if we earlier had x = ~y.\n      In which case we can change this statement to be lhs = y.\n@@ -1665,7 +1632,6 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t      && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs_def_operand))\n \t    result = update_rhs_and_lookup_avail_expr (stmt,\n \t\t\t\t\t\t       rhs_def_operand,\n-\t\t\t\t\t\t       &bd->avail_exprs,\n \t\t\t\t\t\t       insert);\n \t}\n     }\n@@ -1749,8 +1715,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t\t\t   || TREE_CODE_CLASS (TREE_CODE (t)) == '<')\n \t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n \t\t\t  && is_gimple_val (TREE_OPERAND (t, 1))))\n-\t\t    result = update_rhs_and_lookup_avail_expr\n-\t\t      (stmt, t, &bd->avail_exprs, insert);\n+\t\t    result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n \t\t}\n \t    }\n \t}\n@@ -1790,9 +1755,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t      TREE_OPERAND (TREE_OPERAND (dummy_cond, 0), 1)\n \t\t= integer_zero_node;\n \t    }\n-\t  val = simplify_cond_and_lookup_avail_expr (dummy_cond,\n-\t\t\t\t\t\t     &bd->avail_exprs,\n-\t\t\t\t\t\t     NULL, false);\n+\t  val = simplify_cond_and_lookup_avail_expr (dummy_cond, NULL, false);\n \t}\n \n       if (val && integer_onep (val))\n@@ -1809,8 +1772,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t\t       local_fold (build (MINUS_EXPR, TREE_TYPE (op1),\n \t\t\t\t\t  op1, integer_one_node)));\n \n-\t  result = update_rhs_and_lookup_avail_expr (stmt, t,\n-\t\t\t\t\t\t     &bd->avail_exprs, insert);\n+\t  result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n \t}\n     }\n \n@@ -1845,9 +1807,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t      TREE_OPERAND (TREE_OPERAND (dummy_cond, 0), 1)\n \t\t= build_int_cst (type, 0);\n \t    }\n-\t  val = simplify_cond_and_lookup_avail_expr (dummy_cond,\n-\t\t\t\t\t\t     &bd->avail_exprs,\n-\t\t\t\t\t\t     NULL, false);\n+\t  val = simplify_cond_and_lookup_avail_expr (dummy_cond, NULL, false);\n \n \t  if (!val)\n \t    {\n@@ -1857,7 +1817,6 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t\t= build_int_cst (type, 0);\n \n \t      val = simplify_cond_and_lookup_avail_expr (dummy_cond,\n-\t\t\t\t\t\t\t &bd->avail_exprs,\n \t\t\t\t\t\t\t NULL, false);\n \n \t      if (val)\n@@ -1880,8 +1839,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t  else\n \t    t = op;\n \n-\t  result = update_rhs_and_lookup_avail_expr (stmt, t,\n-\t\t\t\t\t\t     &bd->avail_exprs, insert);\n+\t  result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n \t}\n     }\n \n@@ -1892,8 +1850,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n       tree t = fold_read_from_constant_string (rhs);\n \n       if (t)\n-        result = update_rhs_and_lookup_avail_expr (stmt, t,\n-\t\t\t\t\t\t   &bd->avail_exprs, insert);\n+        result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n     }\n \n   return result;\n@@ -1968,7 +1925,6 @@ find_equivalent_equality_comparison (tree cond)\n \n static tree\n simplify_cond_and_lookup_avail_expr (tree stmt,\n-\t\t\t\t     varray_type *block_avail_exprs_p,\n \t\t\t\t     stmt_ann_t ann,\n \t\t\t\t     int insert)\n {\n@@ -2008,8 +1964,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \n \t\t  /* Lookup the condition and return its known value if it\n \t\t     exists.  */\n-\t\t  new_cond = lookup_avail_expr (stmt, block_avail_exprs_p,\n-\t\t\t\t\t\tinsert);\n+\t\t  new_cond = lookup_avail_expr (stmt, insert);\n \t\t  if (new_cond)\n \t\t    return new_cond;\n \n@@ -2198,9 +2153,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n    condition which we may be able to optimize better.  */\n \n static tree\n-simplify_switch_and_lookup_avail_expr (tree stmt,\n-\t\t\t\t       varray_type *block_avail_exprs_p,\n-\t\t\t\t       int insert)\n+simplify_switch_and_lookup_avail_expr (tree stmt, int insert)\n {\n   tree cond = SWITCH_COND (stmt);\n   tree def, to, ti;\n@@ -2246,7 +2199,7 @@ simplify_switch_and_lookup_avail_expr (tree stmt,\n \t\t  SWITCH_COND (stmt) = def;\n \t\t  modify_stmt (stmt);\n \n-\t\t  return lookup_avail_expr (stmt, block_avail_exprs_p, insert);\n+\t\t  return lookup_avail_expr (stmt, insert);\n \t\t}\n \t    }\n \t}\n@@ -2378,8 +2331,6 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n   bool insert = true;\n   tree cached_lhs;\n   bool retval = false;\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     def = TREE_OPERAND (stmt, 0);\n@@ -2394,28 +2345,21 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n     insert = false;\n \n   /* Check if the expression has been computed before.  */\n-  cached_lhs = lookup_avail_expr (stmt, &bd->avail_exprs, insert);\n+  cached_lhs = lookup_avail_expr (stmt, insert);\n \n   /* If this is an assignment and the RHS was not in the hash table,\n      then try to simplify the RHS and lookup the new RHS in the\n      hash table.  */\n   if (! cached_lhs && TREE_CODE (stmt) == MODIFY_EXPR)\n-    cached_lhs = simplify_rhs_and_lookup_avail_expr (walk_data,\n-\t\t\t\t\t\t     stmt,\n-\t\t\t\t\t\t     insert);\n+    cached_lhs = simplify_rhs_and_lookup_avail_expr (walk_data, stmt, insert);\n   /* Similarly if this is a COND_EXPR and we did not find its\n      expression in the hash table, simplify the condition and\n      try again.  */\n   else if (! cached_lhs && TREE_CODE (stmt) == COND_EXPR)\n-    cached_lhs = simplify_cond_and_lookup_avail_expr (stmt,\n-\t\t\t\t\t\t      &bd->avail_exprs,\n-\t\t\t\t\t\t      ann,\n-\t\t\t\t\t\t      insert);\n+    cached_lhs = simplify_cond_and_lookup_avail_expr (stmt, ann, insert);\n   /* Similarly for a SWITCH_EXPR.  */\n   else if (!cached_lhs && TREE_CODE (stmt) == SWITCH_EXPR)\n-    cached_lhs = simplify_switch_and_lookup_avail_expr (stmt,\n-\t\t\t\t\t\t        &bd->avail_exprs,\n-\t\t\t\t\t\t        insert);\n+    cached_lhs = simplify_switch_and_lookup_avail_expr (stmt, insert);\n \n   opt_stats.num_exprs_considered++;\n \n@@ -2471,7 +2415,6 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \n static void\n record_equivalences_from_stmt (tree stmt,\n-\t\t\t       varray_type *block_avail_exprs_p,\n \t\t\t       varray_type *block_nonzero_vars_p,\n \t\t\t       int may_optimize_p,\n \t\t\t       stmt_ann_t ann)\n@@ -2598,7 +2541,7 @@ record_equivalences_from_stmt (tree stmt,\n \n \t  /* Finally enter the statement into the available expression\n \t     table.  */\n-\t  lookup_avail_expr (new, block_avail_exprs_p, true);\n+\t  lookup_avail_expr (new, true);\n \t}\n     }\n }\n@@ -2803,7 +2746,6 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n   /* Record any additional equivalences created by this statement.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     record_equivalences_from_stmt (stmt,\n-\t\t\t\t   &bd->avail_exprs,\n \t\t\t\t   &bd->nonzero_vars,\n \t\t\t\t   may_optimize_p,\n \t\t\t\t   ann);\n@@ -2870,9 +2812,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n    hash table to account for the changes made to STMT.  */\n \n static tree\n-update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs, \n-\t\t\t\t  varray_type *block_avail_exprs_p,\n-\t\t\t\t  bool insert)\n+update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs, bool insert)\n {\n   tree cached_lhs = NULL;\n \n@@ -2889,7 +2829,7 @@ update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs,\n   TREE_OPERAND (stmt, 1) = new_rhs;\n \n   /* Now lookup the updated statement in the hash table.  */\n-  cached_lhs = lookup_avail_expr (stmt, block_avail_exprs_p, insert);\n+  cached_lhs = lookup_avail_expr (stmt, insert);\n \n   /* We have now called lookup_avail_expr twice with two different\n      versions of this same statement, once in optimize_stmt, once here.\n@@ -2913,7 +2853,7 @@ update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs,\n      we found a copy of this statement in the second hash table lookup\n      we want _no_ copies of this statement in BLOCK_AVAIL_EXPRs.  */\n   if (insert)\n-    VARRAY_POP (*block_avail_exprs_p);\n+    VARRAY_POP (avail_exprs_stack);\n \n   /* And make sure we record the fact that we modified this\n      statement.  */\n@@ -2935,7 +2875,7 @@ update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs,\n    aliased references.  */\n \n static tree\n-lookup_avail_expr (tree stmt, varray_type *block_avail_exprs_p, bool insert)\n+lookup_avail_expr (tree stmt, bool insert)\n {\n   void **slot;\n   tree lhs;\n@@ -2989,9 +2929,7 @@ lookup_avail_expr (tree stmt, varray_type *block_avail_exprs_p, bool insert)\n   if (*slot == NULL)\n     {\n       *slot = (void *) element;\n-      if (! *block_avail_exprs_p)\n-        VARRAY_TREE_INIT (*block_avail_exprs_p, 20, \"block_avail_exprs\");\n-      VARRAY_PUSH_TREE (*block_avail_exprs_p, stmt ? stmt : element->rhs);\n+      VARRAY_PUSH_TREE (avail_exprs_stack, stmt ? stmt : element->rhs);\n       return NULL_TREE;\n     }\n \n@@ -3134,7 +3072,6 @@ record_range (tree cond, basic_block bb, varray_type *vrp_variables_p)\n static struct eq_expr_value\n get_eq_expr_value (tree if_stmt,\n \t\t   int true_arm,\n-\t\t   varray_type *block_avail_exprs_p,\n \t\t   basic_block bb,\n \t\t   varray_type *vrp_variables_p)\n {\n@@ -3200,9 +3137,9 @@ get_eq_expr_value (tree if_stmt,\n \t     condition into the hash table.  */\n \t  if (true_arm)\n \t    {\n-\t      record_cond (cond, boolean_true_node, block_avail_exprs_p);\n-\t      record_dominating_conditions (cond, block_avail_exprs_p);\n-\t      record_cond (inverted, boolean_false_node, block_avail_exprs_p);\n+\t      record_cond (cond, boolean_true_node);\n+\t      record_dominating_conditions (cond);\n+\t      record_cond (inverted, boolean_false_node);\n \n \t      if (TREE_CONSTANT (op1))\n \t\trecord_range (cond, bb, vrp_variables_p);\n@@ -3219,9 +3156,9 @@ get_eq_expr_value (tree if_stmt,\n \t  else\n \t    {\n \n-\t      record_cond (inverted, boolean_true_node, block_avail_exprs_p);\n-\t      record_dominating_conditions (inverted, block_avail_exprs_p);\n-\t      record_cond (cond, boolean_false_node, block_avail_exprs_p);\n+\t      record_cond (inverted, boolean_true_node);\n+\t      record_dominating_conditions (inverted);\n+\t      record_cond (cond, boolean_false_node);\n \n \t      if (TREE_CONSTANT (op1))\n \t\trecord_range (inverted, bb, vrp_variables_p);"}]}