{"sha": "c16126ac1815c23771abc76d7daa30662dc31379", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE2MTI2YWMxODE1YzIzNzcxYWJjNzZkN2RhYTMwNjYyZGMzMTM3OQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-07-06T10:26:12Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-07-06T10:26:12Z"}, "message": "re PR fortran/58586 (ICE with derived type with allocatable component passed by value)\n\ngcc/testsuite/ChangeLog:\n\n2015-07-06  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/58586\n\t* gfortran.dg/alloc_comp_class_3.f03: New test.\n\t* gfortran.dg/alloc_comp_class_4.f03: New test.\n\n\ngcc/fortran/ChangeLog:\n\n2015-07-06  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/58586\n\t* resolve.c (resolve_symbol): Non-private functions in modules\n\twith allocatable or pointer components are marked referenced\n\tnow. Furthermore is the default init especially for those\n\tcomponents now done in gfc_conf_procedure_call preventing\n\tduplicate code.\n\t* trans-decl.c (gfc_generate_function_code): Generate a fake\n\tresult decl for functions returning an object with allocatable\n\tcomponents and initialize them.\n\t* trans-expr.c (gfc_conv_procedure_call): For value typed trees\n\tuse the tree without indirect ref. And for non-decl trees\n\tadd a temporary variable to prevent evaluating the tree\n\tmultiple times (prevent multiple function evaluations).\n\t* trans.h: Made gfc_trans_structure_assign () protoype\n\tavailable, which is now needed by trans-decl.c:gfc_generate_\n\tfunction_code(), too.\n\nFrom-SVN: r225447", "tree": {"sha": "c52a82843f3c1435cfba1b2ed903bdb4e71476cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c52a82843f3c1435cfba1b2ed903bdb4e71476cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c16126ac1815c23771abc76d7daa30662dc31379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16126ac1815c23771abc76d7daa30662dc31379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c16126ac1815c23771abc76d7daa30662dc31379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16126ac1815c23771abc76d7daa30662dc31379/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8ba649886633947106b28f1ebf43b3b0d86be6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ba649886633947106b28f1ebf43b3b0d86be6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8ba649886633947106b28f1ebf43b3b0d86be6c"}], "stats": {"total": 263, "additions": 249, "deletions": 14}, "files": [{"sha": "10b6cddf9fd146d92b1ba1b3dae90f0cbcc1f7b5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -1,3 +1,22 @@\n+2015-07-06  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/58586\n+\t* resolve.c (resolve_symbol): Non-private functions in modules\n+\twith allocatable or pointer components are marked referenced\n+\tnow. Furthermore is the default init especially for those\n+\tcomponents now done in gfc_conf_procedure_call preventing\n+\tduplicate code.\n+\t* trans-decl.c (gfc_generate_function_code): Generate a fake\n+\tresult decl for\tfunctions returning an object with allocatable\n+\tcomponents and initialize them.\n+\t* trans-expr.c (gfc_conv_procedure_call): For value typed trees\n+\tuse the tree without indirect ref. And for non-decl trees\n+\tadd a temporary variable to prevent evaluating the tree\n+\tmultiple times (prevent multiple function evaluations).\n+\t* trans.h: Made gfc_trans_structure_assign () protoype\n+\tavailable, which is now needed by trans-decl.c:gfc_generate_\n+\tfunction_code(), too.\n+\n 2015-07-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66725"}, {"sha": "d16bf13eb051e221bc8524c09ab4f0d7e82abbc7", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -14083,10 +14083,15 @@ resolve_symbol (gfc_symbol *sym)\n \n       if ((!a->save && !a->dummy && !a->pointer\n \t   && !a->in_common && !a->use_assoc\n-\t   && (a->referenced || a->result)\n-\t   && !(a->function && sym != sym->result))\n+\t   && !a->result && !a->function)\n \t  || (a->dummy && a->intent == INTENT_OUT && !a->pointer))\n \tapply_default_init (sym);\n+      else if (a->function && sym->result && a->access != ACCESS_PRIVATE\n+\t       && (sym->ts.u.derived->attr.alloc_comp\n+\t\t   || sym->ts.u.derived->attr.pointer_comp))\n+\t/* Mark the result symbol to be referenced, when it has allocatable\n+\t   components.  */\n+\tsym->result->attr.referenced = 1;\n     }\n \n   if (sym->ts.type == BT_CLASS && sym->ns == gfc_current_ns"}, {"sha": "aec20189528812c8d2d0b1b48a9e28bf124765d0", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -5885,9 +5885,33 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tmp = gfc_trans_code (ns->code);\n   gfc_add_expr_to_block (&body, tmp);\n \n-  if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node)\n+  if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node\n+      || (sym->result && sym->result != sym\n+\t  && sym->result->ts.type == BT_DERIVED\n+\t  && sym->result->ts.u.derived->attr.alloc_comp))\n     {\n+      bool artificial_result_decl = false;\n       tree result = get_proc_result (sym);\n+      gfc_symbol *rsym = sym == sym->result ? sym : sym->result;\n+\n+      /* Make sure that a function returning an object with\n+\t alloc/pointer_components always has a result, where at least\n+\t the allocatable/pointer components are set to zero.  */\n+      if (result == NULL_TREE && sym->attr.function\n+\t  && ((sym->result->ts.type == BT_DERIVED\n+\t       && (sym->attr.allocatable\n+\t\t   || sym->attr.pointer\n+\t\t   || sym->result->ts.u.derived->attr.alloc_comp\n+\t\t   || sym->result->ts.u.derived->attr.pointer_comp))\n+\t      || (sym->result->ts.type == BT_CLASS\n+\t\t  && (CLASS_DATA (sym)->attr.allocatable\n+\t\t      || CLASS_DATA (sym)->attr.class_pointer\n+\t\t      || CLASS_DATA (sym->result)->attr.alloc_comp\n+\t\t      || CLASS_DATA (sym->result)->attr.pointer_comp))))\n+\t{\n+\t  artificial_result_decl = true;\n+\t  result = gfc_get_fake_result_decl (sym, 0);\n+\t}\n \n       if (result != NULL_TREE && sym->attr.function && !sym->attr.pointer)\n \t{\n@@ -5907,16 +5931,30 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t\t\t\t\t\t\tnull_pointer_node));\n \t    }\n \t  else if (sym->ts.type == BT_DERIVED\n-\t\t   && sym->ts.u.derived->attr.alloc_comp\n \t\t   && !sym->attr.allocatable)\n \t    {\n-\t      rank = sym->as ? sym->as->rank : 0;\n-\t      tmp = gfc_nullify_alloc_comp (sym->ts.u.derived, result, rank);\n-\t      gfc_add_expr_to_block (&init, tmp);\n+\t      gfc_expr *init_exp;\n+\t      /* Arrays are not initialized using the default initializer of\n+\t\t their elements.  Therefore only check if a default\n+\t\t initializer is available when the result is scalar.  */\n+\t      init_exp = rsym->as ? NULL : gfc_default_initializer (&rsym->ts);\n+\t      if (init_exp)\n+\t\t{\n+\t\t  tmp = gfc_trans_structure_assign (result, init_exp, 0);\n+\t\t  gfc_free_expr (init_exp);\n+\t\t  gfc_add_expr_to_block (&init, tmp);\n+\t\t}\n+\t      else if (rsym->ts.u.derived->attr.alloc_comp)\n+\t\t{\n+\t\t  rank = rsym->as ? rsym->as->rank : 0;\n+\t\t  tmp = gfc_nullify_alloc_comp (rsym->ts.u.derived, result,\n+\t\t\t\t\t\trank);\n+\t\t  gfc_prepend_expr_to_block (&body, tmp);\n+\t\t}\n \t    }\n \t}\n \n-      if (result == NULL_TREE)\n+      if (result == NULL_TREE || artificial_result_decl)\n \t{\n \t  /* TODO: move to the appropriate place in resolve.c.  */\n \t  if (warn_return_type && sym == sym->result)\n@@ -5926,7 +5964,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t  if (warn_return_type)\n \t    TREE_NO_WARNING(sym->backend_decl) = 1;\n \t}\n-      else\n+      if (result != NULL_TREE)\n \tgfc_add_expr_to_block (&body, gfc_generate_return ());\n     }\n "}, {"sha": "195f7a4f536e356be46605fd2ce2d81cd29afa0e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -1465,7 +1465,6 @@ realloc_lhs_warning (bt type, bool array, locus *where)\n }\n \n \n-static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init);\n static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n \t\t\t\t\t\t gfc_expr *);\n \n@@ -5340,8 +5339,19 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    && e->expr_type != EXPR_VARIABLE && !e->rank)\n         {\n \t  int parm_rank;\n-\t  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t parmse.expr);\n+\t  /* It is known the e returns a structure type with at least one\n+\t     allocatable component.  When e is a function, ensure that the\n+\t     function is called once only by using a temporary variable.  */\n+\t  if (!DECL_P (parmse.expr))\n+\t    parmse.expr = gfc_evaluate_now_loc (input_location,\n+\t\t\t\t\t\tparmse.expr, &se->pre);\n+\n+\t  if (fsym && fsym->attr.value)\n+\t    tmp = parmse.expr;\n+\t  else\n+\t    tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t       parmse.expr);\n+\n \t  parm_rank = e->rank;\n \t  switch (parm_kind)\n \t    {\n@@ -7158,7 +7168,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \n /* Assign a derived type constructor to a variable.  */\n \n-static tree\n+tree\n gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init)\n {\n   gfc_constructor *c;\n@@ -7471,7 +7481,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n       if (expr->ts.type == BT_CHARACTER\n \t  && expr->expr_type != EXPR_FUNCTION)\n \tgfc_conv_string_parameter (se);\n-      else\n+     else\n \tse->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \n       return;"}, {"sha": "f7cf5f016feebc1f999eb63d1c9dee6e0099f033", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -669,6 +669,9 @@ tree gfc_deallocate_scalar_with_status (tree, tree, bool, gfc_expr*, gfc_typespe\n /* Generate code to call realloc().  */\n tree gfc_call_realloc (stmtblock_t *, tree, tree);\n \n+/* Assign a derived type constructor to a variable.  */\n+tree gfc_trans_structure_assign (tree, gfc_expr *, bool);\n+\n /* Generate code for an assignment, includes scalarization.  */\n tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool, bool);\n "}, {"sha": "0753e33d535d8b15acade78e949212e2c3ad83b7", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_class_3.f03", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_3.f03?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+! { dg-options \"-Wreturn-type\" }\n+!\n+! Check that pr58586 is fixed now.\n+! Based on a contribution by Vladimir Fuka\n+! Contibuted by Andre Vehreschild\n+\n+program test_pr58586\n+  implicit none\n+\n+  type :: a\n+  end type\n+\n+  type :: c\n+     type(a), allocatable :: a\n+  end type\n+\n+  type :: b\n+     integer, allocatable :: a\n+  end type\n+\n+  type :: t\n+    integer, allocatable :: comp\n+  end type\n+  type :: u\n+    type(t), allocatable :: comp\n+  end type\n+\n+\n+  ! These two are merely to check, if compilation works\n+  call add(b())\n+  call add(b(null()))\n+\n+  ! This needs to execute, to see whether the segfault at runtime is resolved\n+  call add_c(c_init())\n+\n+  call sub(u())\n+contains\n+\n+  subroutine add (d)\n+    type(b), value :: d\n+  end subroutine\n+\n+  subroutine add_c (d)\n+    type(c), value :: d\n+  end subroutine\n+\n+  type(c) function c_init()  ! { dg-warning \"not set\" }\n+  end function\n+\n+  subroutine sub(d)\n+    type(u), value :: d\n+  end subroutine\n+end program test_pr58586\n+"}, {"sha": "28b7e631a874eca6b8eb78670708f3a93feb6d96", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_class_4.f03", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c16126ac1815c23771abc76d7daa30662dc31379/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_4.f03?ref=c16126ac1815c23771abc76d7daa30662dc31379", "patch": "@@ -0,0 +1,105 @@\n+! { dg-do run }\n+! { dg-options \"-Wreturn-type\" }\n+!\n+! Check that pr58586 is fixed now.\n+! Based on a contribution by Vladimir Fuka\n+! Contibuted by Andre Vehreschild\n+\n+module test_pr58586_mod\n+  implicit none\n+\n+  type :: a\n+  end type\n+\n+  type :: c\n+     type(a), allocatable :: a\n+  end type\n+\n+  type :: d\n+  contains\n+     procedure :: init => d_init\n+  end type\n+\n+  type, extends(d) :: e\n+  contains\n+     procedure :: init => e_init\n+  end type\n+\n+  type :: b\n+     integer, allocatable :: a\n+  end type\n+\n+  type t\n+    integer :: i = 5\n+  end type\n+\n+contains\n+\n+  subroutine add (d)\n+    type(b), value :: d\n+  end subroutine\n+\n+  subroutine add_c (d)\n+    type(c), value :: d\n+  end subroutine\n+\n+  subroutine add_class_c (d)\n+    class(c), value :: d\n+  end subroutine\n+\n+  subroutine add_t (d)\n+    type(t), value :: d\n+  end subroutine\n+\n+  type(c) function c_init() ! { dg-warning \"not set\" }\n+  end function\n+\n+  class(c) function c_init2() ! { dg-warning \"not set\" }\n+    allocatable :: c_init2\n+  end function\n+\n+  type(c) function d_init(this) ! { dg-warning \"not set\" }\n+    class(d) :: this\n+  end function\n+\n+  type(c) function e_init(this)\n+    class(e) :: this\n+    allocate (e_init%a)\n+  end function\n+\n+  type(t) function t_init() ! { dg-warning \"not set\" }\n+    allocatable :: t_init\n+  end function\n+\n+  type(t) function static_t_init() ! { dg-warning \"not set\" }\n+  end function\n+end module test_pr58586_mod\n+\n+program test_pr58586\n+  use test_pr58586_mod\n+\n+  class(d), allocatable :: od\n+  class(e), allocatable :: oe\n+  type(t), allocatable :: temp\n+\n+  ! These two are merely to check, if compilation works\n+  call add(b())\n+  call add(b(null()))\n+\n+  ! This needs to execute, to see whether the segfault at runtime is resolved\n+  call add_c(c_init())\n+  call add_class_c(c_init2())\n+\n+  call add_t(static_t_init())\n+  ! temp = t_init() ! <-- This derefs a null-pointer currently\n+  ! Filed as pr66775\n+  if (allocated (temp)) call abort()\n+\n+  allocate(od)\n+  call add_c(od%init())\n+  deallocate(od)\n+  allocate(oe)\n+  call add_c(oe%init())\n+  deallocate(oe)\n+end program\n+"}]}