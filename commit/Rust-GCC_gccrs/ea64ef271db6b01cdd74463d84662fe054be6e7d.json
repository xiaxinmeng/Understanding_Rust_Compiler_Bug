{"sha": "ea64ef271db6b01cdd74463d84662fe054be6e7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE2NGVmMjcxZGI2YjAxY2RkNzQ0NjNkODQ2NjJmZTA1NGJlNmU3ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-11-10T07:12:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-10T07:12:10Z"}, "message": "alias.c (MAX_ALIAS_LOOP_PASSES): Define.\n\n        * alias.c (MAX_ALIAS_LOOP_PASSES): Define.\n        (init_alias_analysis): Break out of loops after MAX_ALIAS_LOOP_PASSES.\n\nFrom-SVN: r16415", "tree": {"sha": "ddff8d78b2a13cab1df70004e71c53922b7f54d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddff8d78b2a13cab1df70004e71c53922b7f54d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea64ef271db6b01cdd74463d84662fe054be6e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea64ef271db6b01cdd74463d84662fe054be6e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea64ef271db6b01cdd74463d84662fe054be6e7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea64ef271db6b01cdd74463d84662fe054be6e7d/comments", "author": null, "committer": null, "parents": [{"sha": "0ff27f584bf0b28a6922de4374cd95b714e5a0c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff27f584bf0b28a6922de4374cd95b714e5a0c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff27f584bf0b28a6922de4374cd95b714e5a0c3"}], "stats": {"total": 37, "additions": 32, "deletions": 5}, "files": [{"sha": "5a1e4f13eb6d5ccb74ef74170fda2a504069e0ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea64ef271db6b01cdd74463d84662fe054be6e7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea64ef271db6b01cdd74463d84662fe054be6e7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea64ef271db6b01cdd74463d84662fe054be6e7d", "patch": "@@ -1,3 +1,8 @@\n+Mon Nov 10 00:05:56 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* alias.c (MAX_ALIAS_LOOP_PASSES): Define.\n+\t(init_alias_analysis): Break out of loops after MAX_ALIAS_LOOP_PASSES.\n+\n Sun Nov  9 02:07:16 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* fixinc.svr4 (__STDC__): Add another case."}, {"sha": "333aa5c754e36534219bb2cd4af80e2ec32409ad", "filename": "gcc/alias.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea64ef271db6b01cdd74463d84662fe054be6e7d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea64ef271db6b01cdd74463d84662fe054be6e7d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ea64ef271db6b01cdd74463d84662fe054be6e7d", "patch": "@@ -36,6 +36,12 @@ static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n \n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n+/* Cap the number of passes we make over the insns propagating alias\n+   information through set chains.\n+\n+   10 is a completely arbitrary choice.  */\n+#define MAX_ALIAS_LOOP_PASSES 10\n+   \n /* reg_base_value[N] gives an address to which register N is related.\n    If all sets after the first add or subtract to the current value\n    or otherwise modify it so it does not point to a different top level\n@@ -962,7 +968,7 @@ void\n init_alias_analysis ()\n {\n   int maxreg = max_reg_num ();\n-  int changed;\n+  int changed, pass;\n   register int i;\n   register rtx insn;\n   rtx note;\n@@ -1002,10 +1008,21 @@ init_alias_analysis ()\n \n      We could propagate more information in the first pass by making use\n      of REG_N_SETS to determine immediately that the alias information\n-     for a pseudo is \"constant\".  */\n+     for a pseudo is \"constant\".\n+\n+     A program with an uninitialized variable can cause an infinite loop\n+     here.  Instead of doing a full dataflow analysis to detect such problems\n+     we just cap the number of iterations for the loop.\n+\n+     The state of the arrays for the set chain in question does not matter\n+     since the program has undefined behavior.  */\n   changed = 1;\n-  while (changed)\n+  pass = 0;\n+  while (changed && pass < MAX_ALIAS_LOOP_PASSES)\n     {\n+      /* Keep track of the pass number so we can break out of the loop.  */\n+      pass++;\n+\n       /* Assume nothing will change this iteration of the loop.  */\n       changed = 0;\n \n@@ -1130,10 +1147,15 @@ init_alias_analysis ()\n \n      In theory this loop can take as long as O(registers^2), but unless\n      there are very long dependency chains it will run in close to linear\n-     time.  */\n+     time.\n+\n+     This loop may not be needed any longer now that the main loop does\n+     a better job at propagating alias information.  */\n+  pass = 0;\n   do\n     {\n       changed = 0;\n+      pass++;\n       for (i = 0; i < reg_base_value_size; i++)\n \t{\n \t  rtx base = reg_base_value[i];\n@@ -1148,7 +1170,7 @@ init_alias_analysis ()\n \t    }\n \t}\n     }\n-  while (changed);\n+  while (changed && pass < MAX_ALIAS_LOOP_PASSES);\n \n   new_reg_base_value = 0;\n   reg_seen = 0;"}]}