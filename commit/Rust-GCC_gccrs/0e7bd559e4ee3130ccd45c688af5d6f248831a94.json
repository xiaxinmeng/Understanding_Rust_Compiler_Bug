{"sha": "0e7bd559e4ee3130ccd45c688af5d6f248831a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU3YmQ1NTllNGVlMzEzMGNjZDQ1YzY4OGFmNWQ2ZjI0ODgzMWE5NA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-07T22:46:56Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-07T22:46:56Z"}, "message": "Improve API docs for std::pair\n\n\t* include/bits/stl_pair.h: Improve docs.\n\t* include/std/tuple: Likewise.\n\nFrom-SVN: r270989", "tree": {"sha": "a3721c6eccaf4eb992312d14ac043987817912f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3721c6eccaf4eb992312d14ac043987817912f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e7bd559e4ee3130ccd45c688af5d6f248831a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7bd559e4ee3130ccd45c688af5d6f248831a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e7bd559e4ee3130ccd45c688af5d6f248831a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7bd559e4ee3130ccd45c688af5d6f248831a94/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c34d3fd3068c5f991f75017023ba8eb36879ffa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34d3fd3068c5f991f75017023ba8eb36879ffa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34d3fd3068c5f991f75017023ba8eb36879ffa3"}], "stats": {"total": 76, "additions": 59, "deletions": 17}, "files": [{"sha": "acf58e9c22b5f8c725a3d8b103f91dc0cf773d8b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7bd559e4ee3130ccd45c688af5d6f248831a94/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7bd559e4ee3130ccd45c688af5d6f248831a94/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0e7bd559e4ee3130ccd45c688af5d6f248831a94", "patch": "@@ -1,5 +1,8 @@\n 2019-05-07  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/stl_pair.h: Improve docs.\n+\t* include/std/tuple: Likewise.\n+\n \t* doc/doxygen/doxygroups.cc (std::literals): Add documentation for\n \tinline namespace.\n \t* include/std/chrono: Improve docs."}, {"sha": "f99b774c21e7f52d12ca7e93be082eae96ed3411", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7bd559e4ee3130ccd45c688af5d6f248831a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7bd559e4ee3130ccd45c688af5d6f248831a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=0e7bd559e4ee3130ccd45c688af5d6f248831a94", "patch": "@@ -72,13 +72,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n #if __cplusplus >= 201103L\n-  /// piecewise_construct_t\n+  /// Tag type for piecewise construction of std::pair objects.\n   struct piecewise_construct_t { explicit piecewise_construct_t() = default; };\n \n-  /// piecewise_construct\n+  /// Tag for piecewise construction of std::pair objects.\n   _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =\n     piecewise_construct_t();\n \n+  /// @cond undocumented\n+\n   // Forward declarations.\n   template<typename...>\n     class tuple;\n@@ -198,21 +200,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif // C++11\n   };\n \n+  /// @endcond\n+\n  /**\n    *  @brief Struct holding two objects of arbitrary type.\n    *\n    *  @tparam _T1  Type of first object.\n    *  @tparam _T2  Type of second object.\n+   *\n+   *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>\n    */\n   template<typename _T1, typename _T2>\n     struct pair\n     : private __pair_base<_T1, _T2>\n     {\n-      typedef _T1 first_type;    /// @c first_type is the first bound type\n-      typedef _T2 second_type;   /// @c second_type is the second bound type\n+      typedef _T1 first_type;    ///< The type of the `first` member\n+      typedef _T2 second_type;   ///< The type of the `second` member\n \n-      _T1 first;                 /// @c first is a copy of the first object\n-      _T2 second;                /// @c second is a copy of the second object\n+      _T1 first;                 ///< The first member\n+      _T2 second;                ///< The second member\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 265.  std::pair::pair() effects overly restrictive\n@@ -243,14 +249,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : first(), second() { }\n #endif\n \n-      /** Two objects may be passed to a @c pair constructor to be copied.  */\n #if __cplusplus < 201103L\n+      /// Two objects may be passed to a @c pair constructor to be copied.\n       pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n #else\n       // Shortcut for constraining the templates that don't take pairs.\n+      /// @cond undocumented\n       using _PCCP = _PCC<true, _T1, _T2>;\n+      /// @endcond\n \n+      /// Construct from two const lvalues, allowing implicit conversions.\n       template<typename _U1 = _T1, typename _U2=_T2, typename\n \t       enable_if<_PCCP::template\n \t\t\t   _ConstructiblePair<_U1, _U2>()\n@@ -260,6 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n \n+      /// Construct from two const lvalues, disallowing implicit conversions.\n        template<typename _U1 = _T1, typename _U2=_T2, typename\n \t\tenable_if<_PCCP::template\n \t\t\t    _ConstructiblePair<_U1, _U2>()\n@@ -269,18 +279,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       explicit constexpr pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n #endif\n+      //@}\n \n-      /** There is also a templated copy ctor for the @c pair class itself.  */\n #if __cplusplus < 201103L\n+      /// There is also a templated constructor to convert from other pairs.\n       template<typename _U1, typename _U2>\n \tpair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n #else\n       // Shortcut for constraining the templates that take pairs.\n+      /// @cond undocumented\n       template <typename _U1, typename _U2>\n         using _PCCFP = _PCC<!is_same<_T1, _U1>::value\n \t\t\t    || !is_same<_T2, _U2>::value,\n \t\t\t    _T1, _T2>;\n+      /// @endcond\n \n       template<typename _U1, typename _U2, typename\n \t       enable_if<_PCCFP<_U1, _U2>::template\n@@ -299,9 +312,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                          bool>::type=false>\n \texplicit constexpr pair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n+#endif\n \n-      constexpr pair(const pair&) = default;\n-      constexpr pair(pair&&) = default;\n+#if __cplusplus >= 201103L\n+      constexpr pair(const pair&) = default;\t///< Copy constructor\n+      constexpr pair(pair&&) = default;\t\t///< Move constructor\n \n       // DR 811.\n       template<typename _U1, typename\n@@ -420,6 +435,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n+      /// Swap the first members and then the second members.\n       void\n       swap(pair& __p)\n       noexcept(__and_<__is_nothrow_swappable<_T1>,\n@@ -438,6 +454,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n     };\n \n+  /// @relates pair @{\n+\n #if __cpp_deduction_guides >= 201606\n   template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;\n #endif\n@@ -448,7 +466,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return __x.first == __y.first && __x.second == __y.second; }\n \n-  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>\n+  /** Defines a lexicographical order for pairs.\n+   *\n+   * For two pairs of the same type, `P` is ordered before `Q` if\n+   * `P.first` is less than `Q.first`, or if `P.first` and `Q.first`\n+   * are equivalent (neither is less than the other) and `P.second` is less\n+   * than `Q.second`.\n+  */\n   template<typename _T1, typename _T2>\n     inline _GLIBCXX_CONSTEXPR bool\n     operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n@@ -480,9 +504,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return !(__x < __y); }\n \n #if __cplusplus >= 201103L\n-  /// See std::pair::swap().\n-  // Note:  no std::swap overloads in C++03 mode, this has performance\n-  //        implications, see, eg, libstdc++/38466.\n+  /** Swap overload for pairs. Calls std::pair::swap().\n+   *\n+   * @note This std::swap overload is not declared in C++03 mode,\n+   * which has performance implications, e.g. see https://gcc.gnu.org/PR38466\n+  */\n   template<typename _T1, typename _T2>\n     inline\n #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n@@ -504,15 +530,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n #endif // __cplusplus >= 201103L\n \n+  // @} relates pair\n+\n   /**\n    *  @brief A convenience wrapper for creating a pair from two objects.\n    *  @param  __x  The first object.\n    *  @param  __y  The second object.\n    *  @return   A newly-constructed pair<> object of the appropriate type.\n    *\n-   *  The standard requires that the objects be passed by reference-to-const,\n-   *  but LWG issue #181 says they should be passed by const value.  We follow\n-   *  the LWG by default.\n+   *  The C++98 standard says the objects are passed by reference-to-const,\n+   *  but C++03 says they are passed by value (this was LWG issue #181).\n+   *\n+   *  Since C++11 they have been passed by forwarding reference and then\n+   *  forwarded to the new members of the pair. To create a pair with a\n+   *  member of reference type, pass a `reference_wrapper` to this function.\n    */\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 181.  make_pair() unintended behavior"}, {"sha": "956e031ae9d264b26c97f5564fb92de3f4969e8b", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7bd559e4ee3130ccd45c688af5d6f248831a94/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7bd559e4ee3130ccd45c688af5d6f248831a94/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=0e7bd559e4ee3130ccd45c688af5d6f248831a94", "patch": "@@ -1691,6 +1691,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };\n \n   // See stl_pair.h...\n+  /** \"piecewise construction\" using a tuple of arguments for each member.\n+   *\n+   * @param __first Arguments for the first member of the pair.\n+   * @param __second Arguments for the second member of the pair.\n+   *\n+   * The elements of each tuple will be used as the constructor arguments\n+   * for the data members of the pair.\n+  */\n   template<class _T1, class _T2>\n     template<typename... _Args1, typename... _Args2>\n       inline"}]}