{"sha": "4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY5NDg0MGEwMWNjNGI4MjM3OGZkZmJiZjdkN2Q4YTVjNzQyNmI1NA==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2003-04-14T21:59:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-04-14T21:59:54Z"}, "message": "tree.c (int_fits_type_p): Extract generic checks from the case of constant type bounds.\n\n\t* tree.c (int_fits_type_p): Extract generic checks from the case\n\tof constant type bounds. Refine the checks against constant type\n\tbounds to allow for possible decisions against each of these bounds\n\twithout requiring both bounds to be constant.\n\t(tree_int_cst_msb): Put back.\n\t* tree.h (tree_int_cst_msb): Likewise.\n\nFrom-SVN: r65598", "tree": {"sha": "d6f78a17177abce92c003a3fe0b73ef57a45b129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f78a17177abce92c003a3fe0b73ef57a45b129"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/comments", "author": null, "committer": null, "parents": [{"sha": "4147232b5c88a1aa647626825cd98516f9ffb0d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4147232b5c88a1aa647626825cd98516f9ffb0d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4147232b5c88a1aa647626825cd98516f9ffb0d7"}], "stats": {"total": 93, "additions": 74, "deletions": 19}, "files": [{"sha": "41451aa9c4aa0e601812b9d5e0735738b7a1fcdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "patch": "@@ -17,6 +17,13 @@\n \n 2003-04-14  Olivier Hainque <hainque@act-europe.fr>\n \n+\t* tree.c (int_fits_type_p): Extract generic checks from the case\n+\tof constant type bounds. Refine the checks against constant type\n+\tbounds to allow for possible decisions against each of these bounds\n+\twithout requiring both bounds to be constant.\n+\t(tree_int_cst_msb): Put back.\n+\t* tree.h (tree_int_cst_msb): Likewise.\n+\n \t* global.c (global_conflicts): Prevent allocation of call clobbered\n \thard regs to pseudos live across abnormal edges, as later passes are\n \tnot ready to handle them."}, {"sha": "2d8e12a8674cd6d4efef1f14dd1c14fd6ba198d8", "filename": "gcc/tree.c", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "patch": "@@ -3245,6 +3245,24 @@ tree_low_cst (t, pos)\n     abort ();\n }\n \n+/* Return the most significant bit of the integer constant T.  */\n+\n+int\n+tree_int_cst_msb (t)\n+     tree t;\n+{\n+  int prec;\n+  HOST_WIDE_INT h;\n+  unsigned HOST_WIDE_INT l;\n+\n+  /* Note that using TYPE_PRECISION here is wrong.  We care about the\n+     actual bits, not the (arbitrary) range of the type.  */\n+  prec = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (t))) - 1;\n+  rshift_double (TREE_INT_CST_LOW (t), TREE_INT_CST_HIGH (t), prec,\n+\t\t 2 * HOST_BITS_PER_WIDE_INT, &l, &h, 0);\n+  return (l & 1) == 1;\n+}\n+\n /* Return an indication of the sign of the integer constant T.\n    The return value is -1 if T < 0, 0 if T == 0, and 1 if T > 0.\n    Note that -1 will never be returned it T's type is unsigned.  */\n@@ -4069,29 +4087,58 @@ int\n int_fits_type_p (c, type)\n      tree c, type;\n {\n-  /* If the bounds of the type are integers, we can check ourselves.\n-     If not, but this type is a subtype, try checking against that.\n-     Otherwise, use force_fit_type, which checks against the precision.  */\n-  if (TYPE_MAX_VALUE (type) != NULL_TREE\n-      && TYPE_MIN_VALUE (type) != NULL_TREE\n-      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n-      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n+  tree type_low_bound = TYPE_MIN_VALUE (type);\n+  tree type_high_bound = TYPE_MAX_VALUE (type);\n+  int ok_for_low_bound, ok_for_high_bound;\n+    \n+  /* Perform some generic filtering first, which may allow making a decision\n+     even if the bounds are not constant.  First, negative integers never fit\n+     in unsigned types, */\n+  if ((TREE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n+      /* Also, unsigned integers with top bit set never fit signed types.  */\n+      || (! TREE_UNSIGNED (type) \n+\t  && TREE_UNSIGNED (TREE_TYPE (c)) && tree_int_cst_msb (c)))\n+    return 0;\n+\n+  /* If at least one bound of the type is a constant integer, we can check\n+     ourselves and maybe make a decision. If no such decision is possible, but\n+     this type is a subtype, try checking against that.  Otherwise, use\n+     force_fit_type, which checks against the precision.\n+\n+     Compute the status for each possibly constant bound, and return if we see\n+     one does not match. Use ok_for_xxx_bound for this purpose, assigning -1\n+     for \"unknown if constant fits\", 0 for \"constant known *not* to fit\" and 1\n+     for \"constant known to fit\".  */\n+\n+  ok_for_low_bound = -1;\n+  ok_for_high_bound = -1;\n+    \n+  /* Check if C >= type_low_bound.  */\n+  if (type_low_bound && TREE_CODE (type_low_bound) == INTEGER_CST)\n     {\n-      if (TREE_UNSIGNED (type))\n-\treturn (! INT_CST_LT_UNSIGNED (TYPE_MAX_VALUE (type), c)\n-\t\t&& ! INT_CST_LT_UNSIGNED (c, TYPE_MIN_VALUE (type))\n-\t\t/* Negative ints never fit unsigned types.  */\n-\t\t&& ! (TREE_INT_CST_HIGH (c) < 0\n-\t\t      && ! TREE_UNSIGNED (TREE_TYPE (c))));\n-      else\n-\treturn (! INT_CST_LT (TYPE_MAX_VALUE (type), c)\n-\t\t&& ! INT_CST_LT (c, TYPE_MIN_VALUE (type))\n-\t\t/* Unsigned ints with top bit set never fit signed types.  */\n-\t\t&& ! (TREE_INT_CST_HIGH (c) < 0\n-\t\t      && TREE_UNSIGNED (TREE_TYPE (c))));\n+      ok_for_low_bound = ! tree_int_cst_lt (c, type_low_bound);\n+      if (! ok_for_low_bound)\n+\treturn 0;\n     }\n+\n+  /* Check if c <= type_high_bound.  */\n+  if (type_high_bound && TREE_CODE (type_high_bound) == INTEGER_CST)\n+    {\n+      ok_for_high_bound = ! tree_int_cst_lt (type_high_bound, c);\n+      if (! ok_for_high_bound)\n+\treturn 0;\n+    }\n+\n+  /* If the constant fits both bounds, the result is known.  */\n+  if (ok_for_low_bound == 1 && ok_for_high_bound == 1)\n+    return 1;\n+\n+  /* If we haven't been able to decide at this point, there nothing more we\n+     can check ourselves here. Look at the base type if we have one.  */\n   else if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != 0)\n     return int_fits_type_p (c, TREE_TYPE (type));\n+  \n+  /* Or to force_fit_type, if nothing else.  */\n   else\n     {\n       c = copy_node (c);"}, {"sha": "95f2ad4ac03b8806c85f20fa5e2af04a5b00e8be", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "patch": "@@ -2300,6 +2300,7 @@ extern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\n extern int tree_int_cst_compare         PARAMS ((tree, tree));\n extern int host_integerp\t\tPARAMS ((tree, int));\n extern HOST_WIDE_INT tree_low_cst\tPARAMS ((tree, int));\n+extern int tree_int_cst_msb\t\tPARAMS ((tree));\n extern int tree_int_cst_sgn\t\tPARAMS ((tree));\n extern int tree_expr_nonnegative_p\tPARAMS ((tree));\n extern int rtl_expr_nonnegative_p\tPARAMS ((rtx));"}]}