{"sha": "f83e254c29dc3690603e06a98d94b3d39eb853d7", "node_id": "C_kwDOANBUbNoAKGY4M2UyNTRjMjlkYzM2OTA2MDNlMDZhOThkOTRiM2QzOWViODUzZDc", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-23T13:31:26Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:28Z"}, "message": "rust-constexpr.cc: fix warnings for unused variables for unsupported bits\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "bb5eb39ab27b058afeaadad2a8d28a0968a58031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb5eb39ab27b058afeaadad2a8d28a0968a58031"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f83e254c29dc3690603e06a98d94b3d39eb853d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83e254c29dc3690603e06a98d94b3d39eb853d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83e254c29dc3690603e06a98d94b3d39eb853d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83e254c29dc3690603e06a98d94b3d39eb853d7/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f7fbbaad1365c786f0f7eaa0687e8ba9e0876f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7fbbaad1365c786f0f7eaa0687e8ba9e0876f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7fbbaad1365c786f0f7eaa0687e8ba9e0876f7"}], "stats": {"total": 299, "additions": 143, "deletions": 156}, "files": [{"sha": "ed0fc2ce345fadc86e2579704bb40e0323291fdb", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 132, "deletions": 128, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e254c29dc3690603e06a98d94b3d39eb853d7/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e254c29dc3690603e06a98d94b3d39eb853d7/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=f83e254c29dc3690603e06a98d94b3d39eb853d7", "patch": "@@ -572,7 +572,6 @@ fold_expr (tree expr)\n   rust_assert (folded != NULL_TREE);\n \n   // more logic here to possibly port\n-\n   return folded;\n }\n \n@@ -1084,9 +1083,11 @@ init_subob_ctx (const constexpr_ctx *ctx, constexpr_ctx &new_ctx, tree index,\n \t/* There's no well-defined subobject for this index.  */\n \tnew_ctx.object = NULL_TREE;\n       else\n-\t// Faisal: commenting this out as not sure if it's needed and it's huge\n-\t// new_ctx.object = build_ctor_subob_ref (index, type, ctx->object);\n-\t;\n+\t{\n+\t  // Faisal: commenting this out as not sure if it's needed and it's\n+\t  // huge new_ctx.object = build_ctor_subob_ref (index, type,\n+\t  // ctx->object);\n+\t}\n     }\n   tree elt = build_constructor (type, NULL);\n   CONSTRUCTOR_NO_CLEARING (elt) = true;\n@@ -1661,17 +1662,16 @@ eval_array_reference (const constexpr_ctx *ctx, tree t, bool lval,\n   /* If it's within the array bounds but doesn't have an explicit\n      initializer, it's initialized from {}.  But use build_value_init\n      directly for non-aggregates to avoid creating a garbage CONSTRUCTOR.  */\n-  tree val;\n+  tree val = NULL_TREE;\n+  sorry (\"array size expression is not supported yet.\");\n+\n   constexpr_ctx new_ctx;\n   if (is_really_empty_class (elem_type, /*ignore_vptr*/ false))\n     return build_constructor (elem_type, NULL);\n-  // Faisal: commenting this out as not sure if we need this but we need to come\n-  // back to handle this to assign suitable value to val before sending it in\n-  // eval_constant_expression below\n   // else if (CP_AGGREGATE_TYPE_P (elem_type))\n-  //  {\n-  //    tree empty_ctor = build_constructor (init_list_type_node, NULL);\n-  //    val = digest_init (elem_type, empty_ctor, tf_warning_or_error);\n+  // {\n+  //   tree empty_ctor = build_constructor (init_list_type_node, NULL);\n+  //    //val = digest_init (elem_type, empty_ctor, tf_warning_or_error);\n   //  }\n   // else\n   //  val = build_value_init (elem_type, tf_warning_or_error);\n@@ -1789,6 +1789,8 @@ eval_component_reference (const constexpr_ctx *ctx, tree t, bool lval,\n       return t;\n     }\n \n+  value = NULL_TREE;\n+  sorry (\"constant folding not supported for this tree code\");\n   /* If there's no explicit init for this field, it's value-initialized.  */\n   // Faisal: commenting this out as not sure if we need this but we need to come\n   // back to handle this to assign suitable value to value before sending it in\n@@ -2586,7 +2588,7 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   tree object = NULL_TREE;\n   /* If we're modifying a const object, save it.  */\n   tree const_object_being_modified = NULL_TREE;\n-  bool mutable_p = false;\n+  // bool mutable_p = false;\n   for (tree probe = target; object == NULL_TREE;)\n     {\n       switch (TREE_CODE (probe))\n@@ -2597,7 +2599,9 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t    tree ob = TREE_OPERAND (probe, 0);\n \t    tree elt = TREE_OPERAND (probe, 1);\n \t    if (TREE_CODE (elt) == FIELD_DECL /*&& DECL_MUTABLE_P (elt)*/)\n-\t      mutable_p = true;\n+\t      {\n+\t\t// mutable_p = true;\n+\t      }\n \t    if (TREE_CODE (probe) == ARRAY_REF)\n \t      {\n \t\t// TODO\n@@ -3606,44 +3610,44 @@ build_anon_member_initialization (tree member, tree init,\n   return true;\n }\n \n-/* V is a vector of constructor elements built up for the base and member\n-   initializers of a constructor for TYPE.  They need to be in increasing\n-   offset order, which they might not be yet if TYPE has a primary base\n-   which is not first in the base-clause or a vptr and at least one base\n-   all of which are non-primary.  */\n-\n-static vec<constructor_elt, va_gc> *\n-sort_constexpr_mem_initializers (tree type, vec<constructor_elt, va_gc> *v)\n-{\n-  tree pri = CLASSTYPE_PRIMARY_BINFO (type);\n-  tree field_type;\n-  unsigned i;\n-  constructor_elt *ce;\n-\n-  if (pri)\n-    field_type = BINFO_TYPE (pri);\n-  else if (TYPE_CONTAINS_VPTR_P (type))\n-    field_type = vtbl_ptr_type_node;\n-  else\n-    return v;\n-\n-  /* Find the element for the primary base or vptr and move it to the\n-     beginning of the vec.  */\n-  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n-    if (TREE_TYPE (ce->index) == field_type)\n-      break;\n-\n-  if (i > 0 && i < vec_safe_length (v))\n-    {\n-      vec<constructor_elt, va_gc> &vref = *v;\n-      constructor_elt elt = vref[i];\n-      for (; i > 0; --i)\n-\tvref[i] = vref[i - 1];\n-      vref[0] = elt;\n-    }\n-\n-  return v;\n-}\n+///* V is a vector of constructor elements built up for the base and member\n+//   initializers of a constructor for TYPE.  They need to be in increasing\n+//   offset order, which they might not be yet if TYPE has a primary base\n+//   which is not first in the base-clause or a vptr and at least one base\n+//   all of which are non-primary.  */\n+//\n+// static vec<constructor_elt, va_gc> *\n+// sort_constexpr_mem_initializers (tree type, vec<constructor_elt, va_gc> *v)\n+//{\n+//  tree pri = CLASSTYPE_PRIMARY_BINFO (type);\n+//  tree field_type;\n+//  unsigned i;\n+//  constructor_elt *ce;\n+//\n+//  if (pri)\n+//    field_type = BINFO_TYPE (pri);\n+//  else if (TYPE_CONTAINS_VPTR_P (type))\n+//    field_type = vtbl_ptr_type_node;\n+//  else\n+//    return v;\n+//\n+//  /* Find the element for the primary base or vptr and move it to the\n+//     beginning of the vec.  */\n+//  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+//    if (TREE_TYPE (ce->index) == field_type)\n+//      break;\n+//\n+//  if (i > 0 && i < vec_safe_length (v))\n+//    {\n+//      vec<constructor_elt, va_gc> &vref = *v;\n+//      constructor_elt elt = vref[i];\n+//      for (; i > 0; --i)\n+//\tvref[i] = vref[i - 1];\n+//      vref[0] = elt;\n+//    }\n+//\n+//  return v;\n+//}\n \n /* Subroutine of  build_constexpr_constructor_member_initializers.\n    The expression tree T represents a data member initialization\n@@ -3755,81 +3759,81 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n   return true;\n }\n \n-/* Build compile-time evalable representations of member-initializer list\n-   for a constexpr constructor.  */\n-\n-static tree\n-build_constexpr_constructor_member_initializers (tree type, tree body)\n-{\n-  vec<constructor_elt, va_gc> *vec = NULL;\n-  bool ok = true;\n-  while (true)\n-    switch (TREE_CODE (body))\n-      {\n-      case STATEMENT_LIST:\n-\tfor (tree stmt : tsi_range (body))\n-\t  {\n-\t    body = stmt;\n-\t    if (TREE_CODE (body) == BIND_EXPR)\n-\t      break;\n-\t  }\n-\tbreak;\n-\n-      case BIND_EXPR:\n-\tbody = BIND_EXPR_BODY (body);\n-\tgoto found;\n-\n-      default:\n-\tgcc_unreachable ();\n-      }\n-found:\n-\n-  if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n-    {\n-      body = TREE_OPERAND (body, 0);\n-      if (TREE_CODE (body) == EXPR_STMT)\n-\tbody = TREE_OPERAND (body, 0);\n-      if (TREE_CODE (body) == INIT_EXPR\n-\t  && (same_type_ignoring_top_level_qualifiers_p (\n-\t    TREE_TYPE (TREE_OPERAND (body, 0)), current_class_type)))\n-\t{\n-\t  /* Trivial copy.  */\n-\t  return TREE_OPERAND (body, 1);\n-\t}\n-      ok = build_data_member_initialization (body, &vec);\n-    }\n-  else if (TREE_CODE (body) == STATEMENT_LIST)\n-    {\n-      for (tree stmt : tsi_range (body))\n-\t{\n-\t  ok = build_data_member_initialization (stmt, &vec);\n-\t  if (!ok)\n-\t    break;\n-\t}\n-    }\n-  else if (EXPR_P (body))\n-    ok = build_data_member_initialization (body, &vec);\n-  else\n-    gcc_assert (errorcount > 0);\n-  if (ok)\n-    {\n-      if (vec_safe_length (vec) > 0)\n-\t{\n-\t  /* In a delegating constructor, return the target.  */\n-\t  constructor_elt *ce = &(*vec)[0];\n-\t  if (ce->index == current_class_ptr)\n-\t    {\n-\t      body = ce->value;\n-\t      vec_free (vec);\n-\t      return body;\n-\t    }\n-\t}\n-      vec = sort_constexpr_mem_initializers (type, vec);\n-      return build_constructor (type, vec);\n-    }\n-  else\n-    return error_mark_node;\n-}\n+///* Build compile-time evalable representations of member-initializer list\n+//   for a constexpr constructor.  */\n+//\n+// static tree\n+// build_constexpr_constructor_member_initializers (tree type, tree body)\n+//{\n+//  vec<constructor_elt, va_gc> *vec = NULL;\n+//  bool ok = true;\n+//  while (true)\n+//    switch (TREE_CODE (body))\n+//      {\n+//      case STATEMENT_LIST:\n+//\tfor (tree stmt : tsi_range (body))\n+//\t  {\n+//\t    body = stmt;\n+//\t    if (TREE_CODE (body) == BIND_EXPR)\n+//\t      break;\n+//\t  }\n+//\tbreak;\n+//\n+//      case BIND_EXPR:\n+//\tbody = BIND_EXPR_BODY (body);\n+//\tgoto found;\n+//\n+//      default:\n+//\tgcc_unreachable ();\n+//      }\n+// found:\n+//\n+//  if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n+//    {\n+//      body = TREE_OPERAND (body, 0);\n+//      if (TREE_CODE (body) == EXPR_STMT)\n+//\tbody = TREE_OPERAND (body, 0);\n+//      if (TREE_CODE (body) == INIT_EXPR\n+//\t  && (same_type_ignoring_top_level_qualifiers_p (\n+//\t    TREE_TYPE (TREE_OPERAND (body, 0)), current_class_type)))\n+//\t{\n+//\t  /* Trivial copy.  */\n+//\t  return TREE_OPERAND (body, 1);\n+//\t}\n+//      ok = build_data_member_initialization (body, &vec);\n+//    }\n+//  else if (TREE_CODE (body) == STATEMENT_LIST)\n+//    {\n+//      for (tree stmt : tsi_range (body))\n+//\t{\n+//\t  ok = build_data_member_initialization (stmt, &vec);\n+//\t  if (!ok)\n+//\t    break;\n+//\t}\n+//    }\n+//  else if (EXPR_P (body))\n+//    ok = build_data_member_initialization (body, &vec);\n+//  else\n+//    gcc_assert (errorcount > 0);\n+//  if (ok)\n+//    {\n+//      if (vec_safe_length (vec) > 0)\n+//\t{\n+//\t  /* In a delegating constructor, return the target.  */\n+//\t  constructor_elt *ce = &(*vec)[0];\n+//\t  if (ce->index == current_class_ptr)\n+//\t    {\n+//\t      body = ce->value;\n+//\t      vec_free (vec);\n+//\t      return body;\n+//\t    }\n+//\t}\n+//      vec = sort_constexpr_mem_initializers (type, vec);\n+//      return build_constructor (type, vec);\n+//    }\n+//  else\n+//    return error_mark_node;\n+//}\n \n // Subroutine of check_constexpr_fundef.  BODY is the body of a function\n // declared to be constexpr, or a sub-statement thereof.  Returns the\n@@ -4457,7 +4461,7 @@ void\n explain_invalid_constexpr_fn (tree fun)\n {\n   static hash_set<tree> *diagnosed;\n-  tree body;\n+  // tree body;\n \n   if (diagnosed == NULL)\n     diagnosed = new hash_set<tree>;\n@@ -5831,7 +5835,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t/* A pointer-to-member constant.  */\n \treturn true;\n \n-    handle_addr_expr:\n+\t// handle_addr_expr:\n #if 0\n       /* FIXME adjust when issue 1197 is fully resolved.  For now don't do\n          any checking here, as we might dereference the pointer later.  If"}, {"sha": "e6ae96931b8734d639bd11130bb1d1dd2649d9dd", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e254c29dc3690603e06a98d94b3d39eb853d7/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e254c29dc3690603e06a98d94b3d39eb853d7/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=f83e254c29dc3690603e06a98d94b3d39eb853d7", "patch": "@@ -1424,16 +1424,16 @@ builtin_pack_call_p (tree call)\n   return builtin_pack_fn_p (CALL_EXPR_FN (call));\n }\n \n-// forked from gcc/cp/pt.cc has_extra_args_mechanism_p\n-\n-/* Return true if the tree T has the extra args mechanism for\n-   avoiding partial instantiation.  */\n-\n-static bool\n-has_extra_args_mechanism_p (const_tree t)\n-{\n-  return false;\n-}\n+//// forked from gcc/cp/pt.cc has_extra_args_mechanism_p\n+//\n+///* Return true if the tree T has the extra args mechanism for\n+//   avoiding partial instantiation.  */\n+//\n+// static bool\n+// has_extra_args_mechanism_p (const_tree t)\n+//{\n+//  return false;\n+//}\n \n // forked from gcc/cp/pt.cc find_parameter_packs_r\n \n@@ -3714,23 +3714,6 @@ char_type_p (tree type)\n tree\n resolve_nondeduced_context (tree orig_expr, tsubst_flags_t complain)\n {\n-  tree expr, offset, baselink;\n-  bool addr;\n-\n-  if (!type_unknown_p (orig_expr))\n-    return orig_expr;\n-\n-  expr = orig_expr;\n-  addr = false;\n-  offset = NULL_TREE;\n-  baselink = NULL_TREE;\n-\n-  if (TREE_CODE (expr) == ADDR_EXPR)\n-    {\n-      expr = TREE_OPERAND (expr, 0);\n-      addr = true;\n-    }\n-\n   return orig_expr;\n }\n "}, {"sha": "378254c59da91794b8d32d2bd168ff53cabe3fbe", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e254c29dc3690603e06a98d94b3d39eb853d7/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e254c29dc3690603e06a98d94b3d39eb853d7/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=f83e254c29dc3690603e06a98d94b3d39eb853d7", "patch": "@@ -3379,7 +3379,7 @@ maybe_constexpr_fn (tree t);\n extern tree\n fold_non_dependent_init (tree, tsubst_flags_t = tf_warning_or_error,\n \t\t\t bool = false, tree = NULL_TREE);\n-}\n+} // namespace Compile\n \n } // namespace Rust\n "}]}