{"sha": "3b5edfeecb64767d26a9cff4b99abe720746ce45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I1ZWRmZWVjYjY0NzY3ZDI2YTljZmY0Yjk5YWJlNzIwNzQ2Y2U0NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-09T11:04:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T11:04:52Z"}, "message": "gcc.c (add_sysrooted_prefix, [...]): Use fatal, not abort.\n\n\t* gcc.c (add_sysrooted_prefix, execute, do_self_spec, do_spec_1,\n\thandle_braces, process_brace_body, main, used_arg,\n\tset_multilib_dir, print_multilib_info): Use fatal, not abort.\n\nFrom-SVN: r87231", "tree": {"sha": "3d5ffc5e520e2925eec6ad90dd8c1c358bcc03a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d5ffc5e520e2925eec6ad90dd8c1c358bcc03a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b5edfeecb64767d26a9cff4b99abe720746ce45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5edfeecb64767d26a9cff4b99abe720746ce45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5edfeecb64767d26a9cff4b99abe720746ce45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5edfeecb64767d26a9cff4b99abe720746ce45/comments", "author": null, "committer": null, "parents": [{"sha": "d73d459345e5d0c1c0048ebb1a8eb5158338697b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73d459345e5d0c1c0048ebb1a8eb5158338697b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d73d459345e5d0c1c0048ebb1a8eb5158338697b"}], "stats": {"total": 133, "additions": 83, "deletions": 50}, "files": [{"sha": "4dff1b82143caa17b3491f7ad3635ec6d7b67595", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b5edfeecb64767d26a9cff4b99abe720746ce45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b5edfeecb64767d26a9cff4b99abe720746ce45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b5edfeecb64767d26a9cff4b99abe720746ce45", "patch": "@@ -1,5 +1,9 @@\n 2004-09-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* gcc.c (add_sysrooted_prefix, execute, do_self_spec, do_spec_1,\n+\thandle_braces, process_brace_body, main, used_arg,\n+\tset_multilib_dir, print_multilib_info): Use fatal, not abort.\n+\n \t* tree-nested.c (create_tmp_var_for): Correct missinverted assert.\n \n \t* tree-outof-ssa.c (free_temp_expr_table): Add missed assert."}, {"sha": "45a9ab44b75453b1e4b587127e494d5b0d264a7f", "filename": "gcc/gcc.c", "status": "modified", "additions": 79, "deletions": 50, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b5edfeecb64767d26a9cff4b99abe720746ce45/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b5edfeecb64767d26a9cff4b99abe720746ce45/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=3b5edfeecb64767d26a9cff4b99abe720746ce45", "patch": "@@ -2628,7 +2628,7 @@ add_sysrooted_prefix (struct path_prefix *pprefix, const char *prefix,\n \t\t      int require_machine_suffix, int os_multilib)\n {\n   if (!IS_ABSOLUTE_PATH (prefix))\n-    abort ();\n+    fatal (\"system path `%s' is not absolute\", prefix);\n \n   if (target_system_root)\n     {\n@@ -2666,8 +2666,7 @@ execute (void)\n \n   struct command *commands;\t/* each command buffer with above info.  */\n \n-  if (processing_spec_function)\n-    abort ();\n+  gcc_assert (!processing_spec_function);\n \n   /* Count # of piped commands.  */\n   for (n_commands = 1, i = 0; i < argbuf_index; i++)\n@@ -2840,8 +2839,7 @@ execute (void)\n \tint pid;\n \n \tpid = pwait (commands[i].pid, &status, 0);\n-\tif (pid < 0)\n-\t  abort ();\n+\tgcc_assert (pid >= 0);\n \n #ifdef HAVE_GETRUSAGE\n \tif (report_times)\n@@ -4365,7 +4363,7 @@ do_self_spec (const char *spec)\n \n \t  /* Each switch should start with '-'.  */\n \t  if (argbuf[i][0] != '-')\n-\t    abort ();\n+\t    fatal (\"switch '%s' does not start with '-'\", argbuf[i]);\n \n \t  sw = &switches[i + first];\n \t  sw->part1 = &argbuf[i][1];\n@@ -4592,7 +4590,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \tswitch (c = *p++)\n \t  {\n \t  case 0:\n-\t    fatal (\"invalid specification!  Bug in cc\");\n+\t    fatal (\"spec '%s' invalid\", spec);\n \n \t  case 'b':\n \t    obstack_grow (&obstack, input_basename, basename_length);\n@@ -4731,7 +4729,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    p += 2;\n \t\t    /* We don't support extra suffix characters after %O.  */\n \t\t    if (*p == '.' || ISALPHA ((unsigned char) *p))\n-\t\t      abort ();\n+\t\t      fatal (\"spec '%s' has invalid `%%0%c'\", spec, *p);\n \t\t    if (suffix_length == 0)\n \t\t      suffix = TARGET_OBJECT_SUFFIX;\n \t\t    else\n@@ -4928,7 +4926,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      int cur_index = argbuf_index;\n \t      /* Handle the {...} following the %W.  */\n \t      if (*p != '{')\n-\t\tabort ();\n+\t\tfatal (\"spec `%s' has invalid `%%W%c\", spec, *p);\n \t      p = handle_braces (p + 1);\n \t      if (p == 0)\n \t\treturn -1;\n@@ -4959,7 +4957,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \n \t      /* Skip past the option value and make a copy.  */\n \t      if (*p != '{')\n-\t\tabort ();\n+\t\tfatal (\"spec `%s' has invalid `%%x%c'\", spec, *p);\n \t      while (*p++ != '}')\n \t\t;\n \t      string = save_string (p1 + 1, p - p1 - 2);\n@@ -5517,6 +5515,7 @@ handle_braces (const char *p)\n {\n   const char *atom, *end_atom;\n   const char *d_atom = NULL, *d_end_atom = NULL;\n+  const char *orig = p;\n \n   bool a_is_suffix;\n   bool a_is_starred;\n@@ -5536,7 +5535,7 @@ handle_braces (const char *p)\n   do\n     {\n       if (a_must_be_last)\n-\tabort ();\n+\tgoto invalid;\n \n       /* Scan one \"atom\" (S in the description above of %{}, possibly\n \t with !, ., or * modifiers).  */\n@@ -5560,32 +5559,33 @@ handle_braces (const char *p)\n \tp++, a_is_starred = 1;\n \n       SKIP_WHITE();\n-      if (*p == '&' || *p == '}')\n+      switch (*p)\n \t{\n+\tcase '&': case '}':\n \t  /* Substitute the switch(es) indicated by the current atom.  */\n \t  ordered_set = true;\n \t  if (disjunct_set || n_way_choice || a_is_negated || a_is_suffix\n \t      || atom == end_atom)\n-\t    abort ();\n+\t    goto invalid;\n \n \t  mark_matching_switches (atom, end_atom, a_is_starred);\n \n \t  if (*p == '}')\n \t    process_marked_switches ();\n-\t}\n-      else if (*p == '|' || *p == ':')\n-\t{\n+\t  break;\n+\n+\tcase '|': case ':':\n \t  /* Substitute some text if the current atom appears as a switch\n \t     or suffix.  */\n \t  disjunct_set = true;\n \t  if (ordered_set)\n-\t    abort ();\n+\t    goto invalid;\n \n \t  if (atom == end_atom)\n \t    {\n \t      if (!n_way_choice || disj_matched || *p == '|'\n \t\t  || a_is_negated || a_is_suffix || a_is_starred)\n-\t\tabort ();\n+\t\tgoto invalid;\n \n \t      /* An empty term may appear as the last choice of an\n \t\t N-way choice set; it means \"otherwise\".  */\n@@ -5596,7 +5596,7 @@ handle_braces (const char *p)\n \t  else\n \t    {\n \t       if (a_is_suffix && a_is_starred)\n-\t\t abort ();\n+\t\t goto invalid;\n \n \t       if (!a_is_starred)\n \t\t disj_starred = false;\n@@ -5639,14 +5639,19 @@ handle_braces (const char *p)\n \t\t  d_atom = d_end_atom = NULL;\n \t\t}\n \t    }\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid;\n \t}\n-      else\n-\tabort ();\n     }\n   while (*p++ != '}');\n \n   return p;\n-\n+  \n+ invalid:\n+  fatal (\"braced spec `%s' is invalid at `%c'\", orig, *p);\n+  \n #undef SKIP_WHITE\n }\n \n@@ -5686,7 +5691,7 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n       else if (*p == '%' && p[1] == '*' && nesting_level == 1)\n \thave_subst = true;\n       else if (*p == '\\0')\n-\tabort ();\n+\tgoto invalid;\n       p++;\n     }\n \n@@ -5695,7 +5700,7 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n     end_body--;\n \n   if (have_subst && !starred)\n-    abort ();\n+    goto invalid;\n \n   if (matched)\n     {\n@@ -5731,6 +5736,9 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n     }\n \n   return p;\n+\n+ invalid:\n+  fatal (\"braced spec body `%s' is invalid\", body);\n }\n \f\n /* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch\n@@ -6454,13 +6462,13 @@ main (int argc, const char **argv)\n \t\t{\n \t\t  value = do_spec (input_file_compiler->spec);\n \t\t  infiles[i].preprocessed = true;\n-\t\t  if (have_o_argbuf_index)\n-\t\t    infiles[i].name = argbuf[have_o_argbuf_index];\n-\t\t  else\n-\t\t    abort ();\n-\t\t  infiles[i].incompiler = lookup_compiler (infiles[i].name,\n-\t\t\t\t\t\t       strlen (infiles[i].name),\n-\t\t\t\t\t\t       infiles[i].language);\n+\t\t  if (!have_o_argbuf_index)\n+\t\t    fatal (\"spec `%s' is invalid\", input_file_compiler->spec);\n+\t\t  infiles[i].name = argbuf[have_o_argbuf_index];\n+\t\t  infiles[i].incompiler\n+\t\t    = lookup_compiler (infiles[i].name,\n+\t\t\t\t       strlen (infiles[i].name),\n+\t\t\t\t       infiles[i].language);\n \n \t\t  if (value < 0)\n \t\t    this_file_error = 1;\n@@ -6921,7 +6929,10 @@ used_arg (const char *p, int len)\n \t  while (*q != ' ')\n \t    {\n \t      if (*q == '\\0')\n-\t\tabort ();\n+\t\t{\n+\t\tinvalid_matches:\n+\t\t  fatal (\"multilib spec `%s' is invalid\", multilib_matches);\n+\t\t}\n \t      q++;\n \t    }\n \t  matches[i].len = q - matches[i].str;\n@@ -6930,7 +6941,7 @@ used_arg (const char *p, int len)\n \t  while (*q != ';' && *q != '\\0')\n \t    {\n \t      if (*q == ' ')\n-\t\tabort ();\n+\t\tgoto invalid_matches;\n \t      q++;\n \t    }\n \t  matches[i].rep_len = q - matches[i].replace;\n@@ -7110,7 +7121,11 @@ set_multilib_dir (void)\n       while (*p != ';')\n \t{\n \t  if (*p == '\\0')\n-\t    abort ();\n+\t    {\n+\t    invalid_exclusions:\n+\t      fatal (\"multilib exclusions `%s' is invalid\",\n+\t\t     multilib_exclusions);\n+\t    }\n \n \t  if (! ok)\n \t    {\n@@ -7122,7 +7137,7 @@ set_multilib_dir (void)\n \t  while (*p != ' ' && *p != ';')\n \t    {\n \t      if (*p == '\\0')\n-\t\tabort ();\n+\t\tgoto invalid_exclusions;\n \t      ++p;\n \t    }\n \n@@ -7164,7 +7179,11 @@ set_multilib_dir (void)\n       while (*p != ' ')\n \t{\n \t  if (*p == '\\0')\n-\t    abort ();\n+\t    {\n+\t    invalid_select:\n+\t      fatal (\"multilib select `%s' is invalid\",\n+\t\t     multilib_select);\n+\t    }\n \t  ++p;\n \t}\n       this_path_len = p - this_path;\n@@ -7176,7 +7195,7 @@ set_multilib_dir (void)\n       while (*p != ';')\n \t{\n \t  if (*p == '\\0')\n-\t    abort ();\n+\t    goto invalid_select;\n \n \t  if (! ok)\n \t    {\n@@ -7188,7 +7207,7 @@ set_multilib_dir (void)\n \t  while (*p != ' ' && *p != ';')\n \t    {\n \t      if (*p == '\\0')\n-\t\tabort ();\n+\t\tgoto invalid_select;\n \t      ++p;\n \t    }\n \n@@ -7301,7 +7320,11 @@ print_multilib_info (void)\n       while (*p != ' ')\n \t{\n \t  if (*p == '\\0')\n-\t    abort ();\n+\t    {\n+\t    invalid_select:\n+\t      fatal (\"multilib select `%s' is invalid\", multilib_select);\n+\t    }\n+\t  \n \t  ++p;\n \t}\n \n@@ -7335,7 +7358,11 @@ print_multilib_info (void)\n \t\tint mp = 0;\n \n \t\tif (*e == '\\0')\n-\t\t  abort ();\n+\t\t  {\n+\t\t  invalid_exclusion:\n+\t\t    fatal (\"multilib exclusion `%s' is invalid\",\n+\t\t\t   multilib_exclusions);\n+\t\t  }\n \n \t\tif (! m)\n \t\t  {\n@@ -7348,7 +7375,7 @@ print_multilib_info (void)\n \t\twhile (*e != ' ' && *e != ';')\n \t\t  {\n \t\t    if (*e == '\\0')\n-\t\t      abort ();\n+\t\t      goto invalid_exclusion;\n \t\t    ++e;\n \t\t  }\n \n@@ -7359,19 +7386,20 @@ print_multilib_info (void)\n \t\t    int len = e - this_arg;\n \n \t\t    if (*q == '\\0')\n-\t\t      abort ();\n+\t\t      goto invalid_select;\n \n \t\t    arg = q;\n \n \t\t    while (*q != ' ' && *q != ';')\n \t\t      {\n \t\t\tif (*q == '\\0')\n-\t\t\t  abort ();\n+\t\t\t  goto invalid_select;\n \t\t\t++q;\n \t\t      }\n \n-\t\t    if (! strncmp (arg, this_arg, (len < q - arg) ? q - arg : len) ||\n-\t\t\tdefault_arg (this_arg, e - this_arg))\n+\t\t    if (! strncmp (arg, this_arg,\n+\t\t\t\t   (len < q - arg) ? q - arg : len)\n+\t\t\t|| default_arg (this_arg, e - this_arg))\n \t\t      {\n \t\t\tmp = 1;\n \t\t\tbreak;\n@@ -7402,7 +7430,8 @@ print_multilib_info (void)\n       if (! skip)\n \t{\n \t  /* If this is a duplicate, skip it.  */\n-\t  skip = (last_path != 0 && (unsigned int) (p - this_path) == last_path_len\n+\t  skip = (last_path != 0\n+\t\t  && (unsigned int) (p - this_path) == last_path_len\n \t\t  && ! strncmp (last_path, this_path, last_path_len));\n \n \t  last_path = this_path;\n@@ -7422,7 +7451,7 @@ print_multilib_info (void)\n \t      const char *arg;\n \n \t      if (*q == '\\0')\n-\t\tabort ();\n+\t\tgoto invalid_select;\n \n \t      if (*q == '!')\n \t\targ = NULL;\n@@ -7432,7 +7461,7 @@ print_multilib_info (void)\n \t      while (*q != ' ' && *q != ';')\n \t\t{\n \t\t  if (*q == '\\0')\n-\t\t    abort ();\n+\t\t    goto invalid_select;\n \t\t  ++q;\n \t\t}\n \n@@ -7463,7 +7492,7 @@ print_multilib_info (void)\n \t  int use_arg;\n \n \t  if (*p == '\\0')\n-\t    abort ();\n+\t    goto invalid_select;\n \n \t  if (skip)\n \t    {\n@@ -7479,7 +7508,7 @@ print_multilib_info (void)\n \t  while (*p != ' ' && *p != ';')\n \t    {\n \t      if (*p == '\\0')\n-\t\tabort ();\n+\t\tgoto invalid_select;\n \t      if (use_arg)\n \t\tputchar (*p);\n \t      ++p;"}]}