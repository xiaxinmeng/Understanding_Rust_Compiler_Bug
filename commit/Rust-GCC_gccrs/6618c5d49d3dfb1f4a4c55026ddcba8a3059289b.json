{"sha": "6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYxOGM1ZDQ5ZDNkZmIxZjRhNGM1NTAyNmRkY2JhOGEzMDU5Mjg5Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-10T06:03:13Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-10T06:03:13Z"}, "message": "cpphash.h (struct cpp_macro): Put comments on their own lines.\n\n\t* cpphash.h (struct cpp_macro): Put comments on their own lines.\n\t(_cpp_expansions_different_trad): New.\n\t* cppmacro.c (warn_of_redefinition): Fix for traditional case.\n\t* cpptrad.c (canonicalize_text): New.\n\t(scan_out_logical_line): Handle no arguments correctly.\n\t(save_replacement_text): Commit memory when finished.\n\t(_cpp_expansions_different_trad): New.\n\nFrom-SVN: r54432", "tree": {"sha": "adbb48f5611c4e938179b3f12970a0c7bef07ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adbb48f5611c4e938179b3f12970a0c7bef07ce1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/comments", "author": null, "committer": null, "parents": [{"sha": "36d010cabfac9532fcd0bc5e52ea2b2bf941e4ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d010cabfac9532fcd0bc5e52ea2b2bf941e4ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d010cabfac9532fcd0bc5e52ea2b2bf941e4ba"}], "stats": {"total": 175, "additions": 145, "deletions": 30}, "files": [{"sha": "0f6cf2e50c1fcfda75642ff846d8f3f06fb8c89f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "patch": "@@ -1,3 +1,13 @@\n+2002-06-10  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_macro): Put comments on their own lines.\n+\t(_cpp_expansions_different_trad): New.\n+\t* cppmacro.c (warn_of_redefinition): Fix for traditional case.\n+\t* cpptrad.c (canonicalize_text): New.\n+\t(scan_out_logical_line): Handle no arguments correctly.\n+\t(save_replacement_text): Commit memory when finished.\n+\t(_cpp_expansions_different_trad): New.\n+\n 2002-06-10  Tim Josling  <tej@melbpc.org.au>\n \n \t* gengtype.c (unnamed enum containing BASE_FILE_*): Add languages"}, {"sha": "6d41ead62373a8a71103f583a15b2a72028eb264", "filename": "gcc/cpphash.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "patch": "@@ -69,18 +69,35 @@ struct dummy\n    Variadic macros cannot occur with traditional cpp.  */\n struct cpp_macro\n {\n-  cpp_hashnode **params;\t/* Parameters, if any.  */\n+  /* Parameters, if any.  */\n+  cpp_hashnode **params;\n+\n+  /* Replacement tokens (ISO) or replacement text (traditional).  See\n+     comment at top of cpptrad.c for how traditional function-like\n+     macros are encoded.  */\n   union\n   {\n-    cpp_token *tokens;\t        /* Tokens of replacement list (ISO).  */\n-    const uchar *text;\t\t/* Expansion text (traditional).  */\n+    cpp_token *tokens;\n+    const uchar *text;\n   } exp;\n-  unsigned int line;\t\t/* Starting line number.  */\n-  unsigned int count;\t\t/* Number of tokens / bytes in expansion.  */\n-  unsigned short paramc;\t/* Number of parameters.  */\n-  unsigned int fun_like : 1;\t/* If a function-like macro.  */\n-  unsigned int variadic : 1;\t/* If a variadic macro.  */\n-  unsigned int syshdr   : 1;\t/* If macro defined in system header.  */\n+\n+  /* Definition line number.  */\n+  unsigned int line;\n+\n+  /* Number of tokens in expansion, or bytes for traditional macros.  */\n+  unsigned int count;\n+\n+  /* Number of parameters.  */\n+  unsigned short paramc;\n+\n+  /* If a function-like macro.  */\n+  unsigned int fun_like : 1;\n+\n+  /* If a variadic macro.  */\n+  unsigned int variadic : 1;\n+\n+  /* If macro defined in system header.  */\n+  unsigned int syshdr   : 1;\n };\n \n /* A generic memory buffer, and operations on it.  */\n@@ -499,6 +516,7 @@ extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n extern cpp_hashnode *_cpp_lex_identifier_trad PARAMS ((cpp_reader *));\n extern void _cpp_set_trad_context PARAMS ((cpp_reader *));\n extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n+extern bool _cpp_expansions_different_trad PARAMS ((cpp_macro *, cpp_macro *));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1"}, {"sha": "a9ca6cf2dbfe864b1fd2a8c6c175835468e16156", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "patch": "@@ -1176,9 +1176,9 @@ warn_of_redefinition (pfile, node, macro2)\n      definitions are the same.  (6.10.3 paragraph 2).  */\n   macro1 = node->value.macro;\n \n-  /* The quick failures.  */\n-  if (macro1->count != macro2->count\n-      || macro1->paramc != macro2->paramc\n+  /* Don't check count here as it can be different in valid\n+     traditional redefinitions with just whitespace differences.  */\n+  if (macro1->paramc != macro2->paramc\n       || macro1->fun_like != macro2->fun_like\n       || macro1->variadic != macro2->variadic)\n     return true;\n@@ -1190,11 +1190,12 @@ warn_of_redefinition (pfile, node, macro2)\n \n   /* Check the replacement text or tokens.  */\n   if (CPP_OPTION (pfile, traditional))\n-    return memcmp (macro1->exp.text, macro2->exp.text, macro1->count);\n+    return _cpp_expansions_different_trad (macro1, macro2);\n \n-  for (i = 0; i < macro1->count; i++)\n-    if (!_cpp_equiv_tokens (&macro1->exp.tokens[i], &macro2->exp.tokens[i]))\n-      return true;\n+  if (macro1->count == macro2->count)\n+    for (i = 0; i < macro1->count; i++)\n+      if (!_cpp_equiv_tokens (&macro1->exp.tokens[i], &macro2->exp.tokens[i]))\n+\treturn true;\n \n   return false;\n }"}, {"sha": "4a76f96f0f28ad8e8bed52ecc384512642f86afd", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 100, "deletions": 14, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6618c5d49d3dfb1f4a4c55026ddcba8a3059289b/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=6618c5d49d3dfb1f4a4c55026ddcba8a3059289b", "patch": "@@ -89,6 +89,8 @@ static void maybe_start_funlike PARAMS ((cpp_reader *, cpp_hashnode *,\n \t\t\t\t\t const uchar *, struct fun_macro *));\n static void save_argument PARAMS ((struct fun_macro *, size_t));\n static void replace_args_and_push PARAMS ((cpp_reader *, struct fun_macro *));\n+static size_t canonicalize_text PARAMS ((uchar *, const uchar *, size_t,\n+\t\t\t\t\t uchar *));\n \n /* Ensures we have N bytes' space in the output buffer, and\n    reallocates it if not.  */\n@@ -557,16 +559,11 @@ scan_out_logical_line (pfile, macro)\n \t\t  pfile->state.parsing_args = 0;\n \t\t  save_argument (&fmacro, out - pfile->trad_out_base);\n \n-\t\t  /* A single whitespace argument is no argument.  */\n-\t\t  if (fmacro.argc == 1 && m->paramc == 0)\n-\t\t    {\n-\t\t      const uchar *p = pfile->trad_out_base;\n-\t\t      p += fmacro.args[0];\n-\t\t      while (is_space (*p))\n-\t\t\tp++;\n-\t\t      if (p == pfile->trad_out_base + fmacro.args[1])\n-\t\t\tfmacro.argc = 0;\n-\t\t    }\n+\t\t  /* A single zero-length argument is no argument.  */\n+\t\t  if (fmacro.argc == 1\n+\t\t      && m->paramc == 0\n+\t\t      && out == pfile->trad_out_base + 1)\n+\t\t    fmacro.argc = 0;\n \n \t\t  if (_cpp_arguments_ok (pfile, m, fmacro.node, fmacro.argc))\n \t\t    {\n@@ -758,11 +755,11 @@ save_replacement_text (pfile, macro, arg_index)\n       /* Lex the rest into the start of the output buffer.  */\n       pfile->trad_out_cur = pfile->trad_out_base;\n \n-      /* If this is the end of the macro, count up the bytes of text\n-\t in the replacement list, excluding the parameter names, and\n-\t save this in macro->count, else store the total bytes in the\n-\t replacement text so far (including block headers).  */\n       macro->count += blen;\n+\n+      /* If we've finished, commit the memory.  */\n+      if (arg_index == 0)\n+\tBUFF_FRONT (pfile->a_buff) += macro->count;\n     }\n }\n \n@@ -814,6 +811,95 @@ _cpp_create_trad_definition (pfile, macro)\n   return true;\n }\n \n+/* Copy SRC of length LEN to DEST, but convert all contiguous\n+   whitespace to a single space, provided it is not in quotes.  The\n+   quote currently in effect is pointed to by PQUOTE, and is updated\n+   by the function.  Returns the number of bytes copied.  */\n+static size_t\n+canonicalize_text (dest, src, len, pquote)\n+     uchar *dest;\n+     const uchar *src;\n+     size_t len;\n+     uchar *pquote;\n+{\n+  uchar *orig_dest = dest;\n+  uchar quote = *pquote;\n+\n+  while (len)\n+    {\n+      if (is_space (*src) && !quote)\n+\t{\n+\t  do\n+\t    src++, len--;\n+\t  while (len && is_space (*src));\n+\t  *dest++ = ' ';\n+\t}\n+      else\n+\t{\n+\t  if (*src == '\\'' || *src == '\"')\n+\t    {\n+\t      if (!quote)\n+\t\tquote = *src;\n+\t      else if (quote == *src)\n+\t\tquote = 0;\n+\t    }\n+\t  *dest++ = *src++, len--;\n+\t}\n+    }\n+\n+  *pquote = quote;\n+  return dest - orig_dest;\n+}\n+\n+/* Returns true if MACRO1 and MACRO2 have expansions different other\n+   than in the form of their whitespace.  */\n+bool\n+_cpp_expansions_different_trad (macro1, macro2)\n+     cpp_macro *macro1, *macro2;\n+{\n+  uchar *p1 = xmalloc (macro1->count + macro2->count);\n+  uchar *p2 = p1 + macro1->count;\n+  uchar quote1 = 0, quote2;\n+  bool mismatch;\n+  size_t len1, len2;\n+\n+  if (macro1->paramc > 0)\n+    {\n+      const uchar *exp1 = macro1->exp.text, *exp2 = macro2->exp.text;\n+\n+      mismatch = true;\n+      for (;;)\n+\t{\n+\t  struct block *b1 = (struct block *) exp1;\n+\t  struct block *b2 = (struct block *) exp2;\n+\n+\t  if (b1->arg_index != b2->arg_index)\n+\t    break;\n+\n+\t  len1 = canonicalize_text (p1, b1->text, b1->text_len, &quote1);\n+\t  len2 = canonicalize_text (p2, b2->text, b2->text_len, &quote2);\n+\t  if (len1 != len2 || memcmp (p1, p2, len1))\n+\t    break;\n+\t  if (b1->arg_index == 0)\n+\t    {\n+\t      mismatch = false;\n+\t      break;\n+\t    }\n+\t  exp1 += BLOCK_LEN (b1->text_len);\n+\t  exp2 += BLOCK_LEN (b2->text_len);\n+\t}\n+    }\n+  else\n+    {\n+      len1 = canonicalize_text (p1, macro1->exp.text, macro1->count, &quote1);\n+      len2 = canonicalize_text (p2, macro2->exp.text, macro2->count, &quote2);\n+      mismatch = (len1 != len2 || memcmp (p1, p2, len1));\n+    }\n+\n+  free (p1);\n+  return mismatch;\n+}\n+\n /* Prepare to be able to scan the current buffer.  */\n void\n _cpp_set_trad_context (pfile)"}]}