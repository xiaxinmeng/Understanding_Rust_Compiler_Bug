{"sha": "6f76a8788eebd50b78213f086166889167f0fcb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3NmE4Nzg4ZWViZDUwYjc4MjEzZjA4NjE2Njg4OTE2N2YwZmNiMg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-05-01T12:33:13Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-05-01T12:33:13Z"}, "message": "reginfo.c (memory_move_cost): Change rclass argument type form 'enum reg_class' to reg_class_t.\n\n\t* reginfo.c (memory_move_cost): Change rclass argument type form\n\t'enum reg_class' to reg_class_t.\n\t* reload.h (memory_move_cost): Update prototype.\n\t* postreload.c reload_cse_simplify_set): Change type dclass var to\n\treg_class_t.\n\t* ira-int.h (ira_allocate_cost_vector, ira_free_cost_vector):\n\tUpdate prototype.\n\t(ira_allocate_and_set_costs): Change aclass argument type form\n\t'enum reg_class' to reg_class_t.\n\t* ira-build.c (ira_allocate_cost_vector, ira_free_cost_vector): \n\tChange aclass argument type to reg_class_t.\n\t(update_conflict_hard_reg_costs): Change type aclass and pref vars\n\tto reg_class_t.\n\t* gcc/ira.c (setup_class_subset_and_memory_move_costs): Adjust\n\tmemory_move_cost call.\n\n\t* config/ia64/ia64.c (ia64_register_move_cost): Remove 'from' and\n\t'to' local var. Rename from_i and to_i arguments to 'from' and 'to'.\n\tChange type tmp var to reg_class_t.\n\nFrom-SVN: r173232", "tree": {"sha": "9da28edb6adadb3c992cd303c7a4d0fc04b5f13d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9da28edb6adadb3c992cd303c7a4d0fc04b5f13d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f76a8788eebd50b78213f086166889167f0fcb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f76a8788eebd50b78213f086166889167f0fcb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f76a8788eebd50b78213f086166889167f0fcb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f76a8788eebd50b78213f086166889167f0fcb2/comments", "author": null, "committer": null, "parents": [{"sha": "7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e"}], "stats": {"total": 69, "additions": 45, "deletions": 24}, "files": [{"sha": "92ea25f757c658fcdbfd959288f63cca4eec37ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -1,3 +1,25 @@\n+2011-05-01  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* reginfo.c (memory_move_cost): Change rclass argument type form\n+\t'enum reg_class' to reg_class_t.\n+\t* reload.h (memory_move_cost): Update prototype.\n+\t* postreload.c reload_cse_simplify_set): Change type dclass var to\n+\treg_class_t.\n+\t* ira-int.h (ira_allocate_cost_vector, ira_free_cost_vector):\n+\tUpdate prototype.\n+\t(ira_allocate_and_set_costs): Change aclass argument type form\n+\t'enum reg_class' to reg_class_t.\n+\t* ira-build.c (ira_allocate_cost_vector, ira_free_cost_vector): \n+\tChange aclass argument type to reg_class_t.\n+\t(update_conflict_hard_reg_costs): Change type aclass and pref vars\n+\tto reg_class_t.\n+\t* gcc/ira.c (setup_class_subset_and_memory_move_costs): Adjust\n+\tmemory_move_cost call.\n+\n+\t* config/ia64/ia64.c (ia64_register_move_cost): Remove 'from' and\n+\t'to' local var. Rename from_i and to_i arguments to 'from' and 'to'.\n+\tChange type tmp var to reg_class_t.\n+\n 2011-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline.c (can_inline_edge_p): Disregard limits when"}, {"sha": "adcb780b9270d56cb753237e9c0f768f27f7bf80", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -5347,12 +5347,9 @@ ia64_rtx_costs (rtx x, int code, int outer_code, int *total,\n    one in class TO, using MODE.  */\n \n static int\n-ia64_register_move_cost (enum machine_mode mode, reg_class_t from_i,\n-\t\t\t reg_class_t to_i)\n+ia64_register_move_cost (enum machine_mode mode, reg_class_t from,\n+\t\t\t reg_class_t to)\n {\n-  enum reg_class from = (enum reg_class) from_i;\n-  enum reg_class to = (enum reg_class) to_i;\n-\n   /* ADDL_REGS is the same as GR_REGS for movement purposes.  */\n   if (to == ADDL_REGS)\n     to = GR_REGS;\n@@ -5363,7 +5360,7 @@ ia64_register_move_cost (enum machine_mode mode, reg_class_t from_i,\n      lower number class as the destination.  */\n   if (from < to)\n     {\n-      enum reg_class tmp = to;\n+      reg_class_t tmp = to;\n       to = from, from = tmp;\n     }\n "}, {"sha": "09897d95387cdf47c372d402446e7c0f75cbb7e5", "filename": "gcc/ira-build.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -1402,17 +1402,17 @@ initiate_cost_vectors (void)\n \n /* Allocate and return a cost vector VEC for ACLASS.  */\n int *\n-ira_allocate_cost_vector (enum reg_class aclass)\n+ira_allocate_cost_vector (reg_class_t aclass)\n {\n-  return (int *) pool_alloc (cost_vector_pool[aclass]);\n+  return (int *) pool_alloc (cost_vector_pool[(int) aclass]);\n }\n \n /* Free a cost vector VEC for ACLASS.  */\n void\n-ira_free_cost_vector (int *vec, enum reg_class aclass)\n+ira_free_cost_vector (int *vec, reg_class_t aclass)\n {\n   ira_assert (vec != NULL);\n-  pool_free (cost_vector_pool[aclass], vec);\n+  pool_free (cost_vector_pool[(int) aclass], vec);\n }\n \n /* Finish work with hard register cost vectors.  Release allocation\n@@ -2969,19 +2969,20 @@ update_conflict_hard_reg_costs (void)\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      enum reg_class aclass = ALLOCNO_CLASS (a);\n-      enum reg_class pref = reg_preferred_class (ALLOCNO_REGNO (a));\n+      reg_class_t aclass = ALLOCNO_CLASS (a);\n+      reg_class_t pref = reg_preferred_class (ALLOCNO_REGNO (a));\n \n-      if (reg_class_size[pref] != 1)\n+      if (reg_class_size[(int) pref] != 1)\n \tcontinue;\n-      index = ira_class_hard_reg_index[aclass][ira_class_hard_regs[pref][0]];\n+      index = ira_class_hard_reg_index[(int) aclass]\n+\t\t\t\t      [ira_class_hard_regs[(int) pref][0]];\n       if (index < 0)\n \tcontinue;\n       if (ALLOCNO_CONFLICT_HARD_REG_COSTS (a) == NULL\n \t  || ALLOCNO_HARD_REG_COSTS (a) == NULL)\n \tcontinue;\n       min = INT_MAX;\n-      for (i = ira_class_hard_regs_num[aclass] - 1; i >= 0; i--)\n+      for (i = ira_class_hard_regs_num[(int) aclass] - 1; i >= 0; i--)\n \tif (ALLOCNO_HARD_REG_COSTS (a)[i] > ALLOCNO_CLASS_COST (a)\n \t    && min > ALLOCNO_HARD_REG_COSTS (a)[i])\n \t  min = ALLOCNO_HARD_REG_COSTS (a)[i];"}, {"sha": "6a6c4831c008b84af4738d1b33f4cdc19b250eef", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -989,8 +989,8 @@ extern void ira_swap_allocno_copy_ends_if_necessary (ira_copy_t);\n extern ira_copy_t ira_add_allocno_copy (ira_allocno_t, ira_allocno_t, int,\n \t\t\t\t\tbool, rtx, ira_loop_tree_node_t);\n \n-extern int *ira_allocate_cost_vector (enum reg_class);\n-extern void ira_free_cost_vector (int *, enum reg_class);\n+extern int *ira_allocate_cost_vector (reg_class_t);\n+extern void ira_free_cost_vector (int *, reg_class_t);\n \n extern void ira_flattening (int, int);\n extern bool ira_build (bool);\n@@ -1347,15 +1347,15 @@ ira_hard_reg_not_in_set_p (int hard_regno, enum machine_mode mode,\n /* Allocate cost vector *VEC for hard registers of ACLASS and\n    initialize the elements by VAL if it is necessary */\n static inline void\n-ira_allocate_and_set_costs (int **vec, enum reg_class aclass, int val)\n+ira_allocate_and_set_costs (int **vec, reg_class_t aclass, int val)\n {\n   int i, *reg_costs;\n   int len;\n \n   if (*vec != NULL)\n     return;\n   *vec = reg_costs = ira_allocate_cost_vector (aclass);\n-  len = ira_class_hard_regs_num[aclass];\n+  len = ira_class_hard_regs_num[(int) aclass];\n   for (i = 0; i < len; i++)\n     reg_costs[i] = val;\n }"}, {"sha": "32dfa18ce19882217a1bd9db2148c302141e2ef6", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -583,11 +583,11 @@ setup_class_subset_and_memory_move_costs (void)\n \t    ira_max_memory_move_cost[mode][cl][0]\n \t      = ira_memory_move_cost[mode][cl][0]\n \t      = memory_move_cost ((enum machine_mode) mode,\n-\t\t\t\t  (enum reg_class) cl, false);\n+\t\t\t\t  (reg_class_t) cl, false);\n \t    ira_max_memory_move_cost[mode][cl][1]\n \t      = ira_memory_move_cost[mode][cl][1]\n \t      = memory_move_cost ((enum machine_mode) mode,\n-\t\t\t\t  (enum reg_class) cl, true);\n+\t\t\t\t  (reg_class_t) cl, true);\n \t    /* Costs for NO_REGS are used in cost calculation on the\n \t       1st pass when the preferred register classes are not\n \t       known yet.  In this case we take the best scenario.  */"}, {"sha": "0f3e5c24658dbef8b41dfba5db1dba3ce43b53f5", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -233,7 +233,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n   int did_change = 0;\n   int dreg;\n   rtx src;\n-  enum reg_class dclass;\n+  reg_class_t dclass;\n   int old_cost;\n   cselib_val *val;\n   struct elt_loc_list *l;"}, {"sha": "a283a9085262b1be2f87dcc862c4da3010e6f448", "filename": "gcc/reginfo.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -629,8 +629,9 @@ register_move_cost (enum machine_mode mode, reg_class_t from, reg_class_t to)\n }\n \n /* Compute cost of moving registers to/from memory.  */\n+\n int\n-memory_move_cost (enum machine_mode mode, enum reg_class rclass, bool in)\n+memory_move_cost (enum machine_mode mode, reg_class_t rclass, bool in)\n {\n   return targetm.memory_move_cost (mode, rclass, in);\n }"}, {"sha": "c9df112b2d02490b5bd8eb7091a4e6e91d07ea35", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76a8788eebd50b78213f086166889167f0fcb2/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=6f76a8788eebd50b78213f086166889167f0fcb2", "patch": "@@ -31,7 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n extern int register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n-extern int memory_move_cost (enum machine_mode, enum reg_class, bool);\n+extern int memory_move_cost (enum machine_mode, reg_class_t, bool);\n extern int memory_move_secondary_cost (enum machine_mode, reg_class_t, bool);\n \n /* Maximum number of reloads we can need.  */"}]}