{"sha": "0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d", "node_id": "C_kwDOANBUbNoAKDAzODZjNDBlZWJmMTgwMGRjNzcyOGJhODVmM2RiYmI5ZWM0ZWViNWQ", "commit": {"author": {"name": "Jeff Chapman II", "email": "jchapman@lock3software.com", "date": "2022-11-03T19:47:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-11-04T17:07:14Z"}, "message": "input: add get_source_text_between\n\nThe c++-contracts branch uses this to retrieve the source form of the\ncontract predicate, to be returned by contract_violation::comment().\n\nCo-authored-by: Jason Merrill  <jason@redhat.com>\n\ngcc/ChangeLog:\n\n\t* input.cc (get_source_text_between): New fn.\n\t* input.h (get_source_text_between): Declare.", "tree": {"sha": "4e50664ab59a990dff40825e20f4ad72961a9bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e50664ab59a990dff40825e20f4ad72961a9bfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d/comments", "author": {"login": "JAChapmanII", "id": 290834, "node_id": "MDQ6VXNlcjI5MDgzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/290834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JAChapmanII", "html_url": "https://github.com/JAChapmanII", "followers_url": "https://api.github.com/users/JAChapmanII/followers", "following_url": "https://api.github.com/users/JAChapmanII/following{/other_user}", "gists_url": "https://api.github.com/users/JAChapmanII/gists{/gist_id}", "starred_url": "https://api.github.com/users/JAChapmanII/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JAChapmanII/subscriptions", "organizations_url": "https://api.github.com/users/JAChapmanII/orgs", "repos_url": "https://api.github.com/users/JAChapmanII/repos", "events_url": "https://api.github.com/users/JAChapmanII/events{/privacy}", "received_events_url": "https://api.github.com/users/JAChapmanII/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679be32e66428f0ba81d1c1b55f7bd47f01cb295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/679be32e66428f0ba81d1c1b55f7bd47f01cb295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/679be32e66428f0ba81d1c1b55f7bd47f01cb295"}], "stats": {"total": 93, "additions": 93, "deletions": 0}, "files": [{"sha": "c185bd74c1f37527c97518565a48bcba63a20dc5", "filename": "gcc/input.cc", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d/gcc%2Finput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d/gcc%2Finput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.cc?ref=0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d", "patch": "@@ -949,6 +949,98 @@ location_get_source_line (const char *file_path, int line)\n   return char_span (buffer, len);\n }\n \n+/* Return a NUL-terminated copy of the source text between two locations, or\n+   NULL if the arguments are invalid.  The caller is responsible for freeing\n+   the return value.  */\n+\n+char *\n+get_source_text_between (location_t start, location_t end)\n+{\n+  expanded_location expstart =\n+    expand_location_to_spelling_point (start, LOCATION_ASPECT_START);\n+  expanded_location expend =\n+    expand_location_to_spelling_point (end, LOCATION_ASPECT_FINISH);\n+\n+  /* If the locations are in different files or the end comes before the\n+     start, give up and return nothing.  */\n+  if (!expstart.file || !expend.file)\n+    return NULL;\n+  if (strcmp (expstart.file, expend.file) != 0)\n+    return NULL;\n+  if (expstart.line > expend.line)\n+    return NULL;\n+  if (expstart.line == expend.line\n+      && expstart.column > expend.column)\n+    return NULL;\n+  /* These aren't real column numbers, give up.  */\n+  if (expstart.column == 0 || expend.column == 0)\n+    return NULL;\n+\n+  /* For a single line we need to trim both edges.  */\n+  if (expstart.line == expend.line)\n+    {\n+      char_span line = location_get_source_line (expstart.file, expstart.line);\n+      if (line.length () < 1)\n+\treturn NULL;\n+      int s = expstart.column - 1;\n+      int len = expend.column - s;\n+      if (line.length () < (size_t)expend.column)\n+\treturn NULL;\n+      return line.subspan (s, len).xstrdup ();\n+    }\n+\n+  struct obstack buf_obstack;\n+  obstack_init (&buf_obstack);\n+\n+  /* Loop through all lines in the range and append each to buf; may trim\n+     parts of the start and end lines off depending on column values.  */\n+  for (int lnum = expstart.line; lnum <= expend.line; ++lnum)\n+    {\n+      char_span line = location_get_source_line (expstart.file, lnum);\n+      if (line.length () < 1 && (lnum != expstart.line && lnum != expend.line))\n+\tcontinue;\n+\n+      /* For the first line in the range, only start at expstart.column */\n+      if (lnum == expstart.line)\n+\t{\n+\t  unsigned off = expstart.column - 1;\n+\t  if (line.length () < off)\n+\t    return NULL;\n+\t  line = line.subspan (off, line.length() - off);\n+\t}\n+      /* For the last line, don't go past expend.column */\n+      else if (lnum == expend.line)\n+\t{\n+\t  if (line.length () < (size_t)expend.column)\n+\t    return NULL;\n+\t  line = line.subspan (0, expend.column);\n+\t}\n+\n+      /* Combine spaces at the beginning of later lines.  */\n+      if (lnum > expstart.line)\n+\t{\n+\t  unsigned off;\n+\t  for (off = 0; off < line.length(); ++off)\n+\t    if (line[off] != ' ' && line[off] != '\\t')\n+\t      break;\n+\t  if (off > 0)\n+\t    {\n+\t      obstack_1grow (&buf_obstack, ' ');\n+\t      line = line.subspan (off, line.length() - off);\n+\t    }\n+\t}\n+\n+      /* This does not include any trailing newlines.  */\n+      obstack_grow (&buf_obstack, line.get_buffer (), line.length ());\n+    }\n+\n+  /* NUL-terminate and finish the buf obstack.  */\n+  obstack_1grow (&buf_obstack, 0);\n+  const char *buf = (const char *) obstack_finish (&buf_obstack);\n+\n+  return xstrdup (buf);\n+}\n+\n /* Determine if FILE_PATH missing a trailing newline on its final line.\n    Only valid to call once all of the file has been loaded, by\n    requesting a line number beyond the end of the file.  */"}, {"sha": "f18769950b5a00d67d1b7d6b9cbd4fdad81111c9", "filename": "gcc/input.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=0386c40eebf1800dc7728ba85f3dbbb9ec4eeb5d", "patch": "@@ -111,6 +111,7 @@ class char_span\n };\n \n extern char_span location_get_source_line (const char *file_path, int line);\n+extern char *get_source_text_between (location_t, location_t);\n \n extern bool location_missing_trailing_newline (const char *file_path);\n "}]}