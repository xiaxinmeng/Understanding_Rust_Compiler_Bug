{"sha": "f1149235142d434a76ceec242944c85c9749d3d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjExNDkyMzUxNDJkNDM0YTc2Y2VlYzI0Mjk0NGM4NWM5NzQ5ZDNkNA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2009-08-20T09:19:53Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-08-20T09:19:53Z"}, "message": "s390.md (\"*brx_stage1_<GPR:mode>\", [...]): New patterns.\n\n2009-08-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.md (\"*brx_stage1_<GPR:mode>\", \"*brxg_64bit\",\n\t\"*brx_64bit\", \"*brx_31bit\"): New patterns.\n\t* config/s390/s390.c ('E'): New output modifier.\n\nFrom-SVN: r150954", "tree": {"sha": "31e0965f7952a66e2759635c762fd4bd809f2972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31e0965f7952a66e2759635c762fd4bd809f2972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1149235142d434a76ceec242944c85c9749d3d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1149235142d434a76ceec242944c85c9749d3d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1149235142d434a76ceec242944c85c9749d3d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1149235142d434a76ceec242944c85c9749d3d4/comments", "author": null, "committer": null, "parents": [{"sha": "a552b644fb1f7fe9eb3fd637839007669edd221c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a552b644fb1f7fe9eb3fd637839007669edd221c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a552b644fb1f7fe9eb3fd637839007669edd221c"}], "stats": {"total": 193, "additions": 193, "deletions": 0}, "files": [{"sha": "f35ed54663d590cb585b4bdf1e2f5e3a24dca0be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1149235142d434a76ceec242944c85c9749d3d4", "patch": "@@ -1,3 +1,9 @@\n+2009-08-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.md (\"*brx_stage1_<GPR:mode>\", \"*brxg_64bit\",\n+\t\"*brx_64bit\", \"*brx_31bit\"): New patterns.\n+\t* config/s390/s390.c ('E'): New output modifier.\n+\n 2009-08-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n             Richard Earnshaw  <richard.earnshaw@arm.com>\n "}, {"sha": "9d619fbc09908309c94b45d22b6bcbe1f63248b3", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=f1149235142d434a76ceec242944c85c9749d3d4", "patch": "@@ -197,6 +197,9 @@\n (define_predicate \"s390_scond_operator\"\n   (match_code \"ltu, gtu, leu, geu\"))\n \n+(define_predicate \"s390_brx_operator\"\n+  (match_code \"le, gt\"))\n+\n ;; Return nonzero if OP is a valid comparison operator\n ;; for an ALC condition.\n "}, {"sha": "1431bfde701791e45da2274ceb36b05257b93ae6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f1149235142d434a76ceec242944c85c9749d3d4", "patch": "@@ -4957,6 +4957,7 @@ print_operand_address (FILE *file, rtx addr)\n \n     'C': print opcode suffix for branch condition.\n     'D': print opcode suffix for inverse branch condition.\n+    'E': print opcode suffix for branch on index instruction.\n     'J': print tls_load/tls_gdcall/tls_ldcall suffix\n     'G': print the size of the operand in bytes.\n     'O': print only the displacement of a memory reference.\n@@ -4989,6 +4990,15 @@ print_operand (FILE *file, rtx x, int code)\n       fprintf (file, s390_branch_condition_mnemonic (x, TRUE));\n       return;\n \n+    case 'E':\n+      if (GET_CODE (x) == LE)\n+\tfprintf (file, \"l\");\n+      else if (GET_CODE (x) == GT)\n+\tfprintf (file, \"h\");\n+      else\n+\tgcc_unreachable ();\n+      return;\n+\n     case 'J':\n       if (GET_CODE (x) == SYMBOL_REF)\n \t{"}, {"sha": "7898dc569a3aba2b376ae4a42f2abd7966ed0044", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1149235142d434a76ceec242944c85c9749d3d4/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f1149235142d434a76ceec242944c85c9749d3d4", "patch": "@@ -7561,6 +7561,180 @@\n ;;  This is all complicated by the fact that since this is a jump insn\n ;;  we must handle our own output reloads.\n \n+;; branch on index\n+\n+; This splitter will be matched by combine and has to add the 2 moves\n+; necessary to load the compare and the increment values into a\n+; register pair as needed by brxle.\n+\n+(define_insn_and_split \"*brx_stage1_<GPR:mode>\"\n+  [(set (pc)\n+        (if_then_else\n+\t (match_operator 6 \"s390_brx_operator\"\n+\t    [(plus:GPR (match_operand:GPR 1 \"register_operand\" \"\")\n+\t\t       (match_operand:GPR 2 \"general_operand\"  \"\"))\n+\t     (match_operand:GPR 3 \"register_operand\" \"\")])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:GPR 4 \"nonimmediate_operand\" \"\")\n+        (plus:GPR (match_dup 1) (match_dup 2)))\n+   (clobber (match_scratch:GPR 5 \"\"))]\n+  \"TARGET_CPU_ZARCH\"\n+  \"#\"\n+  \"!reload_completed && !reload_in_progress\"\n+  [(set (match_dup 7) (match_dup 2)) ; the increment\n+   (set (match_dup 8) (match_dup 3)) ; the comparison value\n+   (parallel [(set (pc)\n+\t\t   (if_then_else\n+\t\t    (match_op_dup 6\n+\t\t       [(plus:GPR (match_dup 1) (match_dup 7))\n+\t\t\t(match_dup 8)])\n+\t\t    (label_ref (match_dup 0))\n+\t\t    (pc)))\n+\t      (set (match_dup 4)\n+\t\t   (plus:GPR (match_dup 1) (match_dup 7)))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  {\n+    rtx dreg = gen_reg_rtx (word_mode == DImode ? TImode : DImode);\n+    operands[7] = gen_lowpart (<GPR:MODE>mode,\n+\t\t\t       gen_highpart (word_mode, dreg));\n+    operands[8] = gen_lowpart (<GPR:MODE>mode,\n+\t\t\t       gen_lowpart (word_mode, dreg));\n+  })\n+\n+; brxlg, brxhg\n+\n+(define_insn_and_split \"*brxg_64bit\"\n+  [(set (pc)\n+        (if_then_else\n+          (match_operator 5 \"s390_brx_operator\"\n+\t     [(plus:DI (match_operand:DI 1 \"register_operand\" \"d,d,d\")\n+\t\t       (subreg:DI (match_operand:TI 2 \"register_operand\" \"d,d,d\") 0))\n+              (subreg:DI (match_dup 2) 8)])\n+          (label_ref (match_operand 0 \"\" \"\"))\n+          (pc)))\n+   (set (match_operand:DI 3 \"nonimmediate_operand\" \"=1,?X,?X\")\n+        (plus:DI (match_dup 1)\n+\t\t (subreg:DI (match_dup 2) 0)))\n+   (clobber (match_scratch:DI 4 \"=X,&1,&?d\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_64BIT\"\n+{\n+  if (which_alternative != 0)\n+    return \"#\";\n+  else if (get_attr_length (insn) == 6)\n+    return \"brx%E5g\\t%1,%2,%l0\";\n+  else\n+    return \"agr\\t%1,%2\\;cgr\\t%1,%M2\\;jg%C5\\t%l0\";\n+}\n+  \"&& reload_completed\n+   && (!REG_P (operands[3])\n+       || !rtx_equal_p (operands[1], operands[3]))\"\n+  [(set (match_dup 4) (match_dup 1))\n+   (parallel [(set (match_dup 4) (plus:DI (match_dup 4) (subreg:DI (match_dup 2) 0)))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (set (reg:CCS CC_REGNUM) (compare:CCS (match_dup 4) (subreg:DI (match_dup 2) 8)))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (pc) (if_then_else (match_op_dup 5 [(reg:CCS CC_REGNUM) (const_int 0)])\n+\t\t\t   (label_ref (match_dup 0))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set_attr \"op_type\"  \"RIE\")\n+   (set_attr \"type\"  \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                      (const_int 6) (const_int 16)))])\n+\n+; brxle, brxh\n+\n+(define_insn_and_split \"*brx_64bit\"\n+  [(set (pc)\n+        (if_then_else\n+          (match_operator 5 \"s390_brx_operator\"\n+\t     [(plus:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n+\t\t       (subreg:SI (match_operand:TI 2 \"register_operand\" \"d,d,d\") 4))\n+              (subreg:SI (match_dup 2) 12)])\n+          (label_ref (match_operand 0 \"\" \"\"))\n+          (pc)))\n+   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=1,?X,?X\")\n+        (plus:SI (match_dup 1)\n+\t\t (subreg:SI (match_dup 2) 4)))\n+   (clobber (match_scratch:SI 4 \"=X,&1,&?d\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_64BIT\"\n+{\n+  if (which_alternative != 0)\n+    return \"#\";\n+  else if (get_attr_length (insn) == 6)\n+    return \"brx%C5\\t%1,%2,%l0\";\n+  else\n+    return \"ar\\t%1,%2\\;cr\\t%1,%M2\\;jg%C5\\t%l0\";\n+}\n+  \"&& reload_completed\n+   && (!REG_P (operands[3])\n+       || !rtx_equal_p (operands[1], operands[3]))\"\n+  [(set (match_dup 4) (match_dup 1))\n+   (parallel [(set (match_dup 4) (plus:SI (match_dup 4) (subreg:SI (match_dup 2) 4)))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (set (reg:CCS CC_REGNUM) (compare:CCS (match_dup 4) (subreg:SI (match_dup 2) 12)))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (pc) (if_then_else (match_op_dup 5 [(reg:CCS CC_REGNUM) (const_int 0)])\n+\t\t\t   (label_ref (match_dup 0))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set_attr \"op_type\"  \"RSI\")\n+   (set_attr \"type\"  \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                      (const_int 6) (const_int 14)))])\n+\n+; brxle, brxh\n+\n+(define_insn_and_split \"*brx_31bit\"\n+  [(set (pc)\n+        (if_then_else\n+          (match_operator 5 \"s390_brx_operator\"\n+\t    [(plus:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n+\t\t      (subreg:SI (match_operand:DI 2 \"register_operand\" \"d,d,d\") 0))\n+\t     (subreg:SI (match_dup 2) 4)])\n+          (label_ref (match_operand 0 \"\" \"\"))\n+          (pc)))\n+   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=1,?X,?X\")\n+        (plus:SI (match_dup 1)\n+\t\t (subreg:SI (match_dup 2) 0)))\n+   (clobber (match_scratch:SI 4 \"=X,&1,&?d\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+{\n+  if (which_alternative != 0)\n+    return \"#\";\n+  else if (get_attr_length (insn) == 6)\n+    return \"brx%C5\\t%1,%2,%l0\";\n+  else\n+    return \"ar\\t%1,%2\\;cr\\t%1,%M2\\;jg%C5\\t%l0\";\n+}\n+  \"&& reload_completed\n+   && (!REG_P (operands[3])\n+       || !rtx_equal_p (operands[1], operands[3]))\"\n+  [(set (match_dup 4) (match_dup 1))\n+   (parallel [(set (match_dup 4) (plus:SI (match_dup 4) (subreg:SI (match_dup 2) 0)))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (set (reg:CCS CC_REGNUM) (compare:CCS (match_dup 4) (subreg:SI (match_dup 2) 4)))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (pc) (if_then_else (match_op_dup 5 [(reg:CCS CC_REGNUM) (const_int 0)])\n+\t\t\t   (label_ref (match_dup 0))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set_attr \"op_type\"  \"RSI\")\n+   (set_attr \"type\"  \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                      (const_int 6) (const_int 14)))])\n+\n+\n+;; branch on count\n+\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n    (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown"}]}