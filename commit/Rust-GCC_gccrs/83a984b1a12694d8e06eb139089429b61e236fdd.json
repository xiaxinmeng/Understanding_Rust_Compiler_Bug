{"sha": "83a984b1a12694d8e06eb139089429b61e236fdd", "node_id": "C_kwDOANBUbNoAKDgzYTk4NGIxYTEyNjk0ZDhlMDZlYjEzOTA4OTQyOWI2MWUyMzZmZGQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-16T10:47:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-16T10:47:11Z"}, "message": "Merge #835\n\n835: Add name-resolution and HIR lowering pass for MatchExpr r=philberty a=philberty\n\nThis adds the name-resolution and HIR lowering pass for the match-expr\r\nthe type checking pass patch needs some work to be split up but these are\r\ntwo nice isolated commits which are easier to read.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "715954488f9c719a3db3d98d29e8828df325c750", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/715954488f9c719a3db3d98d29e8828df325c750"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83a984b1a12694d8e06eb139089429b61e236fdd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhuxkvCRBK7hj4Ov3rIwAAWpkIAK6Bu5W5/RHPFrZAFPdOFEPp\nHBt3Ym4q5RSG4ntKsntPwQfR7dtumjwVmL5FdKr1HtBtrFgwpjs5VmRGGVAsSfnA\n15Dbt9alsrcTcAnujSg9roa8OYiLY8MCxgmTijLSLDbnxTOGcxwOkRb62cucpAcP\n+oo3MBnMnCw5/45mYQBFa/Fk2yEHgQ9lnZSa9gqE3G2V5IazbrZiXxlPRpdhCaLd\nRcCz2PUzJ3rGUK+BrJh/rhIhIF3pzmc+Q2J/Ub3dtJDKJRgoe1tCdUFvpqWba1bR\nhzDWVyzhkLji3L7X1I58OCT+WbF1n7MFZqvTW+i4I9uiB4wM1I+hKASQRZEERL0=\n=p3c0\n-----END PGP SIGNATURE-----\n", "payload": "tree 715954488f9c719a3db3d98d29e8828df325c750\nparent 768f926074a27a7b1a2179613eeeb8291648b8a7\nparent a688913ac153a85aa803faad9d243e66fd12889d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639651631 +0000\ncommitter GitHub <noreply@github.com> 1639651631 +0000\n\nMerge #835\n\n835: Add name-resolution and HIR lowering pass for MatchExpr r=philberty a=philberty\n\nThis adds the name-resolution and HIR lowering pass for the match-expr\r\nthe type checking pass patch needs some work to be split up but these are\r\ntwo nice isolated commits which are easier to read.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a984b1a12694d8e06eb139089429b61e236fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a984b1a12694d8e06eb139089429b61e236fdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a984b1a12694d8e06eb139089429b61e236fdd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "768f926074a27a7b1a2179613eeeb8291648b8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768f926074a27a7b1a2179613eeeb8291648b8a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768f926074a27a7b1a2179613eeeb8291648b8a7"}, {"sha": "a688913ac153a85aa803faad9d243e66fd12889d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a688913ac153a85aa803faad9d243e66fd12889d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a688913ac153a85aa803faad9d243e66fd12889d"}], "stats": {"total": 522, "additions": 396, "deletions": 126}, "files": [{"sha": "1274578a71429fc644f7aae0439494b37e9ac8cd", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -76,7 +76,9 @@ GRS_OBJS = \\\n     rust/rust-hir-full-test.o \\\n     rust/rust-hir-map.o \\\n     rust/rust-ast-lower.o \\\n+    rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-resolve.o \\\n+    rust/rust-ast-resolve-pattern.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\"}, {"sha": "48dcc1067762e5b68ad7513367b4c16803bdd377", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -4337,23 +4337,26 @@ struct MatchCase\n private:\n   MatchArm arm;\n   std::unique_ptr<Expr> expr;\n+  NodeId node_id;\n \n   /* TODO: does whether trailing comma exists need to be stored? currently\n    * assuming it is only syntactical and has no effect on meaning. */\n \n public:\n   MatchCase (MatchArm arm, std::unique_ptr<Expr> expr)\n-    : arm (std::move (arm)), expr (std::move (expr))\n+    : arm (std::move (arm)), expr (std::move (expr)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   MatchCase (const MatchCase &other)\n-    : arm (other.arm), expr (other.expr->clone_expr ())\n+    : arm (other.arm), expr (other.expr->clone_expr ()), node_id (other.node_id)\n   {}\n \n   MatchCase &operator= (const MatchCase &other)\n   {\n     arm = other.arm;\n     expr = other.expr->clone_expr ();\n+    node_id = other.node_id;\n \n     return *this;\n   }\n@@ -4378,6 +4381,8 @@ struct MatchCase\n     rust_assert (!arm.is_error ());\n     return arm;\n   }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n #if 0"}, {"sha": "d46bf0e9fa47c6c0ad952199d259e1ba56391f93", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -456,7 +456,17 @@ class StructPatternField\n   std::vector<Attribute> outer_attrs;\n   Location locus;\n \n+protected:\n+  NodeId node_id;\n+\n public:\n+  enum ItemType\n+  {\n+    TUPLE_PAT,\n+    IDENT_PAT,\n+    IDENT\n+  };\n+\n   virtual ~StructPatternField () {}\n \n   // Unique pointer custom clone function\n@@ -474,14 +484,18 @@ class StructPatternField\n \n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n+  virtual ItemType get_item_type () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n \n   // TODO: seems kinda dodgy. Think of better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n protected:\n-  StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n-    : outer_attrs (std::move (outer_attribs)), locus (locus)\n+  StructPatternField (std::vector<Attribute> outer_attribs, Location locus,\n+\t\t      NodeId node_id)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus), node_id (node_id)\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -499,15 +513,17 @@ class StructPatternFieldTuplePat : public StructPatternField\n \t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n \t\t\t      std::vector<Attribute> outer_attribs,\n \t\t\t      Location locus)\n-    : StructPatternField (std::move (outer_attribs), locus), index (index),\n-      tuple_pattern (std::move (tuple_pattern))\n+    : StructPatternField (std::move (outer_attribs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      index (index), tuple_pattern (std::move (tuple_pattern))\n   {}\n \n   // Copy constructor requires clone\n   StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n     : StructPatternField (other), index (other.index)\n   {\n     // guard to prevent null dereference (only required if error state)\n+    node_id = other.get_node_id ();\n     if (other.tuple_pattern != nullptr)\n       tuple_pattern = other.tuple_pattern->clone_pattern ();\n   }\n@@ -519,6 +535,7 @@ class StructPatternFieldTuplePat : public StructPatternField\n     StructPatternField::operator= (other);\n     index = other.index;\n     // outer_attrs = other.outer_attrs;\n+    node_id = other.get_node_id ();\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.tuple_pattern != nullptr)\n@@ -552,6 +569,8 @@ class StructPatternFieldTuplePat : public StructPatternField\n     return tuple_pattern;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::TUPLE_PAT; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -572,7 +591,8 @@ class StructPatternFieldIdentPat : public StructPatternField\n \t\t\t      std::unique_ptr<Pattern> ident_pattern,\n \t\t\t      std::vector<Attribute> outer_attrs,\n \t\t\t      Location locus)\n-    : StructPatternField (std::move (outer_attrs), locus),\n+    : StructPatternField (std::move (outer_attrs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n       ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n   {}\n \n@@ -581,6 +601,7 @@ class StructPatternFieldIdentPat : public StructPatternField\n     : StructPatternField (other), ident (other.ident)\n   {\n     // guard to prevent null dereference (only required if error state)\n+    node_id = other.get_node_id ();\n     if (other.ident_pattern != nullptr)\n       ident_pattern = other.ident_pattern->clone_pattern ();\n   }\n@@ -592,6 +613,7 @@ class StructPatternFieldIdentPat : public StructPatternField\n     StructPatternField::operator= (other);\n     ident = other.ident;\n     // outer_attrs = other.outer_attrs;\n+    node_id = other.get_node_id ();\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.ident_pattern != nullptr)\n@@ -618,13 +640,17 @@ class StructPatternFieldIdentPat : public StructPatternField\n     return ident_pattern == nullptr;\n   }\n \n+  const Identifier &get_identifier () const { return ident; }\n+\n   // TODO: is this better? Or is a \"vis_pattern\" better?\n   std::unique_ptr<Pattern> &get_ident_pattern ()\n   {\n     rust_assert (ident_pattern != nullptr);\n     return ident_pattern;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::IDENT_PAT; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -644,8 +670,9 @@ class StructPatternFieldIdent : public StructPatternField\n public:\n   StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n \t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n-      has_mut (is_mut), ident (std::move (ident))\n+    : StructPatternField (std::move (outer_attrs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      has_ref (is_ref), has_mut (is_mut), ident (std::move (ident))\n   {}\n \n   std::string as_string () const override;\n@@ -656,6 +683,14 @@ class StructPatternFieldIdent : public StructPatternField\n   void mark_for_strip () override { ident = {}; }\n   bool is_marked_for_strip () const override { return ident.empty (); }\n \n+  const Identifier &get_identifier () const { return ident; }\n+\n+  ItemType get_item_type () const override final { return ItemType::IDENT; }\n+\n+  bool is_ref () const { return has_ref; }\n+\n+  bool is_mut () const { return has_mut; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -827,6 +862,12 @@ class StructPattern : public Pattern\n class TupleStructItems\n {\n public:\n+  enum ItemType\n+  {\n+    RANGE,\n+    NO_RANGE\n+  };\n+\n   virtual ~TupleStructItems () {}\n \n   // TODO: should this store location data?\n@@ -841,6 +882,8 @@ class TupleStructItems\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual ItemType get_item_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n@@ -890,6 +933,8 @@ class TupleStructItemsNoRange : public TupleStructItems\n     return patterns;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::NO_RANGE; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -966,6 +1011,8 @@ class TupleStructItemsRange : public TupleStructItems\n     return upper_patterns;\n   }\n \n+  ItemType get_item_type () const override final { return ItemType::RANGE; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "8cd4fb537d1479bf3b7ca4cf55ae225e9d2d0329", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-ast-lower-base.h\"\n #include \"rust-ast-lower-block.h\"\n #include \"rust-ast-lower-struct-field-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -667,6 +668,56 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n   }\n \n+  void visit (AST::MatchExpr &expr) override\n+  {\n+    HIR::Expr *branch_value\n+      = ASTLoweringExpr::translate (expr.get_scrutinee_expr ().get ());\n+\n+    std::vector<HIR::MatchCase> match_arms;\n+    for (auto &match_case : expr.get_match_cases ())\n+      {\n+\tHIR::Expr *kase_expr\n+\t  = ASTLoweringExpr::translate (match_case.get_expr ().get ());\n+\n+\tHIR::Expr *kase_guard_expr = nullptr;\n+\tif (match_case.get_arm ().has_match_arm_guard ())\n+\t  {\n+\t    kase_guard_expr = ASTLoweringExpr::translate (\n+\t      match_case.get_arm ().get_guard_expr ().get ());\n+\t  }\n+\n+\tstd::vector<std::unique_ptr<HIR::Pattern> > match_arm_patterns;\n+\tfor (auto &pattern : match_case.get_arm ().get_patterns ())\n+\t  {\n+\t    HIR::Pattern *ptrn = ASTLoweringPattern::translate (pattern.get ());\n+\t    match_arm_patterns.push_back (std::unique_ptr<HIR::Pattern> (ptrn));\n+\t  }\n+\n+\tHIR::MatchArm arm (std::move (match_arm_patterns),\n+\t\t\t   std::unique_ptr<HIR::Expr> (kase_guard_expr),\n+\t\t\t   match_case.get_arm ().get_outer_attrs ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tHIR::MatchCase kase (std::move (mapping), std::move (arm),\n+\t\t\t     std::unique_ptr<HIR::Expr> (kase_expr));\n+\tmatch_arms.push_back (std::move (kase));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::MatchExpr (mapping, std::unique_ptr<HIR::Expr> (branch_value),\n+\t\t\t    std::move (match_arms), expr.get_inner_attrs (),\n+\t\t\t    expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n private:\n   ASTLoweringExpr ()\n     : ASTLoweringBase (), translated (nullptr),"}, {"sha": "4ff61cd2a47e7df93249e9bb48f60de00175d928", "filename": "gcc/rust/hir/rust-ast-lower-pattern.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+void\n+ASTLoweringPattern::visit (AST::PathInExpression &pattern)\n+{\n+  translated = ASTLowerPathInExpression::translate (&pattern);\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::TupleStructPattern &pattern)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&pattern.get_path ());\n+\n+  TupleStructItems *lowered = nullptr;\n+  auto &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case AST::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case AST::TupleStructItems::NO_RANGE: {\n+\tAST::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<AST::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tstd::vector<std::unique_ptr<HIR::Pattern> > patterns;\n+\tfor (auto &inner_pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    HIR::Pattern *p\n+\t      = ASTLoweringPattern::translate (inner_pattern.get ());\n+\t    patterns.push_back (std::unique_ptr<HIR::Pattern> (p));\n+\t  }\n+\n+\tlowered = new HIR::TupleStructItemsNoRange (std::move (patterns));\n+      }\n+      break;\n+    }\n+\n+  translated = new HIR::TupleStructPattern (\n+    *path, std::unique_ptr<HIR::TupleStructItems> (lowered));\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::StructPattern &pattern)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&pattern.get_path ());\n+\n+  auto &raw_elems = pattern.get_struct_pattern_elems ();\n+  rust_assert (!raw_elems.has_etc ());\n+\n+  std::vector<std::unique_ptr<HIR::StructPatternField> > fields;\n+  for (auto &field : raw_elems.get_struct_pattern_fields ())\n+    {\n+      HIR::StructPatternField *f = nullptr;\n+      switch (field->get_item_type ())\n+\t{\n+\t  case AST::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT: {\n+\t    AST::StructPatternFieldIdent &ident\n+\t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    f = new HIR::StructPatternFieldIdent (\n+\t      ident.get_identifier (), ident.is_ref (),\n+\t      ident.is_mut () ? Mutability::Mut : Mutability::Imm,\n+\t      ident.get_outer_attrs (), ident.get_locus ());\n+\t  }\n+\t  break;\n+\t}\n+\n+      fields.push_back (std::unique_ptr<HIR::StructPatternField> (f));\n+    }\n+\n+  HIR::StructPatternElements elems (std::move (fields));\n+  translated = new HIR::StructPattern (*path, std::move (elems));\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "d8c03cef7442b3ef83da63fbf457fee1de75ce9e", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -20,7 +20,6 @@\n #define RUST_AST_LOWER_PATTERN\n \n #include \"rust-ast-lower-base.h\"\n-#include \"rust-diagnostics.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -34,12 +33,11 @@ class ASTLoweringPattern : public ASTLoweringBase\n   {\n     ASTLoweringPattern resolver;\n     pattern->accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n     return resolver.translated;\n   }\n \n-  virtual ~ASTLoweringPattern () override {}\n-\n-  void visit (AST::IdentifierPattern &pattern)\n+  void visit (AST::IdentifierPattern &pattern) override\n   {\n     std::unique_ptr<Pattern> to_bind;\n     translated\n@@ -50,6 +48,12 @@ class ASTLoweringPattern : public ASTLoweringBase\n \t\t\t\t    std::move (to_bind));\n   }\n \n+  void visit (AST::PathInExpression &pattern) override;\n+\n+  void visit (AST::StructPattern &pattern) override;\n+\n+  void visit (AST::TupleStructPattern &pattern) override;\n+\n private:\n   ASTLoweringPattern () : translated (nullptr) {}\n "}, {"sha": "0e5d97b5c5331052d97c2631a3a88463bac665c2", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 9, "deletions": 43, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -3681,57 +3681,29 @@ struct MatchArm\n   std::string as_string () const;\n };\n \n-/*\n-// Base \"match case\" for a match expression - abstract\n-class MatchCase\n-{\n-  MatchArm arm;\n-\n-protected:\n-  MatchCase (MatchArm arm) : arm (std::move (arm)) {}\n-\n-  // Should not require copy constructor or assignment operator overloading\n-\n-  // Clone function implementation as pure virtual method\n-  virtual MatchCase *clone_match_case_impl () const = 0;\n-\n-public:\n-  virtual ~MatchCase () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<MatchCase> clone_match_case () const\n-  {\n-    return std::unique_ptr<MatchCase> (clone_match_case_impl ());\n-  }\n-\n-  virtual std::string as_string () const;\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-};\n-*/\n-\n /* A \"match case\" - a correlated match arm and resulting expression. Not\n  * abstract. */\n struct MatchCase\n {\n private:\n+  Analysis::NodeMapping mappings;\n   MatchArm arm;\n   std::unique_ptr<Expr> expr;\n \n-  /* TODO: does whether trailing comma exists need to be stored? currently\n-   * assuming it is only syntactical and has no effect on meaning. */\n-\n public:\n-  MatchCase (MatchArm arm, std::unique_ptr<Expr> expr)\n-    : arm (std::move (arm)), expr (std::move (expr))\n+  MatchCase (Analysis::NodeMapping mappings, MatchArm arm,\n+\t     std::unique_ptr<Expr> expr)\n+    : mappings (mappings), arm (std::move (arm)), expr (std::move (expr))\n   {}\n \n   MatchCase (const MatchCase &other)\n-    : arm (other.arm), expr (other.expr->clone_expr ())\n+    : mappings (other.mappings), arm (other.arm),\n+      expr (other.expr->clone_expr ())\n   {}\n \n   MatchCase &operator= (const MatchCase &other)\n   {\n+    mappings = other.mappings;\n     arm = other.arm;\n     expr = other.expr->clone_expr ();\n \n@@ -3744,6 +3716,8 @@ struct MatchCase\n   ~MatchCase () = default;\n \n   std::string as_string () const;\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n };\n \n #if 0\n@@ -3841,23 +3815,15 @@ class MatchExpr : public ExprWithBlock\n {\n   std::unique_ptr<Expr> branch_value;\n   AST::AttrVec inner_attrs;\n-\n-  // bool has_match_arms;\n-  // MatchArms match_arms;\n-  // std::vector<std::unique_ptr<MatchCase> > match_arms; // inlined from\n-  // MatchArms\n   std::vector<MatchCase> match_arms;\n-\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  // Returns whether the match expression has any match arms.\n   bool has_match_arms () const { return !match_arms.empty (); }\n \n   MatchExpr (Analysis::NodeMapping mappings, std::unique_ptr<Expr> branch_value,\n-\t     // std::vector<std::unique_ptr<MatchCase> > match_arms,\n \t     std::vector<MatchCase> match_arms, AST::AttrVec inner_attrs,\n \t     AST::AttrVec outer_attrs, Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attrs)),"}, {"sha": "79f3789cb5ae296420dc1144c97bd3a8ed129499", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -199,7 +199,6 @@ class StructPatternField;\n class StructPatternFieldTuplePat;\n class StructPatternFieldIdentPat;\n class StructPatternFieldIdent;\n-struct StructPatternElements;\n class StructPattern;\n class TupleStructItems;\n class TupleStructItemsNoRange;"}, {"sha": "76b88255d9a5c2a1cbd2b5faa89aad5cd643c047", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -2575,16 +2575,6 @@ StructPatternElements::as_string () const\n \t}\n     }\n \n-  str += \"\\n  Etc: \";\n-  if (has_struct_pattern_etc)\n-    {\n-      str += \"true\";\n-    }\n-  else\n-    {\n-      str += \"false\";\n-    }\n-\n   return str;\n }\n "}, {"sha": "1373cc7a49119c766bb6d178fb3c292487f2f61a", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 3, "deletions": 59, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -377,26 +377,6 @@ class ReferencePattern : public Pattern\n   }\n };\n \n-// aka StructPatternEtCetera; potential element in struct pattern\n-struct StructPatternEtc\n-{\n-private:\n-  AST::AttrVec outer_attrs;\n-\n-  // should this store location data?\n-\n-public:\n-  StructPatternEtc (AST::AttrVec outer_attribs)\n-    : outer_attrs (std::move (outer_attribs))\n-  {}\n-\n-  // Creates an empty StructPatternEtc\n-  static StructPatternEtc create_empty ()\n-  {\n-    return StructPatternEtc (AST::AttrVec ());\n-  }\n-};\n-\n // Base class for a single field in a struct pattern - abstract\n class StructPatternField\n {\n@@ -561,45 +541,24 @@ class StructPatternFieldIdent : public StructPatternField\n struct StructPatternElements\n {\n private:\n-  // bool has_struct_pattern_fields;\n   std::vector<std::unique_ptr<StructPatternField> > fields;\n \n-  bool has_struct_pattern_etc;\n-  StructPatternEtc etc;\n-\n-  // must have at least one of the two and maybe both\n-\n-  // should this store location data?\n-\n public:\n   // Returns whether there are any struct pattern fields\n   bool has_struct_pattern_fields () const { return !fields.empty (); }\n \n   /* Returns whether the struct pattern elements is entirely empty (no fields,\n    * no etc). */\n-  bool is_empty () const\n-  {\n-    return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n-  }\n+  bool is_empty () const { return !has_struct_pattern_fields (); }\n \n   // Constructor for StructPatternElements with both (potentially)\n-  StructPatternElements (\n-    std::vector<std::unique_ptr<StructPatternField> > fields,\n-    StructPatternEtc etc)\n-    : fields (std::move (fields)), has_struct_pattern_etc (true),\n-      etc (std::move (etc))\n-  {}\n-\n-  // Constructor for StructPatternElements with no StructPatternEtc\n   StructPatternElements (\n     std::vector<std::unique_ptr<StructPatternField> > fields)\n-    : fields (std::move (fields)), has_struct_pattern_etc (false),\n-      etc (StructPatternEtc::create_empty ())\n+    : fields (std::move (fields))\n   {}\n \n   // Copy constructor with vector clone\n   StructPatternElements (StructPatternElements const &other)\n-    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n   {\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n@@ -609,9 +568,6 @@ struct StructPatternElements\n   // Overloaded assignment operator with vector clone\n   StructPatternElements &operator= (StructPatternElements const &other)\n   {\n-    etc = other.etc;\n-    has_struct_pattern_etc = other.has_struct_pattern_etc;\n-\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n       fields.push_back (e->clone_struct_pattern_field ());\n@@ -637,27 +593,15 @@ struct StructPatternElements\n class StructPattern : public Pattern\n {\n   PathInExpression path;\n-\n-  // bool has_struct_pattern_elements;\n   StructPatternElements elems;\n \n-  // TODO: should this store location data? Accessor uses path location data.\n-\n public:\n   std::string as_string () const override;\n \n-  // Constructs a struct pattern from specified StructPatternElements\n-  StructPattern (PathInExpression struct_path,\n-\t\t StructPatternElements elems\n-\t\t = StructPatternElements::create_empty ())\n+  StructPattern (PathInExpression struct_path, StructPatternElements elems)\n     : path (std::move (struct_path)), elems (std::move (elems))\n   {}\n \n-  /* TODO: constructor to construct via elements included in\n-   * StructPatternElements */\n-\n-  /* Returns whether struct pattern has any struct pattern elements (if not, it\n-   * is empty). */\n   bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n \n   Location get_locus () const { return path.get_locus (); }"}, {"sha": "5f496a664de8e9630750761df12a1738c83ccf5e", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-ast-resolve-struct-expr-field.h\"\n #include \"rust-ast-verify-assignee.h\"\n #include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -409,6 +410,41 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::MatchExpr &expr) override\n+  {\n+    ResolveExpr::go (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+    for (auto &match_case : expr.get_match_cases ())\n+      {\n+\t// each arm is in its own scope\n+\tNodeId scope_node_id = match_case.get_node_id ();\n+\tresolver->get_name_scope ().push (scope_node_id);\n+\tresolver->get_type_scope ().push (scope_node_id);\n+\tresolver->get_label_scope ().push (scope_node_id);\n+\tresolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+\tresolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\tresolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+\t// resolve\n+\tAST::MatchArm &arm = match_case.get_arm ();\n+\tif (arm.has_match_arm_guard ())\n+\t  ResolveExpr::go (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\n+\t// insert any possible new patterns\n+\tfor (auto &pattern : arm.get_patterns ())\n+\t  {\n+\t    PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n+\t  }\n+\n+\t// resolve the body\n+\tResolveExpr::go (match_case.get_expr ().get (), expr.get_node_id ());\n+\n+\t// done\n+\tresolver->get_name_scope ().pop ();\n+\tresolver->get_type_scope ().pop ();\n+\tresolver->get_label_scope ().pop ();\n+      }\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "c97a83f843ea43f57d1c5fe1b37513e3ad9e2899", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+PatternDeclaration::visit (AST::PathInExpression &pattern)\n+{\n+  ResolveExpr::go (&pattern, parent);\n+}\n+\n+void\n+PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n+{\n+  ResolveExpr::go (&pattern.get_path (), parent);\n+\n+  std::unique_ptr<AST::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case AST::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case AST::TupleStructItems::NO_RANGE: {\n+\tAST::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<AST::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tfor (auto &inner_pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    PatternDeclaration::go (inner_pattern.get (),\n+\t\t\t\t    pattern.get_node_id ());\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+PatternDeclaration::visit (AST::StructPattern &pattern)\n+{\n+  ResolveExpr::go (&pattern.get_path (), parent);\n+\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case AST::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT: {\n+\t    AST::StructPatternFieldIdent &ident\n+\t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    resolver->get_name_scope ().insert (\n+\t      CanonicalPath::new_seg (ident.get_node_id (),\n+\t\t\t\t      ident.get_identifier ()),\n+\t      ident.get_node_id (), pattern.get_locus ());\n+\t    resolver->insert_new_definition (\n+\t      ident.get_node_id (),\n+\t      Definition{ident.get_node_id (), pattern.get_node_id ()});\n+\t    resolver->mark_decl_mutability (ident.get_node_id (),\n+\t\t\t\t\t    ident.is_mut ());\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  // TODO\n+  rust_assert (!struct_pattern_elems.has_etc ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "57c73ba345634c212014d968051efbab346607d4", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a984b1a12694d8e06eb139089429b61e236fdd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=83a984b1a12694d8e06eb139089429b61e236fdd", "patch": "@@ -83,6 +83,13 @@ class PatternDeclaration : public ResolverBase\n \t\t\t\t    pattern.get_is_mut ());\n   }\n \n+  // cases in a match expression\n+  void visit (AST::PathInExpression &pattern) override;\n+\n+  void visit (AST::StructPattern &pattern) override;\n+\n+  void visit (AST::TupleStructPattern &pattern) override;\n+\n private:\n   PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n };"}]}