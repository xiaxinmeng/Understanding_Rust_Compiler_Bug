{"sha": "350f5d3bc401adc4b3115c39b98608209a46e611", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwZjVkM2JjNDAxYWRjNGIzMTE1YzM5Yjk4NjA4MjA5YTQ2ZTYxMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:19:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:19:43Z"}, "message": "[multiple changes]\n\n2014-07-16  Bob Duff  <duff@adacore.com>\n\n\t* gnat_ugn.texi: Document need for project file\n\tfor --incremental switch for gnat2xml.\n\n2014-07-16  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Fix example of non-packable components in packed\n\trecords section.\n\n2014-07-16  Robert Dewar  <dewar@adacore.com>\n\n\t* s-tpoben.adb, s-tasren.adb, s-interr.adb, s-interr-hwint.adb,\n\ts-shasto.adb, s-interr-vms.adb, s-interr-sigaction.adb: Avoid use of\n\tupper case in exception messages.\n\nFrom-SVN: r212650", "tree": {"sha": "0a1bed6b394ae9018d19cdece4f60372c56bd833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a1bed6b394ae9018d19cdece4f60372c56bd833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/350f5d3bc401adc4b3115c39b98608209a46e611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350f5d3bc401adc4b3115c39b98608209a46e611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350f5d3bc401adc4b3115c39b98608209a46e611", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350f5d3bc401adc4b3115c39b98608209a46e611/comments", "author": null, "committer": null, "parents": [{"sha": "ea70f3d0c1c8c839358cef35bf1ccafc94bca9c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea70f3d0c1c8c839358cef35bf1ccafc94bca9c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea70f3d0c1c8c839358cef35bf1ccafc94bca9c3"}], "stats": {"total": 595, "additions": 305, "deletions": 290}, "files": [{"sha": "06f92f39971a9cabafe2aaa2576e42334cd274cb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -1,3 +1,19 @@\n+2014-07-16  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_ugn.texi: Document need for project file\n+\tfor --incremental switch for gnat2xml.\n+\n+2014-07-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Fix example of non-packable components in packed\n+\trecords section.\n+\n+2014-07-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-tpoben.adb, s-tasren.adb, s-interr.adb, s-interr-hwint.adb,\n+\ts-shasto.adb, s-interr-vms.adb, s-interr-sigaction.adb: Avoid use of\n+\tupper case in exception messages.\n+\n 2014-07-16  Robert Dewar  <dewar@adacore.com>\n \n \t* snames.ads-tmpl, sem_attr.adb, exp_attr.adb: Same_Storage attribute"}, {"sha": "6afacd2a348d9e8c476e35629d9b31c7d55e17e9", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -15464,7 +15464,8 @@ taken by components.  We distinguish between @emph{packable} components and\n Components of the following types are considered packable:\n @itemize @bullet\n @item\n-All primitive types are packable.\n+Components of a primitive type are packable unless they are aliased\n+or of an atomic type.\n \n @item\n Small packed arrays, whose size does not exceed 64 bits, and where the\n@@ -15491,10 +15492,12 @@ For example, consider the record\n    type Rb2 is array (1 .. 65) of Boolean;\n    pragma Pack (rb2);\n \n+   type AF is new Float with Atomic;\n+\n    type x2 is record\n       l1 : Boolean;\n       l2 : Duration;\n-      l3 : Float;\n+      l3 : AF;\n       l4 : Boolean;\n       l5 : Rb1;\n       l6 : Rb2;\n@@ -15522,8 +15525,8 @@ Studying this example, we see that the packable fields @code{l1}\n and @code{l2} are\n of length equal to their sizes, and placed at specific bit boundaries (and\n not byte boundaries) to\n-eliminate padding.  But @code{l3} is of a non-packable float type, so\n-it is on the next appropriate alignment boundary.\n+eliminate padding.  But @code{l3} is of a non-packable float type (because\n+it is aliased), so it is on the next appropriate alignment boundary.\n \n The next two fields are fully packable, so @code{l4} and @code{l5} are\n minimally packed with no gaps.  However, type @code{Rb2} is a packed"}, {"sha": "6a62aa7028568d6d0118997ade4c45508bc1c138", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -15145,7 +15145,8 @@ Options:\n --incremental -- incremental processing on a per-file basis. Source files are\n       only processed if they have been modified, or if files they depend\n       on have been modified. This is similar to the way gnatmake/gprbuild\n-      only compiles files that need to be recompiled.\n+      only compiles files that need to be recompiled. You need to use a project\n+      file for this to work.\n \n --output-dir=@var{dir} -- generate one .xml file for each Ada source file, in\n       directory @file{dir}. (Default is to generate the XML to standard"}, {"sha": "5f5961cb912bf2fc0461e445d245881d4eae8cf5", "filename": "gcc/ada/s-interr-hwint.adb", "status": "modified", "additions": 94, "deletions": 98, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr-hwint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr-hwint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-hwint.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2013, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,14 +54,14 @@\n --  any time.\n \n --  Within this package, the lock L is used to protect the various status\n---  tables. If there is a Server_Task associated with a signal or interrupt, we\n---  use the per-task lock of the Server_Task instead so that we protect the\n+--  tables. If there is a Server_Task associated with a signal or interrupt,\n+--  we use the per-task lock of the Server_Task instead so that we protect the\n --  status between Interrupt_Manager and Server_Task. Protection among service\n --  requests are ensured via user calls to the Interrupt_Manager entries.\n \n --  This is reasonably generic version of this package, supporting vectored\n---  hardware interrupts using non-RTOS specific adapter routines which\n---  should easily implemented on any RTOS capable of supporting GNAT.\n+--  hardware interrupts using non-RTOS specific adapter routines which should\n+--  easily implemented on any RTOS capable of supporting GNAT.\n \n with Ada.Unchecked_Conversion;\n with Ada.Task_Identification;\n@@ -92,8 +92,8 @@ package body System.Interrupts is\n    -- Local Tasks --\n    -----------------\n \n-   --  WARNING: System.Tasking.Stages performs calls to this task with\n-   --  low-level constructs. Do not change this spec without synchronizing it.\n+   --  WARNING: System.Tasking.Stages performs calls to this task with low-\n+   --  level constructs. Do not change this spec without synchronizing it.\n \n    task Interrupt_Manager is\n       entry Detach_Interrupt_Entries (T : Task_Id);\n@@ -148,8 +148,8 @@ package body System.Interrupts is\n      (others => (null, Static => False));\n    pragma Volatile_Components (User_Handler);\n    --  Holds the protected procedure handler (if any) and its Static\n-   --  information  for each interrupt or signal. A handler is static\n-   --  iff it is specified through the pragma Attach_Handler.\n+   --  information for each interrupt or signal. A handler is static iff it\n+   --  is specified through the pragma Attach_Handler.\n \n    User_Entry : array (Interrupt_ID) of Entry_Assoc :=\n      (others => (T => Null_Task, E => Null_Task_Entry));\n@@ -181,18 +181,18 @@ package body System.Interrupts is\n    Semaphore_ID_Map : array\n      (Interrupt_ID range 0 .. System.OS_Interface.Max_HW_Interrupt)\n       of Binary_Semaphore_Id := (others => 0);\n-   --  Array of binary semaphores associated with vectored interrupts\n-   --  Note that the last bound should be Max_HW_Interrupt, but this will raise\n+   --  Array of binary semaphores associated with vectored interrupts. Note\n+   --  that the last bound should be Max_HW_Interrupt, but this will raise\n    --  Storage_Error if Num_HW_Interrupts is null, so use an extra 4 bytes\n    --  instead.\n \n    Interrupt_Access_Hold : Interrupt_Task_Access;\n    --  Variable for allocating an Interrupt_Server_Task\n \n    Handler_Installed : array (HW_Interrupt) of Boolean := (others => False);\n-   --  True if Notify_Interrupt was connected to the interrupt.  Handlers\n-   --  can be connected but disconnection is not possible on VxWorks.\n-   --  Therefore we ensure Notify_Installed is connected at most once.\n+   --  True if Notify_Interrupt was connected to the interrupt. Handlers can\n+   --  be connected but disconnection is not possible on VxWorks. Therefore\n+   --  we ensure Notify_Installed is connected at most once.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -230,12 +230,12 @@ package body System.Interrupts is\n    --------------------\n \n    --  Calling this procedure with New_Handler = null and Static = True\n-   --  means we want to detach the current handler regardless of the\n-   --  previous handler's binding status (i.e. do not care if it is a\n-   --  dynamic or static handler).\n+   --  means we want to detach the current handler regardless of the previous\n+   --  handler's binding status (i.e. do not care if it is a dynamic or static\n+   --  handler).\n \n-   --  This option is needed so that during the finalization of a PO, we\n-   --  can detach handlers attached through pragma Attach_Handler.\n+   --  This option is needed so that during the finalization of a PO, we can\n+   --  detach handlers attached through pragma Attach_Handler.\n \n    procedure Attach_Handler\n      (New_Handler : Parameterless_Handler;\n@@ -260,8 +260,7 @@ package body System.Interrupts is\n       Int_Ref : System.Address)\n    is\n       Interrupt : constant Interrupt_ID :=\n-        Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n-\n+                    Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       Interrupt_Manager.Bind_Interrupt_To_Entry (T, E, Interrupt);\n@@ -284,7 +283,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       else\n          return;\n       end if;\n@@ -300,9 +299,9 @@ package body System.Interrupts is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n \n-      --  ??? Since Parameterless_Handler is not Atomic, the\n-      --  current implementation is wrong. We need a new service in\n-      --  Interrupt_Manager to ensure atomicity.\n+      --  ??? Since Parameterless_Handler is not Atomic, the current\n+      --  implementation is wrong. We need a new service in Interrupt_Manager\n+      --  to ensure atomicity.\n \n       return User_Handler (Interrupt).H;\n    end Current_Handler;\n@@ -320,7 +319,8 @@ package body System.Interrupts is\n \n    procedure Detach_Handler\n      (Interrupt : Interrupt_ID;\n-      Static    : Boolean := False) is\n+      Static    : Boolean := False)\n+   is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       Interrupt_Manager.Detach_Handler (Interrupt, Static);\n@@ -340,12 +340,12 @@ package body System.Interrupts is\n    ----------------------\n \n    --  Calling this procedure with New_Handler = null and Static = True\n-   --  means we want to detach the current handler regardless of the\n-   --  previous handler's binding status (i.e. do not care if it is a\n-   --  dynamic or static handler).\n+   --  means we want to detach the current handler regardless of the previous\n+   --  handler's binding status (i.e. we do not care if it is a dynamic or\n+   --  static handler).\n \n-   --  This option is needed so that during the finalization of a PO, we\n-   --  can detach handlers attached through pragma Attach_Handler.\n+   --  This option is needed so that during the finalization of a PO, we can\n+   --  detach handlers attached through pragma Attach_Handler.\n \n    procedure Exchange_Handler\n      (Old_Handler : out Parameterless_Handler;\n@@ -394,7 +394,6 @@ package body System.Interrupts is\n \n    procedure Finalize_Interrupt_Servers is\n       HW_Interrupts : constant Boolean := HW_Interrupt'Last >= 0;\n-\n    begin\n       if HW_Interrupts then\n          for Int in HW_Interrupt loop\n@@ -405,8 +404,8 @@ package body System.Interrupts is\n             then\n                Interrupt_Manager.Attach_Handler\n                  (New_Handler => null,\n-                  Interrupt => Interrupt_ID (Int),\n-                  Static => True,\n+                  Interrupt   => Interrupt_ID (Int),\n+                  Static      => True,\n                   Restoration => True);\n             end if;\n          end loop;\n@@ -579,7 +578,6 @@ package body System.Interrupts is\n       Fat := To_Fat_Ptr (Handler);\n \n       Ptr := Registered_Handler_Head;\n-\n       while Ptr /= null loop\n          if Ptr.H = Fat.Handler_Addr then\n             return True;\n@@ -605,31 +603,28 @@ package body System.Interrupts is\n    -- Notify_Interrupt --\n    ----------------------\n \n-   --  Umbrella handler for vectored hardware interrupts (as opposed to\n-   --  signals and exceptions).  As opposed to the signal implementation,\n-   --  this handler is installed in the vector table when the first Ada\n-   --  handler is attached to the interrupt.  However because VxWorks don't\n-   --  support disconnecting handlers, this subprogram always test whether\n-   --  or not an Ada handler is effectively attached.\n+   --  Umbrella handler for vectored hardware interrupts (as opposed to signals\n+   --  and exceptions). As opposed to the signal implementation, this handler\n+   --  is installed in the vector table when the first Ada handler is attached\n+   --  to the interrupt. However because VxWorks don't support disconnecting\n+   --  handlers, this subprogram always test whether or not an Ada handler is\n+   --  effectively attached.\n \n-   --  Otherwise, the handler that existed prior to program startup is\n-   --  in the vector table.  This ensures that handlers installed by\n-   --  the BSP are active unless explicitly replaced in the program text.\n+   --  Otherwise, the handler that existed prior to program startup is in the\n+   --  vector table. This ensures that handlers installed by the BSP are active\n+   --  unless explicitly replaced in the program text.\n \n-   --  Each Interrupt_Server_Task has an associated binary semaphore\n-   --  on which it pends once it's been started.  This routine determines\n-   --  The appropriate semaphore and issues a semGive call, waking\n-   --  the server task.  When a handler is unbound,\n-   --  System.Interrupts.Unbind_Handler issues a Binary_Semaphore_Flush,\n-   --  and the server task deletes its semaphore and terminates.\n+   --  Each Interrupt_Server_Task has an associated binary semaphore on which\n+   --  it pends once it's been started. This routine determines The appropriate\n+   --  semaphore and issues a semGive call, waking the server task. When\n+   --  a handler is unbound, System.Interrupts.Unbind_Handler issues a\n+   --  Binary_Semaphore_Flush, and the server task deletes its semaphore\n+   --  and terminates.\n \n    procedure Notify_Interrupt (Param : System.Address) is\n       Interrupt : constant Interrupt_ID := Interrupt_ID (Param);\n-\n-      Id : constant Binary_Semaphore_Id := Semaphore_ID_Map (Interrupt);\n-\n-      Status : int;\n-\n+      Id        : constant Binary_Semaphore_Id := Semaphore_ID_Map (Interrupt);\n+      Status    : int;\n    begin\n       if Id /= 0 then\n          Status := Binary_Semaphore_Release (Id);\n@@ -645,7 +640,7 @@ package body System.Interrupts is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       return Storage_Elements.To_Address\n-        (Storage_Elements.Integer_Address (Interrupt));\n+               (Storage_Elements.Integer_Address (Interrupt));\n    end Reference;\n \n    --------------------------------\n@@ -656,15 +651,15 @@ package body System.Interrupts is\n       New_Node_Ptr : R_Link;\n \n    begin\n-      --  This routine registers a handler as usable for dynamic\n-      --  interrupt handler association. Routines attaching and detaching\n-      --  handlers dynamically should determine whether the handler is\n-      --  registered. Program_Error should be raised if it is not registered.\n+      --  This routine registers a handler as usable for dynamic interrupt\n+      --  handler association. Routines attaching and detaching handlers\n+      --  dynamically should determine whether the handler is registered.\n+      --  Program_Error should be raised if it is not registered.\n \n-      --  Pragma Interrupt_Handler can only appear in a library\n-      --  level PO definition and instantiation. Therefore, we do not need\n-      --  to implement an unregister operation. Nor do we need to\n-      --  protect the queue structure with a lock.\n+      --  Pragma Interrupt_Handler can only appear in a library level PO\n+      --  definition and instantiation. Therefore, we do not need to implement\n+      --  an unregister operation. Nor do we need to protect the queue\n+      --  structure with a lock.\n \n       pragma Assert (Handler_Addr /= System.Null_Address);\n \n@@ -674,7 +669,6 @@ package body System.Interrupts is\n       if Registered_Handler_Head = null then\n          Registered_Handler_Head := New_Node_Ptr;\n          Registered_Handler_Tail := New_Node_Ptr;\n-\n       else\n          Registered_Handler_Tail.Next := New_Node_Ptr;\n          Registered_Handler_Tail := New_Node_Ptr;\n@@ -717,7 +711,7 @@ package body System.Interrupts is\n \n    procedure Unimplemented (Feature : String) is\n    begin\n-      raise Program_Error with Feature & \" not implemented on VxWorks\";\n+      raise Program_Error with feature & \" not implemented on VxWorks\";\n    end Unimplemented;\n \n    -----------------------\n@@ -732,8 +726,8 @@ package body System.Interrupts is\n \n       procedure Bind_Handler (Interrupt : Interrupt_ID);\n       --  This procedure does not do anything if a signal is blocked.\n-      --  Otherwise, we have to interrupt Server_Task for status change through\n-      --  a wakeup signal.\n+      --  Otherwise, we have to interrupt Server_Task for status change\n+      --  through a wakeup signal.\n \n       procedure Unbind_Handler (Interrupt : Interrupt_ID);\n       --  This procedure does not do anything if a signal is blocked.\n@@ -767,8 +761,8 @@ package body System.Interrupts is\n \n       procedure Unbind_Handler (Interrupt : Interrupt_ID) is\n          Status : int;\n-      begin\n \n+      begin\n          --  Flush server task off semaphore, allowing it to terminate\n \n          Status := Binary_Semaphore_Flush (Semaphore_ID_Map (Interrupt));\n@@ -786,11 +780,12 @@ package body System.Interrupts is\n          Old_Handler : Parameterless_Handler;\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n-            --  If an interrupt entry is installed raise\n-            --  Program_Error. (propagate it to the caller).\n+\n+            --  If an interrupt entry is installed raise Program_Error\n+            --  (propagate it to the caller).\n \n             raise Program_Error with\n-              \"An interrupt entry is already installed\";\n+              \"an interrupt entry is already installed\";\n          end if;\n \n          --  Note : Static = True will pass the following check. This is the\n@@ -799,11 +794,11 @@ package body System.Interrupts is\n \n          if not Static and then User_Handler (Interrupt).Static then\n \n-            --  Trying to detach a static Interrupt Handler. raise\n+            --  Trying to detach a static Interrupt Handler, raise\n             --  Program_Error.\n \n             raise Program_Error with\n-              \"Trying to detach a static Interrupt Handler\";\n+              \"trying to detach a static Interrupt Handler\";\n          end if;\n \n          Old_Handler := User_Handler (Interrupt).H;\n@@ -833,32 +828,32 @@ package body System.Interrupts is\n          if User_Entry (Interrupt).T /= Null_Task then\n \n             --  If an interrupt entry is already installed, raise\n-            --  Program_Error. (propagate it to the caller).\n+            --  Program_Error (propagate it to the caller).\n \n-            raise Program_Error with \"An interrupt is already installed\";\n+            raise Program_Error with \"an interrupt is already installed\";\n          end if;\n \n-         --  Note : A null handler with Static = True will\n-         --  pass the following check. This is the case when we want to\n-         --  detach a handler regardless of the Static status\n-         --  of Current_Handler.\n-         --  We don't check anything if Restoration is True, since we\n-         --  may be detaching a static handler to restore a dynamic one.\n+         --  Note : A null handler with Static = True will pass the following\n+         --  check. This is the case when we want to detach a handler\n+         --  regardless of the Static status of Current_Handler.\n+\n+         --  We don't check anything if Restoration is True, since we may be\n+         --  detaching a static handler to restore a dynamic one.\n \n          if not Restoration and then not Static\n            and then (User_Handler (Interrupt).Static\n \n-            --  Trying to overwrite a static Interrupt Handler with a\n-            --  dynamic Handler\n+            --  Trying to overwrite a static Interrupt Handler with a dynamic\n+            --  Handler\n \n-            --  The new handler is not specified as an\n-            --  Interrupt Handler by a pragma.\n+            --  The new handler is not specified as an Interrupt Handler by a\n+            --  pragma.\n \n            or else not Is_Registered (New_Handler))\n          then\n             raise Program_Error with\n-               \"Trying to overwrite a static Interrupt Handler with a \" &\n-               \"dynamic Handler\";\n+               \"trying to overwrite a static interrupt handler with a \"\n+               & \"dynamic handler\";\n          end if;\n \n          --  Save the old handler\n@@ -879,8 +874,8 @@ package body System.Interrupts is\n             User_Handler (Interrupt).Static := Static;\n          end if;\n \n-         --  Invoke a corresponding Server_Task if not yet created.\n-         --  Place Task_Id info in Server_ID array.\n+         --  Invoke a corresponding Server_Task if not yet created. Place\n+         --  Task_Id info in Server_ID array.\n \n          if New_Handler /= null\n            and then\n@@ -909,11 +904,11 @@ package body System.Interrupts is\n          end if;\n       end Unprotected_Exchange_Handler;\n \n-      --  Start of processing for Interrupt_Manager\n+   --  Start of processing for Interrupt_Manager\n \n    begin\n-      --  By making this task independent of any master, when the process\n-      --  goes away, the Interrupt_Manager will terminate gracefully.\n+      --  By making this task independent of any master, when the process goes\n+      --  away, the Interrupt_Manager will terminate gracefully.\n \n       System.Tasking.Utilities.Make_Independent;\n \n@@ -948,15 +943,16 @@ package body System.Interrupts is\n \n             or\n                accept Detach_Handler\n-                  (Interrupt   : Interrupt_ID;\n-                   Static      : Boolean)\n+                  (Interrupt : Interrupt_ID;\n+                   Static    : Boolean)\n                do\n                   Unprotected_Detach_Handler (Interrupt, Static);\n                end Detach_Handler;\n+\n             or\n                accept Bind_Interrupt_To_Entry\n-                 (T       : Task_Id;\n-                  E       : Task_Entry_Index;\n+                 (T         : Task_Id;\n+                  E         : Task_Entry_Index;\n                   Interrupt : Interrupt_ID)\n                do\n                   --  If there is a binding already (either a procedure or an\n@@ -966,7 +962,7 @@ package body System.Interrupts is\n                     or else User_Entry (Interrupt).T /= Null_Task\n                   then\n                      raise Program_Error with\n-                       \"A binding for this interrupt is already present\";\n+                       \"a binding for this interrupt is already present\";\n                   end if;\n \n                   User_Entry (Interrupt) := Entry_Assoc'(T => T, E => E);"}, {"sha": "1daca4d1a3c43a3854f9c351c5156d60200ce1f9", "filename": "gcc/ada/s-interr-sigaction.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr-sigaction.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr-sigaction.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-sigaction.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -86,8 +86,8 @@ package body System.Interrupts is\n       Interrupt   : Interrupt_ID;\n       Static      : Boolean;\n       Restoration : Boolean);\n-   --  This internal procedure is needed to finalize protected objects\n-   --  that contain interrupt handlers.\n+   --  This internal procedure is needed to finalize protected objects that\n+   --  contain interrupt handlers.\n \n    procedure Signal_Handler (Sig : Interrupt_ID);\n    pragma Convention (C, Signal_Handler);\n@@ -157,7 +157,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Descriptors (Interrupt).T /= Null_Task;\n@@ -171,7 +171,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       else\n          return Descriptors (Interrupt).Kind /= Unknown;\n       end if;\n@@ -329,7 +329,8 @@ package body System.Interrupts is\n    procedure Attach_Handler\n      (New_Handler : Parameterless_Handler;\n       Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False) is\n+      Static      : Boolean := False)\n+   is\n    begin\n       Attach_Handler (New_Handler, Interrupt, Static, False);\n    end Attach_Handler;\n@@ -359,8 +360,8 @@ package body System.Interrupts is\n              or else not Is_Registered (New_Handler))\n       then\n          raise Program_Error with\n-           \"Trying to overwrite a static Interrupt Handler with a \" &\n-           \"dynamic Handler\";\n+           \"trying to overwrite a static interrupt handler with a \" &\n+           \"dynamic handler\";\n       end if;\n \n       if Handlers (Interrupt) = null then\n@@ -405,10 +406,10 @@ package body System.Interrupts is\n \n       if Descriptors (Interrupt).Kind = Task_Entry then\n \n-         --  In case we have an Interrupt Entry already installed.\n-         --  raise a program error. (propagate it to the caller).\n+         --  In case we have an Interrupt Entry already installed, raise a\n+         --  program error (propagate it to the caller).\n \n-         raise Program_Error with \"An interrupt is already installed\";\n+         raise Program_Error with \"an interrupt is already installed\";\n \n       else\n          Old_Handler := Current_Handler (Interrupt);\n@@ -430,12 +431,12 @@ package body System.Interrupts is\n       end if;\n \n       if Descriptors (Interrupt).Kind = Task_Entry then\n-         raise Program_Error with \"Trying to detach an Interrupt Entry\";\n+         raise Program_Error with \"trying to detach an interrupt entry\";\n       end if;\n \n       if not Static and then Descriptors (Interrupt).Static then\n          raise Program_Error with\n-           \"Trying to detach a static Interrupt Handler\";\n+           \"trying to detach a static interrupt handler\";\n       end if;\n \n       Descriptors (Interrupt) :=\n@@ -504,7 +505,6 @@ package body System.Interrupts is\n       Fat := To_Fat_Ptr (Handler);\n \n       while Ptr /= null loop\n-\n          if Ptr.H = Fat.Handler_Addr then\n             return True;\n          end if;\n@@ -536,7 +536,7 @@ package body System.Interrupts is\n \n       if Descriptors (Interrupt).Kind /= Unknown then\n          raise Program_Error with\n-           \"A binding for this interrupt is already present\";\n+           \"a binding for this interrupt is already present\";\n       end if;\n \n       if Handlers (Interrupt) = null then"}, {"sha": "7ef3b1cbbde43ea67cc6bc164fedf4b5db5f9fff", "filename": "gcc/ada/s-interr-vms.adb", "status": "modified", "additions": 71, "deletions": 74, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vms.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2013, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -104,8 +104,8 @@ package body System.Interrupts is\n          Static      : Boolean);\n \n       entry Detach_Handler\n-        (Interrupt   : Interrupt_ID;\n-         Static      : Boolean);\n+        (Interrupt : Interrupt_ID;\n+         Static    : Boolean);\n \n       entry Bind_Interrupt_To_Entry\n         (T         : Task_Id;\n@@ -172,10 +172,10 @@ package body System.Interrupts is\n \n    Last_Unblocker : constant array (Interrupt_ID'Range) of Task_Id :=\n      (others => Null_Task);\n---  ??? pragma Volatile_Components (Last_Unblocker);\n-   --  Holds the ID of the last Task which Unblocked this Interrupt.\n-   --  It contains Null_Task if no tasks have ever requested the\n-   --  Unblocking operation or the Interrupt is currently Blocked.\n+   --  ??? pragma Volatile_Components (Last_Unblocker);\n+   --  Holds the ID of the last Task which Unblocked this Interrupt. It\n+   --  contains Null_Task if no tasks have ever requested the Unblocking\n+   --  operation or the Interrupt is currently Blocked.\n \n    Server_ID : array (Interrupt_ID'Range) of Task_Id :=\n                  (others => Null_Task);\n@@ -185,8 +185,8 @@ package body System.Interrupts is\n    --  decide whether to create a new Server_Task.\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n-   --  Handlers. These definitions are used to register the handlers specified\n-   --  by the pragma Interrupt_Handler.\n+   --  Handlers. These definitions are used to register the handlers\n+   --  specified by the pragma Interrupt_Handler.\n \n    type Registered_Handler;\n    type R_Link is access all Registered_Handler;\n@@ -218,15 +218,15 @@ package body System.Interrupts is\n       New_Node_Ptr : R_Link;\n \n    begin\n-      --  This routine registers the Handler as usable for Dynamic\n-      --  Interrupt Handler. Routines attaching and detaching Handler\n-      --  dynamically should first consult if the Handler is registered.\n-      --  A Program Error should be raised if it is not registered.\n+      --  This routine registers the Handler as usable for Dynamic Interrupt\n+      --  Handler. Routines attaching and detaching Handler dynamically should\n+      --  first consult if the Handler is registered. A Program Error should be\n+      --  raised if it is not registered.\n \n-      --  The pragma Interrupt_Handler can only appear in the library\n-      --  level PO definition and instantiation. Therefore, we do not need\n-      --  to implement Unregistering operation. Neither we need to\n-      --  protect the queue structure using a Lock.\n+      --  The pragma Interrupt_Handler can only appear in the library level PO\n+      --  definition and instantiation. Therefore, we do not need to implement\n+      --  Unregistering operation. Neither we need to protect the queue\n+      --  structure using a Lock.\n \n       pragma Assert (Handler_Addr /= System.Null_Address);\n \n@@ -267,7 +267,6 @@ package body System.Interrupts is\n       Fat := To_Fat_Ptr (Handler);\n \n       Ptr := Registered_Handler_Head;\n-\n       while Ptr /= null loop\n          if Ptr.H = Fat.Handler_Addr then\n             return True;\n@@ -296,7 +295,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return User_Entry (Interrupt).T /= Null_Task;\n@@ -310,7 +309,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return User_Handler (Interrupt).H /= null;\n@@ -324,7 +323,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Blocked (Interrupt);\n@@ -338,7 +337,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Ignored (Interrupt);\n@@ -354,7 +353,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       --  ??? Since Parameterless_Handler is not Atomic, the current\n@@ -369,25 +368,25 @@ package body System.Interrupts is\n    --------------------\n \n    --  Calling this procedure with New_Handler = null and Static = True\n-   --  means we want to detach the current handler regardless of the\n-   --  previous handler's binding status (i.e. do not care if it is a\n-   --  dynamic or static handler).\n+   --  means we want to detach the current handler regardless of the previous\n+   --  handler's binding status (i.e. we do not care if it is a dynamic or\n+   --  static handler).\n \n    --  This option is needed so that during the finalization of a PO, we\n    --  can detach handlers attached through pragma Attach_Handler.\n \n    procedure Attach_Handler\n      (New_Handler : Parameterless_Handler;\n       Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False) is\n+      Static      : Boolean := False)\n+   is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Attach_Handler (New_Handler, Interrupt, Static);\n-\n    end Attach_Handler;\n \n    ----------------------\n@@ -411,12 +410,11 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Exchange_Handler\n         (Old_Handler, New_Handler, Interrupt, Static);\n-\n    end Exchange_Handler;\n \n    --------------------\n@@ -437,7 +435,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Detach_Handler (Interrupt, Static);\n@@ -451,11 +449,11 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Storage_Elements.To_Address\n-        (Storage_Elements.Integer_Address (Interrupt));\n+               (Storage_Elements.Integer_Address (Interrupt));\n    end Reference;\n \n    -----------------------------\n@@ -472,16 +470,15 @@ package body System.Interrupts is\n       Int_Ref : System.Address)\n    is\n       Interrupt : constant Interrupt_ID :=\n-        Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n+                    Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n \n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Bind_Interrupt_To_Entry (T, E, Interrupt);\n-\n    end Bind_Interrupt_To_Entry;\n \n    ------------------------------\n@@ -501,7 +498,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Block_Interrupt (Interrupt);\n@@ -515,7 +512,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Unblock_Interrupt (Interrupt);\n@@ -530,7 +527,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Last_Unblocker (Interrupt);\n@@ -544,7 +541,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Ignore_Interrupt (Interrupt);\n@@ -602,7 +599,7 @@ package body System.Interrupts is\n             --  In case we have an Interrupt Entry already installed.\n             --  raise a program error. (propagate it to the caller).\n \n-            raise Program_Error with \"An interrupt is already installed\";\n+            raise Program_Error with \"an interrupt is already installed\";\n          end if;\n \n          --  Note: A null handler with Static=True will pass the following\n@@ -618,14 +615,14 @@ package body System.Interrupts is\n \n            and then (User_Handler (Interrupt).Static\n \n-                        --  The new handler is not specified as an\n-                        --  Interrupt Handler by a pragma.\n+                       --  The new handler is not specified as an\n+                       --  Interrupt Handler by a pragma.\n \n-                        or else not Is_Registered (New_Handler))\n+                       or else not Is_Registered (New_Handler))\n          then\n             raise Program_Error with\n-              \"Trying to overwrite a static Interrupt Handler with a \" &\n-              \"dynamic Handler\";\n+              \"trying to overwrite a static interrupt handler with a \" &\n+              \"dynamic handler\";\n          end if;\n \n          --  The interrupt should no longer be ignored if it was ever ignored\n@@ -673,23 +670,23 @@ package body System.Interrupts is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n \n-            --  In case we have an Interrupt Entry installed.\n-            --  raise a program error. (propagate it to the caller).\n+            --  In case we have an Interrupt Entry installed, raise a program\n+            --  error, (propagate it to the caller).\n \n             raise Program_Error with\n-              \"An interrupt entry is already installed\";\n+              \"an interrupt entry is already installed\";\n          end if;\n \n          --  Note : Static = True will pass the following check. That is the\n          --  case when we want to detach a handler regardless of the static\n          --  status of the current_Handler.\n \n          if not Static and then User_Handler (Interrupt).Static then\n-            --  Tries to detach a static Interrupt Handler.\n-            --  raise a program error.\n+\n+            --  Tries to detach a static Interrupt Handler, raise program error\n \n             raise Program_Error with\n-              \"Trying to detach a static Interrupt Handler\";\n+              \"trying to detach a static interrupt handler\";\n          end if;\n \n          --  The interrupt should no longer be ignored if\n@@ -708,17 +705,17 @@ package body System.Interrupts is\n    --  Start of processing for Interrupt_Manager\n \n    begin\n-      --  By making this task independent of master, when the process\n-      --  goes away, the Interrupt_Manager will terminate gracefully.\n+      --  By making this task independent of master, when the process goes\n+      --  away, the Interrupt_Manager will terminate gracefully.\n \n       System.Tasking.Utilities.Make_Independent;\n \n-      --  Environment task gets its own interrupt mask, saves it,\n-      --  and then masks all interrupts except the Keep_Unmasked set.\n+      --  Environment task gets its own interrupt mask, saves it, and then\n+      --  masks all interrupts except the Keep_Unmasked set.\n \n-      --  During rendezvous, the Interrupt_Manager receives the old\n-      --  interrupt mask of the environment task, and sets its own\n-      --  interrupt mask to that value.\n+      --  During rendezvous, the Interrupt_Manager receives the old interrupt\n+      --  mask of the environment task, and sets its own interrupt mask to that\n+      --  value.\n \n       --  The environment task will call the entry of Interrupt_Manager some\n       --  during elaboration of the body of this package.\n@@ -728,18 +725,18 @@ package body System.Interrupts is\n          null;\n       end Initialize;\n \n-      --  Note: All tasks in RTS will have all the Reserve Interrupts\n-      --  being masked (except the Interrupt_Manager) and Keep_Unmasked\n-      --  unmasked when created.\n+      --  Note: All tasks in RTS will have all the Reserve Interrupts being\n+      --  masked (except the Interrupt_Manager) and Keep_Unmasked unmasked\n+      --  when created.\n \n-      --  Abort_Task_Interrupt is one of the Interrupt unmasked\n-      --  in all tasks. We mask the Interrupt in this particular task\n-      --  so that \"sigwait\" is possible to catch an explicitly sent\n-      --  Abort_Task_Interrupt from the Server_Tasks.\n+      --  Abort_Task_Interrupt is one of the Interrupt unmasked in all tasks.\n+      --  We mask the Interrupt in this particular task so that \"sigwait\" is\n+      --  possible to catch an explicitly sent Abort_Task_Interrupt from the\n+      --  Server_Tasks.\n \n-      --  This sigwaiting is needed so that we make sure a Server_Task is\n-      --  out of its own sigwait state. This extra synchronization is\n-      --  necessary to prevent following scenarios.\n+      --  This sigwaiting is needed so that we make sure a Server_Task is out\n+      --  of its own sigwait state. This extra synchronization is necessary to\n+      --  prevent following scenarios.\n \n       --   1) Interrupt_Manager sends an Abort_Task_Interrupt to the\n       --      Server_Task then changes its own interrupt mask (OS level).\n@@ -759,6 +756,7 @@ package body System.Interrupts is\n \n          declare\n             Old_Handler : Parameterless_Handler;\n+\n          begin\n             select\n \n@@ -801,7 +799,7 @@ package body System.Interrupts is\n                  or else User_Entry (Interrupt).T /= Null_Task\n                then\n                   raise Program_Error with\n-                    \"A binding for this interrupt is already present\";\n+                    \"a binding for this interrupt is already present\";\n                end if;\n \n                --  The interrupt should no longer be ignored if\n@@ -877,8 +875,8 @@ package body System.Interrupts is\n             end select;\n \n          exception\n-            --  If there is a program error we just want to propagate it\n-            --  to the caller and do not want to stop this task.\n+            --  If there is a program error we just want to propagate it to the\n+            --  caller and do not want to stop this task.\n \n             when Program_Error =>\n                null;\n@@ -1026,7 +1024,6 @@ package body System.Interrupts is\n      (Object : access Dynamic_Interrupt_Protection) return Boolean\n    is\n       pragma Warnings (Off, Object);\n-\n    begin\n       return True;\n    end Has_Interrupt_Or_Attach_Handler;"}, {"sha": "cbf8f03117f55620b0bfe2b257134138300edcc6", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 83, "deletions": 85, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2013, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,26 +31,26 @@\n \n --  Invariants:\n \n---  All user-handleable interrupts are masked at all times in all\n---  tasks/threads except possibly for the Interrupt_Manager task.\n+--  All user-handleable interrupts are masked at all times in all tasks/threads\n+--  except possibly for the Interrupt_Manager task.\n \n---  When a user task wants to have the effect of masking/unmasking an\n---  interrupt, it must call Block_Interrupt/Unblock_Interrupt, which\n---  will have the effect of unmasking/masking the interrupt in the\n---  Interrupt_Manager task.\n+--  When a user task wants to achieve masking/unmasking an interrupt, it must\n+--  call Block_Interrupt/Unblock_Interrupt, which will have the effect of\n+--  unmasking/masking the interrupt in the Interrupt_Manager task.\n \n --  Note : Direct calls to sigaction, sigprocmask, pthread_sigsetmask or any\n --  other low-level interface that changes the interrupt action or\n --  interrupt mask needs a careful thought.\n+\n --  One may achieve the effect of system calls first masking RTS blocked\n --  (by calling Block_Interrupt) for the interrupt under consideration.\n --  This will make all the tasks in RTS blocked for the Interrupt.\n \n---  Once we associate a Server_Task with an interrupt, the task never\n---  goes away, and we never remove the association.\n+--  Once we associate a Server_Task with an interrupt, the task never goes\n+--  away, and we never remove the association.\n \n---  There is no more than one interrupt per Server_Task and no more than\n---  one Server_Task per interrupt.\n+--  There is no more than one interrupt per Server_Task and no more than one\n+--  Server_Task per interrupt.\n \n with Ada.Task_Identification;\n \n@@ -236,7 +236,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Attach_Handler (New_Handler, Interrupt, Static);\n@@ -255,13 +255,13 @@ package body System.Interrupts is\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n-      Interrupt   : constant Interrupt_ID :=\n-                      Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n+      Interrupt : constant Interrupt_ID :=\n+                    Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n \n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Bind_Interrupt_To_Entry (T, E, Interrupt);\n@@ -275,7 +275,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Block_Interrupt (Interrupt);\n@@ -291,7 +291,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       --  ??? Since Parameterless_Handler is not Atomic, the current\n@@ -319,7 +319,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Detach_Handler (Interrupt, Static);\n@@ -355,7 +355,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Exchange_Handler\n@@ -385,8 +385,8 @@ package body System.Interrupts is\n       --  signal to the Server_Task\n \n       if not Interrupt_Manager'Terminated\n-        and then State (System.Interrupt_Management.Abort_Task_Interrupt)\n-                  /= Default\n+        and then\n+          State (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n       then\n          for N in reverse Object.Previous_Handlers'Range loop\n             Interrupt_Manager.Attach_Handler\n@@ -431,7 +431,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Ignore_Interrupt (Interrupt);\n@@ -488,7 +488,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Blocked (Interrupt);\n@@ -502,7 +502,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return User_Entry (Interrupt).T /= Null_Task;\n@@ -516,7 +516,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return User_Handler (Interrupt).H /= null;\n@@ -530,7 +530,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Ignored (Interrupt);\n@@ -561,7 +561,6 @@ package body System.Interrupts is\n       Fat := To_Fat_Ptr (Handler);\n \n       Ptr := Registered_Handler_Head;\n-\n       while Ptr /= null loop\n          if Ptr.H = Fat.Handler_Addr then\n             return True;\n@@ -590,11 +589,11 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Storage_Elements.To_Address\n-        (Storage_Elements.Integer_Address (Interrupt));\n+               (Storage_Elements.Integer_Address (Interrupt));\n    end Reference;\n \n    ---------------------------------\n@@ -638,7 +637,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Unblock_Interrupt (Interrupt);\n@@ -654,7 +653,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       return Last_Unblocker (Interrupt);\n@@ -668,7 +667,7 @@ package body System.Interrupts is\n    begin\n       if Is_Reserved (Interrupt) then\n          raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n       end if;\n \n       Interrupt_Manager.Unignore_Interrupt (Interrupt);\n@@ -743,13 +742,14 @@ package body System.Interrupts is\n \n       procedure Unbind_Handler (Interrupt : Interrupt_ID) is\n          Server : System.Tasking.Task_Id;\n+\n       begin\n          if not Blocked (Interrupt) then\n+\n             --  Currently, there is a Handler or an Entry attached and\n-            --  corresponding Server_Task is waiting on \"sigwait.\"\n-            --  We have to wake up the Server_Task and make it\n-            --  wait on condition variable by sending an\n-            --  Abort_Task_Interrupt\n+            --  corresponding Server_Task is waiting on \"sigwait.\" We have to\n+            --  wake up the Server_Task and make it wait on condition variable\n+            --  by sending an Abort_Task_Interrupt\n \n             Server := Server_ID (Interrupt);\n \n@@ -803,11 +803,11 @@ package body System.Interrupts is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n \n-            --  In case we have an Interrupt Entry installed.\n-            --  raise a program error. (propagate it to the caller).\n+            --  In case we have an Interrupt Entry installed, raise a program\n+            --  error, (propagate it to the caller).\n \n             raise Program_Error with\n-              \"An interrupt entry is already installed\";\n+              \"an interrupt entry is already installed\";\n          end if;\n \n          --  Note : Static = True will pass the following check. That is the\n@@ -820,7 +820,7 @@ package body System.Interrupts is\n             --  raise a program error.\n \n             raise Program_Error with\n-              \"Trying to detach a static Interrupt Handler\";\n+              \"trying to detach a static interrupt handler\";\n          end if;\n \n          --  The interrupt should no longer be ignored if\n@@ -854,35 +854,35 @@ package body System.Interrupts is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n \n-            --  In case we have an Interrupt Entry already installed.\n-            --  raise a program error. (propagate it to the caller).\n+            --  In case we have an Interrupt Entry already installed, raise a\n+            --  program error, (propagate it to the caller).\n \n             raise Program_Error with\n-              \"An interrupt is already installed\";\n+              \"an interrupt is already installed\";\n          end if;\n \n-         --  Note : A null handler with Static = True will pass the\n-         --  following check. That is the case when we want to Detach a\n-         --  handler regardless of the Static status of the current_Handler.\n+         --  Note : A null handler with Static = True will pass the following\n+         --  check. That is the case when we want to Detach a handler\n+         --  regardless of the Static status of the current_Handler.\n \n-         --  We don't check anything if Restoration is True, since we\n-         --  may be detaching a static handler to restore a dynamic one.\n+         --  We don't check anything if Restoration is True, since we may be\n+         --  detaching a static handler to restore a dynamic one.\n \n          if not Restoration and then not Static\n \n-            --  Tries to overwrite a static Interrupt Handler with a\n-            --  dynamic Handler\n+            --  Tries to overwrite a static Interrupt Handler with a dynamic\n+            --  Handler\n \n            and then (User_Handler (Interrupt).Static\n \n-                        --  The new handler is not specified as an\n-                        --  Interrupt Handler by a pragma.\n+                       --  The new handler is not specified as an\n+                       --  Interrupt Handler by a pragma.\n \n-                        or else not Is_Registered (New_Handler))\n+                       or else not Is_Registered (New_Handler))\n          then\n             raise Program_Error with\n-              \"Trying to overwrite a static Interrupt Handler with a \" &\n-              \"dynamic Handler\";\n+              \"trying to overwrite a static Interrupt Handler with a \" &\n+              \"dynamic handler\";\n          end if;\n \n          --  The interrupt should no longer be ignored if\n@@ -945,38 +945,37 @@ package body System.Interrupts is\n \n       System.Tasking.Utilities.Make_Independent;\n \n-      --  Environment task gets its own interrupt mask, saves it,\n-      --  and then masks all interrupts except the Keep_Unmasked set.\n+      --  Environment task gets its own interrupt mask, saves it, and then\n+      --  masks all interrupts except the Keep_Unmasked set.\n \n-      --  During rendezvous, the Interrupt_Manager receives the old\n-      --  interrupt mask of the environment task, and sets its own\n-      --  interrupt mask to that value.\n+      --  During rendezvous, the Interrupt_Manager receives the old interrupt\n+      --  mask of the environment task, and sets its own interrupt mask to that\n+      --  value.\n \n       --  The environment task will call the entry of Interrupt_Manager some\n       --  during elaboration of the body of this package.\n \n       accept Initialize (Mask : IMNG.Interrupt_Mask) do\n          declare\n             The_Mask : aliased IMNG.Interrupt_Mask;\n-\n          begin\n             IMOP.Copy_Interrupt_Mask (The_Mask, Mask);\n             IMOP.Set_Interrupt_Mask (The_Mask'Access);\n          end;\n       end Initialize;\n \n-      --  Note: All tasks in RTS will have all the Reserve Interrupts\n-      --  being masked (except the Interrupt_Manager) and Keep_Unmasked\n-      --  unmasked when created.\n+      --  Note: All tasks in RTS will have all the Reserve Interrupts being\n+      --  masked (except the Interrupt_Manager) and Keep_Unmasked unmasked\n+      --  when created.\n \n-      --  Abort_Task_Interrupt is one of the Interrupt unmasked\n-      --  in all tasks. We mask the Interrupt in this particular task\n-      --  so that \"sigwait\" is possible to catch an explicitly sent\n-      --  Abort_Task_Interrupt from the Server_Tasks.\n+      --  Abort_Task_Interrupt is one of the Interrupt unmasked in all tasks.\n+      --  We mask the Interrupt in this particular task so that \"sigwait\" is\n+      --  possible to catch an explicitly sent Abort_Task_Interrupt from the\n+      --  Server_Tasks.\n \n-      --  This sigwaiting is needed so that we make sure a Server_Task is\n-      --  out of its own sigwait state. This extra synchronization is\n-      --  necessary to prevent following scenarios.\n+      --  This sigwaiting is needed so that we make sure a Server_Task is out\n+      --  of its own sigwait state. This extra synchronization is necessary to\n+      --  prevent following scenarios.\n \n       --   1) Interrupt_Manager sends an Abort_Task_Interrupt to the\n       --      Server_Task then changes its own interrupt mask (OS level).\n@@ -1037,14 +1036,14 @@ package body System.Interrupts is\n                   E       : Task_Entry_Index;\n                   Interrupt : Interrupt_ID)\n                do\n-                  --  if there is a binding already (either a procedure or an\n+                  --  If there is a binding already (either a procedure or an\n                   --  entry), raise Program_Error (propagate it to the caller).\n \n                   if User_Handler (Interrupt).H /= null\n                     or else User_Entry (Interrupt).T /= Null_Task\n                   then\n                      raise Program_Error with\n-                       \"A binding for this interrupt is already present\";\n+                       \"a binding for this interrupt is already present\";\n                   end if;\n \n                   --  The interrupt should no longer be ignored if\n@@ -1118,10 +1117,10 @@ package body System.Interrupts is\n                   if User_Handler (Interrupt).H /= null\n                     or else User_Entry (Interrupt).T /= Null_Task\n                   then\n-                     --  This is the case where the Server_Task is waiting\n-                     --  on \"sigwait.\" Wake it up by sending an\n-                     --  Abort_Task_Interrupt so that the Server_Task\n-                     --  waits on Cond.\n+                     --  This is the case where the Server_Task is\n+                     --  waiting on \"sigwait.\" Wake it up by sending an\n+                     --  Abort_Task_Interrupt so that the Server_Task waits\n+                     --  on Cond.\n \n                      POP.Abort_Task (Server_ID (Interrupt));\n \n@@ -1158,8 +1157,8 @@ package body System.Interrupts is\n                   else\n                      --  The Server_Task must be waiting on the Cond variable\n                      --  since it was being blocked and an Interrupt Hander or\n-                     --  an Entry was there. Wake it up and let it change\n-                     --  it place of waiting according to its new state.\n+                     --  an Entry was there. Wake it up and let it change it\n+                     --  place of waiting according to its new state.\n \n                      POP.Wakeup (Server_ID (Interrupt),\n                        Interrupt_Server_Blocked_Interrupt_Sleep);\n@@ -1242,8 +1241,8 @@ package body System.Interrupts is\n       Tmp_Entry_Index : Task_Entry_Index;\n \n    begin\n-      --  By making this task independent of master, when the process\n-      --  goes away, the Server_Task will terminate gracefully.\n+      --  By making this task independent of master, when the process goes\n+      --  away, the Server_Task will terminate gracefully.\n \n       System.Tasking.Utilities.Make_Independent;\n \n@@ -1262,8 +1261,8 @@ package body System.Interrupts is\n \n       --  There are two Interrupt interrupts that this task catch through\n       --  \"sigwait.\" One is the Interrupt this task is designated to catch\n-      --  in order to execute user handler or entry. The other one is the\n-      --  Abort_Task_Interrupt. This interrupt is being sent from the\n+      --  in order to execute user handler or entry. The other one is\n+      --  the Abort_Task_Interrupt. This interrupt is being sent from the\n       --  Interrupt_Manager to inform status changes (e.g: become Blocked,\n       --  Handler or Entry is to be detached).\n \n@@ -1303,8 +1302,7 @@ package body System.Interrupts is\n \n          elsif Blocked (Interrupt) then\n \n-            --  Interrupt is blocked. Stay here, so we won't catch\n-            --  the Interrupt.\n+            --  Interrupt is blocked. Stay here, so we won't catch it\n \n             Self_ID.Common.State := Interrupt_Server_Blocked_Interrupt_Sleep;\n             POP.Sleep (Self_ID, Interrupt_Server_Blocked_Interrupt_Sleep);"}, {"sha": "6e0749c14cece4c73d6baf512ccdb853599feabc", "filename": "gcc/ada/s-shasto.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-shasto.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-shasto.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-shasto.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -541,7 +541,7 @@ package body System.Shared_Storage is\n \n                   when others =>\n                      raise Program_Error with\n-                        \"Cannot create shared variable file for \"\"\" & S & '\"';\n+                        \"cannot create shared variable file for \"\"\" & S & '\"';\n                end;\n          end;\n "}, {"sha": "34cf94c94aa56008040bc0a0bee19db9419d0733", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1992-2013, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -367,7 +367,8 @@ package body System.Tasking.Rendezvous is\n       if System.Tasking.Detect_Blocking\n         and then STPO.Self.Common.Protected_Action_Nesting > 0\n       then\n-         raise Program_Error with \"potentially blocking operation\";\n+         raise Program_Error with\n+           \"potentially blocking operation\";\n       end if;\n \n       Call_Synchronous\n@@ -1012,7 +1013,8 @@ package body System.Tasking.Rendezvous is\n                end if;\n \n                Initialization.Undefer_Abort (Self_Id);\n-               raise Program_Error with \"Entry call not a delay mode\";\n+               raise Program_Error with\n+                 \"entry call not a delay mode\";\n             end if;\n       end case;\n \n@@ -1316,7 +1318,8 @@ package body System.Tasking.Rendezvous is\n       if System.Tasking.Detect_Blocking\n         and then Self_Id.Common.Protected_Action_Nesting > 0\n       then\n-         raise Program_Error with \"potentially blocking operation\";\n+         raise Program_Error with\n+           \"potentially blocking operation\";\n       end if;\n \n       if Parameters.Runtime_Traces then\n@@ -1688,7 +1691,8 @@ package body System.Tasking.Rendezvous is\n       if System.Tasking.Detect_Blocking\n         and then Self_Id.Common.Protected_Action_Nesting > 0\n       then\n-         raise Program_Error with \"potentially blocking operation\";\n+         raise Program_Error with\n+           \"potentially blocking operation\";\n       end if;\n \n       Initialization.Defer_Abort (Self_Id);"}, {"sha": "9131f8c07b9a7b3d7661536756bee1d646d9b157", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f5d3bc401adc4b3115c39b98608209a46e611/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=350f5d3bc401adc4b3115c39b98608209a46e611", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                               B o d y                                    --\n --                                                                          --\n---          Copyright (C) 1998-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -103,7 +103,7 @@ package body System.Tasking.Protected_Objects.Entries is\n          STPO.Write_Lock (Object.L'Unrestricted_Access, Ceiling_Violation);\n \n          if Ceiling_Violation then\n-            raise Program_Error with \"Ceiling Violation\";\n+            raise Program_Error with \"ceiling violation\";\n          end if;\n \n          if Single_Lock then\n@@ -231,7 +231,7 @@ package body System.Tasking.Protected_Objects.Entries is\n       Lock_Entries_With_Status (Object, Ceiling_Violation);\n \n       if Ceiling_Violation then\n-         raise Program_Error with \"Ceiling Violation\";\n+         raise Program_Error with \"ceiling violation\";\n       end if;\n    end Lock_Entries;\n \n@@ -245,7 +245,7 @@ package body System.Tasking.Protected_Objects.Entries is\n    is\n    begin\n       if Object.Finalized then\n-         raise Program_Error with \"Protected Object is finalized\";\n+         raise Program_Error with \"protected object is finalized\";\n       end if;\n \n       --  If pragma Detect_Blocking is active then, as described in the ARM\n@@ -305,7 +305,7 @@ package body System.Tasking.Protected_Objects.Entries is\n \n    begin\n       if Object.Finalized then\n-         raise Program_Error with \"Protected Object is finalized\";\n+         raise Program_Error with \"protected object is finalized\";\n       end if;\n \n       --  If pragma Detect_Blocking is active then, as described in the ARM\n@@ -330,7 +330,7 @@ package body System.Tasking.Protected_Objects.Entries is\n       Read_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n-         raise Program_Error with \"Ceiling Violation\";\n+         raise Program_Error with \"ceiling violation\";\n       end if;\n \n       --  We are entering in a protected action, so that we increase the"}]}