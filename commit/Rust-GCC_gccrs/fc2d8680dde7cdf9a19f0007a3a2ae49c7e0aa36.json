{"sha": "fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyZDg2ODBkZGU3Y2RmOWExOWYwMDA3YTNhMmFlNDljN2UwYWEzNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-11T11:46:47Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-11T11:46:47Z"}, "message": "re PR fortran/30876 (Array valued recursive function rejected)\n\n2007-05-11 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/30876\n\t* trans-expr.c (gfc_conv_function_call): Reduce indirection for\n\tdirect assignments of recursive array valued functions.\n\t* primary.c (gfc_match_rvalue): Correct error for recursive\n\tfunction calls such that directly recursive calls of scalar\n\tfunction without an explicit result are disallowed.\n\n2007-05-11 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/30876\n\t* gfortran.dg/recursive_reference_1.f90: Put error at correct\n\tline.\n\t* gfortran.dg/recursive_reference_2.f90: New test.\n\nFrom-SVN: r124616", "tree": {"sha": "954562f2de3bc196c47fcd9c848c6f563adc96a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/954562f2de3bc196c47fcd9c848c6f563adc96a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/comments", "author": null, "committer": null, "parents": [{"sha": "847b053dd214c6e26a2025bf29422457cb50143d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/847b053dd214c6e26a2025bf29422457cb50143d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/847b053dd214c6e26a2025bf29422457cb50143d"}], "stats": {"total": 85, "additions": 73, "deletions": 12}, "files": [{"sha": "531e4da969fa6624c4719390f061847520006cca", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "patch": "@@ -1,3 +1,12 @@\n+2007-05-11 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/30876\n+\t* trans-expr.c (gfc_conv_function_call): Reduce indirection for\n+\tdirect assignments of recursive array valued functions.\n+\t* primary.c (gfc_match_rvalue): Correct error for recursive\n+\tfunction calls such that directly recursive calls of scalar\n+\tfunction without an explicit result are disallowed.\n+\n 2007-05-11 Paul Thomas <pault@gcc.gnu.org>\n \n \tPR fortran/30878"}, {"sha": "653df5d4162360d3e10583e830f120a002916d69", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "patch": "@@ -2062,17 +2062,16 @@ gfc_match_rvalue (gfc_expr **result)\n       gfc_gobble_whitespace ();\n       if (sym->attr.recursive\n \t  && gfc_peek_char () == '('\n-\t  && gfc_current_ns->proc_name == sym)\n+\t  && gfc_current_ns->proc_name == sym\n+\t  && !sym->attr.dimension)\n \t{\n-\t  if (!sym->attr.dimension)\n-\t    goto function0;\n-\n-\t  gfc_error (\"'%s' is array valued and directly recursive \"\n-\t\t     \"at %C , so the keyword RESULT must be specified \"\n-\t\t     \"in the FUNCTION statement\", sym->name);\n+\t  gfc_error (\"'%s' at %C is the name of a recursive function \"\n+\t\t     \"and so refers to the result variable. Use an \"\n+\t\t     \"explicit RESULT variable for direct recursion \"\n+\t\t     \"(12.5.2.1)\", sym->name);\n \t  return MATCH_ERROR;\n \t}\n-\t\n+\n       if (gfc_current_ns->proc_name == sym\n \t  || (gfc_current_ns->parent != NULL\n \t      && gfc_current_ns->parent->proc_name == sym))"}, {"sha": "239e41e1f8b88ab7690f3163ebaf394fa4ae29c6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "patch": "@@ -2317,7 +2317,17 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   if (byref)\n     {\n       if (se->direct_byref)\n-\tretargs = gfc_chainon_list (retargs, se->expr);\n+\t{\n+\t  /* Sometimes, too much indirection can be applied; eg. for\n+\t     function_result = array_valued_recursive_function.  */\n+\t  if (TREE_TYPE (TREE_TYPE (se->expr))\n+\t\t&& TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr)))\n+\t\t&& GFC_DESCRIPTOR_TYPE_P\n+\t\t\t(TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr)))))\n+\t    se->expr = build_fold_indirect_ref (se->expr);\n+\n+\t  retargs = gfc_chainon_list (retargs, se->expr);\n+\t}\n       else if (sym->result->attr.dimension)\n \t{\n \t  gcc_assert (se->loop && info);"}, {"sha": "3f606756982652cb93264ba6ab7a7b18fdfb881f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "patch": "@@ -1,3 +1,10 @@\n+2007-05-11 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/30876\n+\t* gfortran.dg/recursive_reference_1.f90: Put error at correct\n+\tline.\n+\t* gfortran.dg/recursive_reference_2.f90: New test.\n+\n 2007-05-11 Paul Thomas <pault@gcc.gnu.org>\n \n \tPR fortran/30878"}, {"sha": "3ca6bcb17117e700a06c449f08c06e9fb6ddfc4e", "filename": "gcc/testsuite/gfortran.dg/recursive_reference_1.f90", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_1.f90?ref=fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "patch": "@@ -1,7 +1,9 @@\n ! { dg-do compile }\n ! Tests the patch for PR27613, in which directly recursive, scalar\n ! functions were generating an \"unclassifiable statement\" error\n-! for the recursive statement(s).\n+! for the recursive statement(s).  This was subsequently determined\n+! to be wrong code and the error on 'bad_stuff' was removed.\n+! See 12.5.2.1 of the standard and PR30876.\n !\n ! Based on PR testcase by Nicolas Bock  <nicolasbock@gmail.com>\n !\n@@ -15,7 +17,7 @@ recursive function original_stuff(n)\n     integer :: n\n     original_stuff = 1\n     if(n < 5) then\n-      original_stuff = original_stuff + original_stuff (n+1)\n+      original_stuff = original_stuff + original_stuff (n+1) ! { dg-error \"name of a recursive function\" }\n     endif\n   end function original_stuff\n \n@@ -42,7 +44,7 @@ recursive function bad_stuff(n)\n     integer :: n(2)\n     bad_stuff = 1\n     if(maxval (n) < 5) then\n-      bad_stuff = bad_stuff + bad_stuff (n+1) ! { dg-error \"RESULT must be specified\" }\n+      bad_stuff = bad_stuff + bad_stuff (n+1)\n     endif\n   end function bad_stuff\n end program test"}, {"sha": "59df43cdf1aeb2d2287595a24f871f693a472c31", "filename": "gcc/testsuite/gfortran.dg/recursive_reference_2.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_reference_2.f90?ref=fc2d8680dde7cdf9a19f0007a3a2ae49c7e0aa36", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile }\n+! Tests the fix for PR30876 in which interface derived types were\n+! not always being associated.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+MODULE M1\n+CONTAINS\n+ FUNCTION correct_input(i)\n+   INTEGER :: i,correct_input(5), ans(5) = 0\n+   IF (i<1) correct_input=test(1)\n+   IF (i>5) correct_input=test(5)\n+ END FUNCTION correct_input\n+\n+ RECURSIVE FUNCTION test(i)\n+  INTEGER :: test(5),i,j\n+  IF (i<1 .OR. i>5) THEN\n+    test=correct_input(i)\n+  ELSE\n+    test=0\n+    test(1:6-i)=(/(j,j=i,5)/)\n+    test=test(3)\n+  ENDIF\n+ END FUNCTION\n+\n+END MODULE M1\n+\n+USE M1\n+integer :: ans(5)\n+IF (ANY(TEST(3).NE.(/5,5,5,5,5/))) CALL ABORT()\n+IF (ANY(TEST(6).NE.(/0,0,0,0,0/))) CALL ABORT()\n+END\n+! { dg-final { cleanup-modules \"m1\" } }\n+"}]}