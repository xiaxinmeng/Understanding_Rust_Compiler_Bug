{"sha": "eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2YzNkZjFhMGUzNGVkYzdhMjQzYzc4MWExYjg4NDJlM2ZjMjg1Yw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-04-29T14:20:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-04-29T14:20:41Z"}, "message": "expr.h (expand_shift): Rename to ...\n\n2011-04-29  Richard Guenther  <rguenther@suse.de>\n\n\t* expr.h (expand_shift): Rename to ...\n\t(expand_variable_shift): ... this.\n\t(expand_shift): Take a constant shift amount.\n\t* expmed.c (expand_shift): Rename to ...\n\t(expand_variable_shift): ... this.\n\t(expand_shift): New wrapper around expand_variable_shift.\n\t* expr.c (convert_move, emit_group_load_1, emit_group_store,\n\toptimize_bitfield_assignment_op, store_field, expand_expr_real_2,\n\texpand_expr_real_1, reduce_to_bit_field_precision): Adjust.\n\t* expmed.c (store_fixed_bit_field, extract_bit_field_1,\n\textract_fixed_bit_field, extract_split_bit_field, expand_mult_const,\n\texpand_mult, expand_widening_mult, expand_mult_highpart_adjust,\n\textract_high_half, expand_sdiv_pow2, expand_divmod, emit_cstore,\n\temit_store_flag_1, emit_store_flag): Likewise.\n\t* builtins.c (expand_builtin_signbit): Likewise.\n\t* calls.c (load_register_parameters): Likewise.\n\t* function.c (assign_parm_setup_block): Likewise.\n\t* lower-subreg.c (resolve_shift_zext): Likewise.\n\t* optabs.c (widen_bswap, expand_abs_nojump,\n\texpand_one_cmpl_abs_nojump, expand_float): Likewise.\n\t* spu/spu.c (spu_expand_extv): Likewise.\n\t* sparc/sparc.c (sparc32_initialize_trampoline): Likewise.\n\nFrom-SVN: r173157", "tree": {"sha": "f442091bcb3d922e2508780f3c19d3d70034b779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f442091bcb3d922e2508780f3c19d3d70034b779"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f616812d9cb9a651fb4636a3ec499c1b87995f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f616812d9cb9a651fb4636a3ec499c1b87995f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f616812d9cb9a651fb4636a3ec499c1b87995f3"}], "stats": {"total": 301, "additions": 137, "deletions": 164}, "files": [{"sha": "ce855a4b159f8b0747cbb4ab1ef63b365cc295a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -1,3 +1,28 @@\n+2011-04-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* expr.h (expand_shift): Rename to ...\n+\t(expand_variable_shift): ... this.\n+\t(expand_shift): Take a constant shift amount.\n+\t* expmed.c (expand_shift): Rename to ...\n+\t(expand_variable_shift): ... this.\n+\t(expand_shift): New wrapper around expand_variable_shift.\n+\t* expr.c (convert_move, emit_group_load_1, emit_group_store,\n+\toptimize_bitfield_assignment_op, store_field, expand_expr_real_2,\n+\texpand_expr_real_1, reduce_to_bit_field_precision): Adjust.\n+\t* expmed.c (store_fixed_bit_field, extract_bit_field_1,\n+\textract_fixed_bit_field, extract_split_bit_field, expand_mult_const,\n+\texpand_mult, expand_widening_mult, expand_mult_highpart_adjust,\n+\textract_high_half, expand_sdiv_pow2, expand_divmod, emit_cstore,\n+\temit_store_flag_1, emit_store_flag): Likewise.\n+\t* builtins.c (expand_builtin_signbit): Likewise.\n+\t* calls.c (load_register_parameters): Likewise.\n+\t* function.c (assign_parm_setup_block): Likewise.\n+\t* lower-subreg.c (resolve_shift_zext): Likewise.\n+\t* optabs.c (widen_bswap, expand_abs_nojump,\n+\texpand_one_cmpl_abs_nojump, expand_float): Likewise.\n+\t* spu/spu.c (spu_expand_extv): Likewise.\n+\t* sparc/sparc.c (sparc32_initialize_trampoline): Likewise.\n+\n 2011-04-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-inline.c (remap_eh_region_tree_nr): Use integer_type_node"}, {"sha": "668226daf7c9952b0d26174327871b8a02d4e74f", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -5423,8 +5423,7 @@ expand_builtin_signbit (tree exp, rtx target)\n       /* Perform a logical right shift to place the signbit in the least\n \t significant bit, then truncate the result to the desired mode\n \t and mask just this bit.  */\n-      temp = expand_shift (RSHIFT_EXPR, imode, temp,\n-\t\t\t   build_int_cst (NULL_TREE, bitpos), NULL_RTX, 1);\n+      temp = expand_shift (RSHIFT_EXPR, imode, temp, bitpos, NULL_RTX, 1);\n       temp = gen_lowpart (rmode, temp);\n       temp = expand_binop (rmode, and_optab, temp, const1_rtx,\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);"}, {"sha": "98f3009905a55a7d3ab1c27390939d91922de446", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -1668,9 +1668,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t     call only uses SIZE bytes at the msb end, but it doesn't\n \t\t     seem worth generating rtl to say that.  */\n \t\t  reg = gen_rtx_REG (word_mode, REGNO (reg));\n-\t\t  x = expand_shift (LSHIFT_EXPR, word_mode, reg,\n-\t\t\t\t    build_int_cst (NULL_TREE, shift),\n-\t\t\t\t    reg, 1);\n+\t\t  x = expand_shift (LSHIFT_EXPR, word_mode, reg, shift, reg, 1);\n \t\t  if (x != reg)\n \t\t    emit_move_insn (reg, x);\n \t\t}\n@@ -1714,9 +1712,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t\t\t\t\t\t: LSHIFT_EXPR;\n \n \t\t  emit_move_insn (x, tem);\n-\t\t  x = expand_shift (dir, word_mode, x,\n-\t\t\t\t    build_int_cst (NULL_TREE, shift),\n-\t\t\t\t    ri, 1);\n+\t\t  x = expand_shift (dir, word_mode, x, shift, ri, 1);\n \t\t  if (x != ri)\n \t\t    emit_move_insn (ri, x);\n \t\t}"}, {"sha": "79802fb285d02bca51602d87705f784910caba31", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -7836,16 +7836,14 @@ sparc32_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n   emit_move_insn\n     (adjust_address (m_tramp, SImode, 0),\n      expand_binop (SImode, ior_optab,\n-\t\t   expand_shift (RSHIFT_EXPR, SImode, fnaddr,\n-\t\t\t\t size_int (10), 0, 1),\n+\t\t   expand_shift (RSHIFT_EXPR, SImode, fnaddr, 10, 0, 1),\n \t\t   GEN_INT (trunc_int_for_mode (0x03000000, SImode)),\n \t\t   NULL_RTX, 1, OPTAB_DIRECT));\n \n   emit_move_insn\n     (adjust_address (m_tramp, SImode, 4),\n      expand_binop (SImode, ior_optab,\n-\t\t   expand_shift (RSHIFT_EXPR, SImode, cxt,\n-\t\t\t\t size_int (10), 0, 1),\n+\t\t   expand_shift (RSHIFT_EXPR, SImode, cxt, 10, 0, 1),\n \t\t   GEN_INT (trunc_int_for_mode (0x05000000, SImode)),\n \t\t   NULL_RTX, 1, OPTAB_DIRECT));\n "}, {"sha": "f93c14c39d52e887e7207d0a66f44c1251df1d90", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -748,10 +748,7 @@ spu_expand_extv (rtx ops[], int unsignedp)\n     emit_insn (gen_rotlti3 (s0, s0, GEN_INT (start)));\n \n   if (128 - width)\n-    {\n-      tree c = build_int_cst (NULL_TREE, 128 - width);\n-      s0 = expand_shift (RSHIFT_EXPR, TImode, s0, c, s0, unsignedp);\n-    }\n+    s0 = expand_shift (RSHIFT_EXPR, TImode, s0, 128 - width, s0, unsignedp);\n \n   emit_move_insn (dst, s0);\n }"}, {"sha": "7e9204d444a6e603faaf8d078103a31eb714dcd7", "filename": "gcc/expmed.c", "status": "modified", "additions": 77, "deletions": 110, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -916,7 +916,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \t\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       if (bitpos > 0)\n \tvalue = expand_shift (LSHIFT_EXPR, mode, value,\n-\t\t\t      build_int_cst (NULL_TREE, bitpos), NULL_RTX, 1);\n+\t\t\t      bitpos, NULL_RTX, 1);\n     }\n \n   /* Now clear the chosen bits in OP0,\n@@ -1396,13 +1396,9 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       /* Signed bit field: sign-extend with two arithmetic shifts.  */\n       target = expand_shift (LSHIFT_EXPR, mode, target,\n-\t\t\t     build_int_cst (NULL_TREE,\n-\t\t\t\t\t    GET_MODE_BITSIZE (mode) - bitsize),\n-\t\t\t     NULL_RTX, 0);\n+\t\t\t     GET_MODE_BITSIZE (mode) - bitsize, NULL_RTX, 0);\n       return expand_shift (RSHIFT_EXPR, mode, target,\n-\t\t\t   build_int_cst (NULL_TREE,\n-\t\t\t\t\t  GET_MODE_BITSIZE (mode) - bitsize),\n-\t\t\t   NULL_RTX, 0);\n+\t\t\t   GET_MODE_BITSIZE (mode) - bitsize, NULL_RTX, 0);\n     }\n \n   /* From here on we know the desired field is smaller than a word.  */\n@@ -1752,12 +1748,11 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t{\n \t  /* If the field does not already start at the lsb,\n \t     shift it so it does.  */\n-\t  tree amount = build_int_cst (NULL_TREE, bitpos);\n \t  /* Maybe propagate the target for the shift.  */\n \t  /* But not if we will return it--could confuse integrate.c.  */\n \t  rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n \t  if (tmode != mode) subtarget = 0;\n-\t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, amount, subtarget, 1);\n+\t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, bitpos, subtarget, 1);\n \t}\n       /* Convert the value to the desired mode.  */\n       if (mode != tmode)\n@@ -1791,18 +1786,14 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \n   if (GET_MODE_BITSIZE (mode) != (bitsize + bitpos))\n     {\n-      tree amount\n-\t= build_int_cst (NULL_TREE,\n-\t\t\t GET_MODE_BITSIZE (mode) - (bitsize + bitpos));\n+      int amount = GET_MODE_BITSIZE (mode) - (bitsize + bitpos);\n       /* Maybe propagate the target for the shift.  */\n       rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n       op0 = expand_shift (LSHIFT_EXPR, mode, op0, amount, subtarget, 1);\n     }\n \n   return expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t       build_int_cst (NULL_TREE,\n-\t\t\t\t      GET_MODE_BITSIZE (mode) - bitsize),\n-\t\t       target, 0);\n+\t\t       GET_MODE_BITSIZE (mode) - bitsize, target, 0);\n }\n \f\n /* Return a constant integer (CONST_INT or CONST_DOUBLE) mask value\n@@ -1913,15 +1904,13 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  if (bitsize != bitsdone)\n \t    part = expand_shift (LSHIFT_EXPR, word_mode, part,\n-\t\t\t\t build_int_cst (NULL_TREE, bitsize - bitsdone),\n-\t\t\t\t 0, 1);\n+\t\t\t\t bitsize - bitsdone, 0, 1);\n \t}\n       else\n \t{\n \t  if (bitsdone != thissize)\n \t    part = expand_shift (LSHIFT_EXPR, word_mode, part,\n-\t\t\t\t build_int_cst (NULL_TREE,\n-\t\t\t\t\t\tbitsdone - thissize), 0, 1);\n+\t\t\t\t bitsdone - thissize, 0, 1);\n \t}\n \n       if (first)\n@@ -1940,11 +1929,9 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     return result;\n   /* Signed bit field: sign-extend with two arithmetic shifts.  */\n   result = expand_shift (LSHIFT_EXPR, word_mode, result,\n-\t\t\t build_int_cst (NULL_TREE, BITS_PER_WORD - bitsize),\n-\t\t\t NULL_RTX, 0);\n+\t\t\t BITS_PER_WORD - bitsize, NULL_RTX, 0);\n   return expand_shift (RSHIFT_EXPR, word_mode, result,\n-\t\t       build_int_cst (NULL_TREE, BITS_PER_WORD - bitsize),\n-\t\t       NULL_RTX, 0);\n+\t\t       BITS_PER_WORD - bitsize, NULL_RTX, 0);\n }\n \f\n /* Try to read the low bits of SRC as an rvalue of mode MODE, preserving\n@@ -2053,8 +2040,8 @@ expand_dec (rtx target, rtx dec)\n    Return the rtx for where the value is.  */\n \n rtx\n-expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n-\t      tree amount, rtx target, int unsignedp)\n+expand_variable_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n+\t\t       tree amount, rtx target, int unsignedp)\n {\n   rtx op1, temp = 0;\n   int left = (code == LSHIFT_EXPR || code == LROTATE_EXPR);\n@@ -2167,10 +2154,11 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \n \t      shifted = force_reg (mode, shifted);\n \n-\t      temp = expand_shift (left ? LSHIFT_EXPR : RSHIFT_EXPR,\n-\t\t\t\t   mode, shifted, new_amount, 0, 1);\n-\t      temp1 = expand_shift (left ? RSHIFT_EXPR : LSHIFT_EXPR,\n-\t\t\t\t    mode, shifted, other_amount, subtarget, 1);\n+\t      temp = expand_variable_shift (left ? LSHIFT_EXPR : RSHIFT_EXPR,\n+\t\t\t\t\t    mode, shifted, new_amount, 0, 1);\n+\t      temp1 = expand_variable_shift (left ? RSHIFT_EXPR : LSHIFT_EXPR,\n+\t\t\t\t\t     mode, shifted, other_amount,\n+\t\t\t\t\t     subtarget, 1);\n \t      return expand_binop (mode, ior_optab, temp, temp1, target,\n \t\t\t\t   unsignedp, methods);\n \t    }\n@@ -2213,6 +2201,24 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   gcc_assert (temp);\n   return temp;\n }\n+\n+/* Output a shift instruction for expression code CODE,\n+   with SHIFTED being the rtx for the value to shift,\n+   and AMOUNT the amount to shift by.\n+   Store the result in the rtx TARGET, if that is convenient.\n+   If UNSIGNEDP is nonzero, do a logical shift; otherwise, arithmetic.\n+   Return the rtx for where the value is.  */\n+\n+rtx\n+expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n+\t      int amount, rtx target, int unsignedp)\n+{\n+  /* ???  With re-writing expand_shift we could avoid going through a\n+     tree for the shift amount and directly do GEN_INT (amount).  */\n+  return expand_variable_shift (code, mode, shifted,\n+\t\t\t\tbuild_int_cst (integer_type_node, amount),\n+\t\t\t\ttarget, unsignedp);\n+}\n \f\n /* Indicates the type of fixup needed after a constant multiplication.\n    BASIC_VARIANT means no fixup is needed, NEGATE_VARIANT means that\n@@ -2838,64 +2844,51 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n       switch (alg->op[opno])\n \t{\n \tcase alg_shift:\n-\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t      build_int_cst (NULL_TREE, log),\n-\t\t\t      NULL_RTX, 0);\n+\t  tem = expand_shift (LSHIFT_EXPR, mode, accum, log, NULL_RTX, 0);\n \t  /* REG_EQUAL note will be attached to the following insn.  */\n \t  emit_move_insn (accum, tem);\n \t  val_so_far <<= log;\n \t  break;\n \n \tcase alg_add_t_m2:\n-\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t      build_int_cst (NULL_TREE, log),\n-\t\t\t      NULL_RTX, 0);\n+\t  tem = expand_shift (LSHIFT_EXPR, mode, op0, log, NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far += (HOST_WIDE_INT) 1 << log;\n \t  break;\n \n \tcase alg_sub_t_m2:\n-\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t      build_int_cst (NULL_TREE, log),\n-\t\t\t      NULL_RTX, 0);\n+\t  tem = expand_shift (LSHIFT_EXPR, mode, op0, log, NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far -= (HOST_WIDE_INT) 1 << log;\n \t  break;\n \n \tcase alg_add_t2_m:\n \t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\tbuild_int_cst (NULL_TREE, log),\n-\t\t\t\tshift_subtarget,\n-\t\t\t\t0);\n+\t\t\t\tlog, shift_subtarget, 0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, op0),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far = (val_so_far << log) + 1;\n \t  break;\n \n \tcase alg_sub_t2_m:\n \t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\tbuild_int_cst (NULL_TREE, log),\n-\t\t\t\tshift_subtarget, 0);\n+\t\t\t\tlog, shift_subtarget, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, accum, op0),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far = (val_so_far << log) - 1;\n \t  break;\n \n \tcase alg_add_factor:\n-\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t      build_int_cst (NULL_TREE, log),\n-\t\t\t      NULL_RTX, 0);\n+\t  tem = expand_shift (LSHIFT_EXPR, mode, accum, log, NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far += val_so_far << log;\n \t  break;\n \n \tcase alg_sub_factor:\n-\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t      build_int_cst (NULL_TREE, log),\n-\t\t\t      NULL_RTX, 0);\n+\t  tem = expand_shift (LSHIFT_EXPR, mode, accum, log, NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, tem, accum),\n \t\t\t\t (add_target\n \t\t\t\t  ? add_target : (optimize ? 0 : tem)));\n@@ -3028,8 +3021,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t      int shift = floor_log2 (CONST_DOUBLE_HIGH (op1))\n \t\t\t  + HOST_BITS_PER_WIDE_INT;\n \t      return expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t   build_int_cst (NULL_TREE, shift),\n-\t\t\t\t   target, unsignedp);\n+\t\t\t\t   shift, target, unsignedp);\n \t    }\n \t}\n \n@@ -3042,8 +3034,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t  /* Special case powers of two.  */\n \t  if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n \t    return expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t build_int_cst (NULL_TREE, floor_log2 (coeff)),\n-\t\t\t\t target, unsignedp);\n+\t\t\t\t floor_log2 (coeff), target, unsignedp);\n \n \t  /* Exclude cost of op0 from max_cost to match the cost\n \t     calculation of the synth_mult.  */\n@@ -3123,8 +3114,7 @@ expand_widening_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t{\n \t  op0 = convert_to_mode (mode, op0, this_optab == umul_widen_optab);\n \t  return expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t       build_int_cst (NULL_TREE, floor_log2 (coeff)),\n-\t\t\t       target, unsignedp);\n+\t\t\t       floor_log2 (coeff), target, unsignedp);\n \t}\n \n       /* Exclude cost of op0 from max_cost to match the cost\n@@ -3297,16 +3287,14 @@ expand_mult_highpart_adjust (enum machine_mode mode, rtx adj_operand, rtx op0,\n   enum rtx_code adj_code = unsignedp ? PLUS : MINUS;\n \n   tem = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t      build_int_cst (NULL_TREE, GET_MODE_BITSIZE (mode) - 1),\n-\t\t      NULL_RTX, 0);\n+\t\t      GET_MODE_BITSIZE (mode) - 1, NULL_RTX, 0);\n   tem = expand_and (mode, tem, op1, NULL_RTX);\n   adj_operand\n     = force_operand (gen_rtx_fmt_ee (adj_code, mode, adj_operand, tem),\n \t\t     adj_operand);\n \n   tem = expand_shift (RSHIFT_EXPR, mode, op1,\n-\t\t      build_int_cst (NULL_TREE, GET_MODE_BITSIZE (mode) - 1),\n-\t\t      NULL_RTX, 0);\n+\t\t      GET_MODE_BITSIZE (mode) - 1, NULL_RTX, 0);\n   tem = expand_and (mode, tem, op0, NULL_RTX);\n   target = force_operand (gen_rtx_fmt_ee (adj_code, mode, adj_operand, tem),\n \t\t\t  target);\n@@ -3328,7 +3316,7 @@ extract_high_half (enum machine_mode mode, rtx op)\n \n   wider_mode = GET_MODE_WIDER_MODE (mode);\n   op = expand_shift (RSHIFT_EXPR, wider_mode, op,\n-\t\t     build_int_cst (NULL_TREE, GET_MODE_BITSIZE (mode)), 0, 1);\n+\t\t     GET_MODE_BITSIZE (mode), 0, 1);\n   return convert_modes (mode, wider_mode, op, 0);\n }\n \n@@ -3615,11 +3603,9 @@ static rtx\n expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n {\n   rtx temp, label;\n-  tree shift;\n   int logd;\n \n   logd = floor_log2 (d);\n-  shift = build_int_cst (NULL_TREE, logd);\n \n   if (d == 2\n       && BRANCH_COST (optimize_insn_for_speed_p (),\n@@ -3629,7 +3615,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n       temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, 1);\n       temp = expand_binop (mode, add_optab, temp, op0, NULL_RTX,\n \t\t\t   0, OPTAB_LIB_WIDEN);\n-      return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n+      return expand_shift (RSHIFT_EXPR, mode, temp, logd, NULL_RTX, 0);\n     }\n \n #ifdef HAVE_conditional_move\n@@ -3657,7 +3643,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t  rtx seq = get_insns ();\n \t  end_sequence ();\n \t  emit_insn (seq);\n-\t  return expand_shift (RSHIFT_EXPR, mode, temp2, shift, NULL_RTX, 0);\n+\t  return expand_shift (RSHIFT_EXPR, mode, temp2, logd, NULL_RTX, 0);\n \t}\n       end_sequence ();\n     }\n@@ -3675,19 +3661,18 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n       else\n \ttemp = expand_shift (RSHIFT_EXPR, mode, temp,\n-\t\t\t     build_int_cst (NULL_TREE, ushift),\n-\t\t\t     NULL_RTX, 1);\n+\t\t\t     ushift, NULL_RTX, 1);\n       temp = expand_binop (mode, add_optab, temp, op0, NULL_RTX,\n \t\t\t   0, OPTAB_LIB_WIDEN);\n-      return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n+      return expand_shift (RSHIFT_EXPR, mode, temp, logd, NULL_RTX, 0);\n     }\n \n   label = gen_label_rtx ();\n   temp = copy_to_mode_reg (mode, op0);\n   do_cmp_and_jump (temp, const0_rtx, GE, mode, label);\n   expand_inc (temp, GEN_INT (d - 1));\n   emit_label (label);\n-  return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n+  return expand_shift (RSHIFT_EXPR, mode, temp, logd, NULL_RTX, 0);\n }\n \f\n /* Emit the code to divide OP0 by OP1, putting the result in TARGET\n@@ -3951,9 +3936,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n \t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t     build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t    pre_shift),\n-\t\t\t\t\t     tquotient, 1);\n+\t\t\t\t\t     pre_shift, tquotient, 1);\n \t\t  }\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT)\n \t\t  {\n@@ -4005,15 +3988,14 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    t2 = force_operand (gen_rtx_MINUS (compute_mode,\n \t\t\t\t\t\t\t       op0, t1),\n \t\t\t\t\t\tNULL_RTX);\n-\t\t\t    t3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t       integer_one_node, NULL_RTX, 1);\n+\t\t\t    t3 = expand_shift (RSHIFT_EXPR, compute_mode,\n+\t\t\t\t\t       t2, 1, NULL_RTX, 1);\n \t\t\t    t4 = force_operand (gen_rtx_PLUS (compute_mode,\n \t\t\t\t\t\t\t      t1, t3),\n \t\t\t\t\t\tNULL_RTX);\n \t\t\t    quotient = expand_shift\n \t\t\t      (RSHIFT_EXPR, compute_mode, t4,\n-\t\t\t       build_int_cst (NULL_TREE, post_shift - 1),\n-\t\t\t       tquotient, 1);\n+\t\t\t       post_shift - 1, tquotient, 1);\n \t\t\t  }\n \t\t\telse\n \t\t\t  {\n@@ -4025,8 +4007,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n \t\t\t    t1 = expand_shift\n \t\t\t      (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t       build_int_cst (NULL_TREE, pre_shift),\n-\t\t\t       NULL_RTX, 1);\n+\t\t\t       pre_shift, NULL_RTX, 1);\n \t\t\t    extra_cost\n \t\t\t      = (shift_cost[speed][compute_mode][pre_shift]\n \t\t\t\t + shift_cost[speed][compute_mode][post_shift]);\n@@ -4037,8 +4018,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      goto fail1;\n \t\t\t    quotient = expand_shift\n \t\t\t      (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t       build_int_cst (NULL_TREE, post_shift),\n-\t\t\t       tquotient, 1);\n+\t\t\t       post_shift, tquotient, 1);\n \t\t\t  }\n \t\t      }\n \t\t  }\n@@ -4170,12 +4150,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  goto fail1;\n \t\t\tt2 = expand_shift\n \t\t\t  (RSHIFT_EXPR, compute_mode, t1,\n-\t\t\t   build_int_cst (NULL_TREE, post_shift),\n-\t\t\t   NULL_RTX, 0);\n+\t\t\t   post_shift, NULL_RTX, 0);\n \t\t\tt3 = expand_shift\n \t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t   build_int_cst (NULL_TREE, size - 1),\n-\t\t\t   NULL_RTX, 0);\n+\t\t\t   size - 1, NULL_RTX, 0);\n \t\t\tif (d < 0)\n \t\t\t  quotient\n \t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n@@ -4210,12 +4188,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t    NULL_RTX);\n \t\t\tt3 = expand_shift\n \t\t\t  (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t   build_int_cst (NULL_TREE, post_shift),\n-\t\t\t   NULL_RTX, 0);\n+\t\t\t   post_shift, NULL_RTX, 0);\n \t\t\tt4 = expand_shift\n \t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t   build_int_cst (NULL_TREE, size - 1),\n-\t\t\t   NULL_RTX, 0);\n+\t\t\t   size - 1, NULL_RTX, 0);\n \t\t\tif (d < 0)\n \t\t\t  quotient\n \t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n@@ -4272,8 +4248,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t      }\n \t\t    quotient = expand_shift\n \t\t      (RSHIFT_EXPR, compute_mode, op0,\n-\t\t       build_int_cst (NULL_TREE, pre_shift),\n-\t\t       tquotient, 0);\n+\t\t       pre_shift, tquotient, 0);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -4288,8 +4263,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t      {\n \t\t\tt1 = expand_shift\n \t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t   build_int_cst (NULL_TREE, size - 1),\n-\t\t\t   NULL_RTX, 0);\n+\t\t\t   size - 1, NULL_RTX, 0);\n \t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n@@ -4302,8 +4276,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  {\n \t\t\t    t4 = expand_shift\n \t\t\t      (RSHIFT_EXPR, compute_mode, t3,\n-\t\t\t       build_int_cst (NULL_TREE, post_shift),\n-\t\t\t       NULL_RTX, 1);\n+\t\t\t       post_shift, NULL_RTX, 1);\n \t\t\t    quotient = expand_binop (compute_mode, xor_optab,\n \t\t\t\t\t\t     t4, t1, tquotient, 0,\n \t\t\t\t\t\t     OPTAB_WIDEN);\n@@ -4320,8 +4293,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t   0, OPTAB_WIDEN);\n \t\tnsign = expand_shift\n \t\t  (RSHIFT_EXPR, compute_mode, t2,\n-\t\t   build_int_cst (NULL_TREE, size - 1),\n-\t\t   NULL_RTX, 0);\n+\t\t   size - 1, NULL_RTX, 0);\n \t\tt3 = force_operand (gen_rtx_MINUS (compute_mode, t1, nsign),\n \t\t\t\t    NULL_RTX);\n \t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, compute_mode, t3, op1,\n@@ -4435,8 +4407,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\trtx t1, t2, t3;\n \t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n \t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t   build_int_cst (NULL_TREE, floor_log2 (d)),\n-\t\t\t\t   tquotient, 1);\n+\t\t\t\t   floor_log2 (d), tquotient, 1);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n \t\t\t\t   GEN_INT (d - 1),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -4533,8 +4504,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\trtx t1, t2, t3;\n \t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n \t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t   build_int_cst (NULL_TREE, floor_log2 (d)),\n-\t\t\t\t   tquotient, 0);\n+\t\t\t\t   floor_log2 (d), tquotient, 0);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n \t\t\t\t   GEN_INT (d - 1),\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -4655,8 +4625,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    pre_shift = floor_log2 (d & -d);\n \t    ml = invert_mod2n (d >> pre_shift, size);\n \t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t       build_int_cst (NULL_TREE, pre_shift),\n-\t\t\t       NULL_RTX, unsignedp);\n+\t\t\t       pre_shift, NULL_RTX, unsignedp);\n \t    quotient = expand_mult (compute_mode, t1,\n \t\t\t\t    gen_int_mode (ml, compute_mode),\n \t\t\t\t    NULL_RTX, 1);\n@@ -4689,8 +4658,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t  remainder, 1, OPTAB_LIB_WIDEN);\n \t      }\n \t    tem = plus_constant (op1, -1);\n-\t    tem = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n-\t\t\t\tinteger_one_node, NULL_RTX, 1);\n+\t    tem = expand_shift (RSHIFT_EXPR, compute_mode, tem, 1, NULL_RTX, 1);\n \t    do_cmp_and_jump (remainder, tem, LEU, compute_mode, label);\n \t    expand_inc (quotient, const1_rtx);\n \t    expand_dec (remainder, op1);\n@@ -4715,13 +4683,12 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    abs_rem = expand_abs (compute_mode, remainder, NULL_RTX, 1, 0);\n \t    abs_op1 = expand_abs (compute_mode, op1, NULL_RTX, 1, 0);\n \t    tem = expand_shift (LSHIFT_EXPR, compute_mode, abs_rem,\n-\t\t\t\tinteger_one_node, NULL_RTX, 1);\n+\t\t\t\t1, NULL_RTX, 1);\n \t    do_cmp_and_jump (tem, abs_op1, LTU, compute_mode, label);\n \t    tem = expand_binop (compute_mode, xor_optab, op0, op1,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \t    mask = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n-\t\t\t\t build_int_cst (NULL_TREE, size - 1),\n-\t\t\t\t NULL_RTX, 0);\n+\t\t\t\t size - 1, NULL_RTX, 0);\n \t    tem = expand_binop (compute_mode, xor_optab, mask, const1_rtx,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \t    tem = expand_binop (compute_mode, sub_optab, tem, mask,\n@@ -5090,7 +5057,7 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n \t   && (STORE_FLAG_VALUE\n \t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (result_mode) - 1))))\n     op0 = expand_shift (RSHIFT_EXPR, result_mode, op0,\n-\t\t\tsize_int (GET_MODE_BITSIZE (result_mode) - 1), subtarget,\n+\t\t\tGET_MODE_BITSIZE (result_mode) - 1, subtarget,\n \t\t\tnormalizep == 1);\n   else\n     {\n@@ -5270,7 +5237,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t   a logical shift from the sign bit to the low-order bit; for\n \t   a -1/0 value, we do an arithmetic shift.  */\n \top0 = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t    size_int (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t    GET_MODE_BITSIZE (mode) - 1,\n \t\t\t    subtarget, normalizep != -1);\n \n       if (mode != target_mode)\n@@ -5555,7 +5522,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \tsubtarget = 0;\n \n       tem = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t  size_int (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t  GET_MODE_BITSIZE (mode) - 1,\n \t\t\t  subtarget, 0);\n       tem = expand_binop (mode, sub_optab, tem, op0, subtarget, 0,\n \t\t\t  OPTAB_WIDEN);\n@@ -5621,7 +5588,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   if (tem && normalizep)\n     tem = expand_shift (RSHIFT_EXPR, mode, tem,\n-\t\t\tsize_int (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\tGET_MODE_BITSIZE (mode) - 1,\n \t\t\tsubtarget, normalizep == 1);\n \n   if (tem)"}, {"sha": "5574b2d1ab98792363fedf3ba9d3c19a17581219", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -616,7 +616,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t{\n \t  enum machine_mode intermediate;\n \t  rtx tmp;\n-\t  tree shift_amount;\n+\t  int shift_amount;\n \n \t  /* Search for a mode to convert via.  */\n \t  for (intermediate = from_mode; intermediate != VOIDmode;\n@@ -636,9 +636,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n \t  /* No suitable intermediate mode.\n \t     Generate what we need with\tshifts.  */\n-\t  shift_amount = build_int_cst (NULL_TREE,\n-\t\t\t\t\tGET_MODE_BITSIZE (to_mode)\n-\t\t\t\t\t- GET_MODE_BITSIZE (from_mode));\n+\t  shift_amount = (GET_MODE_BITSIZE (to_mode)\n+\t\t\t  - GET_MODE_BITSIZE (from_mode));\n \t  from = gen_lowpart (to_mode, force_reg (from_mode, from));\n \t  tmp = expand_shift (LSHIFT_EXPR, to_mode, from, shift_amount,\n \t\t\t      to, unsignedp);\n@@ -1753,7 +1752,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \n       if (shift)\n \ttmps[i] = expand_shift (LSHIFT_EXPR, mode, tmps[i],\n-\t\t\t\tbuild_int_cst (NULL_TREE, shift), tmps[i], 0);\n+\t\t\t\tshift, tmps[i], 0);\n     }\n }\n \n@@ -2050,8 +2049,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t    {\n \t      int shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n \t      tmps[i] = expand_shift (RSHIFT_EXPR, mode, tmps[i],\n-\t\t\t\t      build_int_cst (NULL_TREE, shift),\n-\t\t\t\t      tmps[i], 0);\n+\t\t\t\t      shift, tmps[i], 0);\n \t    }\n \t  bytelen = adj_bytelen;\n \t}\n@@ -4052,8 +4050,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t  binop = xor_optab;\n \t}\n       value = expand_shift (LSHIFT_EXPR, str_mode, value,\n-\t\t\t    build_int_cst (NULL_TREE, bitpos),\n-\t\t\t    NULL_RTX, 1);\n+\t\t\t    bitpos, NULL_RTX, 1);\n       result = expand_binop (str_mode, binop, str_rtx,\n \t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n       if (result != str_rtx)\n@@ -4087,8 +4084,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t\t\t      NULL_RTX);\n \t}\n       value = expand_shift (LSHIFT_EXPR, GET_MODE (str_rtx), value,\n-\t\t\t    build_int_cst (NULL_TREE, bitpos),\n-\t\t\t    NULL_RTX, 1);\n+\t\t\t    bitpos, NULL_RTX, 1);\n       result = expand_binop (GET_MODE (str_rtx), binop, str_rtx,\n \t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n       if (result != str_rtx)\n@@ -5882,8 +5878,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  && bitsize < (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (temp))\n \t  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n \ttemp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,\n-\t\t\t     size_int (GET_MODE_BITSIZE (GET_MODE (temp))\n-\t\t\t\t       - bitsize),\n+\t\t\t     GET_MODE_BITSIZE (GET_MODE (temp)) - bitsize,\n \t\t\t     NULL_RTX, 1);\n \n       /* Unless MODE is VOIDmode or BLKmode, convert TEMP to\n@@ -8064,8 +8059,8 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \ttarget = 0;\n       op0 = expand_expr (treeop0, subtarget,\n \t\t\t VOIDmode, EXPAND_NORMAL);\n-      temp = expand_shift (code, mode, op0, treeop1, target,\n-\t\t\t   unsignedp);\n+      temp = expand_variable_shift (code, mode, op0, treeop1, target,\n+\t\t\t\t    unsignedp);\n       if (code == LSHIFT_EXPR)\n \ttemp = REDUCE_BIT_FIELD (temp);\n       return temp;\n@@ -8980,9 +8975,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\ttree count\n-\t\t\t  = build_int_cst (NULL_TREE,\n-\t\t\t\t\t   GET_MODE_BITSIZE (imode) - bitsize);\n+\t\t\tint count = GET_MODE_BITSIZE (imode) - bitsize;\n \n \t\t\top0 = expand_shift (LSHIFT_EXPR, imode, op0, count,\n \t\t\t\t\t    target, 0);\n@@ -9251,9 +9244,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t&& GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t\t&& bitsize < (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (op0)))\n \t      op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,\n-\t\t\t\t  size_int (GET_MODE_BITSIZE (GET_MODE (op0))\n-\t\t\t\t\t    - bitsize),\n-\t\t\t\t  op0, 1);\n+\t\t\t\t  GET_MODE_BITSIZE (GET_MODE (op0))\n+\t\t\t\t  - bitsize, op0, 1);\n \n \t    /* If the result type is BLKmode, store the data into a temporary\n \t       of the appropriate type, but with the mode corresponding to the\n@@ -9750,10 +9742,11 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n     }\n   else\n     {\n-      tree count = build_int_cst (NULL_TREE,\n-\t\t\t\t  GET_MODE_BITSIZE (GET_MODE (exp)) - prec);\n-      exp = expand_shift (LSHIFT_EXPR, GET_MODE (exp), exp, count, target, 0);\n-      return expand_shift (RSHIFT_EXPR, GET_MODE (exp), exp, count, target, 0);\n+      int count = GET_MODE_BITSIZE (GET_MODE (exp)) - prec;\n+      exp = expand_shift (LSHIFT_EXPR, GET_MODE (exp),\n+\t\t\t  exp, count, target, 0);\n+      return expand_shift (RSHIFT_EXPR, GET_MODE (exp),\n+\t\t\t   exp, count, target, 0);\n     }\n }\n \f"}, {"sha": "cb4050dc10d45426982c2c2d30e84e74301994ef", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -488,8 +488,10 @@ extern rtx expand_call (tree, rtx, int);\n extern void fixup_tail_calls (void);\n \n #ifdef TREE_CODE\n-extern rtx expand_shift (enum tree_code, enum machine_mode, rtx, tree, rtx,\n-\t\t\t int);\n+extern rtx expand_variable_shift (enum tree_code, enum machine_mode,\n+\t\t\t\t  rtx, tree, rtx, int);\n+extern rtx expand_shift (enum tree_code, enum machine_mode, rtx, int, rtx,\n+\t\t\t     int);\n extern rtx expand_divmod (int, enum tree_code, enum machine_mode, rtx, rtx,\n \t\t\t  rtx, int);\n #endif"}, {"sha": "973e5a1d34e1cf45f8b9d867f3e4ecf740f6b2d8", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -2876,9 +2876,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n \t      rtx reg = gen_rtx_REG (word_mode, REGNO (entry_parm));\n \n-\t      x = expand_shift (LSHIFT_EXPR, word_mode, reg,\n-\t\t\t\tbuild_int_cst (NULL_TREE, by),\n-\t\t\t\tNULL_RTX, 1);\n+\t      x = expand_shift (LSHIFT_EXPR, word_mode, reg, by, NULL_RTX, 1);\n \t      tem = change_address (mem, word_mode, 0);\n \t      emit_move_insn (tem, x);\n \t    }"}, {"sha": "2119c0902b3a4f35e41055d42d93ed8e7f810749", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -1039,8 +1039,7 @@ resolve_shift_zext (rtx insn)\n \tsrc_reg = expand_shift (GET_CODE (op) == ASHIFT ?\n \t\t\t\tLSHIFT_EXPR : RSHIFT_EXPR,\n \t\t\t\tword_mode, src_reg,\n-\t\t\t\tbuild_int_cst (NULL_TREE,\n-\t\t\t\t\t       shift_count - BITS_PER_WORD),\n+\t\t\t\tshift_count - BITS_PER_WORD,\n \t\t\t\tdest_reg, 1);\n     }\n "}, {"sha": "62e123ba514883c2fba20955df66c870d73ad214", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "patch": "@@ -2453,8 +2453,8 @@ widen_bswap (enum machine_mode mode, rtx op0, rtx target)\n \n   if (x != 0)\n     x = expand_shift (RSHIFT_EXPR, wider_mode, x,\n-\t\t      size_int (GET_MODE_BITSIZE (wider_mode)\n-\t\t\t        - GET_MODE_BITSIZE (mode)),\n+\t\t      GET_MODE_BITSIZE (wider_mode)\n+\t\t      - GET_MODE_BITSIZE (mode),\n \t\t      NULL_RTX, true);\n \n   if (x != 0)\n@@ -3150,7 +3150,7 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n \t      \t      false) >= 2)\n     {\n       rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t   size_int (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t\t   GET_MODE_BITSIZE (mode) - 1,\n \t\t\t\t   NULL_RTX, 0);\n \n       temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n@@ -3251,7 +3251,7 @@ expand_one_cmpl_abs_nojump (enum machine_mode mode, rtx op0, rtx target)\n \t             false) >= 2)\n     {\n       rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t   size_int (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t\t   GET_MODE_BITSIZE (mode) - 1,\n \t\t\t\t   NULL_RTX, 0);\n \n       temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n@@ -4724,8 +4724,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t      emit_label (neglabel);\n \t      temp = expand_binop (imode, and_optab, from, const1_rtx,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t      temp1 = expand_shift (RSHIFT_EXPR, imode, from, integer_one_node,\n-\t\t\t\t    NULL_RTX, 1);\n+\t      temp1 = expand_shift (RSHIFT_EXPR, imode, from, 1, NULL_RTX, 1);\n \t      temp = expand_binop (imode, ior_optab, temp, temp1, temp, 1,\n \t\t\t\t   OPTAB_LIB_WIDEN);\n \t      expand_float (target, temp, 0);"}]}