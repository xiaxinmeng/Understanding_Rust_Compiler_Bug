{"sha": "71afd0628419c5d670701cb35bc9860380c7d9fb", "node_id": "C_kwDOANBUbNoAKDcxYWZkMDYyODQxOWM1ZDY3MDcwMWNiMzViYzk4NjAzODBjN2Q5ZmI", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-03-01T19:28:46Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-03-02T16:01:36Z"}, "message": "c++: ICE with -Wmismatched-tags and member template [PR106259]\n\n-Wmismatched-tags warns about the (harmless) struct/class mismatch.\nFor, e.g.,\n\n  template<typename T> struct A { };\n  class A<int> a;\n\nit works by adding A<T> to the class2loc hash table while parsing the\nclass-head and then, while parsing the elaborate type-specifier, we\nadd A<int>.  At the end of c_parse_file we go through the table and\nwarn about the class-key mismatches.  In this PR we crash though; we\nhave\n\n  template<typename T> struct A {\n    template<typename U> struct W { };\n  };\n  struct A<int>::W<int> w; // #1\n\nwhere while parsing A and #1 we've stashed\n   A<T>\n   A<T>::W<U>\n   A<int>::W<int>\ninto class2loc.  Then in class_decl_loc_t::diag_mismatched_tags TYPE\nis A<int>::W<int>, and specialization_of gets us A<int>::W<U>, which\nis not in class2loc, so we crash on gcc_assert (cdlguide).  But it's\nOK not to have found A<int>::W<U>, we should just look one \"level\" up,\nthat is, A<T>::W<U>.\n\nIt's important to handle class specializations, so e.g.\n\n  template<>\n  struct A<char> {\n    template<typename U>\n    class W { };\n  };\n\nwhere W's class-key is different than in the primary template above,\nso we should warn depending on whether we're looking into A<char>\nor into a different instantiation.\n\n\tPR c++/106259\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (class_decl_loc_t::diag_mismatched_tags): If the first\n\tlookup of SPEC didn't find anything, try to look for\n\tmost_general_template.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/warn/Wmismatched-tags-11.C: New test.", "tree": {"sha": "f1a69495777668c68ac24cb8e8082e9885107c37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1a69495777668c68ac24cb8e8082e9885107c37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71afd0628419c5d670701cb35bc9860380c7d9fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71afd0628419c5d670701cb35bc9860380c7d9fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71afd0628419c5d670701cb35bc9860380c7d9fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71afd0628419c5d670701cb35bc9860380c7d9fb/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da19e37cedc2acd1c560012dc41a57b7145dc181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da19e37cedc2acd1c560012dc41a57b7145dc181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da19e37cedc2acd1c560012dc41a57b7145dc181"}], "stats": {"total": 53, "additions": 47, "deletions": 6}, "files": [{"sha": "b00a6cd5b8b33aa2ee9e2b4ae3a833668e926ec6", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71afd0628419c5d670701cb35bc9860380c7d9fb/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71afd0628419c5d670701cb35bc9860380c7d9fb/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=71afd0628419c5d670701cb35bc9860380c7d9fb", "patch": "@@ -34473,14 +34473,32 @@ class_decl_loc_t::diag_mismatched_tags (tree type_decl)\n \t be (and inevitably is) at index zero.  */\n       tree spec = specialization_of (type);\n       cdlguide = class2loc.get (spec);\n+      /* It's possible that we didn't find SPEC.  Consider:\n+\n+\t   template<typename T> struct A {\n+\t     template<typename U> struct W { };\n+\t   };\n+\t   struct A<int>::W<int> w; // #1\n+\n+\t where while parsing A and #1 we've stashed\n+\t   A<T>\n+\t   A<T>::W<U>\n+\t   A<int>::W<int>\n+\t into CLASS2LOC.  If TYPE is A<int>::W<int>, specialization_of\n+\t will yield A<int>::W<U> which may be in CLASS2LOC if we had\n+\t an A<int> class specialization, but otherwise won't be in it.\n+\t So try to look up A<T>::W<U>.  */\n+      if (!cdlguide)\n+\t{\n+\t  spec = DECL_TEMPLATE_RESULT (most_general_template (spec));\n+\t  cdlguide = class2loc.get (spec);\n+\t}\n+      /* Now we really should have found something.  */\n       gcc_assert (cdlguide != NULL);\n     }\n-  else\n-    {\n-      /* Skip declarations that consistently use the same class-key.  */\n-      if (def_class_key != none_type)\n-\treturn;\n-    }\n+  /* Skip declarations that consistently use the same class-key.  */\n+  else if (def_class_key != none_type)\n+    return;\n \n   /* Set if a definition for the class has been seen.  */\n   const bool def_p = cdlguide->def_p ();"}, {"sha": "6c4e571726aa14863728eddbc45c2915ff067a50", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-tags-11.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71afd0628419c5d670701cb35bc9860380c7d9fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71afd0628419c5d670701cb35bc9860380c7d9fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-tags-11.C?ref=71afd0628419c5d670701cb35bc9860380c7d9fb", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/106259\n+// { dg-do compile }\n+// { dg-options \"-Wmismatched-tags\" }\n+\n+template<typename T> struct A {\n+  template<typename U>\n+  struct W { };\n+};\n+\n+template<>\n+struct A<char> {\n+  template<typename U>\n+  class W { };\n+};\n+\n+void\n+g ()\n+{\n+  struct A<char>::W<int> w1; // { dg-warning \"mismatched\" }\n+  struct A<int>::W<int> w2;\n+  class A<char>::W<int> w3;\n+  class A<int>::W<int> w4; // { dg-warning \"mismatched\" }\n+}"}]}