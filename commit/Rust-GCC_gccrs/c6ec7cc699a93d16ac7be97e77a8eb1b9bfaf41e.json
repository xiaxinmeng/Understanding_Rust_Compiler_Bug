{"sha": "c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZlYzdjYzY5OWE5M2QxNmFjN2JlOTdlNzdhOGViMWI5YmZhZjQxZQ==", "commit": {"author": {"name": "Dennis Wassel", "email": "dennis.wassel@gmail.com", "date": "2009-10-01T02:32:41Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-10-01T02:32:41Z"}, "message": "trans-array.c (gfc_trans_array_bound_check): Improved bounds checking error messages.\n\n2009-09-30  Dennis Wassel  <dennis.wassel@gmail.com>\n\n\t* gcc/fortran/trans-array.c (gfc_trans_array_bound_check): Improved\n\tbounds checking error messages. (gfc_conv_array_ref): Likewise.\n\t(gfc_conv_ss_startstride): Likewise.\n\nFrom-SVN: r152355", "tree": {"sha": "3ede31e35824ce27e872abd65707aaa5916087d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ede31e35824ce27e872abd65707aaa5916087d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e/comments", "author": null, "committer": null, "parents": [{"sha": "4578037eb7b14062b4c1a5bafccc13893c11561c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4578037eb7b14062b4c1a5bafccc13893c11561c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4578037eb7b14062b4c1a5bafccc13893c11561c"}], "stats": {"total": 204, "additions": 118, "deletions": 86}, "files": [{"sha": "2398dd0fc68293487c19667c1dece2901de414c6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e", "patch": "@@ -1,3 +1,9 @@\n+2009-09-30  Dennis Wassel  <dennis.wassel@gmail.com>\n+\n+\t* gcc/fortran/trans-array.c (gfc_trans_array_bound_check): Improved\n+\tbounds checking error messages. (gfc_conv_array_ref): Likewise.\n+\t(gfc_conv_ss_startstride): Likewise.\n+\n 2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n \n \t* resolve.c (check_typebound_baseobject): Don't check for"}, {"sha": "e16200010d1be7173edcb8449d801c61f56d88ef", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 112, "deletions": 86, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c6ec7cc699a93d16ac7be97e77a8eb1b9bfaf41e", "patch": "@@ -2296,7 +2296,7 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n \t\t\t     locus * where, bool check_upper)\n {\n   tree fault;\n-  tree tmp;\n+  tree tmp_lo, tmp_up;\n   char *msg;\n   const char * name = NULL;\n \n@@ -2333,34 +2333,46 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n \t  name = \"unnamed constant\";\n     }\n \n-  /* Check lower bound.  */\n-  tmp = gfc_conv_array_lbound (descriptor, n);\n-  fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp);\n-  if (name)\n-    asprintf (&msg, \"%s for array '%s', lower bound of dimension %d exceeded\"\n-\t      \"(%%ld < %%ld)\", gfc_msg_fault, name, n+1);\n-  else\n-    asprintf (&msg, \"%s, lower bound of dimension %d exceeded (%%ld < %%ld)\",\n-\t      gfc_msg_fault, n+1);\n-  gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n-\t\t\t   fold_convert (long_integer_type_node, index),\n-\t\t\t   fold_convert (long_integer_type_node, tmp));\n-  gfc_free (msg);\n-\n-  /* Check upper bound.  */\n+  /* If upper bound is present, include both bounds in the error message.  */\n   if (check_upper)\n     {\n-      tmp = gfc_conv_array_ubound (descriptor, n);\n-      fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp);\n+      tmp_lo = gfc_conv_array_lbound (descriptor, n);\n+      tmp_up = gfc_conv_array_ubound (descriptor, n);\n+\n       if (name)\n-\tasprintf (&msg, \"%s for array '%s', upper bound of dimension %d \"\n-\t\t\t\" exceeded (%%ld > %%ld)\", gfc_msg_fault, name, n+1);\n+\tasprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t  \"outside of expected range (%%ld:%%ld)\", n+1, name);\n       else\n-\tasprintf (&msg, \"%s, upper bound of dimension %d exceeded (%%ld > %%ld)\",\n-\t\t  gfc_msg_fault, n+1);\n+\tasprintf (&msg, \"Index '%%ld' of dimension %d \"\n+\t\t  \"outside of expected range (%%ld:%%ld)\", n+1);\n+\n+      fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp_lo);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n-\t\t\t       fold_convert (long_integer_type_node, tmp));\n+\t\t\t       fold_convert (long_integer_type_node, tmp_lo),\n+\t\t\t       fold_convert (long_integer_type_node, tmp_up));\n+      fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp_up);\n+      gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n+\t\t\t       fold_convert (long_integer_type_node, index),\n+\t\t\t       fold_convert (long_integer_type_node, tmp_lo),\n+\t\t\t       fold_convert (long_integer_type_node, tmp_up));\n+      gfc_free (msg);\n+    }\n+  else\n+    {\n+      tmp_lo = gfc_conv_array_lbound (descriptor, n);\n+\n+      if (name)\n+\tasprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t  \"below lower bound of %%ld\", n+1, name);\n+      else\n+\tasprintf (&msg, \"Index '%%ld' of dimension %d \"\n+\t\t  \"below lower bound of %%ld\", n+1);\n+\n+      fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp_lo);\n+      gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n+\t\t\t       fold_convert (long_integer_type_node, index),\n+\t\t\t       fold_convert (long_integer_type_node, tmp_lo));\n       gfc_free (msg);\n     }\n \n@@ -2561,9 +2573,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \n \t  cond = fold_build2 (LT_EXPR, boolean_type_node, \n \t\t\t      indexse.expr, tmp);\n-\t  asprintf (&msg, \"%s for array '%s', \"\n-\t            \"lower bound of dimension %d exceeded (%%ld < %%ld)\",\n-\t\t    gfc_msg_fault, sym->name, n+1);\n+\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t    \"below lower bound of %%ld\", n+1, sym->name);\n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n \t\t\t\t   fold_convert (long_integer_type_node,\n \t\t\t\t\t\t indexse.expr),\n@@ -2587,9 +2598,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \n \t      cond = fold_build2 (GT_EXPR, boolean_type_node, \n \t\t\t\t  indexse.expr, tmp);\n-\t      asprintf (&msg, \"%s for array '%s', \"\n-\t\t\t\"upper bound of dimension %d exceeded (%%ld > %%ld)\",\n-\t\t\tgfc_msg_fault, sym->name, n+1);\n+\t      asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t\t\"above upper bound of %%ld\", n+1, sym->name);\n \t      gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n \t\t\t\t   fold_convert (long_integer_type_node,\n \t\t\t\t\t\t indexse.expr),\n@@ -3166,7 +3176,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n       tree lbound, ubound;\n       tree end;\n       tree size[GFC_MAX_DIMENSIONS];\n-      tree stride_pos, stride_neg, non_zerosized, tmp2;\n+      tree stride_pos, stride_neg, non_zerosized, tmp2, tmp3;\n       gfc_ss_info *info;\n       char *msg;\n       int dim;\n@@ -3246,77 +3256,95 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t   stride_pos, stride_neg);\n \n \t      /* Check the start of the range against the lower and upper\n-\t\t bounds of the array, if the range is not empty.  */\n-\t      tmp = fold_build2 (LT_EXPR, boolean_type_node, info->start[n],\n-\t\t\t\t lbound);\n-\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t non_zerosized, tmp);\n-\t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded (%%ld < %%ld)\", gfc_msg_fault,\n-\t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t\t       &ss->expr->where, msg,\n-\t\t\t\t       fold_convert (long_integer_type_node,\n-\t\t\t\t\t\t     info->start[n]),\n-\t\t\t\t       fold_convert (long_integer_type_node,\n-\t\t\t\t\t\t     lbound));\n-\t      gfc_free (msg);\n-\n+\t\t bounds of the array, if the range is not empty. \n+\t         If upper bound is present, include both bounds in the \n+\t\t error message.  */\n \t      if (check_upper)\n \t\t{\n-\t\t  tmp = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t     info->start[n], ubound);\n+\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node, \n+\t\t\t\t     info->start[n], lbound);\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n-\t          asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n-\t\t\t    \"'%s' exceeded (%%ld > %%ld)\", gfc_msg_fault,\n+\t\t  tmp2 = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t      info->start[n], ubound);\n+\t\t  tmp2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      non_zerosized, tmp2);\n+\t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t\t    \"outside of expected range (%%ld:%%ld)\", \n \t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t&ss->expr->where, msg,\n-\t\t\tfold_convert (long_integer_type_node, info->start[n]),\n-\t\t\tfold_convert (long_integer_type_node, ubound));\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &inner, \n+\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t     fold_convert (long_integer_type_node, info->start[n]),\n+\t\t     fold_convert (long_integer_type_node, lbound), \n+\t\t     fold_convert (long_integer_type_node, ubound));\n+\t\t  gfc_trans_runtime_check (true, false, tmp2, &inner, \n+\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t     fold_convert (long_integer_type_node, info->start[n]),\n+\t\t     fold_convert (long_integer_type_node, lbound), \n+\t\t     fold_convert (long_integer_type_node, ubound));\n \t\t  gfc_free (msg);\n \t\t}\n-\n+\t      else\n+\t\t{\n+\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node, \n+\t\t\t\t     info->start[n], lbound);\n+\t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t     non_zerosized, tmp);\n+\t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t\t    \"below lower bound of %%ld\", \n+\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &inner, \n+\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t     fold_convert (long_integer_type_node, info->start[n]),\n+\t\t     fold_convert (long_integer_type_node, lbound));\n+\t\t  gfc_free (msg);\n+\t\t}\n+\t      \n \t      /* Compute the last element of the range, which is not\n \t\t necessarily \"end\" (think 0:5:3, which doesn't contain 5)\n \t\t and check it against both lower and upper bounds.  */\n-\t      tmp2 = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n+\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n \t\t\t\t  info->start[n]);\n-\t      tmp2 = fold_build2 (TRUNC_MOD_EXPR, gfc_array_index_type, tmp2,\n+\t      tmp = fold_build2 (TRUNC_MOD_EXPR, gfc_array_index_type, tmp,\n \t\t\t\t  info->stride[n]);\n-\t      tmp2 = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t  tmp2);\n-\n-\t      tmp = fold_build2 (LT_EXPR, boolean_type_node, tmp2, lbound);\n-\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t non_zerosized, tmp);\n-\t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded (%%ld < %%ld)\", gfc_msg_fault,\n-\t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t\t       &ss->expr->where, msg,\n-\t\t\t\t       fold_convert (long_integer_type_node,\n-\t\t\t\t\t\t     tmp2),\n-\t\t\t\t       fold_convert (long_integer_type_node,\n-\t\t\t\t\t\t     lbound));\n-\t      gfc_free (msg);\n-\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n+\t\t\t\t  tmp);\n+\t      tmp2 = fold_build2 (LT_EXPR, boolean_type_node, tmp, lbound);\n+\t      tmp2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t non_zerosized, tmp2);\n \t      if (check_upper)\n \t\t{\n-\t\t  tmp = fold_build2 (GT_EXPR, boolean_type_node, tmp2, ubound);\n-\t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t     non_zerosized, tmp);\n-\t\t  asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n-\t\t\t    \"'%s' exceeded (%%ld > %%ld)\", gfc_msg_fault,\n+\t\t  tmp3 = fold_build2 (GT_EXPR, boolean_type_node, tmp, ubound);\n+\t\t  tmp3 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      non_zerosized, tmp3);\n+\t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t\t    \"outside of expected range (%%ld:%%ld)\", \n \t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t&ss->expr->where, msg,\n-\t\t\tfold_convert (long_integer_type_node, tmp2),\n-\t\t\tfold_convert (long_integer_type_node, ubound));\n+\t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n+\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t     fold_convert (long_integer_type_node, tmp),\n+\t\t     fold_convert (long_integer_type_node, ubound), \n+\t\t     fold_convert (long_integer_type_node, lbound));\n+\t\t  gfc_trans_runtime_check (true, false, tmp3, &inner,\n+\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t     fold_convert (long_integer_type_node, tmp),\n+\t\t     fold_convert (long_integer_type_node, ubound), \n+\t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  gfc_free (msg);\n \t\t}\n-\n+\t      else\n+\t\t{\n+\t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n+\t\t\t    \"below lower bound of %%ld\", \n+\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n+\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t     fold_convert (long_integer_type_node, tmp),\n+\t\t     fold_convert (long_integer_type_node, lbound));\n+\t\t  gfc_free (msg);\n+\t\t}\n+\t      \n \t      /* Check the section sizes match.  */\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n \t\t\t\t info->start[n]);\n@@ -3330,8 +3358,6 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t         others against this.  */\n \t      if (size[n])\n \t\t{\n-\t\t  tree tmp3;\n-\n \t\t  tmp3 = fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n \t\t  asprintf (&msg, \"%s, size mismatch for dimension %d \"\n \t\t\t    \"of array '%s' (%%ld/%%ld)\", gfc_msg_bounds,"}]}