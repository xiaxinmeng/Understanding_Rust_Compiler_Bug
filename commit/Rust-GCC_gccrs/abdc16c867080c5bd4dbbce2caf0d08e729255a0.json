{"sha": "abdc16c867080c5bd4dbbce2caf0d08e729255a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkYzE2Yzg2NzA4MGM1YmQ0ZGJiY2UyY2FmMGQwOGU3MjkyNTVhMA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-04-02T17:14:48Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-04-02T17:14:48Z"}, "message": "PR c++/67376 - [5/6 regression] Comparison with pointer to past-the-end\n\nPR c++/67376 - [5/6 regression] Comparison with pointer to past-the-end\n        of array fails inside constant expression\nPR c++/70170 - [6 regression] bogus not a constant expression error comparing\n        pointer to array to null\nPR c++/70172 - incorrect reinterpret_cast from integer to pointer error\n        on invalid constexpr initialization\nPR c++/70228 - insufficient detail in diagnostics for a constexpr out of bounds\n        array subscript\n\ngcc/testsuite/ChangeLog:\n2016-04-02  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/67376\n        PR c++/70170\n        PR c++/70172\n        PR c++/70228\n        * g++.dg/cpp0x/constexpr-array-ptr10.C: New test.\n        * g++.dg/cpp0x/constexpr-array-ptr9.C: New test.\n        * g++.dg/cpp0x/constexpr-nullptr-1.C: New test.\n        * g++.dg/cpp0x/constexpr-array5.C: Adjust text of expected diagnostic.\n        * g++.dg/cpp0x/constexpr-string.C: Same.\n        * g++.dg/cpp0x/constexpr-wstring2.C: Same.\n        * g++.dg/cpp0x/pr65398.C: Same.\n        * g++.dg/ext/constexpr-vla1.C: Same.\n        * g++.dg/ext/constexpr-vla2.C: Same.\n        * g++.dg/ext/constexpr-vla3.C: Same.\n        * g++.dg/ubsan/pr63956.C: Same.\n\ngcc/cp/ChangeLog:\n2016-04-02  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/67376\n        PR c++/70170\n        PR c++/70172\n        PR c++/70228\n        * constexpr.c (diag_array_subscript): New function.\n        (cxx_eval_array_reference): Detect out of bounds array indices.\n\ngcc/ChangeLog:\n2016-04-02  Martin Sebor  <msebor@redhat.com>\n\n        PR c++/67376\n        * fold-const.c (maybe_nonzero_address): New function.\n        (fold_comparison): Call it.  Fold equality and relational\n        expressions involving null pointers.\n        (tree_single_nonzero_warnv_p): Call maybe_nonzero_address.\n\nFrom-SVN: r234698", "tree": {"sha": "f504219a5a11f02c14411065cc894e05404ff4ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f504219a5a11f02c14411065cc894e05404ff4ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abdc16c867080c5bd4dbbce2caf0d08e729255a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdc16c867080c5bd4dbbce2caf0d08e729255a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abdc16c867080c5bd4dbbce2caf0d08e729255a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdc16c867080c5bd4dbbce2caf0d08e729255a0/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d9979e629a54f0d7e3378c90c7eb1adfd76196e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9979e629a54f0d7e3378c90c7eb1adfd76196e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9979e629a54f0d7e3378c90c7eb1adfd76196e"}], "stats": {"total": 449, "additions": 420, "deletions": 29}, "files": [{"sha": "c1dc2e590aa700c98967a6798d98f67fe9102c4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -1,3 +1,11 @@\n+2016-04-02  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67376\n+\t* fold-const.c (maybe_nonzero_address): New function.\n+\t(fold_comparison): Call it.  Fold equality and relational\n+\texpressions involving null pointers.\n+\t(tree_single_nonzero_warnv_p): Call maybe_nonzero_address.\n+\n 2016-03-31  Evandro Menezes  <e.menezes@samsung.com>\n \n \tFix the predicate \"aarch64_simd_reg_or_zero\" to correctly validate"}, {"sha": "524f6636860b14184dd705c73ab320bec3cb9830", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -1,3 +1,12 @@\n+2016-04-02  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67376\n+\tPR c++/70170\n+\tPR c++/70172\n+\tPR c++/70228\n+\t* constexpr.c (diag_array_subscript): New function.\n+\t(cxx_eval_array_reference): Detect out of bounds array indices.\n+\n 2016-04-01  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/70449"}, {"sha": "b94b346c45c1f6198165c6cb3dc332721b2508b8", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -1825,6 +1825,30 @@ find_array_ctor_elt (tree ary, tree dindex, bool insert = false)\n   return -1;\n }\n \n+/* Under the control of CTX, issue a detailed diagnostic for\n+   an out-of-bounds subscript INDEX into the expression ARRAY.  */\n+\n+static void\n+diag_array_subscript (const constexpr_ctx *ctx, tree array, tree index)\n+{\n+  if (!ctx->quiet)\n+    {\n+      tree arraytype = TREE_TYPE (array);\n+\n+      /* Convert the unsigned array subscript to a signed integer to avoid\n+\t printing huge numbers for small negative values.  */\n+      tree sidx = fold_convert (ssizetype, index);\n+      if (DECL_P (array))\n+\t{\n+\t  error (\"array subscript value %qE is outside the bounds \"\n+\t\t \"of array %qD of type %qT\", sidx, array, arraytype);\n+\t  inform (DECL_SOURCE_LOCATION (array), \"declared here\");\n+\t}\n+      else\n+\terror (\"array subscript value %qE is outside the bounds \"\n+\t       \"of array type %qT\", sidx, arraytype);\n+    }\n+}\n \n /* Subroutine of cxx_eval_constant_expression.\n    Attempt to reduce a reference to an array slot.  */\n@@ -1873,8 +1897,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   if (!tree_fits_shwi_p (index)\n       || (i = tree_to_shwi (index)) < 0)\n     {\n-      if (!ctx->quiet)\n-\terror (\"negative array subscript\");\n+      diag_array_subscript (ctx, ary, index);\n       *non_constant_p = true;\n       return t;\n     }\n@@ -1886,8 +1909,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   VERIFY_CONSTANT (nelts);\n   if (!tree_int_cst_lt (index, nelts))\n     {\n-      if (!ctx->quiet)\n-\terror (\"array subscript out of bound\");\n+      diag_array_subscript (ctx, ary, index);\n       *non_constant_p = true;\n       return t;\n     }"}, {"sha": "0f4bf7eca6b23b8198c9cf28e139ed9a6b9a657d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -8338,6 +8338,20 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n   return total.to_uhwi () > (unsigned HOST_WIDE_INT) size;\n }\n \n+/* Return a positive integer when the symbol DECL is known to have\n+   a nonzero address, zero when it's known not to (e.g., it's a weak\n+   symbol), and a negative integer when the symbol is not yet in the\n+   symbol table and so whether or not its address is zero is unknown.  */\n+static int\n+maybe_nonzero_address (tree decl)\n+{\n+  if (DECL_P (decl) && decl_in_symtab_p (decl))\n+    if (struct symtab_node *symbol = symtab_node::get_create (decl))\n+      return symbol->nonzero_address ();\n+\n+  return -1;\n+}\n+\n /* Subroutine of fold_binary.  This routine performs all of the\n    transformations that are common to the equality/inequality\n    operators (EQ_EXPR and NE_EXPR) and the ordering operators\n@@ -8638,6 +8652,39 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t    base1 = build_fold_addr_expr_loc (loc, base1);\n \t  return fold_build2_loc (loc, code, type, base0, base1);\n \t}\n+      /* Comparison between an ordinary (non-weak) symbol and a null\n+\t pointer can be eliminated since such symbols must have a non\n+\t null address.  In C, relational expressions between pointers\n+\t to objects and null pointers are undefined.  The results\n+\t below follow the C++ rules with the additional property that\n+\t every object pointer compares greater than a null pointer.\n+      */\n+      else if (DECL_P (base0)\n+\t       && maybe_nonzero_address (base0) > 0\n+\t       /* Avoid folding references to struct members at offset 0 to\n+\t\t  prevent tests like '&ptr->firstmember == 0' from getting\n+\t\t  eliminated.  When ptr is null, although the -> expression\n+\t\t  is strictly speaking invalid, GCC retains it as a matter\n+\t\t  of QoI.  See PR c/44555. */\n+\t       && (offset0 == NULL_TREE && bitpos0 != 0)\n+\t       /* The caller guarantees that when one of the arguments is\n+\t\t  constant (i.e., null in this case) it is second.  */\n+\t       && integer_zerop (arg1))\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case EQ_EXPR:\n+\t    case LE_EXPR:\n+\t    case LT_EXPR:\n+\t      return boolean_false_node;\n+\t    case GE_EXPR:\n+\t    case GT_EXPR:\n+\t    case NE_EXPR:\n+\t      return boolean_true_node;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n     }\n \n   /* Transform comparisons of the form X +- C1 CMP Y +- C2 to\n@@ -13508,16 +13555,9 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \t/* For objects in symbol table check if we know they are non-zero.\n \t   Don't do anything for variables and functions before symtab is built;\n \t   it is quite possible that they will be declared weak later.  */\n-\tif (DECL_P (base) && decl_in_symtab_p (base))\n-\t  {\n-\t    struct symtab_node *symbol;\n-\n-\t    symbol = symtab_node::get_create (base);\n-\t    if (symbol)\n-\t      return symbol->nonzero_address ();\n-\t    else\n-\t      return false;\n-\t  }\n+\tint nonzero_addr = maybe_nonzero_address (base);\n+\tif (nonzero_addr >= 0)\n+\t  return nonzero_addr;\n \n \t/* Function local objects are never NULL.  */\n \tif (DECL_P (base)"}, {"sha": "014a2edefd108e047cc31af6f4dd2f9a3ac21c17", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -1,3 +1,21 @@\n+2016-04-02  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67376\n+\tPR c++/70170\n+\tPR c++/70172\n+\tPR c++/70228\n+\t* g++.dg/cpp0x/constexpr-array-ptr10.C: New test.\n+\t* g++.dg/cpp0x/constexpr-array-ptr9.C: New test.\n+\t* g++.dg/cpp0x/constexpr-nullptr-1.C: New test.\n+\t* g++.dg/cpp0x/constexpr-array5.C: Adjust text of expected diagnostic.\n+\t* g++.dg/cpp0x/constexpr-string.C: Same.\n+\t* g++.dg/cpp0x/constexpr-wstring2.C: Same.\n+\t* g++.dg/cpp0x/pr65398.C: Same.\n+\t* g++.dg/ext/constexpr-vla1.C: Same.\n+\t* g++.dg/ext/constexpr-vla2.C: Same.\n+\t* g++.dg/ext/constexpr-vla3.C: Same.\n+\t* g++.dg/ubsan/pr63956.C: Same.\n+\n 2016-04-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/70467"}, {"sha": "f75b3c3227f3d742ac290786fc1192b5fff17b74", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr10.C", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -0,0 +1,112 @@\n+// PR c++/67376 - [5/6 regression] Comparison with pointer to past-the-end\n+//                of array fails inside constant expression\n+// This test verifies the aspect of the bug raised in comment #10,\n+// specifically comparing pointers to null.  The basic regression test\n+// is in g++.dg/cpp0x/constexpr-67376.C.\n+// Note also that while the description of the bug talks about pointers\n+// pointing past the end of arrays but the prolem is more general than\n+// that and involves all constexpr object pointers.\n+\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-Wall -Wextra\" }\n+\n+namespace A {\n+\n+extern int i;\n+\n+constexpr int *p0 = &i;\n+\n+constexpr bool b0  = p0;        // { dg-warning \"address of .A::i.\" }\n+constexpr bool b1  = p0 == 0;   // { dg-warning \"address of .A::i.\" }\n+constexpr bool b2  = p0 != 0;   // { dg-warning \"address of .A::i.\" }\n+constexpr bool b3  = p0 <  0;   // { dg-warning \"ordered comparison\" }\n+constexpr bool b4  = p0 <= 0;   // { dg-warning \"ordered comparison\" }\n+constexpr bool b5  = p0 >  0;   // { dg-warning \"ordered comparison\" }\n+constexpr bool b6  = p0 >= 0;   // { dg-warning \"ordered comparison\" }\n+\n+constexpr bool b7  = !p0;       // { dg-warning \"address of .A::i.\" }\n+constexpr bool b8  = 0 == p0;   // { dg-warning \"address of .A::i.\" }\n+constexpr bool b9  = 0 != p0;   // { dg-warning \"address of .A::i.\" }\n+constexpr bool b10 = 0 <  p0;   // { dg-warning \"ordered comparison\" }\n+constexpr bool b11 = 0 <= p0;   // { dg-warning \"ordered comparison\" }\n+constexpr bool b12 = 0 >  p0;   // { dg-warning \"ordered comparison\" }\n+constexpr bool b13 = 0 >= p0;   // { dg-warning \"ordered comparison\" }\n+\n+}\n+\n+namespace B {\n+\n+// PR c++/70172 - incorrect reinterpret_cast from integer to pointer\n+// error on invalid constexpr initialization\n+\n+struct S { int a, b[1]; } s;\n+\n+constexpr S *p0 = &s;\n+\n+constexpr int *q0 = p0->b;      // { dg-bogus \"reinterpret_cast from integer to pointer\" }\n+\n+}\n+\n+namespace WeakRefTest1 {\n+\n+extern __attribute__ ((weak)) int i;\n+\n+constexpr int *p0 = &i;\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wextra\"\n+// Suppress warning: ordered comparison of pointer with integer zero\n+\n+constexpr bool b0  = p0;        // { dg-error \"not a constant expression\" }\n+constexpr bool b1  = p0 == 0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b2  = p0 != 0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b4  = p0 <= 0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b5  = p0 >  0;   // { dg-error \"not a constant expression\" }\n+\n+constexpr bool b7  = !p0;       // { dg-error \"not a constant expression\" }\n+constexpr bool b8  = 0 == p0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b9  = 0 != p0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b10 = 0 <  p0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b13 = 0 >= p0;   // { dg-error \"not a constant expression\" }\n+\n+// The following are accepted as constant expressions due to bug c++/70196.\n+constexpr bool b3  = p0 <  0;\n+constexpr bool b6  = p0 >= 0;\n+constexpr bool b11 = 0 <= p0;\n+constexpr bool b12 = 0 >  p0;\n+\n+#pragma GCC diagnostic pop\n+\n+}\n+\n+namespace WeakRefTest2 {\n+\n+extern __attribute__ ((weak)) int i;\n+\n+constexpr int *p1 = &i + 1;\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wextra\"\n+// Suppress warning: ordered comparison of pointer with integer zero\n+\n+constexpr bool b0  = p1;        // { dg-error \"not a constant expression\" }\n+constexpr bool b1  = p1 == 0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b2  = p1 != 0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b4  = p1 <= 0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b5  = p1 >  0;   // { dg-error \"not a constant expression\" }\n+\n+constexpr bool b7  = !p1;       // { dg-error \"not a constant expression\" }\n+constexpr bool b8  = 0 == p1;   // { dg-error \"not a constant expression\" }\n+constexpr bool b9  = 0 != p1;   // { dg-error \"not a constant expression\" }\n+constexpr bool b10 = 0 <  p1;   // { dg-error \"not a constant expression\" }\n+constexpr bool b13 = 0 >= p1;   // { dg-error \"not a constant expression\" }\n+\n+// The following are accepted as constant expressions due to bug c++/70196.\n+// constexpr bool b3  = p1 <  0;\n+// constexpr bool b6  = p1 >= 0;\n+// constexpr bool b11 = 0 <= p1;\n+// constexpr bool b12 = 0 >  p1;\n+\n+#pragma GCC diagnostic pop\n+\n+}"}, {"sha": "f0250cbcd22dd69b97cde035d67cad3d9c552f0f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr9.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr9.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -0,0 +1,57 @@\n+// PR c++/67376 - [5/6 regression] Comparison with pointer to past-the-end\n+//     of array fails inside constant expression\n+// { dg-do compile { target c++11 } }\n+\n+int a [2];\n+\n+constexpr const int* pa[] = {\n+  a,\n+  a + 0,\n+  a + 1,\n+  a + 2,\n+  &a [0],\n+  &a [0] + 0,\n+  &a [0] + 1,\n+  &a [0] + 2,\n+  &a [1],\n+  &a [1] - 1,\n+  &a [1] + 0,\n+  &a [1] + 1,\n+  &a [2] - 2,\n+  &a [2] - 1,\n+  &a [2] + 0\n+};\n+\n+#define Assert(e) static_assert ((e), #e)\n+\n+Assert (!(a == 0));\n+Assert (!(a == (int*)0));\n+Assert (!(a == nullptr));\n+\n+Assert (a != 0);\n+Assert (a != (int*)0);\n+Assert (a != nullptr);\n+\n+Assert (!(0 == a));\n+Assert (!((int*)0 == a));\n+Assert (!(nullptr == a));\n+\n+Assert (0 != a);\n+Assert ((int*)0 != a);\n+Assert (nullptr != a);\n+\n+bool constexpr test_eq (unsigned inx)\n+{\n+  return inx ? pa [inx - 1] == 0 && 0 == pa [inx - 1]\n+    && test_eq (inx - 1) : pa [inx] == 0 && 0 == pa [inx];\n+}\n+\n+Assert (!test_eq (sizeof pa / sizeof *pa));\n+\n+bool constexpr test_ne (unsigned inx)\n+{\n+  return inx ? pa [inx - 1] != 0 && 0 != pa [inx - 1]\n+    && test_ne (inx - 1) : pa [inx] != 0 && 0 != pa [inx];\n+}\n+\n+Assert (test_ne (sizeof pa / sizeof *pa));"}, {"sha": "00dfd6db4dfa2798ed15354dbce2a1c47e1c15b0", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array5.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -3,7 +3,7 @@\n \n // Reliable ICE\n constexpr int n[3] = {};\n-constexpr int k = n[-1];            // { dg-error \"negative\" }\n+constexpr int k = n[-1];            // { dg-error \"array subscript\" }\n \n // Some random byte\n-constexpr char c = \"foo\"[-1000];    // { dg-error \"negative\" }\n+constexpr char c = \"foo\"[-1000];    // { dg-error \"array subscript\" }"}, {"sha": "420a04b7768b82312403c23ae12c37d4a0f39300", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-1.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -0,0 +1,125 @@\n+// Verify the correctness of folding relational expressions involving\n+// pointers to array elements and struct data members and null pointers.\n+// Although the C semantics of relational expressions are only defined\n+// for pointers to objects, C++ makes them well-defined when\n+// (nullptr < p) yields true.  See the discussion of the patch for\n+// c++/67376 on gcc-patches for additional background.\n+\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fdump-tree-optimized\" }\n+\n+// Runtime assert.  Used for potentially invalid expressions.\n+#define RA(e)  ((e) ? (void)0 : __builtin_abort ())\n+\n+// Static assert.  Used for valid core constant expressions.\n+#define SA(e)  static_assert ((e), #e)\n+\n+void test_first_array_element ()\n+{\n+  static constexpr int a[] = { 0 };\n+  constexpr const int *null = 0;\n+  constexpr const int *pi = a;\n+\n+  // The following are valid constant expressions since in &*pi\n+  // the '&*' \"cancel each other out.\"\n+  SA (!(null == &*pi));\n+  SA ( (null != &*pi));\n+\n+  // The validity of the relational expressions involving null\n+  // pointers in a constexpr context is questionable.  Use a run\n+  // time assertion to verify these.\n+  RA ( (null <  &*pi));\n+  RA ( (null <= &*pi));\n+  RA (!(null >  &*pi));\n+  RA (!(null >= &*pi));\n+\n+  SA (!(&*pi == null));\n+  SA ( (&*pi != null));\n+  RA (!(&*pi <  null));\n+  RA (!(&*pi <= null));\n+  RA ( (&*pi >  null));\n+  RA ( (&*pi >= null));\n+\n+  // The following are valid constant expressions since &pi [0] is\n+  // equivalent to &*pi.\n+  SA (!(null == &pi [0]));\n+  SA ( (null != &pi [0]));\n+  RA ( (null <  &pi [0]));\n+  RA ( (null <= &pi [0]));\n+  RA (!(null >  &pi [0]));\n+  RA (!(null >= &pi [0]));\n+\n+  SA (!(&pi [0] == null));\n+  SA ( (&pi [0] != null));\n+  RA (!(&pi [0] <  null));\n+  RA (!(&pi [0] <= null));\n+  RA ( (&pi [0] >  null));\n+  RA ( (&pi [0] >= null));\n+}\n+\n+void test_first_null_array_element ()\n+{\n+  constexpr const int *pi = 0;\n+  constexpr const int *qi = 0;\n+\n+  // The following are valid constant expressions since in &*qi\n+  // the '&*' \"cancel each other out.\"\n+  SA ( (pi == &*qi));\n+  SA (!(pi != &*qi));\n+\n+  // The validity of the relational expressions involving null\n+  // pointers in a constexpr context is questionable.\n+  RA (!(pi <  &*qi));\n+  RA ( (pi <= &*qi));\n+  RA (!(pi >  &*qi));\n+  RA ( (pi >= &*qi));\n+\n+  SA ( (&*qi == pi));\n+  SA (!(&*qi != pi));\n+  RA (!(&*qi <  pi));\n+  RA ( (&*qi <= pi));\n+  RA (!(&*qi >  pi));\n+  RA ( (&*qi >= pi));\n+\n+  // The following are valid constant expressions since &qi [0] is\n+  // equivalent to &*qi.\n+  SA ( (pi == &qi [0]));\n+  SA (!(pi != &qi [0]));\n+  RA (!(pi <  &qi [0]));\n+  RA ( (pi <= &qi [0]));\n+  RA (!(pi >  &qi [0]));\n+  RA ( (pi >= &qi [0]));\n+\n+  SA ( (&qi [0] == pi));\n+  SA (!(&qi [0] != pi));\n+  RA (!(&qi [0] <  pi));\n+  RA ( (&qi [0] <= pi));\n+  RA (!(&qi [0] >  pi));\n+  RA ( (&qi [0] >= pi));\n+}\n+\n+void test_first_struct_member ()\n+{\n+  static struct S { int a, b; } s = { 0, 0 };\n+\n+  constexpr const int *p = 0;\n+  constexpr const S   *q = &s;\n+\n+  SA (!(p == &q->b));\n+  SA ( (p != &q->b));\n+  RA ( (p <  &q->b));\n+  RA ( (p <= &q->b));\n+  RA (!(p >  &q->b));\n+  RA (!(p >= &q->b));\n+\n+  SA (!(&q->b == p));\n+  SA ( (&q->b != p));\n+  RA (!(&q->b <  p));\n+  RA (!(&q->b <= p));\n+  RA ( (&q->b >  p));\n+  RA ( (&q->b >= p));\n+}\n+\n+// Expect all runtime asserts to have been eliminated as a result\n+// of the tested expressions constant folded into true.\n+// { dg-final { scan-assembler-not \"abort\" } }"}, {"sha": "41fa4664ed68ed288196ee20b31c7faeb21f0b90", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-string.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-string.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-string.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-string.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -2,4 +2,4 @@\n \n constexpr char c1 = \"hi\"[1];\n constexpr char c2 = \"hi\"[2];\n-constexpr char c3 = \"hi\"[3];\t// { dg-error \"out of bound\" }\n+constexpr char c3 = \"hi\"[3];\t// { dg-error \"array subscript\" }"}, {"sha": "4055e0ee8ecaaa6d1bcba041466b74625b2dcafa", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-wstring2.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-wstring2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-wstring2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-wstring2.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -1,6 +1,6 @@\n // PR c++/48570\n // { dg-do compile { target c++11 } }\n \n-constexpr wchar_t c1 = L\"hi\"[3];\t// { dg-error \"out of bound\" }\n-constexpr char16_t c2 = u\"hi\"[3];\t// { dg-error \"out of bound\" }\n-constexpr char32_t c3 = U\"hi\"[3];\t// { dg-error \"out of bound\" }\n+constexpr wchar_t c1 = L\"hi\"[3];\t// { dg-error \"array subscript\" }\n+constexpr char16_t c2 = u\"hi\"[3];\t// { dg-error \"array subscript\" }\n+constexpr char32_t c3 = U\"hi\"[3];\t// { dg-error \"array subscript\" }"}, {"sha": "6bd34a4ffcad6422ffbd4e1d7f710c63c16b91b4", "filename": "gcc/testsuite/g++.dg/cpp0x/pr65398.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65398.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65398.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65398.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -12,12 +12,12 @@ constexpr char c5 = *(&s[2] + 0);\n constexpr char c6 = *(&s[0] + 2);\n constexpr char c7 = *(&s[2] + 1);\n \n-constexpr char d1 = *(&s[4] - 0); // { dg-error \"array subscript out of bound\" }\n+constexpr char d1 = *(&s[4] - 0); // { dg-error \"array subscript\" }\n constexpr char d2 = *(&s[4] - 1);\n constexpr char d3 = *(&s[4] - 2);\n constexpr char d4 = *(&s[4] - 3);\n constexpr char d5 = *(&s[4] - 4);\n-constexpr char d6 = *(&s[4] - 5);  // { dg-error \"negative array subscript\" }\n+constexpr char d6 = *(&s[4] - 5);  // { dg-error \"array subscript\" }\n \n /* Don't accept invalid stuff.  */\n constexpr char e1 = *(&s[5] - 1); // { dg-error \"is not a constant expression\" }\n@@ -45,12 +45,12 @@ constexpr int i5 = *(&l[2] + 0);\n constexpr int i6 = *(&l[0] + 2);\n constexpr int i7 = *(&l[2] + 1);\n \n-constexpr char j1 = *(&l[4] - 0); // { dg-error \"array subscript out of bound\" }\n+constexpr char j1 = *(&l[4] - 0); // { dg-error \"array subscript\" }\n constexpr char j2 = *(&l[4] - 1);\n constexpr char j3 = *(&l[4] - 2);\n constexpr char j4 = *(&l[4] - 3);\n constexpr char j5 = *(&l[4] - 4);\n-constexpr char j6 = *(&l[4] - 5);  // { dg-error \"negative array subscript\" }\n+constexpr char j6 = *(&l[4] - 5);  // { dg-error \"array subscript\" }\n \n /* Don't accept invalid stuff.  */\n constexpr char k1 = *(&l[5] - 1); // { dg-error \"is not a constant expression\" }"}, {"sha": "21eb93dc65429c34ed1f74adc48980062d362a75", "filename": "gcc/testsuite/g++.dg/ext/constexpr-vla1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla1.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -27,4 +27,4 @@ fn_not_ok (int n)\n }\n \n constexpr int n1 = fn_ok (3);\n-constexpr int n2 = fn_not_ok (3); // { dg-error \"array subscript out of bound\" }\n+constexpr int n2 = fn_not_ok (3); // { dg-error \"array subscript\" }"}, {"sha": "6aab18436d52836a49e35968354a1fd3354d9028", "filename": "gcc/testsuite/g++.dg/ext/constexpr-vla2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla2.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -18,4 +18,4 @@ fn_ok (int n)\n }\n \n constexpr int i1 = fn_ok (3);\n-constexpr int i2 = fn_bad (3); // { dg-error \"array subscript out of bound\" }\n+constexpr int i2 = fn_bad (3); // { dg-error \"array subscript\" }"}, {"sha": "33fc968ad5a6e536f875a813990b1d31daecba8d", "filename": "gcc/testsuite/g++.dg/ext/constexpr-vla3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla3.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -11,4 +11,4 @@ foo (int n)\n   return z;\n }\n \n-constexpr int n = foo (3); // { dg-error \"array subscript out of bound\" }\n+constexpr int n = foo (3); // { dg-error \"array subscript\" }"}, {"sha": "90360be112a03b03ebeab06c3812815250ec18e1", "filename": "gcc/testsuite/g++.dg/ubsan/pr63956.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc16c867080c5bd4dbbce2caf0d08e729255a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C?ref=abdc16c867080c5bd4dbbce2caf0d08e729255a0", "patch": "@@ -86,7 +86,7 @@ fn5 (const int *a, int b)\n \n constexpr int m1[4] = { 1, 2, 3, 4 };\n constexpr int m2 = fn5 (m1, 3);\n-constexpr int m3 = fn5 (m1, 4); // { dg-error \"array subscript out of bound\" }\n+constexpr int m3 = fn5 (m1, 4); // { dg-error \"array subscript\" }\n \n constexpr int\n fn6 (const int &a, int b)\n@@ -116,7 +116,7 @@ fn8 (int i)\n }\n \n constexpr int o1 = fn8 (9);\n-constexpr int o2 = fn8 (10); // { dg-error \"array subscript out of bound\" }\n+constexpr int o2 = fn8 (10); // { dg-error \"array subscript\" }\n \n constexpr int\n fn9 (int a, int b)"}]}