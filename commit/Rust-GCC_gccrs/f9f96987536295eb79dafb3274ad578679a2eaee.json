{"sha": "f9f96987536295eb79dafb3274ad578679a2eaee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmOTY5ODc1MzYyOTVlYjc5ZGFmYjMyNzRhZDU3ODY3OWEyZWFlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-06T21:47:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-06T21:47:49Z"}, "message": "compiler, runtime: Implement struct and array comparisons.\n\nFrom-SVN: r182971", "tree": {"sha": "7ff2e7efed850e645b91f841d36c555604c40441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ff2e7efed850e645b91f841d36c555604c40441"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9f96987536295eb79dafb3274ad578679a2eaee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f96987536295eb79dafb3274ad578679a2eaee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f96987536295eb79dafb3274ad578679a2eaee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f96987536295eb79dafb3274ad578679a2eaee/comments", "author": null, "committer": null, "parents": [{"sha": "4b6aaa996e0d8f5abac818315b6f77cb3596db98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6aaa996e0d8f5abac818315b6f77cb3596db98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6aaa996e0d8f5abac818315b6f77cb3596db98"}], "stats": {"total": 2108, "additions": 1864, "deletions": 244}, "files": [{"sha": "382f5a1c1567793d2fe7c4cde0f7d3bcc977e295", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -379,9 +379,9 @@ class Backend\n   // must be a pointer to this struct type.\n   // \n   // We must create the named structure before we know its\n-  // initializer, because the initializer refer to its own address.\n-  // After calling this the frontend will call\n-  // set_immutable_struct_initializer.\n+  // initializer, because the initializer may refer to its own\n+  // address.  After calling this the frontend will call\n+  // immutable_struct_set_init.\n   virtual Bvariable*\n   immutable_struct(const std::string& name, bool is_common, Btype* type,\n \t\t   Location) = 0;\n@@ -400,8 +400,8 @@ class Backend\n \n   // Create a reference to a named immutable initialized data\n   // structure defined in some other package.  This will be a\n-  // structure created by a call to immutable_struct_expression with\n-  // the same NAME and TYPE and with IS_COMMON passed as false.  This\n+  // structure created by a call to immutable_struct with the same\n+  // NAME and TYPE and with IS_COMMON passed as false.  This\n   // corresponds to an extern const global variable in C.\n   virtual Bvariable*\n   immutable_struct_reference(const std::string& name, Btype* type,"}, {"sha": "84c18a3f44090f7744e0222892e6ad0cd4e212f9", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 289, "deletions": 46, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -1135,6 +1135,63 @@ Expression::make_temporary_reference(Temporary_statement* statement,\n   return new Temporary_reference_expression(statement, location);\n }\n \n+// Class Set_and_use_temporary_expression.\n+\n+// Return the type.\n+\n+Type*\n+Set_and_use_temporary_expression::do_type()\n+{\n+  return this->statement_->type();\n+}\n+\n+// Take the address.\n+\n+void\n+Set_and_use_temporary_expression::do_address_taken(bool)\n+{\n+  this->statement_->set_is_address_taken();\n+}\n+\n+// Return the backend representation.\n+\n+tree\n+Set_and_use_temporary_expression::do_get_tree(Translate_context* context)\n+{\n+  Bvariable* bvar = this->statement_->get_backend_variable(context);\n+  tree var_tree = var_to_tree(bvar);\n+  tree expr_tree = this->expr_->get_tree(context);\n+  if (var_tree == error_mark_node || expr_tree == error_mark_node)\n+    return error_mark_node;\n+  Location loc = this->location();\n+  return build2_loc(loc.gcc_location(), COMPOUND_EXPR, TREE_TYPE(var_tree),\n+\t\t    build2_loc(loc.gcc_location(), MODIFY_EXPR, void_type_node,\n+\t\t\t       var_tree, expr_tree),\n+\t\t    var_tree);\n+}\n+\n+// Dump.\n+\n+void\n+Set_and_use_temporary_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << '(';\n+  ast_dump_context->dump_temp_variable_name(this->statement_);\n+  ast_dump_context->ostream() << \" = \";\n+  this->expr_->dump_expression(ast_dump_context);\n+  ast_dump_context->ostream() << ')';\n+}\n+\n+// Make a set-and-use temporary.\n+\n+Set_and_use_temporary_expression*\n+Expression::make_set_and_use_temporary(Temporary_statement* statement,\n+\t\t\t\t       Expression* expr, Location location)\n+{\n+  return new Set_and_use_temporary_expression(statement, expr, location);\n+}\n+\n // A sink expression--a use of the blank identifier _.\n \n class Sink_expression : public Expression\n@@ -4468,11 +4525,38 @@ Unary_expression::do_check_types(Gogo*)\n tree\n Unary_expression::do_get_tree(Translate_context* context)\n {\n+  Location loc = this->location();\n+\n+  // Taking the address of a set-and-use-temporary expression requires\n+  // setting the temporary and then taking the address.\n+  if (this->op_ == OPERATOR_AND)\n+    {\n+      Set_and_use_temporary_expression* sut =\n+\tthis->expr_->set_and_use_temporary_expression();\n+      if (sut != NULL)\n+\t{\n+\t  Temporary_statement* temp = sut->temporary();\n+\t  Bvariable* bvar = temp->get_backend_variable(context);\n+\t  tree var_tree = var_to_tree(bvar);\n+\t  Expression* val = sut->expression();\n+\t  tree val_tree = val->get_tree(context);\n+\t  if (var_tree == error_mark_node || val_tree == error_mark_node)\n+\t    return error_mark_node;\n+\t  tree addr_tree = build_fold_addr_expr_loc(loc.gcc_location(),\n+\t\t\t\t\t\t    var_tree);\n+\t  return build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n+\t\t\t    TREE_TYPE(addr_tree),\n+\t\t\t    build2_loc(sut->location().gcc_location(),\n+\t\t\t\t       MODIFY_EXPR, void_type_node,\n+\t\t\t\t       var_tree, val_tree),\n+\t\t\t    addr_tree);\n+\t}\n+    }\n+\n   tree expr = this->expr_->get_tree(context);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n-  Location loc = this->location();\n   switch (this->op_)\n     {\n     case OPERATOR_PLUS:\n@@ -5398,7 +5482,8 @@ Binary_expression::eval_complex(Operator op, Type* left_type,\n // constants.\n \n Expression*\n-Binary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n+Binary_expression::do_lower(Gogo* gogo, Named_object*,\n+\t\t\t    Statement_inserter* inserter, int)\n {\n   Location location = this->location();\n   Operator op = this->op_;\n@@ -5727,9 +5812,183 @@ Binary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       mpz_clear(right_val);\n     }\n \n+  // Lower struct and array comparisons.\n+  if (op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ)\n+    {\n+      if (left->type()->struct_type() != NULL)\n+\treturn this->lower_struct_comparison(gogo, inserter);\n+      else if (left->type()->array_type() != NULL\n+\t       && !left->type()->is_slice_type())\n+\treturn this->lower_array_comparison(gogo, inserter);\n+    }\n+\n   return this;\n }\n \n+// Lower a struct comparison.\n+\n+Expression*\n+Binary_expression::lower_struct_comparison(Gogo* gogo,\n+\t\t\t\t\t   Statement_inserter* inserter)\n+{\n+  Struct_type* st = this->left_->type()->struct_type();\n+  Struct_type* st2 = this->right_->type()->struct_type();\n+  if (st2 == NULL)\n+    return this;\n+  if (st != st2 && !Type::are_identical(st, st2, false, NULL))\n+    return this;\n+  if (!Type::are_compatible_for_comparison(true, this->left_->type(),\n+\t\t\t\t\t   this->right_->type(), NULL))\n+    return this;\n+\n+  // See if we can compare using memcmp.  As a heuristic, we use\n+  // memcmp rather than field references and comparisons if there are\n+  // more than two fields.\n+  if (st->compare_is_identity() && st->total_field_count() > 2)\n+    return this->lower_compare_to_memcmp(gogo, inserter);\n+\n+  Location loc = this->location();\n+\n+  Expression* left = this->left_;\n+  Temporary_statement* left_temp = NULL;\n+  if (left->var_expression() == NULL\n+      && left->temporary_reference_expression() == NULL)\n+    {\n+      left_temp = Statement::make_temporary(left->type(), NULL, loc);\n+      inserter->insert(left_temp);\n+      left = Expression::make_set_and_use_temporary(left_temp, left, loc);\n+    }\n+\n+  Expression* right = this->right_;\n+  Temporary_statement* right_temp = NULL;\n+  if (right->var_expression() == NULL\n+      && right->temporary_reference_expression() == NULL)\n+    {\n+      right_temp = Statement::make_temporary(right->type(), NULL, loc);\n+      inserter->insert(right_temp);\n+      right = Expression::make_set_and_use_temporary(right_temp, right, loc);\n+    }\n+\n+  Expression* ret = Expression::make_boolean(true, loc);\n+  const Struct_field_list* fields = st->fields();\n+  unsigned int field_index = 0;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf, ++field_index)\n+    {\n+      if (field_index > 0)\n+\t{\n+\t  if (left_temp == NULL)\n+\t    left = left->copy();\n+\t  else\n+\t    left = Expression::make_temporary_reference(left_temp, loc);\n+\t  if (right_temp == NULL)\n+\t    right = right->copy();\n+\t  else\n+\t    right = Expression::make_temporary_reference(right_temp, loc);\n+\t}\n+      Expression* f1 = Expression::make_field_reference(left, field_index,\n+\t\t\t\t\t\t\tloc);\n+      Expression* f2 = Expression::make_field_reference(right, field_index,\n+\t\t\t\t\t\t\tloc);\n+      Expression* cond = Expression::make_binary(OPERATOR_EQEQ, f1, f2, loc);\n+      ret = Expression::make_binary(OPERATOR_ANDAND, ret, cond, loc);\n+    }\n+\n+  if (this->op_ == OPERATOR_NOTEQ)\n+    ret = Expression::make_unary(OPERATOR_NOT, ret, loc);\n+\n+  return ret;\n+}\n+\n+// Lower an array comparison.\n+\n+Expression*\n+Binary_expression::lower_array_comparison(Gogo* gogo,\n+\t\t\t\t\t  Statement_inserter* inserter)\n+{\n+  Array_type* at = this->left_->type()->array_type();\n+  Array_type* at2 = this->right_->type()->array_type();\n+  if (at2 == NULL)\n+    return this;\n+  if (at != at2 && !Type::are_identical(at, at2, false, NULL))\n+    return this;\n+  if (!Type::are_compatible_for_comparison(true, this->left_->type(),\n+\t\t\t\t\t   this->right_->type(), NULL))\n+    return this;\n+\n+  // Call memcmp directly if possible.  This may let the middle-end\n+  // optimize the call.\n+  if (at->compare_is_identity())\n+    return this->lower_compare_to_memcmp(gogo, inserter);\n+\n+  // Call the array comparison function.\n+  Named_object* hash_fn;\n+  Named_object* equal_fn;\n+  at->type_functions(gogo, this->left_->type()->named_type(), NULL, NULL,\n+\t\t     &hash_fn, &equal_fn);\n+\n+  Location loc = this->location();\n+\n+  Expression* func = Expression::make_func_reference(equal_fn, NULL, loc);\n+\n+  Expression_list* args = new Expression_list();\n+  args->push_back(this->operand_address(inserter, this->left_));\n+  args->push_back(this->operand_address(inserter, this->right_));\n+  args->push_back(Expression::make_type_info(at, TYPE_INFO_SIZE));\n+\n+  Expression* ret = Expression::make_call(func, args, false, loc);\n+\n+  if (this->op_ == OPERATOR_NOTEQ)\n+    ret = Expression::make_unary(OPERATOR_NOT, ret, loc);\n+\n+  return ret;\n+}\n+\n+// Lower a struct or array comparison to a call to memcmp.\n+\n+Expression*\n+Binary_expression::lower_compare_to_memcmp(Gogo*, Statement_inserter* inserter)\n+{\n+  Location loc = this->location();\n+\n+  Expression* a1 = this->operand_address(inserter, this->left_);\n+  Expression* a2 = this->operand_address(inserter, this->right_);\n+  Expression* len = Expression::make_type_info(this->left_->type(),\n+\t\t\t\t\t       TYPE_INFO_SIZE);\n+\n+  Expression* call = Runtime::make_call(Runtime::MEMCMP, loc, 3, a1, a2, len);\n+\n+  mpz_t zval;\n+  mpz_init_set_ui(zval, 0);\n+  Expression* zero = Expression::make_integer(&zval, NULL, loc);\n+  mpz_clear(zval);\n+\n+  return Expression::make_binary(this->op_, call, zero, loc);\n+}\n+\n+// Return the address of EXPR, cast to unsafe.Pointer.\n+\n+Expression*\n+Binary_expression::operand_address(Statement_inserter* inserter,\n+\t\t\t\t   Expression* expr)\n+{\n+  Location loc = this->location();\n+\n+  if (!expr->is_addressable())\n+    {\n+      Temporary_statement* temp = Statement::make_temporary(expr->type(), NULL,\n+\t\t\t\t\t\t\t    loc);\n+      inserter->insert(temp);\n+      expr = Expression::make_set_and_use_temporary(temp, expr, loc);\n+    }\n+  expr = Expression::make_unary(OPERATOR_AND, expr, loc);\n+  static_cast<Unary_expression*>(expr)->set_does_not_escape();\n+  Type* void_type = Type::make_void_type();\n+  Type* unsafe_pointer_type = Type::make_pointer_type(void_type);\n+  return Expression::make_cast(unsafe_pointer_type, expr, loc);\n+}\n+\n // Return the integer constant value, if it has one.\n \n bool\n@@ -6072,49 +6331,28 @@ Binary_expression::check_operator_type(Operator op, Type* type, Type* otype,\n \n     case OPERATOR_EQEQ:\n     case OPERATOR_NOTEQ:\n-      if (type->integer_type() == NULL\n-\t  && type->float_type() == NULL\n-\t  && type->complex_type() == NULL\n-\t  && !type->is_string_type()\n-\t  && type->points_to() == NULL\n-\t  && !type->is_nil_type()\n-\t  && !type->is_boolean_type()\n-\t  && type->interface_type() == NULL\n-\t  && (type->array_type() == NULL\n-\t      || type->array_type()->length() != NULL)\n-\t  && type->map_type() == NULL\n-\t  && type->channel_type() == NULL\n-\t  && type->function_type() == NULL)\n-\t{\n-\t  error_at(location,\n-\t\t   (\"expected integer, floating, complex, string, pointer, \"\n-\t\t    \"boolean, interface, slice, map, channel, \"\n-\t\t    \"or function type\"));\n-\t  return false;\n-\t}\n-      if ((type->is_slice_type()\n-\t   || type->map_type() != NULL\n-\t   || type->function_type() != NULL)\n-\t  && !otype->is_nil_type())\n-\t{\n-\t  error_at(location,\n-\t\t   (\"slice, map, and function types may only \"\n-\t\t    \"be compared to nil\"));\n-\t  return false;\n-\t}\n+      {\n+\tstd::string reason;\n+\tif (!Type::are_compatible_for_comparison(true, type, otype, &reason))\n+\t  {\n+\t    error_at(location, \"%s\", reason.c_str());\n+\t    return false;\n+\t  }\n+      }\n       break;\n \n     case OPERATOR_LT:\n     case OPERATOR_LE:\n     case OPERATOR_GT:\n     case OPERATOR_GE:\n-      if (type->integer_type() == NULL\n-\t  && type->float_type() == NULL\n-\t  && !type->is_string_type())\n-\t{\n-\t  error_at(location, \"expected integer, floating, or string type\");\n-\t  return false;\n-\t}\n+      {\n+\tstd::string reason;\n+\tif (!Type::are_compatible_for_comparison(false, type, otype, &reason))\n+\t  {\n+\t    error_at(location, \"%s\", reason.c_str());\n+\t    return false;\n+\t  }\n+      }\n       break;\n \n     case OPERATOR_PLUS:\n@@ -12740,10 +12978,10 @@ class Composite_literal_expression : public Parser_expression\n   lower_struct(Gogo*, Type*);\n \n   Expression*\n-  lower_array(Type*);\n+  lower_array(Gogo*, Type*);\n \n   Expression*\n-  make_array(Type*, Expression_list*);\n+  make_array(Gogo*, Type*, Expression_list*);\n \n   Expression*\n   lower_map(Gogo*, Named_object*, Statement_inserter*, Type*);\n@@ -12810,7 +13048,7 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n   else if (type->struct_type() != NULL)\n     ret = this->lower_struct(gogo, type);\n   else if (type->array_type() != NULL)\n-    ret = this->lower_array(type);\n+    ret = this->lower_array(gogo, type);\n   else if (type->map_type() != NULL)\n     ret = this->lower_map(gogo, function, inserter, type);\n   else\n@@ -13023,11 +13261,11 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n // Lower an array composite literal.\n \n Expression*\n-Composite_literal_expression::lower_array(Type* type)\n+Composite_literal_expression::lower_array(Gogo* gogo, Type* type)\n {\n   Location location = this->location();\n   if (this->vals_ == NULL || !this->has_keys_)\n-    return this->make_array(type, this->vals_);\n+    return this->make_array(gogo, type, this->vals_);\n \n   std::vector<Expression*> vals;\n   vals.reserve(this->vals_->size());\n@@ -13127,14 +13365,15 @@ Composite_literal_expression::lower_array(Type* type)\n   for (size_t i = 0; i < size; ++i)\n     list->push_back(vals[i]);\n \n-  return this->make_array(type, list);\n+  return this->make_array(gogo, type, list);\n }\n \n // Actually build the array composite literal. This handles\n // [...]{...}.\n \n Expression*\n-Composite_literal_expression::make_array(Type* type, Expression_list* vals)\n+Composite_literal_expression::make_array(Gogo* gogo, Type* type,\n+\t\t\t\t\t Expression_list* vals)\n {\n   Location location = this->location();\n   Array_type* at = type->array_type();\n@@ -13146,6 +13385,10 @@ Composite_literal_expression::make_array(Type* type, Expression_list* vals)\n       Expression* elen = Expression::make_integer(&vlen, NULL, location);\n       mpz_clear(vlen);\n       at = Type::make_array_type(at->element_type(), elen);\n+\n+      // This is after the finalize_methods pass, so run that now.\n+      at->finalize_methods(gogo);\n+\n       type = at;\n     }\n   if (at->length() != NULL)"}, {"sha": "668f8a14693d9b172df991f6ed8d5f87c78dd193", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -25,6 +25,7 @@ class Struct_field;\n class Expression_list;\n class Var_expression;\n class Temporary_reference_expression;\n+class Set_and_use_temporary_expression;\n class String_expression;\n class Binary_expression;\n class Call_expression;\n@@ -60,6 +61,7 @@ class Expression\n     EXPRESSION_CONST_REFERENCE,\n     EXPRESSION_VAR_REFERENCE,\n     EXPRESSION_TEMPORARY_REFERENCE,\n+    EXPRESSION_SET_AND_USE_TEMPORARY,\n     EXPRESSION_SINK,\n     EXPRESSION_FUNC_REFERENCE,\n     EXPRESSION_UNKNOWN_REFERENCE,\n@@ -134,6 +136,13 @@ class Expression\n   static Temporary_reference_expression*\n   make_temporary_reference(Temporary_statement*, Location);\n \n+  // Make an expressions which sets a temporary variable and then\n+  // evaluates to a reference to that temporary variable.  This is\n+  // used to set a temporary variable while retaining the order of\n+  // evaluation.\n+  static Set_and_use_temporary_expression*\n+  make_set_and_use_temporary(Temporary_statement*, Expression*, Location);\n+\n   // Make a sink expression--a reference to the blank identifier _.\n   static Expression*\n   make_sink(Location);\n@@ -396,6 +405,15 @@ class Expression\n \t\t\t EXPRESSION_TEMPORARY_REFERENCE>();\n   }\n \n+  // If this is a set-and-use-temporary, return the\n+  // Set_and_use_temporary_expression.  Otherwise, return NULL.\n+  Set_and_use_temporary_expression*\n+  set_and_use_temporary_expression()\n+  {\n+    return this->convert<Set_and_use_temporary_expression,\n+\t\t\t EXPRESSION_SET_AND_USE_TEMPORARY>();\n+  }\n+\n   // Return whether this is a sink expression.\n   bool\n   is_sink_expression() const\n@@ -1021,6 +1039,62 @@ class Temporary_reference_expression : public Expression\n   bool is_lvalue_;\n };\n \n+// Set and use a temporary variable.\n+\n+class Set_and_use_temporary_expression : public Expression\n+{\n+ public:\n+  Set_and_use_temporary_expression(Temporary_statement* statement,\n+\t\t\t\t   Expression* expr, Location location)\n+    : Expression(EXPRESSION_SET_AND_USE_TEMPORARY, location),\n+      statement_(statement), expr_(expr)\n+  { }\n+\n+  // Return the temporary.\n+  Temporary_statement*\n+  temporary() const\n+  { return this->statement_; }\n+\n+  // Return the expression.\n+  Expression*\n+  expression() const\n+  { return this->expr_; }\n+\n+ protected:\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return make_set_and_use_temporary(this->statement_, this->expr_,\n+\t\t\t\t      this->location());\n+  }\n+\n+  bool\n+  do_is_addressable() const\n+  { return true; }\n+\n+  void\n+  do_address_taken(bool);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The statement where the temporary variable is defined.\n+  Temporary_statement* statement_;\n+  // The expression to assign to the temporary.\n+  Expression* expr_;\n+};\n+\n // A string expression.\n \n class String_expression : public Expression\n@@ -1200,6 +1274,18 @@ class Binary_expression : public Expression\n   do_dump_expression(Ast_dump_context*) const;\n \n  private:\n+  Expression*\n+  lower_struct_comparison(Gogo*, Statement_inserter*);\n+\n+  Expression*\n+  lower_array_comparison(Gogo*, Statement_inserter*);\n+\n+  Expression*\n+  lower_compare_to_memcmp(Gogo*, Statement_inserter*);\n+\n+  Expression*\n+  operand_address(Statement_inserter*, Expression*);\n+\n   // The binary operator to apply.\n   Operator op_;\n   // The left hand side operand."}, {"sha": "bfa3afdfc3c57f3ca340f332c893f62d17b267d1", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -106,6 +106,9 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   // form which is easier to use.\n   ::gogo->lower_parse_tree();\n \n+  // Write out queued up functions for hash and comparison of types.\n+  ::gogo->write_specific_type_functions();\n+\n   // Now that we have seen all the names, verify that types are\n   // correct.\n   ::gogo->verify_types();"}, {"sha": "0a7cd567aa69639a81bddc70350ebd35cebb64bf", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -116,10 +116,10 @@ Gogo::define_builtin_function_trees()\n \t\t\t\t\t  NULL_TREE),\n \t\t true);\n \n-  // We use __builtin_memmove for the predeclared copy function.\n-  define_builtin(BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n-\t\t build_function_type_list(ptr_type_node,\n-\t\t\t\t\t  ptr_type_node,\n+  // We use __builtin_memcmp for struct comparisons.\n+  define_builtin(BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n+\t\t build_function_type_list(integer_type_node,\n+\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t  size_type_node,\n \t\t\t\t\t  NULL_TREE),\n@@ -647,7 +647,8 @@ Gogo::write_globals()\n   this->build_interface_method_tables();\n \n   Bindings* bindings = this->current_bindings();\n-  size_t count = bindings->size_definitions();\n+  size_t count_definitions = bindings->size_definitions();\n+  size_t count = count_definitions;\n \n   tree* vec = new tree[count];\n \n@@ -822,6 +823,10 @@ Gogo::write_globals()\n       || this->is_main_package())\n     this->write_initialization_function(init_fndecl, init_stmt_list);\n \n+  // We should not have seen any new bindings created during the\n+  // conversion.\n+  go_assert(count_definitions == this->current_bindings()->size_definitions());\n+\n   // Pass everything back to the middle-end.\n \n   wrapup_global_declarations(vec, count);"}, {"sha": "eb24947d0bb540c377c4a727340b913516b09542", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -38,6 +38,8 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int int_type_size,\n     unique_prefix_(),\n     unique_prefix_specified_(false),\n     interface_types_(),\n+    specific_type_functions_(),\n+    specific_type_functions_are_written_(false),\n     named_types_are_converted_(false)\n {\n   const Location loc = Linemap::predeclared_location();\n@@ -978,6 +980,16 @@ Gogo::declare_package_type(const std::string& name, Location location)\n   return this->package_->bindings()->add_type_declaration(name, NULL, location);\n }\n \n+// Declare a function at the package level.\n+\n+Named_object*\n+Gogo::declare_package_function(const std::string& name, Function_type* type,\n+\t\t\t       Location location)\n+{\n+  return this->package_->bindings()->add_function_declaration(name, NULL, type,\n+\t\t\t\t\t\t\t      location);\n+}\n+\n // Define a type which was already declared.\n \n void\n@@ -1116,6 +1128,46 @@ Gogo::clear_file_scope()\n     }\n }\n \n+// Queue up a type specific function for later writing.  These are\n+// written out in write_specific_type_functions, called after the\n+// parse tree is lowered.\n+\n+void\n+Gogo::queue_specific_type_function(Type* type, Named_type* name,\n+\t\t\t\t   const std::string& hash_name,\n+\t\t\t\t   Function_type* hash_fntype,\n+\t\t\t\t   const std::string& equal_name,\n+\t\t\t\t   Function_type* equal_fntype)\n+{\n+  go_assert(!this->specific_type_functions_are_written_);\n+  go_assert(!this->in_global_scope());\n+  Specific_type_function* tsf = new Specific_type_function(type, name,\n+\t\t\t\t\t\t\t   hash_name,\n+\t\t\t\t\t\t\t   hash_fntype,\n+\t\t\t\t\t\t\t   equal_name,\n+\t\t\t\t\t\t\t   equal_fntype);\n+  this->specific_type_functions_.push_back(tsf);\n+}\n+\n+// Write out type specific functions.\n+\n+void\n+Gogo::write_specific_type_functions()\n+{\n+  while (!this->specific_type_functions_.empty())\n+    {\n+      Specific_type_function* tsf = this->specific_type_functions_.back();\n+      this->specific_type_functions_.pop_back();\n+      tsf->type->write_specific_type_functions(this, tsf->name,\n+\t\t\t\t\t       tsf->hash_name,\n+\t\t\t\t\t       tsf->hash_fntype,\n+\t\t\t\t\t       tsf->equal_name,\n+\t\t\t\t\t       tsf->equal_fntype);\n+      delete tsf;\n+    }\n+  this->specific_type_functions_are_written_ = true;\n+}\n+\n // Traverse the tree.\n \n void\n@@ -1468,6 +1520,10 @@ Finalize_methods::type(Type* t)\n       t->struct_type()->finalize_methods(this->gogo_);\n       break;\n \n+    case Type::TYPE_ARRAY:\n+      t->array_type()->finalize_methods(this->gogo_);\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "ac1707a0c53e2eb63be5e7824dced71c278c15ed", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -277,6 +277,11 @@ class Gogo\n   Named_object*\n   declare_function(const std::string&, Function_type*, Location);\n \n+  // Declare a function at the package level.  This is used for\n+  // functions generated for a type.\n+  Named_object*\n+  declare_package_function(const std::string&, Function_type*, Location);\n+\n   // Add a label.\n   Label*\n   add_label_definition(const std::string&, Location);\n@@ -364,6 +369,20 @@ class Gogo\n   void\n   clear_file_scope();\n \n+  // Queue up a type-specific function to be written out.  This is\n+  // used when a type-specific function is needed when not at the top\n+  // level.\n+  void\n+  queue_specific_type_function(Type* type, Named_type* name,\n+\t\t\t       const std::string& hash_name,\n+\t\t\t       Function_type* hash_fntype,\n+\t\t\t       const std::string& equal_name,\n+\t\t\t       Function_type* equal_fntype);\n+\n+  // Write out queued specific type functions.\n+  void\n+  write_specific_type_functions();\n+\n   // Traverse the tree.  See the Traverse class.\n   void\n   traverse(Traverse*);\n@@ -603,6 +622,27 @@ class Gogo\n   // Type used to map special names in the sys package.\n   typedef std::map<std::string, std::string> Sys_names;\n \n+  // Type used to queue writing a type specific function.\n+  struct Specific_type_function\n+  {\n+    Type* type;\n+    Named_type* name;\n+    std::string hash_name;\n+    Function_type* hash_fntype;\n+    std::string equal_name;\n+    Function_type* equal_fntype;\n+\n+    Specific_type_function(Type* atype, Named_type* aname,\n+\t\t\t   const std::string& ahash_name,\n+\t\t\t   Function_type* ahash_fntype,\n+\t\t\t   const std::string& aequal_name,\n+\t\t\t   Function_type* aequal_fntype)\n+      : type(atype), name(aname), hash_name(ahash_name),\n+\thash_fntype(ahash_fntype), equal_name(aequal_name),\n+\tequal_fntype(aequal_fntype)\n+    { }\n+  };\n+\n   // The backend generator.\n   Backend* backend_;\n   // The object used to keep track of file names and line numbers.\n@@ -635,6 +675,10 @@ class Gogo\n   bool unique_prefix_specified_;\n   // A list of interface types defined while parsing.\n   std::vector<Interface_type*> interface_types_;\n+  // Type specific functions to write out.\n+  std::vector<Specific_type_function*> specific_type_functions_;\n+  // Whether we are done writing out specific type functions.\n+  bool specific_type_functions_are_written_;\n   // Whether named types have been converted.\n   bool named_types_are_converted_;\n };"}, {"sha": "438864c355986de6f459d63e24f2e1b4a10b399d", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -28,6 +28,9 @@\n // the name.  The third is the parameter types and the fourth is the\n // result types.\n \n+// The standard C memcmp function, used for struct comparisons.\n+DEF_GO_RUNTIME(MEMCMP, \"memcmp\", P3(POINTER, POINTER, UINTPTR), R1(INT))\n+\n // Range over a string, returning the next index.\n DEF_GO_RUNTIME(STRINGITER, \"runtime.stringiter\", P2(STRING, INT), R1(INT))\n "}, {"sha": "334dc336cce0446cbf59954302f9ce9bbe922fa4", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 895, "deletions": 110, "changes": 1005, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -474,6 +474,115 @@ Type::are_compatible_for_binop(const Type* lhs, const Type* rhs)\n   return false;\n }\n \n+// Return true if a value with type T1 may be compared with a value of\n+// type T2.  IS_EQUALITY_OP is true for == or !=, false for <, etc.\n+\n+bool\n+Type::are_compatible_for_comparison(bool is_equality_op, const Type *t1,\n+\t\t\t\t    const Type *t2, std::string *reason)\n+{\n+  if (t1 != t2\n+      && !Type::are_assignable(t1, t2, NULL)\n+      && !Type::are_assignable(t2, t1, NULL))\n+    {\n+      if (reason != NULL)\n+\t*reason = \"incompatible types in binary expression\";\n+      return false;\n+    }\n+\n+  if (!is_equality_op)\n+    {\n+      if (t1->integer_type() == NULL\n+\t  && t1->float_type() == NULL\n+\t  && !t1->is_string_type())\n+\t{\n+\t  if (reason != NULL)\n+\t    *reason = _(\"invalid comparison of non-ordered type\");\n+\t  return false;\n+\t}\n+    }\n+  else if (t1->is_slice_type()\n+\t   || t1->map_type() != NULL\n+\t   || t1->function_type() != NULL\n+\t   || t2->is_slice_type()\n+\t   || t2->map_type() != NULL\n+\t   || t2->function_type() != NULL)\n+    {\n+      if (!t1->is_nil_type() && !t2->is_nil_type())\n+\t{\n+\t  if (reason != NULL)\n+\t    {\n+\t      if (t1->is_slice_type() || t2->is_slice_type())\n+\t\t*reason = _(\"slice can only be compared to nil\");\n+\t      else if (t1->map_type() != NULL || t2->map_type() != NULL)\n+\t\t*reason = _(\"map can only be compared to nil\");\n+\t      else\n+\t\t*reason = _(\"func can only be compared to nil\");\n+\n+\t      // Match 6g error messages.\n+\t      if (t1->interface_type() != NULL || t2->interface_type() != NULL)\n+\t\t{\n+\t\t  char buf[200];\n+\t\t  snprintf(buf, sizeof buf, _(\"invalid operation (%s)\"),\n+\t\t\t   reason->c_str());\n+\t\t  *reason = buf;\n+\t\t}\n+\t    }\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      if (!t1->is_boolean_type()\n+\t  && t1->integer_type() == NULL\n+\t  && t1->float_type() == NULL\n+\t  && t1->complex_type() == NULL\n+\t  && !t1->is_string_type()\n+\t  && t1->points_to() == NULL\n+\t  && t1->channel_type() == NULL\n+\t  && t1->interface_type() == NULL\n+\t  && t1->struct_type() == NULL\n+\t  && t1->array_type() == NULL\n+\t  && !t1->is_nil_type())\n+\t{\n+\t  if (reason != NULL)\n+\t    *reason = _(\"invalid comparison of non-comparable type\");\n+\t  return false;\n+\t}\n+\n+      if (t1->named_type() != NULL)\n+\treturn t1->named_type()->named_type_is_comparable(reason);\n+      else if (t2->named_type() != NULL)\n+\treturn t2->named_type()->named_type_is_comparable(reason);\n+      else if (t1->struct_type() != NULL)\n+\t{\n+\t  const Struct_field_list* fields = t1->struct_type()->fields();\n+\t  for (Struct_field_list::const_iterator p = fields->begin();\n+\t       p != fields->end();\n+\t       ++p)\n+\t    {\n+\t      if (!p->type()->is_comparable())\n+\t\t{\n+\t\t  if (reason != NULL)\n+\t\t    *reason = _(\"invalid comparison of non-comparable struct\");\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+      else if (t1->array_type() != NULL)\n+\t{\n+\t  if (!t1->array_type()->element_type()->is_comparable())\n+\t    {\n+\t      if (reason != NULL)\n+\t\t*reason = _(\"invalid comparison of non-comparable array\");\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n // Return true if a value with type RHS may be assigned to a variable\n // with type LHS.  If CHECK_HIDDEN_FIELDS is true, check whether any\n // hidden fields are modified.  If REASON is not NULL, set *REASON to\n@@ -897,44 +1006,17 @@ Type::make_type_descriptor_var(Gogo* gogo)\n       phash = &ins.first->second;\n     }\n \n-  std::string var_name;\n-  if (nt == NULL)\n-    var_name = this->unnamed_type_descriptor_var_name(gogo);\n-  else\n-    var_name = this->type_descriptor_var_name(gogo);\n+  std::string var_name = this->type_descriptor_var_name(gogo, nt);\n \n   // Build the contents of the type descriptor.\n   Expression* initializer = this->do_type_descriptor(gogo, NULL);\n \n   Btype* initializer_btype = initializer->type()->get_backend(gogo);\n \n-  // See if this type descriptor is defined in a different package.\n-  bool is_defined_elsewhere = false;\n-  if (nt != NULL)\n-    {\n-      if (nt->named_object()->package() != NULL)\n-\t{\n-\t  // This is a named type defined in a different package.  The\n-\t  // type descriptor should be defined in that package.\n-\t  is_defined_elsewhere = true;\n-\t}\n-    }\n-  else\n-    {\n-      if (this->points_to() != NULL\n-\t  && this->points_to()->named_type() != NULL\n-\t  && this->points_to()->named_type()->named_object()->package() != NULL)\n-\t{\n-\t  // This is an unnamed pointer to a named type defined in a\n-\t  // different package.  The descriptor should be defined in\n-\t  // that package.\n-\t  is_defined_elsewhere = true;\n-\t}\n-    }\n-\n   Location loc = nt == NULL ? Linemap::predeclared_location() : nt->location();\n \n-  if (is_defined_elsewhere)\n+  const Package* dummy;\n+  if (this->type_descriptor_defined_elsewhere(nt, &dummy))\n     {\n       this->type_descriptor_var_ =\n \tgogo->backend()->immutable_struct_reference(var_name,\n@@ -984,21 +1066,15 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \t\t\t\t\t     binitializer);\n }\n \n-// Return the name of the type descriptor variable for an unnamed\n-// type.\n+// Return the name of the type descriptor variable.  If NT is not\n+// NULL, use it to get the name.  Otherwise this is an unnamed type.\n \n std::string\n-Type::unnamed_type_descriptor_var_name(Gogo* gogo)\n+Type::type_descriptor_var_name(Gogo* gogo, Named_type* nt)\n {\n-  return \"__go_td_\" + this->mangled_name(gogo);\n-}\n-\n-// Return the name of the type descriptor variable for a named type.\n+  if (nt == NULL)\n+    return \"__go_td_\" + this->mangled_name(gogo);\n \n-std::string\n-Type::type_descriptor_var_name(Gogo* gogo)\n-{\n-  Named_type* nt = this->named_type();\n   Named_object* no = nt->named_object();\n   const Named_object* in_function = nt->in_function();\n   std::string ret = \"__go_tdn_\";\n@@ -1026,6 +1102,39 @@ Type::type_descriptor_var_name(Gogo* gogo)\n   return ret;\n }\n \n+// Return true if this type descriptor is defined in a different\n+// package.  If this returns true it sets *PACKAGE to the package.\n+\n+bool\n+Type::type_descriptor_defined_elsewhere(Named_type* nt,\n+\t\t\t\t\tconst Package** package)\n+{\n+  if (nt != NULL)\n+    {\n+      if (nt->named_object()->package() != NULL)\n+\t{\n+\t  // This is a named type defined in a different package.  The\n+\t  // type descriptor should be defined in that package.\n+\t  *package = nt->named_object()->package();\n+\t  return true;\n+\t}\n+    }\n+  else\n+    {\n+      if (this->points_to() != NULL\n+\t  && this->points_to()->named_type() != NULL\n+\t  && this->points_to()->named_type()->named_object()->package() != NULL)\n+\t{\n+\t  // This is an unnamed pointer to a named type defined in a\n+\t  // different package.  The descriptor should be defined in\n+\t  // that package.\n+\t  *package = this->points_to()->named_type()->named_object()->package();\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n // Return a composite literal for a type descriptor.\n \n Expression*\n@@ -1157,18 +1266,18 @@ Type::make_type_descriptor_type()\n       // The type descriptor type.\n \n       Typed_identifier_list* params = new Typed_identifier_list();\n-      params->push_back(Typed_identifier(\"\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n+      params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n       Typed_identifier_list* results = new Typed_identifier_list();\n       results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n \n       Type* hashfn_type = Type::make_function_type(NULL, params, results, bloc);\n \n       params = new Typed_identifier_list();\n-      params->push_back(Typed_identifier(\"\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n+      params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n       results = new Typed_identifier_list();\n       results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n@@ -1213,67 +1322,278 @@ Type::make_type_descriptor_ptr_type()\n   return ret;\n }\n \n-// Return the names of runtime functions which compute a hash code for\n-// this type and which compare whether two values of this type are\n-// equal.\n+// Set *HASH_FN and *EQUAL_FN to the runtime functions which compute a\n+// hash code for this type and which compare whether two values of\n+// this type are equal.  If NAME is not NULL it is the name of this\n+// type.  HASH_FNTYPE and EQUAL_FNTYPE are the types of these\n+// functions, for convenience; they may be NULL.\n \n void\n-Type::type_functions(const char** hash_fn, const char** equal_fn) const\n+Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n+\t\t     Function_type* equal_fntype, Named_object** hash_fn,\n+\t\t     Named_object** equal_fn)\n {\n-  switch (this->base()->classification())\n+  if (hash_fntype == NULL || equal_fntype == NULL)\n     {\n-    case Type::TYPE_ERROR:\n-    case Type::TYPE_VOID:\n-    case Type::TYPE_NIL:\n-      // These types can not be hashed or compared.\n-      *hash_fn = \"__go_type_hash_error\";\n-      *equal_fn = \"__go_type_equal_error\";\n-      break;\n+      Location bloc = Linemap::predeclared_location();\n \n-    case Type::TYPE_BOOLEAN:\n-    case Type::TYPE_INTEGER:\n-    case Type::TYPE_FLOAT:\n-    case Type::TYPE_COMPLEX:\n-    case Type::TYPE_POINTER:\n-    case Type::TYPE_CHANNEL:\n-      *hash_fn = \"__go_type_hash_identity\";\n-      *equal_fn = \"__go_type_equal_identity\";\n-      break;\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+      Type* void_type = Type::make_void_type();\n+      Type* unsafe_pointer_type = Type::make_pointer_type(void_type);\n \n-    case Type::TYPE_STRING:\n-      *hash_fn = \"__go_type_hash_string\";\n-      *equal_fn = \"__go_type_equal_string\";\n-      break;\n+      if (hash_fntype == NULL)\n+\t{\n+\t  Typed_identifier_list* params = new Typed_identifier_list();\n+\t  params->push_back(Typed_identifier(\"key\", unsafe_pointer_type,\n+\t\t\t\t\t     bloc));\n+\t  params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n-    case Type::TYPE_STRUCT:\n-    case Type::TYPE_ARRAY:\n-    case Type::TYPE_FUNCTION:\n-    case Type::TYPE_MAP:\n-      // These types can not be hashed or compared.\n-      *hash_fn = \"__go_type_hash_error\";\n-      *equal_fn = \"__go_type_equal_error\";\n-      break;\n+\t  Typed_identifier_list* results = new Typed_identifier_list();\n+\t  results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n \n-    case Type::TYPE_INTERFACE:\n-      if (this->interface_type()->is_empty())\n+\t  hash_fntype = Type::make_function_type(NULL, params, results, bloc);\n+\t}\n+      if (equal_fntype == NULL)\n \t{\n-\t  *hash_fn = \"__go_type_hash_empty_interface\";\n-\t  *equal_fn = \"__go_type_equal_empty_interface\";\n+\t  Typed_identifier_list* params = new Typed_identifier_list();\n+\t  params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type,\n+\t\t\t\t\t     bloc));\n+\t  params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type,\n+\t\t\t\t\t     bloc));\n+\t  params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n+\n+\t  Typed_identifier_list* results = new Typed_identifier_list();\n+\t  results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(),\n+\t\t\t\t\t      bloc));\n+\n+\t  equal_fntype = Type::make_function_type(NULL, params, results, bloc);\n \t}\n-      else\n+    }\n+\n+  const char* hash_fnname;\n+  const char* equal_fnname;\n+  if (this->compare_is_identity())\n+    {\n+      hash_fnname = \"__go_type_hash_identity\";\n+      equal_fnname = \"__go_type_equal_identity\";\n+    }\n+  else if (!this->is_comparable())\n+    {\n+      hash_fnname = \"__go_type_hash_error\";\n+      equal_fnname = \"__go_type_equal_error\";\n+    }\n+  else\n+    {\n+      switch (this->base()->classification())\n \t{\n-\t  *hash_fn = \"__go_type_hash_interface\";\n-\t  *equal_fn = \"__go_type_equal_interface\";\n+\tcase Type::TYPE_ERROR:\n+\tcase Type::TYPE_VOID:\n+\tcase Type::TYPE_NIL:\n+\tcase Type::TYPE_FUNCTION:\n+\tcase Type::TYPE_MAP:\n+\t  // For these types is_comparable should have returned false.\n+\t  go_unreachable();\n+\n+\tcase Type::TYPE_BOOLEAN:\n+\tcase Type::TYPE_INTEGER:\n+\tcase Type::TYPE_POINTER:\n+\tcase Type::TYPE_CHANNEL:\n+\t  // For these types compare_is_identity should have returned true.\n+\t  go_unreachable();\n+\n+\tcase Type::TYPE_FLOAT:\n+\t  hash_fnname = \"__go_type_hash_float\";\n+\t  equal_fnname = \"__go_type_equal_float\";\n+\t  break;\n+\n+\tcase Type::TYPE_COMPLEX:\n+\t  hash_fnname = \"__go_type_hash_complex\";\n+\t  equal_fnname = \"__go_type_equal_complex\";\n+\t  break;\n+\n+\tcase Type::TYPE_STRING:\n+\t  hash_fnname = \"__go_type_hash_string\";\n+\t  equal_fnname = \"__go_type_equal_string\";\n+\t  break;\n+\n+\tcase Type::TYPE_STRUCT:\n+\t  {\n+\t    // This is a struct which can not be compared using a\n+\t    // simple identity function.  We need to build a function\n+\t    // for comparison.\n+\t    this->specific_type_functions(gogo, name, hash_fntype,\n+\t\t\t\t\t  equal_fntype, hash_fn, equal_fn);\n+\t    return;\n+\t  }\n+\n+\tcase Type::TYPE_ARRAY:\n+\t  if (this->is_slice_type())\n+\t    {\n+\t      // Type::is_compatible_for_comparison should have\n+\t      // returned false.\n+\t      go_unreachable();\n+\t    }\n+\t  else\n+\t    {\n+\t      // This is an array which can not be compared using a\n+\t      // simple identity function.  We need to build a\n+\t      // function for comparison.\n+\t      this->specific_type_functions(gogo, name, hash_fntype,\n+\t\t\t\t\t    equal_fntype, hash_fn, equal_fn);\n+\t      return;\n+\t    }\n+\t  break;\n+\n+\tcase Type::TYPE_INTERFACE:\n+\t  if (this->interface_type()->is_empty())\n+\t    {\n+\t      hash_fnname = \"__go_type_hash_empty_interface\";\n+\t      equal_fnname = \"__go_type_equal_empty_interface\";\n+\t    }\n+\t  else\n+\t    {\n+\t      hash_fnname = \"__go_type_hash_interface\";\n+\t      equal_fnname = \"__go_type_equal_interface\";\n+\t    }\n+\t  break;\n+\n+\tcase Type::TYPE_NAMED:\n+\tcase Type::TYPE_FORWARD:\n+\t  go_unreachable();\n+\n+\tdefault:\n+\t  go_unreachable();\n \t}\n-      break;\n+    }\n \n-    case Type::TYPE_NAMED:\n-    case Type::TYPE_FORWARD:\n-      go_unreachable();\n \n-    default:\n-      go_unreachable();\n+  Location bloc = Linemap::predeclared_location();\n+  *hash_fn = Named_object::make_function_declaration(hash_fnname, NULL,\n+\t\t\t\t\t\t     hash_fntype, bloc);\n+  (*hash_fn)->func_declaration_value()->set_asm_name(hash_fnname);\n+  *equal_fn = Named_object::make_function_declaration(equal_fnname, NULL,\n+\t\t\t\t\t\t      equal_fntype, bloc);\n+  (*equal_fn)->func_declaration_value()->set_asm_name(equal_fnname);\n+}\n+\n+// A hash table mapping types to the specific hash functions.\n+\n+Type::Type_functions Type::type_functions_table;\n+\n+// Handle a type function which is specific to a type: a struct or\n+// array which can not use an identity comparison.\n+\n+void\n+Type::specific_type_functions(Gogo* gogo, Named_type* name,\n+\t\t\t      Function_type* hash_fntype,\n+\t\t\t      Function_type* equal_fntype,\n+\t\t\t      Named_object** hash_fn,\n+\t\t\t      Named_object** equal_fn)\n+{\n+  Hash_equal_fn fnull(NULL, NULL);\n+  std::pair<Type*, Hash_equal_fn> val(name != NULL ? name : this, fnull);\n+  std::pair<Type_functions::iterator, bool> ins =\n+    Type::type_functions_table.insert(val);\n+  if (!ins.second)\n+    {\n+      // We already have functions for this type\n+      *hash_fn = ins.first->second.first;\n+      *equal_fn = ins.first->second.second;\n+      return;\n     }\n+\n+  std::string base_name;\n+  if (name == NULL)\n+    base_name = gogo->pack_hidden_name(this->mangled_name(gogo), false);\n+  else\n+    {\n+      // This name is already hidden or not as appropriate.\n+      base_name = name->name();\n+      const Named_object* in_function = name->in_function();\n+      if (in_function != NULL)\n+\tbase_name += '$' + in_function->name();\n+    }\n+  std::string hash_name = base_name + \"$hash\";\n+  std::string equal_name = base_name + \"$equal\";\n+\n+  Location bloc = Linemap::predeclared_location();\n+\n+  const Package* package = NULL;\n+  bool is_defined_elsewhere =\n+    this->type_descriptor_defined_elsewhere(name, &package);\n+  if (is_defined_elsewhere)\n+    {\n+      *hash_fn = Named_object::make_function_declaration(hash_name, package,\n+\t\t\t\t\t\t\t hash_fntype, bloc);\n+      *equal_fn = Named_object::make_function_declaration(equal_name, package,\n+\t\t\t\t\t\t\t  equal_fntype, bloc);\n+    }\n+  else\n+    {\n+      *hash_fn = gogo->declare_package_function(hash_name, hash_fntype, bloc);\n+      *equal_fn = gogo->declare_package_function(equal_name, equal_fntype,\n+\t\t\t\t\t\t bloc);\n+    }\n+\n+  ins.first->second.first = *hash_fn;\n+  ins.first->second.second = *equal_fn;\n+\n+  if (!is_defined_elsewhere)\n+    {\n+      if (gogo->in_global_scope())\n+\tthis->write_specific_type_functions(gogo, name, hash_name, hash_fntype,\n+\t\t\t\t\t    equal_name, equal_fntype);\n+      else\n+\tgogo->queue_specific_type_function(this, name, hash_name, hash_fntype,\n+\t\t\t\t\t   equal_name, equal_fntype);\n+    }\n+}\n+\n+// Write the hash and equality functions for a type which needs to be\n+// written specially.\n+\n+void\n+Type::write_specific_type_functions(Gogo* gogo, Named_type* name,\n+\t\t\t\t    const std::string& hash_name,\n+\t\t\t\t    Function_type* hash_fntype,\n+\t\t\t\t    const std::string& equal_name,\n+\t\t\t\t    Function_type* equal_fntype)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  Named_object* hash_fn = gogo->start_function(hash_name, hash_fntype, false,\n+\t\t\t\t\t       bloc);\n+  gogo->start_block(bloc);\n+\n+  if (this->struct_type() != NULL)\n+    this->struct_type()->write_hash_function(gogo, name, hash_fntype,\n+\t\t\t\t\t     equal_fntype);\n+  else if (this->array_type() != NULL)\n+    this->array_type()->write_hash_function(gogo, name, hash_fntype,\n+\t\t\t\t\t    equal_fntype);\n+  else\n+    go_unreachable();\n+\n+  Block* b = gogo->finish_block(bloc);\n+  gogo->add_block(b, bloc);\n+  gogo->lower_block(hash_fn, b);\n+  gogo->finish_function(bloc);\n+\n+  Named_object *equal_fn = gogo->start_function(equal_name, equal_fntype,\n+\t\t\t\t\t\tfalse, bloc);\n+  gogo->start_block(bloc);\n+\n+  if (this->struct_type() != NULL)\n+    this->struct_type()->write_equal_function(gogo, name);\n+  else if (this->array_type() != NULL)\n+    this->array_type()->write_equal_function(gogo, name);\n+  else\n+    go_unreachable();\n+\n+  b = gogo->finish_block(bloc);\n+  gogo->add_block(b, bloc);\n+  gogo->lower_block(equal_fn, b);\n+  gogo->finish_function(bloc);\n }\n \n // Return a composite literal for the type descriptor for a plain type\n@@ -1320,25 +1640,20 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   mpz_set_ui(iv, this->hash_for_method(gogo));\n   vals->push_back(Expression::make_integer(&iv, p->type(), bloc));\n \n-  const char* hash_fn;\n-  const char* equal_fn;\n-  this->type_functions(&hash_fn, &equal_fn);\n-\n   ++p;\n   go_assert(p->is_field_name(\"hashfn\"));\n-  Function_type* fntype = p->type()->function_type();\n-  Named_object* no = Named_object::make_function_declaration(hash_fn, NULL,\n-\t\t\t\t\t\t\t     fntype,\n-\t\t\t\t\t\t\t     bloc);\n-  no->func_declaration_value()->set_asm_name(hash_fn);\n-  vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n+  Function_type* hash_fntype = p->type()->function_type();\n \n   ++p;\n   go_assert(p->is_field_name(\"equalfn\"));\n-  fntype = p->type()->function_type();\n-  no = Named_object::make_function_declaration(equal_fn, NULL, fntype, bloc);\n-  no->func_declaration_value()->set_asm_name(equal_fn);\n-  vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n+  Function_type* equal_fntype = p->type()->function_type();\n+\n+  Named_object* hash_fn;\n+  Named_object* equal_fn;\n+  this->type_functions(gogo, name, hash_fntype, equal_fntype, &hash_fn,\n+\t\t       &equal_fn);\n+  vals->push_back(Expression::make_func_reference(hash_fn, NULL, bloc));\n+  vals->push_back(Expression::make_func_reference(equal_fn, NULL, bloc));\n \n   ++p;\n   go_assert(p->is_field_name(\"string\"));\n@@ -1680,6 +1995,10 @@ class Error_type : public Type\n   { }\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   Btype*\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->error_type(); }\n@@ -1714,6 +2033,10 @@ class Void_type : public Type\n   { }\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   Btype*\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->void_type(); }\n@@ -1748,6 +2071,10 @@ class Boolean_type : public Type\n   { }\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return true; }\n+\n   Btype*\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->bool_type(); }\n@@ -2335,6 +2662,10 @@ class Sink_type : public Type\n   { }\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   Btype*\n   do_get_backend(Gogo*)\n   { go_unreachable(); }\n@@ -3243,6 +3574,10 @@ class Nil_type : public Type\n   { }\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   Btype*\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->pointer_type(gogo->backend()->void_type()); }\n@@ -3290,6 +3625,10 @@ class Call_multiple_result_type : public Type\n     return false;\n   }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   Btype*\n   do_get_backend(Gogo* gogo)\n   {\n@@ -3564,6 +3903,25 @@ Struct_type::struct_has_hidden_fields(const Named_type* within,\n   return false;\n }\n \n+// Whether comparisons of this struct type are simple identity\n+// comparisons.\n+\n+bool\n+Struct_type::do_compare_is_identity() const\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields == NULL)\n+    return true;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    if (!pf->type()->compare_is_identity())\n+      return false;\n+  return true;\n+}\n+\n+// Build identity and hash functions for this struct.\n+\n // Hash code.\n \n unsigned int\n@@ -3779,6 +4137,17 @@ Struct_type::is_unexported_local_field(Gogo* gogo,\n void\n Struct_type::finalize_methods(Gogo* gogo)\n {\n+  // If this type needs explicit comparison and hash functions, create\n+  // them now.  It would be a bit better to do this only if the\n+  // functions are needed, but they will be static so the backend can\n+  // discard them if they are not used.\n+  if (!this->compare_is_identity() && this->is_comparable())\n+    {\n+      Named_object* hash_fn;\n+      Named_object* equal_fn;\n+      this->type_functions(gogo, NULL, NULL, NULL, &hash_fn, &equal_fn);\n+    }\n+\n   if (this->all_methods_ != NULL)\n     return;\n   Type::finalize_methods(gogo, this, this->location_, &this->all_methods_);\n@@ -3952,6 +4321,170 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   return Expression::make_struct_composite_literal(stdt, vals, bloc);\n }\n \n+// Write the hash function for a struct which can not use the identity\n+// function.\n+\n+void\n+Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n+\t\t\t\t Function_type* hash_fntype,\n+\t\t\t\t Function_type* equal_fntype)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  // The pointer to the struct that we are going to hash.  This is an\n+  // argument to the hash function we are implementing here.\n+  Named_object* key_arg = gogo->lookup(\"key\", NULL);\n+  go_assert(key_arg != NULL);\n+  Type* key_arg_type = key_arg->var_value()->type();\n+\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  // Get a 0.\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, 0);\n+  Expression* zero = Expression::make_integer(&ival, uintptr_type, bloc);\n+  mpz_clear(ival);\n+\n+  // Make a temporary to hold the return value, initialized to 0.\n+  Temporary_statement* retval = Statement::make_temporary(uintptr_type, zero,\n+\t\t\t\t\t\t\t  bloc);\n+  gogo->add_statement(retval);\n+\n+  // Make a temporary to hold the key as a uintptr.\n+  Expression* ref = Expression::make_var_reference(key_arg, bloc);\n+  ref = Expression::make_cast(uintptr_type, ref, bloc);\n+  Temporary_statement* key = Statement::make_temporary(uintptr_type, ref,\n+\t\t\t\t\t\t       bloc);\n+  gogo->add_statement(key);\n+\n+  // Loop over the struct fields.\n+  bool first = true;\n+  const Struct_field_list* fields = this->fields_;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    {\n+      if (first)\n+\tfirst = false;\n+      else\n+\t{\n+\t  // Multiply retval by 33.\n+\t  mpz_init_set_ui(ival, 33);\n+\t  Expression* i33 = Expression::make_integer(&ival, uintptr_type,\n+\t\t\t\t\t\t     bloc);\n+\t  mpz_clear(ival);\n+\n+\t  ref = Expression::make_temporary_reference(retval, bloc);\n+\t  Statement* s = Statement::make_assignment_operation(OPERATOR_MULTEQ,\n+\t\t\t\t\t\t\t      ref, i33, bloc);\n+\t  gogo->add_statement(s);\n+\t}\n+\n+      // Get a pointer to the value of this field.\n+      Expression* offset = Expression::make_struct_field_offset(this, &*pf);\n+      ref = Expression::make_temporary_reference(key, bloc);\n+      Expression* subkey = Expression::make_binary(OPERATOR_PLUS, ref, offset,\n+\t\t\t\t\t\t   bloc);\n+      subkey = Expression::make_cast(key_arg_type, subkey, bloc);\n+\n+      // Get the size of this field.\n+      Expression* size = Expression::make_type_info(pf->type(),\n+\t\t\t\t\t\t    Expression::TYPE_INFO_SIZE);\n+\n+      // Get the hash function to use for the type of this field.\n+      Named_object* hash_fn;\n+      Named_object* equal_fn;\n+      pf->type()->type_functions(gogo, pf->type()->named_type(), hash_fntype,\n+\t\t\t\t equal_fntype, &hash_fn, &equal_fn);\n+\n+      // Call the hash function for the field.\n+      Expression_list* args = new Expression_list();\n+      args->push_back(subkey);\n+      args->push_back(size);\n+      Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n+      Expression* call = Expression::make_call(func, args, false, bloc);\n+\n+      // Add the field's hash value to retval.\n+      Temporary_reference_expression* tref =\n+\tExpression::make_temporary_reference(retval, bloc);\n+      tref->set_is_lvalue();\n+      Statement* s = Statement::make_assignment_operation(OPERATOR_PLUSEQ,\n+\t\t\t\t\t\t\t  tref, call, bloc);\n+      gogo->add_statement(s);\n+    }\n+\n+  // Return retval to the caller of the hash function.\n+  Expression_list* vals = new Expression_list();\n+  ref = Expression::make_temporary_reference(retval, bloc);\n+  vals->push_back(ref);\n+  Statement* s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n+// Write the equality function for a struct which can not use the\n+// identity function.\n+\n+void\n+Struct_type::write_equal_function(Gogo* gogo, Named_type* name)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  // The pointers to the structs we are going to compare.\n+  Named_object* key1_arg = gogo->lookup(\"key1\", NULL);\n+  Named_object* key2_arg = gogo->lookup(\"key2\", NULL);\n+  go_assert(key1_arg != NULL && key2_arg != NULL);\n+\n+  // Build temporaries with the right types.\n+  Type* pt = Type::make_pointer_type(name != NULL\n+\t\t\t\t     ? static_cast<Type*>(name)\n+\t\t\t\t     : static_cast<Type*>(this));\n+\n+  Expression* ref = Expression::make_var_reference(key1_arg, bloc);\n+  ref = Expression::make_unsafe_cast(pt, ref, bloc);\n+  Temporary_statement* p1 = Statement::make_temporary(pt, ref, bloc);\n+  gogo->add_statement(p1);\n+\n+  ref = Expression::make_var_reference(key2_arg, bloc);\n+  ref = Expression::make_unsafe_cast(pt, ref, bloc);\n+  Temporary_statement* p2 = Statement::make_temporary(pt, ref, bloc);\n+  gogo->add_statement(p2);\n+\n+  const Struct_field_list* fields = this->fields_;\n+  unsigned int field_index = 0;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf, ++field_index)\n+    {\n+      // Compare one field in both P1 and P2.\n+      Expression* f1 = Expression::make_temporary_reference(p1, bloc);\n+      f1 = Expression::make_unary(OPERATOR_MULT, f1, bloc);\n+      f1 = Expression::make_field_reference(f1, field_index, bloc);\n+\n+      Expression* f2 = Expression::make_temporary_reference(p2, bloc);\n+      f2 = Expression::make_unary(OPERATOR_MULT, f2, bloc);\n+      f2 = Expression::make_field_reference(f2, field_index, bloc);\n+\n+      Expression* cond = Expression::make_binary(OPERATOR_NOTEQ, f1, f2, bloc);\n+\n+      // If the values are not equal, return false.\n+      gogo->start_block(bloc);\n+      Expression_list* vals = new Expression_list();\n+      vals->push_back(Expression::make_boolean(false, bloc));\n+      Statement* s = Statement::make_return_statement(vals, bloc);\n+      gogo->add_statement(s);\n+      Block* then_block = gogo->finish_block(bloc);\n+\n+      s = Statement::make_if_statement(cond, then_block, NULL, bloc);\n+      gogo->add_statement(s);\n+    }\n+\n+  // All the fields are equal, so return true.\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(Expression::make_boolean(true, bloc));\n+  Statement* s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n // Reflection string.\n \n void\n@@ -4190,6 +4723,25 @@ Array_type::is_identical(const Array_type* t, bool errors_are_identical) const\n   return false;\n }\n \n+// If this type needs explicit comparison and hash functions, create\n+// them now.  It would be a bit better to do this only if the\n+// functions are needed, but they will be static so the backend can\n+// discard them if they are not used.\n+\n+void\n+Array_type::finalize_methods(Gogo* gogo)\n+{\n+  if (this->length_ != NULL\n+      && !this->length_->is_nil_expression()\n+      && !this->compare_is_identity()\n+      && this->is_comparable())\n+    {\n+      Named_object* hash_fn;\n+      Named_object* equal_fn;\n+      this->type_functions(gogo, NULL, NULL, NULL, &hash_fn, &equal_fn);\n+    }\n+}\n+\n // Traversal.\n \n int\n@@ -4298,6 +4850,198 @@ Array_type::do_hash_for_method(Gogo* gogo) const\n   return this->element_type_->hash_for_method(gogo) + 1;\n }\n \n+// Write the hash function for an array which can not use the identify\n+// function.\n+\n+void\n+Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n+\t\t\t\tFunction_type* hash_fntype,\n+\t\t\t\tFunction_type* equal_fntype)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  // The pointer to the array that we are going to hash.  This is an\n+  // argument to the hash function we are implementing here.\n+  Named_object* key_arg = gogo->lookup(\"key\", NULL);\n+  go_assert(key_arg != NULL);\n+  Type* key_arg_type = key_arg->var_value()->type();\n+\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  // Get a 0.\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, 0);\n+  Expression* zero = Expression::make_integer(&ival, uintptr_type, bloc);\n+  mpz_clear(ival);\n+\n+  // Make a temporary to hold the return value, initialized to 0.\n+  Temporary_statement* retval = Statement::make_temporary(uintptr_type, zero,\n+\t\t\t\t\t\t\t  bloc);\n+  gogo->add_statement(retval);\n+\n+  // Make a temporary to hold the key as a uintptr.\n+  Expression* ref = Expression::make_var_reference(key_arg, bloc);\n+  ref = Expression::make_cast(uintptr_type, ref, bloc);\n+  Temporary_statement* key = Statement::make_temporary(uintptr_type, ref,\n+\t\t\t\t\t\t       bloc);\n+  gogo->add_statement(key);\n+\n+  // Loop over the array elements.\n+  // for i = range a\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  Temporary_statement* index = Statement::make_temporary(int_type, NULL, bloc);\n+  gogo->add_statement(index);\n+\n+  Expression* iref = Expression::make_temporary_reference(index, bloc);\n+  Expression* aref = Expression::make_var_reference(key_arg, bloc);\n+  Type* pt = Type::make_pointer_type(name != NULL\n+\t\t\t\t     ? static_cast<Type*>(name)\n+\t\t\t\t     : static_cast<Type*>(this));\n+  aref = Expression::make_cast(pt, aref, bloc);\n+  For_range_statement* for_range = Statement::make_for_range_statement(iref,\n+\t\t\t\t\t\t\t\t       NULL,\n+\t\t\t\t\t\t\t\t       aref,\n+\t\t\t\t\t\t\t\t       bloc);\n+\n+  gogo->start_block(bloc);\n+\n+  // Multiply retval by 33.\n+  mpz_init_set_ui(ival, 33);\n+  Expression* i33 = Expression::make_integer(&ival, uintptr_type, bloc);\n+  mpz_clear(ival);\n+\n+  ref = Expression::make_temporary_reference(retval, bloc);\n+  Statement* s = Statement::make_assignment_operation(OPERATOR_MULTEQ, ref,\n+\t\t\t\t\t\t      i33, bloc);\n+  gogo->add_statement(s);\n+\n+  // Get the hash function for the element type.\n+  Named_object* hash_fn;\n+  Named_object* equal_fn;\n+  this->element_type_->type_functions(gogo, this->element_type_->named_type(),\n+\t\t\t\t      hash_fntype, equal_fntype, &hash_fn,\n+\t\t\t\t      &equal_fn);\n+\n+  // Get a pointer to this element in the loop.\n+  Expression* subkey = Expression::make_temporary_reference(key, bloc);\n+  subkey = Expression::make_cast(key_arg_type, subkey, bloc);\n+\n+  // Get the size of each element.\n+  Expression* ele_size = Expression::make_type_info(this->element_type_,\n+\t\t\t\t\t\t    Expression::TYPE_INFO_SIZE);\n+\n+  // Get the hash of this element.\n+  Expression_list* args = new Expression_list();\n+  args->push_back(subkey);\n+  args->push_back(ele_size);\n+  Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n+  Expression* call = Expression::make_call(func, args, false, bloc);\n+\n+  // Add the element's hash value to retval.\n+  Temporary_reference_expression* tref =\n+    Expression::make_temporary_reference(retval, bloc);\n+  tref->set_is_lvalue();\n+  s = Statement::make_assignment_operation(OPERATOR_PLUSEQ, tref, call, bloc);\n+  gogo->add_statement(s);\n+\n+  // Increase the element pointer.\n+  tref = Expression::make_temporary_reference(key, bloc);\n+  tref->set_is_lvalue();\n+  s = Statement::make_assignment_operation(OPERATOR_PLUSEQ, tref, ele_size,\n+\t\t\t\t\t   bloc);\n+\n+  Block* statements = gogo->finish_block(bloc);\n+\n+  for_range->add_statements(statements);\n+  gogo->add_statement(for_range);\n+\n+  // Return retval to the caller of the hash function.\n+  Expression_list* vals = new Expression_list();\n+  ref = Expression::make_temporary_reference(retval, bloc);\n+  vals->push_back(ref);\n+  s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n+// Write the equality function for an array which can not use the\n+// identity function.\n+\n+void\n+Array_type::write_equal_function(Gogo* gogo, Named_type* name)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  // The pointers to the arrays we are going to compare.\n+  Named_object* key1_arg = gogo->lookup(\"key1\", NULL);\n+  Named_object* key2_arg = gogo->lookup(\"key2\", NULL);\n+  go_assert(key1_arg != NULL && key2_arg != NULL);\n+\n+  // Build temporaries for the keys with the right types.\n+  Type* pt = Type::make_pointer_type(name != NULL\n+\t\t\t\t     ? static_cast<Type*>(name)\n+\t\t\t\t     : static_cast<Type*>(this));\n+\n+  Expression* ref = Expression::make_var_reference(key1_arg, bloc);\n+  ref = Expression::make_unsafe_cast(pt, ref, bloc);\n+  Temporary_statement* p1 = Statement::make_temporary(pt, ref, bloc);\n+  gogo->add_statement(p1);\n+\n+  ref = Expression::make_var_reference(key2_arg, bloc);\n+  ref = Expression::make_unsafe_cast(pt, ref, bloc);\n+  Temporary_statement* p2 = Statement::make_temporary(pt, ref, bloc);\n+  gogo->add_statement(p2);\n+\n+  // Loop over the array elements.\n+  // for i = range a\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  Temporary_statement* index = Statement::make_temporary(int_type, NULL, bloc);\n+  gogo->add_statement(index);\n+\n+  Expression* iref = Expression::make_temporary_reference(index, bloc);\n+  Expression* aref = Expression::make_temporary_reference(p1, bloc);\n+  For_range_statement* for_range = Statement::make_for_range_statement(iref,\n+\t\t\t\t\t\t\t\t       NULL,\n+\t\t\t\t\t\t\t\t       aref,\n+\t\t\t\t\t\t\t\t       bloc);\n+\n+  gogo->start_block(bloc);\n+\n+  // Compare element in P1 and P2.\n+  Expression* e1 = Expression::make_temporary_reference(p1, bloc);\n+  e1 = Expression::make_unary(OPERATOR_MULT, e1, bloc);\n+  ref = Expression::make_temporary_reference(index, bloc);\n+  e1 = Expression::make_array_index(e1, ref, NULL, bloc);\n+\n+  Expression* e2 = Expression::make_temporary_reference(p2, bloc);\n+  e2 = Expression::make_unary(OPERATOR_MULT, e2, bloc);\n+  ref = Expression::make_temporary_reference(index, bloc);\n+  e2 = Expression::make_array_index(e2, ref, NULL, bloc);\n+\n+  Expression* cond = Expression::make_binary(OPERATOR_NOTEQ, e1, e2, bloc);\n+\n+  // If the elements are not equal, return false.\n+  gogo->start_block(bloc);\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(Expression::make_boolean(false, bloc));\n+  Statement* s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+  Block* then_block = gogo->finish_block(bloc);\n+\n+  s = Statement::make_if_statement(cond, then_block, NULL, bloc);\n+  gogo->add_statement(s);\n+\n+  Block* statements = gogo->finish_block(bloc);\n+\n+  for_range->add_statements(statements);\n+  gogo->add_statement(for_range);\n+\n+  // All the elements are equal, so return true.\n+  vals = new Expression_list();\n+  vals->push_back(Expression::make_boolean(true, bloc));\n+  s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n // Get a tree for the length of a fixed array.  The length may be\n // computed using a function call, so we must only evaluate it once.\n \n@@ -4730,10 +5474,8 @@ Map_type::do_traverse(Traverse* traverse)\n bool\n Map_type::do_verify()\n {\n-  if (this->key_type_->struct_type() != NULL\n-      || this->key_type_->array_type() != NULL\n-      || this->key_type_->function_type() != NULL\n-      || this->key_type_->map_type() != NULL)\n+  // The runtime support uses \"map[void]void\".\n+  if (!this->key_type_->is_comparable() && !this->key_type_->is_void_type())\n     {\n       error_at(this->location_, \"invalid map key type\");\n       return false;\n@@ -6292,6 +7034,21 @@ Named_type::is_named_error_type() const\n   return ret;\n }\n \n+// Whether this type is comparable.  We have to be careful about\n+// circular type definitions.\n+\n+bool\n+Named_type::named_type_is_comparable(std::string* reason) const\n+{\n+  if (this->seen_)\n+    return false;\n+  this->seen_ = true;\n+  bool ret = Type::are_compatible_for_comparison(true, this->type_,\n+\t\t\t\t\t\t this->type_, reason);\n+  this->seen_ = false;\n+  return ret;\n+}\n+\n // Add a method to this type.\n \n Named_object*\n@@ -6367,6 +7124,20 @@ Named_type::is_unexported_local_method(Gogo* gogo,\n void\n Named_type::finalize_methods(Gogo* gogo)\n {\n+  // If this type needs explicit comparison and hash functions, create\n+  // them now.  It would be a bit better to do this only if the\n+  // functions are needed, but they will be static so the backend can\n+  // discard them if they are not used.\n+  if ((this->struct_type() != NULL\n+       || (this->array_type() != NULL && !this->is_slice_type()))\n+      && !this->compare_is_identity()\n+      && this->is_comparable())\n+    {\n+      Named_object* hash_fn;\n+      Named_object* equal_fn;\n+      this->type_functions(gogo, this, NULL, NULL, &hash_fn, &equal_fn);\n+    }\n+\n   if (this->all_methods_ != NULL)\n     return;\n \n@@ -6616,6 +7387,20 @@ Named_type::do_has_pointer() const\n   return ret;\n }\n \n+// Return whether comparisons for this type can use the identity\n+// function.\n+\n+bool\n+Named_type::do_compare_is_identity() const\n+{\n+  if (this->seen_)\n+    return false;\n+  this->seen_ = true;\n+  bool ret = this->type_->compare_is_identity();\n+  this->seen_ = false;\n+  return ret;\n+}\n+\n // Return a hash code.  This is used for method lookup.  We simply\n // hash on the name itself.\n "}, {"sha": "b00b007aa1c0d43c3c13751feba048c13ec3bf63", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 139, "deletions": 9, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -522,6 +522,21 @@ class Type\n   static bool\n   are_compatible_for_binop(const Type* t1, const Type* t2);\n \n+  // Return true if two types are compatible for use with the\n+  // comparison operator.  IS_EQUALITY_OP is true if this is an\n+  // equality comparison, false if it is an ordered comparison.  This\n+  // is an equivalence relation.  If this returns false, and REASON is\n+  // not NULL, it sets *REASON.\n+  static bool\n+  are_compatible_for_comparison(bool is_equality_op, const Type *t1,\n+\t\t\t\tconst Type *t2, std::string* reason);\n+\n+  // Return true if a type is comparable with itself.  This is true of\n+  // most types, but false for, e.g., function types.\n+  bool\n+  is_comparable() const\n+  { return Type::are_compatible_for_comparison(true, this, this, NULL); }\n+\n   // Return true if a value with type RHS is assignable to a variable\n   // with type LHS.  This is not an equivalence relation.  If this\n   // returns false, and REASON is not NULL, it sets *REASON.\n@@ -549,6 +564,13 @@ class Type\n   bool\n   has_hidden_fields(const Named_type* within, std::string* reason) const;\n \n+  // Return true if values of this type can be compared using an\n+  // identity function which gets nothing but a pointer to the value\n+  // and a size.\n+  bool\n+  compare_is_identity() const\n+  { return this->do_compare_is_identity(); }\n+\n   // Return a hash code for this type for the method hash table.\n   // Types which are equivalent according to are_identical will have\n   // the same hash code.\n@@ -839,6 +861,20 @@ class Type\n   std::string\n   mangled_name(Gogo*) const;\n \n+  // Get the hash and equality functions for a type.\n+  void\n+  type_functions(Gogo*, Named_type* name, Function_type* hash_fntype,\n+\t\t Function_type* equal_fntype, Named_object** hash_fn,\n+\t\t Named_object** equal_fn);\n+\n+  // Write the hash and equality type functions.\n+  void\n+  write_specific_type_functions(Gogo*, Named_type*,\n+\t\t\t\tconst std::string& hash_name,\n+\t\t\t\tFunction_type* hash_fntype,\n+\t\t\t\tconst std::string& equal_name,\n+\t\t\t\tFunction_type* equal_fntype);\n+\n   // Export the type.\n   void\n   export_type(Export* exp) const\n@@ -866,6 +902,9 @@ class Type\n   do_has_pointer() const\n   { return false; }\n \n+  virtual bool\n+  do_compare_is_identity() const = 0;\n+\n   virtual unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -878,7 +917,6 @@ class Type\n   virtual void\n   do_reflection(Gogo*, std::string*) const = 0;\n \n-\n   virtual void\n   do_mangled_name(Gogo*, std::string*) const = 0;\n \n@@ -1002,18 +1040,24 @@ class Type\n   void\n   make_type_descriptor_var(Gogo*);\n \n-  // Return the name of the type descriptor variable for an unnamed\n-  // type.\n+  // Return the name of the type descriptor variable.  If NAME is not\n+  // NULL, it is the name to use.\n   std::string\n-  unnamed_type_descriptor_var_name(Gogo*);\n+  type_descriptor_var_name(Gogo*, Named_type* name);\n \n-  // Return the name of the type descriptor variable for a named type.\n-  std::string\n-  type_descriptor_var_name(Gogo*);\n+  // Return true if the type descriptor for this type should be\n+  // defined in some other package.  If NAME is not NULL, it is the\n+  // name of this type.  If this returns true it sets *PACKAGE to the\n+  // package where the type descriptor is defined.\n+  bool\n+  type_descriptor_defined_elsewhere(Named_type* name, const Package** package);\n \n-  // Get the hash and equality functions for a type.\n+  // Build the hash and equality type functions for a type which needs\n+  // specific functions.\n   void\n-  type_functions(const char** hash_fn, const char** equal_fn) const;\n+  specific_type_functions(Gogo*, Named_type*, Function_type* hash_fntype,\n+\t\t\t  Function_type* equal_fntype, Named_object** hash_fn,\n+\t\t\t  Named_object** equal_fn);\n \n   // Build a composite literal for the uncommon type information.\n   Expression*\n@@ -1097,6 +1141,14 @@ class Type\n   // A list of builtin named types.\n   static std::vector<Named_type*> named_builtin_types;\n \n+  // A map from types which need specific type functions to the type\n+  // functions themselves.\n+  typedef std::pair<Named_object*, Named_object*> Hash_equal_fn;\n+  typedef Unordered_map_hash(const Type*, Hash_equal_fn, Type_hash_identical,\n+\t\t\t     Type_identical) Type_functions;\n+\n+  static Type_functions type_functions_table;\n+\n   // The type classification.\n   Type_classification classification_;\n   // The backend representation of the type, once it has been\n@@ -1314,6 +1366,10 @@ class Integer_type : public Type\n   is_identical(const Integer_type* t) const;\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1383,6 +1439,10 @@ class Float_type : public Type\n   is_identical(const Float_type* t) const;\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1448,6 +1508,10 @@ class Complex_type : public Type\n   is_identical(const Complex_type* t) const;\n \n  protected:\n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1504,6 +1568,10 @@ class String_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   Btype*\n   do_get_backend(Gogo*);\n \n@@ -1618,6 +1686,10 @@ class Function_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1699,6 +1771,10 @@ class Pointer_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1944,6 +2020,14 @@ class Struct_type : public Type\n   static Type*\n   make_struct_type_descriptor_type();\n \n+  // Write the hash function for this type.\n+  void\n+  write_hash_function(Gogo*, Named_type*, Function_type*, Function_type*);\n+\n+  // Write the equality function for this type.\n+  void\n+  write_equal_function(Gogo*, Named_type*);\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -1954,6 +2038,9 @@ class Struct_type : public Type\n   bool\n   do_has_pointer() const;\n \n+  bool\n+  do_compare_is_identity() const;\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2022,6 +2109,10 @@ class Array_type : public Type\n   array_has_hidden_fields(const Named_type* within, std::string* reason) const\n   { return this->element_type_->has_hidden_fields(within, reason); }\n \n+  // Build the hash and equality functions if necessary.\n+  void\n+  finalize_methods(Gogo*);\n+\n   // Return a tree for the pointer to the values in an array.\n   tree\n   value_pointer_tree(Gogo*, tree array) const;\n@@ -2052,6 +2143,14 @@ class Array_type : public Type\n   static Type*\n   make_slice_type_descriptor_type();\n \n+  // Write the hash function for this type.\n+  void\n+  write_hash_function(Gogo*, Named_type*, Function_type*, Function_type*);\n+\n+  // Write the equality function for this type.\n+  void\n+  write_equal_function(Gogo*, Named_type*);\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -2065,6 +2164,13 @@ class Array_type : public Type\n     return this->length_ == NULL || this->element_type_->has_pointer();\n   }\n \n+  bool\n+  do_compare_is_identity() const\n+  {\n+    return (this->length_ != NULL\n+\t    && this->element_type_->compare_is_identity());\n+  }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2155,6 +2261,10 @@ class Map_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2237,6 +2347,10 @@ class Channel_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2348,6 +2462,10 @@ class Interface_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return false; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2480,6 +2598,11 @@ class Named_type : public Type\n   bool\n   is_named_error_type() const;\n \n+  // Return whether this type is comparable.  If REASON is not NULL,\n+  // set *REASON when returning false.\n+  bool\n+  named_type_is_comparable(std::string* reason) const;\n+\n   // Add a method to this type.\n   Named_object*\n   add_method(const std::string& name, Function*);\n@@ -2572,6 +2695,9 @@ class Named_type : public Type\n   bool\n   do_has_pointer() const;\n \n+  bool\n+  do_compare_is_identity() const;\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2704,6 +2830,10 @@ class Forward_declaration_type : public Type\n   do_has_pointer() const\n   { return this->real_type()->has_pointer(); }\n \n+  bool\n+  do_compare_is_identity() const\n+  { return this->real_type()->compare_is_identity(); }\n+\n   unsigned int\n   do_hash_for_method(Gogo* gogo) const\n   { return this->real_type()->hash_for_method(gogo); }"}, {"sha": "0113a69ddb8d3439e88c3627b0bab5fabc4adfeb", "filename": "gcc/testsuite/go.test/test/cmp6.go", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp6.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp6.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fcmp6.go?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -11,7 +11,7 @@ func use(bool) {}\n type T1 *int\n type T2 *int\n \n-type T3 struct {}\n+type T3 struct{ z []int }\n \n var t3 T3\n \n@@ -21,12 +21,12 @@ func main() {\n \t// so chan int can be compared against\n \t// directional channels but channel of different\n \t// direction cannot be compared against each other.\n-\tvar c1 chan <-int\n+\tvar c1 chan<- int\n \tvar c2 <-chan int\n \tvar c3 chan int\n-\t\n-\tuse(c1 == c2)\t// ERROR \"invalid operation|incompatible\"\n-\tuse(c2 == c1)\t// ERROR \"invalid operation|incompatible\"\n+\n+\tuse(c1 == c2) // ERROR \"invalid operation|incompatible\"\n+\tuse(c2 == c1) // ERROR \"invalid operation|incompatible\"\n \tuse(c1 == c3)\n \tuse(c2 == c2)\n \tuse(c3 == c1)\n@@ -36,14 +36,32 @@ func main() {\n \tvar p1 T1\n \tvar p2 T2\n \tvar p3 *int\n-\t\n-\tuse(p1 == p2)\t// ERROR \"invalid operation|incompatible\"\n-\tuse(p2 == p1)\t// ERROR \"invalid operation|incompatible\"\n+\n+\tuse(p1 == p2) // ERROR \"invalid operation|incompatible\"\n+\tuse(p2 == p1) // ERROR \"invalid operation|incompatible\"\n \tuse(p1 == p3)\n \tuse(p2 == p2)\n \tuse(p3 == p1)\n \tuse(p3 == p2)\n-\t\n+\n \t// Comparison of structs should have a good message\n-\tuse(t3 == t3)\t// ERROR \"struct|expected\"\n+\tuse(t3 == t3) // ERROR \"struct|expected\"\n+\n+\t// Slices, functions, and maps too.\n+\tvar x []int\n+\tvar f func()\n+\tvar m map[int]int\n+\tuse(x == x) // ERROR \"slice can only be compared to nil\"\n+\tuse(f == f) // ERROR \"func can only be compared to nil\"\n+\tuse(m == m) // ERROR \"map can only be compared to nil\"\n+\n+\t// Comparison with interface that cannot return true\n+\t// (would panic).\n+\tvar i interface{}\n+\tuse(i == x) // ERROR \"invalid operation\"\n+\tuse(x == i) // ERROR \"invalid operation\"\n+\tuse(i == f) // ERROR \"invalid operation\"\n+\tuse(f == i) // ERROR \"invalid operation\"\n+\tuse(i == m) // ERROR \"invalid operation\"\n+\tuse(m == i) // ERROR \"invalid operation\"\n }"}, {"sha": "b5db6f0d1ca424868958267331fb169121cdf315", "filename": "gcc/testsuite/go.test/test/recover2.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover2.go?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -60,6 +60,7 @@ func test4() {\n \n type T struct {\n \ta, b int\n+\tc    []int\n }\n \n func test5() {"}, {"sha": "4625ce232b621730727c679461bfed54ecdfc5cd", "filename": "libgo/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -460,8 +460,10 @@ runtime_files = \\\n \truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n \truntime/go-trampoline.c \\\n+\truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n \truntime/go-type-error.c \\\n+\truntime/go-type-float.c \\\n \truntime/go-type-identity.c \\\n \truntime/go-type-interface.c \\\n \truntime/go-type-string.c \\"}, {"sha": "0304f7e8996e57345d0d5c6e62f171c4a15aac7a", "filename": "libgo/Makefile.in", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -208,7 +208,8 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-string-to-byte-array.c \\\n \truntime/go-string-to-int-array.c runtime/go-strplus.c \\\n \truntime/go-strslice.c runtime/go-trampoline.c \\\n-\truntime/go-type-eface.c runtime/go-type-error.c \\\n+\truntime/go-type-complex.c runtime/go-type-eface.c \\\n+\truntime/go-type-error.c runtime/go-type-float.c \\\n \truntime/go-type-identity.c runtime/go-type-interface.c \\\n \truntime/go-type-string.c runtime/go-typedesc-equal.c \\\n \truntime/go-typestring.c runtime/go-unreflect.c \\\n@@ -242,13 +243,14 @@ am__objects_4 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-reflect-map.lo go-rune.lo go-runtime-error.lo go-setenv.lo \\\n \tgo-signal.lo go-strcmp.lo go-string-to-byte-array.lo \\\n \tgo-string-to-int-array.lo go-strplus.lo go-strslice.lo \\\n-\tgo-trampoline.lo go-type-eface.lo go-type-error.lo \\\n-\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n-\tgo-typedesc-equal.lo go-typestring.lo go-unreflect.lo \\\n-\tgo-unsafe-new.lo go-unsafe-newarray.lo go-unsafe-pointer.lo \\\n-\tgo-unwind.lo chan.lo cpuprof.lo $(am__objects_1) mcache.lo \\\n-\tmcentral.lo $(am__objects_2) mfinal.lo mfixalloc.lo mgc0.lo \\\n-\tmheap.lo msize.lo proc.lo runtime.lo thread.lo yield.lo \\\n+\tgo-trampoline.lo go-type-complex.lo go-type-eface.lo \\\n+\tgo-type-error.lo go-type-float.lo go-type-identity.lo \\\n+\tgo-type-interface.lo go-type-string.lo go-typedesc-equal.lo \\\n+\tgo-typestring.lo go-unreflect.lo go-unsafe-new.lo \\\n+\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unwind.lo \\\n+\tchan.lo cpuprof.lo $(am__objects_1) mcache.lo mcentral.lo \\\n+\t$(am__objects_2) mfinal.lo mfixalloc.lo mgc0.lo mheap.lo \\\n+\tmsize.lo proc.lo runtime.lo thread.lo yield.lo \\\n \t$(am__objects_3) iface.lo malloc.lo map.lo mprof.lo reflect.lo \\\n \truntime1.lo sema.lo sigqueue.lo string.lo time.lo\n am_libgo_la_OBJECTS = $(am__objects_4)\n@@ -881,8 +883,10 @@ runtime_files = \\\n \truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n \truntime/go-trampoline.c \\\n+\truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n \truntime/go-type-error.c \\\n+\truntime/go-type-float.c \\\n \truntime/go-type-identity.c \\\n \truntime/go-type-interface.c \\\n \truntime/go-type-string.c \\\n@@ -2523,8 +2527,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strplus.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strslice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-trampoline.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-eface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-error.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-float.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-identity.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-string.Plo@am__quote@\n@@ -2928,6 +2934,13 @@ go-trampoline.lo: runtime/go-trampoline.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-trampoline.lo `test -f 'runtime/go-trampoline.c' || echo '$(srcdir)/'`runtime/go-trampoline.c\n \n+go-type-complex.lo: runtime/go-type-complex.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-complex.lo -MD -MP -MF $(DEPDIR)/go-type-complex.Tpo -c -o go-type-complex.lo `test -f 'runtime/go-type-complex.c' || echo '$(srcdir)/'`runtime/go-type-complex.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-complex.Tpo $(DEPDIR)/go-type-complex.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-complex.c' object='go-type-complex.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-complex.lo `test -f 'runtime/go-type-complex.c' || echo '$(srcdir)/'`runtime/go-type-complex.c\n+\n go-type-eface.lo: runtime/go-type-eface.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-eface.lo -MD -MP -MF $(DEPDIR)/go-type-eface.Tpo -c -o go-type-eface.lo `test -f 'runtime/go-type-eface.c' || echo '$(srcdir)/'`runtime/go-type-eface.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-eface.Tpo $(DEPDIR)/go-type-eface.Plo\n@@ -2942,6 +2955,13 @@ go-type-error.lo: runtime/go-type-error.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-error.lo `test -f 'runtime/go-type-error.c' || echo '$(srcdir)/'`runtime/go-type-error.c\n \n+go-type-float.lo: runtime/go-type-float.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-float.lo -MD -MP -MF $(DEPDIR)/go-type-float.Tpo -c -o go-type-float.lo `test -f 'runtime/go-type-float.c' || echo '$(srcdir)/'`runtime/go-type-float.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-float.Tpo $(DEPDIR)/go-type-float.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-float.c' object='go-type-float.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-float.lo `test -f 'runtime/go-type-float.c' || echo '$(srcdir)/'`runtime/go-type-float.c\n+\n go-type-identity.lo: runtime/go-type-identity.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-identity.lo -MD -MP -MF $(DEPDIR)/go-type-identity.Tpo -c -o go-type-identity.lo `test -f 'runtime/go-type-identity.c' || echo '$(srcdir)/'`runtime/go-type-identity.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-identity.Tpo $(DEPDIR)/go-type-identity.Plo"}, {"sha": "f923c867d99585644a2c3acb028e7b0ead641b82", "filename": "libgo/runtime/go-type-complex.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-complex.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -0,0 +1,122 @@\n+/* go-type-complex.c -- hash and equality complex functions.\n+\n+   Copyright 2012 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"runtime.h\"\n+#include \"go-type.h\"\n+\n+/* The 64-bit type.  */\n+\n+typedef unsigned int DItype __attribute__ ((mode (DI)));\n+\n+/* Hash function for float types.  */\n+\n+uintptr_t\n+__go_type_hash_complex (const void *vkey, uintptr_t key_size)\n+{\n+  if (key_size == 8)\n+    {\n+      union\n+      {\n+\tunsigned char a[8];\n+\t__complex float cf;\n+\tDItype di;\n+      } ucf;\n+      __complex float cf;\n+      float cfr;\n+      float cfi;\n+\n+      __builtin_memcpy (ucf.a, vkey, 8);\n+      cf = ucf.cf;\n+      cfr = __builtin_crealf (cf);\n+      cfi = __builtin_cimagf (cf);\n+      if (__builtin_isinff (cfr) || __builtin_isinff (cfi)\n+\t  || __builtin_isnanf (cfr) || __builtin_isnanf (cfi))\n+\treturn 0;\n+\n+      /* Avoid negative zero.  */\n+      if (cfr == 0 && cfi == 0)\n+\treturn 0;\n+      else if (cfr == 0)\n+\tucf.cf = cfi * 1.0iF;\n+      else if (cfi == 0)\n+\tucf.cf = cfr;\n+\n+      return ucf.di;\n+    }\n+  else if (key_size == 16)\n+    {\n+      union\n+      {\n+\tunsigned char a[16];\n+\t__complex double cd;\n+\tDItype adi[2];\n+      } ucd;\n+      __complex double cd;\n+      double cdr;\n+      double cdi;\n+\n+      __builtin_memcpy (ucd.a, vkey, 16);\n+      cd = ucd.cd;\n+      cdr = __builtin_crealf (cd);\n+      cdi = __builtin_cimagf (cd);\n+      if (__builtin_isinf (cdr) || __builtin_isinf (cdi)\n+\t  || __builtin_isnan (cdr) || __builtin_isnan (cdi))\n+\treturn 0;\n+\n+      /* Avoid negative zero.  */\n+      if (cdr == 0 && cdi == 0)\n+\treturn 0;\n+      else if (cdr == 0)\n+\tucd.cd = cdi * 1.0i;\n+      else if (cdi == 0)\n+\tucd.cd = cdr;\n+\n+      return ucd.adi[0] ^ ucd.adi[1];\n+    }\n+  else\n+    runtime_throw (\"__go_type_hash_complex: invalid complex size\");\n+}\n+\n+/* Equality function for complex types.  */\n+\n+_Bool\n+__go_type_equal_complex (const void *vk1, const void *vk2, uintptr_t key_size)\n+{\n+  if (key_size == 8)\n+    {\n+      union\n+      {\n+\tunsigned char a[8];\n+\t__complex float cf;\n+      } ucf;\n+      __complex float cf1;\n+      __complex float cf2;\n+\n+      __builtin_memcpy (ucf.a, vk1, 8);\n+      cf1 = ucf.cf;\n+      __builtin_memcpy (ucf.a, vk2, 8);\n+      cf2 = ucf.cf;\n+      return cf1 == cf2;\n+    }\n+  else if (key_size == 16)\n+    {\n+      union\n+      {\n+\tunsigned char a[16];\n+\t__complex double cd;\n+      } ucd;\n+      __complex double cd1;\n+      __complex double cd2;\n+\n+      __builtin_memcpy (ucd.a, vk1, 16);\n+      cd1 = ucd.cd;\n+      __builtin_memcpy (ucd.a, vk2, 16);\n+      cd2 = ucd.cd;\n+      return cd1 == cd2;\n+    }\n+  else\n+    runtime_throw (\"__go_type_equal_complex: invalid complex size\");\n+}"}, {"sha": "cb3424b98d31eb367abdc27570372e68d6952de1", "filename": "libgo/runtime/go-type-eface.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-eface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-eface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-eface.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -10,13 +10,13 @@\n \n /* A hash function for an empty interface.  */\n \n-size_t\n+uintptr_t\n __go_type_hash_empty_interface (const void *vval,\n-\t\t\t\tsize_t key_size __attribute__ ((unused)))\n+\t\t\t\tuintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_empty_interface *val;\n   const struct __go_type_descriptor *descriptor;\n-  size_t size;\n+  uintptr_t size;\n \n   val = (const struct __go_empty_interface *) vval;\n   descriptor = val->__type_descriptor;\n@@ -33,7 +33,7 @@ __go_type_hash_empty_interface (const void *vval,\n \n _Bool\n __go_type_equal_empty_interface (const void *vv1, const void *vv2,\n-\t\t\t\t size_t key_size __attribute__ ((unused)))\n+\t\t\t\t uintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_empty_interface *v1;\n   const struct __go_empty_interface *v2;"}, {"sha": "b4c609b93ec36ae638a49320c8d044b6609fa9a6", "filename": "libgo/runtime/go-type-error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-error.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -10,9 +10,9 @@\n /* A hash function used for a type which does not support hash\n    functions.  */\n \n-size_t\n+uintptr_t\n __go_type_hash_error (const void *val __attribute__ ((unused)),\n-\t\t      size_t key_size __attribute__ ((unused)))\n+\t\t      uintptr_t key_size __attribute__ ((unused)))\n {\n   runtime_panicstring (\"hash of unhashable type\");\n }\n@@ -22,7 +22,7 @@ __go_type_hash_error (const void *val __attribute__ ((unused)),\n _Bool\n __go_type_equal_error (const void *v1 __attribute__ ((unused)),\n \t\t       const void *v2 __attribute__ ((unused)),\n-\t\t       size_t key_size __attribute__ ((unused)))\n+\t\t       uintptr_t key_size __attribute__ ((unused)))\n {\n   runtime_panicstring (\"comparing uncomparable types\");\n }"}, {"sha": "cc6e247e531c9d97c61b4b1f56ed99ab21bbda2f", "filename": "libgo/runtime/go-type-float.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-float.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -0,0 +1,96 @@\n+/* go-type-float.c -- hash and equality float functions.\n+\n+   Copyright 2012 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"runtime.h\"\n+#include \"go-type.h\"\n+\n+/* The 32-bit and 64-bit types.  */\n+\n+typedef unsigned int SItype __attribute__ ((mode (SI)));\n+typedef unsigned int DItype __attribute__ ((mode (DI)));\n+\n+/* Hash function for float types.  */\n+\n+uintptr_t\n+__go_type_hash_float (const void *vkey, uintptr_t key_size)\n+{\n+  if (key_size == 4)\n+    {\n+      union\n+      {\n+\tunsigned char a[4];\n+\tfloat f;\n+\tSItype si;\n+      } uf;\n+      float f;\n+\n+      __builtin_memcpy (uf.a, vkey, 4);\n+      f = uf.f;\n+      if (__builtin_isinff (f) || __builtin_isnanf (f) || f == 0)\n+\treturn 0;\n+      return (uintptr_t) uf.si;\n+    }\n+  else if (key_size == 8)\n+    {\n+      union\n+      {\n+\tunsigned char a[8];\n+\tdouble d;\n+\tDItype di;\n+      } ud;\n+      double d;\n+\n+      __builtin_memcpy (ud.a, vkey, 8);\n+      d = ud.d;\n+      if (__builtin_isinf (d) || __builtin_isnan (d) || d == 0)\n+\treturn 0;\n+      return (uintptr_t) ud.di;\n+    }\n+  else\n+    runtime_throw (\"__go_type_hash_float: invalid float size\");\n+}\n+\n+/* Equality function for float types.  */\n+\n+_Bool\n+__go_type_equal_float (const void *vk1, const void *vk2, uintptr_t key_size)\n+{\n+  if (key_size == 4)\n+    {\n+      union\n+      {\n+\tunsigned char a[4];\n+\tfloat f;\n+      } uf;\n+      float f1;\n+      float f2;\n+\n+      __builtin_memcpy (uf.a, vk1, 4);\n+      f1 = uf.f;\n+      __builtin_memcpy (uf.a, vk2, 4);\n+      f2 = uf.f;\n+      return f1 == f2;\n+    }\n+  else if (key_size == 8)\n+    {\n+      union\n+      {\n+\tunsigned char a[8];\n+\tdouble d;\n+\tDItype di;\n+      } ud;\n+      double d1;\n+      double d2;\n+\n+      __builtin_memcpy (ud.a, vk1, 8);\n+      d1 = ud.d;\n+      __builtin_memcpy (ud.a, vk2, 8);\n+      d2 = ud.d;\n+      return d1 == d2;\n+    }\n+  else\n+    runtime_throw (\"__go_type_equal_float: invalid float size\");\n+}"}, {"sha": "a0168e248361387b1100334f047f6f11289c0f9c", "filename": "libgo/runtime/go-type-identity.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-identity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-identity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-identity.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -8,43 +8,45 @@\n \n #include \"go-type.h\"\n \n-/* Typedefs for accesses of different sizes.  */\n+/* The 64-bit type.  */\n \n-typedef int QItype __attribute__ ((mode (QI)));\n-typedef int HItype __attribute__ ((mode (HI)));\n-typedef int SItype __attribute__ ((mode (SI)));\n-typedef int DItype __attribute__ ((mode (DI)));\n+typedef unsigned int DItype __attribute__ ((mode (DI)));\n \n /* An identity hash function for a type.  This is used for types where\n    we can simply use the type value itself as a hash code.  This is\n    true of, e.g., integers and pointers.  */\n \n-size_t\n-__go_type_hash_identity (const void *key, size_t key_size)\n+uintptr_t\n+__go_type_hash_identity (const void *key, uintptr_t key_size)\n {\n-  switch (key_size)\n+  uintptr_t ret;\n+  uintptr_t i;\n+  const unsigned char *p;\n+\n+  if (key_size <= 8)\n     {\n-    case 1:\n-      return *(const QItype *) key;\n-    case 2:\n-      return *(const HItype *) key;\n-    case 3:\n-    case 4:\n-    case 5:\n-    case 6:\n-    case 7:\n-      return *(const SItype *) key;\n-    default:\n-      return *(const DItype *) key;\n+      union\n+      {\n+\tDItype v;\n+\tunsigned char a[8];\n+      } u;\n+      u.v = 0;\n+      __builtin_memcpy (&u.a, key, key_size);\n+      return (uintptr_t) u.v;\n     }\n+\n+  ret = 5381;\n+  for (i = 0, p = (const unsigned char *) key; i < key_size; i++, p++)\n+    ret = ret * 33 + *p;\n+  return ret;\n }\n \n /* An identity equality function for a type.  This is used for types\n    where we can check for equality by checking that the values have\n    the same bits.  */\n \n _Bool\n-__go_type_equal_identity (const void *k1, const void *k2, size_t key_size)\n+__go_type_equal_identity (const void *k1, const void *k2, uintptr_t key_size)\n {\n   return __builtin_memcmp (k1, k2, key_size) == 0;\n }"}, {"sha": "bc3b37c4ba23514f74e12c38c05417d4f7dc012f", "filename": "libgo/runtime/go-type-interface.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-interface.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -9,13 +9,13 @@\n \n /* A hash function for an interface.  */\n \n-size_t\n+uintptr_t\n __go_type_hash_interface (const void *vval,\n-\t\t\t  size_t key_size __attribute__ ((unused)))\n+\t\t\t  uintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_interface *val;\n   const struct __go_type_descriptor *descriptor;\n-  size_t size;\n+  uintptr_t size;\n \n   val = (const struct __go_interface *) vval;\n   if (val->__methods == NULL)\n@@ -32,7 +32,7 @@ __go_type_hash_interface (const void *vval,\n \n _Bool\n __go_type_equal_interface (const void *vv1, const void *vv2,\n-\t\t\t   size_t key_size __attribute__ ((unused)))\n+\t\t\t   uintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_interface *v1;\n   const struct __go_interface *v2;"}, {"sha": "719ecb0e7ea7e8cdf00b673d9d597a254b5f1359", "filename": "libgo/runtime/go-type-string.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-string.c?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -11,14 +11,14 @@\n \n /* A string hash function for a map.  */\n \n-size_t\n+uintptr_t\n __go_type_hash_string (const void *vkey,\n-\t\t       size_t key_size __attribute__ ((unused)))\n+\t\t       uintptr_t key_size __attribute__ ((unused)))\n {\n-  size_t ret;\n+  uintptr_t ret;\n   const struct __go_string *key;\n-  size_t len;\n-  size_t i;\n+  int len;\n+  int i;\n   const unsigned char *p;\n \n   ret = 5381;\n@@ -33,7 +33,7 @@ __go_type_hash_string (const void *vkey,\n \n _Bool\n __go_type_equal_string (const void *vk1, const void *vk2,\n-\t\t\tsize_t key_size __attribute__ ((unused)))\n+\t\t\tuintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_string *k1;\n   const struct __go_string *k2;"}, {"sha": "25f096c485174e2e870ee920e1f6c882720009b3", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -86,11 +86,11 @@ struct __go_type_descriptor\n      size of this type, and returns a hash code.  We pass the size\n      explicitly becaues it means that we can share a single instance\n      of this function for various different types.  */\n-  size_t (*__hashfn) (const void *, size_t);\n+  uintptr_t (*__hashfn) (const void *, uintptr_t);\n \n   /* This function takes two pointers to values of this type, and the\n      size of this type, and returns whether the values are equal.  */\n-  _Bool (*__equalfn) (const void *, const void *, size_t);\n+  _Bool (*__equalfn) (const void *, const void *, uintptr_t);\n \n   /* A string describing this type.  This is only used for\n      debugging.  */\n@@ -317,13 +317,17 @@ extern _Bool\n __go_type_descriptors_equal(const struct __go_type_descriptor*,\n \t\t\t    const struct __go_type_descriptor*);\n \n-extern size_t __go_type_hash_identity (const void *, size_t);\n-extern _Bool __go_type_equal_identity (const void *, const void *, size_t);\n-extern size_t __go_type_hash_string (const void *, size_t);\n-extern _Bool __go_type_equal_string (const void *, const void *, size_t);\n-extern size_t __go_type_hash_interface (const void *, size_t);\n-extern _Bool __go_type_equal_interface (const void *, const void *, size_t);\n-extern size_t __go_type_hash_error (const void *, size_t);\n-extern _Bool __go_type_equal_error (const void *, const void *, size_t);\n+extern uintptr_t __go_type_hash_identity (const void *, uintptr_t);\n+extern _Bool __go_type_equal_identity (const void *, const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_string (const void *, uintptr_t);\n+extern _Bool __go_type_equal_string (const void *, const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_float (const void *, uintptr_t);\n+extern _Bool __go_type_equal_float (const void *, const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_complex (const void *, uintptr_t);\n+extern _Bool __go_type_equal_complex (const void *, const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_interface (const void *, uintptr_t);\n+extern _Bool __go_type_equal_interface (const void *, const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_error (const void *, uintptr_t);\n+extern _Bool __go_type_equal_error (const void *, const void *, uintptr_t);\n \n #endif /* !defined(LIBGO_GO_TYPE_H) */"}, {"sha": "b414b160ed13fe7b9c5a4bdb954a8a1443490f4a", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f96987536295eb79dafb3274ad578679a2eaee/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=f9f96987536295eb79dafb3274ad578679a2eaee", "patch": "@@ -322,18 +322,18 @@ localname() {\n \tpattern='Test([^a-z].*)?'\n \t# The -p option tells GNU nm not to sort.\n \t# The -v option tells Solaris nm to sort by value.\n-\ttests=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n+\ttests=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | fgrep -v '$' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n \tif [ \"x$tests\" = x ]; then\n \t\techo 'gotest: warning: no tests matching '$pattern in _gotest_.o $xofile 1>&2\n \t\texit 2\n \tfi\n \t# benchmarks are named BenchmarkFoo.\n \tpattern='Benchmark([^a-z].*)?'\n-\tbenchmarks=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n+\tbenchmarks=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | fgrep -v '$' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n \n \t# examples are named ExampleFoo\n \tpattern='Example([^a-z].*)?'\n-\texamples=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n+\texamples=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | fgrep -v '$' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n \n \t# package spec\n \techo 'package main'"}]}