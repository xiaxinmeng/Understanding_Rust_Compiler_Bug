{"sha": "7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMzNzY5NWRjMmM4ZjEwNmZiYWQ4YjU5YWQyYjRhMmM5ZDQxMzcxMA==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "1999-12-03T16:45:53Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "1999-12-03T16:45:53Z"}, "message": "align.C: New test.\n\n\t* g++.old-deja/g++.abi/align.C: New test.\n\t* g++.old-deja/g++.abi/aggregates.C: Likewise.\n\t* g++.old-deja/g++.abi/bitfields.C: Likewise.\n\nFrom-SVN: r30769", "tree": {"sha": "e1d929ba7f79b104295fef47de2106806a1ca892", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1d929ba7f79b104295fef47de2106806a1ca892"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/comments", "author": null, "committer": null, "parents": [{"sha": "ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5"}], "stats": {"total": 412, "additions": 412, "deletions": 0}, "files": [{"sha": "cc47296b69295a81f56ebe89e84d83c92b2dc0e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "patch": "@@ -1,3 +1,9 @@\n+1999-12-02  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/align.C: New test.\n+\t* g++.old-deja/g++.abi/aggregates.C: Likewise.\n+\t* g++.old-deja/g++.abi/bitfields.C: Likewise.\n+\n 1999-12-01  Richard Henderson  <rth@cygnus.com>\n \n \t* gcc.c-torture/execute/991201-1.c: New."}, {"sha": "37f5385b4bf6d93013cba60069ab60cd63220b91", "filename": "gcc/testsuite/g++.old-deja/g++.abi/aggregates.C", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Faggregates.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Faggregates.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Faggregates.C?ref=7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "patch": "@@ -0,0 +1,125 @@\n+// Skip if not target: i?86-*-linux*\n+// Special g++ Options: -malign-double\n+// Origin: Alex Samuel <samuel@codesourcery.com>\n+\n+/* Test the data layout of C aggregates by checking aggregate size and\n+   alignment and field offsets for compliance with the IA-64 ABI.  */\n+\n+template<typename T>\n+inline unsigned\n+alignmentof ()\n+{\n+  struct S\n+  {\n+    char start_;\n+    T object_;\n+  };\n+\n+  return (unsigned) & ((S *) 0)->object_;\n+}\n+\n+/* Computes the alignment, in bytes, of TYPE.  */\n+\n+#define alignof(type) (alignmentof<type> ())\n+\n+/* Computes the offset of FIELD in AGGREGATE.  */\n+\n+#define offsetof(aggregate, field) \\\n+  ((unsigned) (& ((aggregate*) 0)->field))\n+\n+\n+/* Structs S1, S2, S3, S4, and union U5 are taken from Intel, \"IA-64\n+   Software Conventions and Runtime Architecture Guide\", version of\n+   August 1999.  */\n+\n+struct S1\n+{\n+  char c;\n+};\n+\n+struct S2\n+{\n+  char c;\n+  char d;\n+  short s;\n+  int n;\n+};\n+\n+struct S3\n+{\n+  char c;\n+  short s;\n+};\n+\n+struct S4\n+{\n+  char c;\n+  double d;\n+  short s;\n+};\n+\n+union U5\n+{\n+  char c;\n+  short s;\n+  int j;\n+};\n+\n+\n+\n+int\n+main ()\n+{\n+  if (sizeof (struct S1) \t\t!=  1)\n+    return 1;\n+  if (alignof (struct S1)\t\t!=  1)\n+    return 2;\n+  if (offsetof (struct S1, c)\t\t!=  0)\n+    return 3;\n+  \n+  if (sizeof (struct S2)\t\t!=  8)\n+    return 4;\n+  if (alignof (struct S2)       \t!=  4)\n+    return 5;\n+  if (offsetof (struct S2, c)\t\t!=  0)\n+    return 6;\n+  if (offsetof (struct S2, d)\t\t!=  1)\n+    return 7;\n+  if (offsetof (struct S2, s)\t\t!=  2)\n+    return 8;\n+  if (offsetof (struct S2, n)\t\t!=  4)\n+    return 9;\n+  \n+  if (sizeof (struct S3)\t\t!=  4)\n+    return 10;\n+  if (alignof (struct S3)\t\t!=  2)\n+    return 11;\n+  if (offsetof (struct S3, c)\t\t!=  0)\n+    return 12;\n+  if (offsetof (struct S3, s)\t\t!=  2)\n+    return 13;\n+  \n+  if (sizeof (struct S4)\t\t!= 24)\n+    return 14;\n+  if (alignof (struct S4)\t\t!=  8)\n+    return 15;\n+  if (offsetof (struct S4, c)\t\t!=  0)\n+    return 16;\n+  if (offsetof (struct S4, d)\t\t!=  8)\n+    return 17;\n+  if (offsetof (struct S4, s)\t\t!= 16)\n+    return 18;\n+  \n+  if (sizeof (union U5)\t\t\t!=  4)\n+    return 19;\n+  if (alignof (union U5)\t\t!=  4)\n+    return 20;\n+  if (offsetof (union U5, c)\t\t!=  0)\n+    return 21;\n+  if (offsetof (union U5, s)\t\t!=  0)\n+    return 22;\n+  if (offsetof (union U5, j)\t\t!=  0)\n+    return 23;\n+  \n+  return 0;\n+}"}, {"sha": "d35ea3996cb915789440425b45ea925f87b49add", "filename": "gcc/testsuite/g++.old-deja/g++.abi/align.C", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Falign.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Falign.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Falign.C?ref=7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "patch": "@@ -0,0 +1,122 @@\n+// Skip if not target: i?86-*-linux*\n+// Special g++ Options: -malign-double\n+// Origin: Alex Samuel <samuel@codesourcery.com>\n+\n+/* Test the size and alignment of fundamental C types for compliance\n+   with the IA-64 ABI.  */\n+\n+template<typename T>\n+inline unsigned\n+alignmentof ()\n+{\n+  struct S\n+  {\n+    char start_;\n+    T object_;\n+  };\n+\n+  return (unsigned) & ((S *) 0)->object_;\n+}\n+\n+/* Computes the alignment, in bytes, of TYPE.  */\n+\n+#define alignof(type) (alignmentof<type> ())\n+\n+int\n+main ()\n+{\n+  if (sizeof  (char)                    !=  1)\n+    return 1;\n+  if (alignof (char)                    !=  1)\n+    return 2;\n+  if (sizeof  (signed char)             !=  1)\n+    return 3;\n+  if (alignof (signed char)             !=  1)\n+    return 4;\n+  if (sizeof  (unsigned char)           !=  1)\n+    return 5;  \n+  if (alignof (unsigned char)           !=  1)\n+    return 6;\n+  if (sizeof  (short)                   !=  2)\n+    return 7;\n+  if (alignof (short)                   !=  2)\n+    return 8;\n+  if (sizeof  (signed short)            !=  2)\n+    return 9\n+  if (alignof (signed short)            !=  2)\n+    return 10;\n+  if (sizeof  (unsigned short)          !=  2)\n+    return 11;\n+  if (alignof (unsigned short)          !=  2)\n+    return 12;\n+  if (sizeof  (int)                     !=  4)\n+    return 13;\n+  if (alignof (int)                     !=  4)\n+    return 14;\n+  if (sizeof  (signed int)              !=  4)\n+    return 15;\n+  if (alignof (signed int)              !=  4)\n+    return 16;\n+  if (sizeof  (unsigned int)            !=  4)\n+    return 17;\n+  if (alignof (unsigned int)            !=  4)\n+    return 18;\n+  if (sizeof  (enum { a })              !=  4)\n+    return 19;\n+  if (alignof (enum { a })              !=  4)\n+    return 20;\n+#ifdef HAVE_IA64_TYPES\n+  if (sizeof  (__int64)                 !=  8)\n+    return 21;\n+  if (alignof (__int64)                 !=  8)\n+    return 22;\n+  if (sizeof  (signed __int64)          !=  8)\n+    return 23;\n+  if (alignof (signed ___int64)         !=  8)\n+    return 24;\n+  if (sizeof  (unsigned __int64)        !=  8)\n+    return 25;\n+  if (alignof (unsigned __int64)        !=  8)\n+    return 26;\n+  if (sizeof  (__int128)                != 16)\n+    return 27;\n+  if (alignof (__int128)                != 16)\n+    return 28;\n+  if (sizeof  (signed __int128)         != 16)\n+    return 29;\n+  if (alignof (signed ___int128)        != 16)\n+    return 30;\n+  if (sizeof  (unsigned __int128)       != 16)\n+    return 31;\n+  if (alignof (unsigned ___int128)      != 16)\n+    return 32;\n+#endif  /* HAVE_IA64_TYPES  */\n+  if (sizeof  (void *)                  !=  4)\n+    return 33;\n+  if (alignof (pointer)                 !=  4)\n+    return 34;\n+  if (sizeof  (void (*) ())             !=  4)\n+    return 35;\n+  if (alignof (void (*) ())             !=  4)\n+    return 36;\n+  if (sizeof  (float)                   !=  4)\n+    return 37;\n+  if (alignof (float)                   !=  4)\n+    return 38;\n+  if (sizeof  (double)                  !=  8)\n+    return 39;\n+  if (alignof (double)                  !=  8)\n+    return 40;\n+#ifdef HAVE_IA64_TYPES\n+  if (sizeof  (__float80)               != 16)\n+    return 41;\n+  if (alignof (__float80)               != 16)\n+    return 42;\n+  if (sizeof  (__float128)              != 16)\n+    return 43;\n+  if (alignof (__float128)              != 16)\n+    return 44;\n+#endif  /* HAVE_IA64_TYPES  */\n+\n+  return 0;\n+}"}, {"sha": "75b6571b1dc94ac585384a6d9de79f89e6e00bcf", "filename": "gcc/testsuite/g++.old-deja/g++.abi/bitfields.C", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fbitfields.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7337695dc2c8f106fbad8b59ad2b4a2c9d413710/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fbitfields.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fbitfields.C?ref=7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "patch": "@@ -0,0 +1,159 @@\n+// Skip if not target: i?86-*-linux*\n+// Special g++ Options: -malign-double\n+// Origin: Alex Samuel <samuel@codesourcery.com>\n+\n+/* Test the layout of bitfields in C aggretagtes for compliance with\n+   the IA-64 ABI.  */\n+\n+#include <cstring>\n+\n+template<typename T>\n+inline unsigned\n+alignmentof ()\n+{\n+  struct S\n+  {\n+    char start_;\n+    T object_;\n+  };\n+\n+  return (unsigned) & ((S *) 0)->object_;\n+}\n+\n+/* Computes the alignment, in bytes, of TYPE.  */\n+\n+#define alignof(type) (alignmentof<type> ())\n+\n+/* Returns true iff all the bits in the range \n+   START_BIT <= bit < START_BIT + NUM_BITS, and only those bits, are\n+   set in the region of memory starting at BUF of LENGTH bytes.  */\n+\n+bool\n+check_bits (char *buf,\n+\t    unsigned length,\n+\t    unsigned start_bit,\n+\t    unsigned num_bits)\n+{\n+  for (unsigned bit = 0; bit < 8 * length; ++bit) {\n+    bool is_set = (buf[bit / 8] & (1 << (bit % 8))) != 0;\n+    if (start_bit <= bit && bit < start_bit + num_bits) {\n+      if (! is_set)\n+\treturn false;\n+    }\n+    else {\n+      if (is_set)\n+\treturn false;\n+    }\n+  }\n+  return true;\n+}\n+\n+/* Creates a variable of type AGGREGATE, sets FIELD to -1, and\n+   verifies that NUM_BITS bits starting at START_BIT, and no other\n+   bits, are set.  If the check fails, returns with value RVAL.  */\n+\n+#define CHECK_FIELD(AGGREGATE, FIELD, START_BIT, NUM_BITS, RVAL)          \\\n+  do {                                                                    \\\n+    AGGREGATE a__;                                                        \\\n+    memset (& a__, 0, sizeof (a__));                                      \\\n+    a__.FIELD = -1;                                                       \\\n+    if (! check_bits ((char *) & a__, sizeof (a__), START_BIT, NUM_BITS)) \\\n+      return RVAL;                                                        \\\n+  } while (0);\n+\n+\n+\n+/* Structs S1, S2, S3, S4, and union U5 are taken from Intel, \"IA-64\n+   Software Conventions and Runtime Architecture Guide\", version of\n+   August 1999.  */\n+\n+struct S1\n+{\n+  int       j : 5;\n+  int       k : 6;\n+  int       m : 7;\n+};\n+\n+#ifdef HAVE_IA64_TYPES\n+struct S2\n+{\n+  short     s : 9;\n+  __int64   j : 9;\n+  char      c    ;\n+  short     t : 9;\n+  short     u : 9;\n+  char      d    ;\n+};\n+#endif  /* HAVE_IA64_TYPES  */\n+\n+struct S3\n+{\n+  char      c    ;\n+  short     s : 8;\n+};\n+\n+union U4\n+{\n+  char      c    ;\n+  short     s : 8;\n+};\n+\n+struct S5\n+{\n+  char      c    ;\n+  int         : 0;\n+  char      d    ;\n+  short       : 9;\n+  char      e    ;\n+  char        : 0;\n+};\n+\n+\n+int\n+main ()\n+{\n+  if (sizeof (struct S1)\t\t!=  4)\n+    return 1;\n+  if (alignof (struct S1)\t\t!=  4)\n+    return 2;\n+  CHECK_FIELD (S1, j,  0,  5,  3);\n+  CHECK_FIELD (S1, k,  5,  6,  4);\n+  CHECK_FIELD (S1, m, 11,  7,  5);\n+\n+#ifdef HAVE_IA64_TYPES\n+  if (sizeof (struct S2)\t\t!= 16)\n+    return 6;\n+  if (alignof (struct S2)\t\t!=  8)\n+    return 7;\n+  CHECK_FIELD (S2, s,  0,  9,  8);\n+  CHECK_FIELD (S2, j,  9,  9,  9);\n+  CHECK_FIELD (S2, c, 24,  8, 10);\n+  CHECK_FIELD (S2, t, 32,  9, 11);\n+  CHECK_FIELD (S2, u, 48,  9, 12);\n+  CHECK_FIELD (S2, d, 64,  8, 13);\n+#endif  /* HAVE_IA64_TYPES  */\n+\n+  if (sizeof (struct S3)\t\t!=  2)\n+    return 14;\n+  if (sizeof (struct S3)\t\t!=  2)\n+    return 15;\n+  CHECK_FIELD (S3, c,  0,  8, 16);\n+  CHECK_FIELD (S3, s,  8,  8, 17);\n+\n+  if (sizeof (union U4) \t\t!=  2)\n+    return 18;\n+  if (alignof (union U4)\t\t!=  2)\n+    return 19;\n+  CHECK_FIELD (U4, c,  0,  8, 20);\n+  CHECK_FIELD (U4, s,  0,  8, 21);\n+\n+  if (sizeof (struct S5)\t\t!=  9)\n+    return 22;\n+  if (alignof (struct S5)\t\t!=  1)\n+    return 23;\n+  CHECK_FIELD (S5, c,  0,  8, 24);\n+  CHECK_FIELD (S5, d, 32,  8, 25);\n+  CHECK_FIELD (S5, e, 64,  8, 26);\n+\n+  return 0;\n+}"}]}