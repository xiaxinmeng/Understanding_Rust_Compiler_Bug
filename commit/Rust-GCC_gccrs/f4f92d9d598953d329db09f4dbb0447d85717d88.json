{"sha": "f4f92d9d598953d329db09f4dbb0447d85717d88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmOTJkOWQ1OTg5NTNkMzI5ZGIwOWY0ZGJiMDQ0N2Q4NTcxN2Q4OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T10:35:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T10:35:25Z"}, "message": "[multiple changes]\n\n2011-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Inlined_Call): Fix use of uninitialized\n\tvariable for type of return value when return type is\n\tunconstrained and context is an assignment.\n\n2011-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Check_Class_Wide_Actual): Do not generate body of\n\tclass-wide operation if expansion is not enabled.\n\n2011-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* checks.adb (Apply_Scalar_Range_Check): Deal with access\n\ttype prefix.\n\n2011-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications, case\n\tAspect_Invariant): Do not issue error at this point on illegal\n\tpragma placement, as this is checked later on when analyzing\n\tthe corresponding pragma.\n\t* sem_prag.adb (Error_Pragma_Arg_Alternate_Name): New procedure\n\tsimilar to Error_Pragma_Arg, except the source name of the\n\taspect/pragma to use in warnings may be equal to parameter\n\tAlt_Name (Analyze_Pragma, case Pragma_Invariant): refine error\n\tmessage to distinguish source name of pragma/aspect, and whether\n\tthe illegality resides in the type being public, or being private\n\twithout a public declaration\n\n2011-09-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.adb (Check_For_Fd_Set): On Windows, no need for bitmap\n\tsize check (fd_set is implemented differently on that platform).\n\n2011-09-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-taprop-vxworks.adb, s-taprop-tru64.adb, s-taprop-vms.adb,\n\ts-tpoaal.adb, s-taprop-mingw.adb, s-taprop-linux.adb,\n\ts-taprop-solaris.adb, s-taprop-irix.adb, s-taprop.ads,\n\ts-taprop-hpux-dce.adb, s-taprop-dummy.adb, s-taprop-posix.adb\n\t(ATCB_Allocation): New subpackage of\n\tSystem.Tasking.Primitive_Operations, shared across all targets\n\twith full tasking runtime.\n\t(ATCB_Allocation.New_ATCB): Moved there (from target specific\n\ts-taprop bodies).\n\t(ATCB_Allocation.Free_ATCB): New subprogram. Deallocate an ATCB,\n\ttaking care of establishing a local temporary ATCB if the one\n\tbeing deallocated is Self, to avoid a reference to the freed\n\tATCB in Abort_Undefer.\n\n2011-09-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-tassta.adb, s-taskin.ads (Free_Task): If the task is not\n\tterminated, mark it for deallocation upon termination.\n\t(Terminate_Task): Call Free_Task again if the task is marked\n\tfor automatic deallocation upon termination.\n\nFrom-SVN: r178582", "tree": {"sha": "b09f42a49b595c51ca661f47a4e6113ec4d568de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09f42a49b595c51ca661f47a4e6113ec4d568de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4f92d9d598953d329db09f4dbb0447d85717d88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f92d9d598953d329db09f4dbb0447d85717d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f92d9d598953d329db09f4dbb0447d85717d88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f92d9d598953d329db09f4dbb0447d85717d88/comments", "author": null, "committer": null, "parents": [{"sha": "4cdccf26659e2463f0c1e06da20cb21ea612b391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cdccf26659e2463f0c1e06da20cb21ea612b391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cdccf26659e2463f0c1e06da20cb21ea612b391"}], "stats": {"total": 779, "additions": 442, "deletions": 337}, "files": [{"sha": "0b5216f1e0cb37c1ec7dfec4c90d7cb20f552747", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -1,3 +1,61 @@\n+2011-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Inlined_Call): Fix use of uninitialized\n+\tvariable for type of return value when return type is\n+\tunconstrained and context is an assignment.\n+\n+2011-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Check_Class_Wide_Actual): Do not generate body of\n+\tclass-wide operation if expansion is not enabled.\n+\n+2011-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb (Apply_Scalar_Range_Check): Deal with access\n+\ttype prefix.\n+\n+2011-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications, case\n+\tAspect_Invariant): Do not issue error at this point on illegal\n+\tpragma placement, as this is checked later on when analyzing\n+\tthe corresponding pragma.\n+\t* sem_prag.adb (Error_Pragma_Arg_Alternate_Name): New procedure\n+\tsimilar to Error_Pragma_Arg, except the source name of the\n+\taspect/pragma to use in warnings may be equal to parameter\n+\tAlt_Name (Analyze_Pragma, case Pragma_Invariant): refine error\n+\tmessage to distinguish source name of pragma/aspect, and whether\n+\tthe illegality resides in the type being public, or being private\n+\twithout a public declaration\n+\n+2011-09-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.adb (Check_For_Fd_Set): On Windows, no need for bitmap\n+\tsize check (fd_set is implemented differently on that platform).\n+\n+2011-09-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-taprop-vxworks.adb, s-taprop-tru64.adb, s-taprop-vms.adb,\n+\ts-tpoaal.adb, s-taprop-mingw.adb, s-taprop-linux.adb,\n+\ts-taprop-solaris.adb, s-taprop-irix.adb, s-taprop.ads,\n+\ts-taprop-hpux-dce.adb, s-taprop-dummy.adb, s-taprop-posix.adb\n+\t(ATCB_Allocation): New subpackage of\n+\tSystem.Tasking.Primitive_Operations, shared across all targets\n+\twith full tasking runtime.\n+\t(ATCB_Allocation.New_ATCB): Moved there (from target specific\n+\ts-taprop bodies).\n+\t(ATCB_Allocation.Free_ATCB): New subprogram. Deallocate an ATCB,\n+\ttaking care of establishing a local temporary ATCB if the one\n+\tbeing deallocated is Self, to avoid a reference to the freed\n+\tATCB in Abort_Undefer.\n+\n+2011-09-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-tassta.adb, s-taskin.ads (Free_Task): If the task is not\n+\tterminated, mark it for deallocation upon termination.\n+\t(Terminate_Task): Call Free_Task again if the task is marked\n+\tfor automatic deallocation upon termination.\n+\n 2011-09-06  Robert Dewar  <dewar@adacore.com>\n \n \t* a-cbprqu.ads, a-cbsyqu.ads, a-cuprqu.ads, a-cusyqu.ads,"}, {"sha": "336b14462c2c4f33e73d6e1ec3b9ba375223f103", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -1877,6 +1877,9 @@ package body Checks is\n       if Is_Subscr_Ref then\n          Arr := Prefix (Parnt);\n          Arr_Typ := Get_Actual_Subtype_If_Available (Arr);\n+         if Is_Access_Type (Arr_Typ) then\n+            Arr_Typ := Directly_Designated_Type (Arr_Typ);\n+         end if;\n       end if;\n \n       if not Do_Range_Check (Expr) then"}, {"sha": "b3003893eef171264e624317dc9d45dfa30b9fbe", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -3740,17 +3740,24 @@ package body Exp_Ch6 is\n       New_A    : Node_Id;\n       Num_Ret  : Int := 0;\n       Ret_Type : Entity_Id;\n-      Targ     : Node_Id;\n-      Targ1    : Node_Id;\n+\n+      Targ : Node_Id;\n+      --  The target of the call. If context is an assignment statement then\n+      --  this is the left-hand side of the assignment. else it is a temporary\n+      --  to which the return value is assigned prior to rewriting the call.\n+\n+      Targ1 : Node_Id;\n+      --  A separate target used when the return type is unconstrained\n+\n       Temp     : Entity_Id;\n       Temp_Typ : Entity_Id;\n \n       Return_Object : Entity_Id := Empty;\n       --  Entity in declaration in an extended_return_statement\n \n       Is_Unc : constant Boolean :=\n-                    Is_Array_Type (Etype (Subp))\n-                      and then not Is_Constrained (Etype (Subp));\n+                 Is_Array_Type (Etype (Subp))\n+                   and then not Is_Constrained (Etype (Subp));\n       --  If the type returned by the function is unconstrained and the call\n       --  can be inlined, special processing is required.\n \n@@ -3841,6 +3848,7 @@ package body Exp_Ch6 is\n                   Rewrite (N, New_Copy (A));\n                end if;\n             end if;\n+\n             return Skip;\n \n          elsif Is_Entity_Name (N)\n@@ -3891,8 +3899,8 @@ package body Exp_Ch6 is\n                if Nkind_In (Expression (N), N_Aggregate, N_Null) then\n                   Ret :=\n                     Make_Qualified_Expression (Sloc (N),\n-                       Subtype_Mark => New_Occurrence_Of (Ret_Type, Sloc (N)),\n-                       Expression => Relocate_Node (Expression (N)));\n+                      Subtype_Mark => New_Occurrence_Of (Ret_Type, Sloc (N)),\n+                      Expression => Relocate_Node (Expression (N)));\n                else\n                   Ret :=\n                     Unchecked_Convert_To\n@@ -3902,32 +3910,30 @@ package body Exp_Ch6 is\n                if Nkind (Targ) = N_Defining_Identifier then\n                   Rewrite (N,\n                     Make_Assignment_Statement (Loc,\n-                      Name => New_Occurrence_Of (Targ, Loc),\n+                      Name       => New_Occurrence_Of (Targ, Loc),\n                       Expression => Ret));\n                else\n                   Rewrite (N,\n                     Make_Assignment_Statement (Loc,\n-                      Name => New_Copy (Targ),\n+                      Name       => New_Copy (Targ),\n                       Expression => Ret));\n                end if;\n \n                Set_Assignment_OK (Name (N));\n \n                if Present (Exit_Lab) then\n                   Insert_After (N,\n-                    Make_Goto_Statement (Loc,\n-                      Name => New_Copy (Lab_Id)));\n+                    Make_Goto_Statement (Loc, Name => New_Copy (Lab_Id)));\n                end if;\n             end if;\n \n             return OK;\n \n-         elsif Nkind (N) = N_Extended_Return_Statement then\n-\n-            --  An extended return becomes a block whose first statement is\n-            --  the assignment of the initial expression of the return object\n-            --  to the target of the call itself.\n+         --  An extended return becomes a block whose first statement is the\n+         --  assignment of the initial expression of the return object to the\n+         --  target of the call itself.\n \n+         elsif Nkind (N) = N_Extended_Return_Statement then\n             declare\n                Return_Decl : constant Entity_Id :=\n                                First (Return_Object_Declarations (N));\n@@ -3940,12 +3946,12 @@ package body Exp_Ch6 is\n                   if Nkind (Targ) = N_Defining_Identifier then\n                      Assign :=\n                        Make_Assignment_Statement (Loc,\n-                         Name => New_Occurrence_Of (Targ, Loc),\n+                         Name       => New_Occurrence_Of (Targ, Loc),\n                          Expression => Expression (Return_Decl));\n                   else\n                      Assign :=\n                        Make_Assignment_Statement (Loc,\n-                         Name => New_Copy (Targ),\n+                         Name       => New_Copy (Targ),\n                          Expression => Expression (Return_Decl));\n                   end if;\n \n@@ -4011,7 +4017,6 @@ package body Exp_Ch6 is\n            and then Nkind (Fst) = N_Assignment_Statement\n            and then No (Next (Fst))\n          then\n-\n             --  The function call may have been rewritten as the temporary\n             --  that holds the result of the call, in which case remove the\n             --  now useless declaration.\n@@ -4080,6 +4085,7 @@ package body Exp_Ch6 is\n \n       procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id) is\n          HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n+\n       begin\n          --  If there is a transient scope for N, this will be the scope of the\n          --  actions for N, and the statements in Blk need to be within this\n@@ -4161,7 +4167,6 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_Inlined_Call\n \n    begin\n-\n       --  Check for an illegal attempt to inline a recursive procedure. If the\n       --  subprogram has parameters this is detected when trying to supply a\n       --  binding for parameters that already have one. For parameterless\n@@ -4219,8 +4224,12 @@ package body Exp_Ch6 is\n       --  expansion of an extended return, the left-hand side provides bounds\n       --  even if the return type is unconstrained.\n \n-      if Is_Unc and then Nkind (Parent (N)) /= N_Assignment_Statement then\n-         Targ1 := Defining_Identifier (First (Declarations (Blk)));\n+      if Is_Unc then\n+         if Nkind (Parent (N)) /= N_Assignment_Statement then\n+            Targ1 := Defining_Identifier (First (Declarations (Blk)));\n+         else\n+            Targ1 := Name (Parent (N));\n+         end if;\n       end if;\n \n       --  If this is a derived function, establish the proper return type\n@@ -4250,16 +4259,14 @@ package body Exp_Ch6 is\n \n          if Is_Class_Wide_Type (Etype (F))\n            or else (Is_Access_Type (Etype (F))\n-                      and then\n-                    Is_Class_Wide_Type (Designated_Type (Etype (F))))\n+                     and then Is_Class_Wide_Type (Designated_Type (Etype (F))))\n          then\n             Temp_Typ := Etype (F);\n \n          elsif Base_Type (Etype (F)) = Base_Type (Etype (A))\n            and then Etype (F) /= Base_Type (Etype (F))\n          then\n             Temp_Typ := Etype (F);\n-\n          else\n             Temp_Typ := Etype (A);\n          end if;\n@@ -4285,13 +4292,13 @@ package body Exp_Ch6 is\n \n            or else\n              (Nkind_In (A, N_Real_Literal,\n-                            N_Integer_Literal,\n-                            N_Character_Literal)\n-                and then not Address_Taken (F))\n+                           N_Integer_Literal,\n+                           N_Character_Literal)\n+               and then not Address_Taken (F))\n          then\n             if Etype (F) /= Etype (A) then\n                Set_Renamed_Object\n-                (F, Unchecked_Convert_To (Etype (F), Relocate_Node (A)));\n+                 (F, Unchecked_Convert_To (Etype (F), Relocate_Node (A)));\n             else\n                Set_Renamed_Object (F, A);\n             end if;\n@@ -4337,9 +4344,9 @@ package body Exp_Ch6 is\n             if Ekind (F) = E_In_Parameter\n               and then not Is_By_Reference_Type (Etype (A))\n               and then\n-               (not Is_Array_Type (Etype (A))\n-                 or else not Is_Object_Reference (A)\n-                 or else Is_Bit_Packed_Array (Etype (A)))\n+                (not Is_Array_Type (Etype (A))\n+                  or else not Is_Object_Reference (A)\n+                  or else Is_Bit_Packed_Array (Etype (A)))\n             then\n                Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -4698,7 +4705,6 @@ package body Exp_Ch6 is\n                Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n \n                --  Create the temporary, generate:\n-               --\n                --    Local_Id : Ptr_Typ;\n \n                Local_Id := Make_Temporary (Loc, 'T');\n@@ -4710,7 +4716,6 @@ package body Exp_Ch6 is\n                      New_Reference_To (Ptr_Typ, Loc)));\n \n                --  Allocate the object, generate:\n-               --\n                --    Local_Id := <Alloc_Expr>;\n \n                Append_To (Stmts,\n@@ -4758,7 +4763,6 @@ package body Exp_Ch6 is\n             end;\n \n          --  For all other cases, generate:\n-         --\n          --    Temp_Id := <Alloc_Expr>;\n \n          else"}, {"sha": "59e63bde2463008f1f08f1b4128d0e3aa6c2f510", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -198,7 +198,7 @@ package body GNAT.Sockets is\n    procedure Check_For_Fd_Set (Fd : Socket_Type);\n    pragma Inline (Check_For_Fd_Set);\n    --  Raise Constraint_Error if Fd is less than 0 or greater than or equal to\n-   --  FD_SETSIZE.\n+   --  FD_SETSIZE, on platforms where fd_set is a bitmap.\n \n    --  Types needed for Datagram_Socket_Stream_Type\n \n@@ -468,6 +468,32 @@ package body GNAT.Sockets is\n       end if;\n    end Bind_Socket;\n \n+   ----------------------\n+   -- Check_For_Fd_Set --\n+   ----------------------\n+\n+   procedure Check_For_Fd_Set (Fd : Socket_Type) is\n+      use SOSC;\n+   begin\n+      --  On Windows, fd_set is a FD_SETSIZE array of socket ids:\n+      --  no check required. Warnings suppressed because condition\n+      --  is known at compile time.\n+\n+      pragma Warnings (Off);\n+      if Target_OS = Windows then\n+         pragma Warnings (On);\n+\n+         return;\n+\n+      --  On other platforms, fd_set is an FD_SETSIZE bitmap: check\n+      --  that Fd is within range (otherwise behaviour is undefined).\n+\n+      elsif Fd < 0 or else Fd >= SOSC.FD_SETSIZE then\n+         raise Constraint_Error with \"invalid value for socket set: \"\n+                                       & Image (Fd);\n+      end if;\n+   end Check_For_Fd_Set;\n+\n    --------------------\n    -- Check_Selector --\n    --------------------\n@@ -573,18 +599,6 @@ package body GNAT.Sockets is\n       Narrow (E_Socket_Set);\n    end Check_Selector;\n \n-   ----------------------\n-   -- Check_For_Fd_Set --\n-   ----------------------\n-\n-   procedure Check_For_Fd_Set (Fd : Socket_Type) is\n-   begin\n-      if Fd < 0 or else Fd >= SOSC.FD_SETSIZE then\n-         raise Constraint_Error with \"invalid value for socket set: \"\n-                                       & Image (Fd);\n-      end if;\n-   end Check_For_Fd_Set;\n-\n    -----------\n    -- Clear --\n    -----------"}, {"sha": "f6e9a64cdc7a31a71fa8093fbdbe7fb2c687fc35", "filename": "gcc/ada/s-taprop-dummy.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-dummy.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -46,6 +46,13 @@ package body System.Task_Primitives.Operations is\n    pragma Warnings (Off);\n    --  Turn off warnings since so many unreferenced parameters\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ----------------\n    -- Abort_Task --\n    ----------------\n@@ -252,15 +259,6 @@ package body System.Task_Primitives.Operations is\n       return 0.0;\n    end Monotonic_Clock;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    ---------------\n    -- Read_Lock --\n    ---------------"}, {"sha": "346de43ba0521c7616aac67650e29ba2c4207b9d", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -39,7 +39,6 @@ pragma Polling (Off);\n --  operations. It causes infinite loops and other problems.\n \n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n \n@@ -130,6 +129,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -696,15 +702,6 @@ package body System.Task_Primitives.Operations is\n       Specific.Set (Self_ID);\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -839,12 +836,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       if not Single_Lock then\n@@ -859,11 +851,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "264690499203161a142704ae2d55142e5b772626", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -39,7 +39,6 @@ pragma Polling (Off);\n --  operations. It causes infinite loops and other problems.\n \n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n \n@@ -127,6 +126,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -699,15 +705,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -901,12 +898,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       if not Single_Lock then\n@@ -921,11 +913,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "84c663a282ae4701243a1c4c0599c2b5a7f8f7ab", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -38,8 +38,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Ada.Unchecked_Deallocation;\n-\n with Interfaces.C;\n \n with System.Task_Info;\n@@ -137,6 +135,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -731,15 +736,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -978,12 +974,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       if not Single_Lock then\n@@ -999,11 +990,8 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       SC.Invalidate_Stack_Cache (T.Common.Compiler_Data.Pri_Stack_Info'Access);\n-      Free (Tmp);\n \n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "d26568f4522cef708f6a1648038672c11cc81e87", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -38,8 +38,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Ada.Unchecked_Deallocation;\n-\n with Interfaces.C;\n with Interfaces.C.Strings;\n \n@@ -176,6 +174,13 @@ package body System.Task_Primitives.Operations is\n \n    end Specific;\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -820,15 +825,6 @@ package body System.Task_Primitives.Operations is\n          Self_ID.Common.Compiler_Data.Pri_Stack_Info.Limit'Address);\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -987,13 +983,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Self_ID   : Task_Id := T;\n       Result    : DWORD;\n       Succeeded : BOOL;\n-      Is_Self   : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1017,11 +1008,7 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Succeeded = Win32.TRUE);\n       end if;\n \n-      Free (Self_ID);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "eb1b77147ec68bdbf1589c1f0e8703f414621e31", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -45,7 +45,6 @@ pragma Polling (Off);\n --  operations. It causes infinite loops and other problems.\n \n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n \n@@ -144,6 +143,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -782,15 +788,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -1000,12 +997,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       if not Single_Lock then\n@@ -1020,11 +1012,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "b5fe1ee9d42c05be8338e91589d3675f41394a7d", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -38,8 +38,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Ada.Unchecked_Deallocation;\n-\n with Interfaces.C;\n \n with System.Multiprocessors;\n@@ -226,6 +224,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -868,26 +873,15 @@ package body System.Task_Primitives.Operations is\n    procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := thr_self;\n-\n-      Self_ID.Common.LL.LWP := lwp_self;\n+      Self_ID.Common.LL.LWP    := lwp_self;\n \n       Set_Task_Affinity (Self_ID);\n-\n       Specific.Set (Self_ID);\n \n       --  We need the above code even if we do direct fetch of Task_Id in Self\n       --  for the main task on Sun, x86 Solaris and for gcc 2.7.2.\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -1032,12 +1026,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       T.Common.LL.Thread := Null_Thread_Id;\n@@ -1054,11 +1043,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "b0b727d9bb1005eb7057fbecdae4cdb5f813faf9", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -38,8 +38,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Ada.Unchecked_Deallocation;\n-\n with Interfaces;\n with Interfaces.C;\n \n@@ -127,6 +125,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -695,15 +700,6 @@ package body System.Task_Primitives.Operations is\n       Specific.Set (Self_ID);\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -930,12 +926,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       if not Single_Lock then\n@@ -950,11 +941,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "92b6023bdff3c63080de3901bfb308b4ee6db693", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -39,7 +39,6 @@ pragma Polling (Off);\n --  operations. It causes infinite loops and other problems.\n \n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n \n@@ -114,6 +113,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -680,15 +686,6 @@ package body System.Task_Primitives.Operations is\n       Specific.Set (Self_ID);\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -839,12 +836,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : Interfaces.C.int;\n-      Tmp     : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : Interfaces.C.int;\n \n    begin\n       if not Single_Lock then\n@@ -859,11 +851,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Set (null);\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "6b3c35eafe3d077b16797100a110f52811268a91", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -39,7 +39,6 @@ pragma Polling (Off);\n --  operations. It causes infinite loops and other problems.\n \n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n \n@@ -140,6 +139,13 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n@@ -828,15 +834,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Enter_Task;\n \n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n    -------------------\n    -- Is_Valid_Task --\n    -------------------\n@@ -986,12 +983,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result  : int;\n-      Tmp     : Task_Id          := T;\n-      Is_Self : constant Boolean := (T = Self);\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+      Result : int;\n \n    begin\n       if not Single_Lock then\n@@ -1008,11 +1000,7 @@ package body System.Task_Primitives.Operations is\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n \n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Specific.Delete;\n-      end if;\n+      ATCB_Allocation.Free_ATCB (T);\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "12fbd71386e73a5d735c3fd1988e53cc266ffb99", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -87,9 +87,24 @@ package System.Task_Primitives.Operations is\n    --  The effects of further calls to operations defined below on the task\n    --  are undefined thereafter.\n \n-   function New_ATCB (Entry_Num : ST.Task_Entry_Index) return ST.Task_Id;\n-   pragma Inline (New_ATCB);\n-   --  Allocate a new ATCB with the specified number of entries\n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package ATCB_Allocation is\n+\n+      function New_ATCB (Entry_Num : ST.Task_Entry_Index) return ST.Task_Id;\n+      pragma Inline (New_ATCB);\n+      --  Allocate a new ATCB with the specified number of entries\n+\n+      procedure Free_ATCB (T : ST.Task_Id);\n+      pragma Inline (Free_ATCB);\n+      --  Deallocate an ATCB previously allocated by New_ATCB\n+\n+   end ATCB_Allocation;\n+\n+   function New_ATCB (Entry_Num : ST.Task_Entry_Index) return ST.Task_Id\n+     renames ATCB_Allocation.New_ATCB;\n \n    procedure Initialize_TCB (Self_ID : ST.Task_Id; Succeeded : out Boolean);\n    pragma Inline (Initialize_TCB);"}, {"sha": "d31313708f780b2fdc9b5fd3fa083e8e9252cb51", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -1150,6 +1150,12 @@ package System.Tasking is\n       --\n       --  Protection: Self.L. Once a task has set Self.Stage to Completing, it\n       --  has exclusive access to this field.\n+\n+      Free_On_Termination : Boolean := False;\n+      --  Deallocate the ATCB when the task terminates. This flag is normally\n+      --  False, and is set True when Unchecked_Deallocation is called on a\n+      --  non-terminated task so that the associated storage is automatically\n+      --  reclaimed when the task terminates.\n    end record;\n \n    --------------------"}, {"sha": "6449bf6b01715f31852b2c20d5f77ac9e4153539", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -969,12 +969,11 @@ package body System.Tasking.Stages is\n          Free_Entry_Names (T);\n          System.Task_Primitives.Operations.Finalize_TCB (T);\n \n-      --  If the task is not terminated, then we simply ignore the call. This\n-      --  happens when a user program attempts an unchecked deallocation on\n-      --  a non-terminated task.\n-\n       else\n-         null;\n+         --  If the task is not terminated, then mark the task as to be freed\n+         --  upon termination.\n+\n+         T.Free_On_Termination := True;\n       end if;\n    end Free_Task;\n \n@@ -1429,6 +1428,7 @@ package body System.Tasking.Stages is\n    procedure Terminate_Task (Self_ID : Task_Id) is\n       Environment_Task : constant Task_Id := STPO.Environment_Task;\n       Master_of_Task   : Integer;\n+      Deallocate       : Boolean;\n \n    begin\n       Debug.Task_Termination_Hook;\n@@ -1474,6 +1474,7 @@ package body System.Tasking.Stages is\n       Stack_Guard (Self_ID, False);\n \n       Utilities.Make_Passive (Self_ID, Task_Completed => True);\n+      Deallocate := Self_ID.Free_On_Termination;\n \n       if Single_Lock then\n          Unlock_RTS;\n@@ -1485,7 +1486,12 @@ package body System.Tasking.Stages is\n       Initialization.Final_Task_Unlock (Self_ID);\n \n       --  WARNING: past this point, this thread must assume that the ATCB has\n-      --  been deallocated. It should not be accessed again.\n+      --  been deallocated, and can't access it anymore (which is why we have\n+      --  saved the Free_On_Termination flag in a temporary variable).\n+\n+      if Deallocate then\n+         Free_Task (Self_ID);\n+      end if;\n \n       if Master_of_Task > 0 then\n          STPO.Exit_Task;"}, {"sha": "0e79f457068e6d7a6cad35a3dc7cbcf4eca3c35c", "filename": "gcc/ada/s-tpoaal.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-tpoaal.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fs-tpoaal.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoaal.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -0,0 +1,79 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--             SYSTEM.TASK_PRIMITIVES.OPERATIONS.ATCB_ALLOCATION            --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+separate (System.Task_Primitives.Operations)\n+package body ATCB_Allocation is\n+\n+   ---------------\n+   -- Free_ATCB --\n+   ---------------\n+\n+   procedure Free_ATCB (T : Task_Id) is\n+      Tmp     : Task_Id := T;\n+      Is_Self : constant Boolean := T = Self;\n+\n+      procedure Free is new\n+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+\n+   begin\n+      if Is_Self then\n+         declare\n+            Local_ATCB : aliased Ada_Task_Control_Block (0);\n+            --  Create a dummy ATCB and initialize it minimally so that \"Free\"\n+            --  can still call Self and Defer/Undefer_Abort after Tmp is freed\n+            --  by the underlying memory management library.\n+\n+         begin\n+            Local_ATCB.Common.LL.Thread        := T.Common.LL.Thread;\n+            Local_ATCB.Common.Current_Priority := T.Common.Current_Priority;\n+\n+            Specific.Set (Local_ATCB'Unchecked_Access);\n+            Free (Tmp);\n+            Specific.Set (null);\n+         end;\n+\n+      else\n+         Free (Tmp);\n+      end if;\n+   end Free_ATCB;\n+\n+   --------------\n+   -- New_ATCB --\n+   --------------\n+\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n+   begin\n+      return new Ada_Task_Control_Block (Entry_Num);\n+   end New_ATCB;\n+\n+end ATCB_Allocation;"}, {"sha": "2655b25eddf6ea1617fc321872077b5a60006294", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -1289,25 +1289,9 @@ package body Sem_Ch13 is\n                when Aspect_Invariant      |\n                     Aspect_Type_Invariant =>\n \n-                  --  Check placement legality: An invariant must apply to a\n-                  --  private type, or appear in the private part of a spec.\n-                  --  Analysis of the pragma will verify that in the private\n-                  --  part it applies to a completion.\n-\n-                  if Nkind_In (N, N_Private_Type_Declaration,\n-                                  N_Private_Extension_Declaration)\n-                  then\n-                     null;\n-\n-                  elsif Nkind (N) = N_Full_Type_Declaration\n-                    and then In_Private_Part (Current_Scope)\n-                  then\n-                     null;\n-\n-                  else\n-                     Error_Msg_N\n-                       (\"invariant aspect must apply to a private type\", N);\n-                  end if;\n+                  --  Analysis of the pragma will verify placement legality:\n+                  --  an invariant must apply to a private type, or appear in\n+                  --  the private part of a spec and apply to a completion.\n \n                   --  Construct the pragma\n "}, {"sha": "6c561dafc7101178594013508bba443857b09258", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -1859,9 +1859,12 @@ package body Sem_Ch8 is\n               Statements (Handled_Statement_Sequence (New_Body)));\n \n             --  The generated body does not freeze. It is analyzed when the\n-            --  generated operation is frozen.\n+            --  generated operation is frozen. This body is only needed if\n+            --  expansion is enabled.\n \n-            Append_Freeze_Action (Defining_Entity (New_Decl), New_Body);\n+            if Expander_Active then\n+               Append_Freeze_Action (Defining_Entity (New_Decl), New_Body);\n+            end if;\n \n             Result := Defining_Entity (New_Decl);\n          end if;"}, {"sha": "2ca94177c44257ba5027527c809c38ac4c5c0a5c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 105, "deletions": 57, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f92d9d598953d329db09f4dbb0447d85717d88/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f4f92d9d598953d329db09f4dbb0447d85717d88", "patch": "@@ -29,63 +29,65 @@\n --  to complete the syntax checks. Certain pragmas are handled partially or\n --  completely by the parser (see Par.Prag for further details).\n \n-with Atree;    use Atree;\n-with Casing;   use Casing;\n-with Checks;   use Checks;\n-with Csets;    use Csets;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Exp_Dist; use Exp_Dist;\n-with Exp_Util; use Exp_Util;\n-with Freeze;   use Freeze;\n-with Lib;      use Lib;\n-with Lib.Writ; use Lib.Writ;\n-with Lib.Xref; use Lib.Xref;\n-with Namet.Sp; use Namet.Sp;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-with Par_SCO;  use Par_SCO;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch12; use Sem_Ch12;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Dist; use Sem_Dist;\n-with Sem_Elim; use Sem_Elim;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Intr; use Sem_Intr;\n-with Sem_Mech; use Sem_Mech;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Type; use Sem_Type;\n-with Sem_Util; use Sem_Util;\n-with Sem_VFpt; use Sem_VFpt;\n-with Sem_Warn; use Sem_Warn;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinfo.CN; use Sinfo.CN;\n-with Sinput;   use Sinput;\n-with Snames;   use Snames;\n-with Stringt;  use Stringt;\n-with Stylesw;  use Stylesw;\n+with System.Case_Util;\n+\n+with Atree;            use Atree;\n+with Casing;           use Casing;\n+with Checks;           use Checks;\n+with Csets;            use Csets;\n+with Debug;            use Debug;\n+with Einfo;            use Einfo;\n+with Elists;           use Elists;\n+with Errout;           use Errout;\n+with Exp_Dist;         use Exp_Dist;\n+with Exp_Util;         use Exp_Util;\n+with Freeze;           use Freeze;\n+with Lib;              use Lib;\n+with Lib.Writ;         use Lib.Writ;\n+with Lib.Xref;         use Lib.Xref;\n+with Namet.Sp;         use Namet.Sp;\n+with Nlists;           use Nlists;\n+with Nmake;            use Nmake;\n+with Opt;              use Opt;\n+with Output;           use Output;\n+with Par_SCO;          use Par_SCO;\n+with Restrict;         use Restrict;\n+with Rident;           use Rident;\n+with Rtsfind;          use Rtsfind;\n+with Sem;              use Sem;\n+with Sem_Aux;          use Sem_Aux;\n+with Sem_Ch3;          use Sem_Ch3;\n+with Sem_Ch6;          use Sem_Ch6;\n+with Sem_Ch8;          use Sem_Ch8;\n+with Sem_Ch12;         use Sem_Ch12;\n+with Sem_Ch13;         use Sem_Ch13;\n+with Sem_Disp;         use Sem_Disp;\n+with Sem_Dist;         use Sem_Dist;\n+with Sem_Elim;         use Sem_Elim;\n+with Sem_Eval;         use Sem_Eval;\n+with Sem_Intr;         use Sem_Intr;\n+with Sem_Mech;         use Sem_Mech;\n+with Sem_Res;          use Sem_Res;\n+with Sem_Type;         use Sem_Type;\n+with Sem_Util;         use Sem_Util;\n+with Sem_VFpt;         use Sem_VFpt;\n+with Sem_Warn;         use Sem_Warn;\n+with Stand;            use Stand;\n+with Sinfo;            use Sinfo;\n+with Sinfo.CN;         use Sinfo.CN;\n+with Sinput;           use Sinput;\n+with Snames;           use Snames;\n+with Stringt;          use Stringt;\n+with Stylesw;          use Stylesw;\n with Table;\n-with Targparm; use Targparm;\n-with Tbuild;   use Tbuild;\n+with Targparm;         use Targparm;\n+with Tbuild;           use Tbuild;\n with Ttypes;\n-with Uintp;    use Uintp;\n-with Uname;    use Uname;\n-with Urealp;   use Urealp;\n-with Validsw;  use Validsw;\n-with Warnsw;   use Warnsw;\n+with Uintp;            use Uintp;\n+with Uname;            use Uname;\n+with Urealp;           use Urealp;\n+with Validsw;          use Validsw;\n+with Warnsw;           use Warnsw;\n \n package body Sem_Prag is\n \n@@ -646,6 +648,17 @@ package body Sem_Prag is\n       --  Similar to above form of Error_Pragma_Arg except that two messages\n       --  are provided, the second is a continuation comment starting with \\.\n \n+      procedure Error_Pragma_Arg_Alternate_Name\n+        (Msg      : String;\n+         Arg      : Node_Id;\n+         Alt_Name : Name_Id);\n+      pragma No_Return (Error_Pragma_Arg_Alternate_Name);\n+      --  Outputs error message for current pragma, similar to\n+      --  Error_Pragma_Arg, except the source name of the aspect/pragma to use\n+      --  in warnings may be equal to Alt_Name (which should be equivalent to\n+      --  the name used in pragma). The location for the source name should be\n+      --  pointed to by Arg.\n+\n       procedure Error_Pragma_Arg_Ident (Msg : String; Arg : Node_Id);\n       pragma No_Return (Error_Pragma_Arg_Ident);\n       --  Outputs error message for current pragma. The message may contain\n@@ -2427,6 +2440,34 @@ package body Sem_Prag is\n          Error_Pragma_Arg (Msg2, Arg);\n       end Error_Pragma_Arg;\n \n+      -------------------------------------\n+      -- Error_Pragma_Arg_Alternate_Name --\n+      -------------------------------------\n+\n+      procedure Error_Pragma_Arg_Alternate_Name\n+        (Msg      : String;\n+         Arg      : Node_Id;\n+         Alt_Name : Name_Id)\n+      is\n+         MsgF        : String := Msg;\n+         Source_Name : String := Exact_Source_Name (Sloc (Arg));\n+         Alter_Name  : String := Get_Name_String (Alt_Name);\n+\n+      begin\n+         System.Case_Util.To_Lower (Source_Name);\n+         System.Case_Util.To_Lower (Alter_Name);\n+\n+         if Source_Name = Alter_Name then\n+            Error_Msg_Name_1 := Alt_Name;\n+         else\n+            Error_Msg_Name_1 := Pname;\n+         end if;\n+\n+         Fix_Error (MsgF);\n+         Error_Msg_N (MsgF, Get_Pragma_Arg (Arg));\n+         raise Pragma_Exit;\n+      end Error_Pragma_Arg_Alternate_Name;\n+\n       ----------------------------\n       -- Error_Pragma_Arg_Ident --\n       ----------------------------\n@@ -10140,9 +10181,16 @@ package body Sem_Prag is\n             then\n                null;\n \n+            elsif In_Private_Part (Current_Scope) then\n+               Error_Pragma_Arg_Alternate_Name\n+                 (\"pragma% only allowed for private type \" &\n+                  \"declared in visible part\", Arg1,\n+                  Alt_Name => Name_Type_Invariant);\n+\n             else\n-               Error_Pragma_Arg\n-                 (\"pragma% only allowed for private type\", Arg1);\n+               Error_Pragma_Arg_Alternate_Name\n+                 (\"pragma% only allowed for private type\", Arg1,\n+                  Alt_Name => Name_Type_Invariant);\n             end if;\n \n             --  Note that the type has at least one invariant, and also that"}]}