{"sha": "2050a1bbac14451de357a7d78ffdc6621f49ab30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1MGExYmJhYzE0NDUxZGUzNTdhN2Q3OGZmZGM2NjIxZjQ5YWIzMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-01-10T20:30:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-01-10T20:30:56Z"}, "message": "re PR c++/9128 (Typeid does not work on polymorphic classes)\n\n\n\tPR c++/9128\n\t* g++.dg/rtti/typeid1.C: New file.\n\n\tPR c++/9153\n\t* g++.dg/parse/lookup1.C: New file.\n\n\tPR c++/9171\n\t* g++.dg/templ/spec5.C: New file.\n\n\t* cp-tree.h (reparse_absdcl_as_expr): Remove.\n\t(reparse_absdcl_as_casts): Likewise.\n\t(reparse_decl_as_expr): Likewise.\n\t(finish_decl_parsing): Likewise.\n\t* decl2.c (reparse_absdcl_as_expr): Remove.\n\t(reparse_absdcl_as_casts): Likewise.\n\t(repase_decl_as_expr): Likewise.\n\t(finish_decl_parsing): Likewise.\n\n\tPR c++/9128\n\tPR c++/9153\n\tPR c++/9171\n\t* parser.c (cp_parser_pre_parsed_nested_name_specifier): New\n\tfunction.\n\t(cp_parser_nested_name_specifier_opt): Correct the\n\tcheck_dependency_p false.\n\t(cp_parser_postfix_expression): Fix formatting.\n\t(cp_parser_decl_specifier_seq): Avoid looking for constructor\n\tdeclarators when possible.\n\t(cp_parser_template_id): Avoid performing name-lookup when\n\tpossible.\n\t(cp_parser_class_head): Do not count specializations when counting\n\tlevels of templates.\n\t(cp_parser_constructor_declarator_p): Return immediately if\n\tthere's no chance that the tokens form a constructor declarator.\n\t* rtti.c (throw_bad_typeid): Add comment.  Do not return an\n\texpression with reference type.\n\t(get_tinfo_decl_dynamic): Do not return an expression with\n\treference type.\n\t(build_typeid): Add comment.  Do not return an expression with\n\treference type.\n\t* typeck.c (build_class_member_access_expr): Improve handling of\n\tconditionals and comma-expressions as objects.\n\nFrom-SVN: r61166", "tree": {"sha": "2cea45ec7f50f69c10cd2f4336195b5e297a14be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cea45ec7f50f69c10cd2f4336195b5e297a14be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2050a1bbac14451de357a7d78ffdc6621f49ab30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2050a1bbac14451de357a7d78ffdc6621f49ab30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2050a1bbac14451de357a7d78ffdc6621f49ab30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2050a1bbac14451de357a7d78ffdc6621f49ab30/comments", "author": null, "committer": null, "parents": [{"sha": "0cdca92b467aa92deec2819ff65652b87af6f1ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cdca92b467aa92deec2819ff65652b87af6f1ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cdca92b467aa92deec2819ff65652b87af6f1ea"}], "stats": {"total": 422, "additions": 209, "deletions": 213}, "files": [{"sha": "6ea43a423d470b15c6ca864b427b6ae21b02bb79", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -1,3 +1,39 @@\n+2003-01-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (reparse_absdcl_as_expr): Remove.\n+\t(reparse_absdcl_as_casts): Likewise.\n+\t(reparse_decl_as_expr): Likewise.\n+\t(finish_decl_parsing): Likewise.\n+\t* decl2.c (reparse_absdcl_as_expr): Remove.\n+\t(reparse_absdcl_as_casts): Likewise.\n+\t(repase_decl_as_expr): Likewise.\n+\t(finish_decl_parsing): Likewise.\n+\n+\tPR c++/9128\n+\tPR c++/9153\n+\tPR c++/9171\n+\t* parser.c (cp_parser_pre_parsed_nested_name_specifier): New\n+\tfunction.\n+\t(cp_parser_nested_name_specifier_opt): Correct the\n+\tcheck_dependency_p false.\n+\t(cp_parser_postfix_expression): Fix formatting.\n+\t(cp_parser_decl_specifier_seq): Avoid looking for constructor\n+\tdeclarators when possible.\n+\t(cp_parser_template_id): Avoid performing name-lookup when\n+\tpossible.\n+\t(cp_parser_class_head): Do not count specializations when counting\n+\tlevels of templates.\n+\t(cp_parser_constructor_declarator_p): Return immediately if\n+\tthere's no chance that the tokens form a constructor declarator.\n+\t* rtti.c (throw_bad_typeid): Add comment.  Do not return an\n+\texpression with reference type.\n+\t(get_tinfo_decl_dynamic): Do not return an expression with\n+\treference type.\n+\t(build_typeid): Add comment.  Do not return an expression with\n+\treference type.\n+\t* typeck.c (build_class_member_access_expr): Improve handling of\n+\tconditionals and comma-expressions as objects.\n+\n 2003-01-09  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* decl.c (bad_specifiers): Fix parameter order error I introduced."}, {"sha": "46fd5b1c3514d6c95da5090a94c48a10330a082c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -3865,13 +3865,9 @@ extern void import_export_decl (tree);\n extern void import_export_tinfo\t(tree, tree, bool);\n extern tree build_cleanup\t\t\tPARAMS ((tree));\n extern void finish_file\t\t\t\tPARAMS ((void));\n-extern tree reparse_absdcl_as_expr\t\tPARAMS ((tree, tree));\n-extern tree reparse_absdcl_as_casts\t\tPARAMS ((tree, tree));\n extern tree build_expr_from_tree\t\tPARAMS ((tree));\n extern tree build_offset_ref_call_from_tree     (tree, tree);\n extern tree build_call_from_tree                (tree, tree, bool);\n-extern tree reparse_decl_as_expr (tree, tree);\n-extern tree finish_decl_parsing (tree);\n extern void set_decl_namespace (tree, tree, bool);\n extern tree current_decl_namespace              PARAMS ((void));\n extern void push_decl_namespace                 PARAMS ((tree));"}, {"sha": "47b841cbd3bdf90d463d87e37bd5e50aef159256", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -2876,79 +2876,6 @@ finish_file ()\n     }\n }\n \n-/* This is something of the form 'A()()()()()+1' that has turned out to be an\n-   expr.  Since it was parsed like a type, we need to wade through and fix\n-   that.  Unfortunately, since operator() is left-associative, we can't use\n-   tail recursion.  In the above example, TYPE is `A', and DECL is\n-   `()()()()()'.\n-\n-   Maybe this shouldn't be recursive, but how often will it actually be\n-   used?  (jason) */\n-\n-tree\n-reparse_absdcl_as_expr (type, decl)\n-     tree type, decl;\n-{\n-  /* do build_functional_cast (type, NULL_TREE) at bottom */\n-  if (TREE_OPERAND (decl, 0) == NULL_TREE)\n-    return build_functional_cast (type, NULL_TREE);\n-\n-  /* recurse */\n-  decl = reparse_absdcl_as_expr (type, TREE_OPERAND (decl, 0));\n-\n-  return finish_call_expr (decl, NULL_TREE, /*disallow_virtual=*/false);\n-}\n-\n-/* This is something of the form `int ((int)(int)(int)1)' that has turned\n-   out to be an expr.  Since it was parsed like a type, we need to wade\n-   through and fix that.  Since casts are right-associative, we are\n-   reversing the order, so we don't have to recurse.\n-\n-   In the above example, DECL is the `(int)(int)(int)', and EXPR is the\n-   `1'.  */\n-\n-tree\n-reparse_absdcl_as_casts (decl, expr)\n-     tree decl, expr;\n-{\n-  tree type;\n-  int non_void_p = 0;\n-  \n-  if (TREE_CODE (expr) == CONSTRUCTOR\n-      && TREE_TYPE (expr) == 0)\n-    {\n-      type = groktypename (TREE_VALUE (CALL_DECLARATOR_PARMS (decl)));\n-      decl = TREE_OPERAND (decl, 0);\n-\n-      if (processing_template_decl)\n-\tTREE_TYPE (expr) = type;\n-      else\n-\t{\n-\t  expr = digest_init (type, expr, (tree *) 0);\n-\t  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n-\t    {\n-\t      int failure = complete_array_type (type, expr, 1);\n-\t      my_friendly_assert (!failure, 78);\n-\t    }\n-\t}\n-    }\n-\n-  while (decl)\n-    {\n-      type = groktypename (TREE_VALUE (CALL_DECLARATOR_PARMS (decl)));\n-      decl = TREE_OPERAND (decl, 0);\n-      if (!VOID_TYPE_P (type))\n-\tnon_void_p = 1;\n-      expr = build_c_cast (type, expr);\n-    }\n-\n-  if (warn_old_style_cast && ! in_system_header\n-      && non_void_p && current_lang_name != lang_name_c)\n-    warning (\"use of old-style cast\");\n-\n-  return expr;\n-}\n-\n /* T is the parse tree for an expression.  Return the expression after\n    performing semantic analysis.  */\n \n@@ -3461,62 +3388,6 @@ build_call_from_tree (tree fn, tree args, bool disallow_virtual)\n   return finish_call_expr (fn, args, disallow_virtual);\n }\n \n-/* This is something of the form `int (*a)++' that has turned out to be an\n-   expr.  It was only converted into parse nodes, so we need to go through\n-   and build up the semantics.  Most of the work is done by\n-   build_expr_from_tree, above.\n-\n-   In the above example, TYPE is `int' and DECL is `*a'.  */\n-\n-tree\n-reparse_decl_as_expr (tree type, tree decl)\n-{\n-  decl = build_expr_from_tree (decl);\n-  if (type)\n-    return build_functional_cast (type, build_tree_list (NULL_TREE, decl));\n-  else\n-    return decl;\n-}\n-\n-/* This is something of the form `int (*a)' that has turned out to be a\n-   decl.  It was only converted into parse nodes, so we need to do the\n-   checking that make_{pointer,reference}_declarator do.  */\n-\n-tree\n-finish_decl_parsing (tree decl)\n-{\n-  switch (TREE_CODE (decl))\n-    {\n-    case IDENTIFIER_NODE:\n-      return decl;\n-    case INDIRECT_REF:\n-      return make_pointer_declarator\n-\t(NULL_TREE, finish_decl_parsing (TREE_OPERAND (decl, 0)));\n-    case ADDR_EXPR:\n-      return make_reference_declarator\n-\t(NULL_TREE, finish_decl_parsing (TREE_OPERAND (decl, 0)));\n-    case BIT_NOT_EXPR:\n-      TREE_OPERAND (decl, 0) = finish_decl_parsing (TREE_OPERAND (decl, 0));\n-      return decl;\n-    case SCOPE_REF:\n-      push_nested_class (TREE_TYPE (TREE_OPERAND (decl, 0)), 3);\n-      TREE_COMPLEXITY (decl) = current_class_depth;\n-      return decl;\n-    case ARRAY_REF:\n-      TREE_OPERAND (decl, 0) = finish_decl_parsing (TREE_OPERAND (decl, 0));\n-      return decl;\n-    case TREE_LIST:\n-      /* For attribute handling.  */\n-      TREE_VALUE (decl) = finish_decl_parsing (TREE_VALUE (decl));\n-      return decl;\n-    case TEMPLATE_ID_EXPR:\n-      return decl;\n-    default:\n-      abort ();\n-      return NULL_TREE;\n-    }\n-}\n-\n /* Return 1 if root encloses child.  */\n \n static bool"}, {"sha": "d626939e281aa07a18b56a8797507bac77c59280", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 95, "deletions": 49, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -1764,6 +1764,8 @@ static void cp_parser_check_class_key\n   (enum tag_types, tree type);\n static bool cp_parser_optional_template_keyword\n   (cp_parser *);\n+static void cp_parser_pre_parsed_nested_name_specifier \n+  (cp_parser *);\n static void cp_parser_cache_group\n   (cp_parser *, cp_token_cache *, enum cpp_ttype, unsigned);\n static void cp_parser_parse_tentatively \n@@ -3091,15 +3093,6 @@ cp_parser_primary_expression (cp_parser *parser,\n    function does not do this in order to avoid wastefully creating\n    SCOPE_REFs when they are not required.\n \n-   If ASSUME_TYPENAME_P is true then we assume that qualified names\n-   are typenames.  This flag is set when parsing a declarator-id;\n-   for something like:\n-\n-     template <class T>\n-     int S<T>::R::i = 3;\n-\n-   we are supposed to assume that `S<T>::R' is a class.\n-\n    If TEMPLATE_KEYWORD_P is true, then we have just seen the\n    `template' keyword.\n \n@@ -3460,36 +3453,30 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n   bool success = false;\n   tree access_check = NULL_TREE;\n   ptrdiff_t start;\n+  cp_token* token;\n \n   /* If the next token corresponds to a nested name specifier, there\n-     is no need to reparse it.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NESTED_NAME_SPECIFIER))\n-    {\n-      tree value;\n-      tree check;\n-\n-      /* Get the stored value.  */\n-      value = cp_lexer_consume_token (parser->lexer)->value;\n-      /* Perform any access checks that were deferred.  */\n-      for (check = TREE_PURPOSE (value); check; check = TREE_CHAIN (check))\n-\tcp_parser_defer_access_check (parser, \n-\t\t\t\t      TREE_PURPOSE (check),\n-\t\t\t\t      TREE_VALUE (check));\n-      /* Set the scope from the stored value.  */\n-      parser->scope = TREE_VALUE (value);\n-      parser->qualifying_scope = TREE_TYPE (value);\n-      parser->object_scope = NULL_TREE;\n+     is no need to reparse it.  However, if CHECK_DEPENDENCY_P is\n+     false, it may have been true before, in which case something \n+     like `A<X>::B<Y>::C' may have resulted in a nested-name-specifier\n+     of `A<X>::', where it should now be `A<X>::B<Y>::'.  So, when\n+     CHECK_DEPENDENCY_P is false, we have to fall through into the\n+     main loop.  */\n+  if (check_dependency_p\n+      && cp_lexer_next_token_is (parser->lexer, CPP_NESTED_NAME_SPECIFIER))\n+    {\n+      cp_parser_pre_parsed_nested_name_specifier (parser);\n       return parser->scope;\n     }\n \n   /* Remember where the nested-name-specifier starts.  */\n   if (cp_parser_parsing_tentatively (parser)\n       && !cp_parser_committed_to_tentative_parse (parser))\n     {\n-      cp_token *next_token = cp_lexer_peek_token (parser->lexer);\n+      token = cp_lexer_peek_token (parser->lexer);\n       start = cp_lexer_token_difference (parser->lexer,\n \t\t\t\t\t parser->lexer->first_token,\n-\t\t\t\t\t next_token);\n+\t\t\t\t\t token);\n       access_check = parser->context->deferred_access_checks;\n     }\n   else\n@@ -3500,13 +3487,25 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       tree new_scope;\n       tree old_scope;\n       tree saved_qualifying_scope;\n-      cp_token *token;\n       bool template_keyword_p;\n \n+      /* Spot cases that cannot be the beginning of a\n+\t nested-name-specifier.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+\n+      /* If the next token is CPP_NESTED_NAME_SPECIFIER, just process\n+\t the already parsed nested-name-specifier.  */\n+      if (token->type == CPP_NESTED_NAME_SPECIFIER)\n+\t{\n+\t  /* Grab the nested-name-specifier and continue the loop.  */\n+\t  cp_parser_pre_parsed_nested_name_specifier (parser);\n+\t  success = true;\n+\t  continue;\n+\t}\n+\n       /* Spot cases that cannot be the beginning of a\n \t nested-name-specifier.  On the second and subsequent times\n \t through the loop, we look for the `template' keyword.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n       if (success && token->keyword == RID_TEMPLATE)\n \t;\n       /* A template-id can start a nested-name-specifier.  */\n@@ -3631,7 +3630,6 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n      we issue duplicate error messages.  */\n   if (success && start >= 0)\n     {\n-      cp_token *token;\n       tree c;\n \n       /* Find the token that corresponds to the start of the\n@@ -4232,20 +4230,16 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t      postfix_expression = (build_offset_ref_call_from_tree\n \t\t\t\t    (postfix_expression, args));\n \t    else if (idk == CP_PARSER_ID_KIND_QUALIFIED)\n-\t      {\n-\t\t/* A call to a static class member, or a\n-\t\t   namespace-scope function.  */\n-\t\tpostfix_expression\n-\t\t  = finish_call_expr (postfix_expression, args,\n-\t\t\t\t      /*disallow_virtual=*/true);\n-\t      }\n+\t      /* A call to a static class member, or a namespace-scope\n+\t\t function.  */\n+\t      postfix_expression\n+\t\t= finish_call_expr (postfix_expression, args,\n+\t\t\t\t    /*disallow_virtual=*/true);\n \t    else\n-\t      {\n-\t\t/* All other function calls.  */\n-\t\tpostfix_expression \n-\t\t  = finish_call_expr (postfix_expression, args, \n-\t\t\t\t      /*disallow_virtual=*/false);\n-\t      }\n+\t      /* All other function calls.  */\n+\t      postfix_expression \n+\t\t= finish_call_expr (postfix_expression, args, \n+\t\t\t\t    /*disallow_virtual=*/false);\n \n \t    /* The POSTFIX_EXPRESSION is certainly no longer an id.  */\n \t    idk = CP_PARSER_ID_KIND_NONE;\n@@ -6903,6 +6897,7 @@ cp_parser_decl_specifier_seq (parser, flags, attributes,\n {\n   tree decl_specs = NULL_TREE;\n   bool friend_p = false;\n+  bool constructor_possible_p = true;\n \n   /* Assume no class or enumeration type is declared.  */\n   *declares_class_or_enum = false;\n@@ -6961,6 +6956,8 @@ cp_parser_decl_specifier_seq (parser, flags, attributes,\n \t  decl_spec = token->value;\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n+\t  /* A constructor declarator cannot appear in a typedef.  */\n+\t  constructor_possible_p = false;\n \t  break;\n \n \t  /* storage-class-specifier:\n@@ -6988,6 +6985,7 @@ cp_parser_decl_specifier_seq (parser, flags, attributes,\n       /* Constructors are a special case.  The `S' in `S()' is not a\n \t decl-specifier; it is the beginning of the declarator.  */\n       constructor_p = (!decl_spec \n+\t\t       && constructor_possible_p\n \t\t       && cp_parser_constructor_declarator_p (parser,\n \t\t\t\t\t\t\t      friend_p));\n \n@@ -7045,6 +7043,9 @@ cp_parser_decl_specifier_seq (parser, flags, attributes,\n \t     error message later.  */\n \t  if (decl_spec && !is_cv_qualifier)\n \t    flags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n+\t  /* A constructor declarator cannot follow a type-specifier.  */\n+\t  if (decl_spec)\n+\t    constructor_possible_p = false;\n \t}\n \n       /* If we still do not have a DECL_SPEC, then there are no more\n@@ -8102,10 +8103,12 @@ cp_parser_template_id (cp_parser *parser,\n   bool saved_greater_than_is_operator_p;\n   ptrdiff_t start_of_id;\n   tree access_check = NULL_TREE;\n+  cp_token *next_token;\n \n   /* If the next token corresponds to a template-id, there is no need\n      to reparse it.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_TEMPLATE_ID))\n+  next_token = cp_lexer_peek_token (parser->lexer);\n+  if (next_token->type == CPP_TEMPLATE_ID)\n     {\n       tree value;\n       tree check;\n@@ -8121,11 +8124,21 @@ cp_parser_template_id (cp_parser *parser,\n       return TREE_VALUE (value);\n     }\n \n+  /* Avoid performing name lookup if there is no possibility of\n+     finding a template-id.  */\n+  if ((next_token->type != CPP_NAME && next_token->keyword != RID_OPERATOR)\n+      || (next_token->type == CPP_NAME\n+\t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_LESS))\n+    {\n+      cp_parser_error (parser, \"expected template-id\");\n+      return error_mark_node;\n+    }\n+\n   /* Remember where the template-id starts.  */\n   if (cp_parser_parsing_tentatively (parser)\n       && !cp_parser_committed_to_tentative_parse (parser))\n     {\n-      cp_token *next_token = cp_lexer_peek_token (parser->lexer);\n+      next_token = cp_lexer_peek_token (parser->lexer);\n       start_of_id = cp_lexer_token_difference (parser->lexer,\n \t\t\t\t\t       parser->lexer->first_token,\n \t\t\t\t\t       next_token);\n@@ -10177,7 +10190,7 @@ cp_parser_direct_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n \t{\n \t  /* This is either a parameter-declaration-clause, or a\n   \t     parenthesized declarator. When we know we are parsing a\n-  \t     named declaratory, it must be a paranthesized declarator\n+  \t     named declarator, it must be a paranthesized declarator\n   \t     if FIRST is true. For instance, `(int)' is a\n   \t     parameter-declaration-clause, with an omitted\n   \t     direct-abstract-declarator. But `((*))', is a\n@@ -11851,7 +11864,7 @@ cp_parser_class_head (parser,\n \n      Handle this gracefully by accepting the extra qualifier, and then\n      issuing an error about it later if this really is a\n-     class-header.  If it turns out just to be an elaborated type\n+     class-head.  If it turns out just to be an elaborated type\n      specifier, remain silent.  */\n   if (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false))\n     qualified_p = true;\n@@ -11920,7 +11933,8 @@ cp_parser_class_head (parser,\n \t    if (TYPE_P (scope) \n \t\t&& CLASS_TYPE_P (scope)\n \t\t&& CLASSTYPE_TEMPLATE_INFO (scope)\n-\t\t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (scope)))\n+\t\t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (scope))\n+\t\t&& !CLASSTYPE_TEMPLATE_SPECIALIZATION (scope))\n \t      ++num_templates;\n \t}\n     }\n@@ -13983,6 +13997,16 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n   bool constructor_p;\n   tree type_decl = NULL_TREE;\n   bool nested_name_p;\n+  cp_token *next_token;\n+\n+  /* The common case is that this is not a constructor declarator, so\n+     try to avoid doing lots of work if at all possible.  */\n+  next_token = cp_lexer_peek_token (parser->lexer);\n+  if (next_token->type != CPP_NAME\n+      && next_token->type != CPP_SCOPE\n+      && next_token->type != CPP_NESTED_NAME_SPECIFIER\n+      && next_token->type != CPP_TEMPLATE_ID)\n+    return false;\n \n   /* Parse tentatively; we are going to roll back all of the tokens\n      consumed here.  */\n@@ -14830,6 +14854,28 @@ cp_parser_optional_template_keyword (cp_parser *parser)\n   return false;\n }\n \n+/* The next token is a CPP_NESTED_NAME_SPECIFIER.  Consume the token,\n+   set PARSER->SCOPE, and perform other related actions.  */\n+\n+static void\n+cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n+{\n+  tree value;\n+  tree check;\n+\n+  /* Get the stored value.  */\n+  value = cp_lexer_consume_token (parser->lexer)->value;\n+  /* Perform any access checks that were deferred.  */\n+  for (check = TREE_PURPOSE (value); check; check = TREE_CHAIN (check))\n+    cp_parser_defer_access_check (parser, \n+\t\t\t\t  TREE_PURPOSE (check),\n+\t\t\t\t  TREE_VALUE (check));\n+  /* Set the scope from the stored value.  */\n+  parser->scope = TREE_VALUE (value);\n+  parser->qualifying_scope = TREE_TYPE (value);\n+  parser->object_scope = NULL_TREE;\n+}\n+\n /* Add tokens to CACHE until an non-nested END token appears.  */\n \n static void"}, {"sha": "71b8e34b19982868f599dd6d8474815d230310ab", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -174,6 +174,9 @@ throw_bad_cast (void)\n   return build_call (fn, NULL_TREE);\n }\n \n+/* Return an expression for \"__cxa_bad_typeid()\".  The expression\n+   returned is an lvalue of type \"const std::type_info\".  */\n+\n static tree\n throw_bad_typeid (void)\n {\n@@ -187,17 +190,19 @@ throw_bad_typeid (void)\n       fn = push_throw_library_fn (fn, t);\n     }\n \n-  return build_call (fn, NULL_TREE);\n+  return convert_from_reference (build_call (fn, NULL_TREE));\n }\n \f\n-/* Return a pointer to type_info function associated with the expression EXP.\n-   If EXP is a reference to a polymorphic class, return the dynamic type;\n+/* Return an lvalue expression whose type is \"const std::type_info\"\n+   and whose value indicates the type of the expression EXP.  If EXP\n+   is a reference to a polymorphic class, return the dynamic type;\n    otherwise return the static type of the expression.  */\n \n static tree\n get_tinfo_decl_dynamic (tree exp)\n {\n   tree type;\n+  tree t;\n   \n   if (exp == error_mark_node)\n     return error_mark_node;\n@@ -221,18 +226,18 @@ get_tinfo_decl_dynamic (tree exp)\n   if (TYPE_POLYMORPHIC_P (type) && ! resolves_to_fixed_type_p (exp, 0))\n     {\n       /* build reference to type_info from vtable.  */\n-      tree t;\n       tree index;\n \n       /* The RTTI information is at index -1.  */\n       index = build_int_2 (-1 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n       t = build_vtbl_ref (exp, index);\n       TREE_TYPE (t) = type_info_ptr_type;\n-      return t;\n     }\n+  else\n+    /* Otherwise return the type_info for the static type of the expr.  */\n+    t = get_tinfo_ptr (TYPE_MAIN_VARIANT (type));\n \n-  /* Otherwise return the type_info for the static type of the expr.  */\n-  return get_tinfo_ptr (TYPE_MAIN_VARIANT (type));\n+  return build_indirect_ref (t, NULL);\n }\n \n static bool\n@@ -253,6 +258,9 @@ typeid_ok_p (void)\n   return true;\n }\n \n+/* Return an expression for \"typeid(EXP)\".  The expression returned is\n+   an lvalue of type \"const std::type_info\".  */\n+\n tree\n build_typeid (tree exp)\n {\n@@ -280,16 +288,14 @@ build_typeid (tree exp)\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n-  exp = build_indirect_ref (exp, NULL);\n-\n   if (cond)\n     {\n       tree bad = throw_bad_typeid ();\n \n       exp = build (COND_EXPR, TREE_TYPE (exp), cond, exp, bad);\n     }\n \n-  return convert_from_reference (exp);\n+  return exp;\n }\n \n /* Generate the NTBS name of a type.  */"}, {"sha": "e7921c55e1009e5c3c384bdecf6972c830887adc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -1865,27 +1865,6 @@ build_class_member_access_expr (tree object, tree member,\n   my_friendly_assert (DECL_P (member) || BASELINK_P (member),\n \t\t      20020801);\n \n-  /* Transform `(a, b).x' into `a, b.x' and `(a ? b : c).x' into \n-     `a ? b.x : c.x'.  These transformations should not really be\n-     necessary, but they are.  */\n-  if (TREE_CODE (object) == COMPOUND_EXPR)\n-    {\n-      result = build_class_member_access_expr (TREE_OPERAND (object, 1),\n-\t\t\t\t\t       member, access_path, \n-\t\t\t\t\t       preserve_reference);\n-      return build (COMPOUND_EXPR, TREE_TYPE (result), \n-\t\t    TREE_OPERAND (object, 0), result);\n-    }\n-  else if (TREE_CODE (object) == COND_EXPR)\n-    return (build_conditional_expr\n-\t    (TREE_OPERAND (object, 0),\n-\t     build_class_member_access_expr (TREE_OPERAND (object, 1),\n-\t\t\t\t\t     member, access_path,\n-\t\t\t\t\t     preserve_reference),\n-\t     build_class_member_access_expr (TREE_OPERAND (object, 2),\n-\t\t\t\t\t     member, access_path,\n-\t\t\t\t\t     preserve_reference)));\n-\n   /* [expr.ref]\n \n      The type of the first expression shall be \"class object\" (of a\n@@ -1925,6 +1904,34 @@ build_class_member_access_expr (tree object, tree member,\n       return error_mark_node;\n     }\n \n+  /* Transform `(a, b).x' into `(*(a, &b)).x' and `(a ? b : c).x' into\n+     `(*(a ?  &b : &c)).x'.  Unfortunately, expand_expr cannot handle a\n+     COMPONENT_REF where the first operand is a conditional or comma\n+     expression with class type.  */\n+  if (TREE_CODE (object) == COMPOUND_EXPR)\n+    {\n+      object = build (COMPOUND_EXPR, \n+\t\t      build_pointer_type (object_type),\n+\t\t      TREE_OPERAND (object, 0),\n+\t\t      build_unary_op (ADDR_EXPR, \n+\t\t\t\t      TREE_OPERAND (object, 1),\n+\t\t\t\t      /*noconvert=*/1));\n+      object = build_indirect_ref (object, NULL);\n+    }\n+  else if (TREE_CODE (object) == COND_EXPR)\n+    {\n+      object = build (COND_EXPR, \n+\t\t      build_pointer_type (object_type),\n+\t\t      TREE_OPERAND (object, 0),\n+\t\t      build_unary_op (ADDR_EXPR, \n+\t\t\t\t      TREE_OPERAND (object, 1),\n+\t\t\t\t      /*noconvert=*/1),\n+\t\t      build_unary_op (ADDR_EXPR, \n+\t\t\t\t      TREE_OPERAND (object, 2),\n+\t\t\t\t      /*noconvert=*/1));\n+      object = build_indirect_ref (object, NULL);\n+    }\n+\n   /* In [expr.ref], there is an explicit list of the valid choices for\n      MEMBER.  We check for each of those cases here.  */\n   if (TREE_CODE (member) == VAR_DECL)"}, {"sha": "e642d44faa571b309d3f57999c47a9a2d4a16f01", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -1,3 +1,14 @@\n+2003-01-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9128\n+\t* g++.dg/rtti/typeid1.C: New file.\n+\n+\tPR c++/9153\n+\t* g++.dg/parse/lookup1.C: New file.\n+\n+\tPR c++/9171\n+\t* g++.dg/templ/spec5.C: New file.\n+\t\n 2003-01-10  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* gcc.c-torture/compile/20030110-1.c: New test."}, {"sha": "0325d3c6926584dea149871d1a6d04d2476abba4", "filename": "gcc/testsuite/g++.dg/parse/lookup1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flookup1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flookup1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flookup1.C?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -0,0 +1,9 @@\n+#include <list>\n+\n+using namespace std;\n+\n+template <class T, class Alloc>\n+class new_list : public list<T, Alloc> {\n+public:\n+    typedef typename list<T, Alloc>::iterator iterator;\n+};"}, {"sha": "e26517576b9b053e835e3f2c33e9e413a12f889b", "filename": "gcc/testsuite/g++.dg/rtti/typeid1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Ftypeid1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Ftypeid1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Ftypeid1.C?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -0,0 +1,11 @@\n+#include <typeinfo>\n+\n+struct A {\n+  virtual ~A() {}\n+};\n+\n+int main() {\n+   A* a = new A;\n+   typeid(*a).name();\n+}\n+"}, {"sha": "ad101b01d6aee010d22e3094b4dd5266d2b77556", "filename": "gcc/testsuite/g++.dg/template/spec5.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2050a1bbac14451de357a7d78ffdc6621f49ab30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec5.C?ref=2050a1bbac14451de357a7d78ffdc6621f49ab30", "patch": "@@ -0,0 +1,3 @@\n+template <int i> struct A;\n+template <> struct A<0> { struct B; };\n+struct A<0>::B {};"}]}