{"sha": "050af1445b878d2a8a070f4c2ad602cbe80f8d73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwYWYxNDQ1Yjg3OGQyYThhMDcwZjRjMmFkNjAyY2JlODBmOGQ3Mw==", "commit": {"author": {"name": "Matthew Fortune", "email": "matthew.fortune@imgtec.com", "date": "2014-11-12T21:39:46Z"}, "committer": {"name": "Matthew Fortune", "email": "mpf@gcc.gnu.org", "date": "2014-11-12T21:39:46Z"}, "message": "Implement MIPS o32 FPXX, FP64, FP64A ABI extensions.\n\n2014-11-12  Matthew Fortune  <matthew.fortune@imgtec.com>\n\ngcc/\n\t* common/config/mips/mips-common.c (mips_handle_option): Ensure\n\tthat -mfp32, -mfp64 disable -mfpxx and -mfpxx disables -mfp64.\n\t* config.gcc (--with-fp-32): New option.\n\t(--with-odd-spreg-32): Likewise.\n\t* config.in (HAVE_AS_DOT_MODULE): New config define.\n\t* config/mips/mips-protos.h\n\t(mips_secondary_memory_needed): New prototype.\n\t(mips_hard_regno_caller_save_mode): Likewise.\n\t* config/mips/mips.c (mips_get_reg_raw_mode): New static prototype.\n\t(mips_get_arg_info): Assert that V2SFmode is only handled specially\n\twith TARGET_PAIRED_SINGLE_FLOAT.\n\t(mips_return_mode_in_fpr_p): Likewise.\n\t(mips16_call_stub_mode_suffix): Likewise.\n\t(mips_get_reg_raw_mode): New static function.\n\t(mips_return_fpr_pair): O32 return values span two registers.\n\t(mips16_build_call_stub): Likewise.\n\t(mips_function_value_regno_p): Support both FP return registers.\n\t(mips_output_64bit_xfer): Use mthc1 whenever TARGET_HAS_MXHC1.  Add\n\tspecific cases for TARGET_FPXX to move via memory.\n\t(mips_dwarf_register_span): For TARGET_FPXX pretend that modes larger\n\tthan UNITS_PER_FPREG 'span' one register.\n\t(mips_dwarf_frame_reg_mode): New static function.\n\t(mips_file_start): Switch to using .module instead of .gnu_attribute.\n\tNo longer support FP ABI 4 (-mips32r2 -mfp64), replace with FP ABI 6.\n\tAdd FP ABI 5 (-mfpxx) and FP ABI 7 (-mfp64 -mno-odd-spreg).\n\t(mips_save_reg, mips_restore_reg): Always represent DFmode frame\n\tslots with two CFI directives even for O32 FP64.\n\t(mips_for_each_saved_gpr_and_fpr): Account for fixed_regs when\n\tsaving/restoring callee-saved registers.\n\t(mips_hard_regno_mode_ok_p): Implement O32 FP64A extension.\n\t(mips_secondary_memory_needed): New function.\n\t(mips_option_override): ABI check for TARGET_FLOATXX.  Disable\n\todd-numbered single-precision registers\twhen using TARGET_FLOATXX.\n\tImplement -modd-spreg and defaults.\n\t(mips_conditional_register_usage): Redefine O32 FP64 to match O32 FP32\n\tcallee-saved behaviour.\n\t(mips_hard_regno_caller_save_mode): Implement.\n\t(TARGET_GET_RAW_RESULT_MODE): Define target hook.\n\t(TARGET_GET_RAW_ARG_MODE): Define target hook.\n\t(TARGET_DWARF_FRAME_REG_MODE): Define target hook.\n\t* config/mips/mips.h (TARGET_FLOAT32): New macro.\n\t(TARGET_O32_FP64A_ABI): Likewise.\n\t(TARGET_CPU_CPP_BUILTINS): TARGET_FPXX is __mips_fpr==0. Add\n\t_MIPS_SPFPSET builtin define.\n\t(MIPS_FPXX_OPTION_SPEC): New macro.\n\t(OPTION_DEFAULT_SPECS): Pass through --with-fp-32=* to -mfp and\n\t--with-odd-spreg-32=* to -m[no-]odd-spreg.\n\t(ISA_HAS_ODD_SPREG): New macro.\n\t(ISA_HAS_MXHC1): True for anything other than -mfp32.\n\t(ASM_SPEC): Pass through mfpxx, mfp64, -mno-odd-spreg and -modd-spreg.\n\t(MIN_FPRS_PER_FMT): Redefine in terms of TARGET_ODD_SPREG.\n\t(HARD_REGNO_CALLER_SAVE_MODE): Define.  Implement O32 FPXX extension\n\t(HARD_REGNO_CALL_PART_CLOBBERED): Likewise.\n\t(SECONDARY_MEMORY_NEEDED): Likewise.\n\t(FUNCTION_ARG_REGNO_P): Update for O32 FPXX and FP64 extensions.\n\t* config/mips/mips.md (define_attr enabled): Implement O32 FPXX and\n\tFP64A ABI extensions.\n\t(move_doubleword_fpr<mode>): Use ISA_HAS_MXHC1 instead of\n\tTARGET_FLOAT64.\n\t* config/mips/mips.opt (mfpxx): New target option.\n\t(modd-spreg): Likewise.\n\t* config/mips/mti-elf.h (DRIVER_SELF_SPECS): Infer FP ABI from arch.\n\t* config/mips/mti-linux.h (DRIVER_SELF_SPECS): Likewise and remove\n\tfp64 sysroot.\n\t* config/mips/t-mti-elf: Remove fp64 multilib.\n\t* config/mips/t-mti-linux: Likewise.\n\t* configure.ac: Detect .module support.\n\t* configure: Regenerate.\n\t* doc/invoke.texi: Document -mfpxx, -modd-spreg, -mno-odd-spreg option.\n\t* doc/install.texi (--with-fp-32, --with-odd-spreg-32): Document new\n\toptions.\n\ngcc/testsuite/\n\t* gcc.target/mips/args-1.c: Handle __mips_fpr == 0.\n\t* gcc.target/mips/call-clobbered-1.c: New.\n\t* gcc.target/mips/call-clobbered-2.c: New.\n\t* gcc.target/mips/call-clobbered-3.c: New.\n\t* gcc.target/mips/call-clobbered-4.c: New.\n\t* gcc.target/mips/call-clobbered-5.c: New.\n\t* gcc.target/mips/call-saved-4.c: New.\n\t* gcc.target/mips/call-saved-5.c: New.\n\t* gcc.target/mips/call-saved-6.c: New.\n\t* gcc.target/mips/mips.exp: Support -mfpxx, -ffixed-f*,\n\tand -m[no-]odd-spreg.  Use _MIPS_SPFPSET to determine default\n\todd-spreg option.  Account for -modd-spreg in minimum arch code.\n\t* gcc.target/mips/movdf-1.c: New.\n\t* gcc.target/mips/movdf-2.c: New.\n\t* gcc.target/mips/movdf-3.c: New.\n\t* gcc.target/mips/oddspreg-1.c: New.\n\t* gcc.target/mips/oddspreg-2.c: New.\n\t* gcc.target/mips/oddspreg-3.c: New.\n\t* gcc.target/mips/oddspreg-4.c: New.\n\t* gcc.target/mips/oddspreg-5.c: New.\n\t* gcc.target/mips/oddspreg-6.c: New.\n\nlibgcc/\n\t* config/mips/mips16.S: Set .module when supported.  Update O32\n\tFP64 calling convention and use for FPXX when possible.  Add FPXX\n\tcalling convention fallback case.\n\nFrom-SVN: r217446", "tree": {"sha": "ae5a1e2880c64a6507d463ca40e21b1f5abaf535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5a1e2880c64a6507d463ca40e21b1f5abaf535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/050af1445b878d2a8a070f4c2ad602cbe80f8d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050af1445b878d2a8a070f4c2ad602cbe80f8d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050af1445b878d2a8a070f4c2ad602cbe80f8d73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050af1445b878d2a8a070f4c2ad602cbe80f8d73/comments", "author": {"login": "mfortune", "id": 10220247, "node_id": "MDQ6VXNlcjEwMjIwMjQ3", "avatar_url": "https://avatars.githubusercontent.com/u/10220247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mfortune", "html_url": "https://github.com/mfortune", "followers_url": "https://api.github.com/users/mfortune/followers", "following_url": "https://api.github.com/users/mfortune/following{/other_user}", "gists_url": "https://api.github.com/users/mfortune/gists{/gist_id}", "starred_url": "https://api.github.com/users/mfortune/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mfortune/subscriptions", "organizations_url": "https://api.github.com/users/mfortune/orgs", "repos_url": "https://api.github.com/users/mfortune/repos", "events_url": "https://api.github.com/users/mfortune/events{/privacy}", "received_events_url": "https://api.github.com/users/mfortune/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "21c767169b833b6c22f8b1e8550e95ef792b6fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c767169b833b6c22f8b1e8550e95ef792b6fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c767169b833b6c22f8b1e8550e95ef792b6fd1"}], "stats": {"total": 1007, "additions": 955, "deletions": 52}, "files": [{"sha": "a15bfd2c5cc57becbcdcaa9ae6436f011839dd90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -1,3 +1,77 @@\n+2014-11-12  Matthew Fortune  <matthew.fortune@imgtec.com>\n+\n+\t* common/config/mips/mips-common.c (mips_handle_option): Ensure\n+\tthat -mfp32, -mfp64 disable -mfpxx and -mfpxx disables -mfp64.\n+\t* config.gcc (--with-fp-32): New option.\n+\t(--with-odd-spreg-32): Likewise.\n+\t* config.in (HAVE_AS_DOT_MODULE): New config define.\n+\t* config/mips/mips-protos.h\n+\t(mips_secondary_memory_needed): New prototype.\n+\t(mips_hard_regno_caller_save_mode): Likewise.\n+\t* config/mips/mips.c (mips_get_reg_raw_mode): New static prototype.\n+\t(mips_get_arg_info): Assert that V2SFmode is only handled specially\n+\twith TARGET_PAIRED_SINGLE_FLOAT.\n+\t(mips_return_mode_in_fpr_p): Likewise.\n+\t(mips16_call_stub_mode_suffix): Likewise.\n+\t(mips_get_reg_raw_mode): New static function.\n+\t(mips_return_fpr_pair): O32 return values span two registers.\n+\t(mips16_build_call_stub): Likewise.\n+\t(mips_function_value_regno_p): Support both FP return registers.\n+\t(mips_output_64bit_xfer): Use mthc1 whenever TARGET_HAS_MXHC1.  Add\n+\tspecific cases for TARGET_FPXX to move via memory.\n+\t(mips_dwarf_register_span): For TARGET_FPXX pretend that modes larger\n+\tthan UNITS_PER_FPREG 'span' one register.\n+\t(mips_dwarf_frame_reg_mode): New static function.\n+\t(mips_file_start): Switch to using .module instead of .gnu_attribute.\n+\tNo longer support FP ABI 4 (-mips32r2 -mfp64), replace with FP ABI 6.\n+\tAdd FP ABI 5 (-mfpxx) and FP ABI 7 (-mfp64 -mno-odd-spreg).\n+\t(mips_save_reg, mips_restore_reg): Always represent DFmode frame\n+\tslots with two CFI directives even for O32 FP64.\n+\t(mips_for_each_saved_gpr_and_fpr): Account for fixed_regs when\n+\tsaving/restoring callee-saved registers.\n+\t(mips_hard_regno_mode_ok_p): Implement O32 FP64A extension.\n+\t(mips_secondary_memory_needed): New function.\n+\t(mips_option_override): ABI check for TARGET_FLOATXX.  Disable\n+\todd-numbered single-precision registers\twhen using TARGET_FLOATXX.\n+\tImplement -modd-spreg and defaults.\n+\t(mips_conditional_register_usage): Redefine O32 FP64 to match O32 FP32\n+\tcallee-saved behaviour.\n+\t(mips_hard_regno_caller_save_mode): Implement.\n+\t(TARGET_GET_RAW_RESULT_MODE): Define target hook.\n+\t(TARGET_GET_RAW_ARG_MODE): Define target hook.\n+\t(TARGET_DWARF_FRAME_REG_MODE): Define target hook.\n+\t* config/mips/mips.h (TARGET_FLOAT32): New macro.\n+\t(TARGET_O32_FP64A_ABI): Likewise.\n+\t(TARGET_CPU_CPP_BUILTINS): TARGET_FPXX is __mips_fpr==0. Add\n+\t_MIPS_SPFPSET builtin define.\n+\t(MIPS_FPXX_OPTION_SPEC): New macro.\n+\t(OPTION_DEFAULT_SPECS): Pass through --with-fp-32=* to -mfp and\n+\t--with-odd-spreg-32=* to -m[no-]odd-spreg.\n+\t(ISA_HAS_ODD_SPREG): New macro.\n+\t(ISA_HAS_MXHC1): True for anything other than -mfp32.\n+\t(ASM_SPEC): Pass through mfpxx, mfp64, -mno-odd-spreg and -modd-spreg.\n+\t(MIN_FPRS_PER_FMT): Redefine in terms of TARGET_ODD_SPREG.\n+\t(HARD_REGNO_CALLER_SAVE_MODE): Define.  Implement O32 FPXX extension\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): Likewise.\n+\t(SECONDARY_MEMORY_NEEDED): Likewise.\n+\t(FUNCTION_ARG_REGNO_P): Update for O32 FPXX and FP64 extensions.\n+\t* config/mips/mips.md (define_attr enabled): Implement O32 FPXX and\n+\tFP64A ABI extensions.\n+\t(move_doubleword_fpr<mode>): Use ISA_HAS_MXHC1 instead of\n+\tTARGET_FLOAT64.\n+\t* config/mips/mips.opt (mfpxx): New target option.\n+\t(modd-spreg): Likewise.\n+\t* config/mips/mti-elf.h (DRIVER_SELF_SPECS): Infer FP ABI from arch.\n+\t* config/mips/mti-linux.h (DRIVER_SELF_SPECS): Likewise and remove\n+\tfp64 sysroot.\n+\t* config/mips/t-mti-elf: Remove fp64 multilib.\n+\t* config/mips/t-mti-linux: Likewise.\n+\t* configure.ac: Detect .module support.\n+\t* configure: Regenerate.\n+\t* doc/invoke.texi: Document -mfpxx, -modd-spreg, -mno-odd-spreg option.\n+\t* doc/install.texi (--with-fp-32, --with-odd-spreg-32): Document new\n+\toptions.\n+\n 2014-11-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/63815"}, {"sha": "a140d5594730fb0dc4068257c3fb7dc496da9488", "filename": "gcc/common/config/mips/mips-common.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fcommon%2Fconfig%2Fmips%2Fmips-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fcommon%2Fconfig%2Fmips%2Fmips-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fmips%2Fmips-common.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -42,6 +42,15 @@ mips_handle_option (struct gcc_options *opts,\n       opts->x_mips_cache_flush_func = NULL;\n       return true;\n \n+    case OPT_mfp32:\n+    case OPT_mfp64:\n+      opts->x_target_flags &= ~MASK_FLOATXX;\n+      return true;\n+\n+    case OPT_mfpxx:\n+      opts->x_target_flags &= ~MASK_FLOAT64;\n+      return true;\n+\n     default:\n       return true;\n     }"}, {"sha": "0af4a1a851c41f9ac93196252ee52adf462df1d0", "filename": "gcc/config.gcc", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -3754,7 +3754,7 @@ case \"${target}\" in\n \t\t;;\n \n \tmips*-*-*)\n-\t\tsupported_defaults=\"abi arch arch_32 arch_64 float fpu nan tune tune_32 tune_64 divide llsc mips-plt synci\"\n+\t\tsupported_defaults=\"abi arch arch_32 arch_64 float fpu nan fp_32 odd_spreg_32 tune tune_32 tune_64 divide llsc mips-plt synci\"\n \n \t\tcase ${with_float} in\n \t\t\"\" | soft | hard)\n@@ -3786,6 +3786,32 @@ case \"${target}\" in\n \t\t\t;;\n \t\tesac\n \n+\t\tcase ${with_fp_32} in\n+\t\t\"\" | 32 | xx | 64)\n+\t\t\t# OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Unknown FP mode used in --with-fp-32=$with_fp_32\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n+\t\tcase ${with_odd_spreg_32} in\n+\t\tyes)\n+\t\t\twith_odd_spreg_32=\"odd-spreg\"\n+\t\t\t;;\n+\t\tno)\n+\t\t\twith_odd_spreg_32=\"no-odd-spreg\"\n+\t\t\t;;\n+\t\t\"\")\n+\t\t\t# OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Unknown odd-spreg-32 type used in --with-odd-spreg-32=$with_odd_spreg_32\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n \t\tcase ${with_abi} in\n \t\t\"\" | 32 | o64 | n32 | 64 | eabi)\n \t\t\t# OK\n@@ -4213,7 +4239,7 @@ case ${target} in\n esac\n \n t=\n-all_defaults=\"abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu nan divide llsc mips-plt synci tls\"\n+all_defaults=\"abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu nan fp_32 odd_spreg_32 divide llsc mips-plt synci tls\"\n for option in $all_defaults\n do\n \teval \"val=\\$with_\"`echo $option | sed s/-/_/g`"}, {"sha": "520b5f71fafad9db5863feb9612243b68329d11a", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -472,6 +472,12 @@\n #endif\n \n \n+/* Define if the assembler understands .module. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_DOT_MODULE\n+#endif\n+\n+\n /* Define if your assembler supports the -no-mul-bug-abort option. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_NO_MUL_BUG_ABORT_OPTION"}, {"sha": "adeda598a9d892ca81f0a1940a3ff649d2effe0d", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -278,6 +278,8 @@ extern void mips_expand_before_return (void);\n extern void mips_expand_epilogue (bool);\n extern bool mips_can_use_return_insn (void);\n \n+extern bool mips_secondary_memory_needed (enum reg_class, enum reg_class,\n+\t\t\t\t\t  machine_mode);\n extern bool mips_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t   machine_mode, enum reg_class);\n extern bool mips_dangerous_for_la25_p (rtx);\n@@ -287,6 +289,9 @@ extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   rtx, bool);\n extern int mips_class_max_nregs (enum reg_class, machine_mode);\n \n+extern machine_mode mips_hard_regno_caller_save_mode (unsigned int,\n+\t\t\t\t\t\t      unsigned int,\n+\t\t\t\t\t\t      machine_mode);\n extern int mips_adjust_insn_length (rtx_insn *, int);\n extern void mips_output_load_label (rtx);\n extern const char *mips_output_conditional_branch (rtx_insn *, rtx *,"}, {"sha": "02268f3247e45029e691d8e27147953244fdd904", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 220, "deletions": 23, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -1232,6 +1232,7 @@ static rtx mips_find_pic_call_symbol (rtx_insn *, rtx, bool);\n static int mips_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static unsigned int mips_function_arg_boundary (machine_mode, const_tree);\n+static machine_mode mips_get_reg_raw_mode (int regno);\n \f\n struct mips16_flip_traits : default_hashmap_traits\n {\n@@ -5160,6 +5161,7 @@ mips_get_arg_info (struct mips_arg_info *info, const CUMULATIVE_ARGS *cum,\n       /* Only leading floating-point scalars are passed in\n \t floating-point registers.  We also handle vector floats the same\n \t say, which is OK because they are not covered by the standard ABI.  */\n+      gcc_assert (TARGET_PAIRED_SINGLE_FLOAT || mode != V2SFmode);\n       info->fpr_p = (!cum->gp_reg_found\n \t\t     && cum->arg_number < 2\n \t\t     && (type == 0\n@@ -5175,6 +5177,7 @@ mips_get_arg_info (struct mips_arg_info *info, const CUMULATIVE_ARGS *cum,\n       /* Scalar, complex and vector floating-point types are passed in\n \t floating-point registers, as long as this is a named rather\n \t than a variable argument.  */\n+      gcc_assert (TARGET_PAIRED_SINGLE_FLOAT || mode != V2SFmode);\n       info->fpr_p = (named\n \t\t     && (type == 0 || FLOAT_TYPE_P (type))\n \t\t     && (GET_MODE_CLASS (mode) == MODE_FLOAT\n@@ -5458,6 +5461,16 @@ mips_function_arg_boundary (machine_mode mode, const_tree type)\n   return alignment;\n }\n \n+/* Implement TARGET_GET_RAW_RESULT_MODE and TARGET_GET_RAW_ARG_MODE.  */\n+\n+static machine_mode\n+mips_get_reg_raw_mode (int regno)\n+{\n+  if (TARGET_FLOATXX && FP_REG_P (regno))\n+    return DFmode;\n+  return default_get_reg_raw_mode (regno);\n+}\n+\n /* Return true if FUNCTION_ARG_PADDING (MODE, TYPE) should return\n    upward rather than downward.  In other words, return true if the\n    first byte of the stack slot has useful data, false if the last\n@@ -5615,6 +5628,7 @@ mips_return_in_msb (const_tree valtype)\n static bool\n mips_return_mode_in_fpr_p (machine_mode mode)\n {\n+  gcc_assert (TARGET_PAIRED_SINGLE_FLOAT || mode != V2SFmode);\n   return ((GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   || mode == V2SFmode\n \t   || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n@@ -5661,7 +5675,7 @@ mips_return_fpr_pair (machine_mode mode,\n {\n   int inc;\n \n-  inc = (TARGET_NEWABI ? 2 : MAX_FPRS_PER_FMT);\n+  inc = (TARGET_NEWABI || mips_abi == ABI_32 ? 2 : MAX_FPRS_PER_FMT);\n   return gen_rtx_PARALLEL\n     (mode,\n      gen_rtvec (2,\n@@ -5777,19 +5791,31 @@ mips_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n \n /* Implement TARGET_FUNCTION_VALUE_REGNO_P.\n \n-   On the MIPS, R2 R3 and F0 F2 are the only register thus used.\n-   Currently, R2 and F0 are only implemented here (C has no complex type).  */\n+   On the MIPS, R2 R3 and F0 F2 are the only register thus used.  */\n \n static bool\n mips_function_value_regno_p (const unsigned int regno)\n {\n+  /* Most types only require one GPR or one FPR for return values but for\n+     hard-float two FPRs can be used for _Complex types (for all ABIs)\n+     and long doubles (for n64).  */\n   if (regno == GP_RETURN\n       || regno == FP_RETURN\n-      || (LONG_DOUBLE_TYPE_SIZE == 128\n-\t  && FP_RETURN != GP_RETURN\n+      || (FP_RETURN != GP_RETURN\n \t  && regno == FP_RETURN + 2))\n     return true;\n \n+  /* For o32 FP32, _Complex double will be returned in four 32-bit registers.\n+     This does not apply to o32 FPXX as floating-point function argument and\n+     return registers are described as 64-bit even though floating-point\n+     registers are primarily described as 32-bit internally.\n+     See: mips_get_reg_raw_mode.  */\n+  if ((mips_abi == ABI_32 && TARGET_FLOAT32)\n+      && FP_RETURN != GP_RETURN\n+      && (regno == FP_RETURN + 1\n+\t  || regno == FP_RETURN + 3))\n+    return true;\n+\n   return false;\n }\n \n@@ -6497,7 +6523,10 @@ mips16_call_stub_mode_suffix (machine_mode mode)\n   else if (mode == DCmode)\n     return \"dc\";\n   else if (mode == V2SFmode)\n-    return \"df\";\n+    {\n+      gcc_assert (TARGET_PAIRED_SINGLE_FLOAT);\n+      return \"df\";\n+    }\n   else\n     gcc_unreachable ();\n }\n@@ -6521,13 +6550,27 @@ mips_output_64bit_xfer (char direction, unsigned int gpreg, unsigned int fpreg)\n   if (TARGET_64BIT)\n     fprintf (asm_out_file, \"\\tdm%cc1\\t%s,%s\\n\", direction,\n  \t     reg_names[gpreg], reg_names[fpreg]);\n-  else if (TARGET_FLOAT64)\n+  else if (ISA_HAS_MXHC1)\n     {\n       fprintf (asm_out_file, \"\\tm%cc1\\t%s,%s\\n\", direction,\n  \t       reg_names[gpreg + TARGET_BIG_ENDIAN], reg_names[fpreg]);\n       fprintf (asm_out_file, \"\\tm%chc1\\t%s,%s\\n\", direction,\n  \t       reg_names[gpreg + TARGET_LITTLE_ENDIAN], reg_names[fpreg]);\n     }\n+  else if (TARGET_FLOATXX && direction == 't')\n+    {\n+      /* Use the argument save area to move via memory.  */\n+      fprintf (asm_out_file, \"\\tsw\\t%s,0($sp)\\n\", reg_names[gpreg]);\n+      fprintf (asm_out_file, \"\\tsw\\t%s,4($sp)\\n\", reg_names[gpreg + 1]);\n+      fprintf (asm_out_file, \"\\tldc1\\t%s,0($sp)\\n\", reg_names[fpreg]);\n+    }\n+  else if (TARGET_FLOATXX && direction == 'f')\n+    {\n+      /* Use the argument save area to move via memory.  */\n+      fprintf (asm_out_file, \"\\tsdc1\\t%s,0($sp)\\n\", reg_names[fpreg]);\n+      fprintf (asm_out_file, \"\\tlw\\t%s,0($sp)\\n\", reg_names[gpreg]);\n+      fprintf (asm_out_file, \"\\tlw\\t%s,4($sp)\\n\", reg_names[gpreg + 1]);\n+    }\n   else\n     {\n       /* Move the least-significant word.  */\n@@ -6935,11 +6978,11 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n \t    case SCmode:\n \t      mips_output_32bit_xfer ('f', GP_RETURN + TARGET_BIG_ENDIAN,\n \t\t\t\t      TARGET_BIG_ENDIAN\n-\t\t\t\t      ? FP_REG_FIRST + MAX_FPRS_PER_FMT\n+\t\t\t\t      ? FP_REG_FIRST + 2\n \t\t\t\t      : FP_REG_FIRST);\n \t      mips_output_32bit_xfer ('f', GP_RETURN + TARGET_LITTLE_ENDIAN,\n \t\t\t\t      TARGET_LITTLE_ENDIAN\n-\t\t\t\t      ? FP_REG_FIRST + MAX_FPRS_PER_FMT\n+\t\t\t\t      ? FP_REG_FIRST + 2\n \t\t\t\t      : FP_REG_FIRST);\n \t      if (GET_MODE (retval) == SCmode && TARGET_64BIT)\n \t\t{\n@@ -6968,10 +7011,12 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n \n \t    case DCmode:\n \t      mips_output_64bit_xfer ('f', GP_RETURN + (8 / UNITS_PER_WORD),\n-\t\t\t\t      FP_REG_FIRST + MAX_FPRS_PER_FMT);\n+\t\t\t\t      FP_REG_FIRST + 2);\n \t      /* Fall though.  */\n  \t    case DFmode:\n \t    case V2SFmode:\n+\t      gcc_assert (TARGET_PAIRED_SINGLE_FLOAT\n+\t\t\t  || GET_MODE (retval) != V2SFmode);\n \t      mips_output_64bit_xfer ('f', GP_RETURN, FP_REG_FIRST);\n \t      break;\n \n@@ -8682,14 +8727,28 @@ mips_dwarf_register_span (rtx reg)\n   rtx high, low;\n   machine_mode mode;\n \n-  /* By default, GCC maps increasing register numbers to increasing\n-     memory locations, but paired FPRs are always little-endian,\n-     regardless of the prevailing endianness.  */\n+  /* TARGET_FLOATXX is implemented as 32-bit floating-point registers but\n+     ensures that double-precision registers are treated as if they were\n+     64-bit physical registers.  The code will run correctly with 32-bit or\n+     64-bit registers which means that dwarf information cannot be precise\n+     for all scenarios.  We choose to state that the 64-bit values are stored\n+     in a single 64-bit 'piece'.  This slightly unusual construct can then be\n+     interpreted as either a pair of registers if the registers are 32-bit or\n+     a single 64-bit register depending on hardware.  */\n   mode = GET_MODE (reg);\n   if (FP_REG_P (REGNO (reg))\n-      && TARGET_BIG_ENDIAN\n-      && MAX_FPRS_PER_FMT > 1\n+      && TARGET_FLOATXX\n       && GET_MODE_SIZE (mode) > UNITS_PER_FPREG)\n+    {\n+      return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, reg));\n+    }\n+  /* By default, GCC maps increasing register numbers to increasing\n+     memory locations, but paired FPRs are always little-endian,\n+     regardless of the prevailing endianness.  */\n+  else if (FP_REG_P (REGNO (reg))\n+\t   && TARGET_BIG_ENDIAN\n+\t   && MAX_FPRS_PER_FMT > 1\n+\t   && GET_MODE_SIZE (mode) > UNITS_PER_FPREG)\n     {\n       gcc_assert (GET_MODE_SIZE (mode) == UNITS_PER_HWFPVALUE);\n       high = mips_subword (reg, true);\n@@ -8700,6 +8759,19 @@ mips_dwarf_register_span (rtx reg)\n   return NULL_RTX;\n }\n \n+/* Implement TARGET_DWARF_FRAME_REG_MODE.  */\n+\n+static machine_mode\n+mips_dwarf_frame_reg_mode (int regno)\n+{\n+  machine_mode mode = default_dwarf_frame_reg_mode (regno);\n+\n+  if (FP_REG_P (regno) && mips_abi == ABI_32 && TARGET_FLOAT64)\n+    mode = SImode;\n+\n+  return mode;\n+}\n+\n /* DSP ALU can bypass data with no delays for the following pairs. */\n enum insn_code dspalu_bypass_table[][2] =\n {\n@@ -8979,6 +9051,31 @@ mips_file_start (void)\n     fprintf (asm_out_file, \"\\t.nan\\t%s\\n\",\n \t     mips_nan == MIPS_IEEE_754_2008 ? \"2008\" : \"legacy\");\n \n+#ifdef HAVE_AS_DOT_MODULE\n+  /* Record the FP ABI.  See below for comments.  */\n+  if (TARGET_NO_FLOAT)\n+#ifdef HAVE_AS_GNU_ATTRIBUTE\n+    fputs (\"\\t.gnu_attribute 4, 0\\n\", asm_out_file);\n+#else\n+    ;\n+#endif\n+  else if (!TARGET_HARD_FLOAT_ABI)\n+    fputs (\"\\t.module\\tsoftfloat\\n\", asm_out_file);\n+  else if (!TARGET_DOUBLE_FLOAT)\n+    fputs (\"\\t.module\\tsinglefloat\\n\", asm_out_file);\n+  else if (TARGET_FLOATXX)\n+    fputs (\"\\t.module\\tfp=xx\\n\", asm_out_file);\n+  else if (TARGET_FLOAT64)\n+    fputs (\"\\t.module\\tfp=64\\n\", asm_out_file);\n+  else\n+    fputs (\"\\t.module\\tfp=32\\n\", asm_out_file);\n+\n+  if (TARGET_ODD_SPREG)\n+    fputs (\"\\t.module\\toddspreg\\n\", asm_out_file);\n+  else\n+    fputs (\"\\t.module\\tnooddspreg\\n\", asm_out_file);\n+\n+#else\n #ifdef HAVE_AS_GNU_ATTRIBUTE\n   {\n     int attr;\n@@ -8992,15 +9089,26 @@ mips_file_start (void)\n     /* Single-float code, -msingle-float.  */\n     else if (!TARGET_DOUBLE_FLOAT)\n       attr = 2;\n-    /* 64-bit FP registers on a 32-bit target, -mips32r2 -mfp64.  */\n-    else if (!TARGET_64BIT && TARGET_FLOAT64)\n-      attr = 4;\n+    /* 64-bit FP registers on a 32-bit target, -mips32r2 -mfp64.\n+       Reserved attr=4.\n+       This case used 12 callee-saved double-precision registers\n+       and is deprecated.  */\n+    /* 64-bit or 32-bit FP registers on a 32-bit target, -mfpxx.  */\n+    else if (TARGET_FLOATXX)\n+      attr = 5;\n+    /* 64-bit FP registers on a 32-bit target, -mfp64 -modd-spreg.  */\n+    else if (mips_abi == ABI_32 && TARGET_FLOAT64 && TARGET_ODD_SPREG)\n+      attr = 6;\n+    /* 64-bit FP registers on a 32-bit target, -mfp64 -mno-odd-spreg.  */\n+    else if (mips_abi == ABI_32 && TARGET_FLOAT64)\n+      attr = 7;\n     /* Regular FP code, FP regs same size as GP regs, -mdouble-float.  */\n     else\n       attr = 1;\n \n     fprintf (asm_out_file, \"\\t.gnu_attribute 4, %d\\n\", attr);\n   }\n+#endif\n #endif\n \n   /* If TARGET_ABICALLS, tell GAS to generate -KPIC code.  */\n@@ -10491,7 +10599,9 @@ mips_for_each_saved_acc (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n static void\n mips_save_reg (rtx reg, rtx mem)\n {\n-  if (GET_MODE (reg) == DFmode && !TARGET_FLOAT64)\n+  if (GET_MODE (reg) == DFmode\n+      && (!TARGET_FLOAT64\n+\t  || mips_abi == ABI_32))\n     {\n       rtx x1, x2;\n \n@@ -10649,7 +10759,16 @@ mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,\n        regno -= MAX_FPRS_PER_FMT)\n     if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n       {\n-\tmips_save_restore_reg (fpr_mode, regno, offset, fn);\n+\tif (!TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT\n+\t    && (fixed_regs[regno] || fixed_regs[regno + 1]))\n+\t  {\n+\t    if (fixed_regs[regno])\n+\t      mips_save_restore_reg (SFmode, regno + 1, offset, fn);\n+\t    else\n+\t      mips_save_restore_reg (SFmode, regno, offset, fn);\n+\t  }\n+\telse\n+\t  mips_save_restore_reg (fpr_mode, regno, offset, fn);\n \toffset -= GET_MODE_SIZE (fpr_mode);\n       }\n }\n@@ -11420,7 +11539,9 @@ mips_restore_reg (rtx reg, rtx mem)\n      $7 instead and adjust the return insn appropriately.  */\n   if (TARGET_MIPS16 && REGNO (reg) == RETURN_ADDR_REGNUM)\n     reg = gen_rtx_REG (GET_MODE (reg), GP_REG_FIRST + 7);\n-  else if (GET_MODE (reg) == DFmode && !TARGET_FLOAT64)\n+  else if (GET_MODE (reg) == DFmode\n+\t   && (!TARGET_FLOAT64\n+\t       || mips_abi == ABI_32))\n     {\n       mips_add_cfa_restore (mips_subword (reg, true));\n       mips_add_cfa_restore (mips_subword (reg, false));\n@@ -11770,6 +11891,11 @@ mips_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n       && (((regno - FP_REG_FIRST) % MAX_FPRS_PER_FMT) == 0\n \t  || (MIN_FPRS_PER_FMT == 1 && size <= UNITS_PER_FPREG)))\n     {\n+      /* Deny use of odd-numbered registers for 32-bit data for\n+\t the o32 FP64A ABI.  */\n+      if (TARGET_O32_FP64A_ABI && size <= 4 && (regno & 1) != 0)\n+\treturn false;\n+\n       /* Allow 64-bit vector modes for Loongson-2E/2F.  */\n       if (TARGET_LOONGSON_VECTORS\n \t  && (mode == V2SImode\n@@ -12124,6 +12250,25 @@ mips_memory_move_cost (machine_mode mode, reg_class_t rclass, bool in)\n \t  + memory_move_secondary_cost (mode, rclass, in));\n } \n \n+/* Implement SECONDARY_MEMORY_NEEDED.  */\n+\n+bool\n+mips_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n+\t\t\t      machine_mode mode)\n+{\n+  /* Ignore spilled pseudos.  */\n+  if (lra_in_progress && (class1 == NO_REGS || class2 == NO_REGS))\n+    return false;\n+\n+  if (((class1 == FP_REGS) != (class2 == FP_REGS))\n+      && ((TARGET_FLOATXX && !ISA_HAS_MXHC1)\n+\t  || TARGET_O32_FP64A_ABI)\n+      && GET_MODE_SIZE (mode) >= 8)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return the register class required for a secondary register when\n    copying between one of the registers in RCLASS and value X, which\n    has mode MODE.  X is the source of the move if IN_P, otherwise it\n@@ -17041,6 +17186,13 @@ mips_option_override (void)\n \ttarget_flags &= ~MASK_FLOAT64;\n     }\n \n+  if (mips_abi != ABI_32 && TARGET_FLOATXX)\n+    error (\"%<-mfpxx%> can only be used with the o32 ABI\");\n+  else if (ISA_MIPS1 && !TARGET_FLOAT32)\n+    error (\"%<-march=%s%> requires %<-mfp32%>\", mips_arch_info->name);\n+  else if (TARGET_FLOATXX && !mips_lra_flag)\n+    error (\"%<-mfpxx%> requires %<-mlra%>\");\n+\n   /* End of code shared with GAS.  */\n \n   /* The R5900 FPU only supports single precision.  */\n@@ -17128,6 +17280,28 @@ mips_option_override (void)\n     warning (0, \"the %qs architecture does not support madd or msub\"\n \t     \" instructions\", mips_arch_info->name);\n \n+  /* If neither -modd-spreg nor -mno-odd-spreg was given on the command\n+     line, set MASK_ODD_SPREG based on the ISA and ABI.  */\n+  if ((target_flags_explicit & MASK_ODD_SPREG) == 0)\n+    {\n+      /* Disable TARGET_ODD_SPREG when using the o32 FPXX ABI.  */\n+      if (!ISA_HAS_ODD_SPREG || TARGET_FLOATXX)\n+\ttarget_flags &= ~MASK_ODD_SPREG;\n+      else\n+\ttarget_flags |= MASK_ODD_SPREG;\n+    }\n+  else if (TARGET_ODD_SPREG && !ISA_HAS_ODD_SPREG)\n+    warning (0, \"the %qs architecture does not support odd single-precision\"\n+\t     \" registers\", mips_arch_info->name);\n+\n+  if (!TARGET_ODD_SPREG && TARGET_64BIT)\n+    {\n+      error (\"unsupported combination: %s\", \"-mgp64 -mno-odd-spreg\");\n+      /* Allow compilation to continue further even though invalid output\n+         will be produced.  */\n+      target_flags |= MASK_ODD_SPREG;\n+    }\n+\n   /* The effect of -mabicalls isn't defined for the EABI.  */\n   if (mips_abi == ABI_EABI && TARGET_ABICALLS)\n     {\n@@ -17490,8 +17664,10 @@ mips_conditional_register_usage (void)\n \tcall_really_used_regs[regno] = call_used_regs[regno] = 1;\n     }\n   /* Odd registers in the range $f21-$f31 (inclusive) are call-clobbered\n-     for n32.  */\n-  if (mips_abi == ABI_N32)\n+     for n32 and o32 FP64.  */\n+  if (mips_abi == ABI_N32\n+      || (mips_abi == ABI_32\n+          && TARGET_FLOAT64))\n     {\n       int regno;\n       for (regno = FP_REG_FIRST + 21; regno <= FP_REG_FIRST + 31; regno+=2)\n@@ -18824,6 +19000,21 @@ mips_expand_vec_minmax (rtx target, rtx op0, rtx op1,\n   emit_insn (gen_rtx_SET (VOIDmode, target, x));\n }\n \n+/* Implement HARD_REGNO_CALLER_SAVE_MODE.  */\n+\n+machine_mode\n+mips_hard_regno_caller_save_mode (unsigned int regno,\n+\t\t\t\t  unsigned int nregs,\n+\t\t\t\t  machine_mode mode)\n+{\n+  /* For performance, avoid saving/restoring upper parts of a register\n+     by returning MODE as save mode when the mode is known.  */\n+  if (mode == VOIDmode)\n+    return choose_hard_reg_mode (regno, nregs, false);\n+  else\n+    return mode;\n+}\n+\n /* Implement TARGET_CASE_VALUES_THRESHOLD.  */\n \n unsigned int\n@@ -19043,6 +19234,10 @@ mips_lra_p (void)\n #define TARGET_FUNCTION_ARG_ADVANCE mips_function_arg_advance\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY mips_function_arg_boundary\n+#undef TARGET_GET_RAW_RESULT_MODE\n+#define TARGET_GET_RAW_RESULT_MODE mips_get_reg_raw_mode\n+#undef TARGET_GET_RAW_ARG_MODE\n+#define TARGET_GET_RAW_ARG_MODE mips_get_reg_raw_mode\n \n #undef TARGET_MODE_REP_EXTENDED\n #define TARGET_MODE_REP_EXTENDED mips_mode_rep_extended\n@@ -19099,6 +19294,8 @@ mips_lra_p (void)\n #endif\n #undef TARGET_DWARF_REGISTER_SPAN\n #define TARGET_DWARF_REGISTER_SPAN mips_dwarf_register_span\n+#undef TARGET_DWARF_FRAME_REG_MODE\n+#define TARGET_DWARF_FRAME_REG_MODE mips_dwarf_frame_reg_mode\n \n #undef TARGET_ASM_FINAL_POSTSCAN_INSN\n #define TARGET_ASM_FINAL_POSTSCAN_INSN mips_final_postscan_insn"}, {"sha": "8a3882942196ca767a9df4677422391cc49f4e7c", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 70, "deletions": 7, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -323,6 +323,15 @@ struct mips_cpu_info {\n #define TARGET_HARD_FLOAT (TARGET_HARD_FLOAT_ABI && !TARGET_MIPS16)\n #define TARGET_SOFT_FLOAT (TARGET_SOFT_FLOAT_ABI || TARGET_MIPS16)\n \n+/* TARGET_FLOAT64 represents -mfp64 and TARGET_FLOATXX represents\n+   -mfpxx, derive TARGET_FLOAT32 to represent -mfp32.  */\n+#define TARGET_FLOAT32 (!TARGET_FLOAT64 && !TARGET_FLOATXX)\n+\n+/* TARGET_O32_FP64A_ABI represents all the conditions that form the\n+   o32 FP64A ABI extension (-mabi=32 -mfp64 -mno-odd-spreg).  */\n+#define TARGET_O32_FP64A_ABI (mips_abi == ABI_32 && TARGET_FLOAT64 \\\n+\t\t\t      && !TARGET_ODD_SPREG)\n+\n /* False if SC acts as a memory barrier with respect to itself,\n    otherwise a SYNC will be emitted after SC for atomic operations\n    that require ordering between the SC and following loads and\n@@ -391,6 +400,8 @@ struct mips_cpu_info {\n \t\t\t\t\t\t\t\t\t\\\n       if (TARGET_FLOAT64)\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_fpr=64\");\t\t\t\t\\\n+      else if (TARGET_FLOATXX)\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__mips_fpr=0\");\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_fpr=32\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -519,6 +530,8 @@ struct mips_cpu_info {\n       builtin_define_with_int_value (\"_MIPS_SZPTR\", POINTER_SIZE);\t\\\n       builtin_define_with_int_value (\"_MIPS_FPSET\",\t\t\t\\\n \t\t\t\t     32 / MAX_FPRS_PER_FMT);\t\t\\\n+      builtin_define_with_int_value (\"_MIPS_SPFPSET\",\t\t\t\\\n+\t\t\t\t     TARGET_ODD_SPREG ? 32 : 16);\t\\\n \t\t\t\t\t\t\t\t\t\\\n       /* These defines reflect the ABI in use, not whether the  \t\\\n \t FPU is directly accessible.  */\t\t\t\t\\\n@@ -754,6 +767,12 @@ struct mips_cpu_info {\n #define MIPS_32BIT_OPTION_SPEC \\\n   \"mips1|mips2|mips32*|mgp32\"\n \n+/* A spec condition that matches architectures should be targeted with\n+   o32 FPXX for compatibility reasons.  */\n+#define MIPS_FPXX_OPTION_SPEC \\\n+  \"mips2|mips3|mips4|mips5|mips32|mips32r2|mips32r3|mips32r5| \\\n+   mips64|mips64r2|mips64r3|mips64r5\"\n+\n /* Infer a -msynci setting from a -mips argument, on the assumption that\n    -msynci is desired where possible.  */\n #define MIPS_ISA_SYNCI_SPEC \\\n@@ -778,7 +797,12 @@ struct mips_cpu_info {\n    --with-abi is ignored if -mabi is specified.\n    --with-float is ignored if -mhard-float or -msoft-float are\n      specified.\n+   --with-fpu is ignored if -msoft-float, -msingle-float or -mdouble-float are\n+     specified.\n    --with-nan is ignored if -mnan is specified.\n+   --with-fp-32 is ignored if -msoft-float, -msingle-float or -mfp are specified.\n+   --with-odd-spreg-32 is ignored if -msoft-float, -msingle-float, -modd-spreg\n+     or -mno-odd-spreg are specified.\n    --with-divide is ignored if -mdivide-traps or -mdivide-breaks are\n      specified. */\n #define OPTION_DEFAULT_SPECS \\\n@@ -790,8 +814,12 @@ struct mips_cpu_info {\n   {\"tune_64\", \"%{\" OPT_ARCH64 \":%{!mtune=*:-mtune=%(VALUE)}}\" }, \\\n   {\"abi\", \"%{!mabi=*:-mabi=%(VALUE)}\" }, \\\n   {\"float\", \"%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}\" }, \\\n-  {\"fpu\", \"%{!msingle-float:%{!mdouble-float:-m%(VALUE)-float}}\" }, \\\n+  {\"fpu\", \"%{!msoft-float:%{!msingle-float:%{!mdouble-float:-m%(VALUE)-float}}}\" }, \\\n   {\"nan\", \"%{!mnan=*:-mnan=%(VALUE)}\" }, \\\n+  {\"fp_32\", \"%{\" OPT_ARCH32 \\\n+\t    \":%{!msoft-float:%{!msingle-float:%{!mfp*:-mfp%(VALUE)}}}}\" }, \\\n+  {\"odd_spreg_32\", \"%{\" OPT_ARCH32 \":%{!msoft-float:%{!msingle-float:\" \\\n+\t\t   \"%{!modd-spreg:%{!mno-odd-spreg:-m%(VALUE)}}}}}\" }, \\\n   {\"divide\", \"%{!mdivide-traps:%{!mdivide-breaks:-mdivide-%(VALUE)}}\" }, \\\n   {\"llsc\", \"%{!mllsc:%{!mno-llsc:-m%(VALUE)}}\" }, \\\n   {\"mips-plt\", \"%{!mplt:%{!mno-plt:-m%(VALUE)}}\" }, \\\n@@ -843,6 +871,12 @@ struct mips_cpu_info {\n    been generated up to this point.  */\n #define ISA_HAS_BRANCHLIKELY\t(!ISA_MIPS1)\n \n+/* ISA has 32 single-precision registers.  */\n+#define ISA_HAS_ODD_SPREG\t((mips_isa_rev >= 1\t\t\t\\\n+\t\t\t\t  && !TARGET_LOONGSON_3A)\t\t\\\n+\t\t\t\t || TARGET_FLOAT64\t\t\t\\\n+\t\t\t\t || TARGET_MIPS5900)\n+\n /* ISA has a three-operand multiplication instruction (usually spelt \"mul\").  */\n #define ISA_HAS_MUL3\t\t((TARGET_MIPS3900                       \\\n \t\t\t\t  || TARGET_MIPS5400\t\t\t\\\n@@ -1030,7 +1064,8 @@ struct mips_cpu_info {\n #define ISA_HAS_EXT_INS\t\t(mips_isa_rev >= 2 && !TARGET_MIPS16)\n \n /* ISA has instructions for accessing top part of 64-bit fp regs.  */\n-#define ISA_HAS_MXHC1\t\t(TARGET_FLOAT64 && mips_isa_rev >= 2)\n+#define ISA_HAS_MXHC1\t\t(!TARGET_FLOAT32\t\\\n+\t\t\t\t && mips_isa_rev >= 2)\n \n /* ISA has lwxs instruction (load w/scaled index address.  */\n #define ISA_HAS_LWXS\t\t((TARGET_SMARTMIPS || TARGET_MICROMIPS) \\\n@@ -1186,7 +1221,8 @@ struct mips_cpu_info {\n %(subtarget_asm_debugging_spec) \\\n %{mabi=*} %{!mabi=*: %(asm_abi_default_spec)} \\\n %{mgp32} %{mgp64} %{march=*} %{mxgot:-xgot} \\\n-%{mfp32} %{mfp64} %{mnan=*} \\\n+%{mfp32} %{mfpxx} %{mfp64} %{mnan=*} \\\n+%{modd-spreg} %{mno-odd-spreg} \\\n %{mshared} %{mno-shared} \\\n %{msym32} %{mno-sym32} \\\n %{mtune=*} \\\n@@ -1358,7 +1394,7 @@ struct mips_cpu_info {\n /* The number of consecutive floating-point registers needed to store the\n    smallest format supported by the FPU.  */\n #define MIN_FPRS_PER_FMT \\\n-  (mips_isa_rev >= 1 ? 1 : MAX_FPRS_PER_FMT)\n+  (TARGET_ODD_SPREG ? 1 : MAX_FPRS_PER_FMT)\n \n /* The largest size of value that can be held in floating-point\n    registers and moved with a single instruction.  */\n@@ -1764,6 +1800,16 @@ struct mips_cpu_info {\n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n   mips_hard_regno_mode_ok[ (int)(MODE) ][ (REGNO) ]\n \n+/* Select a register mode required for caller save of hard regno REGNO.  */\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n+  mips_hard_regno_caller_save_mode (REGNO, NREGS, MODE)\n+\n+/* Odd-numbered single-precision registers are not considered callee-saved\n+   for o32 FPXX as they will be clobbered when run on an FR=1 FPU.  */\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n+  (TARGET_FLOATXX && hard_regno_nregs[REGNO][MODE] == 1\t\t\t\\\n+   && FP_REG_P (REGNO) && ((REGNO) & 1))\n+\n #define MODES_TIEABLE_P mips_modes_tieable_p\n \n /* Register to use for pushing function arguments.  */\n@@ -2097,6 +2143,19 @@ enum reg_class\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n   mips_secondary_reload_class (CLASS, MODE, X, false)\n \n+/* When targeting the o32 FPXX ABI, all moves with a length of doubleword\n+   or greater must be performed by FR-mode-aware instructions.\n+   This can be achieved using MFHC1/MTHC1 when these instructions are\n+   available but otherwise moves must go via memory.\n+   For the o32 FP64A ABI, all odd-numbered moves with a length of\n+   doubleword or greater are required to use memory.  Using MTC1/MFC1\n+   to access the lower-half of these registers would require a forbidden\n+   single-precision access.  We require all double-word moves to use\n+   memory because adding even and odd floating-point registers classes\n+   would have a significant impact on the backend.  */\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n+  mips_secondary_memory_needed ((CLASS1), (CLASS2), (MODE))\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n \n@@ -2218,12 +2277,16 @@ enum reg_class\n   (TARGET_MIPS16 ? GP_ARG_FIRST + 2 : PIC_OFFSET_TABLE_REGNUM)\n \n /* 1 if N is a possible register number for function argument passing.\n-   We have no FP argument registers when soft-float.  When FP registers\n-   are 32 bits, we can't directly reference the odd numbered ones.  */\n+   We have no FP argument registers when soft-float.  Special handling\n+   is required for O32 where only even numbered registers are used for\n+   O32-FPXX and O32-FP64.  */\n \n #define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\\\n   ((IN_RANGE((N), GP_ARG_FIRST, GP_ARG_LAST)\t\t\t\\\n-    || (IN_RANGE((N), FP_ARG_FIRST, FP_ARG_LAST)))\t\t\\\n+    || (IN_RANGE((N), FP_ARG_FIRST, FP_ARG_LAST) \t\t\\\n+        && (mips_abi != ABI_32 \t\t\t\t\t\\\n+            || TARGET_FLOAT32 \t\t\t\t\t\\\n+            || ((N) % 2 == 0))))\t\t\t\t\\\n    && !fixed_regs[N])\n \f\n /* This structure has to cope with two different argument allocation"}, {"sha": "647bf853c222323b64a6eb68da82307f13d209a3", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -433,11 +433,17 @@\n   (const_string \"none\"))\n \n (define_attr \"enabled\" \"no,yes\"\n-  (if_then_else (ior (eq_attr \"compression\" \"all,none\")\n-\t\t     (and (eq_attr \"compression\" \"micromips\")\n-\t                  (match_test \"TARGET_MICROMIPS\")))\n-\t        (const_string \"yes\")\n-\t        (const_string \"no\")))\n+  (cond [;; The o32 FPXX and FP64A ABI extensions prohibit direct moves between\n+\t ;; GR_REG and FR_REG for 64-bit values.\n+\t (and (eq_attr \"move_type\" \"mtc,mfc\")\n+\t      (match_test \"(TARGET_FLOATXX && !ISA_HAS_MXHC1)\n+\t\t\t   || TARGET_O32_FP64A_ABI\")\n+\t      (eq_attr \"dword_mode\" \"yes\"))\n+\t (const_string \"no\")\n+\t (and (eq_attr \"compression\" \"micromips\")\n+\t      (match_test \"!TARGET_MICROMIPS\"))\n+\t (const_string \"no\")]\n+\t(const_string \"yes\")))\n \n ;; The number of individual instructions that a non-branch pattern generates,\n ;; using units of BASE_INSN_LENGTH.\n@@ -4997,7 +5003,7 @@\n       rtx low = mips_subword (operands[1], 0);\n       rtx high = mips_subword (operands[1], 1);\n       emit_insn (gen_load_low<mode> (operands[0], low));\n-      if (TARGET_FLOAT64 && !TARGET_64BIT)\n+      if (ISA_HAS_MXHC1 && !TARGET_64BIT)\n       \temit_insn (gen_mthc1<mode> (operands[0], high, operands[0]));\n       else\n \temit_insn (gen_load_high<mode> (operands[0], high, operands[0]));\n@@ -5007,7 +5013,7 @@\n       rtx low = mips_subword (operands[0], 0);\n       rtx high = mips_subword (operands[0], 1);\n       emit_insn (gen_store_word<mode> (low, operands[1], const0_rtx));\n-      if (TARGET_FLOAT64 && !TARGET_64BIT)\n+      if (ISA_HAS_MXHC1 && !TARGET_64BIT)\n \temit_insn (gen_mfhc1<mode> (high, operands[1]));\n       else\n \temit_insn (gen_store_word<mode> (high, operands[1], const1_rtx));"}, {"sha": "146961e52ad3455975ff9e108e22a3ff18d29b8d", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -197,6 +197,10 @@ mfp32\n Target Report RejectNegative InverseMask(FLOAT64)\n Use 32-bit floating-point registers\n \n+mfpxx\n+Target Report RejectNegative Mask(FLOATXX)\n+Conform to the o32 FPXX ABI\n+\n mfp64\n Target Report RejectNegative Mask(FLOAT64)\n Use 64-bit floating-point registers\n@@ -408,5 +412,9 @@ mxgot\n Target Report Var(TARGET_XGOT)\n Lift restrictions on GOT size\n \n+modd-spreg\n+Target Report Mask(ODD_SPREG)\n+Enable use of odd-numbered single-precision registers\n+\n noasmopt\n Driver"}, {"sha": "d6dc1bb84e499a4751889028233f21c995cfebab", "filename": "gcc/config/mips/mti-elf.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmti-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmti-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmti-elf.h?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -34,6 +34,11 @@ along with GCC; see the file COPYING3.  If not see\n      or -mgp setting.  */\t\t\t\t\t\t\\\n   \"%{!mabi=*: %{\" MIPS_32BIT_OPTION_SPEC \": -mabi=32;: -mabi=n32}}\",\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  /* If no FP ABI option is specified, infer one from the\t\t\\\n+     ABI/ISA level.  */\t\t\t\t\t\t\t\\\n+  \"%{!msoft-float: %{!msingle-float: %{!mfp*: %{mabi=32: %{\"\t\t\\\n+  MIPS_FPXX_OPTION_SPEC \": -mfpxx}}}}}\",\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   /* Make sure that an endian option is always present.  This makes\t\\\n      things like LINK_SPEC easier to write.  */\t\t\t\t\\\n   \"%{!EB:%{!EL:%(endian_spec)}}\",\t\t\t\t\t\\"}, {"sha": "98d6582b1984c0c71037166f3b3b33bfbda04052", "filename": "gcc/config/mips/mti-linux.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmti-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfig%2Fmips%2Fmti-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmti-linux.h?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -39,6 +39,11 @@ along with GCC; see the file COPYING3.  If not see\n      or -mgp setting.  */\t\t\t\t\t\t\\\n   \"%{!mabi=*: %{\" MIPS_32BIT_OPTION_SPEC \": -mabi=32;: -mabi=n32}}\",\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  /* If no FP ABI option is specified, infer one from the\t\t\\\n+     ABI/ISA level.  */\t\t\t\t\t\t\t\\\n+  \"%{!msoft-float: %{!msingle-float: %{!mfp*: %{mabi=32: %{\"\t\t\\\n+  MIPS_FPXX_OPTION_SPEC \": -mfpxx}}}}}\",\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   /* Base SPECs.  */\t\t\t\t\t\t\t\\\n   BASE_DRIVER_SELF_SPECS\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\"}, {"sha": "064b438304a0aea735aa6ddd8eef49be48299b2f", "filename": "gcc/configure", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -26152,6 +26152,41 @@ $as_echo \"#define HAVE_AS_GNU_ATTRIBUTE 1\" >>confdefs.h\n \n fi\n \n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .module support\" >&5\n+$as_echo_n \"checking assembler for .module support... \" >&6; }\n+if test \"${gcc_cv_as_mips_dot_module+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_mips_dot_module=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.module fp=32' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_mips_dot_module=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_mips_dot_module\" >&5\n+$as_echo \"$gcc_cv_as_mips_dot_module\" >&6; }\n+if test $gcc_cv_as_mips_dot_module = yes; then\n+\n+$as_echo \"#define HAVE_AS_DOT_MODULE 1\" >>confdefs.h\n+\n+fi\n+    if test x$gcc_cv_as_mips_dot_module = xno \\\n+       && test x$with_fp_32 != x; then\n+      as_fn_error \"Requesting --with-fp-32= requires assembler support for .module.\" \"$LINENO\" 5\n+    fi\n+\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .micromips support\" >&5\n $as_echo_n \"checking assembler for .micromips support... \" >&6; }\n if test \"${gcc_cv_as_micromips_support+set}\" = set; then :"}, {"sha": "8be5479591e87cb5fc9036e36c0b6890714862ac", "filename": "gcc/configure.ac", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -4241,6 +4241,17 @@ LCF0:\n       [AC_DEFINE(HAVE_AS_GNU_ATTRIBUTE, 1,\n \t  [Define if your assembler supports .gnu_attribute.])])\n \n+    gcc_GAS_CHECK_FEATURE([.module support],\n+      gcc_cv_as_mips_dot_module,,,\n+      [.module fp=32],,\n+      [AC_DEFINE(HAVE_AS_DOT_MODULE, 1,\n+\t  [Define if your assembler supports .module.])])\n+    if test x$gcc_cv_as_mips_dot_module = xno \\\n+       && test x$with_fp_32 != x; then\n+      AC_MSG_ERROR(\n+\t[Requesting --with-fp-32= requires assembler support for .module.])\n+    fi\n+\n     gcc_GAS_CHECK_FEATURE([.micromips support],\n       gcc_cv_as_micromips_support,,[--fatal-warnings],\n       [.set micromips],,"}, {"sha": "f314cf20978ed91bc60ef5254d57983d96acdbf9", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -1261,6 +1261,32 @@ ISA for floating-point arithmetics.  You can select either @samp{sse} which\n enables @option{-msse2} or @samp{avx} which enables @option{-mavx} by default.\n This option is only supported on i386 and x86-64 targets.\n \n+@item --with-fp-32=@var{mode}\n+On MIPS targets, set the default value for the @option{-mfp} option when using\n+the o32 ABI.  The possibilities for @var{mode} are:\n+@table @code\n+@item 32\n+Use the o32 FP32 ABI extension, as with the @option{-mfp32} command-line\n+option.\n+@item xx\n+Use the o32 FPXX ABI extension, as with the @option{-mfpxx} command-line\n+option.\n+@item 64\n+Use the o32 FP64 ABI extension, as with the @option{-mfp64} command-line\n+option.\n+@end table\n+In the absence of this configuration option the default is to use the o32\n+FP32 ABI extension.\n+\n+@item --with-odd-spreg-32\n+On MIPS targets, set the @option{-modd-spreg} option by default when using\n+the o32 ABI.\n+\n+@item --without-odd-spreg-32\n+On MIPS targets, set the @option{-mno-odd-spreg} option by default when using\n+the o32 ABI.  This is normally used in conjunction with\n+@option{--with-fp-32=64} in order to target the o32 FP64A ABI extension.\n+\n @item --with-nan=@var{encoding}\n On MIPS targets, set the default encoding convention to use for the\n special not-a-number (NaN) IEEE 754 floating-point data.  The"}, {"sha": "294e17dcf8923791477cda0bddef00c146b59690", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -788,8 +788,9 @@ Objective-C and Objective-C++ Dialects}.\n -minterlink-mips16  -mno-interlink-mips16 @gol\n -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol\n -mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot @gol\n--mgp32  -mgp64  -mfp32  -mfp64  -mhard-float  -msoft-float @gol\n+-mgp32  -mgp64  -mfp32  -mfpxx  -mfp64  -mhard-float  -msoft-float @gol\n -mno-float  -msingle-float  -mdouble-float @gol\n+-modd-spreg -mno-odd-spreg @gol\n -mabs=@var{mode}  -mnan=@var{encoding} @gol\n -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol\n -mmcu -mmno-mcu @gol\n@@ -17745,7 +17746,20 @@ same, but each scalar value is passed in a single 64-bit register\n rather than a pair of 32-bit registers.  For example, scalar\n floating-point values are returned in @samp{$f0} only, not a\n @samp{$f0}/@samp{$f1} pair.  The set of call-saved registers also\n-remains the same, but all 64 bits are saved.\n+remains the same in that the even-numbered double-precision registers\n+are saved.\n+\n+Two additional variants of the o32 ABI are supported to enable\n+a transition from 32-bit to 64-bit registers.  These are FPXX\n+(@option{-mfpxx}) and FP64A (@option{-mfp64} @option{-mno-odd-spreg}).\n+The FPXX extension mandates that all code must execute correctly\n+when run using 32-bit or 64-bit registers.  The code can be interlinked\n+with either FP32 or FP64, but not both.\n+The FP64A extension is similar to the FP64 extension but forbids the\n+use of odd-numbered single-precision registers.  This can be used\n+in conjunction with the @code{FRE} mode of FPUs in MIPS32R5\n+processors and allows both FP32 and FP64A code to interlink and\n+run in the same process without changing FPU modes.\n \n @item -mabicalls\n @itemx -mno-abicalls\n@@ -17834,6 +17848,10 @@ Assume that floating-point registers are 32 bits wide.\n @opindex mfp64\n Assume that floating-point registers are 64 bits wide.\n \n+@item -mfpxx\n+@opindex mfpxx\n+Do not assume the width of floating-point registers.\n+\n @item -mhard-float\n @opindex mhard-float\n Use floating-point coprocessor instructions.\n@@ -17865,6 +17883,15 @@ operations.\n Assume that the floating-point coprocessor supports double-precision\n operations.  This is the default.\n \n+@item -modd-spreg\n+@itemx -mno-odd-spreg\n+@opindex modd-spreg\n+@opindex mno-odd-spreg\n+Enable the use of odd-numbered single-precision floating-point registers\n+for the o32 ABI.  This is the default for processors that are known to\n+support these registers.  When using the o32 FPXX ABI, @code{-mno-odd-spreg}\n+is set by default.\n+\n @item -mabs=2008\n @itemx -mabs=legacy\n @opindex mabs=2008"}, {"sha": "c2cbfe80aedc456b07d774b6fc61290a824008e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -1,3 +1,27 @@\n+2014-11-12  Matthew Fortune  <matthew.fortune@imgtec.com>\n+\n+\t* gcc.target/mips/args-1.c: Handle __mips_fpr == 0.\n+\t* gcc.target/mips/call-clobbered-1.c: New.\n+\t* gcc.target/mips/call-clobbered-2.c: New.\n+\t* gcc.target/mips/call-clobbered-3.c: New.\n+\t* gcc.target/mips/call-clobbered-4.c: New.\n+\t* gcc.target/mips/call-clobbered-5.c: New.\n+\t* gcc.target/mips/call-saved-4.c: New.\n+\t* gcc.target/mips/call-saved-5.c: New.\n+\t* gcc.target/mips/call-saved-6.c: New.\n+\t* gcc.target/mips/mips.exp: Support -mfpxx, -ffixed-f*,\n+\tand -m[no-]odd-spreg.  Use _MIPS_SPFPSET to determine default\n+\todd-spreg option.  Account for -modd-spreg in minimum arch code.\n+\t* gcc.target/mips/movdf-1.c: New.\n+\t* gcc.target/mips/movdf-2.c: New.\n+\t* gcc.target/mips/movdf-3.c: New.\n+\t* gcc.target/mips/oddspreg-1.c: New.\n+\t* gcc.target/mips/oddspreg-2.c: New.\n+\t* gcc.target/mips/oddspreg-3.c: New.\n+\t* gcc.target/mips/oddspreg-4.c: New.\n+\t* gcc.target/mips/oddspreg-5.c: New.\n+\t* gcc.target/mips/oddspreg-6.c: New.\n+\n 2014-11-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/63815"}, {"sha": "643df24263c860a7d8a0ef30b633ada6ca03a335", "filename": "gcc/testsuite/gcc.target/mips/args-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fargs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fargs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fargs-1.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -5,7 +5,7 @@\n const char *compiled_for = _MIPS_ARCH;\n const char *optimized_for = _MIPS_TUNE;\n \n-#if __mips_fpr != 32 && __mips_fpr != 64\n+#if __mips_fpr != 32 && __mips_fpr != 64 && __mips_fpr != 0\n #error Bad __mips_fpr\n #endif\n "}, {"sha": "ecb994f2187029407df00e51919ee7cf5123be7e", "filename": "gcc/testsuite/gcc.target/mips/call-clobbered-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-1.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,21 @@\n+/* Check that we handle call-clobbered FPRs correctly.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"isa>=2 -mabi=32 -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19\" } */\n+\n+void bar (void);\n+double a;\n+double\n+foo ()\n+{\n+  double b = a + 1.0;\n+  bar();\n+  return b;\n+}\n+/* { dg-final { scan-assembler-not \"lwc1\" } } */\n+/* { dg-final { scan-assembler-not \"swc1\" } } */\n+/* { dg-final { scan-assembler-times \"sdc1\" 2 } } */\n+/* { dg-final { scan-assembler-times \"ldc1\" 4 } } */\n+/* { dg-final { scan-assembler-not \"mtc\" } } */\n+/* { dg-final { scan-assembler-not \"mfc\" } } */\n+/* { dg-final { scan-assembler-not \"mthc\" } } */\n+/* { dg-final { scan-assembler-not \"mfhc\" } } */"}, {"sha": "5f9a47208c71480aafb59d5a6ebc1da3ec779058", "filename": "gcc/testsuite/gcc.target/mips/call-clobbered-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-2.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,21 @@\n+/* Check that we handle call-clobbered FPRs correctly.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -modd-spreg -mfp32 -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19 -ffixed-f20 -ffixed-f22 -ffixed-f24 -ffixed-f26 -ffixed-f28 -ffixed-f30\" } */\n+\n+void bar (void);\n+float a;\n+float\n+foo ()\n+{\n+  float b = a + 1.0f;\n+  bar();\n+  return b;\n+}\n+/* { dg-final { scan-assembler-times \"lwc1\" 4 } } */\n+/* { dg-final { scan-assembler-times \"swc1\" 2 } } */\n+/* { dg-final { scan-assembler-not \"mtc\" } } */\n+/* { dg-final { scan-assembler-not \"mfc\" } } */\n+/* { dg-final { scan-assembler-not \"mthc\" } } */\n+/* { dg-final { scan-assembler-not \"mfhc\" } } */\n+/* { dg-final { scan-assembler-not \"sdc1\" } } */\n+/* { dg-final { scan-assembler-not \"ldc1\" } } */"}, {"sha": "fce4d9912451c945d1e976b4c00113d96dfe883f", "filename": "gcc/testsuite/gcc.target/mips/call-clobbered-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-3.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,23 @@\n+/* Check that we handle call-clobbered FPRs correctly.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* Refer to call-clobbered-4.c to see the expected output from -Os builds.  */\n+/* { dg-skip-if \"uses callee-saved GPR\" { *-*-* } { \"-Os\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -modd-spreg -mfpxx -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19 -ffixed-f20 -ffixed-f22 -ffixed-f24 -ffixed-f26 -ffixed-f28 -ffixed-f30\" } */\n+\n+void bar (void);\n+float a;\n+float\n+foo ()\n+{\n+  float b = a + 1.0f;\n+  bar();\n+  return b;\n+}\n+/* { dg-final { scan-assembler-times \"lwc1\" 5 } } */\n+/* { dg-final { scan-assembler-times \"swc1\" 3 } } */\n+/* { dg-final { scan-assembler-not \"mtc\" } } */\n+/* { dg-final { scan-assembler-not \"mfc\" } } */\n+/* { dg-final { scan-assembler-not \"mthc\" } } */\n+/* { dg-final { scan-assembler-not \"mfhc\" } } */\n+/* { dg-final { scan-assembler-not \"ldc1\" } } */\n+/* { dg-final { scan-assembler-not \"sdc1\" } } */"}, {"sha": "51498b8fa283aa96b333ef42dd1f88306f165b32", "filename": "gcc/testsuite/gcc.target/mips/call-clobbered-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-4.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,23 @@\n+/* Check that we handle call-clobbered FPRs correctly.\n+   This test differs from call-clobbered-3.c because when optimising for size\n+   a callee-saved GPR is used for 'b' to cross the call.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"*\" } { \"-Os\" } } */\n+/* { dg-options \"-mabi=32 -modd-spreg -mfpxx -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19 -ffixed-f20 -ffixed-f22 -ffixed-f24 -ffixed-f26 -ffixed-f28 -ffixed-f30\" } */\n+\n+void bar (void);\n+float a;\n+float\n+foo ()\n+{\n+  float b = a + 1.0f;\n+  bar();\n+  return b;\n+}\n+/* { dg-final { scan-assembler-times \"lwc1\" 4 } } */\n+/* { dg-final { scan-assembler-times \"swc1\" 2 } } */\n+/* { dg-final { scan-assembler-times \"mtc\" 1 } } */\n+/* { dg-final { scan-assembler-times \"mfc\" 1 } } */\n+/* { dg-final { scan-assembler-not \"mthc\" } } */\n+/* { dg-final { scan-assembler-not \"mfhc\" } } */\n+/* { dg-final { scan-assembler-not \"ldc1\" } } */\n+/* { dg-final { scan-assembler-not \"sdc1\" } } */"}, {"sha": "c7cd7cac7ddca288555b7acb1a1a7db3acf9ad8b", "filename": "gcc/testsuite/gcc.target/mips/call-clobbered-5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-clobbered-5.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,21 @@\n+/* Check that we handle call-clobbered FPRs correctly.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mfp64 -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19 -ffixed-f20 -ffixed-f22 -ffixed-f24 -ffixed-f26 -ffixed-f28 -ffixed-f30\" } */\n+\n+void bar (void);\n+float a;\n+float\n+foo ()\n+{\n+  float b = a + 1.0f;\n+  bar();\n+  return b;\n+}\n+/* { dg-final { scan-assembler-times \"lwc1\" 3 } } */\n+/* { dg-final { scan-assembler-times \"swc1\" 1 } } */\n+/* { dg-final { scan-assembler-not \"sdc1\" } } */\n+/* { dg-final { scan-assembler-not \"ldc1\" } } */\n+/* { dg-final { scan-assembler-not \"mtc\" } } */\n+/* { dg-final { scan-assembler-not \"mfc\" } } */\n+/* { dg-final { scan-assembler-not \"mthc\" } } */\n+/* { dg-final { scan-assembler-not \"mfhc\" } } */"}, {"sha": "e12617558d90c755ce3c8c7aaf17143e2952afc8", "filename": "gcc/testsuite/gcc.target/mips/call-saved-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-4.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,32 @@\n+/* Check that we save the correct call-saved GPRs and FPRs.  */\n+/* { dg-options \"isa>=2 -mabi=32 -mfp32\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int x)\n+{\n+  __builtin_unwind_init ();\n+  __builtin_eh_return (x, bar);\n+}\n+/* { dg-final { scan-assembler \"\\\\\\$16\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$17\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$18\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$19\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$20\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$21\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$22\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$23\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$(30|fp)\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f20\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f22\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f24\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f26\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f28\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f30\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f21\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f23\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f25\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f27\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f29\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f31\" } } */"}, {"sha": "2937b316dc719138bc78e60575da446b00849cd0", "filename": "gcc/testsuite/gcc.target/mips/call-saved-5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-5.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,32 @@\n+/* Check that we save the correct call-saved GPRs and FPRs.  */\n+/* { dg-options \"-mabi=32 -mfpxx\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int x)\n+{\n+  __builtin_unwind_init ();\n+  __builtin_eh_return (x, bar);\n+}\n+/* { dg-final { scan-assembler \"\\\\\\$16\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$17\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$18\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$19\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$20\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$21\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$22\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$23\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$(30|fp)\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f20\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f22\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f24\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f26\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f28\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f30\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f21\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f23\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f25\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f27\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f29\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f31\" } } */"}, {"sha": "0d1a4c845c95b496b10130ca6c9ad3fb55a8706a", "filename": "gcc/testsuite/gcc.target/mips/call-saved-6.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcall-saved-6.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,32 @@\n+/* Check that we save the correct call-saved GPRs and FPRs.  */\n+/* { dg-options \"-mabi=32 -mfp64\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int x)\n+{\n+  __builtin_unwind_init ();\n+  __builtin_eh_return (x, bar);\n+}\n+/* { dg-final { scan-assembler \"\\\\\\$16\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$17\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$18\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$19\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$20\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$21\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$22\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$23\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$(30|fp)\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f20\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f22\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f24\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f26\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f28\" } } */\n+/* { dg-final { scan-assembler \"\\\\\\$f30\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f21\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f23\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f25\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f27\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f29\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$f31\" } } */"}, {"sha": "a9beb276e95cac7a264fb898669cc6c2ff34fc01", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -235,7 +235,7 @@ set mips_option_groups {\n     endianness \"-E(L|B)|-me(l|b)\"\n     float \"-m(hard|soft)-float\"\n     forbid_cpu \"forbid_cpu=.*\"\n-    fp \"-mfp(32|64)\"\n+    fp \"-mfp(32|xx|64)\"\n     gp \"-mgp(32|64)\"\n     long \"-mlong(32|64)\"\n     micromips \"-mmicromips|-mno-micromips\"\n@@ -248,6 +248,10 @@ set mips_option_groups {\n     dump \"-fdump-.*\"\n }\n \n+for { set option 0 } { $option < 32 } { incr option } {\n+    lappend mips_option_groups \"fixed-f$option\" \"-ffixed-f$option\"\n+}\n+\n # Add -mfoo/-mno-foo options to mips_option_groups.\n foreach option {\n     abicalls\n@@ -270,6 +274,7 @@ foreach option {\n     synci\n     relax-pic-calls\n     mcount-ra-address\n+    odd-spreg\n } {\n     lappend mips_option_groups $option \"-m(no-|)$option\"\n }\n@@ -723,8 +728,12 @@ proc mips-dg-init {} {\n \t    #if __mips_fpr == 64\n \t    \"-mfp64\",\n \t    #else\n+\t    #if __mips_fpr == 0\n+\t    \"-mfpxx\",\n+\t    #else\n \t    \"-mfp32\",\n \t    #endif\n+\t    #endif\n \n \t    #ifdef __mips64\n \t    \"-mgp64\",\n@@ -756,6 +765,12 @@ proc mips-dg-init {} {\n \t    \"-mno-paired-single\",\n \t    #endif\n \n+\t    #if _MIPS_SPFPSET == 32\n+\t    \"-modd-spreg\",\n+\t    #else\n+\t    \"-mno-odd-spreg\",\n+\t    #endif\n+\n \t    #if __mips_abicalls\n \t    \"-mabicalls\",\n \t    #else\n@@ -841,6 +856,8 @@ proc mips-dg-finish {} {\n #            |                           |\n #         -mfp64                      -mfp32\n #            |                           |\n+#         -modd-spreg                 -mno-odd-spreg\n+#            |                           |\n #         -mabs=2008/-mabs=legacy     <no option>\n #            |                           |\n #         -mhard-float                -msoft-float\n@@ -930,6 +947,7 @@ proc mips-dg-options { args } {\n     mips_option_dependency options \"-mips3d\" \"-mpaired-single\"\n     mips_option_dependency options \"-mpaired-single\" \"-mfp64\"\n     mips_option_dependency options \"-mfp64\" \"-mhard-float\"\n+    mips_option_dependency options \"-mfp64\" \"-modd-spreg\"\n     mips_option_dependency options \"-mabs=2008\" \"-mhard-float\"\n     mips_option_dependency options \"-mabs=legacy\" \"-mhard-float\"\n     mips_option_dependency options \"-mrelax-pic-calls\" \"-mno-plt\"\n@@ -1046,10 +1064,13 @@ proc mips-dg-options { args } {\n         # We need a MIPS32 or MIPS64 ISA for:\n \t#\n         #   - paired-single instructions(*)\n+        #   - odd numbered single precision registers\n         #\n \t# (*) Note that we don't support MIPS V at the moment.\n \t} elseif { $isa_rev < 1\n-\t\t   && [mips_have_test_option_p options \"-mpaired-single\"] } {\n+\t\t   && ([mips_have_test_option_p options \"-mpaired-single\"]\n+\t\t       || ([mips_have_test_option_p options \"-modd-spreg\"]\n+\t\t\t   && ![mips_have_test_option_p options \"-mfp64\"]))} {\n \t    if { $gp_size == 32 } {\n \t\tmips_make_test_option options \"-mips32\"\n \t    } else {\n@@ -1071,7 +1092,9 @@ proc mips-dg-options { args } {\n \t# (*) needed by both -mbranch-likely and -mfix-r10000\n \t} elseif { $isa < 2\n \t\t   && ([mips_have_test_option_p options \"-mbranch-likely\"]\n-\t\t       || [mips_have_test_option_p options \"-mfix-r10000\"]) } {\n+\t\t       || [mips_have_test_option_p options \"-mfix-r10000\"]\n+\t\t       || ($gp_size == 32\n+\t\t\t   && [mips_have_test_option_p options \"-mfpxx\"])) } {\n \t    mips_make_test_option options \"-mips2\"\n \t# Check whether we need to switch from a 32-bit processor to the\n \t# \"nearest\" 64-bit processor.\n@@ -1122,6 +1145,9 @@ proc mips-dg-options { args } {\n \t} elseif { [mips_have_test_option_p options \"-mlong64\"]\n \t\t   && [mips_long32_abi_p $abi] } {\n \t    set force_abi 1\n+\t} elseif { [mips_have_test_option_p options \"-mfpxx\"]\n+\t\t   && ![mips_same_option_p $abi \"-mabi=32\"] } {\n+\t    set force_abi 1\n \t} else {\n \t    set force_abi 0\n \t}\n@@ -1193,6 +1219,9 @@ proc mips-dg-options { args } {\n \t}\n \tif { $isa_rev < 1 } {\n \t    mips_make_test_option options \"-mno-paired-single\"\n+\t    if { ![mips_have_test_option_p options \"-mgp64\"] } {\n+\t\tmips_make_test_option options \"-mno-odd-spreg\"\n+\t    }\n \t}\n \tif { $isa_rev < 2 } {\n \t    if { $gp_size == 32 } {\n@@ -1223,6 +1252,7 @@ proc mips-dg-options { args } {\n     mips_option_dependency options \"-mplt\" \"-mno-shared\"\n     mips_option_dependency options \"-mno-shared\" \"-fno-pic\"\n     mips_option_dependency options \"-mfp32\" \"-mno-paired-single\"\n+    mips_option_dependency options \"-mfpxx\" \"-mno-paired-single\"\n     mips_option_dependency options \"-msoft-float\" \"-mno-paired-single\"\n     mips_option_dependency options \"-mno-paired-single\" \"-mno-mips3d\"\n \n@@ -1244,7 +1274,9 @@ proc mips-dg-options { args } {\n     foreach group $mips_abi_groups {\n \tset old_option [mips_original_option $group]\n \tset new_option [mips_option options $group]\n-\tif { ![mips_same_option_p $old_option $new_option] } {\n+\tif { ![mips_same_option_p $old_option $new_option]\n+\t     && ![mips_same_option_p $old_option \"-mfpxx\"]\n+\t     && ![mips_same_option_p $new_option \"-mfpxx\"] } {\n \t    switch -- [lindex $do_what 0] {\n \t\tlink -\n \t\trun {"}, {"sha": "f0267d00e97967cdadb9bab1ebc89592c9bf643b", "filename": "gcc/testsuite/gcc.target/mips/movdf-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-1.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,14 @@\n+/* Check that we move DFmode values via memory between FP and GP.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mfpxx isa=2\" } */\n+\n+void bar (void);\n+\n+double\n+foo (int x, double a)\n+{\n+  return a;\n+}\n+/* { dg-final { scan-assembler-not \"mthc1\" } } */\n+/* { dg-final { scan-assembler-not \"mtc1\" } } */\n+/* { dg-final { scan-assembler-times \"ldc1\" 1 } } */"}, {"sha": "175b61c7e7760ebb3d72b08c665a2dddfdd5f8f5", "filename": "gcc/testsuite/gcc.target/mips/movdf-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-2.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,14 @@\n+/* Check that we move DFmode values using mthc between FP and GP.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mfpxx isa_rev=2\" } */\n+\n+void bar (void);\n+\n+double\n+foo (int x, double a)\n+{\n+  return a;\n+}\n+/* { dg-final { scan-assembler \"mthc1\" } } */\n+/* { dg-final { scan-assembler \"mtc1\" } } */\n+/* { dg-final { scan-assembler-not \"ldc1\" } } */"}, {"sha": "5db52c9487b5d659c450439fd12dd50d8c9a69ed", "filename": "gcc/testsuite/gcc.target/mips/movdf-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmovdf-3.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,13 @@\n+/* Check that we move DFmode values using mtc1 between FP and GP.  */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mfp32 isa=2\" } */\n+\n+void bar (void);\n+\n+double\n+foo (int x, double a)\n+{\n+  return a;\n+}\n+/* { dg-final { scan-assembler-times \"mtc1\" 2 } } */\n+/* { dg-final { scan-assembler-not \"ldc1\" } } */"}, {"sha": "a9c695736930e1f7d5d11f8e93ec9d8989be9c4b", "filename": "gcc/testsuite/gcc.target/mips/oddspreg-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-1.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,13 @@\n+/* Check that we enable odd-numbered single precision registers.  */\n+/* { dg-options \"-mabi=32 -modd-spreg -mhard-float\" } */\n+\n+#if _MIPS_SPFPSET != 32\n+#error \"Incorrect number of single-precision registers reported\"\n+#endif\n+\n+void\n+foo ()\n+{\n+  register float foo asm (\"$f1\");\n+  asm volatile (\"\" : \"=f\" (foo));\n+}"}, {"sha": "e2e0a2660bb23b6a8b191f74ee46e847975b2955", "filename": "gcc/testsuite/gcc.target/mips/oddspreg-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-2.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,10 @@\n+/* Check that we disable odd-numbered single precision registers.  */\n+/* { dg-skip-if \"needs asm output\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mno-odd-spreg -mhard-float\" } */\n+\n+void\n+foo ()\n+{\n+  register float foo asm (\"$f1\"); /* { dg-error \"isn't suitable for\" } */\n+  asm volatile (\"\" : \"=f\" (foo));\n+}"}, {"sha": "f287eb66e92c8212b8ea6238cc42ed6ce96612f5", "filename": "gcc/testsuite/gcc.target/mips/oddspreg-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-3.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,10 @@\n+/* Check that we disable odd-numbered single precision registers.  */\n+/* { dg-skip-if \"needs asm output\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mfp32 -march=loongson3a -mhard-float\" } */\n+\n+void\n+foo ()\n+{\n+  register float foo asm (\"$f1\"); /* { dg-error \"isn't suitable for\" } */\n+  asm volatile (\"\" : \"=f\" (foo));\n+}"}, {"sha": "723424a39bd8327301a33a4da62db01d1ee4b754", "filename": "gcc/testsuite/gcc.target/mips/oddspreg-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-4.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,15 @@\n+/* Check that we disable odd-numbered single precision registers and can\n+   still generate code.  */\n+/* { dg-options \"-mabi=32 -mno-odd-spreg -mhard-float\" } */\n+\n+#if _MIPS_SPFPSET != 16\n+#error \"Incorrect number of single-precision registers reported\"\n+#endif\n+\n+float a;\n+float\n+foo ()\n+{\n+  float b = a + 1.0f;\n+  return b;\n+}"}, {"sha": "8d7d884580c29425e1be9bcd4956f045d3694d0c", "filename": "gcc/testsuite/gcc.target/mips/oddspreg-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-5.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,11 @@\n+/* Check that -mno-odd-spreg is not supported with -mabi=64.  */\n+/* { dg-options \"-mabi=64 -mno-odd-spreg -mhard-float\" } */\n+/* { dg-error \"unsupported combination\" \"\" { target *-*-* } 0 } */\n+\n+float a;\n+float\n+foo ()\n+{\n+  float b = a + 1.0f;\n+  return b;\n+}"}, {"sha": "955dea901407788395c66156cc6e4a822a2ddabd", "filename": "gcc/testsuite/gcc.target/mips/oddspreg-6.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Foddspreg-6.c?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -0,0 +1,10 @@\n+/* Check that we disable odd-numbered single precision registers for FPXX.  */\n+/* { dg-skip-if \"needs asm output\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+/* { dg-options \"-mabi=32 -mfpxx -mhard-float\" } */\n+\n+void\n+foo ()\n+{\n+  register float foo asm (\"$f1\"); /* { dg-error \"isn't suitable for\" } */\n+  asm volatile (\"\" : \"=f\" (foo));\n+}"}, {"sha": "fd7ba114d36a296311bbbb5d7bdf46a23bddb595", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -1,3 +1,9 @@\n+2014-11-12  Matthew Fortune  <matthew.fortune@imgtec.com>\n+\n+\t* config/mips/mips16.S: Set .module when supported.  Update O32\n+\tFP64 calling convention and use for FPXX when possible.  Add FPXX\n+\tcalling convention fallback case.\n+\n 2014-11-06  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config.host: Handle nvptx-*-*."}, {"sha": "c0c73ffac008ef6efa0f9a2bc92ab78379a7a2f4", "filename": "libgcc/config/mips/mips16.S", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050af1445b878d2a8a070f4c2ad602cbe80f8d73/libgcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050af1445b878d2a8a070f4c2ad602cbe80f8d73/libgcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmips%2Fmips16.S?ref=050af1445b878d2a8a070f4c2ad602cbe80f8d73", "patch": "@@ -21,6 +21,8 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+#include \"auto-host.h\"\n+\n #if defined(__mips_micromips) || defined(__mips_soft_float)\n   /* Do nothing because this code is only needed when linking\n      against mips16 hard-float objects.  Neither micromips code\n@@ -29,6 +31,16 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n      for those cases.  */\n #else\n \n+#if defined(HAVE_AS_MODULE)\n+#if __mips_fpr == 32\n+\t.module fp=32\n+#elif __mips_fpr == 0\n+\t.module fp=xx\n+#elif __mips_fpr == 64\n+\t.module fp=64\n+#endif\n+#endif\n+\n /* This file contains mips16 floating point support functions.  These\n    functions are called by mips16 code to handle floating point when\n    -msoft-float is not used.  They accept the arguments and return\n@@ -152,8 +164,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* The high 32 bits of $2 correspond to the second word in memory;\n    i.e. the imaginary part.  */\n #define MOVE_SC_RET(D, T) MERGE_GPR##D ($2, $f1, $f0); jr T\n-#elif __mips_fpr == 64\n-#define MOVE_SC_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##c1 $3,$f1)\n #else\n #define MOVE_SC_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##c1 $3,$f2)\n #endif\n@@ -174,16 +184,29 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define MOVE_DF_BYTE8(D) dm##D##c1 $5,$f13\n #define MOVE_DF_RET(D, T) DELAY##D (T, dm##D##c1 $2,$f0)\n #define MOVE_DC_RET(D, T) dm##D##c1 $3,$f1; MOVE_DF_RET (D, T)\n-#elif __mips_fpr == 64 && defined(__MIPSEB__)\n+#elif __mips_fpr != 32 && __mips_isa_rev >= 2 && defined(__MIPSEB__)\n #define MOVE_DF_BYTE0(D) m##D##c1 $5,$f12; m##D##hc1 $4,$f12\n #define MOVE_DF_BYTE8(D) m##D##c1 $7,$f14; m##D##hc1 $6,$f14\n #define MOVE_DF_RET(D, T) m##D##c1 $3,$f0; DELAY##D (T, m##D##hc1 $2,$f0)\n-#define MOVE_DC_RET(D, T) m##D##c1 $5,$f1; m##D##hc1 $4,$f1; MOVE_DF_RET (D, T)\n-#elif __mips_fpr == 64\n+#define MOVE_DC_RET(D, T) m##D##c1 $5,$f2; m##D##hc1 $4,$f2; MOVE_DF_RET (D, T)\n+#elif __mips_fpr != 32 && __mips_isa_rev >= 2\n #define MOVE_DF_BYTE0(D) m##D##c1 $4,$f12; m##D##hc1 $5,$f12\n #define MOVE_DF_BYTE8(D) m##D##c1 $6,$f14; m##D##hc1 $7,$f14\n #define MOVE_DF_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##hc1 $3,$f0)\n-#define MOVE_DC_RET(D, T) m##D##c1 $4,$f1; m##D##hc1 $5,$f1; MOVE_DF_RET (D, T)\n+#define MOVE_DC_RET(D, T) m##D##c1 $4,$f2; m##D##hc1 $5,$f2; MOVE_DF_RET (D, T)\n+#elif __mips_fpr == 0\n+#define MOVE_DF_BYTE0t sw $4, 0($29); sw $5, 4($29); ldc1 $f12, 0($29)\n+#define MOVE_DF_BYTE0f sdc1 $f12, 0($29); lw $4, 0($29); lw $5, 4($29)\n+#define MOVE_DF_BYTE0(D) MOVE_DF_BYTE0##D\n+#define MOVE_DF_BYTE8t sw $6, 8($29); sw $7, 12($29); ldc1 $f14, 8($29)\n+#define MOVE_DF_BYTE8f sdc1 $f14, 8($29); lw $6, 8($29); lw $7, 12($29)\n+#define MOVE_DF_BYTE8(D) MOVE_DF_BYTE8##D\n+#define MOVE_DF_RETt(T) sw $2, 0($29); sw $3, 4($29); DELAYt (T, ldc1 $f0, 0($29))\n+#define MOVE_DF_RETf(T) sdc1 $f0, 0($29); lw $2, 0($29); DELAYf (T, lw $3, 4($29))\n+#define MOVE_DF_RET(D, T) MOVE_DF_RET##D(T)\n+#define MOVE_DC_RETt(T) sw $4, 8($29); sw $5, 12($29); ldc1 $f2, 8($29); MOVE_DF_RETt(T)\n+#define MOVE_DC_RETf(T) sdc1 $f2, 8($29); lw $4, 8($29); lw $5, 12($29); MOVE_DF_RETf(T)\n+#define MOVE_DC_RET(D, T) MOVE_DF_RET##D(T)\n #elif defined(__MIPSEB__)\n /* FPRs are little-endian.  */\n #define MOVE_DF_BYTE0(D) m##D##c1 $4,$f13; m##D##c1 $5,$f12"}]}