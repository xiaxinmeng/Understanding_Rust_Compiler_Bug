{"sha": "43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNiMWI5ZWRmY2Q1YWViOGZlNWNhMDEyYzgxY2RkOGQ0MjU5ZGUwNA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2014-09-23T18:36:14Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-09-23T18:36:14Z"}, "message": "demangle.h (DMGL_DLANG): New macro.\n\ninclude/:\n\t* demangle.h (DMGL_DLANG): New macro.\n\t(DMGL_STYLE_MASK): Add DMGL_DLANG.\n\t(demangling_styles): Add dlang_demangling.\n\t(DLANG_DEMANGLING_STYLE_STRING): New macro.\n\t(DLANG_DEMANGLING): New macro.\n\t(dlang_demangle): New prototype.\nlibiberty/:\n\t* Makefile.in (CFILES): Add d-demangle.c.\n\t(REQUIRED_OFILES): Add d-demangle.o.\n\t* cplus-dem.c (libiberty_demanglers): Add dlang_demangling case.\n\t(cplus_demangle): Likewise.\n\t* d-demangle.c: New file.\n\t* testsuite/Makefile.in (really-check): Add check-d-demangle.\n\t* testsuite/d-demangle-expected: New file.\n\nFrom-SVN: r215530", "tree": {"sha": "2fadd5830c2d708e5dd314b70206728b68cc62de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fadd5830c2d708e5dd314b70206728b68cc62de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a9f3c8f1e05cec05b02b8b79e6a5531ba8dc377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9f3c8f1e05cec05b02b8b79e6a5531ba8dc377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9f3c8f1e05cec05b02b8b79e6a5531ba8dc377"}], "stats": {"total": 2334, "additions": 2329, "deletions": 5}, "files": [{"sha": "88176beda1987c48af0f3fc1dcd9a0c1c614c038", "filename": "include/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -1,3 +1,12 @@\n+2014-09-23  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* demangle.h (DMGL_DLANG): New macro.\n+\t(DMGL_STYLE_MASK): Add DMGL_DLANG.\n+\t(demangling_styles): Add dlang_demangling.\n+\t(DLANG_DEMANGLING_STYLE_STRING): New macro.\n+\t(DLANG_DEMANGLING): New macro.\n+\t(dlang_demangle): New prototype.\n+\n 2014-09-15  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* longlong.h: Add __udiv_w_sdiv prototype."}, {"sha": "d2a6731a9ee5509e8d0f27744f7bb85b4c1e05ca", "filename": "include/demangle.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -63,9 +63,10 @@ extern \"C\" {\n #define DMGL_EDG\t (1 << 13)\n #define DMGL_GNU_V3\t (1 << 14)\n #define DMGL_GNAT\t (1 << 15)\n+#define DMGL_DLANG\t (1 << 16)\n \n /* If none of these are set, use 'current_demangling_style' as the default. */\n-#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT)\n+#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT|DMGL_DLANG)\n \n /* Enumeration of possible demangling styles.\n \n@@ -87,7 +88,8 @@ extern enum demangling_styles\n   edg_demangling = DMGL_EDG,\n   gnu_v3_demangling = DMGL_GNU_V3,\n   java_demangling = DMGL_JAVA,\n-  gnat_demangling = DMGL_GNAT\n+  gnat_demangling = DMGL_GNAT,\n+  dlang_demangling = DMGL_DLANG\n } current_demangling_style;\n \n /* Define string names for the various demangling styles. */\n@@ -102,6 +104,7 @@ extern enum demangling_styles\n #define GNU_V3_DEMANGLING_STYLE_STRING        \"gnu-v3\"\n #define JAVA_DEMANGLING_STYLE_STRING          \"java\"\n #define GNAT_DEMANGLING_STYLE_STRING          \"gnat\"\n+#define DLANG_DEMANGLING_STYLE_STRING         \"dlang\"\n \n /* Some macros to test what demangling style is active. */\n \n@@ -115,6 +118,7 @@ extern enum demangling_styles\n #define GNU_V3_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU_V3)\n #define JAVA_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_JAVA)\n #define GNAT_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNAT)\n+#define DLANG_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_DLANG)\n \n /* Provide information about the available demangle styles. This code is\n    pulled from gdb into libiberty because it is useful to binutils also.  */\n@@ -169,6 +173,9 @@ java_demangle_v3 (const char *mangled);\n char *\n ada_demangle (const char *mangled, int options);\n \n+extern char *\n+dlang_demangle (const char *mangled, int options);\n+\n enum gnu_v3_ctor_kinds {\n   gnu_v3_complete_object_ctor = 1,\n   gnu_v3_base_object_ctor,"}, {"sha": "d47b8730ea5734d6a232858c768426e190cd133d", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -1,3 +1,13 @@\n+2014-09-23  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* Makefile.in (CFILES): Add d-demangle.c.\n+\t(REQUIRED_OFILES): Add d-demangle.o.\n+\t* cplus-dem.c (libiberty_demanglers): Add dlang_demangling case.\n+\t(cplus_demangle): Likewise.\n+\t* d-demangle.c: New file.\n+\t* testsuite/Makefile.in (really-check): Add check-d-demangle.\n+\t* testsuite/d-demangle-expected: New file.\n+\n 2014-09-19  Ian Lance Taylor  <iant@google.com>\n \n \t* simple-object-elf.c (simple_object_elf_write_ehdr): Correctly"}, {"sha": "9b877209bd18b46031ac099ab14a597e2f9d2655", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -127,7 +127,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \tbasename.c bcmp.c bcopy.c bsearch.c bzero.c\t\t\t\\\n \tcalloc.c choose-temp.c clock.c concat.c cp-demangle.c\t\t\\\n \t cp-demint.c cplus-dem.c crc32.c\t\t\t\t\\\n-\tdwarfnames.c dyn-string.c\t\t\t\t\t\\\n+\td-demangle.c dwarfnames.c dyn-string.c\t\t\t\t\\\n \tfdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c\t\t\\\n \tfnmatch.c fopen_unlocked.c\t\t\t\t\t\\\n \tgetcwd.c getopt.c getopt1.c getpagesize.c getpwd.c getruntime.c\t\\\n@@ -167,7 +167,7 @@ REQUIRED_OFILES =\t\t\t\t\t\t\t\\\n \t./md5.$(objext) ./sha1.$(objext) ./alloca.$(objext)\t\t\\\n \t./argv.$(objext)\t\t\t\t\t\t\\\n \t./choose-temp.$(objext) ./concat.$(objext)\t\t\t\\\n-\t./cp-demint.$(objext) ./crc32.$(objext)\t\t\t\t\\\n+\t./cp-demint.$(objext) ./crc32.$(objext) ./d-demangle.$(objext)\t\\\n \t./dwarfnames.$(objext) ./dyn-string.$(objext)\t\t\t\\\n \t./fdmatch.$(objext) ./fibheap.$(objext)\t\t\t\t\\\n \t./filename_cmp.$(objext) ./floatformat.$(objext)\t\t\\\n@@ -714,6 +714,14 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/dyn-string.c $(OUTPUT_OPTION)\n \n+./d-demangle.$(objext): $(srcdir)/d-demangle.c config.h $(INCDIR)/ansidecl.h \\\n+\t$(srcdir)/cp-demangle.h $(INCDIR)/demangle.h \\\n+\t$(INCDIR)/dyn-string.h $(INCDIR)/getopt.h $(INCDIR)/libiberty.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/d-demangle.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/d-demangle.c $(OUTPUT_OPTION)\n+\n ./fdmatch.$(objext): $(srcdir)/fdmatch.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\"}, {"sha": "c68b9813de25c6ee39e5288bf74649a1d2de3965", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -305,6 +305,12 @@ const struct demangler_engine libiberty_demanglers[] =\n     \"GNAT style demangling\"\n   }\n   ,\n+  {\n+    DLANG_DEMANGLING_STYLE_STRING,\n+    dlang_demangling,\n+    \"DLANG style demangling\"\n+  }\n+  ,\n   {\n     NULL, unknown_demangling, NULL\n   }\n@@ -870,6 +876,13 @@ cplus_demangle (const char *mangled, int options)\n   if (GNAT_DEMANGLING)\n     return ada_demangle (mangled, options);\n \n+  if (DLANG_DEMANGLING)\n+    {\n+      ret = dlang_demangle (mangled, options);\n+      if (ret)\n+\treturn ret;\n+    }\n+\n   ret = internal_cplus_demangle (work, mangled);\n   squangle_mop_up (work);\n   return (ret);"}, {"sha": "d31bf9423780ca68ea18c71fe9f9ee55f90add37", "filename": "libiberty/d-demangle.c", "status": "added", "additions": 1338, "deletions": 0, "changes": 1338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Fd-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Fd-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fd-demangle.c?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -0,0 +1,1338 @@\n+/* Demangler for the D programming language\n+   Copyright 2014 Free Software Foundation, Inc.\n+   Written by Iain Buclaw (ibuclaw@gdcproject.org)\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU Library General Public\n+License, the Free Software Foundation gives you unlimited permission\n+to link the compiled version of this file into combinations with other\n+programs, and to distribute those combinations without any restriction\n+coming from the use of this file.  (The Library Public License\n+restrictions do apply in other respects; for example, they cover\n+modification of the file, and distribution when not linked into a\n+combined executable.)\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.\n+If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This file exports one function; dlang_demangle.\n+\n+   This file imports strtol and strtold for decoding mangled literals.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include \"safe-ctype.h\"\n+\n+#include <sys/types.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#else\n+extern long strtol (const char *nptr, char **endptr, int base);\n+extern long double strtold (const char *nptr, char **endptr);\n+#endif\n+\n+#include <demangle.h>\n+#include \"libiberty.h\"\n+\n+/* A mini string-handling package */\n+\n+typedef struct string\t\t/* Beware: these aren't required to be */\n+{\t\t\t\t/*  '\\0' terminated.  */\n+  char *b;\t\t\t/* pointer to start of string */\n+  char *p;\t\t\t/* pointer after last character */\n+  char *e;\t\t\t/* pointer after end of allocated space */\n+} string;\n+\n+static void\n+string_need (string *s, int n)\n+{\n+  int tem;\n+\n+  if (s->b == NULL)\n+    {\n+      if (n < 32)\n+\t{\n+\t  n = 32;\n+\t}\n+      s->p = s->b = XNEWVEC (char, n);\n+      s->e = s->b + n;\n+    }\n+  else if (s->e - s->p < n)\n+    {\n+      tem = s->p - s->b;\n+      n += tem;\n+      n *= 2;\n+      s->b = XRESIZEVEC (char, s->b, n);\n+      s->p = s->b + tem;\n+      s->e = s->b + n;\n+    }\n+}\n+\n+static void\n+string_delete (string *s)\n+{\n+  if (s->b != NULL)\n+    {\n+      XDELETEVEC (s->b);\n+      s->b = s->e = s->p = NULL;\n+    }\n+}\n+\n+static void\n+string_init (string *s)\n+{\n+  s->b = s->p = s->e = NULL;\n+}\n+\n+static int\n+string_length (string *s)\n+{\n+  if (s->p == s->b)\n+    {\n+      return 0;\n+    }\n+  return s->p - s->b;\n+}\n+\n+static void\n+string_setlength (string *s, int n)\n+{\n+  if (n - string_length (s) < 0)\n+    {\n+      s->p = s->b + n;\n+    }\n+}\n+\n+static void\n+string_append (string *p, const char *s)\n+{\n+  int n = strlen (s);\n+  string_need (p, n);\n+  memcpy (p->p, s, n);\n+  p->p += n;\n+}\n+\n+static void\n+string_appendn (string *p, const char *s, int n)\n+{\n+  if (n != 0)\n+    {\n+      string_need (p, n);\n+      memcpy (p->p, s, n);\n+      p->p += n;\n+    }\n+}\n+\n+static void\n+string_prependn (string *p, const char *s, int n)\n+{\n+  char *q;\n+\n+  if (n != 0)\n+    {\n+      string_need (p, n);\n+      for (q = p->p - 1; q >= p->b; q--)\n+\t{\n+\t  q[n] = q[0];\n+\t}\n+      memcpy (p->b, s, n);\n+      p->p += n;\n+    }\n+}\n+\n+static void\n+string_prepend (string *p, const char *s)\n+{\n+  if (s != NULL && *s != '\\0')\n+    {\n+      string_prependn (p, s, strlen (s));\n+    }\n+}\n+\n+/* Prototypes for forward referenced functions */\n+static const char *dlang_function_args (string *, const char *);\n+\n+static const char *dlang_type (string *, const char *);\n+\n+static const char *dlang_value (string *, const char *, const char *, char);\n+\n+static const char *dlang_parse_symbol (string *, const char *);\n+\n+static const char *dlang_parse_tuple (string *, const char *);\n+\n+static const char *dlang_parse_template (string *, const char *, long);\n+\n+\n+/* Demangle the calling convention from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_call_convention (string *decl, const char *mangled)\n+{\n+  if (mangled == NULL || *mangled == '\\0')\n+    return mangled;\n+\n+  switch (*mangled)\n+    {\n+    case 'F': /* (D) */\n+      mangled++;\n+      break;\n+    case 'U': /* (C) */\n+      mangled++;\n+      string_append (decl, \"extern(C) \");\n+      break;\n+    case 'W': /* (Windows) */\n+      mangled++;\n+      string_append (decl, \"extern(Windows) \");\n+      break;\n+    case 'V': /* (Pascal) */\n+      mangled++;\n+      string_append (decl, \"extern(Pascal) \");\n+      break;\n+    case 'R': /* (C++) */\n+      mangled++;\n+      string_append (decl, \"extern(C++) \");\n+      break;\n+    default:\n+      return NULL;\n+    }\n+\n+  return mangled;\n+}\n+\n+/* Demangle the D function attributes from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_attributes (string *decl, const char *mangled)\n+{\n+  if (mangled == NULL || *mangled == '\\0')\n+    return mangled;\n+\n+  while (*mangled == 'N')\n+    {\n+      mangled++;\n+      switch (*mangled)\n+\t{\n+\tcase 'a': /* pure */\n+\t  mangled++;\n+\t  string_append (decl, \"pure \");\n+\t  continue;\n+\tcase 'b': /* nothrow */\n+\t  mangled++;\n+\t  string_append (decl, \"nothrow \");\n+\t  continue;\n+\tcase 'c': /* ref */\n+\t  mangled++;\n+\t  string_append (decl, \"ref \");\n+\t  continue;\n+\tcase 'd': /* @property */\n+\t  mangled++;\n+\t  string_append (decl, \"@property \");\n+\t  continue;\n+\tcase 'e': /* @trusted */\n+\t  mangled++;\n+\t  string_append (decl, \"@trusted \");\n+\t  continue;\n+\tcase 'f': /* @safe */\n+\t  mangled++;\n+\t  string_append (decl, \"@safe \");\n+\t  continue;\n+\tcase 'g':\n+\tcase 'h':\n+\t  /* inout parameter is represented as 'Ng'.\n+\t     vector parameter is represented as 'Nh'.\n+\t     If we see this, then we know we're really in the\n+\t     parameter list.  Rewind and break.  */\n+\t  mangled--;\n+\t  break;\n+\tcase 'i': /* @nogc */\n+\t  mangled++;\n+\t  string_append (decl, \"@nogc \");\n+\t  continue;\n+\t}\n+      break;\n+    }\n+\n+  return mangled;\n+}\n+\n+/* Demangle the function type from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_function_type (string *decl, const char *mangled)\n+{\n+  string attr, args, type;\n+  size_t szattr, szargs, sztype;\n+\n+  if (mangled == NULL || *mangled == '\\0')\n+    return mangled;\n+\n+  /* The order of the mangled string is:\n+\tCallConvention FuncAttrs Arguments ArgClose Type\n+\n+     The demangled string is re-ordered as:\n+\tCallConvention Type Arguments FuncAttrs\n+   */\n+  string_init (&attr);\n+  string_init (&args);\n+  string_init (&type);\n+\n+  /* Function call convention.  */\n+  mangled = dlang_call_convention (decl, mangled);\n+\n+  /* Function attributes.  */\n+  mangled = dlang_attributes (&attr, mangled);\n+  szattr = string_length (&attr);\n+\n+  /* Function arguments.  */\n+  mangled = dlang_function_args (&args, mangled);\n+  szargs = string_length (&args);\n+\n+  /* Function return type.  */\n+  mangled = dlang_type (&type, mangled);\n+  sztype = string_length (&type);\n+\n+  /* Append to decl in order. */\n+  string_appendn (decl, type.b, sztype);\n+  string_append (decl, \"(\");\n+  string_appendn (decl, args.b, szargs);\n+  string_append (decl, \") \");\n+  string_appendn (decl, attr.b, szattr);\n+\n+  string_delete (&attr);\n+  string_delete (&args);\n+  string_delete (&type);\n+  return mangled;\n+}\n+\n+/* Demangle the argument list from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_function_args (string *decl, const char *mangled)\n+{\n+  size_t n = 0;\n+\n+  while (mangled && *mangled != '\\0')\n+    {\n+      switch (*mangled)\n+\t{\n+\tcase 'X': /* (variadic T t...) style.  */\n+\t  mangled++;\n+\t  string_append (decl, \"...\");\n+\t  return mangled;\n+\tcase 'Y': /* (variadic T t, ...) style.  */\n+\t  mangled++;\n+\t  string_append (decl, \", ...\");\n+\t  return mangled;\n+\tcase 'Z': /* Normal function.  */\n+\t  mangled++;\n+\t  return mangled;\n+\t}\n+\n+      if (n++)\n+\tstring_append (decl, \", \");\n+\n+      if (*mangled == 'M') /* scope(T) */\n+\t{\n+\t  mangled++;\n+\t  string_append (decl, \"scope \");\n+\t}\n+\n+      switch (*mangled)\n+\t{\n+\tcase 'J': /* out(T) */\n+\t  mangled++;\n+\t  string_append (decl, \"out \");\n+\t  break;\n+\tcase 'K': /* ref(T) */\n+\t  mangled++;\n+\t  string_append (decl, \"ref \");\n+\t  break;\n+\tcase 'L': /* lazy(T) */\n+\t  mangled++;\n+\t  string_append (decl, \"lazy \");\n+\t  break;\n+\t}\n+      mangled = dlang_type (decl, mangled);\n+    }\n+\n+  return mangled;\n+}\n+\n+/* Demangle the type from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_type (string *decl, const char *mangled)\n+{\n+  if (mangled == NULL || *mangled == '\\0')\n+    return mangled;\n+\n+  switch (*mangled)\n+    {\n+    case 'O': /* shared(T) */\n+      mangled++;\n+      string_append (decl, \"shared(\");\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \")\");\n+      return mangled;\n+    case 'x': /* const(T) */\n+      mangled++;\n+      string_append (decl, \"const(\");\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \")\");\n+      return mangled;\n+    case 'y': /* immutable(T) */\n+      mangled++;\n+      string_append (decl, \"immutable(\");\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \")\");\n+      return mangled;\n+    case 'N':\n+      mangled++;\n+      if (*mangled == 'g') /* wild(T) */\n+\t{\n+\t  mangled++;\n+\t  string_append (decl, \"inout(\");\n+\t  mangled = dlang_type (decl, mangled);\n+\t  string_append (decl, \")\");\n+\t  return mangled;\n+\t}\n+      else if (*mangled == 'h') /* vector(T) */\n+\t{\n+\t  mangled++;\n+\t  string_append (decl, \"__vector(\");\n+\t  mangled = dlang_type (decl, mangled);\n+\t  string_append (decl, \")\");\n+\t  return mangled;\n+\t}\n+      else\n+\treturn NULL;\n+    case 'A': /* dynamic array (T[]) */\n+      mangled++;\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \"[]\");\n+      return mangled;\n+    case 'G': /* static array (T[N]) */\n+    {\n+      const char *numptr;\n+      size_t num = 0;\n+      mangled++;\n+\n+      numptr = mangled;\n+      while (ISDIGIT (*mangled))\n+\t{\n+\t  num++;\n+\t  mangled++;\n+\t}\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \"[\");\n+      string_appendn (decl, numptr, num);\n+      string_append (decl, \"]\");\n+      return mangled;\n+    }\n+    case 'H': /* associative array (T[T]) */\n+    {\n+      string type;\n+      size_t sztype;\n+      mangled++;\n+\n+      string_init (&type);\n+      mangled = dlang_type (&type, mangled);\n+      sztype = string_length (&type);\n+\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \"[\");\n+      string_appendn (decl, type.b, sztype);\n+      string_append (decl, \"]\");\n+\n+      string_delete (&type);\n+      return mangled;\n+    }\n+    case 'P': /* pointer (T*) */\n+      mangled++;\n+      mangled = dlang_type (decl, mangled);\n+      string_append (decl, \"*\");\n+      return mangled;\n+    case 'I': /* ident T */\n+    case 'C': /* class T */\n+    case 'S': /* struct T */\n+    case 'E': /* enum T */\n+    case 'T': /* typedef T */\n+      mangled++;\n+      return dlang_parse_symbol (decl, mangled);\n+    case 'D': /* delegate T */\n+      mangled++;\n+      mangled = dlang_function_type (decl, mangled);\n+      string_append (decl, \"delegate\");\n+      return mangled;\n+    case 'B': /* tuple T */\n+      mangled++;\n+      return dlang_parse_tuple (decl, mangled);\n+\n+    /* Function types */\n+    case 'F': case 'U': case 'W':\n+    case 'V': case 'R':\n+      mangled = dlang_function_type (decl, mangled);\n+      string_append (decl, \"function\");\n+      return mangled;\n+\n+    /* Basic types */\n+    case 'n':\n+      mangled++;\n+      string_append (decl, \"none\");\n+      return mangled;\n+    case 'v':\n+      mangled++;\n+      string_append (decl, \"void\");\n+      return mangled;\n+    case 'g':\n+      mangled++;\n+      string_append (decl, \"byte\");\n+      return mangled;\n+    case 'h':\n+      mangled++;\n+      string_append (decl, \"ubyte\");\n+      return mangled;\n+    case 's':\n+      mangled++;\n+      string_append (decl, \"short\");\n+      return mangled;\n+    case 't':\n+      mangled++;\n+      string_append (decl, \"ushort\");\n+      return mangled;\n+    case 'i':\n+      mangled++;\n+      string_append (decl, \"int\");\n+      return mangled;\n+    case 'k':\n+      mangled++;\n+      string_append (decl, \"uint\");\n+      return mangled;\n+    case 'l':\n+      mangled++;\n+      string_append (decl, \"long\");\n+      return mangled;\n+    case 'm':\n+      mangled++;\n+      string_append (decl, \"ulong\");\n+      return mangled;\n+    case 'f':\n+      mangled++;\n+      string_append (decl, \"float\");\n+      return mangled;\n+    case 'd':\n+      mangled++;\n+      string_append (decl, \"double\");\n+      return mangled;\n+    case 'e':\n+      mangled++;\n+      string_append (decl, \"real\");\n+      return mangled;\n+\n+    /* Imaginary and Complex types */\n+    case 'o':\n+      mangled++;\n+      string_append (decl, \"ifloat\");\n+      return mangled;\n+    case 'p':\n+      mangled++;\n+      string_append (decl, \"idouble\");\n+      return mangled;\n+    case 'j':\n+      mangled++;\n+      string_append (decl, \"ireal\");\n+      return mangled;\n+    case 'q':\n+      mangled++;\n+      string_append (decl, \"cfloat\");\n+      return mangled;\n+    case 'r':\n+      mangled++;\n+      string_append (decl, \"cdouble\");\n+      return mangled;\n+    case 'c':\n+      mangled++;\n+      string_append (decl, \"creal\");\n+      return mangled;\n+\n+    /* Other types */\n+    case 'b':\n+      mangled++;\n+      string_append (decl, \"bool\");\n+      return mangled;\n+    case 'a':\n+      mangled++;\n+      string_append (decl, \"char\");\n+      return mangled;\n+    case 'u':\n+      mangled++;\n+      string_append (decl, \"wchar\");\n+      return mangled;\n+    case 'w':\n+      mangled++;\n+      string_append (decl, \"dchar\");\n+      return mangled;\n+\n+    default: /* unhandled */\n+      return NULL;\n+    }\n+}\n+\n+/* Extract the identifier from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_identifier (string *decl, const char *mangled)\n+{\n+  if (mangled == NULL || *mangled == '\\0')\n+    return mangled;\n+\n+  if (ISDIGIT (*mangled))\n+    {\n+      char *endptr;\n+      long i = strtol (mangled, &endptr, 10);\n+\n+      if (endptr == NULL || i <= 0 || strlen (endptr) < (size_t) i)\n+\treturn NULL;\n+\n+      mangled = endptr;\n+\n+      /* May be a template instance.  */\n+      if (i >= 5 && strncmp (mangled, \"__T\", 3) == 0)\n+\t{\n+\t  /* Template symbol.  */\n+\t  if (ISDIGIT (mangled[3]) && mangled[3] != '0')\n+\t    return dlang_parse_template (decl, mangled, i);\n+\n+\t  return NULL;\n+\t}\n+\n+      if (strncmp (mangled, \"__ctor\", i) == 0)\n+\t{\n+\t  /* Constructor symbol for a class/struct.  */\n+\t  string_append (decl, \"this\");\n+\t  mangled += i;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__dtor\", i) == 0)\n+\t{\n+\t  /* Destructor symbol for a class/struct.  */\n+\t  string_append (decl, \"~this\");\n+\t  mangled += i;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__postblit\", i) == 0)\n+\t{\n+\t  /* Postblit symbol for a struct.  */\n+\t  string_append (decl, \"this(this)\");\n+\t  mangled += i;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__initZ\", i+1) == 0)\n+\t{\n+\t  /* The static initialiser for a given symbol.  */\n+\t  string_append (decl, \"init$\");\n+\t  mangled += i + 1;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__ClassZ\", i+1) == 0)\n+\t{\n+\t  /* The classinfo symbol for a given class.  */\n+\t  string_prepend (decl, \"ClassInfo for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += i + 1;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__vtblZ\", i+1) == 0)\n+\t{\n+\t  /* The vtable symbol for a given class.  */\n+\t  string_prepend (decl, \"vtable for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += i + 1;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__InterfaceZ\", i+1) == 0)\n+\t{\n+\t  /* The interface symbol for a given class.  */\n+\t  string_prepend (decl, \"Interface for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += i + 1;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__ModuleInfoZ\", i+1) == 0)\n+\t{\n+\t  /* The ModuleInfo symbol for a given module.  */\n+\t  string_prepend (decl, \"ModuleInfo for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += i + 1;\n+\t  return mangled;\n+\t}\n+\n+      string_appendn (decl, mangled, i);\n+      mangled += i;\n+    }\n+  else\n+    return NULL;\n+\n+  return mangled;\n+}\n+\n+/* Extract the integer value from MANGLED and append it to DECL,\n+   where TYPE is the type it should be represented as.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_integer (string *decl, const char *mangled, char type)\n+{\n+  if (type == 'a' || type == 'u' || type == 'w')\n+    {\n+      /* Parse character value.  */\n+      char value[10];\n+      int pos = 10;\n+      int width = 0;\n+      char *endptr;\n+      long val = strtol (mangled, &endptr, 10);\n+\n+      if (endptr == NULL || val < 0)\n+\treturn NULL;\n+\n+      string_append (decl, \"'\");\n+\n+      if (type == 'a' && val >= 0x20 && val < 0x7F)\n+\t{\n+\t  /* Represent as a character literal.  */\n+\t  char c = (char) val;\n+\t  string_appendn (decl, &c, 1);\n+\t}\n+      else\n+\t{\n+\t  /* Represent as a hexadecimal value.  */\n+\t  switch (type)\n+\t    {\n+\t    case 'a': /* char */\n+\t      string_append (decl, \"\\\\x\");\n+\t      width = 2;\n+\t      break;\n+\t    case 'u': /* wchar */\n+\t      string_append (decl, \"\\\\u\");\n+\t      width = 4;\n+\t      break;\n+\t    case 'w': /* dchar */\n+\t      string_append (decl, \"\\\\U\");\n+\t      width = 8;\n+\t      break;\n+\t    }\n+\n+\t  while (val > 0)\n+\t    {\n+\t      int digit = val % 16;\n+\n+\t      if (digit < 10)\n+\t\tvalue[--pos] = (char)(digit + '0');\n+\t      else\n+\t\tvalue[--pos] = (char)((digit - 10) + 'a');\n+\n+\t      val /= 16;\n+\t      width--;\n+\t    }\n+\n+\t  for (; width > 0; width--)\n+\t    value[--pos] = '0';\n+\n+\t  string_appendn (decl, &(value[pos]), 10 - pos);\n+\t}\n+      string_append (decl, \"'\");\n+      mangled = endptr;\n+    }\n+  else if (type == 'b')\n+    {\n+      /* Parse boolean value.  */\n+      char *endptr;\n+      long val = strtol (mangled, &endptr, 10);\n+\n+      if (endptr == NULL || val < 0)\n+\treturn NULL;\n+\n+      string_append (decl, val ? \"true\" : \"false\");\n+      mangled = endptr;\n+    }\n+  else\n+    {\n+      /* Parse integer value.  */\n+      const char *numptr = mangled;\n+      size_t num = 0;\n+\n+      while (ISDIGIT (*mangled))\n+\t{\n+\t  num++;\n+\t  mangled++;\n+\t}\n+      string_appendn (decl, numptr, num);\n+\n+      /* Append suffix.  */\n+      switch (type)\n+\t{\n+\tcase 'h': /* ubyte */\n+\tcase 't': /* ushort */\n+\tcase 'k': /* uint */\n+\t  string_append (decl, \"u\");\n+\t  break;\n+\tcase 'l': /* long */\n+\t  string_append (decl, \"L\");\n+\t  break;\n+\tcase 'm': /* ulong */\n+\t  string_append (decl, \"uL\");\n+\t  break;\n+\t}\n+    }\n+\n+  return mangled;\n+}\n+\n+/* Extract the floating-point value from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_real (string *decl, const char *mangled)\n+{\n+  char buffer[64];\n+  int len = 0;\n+  long double value;\n+  char *endptr;\n+\n+  /* Handle NAN and +-INF.  */\n+  if (strncmp (mangled, \"NAN\", 3) == 0)\n+    {\n+      string_append (decl, \"NaN\");\n+      mangled += 3;\n+      return mangled;\n+    }\n+  else if (strncmp (mangled, \"INF\", 3) == 0)\n+    {\n+      string_append (decl, \"Inf\");\n+      mangled += 3;\n+      return mangled;\n+    }\n+  else if (strncmp (mangled, \"NINF\", 4) == 0)\n+    {\n+      string_append (decl, \"-Inf\");\n+      mangled += 4;\n+      return mangled;\n+    }\n+\n+  /* Hexadecimal prefix and leading bit.  */\n+  if (*mangled == 'N')\n+    {\n+      buffer[len++] = '-';\n+      mangled++;\n+    }\n+\n+  if (!ISXDIGIT (*mangled))\n+    return NULL;\n+\n+  buffer[len++] = '0';\n+  buffer[len++] = 'x';\n+  buffer[len++] = *mangled;\n+  buffer[len++] = '.';\n+  mangled++;\n+\n+  /* Significand.  */\n+  while (ISXDIGIT (*mangled))\n+    {\n+      buffer[len++] = *mangled;\n+      mangled++;\n+    }\n+\n+  /* Exponent.  */\n+  if (*mangled != 'P')\n+    return NULL;\n+\n+  buffer[len++] = 'p';\n+  mangled++;\n+\n+  if (*mangled == 'N')\n+    {\n+      buffer[len++] = '-';\n+      mangled++;\n+    }\n+\n+  while (ISDIGIT (*mangled))\n+    {\n+      buffer[len++] = *mangled;\n+      mangled++;\n+    }\n+\n+  /* Convert buffer from hexadecimal to floating-point.  */\n+  buffer[len] = '\\0';\n+  value = strtold (buffer, &endptr);\n+\n+  if (endptr == NULL || endptr != (buffer + len))\n+    return NULL;\n+\n+  len = snprintf (buffer, sizeof(buffer), \"%#Lg\", value);\n+  string_appendn (decl, buffer, len);\n+  return mangled;\n+}\n+\n+/* Convert VAL from an ascii hexdigit to value.  */\n+static char\n+ascii2hex (char val)\n+{\n+  if (val >= 'a' && val <= 'f')\n+    return (val - 'a' + 10);\n+\n+  if (val >= 'A' && val <= 'F')\n+    return (val - 'A' + 10);\n+\n+  if (val >= '0' && val <= '9')\n+    return (val - '0');\n+\n+  return 0;\n+}\n+\n+/* Extract the string value from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_string (string *decl, const char *mangled)\n+{\n+  char type = *mangled;\n+  char *endptr;\n+  long len;\n+\n+  mangled++;\n+  len = strtol (mangled, &endptr, 10);\n+\n+  if (endptr == NULL || len < 0)\n+    return NULL;\n+\n+  mangled = endptr;\n+  if (*mangled != '_')\n+    return NULL;\n+\n+  mangled++;\n+  string_append (decl, \"\\\"\");\n+  while (len--)\n+    {\n+      if (ISXDIGIT (mangled[0]) && ISXDIGIT (mangled[1]))\n+\t{\n+\t  char a = ascii2hex (mangled[0]);\n+\t  char b = ascii2hex (mangled[1]);\n+\t  char val = (a << 4) | b;\n+\t  string_appendn (decl, &val, 1);\n+\t}\n+      else\n+\treturn NULL;\n+\n+      mangled += 2;\n+    }\n+  string_append (decl, \"\\\"\");\n+\n+  if (type != 'a')\n+    string_appendn (decl, &type, 1);\n+\n+  return mangled;\n+}\n+\n+/* Extract the static array value from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_arrayliteral (string *decl, const char *mangled)\n+{\n+  char *endptr;\n+  long elements = strtol (mangled, &endptr, 10);\n+\n+  if (endptr == NULL || elements < 0)\n+    return NULL;\n+\n+  mangled = endptr;\n+  string_append (decl, \"[\");\n+  while (elements--)\n+    {\n+      mangled = dlang_value (decl, mangled, NULL, '\\0');\n+      if (elements != 0)\n+\tstring_append (decl, \", \");\n+    }\n+\n+  string_append (decl, \"]\");\n+  return mangled;\n+}\n+\n+/* Extract the associative array value from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_assocarray (string *decl, const char *mangled)\n+{\n+  char *endptr;\n+  long elements = strtol (mangled, &endptr, 10);\n+\n+  if (endptr == NULL || elements < 0)\n+    return NULL;\n+\n+  mangled = endptr;\n+  string_append (decl, \"[\");\n+  while (elements--)\n+    {\n+      mangled = dlang_value (decl, mangled, NULL, '\\0');\n+      string_append (decl, \":\");\n+      mangled = dlang_value (decl, mangled, NULL, '\\0');\n+\n+      if (elements != 0)\n+\tstring_append (decl, \", \");\n+    }\n+\n+  string_append (decl, \"]\");\n+  return mangled;\n+}\n+\n+/* Extract the struct literal value for NAME from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_structlit (string *decl, const char *mangled, const char *name)\n+{\n+  char *endptr;\n+  long args = strtol (mangled, &endptr, 10);\n+\n+  if (endptr == NULL || args < 0)\n+    return NULL;\n+\n+  mangled = endptr;\n+  if (name != NULL)\n+    string_append (decl, name);\n+\n+  string_append (decl, \"(\");\n+  while (args--)\n+    {\n+      mangled = dlang_value (decl, mangled, NULL, '\\0');\n+      if (args != 0)\n+\tstring_append (decl, \", \");\n+    }\n+\n+  string_append (decl, \")\");\n+  return mangled;\n+}\n+\n+/* Extract the value from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_value (string *decl, const char *mangled, const char *name, char type)\n+{\n+  if (mangled == NULL || *mangled == '\\0')\n+    return mangled;\n+\n+  switch (*mangled)\n+    {\n+      /* Null value.  */\n+    case 'n':\n+      mangled++;\n+      string_append (decl, \"null\");\n+      break;\n+\n+      /* Integral values.  */\n+    case 'N':\n+      mangled++;\n+      string_append (decl, \"-\");\n+      mangled = dlang_parse_integer (decl, mangled, type);\n+      break;\n+\n+    case 'i':\n+      mangled++;\n+      if (*mangled < '0' || *mangled > '9')\n+\treturn NULL;\n+      /* Fall through */\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+      mangled = dlang_parse_integer (decl, mangled, type);\n+      break;\n+\n+      /* Real value.  */\n+    case 'e':\n+      mangled++;\n+      mangled = dlang_parse_real (decl, mangled);\n+      break;\n+\n+      /* Complex value.  */\n+    case 'c':\n+      mangled++;\n+      mangled = dlang_parse_real (decl, mangled);\n+      string_append (decl, \"+\");\n+      if (mangled == NULL || *mangled != 'c')\n+\treturn NULL;\n+      mangled++;\n+      mangled = dlang_parse_real (decl, mangled);\n+      string_append (decl, \"i\");\n+      break;\n+\n+      /* String values.  */\n+    case 'a': /* UTF8 */\n+    case 'w': /* UTF16 */\n+    case 'd': /* UTF32 */\n+      mangled = dlang_parse_string (decl, mangled);\n+      break;\n+\n+      /* Array values.  */\n+    case 'A':\n+      mangled++;\n+      if (type == 'H')\n+\tmangled = dlang_parse_assocarray (decl, mangled);\n+      else\n+\tmangled = dlang_parse_arrayliteral (decl, mangled);\n+      break;\n+\n+      /* Struct values.  */\n+    case 'S':\n+      mangled++;\n+      mangled = dlang_parse_structlit (decl, mangled, name);\n+      break;\n+\n+    default:\n+      return NULL;\n+    }\n+\n+  return mangled;\n+}\n+\n+static int\n+dlang_call_convention_p (const char *mangled)\n+{\n+  size_t i;\n+\n+  switch (*mangled)\n+    {\n+    case 'F': case 'U': case 'V':\n+    case 'W': case 'R':\n+      return 1;\n+\n+    case 'M': /* Prefix for functions needing 'this' */\n+      i = 1;\n+      if (mangled[i] == 'x')\n+\ti++;\n+\n+      switch (mangled[i])\n+\t{\n+\tcase 'F': case 'U': case 'V':\n+\tcase 'W': case 'R':\n+\t  return 1;\n+\t}\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Extract and demangle the symbol in MANGLED and append it to DECL.\n+   Returns the remaining signature on success or NULL on failure.  */\n+static const char *\n+dlang_parse_symbol (string *decl, const char *mangled)\n+{\n+  size_t n = 0;\n+  do\n+    {\n+      if (n++)\n+\tstring_append (decl, \".\");\n+\n+      mangled = dlang_identifier (decl, mangled);\n+\n+      if (mangled && dlang_call_convention_p (mangled))\n+\t{\n+\t  int saved;\n+\n+\t  /* Skip over 'this' parameter.  */\n+\t  if (*mangled == 'M')\n+\t    mangled += (mangled[1] == 'x') ? 2 : 1;\n+\n+\t  /* Skip over calling convention and attributes in qualified name.  */\n+\t  saved = string_length (decl);\n+\t  mangled = dlang_call_convention (decl, mangled);\n+\t  mangled = dlang_attributes (decl, mangled);\n+\t  string_setlength (decl, saved);\n+\n+\t  string_append (decl, \"(\");\n+\t  mangled = dlang_function_args (decl, mangled);\n+\t  string_append (decl, \")\");\n+\n+\t  /* Demangle the function return type as a kind of sanity test.  */\n+\t  if (mangled && !ISDIGIT (*mangled))\n+\t    {\n+\t      saved = string_length (decl);\n+\t      mangled = dlang_type (decl, mangled);\n+\t      string_setlength (decl, saved);\n+\t    }\n+\t}\n+    }\n+  while (mangled && ISDIGIT (*mangled));\n+\n+  return mangled;\n+}\n+\n+/* Demangle the tuple from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_parse_tuple (string *decl, const char *mangled)\n+{\n+  char *endptr;\n+  long elements = strtol (mangled, &endptr, 10);\n+\n+  if (endptr == NULL || elements < 0)\n+    return NULL;\n+\n+  mangled = endptr;\n+  string_append (decl, \"Tuple!(\");\n+\n+  while (elements--)\n+    {\n+      mangled = dlang_type (decl, mangled);\n+      if (elements != 0)\n+\tstring_append (decl, \", \");\n+    }\n+\n+  string_append (decl, \")\");\n+  return mangled;\n+}\n+\n+/* Demangle the argument list from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_template_args (string *decl, const char *mangled)\n+{\n+  size_t n = 0;\n+\n+  while (mangled && *mangled != '\\0')\n+    {\n+      switch (*mangled)\n+\t{\n+\tcase 'Z': /* End of parameter list.  */\n+\t  mangled++;\n+\t  return mangled;\n+\t}\n+\n+      if (n++)\n+\tstring_append (decl, \", \");\n+\n+      switch (*mangled)\n+\t{\n+\tcase 'S': /* Symbol parameter.  */\n+\t  mangled++;\n+\t  mangled = dlang_parse_symbol (decl, mangled);\n+\t  break;\n+\tcase 'T': /* Type parameter.  */\n+\t  mangled++;\n+\t  mangled = dlang_type (decl, mangled);\n+\t  break;\n+\tcase 'V': /* Value parameter.  */\n+\t{\n+\t  string name;\n+\t  char type;\n+\n+\t  /* Peek at the type.  */\n+\t  mangled++;\n+\t  type = *mangled;\n+\n+\t  /* In the few instances where the type is actually desired in\n+\t     the output, it should precede the value from dlang_value.  */\n+\t  string_init (&name);\n+\t  mangled = dlang_type (&name, mangled);\n+\t  string_need (&name, 1);\n+\t  *(name.p) = '\\0';\n+\n+\t  mangled = dlang_value (decl, mangled, name.b, type);\n+\t  string_delete (&name);\n+\t  break;\n+\t}\n+\n+\tdefault:\n+\t  return NULL;\n+\t}\n+    }\n+\n+  return mangled;\n+}\n+\n+/* Extract and demangle the template symbol in MANGLED, expected to\n+   be made up of LEN characters, and append it to DECL.\n+   Returns the remaining signature on success or NULL on failure.  */\n+static const char *\n+dlang_parse_template (string *decl, const char *mangled, long len)\n+{\n+  const char *start = mangled;\n+\n+  /* Template instance names have the types and values of its parameters\n+     encoded into it.\n+\n+\tTemplateInstanceName:\n+\t    Number __T LName TemplateArgs Z\n+\t\t   ^\n+     The start pointer should be at the above location, and LEN should be\n+     the value of the decoded number.\n+   */\n+  if (strncmp (mangled, \"__T\", 3) != 0)\n+    return NULL;\n+\n+  mangled += 3;\n+\n+  /* Template identifier.  */\n+  mangled = dlang_identifier (decl, mangled);\n+\n+  /* Template arguments.  */\n+  string_append (decl, \"!(\");\n+  mangled = dlang_template_args (decl, mangled);\n+  string_append (decl, \")\");\n+\n+  /* Check for template name length mismatch.  */\n+  if (mangled && (mangled - start) != len)\n+    return NULL;\n+\n+  return mangled;\n+}\n+\n+/* Extract and demangle the symbol in MANGLED.  Returns the demangled\n+   signature on success or NULL on failure.  */\n+\n+char *\n+dlang_demangle (const char *mangled, int option ATTRIBUTE_UNUSED)\n+{\n+  string decl;\n+  char *demangled = NULL;\n+\n+  if (mangled == NULL || *mangled == '\\0')\n+    return NULL;\n+\n+  if (strncmp (mangled, \"_D\", 2) != 0)\n+    return NULL;\n+\n+  string_init (&decl);\n+\n+  if (strcmp (mangled, \"_Dmain\") == 0)\n+    {\n+      string_append (&decl, \"D main\");\n+    }\n+  else\n+    {\n+      mangled += 2;\n+\n+      if (dlang_parse_symbol (&decl, mangled) == NULL)\n+\tstring_delete (&decl);\n+    }\n+\n+  if (string_length (&decl) > 0)\n+    {\n+      string_need (&decl, 1);\n+      *(decl.p) = '\\0';\n+      demangled = decl.b;\n+    }\n+\n+  return demangled;\n+}\n+"}, {"sha": "bb2db67fb662edb3534dd90148b242607ee5736d", "filename": "libiberty/testsuite/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2FMakefile.in?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -45,12 +45,15 @@ all:\n # CHECK is set to \"really_check\" or the empty string by configure.\n check: @CHECK@\n \n-really-check: check-cplus-dem check-pexecute check-expandargv\n+really-check: check-cplus-dem check-d-demangle check-pexecute check-expandargv\n \n # Run some tests of the demangler.\n check-cplus-dem: test-demangle $(srcdir)/demangle-expected\n \t./test-demangle < $(srcdir)/demangle-expected\n \n+check-d-demangle: test-demangle $(srcdir)/d-demangle-expected\n+\t./test-demangle < $(srcdir)/d-demangle-expected\n+\n # Check the pexecute code.\n check-pexecute: test-pexecute\n \t./test-pexecute"}, {"sha": "2aeacb8389fdfebe6365d69cc89edf53eeb4621c", "filename": "libiberty/testsuite/d-demangle-expected", "status": "added", "additions": 936, "deletions": 0, "changes": 936, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Ftestsuite%2Fd-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04/libiberty%2Ftestsuite%2Fd-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fd-demangle-expected?ref=43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "patch": "@@ -0,0 +1,936 @@\n+# This file holds test cases for the D demangler.\n+# Each test case looks like this:\n+#  options\n+#  input to be demangled\n+#  expected output\n+#\n+# See demangle-expected for documentation of supported options.\n+#\n+# A line starting with `#' is ignored.\n+# However, blank lines in this file are NOT ignored.\n+#\n+############\n+#\n+# Coverage Tests\n+#\n+--format=dlang\n+_Dmain\n+D main\n+#\n+--format=dlang\n+_D8demangle4testPFLAiYi\n+demangle.test\n+#\n+--format=dlang\n+_D8demangle4testFaZv\n+demangle.test(char)\n+#\n+--format=dlang\n+_D8demangle4testFbZv\n+demangle.test(bool)\n+#\n+--format=dlang\n+_D8demangle4testFcZv\n+demangle.test(creal)\n+#\n+--format=dlang\n+_D8demangle4testFdZv\n+demangle.test(double)\n+#\n+--format=dlang\n+_D8demangle4testFeZv\n+demangle.test(real)\n+#\n+--format=dlang\n+_D8demangle4testFfZv\n+demangle.test(float)\n+#\n+--format=dlang\n+_D8demangle4testFgZv\n+demangle.test(byte)\n+#\n+--format=dlang\n+_D8demangle4testFhZv\n+demangle.test(ubyte)\n+#\n+--format=dlang\n+_D8demangle4testFiZv\n+demangle.test(int)\n+#\n+--format=dlang\n+_D8demangle4testFjZv\n+demangle.test(ireal)\n+#\n+--format=dlang\n+_D8demangle4testFkZv\n+demangle.test(uint)\n+#\n+--format=dlang\n+_D8demangle4testFlZv\n+demangle.test(long)\n+#\n+--format=dlang\n+_D8demangle4testFmZv\n+demangle.test(ulong)\n+#\n+--format=dlang\n+_D8demangle4testFnZv\n+demangle.test(none)\n+#\n+--format=dlang\n+_D8demangle4testFoZv\n+demangle.test(ifloat)\n+#\n+--format=dlang\n+_D8demangle4testFpZv\n+demangle.test(idouble)\n+#\n+--format=dlang\n+_D8demangle4testFqZv\n+demangle.test(cfloat)\n+#\n+--format=dlang\n+_D8demangle4testFrZv\n+demangle.test(cdouble)\n+#\n+--format=dlang\n+_D8demangle4testFsZv\n+demangle.test(short)\n+#\n+--format=dlang\n+_D8demangle4testFtZv\n+demangle.test(ushort)\n+#\n+--format=dlang\n+_D8demangle4testFuZv\n+demangle.test(wchar)\n+#\n+--format=dlang\n+_D8demangle4testFvZv\n+demangle.test(void)\n+#\n+--format=dlang\n+_D8demangle4testFwZv\n+demangle.test(dchar)\n+#\n+--format=dlang\n+_D8demangle4testFOaZv\n+demangle.test(shared(char))\n+#\n+--format=dlang\n+_D8demangle4testFxaZv\n+demangle.test(const(char))\n+#\n+--format=dlang\n+_D8demangle4testFyaZv\n+demangle.test(immutable(char))\n+#\n+--format=dlang\n+_D8demangle4testFNgaZv\n+demangle.test(inout(char))\n+#\n+--format=dlang\n+_D8demangle4testFOxaZv\n+demangle.test(shared(const(char)))\n+#\n+--format=dlang\n+_D8demangle4testFONgaZv\n+demangle.test(shared(inout(char)))\n+#\n+--format=dlang\n+_D8demangle4testFAaZv\n+demangle.test(char[])\n+#\n+--format=dlang\n+_D8demangle4testFAAaZv\n+demangle.test(char[][])\n+#\n+--format=dlang\n+_D8demangle4testFAAAaZv\n+demangle.test(char[][][])\n+#\n+--format=dlang\n+_D8demangle4testFG42aZv\n+demangle.test(char[42])\n+#\n+--format=dlang\n+_D8demangle4testFG42G42aZv\n+demangle.test(char[42][42])\n+#\n+--format=dlang\n+_D8demangle4testFG42G42G42aZv\n+demangle.test(char[42][42][42])\n+#\n+--format=dlang\n+_D8demangle4testFG1234567890aZv\n+demangle.test(char[1234567890])\n+#\n+--format=dlang\n+_D8demangle4testFHaaZv\n+demangle.test(char[char])\n+#\n+--format=dlang\n+_D8demangle4testFHHaaaZv\n+demangle.test(char[char[char]])\n+#\n+--format=dlang\n+_D8demangle4testFPaZv\n+demangle.test(char*)\n+#\n+--format=dlang\n+_D8demangle4testFPPaZv\n+demangle.test(char**)\n+#\n+--format=dlang\n+_D8demangle4testFPPPaZv\n+demangle.test(char***)\n+#\n+--format=dlang\n+_D8demangle4testFNhG8gZv\n+demangle.test(__vector(byte[8]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG16gZv\n+demangle.test(__vector(byte[16]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG32gZv\n+demangle.test(__vector(byte[32]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG4sZv\n+demangle.test(__vector(short[4]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG8sZv\n+demangle.test(__vector(short[8]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG16sZv\n+demangle.test(__vector(short[16]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG2iZv\n+demangle.test(__vector(int[2]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG4iZv\n+demangle.test(__vector(int[4]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG8iZv\n+demangle.test(__vector(int[8]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG1lZv\n+demangle.test(__vector(long[1]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG2lZv\n+demangle.test(__vector(long[2]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG4lZv\n+demangle.test(__vector(long[4]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG2fZv\n+demangle.test(__vector(float[2]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG4fZv\n+demangle.test(__vector(float[4]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG8fZv\n+demangle.test(__vector(float[8]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG1dZv\n+demangle.test(__vector(double[1]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG2dZv\n+demangle.test(__vector(double[2]))\n+#\n+--format=dlang\n+_D8demangle4testFNhG4dZv\n+demangle.test(__vector(double[4]))\n+#\n+--format=dlang\n+_D8demangle4testFI5identZv\n+demangle.test(ident)\n+#\n+--format=dlang\n+_D8demangle4testFI5ident4testZv\n+demangle.test(ident.test)\n+#\n+--format=dlang\n+_D8demangle4testFC5classZv\n+demangle.test(class)\n+#\n+--format=dlang\n+_D8demangle4testFC5class4testZv\n+demangle.test(class.test)\n+#\n+--format=dlang\n+_D8demangle4testFS6structZv\n+demangle.test(struct)\n+#\n+--format=dlang\n+_D8demangle4testFS6struct4testZv\n+demangle.test(struct.test)\n+#\n+--format=dlang\n+_D8demangle4testFE4enumZv\n+demangle.test(enum)\n+#\n+--format=dlang\n+_D8demangle4testFE4enum4testZv\n+demangle.test(enum.test)\n+#\n+--format=dlang\n+_D8demangle4testFT7typedefZv\n+demangle.test(typedef)\n+#\n+--format=dlang\n+_D8demangle4testFT7typedef4testZv\n+demangle.test(typedef.test)\n+#\n+--format=dlang\n+_D8demangle4testFJaZv\n+demangle.test(out char)\n+#\n+--format=dlang\n+_D8demangle4testFKaZv\n+demangle.test(ref char)\n+#\n+--format=dlang\n+_D8demangle4testFLaZv\n+demangle.test(lazy char)\n+#\n+--format=dlang\n+_D8demangle4testFMaZv\n+demangle.test(scope char)\n+#\n+--format=dlang\n+_D8demangle4testFaXv\n+demangle.test(char...)\n+#\n+--format=dlang\n+_D8demangle4testFaYv\n+demangle.test(char, ...)\n+#\n+--format=dlang\n+_D8demangle4testFaaYv\n+demangle.test(char, char, ...)\n+#\n+--format=dlang\n+_D8demangle4testFaaZv\n+demangle.test(char, char)\n+#\n+--format=dlang\n+_D8demangle4testFB0Zv\n+demangle.test(Tuple!())\n+#\n+--format=dlang\n+_D8demangle4testFB1aZv\n+demangle.test(Tuple!(char))\n+#\n+--format=dlang\n+_D8demangle4testFB2aaZv\n+demangle.test(Tuple!(char, char))\n+#\n+--format=dlang\n+_D8demangle4testFB3aaaZv\n+demangle.test(Tuple!(char, char, char))\n+#\n+--format=dlang\n+_D8demangle4testFB2OaaZv\n+demangle.test(Tuple!(shared(char), char))\n+#\n+--format=dlang\n+_D8demangle4testFB3aDFZaaZv\n+demangle.test(Tuple!(char, char() delegate, char))\n+#\n+--format=dlang\n+_D8demangle4testFDFZaZv\n+demangle.test(char() delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDUZaZv\n+demangle.test(extern(C) char() delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDWZaZv\n+demangle.test(extern(Windows) char() delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDVZaZv\n+demangle.test(extern(Pascal) char() delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDRZaZv\n+demangle.test(extern(C++) char() delegate)\n+#\n+--format=dlang\n+_D8demangle4testFFZaZv\n+demangle.test(char() function)\n+#\n+--format=dlang\n+_D8demangle4testFUZaZv\n+demangle.test(extern(C) char() function)\n+#\n+--format=dlang\n+_D8demangle4testFWZaZv\n+demangle.test(extern(Windows) char() function)\n+#\n+--format=dlang\n+_D8demangle4testFVZaZv\n+demangle.test(extern(Pascal) char() function)\n+#\n+--format=dlang\n+_D8demangle4testFRZaZv\n+demangle.test(extern(C++) char() function)\n+#\n+--format=dlang\n+_D8demangle4testFDFNaZaZv\n+demangle.test(char() pure delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNbZaZv\n+demangle.test(char() nothrow delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNcZaZv\n+demangle.test(char() ref delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNdZaZv\n+demangle.test(char() @property delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNeZaZv\n+demangle.test(char() @trusted delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNfZaZv\n+demangle.test(char() @safe delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNiZaZv\n+demangle.test(char() @nogc delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNaNbZaZv\n+demangle.test(char() pure nothrow delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNbNaZaZv\n+demangle.test(char() nothrow pure delegate)\n+#\n+--format=dlang\n+_D8demangle4testFDFNdNfNaZaZv\n+demangle.test(char() @property @safe pure delegate)\n+#\n+--format=dlang\n+_D8demangle4testFFNaZaZv\n+demangle.test(char() pure function)\n+#\n+--format=dlang\n+_D8demangle4testFFNbZaZv\n+demangle.test(char() nothrow function)\n+#\n+--format=dlang\n+_D8demangle4testFFNcZaZv\n+demangle.test(char() ref function)\n+#\n+--format=dlang\n+_D8demangle4testFFNdZaZv\n+demangle.test(char() @property function)\n+#\n+--format=dlang\n+_D8demangle4testFFNeZaZv\n+demangle.test(char() @trusted function)\n+#\n+--format=dlang\n+_D8demangle4testFFNfZaZv\n+demangle.test(char() @safe function)\n+#\n+--format=dlang\n+_D8demangle4testFFNiZaZv\n+demangle.test(char() @nogc function)\n+#\n+--format=dlang\n+_D8demangle4testFFNaNbZaZv\n+demangle.test(char() pure nothrow function)\n+#\n+--format=dlang\n+_D8demangle4testFFNbNaZaZv\n+demangle.test(char() nothrow pure function)\n+#\n+--format=dlang\n+_D8demangle4testFFNdNfNaZaZv\n+demangle.test(char() @property @safe pure function)\n+#\n+--format=dlang\n+_D8demangle4test6__initZ\n+demangle.test.init$\n+#\n+--format=dlang\n+_D8demangle4test6__vtblZ\n+vtable for demangle.test\n+#\n+--format=dlang\n+_D8demangle4test7__ClassZ\n+ClassInfo for demangle.test\n+#\n+--format=dlang\n+_D8demangle4test11__InterfaceZ\n+Interface for demangle.test\n+#\n+--format=dlang\n+_D8demangle4test12__ModuleInfoZ\n+ModuleInfo for demangle.test\n+#\n+--format=dlang\n+_D8demangle4test6__ctorMFZv\n+demangle.test.this()\n+#\n+--format=dlang\n+_D8demangle4test6__dtorMFZv\n+demangle.test.~this()\n+#\n+--format=dlang\n+_D8demangle4test6__postblitMFZv\n+demangle.test.this(this)\n+#\n+--format=dlang\n+_D8demangle4testFHAbaZv\n+demangle.test(char[bool[]])\n+#\n+--format=dlang\n+_D8demangle4testFHG42caZv\n+demangle.test(char[creal[42]])\n+#\n+--format=dlang\n+_D8demangle4testFAiXv\n+demangle.test(int[]...)\n+#\n+--format=dlang\n+_D8demangle4testFLAiXv\n+demangle.test(lazy int[]...)\n+#\n+--format=dlang\n+_D8demangle4testFAiYv\n+demangle.test(int[], ...)\n+#\n+--format=dlang\n+_D8demangle4testFLAiYv\n+demangle.test(lazy int[], ...)\n+#\n+--format=dlang\n+_D8demangle4testFLilZv\n+demangle.test(lazy int, long)\n+#\n+--format=dlang\n+_D8demangle4testFLliZv\n+demangle.test(lazy long, int)\n+#\n+--format=dlang\n+_D8demangle4testFLC6ObjectLDFLiZiZi\n+demangle.test(lazy Object, lazy int(lazy int) delegate)\n+#\n+--format=dlang\n+_D8demangle9__T4testZv\n+demangle.test!()\n+#\n+--format=dlang\n+_D8demangle11__T4testTaZv\n+demangle.test!(char)\n+#\n+--format=dlang\n+_D8demangle13__T4testTaTaZv\n+demangle.test!(char, char)\n+#\n+--format=dlang\n+_D8demangle15__T4testTaTaTaZv\n+demangle.test!(char, char, char)\n+#\n+--format=dlang\n+_D8demangle16__T4testTaTOiTaZv\n+demangle.test!(char, shared(int), char)\n+#\n+--format=dlang\n+_D8demangle17__T4testS6symbolZv\n+demangle.test!(symbol)\n+#\n+--format=dlang\n+_D8demangle21__T4testS6symbol3fooZv\n+demangle.test!(symbol.foo)\n+#\n+--format=dlang\n+_D8demangle25__T4testS6symbol3foo3barZv\n+demangle.test!(symbol.foo.bar)\n+#\n+--format=dlang\n+_D8demangle19__T4testTaS6symbolZv\n+demangle.test!(char, symbol)\n+#\n+--format=dlang\n+_D8demangle19__T4testS6symbolTaZv\n+demangle.test!(symbol, char)\n+#\n+--format=dlang\n+_D8demangle13__T4testVPinZv\n+demangle.test!(null)\n+#\n+--format=dlang\n+_D8demangle14__T4testVg123Zv\n+demangle.test!(123)\n+#\n+--format=dlang\n+_D8demangle14__T4testVi123Zv\n+demangle.test!(123)\n+#\n+--format=dlang\n+_D8demangle14__T4testVs123Zv\n+demangle.test!(123)\n+#\n+--format=dlang\n+_D8demangle14__T4testVh123Zv\n+demangle.test!(123u)\n+#\n+--format=dlang\n+_D8demangle14__T4testVk123Zv\n+demangle.test!(123u)\n+#\n+--format=dlang\n+_D8demangle14__T4testVt123Zv\n+demangle.test!(123u)\n+#\n+--format=dlang\n+_D8demangle14__T4testVl123Zv\n+demangle.test!(123L)\n+#\n+--format=dlang\n+_D8demangle14__T4testVm123Zv\n+demangle.test!(123uL)\n+#\n+--format=dlang\n+_D8demangle15__T4testViN123Zv\n+demangle.test!(-123)\n+#\n+--format=dlang\n+_D8demangle15__T4testVkN123Zv\n+demangle.test!(-123u)\n+#\n+--format=dlang\n+_D8demangle15__T4testVlN123Zv\n+demangle.test!(-123L)\n+#\n+--format=dlang\n+_D8demangle15__T4testVmN123Zv\n+demangle.test!(-123uL)\n+#\n+--format=dlang\n+_D8demangle12__T4testVb1Zv\n+demangle.test!(true)\n+#\n+--format=dlang\n+_D8demangle12__T4testVb0Zv\n+demangle.test!(false)\n+#\n+--format=dlang\n+_D8demangle13__T4testVa10Zv\n+demangle.test!('\\x0a')\n+#\n+--format=dlang\n+_D8demangle13__T4testVa32Zv\n+demangle.test!(' ')\n+#\n+--format=dlang\n+_D8demangle13__T4testVa65Zv\n+demangle.test!('A')\n+#\n+--format=dlang\n+_D8demangle14__T4testVa126Zv\n+demangle.test!('~')\n+#\n+--format=dlang\n+_D8demangle15__T4testVu1000Zv\n+demangle.test!('\\u03e8')\n+#\n+--format=dlang\n+_D8demangle17__T4testVw100000Zv\n+demangle.test!('\\U000186a0')\n+#\n+--format=dlang\n+_D8demangle17__T4testVde0A8P6Zv\n+demangle.test!(42.0000)\n+#\n+--format=dlang\n+_D8demangle16__T4testVdeA8P2Zv\n+demangle.test!(42.0000)\n+#\n+--format=dlang\n+_D8demangle18__T4testVdeN0A8P6Zv\n+demangle.test!(-42.0000)\n+#\n+--format=dlang\n+_D8demangle31__T4testVde0F6E978D4FDF3B646P7Zv\n+demangle.test!(123.456)\n+#\n+--format=dlang\n+_D8demangle15__T4testVdeNANZv\n+demangle.test!(NaN)\n+#\n+--format=dlang\n+_D8demangle15__T4testVdeINFZv\n+demangle.test!(Inf)\n+#\n+--format=dlang\n+_D8demangle16__T4testVdeNINFZv\n+demangle.test!(-Inf)\n+#\n+--format=dlang\n+_D8demangle23__T4testVfe0FFFFFFP128Zv\n+demangle.test!(3.40282e+38)\n+#\n+--format=dlang\n+_D8demangle32__T4testVde0FFFFFFFFFFFFF8P1024Zv\n+demangle.test!(1.79769e+308)\n+#\n+--format=dlang\n+_D8demangle19__T4testVfe08PN125Zv\n+demangle.test!(1.17549e-38)\n+#\n+--format=dlang\n+_D8demangle20__T4testVde08PN1021Zv\n+demangle.test!(2.22507e-308)\n+#\n+--format=dlang\n+_D8demangle51__T4testVrc0C4CCCCCCCCCCCCCDP4c0B666666666666666P6Zv\n+demangle.test!(12.3000+45.6000i)\n+#\n+--format=dlang\n+_D8demangle52__T4testVrcN0C4CCCCCCCCCCCCCDP4c0B666666666666666P6Zv\n+demangle.test!(-12.3000+45.6000i)\n+#\n+--format=dlang\n+_D8demangle22__T4testVG3ua3_616263Zv\n+demangle.test!(\"abc\")\n+#\n+--format=dlang\n+_D8demangle22__T4testVG3ud3_616263Zv\n+demangle.test!(\"abc\"d)\n+#\n+--format=dlang\n+_D8demangle22__T4testVG3uw3_616263Zv\n+demangle.test!(\"abc\"w)\n+#\n+--format=dlang\n+_D8demangle22__T4testVAiA4i1i2i3i4Zv\n+demangle.test!([1, 2, 3, 4])\n+#\n+--format=dlang\n+_D8demangle25__T4testVAdA2e08P1eN08P1Zv\n+demangle.test!([1.00000, -1.00000])\n+#\n+--format=dlang\n+_D8demangle23__T4testVHiiA2i1i2i3i4Zv\n+demangle.test!([1:2, 3:4])\n+#\n+--format=dlang\n+_D8demangle39__T4testVHAxaiA2a3_616263i1a3_646566i2Zv\n+demangle.test!([\"abc\":1, \"def\":2])\n+#\n+--format=dlang\n+_D8demangle28__T4testVS8demangle1SS2i1i2Zv\n+demangle.test!(demangle.S(1, 2))\n+#\n+--format=dlang\n+_D8demangle35__T4testVS8demangle1SS2i1a3_616263Zv\n+demangle.test!(demangle.S(1, \"abc\"))\n+#\n+# Unittests\n+#\n+--format=dlang\n+printf\n+printf\n+#\n+--format=dlang\n+_foo\n+_foo\n+#\n+--format=dlang\n+_D88\n+_D88\n+#\n+--format=dlang\n+_D5__T1aZv\n+_D5__T1aZv\n+#\n+--format=dlang\n+_D4test3fooAa\n+test.foo\n+#\n+--format=dlang\n+_D8demangle8demangleFAaZAa\n+demangle.demangle(char[])\n+#\n+--format=dlang\n+_D6object6Object8opEqualsFC6ObjectZi\n+object.Object.opEquals(Object)\n+#\n+--format=dlang\n+_D6object6Object8opAssignFC6ObjectZi\n+object.Object.opAssign(Object)\n+#\n+--format=dlang\n+_D4test2dgDFiYd\n+test.dg\n+#\n+--format=dlang\n+_D1a1bi\n+a.b\n+#\n+--format=dlang\n+_D1a1bPFiZi\n+a.b\n+#\n+--format=dlang\n+_D4test34__T3barVG3uw3_616263VG3wd3_646566Z1xi\n+test.bar!(\"abc\"w, \"def\"d).x\n+#\n+--format=dlang\n+_D6plugin8generateFiiZAya\n+plugin.generate(int, int)\n+#\n+--format=dlang\n+_D6plugin8generateFiiZAxa\n+plugin.generate(int, int)\n+#\n+--format=dlang\n+_D6plugin8generateFiiZAOa\n+plugin.generate(int, int)\n+#\n+--format=dlang\n+_D8demangle3fnAFZv3fnBMFZv\n+demangle.fnA().fnB()\n+#\n+--format=dlang\n+_D8demangle4mainFZv1S3fnCFZv\n+demangle.main().S.fnC()\n+#\n+--format=dlang\n+_D8demangle4mainFZv1S3fnDMFZv\n+demangle.main().S.fnD()\n+#\n+--format=dlang\n+_D8demangle4mainFZv5localMFZi\n+demangle.main().local()\n+#\n+--format=dlang\n+_D3std5ascii9uppercaseyAa\n+std.ascii.uppercase\n+#\n+--format=dlang\n+_D3std6stream9BOMEndianyG5E3std6system6Endian\n+std.stream.BOMEndian\n+#\n+--format=dlang\n+_D3std8internal7uni_tab10unicodeNkoyS3std8internal3uni12CodepointSet\n+std.internal.uni_tab.unicodeNko\n+#\n+--format=dlang\n+_D2gc2gc2GC6addrOfMFPvZPv\n+gc.gc.GC.addrOf(void*)\n+#\n+--format=dlang\n+_D3std7process10setCLOEXECFibZv\n+std.process.setCLOEXEC(int, bool)\n+#\n+--format=dlang\n+_D3std6digest2md3MD53putMFNaNbNeMAxhXv\n+std.digest.md.MD5.put(scope const(ubyte)[]...)\n+#\n+--format=dlang\n+_D3std6mmfile6MmFile13opIndexAssignMFhmZh\n+std.mmfile.MmFile.opIndexAssign(ubyte, ulong)\n+#\n+--format=dlang\n+_D3std7process18escapeShellCommandFxAAaXAya\n+std.process.escapeShellCommand(const(char[][])...)\n+#\n+--format=dlang\n+_D4core4sync5mutex5Mutex6__ctorMFC6ObjectZC4core4sync5mutex5Mutex\n+core.sync.mutex.Mutex.this(Object)\n+#\n+--format=dlang\n+_D6object14TypeInfo_Array8argTypesMFNbNfJC8TypeInfoJC8TypeInfoZi\n+object.TypeInfo_Array.argTypes(out TypeInfo, out TypeInfo)\n+#\n+--format=dlang\n+_D2rt6dmain211_d_run_mainUiPPaPUAAaZiZi7tryExecMFMDFZvZv\n+rt.dmain2._d_run_main(int, char**, extern(C) int(char[][]) function*).tryExec(scope void() delegate)\n+#\n+--format=dlang\n+_D6object9Exception6__ctorMFNaNbNfAyaAyamC6object9ThrowableZC9Exception\n+object.Exception.this(immutable(char)[], immutable(char)[], ulong, object.Throwable)\n+#\n+--format=dlang\n+_D3gcc3deh17parse_lsda_headerFPS3gcc6unwind7generic15_Unwind_ContextPhPS3gcc3deh16lsda_header_infoZPh\n+gcc.deh.parse_lsda_header(gcc.unwind.generic._Unwind_Context*, ubyte*, gcc.deh.lsda_header_info*)\n+#\n+--format=dlang\n+_D3std6socket23UnknownAddressReference6__ctorMFPS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference\n+std.socket.UnknownAddressReference.this(core.sys.posix.sys.socket.sockaddr*, uint)\n+#\n+--format=dlang\n+_D8demangle20__T2fnVAiA4i1i2i3i4Z2fnFZv\n+demangle.fn!([1, 2, 3, 4]).fn()\n+#\n+--format=dlang\n+_D8demangle10__T2fnVi1Z2fnFZv\n+demangle.fn!(1).fn()\n+#\n+--format=dlang\n+_D8demangle26__T2fnVS8demangle1SS2i1i2Z2fnFZv\n+demangle.fn!(demangle.S(1, 2)).fn()\n+#\n+--format=dlang\n+_D8demangle13__T2fnVeeNANZ2fnFZv\n+demangle.fn!(NaN).fn()\n+#\n+--format=dlang\n+_D8demangle14__T2fnVeeNINFZ2fnFZv\n+demangle.fn!(-Inf).fn()\n+#\n+--format=dlang\n+_D8demangle13__T2fnVeeINFZ2fnFZv\n+demangle.fn!(Inf).fn()\n+#\n+--format=dlang\n+_D8demangle21__T2fnVHiiA2i1i2i3i4Z2fnFZv\n+demangle.fn!([1:2, 3:4]).fn()\n+#\n+--format=dlang\n+_D8demangle2fnFNgiZNgi\n+demangle.fn(inout(int))\n+#\n+--format=dlang\n+_D8demangle29__T2fnVa97Va9Va0Vu257Vw65537Z2fnFZv\n+demangle.fn!('a', '\\x09', '\\x00', '\\u0101', '\\U00010001').fn()\n+#\n+--format=dlang\n+_D2gc11gctemplates56__T8mkBitmapTS3std5range13__T4iotaTiTiZ4iotaFiiZ6ResultZ8mkBitmapFNbNiNfPmmZv\n+gc.gctemplates.mkBitmap!(std.range.iota!(int, int).iota(int, int).Result).mkBitmap(ulong*, ulong)\n+#\n+--format=dlang\n+_D8serenity9persister6Sqlite70__T15SqlitePersisterTS8serenity9persister6Sqlite11__unittest6FZv4TestZ15SqlitePersister12__T7opIndexZ7opIndexMFmZS8serenity9persister6Sqlite11__unittest6FZv4Test\n+serenity.persister.Sqlite.SqlitePersister!(serenity.persister.Sqlite.__unittest6().Test).SqlitePersister.opIndex!().opIndex(ulong)\n+#\n+--format=dlang\n+_D4test4mainFZv5localMFZi\n+test.main().local()"}]}