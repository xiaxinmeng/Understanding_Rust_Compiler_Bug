{"sha": "ff7793bea465019683b3a07d7ffceb6eae22def5", "node_id": "C_kwDOANBUbNoAKGZmNzc5M2JlYTQ2NTAxOTY4M2IzYTA3ZDdmZmNlYjZlYWUyMmRlZjU", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-05-25T13:33:15Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-01T19:36:56Z"}, "message": "libstdc++: Allow stateful allocators in std::list::sort [PR 66742]\n\nThe temporary lists used by std::list::sort are default constructed,\nwhich means they use default constructed allocators. The sort operation\nis defined in terms of merge and splice operations, which have undefined\nbehaviour (and abort) if the allocators do not compare equal. This means\nit is not possible to sort a list that uses an allocator that compares\nunequal to an default constructed allocator.\n\nThe solution is to avoid using temporary std::list objects at all. We do\nnot need to be able to allocate memory because no nodes are allocated,\nonly spliced from one list to another. That means the temporary lists\ndon't need an allocator at all, so whether it would compare equal\ndoesn't matter.\n\nInstead of temporary std::list objects, we can just use a collection of\n_List_node_base objects that nodes can be spliced onto as needed. Those\nobjects are wrapped in a _Scratch_list type that implements the splicing\nand merging operations used by list::sort.\n\nWe also don't need to update the list size during the sort, because\nsorting doesn't alter the number of nodes. Although we move nodes in and\nout of the scratch lists, at the end of the function all nodes are back\nin the original std::list and the scratch lists are empty.  So for the\ncxx11 ABI we can avoid the _M_size modifications usually done when\nsplicing nodes.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/66742\n\t* include/bits/list.tcc (list::sort()): Use _Scratch_list\n\tobjects for splicing and merging.\n\t(list::sort(StrictWeakOrdering)): Likewise.\n\t* include/bits/stl_list.h (__detail::_Scratch_list): New type.\n\t* src/c++98/list.cc (_List_node_base::_M_transfer): Add\n\tassertion for --enable-libstdcxx-debug library.\n\t* testsuite/23_containers/list/operations/66742.cc: New test.", "tree": {"sha": "fefd2aee90bc3c6b1feee3fc1571ed23a2d6d956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fefd2aee90bc3c6b1feee3fc1571ed23a2d6d956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff7793bea465019683b3a07d7ffceb6eae22def5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7793bea465019683b3a07d7ffceb6eae22def5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7793bea465019683b3a07d7ffceb6eae22def5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7793bea465019683b3a07d7ffceb6eae22def5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e9407b3b4298bd587e0df2e0047679019b66cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e9407b3b4298bd587e0df2e0047679019b66cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34e9407b3b4298bd587e0df2e0047679019b66cf"}], "stats": {"total": 235, "additions": 190, "deletions": 45}, "files": [{"sha": "7f4e1569ab1a96e3e19ba07ad315ea891f04ae1d", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=ff7793bea465019683b3a07d7ffceb6eae22def5", "patch": "@@ -485,21 +485,34 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node\n \t  && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)\n       {\n-        list __carry;\n-        list __tmp[64];\n-        list * __fill = __tmp;\n-        list * __counter;\n+\tusing __detail::_Scratch_list;\n+\t// The algorithm used here is largely unchanged from the SGI STL\n+\t// and is described in The C++ Standard Template Library by Plauger,\n+\t// Stepanov, Lee, Musser.\n+\t// Each element of *this is spliced out and merged into one of the\n+\t// sorted lists in __tmp, then all the lists in __tmp are merged\n+\t// together and then swapped back into *this.\n+\t// Because all nodes end up back in *this we do not need to update\n+\t// this->size() while nodes are temporarily moved out.\n+\t_Scratch_list __carry;\n+\t_Scratch_list __tmp[64];\n+\t_Scratch_list* __fill = __tmp;\n+\t_Scratch_list* __counter;\n+\n+\t_Scratch_list::_Ptr_cmp<const_iterator, void> __ptr_comp;\n+\n \t__try\n \t  {\n \t    do\n \t      {\n-\t\t__carry.splice(__carry.begin(), *this, begin());\n+\t\t__carry._M_take_one(begin()._M_node);\n \n \t\tfor(__counter = __tmp;\n \t\t    __counter != __fill && !__counter->empty();\n \t\t    ++__counter)\n \t\t  {\n-\t\t    __counter->merge(__carry);\n+\n+\t\t    __counter->merge(__carry, __ptr_comp);\n \t\t    __carry.swap(*__counter);\n \t\t  }\n \t\t__carry.swap(*__counter);\n@@ -509,14 +522,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    while ( !empty() );\n \n \t    for (__counter = __tmp + 1; __counter != __fill; ++__counter)\n-\t      __counter->merge(*(__counter - 1));\n-\t    swap( *(__fill - 1) );\n+\t      __counter->merge(__counter[-1], __ptr_comp);\n+\t    __fill[-1].swap(this->_M_impl._M_node);\n \t  }\n \t__catch(...)\n \t  {\n-\t    this->splice(this->end(), __carry);\n+\t    // Move all nodes back into *this.\n+\t    __carry._M_put_all(end()._M_node);\n \t    for (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)\n-\t      this->splice(this->end(), __tmp[__i]);\n+\t      __tmp[__i]._M_put_all(end()._M_node);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -602,42 +616,49 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t// Do nothing if the list has length 0 or 1.\n \tif (this->_M_impl._M_node._M_next != &this->_M_impl._M_node\n \t    && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)\n-\t  {\n-\t    list __carry;\n-\t    list __tmp[64];\n-\t    list * __fill = __tmp;\n-\t    list * __counter;\n-\t    __try\n-\t      {\n-\t\tdo\n-\t\t  {\n-\t\t    __carry.splice(__carry.begin(), *this, begin());\n-\n-\t\t    for(__counter = __tmp;\n-\t\t\t__counter != __fill && !__counter->empty();\n-\t\t\t++__counter)\n-\t\t      {\n-\t\t\t__counter->merge(__carry, __comp);\n-\t\t\t__carry.swap(*__counter);\n-\t\t      }\n-\t\t    __carry.swap(*__counter);\n-\t\t    if (__counter == __fill)\n-\t\t      ++__fill;\n-\t\t  }\n-\t\twhile ( !empty() );\n+\t{\n+\t  using __detail::_Scratch_list;\n+\t  _Scratch_list __carry;\n+\t  _Scratch_list __tmp[64];\n+\t  _Scratch_list* __fill = __tmp;\n+\t  _Scratch_list* __counter;\n \n-\t\tfor (__counter = __tmp + 1; __counter != __fill; ++__counter)\n-\t\t  __counter->merge(*(__counter - 1), __comp);\n-\t\tswap(*(__fill - 1));\n-\t      }\n-\t    __catch(...)\n-\t      {\n-\t\tthis->splice(this->end(), __carry);\n-\t\tfor (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)\n-\t\t  this->splice(this->end(), __tmp[__i]);\n-\t\t__throw_exception_again;\n-\t      }\n-\t  }\n+\t_Scratch_list::_Ptr_cmp<const_iterator, _StrictWeakOrdering> __ptr_comp\n+\t  = { __comp };\n+\n+\t  __try\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  __carry._M_take_one(begin()._M_node);\n+\n+\t\t  for(__counter = __tmp;\n+\t\t      __counter != __fill && !__counter->empty();\n+\t\t      ++__counter)\n+\t\t    {\n+\n+\t\t      __counter->merge(__carry, __ptr_comp);\n+\t\t      __carry.swap(*__counter);\n+\t\t    }\n+\t\t  __carry.swap(*__counter);\n+\t\t  if (__counter == __fill)\n+\t\t    ++__fill;\n+\t\t}\n+\t      while ( !empty() );\n+\n+\t      for (__counter = __tmp + 1; __counter != __fill; ++__counter)\n+\t\t__counter->merge(__counter[-1], __ptr_comp);\n+\t      __fill[-1].swap(this->_M_impl._M_node);\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      // Move all nodes back into *this.\n+\t      __carry._M_put_all(end()._M_node);\n+\t      for (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)\n+\t\t__tmp[__i]._M_put_all(end()._M_node);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n       }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER"}, {"sha": "81361dfa4d5b68977bd9c3940748a5fcff13dc23", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=ff7793bea465019683b3a07d7ffceb6eae22def5", "patch": "@@ -158,6 +158,73 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       _List_node_base* _M_base() { return this; }\n     };\n+\n+    // Used by list::sort to hold nodes being sorted.\n+    struct _Scratch_list : _List_node_base\n+    {\n+      _Scratch_list() { _M_next = _M_prev = this; }\n+\n+      bool empty() const { return _M_next == this; }\n+\n+      void swap(_List_node_base& __l) { _List_node_base::swap(*this, __l); }\n+\n+      template<typename _Iter, typename _Cmp>\n+\tstruct _Ptr_cmp\n+\t{\n+\t  _Cmp _M_cmp;\n+\n+\t  bool\n+\t  operator()(const __detail::_List_node_base* __lhs,\n+\t\t     const __detail::_List_node_base* __rhs) /* not const */\n+\t  { return _M_cmp(*_Iter(__lhs), *_Iter(__rhs)); }\n+\t};\n+\n+      template<typename _Iter>\n+\tstruct _Ptr_cmp<_Iter, void>\n+\t{\n+\t  bool\n+\t  operator()(const __detail::_List_node_base* __lhs,\n+\t\t     const __detail::_List_node_base* __rhs) const\n+\t  { return *_Iter(__lhs) < *_Iter(__rhs); }\n+\t};\n+\n+      // Merge nodes from __x into *this. Both lists must be sorted wrt _Cmp.\n+      template<typename _Cmp>\n+\tvoid\n+\tmerge(_List_node_base& __x, _Cmp __comp)\n+\t{\n+\t  _List_node_base* __first1 = _M_next;\n+\t  _List_node_base* const __last1 = this;\n+\t  _List_node_base* __first2 = __x._M_next;\n+\t  _List_node_base* const __last2 = std::__addressof(__x);\n+\n+\t  while (__first1 != __last1 && __first2 != __last2)\n+\t    {\n+\t      if (__comp(__first2, __first1))\n+\t\t{\n+\t\t  _List_node_base* __next = __first2->_M_next;\n+\t\t  __first1->_M_transfer(__first2, __next);\n+\t\t  __first2 = __next;\n+\t\t}\n+\t      else\n+\t\t__first1 = __first1->_M_next;\n+\t    }\n+\t  if (__first2 != __last2)\n+\t    this->_M_transfer(__first2, __last2);\n+\t}\n+\n+      // Splice the node at __i into *this.\n+      void _M_take_one(_List_node_base* __i)\n+      { this->_M_transfer(__i, __i->_M_next); }\n+\n+      // Splice all nodes from *this after __i.\n+      void _M_put_all(_List_node_base* __i)\n+      {\n+\tif (!empty())\n+\t  __i->_M_transfer(_M_next, this);\n+      }\n+    };\n+\n   } // namespace detail\n \n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER"}, {"sha": "c2f5c43622ea8a201b185574af5ffebb419ef5e1", "filename": "libstdc++-v3/src/c++98/list.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Flist.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Flist.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2Flist.cc?ref=ff7793bea465019683b3a07d7ffceb6eae22def5", "patch": "@@ -94,6 +94,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_transfer(_List_node_base * const __first,\n \t\t_List_node_base * const __last) _GLIBCXX_USE_NOEXCEPT\n     {\n+      __glibcxx_assert(__first != __last);\n+\n       if (this != __last)\n \t{\n \t  // Remove [first, last) from its old position."}, {"sha": "24bda3920d8961d6b6c1b3d3fa88b65654e6e326", "filename": "libstdc++-v3/testsuite/23_containers/list/operations/66742.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperations%2F66742.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7793bea465019683b3a07d7ffceb6eae22def5/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperations%2F66742.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperations%2F66742.cc?ref=ff7793bea465019683b3a07d7ffceb6eae22def5", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run { target c++11 } }\n+\n+#include <list>\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/66742\n+// abort on sorting list with custom allocator that is not stateless\n+\n+template<typename List, typename Cmp = std::less<typename List::value_type>>\n+bool is_sorted(const List& l, Cmp cmp = {})\n+{\n+  auto it = l.begin();\n+  auto next = it;\n+  const auto end = l.end();\n+  if (it == end)\n+    return true;\n+  while (++next != end)\n+    if (cmp(*next, *it))\n+      return false;\n+    else\n+      it = next;\n+  return true;\n+}\n+\n+void\n+test01()\n+{\n+  using Alloc = __gnu_test::uneq_allocator<int>;\n+  Alloc a1(1);\n+  std::list<int, Alloc> l(a1);\n+  for (int i = 0; i < 1000; ++i)\n+  {\n+    l.push_front(i);\n+    l.push_back(i + (i % 3));\n+  }\n+  const auto orig = l;\n+\n+  l.sort();\n+  VERIFY( is_sorted(l) );\n+  l.sort();\n+  VERIFY( is_sorted(l) );\n+\n+  l = orig;\n+  l.sort(std::less<int>());\n+  VERIFY( is_sorted(l) );\n+  l.sort(std::greater<int>());\n+  VERIFY( is_sorted(l, std::greater<int>()) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}