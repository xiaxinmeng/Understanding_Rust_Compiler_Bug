{"sha": "25da5dc7c6535e061ddfd5ee06b73d228e181c43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVkYTVkYzdjNjUzNWUwNjFkZGZkNWVlMDZiNzNkMjI4ZTE4MWM0Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-12T20:57:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-12T20:57:28Z"}, "message": "re PR target/18932 (ICE in copyprop_hardreg_forward_1, at regrename.c)\n\n        PR target/18932\n        * config/i386/i386.md (all splits and peepholes): Use flags_reg_operand\n        and compare_operator to propagate the input CC mode to the output.\n        * config/i386/predicates.md (compare_operator): New.\n\nFrom-SVN: r92058", "tree": {"sha": "9098e48d682044521f6fc2cc2fb5ad5ba34567c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9098e48d682044521f6fc2cc2fb5ad5ba34567c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25da5dc7c6535e061ddfd5ee06b73d228e181c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25da5dc7c6535e061ddfd5ee06b73d228e181c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25da5dc7c6535e061ddfd5ee06b73d228e181c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25da5dc7c6535e061ddfd5ee06b73d228e181c43/comments", "author": null, "committer": null, "parents": [{"sha": "8d5cfa2765f170e387cd221cae28f20a82a35d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d5cfa2765f170e387cd221cae28f20a82a35d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d5cfa2765f170e387cd221cae28f20a82a35d60"}], "stats": {"total": 467, "additions": 221, "deletions": 246}, "files": [{"sha": "f1b1c55c5fbcbe03b5315300cc0e715e0db41e35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25da5dc7c6535e061ddfd5ee06b73d228e181c43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25da5dc7c6535e061ddfd5ee06b73d228e181c43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25da5dc7c6535e061ddfd5ee06b73d228e181c43", "patch": "@@ -1,3 +1,10 @@\n+2004-12-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/18932\n+\t* config/i386/i386.md (all splits and peepholes): Use flags_reg_operand\n+\tand compare_operator to propagate the input CC mode to the output.\n+\t* config/i386/predicates.md (compare_operator): New.\n+\n 2004-12-12  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/18040"}, {"sha": "135017f643baeab2a201e902e84306803b761330", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 211, "deletions": 246, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25da5dc7c6535e061ddfd5ee06b73d228e181c43/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25da5dc7c6535e061ddfd5ee06b73d228e181c43/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=25da5dc7c6535e061ddfd5ee06b73d228e181c43", "patch": "@@ -7992,51 +7992,53 @@\n   \"#\")\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-        (compare (zero_extract\n-\t\t   (match_operand 0 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand 1 \"const_int_operand\" \"\")\n-\t\t   (match_operand 2 \"const_int_operand\" \"\"))\n-\t\t (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+        (match_operator 1 \"compare_operator\"\n+\t  [(zero_extract\n+\t     (match_operand 2 \"nonimmediate_operand\" \"\")\n+\t     (match_operand 3 \"const_int_operand\" \"\")\n+\t     (match_operand 4 \"const_int_operand\" \"\"))\n+\t   (const_int 0)]))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n-  [(set (reg:CCNO FLAGS_REG) (compare:CCNO (match_dup 3) (const_int 0)))]\n+  [(set (match_dup 0) (match_op_dup 1 [(match_dup 2) (const_int 0)]))]\n {\n-  HOST_WIDE_INT len = INTVAL (operands[1]);\n-  HOST_WIDE_INT pos = INTVAL (operands[2]);\n+  rtx val = operands[2];\n+  HOST_WIDE_INT len = INTVAL (operands[3]);\n+  HOST_WIDE_INT pos = INTVAL (operands[4]);\n   HOST_WIDE_INT mask;\n   enum machine_mode mode, submode;\n \n-  mode = GET_MODE (operands[0]);\n-  if (GET_CODE (operands[0]) == MEM)\n+  mode = GET_MODE (val);\n+  if (GET_CODE (val) == MEM)\n     {\n       /* ??? Combine likes to put non-volatile mem extractions in QImode\n \t no matter the size of the test.  So find a mode that works.  */\n-      if (! MEM_VOLATILE_P (operands[0]))\n+      if (! MEM_VOLATILE_P (val))\n \t{\n \t  mode = smallest_mode_for_size (pos + len, MODE_INT);\n-\t  operands[0] = adjust_address (operands[0], mode, 0);\n+\t  val = adjust_address (val, mode, 0);\n \t}\n     }\n-  else if (GET_CODE (operands[0]) == SUBREG\n-\t   && (submode = GET_MODE (SUBREG_REG (operands[0])),\n+  else if (GET_CODE (val) == SUBREG\n+\t   && (submode = GET_MODE (SUBREG_REG (val)),\n \t       GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (submode))\n \t   && pos + len <= GET_MODE_BITSIZE (submode))\n     {\n       /* Narrow a paradoxical subreg to prevent partial register stalls.  */\n       mode = submode;\n-      operands[0] = SUBREG_REG (operands[0]);\n+      val = SUBREG_REG (val);\n     }\n   else if (mode == HImode && pos + len <= 8)\n     {\n       /* Small HImode tests can be converted to QImode.  */\n       mode = QImode;\n-      operands[0] = gen_lowpart (QImode, operands[0]);\n+      val = gen_lowpart (QImode, val);\n     }\n \n   mask  = ((HOST_WIDE_INT)1 << (pos + len)) - 1;\n   mask &= ~(((HOST_WIDE_INT)1 << pos) - 1);\n \n-  operands[3] = gen_rtx_AND (mode, operands[0], gen_int_mode (mask, mode));\n+  operands[2] = gen_rtx_AND (mode, val, gen_int_mode (mask, mode));\n })\n \n ;; Convert HImode/SImode test instructions with immediate to QImode ones.\n@@ -8045,46 +8047,44 @@\n ;; Do the conversion only post-reload to avoid limiting of the register class\n ;; to QI regs.\n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and (match_operand 0 \"register_operand\" \"\")\n-\t       (match_operand 1 \"const_int_operand\" \"\"))\n-\t  (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(and (match_operand 2 \"register_operand\" \"\")\n+\t        (match_operand 3 \"const_int_operand\" \"\"))\n+\t   (const_int 0)]))]\n    \"reload_completed\n-    && QI_REG_P (operands[0])\n+    && QI_REG_P (operands[2])\n+    && GET_MODE (operands[2]) != QImode\n     && ((ix86_match_ccmode (insn, CCZmode)\n-    \t && !(INTVAL (operands[1]) & ~(255 << 8)))\n+    \t && !(INTVAL (operands[3]) & ~(255 << 8)))\n \t|| (ix86_match_ccmode (insn, CCNOmode)\n-\t    && !(INTVAL (operands[1]) & ~(127 << 8))))\n-    && GET_MODE (operands[0]) != QImode\"\n-  [(set (reg:CCNO FLAGS_REG)\n-\t(compare:CCNO\n-\t  (and:SI (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))\n-\t\t  (match_dup 1))\n-\t  (const_int 0)))]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_int_mode (INTVAL (operands[1]) >> 8, SImode);\")\n+\t    && !(INTVAL (operands[3]) & ~(127 << 8))))\"\n+  [(set (match_dup 0)\n+\t(match_op_dup 1\n+\t  [(and:SI (zero_extract:SI (match_dup 2) (const_int 8) (const_int 8))\n+\t\t   (match_dup 3))\n+\t   (const_int 0)]))]\n+  \"operands[2] = gen_lowpart (SImode, operands[2]);\n+   operands[3] = gen_int_mode (INTVAL (operands[3]) >> 8, SImode);\")\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and (match_operand 0 \"nonimmediate_operand\" \"\")\n-\t       (match_operand 1 \"const_int_operand\" \"\"))\n-\t  (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(and (match_operand 2 \"nonimmediate_operand\" \"\")\n+\t        (match_operand 3 \"const_int_operand\" \"\"))\n+\t   (const_int 0)]))]\n    \"reload_completed\n-    && (!REG_P (operands[0]) || ANY_QI_REG_P (operands[0]))\n+    && GET_MODE (operands[2]) != QImode\n+    && (!REG_P (operands[2]) || ANY_QI_REG_P (operands[2]))\n     && ((ix86_match_ccmode (insn, CCZmode)\n-\t && !(INTVAL (operands[1]) & ~255))\n+\t && !(INTVAL (operands[3]) & ~255))\n \t|| (ix86_match_ccmode (insn, CCNOmode)\n-\t    && !(INTVAL (operands[1]) & ~127)))\n-    && GET_MODE (operands[0]) != QImode\"\n-  [(set (reg:CCNO FLAGS_REG)\n-\t(compare:CCNO\n-\t  (and:QI (match_dup 0)\n-\t\t  (match_dup 1))\n-\t  (const_int 0)))]\n-  \"operands[0] = gen_lowpart (QImode, operands[0]);\n-   operands[1] = gen_lowpart (QImode, operands[1]);\")\n+\t    && !(INTVAL (operands[3]) & ~127)))\"\n+  [(set (match_dup 0)\n+\t(match_op_dup 1 [(and:QI (match_dup 2) (match_dup 3))\n+\t\t\t (const_int 0)]))]\n+  \"operands[2] = gen_lowpart (QImode, operands[2]);\n+   operands[3] = gen_lowpart (QImode, operands[3]);\")\n \n \n ;; %%% This used to optimize known byte-wide and operations to memory,\n@@ -10370,17 +10370,19 @@\n    (set_attr \"mode\" \"DI\")])\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (not:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(not:DI (match_dup 1)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 2 \"compare_operator\"\n+\t  [(not:DI (match_operand:DI 3 \"nonimmediate_operand\" \"\"))\n+\t   (const_int 0)]))\n+   (set (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t(not:DI (match_dup 3)))]\n   \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO (xor:DI (match_dup 1) (const_int -1))\n-\t\t\t\t (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (xor:DI (match_dup 1) (const_int -1)))])]\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 2\n+\t\t     [(xor:DI (match_dup 3) (const_int -1))\n+\t\t      (const_int 0)]))\n+\t      (set (match_dup 1)\n+\t\t   (xor:DI (match_dup 3) (const_int -1)))])]\n   \"\")\n \n (define_expand \"one_cmplsi2\"\n@@ -10419,17 +10421,18 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(not:SI (match_dup 1)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 2 \"compare_operator\"\n+\t  [(not:SI (match_operand:SI 3 \"nonimmediate_operand\" \"\"))\n+\t   (const_int 0)]))\n+   (set (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n+\t(not:SI (match_dup 3)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO (xor:SI (match_dup 1) (const_int -1))\n-\t\t\t\t (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (xor:SI (match_dup 1) (const_int -1)))])]\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 2 [(xor:SI (match_dup 3) (const_int -1))\n+\t\t\t\t    (const_int 0)]))\n+\t      (set (match_dup 1)\n+\t\t   (xor:SI (match_dup 3) (const_int -1)))])]\n   \"\")\n \n ;; ??? Currently never generated - xor is used instead.\n@@ -10446,17 +10449,18 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (not:SI (match_operand:SI 1 \"register_operand\" \"\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(zero_extend:DI (not:SI (match_dup 1))))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 2 \"compare_operator\"\n+\t  [(not:SI (match_operand:SI 3 \"register_operand\" \"\"))\n+\t   (const_int 0)]))\n+   (set (match_operand:DI 1 \"register_operand\" \"\")\n+\t(zero_extend:DI (not:SI (match_dup 3))))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO (xor:SI (match_dup 1) (const_int -1))\n-\t\t\t\t (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (zero_extend:DI (xor:SI (match_dup 1) (const_int -1))))])]\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 2 [(xor:SI (match_dup 3) (const_int -1))\n+\t\t\t\t    (const_int 0)]))\n+\t      (set (match_dup 1)\n+\t\t   (zero_extend:DI (xor:SI (match_dup 3) (const_int -1))))])]\n   \"\")\n \n (define_expand \"one_cmplhi2\"\n@@ -10486,17 +10490,18 @@\n    (set_attr \"mode\" \"HI\")])\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(not:HI (match_dup 1)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 2 \"compare_operator\"\n+\t  [(not:HI (match_operand:HI 3 \"nonimmediate_operand\" \"\"))\n+\t   (const_int 0)]))\n+   (set (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n+\t(not:HI (match_dup 3)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO (xor:HI (match_dup 1) (const_int -1))\n-\t\t      \t\t (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (xor:HI (match_dup 1) (const_int -1)))])]\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 2 [(xor:HI (match_dup 3) (const_int -1))\n+\t\t      \t\t    (const_int 0)]))\n+\t      (set (match_dup 1)\n+\t\t   (xor:HI (match_dup 3) (const_int -1)))])]\n   \"\")\n \n ;; %%% Potential partial reg stall on alternative 1.  What to do?\n@@ -10529,17 +10534,18 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(not:QI (match_dup 1)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 2 \"compare_operator\"\n+\t  [(not:QI (match_operand:QI 3 \"nonimmediate_operand\" \"\"))\n+\t   (const_int 0)]))\n+   (set (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n+\t(not:QI (match_dup 3)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO (xor:QI (match_dup 1) (const_int -1))\n-\t\t      \t\t (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (xor:QI (match_dup 1) (const_int -1)))])]\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 2 [(xor:QI (match_dup 3) (const_int -1))\n+\t\t      \t\t    (const_int 0)]))\n+\t      (set (match_dup 1)\n+\t\t   (xor:QI (match_dup 3) (const_int -1)))])]\n   \"\")\n \f\n ;; Arithmetic shift instructions\n@@ -18843,52 +18849,56 @@\n ; instruction size is unchanged, except in the %eax case for\n ; which it is increased by one byte, hence the ! optimize_size.\n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (and (match_operand 1 \"aligned_operand\" \"\")\n-\t\t      (match_operand 2 \"const_int_operand\" \"\"))\n-\t\t (const_int 0)))\n-   (set (match_operand 0 \"register_operand\" \"\")\n-\t(and (match_dup 1) (match_dup 2)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 2 \"compare_operator\"\n+\t  [(and (match_operand 3 \"aligned_operand\" \"\")\n+\t\t(match_operand 4 \"const_int_operand\" \"\"))\n+\t   (const_int 0)]))\n+   (set (match_operand 1 \"register_operand\" \"\")\n+\t(and (match_dup 3) (match_dup 4)))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n    /* Ensure that the operand will remain sign-extended immediate.  */\n-   && ix86_match_ccmode (insn, INTVAL (operands[2]) >= 0 ? CCNOmode : CCZmode)\n+   && ix86_match_ccmode (insn, INTVAL (operands[4]) >= 0 ? CCNOmode : CCZmode)\n    && ! optimize_size\n-   && ((GET_MODE (operands[0]) == HImode && ! TARGET_FAST_PREFIX)\n-       || (GET_MODE (operands[0]) == QImode && TARGET_PROMOTE_QImode))\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO (and:SI (match_dup 1) (match_dup 2))\n-\t\t\t         (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (and:SI (match_dup 1) (match_dup 2)))])]\n-  \"operands[2]\n-     = gen_int_mode (INTVAL (operands[2])\n-\t\t     & GET_MODE_MASK (GET_MODE (operands[0])),\n-\t\t     SImode);\n-   operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\")\n+   && ((GET_MODE (operands[1]) == HImode && ! TARGET_FAST_PREFIX)\n+       || (GET_MODE (operands[1]) == QImode && TARGET_PROMOTE_QImode))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 2 [(and:SI (match_dup 3) (match_dup 4))\n+\t\t\t            (const_int 0)]))\n+\t      (set (match_dup 1)\n+\t\t   (and:SI (match_dup 3) (match_dup 4)))])]\n+{\n+  operands[4]\n+    = gen_int_mode (INTVAL (operands[4])\n+\t\t    & GET_MODE_MASK (GET_MODE (operands[1])), SImode);\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[3] = gen_lowpart (SImode, operands[3]);\n+})\n \n ; Don't promote the QImode tests, as i386 doesn't have encoding of\n ; the TEST instruction with 32-bit sign-extended immediate and thus\n ; the instruction size would at least double, which is not what we\n ; want even with ! optimize_size.\n (define_split\n-  [(set (reg FLAGS_REG)\n-\t(compare (and (match_operand:HI 0 \"aligned_operand\" \"\")\n-\t\t      (match_operand:HI 1 \"const_int_operand\" \"\"))\n-\t\t (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(and (match_operand:HI 2 \"aligned_operand\" \"\")\n+\t\t(match_operand:HI 3 \"const_int_operand\" \"\"))\n+\t   (const_int 0)]))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n    /* Ensure that the operand will remain sign-extended immediate.  */\n-   && ix86_match_ccmode (insn, INTVAL (operands[1]) >= 0 ? CCNOmode : CCZmode)\n+   && ix86_match_ccmode (insn, INTVAL (operands[3]) >= 0 ? CCNOmode : CCZmode)\n    && ! TARGET_FAST_PREFIX\n    && ! optimize_size\"\n-  [(set (reg:CCNO FLAGS_REG)\n-\t(compare:CCNO (and:SI (match_dup 0) (match_dup 1))\n-\t\t      (const_int 0)))]\n-  \"operands[1]\n-     = gen_int_mode (INTVAL (operands[1])\n-\t\t     & GET_MODE_MASK (GET_MODE (operands[0])),\n-\t\t     SImode);\n-   operands[0] = gen_lowpart (SImode, operands[0]);\")\n+  [(set (match_dup 0)\n+\t(match_op_dup 1 [(and:SI (match_dup 2) (match_dup 3))\n+\t\t         (const_int 0)]))]\n+{\n+  operands[3]\n+    = gen_int_mode (INTVAL (operands[3])\n+\t\t    & GET_MODE_MASK (GET_MODE (operands[2])), SImode);\n+  operands[2] = gen_lowpart (SImode, operands[2]);\n+})\n \n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -19061,13 +19071,14 @@\n \n ;; Don't compare memory with zero, load and use a test instead.\n (define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (match_operand:SI 0 \"memory_operand\" \"\")\n-\t         (const_int 0)))\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+ \t(match_operator 1 \"compare_operator\"\n+\t  [(match_operand:SI 2 \"memory_operand\" \"\")\n+\t   (const_int 0)]))\n    (match_scratch:SI 3 \"r\")]\n   \"ix86_match_ccmode (insn, CCNOmode) && ! optimize_size\"\n-  [(set (match_dup 3) (match_dup 0))\n-   (set (reg:CCNO FLAGS_REG) (compare:CCNO (match_dup 3) (const_int 0)))]\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (match_op_dup 1 [(match_dup 3) (const_int 0)]))]\n   \"\")\n \n ;; NOT is not pairable on Pentium, while XOR is, but one byte longer. \n@@ -19131,77 +19142,77 @@\n ;; versions if we're concerned about partial register stalls.\n \n (define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (and:SI (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"\"))\n-\t\t (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(and:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t   (const_int 0)]))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && (true_regnum (operands[0]) != 0\n-       || (GET_CODE (operands[1]) == CONST_INT\n-\t   && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')))\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n+   && (true_regnum (operands[2]) != 0\n+       || (GET_CODE (operands[3]) == CONST_INT\n+\t   && CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'K')))\n+   && peep2_reg_dead_p (1, operands[2])\"\n   [(parallel\n-     [(set (reg:CCNO FLAGS_REG)\n-\t   (compare:CCNO (and:SI (match_dup 0)\n-\t\t\t         (match_dup 1))\n-\t\t         (const_int 0)))\n-      (set (match_dup 0)\n-\t   (and:SI (match_dup 0) (match_dup 1)))])]\n+     [(set (match_dup 0)\n+\t   (match_op_dup 1 [(and:SI (match_dup 2) (match_dup 3))\n+\t\t            (const_int 0)]))\n+      (set (match_dup 2)\n+\t   (and:SI (match_dup 2) (match_dup 3)))])]\n   \"\")\n \n ;; We don't need to handle HImode case, because it will be promoted to SImode\n ;; on ! TARGET_PARTIAL_REG_STALL\n \n (define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (and:QI (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t\t (match_operand:QI 1 \"immediate_operand\" \"\"))\n-\t\t (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(and:QI (match_operand:QI 2 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 3 \"immediate_operand\" \"\"))\n+\t   (const_int 0)]))]\n   \"! TARGET_PARTIAL_REG_STALL\n    && ix86_match_ccmode (insn, CCNOmode)\n-   && true_regnum (operands[0]) != 0\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n+   && true_regnum (operands[2]) != 0\n+   && peep2_reg_dead_p (1, operands[2])\"\n   [(parallel\n-     [(set (reg:CCNO FLAGS_REG)\n-\t   (compare:CCNO (and:QI (match_dup 0)\n- \t\t\t         (match_dup 1))\n-\t\t         (const_int 0)))\n-      (set (match_dup 0)\n-\t   (and:QI (match_dup 0) (match_dup 1)))])]\n+     [(set (match_dup 0)\n+\t   (match_op_dup 1 [(and:QI (match_dup 2) (match_dup 3))\n+\t\t            (const_int 0)]))\n+      (set (match_dup 2)\n+\t   (and:QI (match_dup 2) (match_dup 3)))])]\n   \"\")\n \n (define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and:SI\n-\t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"\")\n-\t      (const_int 8)\n-\t      (const_int 8))\n-\t    (match_operand 1 \"const_int_operand\" \"\"))\n-\t  (const_int 0)))]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(and:SI\n+\t     (zero_extract:SI\n+\t       (match_operand 2 \"ext_register_operand\" \"\")\n+\t       (const_int 8)\n+\t       (const_int 8))\n+\t     (match_operand 3 \"const_int_operand\" \"\"))\n+\t   (const_int 0)]))]\n   \"! TARGET_PARTIAL_REG_STALL\n    && ix86_match_ccmode (insn, CCNOmode)\n-   && true_regnum (operands[0]) != 0\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel [(set (reg:CCNO FLAGS_REG)\n-\t\t   (compare:CCNO\n-\t\t       (and:SI\n-\t\t\t (zero_extract:SI\n-\t\t\t (match_dup 0)\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t\t\t(match_dup 1))\n-\t\t   (const_int 0)))\n-\t      (set (zero_extract:SI (match_dup 0)\n+   && true_regnum (operands[2]) != 0\n+   && peep2_reg_dead_p (1, operands[2])\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 1\n+\t\t     [(and:SI\n+\t\t\t(zero_extract:SI\n+\t\t\t  (match_dup 2)\n+\t\t\t  (const_int 8)\n+\t\t\t  (const_int 8))\n+\t\t\t(match_dup 3))\n+\t\t      (const_int 0)]))\n+\t      (set (zero_extract:SI (match_dup 2)\n \t\t\t\t    (const_int 8)\n \t\t\t\t    (const_int 8))\n \t\t   (and:SI \n \t\t     (zero_extract:SI\n-\t\t       (match_dup 0)\n+\t\t       (match_dup 2)\n \t\t       (const_int 8)\n \t\t       (const_int 8))\n-\t\t     (match_dup 1)))])]\n+\t\t     (match_dup 3)))])]\n   \"\")\n \n ;; Don't do logical operations with memory inputs.\n@@ -19503,66 +19514,20 @@\n   \"\")\n \f\n ;; Convert compares with 1 to shorter inc/dec operations when CF is not\n-;; required and register dies.\n+;; required and register dies.  Similarly for 128 to plus -128.\n (define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel [(set (reg:CCGC FLAGS_REG)\n-\t\t   (compare:CCGC (match_dup 0)\n-\t\t\t\t (match_dup 1)))\n-\t      (clobber (match_dup 0))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"incdec_operand\" \"\")))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel [(set (reg:CCGC FLAGS_REG)\n-\t\t   (compare:CCGC (match_dup 0)\n-\t\t\t\t (match_dup 1)))\n-\t      (clobber (match_dup 0))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t (match_operand:QI 1 \"incdec_operand\" \"\")))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel [(set (reg:CCGC FLAGS_REG)\n-\t\t   (compare:CCGC (match_dup 0)\n-\t\t\t\t (match_dup 1)))\n-\t      (clobber (match_dup 0))])]\n-  \"\")\n-\n-;; Convert compares with 128 to shorter add -128\n-(define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (const_int 128)))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel [(set (reg:CCGC FLAGS_REG)\n-\t\t   (compare:CCGC (match_dup 0)\n-\t\t\t         (const_int 128)))\n-\t      (clobber (match_dup 0))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (reg FLAGS_REG)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (const_int 128)))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel [(set (reg:CCGC FLAGS_REG)\n-\t\t   (compare:CCGC (match_dup 0)\n-\t\t\t         (const_int 128)))\n-\t      (clobber (match_dup 0))])]\n+  [(set (match_operand 0 \"flags_reg_operand\" \"\")\n+\t(match_operator 1 \"compare_operator\"\n+\t  [(match_operand 2 \"register_operand\" \"\")\n+\t   (match_operand 3 \"const_int_operand\" \"\")]))]\n+  \"(INTVAL (operands[3]) == -1\n+    || INTVAL (operands[3]) == 1\n+    || INTVAL (operands[3]) == 128)\n+   && ix86_match_ccmode (insn, CCGCmode)\n+   && peep2_reg_dead_p (1, operands[2])\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 1 [(match_dup 2) (match_dup 3)]))\n+\t      (clobber (match_dup 2))])]\n   \"\")\n \f\n (define_peephole2"}, {"sha": "a3721a5abe704a95e2b1a89507b967ff313e5e00", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25da5dc7c6535e061ddfd5ee06b73d228e181c43/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25da5dc7c6535e061ddfd5ee06b73d228e181c43/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=25da5dc7c6535e061ddfd5ee06b73d228e181c43", "patch": "@@ -833,3 +833,6 @@\n (define_predicate \"cmpsi_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")\n        (match_operand 0 \"cmpsi_operand_1\")))\n+\n+(define_predicate \"compare_operator\"\n+  (match_code \"compare\"))"}]}