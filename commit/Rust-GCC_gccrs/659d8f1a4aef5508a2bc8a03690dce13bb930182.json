{"sha": "659d8f1a4aef5508a2bc8a03690dce13bb930182", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU5ZDhmMWE0YWVmNTUwOGEyYmM4YTAzNjkwZGNlMTNiYjkzMDE4Mg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-10-20T08:45:33Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-10-20T08:45:33Z"}, "message": "RMIC.java: Reformatted.\n\n2004-10-20  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/rmi/rmic/RMIC.java: Reformatted.\n\nFrom-SVN: r89327", "tree": {"sha": "dc333a430852d8414354f877072b60a623db1b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc333a430852d8414354f877072b60a623db1b37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/659d8f1a4aef5508a2bc8a03690dce13bb930182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/659d8f1a4aef5508a2bc8a03690dce13bb930182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/659d8f1a4aef5508a2bc8a03690dce13bb930182", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/659d8f1a4aef5508a2bc8a03690dce13bb930182/comments", "author": null, "committer": null, "parents": [{"sha": "f4a8f2791cdea5aa417884db3e7da0310babc848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a8f2791cdea5aa417884db3e7da0310babc848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a8f2791cdea5aa417884db3e7da0310babc848"}], "stats": {"total": 1913, "additions": 955, "deletions": 958}, "files": [{"sha": "fb5fe8b00f340bd30251d67fa22a7f8c859819fc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659d8f1a4aef5508a2bc8a03690dce13bb930182/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659d8f1a4aef5508a2bc8a03690dce13bb930182/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=659d8f1a4aef5508a2bc8a03690dce13bb930182", "patch": "@@ -1,3 +1,7 @@\n+2004-10-20  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/rmi/rmic/RMIC.java: Reformatted.\n+\n 2004-10-20  Michael Koch  <konqueror@gmx.de>\n \n \t* java/sql/Timestamp.java,"}, {"sha": "e81c0fb780b061e3e87b57cece86a306e3a006ad", "filename": "libjava/gnu/java/rmi/rmic/RMIC.java", "status": "modified", "additions": 951, "deletions": 958, "changes": 1909, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659d8f1a4aef5508a2bc8a03690dce13bb930182/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659d8f1a4aef5508a2bc8a03690dce13bb930182/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java?ref=659d8f1a4aef5508a2bc8a03690dce13bb930182", "patch": "@@ -52,1034 +52,1027 @@\n import java.util.Iterator;\n import java.util.Set;\n \n-public class RMIC {\n-\n-private String[] args;\n-private int next;\n-private Exception exception;\n-\n-private boolean keep = false;\n-private boolean need11Stubs = true;\n-private boolean need12Stubs = true;\n-private boolean compile = true;\n-private boolean verbose;\n-private String destination;\n-\n-private PrintWriter out;\n-private TabbedWriter ctrl;\n-\n-private Class clazz;\n-private String classname;\n-private String fullclassname;\n-private MethodRef[] remotemethods;\n-private String stubname;\n-private String skelname;\n-private int errorCount = 0;\n-\n-private Class mRemoteInterface;\n-public RMIC(String[] a) {\n-\targs = a;\n-}\n-\n-public static void main(String args[]) {\n-\tRMIC r = new RMIC(args);\n-\tif (r.run() == false) {\n-\t\tException exception = r.getException();\n-\t\tif (exception != null) {\n-\t\t\texception.printStackTrace();\n-\t\t}\n-\t\telse {\n-\t\t\tSystem.exit(1);\n-\t\t}\n-\t}\n-}\n \n-public boolean run() {\n-\tparseOptions();\n-\tif (next >= args.length) {\n-\t\terror(\"no class names found\");\n-\t}\n-\tfor (int i = next; i < args.length; i++) {\n-\t\ttry {\n-\t\t\tif (verbose) {\n-\t\t\t\tSystem.out.println(\"[Processing class \" + args[i] + \".class]\");\n-\t\t\t}\n-\t\t\tprocessClass(args[i].replace(File.separatorChar, '.'));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\texception = e;\n-\t\t\treturn (false);\n-\t\t}\n-\t}\n-\treturn (true);\n-}\n+public class RMIC\n+{\n+  private String[] args;\n+  private int next;\n+  private Exception exception;\n+  private boolean keep = false;\n+  private boolean need11Stubs = true;\n+  private boolean need12Stubs = true;\n+  private boolean compile = true;\n+  private boolean verbose;\n+  private String destination;\n+  private PrintWriter out;\n+  private TabbedWriter ctrl;\n+  private Class clazz;\n+  private String classname;\n+  private String fullclassname;\n+  private MethodRef[] remotemethods;\n+  private String stubname;\n+  private String skelname;\n+  private int errorCount = 0;\n+  private Class mRemoteInterface;\n+\n+  public RMIC(String[] a)\n+  {\n+    args = a;\n+  }\n+\n+  public static void main(String[] args)\n+  {\n+    RMIC r = new RMIC(args);\n+    if (r.run() == false)\n+      {\n+\tException e = r.getException();\n+\tif (e != null)\n+\t  e.printStackTrace();\n+\telse\n+\t  System.exit(1);\n+      }\n+  }\n+\n+  public boolean run()\n+  {\n+    parseOptions();\n+    if (next >= args.length)\n+      error(\"no class names found\");\n+    for (int i = next; i < args.length; i++)\n+      {\n+\ttry\n+\t  {\n+\t    if (verbose)\n+\t      System.out.println(\"[Processing class \" + args[i] + \".class]\");\n+\t    processClass(args[i].replace(File.separatorChar, '.'));\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    exception = e;\n+\t    return (false);\n+\t  }\n+      }\n+    return (true);\n+  }\n+\n+  private boolean processClass(String classname) throws Exception\n+  {\n+    errorCount = 0;\n+    analyzeClass(classname);\n+    if (errorCount > 0)\n+      System.exit(1);\n+    generateStub();\n+    if (need11Stubs)\n+      generateSkel();\n+    if (compile)\n+      {\n+\tcompile(stubname.replace('.', File.separatorChar) + \".java\");\n+\tif (need11Stubs)\n+\t  compile(skelname.replace('.', File.separatorChar) + \".java\");\n+      }\n+    if (! keep)\n+      {\n+\t(new File(stubname.replace('.', File.separatorChar) + \".java\")).delete();\n+\tif (need11Stubs)\n+\t  (new File(skelname.replace('.', File.separatorChar) + \".java\"))\n+\t  .delete();\n+      }\n+    return (true);\n+  }\n+\n+  private void analyzeClass(String cname) throws Exception\n+  {\n+    if (verbose)\n+      System.out.println(\"[analyze class \" + cname + \"]\");\n+    int p = cname.lastIndexOf('.');\n+    if (p != -1)\n+      classname = cname.substring(p + 1);\n+    else\n+      classname = cname;\n+    fullclassname = cname;\n+\n+    HashSet rmeths = new HashSet();\n+    findClass();\n+\n+    // get the remote interface\n+    mRemoteInterface = getRemoteInterface(clazz);\n+    if (mRemoteInterface == null)\n+      return;\n+    if (verbose)\n+      System.out.println(\"[implements \" + mRemoteInterface.getName() + \"]\");\n+\n+    // check if the methods of the remote interface declare RemoteExceptions\n+    Method[] meths = mRemoteInterface.getDeclaredMethods();\n+    for (int i = 0; i < meths.length; i++)\n+      {\n+\tClass[] exceptions = meths[i].getExceptionTypes();\n+\tint index = 0;\n+\tfor (; index < exceptions.length; index++)\n+\t  {\n+\t    if (exceptions[index].equals(RemoteException.class))\n+\t      break;\n+\t  }\n+\tif (index < exceptions.length)\n+\t  rmeths.add(meths[i]);\n+\telse\n+\t  logError(\"Method \" + meths[i]\n+\t           + \" does not throw a java.rmi.RemoteException\");\n+      }\n+\n+    // Convert into a MethodRef array and sort them\n+    remotemethods = new MethodRef[rmeths.size()];\n+    int c = 0;\n+    for (Iterator i = rmeths.iterator(); i.hasNext();)\n+      remotemethods[c++] = new MethodRef((Method) i.next());\n+    Arrays.sort(remotemethods);\n+  }\n+\n+  public Exception getException()\n+  {\n+    return (exception);\n+  }\n+\n+  private void findClass() throws ClassNotFoundException\n+  {\n+    clazz =\n+      Class.forName(fullclassname, true, ClassLoader.getSystemClassLoader());\n+  }\n+\n+  private void generateStub() throws IOException\n+  {\n+    stubname = fullclassname + \"_Stub\";\n+    String stubclassname = classname + \"_Stub\";\n+    ctrl =\n+      new TabbedWriter(new FileWriter((destination == null ? \"\"\n+                                                           : destination\n+                                                           + File.separator)\n+                                      + stubname.replace('.',\n+                                                         File.separatorChar)\n+                                      + \".java\"));\n+    out = new PrintWriter(ctrl);\n+\n+    if (verbose)\n+      System.out.println(\"[Generating class \" + stubname + \".java]\");\n+\n+    out.println(\"// Stub class generated by rmic - DO NOT EDIT!\");\n+    out.println();\n+    if (fullclassname != classname)\n+      {\n+\tString pname =\n+\t  fullclassname.substring(0, fullclassname.lastIndexOf('.'));\n+\tout.println(\"package \" + pname + \";\");\n+\tout.println();\n+      }\n+\n+    out.print(\"public final class \" + stubclassname);\n+    ctrl.indent();\n+    out.println(\"extends java.rmi.server.RemoteStub\");\n+\n+    // Output interfaces we implement\n+    out.print(\"implements \");\n+    /* Scan implemented interfaces, and only print remote interfaces. */\n+    Class[] ifaces = clazz.getInterfaces();\n+    Set remoteIfaces = new HashSet();\n+    for (int i = 0; i < ifaces.length; i++)\n+      {\n+\tClass iface = ifaces[i];\n+\tif (java.rmi.Remote.class.isAssignableFrom(iface))\n+\t  remoteIfaces.add(iface);\n+      }\n+    Iterator iter = remoteIfaces.iterator();\n+    while (iter.hasNext())\n+      {\n+\t/* Print remote interface. */\n+\tClass iface = (Class) iter.next();\n+\tout.print(iface.getName());\n+\n+\t/* Print \", \" if more remote interfaces follow. */\n+\tif (iter.hasNext())\n+\t  out.print(\", \");\n+      }\n+    ctrl.unindent();\n+    out.print(\"{\");\n+    ctrl.indent();\n+\n+    // UID\n+    if (need12Stubs)\n+      {\n+\tout.println(\"private static final long serialVersionUID = 2L;\");\n+\tout.println();\n+      }\n \n-private boolean processClass(String classname) throws Exception {\n-\terrorCount = 0;\n-\tanalyzeClass(classname);\n-\tif(errorCount > 0) {\n-\t\tSystem.exit(1);\n-\t}\n-\tgenerateStub();\n-\tif (need11Stubs) {\n-\t\tgenerateSkel();\n-\t}\n-\tif (compile) {\n-\t\tcompile(stubname.replace('.', File.separatorChar) + \".java\");\n-\t\tif (need11Stubs) {\n-\t\t\tcompile(skelname.replace('.', File.separatorChar) + \".java\");\n-\t\t}\n-\t}\n-\tif (!keep) {\n-\t\t(new File(stubname.replace('.', File.separatorChar) + \".java\")).delete();\n-\t\tif (need11Stubs) {\n-\t\t\t(new File(skelname.replace('.', File.separatorChar) + \".java\")).delete();\n-\t\t}\n-\t}\n-\treturn (true);\n-}\n+    // InterfaceHash - don't know how to calculate this - XXX\n+    if (need11Stubs)\n+      {\n+\tout.println(\"private static final long interfaceHash = \"\n+\t            + RMIHashes.getInterfaceHash(clazz) + \"L;\");\n+\tout.println();\n+\tif (need12Stubs)\n+\t  {\n+\t    out.println(\"private static boolean useNewInvoke;\");\n+\t    out.println();\n+\t  }\n \n-private void analyzeClass(String cname) throws Exception {\n-\tif(verbose){\n-\t\t\tSystem.out.println(\"[analyze class \"+cname+\"]\");\n-\t\t}\n-\tint p = cname.lastIndexOf('.');\n-\tif (p != -1) {\n-\t\tclassname = cname.substring(p+1);\n-\t}\n-\telse {\n-\t\tclassname = cname;\n-\t}\n-\tfullclassname = cname;\n-\n-\t\n-\tHashSet rmeths = new HashSet();\n-\tfindClass();\n-\t\n-\t// get the remote interface\n-\tmRemoteInterface = getRemoteInterface(clazz);\n-\tif(mRemoteInterface == null)\n-\t\treturn;\n-\tif(verbose){\n-\t\tSystem.out.println(\"[implements \"+mRemoteInterface.getName()+\"]\");\n-\t}\n-\n-\t// check if the methods of the remote interface declare RemoteExceptions\n-\tMethod[] meths = mRemoteInterface.getDeclaredMethods();\n-\tfor (int i = 0; i < meths.length; i++) {\n-\t\tClass[] exceptions = meths[i].getExceptionTypes();\n-\t\tint index = 0;\n-\t\tfor(;index < exceptions.length; index++){\n-\t\t\tif(exceptions[index].equals(RemoteException.class)){\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\tif (index < exceptions.length) {\n-\t\t\trmeths.add(meths[i]);\n-\t\t} else {\n-\t\t\tlogError(\"Method \"+meths[i]+\" does not throw a java.rmi.RemoteException\");\n-\t\t}\n-\t}\n-\n-\n-\t// Convert into a MethodRef array and sort them\n-\tremotemethods = new MethodRef[rmeths.size()];\n-\tint c = 0;\n-\tfor (Iterator i = rmeths.iterator(); i.hasNext(); ) {\n-\t\tremotemethods[c++] = new MethodRef((Method)i.next());\n-\t}\n-\tArrays.sort(remotemethods);\n-}\n+\t// Operation table\n+\tout.print(\"private static final java.rmi.server.Operation[] operations = {\");\n \n-public Exception getException() {\n-\treturn (exception);\n-}\n+\tctrl.indent();\n+\tfor (int i = 0; i < remotemethods.length; i++)\n+\t  {\n+\t    Method m = remotemethods[i].meth;\n+\t    out.print(\"new java.rmi.server.Operation(\\\"\");\n+\t    out.print(getPrettyName(m.getReturnType()) + \" \");\n+\t    out.print(m.getName() + \"(\");\n+\t    // Output signature\n+\t    Class[] sig = m.getParameterTypes();\n+\t    for (int j = 0; j < sig.length; j++)\n+\t      {\n+\t\tout.print(getPrettyName(sig[j]));\n+\t\tif (j + 1 < sig.length)\n+\t\t  out.print(\", \");\n+\t      }\n+\t    out.print(\")\\\")\");\n+\t    if (i + 1 < remotemethods.length)\n+\t      out.println(\",\");\n+\t  }\n+\tctrl.unindent();\n+\tout.println(\"};\");\n+\tout.println();\n+      }\n+\n+    // Set of method references.\n+    if (need12Stubs)\n+      {\n+\tfor (int i = 0; i < remotemethods.length; i++)\n+\t  {\n+\t    Method m = remotemethods[i].meth;\n+\t    out.println(\"private static java.lang.reflect.Method $method_\"\n+\t                + m.getName() + \"_\" + i + \";\");\n+\t  }\n+\n+\t// Initialize the methods references.\n+\tout.println();\n+\tout.print(\"static {\");\n+\tctrl.indent();\n \n-private void findClass() throws ClassNotFoundException {\n-\tclazz = Class.forName(fullclassname, true, ClassLoader.getSystemClassLoader());\n-}\n+\tout.print(\"try {\");\n+\tctrl.indent();\n \n-private void generateStub() throws IOException {\n-\tstubname = fullclassname + \"_Stub\";\n-\tString stubclassname = classname + \"_Stub\";\n-\tctrl = new TabbedWriter(new FileWriter((destination == null ? \"\" : destination + File.separator)\n-\t\t\t\t\t       + stubname.replace('.', File.separatorChar)\n-\t\t\t\t\t       + \".java\"));\n-\tout = new PrintWriter(ctrl);\n+\tif (need11Stubs)\n+\t  {\n+\t    out.println(\"java.rmi.server.RemoteRef.class.getMethod(\\\"invoke\\\", new java.lang.Class[] { java.rmi.Remote.class, java.lang.reflect.Method.class, java.lang.Object[].class, long.class });\");\n+\t    out.println(\"useNewInvoke = true;\");\n+\t  }\n+\n+\tfor (int i = 0; i < remotemethods.length; i++)\n+\t  {\n+\t    Method m = remotemethods[i].meth;\n+\t    out.print(\"$method_\" + m.getName() + \"_\" + i + \" = \");\n+\t    out.print(mRemoteInterface.getName() + \".class.getMethod(\\\"\"\n+\t              + m.getName() + \"\\\"\");\n+\t    out.print(\", new java.lang.Class[] {\");\n+\t    // Output signature\n+\t    Class[] sig = m.getParameterTypes();\n+\t    for (int j = 0; j < sig.length; j++)\n+\t      {\n+\t\tout.print(getPrettyName(sig[j]) + \".class\");\n+\t\tif (j + 1 < sig.length)\n+\t\t  out.print(\", \");\n+\t      }\n+\t    out.println(\"});\");\n+\t  }\n+\tctrl.unindent();\n+\tout.println(\"}\");\n+\tout.print(\"catch (java.lang.NoSuchMethodException e) {\");\n+\tctrl.indent();\n+\tif (need11Stubs)\n+\t  out.print(\"useNewInvoke = false;\");\n+\telse\n+\t  out.print(\"throw new java.lang.NoSuchMethodError(\\\"stub class initialization failed\\\");\");\n \n-\tif (verbose) {\n-\t\tSystem.out.println(\"[Generating class \" + stubname + \".java]\");\n-\t}\n+\tctrl.unindent();\n+\tout.print(\"}\");\n \n-\tout.println(\"// Stub class generated by rmic - DO NOT EDIT!\");\n+\tctrl.unindent();\n+\tout.println(\"}\");\n \tout.println();\n-\tif (fullclassname != classname) {\n-\t\tString pname = fullclassname.substring(0, fullclassname.lastIndexOf('.'));\n-\t\tout.println(\"package \" + pname + \";\");\n-\t\tout.println();\n-\t}\n+      }\n \n-\tout.print(\"public final class \" + stubclassname);\n+    // Constructors\n+    if (need11Stubs)\n+      {\n+\tout.print(\"public \" + stubclassname + \"() {\");\n \tctrl.indent();\n-\tout.println(\"extends java.rmi.server.RemoteStub\");\n-\t\n-\t// Output interfaces we implement\n-\tout.print(\"implements \");\n-\t/* Scan implemented interfaces, and only print remote interfaces. */ \n-        Class[] ifaces = clazz.getInterfaces(); \n-\tSet remoteIfaces = new HashSet();\n-        for (int i = 0; i < ifaces.length; i++) {\n-\t\tClass iface = ifaces[i];\n-\t\tif (java.rmi.Remote.class.isAssignableFrom(iface)) {\n-\t\t\tremoteIfaces.add(iface);\n-\t\t}\n-\t}\n-\tIterator iter = remoteIfaces.iterator();\n-\twhile (iter.hasNext()) {\n-\t\t/* Print remote interface. */\n-\t\tClass iface = (Class) iter.next();\n-\t\tout.print(iface.getName());\n-\n-\t\t/* Print \", \" if more remote interfaces follow. */\n-\t\tif (iter.hasNext()) {\n-\t\t\tout.print(\", \");\n-\t\t}\n-\t}\n+\tout.print(\"super();\");\n \tctrl.unindent();\n-\tout.print(\"{\");\n+\tout.println(\"}\");\n+      }\n+\n+    if (need12Stubs)\n+      {\n+\tout.print(\"public \" + stubclassname\n+\t          + \"(java.rmi.server.RemoteRef ref) {\");\n \tctrl.indent();\n+\tout.print(\"super(ref);\");\n+\tctrl.unindent();\n+\tout.println(\"}\");\n+      }\n \n-\t// UID\n-\tif (need12Stubs) {\n-\t\tout.println(\"private static final long serialVersionUID = 2L;\");\n-\t\tout.println();\n-\t}\n+    // Method implementations\n+    for (int i = 0; i < remotemethods.length; i++)\n+      {\n+\tMethod m = remotemethods[i].meth;\n+\tClass[] sig = m.getParameterTypes();\n+\tClass returntype = m.getReturnType();\n+\tClass[] except = sortExceptions(m.getExceptionTypes());\n \n-\t// InterfaceHash - don't know how to calculate this - XXX\n-\tif (need11Stubs) {\n-\t\tout.println(\"private static final long interfaceHash = \" + RMIHashes.getInterfaceHash(clazz) + \"L;\");\n-\t\tout.println();\n-\t\tif (need12Stubs) {\n-\t\t\tout.println(\"private static boolean useNewInvoke;\");\n-\t\t\tout.println();\n-\t\t}\n+\tout.println();\n+\tout.print(\"public \" + getPrettyName(returntype) + \" \" + m.getName()\n+\t          + \"(\");\n+\tfor (int j = 0; j < sig.length; j++)\n+\t  {\n+\t    out.print(getPrettyName(sig[j]));\n+\t    out.print(\" $param_\" + j);\n+\t    if (j + 1 < sig.length)\n+\t      out.print(\", \");\n+\t  }\n+\tout.print(\") \");\n+\tout.print(\"throws \");\n+\tfor (int j = 0; j < except.length; j++)\n+\t  {\n+\t    out.print(getPrettyName(except[j]));\n+\t    if (j + 1 < except.length)\n+\t      out.print(\", \");\n+\t  }\n+\tout.print(\" {\");\n+\tctrl.indent();\n \n-\t\t// Operation table\n-\t\tout.print(\"private static final java.rmi.server.Operation[] operations = {\");\n+\tout.print(\"try {\");\n+\tctrl.indent();\n \n+\tif (need12Stubs)\n+\t  {\n+\t    if (need11Stubs)\n+\t      {\n+\t\tout.print(\"if (useNewInvoke) {\");\n \t\tctrl.indent();\n-\t\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\t\tMethod m = remotemethods[i].meth;\n-\t\t\tout.print(\"new java.rmi.server.Operation(\\\"\");\n-\t\t\tout.print(getPrettyName(m.getReturnType()) + \" \");\n-\t\t\tout.print(m.getName() + \"(\");\n-\t\t\t// Output signature\n-\t\t\tClass[] sig = m.getParameterTypes();\n-\t\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\t\tout.print(getPrettyName(sig[j]));\n-\t\t\t\tif (j+1 < sig.length) {\n-\t\t\t\t\tout.print(\", \");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tout.print(\")\\\")\");\n-\t\t\tif (i + 1 < remotemethods.length) {\n-\t\t\t\tout.println(\",\");\n-\t\t\t}\n-\t\t}\n-\t\tctrl.unindent();\n-\t\tout.println(\"};\");\n-\t\tout.println();\n-\t}\n-\n-\t// Set of method references.\n-\tif (need12Stubs) {\n-\t\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\t\tMethod m = remotemethods[i].meth;\n-\t\t\tout.println(\"private static java.lang.reflect.Method $method_\" + m.getName() + \"_\" + i + \";\");\n-\t\t}\n-\n-\t\t// Initialize the methods references.\n+\t      }\n+\t    if (returntype != Void.TYPE)\n+\t      out.print(\"java.lang.Object $result = \");\n+\t    out.print(\"ref.invoke(this, $method_\" + m.getName() + \"_\" + i\n+\t              + \", \");\n+\t    if (sig.length == 0)\n+\t      out.print(\"null, \");\n+\t    else\n+\t      {\n+\t\tout.print(\"new java.lang.Object[] {\");\n+\t\tfor (int j = 0; j < sig.length; j++)\n+\t\t  {\n+\t\t    if (sig[j] == Boolean.TYPE)\n+\t\t      out.print(\"new java.lang.Boolean($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Byte.TYPE)\n+\t\t      out.print(\"new java.lang.Byte($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Character.TYPE)\n+\t\t      out.print(\"new java.lang.Character($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Short.TYPE)\n+\t\t      out.print(\"new java.lang.Short($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Integer.TYPE)\n+\t\t      out.print(\"new java.lang.Integer($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Long.TYPE)\n+\t\t      out.print(\"new java.lang.Long($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Float.TYPE)\n+\t\t      out.print(\"new java.lang.Float($param_\" + j + \")\");\n+\t\t    else if (sig[j] == Double.TYPE)\n+\t\t      out.print(\"new java.lang.Double($param_\" + j + \")\");\n+\t\t    else\n+\t\t      out.print(\"$param_\" + j);\n+\t\t    if (j + 1 < sig.length)\n+\t\t      out.print(\", \");\n+\t\t  }\n+\t\tout.print(\"}, \");\n+\t      }\n+\t    out.print(Long.toString(remotemethods[i].hash) + \"L\");\n+\t    out.print(\");\");\n+\n+\t    if (returntype != Void.TYPE)\n+\t      {\n \t\tout.println();\n-\t\tout.print(\"static {\");\n-\t\tctrl.indent();\n-\n-\t\tout.print(\"try {\");\n-\t\tctrl.indent();\n-\n-\t\tif (need11Stubs) {\n-\t\t\tout.println(\"java.rmi.server.RemoteRef.class.getMethod(\\\"invoke\\\", new java.lang.Class[] { java.rmi.Remote.class, java.lang.reflect.Method.class, java.lang.Object[].class, long.class });\");\n-\t\t\tout.println(\"useNewInvoke = true;\");\n-\t\t}\n-\n-\t\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\t\tMethod m = remotemethods[i].meth;\n-\t\t\tout.print(\"$method_\" + m.getName() + \"_\" + i + \" = \");\n-\t\t\tout.print(mRemoteInterface.getName() + \".class.getMethod(\\\"\" + m.getName() + \"\\\"\");\n-\t\t\tout.print(\", new java.lang.Class[] {\");\n-\t\t\t// Output signature\n-\t\t\tClass[] sig = m.getParameterTypes();\n-\t\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\t\tout.print(getPrettyName(sig[j]) + \".class\");\n-\t\t\t\tif (j+1 < sig.length) {\n-\t\t\t\t\tout.print(\", \");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tout.println(\"});\");\n-\t\t}\n+\t\tout.print(\"return (\");\n+\t\tif (returntype == Boolean.TYPE)\n+\t\t  out.print(\"((java.lang.Boolean)$result).booleanValue()\");\n+\t\telse if (returntype == Byte.TYPE)\n+\t\t  out.print(\"((java.lang.Byte)$result).byteValue()\");\n+\t\telse if (returntype == Character.TYPE)\n+\t\t  out.print(\"((java.lang.Character)$result).charValue()\");\n+\t\telse if (returntype == Short.TYPE)\n+\t\t  out.print(\"((java.lang.Short)$result).shortValue()\");\n+\t\telse if (returntype == Integer.TYPE)\n+\t\t  out.print(\"((java.lang.Integer)$result).intValue()\");\n+\t\telse if (returntype == Long.TYPE)\n+\t\t  out.print(\"((java.lang.Long)$result).longValue()\");\n+\t\telse if (returntype == Float.TYPE)\n+\t\t  out.print(\"((java.lang.Float)$result).floatValue()\");\n+\t\telse if (returntype == Double.TYPE)\n+\t\t  out.print(\"((java.lang.Double)$result).doubleValue()\");\n+\t\telse\n+\t\t  out.print(\"(\" + getPrettyName(returntype) + \")$result\");\n+\t\tout.print(\");\");\n+\t      }\n+\n+\t    if (need11Stubs)\n+\t      {\n \t\tctrl.unindent();\n \t\tout.println(\"}\");\n-\t\tout.print(\"catch (java.lang.NoSuchMethodException e) {\");\n+\t\tout.print(\"else {\");\n \t\tctrl.indent();\n-\t\tif (need11Stubs) {\n-\t\t\tout.print(\"useNewInvoke = false;\");\n-\t\t}\n-\t\telse {\n-\t\t\tout.print(\"throw new java.lang.NoSuchMethodError(\\\"stub class initialization failed\\\");\");\n-\t\t}\n-\n-\t\tctrl.unindent();\n-\t\tout.print(\"}\");\n-\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n+\t      }\n+\t  }\n+\n+\tif (need11Stubs)\n+\t  {\n+\t    out.println(\"java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject)this, operations, \"\n+\t                + i + \", interfaceHash);\");\n+\t    out.print(\"try {\");\n+\t    ctrl.indent();\n+\t    out.print(\"java.io.ObjectOutput out = call.getOutputStream();\");\n+\t    for (int j = 0; j < sig.length; j++)\n+\t      {\n \t\tout.println();\n-\t}\n-\n-\t// Constructors\n-\tif (need11Stubs) {\n-\t\tout.print(\"public \" + stubclassname + \"() {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"super();\");\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t}\n-\n-\tif (need12Stubs) {\n-\t\tout.print(\"public \" + stubclassname + \"(java.rmi.server.RemoteRef ref) {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"super(ref);\");\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t}\n-\n-\t// Method implementations\n-\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\tMethod m = remotemethods[i].meth;\n-\t\tClass[] sig = m.getParameterTypes();\n-\t\tClass returntype = m.getReturnType();\n-\t\tClass[] except = sortExceptions(m.getExceptionTypes());\n-\n+\t\tif (sig[j] == Boolean.TYPE)\n+\t\t  out.print(\"out.writeBoolean(\");\n+\t\telse if (sig[j] == Byte.TYPE)\n+\t\t  out.print(\"out.writeByte(\");\n+\t\telse if (sig[j] == Character.TYPE)\n+\t\t  out.print(\"out.writeChar(\");\n+\t\telse if (sig[j] == Short.TYPE)\n+\t\t  out.print(\"out.writeShort(\");\n+\t\telse if (sig[j] == Integer.TYPE)\n+\t\t  out.print(\"out.writeInt(\");\n+\t\telse if (sig[j] == Long.TYPE)\n+\t\t  out.print(\"out.writeLong(\");\n+\t\telse if (sig[j] == Float.TYPE)\n+\t\t  out.print(\"out.writeFloat(\");\n+\t\telse if (sig[j] == Double.TYPE)\n+\t\t  out.print(\"out.writeDouble(\");\n+\t\telse\n+\t\t  out.print(\"out.writeObject(\");\n+\t\tout.print(\"$param_\" + j + \");\");\n+\t      }\n+\t    ctrl.unindent();\n+\t    out.println(\"}\");\n+\t    out.print(\"catch (java.io.IOException e) {\");\n+\t    ctrl.indent();\n+\t    out.print(\"throw new java.rmi.MarshalException(\\\"error marshalling arguments\\\", e);\");\n+\t    ctrl.unindent();\n+\t    out.println(\"}\");\n+\t    out.println(\"ref.invoke(call);\");\n+\t    if (returntype != Void.TYPE)\n+\t      out.println(getPrettyName(returntype) + \" $result;\");\n+\t    out.print(\"try {\");\n+\t    ctrl.indent();\n+\t    out.print(\"java.io.ObjectInput in = call.getInputStream();\");\n+\t    boolean needcastcheck = false;\n+\t    if (returntype != Void.TYPE)\n+\t      {\n \t\tout.println();\n-\t\tout.print(\"public \" + getPrettyName(returntype) + \" \" + m.getName() + \"(\");\n-\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\tout.print(getPrettyName(sig[j]));\n-\t\t\tout.print(\" $param_\" + j);\n-\t\t\tif (j+1 < sig.length) {\n-\t\t\t\tout.print(\", \");\n-\t\t\t}\n-\t\t}\n-\t\tout.print(\") \");\n-\t\tout.print(\"throws \");\n-\t\tfor (int j = 0; j < except.length; j++) {\n-\t\t\tout.print(getPrettyName(except[j]));\n-\t\t\tif (j+1 < except.length) {\n-\t\t\t\tout.print(\", \");\n-\t\t\t}\n-\t\t}\n-\t\tout.print(\" {\");\n-\t\tctrl.indent();\n-\n-\t\tout.print(\"try {\");\n+\t\tout.print(\"$result = \");\n+\t\tif (returntype == Boolean.TYPE)\n+\t\t  out.print(\"in.readBoolean();\");\n+\t\telse if (returntype == Byte.TYPE)\n+\t\t  out.print(\"in.readByte();\");\n+\t\telse if (returntype == Character.TYPE)\n+\t\t  out.print(\"in.readChar();\");\n+\t\telse if (returntype == Short.TYPE)\n+\t\t  out.print(\"in.readShort();\");\n+\t\telse if (returntype == Integer.TYPE)\n+\t\t  out.print(\"in.readInt();\");\n+\t\telse if (returntype == Long.TYPE)\n+\t\t  out.print(\"in.readLong();\");\n+\t\telse if (returntype == Float.TYPE)\n+\t\t  out.print(\"in.readFloat();\");\n+\t\telse if (returntype == Double.TYPE)\n+\t\t  out.print(\"in.readDouble();\");\n+\t\telse\n+\t\t  {\n+\t\t    if (returntype != Object.class)\n+\t\t      out.print(\"(\" + getPrettyName(returntype) + \")\");\n+\t\t    else\n+\t\t      needcastcheck = true;\n+\t\t    out.print(\"in.readObject();\");\n+\t\t  }\n+\t\tout.println();\n+\t\tout.print(\"return ($result);\");\n+\t      }\n+\t    ctrl.unindent();\n+\t    out.println(\"}\");\n+\t    out.print(\"catch (java.io.IOException e) {\");\n+\t    ctrl.indent();\n+\t    out.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling return\\\", e);\");\n+\t    ctrl.unindent();\n+\t    out.println(\"}\");\n+\t    if (needcastcheck)\n+\t      {\n+\t\tout.print(\"catch (java.lang.ClassNotFoundException e) {\");\n \t\tctrl.indent();\n-\n-\t\tif (need12Stubs) {\n-\t\t\tif (need11Stubs) {\n-\t\t\t\tout.print(\"if (useNewInvoke) {\");\n-\t\t\t\tctrl.indent();\n-\t\t\t}\n-\t\t\tif (returntype != Void.TYPE) {\n-\t\t\t\tout.print(\"java.lang.Object $result = \");\n-\t\t\t}\n-\t\t\tout.print(\"ref.invoke(this, $method_\" + m.getName() + \"_\" + i + \", \");\n-\t\t\tif (sig.length == 0) {\n-\t\t\t\tout.print(\"null, \");\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tout.print(\"new java.lang.Object[] {\");\n-\t\t\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\t\t\tif (sig[j] == Boolean.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Boolean($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Byte.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Byte($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Character.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Character($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Short.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Short($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Integer.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Integer($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Long.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Long($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Float.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Float($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (sig[j] == Double.TYPE) {\n-\t\t\t\t\t\tout.print(\"new java.lang.Double($param_\" + j + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tout.print(\"$param_\" + j);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (j+1 < sig.length) {\n-\t\t\t\t\t\tout.print(\", \");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tout.print(\"}, \");\n-\t\t\t}\n-\t\t\tout.print(Long.toString(remotemethods[i].hash) + \"L\");\n-\t\t\tout.print(\");\");\n-\n-\t\t\tif (returntype != Void.TYPE) {\n-\t\t\t\tout.println();\n-\t\t\t\tout.print(\"return (\");\n-\t\t\t\tif (returntype == Boolean.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Boolean)$result).booleanValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Byte.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Byte)$result).byteValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Character.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Character)$result).charValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Short.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Short)$result).shortValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Integer.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Integer)$result).intValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Long.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Long)$result).longValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Float.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Float)$result).floatValue()\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Double.TYPE) {\n-\t\t\t\t\tout.print(\"((java.lang.Double)$result).doubleValue()\");\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tout.print(\"(\" + getPrettyName(returntype) + \")$result\");\n-\t\t\t\t}\n-\t\t\t\tout.print(\");\");\n-\t\t\t}\n-\n-\t\t\tif (need11Stubs) {\n-\t\t\t\tctrl.unindent();\n-\t\t\t\tout.println(\"}\");\n-\t\t\t\tout.print(\"else {\");\n-\t\t\t\tctrl.indent();\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (need11Stubs) {\n-\t\t\tout.println(\"java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject)this, operations, \" + i + \", interfaceHash);\");\n-\t\t\tout.print(\"try {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"java.io.ObjectOutput out = call.getOutputStream();\");\n-\t\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\t\tout.println();\n-\t\t\t\tif (sig[j] == Boolean.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeBoolean(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Byte.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeByte(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Character.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeChar(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Short.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeShort(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Integer.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeInt(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Long.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeLong(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Float.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeFloat(\");\n-\t\t\t\t}\n-\t\t\t\telse if (sig[j] == Double.TYPE) {\n-\t\t\t\t\tout.print(\"out.writeDouble(\");\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tout.print(\"out.writeObject(\");\n-\t\t\t\t}\n-\t\t\t\tout.print(\"$param_\" + j + \");\");\n-\t\t\t}\n-\t\t\tctrl.unindent();\n-\t\t\tout.println(\"}\");\n-\t\t\tout.print(\"catch (java.io.IOException e) {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"throw new java.rmi.MarshalException(\\\"error marshalling arguments\\\", e);\");\n-\t\t\tctrl.unindent();\n-\t\t\tout.println(\"}\");\n-\t\t\tout.println(\"ref.invoke(call);\");\n-\t\t\tif (returntype != Void.TYPE) {\n-\t\t\t\tout.println(getPrettyName(returntype) + \" $result;\");\n-\t\t\t}\n-\t\t\tout.print(\"try {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"java.io.ObjectInput in = call.getInputStream();\");\n-\t\t\tboolean needcastcheck = false;\n-\t\t\tif (returntype != Void.TYPE) {\n-\t\t\t\tout.println();\n-\t\t\t\tout.print(\"$result = \");\n-\t\t\t\tif (returntype == Boolean.TYPE) {\n-\t\t\t\t\tout.print(\"in.readBoolean();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Byte.TYPE) {\n-\t\t\t\t\tout.print(\"in.readByte();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Character.TYPE) {\n-\t\t\t\t\tout.print(\"in.readChar();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Short.TYPE) {\n-\t\t\t\t\tout.print(\"in.readShort();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Integer.TYPE) {\n-\t\t\t\t\tout.print(\"in.readInt();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Long.TYPE) {\n-\t\t\t\t\tout.print(\"in.readLong();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Float.TYPE) {\n-\t\t\t\t\tout.print(\"in.readFloat();\");\n-\t\t\t\t}\n-\t\t\t\telse if (returntype == Double.TYPE) {\n-\t\t\t\t\tout.print(\"in.readDouble();\");\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tif (returntype != Object.class) {\n-\t\t\t\t\t\tout.print(\"(\" + getPrettyName(returntype) + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tneedcastcheck = true;\n-\t\t\t\t\t}\n-\t\t\t\t\tout.print(\"in.readObject();\");\n-\t\t\t\t}\n-\t\t\t\tout.println();\n-\t\t\t\tout.print(\"return ($result);\");\n-\t\t\t}\n-\t\t\tctrl.unindent();\n-\t\t\tout.println(\"}\");\n-\t\t\tout.print(\"catch (java.io.IOException e) {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling return\\\", e);\");\n-\t\t\tctrl.unindent();\n-\t\t\tout.println(\"}\");\n-\t\t\tif (needcastcheck) {\n-\t\t\t\tout.print(\"catch (java.lang.ClassNotFoundException e) {\");\n-\t\t\t\tctrl.indent();\n-\t\t\t\tout.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling return\\\", e);\");\n-\t\t\t\tctrl.unindent();\n-\t\t\t\tout.println(\"}\");\n-\t\t\t}\n-\t\t\tout.print(\"finally {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"ref.done(call);\");\n-\t\t\tctrl.unindent();\n-\t\t\tout.print(\"}\");\n-\n-\t\t\tif (need12Stubs && need11Stubs) {\n-\t\t\t\tctrl.unindent();\n-\t\t\t\tout.print(\"}\");\n-\t\t\t}\n-\t\t}\n-\n+\t\tout.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling return\\\", e);\");\n \t\tctrl.unindent();\n-\t\tout.print(\"}\");\n-\n-\t\tboolean needgeneral = true;\n-\t\tfor (int j = 0; j < except.length; j++) {\n-\t\t\tout.println();\n-\t\t\tout.print(\"catch (\" + getPrettyName(except[j]) + \" e) {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"throw e;\");\n-\t\t\tctrl.unindent();\n-\t\t\tout.print(\"}\");\n-\t\t\tif (except[j] == Exception.class) {\n-\t\t\t\tneedgeneral = false;\n-\t\t\t}\n-\t\t}\n-\t\tif (needgeneral) {\n-\t\t\tout.println();\n-\t\t\tout.print(\"catch (java.lang.Exception e) {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"throw new java.rmi.UnexpectedException(\\\"undeclared checked exception\\\", e);\");\n-\t\t\tctrl.unindent();\n-\t\t\tout.print(\"}\");\n-\t\t}\n-\n+\t\tout.println(\"}\");\n+\t      }\n+\t    out.print(\"finally {\");\n+\t    ctrl.indent();\n+\t    out.print(\"ref.done(call);\");\n+\t    ctrl.unindent();\n+\t    out.print(\"}\");\n+\n+\t    if (need12Stubs && need11Stubs)\n+\t      {\n \t\tctrl.unindent();\n \t\tout.print(\"}\");\n-\t\tout.println();\n-\t}\n+\t      }\n+\t  }\n \n \tctrl.unindent();\n-\tout.println(\"}\");\n-\n-\tout.close();\n-}\n-\n-private void generateSkel() throws IOException {\n-\tskelname = fullclassname + \"_Skel\";\n-\tString skelclassname = classname + \"_Skel\";\n-\tctrl = new TabbedWriter(new FileWriter((destination == null ? \"\" : destination + File.separator)\n-\t\t\t\t\t       + skelname.replace('.', File.separatorChar)\n-\t\t\t\t\t       + \".java\"));\n-\tout = new PrintWriter(ctrl);\n-\n-\tif (verbose) {\n-\t\tSystem.out.println(\"[Generating class \" + skelname + \".java]\");\n-\t}\n-\n-\tout.println(\"// Skel class generated by rmic - DO NOT EDIT!\");\n-\tout.println();\n-\tif (fullclassname != classname) {\n-\t\tString pname = fullclassname.substring(0, fullclassname.lastIndexOf('.'));\n-\t\tout.println(\"package \" + pname + \";\");\n-\t\tout.println();\n-\t}\n+\tout.print(\"}\");\n \n-\tout.print(\"public final class \" + skelclassname);\n-\tctrl.indent();\n-\t\n-\t// Output interfaces we implement\n-\tout.print(\"implements java.rmi.server.Skeleton\");\n+\tboolean needgeneral = true;\n+\tfor (int j = 0; j < except.length; j++)\n+\t  {\n+\t    out.println();\n+\t    out.print(\"catch (\" + getPrettyName(except[j]) + \" e) {\");\n+\t    ctrl.indent();\n+\t    out.print(\"throw e;\");\n+\t    ctrl.unindent();\n+\t    out.print(\"}\");\n+\t    if (except[j] == Exception.class)\n+\t      needgeneral = false;\n+\t  }\n+\tif (needgeneral)\n+\t  {\n+\t    out.println();\n+\t    out.print(\"catch (java.lang.Exception e) {\");\n+\t    ctrl.indent();\n+\t    out.print(\"throw new java.rmi.UnexpectedException(\\\"undeclared checked exception\\\", e);\");\n+\t    ctrl.unindent();\n+\t    out.print(\"}\");\n+\t  }\n \n \tctrl.unindent();\n-\tout.print(\"{\");\n-\tctrl.indent();\n-\n-\t// Interface hash - don't know how to calculate this - XXX\n-\tout.println(\"private static final long interfaceHash = \" + RMIHashes.getInterfaceHash(clazz) + \"L;\");\n+\tout.print(\"}\");\n \tout.println();\n-\n-\t// Operation table\n-\tout.print(\"private static final java.rmi.server.Operation[] operations = {\");\n-\n-\tctrl.indent();\n-\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\tMethod m = remotemethods[i].meth;\n-\t\tout.print(\"new java.rmi.server.Operation(\\\"\");\n-\t\tout.print(getPrettyName(m.getReturnType()) + \" \");\n-\t\tout.print(m.getName() + \"(\");\n-\t\t// Output signature\n-\t\tClass[] sig = m.getParameterTypes();\n-\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\tout.print(getPrettyName(sig[j]));\n-\t\t\tif (j+1 < sig.length) {\n-\t\t\t\tout.print(\", \");\n-\t\t\t}\n-\t\t}\n-\t\tout.print(\"\\\")\");\n-\t\tif (i + 1 < remotemethods.length) {\n-\t\t\tout.println(\",\");\n-\t\t}\n-\t}\n-\tctrl.unindent();\n-\tout.println(\"};\");\n-\n+      }\n+\n+    ctrl.unindent();\n+    out.println(\"}\");\n+\n+    out.close();\n+  }\n+\n+  private void generateSkel() throws IOException\n+  {\n+    skelname = fullclassname + \"_Skel\";\n+    String skelclassname = classname + \"_Skel\";\n+    ctrl =\n+      new TabbedWriter(new FileWriter((destination == null ? \"\"\n+                                                           : destination\n+                                                           + File.separator)\n+                                      + skelname.replace('.',\n+                                                         File.separatorChar)\n+                                      + \".java\"));\n+    out = new PrintWriter(ctrl);\n+\n+    if (verbose)\n+      System.out.println(\"[Generating class \" + skelname + \".java]\");\n+\n+    out.println(\"// Skel class generated by rmic - DO NOT EDIT!\");\n+    out.println();\n+    if (fullclassname != classname)\n+      {\n+\tString pname =\n+\t  fullclassname.substring(0, fullclassname.lastIndexOf('.'));\n+\tout.println(\"package \" + pname + \";\");\n \tout.println();\n-\n-\t// getOperations method\n-\tout.print(\"public java.rmi.server.Operation[] getOperations() {\");\n+      }\n+\n+    out.print(\"public final class \" + skelclassname);\n+    ctrl.indent();\n+\n+    // Output interfaces we implement\n+    out.print(\"implements java.rmi.server.Skeleton\");\n+\n+    ctrl.unindent();\n+    out.print(\"{\");\n+    ctrl.indent();\n+\n+    // Interface hash - don't know how to calculate this - XXX\n+    out.println(\"private static final long interfaceHash = \"\n+                + RMIHashes.getInterfaceHash(clazz) + \"L;\");\n+    out.println();\n+\n+    // Operation table\n+    out.print(\"private static final java.rmi.server.Operation[] operations = {\");\n+\n+    ctrl.indent();\n+    for (int i = 0; i < remotemethods.length; i++)\n+      {\n+\tMethod m = remotemethods[i].meth;\n+\tout.print(\"new java.rmi.server.Operation(\\\"\");\n+\tout.print(getPrettyName(m.getReturnType()) + \" \");\n+\tout.print(m.getName() + \"(\");\n+\t// Output signature\n+\tClass[] sig = m.getParameterTypes();\n+\tfor (int j = 0; j < sig.length; j++)\n+\t  {\n+\t    out.print(getPrettyName(sig[j]));\n+\t    if (j + 1 < sig.length)\n+\t      out.print(\", \");\n+\t  }\n+\tout.print(\"\\\")\");\n+\tif (i + 1 < remotemethods.length)\n+\t  out.println(\",\");\n+      }\n+    ctrl.unindent();\n+    out.println(\"};\");\n+\n+    out.println();\n+\n+    // getOperations method\n+    out.print(\"public java.rmi.server.Operation[] getOperations() {\");\n+    ctrl.indent();\n+    out.print(\"return ((java.rmi.server.Operation[]) operations.clone());\");\n+    ctrl.unindent();\n+    out.println(\"}\");\n+\n+    out.println();\n+\n+    // Dispatch method\n+    out.print(\"public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash) throws java.lang.Exception {\");\n+    ctrl.indent();\n+\n+    out.print(\"if (opnum < 0) {\");\n+    ctrl.indent();\n+\n+    for (int i = 0; i < remotemethods.length; i++)\n+      {\n+\tout.print(\"if (hash == \" + Long.toString(remotemethods[i].hash)\n+\t          + \"L) {\");\n \tctrl.indent();\n-\tout.print(\"return ((java.rmi.server.Operation[]) operations.clone());\");\n+\tout.print(\"opnum = \" + i + \";\");\n \tctrl.unindent();\n \tout.println(\"}\");\n-\n-\tout.println();\n-\n-\t// Dispatch method\n-\tout.print(\"public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash) throws java.lang.Exception {\");\n+\tout.print(\"else \");\n+      }\n+    out.print(\"{\");\n+    ctrl.indent();\n+    out.print(\"throw new java.rmi.server.SkeletonMismatchException(\\\"interface hash mismatch\\\");\");\n+    ctrl.unindent();\n+    out.print(\"}\");\n+\n+    ctrl.unindent();\n+    out.println(\"}\");\n+    out.print(\"else if (hash != interfaceHash) {\");\n+    ctrl.indent();\n+    out.print(\"throw new java.rmi.server.SkeletonMismatchException(\\\"interface hash mismatch\\\");\");\n+    ctrl.unindent();\n+    out.println(\"}\");\n+\n+    out.println();\n+\n+    out.println(fullclassname + \" server = (\" + fullclassname + \")obj;\");\n+    out.println(\"switch (opnum) {\");\n+\n+    // Method dispatch\n+    for (int i = 0; i < remotemethods.length; i++)\n+      {\n+\tMethod m = remotemethods[i].meth;\n+\tout.println(\"case \" + i + \":\");\n+\tout.print(\"{\");\n \tctrl.indent();\n \n-\tout.print(\"if (opnum < 0) {\");\n-\tctrl.indent();\n+\tClass[] sig = m.getParameterTypes();\n+\tfor (int j = 0; j < sig.length; j++)\n+\t  {\n+\t    out.print(getPrettyName(sig[j]));\n+\t    out.println(\" $param_\" + j + \";\");\n+\t  }\n \n-\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\tout.print(\"if (hash == \" + Long.toString(remotemethods[i].hash) + \"L) {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"opnum = \" + i + \";\");\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t\tout.print(\"else \");\n-\t}\n-\tout.print(\"{\");\n+\tout.print(\"try {\");\n+\tboolean needcastcheck = false;\n \tctrl.indent();\n-\tout.print(\"throw new java.rmi.server.SkeletonMismatchException(\\\"interface hash mismatch\\\");\");\n+\tout.println(\"java.io.ObjectInput in = call.getInputStream();\");\n+\tfor (int j = 0; j < sig.length; j++)\n+\t  {\n+\t    out.print(\"$param_\" + j + \" = \");\n+\t    if (sig[j] == Boolean.TYPE)\n+\t      out.print(\"in.readBoolean();\");\n+\t    else if (sig[j] == Byte.TYPE)\n+\t      out.print(\"in.readByte();\");\n+\t    else if (sig[j] == Character.TYPE)\n+\t      out.print(\"in.readChar();\");\n+\t    else if (sig[j] == Short.TYPE)\n+\t      out.print(\"in.readShort();\");\n+\t    else if (sig[j] == Integer.TYPE)\n+\t      out.print(\"in.readInt();\");\n+\t    else if (sig[j] == Long.TYPE)\n+\t      out.print(\"in.readLong();\");\n+\t    else if (sig[j] == Float.TYPE)\n+\t      out.print(\"in.readFloat();\");\n+\t    else if (sig[j] == Double.TYPE)\n+\t      out.print(\"in.readDouble();\");\n+\t    else\n+\t      {\n+\t\tif (sig[j] != Object.class)\n+\t\t  {\n+\t\t    out.print(\"(\" + getPrettyName(sig[j]) + \")\");\n+\t\t    needcastcheck = true;\n+\t\t  }\n+\t\tout.print(\"in.readObject();\");\n+\t      }\n+\t    out.println();\n+\t  }\n \tctrl.unindent();\n-\tout.print(\"}\");\n-\n+\tout.println(\"}\");\n+\tout.print(\"catch (java.io.IOException e) {\");\n+\tctrl.indent();\n+\tout.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling arguments\\\", e);\");\n \tctrl.unindent();\n \tout.println(\"}\");\n-\tout.print(\"else if (hash != interfaceHash) {\");\n+\tif (needcastcheck)\n+\t  {\n+\t    out.print(\"catch (java.lang.ClassCastException e) {\");\n+\t    ctrl.indent();\n+\t    out.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling arguments\\\", e);\");\n+\t    ctrl.unindent();\n+\t    out.println(\"}\");\n+\t  }\n+\tout.print(\"finally {\");\n \tctrl.indent();\n-\tout.print(\"throw new java.rmi.server.SkeletonMismatchException(\\\"interface hash mismatch\\\");\");\n+\tout.print(\"call.releaseInputStream();\");\n \tctrl.unindent();\n \tout.println(\"}\");\n \n-\tout.println();\n-\n-\tout.println(fullclassname + \" server = (\" + fullclassname + \")obj;\");\n-\tout.println(\"switch (opnum) {\");\n-\n-\t// Method dispatch\n-\tfor (int i = 0; i < remotemethods.length; i++) {\n-\t\tMethod m = remotemethods[i].meth;\n-\t\tout.println(\"case \" + i + \":\");\n-\t\tout.print(\"{\");\n-\t\tctrl.indent();\n-\n-\t\tClass[] sig = m.getParameterTypes();\n-\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\tout.print(getPrettyName(sig[j]));\n-\t\t\tout.println(\" $param_\" + j + \";\");\n-\t\t}\n-\n-\t\tout.print(\"try {\");\n-\t\tboolean needcastcheck = false;\n-\t\tctrl.indent();\n-\t\tout.println(\"java.io.ObjectInput in = call.getInputStream();\");\n-\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\tout.print(\"$param_\" + j + \" = \");\n-\t\t\tif (sig[j] == Boolean.TYPE) {\n-\t\t\t\tout.print(\"in.readBoolean();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Byte.TYPE) {\n-\t\t\t\tout.print(\"in.readByte();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Character.TYPE) {\n-\t\t\t\tout.print(\"in.readChar();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Short.TYPE) {\n-\t\t\t\tout.print(\"in.readShort();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Integer.TYPE) {\n-\t\t\t\tout.print(\"in.readInt();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Long.TYPE) {\n-\t\t\t\tout.print(\"in.readLong();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Float.TYPE) {\n-\t\t\t\tout.print(\"in.readFloat();\");\n-\t\t\t}\n-\t\t\telse if (sig[j] == Double.TYPE) {\n-\t\t\t\tout.print(\"in.readDouble();\");\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (sig[j] != Object.class) {\n-\t\t\t\t\tout.print(\"(\" + getPrettyName(sig[j]) + \")\");\n-\t\t\t\t\tneedcastcheck = true;\n-\t\t\t\t}\n-\t\t\t\tout.print(\"in.readObject();\");\n-\t\t\t}\n-\t\t\tout.println();\n-\t\t}\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t\tout.print(\"catch (java.io.IOException e) {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling arguments\\\", e);\");\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t\tif (needcastcheck) {\n-\t\t\tout.print(\"catch (java.lang.ClassCastException e) {\");\n-\t\t\tctrl.indent();\n-\t\t\tout.print(\"throw new java.rmi.UnmarshalException(\\\"error unmarshalling arguments\\\", e);\");\n-\t\t\tctrl.unindent();\n-\t\t\tout.println(\"}\");\n-\t\t}\n-\t\tout.print(\"finally {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"call.releaseInputStream();\");\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\n-\t\tClass returntype = m.getReturnType();\n-\t\tif (returntype != Void.TYPE) {\n-\t\t\tout.print(getPrettyName(returntype) + \" $result = \");\n-\t\t}\n-\t\tout.print(\"server.\" + m.getName() + \"(\");\n-\t\tfor (int j = 0; j < sig.length; j++) {\n-\t\t\tout.print(\"$param_\" + j);\n-\t\t\tif (j + 1 < sig.length) {\n-\t\t\t\tout.print(\", \");\n-\t\t\t}\n-\t\t}\n-\t\tout.println(\");\");\n-\n-\t\tout.print(\"try {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"java.io.ObjectOutput out = call.getResultStream(true);\");\n-\t\tif (returntype != Void.TYPE) {\n-\t\t\tout.println();\n-\t\t\tif (returntype == Boolean.TYPE) {\n-\t\t\t\tout.print(\"out.writeBoolean($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Byte.TYPE) {\n-\t\t\t\tout.print(\"out.writeByte($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Character.TYPE) {\n-\t\t\t\tout.print(\"out.writeChar($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Short.TYPE) {\n-\t\t\t\tout.print(\"out.writeShort($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Integer.TYPE) {\n-\t\t\t\tout.print(\"out.writeInt($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Long.TYPE) {\n-\t\t\t\tout.print(\"out.writeLong($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Float.TYPE) {\n-\t\t\t\tout.print(\"out.writeFloat($result);\");\n-\t\t\t}\n-\t\t\telse if (returntype == Double.TYPE) {\n-\t\t\t\tout.print(\"out.writeDouble($result);\");\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tout.print(\"out.writeObject($result);\");\n-\t\t\t}\n-\t\t}\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t\tout.print(\"catch (java.io.IOException e) {\");\n-\t\tctrl.indent();\n-\t\tout.print(\"throw new java.rmi.MarshalException(\\\"error marshalling return\\\", e);\");\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t\tout.print(\"break;\");\n-\n-\t\tctrl.unindent();\n-\t\tout.println(\"}\");\n-\t\tout.println();\n-\t}\n-\n-\tout.print(\"default:\");\n+\tClass returntype = m.getReturnType();\n+\tif (returntype != Void.TYPE)\n+\t  out.print(getPrettyName(returntype) + \" $result = \");\n+\tout.print(\"server.\" + m.getName() + \"(\");\n+\tfor (int j = 0; j < sig.length; j++)\n+\t  {\n+\t    out.print(\"$param_\" + j);\n+\t    if (j + 1 < sig.length)\n+\t      out.print(\", \");\n+\t  }\n+\tout.println(\");\");\n+\n+\tout.print(\"try {\");\n \tctrl.indent();\n-\tout.print(\"throw new java.rmi.UnmarshalException(\\\"invalid method number\\\");\");\n+\tout.print(\"java.io.ObjectOutput out = call.getResultStream(true);\");\n+\tif (returntype != Void.TYPE)\n+\t  {\n+\t    out.println();\n+\t    if (returntype == Boolean.TYPE)\n+\t      out.print(\"out.writeBoolean($result);\");\n+\t    else if (returntype == Byte.TYPE)\n+\t      out.print(\"out.writeByte($result);\");\n+\t    else if (returntype == Character.TYPE)\n+\t      out.print(\"out.writeChar($result);\");\n+\t    else if (returntype == Short.TYPE)\n+\t      out.print(\"out.writeShort($result);\");\n+\t    else if (returntype == Integer.TYPE)\n+\t      out.print(\"out.writeInt($result);\");\n+\t    else if (returntype == Long.TYPE)\n+\t      out.print(\"out.writeLong($result);\");\n+\t    else if (returntype == Float.TYPE)\n+\t      out.print(\"out.writeFloat($result);\");\n+\t    else if (returntype == Double.TYPE)\n+\t      out.print(\"out.writeDouble($result);\");\n+\t    else\n+\t      out.print(\"out.writeObject($result);\");\n+\t  }\n \tctrl.unindent();\n-\tout.print(\"}\");\n-\n+\tout.println(\"}\");\n+\tout.print(\"catch (java.io.IOException e) {\");\n+\tctrl.indent();\n+\tout.print(\"throw new java.rmi.MarshalException(\\\"error marshalling return\\\", e);\");\n \tctrl.unindent();\n-\tout.print(\"}\");\n+\tout.println(\"}\");\n+\tout.print(\"break;\");\n \n \tctrl.unindent();\n \tout.println(\"}\");\n-\n-\tout.close();\n-}\n-\n-private void compile(String name) throws Exception {\n-\tCompiler comp = Compiler.getInstance();\n-\tif (verbose) {\n-\t\tSystem.out.println(\"[Compiling class \" + name + \"]\");\n-\t}\n-\tcomp.setDestination(destination);\n-\tcomp.compile(name);\n-}\n-\n-private static String getPrettyName(Class cls) {\n-        StringBuffer str = new StringBuffer();\n-        for (int count = 0;; count++) {\n-                if (!cls.isArray()) {\n-                        str.append(cls.getName());\n-                        for (; count > 0; count--) {\n-                                str.append(\"[]\");\n-                        }\n-                        return (str.toString());\n-                }\n-                cls = cls.getComponentType();\n-        }\n-}\n+\tout.println();\n+      }\n+\n+    out.print(\"default:\");\n+    ctrl.indent();\n+    out.print(\"throw new java.rmi.UnmarshalException(\\\"invalid method number\\\");\");\n+    ctrl.unindent();\n+    out.print(\"}\");\n+\n+    ctrl.unindent();\n+    out.print(\"}\");\n+\n+    ctrl.unindent();\n+    out.println(\"}\");\n+\n+    out.close();\n+  }\n+\n+  private void compile(String name) throws Exception\n+  {\n+    Compiler comp = Compiler.getInstance();\n+    if (verbose)\n+      System.out.println(\"[Compiling class \" + name + \"]\");\n+    comp.setDestination(destination);\n+    comp.compile(name);\n+  }\n+\n+  private static String getPrettyName(Class cls)\n+  {\n+    StringBuffer str = new StringBuffer();\n+    for (int count = 0;; count++)\n+      {\n+\tif (! cls.isArray())\n+\t  {\n+\t    str.append(cls.getName());\n+\t    for (; count > 0; count--)\n+\t      str.append(\"[]\");\n+\t    return (str.toString());\n+\t  }\n+\tcls = cls.getComponentType();\n+      }\n+  }\n \n /**\n  * Sort exceptions so the most general go last.\n  */\n-private Class[] sortExceptions(Class[] except) {\n-\tfor (int i = 0; i < except.length; i++) {\n-\t\tfor (int j = i+1; j < except.length; j++) {\n-\t\t\tif (except[i].isAssignableFrom(except[j])) {\n-\t\t\t\tClass tmp = except[i];\n-\t\t\t\texcept[i] = except[j];\n-\t\t\t\texcept[j] = tmp;\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn (except);\n-}\n+  private Class[] sortExceptions(Class[] except)\n+  {\n+    for (int i = 0; i < except.length; i++)\n+      {\n+\tfor (int j = i + 1; j < except.length; j++)\n+\t  {\n+\t    if (except[i].isAssignableFrom(except[j]))\n+\t      {\n+\t\tClass tmp = except[i];\n+\t\texcept[i] = except[j];\n+\t\texcept[j] = tmp;\n+\t      }\n+\t  }\n+      }\n+    return (except);\n+  }\n \n /**\n  * Process the options until we find the first argument.\n  */\n-private void parseOptions() {\n-\tfor (;;) {\n-\t\tif (next >= args.length || args[next].charAt(0) != '-') {\n-\t\t\tbreak;\n-\t\t}\n-\t\tString arg = args[next];\n-\t\tnext++;\n-\n-\t\t// Accept `--' options if they look long enough.\n-\t\tif (arg.length() > 3 && arg.charAt(0) == '-'\n-\t\t    && arg.charAt(1) == '-')\n-\t\t  arg = arg.substring(1);\n-\n-\t\tif (arg.equals(\"-keep\")) {\n-\t\t\tkeep = true;\n-\t\t}\n-\t\telse if (arg.equals(\"-keepgenerated\")) {\n-\t\t\tkeep = true;\n-\t\t}\n-\t\telse if (arg.equals(\"-v1.1\")) {\n-\t\t\tneed11Stubs = true;\n-\t\t\tneed12Stubs = false;\n-\t\t}\n-\t\telse if (arg.equals(\"-vcompat\")) {\n-\t\t\tneed11Stubs = true;\n-\t\t\tneed12Stubs = true;\n-\t\t}\n-\t\telse if (arg.equals(\"-v1.2\")) {\n-\t\t\tneed11Stubs = false;\n-\t\t\tneed12Stubs = true;\n-\t\t}\n-\t\telse if (arg.equals(\"-g\")) {\n-\t\t}\n-\t\telse if (arg.equals(\"-depend\")) {\n-\t\t}\n-\t\telse if (arg.equals(\"-nowarn\")) {\n-\t\t}\n-\t\telse if (arg.equals(\"-verbose\")) {\n-\t\t\tverbose = true;\n-\t\t}\n-\t\telse if (arg.equals(\"-nocompile\")) {\n-\t\t\tcompile = false;\n-\t\t}\n-\t\telse if (arg.equals(\"-classpath\")) {\n-\t\t\tnext++;\n-\t\t}\n-\t\telse if (arg.equals(\"-help\")) {\n-\t\t\tusage();\n-\t\t}\n-\t\telse if (arg.equals(\"-version\")) {\n-\t\t\tSystem.out.println(\"rmic (\"\n-\t\t\t\t\t   + System.getProperty(\"java.vm.name\")\n-\t\t\t\t\t   + \") \"\n-\t\t\t\t\t   + System.getProperty(\"java.vm.version\"));\n-\t\t\tSystem.out.println();\n-\t\t\tSystem.out.println(\"Copyright 2002 Free Software Foundation, Inc.\");\n-\t\t\tSystem.out.println(\"This is free software; see the source for copying conditions.  There is NO\");\n-\t\t\tSystem.out.println(\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\");\n-\t\t\tSystem.exit(0);\n-\t\t}\n-\t\telse if (arg.equals(\"-d\")) {\n-\t\t\tdestination = args[next];\n-\t\t\tnext++;\n-\t\t}\n-\t\telse if (arg.charAt(1) == 'J') {\n-\t\t}\n-\t\telse {\n-\t\t\terror(\"unrecognized option `\" + arg + \"'\");\n-\t\t}\n-\t}\n-}\n+  private void parseOptions()\n+  {\n+    for (;;)\n+      {\n+\tif (next >= args.length || args[next].charAt(0) != '-')\n+\t  break;\n+\tString arg = args[next];\n+\tnext++;\n+\n+\t// Accept `--' options if they look long enough.\n+\tif (arg.length() > 3 && arg.charAt(0) == '-' && arg.charAt(1) == '-')\n+\t  arg = arg.substring(1);\n+\n+\tif (arg.equals(\"-keep\"))\n+\t  keep = true;\n+\telse if (arg.equals(\"-keepgenerated\"))\n+\t  keep = true;\n+\telse if (arg.equals(\"-v1.1\"))\n+\t  {\n+\t    need11Stubs = true;\n+\t    need12Stubs = false;\n+\t  }\n+\telse if (arg.equals(\"-vcompat\"))\n+\t  {\n+\t    need11Stubs = true;\n+\t    need12Stubs = true;\n+\t  }\n+\telse if (arg.equals(\"-v1.2\"))\n+\t  {\n+\t    need11Stubs = false;\n+\t    need12Stubs = true;\n+\t  }\n+\telse if (arg.equals(\"-g\"))\n+\t  {\n+\t  }\n+\telse if (arg.equals(\"-depend\"))\n+\t  {\n+\t  }\n+\telse if (arg.equals(\"-nowarn\"))\n+\t  {\n+\t  }\n+\telse if (arg.equals(\"-verbose\"))\n+\t  verbose = true;\n+\telse if (arg.equals(\"-nocompile\"))\n+\t  compile = false;\n+\telse if (arg.equals(\"-classpath\"))\n+\t  next++;\n+\telse if (arg.equals(\"-help\"))\n+\t  usage();\n+\telse if (arg.equals(\"-version\"))\n+\t  {\n+\t    System.out.println(\"rmic (\" + System.getProperty(\"java.vm.name\")\n+\t                       + \") \" + System.getProperty(\"java.vm.version\"));\n+\t    System.out.println();\n+\t    System.out.println(\"Copyright 2002 Free Software Foundation, Inc.\");\n+\t    System.out.println(\"This is free software; see the source for copying conditions.  There is NO\");\n+\t    System.out.println(\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\");\n+\t    System.exit(0);\n+\t  }\n+\telse if (arg.equals(\"-d\"))\n+\t  {\n+\t    destination = args[next];\n+\t    next++;\n+\t  }\n+\telse if (arg.charAt(1) == 'J')\n+\t  {\n+\t  }\n+\telse\n+\t  error(\"unrecognized option `\" + arg + \"'\");\n+      }\n+  }\n \n /**\n  * Looks for the java.rmi.Remote interface that that is implemented by theClazz.\n- * @param theClazz the class to look in  \n+ * @param theClazz the class to look in\n  * @return the Remote interface of theClazz or null if theClazz does not implement a Remote interface\n  */\n-private Class getRemoteInterface(Class theClazz)\n-{\n-\tClass[] interfaces = theClazz.getInterfaces();\n-\tfor (int i = 0; i < interfaces.length; i++)\n-\t{\n-\t\tif (java.rmi.Remote.class.isAssignableFrom(interfaces[i]))\n-\t\t{\n-\t\t\treturn interfaces[i];\n-\t\t}\n-\t}\n-\tlogError(\"Class \"+ theClazz.getName()\n-\t\t\t+ \" is not a remote object. It does not implement an interface that is a java.rmi.Remote-interface.\");\n-\treturn null;\n-}\n-\t\n+  private Class getRemoteInterface(Class theClazz)\n+  {\n+    Class[] interfaces = theClazz.getInterfaces();\n+    for (int i = 0; i < interfaces.length; i++)\n+      {\n+\tif (java.rmi.Remote.class.isAssignableFrom(interfaces[i]))\n+\t  return interfaces[i];\n+      }\n+    logError(\"Class \" + theClazz.getName()\n+             + \" is not a remote object. It does not implement an interface that is a java.rmi.Remote-interface.\");\n+    return null;\n+  }\n+\n /**\n  * Prints an error to System.err and increases the error count.\n  * @param theError\n  */\n-private void logError(String theError){\n-\terrorCount++;\n-\tSystem.err.println(\"error:\"+theError);\n-}\n-\n-private static void error(String message) {\n-\tSystem.err.println(\"rmic: \" + message);\n-\tSystem.err.println(\"Try `rmic --help' for more information.\");\n-\tSystem.exit(1);\n-}\n-\n-private static void usage() {\n-\tSystem.out.println(\n-\"Usage: rmic [OPTION]... CLASS...\\n\" +\n-\"\\n\" +\n-\"\t-keep \t\t\tDon't delete any intermediate files\\n\" +\n-\"\t-keepgenerated \t\tSame as -keep\\n\" +\n-\"\t-v1.1\t\t\tJava 1.1 style stubs only\\n\" +\n-\"\t-vcompat\t\tJava 1.1 & Java 1.2 stubs\\n\" +\n-\"\t-v1.2\t\t\tJava 1.2 style stubs only\\n\" +\n-\"\t-g *\t\t\tGenerated debugging information\\n\" +\n-\"\t-depend *\t\tRecompile out-of-date files\\n\" +\n-\"\t-nowarn\t*\t\tSuppress warning messages\\n\" +\n-\"\t-nocompile\t\tDon't compile the generated files\\n\" +\n-\"\t-verbose \t\tOutput what's going on\\n\" +\n-\"\t-classpath <path> *\tUse given path as classpath\\n\" +\n-\"\t-d <directory> \t\tSpecify where to place generated classes\\n\" +\n-\"\t-J<flag> *\t\tPass flag to Java\\n\" +\n-\"\t-help\t\t\tPrint this help, then exit\\n\" +\n-\"\t-version\t\tPrint version number, then exit\\n\" +\n-\"\\n\" +\n-\"  * Option currently ignored\\n\" +\n-\"Long options can be used with `--option' form as well.\"\n-\t);\n-\tSystem.exit(0);\n-}\n-\n-static class MethodRef\n-\timplements Comparable {\n-\n-Method meth;\n-String sig;\n-long hash;\n-\n-MethodRef(Method m) {\n-\tmeth = m;\n-\t// We match on the name - but what about overloading? - XXX\n-\tsig = m.getName();\n-\thash = RMIHashes.getMethodHash(m);\n-}\n-\n-public int compareTo(Object obj) {\n-\tMethodRef that = (MethodRef)obj;\n-\treturn (this.sig.compareTo(that.sig));\n-}\n-\n-}\n-\n+  private void logError(String theError)\n+  {\n+    errorCount++;\n+    System.err.println(\"error:\" + theError);\n+  }\n+\n+  private static void error(String message)\n+  {\n+    System.err.println(\"rmic: \" + message);\n+    System.err.println(\"Try `rmic --help' for more information.\");\n+    System.exit(1);\n+  }\n+\n+  private static void usage()\n+  {\n+    System.out.println(\"Usage: rmic [OPTION]... CLASS...\\n\" + \"\\n\"\n+                       + \"\t-keep \t\t\tDon't delete any intermediate files\\n\"\n+                       + \"\t-keepgenerated \t\tSame as -keep\\n\"\n+                       + \"\t-v1.1\t\t\tJava 1.1 style stubs only\\n\"\n+                       + \"\t-vcompat\t\tJava 1.1 & Java 1.2 stubs\\n\"\n+                       + \"\t-v1.2\t\t\tJava 1.2 style stubs only\\n\"\n+                       + \"\t-g *\t\t\tGenerated debugging information\\n\"\n+                       + \"\t-depend *\t\tRecompile out-of-date files\\n\"\n+                       + \"\t-nowarn\t*\t\tSuppress warning messages\\n\"\n+                       + \"\t-nocompile\t\tDon't compile the generated files\\n\"\n+                       + \"\t-verbose \t\tOutput what's going on\\n\"\n+                       + \"\t-classpath <path> *\tUse given path as classpath\\n\"\n+                       + \"\t-d <directory> \t\tSpecify where to place generated classes\\n\"\n+                       + \"\t-J<flag> *\t\tPass flag to Java\\n\"\n+                       + \"\t-help\t\t\tPrint this help, then exit\\n\"\n+                       + \"\t-version\t\tPrint version number, then exit\\n\" + \"\\n\"\n+                       + \"  * Option currently ignored\\n\"\n+                       + \"Long options can be used with `--option' form as well.\");\n+    System.exit(0);\n+  }\n+\n+  static class MethodRef\n+    implements Comparable\n+  {\n+    Method meth;\n+    String sig;\n+    long hash;\n+\n+    MethodRef(Method m)\n+    {\n+      meth = m;\n+      // We match on the name - but what about overloading? - XXX\n+      sig = m.getName();\n+      hash = RMIHashes.getMethodHash(m);\n+    }\n+\n+    public int compareTo(Object obj)\n+    {\n+      MethodRef that = (MethodRef) obj;\n+      return (this.sig.compareTo(that.sig));\n+    }\n+  }\n }"}]}