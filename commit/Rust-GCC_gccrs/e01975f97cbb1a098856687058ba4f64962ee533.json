{"sha": "e01975f97cbb1a098856687058ba4f64962ee533", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxOTc1Zjk3Y2JiMWEwOTg4NTY2ODcwNThiYTRmNjQ5NjJlZTUzMw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2020-01-31T00:07:53Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2020-02-03T18:23:51Z"}, "message": "rs6000: Update constraint documentation\n\nThis un-documents constraints that cannot (or should not) be used in\ninline assembler.  It also improves markup, and presentation in general.\n\nMore work is needed, but gradual improvement is easier to do.\n\n\t* config/rs6000/constraints.md: Improve documentation.\n/\n\t* doc/md.texi (PowerPC and IBM RS6000): Improve documentation.", "tree": {"sha": "59d2d104902849aa7b96172532a96d30e7699144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59d2d104902849aa7b96172532a96d30e7699144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e01975f97cbb1a098856687058ba4f64962ee533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01975f97cbb1a098856687058ba4f64962ee533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01975f97cbb1a098856687058ba4f64962ee533", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01975f97cbb1a098856687058ba4f64962ee533/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "492c63e5b72c3497160e2c2e113fb91644b3570e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/492c63e5b72c3497160e2c2e113fb91644b3570e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/492c63e5b72c3497160e2c2e113fb91644b3570e"}], "stats": {"total": 353, "additions": 190, "deletions": 163}, "files": [{"sha": "a76e5753e4542cf15fe233488aa581f651746861", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01975f97cbb1a098856687058ba4f64962ee533/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01975f97cbb1a098856687058ba4f64962ee533/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=e01975f97cbb1a098856687058ba4f64962ee533", "patch": "@@ -1,3 +1,7 @@\n+2020-02-03  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000): Improve documentation.\n+\n 2020-01-15  Segher Boessenkool  <segher@kernel.crashing.org>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "4ded82cd6fd5117b8df3c2add52c1d7dc2b9c1dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01975f97cbb1a098856687058ba4f64962ee533/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01975f97cbb1a098856687058ba4f64962ee533/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e01975f97cbb1a098856687058ba4f64962ee533", "patch": "@@ -1,3 +1,7 @@\n+2020-02-03  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/constraints.md: Improve documentation.\n+\n 2020-02-03  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/93548"}, {"sha": "4074a11da2338c79672e6126deb167fe60c01e10", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 88, "deletions": 65, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01975f97cbb1a098856687058ba4f64962ee533/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01975f97cbb1a098856687058ba4f64962ee533/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=e01975f97cbb1a098856687058ba4f64962ee533", "patch": "@@ -21,192 +21,216 @@\n \n ;; Register constraints\n \n+; Actually defined in common.md:\n+; (define_register_constraint \"r\" \"GENERAL_REGS\"\n+;   \"A general purpose register (GPR), @code{r0}@dots{}@code{r31}.\")\n+\n+(define_register_constraint \"b\" \"BASE_REGS\"\n+  \"A base register.  Like @code{r}, but @code{r0} is not allowed, so\n+   @code{r1}@dots{}@code{r31}.\")\n+\n (define_register_constraint \"f\" \"rs6000_constraints[RS6000_CONSTRAINT_f]\"\n-  \"@internal\")\n+  \"A floating point register (FPR), @code{f0}@dots{}@code{f31}.\")\n \n (define_register_constraint \"d\" \"rs6000_constraints[RS6000_CONSTRAINT_d]\"\n-  \"@internal\")\n+  \"A floating point register.  This is the same as @code{f} nowadays;\n+   historically @code{f} was for single-precision and @code{d} was for\n+   double-precision floating point.\")\n \n-(define_register_constraint \"b\" \"BASE_REGS\"\n-  \"@internal\")\n+(define_register_constraint \"v\" \"ALTIVEC_REGS\"\n+  \"An Altivec vector register (VR), @code{v0}@dots{}@code{v31}.\")\n+\n+(define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n+  \"A VSX register (VSR), @code{vs0}@dots{}@code{vs63}.  This is either an\n+  FPR (@code{vs0}@dots{}@code{vs31} are @code{f0}@dots{}@code{f31}) or a VR\n+  (@code{vs32}@dots{}@code{vs63} are @code{v0}@dots{}@code{v31}).\")\n \n (define_register_constraint \"h\" \"SPECIAL_REGS\"\n-  \"@internal\")\n+  \"@internal A special register (@code{vrsave}, @code{ctr}, or @code{lr}).\")\n \n (define_register_constraint \"c\" \"CTR_REGS\"\n-  \"@internal\")\n+  \"The count register, @code{ctr}.\")\n \n (define_register_constraint \"l\" \"LINK_REGS\"\n-  \"@internal\")\n-\n-(define_register_constraint \"v\" \"ALTIVEC_REGS\"\n-  \"@internal\")\n+  \"The link register, @code{lr}.\")\n \n (define_register_constraint \"x\" \"CR0_REGS\"\n-  \"@internal\")\n+  \"Condition register field 0, @code{cr0}.\")\n \n (define_register_constraint \"y\" \"CR_REGS\"\n-  \"@internal\")\n+  \"Any condition register field, @code{cr0}@dots{}@code{cr7}.\")\n \n (define_register_constraint \"z\" \"CA_REGS\"\n-  \"@internal\")\n-\n-;; Use w as a prefix to add VSX modes\n-;; any VSX register\n-(define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n-  \"Any VSX register if the -mvsx option was used or NO_REGS.\")\n+  \"@internal The carry bit, @code{XER[CA]}.\")\n \n ;; NOTE: For compatibility, \"wc\" is reserved to represent individual CR bits.\n ;; It is currently used for that purpose in LLVM.\n \n (define_register_constraint \"we\" \"rs6000_constraints[RS6000_CONSTRAINT_we]\"\n-  \"VSX register if the -mpower9-vector -m64 options were used or NO_REGS.\")\n+  \"@internal Like @code{wa}, if @option{-mpower9-vector} and @option{-m64} are\n+   used; otherwise, @code{NO_REGS}.\")\n \n ;; NO_REGs register constraint, used to merge mov{sd,sf}, since movsd can use\n ;; direct move directly, and movsf can't to move between the register sets.\n ;; There is a mode_attr that resolves to wa for SDmode and wn for SFmode\n-(define_register_constraint \"wn\" \"NO_REGS\" \"No register (NO_REGS).\")\n+(define_register_constraint \"wn\" \"NO_REGS\"\n+  \"@internal No register (@code{NO_REGS}).\")\n \n (define_register_constraint \"wr\" \"rs6000_constraints[RS6000_CONSTRAINT_wr]\"\n-  \"General purpose register if 64-bit instructions are enabled or NO_REGS.\")\n+  \"@internal Like @code{r}, if @option{-mpowerpc64} is used; otherwise,\n+   @code{NO_REGS}.\")\n \n (define_register_constraint \"wx\" \"rs6000_constraints[RS6000_CONSTRAINT_wx]\"\n-  \"Floating point register if the STFIWX instruction is enabled or NO_REGS.\")\n+  \"@internal Like @code{d}, if @option{-mpowerpc-gfxopt} is used; otherwise,\n+   @code{NO_REGS}.\")\n \n (define_register_constraint \"wA\" \"rs6000_constraints[RS6000_CONSTRAINT_wA]\"\n-  \"BASE_REGS if 64-bit instructions are enabled or NO_REGS.\")\n+  \"@internal Like @code{b}, if @option{-mpowerpc64} is used; otherwise,\n+   @code{NO_REGS}.\")\n \n ;; wB needs ISA 2.07 VUPKHSW\n (define_constraint \"wB\"\n-  \"Signed 5-bit constant integer that can be loaded into an altivec register.\"\n+  \"@internal Signed 5-bit constant integer that can be loaded into an\n+   Altivec register.\"\n   (and (match_code \"const_int\")\n-       (and (match_test \"TARGET_P8_VECTOR\")\n-\t    (match_operand 0 \"s5bit_cint_operand\"))))\n+       (match_test \"TARGET_P8_VECTOR\")\n+       (match_operand 0 \"s5bit_cint_operand\")))\n \n (define_constraint \"wD\"\n-  \"Int constant that is the element number of the 64-bit scalar in a vector.\"\n+  \"@internal Int constant that is the element number of the 64-bit scalar\n+   in a vector.\"\n   (and (match_code \"const_int\")\n        (match_test \"TARGET_VSX && (ival == VECTOR_ELEMENT_SCALAR_64BIT)\")))\n \n (define_constraint \"wE\"\n-  \"Vector constant that can be loaded with the XXSPLTIB instruction.\"\n+  \"@internal Vector constant that can be loaded with the XXSPLTIB instruction.\"\n   (match_test \"xxspltib_constant_nosplit (op, mode)\"))\n \n ;; Extended fusion store\n (define_memory_constraint \"wF\"\n-  \"Memory operand suitable for power8 GPR load fusion\"\n+  \"@internal Memory operand suitable for power8 GPR load fusion.\"\n   (match_operand 0 \"fusion_addis_mem_combo_load\"))\n \n (define_constraint \"wL\"\n-  \"Int constant that is the element number mfvsrld accesses in a vector.\"\n+  \"@internal Int constant that is the element number mfvsrld accesses in\n+   a vector.\"\n   (and (match_code \"const_int\")\n-       (and (match_test \"TARGET_DIRECT_MOVE_128\")\n-\t    (match_test \"(ival == VECTOR_ELEMENT_MFVSRLD_64BIT)\"))))\n+       (match_test \"TARGET_DIRECT_MOVE_128\")\n+       (match_test \"(ival == VECTOR_ELEMENT_MFVSRLD_64BIT)\")))\n \n ;; Generate the XXORC instruction to set a register to all 1's\n (define_constraint \"wM\"\n-  \"Match vector constant with all 1's if the XXLORC instruction is available\"\n+  \"@internal Match vector constant with all 1's if the XXLORC instruction\n+   is available.\"\n   (and (match_test \"TARGET_P8_VECTOR\")\n        (match_operand 0 \"all_ones_constant\")))\n \n ;; ISA 3.0 vector d-form addresses\n (define_memory_constraint \"wO\"\n-  \"Memory operand suitable for the ISA 3.0 vector d-form instructions.\"\n+  \"@internal Memory operand suitable for the ISA 3.0 vector d-form instructions.\"\n   (match_operand 0 \"vsx_quad_dform_memory_operand\"))\n \n ;; Lq/stq validates the address for load/store quad\n (define_memory_constraint \"wQ\"\n-  \"Memory operand suitable for the load/store quad instructions\"\n+  \"@internal Memory operand suitable for the load/store quad instructions.\"\n   (match_operand 0 \"quad_memory_operand\"))\n \n (define_constraint \"wS\"\n-  \"Vector constant that can be loaded with XXSPLTIB & sign extension.\"\n+  \"@internal Vector constant that can be loaded with XXSPLTIB & sign extension.\"\n   (match_test \"xxspltib_constant_split (op, mode)\"))\n \n ;; ISA 3.0 DS-form instruction that has the bottom 2 bits 0 and no update form.\n ;; Used by LXSD/STXSD/LXSSP/STXSSP.  In contrast to \"Y\", the multiple-of-four\n ;; offset is enforced for 32-bit too.\n (define_memory_constraint \"wY\"\n-  \"Offsettable memory operand, with bottom 2 bits 0\"\n+  \"@internal A memory operand for a DS-form instruction.\"\n   (and (match_code \"mem\")\n        (not (match_test \"update_address_mem (op, mode)\"))\n        (match_test \"mem_operand_ds_form (op, mode)\")))\n \n ;; Altivec style load/store that ignores the bottom bits of the address\n (define_memory_constraint \"wZ\"\n-  \"Indexed or indirect memory operand, ignoring the bottom 4 bits\"\n+  \"@internal An indexed or indirect memory operand, ignoring the bottom 4 bits.\"\n   (match_operand 0 \"altivec_indexed_or_indirect_operand\"))\n \n ;; Integer constraints\n \n (define_constraint \"I\"\n-  \"A signed 16-bit constant\"\n+  \"A signed 16-bit constant.\"\n   (and (match_code \"const_int\")\n        (match_test \"((unsigned HOST_WIDE_INT) ival + 0x8000) < 0x10000\")))\n \n (define_constraint \"J\"\n-  \"high-order 16 bits nonzero\"\n+  \"An unsigned 16-bit constant shifted left 16 bits (use @code{L} instead\n+   for @code{SImode} constants).\"\n   (and (match_code \"const_int\")\n        (match_test \"(ival & (~ (unsigned HOST_WIDE_INT) 0xffff0000)) == 0\")))\n \n (define_constraint \"K\"\n-  \"low-order 16 bits nonzero\"\n+  \"An unsigned 16-bit constant.\"\n   (and (match_code \"const_int\")\n        (match_test \"(ival & (~ (HOST_WIDE_INT) 0xffff)) == 0\")))\n \n (define_constraint \"L\"\n-  \"signed 16-bit constant shifted left 16 bits\"\n+  \"A signed 16-bit constant shifted left 16 bits.\"\n   (and (match_code \"const_int\")\n        (match_test \"((ival & 0xffff) == 0\n \t\t      && (ival >> 31 == -1 || ival >> 31 == 0))\")))\n \n (define_constraint \"M\"\n-  \"constant greater than 31\"\n+  \"@internal A constant greater than 31.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival > 31\")))\n \n (define_constraint \"N\"\n-  \"positive constant that is an exact power of two\"\n+  \"@internal An exact power of two.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival > 0 && exact_log2 (ival) >= 0\")))\n \n (define_constraint \"O\"\n-  \"constant zero\"\n+  \"@internal The integer constant zero.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival == 0\")))\n \n (define_constraint \"P\"\n-  \"constant whose negation is signed 16-bit constant\"\n+  \"@internal A constant whose negation is a signed 16-bit constant.\"\n   (and (match_code \"const_int\")\n        (match_test \"((- (unsigned HOST_WIDE_INT) ival) + 0x8000) < 0x10000\")))\n \n ;; 34-bit signed integer constant\n (define_constraint \"eI\"\n-  \"34-bit constant integer that can be loaded with PADDI\"\n+  \"A signed 34-bit integer constant if prefixed instructions are supported.\"\n   (match_operand 0 \"cint34_operand\"))\n \n ;; Floating-point constraints.  These two are defined so that insn\n ;; length attributes can be calculated exactly.\n \n (define_constraint \"G\"\n-  \"Constant that can be copied into GPR with two insns for DF/DD\n-   and one for SF/SD.\"\n+  \"@internal A floating point constant that can be loaded into a register\n+   with one instruction per word.\"\n   (and (match_code \"const_double\")\n        (match_test \"num_insns_constant (op, mode)\n \t\t    == (mode == SFmode || mode == SDmode ? 1 : 2)\")))\n \n (define_constraint \"H\"\n-  \"DF/DD constant that takes three insns.\"\n+  \"@internal A floating point constant that can be loaded into a register\n+   using three instructions.\"\n   (and (match_code \"const_double\")\n        (match_test \"num_insns_constant (op, mode) == 3\")))\n \n ;; Memory constraints\n \n+; Actually defined in common.md:\n+; (define_memory_constraint \"m\"\n+;   \"A memory operand.\"\n+\n (define_memory_constraint \"es\"\n-  \"A ``stable'' memory operand; that is, one which does not include any\n-automodification of the base register.  Unlike @samp{m}, this constraint\n-can be used in @code{asm} statements that might access the operand\n-several times, or that might not access it at all.\"\n+  \"@internal\n+   A ``stable'' memory operand; that is, one which does not include any\n+   automodification of the base register.  This used to be useful when\n+   @code{m} allowed automodification of the base register, but as those\n+   are now only allowed when @code{<} or @code{>} is used, @code{es} is\n+   basically the same as @code{m} without @code{<} and @code{>}.\"\n   (and (match_code \"mem\")\n        (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n \n@@ -216,36 +240,35 @@ several times, or that might not access it at all.\"\n        (match_test \"REG_P (XEXP (op, 0))\")))\n \n (define_memory_constraint \"Y\"\n-  \"memory operand for 8 byte and 16 byte gpr load/store\"\n+  \"@internal A memory operand for a DQ-form instruction.\"\n   (and (match_code \"mem\")\n        (match_test \"mem_operand_gpr (op, mode)\")))\n \n (define_memory_constraint \"Z\"\n-  \"Memory operand that is an indexed or indirect from a register (it is\n-usually better to use @samp{m} or @samp{es} in @code{asm} statements)\"\n+  \"A memory operand accessed with indexed or indirect addressing.\"\n   (match_operand 0 \"indexed_or_indirect_operand\"))\n \n ;; Address constraints\n \n-(define_address_constraint \"a\"\n-  \"Indexed or indirect address operand\"\n-  (match_operand 0 \"indexed_or_indirect_address\"))\n-\n (define_constraint \"R\"\n-  \"AIX TOC entry\"\n+  \"@internal An AIX TOC entry.\"\n   (match_test \"legitimate_constant_pool_address_p (op, QImode, false)\"))\n \n+(define_address_constraint \"a\"\n+  \"An indexed or indirect address.\"\n+  (match_operand 0 \"indexed_or_indirect_address\"))\n+\n ;; General constraints\n \n (define_constraint \"U\"\n-  \"V.4 small data reference\"\n+  \"@internal A V.4 small data reference.\"\n   (and (match_test \"DEFAULT_ABI == ABI_V4\")\n        (match_test \"small_data_operand (op, mode)\")))\n \n (define_constraint \"W\"\n-  \"vector constant that does not require memory\"\n+  \"@internal A vector constant that does not require memory.\"\n   (match_operand 0 \"easy_vector_constant\"))\n \n (define_constraint \"j\"\n-  \"Zero vector constant\"\n+  \"@internal The zero vector constant.\"\n   (match_test \"op == const0_rtx || op == CONST0_RTX (mode)\"))"}, {"sha": "288a3a3201b84fd10c8d3112e74d64d47f538939", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 94, "deletions": 98, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01975f97cbb1a098856687058ba4f64962ee533/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01975f97cbb1a098856687058ba4f64962ee533/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=e01975f97cbb1a098856687058ba4f64962ee533", "patch": "@@ -3187,86 +3187,85 @@ A memory reference that is encoded within the opcode.\n \n @item PowerPC and IBM RS6000---@file{config/rs6000/constraints.md}\n @table @code\n-@item b\n-Address base register\n+@item r\n+A general purpose register (GPR), @code{r0}@dots{}@code{r31}.\n \n-@item d\n-Floating point register (containing 64-bit value)\n+@item b\n+A base register.  Like @code{r}, but @code{r0} is not allowed, so\n+@code{r1}@dots{}@code{r31}.\n \n @item f\n-Floating point register (containing 32-bit value)\n+A floating point register (FPR), @code{f0}@dots{}@code{f31}.\n+\n+@item d\n+A floating point register.  This is the same as @code{f} nowadays;\n+historically @code{f} was for single-precision and @code{d} was for\n+double-precision floating point.\n \n @item v\n-Altivec vector register\n+An Altivec vector register (VR), @code{v0}@dots{}@code{v31}.\n \n @item wa\n-Any VSX register if the @option{-mvsx} option was used or NO_REGS.\n+A VSX register (VSR), @code{vs0}@dots{}@code{vs63}.  This is either an\n+FPR (@code{vs0}@dots{}@code{vs31} are @code{f0}@dots{}@code{f31}) or a VR\n+(@code{vs32}@dots{}@code{vs63} are @code{v0}@dots{}@code{v31}).\n \n-When using the register constraint @code{wa}\n-that takes VSX registers, you must use @code{%x<n>} in the template so\n-that the correct register is used.  Otherwise the register number\n-output in the assembly file will be incorrect if an Altivec register\n-is an operand of a VSX instruction that expects VSX register\n-numbering.\n+When using @code{wa}, you should use the @code{%x} output modifier, so that\n+the correct register number is printed.  For example:\n \n @smallexample\n asm (\"xvadddp %x0,%x1,%x2\"\n      : \"=wa\" (v1)\n      : \"wa\" (v2), \"wa\" (v3));\n @end smallexample\n \n-@noindent\n-is correct, but:\n-\n-@smallexample\n-asm (\"xvadddp %0,%1,%2\" \n-     : \"=wa\" (v1) \n-     : \"wa\" (v2), \"wa\" (v3));\n-@end smallexample\n-\n-@noindent\n-is not correct.\n-\n-If an instruction only takes Altivec registers, you do not want to use\n-@code{%x<n>}.\n+You should not use @code{%x} for @code{v} operands:\n \n @smallexample\n asm (\"xsaddqp %0,%1,%2\"\n      : \"=v\" (v1)\n      : \"v\" (v2), \"v\" (v3));\n @end smallexample\n \n-@noindent\n-is correct because the @code{xsaddqp} instruction only takes Altivec\n-registers, while:\n+@ifset INTERNALS\n+@item h\n+A special register (@code{vrsave}, @code{ctr}, or @code{lr}).\n+@end ifset\n \n-@smallexample\n-asm (\"xsaddqp %x0,%x1,%x2\" \n-     : \"=v\" (v1) \n-     : \"v\" (v2), \"v\" (v3));\n-@end smallexample\n+@item c\n+The count register, @code{ctr}.\n \n-@noindent\n-is incorrect.\n+@item l\n+The link register, @code{lr}.\n+\n+@item x\n+Condition register field 0, @code{cr0}.\n+\n+@item y\n+Any condition register field, @code{cr0}@dots{}@code{cr7}.\n+\n+@ifset INTERNALS\n+@item z\n+The carry bit, @code{XER[CA]}.\n \n @item we\n-VSX register if the @option{-mcpu=power9} and @option{-m64} options\n-were used or NO_REGS.\n+Like @code{wa}, if @option{-mpower9-vector} and @option{-m64} are used;\n+otherwise, @code{NO_REGS}.\n \n @item wn\n-No register (NO_REGS).\n+No register (@code{NO_REGS}).\n \n @item wr\n-General purpose register if 64-bit instructions are enabled or NO_REGS.\n+Like @code{r}, if @option{-mpowerpc64} is used; otherwise, @code{NO_REGS}.\n \n @item wx\n-Floating point register if the STFIWX instruction is enabled or NO_REGS.\n+Like @code{d}, if @option{-mpowerpc-gfxopt} is used; otherwise, @code{NO_REGS}.\n \n @item wA\n-Address base register if 64-bit instructions are enabled or NO_REGS.\n+Like @code{b}, if @option{-mpowerpc64} is used; otherwise, @code{NO_REGS}.\n \n @item wB\n-Signed 5-bit constant integer that can be loaded into an altivec register.\n+Signed 5-bit constant integer that can be loaded into an Altivec register.\n \n @item wD\n Int constant that is the element number of the 64-bit scalar in a vector.\n@@ -3275,90 +3274,78 @@ Int constant that is the element number of the 64-bit scalar in a vector.\n Vector constant that can be loaded with the XXSPLTIB instruction.\n \n @item wF\n-Memory operand suitable for power8 GPR load fusion\n-\n-@item wG\n-Memory operand suitable for TOC fusion memory references.\n+Memory operand suitable for power8 GPR load fusion.\n \n @item wL\n-Int constant that is the element number that the MFVSRLD instruction.\n-targets.\n+Int constant that is the element number mfvsrld accesses in a vector.\n \n @item wM\n Match vector constant with all 1's if the XXLORC instruction is available.\n \n @item wO\n-A memory operand suitable for the ISA 3.0 vector d-form instructions.\n+Memory operand suitable for the ISA 3.0 vector d-form instructions.\n \n @item wQ\n-A memory address that will work with the @code{lq} and @code{stq}\n-instructions.\n+Memory operand suitable for the load/store quad instructions.\n \n @item wS\n Vector constant that can be loaded with XXSPLTIB & sign extension.\n \n-@item h\n-@samp{VRSAVE}, @samp{CTR}, or @samp{LINK} register\n-\n-@item c\n-@samp{CTR} register\n-\n-@item l\n-@samp{LINK} register\n+@item wY\n+A memory operand for a DS-form instruction.\n \n-@item x\n-@samp{CR} register (condition register) number 0\n-\n-@item y\n-@samp{CR} register (condition register)\n-\n-@item z\n-@samp{XER[CA]} carry bit (part of the XER register)\n+@item wZ\n+An indexed or indirect memory operand, ignoring the bottom 4 bits.\n+@end ifset\n \n @item I\n-Signed 16-bit constant\n+A signed 16-bit constant.\n \n @item J\n-Unsigned 16-bit constant shifted left 16 bits (use @samp{L} instead for\n-@code{SImode} constants)\n+An unsigned 16-bit constant shifted left 16 bits (use @code{L} instead\n+for @code{SImode} constants).\n \n @item K\n-Unsigned 16-bit constant\n+An unsigned 16-bit constant.\n \n @item L\n-Signed 16-bit constant shifted left 16 bits\n+A signed 16-bit constant shifted left 16 bits.\n \n+@ifset INTERNALS\n @item M\n-Constant larger than 31\n+An integer constant greater than 31.\n \n @item N\n-Exact power of 2\n+An exact power of 2.\n \n @item O\n-Zero\n+The integer constant zero.\n \n @item P\n-Constant whose negation is a signed 16-bit constant\n+A constant whose negation is a signed 16-bit constant.\n+@end ifset\n \n @item eI\n-Signed 34-bit integer constant if prefixed instructions are supported.\n+A signed 34-bit integer constant if prefixed instructions are supported.\n \n+@ifset INTERNALS\n @item G\n-Floating point constant that can be loaded into a register with one\n-instruction per word\n+A floating point constant that can be loaded into a register with one\n+instruction per word.\n \n @item H\n-Integer/Floating point constant that can be loaded into a register using\n-three instructions\n+A floating point constant that can be loaded into a register using\n+three instructions.\n+@end ifset\n \n @item m\n-Memory operand.\n+A memory operand.\n Normally, @code{m} does not allow addresses that update the base register.\n-If @samp{<} or @samp{>} constraint is also used, they are allowed and\n+If the @code{<} or @code{>} constraint is also used, they are allowed and\n therefore on PowerPC targets in that case it is only safe\n-to use @samp{m<>} in an @code{asm} statement if that @code{asm} statement\n+to use @code{m<>} in an @code{asm} statement if that @code{asm} statement\n accesses the operand exactly once.  The @code{asm} statement must also\n-use @samp{%U@var{<opno>}} as a placeholder for the ``update'' flag in the\n+use @code{%U@var{<opno>}} as a placeholder for the ``update'' flag in the\n corresponding load or store instruction.  For example:\n \n @smallexample\n@@ -3373,35 +3360,44 @@ asm (\"st %1,%0\" : \"=m<>\" (mem) : \"r\" (val));\n \n is not.\n \n+@ifset INTERNALS\n @item es\n A ``stable'' memory operand; that is, one which does not include any\n automodification of the base register.  This used to be useful when\n-@samp{m} allowed automodification of the base register, but as those are now only\n-allowed when @samp{<} or @samp{>} is used, @samp{es} is basically the same\n-as @samp{m} without @samp{<} and @samp{>}.\n+@code{m} allowed automodification of the base register, but as those\n+are now only allowed when @code{<} or @code{>} is used, @code{es} is\n+basically the same as @code{m} without @code{<} and @code{>}.\n+@end ifset\n \n @item Q\n A memory operand addressed by just a base register.\n \n+@ifset INTERNALS\n+@item Y\n+A memory operand for a DQ-form instruction.\n+@end ifset\n+\n @item Z\n-Memory operand that is an indexed or indirect from a register (it is\n-usually better to use @samp{m} or @samp{es} in @code{asm} statements)\n+A memory operand accessed with indexed or indirect addressing.\n \n+@ifset INTERNALS\n @item R\n-AIX TOC entry\n+An AIX TOC entry.\n+@end ifset\n \n @item a\n-Address operand that is an indexed or indirect from a register (@samp{p} is\n-preferable for @code{asm} statements)\n+An indexed or indirect address.\n \n+@ifset INTERNALS\n @item U\n-System V Release 4 small data area reference\n+A V.4 small data reference.\n \n @item W\n-Vector constant that does not require memory\n+A vector constant that does not require memory.\n \n @item j\n-Vector constant that is all zeros.\n+The zero vector constant.\n+@end ifset\n \n @end table\n "}]}