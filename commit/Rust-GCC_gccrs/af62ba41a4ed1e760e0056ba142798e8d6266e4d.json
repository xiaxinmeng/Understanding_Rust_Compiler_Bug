{"sha": "af62ba41a4ed1e760e0056ba142798e8d6266e4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2MmJhNDFhNGVkMWU3NjBlMDA1NmJhMTQyNzk4ZThkNjI2NmU0ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T08:42:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T08:44:00Z"}, "message": "Fix internal error on problematic renaming\n\nThis is an internal renaming generated for a generalized loop iteration\nmade on a tagged record type with predicate, and gigi cannot use the most\nefficient way of implementing renamings because the renamed object is an\nexpression with a non-empty Actions list.\n\ngcc/ada/ChangeLog\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add new local variable\n\tand use it throughout the function.\n\t<E_Variable>: Rename local variable and adjust accordingly.  In the\n\tcase of a renaming, materialize the entity if the renamed object is\n\tan N_Expression_With_Actions node.\n\t<E_Procedure>: Use Alias accessor function consistently.\n\ngcc/testsuite/ChangeLog\n\t* gnat.dg/renaming16.adb: New test.\n\t* gnat.dg/renaming16_pkg.ads: New helper.", "tree": {"sha": "2f78fc1355fd67fd0cf40630b31b57d2b8726d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f78fc1355fd67fd0cf40630b31b57d2b8726d24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af62ba41a4ed1e760e0056ba142798e8d6266e4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af62ba41a4ed1e760e0056ba142798e8d6266e4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af62ba41a4ed1e760e0056ba142798e8d6266e4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af62ba41a4ed1e760e0056ba142798e8d6266e4d/comments", "author": null, "committer": null, "parents": [{"sha": "0949185aed5830fe40bd4fa4a80b21bc90410406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0949185aed5830fe40bd4fa4a80b21bc90410406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0949185aed5830fe40bd4fa4a80b21bc90410406"}], "stats": {"total": 160, "additions": 114, "deletions": 46}, "files": [{"sha": "09f81ba2486b94dd8ec9b446846b41f9513b3fd3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=af62ba41a4ed1e760e0056ba142798e8d6266e4d", "patch": "@@ -1,3 +1,12 @@\n+2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add new local variable\n+\tand use it throughout the function.\n+\t<E_Variable>: Rename local variable and adjust accordingly.  In the\n+\tcase of a renaming, materialize the entity if the renamed object is\n+\tan N_Expression_With_Actions node.\n+\t<E_Procedure>: Use Alias accessor function consistently.\n+\n 2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c (get_array_bit_stride): Get to the debug type,"}, {"sha": "94ea05de14fb95978e54df5c0de30f66f11f9337", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=af62ba41a4ed1e760e0056ba142798e8d6266e4d", "patch": "@@ -280,6 +280,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n {\n   /* The construct that declared the entity.  */\n   const Node_Id gnat_decl = Declaration_Node (gnat_entity);\n+  /* The object that the entity renames, if any.  */\n+  const Entity_Id gnat_renamed_obj = Renamed_Object (gnat_entity);\n   /* The kind of the entity.  */\n   const Entity_Kind kind = Ekind (gnat_entity);\n   /* True if this is a type.  */\n@@ -327,7 +329,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n   /* Contains the list of attributes directly attached to the entity.  */\n   struct attrib *attr_list = NULL;\n \n-  /* Since a use of an Itype is a definition, process it as such if it is in\n+  /* Since a use of an itype is a definition, process it as such if it is in\n      the main unit, except for E_Access_Subtype because it's actually a use\n      of its base type, see below.  */\n   if (!definition\n@@ -375,7 +377,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \t}\n \n-      /* This abort means the Itype has an incorrect scope, i.e. that its\n+      /* This abort means the itype has an incorrect scope, i.e. that its\n \t scope does not correspond to the subprogram it is first used in.  */\n       gcc_unreachable ();\n     }\n@@ -448,6 +450,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n      If we are not defining it, it must be a type or an entity that is defined\n      elsewhere or externally, otherwise we should have defined it already.\n \n+     In other words, the failure of this assertion typically arises when a\n+     reference to an entity (type or object) is made before its declaration,\n+     either directly or by means of a freeze node which is incorrectly placed.\n+     This can also happen for an entity referenced out of context, for example\n+     a parameter outside of the subprogram where it is declared.  GNAT_ENTITY\n+     is the N_Defining_Identifier of the entity, the problematic N_Identifier\n+     being the argument passed to Identifier_to_gnu in the parent frame.\n+\n      One exception is for an entity, typically an inherited operation, which is\n      a local alias for the parent's operation.  It is neither defined, since it\n      is an inherited operation, nor public, since it is declared in the current\n@@ -636,7 +646,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  && !gnu_expr\n \t  && No (Address_Clause (gnat_entity))\n \t  && !No_Initialization (gnat_decl)\n-\t  && No (Renamed_Object (gnat_entity)))\n+\t  && No (gnat_renamed_obj))\n \t{\n \t  gnu_decl = error_mark_node;\n \t  saved = true;\n@@ -692,7 +702,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     && !Treat_As_Volatile (gnat_entity)\n \t     && (((Nkind (gnat_decl) == N_Object_Declaration)\n \t\t  && Present (Expression (gnat_decl)))\n-\t\t || Present (Renamed_Object (gnat_entity))\n+\t\t || Present (gnat_renamed_obj)\n \t\t || imported_p));\n \tbool inner_const_flag = const_flag;\n \tbool static_flag = Is_Statically_Allocated (gnat_entity);\n@@ -704,20 +714,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tbool mutable_p = false;\n \tbool used_by_ref = false;\n \ttree gnu_ext_name = NULL_TREE;\n-\ttree renamed_obj = NULL_TREE;\n+\ttree gnu_renamed_obj = NULL_TREE;\n \ttree gnu_ada_size = NULL_TREE;\n \n \t/* We need to translate the renamed object even though we are only\n \t   referencing the renaming.  But it may contain a call for which\n \t   we'll generate a temporary to hold the return value and which\n \t   is part of the definition of the renaming, so discard it.  */\n-\tif (Present (Renamed_Object (gnat_entity)) && !definition)\n+\tif (Present (gnat_renamed_obj) && !definition)\n \t  {\n \t    if (kind == E_Exception)\n \t      gnu_expr = gnat_to_gnu_entity (Renamed_Entity (gnat_entity),\n \t\t\t\t\t     NULL_TREE, false);\n \t    else\n-\t      gnu_expr = gnat_to_gnu_external (Renamed_Object (gnat_entity));\n+\t      gnu_expr = gnat_to_gnu_external (gnat_renamed_obj);\n \t  }\n \n \t/* Get the type after elaborating the renamed object.  */\n@@ -764,7 +774,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t/* Reject non-renamed objects whose type is an unconstrained array or\n \t   any object whose type is a dummy type or void.  */\n \tif ((TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n-\t     && No (Renamed_Object (gnat_entity)))\n+\t     && No (gnat_renamed_obj))\n \t    || TYPE_IS_DUMMY_P (gnu_type)\n \t    || TREE_CODE (gnu_type) == VOID_TYPE)\n \t  {\n@@ -806,7 +816,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   initializing expression, in which case we can get the size from\n \t   that.  Note that the resulting size may still be a variable, so\n \t   this may end up with an indirect allocation.  */\n-\tif (No (Renamed_Object (gnat_entity))\n+\tif (No (gnat_renamed_obj)\n \t    && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n \t  {\n \t    if (gnu_expr && kind == E_Constant)\n@@ -882,7 +892,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t && integer_zerop (TYPE_SIZE (gnu_type))\n \t\t && !TREE_OVERFLOW (TYPE_SIZE (gnu_type))))\n \t    && !Is_Constr_Subt_For_UN_Aliased (gnat_type)\n-\t    && No (Renamed_Object (gnat_entity))\n+\t    && No (gnat_renamed_obj)\n \t    && No (Address_Clause (gnat_entity)))\n \t  gnu_size = bitsize_unit_node;\n \n@@ -901,7 +911,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    && !Is_Constr_Subt_For_UN_Aliased (gnat_type)\n \t\t    && !Is_Exported (gnat_entity)\n \t\t    && !imported_p\n-\t\t    && No (Renamed_Object (gnat_entity))\n+\t\t    && No (gnat_renamed_obj)\n \t\t    && No (Address_Clause (gnat_entity))))\n \t    && TREE_CODE (TYPE_SIZE (gnu_type)) == INTEGER_CST)\n \t  align = promote_object_alignment (gnu_type, gnat_entity);\n@@ -945,7 +955,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   because we don't support dynamic alignment.  */\n \tif (align == 0\n \t    && Ekind (gnat_type) == E_Class_Wide_Subtype\n-\t    && No (Renamed_Object (gnat_entity))\n+\t    && No (gnat_renamed_obj)\n \t    && No (Address_Clause (gnat_entity)))\n \t  align = get_target_system_allocator_alignment () * BITS_PER_UNIT;\n \n@@ -961,7 +971,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tif (align == 0\n \t    && MINIMUM_ATOMIC_ALIGNMENT > TYPE_ALIGN (gnu_type)\n \t    && !FLOAT_TYPE_P (gnu_type)\n-\t    && !const_flag && No (Renamed_Object (gnat_entity))\n+\t    && !const_flag && No (gnat_renamed_obj)\n \t    && !imported_p && No (Address_Clause (gnat_entity))\n \t    && kind != E_Out_Parameter\n \t    && (gnu_size ? TREE_CODE (gnu_size) == INTEGER_CST\n@@ -1013,7 +1023,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   renaming can be applied to objects that are not names in Ada.\n \t   This processing needs to be applied to the raw expression so as\n \t   to make it more likely to rename the underlying object.  */\n-\tif (Present (Renamed_Object (gnat_entity)))\n+\tif (Present (gnat_renamed_obj))\n \t  {\n \t    /* If the renamed object had padding, strip off the reference to\n \t       the inner object and reset our type.  */\n@@ -1083,8 +1093,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t       the elaborated renamed expression for the renaming.  But this\n \t       means that the caller is responsible for evaluating the address\n \t       of the renaming in the correct place for the definition case to\n-\t       instantiate the SAVE_EXPRs.  */\n-\t    else if (!Materialize_Entity (gnat_entity))\n+\t       instantiate the SAVE_EXPRs.  But we cannot use this mechanism if\n+\t       the renamed object is an N_Expression_With_Actions because this\n+\t       would fail the assertion below.  */\n+\t    else if (!Materialize_Entity (gnat_entity)\n+\t\t     && Nkind (gnat_renamed_obj) != N_Expression_With_Actions)\n \t      {\n \t\ttree init = NULL_TREE;\n \n@@ -1140,23 +1153,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\tinner_const_flag = TREE_READONLY (gnu_expr);\n \t\tgnu_size = NULL_TREE;\n \n-\t\trenamed_obj\n+\t\tgnu_renamed_obj\n \t\t  = elaborate_reference (gnu_expr, gnat_entity, definition,\n \t\t\t\t\t &init);\n \n \t\t/* The expression needs to be marked manually because it will\n \t\t   likely be shared, even for a definition since the ADDR_EXPR\n \t\t   built below can cause the first few nodes to be folded.  */\n \t\tif (global_bindings_p ())\n-\t\t  MARK_VISITED (renamed_obj);\n+\t\t  MARK_VISITED (gnu_renamed_obj);\n \n \t\tif (type_annotate_only\n-\t\t    && TREE_CODE (renamed_obj) == ERROR_MARK)\n+\t\t    && TREE_CODE (gnu_renamed_obj) == ERROR_MARK)\n \t\t  gnu_expr = NULL_TREE;\n \t\telse\n \t\t  {\n \t\t    gnu_expr\n-\t\t      = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n+\t\t      = build_unary_op (ADDR_EXPR, gnu_type, gnu_renamed_obj);\n \t\t    if (init)\n \t\t      gnu_expr\n \t\t\t= build_compound_expr (TREE_TYPE (gnu_expr), init,\n@@ -1525,7 +1538,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t     imported_p || !definition, static_flag,\n \t\t\t     volatile_flag, artificial_p,\n \t\t\t     debug_info_p && definition, attr_list,\n-\t\t\t     gnat_entity, !renamed_obj);\n+\t\t\t     gnat_entity, !gnu_renamed_obj);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -1554,8 +1567,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  DECL_LOOP_PARM_P (gnu_decl) = 1;\n \n \t/* If this is a renaming pointer, attach the renamed object to it.  */\n-\tif (renamed_obj)\n-\t  SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n+\tif (gnu_renamed_obj)\n+\t  SET_DECL_RENAMED_OBJECT (gnu_decl, gnu_renamed_obj);\n \n \t/* If this is a constant and we are defining it or it generates a real\n \t   symbol at the object level and we are referencing it, we may want\n@@ -3396,7 +3409,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t    /* If there are entities in the chain corresponding to components\n \t       that we did not elaborate, ensure we elaborate their types if\n-\t       they are Itypes.  */\n+\t       they are itypes.  */\n \t    for (gnat_temp = First_Entity (gnat_entity);\n \t\t Present (gnat_temp);\n \t\t gnat_temp = Next_Entity (gnat_temp))\n@@ -3482,7 +3495,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t  /* When the subtype has discriminants and these discriminants affect\n \t     the initial shape it has inherited, factor them in.  But for an\n-\t     Unchecked_Union (it must be an Itype), just return the type.  */\n+\t     Unchecked_Union (it must be an itype), just return the type.  */\n \t  if (Has_Discriminants (gnat_entity)\n \t      && Stored_Constraint (gnat_entity) != No_Elist\n \t      && Is_Record_Type (gnat_base_type)\n@@ -3970,41 +3983,37 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   of its type, so we must elaborate that type now.  */\n \tif (Present (Alias (gnat_entity)))\n \t  {\n-\t    const Entity_Id gnat_renamed = Renamed_Object (gnat_entity);\n+\t    const Entity_Id gnat_alias = Alias (gnat_entity);\n \n-\t    if (Ekind (Alias (gnat_entity)) == E_Enumeration_Literal)\n-\t      gnat_to_gnu_entity (Etype (Alias (gnat_entity)), NULL_TREE,\n-\t\t\t\t  false);\n+\t    if (Ekind (gnat_alias) == E_Enumeration_Literal)\n+\t      gnat_to_gnu_entity (Etype (gnat_alias), NULL_TREE, false);\n \n-\t    gnu_decl\n-\t      = gnat_to_gnu_entity (Alias (gnat_entity), gnu_expr, false);\n+\t    gnu_decl = gnat_to_gnu_entity (gnat_alias, gnu_expr, false);\n \n-\t    /* Elaborate any Itypes in the parameters of this entity.  */\n+\t    /* Elaborate any itypes in the parameters of this entity.  */\n \t    for (gnat_temp = First_Formal_With_Extras (gnat_entity);\n \t\t Present (gnat_temp);\n \t\t gnat_temp = Next_Formal_With_Extras (gnat_temp))\n \t      if (Is_Itype (Etype (gnat_temp)))\n \t\tgnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, false);\n \n \t    /* Materialize renamed subprograms in the debugging information\n-\t       when the renamed object is compile time known.  We can consider\n+\t       when the renamed object is known at compile time; we consider\n \t       such renamings as imported declarations.\n \n-\t       Because the parameters in generics instantiation are generally\n-\t       materialized as renamings, we ofter end up having both the\n+\t       Because the parameters in generic instantiations are generally\n+\t       materialized as renamings, we often end up having both the\n \t       renamed subprogram and the renaming in the same context and with\n-\t       the same name: in this case, renaming is both useless debug-wise\n+\t       the same name; in this case, renaming is both useless debug-wise\n \t       and potentially harmful as name resolution in the debugger could\n \t       return twice the same entity!  So avoid this case.  */\n-\t    if (debug_info_p && !artificial_p\n+\t    if (debug_info_p\n+\t\t&& !artificial_p\n+\t\t&& (Ekind (gnat_alias) == E_Function\n+\t\t    || Ekind (gnat_alias) == E_Procedure)\n \t\t&& !(get_debug_scope (gnat_entity, NULL)\n-\t\t       == get_debug_scope (gnat_renamed, NULL)\n-\t\t     && Name_Equals (Chars (gnat_entity),\n-\t\t\t\t     Chars (gnat_renamed)))\n-\t\t&& Present (gnat_renamed)\n-\t\t&& (Ekind (gnat_renamed) == E_Function\n-\t\t    || Ekind (gnat_renamed) == E_Procedure)\n-\t\t&& gnu_decl\n+\t\t     == get_debug_scope (gnat_alias, NULL)\n+\t\t     && Name_Equals (Chars (gnat_entity), Chars (gnat_alias)))\n \t\t&& TREE_CODE (gnu_decl) == FUNCTION_DECL)\n \t      {\n \t\ttree decl = build_decl (input_location, IMPORTED_DECL,\n@@ -4847,7 +4856,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     force_global--;\n \n   /* If this is a packed array type whose original array type is itself\n-     an Itype without freeze node, make sure the latter is processed.  */\n+     an itype without freeze node, make sure the latter is processed.  */\n   if (Is_Packed_Array_Impl_Type (gnat_entity)\n       && Is_Itype (Original_Array_Type (gnat_entity))\n       && No (Freeze_Node (Original_Array_Type (gnat_entity)))\n@@ -10083,7 +10092,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n   finish_record_type (gnu_new_type, nreverse (gnu_field_list),\n \t\t      is_subtype ? 2 : 1, debug_info_p);\n \n-  /* Now go through the entities again looking for Itypes that we have not yet\n+  /* Now go through the entities again looking for itypes that we have not yet\n      elaborated (e.g. Etypes of fields that have Original_Components).  */\n   for (Entity_Id gnat_field = First_Entity (gnat_new_type);\n        Present (gnat_field);"}, {"sha": "99cdfd0929e71db010b1fdb640dabe81cf47f4ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af62ba41a4ed1e760e0056ba142798e8d6266e4d", "patch": "@@ -1,3 +1,8 @@\n+2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/renaming16.adb: New test.\n+\t* gnat.dg/renaming16_pkg.ads: New helper.\n+\n 2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/array40.adb: New test."}, {"sha": "1c30e4dae6a2e3d750f323335e4f76a5eafe3881", "filename": "gcc/testsuite/gnat.dg/renaming16.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Ftestsuite%2Fgnat.dg%2Frenaming16.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Ftestsuite%2Fgnat.dg%2Frenaming16.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frenaming16.adb?ref=af62ba41a4ed1e760e0056ba142798e8d6266e4d", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+with Renaming16_Pkg; use Renaming16_Pkg;\n+\n+procedure Renaming16 is\n+   Results : Bindings_Query_Results_Type;\n+begin\n+   for I in Create_Bindings_Iterator (Results) loop\n+      null;\n+   end loop;\n+end;"}, {"sha": "0d978c3c3d38aca76ba2a0739a7115628f36c190", "filename": "gcc/testsuite/gnat.dg/renaming16_pkg.ads", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Ftestsuite%2Fgnat.dg%2Frenaming16_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62ba41a4ed1e760e0056ba142798e8d6266e4d/gcc%2Ftestsuite%2Fgnat.dg%2Frenaming16_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frenaming16_pkg.ads?ref=af62ba41a4ed1e760e0056ba142798e8d6266e4d", "patch": "@@ -0,0 +1,34 @@\n+with Ada.Iterator_Interfaces;\n+\n+package Renaming16_Pkg is\n+\n+   type Results_Type is tagged null record;\n+\n+   type Cursor is access constant Results_Type'Class;\n+\n+   not overriding\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   package Base_Iterators is\n+      new Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n+   -- Can be with null record\n+   type Bindings_Iterator is\n+     new Base_Iterators.Forward_Iterator with\n+      record\n+         Ref: Cursor;\n+      end record;\n+\n+   not overriding\n+   function Create_Bindings_Iterator\n+     (Results : in out Results_Type'Class)\n+     return Bindings_Iterator;\n+\n+   overriding function First (Object: Bindings_Iterator) return Cursor;\n+   overriding function Next  (Object: Bindings_Iterator; Position: Cursor) return Cursor;\n+\n+   function Whatever return Boolean;\n+   subtype Bindings_Query_Results_Type is Results_Type\n+     with Dynamic_Predicate => Whatever;\n+\n+end Renaming16_Pkg;"}]}