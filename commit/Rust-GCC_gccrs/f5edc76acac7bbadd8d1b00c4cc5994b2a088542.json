{"sha": "f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVlZGM3NmFjYWM3YmJhZGQ4ZDFiMDBjNGNjNTk5NGIyYTA4ODU0Mg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-28T01:15:07Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-28T01:16:34Z"}, "message": "coroutines: Pass class ref to traits lookup and promise allocator [PR94760].\n\nWe changed the argument passed to the promise parameter preview\nto match a reference to *this.  However to be consistent with the\nother ports, we do need to match the reference transformation in\nthe traits lookup and the promise allocator lookup.\n\ngcc/cp/ChangeLog:\n\n2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94760\n\t* coroutines.cc (instantiate_coro_traits): Pass a reference to\n\tobject type rather than a pointer type for 'this', for method\n\tcoroutines.\n\t(struct param_info): Add a field to hold that the parm is a lambda\n\tclosure pointer.\n\t(morph_fn_to_coro): Check for lambda closure pointers in the\n\targs.  Use a reference to *this when building the args list for the\n\tpromise allocator lookup.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94760\n\t* g++.dg/coroutines/pr94760-mismatched-traits-and-promise-prev.C:\n\tNew test.", "tree": {"sha": "4eef2f6a4876fa7ba9a50138918e58e69d295212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4eef2f6a4876fa7ba9a50138918e58e69d295212"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c91b7f3279e23aed965c05197acf3b6f439f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c91b7f3279e23aed965c05197acf3b6f439f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c91b7f3279e23aed965c05197acf3b6f439f8d"}], "stats": {"total": 102, "additions": 98, "deletions": 4}, "files": [{"sha": "dd8ee21e76207778f28dcd38102a09c111afef70", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "patch": "@@ -1,3 +1,15 @@\n+2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94760\n+\t* coroutines.cc (instantiate_coro_traits): Pass a reference to\n+\tobject type rather than a pointer type for 'this', for method\n+\tcoroutines.\n+\t(struct param_info): Add a field to hold that the parm is a lambda\n+\tclosure pointer.\n+\t(morph_fn_to_coro): Check for lambda closure pointers in the\n+\targs.  Use a reference to *this when building the args list for the\n+\tpromise allocator lookup.\n+\n 2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n \n \tPR c++/94759"}, {"sha": "7bb3e98fe6c8df4a90c9244610e423e4fec86e8c", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "patch": "@@ -296,14 +296,26 @@ instantiate_coro_traits (tree fndecl, location_t kw)\n      type.  */\n \n   tree functyp = TREE_TYPE (fndecl);\n+  tree arg = DECL_ARGUMENTS (fndecl);\n+  bool lambda_p = LAMBDA_FUNCTION_P (fndecl);\n   tree arg_node = TYPE_ARG_TYPES (functyp);\n   tree argtypes = make_tree_vec (list_length (arg_node)-1);\n   unsigned p = 0;\n \n   while (arg_node != NULL_TREE && !VOID_TYPE_P (TREE_VALUE (arg_node)))\n     {\n-      TREE_VEC_ELT (argtypes, p++) = TREE_VALUE (arg_node);\n+      /* See PR94807, as to why we must exclude lambda here.  */\n+      if (is_this_parameter (arg) && !lambda_p)\n+\t{\n+\t  /* We pass a reference to *this to the param preview.  */\n+\t  tree ct = TREE_TYPE (TREE_TYPE (arg));\n+\t  TREE_VEC_ELT (argtypes, p++) = cp_build_reference_type (ct, false);\n+\t}\n+      else\n+\tTREE_VEC_ELT (argtypes, p++) = TREE_VALUE (arg_node);\n+\n       arg_node = TREE_CHAIN (arg_node);\n+      arg = DECL_CHAIN (arg);\n     }\n \n   tree argtypepack = cxx_make_type (TYPE_ARGUMENT_PACK);\n@@ -1754,6 +1766,7 @@ struct param_info\n   bool pt_ref;       /* Was a pointer to object.  */\n   bool trivial_dtor; /* The frame type has a trivial DTOR.  */\n   bool this_ptr;     /* Is 'this' */\n+  bool lambda_cobj;  /* Lambda capture object */\n };\n \n struct local_var_info\n@@ -3654,6 +3667,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  The second two entries start out empty - and only get populated\n \t  when we see uses.  */\n       param_uses = new hash_map<tree, param_info>;\n+      bool lambda_p = LAMBDA_FUNCTION_P (orig);\n \n       unsigned no_name_parm = 0;\n       for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n@@ -3694,7 +3708,19 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t    }\n \t  else\n \t    parm.frame_type = actual_type;\n+\n \t  parm.this_ptr = is_this_parameter (arg);\n+\t  /* See PR94807.  When a lambda is in a template instantiation, the\n+\t     closure object is named 'this' instead of '__closure'.  */\n+\t  if (lambda_p)\n+\t    {\n+\t      parm.lambda_cobj = parm.this_ptr\n+\t\t\t\t || (DECL_NAME (arg) == closure_identifier);\n+\t      parm.this_ptr = false;\n+\t    }\n+\t  else\n+\t    parm.lambda_cobj = false;\n+\n \t  parm.trivial_dtor = TYPE_HAS_TRIVIAL_DESTRUCTOR (parm.frame_type);\n \t  char *buf;\n \t  if (DECL_NAME (arg))\n@@ -3839,9 +3865,28 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \tthose of the original function.  */\n       vec<tree, va_gc> *args = make_tree_vector ();\n       vec_safe_push (args, resizeable); /* Space needed.  */\n+\n       for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n \t   arg = DECL_CHAIN (arg))\n-\tvec_safe_push (args, arg);\n+\t{\n+\t  param_info *parm_i = param_uses->get (arg);\n+\t  gcc_checking_assert (parm_i);\n+\t  if (parm_i->lambda_cobj)\n+\t    vec_safe_push (args, arg);\n+\t  else if (parm_i->this_ptr)\n+\t    {\n+\t      /* We pass a reference to *this to the allocator lookup.  */\n+\t      tree tt = TREE_TYPE (TREE_TYPE (arg));\n+\t      tree this_ref = build1 (INDIRECT_REF, tt, arg);\n+\t      tt = cp_build_reference_type (tt, false);\n+\t      this_ref = convert_to_reference (tt, this_ref, CONV_STATIC,\n+\t\t\t\t\t       LOOKUP_NORMAL , NULL_TREE,\n+\t\t\t\t\t       tf_warning_or_error);\n+\t      vec_safe_push (args, this_ref);\n+\t    }\n+\t  else\n+\t    vec_safe_push (args, arg);\n+\t}\n \n       /* We might need to check that the provided function is nothrow.  */\n       tree func;\n@@ -4031,8 +4076,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t\t\t      false, tf_warning_or_error);\n \n \t  /* Add this to the promise CTOR arguments list, accounting for\n-\t     refs and this ptr.  */\n-\t  if (parm.this_ptr)\n+\t     refs and special handling for method this ptr.  */\n+\t  if (parm.lambda_cobj)\n+\t    vec_safe_push (promise_args, arg);\n+\t  else if (parm.this_ptr)\n \t    {\n \t      /* We pass a reference to *this to the param preview.  */\n \t      tree tt = TREE_TYPE (arg);"}, {"sha": "77f56c1f90a2b46e202901b5331df00eb6cae44b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "patch": "@@ -1,3 +1,9 @@\n+2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94760\n+\t* g++.dg/coroutines/pr94760-mismatched-traits-and-promise-prev.C:\n+\tNew test.\n+\n 2020-04-28  Iain Sandoe  <iain@sandoe.co.uk>\n \n \tPR c++/94759"}, {"sha": "235b5e757beb9637cdecd7ce72e24ba2b9fe23cc", "filename": "gcc/testsuite/g++.dg/coroutines/pr9xxxx-mismatched-traits-and-promise-prev.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr9xxxx-mismatched-traits-and-promise-prev.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5edc76acac7bbadd8d1b00c4cc5994b2a088542/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr9xxxx-mismatched-traits-and-promise-prev.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr9xxxx-mismatched-traits-and-promise-prev.C?ref=f5edc76acac7bbadd8d1b00c4cc5994b2a088542", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile  { target c++17 } }\n+\n+#include \"coro.h\"\n+\n+// Test that we get matching types to traits and promise param\n+// preview.\n+\n+// A separate issue from allowing non-class return types.\n+struct Fake {} ;\n+\n+template<typename R, typename CallOp, typename ...T>\n+struct std::coroutine_traits<R, CallOp, T...> {\n+    struct promise_type {\n+        promise_type (CallOp op, T ...args) {}\n+        Fake get_return_object() { return {}; }\n+        std::suspend_always initial_suspend() { return {}; }\n+        std::suspend_never final_suspend() { return {}; }\n+        void return_void() {}\n+        void unhandled_exception() {}\n+    };\n+};\n+\n+\n+struct Foo\n+{\n+  Fake operator() (int a) {\n+    co_return;\n+  }\n+};"}]}