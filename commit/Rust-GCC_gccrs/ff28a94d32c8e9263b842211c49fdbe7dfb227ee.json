{"sha": "ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyOGE5NGQzMmM4ZTkyNjNiODQyMjExYzQ5ZmRiZTdkZmIyMjdlZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-11-28T10:53:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-28T10:53:16Z"}, "message": "invoke.texi (large-stack-frame, [...]): New params.\n\n\t* invoke.texi (large-stack-frame, large-stack-frame-growth): New params.\n\t* cgraph.c (dump_cgraph_node): Dump stack usage.\n\t* cgraph.h (cgraph_local_info): Add estimated_self_stack_size.\n\t(cgraph_global_info): Add estimated_stack_size and stack_frame_offset.\n\t* cgraphunit.c (cgraph_analyze_function): Analyze stack sizes.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Propagate stack usage.\n\t(cgraph_check_inline_limits): Limit stack growth.\n\t* cfgexpand.c: Include tree-inline.h.\n\t(account_stack_vars): New function.\n\t(expand_one_var): New param to just account the stack; return estimated\n\tsize.\n\t(expand_used_vars_for_block): Update call of expand_one_var.\n\t(account_used_vars_for_block): New function.\n\t(estimated_stack_frame_size): Likewise.\n\t(init_vars_expansion, fini_vars_expansion): Break out from..\n\t(expand_used_vars): ... here.\n\t* tree-inline.h (estimated_stack_frame_size): Declare.\n\t* params.def (PARAM_LARGE_STACK_FRAME, PARAM_STACK_FRAME_GROWTH): New.\n\nFrom-SVN: r119281", "tree": {"sha": "9bb94288fc5fbb8cdce4a230d3d4b48f6137378e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb94288fc5fbb8cdce4a230d3d4b48f6137378e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/comments", "author": null, "committer": null, "parents": [{"sha": "00df958942c2e5805cf3ab236da2725f30fee80d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00df958942c2e5805cf3ab236da2725f30fee80d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00df958942c2e5805cf3ab236da2725f30fee80d"}], "stats": {"total": 309, "additions": 280, "deletions": 29}, "files": [{"sha": "19d2f446679414490b2d5652068c2db2c30a3120", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -1,3 +1,24 @@\n+2006-11-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* invoke.texi (large-stack-frame, large-stack-frame-growth): New params.\n+\t* cgraph.c (dump_cgraph_node): Dump stack usage.\n+\t* cgraph.h (cgraph_local_info): Add estimated_self_stack_size.\n+\t(cgraph_global_info): Add estimated_stack_size and stack_frame_offset.\n+\t* cgraphunit.c (cgraph_analyze_function): Analyze stack sizes.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Propagate stack usage.\n+\t(cgraph_check_inline_limits): Limit stack growth.\n+\t* cfgexpand.c: Include tree-inline.h.\n+\t(account_stack_vars): New function.\n+\t(expand_one_var): New param to just account the stack; return estimated\n+\tsize.\n+\t(expand_used_vars_for_block): Update call of expand_one_var.\n+\t(account_used_vars_for_block): New function.\n+\t(estimated_stack_frame_size): Likewise.\n+\t(init_vars_expansion, fini_vars_expansion): Break out from..\n+\t(expand_used_vars): ... here.\n+\t* tree-inline.h (estimated_stack_frame_size): Declare.\n+\t* params.def (PARAM_LARGE_STACK_FRAME, PARAM_STACK_FRAME_GROWTH): New.\n+\n 2006-11-28  Richard Guenther  <rguenther@suse.de>\n \n \t* ggc-page.c (ggc_print_statistics): Use %ul and a cast to"}, {"sha": "b472adb2cd1c20721481647c8c1bc1478df0f254", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 174, "deletions": 29, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"toplev.h\"\n #include \"debug.h\"\n #include \"params.h\"\n+#include \"tree-inline.h\"\n \n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n@@ -583,6 +584,28 @@ expand_stack_vars (bool (*pred) (tree))\n     }\n }\n \n+/* Take into account all sizes of partitions and reset DECL_RTLs.  */\n+static HOST_WIDE_INT\n+account_stack_vars (void)\n+{\n+  size_t si, j, i, n = stack_vars_num;\n+  HOST_WIDE_INT size = 0;\n+\n+  for (si = 0; si < n; ++si)\n+    {\n+      i = stack_vars_sorted[si];\n+\n+      /* Skip variables that aren't partition representatives, for now.  */\n+      if (stack_vars[i].representative != i)\n+\tcontinue;\n+\n+      size += stack_vars[i].size;\n+      for (j = i; j != EOC; j = stack_vars[j].next)\n+\tSET_DECL_RTL (stack_vars[j].decl, NULL);\n+    }\n+  return size;\n+}\n+\n /* A subroutine of expand_one_var.  Called to immediately assign rtl\n    to a variable to be allocated in the stack frame.  */\n \n@@ -721,31 +744,53 @@ defer_stack_allocation (tree var, bool toplevel)\n \n /* A subroutine of expand_used_vars.  Expand one variable according to\n    its flavor.  Variables to be placed on the stack are not actually\n-   expanded yet, merely recorded.  */\n+   expanded yet, merely recorded.  \n+   When REALLY_EXPAND is false, only add stack values to be allocated.\n+   Return stack usage this variable is supposed to take.\n+*/\n \n-static void\n-expand_one_var (tree var, bool toplevel)\n+static HOST_WIDE_INT\n+expand_one_var (tree var, bool toplevel, bool really_expand)\n {\n   if (TREE_CODE (var) != VAR_DECL)\n-    lang_hooks.expand_decl (var);\n+    {\n+      if (really_expand)\n+        lang_hooks.expand_decl (var);\n+    }\n   else if (DECL_EXTERNAL (var))\n     ;\n   else if (DECL_HAS_VALUE_EXPR_P (var))\n     ;\n   else if (TREE_STATIC (var))\n-    expand_one_static_var (var);\n+    {\n+      if (really_expand)\n+        expand_one_static_var (var);\n+    }\n   else if (DECL_RTL_SET_P (var))\n     ;\n   else if (TREE_TYPE (var) == error_mark_node)\n-    expand_one_error_var (var);\n+    {\n+      if (really_expand)\n+        expand_one_error_var (var);\n+    }\n   else if (DECL_HARD_REGISTER (var))\n-    expand_one_hard_reg_var (var);\n+    {\n+      if (really_expand)\n+        expand_one_hard_reg_var (var);\n+    }\n   else if (use_register_for_decl (var))\n-    expand_one_register_var (var);\n+    {\n+      if (really_expand)\n+        expand_one_register_var (var);\n+    }\n   else if (defer_stack_allocation (var, toplevel))\n     add_stack_var (var);\n   else\n-    expand_one_stack_var (var);\n+    {\n+      expand_one_stack_var (var);\n+      return tree_low_cst (DECL_SIZE_UNIT (var), 1);\n+    }\n+  return 0;\n }\n \n /* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n@@ -770,7 +815,7 @@ expand_used_vars_for_block (tree block, bool toplevel)\n \t   care of this.  */\n \t|| (!flag_unit_at_a_time && TREE_STATIC (t)\n \t    && DECL_PRESERVE_P (t)))\n-      expand_one_var (t, toplevel);\n+      expand_one_var (t, toplevel, true);\n \n   this_sv_num = stack_vars_num;\n \n@@ -947,6 +992,122 @@ create_stack_guard (void)\n   cfun->stack_protect_guard = guard;\n }\n \n+/* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n+   expanding variables.  Those variables that can be put into registers\n+   are allocated pseudos; those that can't are put on the stack.\n+\n+   TOPLEVEL is true if this is the outermost BLOCK.  */\n+\n+static HOST_WIDE_INT\n+account_used_vars_for_block (tree block, bool toplevel)\n+{\n+  size_t i, j, old_sv_num, this_sv_num, new_sv_num;\n+  tree t;\n+  HOST_WIDE_INT size = 0;\n+\n+  old_sv_num = toplevel ? 0 : stack_vars_num;\n+\n+  /* Expand all variables at this level.  */\n+  for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n+    if (TREE_USED (t))\n+      size += expand_one_var (t, toplevel, false);\n+\n+  this_sv_num = stack_vars_num;\n+\n+  /* Expand all variables at containing levels.  */\n+  for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n+    size += account_used_vars_for_block (t, false);\n+\n+  /* Since we do not track exact variable lifetimes (which is not even\n+     possible for variables whose address escapes), we mirror the block\n+     tree in the interference graph.  Here we cause all variables at this\n+     level, and all sublevels, to conflict.  Do make certain that a\n+     variable conflicts with itself.  */\n+  if (old_sv_num < this_sv_num)\n+    {\n+      new_sv_num = stack_vars_num;\n+      resize_stack_vars_conflict (new_sv_num);\n+\n+      for (i = old_sv_num; i < new_sv_num; ++i)\n+\tfor (j = i < this_sv_num ? i+1 : this_sv_num; j-- > old_sv_num ;)\n+\t  add_stack_var_conflict (i, j);\n+    }\n+  return size;\n+}\n+\n+/* Prepare for expanding variables.  */\n+static void \n+init_vars_expansion (void)\n+{\n+  tree t;\n+  /* Set TREE_USED on all variables in the unexpanded_var_list.  */\n+  for (t = cfun->unexpanded_var_list; t; t = TREE_CHAIN (t))\n+    TREE_USED (TREE_VALUE (t)) = 1;\n+\n+  /* Clear TREE_USED on all variables associated with a block scope.  */\n+  clear_tree_used (DECL_INITIAL (current_function_decl));\n+\n+  /* Initialize local stack smashing state.  */\n+  has_protected_decls = false;\n+  has_short_buffer = false;\n+}\n+\n+/* Free up stack variable graph data.  */\n+static void\n+fini_vars_expansion (void)\n+{\n+  XDELETEVEC (stack_vars);\n+  XDELETEVEC (stack_vars_sorted);\n+  XDELETEVEC (stack_vars_conflict);\n+  stack_vars = NULL;\n+  stack_vars_alloc = stack_vars_num = 0;\n+  stack_vars_conflict = NULL;\n+  stack_vars_conflict_alloc = 0;\n+}\n+\n+HOST_WIDE_INT\n+estimated_stack_frame_size (void)\n+{\n+  HOST_WIDE_INT size = 0;\n+  tree t, outer_block = DECL_INITIAL (current_function_decl);\n+\n+  init_vars_expansion ();\n+\n+  /* At this point all variables on the unexpanded_var_list with TREE_USED\n+     set are not associated with any block scope.  Lay them out.  */\n+  for (t = cfun->unexpanded_var_list; t; t = TREE_CHAIN (t))\n+    {\n+      tree var = TREE_VALUE (t);\n+\n+      if (TREE_USED (var))\n+        size += expand_one_var (var, true, false);\n+      TREE_USED (var) = 1;\n+    }\n+  size += account_used_vars_for_block (outer_block, true);\n+  if (stack_vars_num > 0)\n+    {\n+      /* Due to the way alias sets work, no variables with non-conflicting\n+\t alias sets may be assigned the same address.  Add conflicts to\n+\t reflect this.  */\n+      add_alias_set_conflicts ();\n+\n+      /* If stack protection is enabled, we don't share space between\n+\t vulnerable data and non-vulnerable data.  */\n+      if (flag_stack_protect)\n+\tadd_stack_protection_conflicts ();\n+\n+      /* Now that we have collected all stack variables, and have computed a\n+\t minimal interference graph, attempt to save some stack space.  */\n+      partition_stack_vars ();\n+      if (dump_file)\n+\tdump_stack_var_partition ();\n+\n+      size += account_stack_vars ();\n+      fini_vars_expansion ();\n+    }\n+  return size;\n+}\n+\n /* Expand all variables used in the function.  */\n \n static void\n@@ -961,16 +1122,7 @@ expand_used_vars (void)\n     frame_phase = off ? align - off : 0;\n   }\n \n-  /* Set TREE_USED on all variables in the unexpanded_var_list.  */\n-  for (t = cfun->unexpanded_var_list; t; t = TREE_CHAIN (t))\n-    TREE_USED (TREE_VALUE (t)) = 1;\n-\n-  /* Clear TREE_USED on all variables associated with a block scope.  */\n-  clear_tree_used (outer_block);\n-\n-  /* Initialize local stack smashing state.  */\n-  has_protected_decls = false;\n-  has_short_buffer = false;\n+  init_vars_expansion ();\n \n   /* At this point all variables on the unexpanded_var_list with TREE_USED\n      set are not associated with any block scope.  Lay them out.  */\n@@ -1005,7 +1157,7 @@ expand_used_vars (void)\n       TREE_USED (var) = 1;\n \n       if (expand_now)\n-\texpand_one_var (var, true);\n+\texpand_one_var (var, true, true);\n     }\n   cfun->unexpanded_var_list = NULL_TREE;\n \n@@ -1059,14 +1211,7 @@ expand_used_vars (void)\n \n       expand_stack_vars (NULL);\n \n-      /* Free up stack variable graph data.  */\n-      XDELETEVEC (stack_vars);\n-      XDELETEVEC (stack_vars_sorted);\n-      XDELETEVEC (stack_vars_conflict);\n-      stack_vars = NULL;\n-      stack_vars_alloc = stack_vars_num = 0;\n-      stack_vars_conflict = NULL;\n-      stack_vars_conflict_alloc = 0;\n+      fini_vars_expansion ();\n     }\n \n   /* If the target requires that FRAME_OFFSET be aligned, do it.  */"}, {"sha": "6fdd925a7dbc15e318547fc1f5bb3fc720188f9e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -716,6 +716,10 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" %i insns\", node->local.self_insns);\n   if (node->global.insns && node->global.insns != node->local.self_insns)\n     fprintf (f, \" (%i after inlining)\", node->global.insns);\n+  if (node->local.estimated_self_stack_size)\n+    fprintf (f, \" %i bytes stack usage\", (int)node->local.estimated_self_stack_size);\n+  if (node->global.estimated_stack_size != node->local.estimated_self_stack_size)\n+    fprintf (f, \" %i bytes after inlining\", (int)node->global.estimated_stack_size);\n   if (node->origin)\n     fprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n   if (node->needed)"}, {"sha": "b7aa81bcd1600421f85974e5cb828e063152ff98", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -51,6 +51,9 @@ enum availability\n \n struct cgraph_local_info GTY(())\n {\n+  /* Estiimated stack frame consumption by the function.  */\n+  HOST_WIDE_INT estimated_self_stack_size;\n+\n   /* Size of the function before inlining.  */\n   int self_insns;\n \n@@ -88,6 +91,11 @@ struct cgraph_local_info GTY(())\n \n struct cgraph_global_info GTY(())\n {\n+  /* Estimated stack frame consumption by the function.  */\n+  HOST_WIDE_INT estimated_stack_size;\n+  /* Expected offset of the stack frame of inlined function.  */\n+  HOST_WIDE_INT stack_frame_offset;\n+\n   /* For inline clones this points to the function they will be inlined into.  */\n   struct cgraph_node *inlined_to;\n "}, {"sha": "59a7e0d4cd1de62fbbcc68618f1d1ff99fc3094a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -950,6 +950,9 @@ cgraph_analyze_function (struct cgraph_node *node)\n   /* First kill forward declaration so reverse inlining works properly.  */\n   cgraph_create_edges (node, decl);\n \n+  node->local.estimated_self_stack_size = estimated_stack_frame_size ();\n+  node->global.estimated_stack_size = node->local.estimated_self_stack_size;\n+  node->global.stack_frame_offset = 0;\n   node->local.inlinable = tree_inlinable_function_p (decl);\n   if (!flag_unit_at_a_time)\n     node->local.self_insns = estimate_num_insns (decl);"}, {"sha": "e606366ef1d90ca569ec8fbec9bb4c279e514ea2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -6033,6 +6033,15 @@ This parameter is ignored when @option{-funit-at-a-time} is not used.\n The default value is 50 which limits unit growth to 1.5 times the original\n size.\n \n+@item large-stack-frame\n+The limit specifying large stack frames.  While inlining the algorithm is trying\n+to not grow past this limit too much.  Default value is 256 bytes.\n+\n+@item large-stack-frame-growth\n+Specifies maximal growth of large stack frames caused by inlining in percents.\n+The default value is 1000 which limits large stack frame growth to 11 times\n+the original size.\n+\n @item max-inline-insns-recursive\n @itemx max-inline-insns-recursive-auto\n Specifies maximum number of instructions out-of-line copy of self recursive inline"}, {"sha": "8e47f36509bc89d3f90b548b75210cf319aa540d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -115,6 +115,7 @@ cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n void\n cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_original)\n {\n+  HOST_WIDE_INT peak;\n   if (duplicate)\n     {\n       /* We may eliminate the need for out-of-line copy to be output.\n@@ -141,6 +142,11 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_o\n     e->callee->global.inlined_to = e->caller->global.inlined_to;\n   else\n     e->callee->global.inlined_to = e->caller;\n+  e->callee->global.stack_frame_offset\n+    = e->caller->global.stack_frame_offset + e->caller->local.estimated_self_stack_size;\n+  peak = e->callee->global.stack_frame_offset + e->callee->local.estimated_self_stack_size;\n+  if (e->callee->global.inlined_to->global.estimated_stack_size < peak)\n+    e->callee->global.inlined_to->global.estimated_stack_size = peak;\n \n   /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = e->next_callee)\n@@ -257,6 +263,7 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n   struct cgraph_edge *e;\n   int newsize;\n   int limit;\n+  HOST_WIDE_INT stack_size_limit, inlined_stack;\n \n   if (one_only)\n     times = 1;\n@@ -288,6 +295,21 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n         *reason = N_(\"--param large-function-growth limit reached\");\n       return false;\n     }\n+\n+  stack_size_limit = to->local.estimated_self_stack_size;\n+\n+  stack_size_limit += stack_size_limit * PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) / 100;\n+\n+  inlined_stack = (to->global.stack_frame_offset\n+\t\t   + to->local.estimated_self_stack_size\n+\t\t   + what->global.estimated_stack_size);\n+  if (inlined_stack  > stack_size_limit\n+      && inlined_stack > PARAM_VALUE (PARAM_LARGE_STACK_FRAME))\n+    {\n+      if (reason)\n+        *reason = N_(\"--param large-stack-frame-growth limit reached\");\n+      return false;\n+    }\n   return true;\n }\n "}, {"sha": "142b19ebbc6309d0ee9aabda548a8eefc653ae21", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -198,6 +198,14 @@ DEFPARAM(PARAM_INLINE_CALL_COST,\n \t \"inline-call-cost\",\n \t \"expense of call operation relative to ordinary arithmetic operations\",\n \t 16, 0, 0)\n+DEFPARAM(PARAM_LARGE_STACK_FRAME,\n+\t \"large-stack-frame\",\n+\t \"The size of stack frame to be considered large\",\n+\t 256, 0, 0)\n+DEFPARAM(PARAM_STACK_FRAME_GROWTH,\n+\t \"large-stack-frame-growth\",\n+\t \"Maximal stack frame growth due to inlining (in percent)\",\n+\t 1000, 0, 0)\n \n /* The GCSE optimization will be disabled if it would require\n    significantly more memory than this value.  */"}, {"sha": "e2a6284c54642b55f45e9c1e318d6d35b9741922", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -1,3 +1,7 @@\n+2006-11-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/winline-1.c: New test.\n+\n 2006-11-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcc.dg/pack-test-1.c: Use __alignof__ to determine natural"}, {"sha": "f6cd2374983b68a9a64638e0a2975f0812126bc8", "filename": "gcc/testsuite/gcc.dg/winline-9.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-9.c?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Winline --param large-stack-frame=10 --param large-stack-frame-growth=2\" } */\n+\n+int a,b;\n+void test(char *);\n+static inline\n+int aa (void)\n+{\n+  char t[10];\n+  test(t);\n+}\n+static inline\n+int bb (void)\n+{ \t\t\t\t/* { dg-warning \"large-stack-frame\" \"\" } */\n+  char t[100];\n+  test(t);\n+}\n+\n+t()\n+{\n+  if (a)\n+    aa();\n+  if (b)\n+    bb(); \t\t\t/* { dg-warning \"called from here\" \"\" } */\n+}"}, {"sha": "4755fbbf9fdcf86a9c28f5128be7d8d51215c9f3", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff28a94d32c8e9263b842211c49fdbe7dfb227ee/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=ff28a94d32c8e9263b842211c49fdbe7dfb227ee", "patch": "@@ -110,6 +110,8 @@ void tree_function_versioning (tree, tree, varray_type, bool);\n extern tree remap_decl (tree decl, copy_body_data *id);\n extern tree remap_type (tree type, copy_body_data *id);\n \n+extern HOST_WIDE_INT estimated_stack_frame_size (void);\n+\n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level.\n    2 if we should consider *all* functions to be inline"}]}