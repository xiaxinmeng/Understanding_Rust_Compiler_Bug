{"sha": "86c0ec1de10050af15afa2965adf6d219f0ccd06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjMGVjMWRlMTAwNTBhZjE1YWZhMjk2NWFkZjZkMjE5ZjBjY2QwNg==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-07-13T11:25:51Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-07-13T11:25:51Z"}, "message": "Implement P0307R2, Making Optional Greater Equal Again.\n\n\t* include/experimental/optional (_Has_addressof): Fix the comment.\n\t* include/std/optional (_Has_addressof): Likewise.\n\t(operator=(_Up&&)): Constrain.\n\t(operator=(const optional<_Up>&)): Likewise.\n\t(operator=(optional<_Up>&&)): Likewise.\n\t(__optional_relop_t): New.\n\t(operator==(const optional<_Tp>&, const optional<_Tp>&)): Constrain.\n\t(operator!=(const optional<_Tp>&, const optional<_Tp>&)):\n\tConstrain and make transparent.\n\t(operator<(const optional<_Tp>&, const optional<_Tp>&)): Constrain.\n\t(operator>(const optional<_Tp>&, const optional<_Tp>&)):\n\tConstrain and make transparent.\n\t(operator<=(const optional<_Tp>&, const optional<_Tp>&)): Likewise.\n\t(operator>=(const optional<_Tp>&, const optional<_Tp>&)): Likewise.\n\t(operator==(const optional<_Tp>&, const _Tp&): Constrain.\n\t(operator==(const _Tp&, const optional<_Tp>&)): Likewise.\n\t(operator!=(const optional<_Tp>&, _Tp const&)):\n\tConstrain and make transparent.\n\t(operator!=(const _Tp&, const optional<_Tp>&)): Likewise.\n\t(operator<(const optional<_Tp>&, const _Tp&)): Constrain.\n\t(operator<(const _Tp&, const optional<_Tp>&)): Likewise.\n\t(operator>(const optional<_Tp>&, const _Tp&)):\n\tConstrain and make transparent.\n\t(operator>(const _Tp&, const optional<_Tp>&)): Likewise.\n\t(operator<=(const optional<_Tp>&, const _Tp&)): Likewise.\n\t(operator<=(const _Tp&, const optional<_Tp>&)): Likewise.\n\t(operator>=(const optional<_Tp>&, const _Tp&)): Likewise.\n\t(operator>=(const _Tp&, const optional<_Tp>&)): Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/2.cc: Adjust.\n\t* testsuite/20_util/optional/constexpr/relops/4.cc: Likewise.\n\t* testsuite/20_util/optional/relops/1.cc: Likewise.\n\t* testsuite/20_util/optional/relops/2.cc: Likewise.\n\t* testsuite/20_util/optional/relops/3.cc: Likewise.\n\t* testsuite/20_util/optional/relops/4.cc: Likewise.\n\t* testsuite/20_util/optional/requirements.cc: Add tests to verify\n\tthat optional's relops are transparent and don't synthesize\n\toperators. Also test that assignment sfinaes.\n\nFrom-SVN: r238292", "tree": {"sha": "183e726ed4834c25799cc810c4c8924243be982d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/183e726ed4834c25799cc810c4c8924243be982d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86c0ec1de10050af15afa2965adf6d219f0ccd06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c0ec1de10050af15afa2965adf6d219f0ccd06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c0ec1de10050af15afa2965adf6d219f0ccd06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c0ec1de10050af15afa2965adf6d219f0ccd06/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceea48fc64eb7d5fe8c2ecfd61f6cda7918e40c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceea48fc64eb7d5fe8c2ecfd61f6cda7918e40c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceea48fc64eb7d5fe8c2ecfd61f6cda7918e40c1"}], "stats": {"total": 335, "additions": 283, "deletions": 52}, "files": [{"sha": "f4d09963b57c734b85eb47e4f25c625627125114", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -1,3 +1,42 @@\n+\tImplement P0307R2, Making Optional Greater Equal Again.\n+\t* include/experimental/optional (_Has_addressof): Fix the comment.\n+\t* include/std/optional (_Has_addressof): Likewise.\n+\t(operator=(_Up&&)): Constrain.\n+\t(operator=(const optional<_Up>&)): Likewise.\n+\t(operator=(optional<_Up>&&)): Likewise.\n+\t(__optional_relop_t): New.\n+\t(operator==(const optional<_Tp>&, const optional<_Tp>&)): Constrain.\n+\t(operator!=(const optional<_Tp>&, const optional<_Tp>&)):\n+\tConstrain and make transparent.\n+\t(operator<(const optional<_Tp>&, const optional<_Tp>&)): Constrain.\n+\t(operator>(const optional<_Tp>&, const optional<_Tp>&)):\n+\tConstrain and make transparent.\n+\t(operator<=(const optional<_Tp>&, const optional<_Tp>&)): Likewise.\n+\t(operator>=(const optional<_Tp>&, const optional<_Tp>&)): Likewise.\n+\t(operator==(const optional<_Tp>&, const _Tp&): Constrain.\n+\t(operator==(const _Tp&, const optional<_Tp>&)): Likewise.\n+\t(operator!=(const optional<_Tp>&, _Tp const&)):\n+\tConstrain and make transparent.\n+\t(operator!=(const _Tp&, const optional<_Tp>&)): Likewise.\n+\t(operator<(const optional<_Tp>&, const _Tp&)): Constrain.\n+\t(operator<(const _Tp&, const optional<_Tp>&)): Likewise.\n+\t(operator>(const optional<_Tp>&, const _Tp&)):\n+\tConstrain and make transparent.\n+\t(operator>(const _Tp&, const optional<_Tp>&)): Likewise.\n+\t(operator<=(const optional<_Tp>&, const _Tp&)): Likewise.\n+\t(operator<=(const _Tp&, const optional<_Tp>&)): Likewise.\n+\t(operator>=(const optional<_Tp>&, const _Tp&)): Likewise.\n+\t(operator>=(const _Tp&, const optional<_Tp>&)): Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/2.cc: Adjust.\n+\t* testsuite/20_util/optional/constexpr/relops/4.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/1.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/2.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/3.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/4.cc: Likewise.\n+\t* testsuite/20_util/optional/requirements.cc: Add tests to verify\n+\tthat optional's relops are transparent and don't synthesize\n+\toperators. Also test that assignment sfinaes.\n+\n 2016-07-13  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI] (_M_c_str):"}, {"sha": "ea8f6fb1c64324f45073dea9601078852d0d9b13", "filename": "libstdc++-v3/include/experimental/optional", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Foptional?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -155,8 +155,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     * @brief Trait that detects the presence of an overloaded unary operator&.\n     *\n     * Practically speaking this detects the presence of such an operator when\n-    * called on a const-qualified lvalue (i.e.\n-    * declval<_Tp * const&>().operator&()).\n+    * called on a const-qualified lvalue (e.g.\n+    * declval<const _Tp&>().operator&()).\n     */\n   template<typename _Tp>\n     struct _Has_addressof"}, {"sha": "f1bb17c75dc937442d98d8ec592d9591c891d7a3", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 75, "deletions": 50, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -131,8 +131,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     * @brief Trait that detects the presence of an overloaded unary operator&.\n     *\n     * Practically speaking this detects the presence of such an operator when\n-    * called on a const-qualified lvalue (i.e.\n-    * declval<_Tp * const&>().operator&()).\n+    * called on a const-qualified lvalue (e.g.\n+    * declval<const _Tp&>().operator&()).\n     */\n   template<typename _Tp>\n     struct _Has_addressof\n@@ -577,16 +577,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Up,\n                enable_if_t<__and_<\n+\t\t\t   is_constructible<_Tp, _Up>,\n+\t\t\t   is_assignable<_Tp&, _Up>,\n \t\t\t   __not_<is_same<_Up, nullopt_t>>,\n \t\t\t   __not_<__is_optional<_Up>>>::value,\n \t\t\t bool> = true>\n         optional&\n         operator=(_Up&& __u)\n         {\n-          static_assert(__and_<is_constructible<_Tp, _Up>,\n-\t\t\t       is_assignable<_Tp&, _Up>>(),\n-                        \"Cannot assign to value type from argument\");\n-\n           if (this->_M_is_engaged())\n             this->_M_get() = std::forward<_Up>(__u);\n           else\n@@ -597,15 +595,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Up,\n                enable_if_t<__and_<\n-\t\t __not_<is_same<_Tp, _Up>>>::value,\n-\t\t\t   bool> = true>\n+\t\t           is_constructible<_Tp, _Up>,\n+\t\t           is_assignable<_Tp&, _Up>,\n+\t\t           __not_<is_same<_Tp, _Up>>>::value,\n+\t\t\t bool> = true>\n         optional&\n         operator=(const optional<_Up>& __u)\n         {\n-          static_assert(__and_<is_constructible<_Tp, _Up>,\n-\t\t\t       is_assignable<_Tp&, _Up>>(),\n-                        \"Cannot assign to value type from argument\");\n-\n           if (__u)\n             {\n               if (this->_M_is_engaged())\n@@ -621,16 +617,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         }\n \n       template<typename _Up,\n-               enable_if_t<__and_<\n-\t\t __not_<is_same<_Tp, _Up>>>::value,\n-\t\t\t   bool> = true>\n+\t       enable_if_t<__and_<\n+\t\t\t   is_constructible<_Tp, _Up>,\n+\t\t\t   is_assignable<_Tp&, _Up>,\n+\t\t\t   __not_<is_same<_Tp, _Up>>>::value,\n+\t\t\t bool> = true>\n         optional&\n         operator=(optional<_Up>&& __u)\n         {\n-          static_assert(__and_<is_constructible<_Tp, _Up>,\n-\t\t\t       is_assignable<_Tp&, _Up>>(),\n-                        \"Cannot assign to value type from argument\");\n-\n           if (__u)\n             {\n               if (this->_M_is_engaged())\n@@ -785,41 +779,60 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     };\n \n+  template<typename _Tp>\n+    using __optional_relop_t =\n+    enable_if_t<is_convertible<_Tp, bool>::value, bool>;\n+\n   // [X.Y.8] Comparisons between optional values.\n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator==(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Tp>())>\n     {\n       return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)\n \t     && (!__lhs || *__lhs == *__rhs);\n     }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator!=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n-    { return !(__lhs == __rhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Tp>())>\n+    {\n+      return static_cast<bool>(__lhs) != static_cast<bool>(__rhs)\n+\t|| (static_cast<bool>(__lhs) && *__lhs != *__rhs);\n+    }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator<(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Tp>())>\n     {\n       return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);\n     }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator>(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n-    { return __rhs < __lhs; }\n+    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Tp>())>\n+    {\n+      return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);\n+    }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator<=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n-    { return !(__rhs < __lhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Tp>())>\n+    {\n+      return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);\n+    }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator>=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n-    { return !(__lhs < __rhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Tp>())>\n+    {\n+      return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);\n+    }\n \n   // [X.Y.9] Comparisons with nullopt.\n   template<typename _Tp>\n@@ -884,64 +897,76 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // [X.Y.10] Comparisons with value type.\n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator==(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Tp>())>\n     { return __lhs && *__lhs == __rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator==(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Tp>())>\n     { return __rhs && __lhs == *__rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n-    operator!=(const optional<_Tp>& __lhs, _Tp const& __rhs)\n-    { return !__lhs || !(*__lhs == __rhs); }\n+    constexpr auto\n+    operator!=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Tp>())>\n+    { return !__lhs || *__lhs != __rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator!=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n-    { return !__rhs || !(__lhs == *__rhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Tp>())>\n+    { return !__rhs || __lhs != *__rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator<(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Tp>())>\n     { return !__lhs || *__lhs < __rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator<(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Tp>())>\n     { return __rhs && __lhs < *__rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator>(const optional<_Tp>& __lhs, const _Tp& __rhs)\n-    { return __lhs && __rhs < *__lhs; }\n+    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Tp>())>\n+    { return __lhs && *__lhs > __rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator>(const _Tp& __lhs, const optional<_Tp>& __rhs)\n-    { return !__rhs || *__rhs < __lhs; }\n+    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Tp>())>\n+    { return !__rhs || __lhs > *__rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator<=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n-    { return !__lhs || !(__rhs < *__lhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Tp>())>\n+    { return !__lhs || *__lhs <= __rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator<=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n-    { return __rhs && !(*__rhs < __lhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Tp>())>\n+    { return __rhs && __lhs <= *__rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator>=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n-    { return __lhs && !(*__lhs < __rhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Tp>())>\n+    { return __lhs && *__lhs >= __rhs; }\n \n   template<typename _Tp>\n-    constexpr bool\n+    constexpr auto\n     operator>=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n-    { return !__rhs || !(__lhs < *__rhs); }\n+    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Tp>())>\n+    { return !__rhs || __lhs >= *__rhs; }\n \n   // [X.Y.11]\n   template<typename _Tp>"}, {"sha": "0ce00c1052f7250820be946fe29ffb7200d7590b", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/2.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F2.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -54,6 +54,18 @@ namespace ns\n   operator<(value_type const& lhs, value_type const& rhs)\n   { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n \n+  constexpr bool\n+  operator>(value_type const& lhs, value_type const& rhs)\n+  { return rhs < lhs; }\n+\n+  constexpr bool\n+  operator<=(value_type const& lhs, value_type const& rhs)\n+  { return lhs < rhs || lhs == rhs; }\n+\n+  constexpr bool\n+  operator>=(value_type const& lhs, value_type const& rhs)\n+  { return lhs > rhs || lhs == rhs; }\n+\n } // namespace ns\n \n int main()"}, {"sha": "d6294ad9d7cbea73b08049c45facf5a92e6f82d8", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/4.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F4.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -54,6 +54,18 @@ namespace ns\n   operator<(value_type const& lhs, value_type const& rhs)\n   { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n \n+  constexpr bool\n+  operator>(value_type const& lhs, value_type const& rhs)\n+  { return rhs < lhs; }\n+\n+  constexpr bool\n+  operator<=(value_type const& lhs, value_type const& rhs)\n+  { return lhs < rhs || lhs == rhs; }\n+\n+  constexpr bool\n+  operator>=(value_type const& lhs, value_type const& rhs)\n+  { return lhs > rhs || lhs == rhs; }\n+\n } // namespace ns\n \n int main()"}, {"sha": "1315902239efc730c6be85ece3caa2c25fa1e002", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/1.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F1.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -36,10 +36,26 @@ namespace ns\n   operator==(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) != std::tie(rhs.i, rhs.s); }\n+\n   bool\n   operator<(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator>(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) > std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) <= std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator>=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) >= std::tie(rhs.i, rhs.s); }\n+\n } // namespace ns\n \n int main()"}, {"sha": "135126576728a97f429486e7c1464469adf7f1d1", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/2.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F2.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -36,10 +36,26 @@ namespace ns\n   operator==(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) != std::tie(rhs.i, rhs.s); }\n+\n   bool\n   operator<(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator>(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) > std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) <= std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator>=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) >= std::tie(rhs.i, rhs.s); }\n+\n } // namespace ns\n \n int main()"}, {"sha": "95fde3b4797d32d921be01a1199ada605fe79db8", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/3.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F3.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -36,10 +36,26 @@ namespace ns\n   operator==(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) != std::tie(rhs.i, rhs.s); }\n+\n   bool\n   operator<(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator>(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) > std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) <= std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator>=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) >= std::tie(rhs.i, rhs.s); }\n+\n } // namespace ns\n \n int main()"}, {"sha": "78d0eb8b2d032167e09dd4095749338465e02d86", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/4.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F4.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -36,10 +36,26 @@ namespace ns\n   operator==(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) != std::tie(rhs.i, rhs.s); }\n+\n   bool\n   operator<(value_type const& lhs, value_type const& rhs)\n   { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n \n+  bool\n+  operator>(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) > std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) <= std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator>=(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) >= std::tie(rhs.i, rhs.s); }\n+\n } // namespace ns\n \n int main()"}, {"sha": "d0f3ab6d773734407c366714b71915f1899609d5", "filename": "libstdc++-v3/testsuite/20_util/optional/requirements.cc", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c0ec1de10050af15afa2965adf6d219f0ccd06/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frequirements.cc?ref=86c0ec1de10050af15afa2965adf6d219f0ccd06", "patch": "@@ -257,3 +257,82 @@ int main()\n     static_assert( *o == 33, \"\" );\n   }\n }\n+\n+using std::void_t;\n+using std::declval;\n+using std::true_type;\n+using std::false_type;\n+\n+template <class T, class = void>\n+struct is_eq_comparable : false_type {};\n+template <class T>\n+struct is_eq_comparable<T, void_t<decltype(declval<T>() == declval<T>())>>\n+: true_type {};\n+\n+template <class T, class = void>\n+struct is_neq_comparable : false_type {};\n+template <class T>\n+struct is_neq_comparable<T, void_t<decltype(declval<T>() != declval<T>())>>\n+: true_type {};\n+\n+template <class T, class = void>\n+struct is_lt_comparable : false_type {};\n+template <class T>\n+struct is_lt_comparable<T, void_t<decltype(declval<T>() < declval<T>())>>\n+: true_type {};\n+\n+template <class T, class = void>\n+struct is_gt_comparable : false_type {};\n+template <class T>\n+struct is_gt_comparable<T, void_t<decltype(declval<T>() > declval<T>())>>\n+: true_type {};\n+\n+template <class T, class = void>\n+struct is_le_comparable : false_type {};\n+template <class T>\n+struct is_le_comparable<T, void_t<decltype(declval<T>() <= declval<T>())>>\n+: true_type {};\n+\n+template <class T, class = void>\n+struct is_ge_comparable : false_type {};\n+template <class T>\n+struct is_ge_comparable<T, void_t<decltype(declval<T>() >= declval<T>())>>\n+: true_type {};\n+\n+using std::optional;\n+\n+static_assert(is_eq_comparable<optional<int>>::value, \"\");\n+static_assert(is_neq_comparable<optional<int>>::value, \"\");\n+static_assert(is_lt_comparable<optional<int>>::value, \"\");\n+static_assert(is_gt_comparable<optional<int>>::value, \"\");\n+static_assert(is_le_comparable<optional<int>>::value, \"\");\n+static_assert(is_ge_comparable<optional<int>>::value, \"\");\n+\n+struct JustEq {};\n+bool operator==(const JustEq&, const JustEq&);\n+\n+static_assert(is_eq_comparable<optional<JustEq>>::value, \"\");\n+static_assert(!is_neq_comparable<optional<JustEq>>::value, \"\");\n+static_assert(!is_lt_comparable<optional<JustEq>>::value, \"\");\n+static_assert(!is_gt_comparable<optional<JustEq>>::value, \"\");\n+static_assert(!is_le_comparable<optional<JustEq>>::value, \"\");\n+static_assert(!is_ge_comparable<optional<JustEq>>::value, \"\");\n+\n+struct JustLt {};\n+bool operator<(const JustLt&, const JustLt&);\n+\n+static_assert(!is_eq_comparable<optional<JustLt>>::value, \"\");\n+static_assert(!is_neq_comparable<optional<JustLt>>::value, \"\");\n+static_assert(is_lt_comparable<optional<JustLt>>::value, \"\");\n+static_assert(!is_gt_comparable<optional<JustLt>>::value, \"\");\n+static_assert(!is_le_comparable<optional<JustLt>>::value, \"\");\n+static_assert(!is_ge_comparable<optional<JustLt>>::value, \"\");\n+\n+static_assert(!std::is_assignable<optional<JustEq>&,\n+\t      optional<JustLt>>::value, \"\");\n+static_assert(!std::is_assignable<optional<JustEq>&,\n+\t      JustLt>::value, \"\");\n+static_assert(!std::is_assignable<optional<JustEq>&,\n+\t      optional<JustLt>&>::value, \"\");\n+static_assert(!std::is_assignable<optional<JustEq>&,\n+\t      JustLt&>::value, \"\");"}]}