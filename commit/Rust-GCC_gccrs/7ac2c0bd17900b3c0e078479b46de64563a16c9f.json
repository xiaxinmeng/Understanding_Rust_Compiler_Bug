{"sha": "7ac2c0bd17900b3c0e078479b46de64563a16c9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjMmMwYmQxNzkwMGIzYzBlMDc4NDc5YjQ2ZGU2NDU2M2ExNmM5Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-08-20T01:45:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-08-20T01:45:49Z"}, "message": "re PR c++/66957 (incorrect \"is protected within this context\" error)\n\n\tPR c++/66957\n\t* search.c (protected_accessible_p): Remove redundant access_in_type.\n\tAdd otype parm instead of walking binfo.\n\t(friend_accessible_p): Check SCOPE itself.  Handle class\n\ttemplates.  Pass through otype.\n\t(dfs_accessible_post): Handle all accessibility cases.\n\t(dfs_accessible_pre): New.\n\t(accessible_p): Use it.  Don't check protected access here.  Pass\n\tdecl and otype to dfs_walk.\n\t(member_declared_in_type, dfs_access_in_type_pre): New.\n\t(access_in_type): Use dfs_access_in_type_pre.\n\t* friend.c (add_friend): Fix multiple friends with the same name.\n\nFrom-SVN: r227023", "tree": {"sha": "b65582f3511b73960f319ef3ff55d38d73013c57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b65582f3511b73960f319ef3ff55d38d73013c57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ac2c0bd17900b3c0e078479b46de64563a16c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac2c0bd17900b3c0e078479b46de64563a16c9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac2c0bd17900b3c0e078479b46de64563a16c9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac2c0bd17900b3c0e078479b46de64563a16c9f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18c4fa8ef0c5e3d705be8f50860b3e58be672256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c4fa8ef0c5e3d705be8f50860b3e58be672256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c4fa8ef0c5e3d705be8f50860b3e58be672256"}], "stats": {"total": 266, "additions": 180, "deletions": 86}, "files": [{"sha": "2a083c804d2944706206aafef5ca3676a9faa9de", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ac2c0bd17900b3c0e078479b46de64563a16c9f", "patch": "@@ -1,5 +1,18 @@\n 2015-08-19  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/66957\n+\t* search.c (protected_accessible_p): Remove redundant access_in_type.\n+\tAdd otype parm instead of walking binfo.\n+\t(friend_accessible_p): Check SCOPE itself.  Handle class\n+\ttemplates.  Pass through otype.\n+\t(dfs_accessible_post): Handle all accessibility cases.\n+\t(dfs_accessible_pre): New.\n+\t(accessible_p): Use it.  Don't check protected access here.  Pass\n+\tdecl and otype to dfs_walk.\n+\t(member_declared_in_type, dfs_access_in_type_pre): New.\n+\t(access_in_type): Use dfs_access_in_type_pre.\n+\t* friend.c (add_friend): Fix multiple friends with the same name.\n+\n \t* lambda.c (current_nonlambda_scope): New.\n \n 2015-08-18  Trevor Saunders  <tbsaunde@tbsaunde.org>"}, {"sha": "f53ce27f19d26f73c7f26cfde381182e1b258fe2", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=7ac2c0bd17900b3c0e078479b46de64563a16c9f", "patch": "@@ -156,11 +156,9 @@ add_friend (tree type, tree decl, bool complain)\n \t\t}\n \t    }\n \n-\t  maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n-\n \t  TREE_VALUE (list) = tree_cons (NULL_TREE, decl,\n \t\t\t\t\t TREE_VALUE (list));\n-\t  return;\n+\t  break;\n \t}\n       list = TREE_CHAIN (list);\n     }\n@@ -172,9 +170,10 @@ add_friend (tree type, tree decl, bool complain)\n \n   maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n \n-  DECL_FRIENDLIST (typedecl)\n-    = tree_cons (DECL_NAME (decl), build_tree_list (NULL_TREE, decl),\n-\t\t DECL_FRIENDLIST (typedecl));\n+  if (!list)\n+    DECL_FRIENDLIST (typedecl)\n+      = tree_cons (DECL_NAME (decl), build_tree_list (NULL_TREE, decl),\n+\t\t   DECL_FRIENDLIST (typedecl));\n   if (!uses_template_parms (type))\n     DECL_BEFRIENDING_CLASSES (decl)\n       = tree_cons (NULL_TREE, type,"}, {"sha": "42db122e98c73932bcf5d1591a4296ee2d9e5d50", "filename": "gcc/cp/search.c", "status": "modified", "additions": 148, "deletions": 80, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=7ac2c0bd17900b3c0e078479b46de64563a16c9f", "patch": "@@ -58,8 +58,6 @@ static tree dfs_walk_once_accessible (tree, bool,\n \t\t\t\t      void *data);\n static tree dfs_access_in_type (tree, void *);\n static access_kind access_in_type (tree, tree);\n-static int protected_accessible_p (tree, tree, tree);\n-static int friend_accessible_p (tree, tree, tree);\n static tree dfs_get_pure_virtuals (tree, void *);\n \n \f\n@@ -582,9 +580,36 @@ context_for_name_lookup (tree decl)\n   return context;\n }\n \n+/* Returns true iff DECL is declared in TYPE.  */\n+\n+static bool\n+member_declared_in_type (tree decl, tree type)\n+{\n+  /* A normal declaration obviously counts.  */\n+  if (context_for_name_lookup (decl) == type)\n+    return true;\n+  /* So does a using or access declaration.  */\n+  if (DECL_LANG_SPECIFIC (decl) && !DECL_DISCRIMINATOR_P (decl)\n+      && purpose_member (type, DECL_ACCESS (decl)))\n+    return true;\n+  return false;\n+}\n+\n /* The accessibility routines use BINFO_ACCESS for scratch space\n    during the computation of the accessibility of some declaration.  */\n \n+/* Avoid walking up past a declaration of the member.  */\n+\n+static tree\n+dfs_access_in_type_pre (tree binfo, void *data)\n+{\n+  tree decl = (tree) data;\n+  tree type = BINFO_TYPE (binfo);\n+  if (member_declared_in_type (decl, type))\n+    return dfs_skip_bases;\n+  return NULL_TREE;\n+}\n+\n #define BINFO_ACCESS(NODE) \\\n   ((access_kind) ((TREE_PUBLIC (NODE) << 1) | TREE_PRIVATE (NODE)))\n \n@@ -705,36 +730,28 @@ access_in_type (tree type, tree decl)\n     The algorithm we use is to make a post-order depth-first traversal\n     of the base-class hierarchy.  As we come up the tree, we annotate\n     each node with the most lenient access.  */\n-  dfs_walk_once (binfo, NULL, dfs_access_in_type, decl);\n+  dfs_walk_once (binfo, dfs_access_in_type_pre, dfs_access_in_type, decl);\n \n   return BINFO_ACCESS (binfo);\n }\n \n-/* Returns nonzero if it is OK to access DECL through an object\n-   indicated by BINFO in the context of DERIVED.  */\n+/* Returns nonzero if it is OK to access DECL named in TYPE through an object\n+   of OTYPE in the context of DERIVED.  */\n \n static int\n-protected_accessible_p (tree decl, tree derived, tree binfo)\n+protected_accessible_p (tree decl, tree derived, tree type, tree otype)\n {\n-  access_kind access;\n-\n   /* We're checking this clause from [class.access.base]\n \n        m as a member of N is protected, and the reference occurs in a\n        member or friend of class N, or in a member or friend of a\n        class P derived from N, where m as a member of P is public, private\n        or protected.\n \n-    Here DERIVED is a possible P, DECL is m and BINFO_TYPE (binfo) is N.  */\n+    Here DERIVED is a possible P, DECL is m and TYPE is N.  */\n \n   /* If DERIVED isn't derived from N, then it can't be a P.  */\n-  if (!DERIVED_FROM_P (BINFO_TYPE (binfo), derived))\n-    return 0;\n-\n-  access = access_in_type (derived, decl);\n-\n-  /* If m is inaccessible in DERIVED, then it's not a P.  */\n-  if (access == ak_none)\n+  if (!DERIVED_FROM_P (type, derived))\n     return 0;\n \n   /* [class.protected]\n@@ -748,33 +765,38 @@ protected_accessible_p (tree decl, tree derived, tree binfo)\n      derived from that class) (_expr.ref_).  If the access is to form\n      a pointer to member, the nested-name-specifier shall name the\n      derived class (or any class derived from that class).  */\n-  if (DECL_NONSTATIC_MEMBER_P (decl))\n-    {\n-      /* We can tell through what the reference is occurring by\n-\t chasing BINFO up to the root.  */\n-      tree t = binfo;\n-      while (BINFO_INHERITANCE_CHAIN (t))\n-\tt = BINFO_INHERITANCE_CHAIN (t);\n-\n-      if (!DERIVED_FROM_P (derived, BINFO_TYPE (t)))\n-\treturn 0;\n-    }\n+  if (DECL_NONSTATIC_MEMBER_P (decl)\n+      && !DERIVED_FROM_P (derived, otype))\n+    return 0;\n \n   return 1;\n }\n \n-/* Returns nonzero if SCOPE is a friend of a type which would be able\n-   to access DECL through the object indicated by BINFO.  */\n+/* Returns nonzero if SCOPE is a type or a friend of a type which would be able\n+   to access DECL through TYPE.  OTYPE is the type of the object.  */\n \n static int\n-friend_accessible_p (tree scope, tree decl, tree binfo)\n+friend_accessible_p (tree scope, tree decl, tree type, tree otype)\n {\n+  /* We're checking this clause from [class.access.base]\n+\n+       m as a member of N is protected, and the reference occurs in a\n+       member or friend of class N, or in a member or friend of a\n+       class P derived from N, where m as a member of P is public, private\n+       or protected.\n+\n+    Here DECL is m and TYPE is N.  SCOPE is the current context,\n+    and we check all its possible Ps.  */\n   tree befriending_classes;\n   tree t;\n \n   if (!scope)\n     return 0;\n \n+  /* Is SCOPE itself a suitable P?  */\n+  if (TYPE_P (scope) && protected_accessible_p (decl, scope, type, otype))\n+    return 1;\n+\n   if (DECL_DECLARES_FUNCTION_P (scope))\n     befriending_classes = DECL_BEFRIENDING_CLASSES (scope);\n   else if (TYPE_P (scope))\n@@ -783,54 +805,113 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n     return 0;\n \n   for (t = befriending_classes; t; t = TREE_CHAIN (t))\n-    if (protected_accessible_p (decl, TREE_VALUE (t), binfo))\n+    if (protected_accessible_p (decl, TREE_VALUE (t), type, otype))\n       return 1;\n \n   /* Nested classes have the same access as their enclosing types, as\n-     per DR 45 (this is a change from the standard).  */\n+     per DR 45 (this is a change from C++98).  */\n   if (TYPE_P (scope))\n-    for (t = TYPE_CONTEXT (scope); t && TYPE_P (t); t = TYPE_CONTEXT (t))\n-      if (protected_accessible_p (decl, t, binfo))\n-\treturn 1;\n+    if (friend_accessible_p (TYPE_CONTEXT (scope), decl, type, otype))\n+      return 1;\n \n   if (DECL_DECLARES_FUNCTION_P (scope))\n     {\n       /* Perhaps this SCOPE is a member of a class which is a\n \t friend.  */\n       if (DECL_CLASS_SCOPE_P (scope)\n-\t  && friend_accessible_p (DECL_CONTEXT (scope), decl, binfo))\n+\t  && friend_accessible_p (DECL_CONTEXT (scope), decl, type, otype))\n \treturn 1;\n+    }\n \n-      /* Or an instantiation of something which is a friend.  */\n-      if (DECL_TEMPLATE_INFO (scope))\n+  /* Maybe scope's template is a friend.  */\n+  if (tree tinfo = get_template_info (scope))\n+    {\n+      tree tmpl = TI_TEMPLATE (tinfo);\n+      if (DECL_CLASS_TEMPLATE_P (tmpl))\n+\ttmpl = TREE_TYPE (tmpl);\n+      else\n+\ttmpl = DECL_TEMPLATE_RESULT (tmpl);\n+      if (tmpl != scope)\n \t{\n-\t  int ret;\n \t  /* Increment processing_template_decl to make sure that\n \t     dependent_type_p works correctly.  */\n \t  ++processing_template_decl;\n-\t  ret = friend_accessible_p (DECL_TI_TEMPLATE (scope), decl, binfo);\n+\t  int ret = friend_accessible_p (tmpl, decl, type, otype);\n \t  --processing_template_decl;\n-\t  return ret;\n+\t  if (ret)\n+\t    return 1;\n \t}\n     }\n \n+  /* If is_friend is true, we should have found a befriending class.  */\n+  gcc_checking_assert (!is_friend (type, scope));\n+\n   return 0;\n }\n \n+struct dfs_accessible_data\n+{\n+  tree decl;\n+  tree object_type;\n+};\n+\n+/* Avoid walking up past a declaration of the member.  */\n+\n+static tree\n+dfs_accessible_pre (tree binfo, void *data)\n+{\n+  dfs_accessible_data *d = (dfs_accessible_data *)data;\n+  tree type = BINFO_TYPE (binfo);\n+  if (member_declared_in_type (d->decl, type))\n+    return dfs_skip_bases;\n+  return NULL_TREE;\n+}\n+\n /* Called via dfs_walk_once_accessible from accessible_p */\n \n static tree\n-dfs_accessible_post (tree binfo, void * /*data*/)\n+dfs_accessible_post (tree binfo, void *data)\n {\n-  if (BINFO_ACCESS (binfo) != ak_none)\n+  /* access_in_type already set BINFO_ACCESS for us.  */\n+  access_kind access = BINFO_ACCESS (binfo);\n+  tree N = BINFO_TYPE (binfo);\n+  dfs_accessible_data *d = (dfs_accessible_data *)data;\n+  tree decl = d->decl;\n+  tree scope = current_nonlambda_scope ();\n+\n+  /* A member m is accessible at the point R when named in class N if */\n+  switch (access)\n     {\n-      tree scope = current_scope ();\n-      if (scope && TREE_CODE (scope) != NAMESPACE_DECL\n-\t  && is_friend (BINFO_TYPE (binfo), scope))\n-\treturn binfo;\n-    }\n+    case ak_none:\n+      return NULL_TREE;\n \n-  return NULL_TREE;\n+    case ak_public:\n+      /* m as a member of N is public, or */\n+      return binfo;\n+\n+    case ak_private:\n+      {\n+\t/* m as a member of N is private, and R occurs in a member or friend of\n+\t   class N, or */\n+\tif (scope && TREE_CODE (scope) != NAMESPACE_DECL\n+\t    && is_friend (N, scope))\n+\t  return binfo;\n+\treturn NULL_TREE;\n+      }\n+\n+    case ak_protected:\n+      {\n+\t/* m as a member of N is protected, and R occurs in a member or friend\n+\t   of class N, or in a member or friend of a class P derived from N,\n+\t   where m as a member of P is public, private, or protected  */\n+\tif (friend_accessible_p (scope, decl, N, d->object_type))\n+\t  return binfo;\n+\treturn NULL_TREE;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* Like accessible_p below, but within a template returns true iff DECL is\n@@ -858,21 +939,15 @@ int\n accessible_p (tree type, tree decl, bool consider_local_p)\n {\n   tree binfo;\n-  tree scope;\n   access_kind access;\n \n-  /* Nonzero if it's OK to access DECL if it has protected\n-     accessibility in TYPE.  */\n-  int protected_ok = 0;\n-\n   /* If this declaration is in a block or namespace scope, there's no\n      access control.  */\n   if (!TYPE_P (context_for_name_lookup (decl)))\n     return 1;\n \n   /* There is no need to perform access checks inside a thunk.  */\n-  scope = current_scope ();\n-  if (scope && DECL_THUNK_P (scope))\n+  if (current_function_decl && DECL_THUNK_P (current_function_decl))\n     return 1;\n \n   /* In a template declaration, we cannot be sure whether the\n@@ -886,13 +961,18 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n       && (!processing_template_parmlist || processing_template_decl > 1))\n     return 1;\n \n+  tree otype;\n   if (!TYPE_P (type))\n     {\n-      binfo = type;\n+      /* When accessing a non-static member, the most derived type in the\n+\t binfo chain is the type of the object; remember that type for\n+\t protected_accessible_p.  */\n+      for (tree b = type; b; b = BINFO_INHERITANCE_CHAIN (b))\n+\totype = BINFO_TYPE (b);\n       type = BINFO_TYPE (type);\n     }\n   else\n-    binfo = TYPE_BINFO (type);\n+    otype = type;\n \n   /* [class.access.base]\n \n@@ -905,48 +985,36 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n \n      --m as a member of N is protected, and the reference occurs in a\n        member or friend of class N, or in a member or friend of a\n-       class P derived from N, where m as a member of P is private or\n+       class P derived from N, where m as a member of P is public, private or\n        protected, or\n \n      --there exists a base class B of N that is accessible at the point\n        of reference, and m is accessible when named in class B.\n \n     We walk the base class hierarchy, checking these conditions.  */\n \n-  if (consider_local_p)\n-    {\n-      /* Figure out where the reference is occurring.  Check to see if\n-\t DECL is private or protected in this scope, since that will\n-\t determine whether protected access is allowed.  */\n-      tree ct = current_nonlambda_class_type ();\n-      if (ct)\n-\tprotected_ok = protected_accessible_p (decl,\n-\t\t\t\t\t       ct,\n-\t\t\t\t\t       binfo);\n-\n-      /* Now, loop through the classes of which we are a friend.  */\n-      if (!protected_ok)\n-\tprotected_ok = friend_accessible_p (scope, decl, binfo);\n-    }\n-\n-  /* Standardize the binfo that access_in_type will use.  We don't\n-     need to know what path was chosen from this point onwards.  */\n+  /* We walk using TYPE_BINFO (type) because access_in_type will set\n+     BINFO_ACCESS on it and its bases.  */\n   binfo = TYPE_BINFO (type);\n \n   /* Compute the accessibility of DECL in the class hierarchy\n      dominated by type.  */\n   access = access_in_type (type, decl);\n-  if (access == ak_public\n-      || (access == ak_protected && protected_ok))\n+  if (access == ak_public)\n     return 1;\n \n+  /* If we aren't considering the point of reference, only the first bullet\n+     applies.  */\n   if (!consider_local_p)\n     return 0;\n \n+  dfs_accessible_data d = { decl, otype };\n+\n   /* Walk the hierarchy again, looking for a base class that allows\n      access.  */\n   return dfs_walk_once_accessible (binfo, /*friends=*/true,\n-\t\t\t\t   NULL, dfs_accessible_post, NULL)\n+\t\t\t\t   dfs_accessible_pre,\n+\t\t\t\t   dfs_accessible_post, &d)\n     != NULL_TREE;\n }\n "}, {"sha": "cdbc6404393373f25dd527cfb31415be30f036bb", "filename": "gcc/testsuite/g++.dg/inherit/access9.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac2c0bd17900b3c0e078479b46de64563a16c9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess9.C?ref=7ac2c0bd17900b3c0e078479b46de64563a16c9f", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/66957\n+\n+class BaseClass {\n+protected:\n+  static int x;\n+};\n+\n+struct DerivedA : BaseClass { };\n+\n+struct DerivedB : BaseClass {\n+  DerivedB() {\n+    (void) DerivedA::x;\n+  }\n+};"}]}