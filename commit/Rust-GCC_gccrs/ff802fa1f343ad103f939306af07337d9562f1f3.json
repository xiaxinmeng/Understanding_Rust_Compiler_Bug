{"sha": "ff802fa1f343ad103f939306af07337d9562f1f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY4MDJmYTFmMzQzYWQxMDNmOTM5MzA2YWYwNzMzN2Q5NTYyZjFmMw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-09-16T10:35:14Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-09-16T10:35:14Z"}, "message": "tree-vectorizer.c: Fix documentation.\n\n\n\t* tree-vectorizer.c: Fix documentation.\n\t* tree-vectorizer.h (vinfo_for_stmt): Add documentation.\n\t(set_vinfo_for_stmt, get_earlier_stmt, get_later_stmt,\n\tis_pattern_stmt_p, is_loop_header_bb_p,\n\tstmt_vinfo_set_inside_of_loop_cost,\n\tstmt_vinfo_set_outside_of_loop_cost, vect_pow2, aligned_access_p,\n\tknown_alignment_for_access_p): Likewise.\n\t* tree-vect-loop.c: Fix documentation.\n\t(vect_get_cost): Start function name from new line.\n\t* tree-vect-data-refs.c: Fix documentation.\n\t* tree-vect_stmts.c: Likewise.\n\t(vect_create_vectorized_promotion_stmts): Always free vec_tmp.\n\t(vectorizable_store): Free vec_oprnds if allocated.\n\t(vectorizable_condition): Initialize several variables to avoid\n\twarnings.\n\t* tree-vect-slp.c: Fix documentation.\n\nFrom-SVN: r164332", "tree": {"sha": "1b8076fd27c4e11e7eb98f7f94307a62c81cb22b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b8076fd27c4e11e7eb98f7f94307a62c81cb22b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff802fa1f343ad103f939306af07337d9562f1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff802fa1f343ad103f939306af07337d9562f1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff802fa1f343ad103f939306af07337d9562f1f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff802fa1f343ad103f939306af07337d9562f1f3/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6be14c0ebc4ba0c43a78a54254c89e07cb2cfc48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be14c0ebc4ba0c43a78a54254c89e07cb2cfc48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be14c0ebc4ba0c43a78a54254c89e07cb2cfc48"}], "stats": {"total": 524, "additions": 296, "deletions": 228}, "files": [{"sha": "2730b6a71ceef36cfd5dbc9547e605230e240428", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -1,3 +1,22 @@\n+2010-09-16  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.c: Fix documentation.\n+\t* tree-vectorizer.h (vinfo_for_stmt): Add documentation.\n+\t(set_vinfo_for_stmt, get_earlier_stmt, get_later_stmt,\n+\tis_pattern_stmt_p, is_loop_header_bb_p,\n+\tstmt_vinfo_set_inside_of_loop_cost,\n+\tstmt_vinfo_set_outside_of_loop_cost, vect_pow2, aligned_access_p,\n+\tknown_alignment_for_access_p): Likewise.\n+\t* tree-vect-loop.c: Fix documentation.\n+\t(vect_get_cost): Start function name from new line.\n+\t* tree-vect-data-refs.c: Fix documentation.\n+\t* tree-vect_stmts.c: Likewise.\n+\t(vect_create_vectorized_promotion_stmts): Always free vec_tmp.\n+\t(vectorizable_store): Free vec_oprnds if allocated.\n+\t(vectorizable_condition): Initialize several variables to avoid\n+\twarnings.\n+\t* tree-vect-slp.c: Fix documentation.\n+\n 2010-09-16  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (tree_node_structure_for_code): TRANSLATION_UNIT_DECL"}, {"sha": "c3360f33cc3c291a417c7b674c1276d176577df7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -1,3 +1,9 @@\n+2010-09-16  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/bb-slp-8.c: Fix documentation, add space between function\n+\tname and parentheses.\n+\t* gcc.dg/vect/bb-slp-8a.c, gcc.dg/vect/bb-slp-8b.c: Likewise.\n+\n 2010-09-15  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/parse/parameter-declaration-2.C: New."}, {"sha": "c5d661a463953cfe12fe60df2d70015ffe2b6995", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -15,8 +15,8 @@ main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n   int i;\n   unsigned int a0, a1, a2, a3;\n  \n-  /* pin and pout may alias. But since all the loads are before the first store\n-     the basic block is vectorizable.  */\n+  /* pin and pout may alias.  But since all the loads are before the first\n+     store the basic block is vectorizable.  */\n   a0 = *pin++ + 23;\n   a1 = *pin++ + 142;\n   a2 = *pin++ + 2;\n@@ -35,7 +35,7 @@ main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n       || out[1] != (in[1] + 142) * y\n       || out[2] != (in[2] + 2) * x\n       || out[3] != (in[3] + 31) * y)\n-    abort();\n+    abort ();\n \n   return 0;\n }"}, {"sha": "08c053b15596f8d9226098c12e338efd58b72e46", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8a.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8a.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -15,7 +15,7 @@ main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n   int i;\n   unsigned int a0, a1, a2, a3;\n  \n-  /* pin and pout may alias, and loads and stores are mixed. The basic block \n+  /* pin and pout may alias, and loads and stores are mixed.  The basic block\n      cannot be vectorized.  */\n   a0 = *pin++ + 23;\n   *pout++ = a0 * x;\n@@ -34,7 +34,7 @@ main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n       || out[1] != (in[1] + 142) * y\n       || out[2] != (in[2] + 2) * x\n       || out[3] != (in[3] + 31) * y)\n-    abort();\n+    abort ();\n \n   return 0;\n }"}, {"sha": "60f4fdb7959e0465b92ad212f53e1ee64a448398", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8b.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8b.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -36,7 +36,7 @@ main1 (unsigned int x, unsigned int y)\n       || out[1] != (in[1] + 142) * y\n       || out[2] != (in[2] + 2) * x\n       || out[3] != (in[3] + 31) * y)\n-    abort();\n+    abort ();\n \n   return 0;\n }"}, {"sha": "0d1e33817383c8dc3e659241474fc003f1ac1415", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 82, "deletions": 80, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -45,19 +45,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n \n /* Return the smallest scalar part of STMT.\n-   This is used to determine the vectype of the stmt. We generally set the\n-   vectype according to the type of the result (lhs). For stmts whose\n+   This is used to determine the vectype of the stmt.  We generally set the\n+   vectype according to the type of the result (lhs).  For stmts whose\n    result-type is different than the type of the arguments (e.g., demotion,\n    promotion), vectype will be reset appropriately (later).  Note that we have\n    to visit the smallest datatype in this function, because that determines the\n-   VF. If the smallest datatype in the loop is present only as the rhs of a\n+   VF.  If the smallest datatype in the loop is present only as the rhs of a\n    promotion operation - we'd miss it.\n    Such a case, where a variable of this datatype does not appear in the lhs\n    anywhere in the loop, can only occur if it's an invariant: e.g.:\n    'int_x = (int) short_inv', which we'd expect to have been optimized away by\n-   invariant motion. However, we cannot rely on invariant motion to always take\n-   invariants out of the loop, and so in the case of promotion we also have to\n-   check the rhs.\n+   invariant motion.  However, we cannot rely on invariant motion to always\n+   take invariants out of the loop, and so in the case of promotion we also\n+   have to check the rhs.\n    LHS_SIZE_UNIT and RHS_SIZE_UNIT contain the sizes of the corresponding\n    types.  */\n \n@@ -89,7 +89,7 @@ vect_get_smallest_scalar_type (gimple stmt, HOST_WIDE_INT *lhs_size_unit,\n \n \n /* Find the place of the data-ref in STMT in the interleaving chain that starts\n-   from FIRST_STMT. Return -1 if the data-ref is not a part of the chain.  */\n+   from FIRST_STMT.  Return -1 if the data-ref is not a part of the chain.  */\n \n int\n vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n@@ -151,7 +151,7 @@ vect_insert_into_interleaving_chain (struct data_reference *dra,\n /* Function vect_update_interleaving_chain.\n \n    For two data-refs DRA and DRB that are a part of a chain interleaved data\n-   accesses, update the interleaving chain. DRB's INIT is smaller than DRA's.\n+   accesses, update the interleaving chain.  DRB's INIT is smaller than DRA's.\n \n    There are four possible cases:\n    1. New stmts - both DRA and DRB are not a part of any chain:\n@@ -211,7 +211,7 @@ vect_update_interleaving_chain (struct data_reference *drb,\n       if (tree_int_cst_compare (init_old, DR_INIT (drb)) > 0)\n \t{\n \t  /* DRB's init is smaller than the init of the stmt previously marked\n-\t     as the first stmt of the interleaving chain of DRA. Therefore, we\n+\t     as the first stmt of the interleaving chain of DRA.  Therefore, we\n \t     update FIRST_STMT and put DRB in the head of the list.  */\n \t  DR_GROUP_FIRST_DR (stmtinfo_b) = DR_STMT (drb);\n \t  DR_GROUP_NEXT_DR (stmtinfo_b) = old_first_stmt;\n@@ -323,7 +323,11 @@ vect_equal_offsets (tree offset1, tree offset2)\n }\n \n \n-/* Check dependence between DRA and DRB for basic block vectorization.  */\n+/* Check dependence between DRA and DRB for basic block vectorization.\n+   If the accesses share same bases and offsets, we can compare their initial\n+   constant offsets to decide whether they differ or not.  In case of a read-\n+   write dependence we check that the load is before the store to ensure that\n+   vectorization will not change the order of the accesses.  */\n \n static bool\n vect_drs_dependent_in_basic_block (struct data_reference *dra,\n@@ -342,7 +346,7 @@ vect_drs_dependent_in_basic_block (struct data_reference *dra,\n         return true;\n     }\n \n-  /* Check that the data-refs have same bases and offsets. If not, we can't\n+  /* Check that the data-refs have same bases and offsets.  If not, we can't\n      determine if they are dependent.  */\n   if ((DR_BASE_ADDRESS (dra) != DR_BASE_ADDRESS (drb)\n        && (TREE_CODE (DR_BASE_ADDRESS (dra)) != ADDR_EXPR\n@@ -368,10 +372,10 @@ vect_drs_dependent_in_basic_block (struct data_reference *dra,\n   if (init_a != init_b)\n     return false;\n \n-  /* We have a read-write dependence. Check that the load is before the store.\n+  /* We have a read-write dependence.  Check that the load is before the store.\n      When we vectorize basic blocks, vector load can be only before \n      corresponding scalar load, and vector store can be only after its\n-     corresponding scalar store. So the order of the acceses is preserved in \n+     corresponding scalar store.  So the order of the acceses is preserved in\n      case the load is before the store.  */\n   earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));   \n   if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n@@ -383,7 +387,7 @@ vect_drs_dependent_in_basic_block (struct data_reference *dra,\n \n /* Function vect_check_interleaving.\n \n-   Check if DRA and DRB are a part of interleaving. In case they are, insert\n+   Check if DRA and DRB are a part of interleaving.  In case they are, insert\n    DRA and DRB in an interleaving chain.  */\n \n static bool\n@@ -813,7 +817,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   /* In case the dataref is in an inner-loop of the loop that is being\n      vectorized (LOOP), we use the base and misalignment information\n-     relative to the outer-loop (LOOP). This is ok only if the misalignment\n+     relative to the outer-loop (LOOP).  This is ok only if the misalignment\n      stays the same throughout the execution of the inner-loop, which is why\n      we have to check that the stride of the dataref in the inner-loop evenly\n      divides by the vector size.  */\n@@ -1241,8 +1245,8 @@ vect_peeling_hash_get_most_frequent (void **slot, void *data)\n }\n \n \n-/* Traverse peeling hash table and calculate cost for each peeling option. Find\n-   one with the lowest cost.  */\n+/* Traverse peeling hash table and calculate cost for each peeling option.\n+   Find the one with the lowest cost.  */\n \n static int\n vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n@@ -1326,15 +1330,15 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n    the alignment of data references in the loop.\n \n    FOR NOW: we assume that whatever versioning/peeling takes place, only the\n-   original loop is to be vectorized; Any other loops that are created by\n+   original loop is to be vectorized.  Any other loops that are created by\n    the transformations performed in this pass - are not supposed to be\n-   vectorized. This restriction will be relaxed.\n+   vectorized.  This restriction will be relaxed.\n \n    This pass will require a cost model to guide it whether to apply peeling\n-   or versioning or a combination of the two. For example, the scheme that\n+   or versioning or a combination of the two.  For example, the scheme that\n    intel uses when given a loop with several memory accesses, is as follows:\n    choose one memory access ('p') which alignment you want to force by doing\n-   peeling. Then, either (1) generate a loop in which 'p' is aligned and all\n+   peeling.  Then, either (1) generate a loop in which 'p' is aligned and all\n    other accesses are not necessarily aligned, or (2) use loop versioning to\n    generate one loop in which all accesses are aligned, and another loop in\n    which only 'p' is necessarily aligned.\n@@ -1343,9 +1347,9 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n    Aart J.C. Bik, Milind Girkar, Paul M. Grey and Ximmin Tian, International\n    Journal of Parallel Programming, Vol. 30, No. 2, April 2002.)\n \n-   Devising a cost model is the most critical aspect of this work. It will\n+   Devising a cost model is the most critical aspect of this work.  It will\n    guide us on which access to peel for, whether to use loop versioning, how\n-   many versions to create, etc. The cost model will probably consist of\n+   many versions to create, etc.  The cost model will probably consist of\n    generic considerations as well as target specific considerations (on\n    powerpc for example, misaligned stores are more painful than misaligned\n    loads).\n@@ -1406,7 +1410,7 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n \t}\n      }\n \n-     These loops are later passed to loop_transform to be vectorized. The\n+     These loops are later passed to loop_transform to be vectorized.  The\n      vectorizer will use the alignment information to guide the transformation\n      (whether to generate regular loads/stores, or with special handling for\n      misalignment).  */\n@@ -1500,11 +1504,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               npeel_tmp = (nelements - mis) % vf;\n \n               /* For multiple types, it is possible that the bigger type access\n-                 will have more than one peeling option. E.g., a loop with two\n+                 will have more than one peeling option.  E.g., a loop with two\n                  types: one of size (vector size / 4), and the other one of\n-                 size (vector size / 8). Vectorization factor will 8. If both\n+                 size (vector size / 8).  Vectorization factor will 8.  If both\n                  access are misaligned by 3, the first one needs one scalar\n-                 iteration to be aligned, and the second one needs 5. But the\n+                 iteration to be aligned, and the second one needs 5.  But the\n                  the first one will be aligned also by peeling 5 scalar\n                  iterations, and in that case both accesses will be aligned.\n                  Hence, except for the immediate peeling amount, we also want\n@@ -1996,7 +2000,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n \n \n /* Analyze groups of strided accesses: check that DR belongs to a group of\n-   strided accesses of legal size, step, etc. Detect gaps, single element\n+   strided accesses of legal size, step, etc.  Detect gaps, single element\n    interleaving, and other special cases. Set strided access info.\n    Collect groups of strided stores for further use in SLP analysis.  */\n \n@@ -2072,9 +2076,10 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       while (next)\n         {\n-          /* Skip same data-refs. In case that two or more stmts share data-ref\n-             (supported only for loads), we vectorize only the first stmt, and\n-             the rest get their vectorized loads from the first one.  */\n+          /* Skip same data-refs.  In case that two or more stmts share\n+             data-ref (supported only for loads), we vectorize only the first\n+             stmt, and the rest get their vectorized loads from the first\n+             one.  */\n           if (!tree_int_cst_compare (DR_INIT (data_ref),\n                                      DR_INIT (STMT_VINFO_DATA_REF (\n \t\t\t\t\t\t   vinfo_for_stmt (next)))))\n@@ -2196,7 +2201,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       /* FORNOW: we handle only interleaving that is a power of 2.\n          We don't fail here if it may be still possible to vectorize the\n-         group using SLP. If not, the size of the group will be checked in\n+         group using SLP.  If not, the size of the group will be checked in\n          vect_analyze_operations, and the vectorization will fail.  */\n       if (exact_log2 (stride) == -1)\n \t{\n@@ -2483,8 +2488,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n     }\n \n-  /* Go through the data-refs, check that the analysis succeeded. Update pointer\n-     from stmt_vec_info struct to DR and vectype.  */\n+  /* Go through the data-refs, check that the analysis succeeded.  Update\n+     pointer from stmt_vec_info struct to DR and vectype.  */\n \n   FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n@@ -2572,7 +2577,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  tree dinit;\n \n \t  /* Build a reference to the first location accessed by the\n-\t     inner-loop: *(BASE+INIT). (The first location is actually\n+\t     inner-loop: *(BASE+INIT).  (The first location is actually\n \t     BASE+INIT+OFFSET, but we add OFFSET separately later).  */\n           tree inner_base = build_fold_indirect_ref\n                                 (fold_build2 (POINTER_PLUS_EXPR,\n@@ -2712,7 +2717,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n /* Function vect_get_new_vect_var.\n \n-   Returns a name for a new variable. The current naming scheme appends the\n+   Returns a name for a new variable.  The current naming scheme appends the\n    prefix \"vect_\" or \"vect_p\" (depending on the value of VAR_KIND) to\n    the name of vectorizer generated variables, and appends that to NAME if\n    provided.  */\n@@ -2767,7 +2772,7 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n    LOOP:    Specify relative to which loop-nest should the address be computed.\n             For example, when the dataref is in an inner-loop nested in an\n \t    outer-loop that is now being vectorized, LOOP can be either the\n-\t    outer-loop, or the inner-loop. The first memory location accessed\n+\t    outer-loop, or the inner-loop.  The first memory location accessed\n \t    by the following dataref ('in' points to short):\n \n \t\tfor (i=0; i<N; i++)\n@@ -2937,7 +2942,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n       Return the increment stmt that updates the pointer in PTR_INCR.\n \n    3. Set INV_P to true if the access pattern of the data reference in the\n-      vectorized loop is invariant. Set it to false otherwise.\n+      vectorized loop is invariant.  Set it to false otherwise.\n \n    4. Return the pointer.  */\n \n@@ -3017,7 +3022,7 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n       print_generic_expr (vect_dump, base_name, TDF_SLIM);\n     }\n \n-  /** (1) Create the new vector-pointer variable:  **/\n+  /* (1) Create the new vector-pointer variable.  */\n   vect_ptr_type = build_pointer_type (vectype);\n   base = get_base_address (DR_REF (dr));\n   if (base\n@@ -3067,16 +3072,16 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \n   add_referenced_var (vect_ptr);\n \n-  /** Note: If the dataref is in an inner-loop nested in LOOP, and we are\n-      vectorizing LOOP (i.e. outer-loop vectorization), we need to create two\n-      def-use update cycles for the pointer: One relative to the outer-loop\n-      (LOOP), which is what steps (3) and (4) below do. The other is relative\n-      to the inner-loop (which is the inner-most loop containing the dataref),\n-      and this is done be step (5) below.\n+  /* Note: If the dataref is in an inner-loop nested in LOOP, and we are\n+     vectorizing LOOP (i.e., outer-loop vectorization), we need to create two\n+     def-use update cycles for the pointer: one relative to the outer-loop\n+     (LOOP), which is what steps (3) and (4) below do.  The other is relative\n+     to the inner-loop (which is the inner-most loop containing the dataref),\n+     and this is done be step (5) below.\n \n-      When vectorizing inner-most loops, the vectorized loop (LOOP) is also the\n-      inner-most loop, and so steps (3),(4) work the same, and step (5) is\n-      redundant.  Steps (3),(4) create the following:\n+     When vectorizing inner-most loops, the vectorized loop (LOOP) is also the\n+     inner-most loop, and so steps (3),(4) work the same, and step (5) is\n+     redundant.  Steps (3),(4) create the following:\n \n \tvp0 = &base_addr;\n \tLOOP:\tvp1 = phi(vp0,vp2)\n@@ -3085,8 +3090,8 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\tvp2 = vp1 + step\n \t\tgoto LOOP\n \n-      If there is an inner-loop nested in loop, then step (5) will also be\n-      applied, and an additional update in the inner-loop will be created:\n+     If there is an inner-loop nested in loop, then step (5) will also be\n+     applied, and an additional update in the inner-loop will be created:\n \n \tvp0 = &base_addr;\n \tLOOP:   vp1 = phi(vp0,vp2)\n@@ -3098,8 +3103,8 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\tvp2 = vp1 + step\n \t\tif () goto LOOP   */\n \n-  /** (3) Calculate the initial address the vector-pointer, and set\n-          the vector-pointer to point to it before the loop:  **/\n+  /* (2) Calculate the initial address the vector-pointer, and set\n+         the vector-pointer to point to it before the loop.  */\n \n   /* Create: (&(base[init_val+offset]) in the loop preheader.  */\n \n@@ -3140,10 +3145,9 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n   else\n     vect_ptr_init = new_temp;\n \n-  /** (4) Handle the updating of the vector-pointer inside the loop.\n-\t  This is needed when ONLY_INIT is false, and also when AT_LOOP\n-\t  is the inner-loop nested in LOOP (during outer-loop vectorization).\n-   **/\n+  /* (3) Handle the updating of the vector-pointer inside the loop.\n+     This is needed when ONLY_INIT is false, and also when AT_LOOP is the\n+     inner-loop nested in LOOP (during outer-loop vectorization).  */\n \n   /* No update in loop is required.  */\n   if (only_init && (!loop_vinfo || at_loop == loop))\n@@ -3182,8 +3186,8 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n     return vptr;\n \n \n-  /** (5) Handle the updating of the vector-pointer inside the inner-loop\n-\t  nested in LOOP, if exists: **/\n+  /* (4) Handle the updating of the vector-pointer inside the inner-loop\n+     nested in LOOP, if exists.  */\n \n   gcc_assert (nested_in_vect_loop);\n   if (!only_init)\n@@ -3358,12 +3362,12 @@ vect_strided_store_supported (tree vectype)\n \n    Given a chain of interleaved stores in DR_CHAIN of LENGTH that must be\n    a power of 2, generate interleave_high/low stmts to reorder the data\n-   correctly for the stores. Return the final references for stores in\n+   correctly for the stores.  Return the final references for stores in\n    RESULT_CHAIN.\n \n    E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n-   The input is 4 vectors each containing 8 elements. We assign a number to each\n-   element, the input sequence is:\n+   The input is 4 vectors each containing 8 elements.  We assign a number to\n+   each element, the input sequence is:\n \n    1st vec:   0  1  2  3  4  5  6  7\n    2nd vec:   8  9 10 11 12 13 14 15\n@@ -3379,18 +3383,18 @@ vect_strided_store_supported (tree vectype)\n \n    i.e., we interleave the contents of the four vectors in their order.\n \n-   We use interleave_high/low instructions to create such output. The input of\n+   We use interleave_high/low instructions to create such output.  The input of\n    each interleave_high/low operation is two vectors:\n    1st vec    2nd vec\n    0 1 2 3    4 5 6 7\n    the even elements of the result vector are obtained left-to-right from the\n-   high/low elements of the first vector. The odd elements of the result are\n+   high/low elements of the first vector.  The odd elements of the result are\n    obtained left-to-right from the high/low elements of the second vector.\n    The output of interleave_high will be:   0 4 1 5\n    and of interleave_low:                   2 6 3 7\n \n \n-   The permutation is done in log LENGTH stages. In each stage interleave_high\n+   The permutation is done in log LENGTH stages.  In each stage interleave_high\n    and interleave_low stmts are created for each pair of vectors in DR_CHAIN,\n    where the first argument is taken from the first half of DR_CHAIN and the\n    second argument from it's second half.\n@@ -3582,8 +3586,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n      1. the misalignment computation\n      2. the extra vector load (for the optimized realignment scheme).\n      3. the phi node for the two vectors from which the realignment is\n-      done (for the optimized realignment scheme).\n-   */\n+      done (for the optimized realignment scheme).  */\n \n   /* 1. Determine where to generate the misalignment computation.\n \n@@ -3807,7 +3810,7 @@ vect_strided_load_supported (tree vectype)\n \n    Given a chain of interleaved loads in DR_CHAIN of LENGTH that must be\n    a power of 2, generate extract_even/odd stmts to reorder the input data\n-   correctly. Return the final references for loads in RESULT_CHAIN.\n+   correctly.  Return the final references for loads in RESULT_CHAIN.\n \n    E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n    The input is 4 vectors each containing 8 elements. We assign a number to each\n@@ -3828,19 +3831,19 @@ vect_strided_load_supported (tree vectype)\n    i.e., the first output vector should contain the first elements of each\n    interleaving group, etc.\n \n-   We use extract_even/odd instructions to create such output. The input of each\n-   extract_even/odd operation is two vectors\n+   We use extract_even/odd instructions to create such output.  The input of\n+   each extract_even/odd operation is two vectors\n    1st vec    2nd vec\n    0 1 2 3    4 5 6 7\n \n-   and the output is the vector of extracted even/odd elements. The output of\n+   and the output is the vector of extracted even/odd elements.  The output of\n    extract_even will be:   0 2 4 6\n    and of extract_odd:     1 3 5 7\n \n \n-   The permutation is done in log LENGTH stages. In each stage extract_even and\n-   extract_odd stmts are created for each pair of vectors in DR_CHAIN in their\n-   order. In our example,\n+   The permutation is done in log LENGTH stages.  In each stage extract_even\n+   and extract_odd stmts are created for each pair of vectors in DR_CHAIN in\n+   their order.  In our example,\n \n    E1: extract_even (1st vec, 2nd vec)\n    E2: extract_odd (1st vec, 2nd vec)\n@@ -3977,13 +3980,12 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n       if (!next_stmt)\n \tbreak;\n \n-      /* Skip the gaps. Loads created for the gaps will be removed by dead\n-       code elimination pass later. No need to check for the first stmt in\n+      /* Skip the gaps.  Loads created for the gaps will be removed by dead\n+       code elimination pass later.  No need to check for the first stmt in\n        the group, since it always exists.\n        DR_GROUP_GAP is the number of steps in elements from the previous\n-       access (if there is no gap DR_GROUP_GAP is 1). We skip loads that\n-       correspond to the gaps.\n-      */\n+       access (if there is no gap DR_GROUP_GAP is 1).  We skip loads that\n+       correspond to the gaps.  */\n       if (next_stmt != first_stmt\n           && gap_count < DR_GROUP_GAP (vinfo_for_stmt (next_stmt)))\n       {\n@@ -4088,8 +4090,8 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \n   /* We can choose between using the implicit realignment scheme (generating\n      a misaligned_move stmt) and the explicit realignment scheme (generating\n-     aligned loads with a REALIGN_LOAD). There are two variants to the explicit\n-     realignment scheme: optimized, and unoptimized.\n+     aligned loads with a REALIGN_LOAD).  There are two variants to the\n+     explicit realignment scheme: optimized, and unoptimized.\n      We can optimize the realignment only if the step between consecutive\n      vector loads is equal to the vector size.  Since the vector memory\n      accesses advance in steps of VS (Vector Size) in the vectorized loop, it"}, {"sha": "95b36f76f15adf605e978463117efebc1dea8473", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -76,7 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n    had successfully passed the analysis phase.\n         Throughout this pass we make a distinction between two types of\n    data: scalars (which are represented by SSA_NAMES), and memory references\n-   (\"data-refs\"). These two types of data require different handling both\n+   (\"data-refs\").  These two types of data require different handling both\n    during analysis and transformation. The types of data-refs that the\n    vectorizer currently supports are ARRAY_REFS which base is an array DECL\n    (not a pointer), and INDIRECT_REFS through pointers; both array and pointer\n@@ -97,10 +97,10 @@ along with GCC; see the file COPYING3.  If not see\n    =====================\n         The loop transformation phase scans all the stmts in the loop, and\n    creates a vector stmt (or a sequence of stmts) for each scalar stmt S in\n-   the loop that needs to be vectorized. It inserts the vector code sequence\n+   the loop that needs to be vectorized.  It inserts the vector code sequence\n    just before the scalar stmt S, and records a pointer to the vector code\n    in STMT_VINFO_VEC_STMT (stmt_info) (stmt_info is the stmt_vec_info struct\n-   attached to S). This pointer will be used for the vectorization of following\n+   attached to S).  This pointer will be used for the vectorization of following\n    stmts which use the def of stmt S. Stmt S is removed if it writes to memory;\n    otherwise, we rely on dead code elimination for removing it.\n \n@@ -112,7 +112,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    To vectorize stmt S2, the vectorizer first finds the stmt that defines\n    the operand 'b' (S1), and gets the relevant vector def 'vb' from the\n-   vector stmt VS1 pointed to by STMT_VINFO_VEC_STMT (stmt_info (S1)). The\n+   vector stmt VS1 pointed to by STMT_VINFO_VEC_STMT (stmt_info (S1)).  The\n    resulting sequence would be:\n \n    VS1: vb = px[i];\n@@ -128,13 +128,13 @@ along with GCC; see the file COPYING3.  If not see\n         Currently the only target specific information that is used is the\n    size of the vector (in bytes) - \"TARGET_VECTORIZE_UNITS_PER_SIMD_WORD\".\n    Targets that can support different sizes of vectors, for now will need\n-   to specify one value for \"TARGET_VECTORIZE_UNITS_PER_SIMD_WORD\". More\n+   to specify one value for \"TARGET_VECTORIZE_UNITS_PER_SIMD_WORD\".  More\n    flexibility will be added in the future.\n \n         Since we only vectorize operations which vector form can be\n    expressed using existing tree codes, to verify that an operation is\n    supported, the vectorizer checks the relevant optab at the relevant\n-   machine_mode (e.g, optab_handler (add_optab, V8HImode)). If\n+   machine_mode (e.g, optab_handler (add_optab, V8HImode)).  If\n    the value found is CODE_FOR_nothing, then there's no target support, and\n    we can't vectorize the stmt.\n \n@@ -144,14 +144,14 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Function vect_determine_vectorization_factor\n \n-   Determine the vectorization factor (VF). VF is the number of data elements\n+   Determine the vectorization factor (VF).  VF is the number of data elements\n    that are operated upon in parallel in a single iteration of the vectorized\n-   loop. For example, when vectorizing a loop that operates on 4byte elements,\n+   loop.  For example, when vectorizing a loop that operates on 4byte elements,\n    on a target with vector size (VS) 16byte, the VF is set to 4, since 4\n    elements can fit in a single vector register.\n \n    We currently support vectorization of loops in which all types operated upon\n-   are of the same size. Therefore this function currently sets VF according to\n+   are of the same size.  Therefore this function currently sets VF according to\n    the size of the types operated upon, and fails if there are multiple sizes\n    in the loop.\n \n@@ -438,7 +438,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n /* Function vect_analyze_scalar_cycles_1.\n \n    Examine the cross iteration def-use cycles of scalar variables\n-   in LOOP. LOOP_VINFO represents the loop that is now being\n+   in LOOP.  LOOP_VINFO represents the loop that is now being\n    considered for vectorization (can be LOOP, or an outer-loop\n    enclosing LOOP).  */\n \n@@ -454,7 +454,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n \n-  /* First - identify all inductions. Reduction detection assumes that all the\n+  /* First - identify all inductions.  Reduction detection assumes that all the\n      inductions have been identified, therefore, this order must not be\n      changed.  */\n   for (gsi = gsi_start_phis  (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -470,7 +470,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \t  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n \t}\n \n-      /* Skip virtual phi's. The data dependences that are associated with\n+      /* Skip virtual phi's.  The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n       if (!is_gimple_reg (SSA_NAME_VAR (def)))\n \tcontinue;\n@@ -569,7 +569,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n /* Function vect_analyze_scalar_cycles.\n \n    Examine the cross iteration def-use cycles of scalar variables, by\n-   analyzing the loop-header PHIs of scalar variables; Classify each\n+   analyzing the loop-header PHIs of scalar variables.  Classify each\n    cycle as one of the following: invariant, induction, reduction, unknown.\n    We do that for the loop represented by LOOP_VINFO, and also to its\n    inner-loop, if exists.\n@@ -1125,8 +1125,8 @@ vect_analyze_loop_form (struct loop *loop)\n \n /* Get cost by calling cost target builtin.  */\n \n-static inline \n-int vect_get_cost (enum vect_cost_for_stmt type_of_cost)\n+static inline int\n+vect_get_cost (enum vect_cost_for_stmt type_of_cost)\n {\n   tree dummy_type = NULL;\n   int dummy = 0;\n@@ -1301,7 +1301,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  /* Analyze cost. Decide if worth while to vectorize.  */\n+  /* Analyze cost.  Decide if worth while to vectorize.  */\n \n   /* Once VF is set, SLP costs should be updated since the number of created\n      vector stmts depends on VF.  */\n@@ -1374,7 +1374,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n /* Function vect_analyze_loop.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n-   for it. The different analyses will record information in the\n+   for it.  The different analyses will record information in the\n    loop_vec_info struct.  */\n loop_vec_info\n vect_analyze_loop (struct loop *loop)\n@@ -1594,7 +1594,7 @@ reduction_code_for_scalar_code (enum tree_code code,\n }\n \n \n-/* Error reporting helper for vect_is_simple_reduction below. GIMPLE statement\n+/* Error reporting helper for vect_is_simple_reduction below.  GIMPLE statement\n    STMT is printed with a message MSG. */\n \n static void\n@@ -1608,7 +1608,7 @@ report_vect_op (gimple stmt, const char *msg)\n /* Function vect_is_simple_reduction_1\n \n    (1) Detect a cross-iteration def-use cycle that represents a simple\n-   reduction computation. We look for the following pattern:\n+   reduction computation.  We look for the following pattern:\n \n    loop_header:\n      a1 = phi < a0, a2 >\n@@ -2023,7 +2023,7 @@ vect_get_single_scalar_iteraion_cost (loop_vec_info loop_vinfo)\n   int nbbs = loop->num_nodes, factor, scalar_single_iter_cost = 0;\n   int innerloop_iters, i, stmt_cost;\n \n-  /* Count statements in scalar loop. Using this as scalar cost for a single\n+  /* Count statements in scalar loop.  Using this as scalar cost for a single\n      iteration for now.\n \n      TODO: Add outer loop support.\n@@ -2308,7 +2308,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      something more reasonable.  */\n \n   /* If the number of iterations is known and we do not do versioning, we can\n-     decide whether to vectorize at compile time. Hence the scalar version\n+     decide whether to vectorize at compile time.  Hence the scalar version\n      do not carry cost model guard costs.  */\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n@@ -2339,7 +2339,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n     }\n \n   /* Calculate number of iterations required to make the vector version\n-     profitable, relative to the loop bodies only. The following condition\n+     profitable, relative to the loop bodies only.  The following condition\n      must hold true:\n      SIC * niters + SOC > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC\n      where\n@@ -2556,7 +2556,7 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n \n    Output:\n    Return a vector variable, initialized with the first VF values of\n-   the induction variable. E.g., for an iv with IV_PHI='X' and\n+   the induction variable.  E.g., for an iv with IV_PHI='X' and\n    evolution S, for a vector of 4 units, we want to return:\n    [X, X + S, X + 2*S, X + 3*S].  */\n \n@@ -2638,8 +2638,8 @@ get_initial_def_for_induction (gimple iv_phi)\n   if (nested_in_vect_loop)\n     {\n       /* iv_loop is nested in the loop to be vectorized.  init_expr had already\n-\t been created during vectorization of previous stmts; We obtain it from\n-\t the STMT_VINFO_VEC_STMT of the defining stmt. */\n+\t been created during vectorization of previous stmts.  We obtain it\n+\t from the STMT_VINFO_VEC_STMT of the defining stmt.  */\n       tree iv_def = PHI_ARG_DEF_FROM_EDGE (iv_phi,\n                                            loop_preheader_edge (iv_loop));\n       vec_init = vect_get_vec_def_for_operand (iv_def, iv_phi, NULL);\n@@ -2905,7 +2905,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n     gcc_assert (loop == (gimple_bb (stmt))->loop_father);\n \n   /* In case of double reduction we only create a vector variable to be put\n-     in the reduction phi node. The actual statement creation is done in\n+     in the reduction phi node.  The actual statement creation is done in\n      vect_create_epilog_for_reduction.  */\n   if (adjustment_def && nested_in_vect_loop\n       && TREE_CODE (init_val) == SSA_NAME\n@@ -3023,7 +3023,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n      reduction statements. \n    STMT is the scalar reduction stmt that is being vectorized.\n    NCOPIES is > 1 in case the vectorization factor (VF) is bigger than the\n-     number of elements that we can fit in a vectype (nunits). In this case\n+     number of elements that we can fit in a vectype (nunits).  In this case\n      we have to generate more than one vector stmt - i.e - we need to \"unroll\"\n      the vector stmt by a factor VF/nunits.  For more details see documentation\n      in vectorizable_operation.\n@@ -3314,7 +3314,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n   /* In case this is a reduction in an inner-loop while vectorizing an outer\n      loop - we don't need to extract a single scalar result at the end of the\n      inner-loop (unless it is double reduction, i.e., the use of reduction is\n-     outside the outer-loop). The final vector of partial results will be used\n+     outside the outer-loop).  The final vector of partial results will be used\n      in the vectorized outer-loop, or reduced to a scalar result at the end of\n      the outer-loop.  */\n   if (nested_in_vect_loop && !double_reduc)\n@@ -3473,7 +3473,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n             }\n \n           /* The only case where we need to reduce scalar results in SLP, is\n-             unrolling. If the size of SCALAR_RESULTS is greater than \n+             unrolling.  If the size of SCALAR_RESULTS is greater than\n              GROUP_SIZE, we reduce them combining elements modulo \n              GROUP_SIZE.  */\n           if (slp_node)\n@@ -3579,7 +3579,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n       VEC_replace (gimple, new_phis, 0, epilog_stmt);\n     }\n \n-  /* 2.6  Handle the loop-exit phis. Replace the uses of scalar loop-exit\n+  /* 2.6  Handle the loop-exit phis.  Replace the uses of scalar loop-exit\n           phis with new adjusted scalar results, i.e., replace use <s_out0>\n           with use <s_out4>.        \n \n@@ -3605,8 +3605,8 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n           use <s_out4> */\n \n   /* In SLP we may have several statements in NEW_PHIS and REDUCTION_PHIS (in \n-     case that GROUP_SIZE is greater than vectorization factor). Therefore, we\n-     need to match SCALAR_RESULTS with corresponding statements. The first\n+     case that GROUP_SIZE is greater than vectorization factor).  Therefore, we\n+     need to match SCALAR_RESULTS with corresponding statements.  The first\n      (GROUP_SIZE / number of new vector stmts) scalar results correspond to\n      the first vector stmt, etc.  \n      (RATIO is equal to (GROUP_SIZE / number of new vector stmts)).  */ \n@@ -3639,7 +3639,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n       phis = VEC_alloc (gimple, heap, 3);\n       /* Find the loop-closed-use at the loop exit of the original scalar\n-         result. (The reduction result is expected to have two immediate uses -\n+         result.  (The reduction result is expected to have two immediate uses -\n          one at the latch block, and one at the loop exit).  */\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n         if (!flow_bb_inside_loop_p (loop, gimple_bb (USE_STMT (use_p))))\n@@ -3740,7 +3740,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                   vect_phi_res = PHI_RESULT (vect_phi);\n \n                   /* Replace the use, i.e., set the correct vs1 in the regular\n-                     reduction phi node. FORNOW, NCOPIES is always 1, so the\n+                     reduction phi node.  FORNOW, NCOPIES is always 1, so the\n                      loop is redundant.  */\n                   use = reduction_phi;\n                   for (j = 0; j < ncopies; j++)\n@@ -3764,8 +3764,8 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n       phis = VEC_alloc (gimple, heap, 3);\n       /* Find the loop-closed-use at the loop exit of the original scalar\n-         result. (The reduction result is expected to have two immediate uses -\n-         one at the latch block, and one at the loop exit). For double \n+         result.  (The reduction result is expected to have two immediate uses,\n+         one at the latch block, and one at the loop exit).  For double\n          reductions we are looking for exit phis of the outer loop.  */\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n         {\n@@ -3814,7 +3814,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.\n \n    This function also handles reduction idioms (patterns) that have been\n-   recognized in advance during vect_pattern_recog. In this case, STMT may be\n+   recognized in advance during vect_pattern_recog.  In this case, STMT may be\n    of this form:\n      X = pattern_expr (arg0, arg1, ..., X)\n    and it's STMT_VINFO_RELATED_STMT points to the last stmt in the original\n@@ -3835,9 +3835,9 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n    Upon entry to this function, STMT_VINFO_VECTYPE records the vectype that\n    indicates what is the actual level of parallelism (V8HI in the example), so\n-   that the right vectorization factor would be derived. This vectype\n+   that the right vectorization factor would be derived.  This vectype\n    corresponds to the type of arguments to the reduction stmt, and should *NOT*\n-   be used to create the vectorized stmt. The right vectype for the vectorized\n+   be used to create the vectorized stmt.  The right vectype for the vectorized\n    stmt is obtained from the type of the result X:\n         get_vectype_for_scalar_type (TREE_TYPE (X))\n \n@@ -3934,7 +3934,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       gcc_assert (!STMT_VINFO_IN_PATTERN_P (stmt_info));\n     }\n \n-  /* 3. Check the operands of the operation. The first operands are defined\n+  /* 3. Check the operands of the operation.  The first operands are defined\n         inside the loop body. The last operand is the reduction variable,\n         which is defined by the loop-header-phi.  */\n \n@@ -3979,7 +3979,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* All uses but the last are expected to be defined in the loop.\n-     The last use is the reduction variable. In case of nested cycle this\n+     The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the\n      reduction variable.  */\n   for (i = 0; i < op_type-1; i++)\n@@ -4110,7 +4110,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           1. The tree-code that is used to create the vector operation in the\n              epilog code (that reduces the partial results) is not the\n              tree-code of STMT, but is rather the tree-code of the original\n-             stmt from the pattern that STMT is replacing. I.e, in the example\n+             stmt from the pattern that STMT is replacing.  I.e, in the example\n              above we want to use 'widen_sum' in the loop, but 'plus' in the\n              epilog.\n           2. The type (mode) we use to check available target support\n@@ -4513,7 +4513,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \n /* Function vectorizable_live_operation.\n \n-   STMT computes a value that is used outside the loop. Check if\n+   STMT computes a value that is used outside the loop.  Check if\n    it can be supported.  */\n \n bool\n@@ -4554,7 +4554,7 @@ vectorizable_live_operation (gimple stmt,\n   gcc_assert (rhs_class != GIMPLE_UNARY_RHS || op_type == unary_op);\n   gcc_assert (rhs_class != GIMPLE_BINARY_RHS || op_type == binary_op);\n \n-  /* FORNOW: support only if all uses are invariant. This means\n+  /* FORNOW: support only if all uses are invariant.  This means\n      that the scalar operations can remain in place, unvectorized.\n      The original last scalar value that they compute will be used.  */\n \n@@ -4665,7 +4665,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      compile time constant), or it is a constant that doesn't divide by the\n      vectorization factor, then an epilog loop needs to be created.\n      We therefore duplicate the loop: the original loop will be vectorized,\n-     and will compute the first (n/VF) iterations. The second copy of the loop\n+     and will compute the first (n/VF) iterations.  The second copy of the loop\n      will remain scalar and will compute the remaining (n%VF) iterations.\n      (VF is the vectorization factor).  */\n "}, {"sha": "2e4e36dcd2896850f6b1c0c81da015b54d1f4864", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -147,7 +147,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t}\n \n       /* Check if DEF_STMT is a part of a pattern in LOOP and get the def stmt\n-         from the pattern. Check that all the stmts of the node are in the\n+         from the pattern.  Check that all the stmts of the node are in the\n          pattern.  */\n       if (loop && def_stmt && gimple_bb (def_stmt)\n           && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n@@ -299,7 +299,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n /* Recursively build an SLP tree starting from NODE.\n    Fail (and return FALSE) if def-stmts are not isomorphic, require data\n-   permutation or are of unsupported types of operation. Otherwise, return\n+   permutation or are of unsupported types of operation.  Otherwise, return\n    TRUE.  */\n \n static bool\n@@ -542,7 +542,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               if (prev_first_load)\n                 {\n                   /* Check that there are no loads from different interleaving\n-                     chains in the same node. The only exception is complex\n+                     chains in the same node.  The only exception is complex\n                      numbers.  */\n                   if (prev_first_load != first_load\n                       && rhs_code != REALPART_EXPR \n@@ -582,7 +582,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                                         ncopies_for_cost, *node);\n                 }\n \n-              /* Store the place of this load in the interleaving chain. In\n+              /* Store the place of this load in the interleaving chain.  In\n                  case that permutation is needed we later decide if a specific\n                  permutation is supported.  */\n               load_place = vect_get_place_in_interleaving_chain (stmt,\n@@ -729,7 +729,7 @@ vect_print_slp_tree (slp_tree node)\n \n /* Mark the tree rooted at NODE with MARK (PURE_SLP or HYBRID).\n    If MARK is HYBRID, it refers to a specific stmt in NODE (the stmt at index\n-   J). Otherwise, MARK is PURE_SLP and J is -1, which indicates that all the\n+   J).  Otherwise, MARK is PURE_SLP and J is -1, which indicates that all the\n    stmts in NODE are to be marked.  */\n \n static void\n@@ -897,7 +897,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n \n   /* In case of reduction every load permutation is allowed, since the order\n      of the reduction statements is not important (as opposed to the case of\n-     strided stores). The only condition we need to check is that all the \n+     strided stores).  The only condition we need to check is that all the\n      load nodes are of the same size and have the same permutation (and then\n      rearrange all the nodes of the SLP instance according to this \n      permutation).  */\n@@ -920,7 +920,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n       real_c = real_b + real_a;\n       imag_c = imag_a + imag_b;\n      i.e., we have {real_b, imag_a} and {real_a, imag_b} instead of \n-     {real_a, imag_a} and {real_b, imag_b}. We check here that if interleaving\n+     {real_a, imag_a} and {real_b, imag_b}.  We check here that if interleaving\n      chains are mixed, they match the above pattern.  */\n   if (complex_numbers)\n     {\n@@ -969,7 +969,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n   /* LOAD_PERMUTATION is a list of indices of all the loads of the SLP\n      instance, not all the loads belong to the same node or interleaving\n-     group. Hence, we need to divide them into groups according to\n+     group.  Hence, we need to divide them into groups according to\n      GROUP_SIZE.  */\n   number_of_groups = VEC_length (int, load_permutation) / group_size;\n \n@@ -1002,7 +1002,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n \n       if (!bad_permutation)\n         {\n-          /* This permutaion is valid for reduction. Since the order of the\n+          /* This permutaion is valid for reduction.  Since the order of the\n              statements in the nodes is not important unless they are memory\n              accesses, we can rearrange the statements in all the nodes \n              according to the order of the loads.  */\n@@ -1064,9 +1064,10 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n /* Find the first load in the loop that belongs to INSTANCE.\n    When loads are in several SLP nodes, there can be a case in which the first\n    load does not appear in the first SLP node to be transformed, causing\n-   incorrect order of statements. Since we generate all the loads together,\n+   incorrect order of statements.  Since we generate all the loads together,\n    they must be inserted before the first load of the SLP instance and not\n    before the first load of the first node of the instance.  */\n+\n static gimple\n vect_find_first_load_in_slp_instance (slp_instance instance)\n {\n@@ -1083,6 +1084,7 @@ vect_find_first_load_in_slp_instance (slp_instance instance)\n \n \n /* Find the last store in SLP INSTANCE.  */\n+\n static gimple\n vect_find_last_store_in_slp_instance (slp_instance instance)\n {\n@@ -1100,7 +1102,7 @@ vect_find_last_store_in_slp_instance (slp_instance instance)\n }\n \n \n-/* Analyze an SLP instance starting from a group of strided stores. Call\n+/* Analyze an SLP instance starting from a group of strided stores.  Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.\n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n \n@@ -1274,7 +1276,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n }\n \n \n-/* Check if there are stmts in the loop can be vectorized using SLP. Build SLP\n+/* Check if there are stmts in the loop can be vectorized using SLP.  Build SLP\n    trees of packed scalar stmts if SLP is possible.  */\n \n bool\n@@ -1339,9 +1341,9 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n       if (unrolling_factor < SLP_INSTANCE_UNROLLING_FACTOR (instance))\n \tunrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (instance);\n \n-      /* Mark all the stmts that belong to INSTANCE as PURE_SLP stmts. Later we\n+      /* Mark all the stmts that belong to INSTANCE as PURE_SLP stmts.  Later we\n \t call vect_detect_hybrid_slp () to find stmts that need hybrid SLP and\n-\t loop-based vectorization. Such stmts will be marked as HYBRID.  */\n+\t loop-based vectorization.  Such stmts will be marked as HYBRID.  */\n       vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance), pure_slp, -1);\n       decided_to_slp++;\n     }\n@@ -1355,7 +1357,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n \n \n /* Find stmts that must be both vectorized and SLPed (since they feed stmts that\n-   can't be SLPed) in the tree rooted at NODE. Mark such stmts as HYBRID.  */\n+   can't be SLPed) in the tree rooted at NODE.  Mark such stmts as HYBRID.  */\n \n static void\n vect_detect_hybrid_slp_stmts (slp_tree node)\n@@ -1493,7 +1495,7 @@ vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n }\n \n \n-/* Analyze statements in SLP instances of the basic block. Return TRUE if the\n+/* Analyze statements in SLP instances of the basic block.  Return TRUE if the\n    operations are supported. */\n \n static bool\n@@ -1523,7 +1525,7 @@ vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n \n /* Check if loads and stores are mixed in the basic block (in that\n    case if we are not sure that the accesses differ, we can't vectorize the\n-   basic block). Also return FALSE in case that there is statement marked as\n+   basic block).  Also return FALSE in case that there is statement marked as\n    not vectorizable.  */\n \n static bool\n@@ -1783,11 +1785,11 @@ vect_slp_analyze_bb (basic_block bb)\n \n \n /* SLP costs are calculated according to SLP instance unrolling factor (i.e.,\n-   the number of created vector stmts depends on the unrolling factor). However,\n-   the actual number of vector stmts for every SLP node depends on VF which is\n-   set later in vect_analyze_operations(). Hence, SLP costs should be updated.\n-   In this function we assume that the inside costs calculated in\n-   vect_model_xxx_cost are linear in ncopies.  */\n+   the number of created vector stmts depends on the unrolling factor).\n+   However, the actual number of vector stmts for every SLP node depends on\n+   VF which is set later in vect_analyze_operations ().  Hence, SLP costs\n+   should be updated.  In this function we assume that the inside costs\n+   calculated in vect_model_xxx_cost are linear in ncopies.  */\n \n void\n vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n@@ -1846,7 +1848,7 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n       op_num = reduc_index - 1;\n       op = gimple_op (stmt, op_num + 1);\n       /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n-         we need either neutral operands or the original operands. See\n+         we need either neutral operands or the original operands.  See\n          get_initial_def_for_reduction() for details.  */\n       switch (code)\n         {\n@@ -2051,7 +2053,7 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n       number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       /* Number of vector stmts was calculated according to LHS in\n          vect_schedule_slp_instance(), fix it by replacing LHS with RHS, if\n-         necessary. See vect_get_smallest_scalar_type() for details.  */\n+         necessary.  See vect_get_smallest_scalar_type () for details.  */\n       vect_get_smallest_scalar_type (first_stmt, &lhs_size_unit,\n                                      &rhs_size_unit);\n       if (rhs_size_unit != lhs_size_unit)\n@@ -2065,7 +2067,7 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n   *vec_oprnds0 = VEC_alloc (tree, heap, number_of_vects);\n \n   /* SLP_NODE corresponds either to a group of stores or to a group of\n-     unary/binary operations. We don't call this function for loads.  \n+     unary/binary operations.  We don't call this function for loads.\n      For reduction defs we call vect_get_constant_vectors(), since we are\n      looking for initial loop invariant values.  */\n   if (SLP_TREE_LEFT (slp_node) && reduc_index == -1)\n@@ -2167,7 +2169,7 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n \n /* Given FIRST_MASK_ELEMENT - the mask element in element representation,\n    return in CURRENT_MASK_ELEMENT its equivalent in target specific\n-   representation. Check that the mask is valid and return FALSE if not.\n+   representation.  Check that the mask is valid and return FALSE if not.\n    Return TRUE in NEED_NEXT_VECTOR if the permutation requires to move to\n    the next vector, i.e., the current first vector is not needed.  */\n \n@@ -2321,8 +2323,8 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n      The masks for a's should be: {0,0,0,3} {3,3,6,6} {6,9,9,9} (in target\n      scpecific type, e.g., in bytes for Altivec.\n      The last mask is illegal since we assume two operands for permute\n-     operation, and the mask element values can't be outside that range. Hence,\n-     the last mask must be converted into {2,5,5,5}.\n+     operation, and the mask element values can't be outside that range.\n+     Hence, the last mask must be converted into {2,5,5,5}.\n      For the first two permutations we need the first and the second input\n      vectors: {a0,b0,c0,a1} and {b1,c1,a2,b2}, and for the last permutation\n      we need the second and the third vectors: {b1,c1,a2,b2} and\n@@ -2438,7 +2440,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n \n   /* For each SLP instance calculate number of vector stmts to be created\n-     for the scalar stmts in each node of the SLP tree. Number of vector\n+     for the scalar stmts in each node of the SLP tree.  Number of vector\n      elements in one vector iteration is the number of scalar elements in\n      one scalar iteration (GROUP_SIZE) multiplied by VF divided by vector\n      size.  */\n@@ -2492,6 +2494,8 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n }\n \n \n+/* Generate vector code for all SLP instances in the loop/basic block.  */\n+\n bool\n vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {"}, {"sha": "3db0ec1b85098f37ca0798a02aa76344310cb225", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -166,7 +166,7 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n \n /* Function exist_non_indexing_operands_for_use_p\n \n-   USE is one of the uses attached to STMT. Check if USE is\n+   USE is one of the uses attached to STMT.  Check if USE is\n    used in STMT for anything other than indexing an array.  */\n \n static bool\n@@ -175,7 +175,7 @@ exist_non_indexing_operands_for_use_p (tree use, gimple stmt)\n   tree operand;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n-  /* USE corresponds to some operand in STMT. If there is no data\n+  /* USE corresponds to some operand in STMT.  If there is no data\n      reference in STMT, then any operand that corresponds to USE\n      is not indexing an array.  */\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -215,7 +215,7 @@ exist_non_indexing_operands_for_use_p (tree use, gimple stmt)\n    Inputs:\n    - a USE in STMT in a loop represented by LOOP_VINFO\n    - LIVE_P, RELEVANT - enum values to be set in the STMT_VINFO of the stmt\n-     that defined USE. This is done by calling mark_relevant and passing it\n+     that defined USE.  This is done by calling mark_relevant and passing it\n      the WORKLIST (to add DEF_STMT to the WORKLIST in case it is relevant).\n \n    Outputs:\n@@ -466,7 +466,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t   relevant = vect_used_by_reduction\n \t This is because we distinguish between two kinds of relevant stmts -\n \t those that are used by a reduction computation, and those that are\n-\t (also) used by a regular computation. This allows us later on to\n+\t (also) used by a regular computation.  This allows us later on to\n \t identify stmts that are used solely by a reduction, and therefore the\n \t order of the results that they produce does not have to be kept.  */\n \n@@ -558,6 +558,9 @@ int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n                                                        dummy_type, dummy);\n }\n \n+\n+/* Get cost for STMT.  */\n+\n int\n cost_for_stmt (gimple stmt)\n {\n@@ -870,10 +873,10 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n                    \"pipelined.\");\n \n         /* Unaligned software pipeline has a load of an address, an initial\n-           load, and possibly a mask operation to \"prime\" the loop. However,\n+           load, and possibly a mask operation to \"prime\" the loop.  However,\n            if this is an access in a group of loads, which provide strided\n            access, then the above cost should only be considered for one\n-           access in the group. Inside the loop, there is a load op\n+           access in the group.  Inside the loop, there is a load op\n            and a realignment op.  */\n \n         if (add_realign_cost)\n@@ -897,8 +900,8 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n /* Function vect_init_vector.\n \n    Insert a new stmt (INIT_STMT) that initializes a new vector variable with\n-   the vector elements of VECTOR_VAR. Place the initialization at BSI if it\n-   is not NULL. Otherwise, place the initialization at the loop preheader.\n+   the vector elements of VECTOR_VAR.  Place the initialization at BSI if it\n+   is not NULL.  Otherwise, place the initialization at the loop preheader.\n    Return the DEF of INIT_STMT.\n    It will be used in the vectorization of STMT.  */\n \n@@ -963,7 +966,7 @@ vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n \n /* Function vect_get_vec_def_for_operand.\n \n-   OP is an operand in STMT. This function returns a (vector) def that will be\n+   OP is an operand in STMT.  This function returns a (vector) def that will be\n    used in the vectorized stmt for STMT.\n \n    In the case that OP is an SSA_NAME which is defined in the loop, then\n@@ -1117,18 +1120,18 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \n /* Function vect_get_vec_def_for_stmt_copy\n \n-   Return a vector-def for an operand. This function is used when the\n+   Return a vector-def for an operand.  This function is used when the\n    vectorized stmt to be created (by the caller to this function) is a \"copy\"\n    created in case the vectorized result cannot fit in one vector, and several\n-   copies of the vector-stmt are required. In this case the vector-def is\n+   copies of the vector-stmt are required.  In this case the vector-def is\n    retrieved from the vector stmt recorded in the STMT_VINFO_RELATED_STMT field\n    of the stmt that defines VEC_OPRND.\n    DT is the type of the vector def VEC_OPRND.\n \n    Context:\n         In case the vectorization factor (VF) is bigger than the number\n    of elements that can fit in a vectype (nunits), we have to generate\n-   more than one vector stmt to vectorize the scalar stmt. This situation\n+   more than one vector stmt to vectorize the scalar stmt.  This situation\n    arises when there are multiple data-types operated upon in the loop; the\n    smallest data-type determines the VF, and as a result, when vectorizing\n    stmts operating on wider types we need to create 'VF/nunits' \"copies\" of the\n@@ -1153,7 +1156,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n    The vectorization of S2:\n         To create the first vector-stmt out of the 4 copies - VSnew.0 -\n    the function 'vect_get_vec_def_for_operand' is called to\n-   get the relevant vector-def for each operand of S2. For operand x it\n+   get the relevant vector-def for each operand of S2.  For operand x it\n    returns  the vector-def 'vx.0'.\n \n         To create the remaining copies of the vector-stmt (VSnew.j), this\n@@ -1196,7 +1199,7 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n \n \n /* Get vectorized definitions for the operands to create a copy of an original\n-   stmt. See vect_get_vec_def_for_stmt_copy() for details.  */\n+   stmt.  See vect_get_vec_def_for_stmt_copy () for details.  */\n \n static void\n vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n@@ -1217,7 +1220,8 @@ vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n }\n \n \n-/* Get vectorized definitions for OP0 and OP1, or SLP_NODE if it is not NULL.  */\n+/* Get vectorized definitions for OP0 and OP1, or SLP_NODE if it is not\n+   NULL.  */\n \n static void\n vect_get_vec_defs (tree op0, tree op1, gimple stmt,\n@@ -1594,7 +1598,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \n    Create a vector stmt whose code, type, number of arguments, and result\n    variable are CODE, OP_TYPE, and VEC_DEST, and its arguments are\n-   VEC_OPRND0 and VEC_OPRND1. The new vector stmt is to be inserted at BSI.\n+   VEC_OPRND0 and VEC_OPRND1.  The new vector stmt is to be inserted at BSI.\n    In the case that CODE is a CALL_EXPR, this means that a call to DECL\n    needs to be created (DECL is a function-decl of a target-builtin).\n    STMT is the original scalar stmt that we are vectorizing.  */\n@@ -1742,8 +1746,9 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n \n-  /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n-     this, so we can safely override NCOPIES with 1 here.  */\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n   if (slp_node)\n     ncopies = 1;\n \n@@ -1900,6 +1905,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   return true;\n }\n+\n+\n /* Function vectorizable_assignment.\n \n    Check if STMT performs an assignment (copy) that can be vectorized.\n@@ -2156,7 +2163,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     vf = 1;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n   if (slp_node)\n     ncopies = 1;\n@@ -2243,7 +2250,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \tfprintf (vect_dump, \"proceeding using word mode.\");\n     }\n \n-  /* Worthwhile without SIMD support? Check only during analysis.  */\n+  /* Worthwhile without SIMD support?  Check only during analysis.  */\n   if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n       && vf < vect_min_worthwhile_factor (code)\n       && !vec_stmt)\n@@ -2270,12 +2277,12 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-  /* Allocate VECs for vector operands. In case of SLP, vector operands are\n+  /* Allocate VECs for vector operands.  In case of SLP, vector operands are\n      created in the previous stages of the recursion, so no allocation is\n-     needed, except for the case of shift with scalar shift argument. In that\n+     needed, except for the case of shift with scalar shift argument.  In that\n      case we store the scalar operand in VEC_OPRNDS1 for every vector stmt to\n      be created to vectorize the SLP group, i.e., SLP_NODE->VEC_STMTS_SIZE.\n-     In case of loop-based vectorization we allocate VECs of size 1. We\n+     In case of loop-based vectorization we allocate VECs of size 1.  We\n      allocate VEC_OPRNDS1 only in case of binary operation.  */\n   if (!slp_node)\n     {\n@@ -2289,13 +2296,13 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n-     vector stmt by a factor VF/nunits. In doing so, we record a pointer\n+     vector stmt by a factor VF/nunits.  In doing so, we record a pointer\n      from one copy of the vector stmt to the next, in the field\n-     STMT_VINFO_RELATED_STMT. This is necessary in order to allow following\n+     STMT_VINFO_RELATED_STMT.  This is necessary in order to allow following\n      stages to find the correct vector defs to be used when vectorizing\n-     stmts that use the defs of the current stmt. The example below illustrates\n-     the vectorization process when VF=16 and nunits=4 (i.e - we need to create\n-     4 vectorized stmts):\n+     stmts that use the defs of the current stmt.  The example below\n+     illustrates the vectorization process when VF=16 and nunits=4 (i.e.,\n+     we need to create 4 vectorized stmts):\n \n      before vectorization:\n                                 RELATED_STMT    VEC_STMT\n@@ -2314,18 +2321,18 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n      step2: vectorize stmt S2 (done here):\n         To vectorize stmt S2 we first need to find the relevant vector\n-        def for the first operand 'x'. This is, as usual, obtained from\n+        def for the first operand 'x'.  This is, as usual, obtained from\n         the vector stmt recorded in the STMT_VINFO_VEC_STMT of the stmt\n-        that defines 'x' (S1). This way we find the stmt VS1_0, and the\n-        relevant vector def 'vx0'. Having found 'vx0' we can generate\n+        that defines 'x' (S1).  This way we find the stmt VS1_0, and the\n+        relevant vector def 'vx0'.  Having found 'vx0' we can generate\n         the vector stmt VS2_0, and as usual, record it in the\n         STMT_VINFO_VEC_STMT of stmt S2.\n         When creating the second copy (VS2_1), we obtain the relevant vector\n         def from the vector stmt recorded in the STMT_VINFO_RELATED_STMT of\n-        stmt VS1_0. This way we find the stmt VS1_1 and the relevant\n-        vector def 'vx1'. Using 'vx1' we create stmt VS2_1 and record a\n+        stmt VS1_0.  This way we find the stmt VS1_1 and the relevant\n+        vector def 'vx1'.  Using 'vx1' we create stmt VS2_1 and record a\n         pointer to it in the STMT_VINFO_RELATED_STMT of the vector stmt VS2_0.\n-        Similarly when creating stmts VS2_2 and VS2_3. This is the resulting\n+        Similarly when creating stmts VS2_2 and VS2_3.  This is the resulting\n         chain of stmts and pointers:\n                                 RELATED_STMT    VEC_STMT\n         VS1_0:  vx0 = memref0   VS1_1           -\n@@ -2348,7 +2355,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t  if (op_type == binary_op && scalar_shift_arg)\n \t    {\n \t      /* Vector shl and shr insn patterns can be defined with scalar\n-\t\t operand 2 (shift operand). In this case, use constant or loop\n+\t\t operand 2 (shift operand).  In this case, use constant or loop\n \t\t invariant op1 directly, without extending it to vector mode\n \t\t first.  */\n \t      optab_op2_mode = insn_data[icode].operand[2].mode;\n@@ -2361,8 +2368,8 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t          if (slp_node)\n \t            {\n \t              /* Store vec_oprnd1 for every vector stmt to be created\n-\t                 for SLP_NODE. We check during the analysis that all the\n-                         shift arguments are the same.\n+\t                 for SLP_NODE.  We check during the analysis that all\n+                         the shift arguments are the same.\n \t                 TODO: Allow different constants for different vector\n \t                 stmts generated for an SLP instance.  */\n \t              for (k = 0; k < slp_node->vec_stmts_size - 1; k++)\n@@ -2415,7 +2422,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n }\n \n \n-/* Get vectorized definitions for loop-based vectorization. For the first\n+/* Get vectorized definitions for loop-based vectorization.  For the first\n    operand we call vect_get_vec_def_for_operand() (with OPRND containing\n    scalar operand), and for the rest we get a copy with\n    vect_get_vec_def_for_stmt_copy() using the previous vector definition\n@@ -2612,7 +2619,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n   if (slp_node)\n     ncopies = 1;\n@@ -2702,7 +2709,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n \n /* Create vectorized promotion statements for vector operands from VEC_OPRNDS0\n-   and VEC_OPRNDS1 (for binary operations). For multi-step conversions store\n+   and VEC_OPRNDS1 (for binary operations).  For multi-step conversions store\n    the resulting vectors and call the function recursively.  */\n \n static void\n@@ -2779,17 +2786,18 @@ vect_create_vectorized_promotion_stmts (VEC (tree, heap) **vec_oprnds0,\n   if (multi_step_cvt)\n     {\n       /* For multi-step promotion operation we first generate we call the\n-         function recurcively for every stage. We start from the input type,\n+         function recurcively for every stage.  We start from the input type,\n          create promotion operations to the intermediate types, and then\n          create promotions to the output type.  */\n       *vec_oprnds0 = VEC_copy (tree, heap, vec_tmp);\n-      VEC_free (tree, heap, vec_tmp);\n       vect_create_vectorized_promotion_stmts (vec_oprnds0, vec_oprnds1,\n                                               multi_step_cvt - 1, stmt,\n                                               vec_dsts, gsi, slp_node, code1,\n                                               code2, decl2, decl2, op_type,\n                                               prev_stmt_info);\n     }\n+\n+  VEC_free (tree, heap, vec_tmp);\n }\n \n \n@@ -2891,7 +2899,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n   if (slp_node)\n     ncopies = 1;\n@@ -3259,7 +3267,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n      the documentation of vect_permute_store_chain()).\n \n      In case of both multiple types and interleaving, above vector stores and\n-     permutation stmts are created for every copy. The result vector stmts are\n+     permutation stmts are created for every copy.  The result vector stmts are\n      put in STMT_VINFO_VEC_STMT for the first copy and in the corresponding\n      STMT_VINFO_RELATED_STMT for the next copies.\n   */\n@@ -3411,6 +3419,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   VEC_free (tree, heap, oprnds);\n   if (result_chain)\n     VEC_free (tree, heap, result_chain);\n+  if (vec_oprnds)\n+    VEC_free (tree, heap, vec_oprnds);\n \n   return true;\n }\n@@ -3476,7 +3486,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     vf = 1;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n   if (slp)\n     ncopies = 1;\n@@ -3603,13 +3613,13 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n-     vector stmt by a factor VF/nunits. In doing so, we record a pointer\n+     vector stmt by a factor VF/nunits.  In doing so, we record a pointer\n      from one copy of the vector stmt to the next, in the field\n-     STMT_VINFO_RELATED_STMT. This is necessary in order to allow following\n+     STMT_VINFO_RELATED_STMT.  This is necessary in order to allow following\n      stages to find the correct vector defs to be used when vectorizing\n-     stmts that use the defs of the current stmt. The example below illustrates\n-     the vectorization process when VF=16 and nunits=4 (i.e - we need to create\n-     4 vectorized stmts):\n+     stmts that use the defs of the current stmt.  The example below\n+     illustrates the vectorization process when VF=16 and nunits=4 (i.e., we\n+     need to create 4 vectorized stmts):\n \n      before vectorization:\n                                 RELATED_STMT    VEC_STMT\n@@ -3621,7 +3631,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n         pointer to it in the STMT_VINFO_VEC_STMT of the scalar stmt S1.\n         Next, we create the vector stmt VS1_1, and record a pointer to\n         it in the STMT_VINFO_RELATED_STMT of the vector stmt VS1_0.\n-        Similarly, for VS1_2 and VS1_3. This is the resulting chain of\n+        Similarly, for VS1_2 and VS1_3.  This is the resulting chain of\n         stmts and pointers:\n                                 RELATED_STMT    VEC_STMT\n         VS1_0:  vx0 = memref0   VS1_1           -\n@@ -3664,9 +3674,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n      STMT_VINFO_VEC_STMT is done in vect_transform_strided_load().\n \n      In case of both multiple types and interleaving, the vector loads and\n-     permutation stmts above are created for every copy. The result vector stmts\n-     are put in STMT_VINFO_VEC_STMT for the first copy and in the corresponding\n-     STMT_VINFO_RELATED_STMT for the next copies.  */\n+     permutation stmts above are created for every copy.  The result vector\n+     stmts are put in STMT_VINFO_VEC_STMT for the first copy and in the\n+     corresponding STMT_VINFO_RELATED_STMT for the next copies.  */\n \n   /* If the data reference is aligned (dr_aligned) or potentially unaligned\n      on a target that supports unaligned accesses (dr_unaligned_supported)\n@@ -3699,7 +3709,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   /* If the misalignment remains the same throughout the execution of the\n      loop, we can create the init_addr and permutation mask at the loop\n-     preheader. Otherwise, it needs to be created inside the loop.\n+     preheader.  Otherwise, it needs to be created inside the loop.\n      This can only occur when vectorizing memory accesses in the inner-loop\n      nested within an outer-loop that is being vectorized.  */\n \n@@ -3854,7 +3864,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  mark_symbols_for_renaming (new_stmt);\n \n-\t  /* 3. Handle explicit realignment if necessary/supported. Create in\n+\t  /* 3. Handle explicit realignment if necessary/supported.  Create in\n \t\tloop: vec_dest = realign_load (msq, lsq, realignment_token)  */\n \t  if (alignment_support_scheme == dr_explicit_realign_optimized\n \t      || alignment_support_scheme == dr_explicit_realign)\n@@ -4035,7 +4045,8 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   tree cond_expr, then_clause, else_clause;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  tree vec_cond_lhs, vec_cond_rhs, vec_then_clause, vec_else_clause;\n+  tree vec_cond_lhs = NULL_TREE, vec_cond_rhs = NULL_TREE;\n+  tree vec_then_clause = NULL_TREE, vec_else_clause = NULL_TREE;\n   tree vec_compare, vec_cond_expr;\n   tree new_temp;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -4365,7 +4376,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   if (!PURE_SLP_STMT (stmt_info))\n     {\n       /* Groups of strided accesses whose size is not a power of 2 are not\n-         vectorizable yet using loop-vectorization. Therefore, if this stmt\n+         vectorizable yet using loop-vectorization.  Therefore, if this stmt\n \t feeds non-SLP-able stmts (i.e., this stmt has to be both SLPed and\n \t loop-based vectorized), the loop cannot be vectorized.  */\n       if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n@@ -4447,7 +4458,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       if (STMT_VINFO_STRIDED_ACCESS (stmt_info) && !slp_node)\n \t{\n \t  /* In case of interleaving, the whole chain is vectorized when the\n-\t     last store in the chain is reached. Store stmts before the last\n+\t     last store in the chain is reached.  Store stmts before the last\n \t     one are skipped, and there vec_stmt_info shouldn't be freed\n \t     meanwhile.  */\n \t  *strided_store = true;\n@@ -4747,7 +4758,7 @@ get_same_sized_vectype (tree scalar_type, tree vector_type ATTRIBUTE_UNUSED)\n \n    Returns whether a stmt with OPERAND can be vectorized.\n    For loops, supportable operands are constants, loop invariants, and operands\n-   that are defined by the current iteration of the loop. Unsupportable\n+   that are defined by the current iteration of the loop.  Unsupportable\n    operands are those that are defined by a previous iteration of the loop (as\n    is the case in reduction/induction computations).\n    For basic blocks, supportable operands are constants and bb invariants.\n@@ -4929,7 +4940,7 @@ vect_is_simple_use_1 (tree operand, loop_vec_info loop_vinfo,\n    - CODE1 and CODE2 are codes of vector operations to be used when\n    vectorizing the operation, if available.\n    - DECL1 and DECL2 are decls of target builtin functions to be used\n-   when vectorizing the operation, if available. In this case,\n+   when vectorizing the operation, if available.  In this case,\n    CODE1 and CODE2 are CALL_EXPR.\n    - MULTI_STEP_CVT determines the number of required intermediate steps in\n    case of multi-step conversion (like char->short->int - in that case\n@@ -4973,7 +4984,7 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n \n      When vectorizing outer-loops, we execute the inner-loop sequentially\n      (each vectorized inner-loop iteration contributes to VF outer-loop\n-     iterations in parallel). We therefore don't allow to change the order\n+     iterations in parallel).  We therefore don't allow to change the order\n      of the computation in the inner-loop during outer-loop vectorization.  */\n \n    if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n@@ -5086,8 +5097,9 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n       *code2 = c2;\n \n       /* We assume here that there will not be more than MAX_INTERM_CVT_STEPS\n-         intermediate  steps in promotion sequence. We try MAX_INTERM_CVT_STEPS\n-         to get to NARROW_VECTYPE, and fail if we do not.  */\n+         intermediate steps in promotion sequence.  We try\n+         MAX_INTERM_CVT_STEPS to get to NARROW_VECTYPE, and fail if we do\n+         not.  */\n       *interm_types = VEC_alloc (tree, heap, MAX_INTERM_CVT_STEPS);\n       for (i = 0; i < 3; i++)\n         {\n@@ -5138,7 +5150,7 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n    and producing a result of type VECTYPE_OUT).\n \n    Narrowing operations we currently support are NOP (CONVERT) and\n-   FIX_TRUNC. This function checks if these operations are supported by\n+   FIX_TRUNC.  This function checks if these operations are supported by\n    the target platform directly via vector tree-codes.\n \n    Output:\n@@ -5206,8 +5218,9 @@ supportable_narrowing_operation (enum tree_code code,\n       *code1 = c1;\n       prev_type = vectype;\n       /* We assume here that there will not be more than MAX_INTERM_CVT_STEPS\n-         intermediate  steps in promotion sequence. We try MAX_INTERM_CVT_STEPS\n-         to get to NARROW_VECTYPE, and fail if we do not.  */\n+         intermediate steps in promotion sequence.  We try\n+         MAX_INTERM_CVT_STEPS to get to NARROW_VECTYPE, and fail if we do\n+         not.  */\n       *interm_types = VEC_alloc (tree, heap, MAX_INTERM_CVT_STEPS);\n       for (i = 0; i < 3; i++)\n         {"}, {"sha": "b7ab0c52dde45ca840ac7169c2260031325ba29c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -208,7 +208,7 @@ vectorize_loops (void)\n   /*  ----------- Analyze loops. -----------  */\n \n   /* If some loop was duplicated, it gets bigger number\n-     than all previously defined loops. This fact allows us to run\n+     than all previously defined loops.  This fact allows us to run\n      only over initial loops skipping newly generated ones.  */\n   FOR_EACH_LOOP (li, loop, 0)\n     if (optimize_loop_nest_for_speed_p (loop))"}, {"sha": "b438dbc1c1b8feb38bd567d0049e782bc0f414d1", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff802fa1f343ad103f939306af07337d9562f1f3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ff802fa1f343ad103f939306af07337d9562f1f3", "patch": "@@ -582,6 +582,8 @@ extern VEC(vec_void_p,heap) *stmt_vec_info_vec;\n void init_stmt_vec_info_vec (void);\n void free_stmt_vec_info_vec (void);\n \n+/* Return a stmt_vec_info corresponding to STMT.  */\n+\n static inline stmt_vec_info\n vinfo_for_stmt (gimple stmt)\n {\n@@ -592,6 +594,8 @@ vinfo_for_stmt (gimple stmt)\n   return (stmt_vec_info) VEC_index (vec_void_p, stmt_vec_info_vec, uid - 1);\n }\n \n+/* Set vectorizer information INFO for STMT.  */\n+\n static inline void\n set_vinfo_for_stmt (gimple stmt, stmt_vec_info info)\n {\n@@ -607,6 +611,8 @@ set_vinfo_for_stmt (gimple stmt, stmt_vec_info info)\n     VEC_replace (vec_void_p, stmt_vec_info_vec, uid - 1, (vec_void_p) info);\n }\n \n+/* Return the earlier statement between STMT1 and STMT2.  */\n+\n static inline gimple\n get_earlier_stmt (gimple stmt1, gimple stmt2)\n {\n@@ -633,6 +639,8 @@ get_earlier_stmt (gimple stmt1, gimple stmt2)\n     return stmt2;\n }\n \n+/* Return the later statement between STMT1 and STMT2.  */\n+\n static inline gimple\n get_later_stmt (gimple stmt1, gimple stmt2)\n {\n@@ -659,6 +667,9 @@ get_later_stmt (gimple stmt1, gimple stmt2)\n     return stmt2;\n }\n \n+/* Return TRUE if a statement represented by STMT_INFO is a part of a\n+   pattern.  */\n+\n static inline bool\n is_pattern_stmt_p (stmt_vec_info stmt_info)\n {\n@@ -674,6 +685,8 @@ is_pattern_stmt_p (stmt_vec_info stmt_info)\n   return false;\n }\n \n+/* Return true if BB is a loop header.  */\n+\n static inline bool\n is_loop_header_bb_p (basic_block bb)\n {\n@@ -683,6 +696,8 @@ is_loop_header_bb_p (basic_block bb)\n   return false;\n }\n \n+/* Set inside loop vectorization cost.  */\n+\n static inline void\n stmt_vinfo_set_inside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n \t\t\t\t    int cost)\n@@ -693,6 +708,8 @@ stmt_vinfo_set_inside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n     STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = cost;\n }\n \n+/* Set inside loop vectorization cost.  */\n+\n static inline void\n stmt_vinfo_set_outside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n \t\t\t\t     int cost)\n@@ -703,6 +720,8 @@ stmt_vinfo_set_outside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n     STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = cost;\n }\n \n+/* Return pow2 (X).  */\n+\n static inline int\n vect_pow2 (int x)\n {\n@@ -723,12 +742,17 @@ vect_pow2 (int x)\n #define DR_MISALIGNMENT(DR)   ((int) (size_t) (DR)->aux)\n #define SET_DR_MISALIGNMENT(DR, VAL)   ((DR)->aux = (void *) (size_t) (VAL))\n \n+/* Return TRUE if the data access is aligned, and FALSE otherwise.  */\n+\n static inline bool\n aligned_access_p (struct data_reference *data_ref_info)\n {\n   return (DR_MISALIGNMENT (data_ref_info) == 0);\n }\n \n+/* Return TRUE if the alignment of the data access is known, and FALSE\n+   otherwise.  */\n+\n static inline bool\n known_alignment_for_access_p (struct data_reference *data_ref_info)\n {"}]}