{"sha": "659e82ad0fff564050e3363172ef52a9a948a27f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU5ZTgyYWQwZmZmNTY0MDUwZTMzNjMxNzJlZjUyYTlhOTQ4YTI3Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-06-15T13:43:56Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-15T13:43:56Z"}, "message": "hashtable.h: Trivial formatting fixes.\n\n2004-06-15  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/hashtable.h: Trivial formatting fixes.\n\t* include/ext/rb_tree: Likewise.\n\nFrom-SVN: r83183", "tree": {"sha": "d8bea7b9eab5e1d4372a7b0a3c041c07dad395f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8bea7b9eab5e1d4372a7b0a3c041c07dad395f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/659e82ad0fff564050e3363172ef52a9a948a27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/659e82ad0fff564050e3363172ef52a9a948a27f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/659e82ad0fff564050e3363172ef52a9a948a27f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/659e82ad0fff564050e3363172ef52a9a948a27f/comments", "author": null, "committer": null, "parents": [{"sha": "d1238423cd03725a2beb98ffb157c4e5022ef3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1238423cd03725a2beb98ffb157c4e5022ef3cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1238423cd03725a2beb98ffb157c4e5022ef3cf"}], "stats": {"total": 1839, "additions": 991, "deletions": 848}, "files": [{"sha": "413d8c631e6e12234c242f616e65955ed920768c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659e82ad0fff564050e3363172ef52a9a948a27f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659e82ad0fff564050e3363172ef52a9a948a27f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=659e82ad0fff564050e3363172ef52a9a948a27f", "patch": "@@ -1,3 +1,8 @@\n+2004-06-15  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/hashtable.h: Trivial formatting fixes.\n+\t* include/ext/rb_tree: Likewise.\n+\n 2004-06-14  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/ext/hash_map: Trivial formatting fixes."}, {"sha": "15b04348d1b9c3f4cf9054b6185d73499c01bfea", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "modified", "additions": 976, "deletions": 839, "changes": 1815, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659e82ad0fff564050e3363172ef52a9a948a27f/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659e82ad0fff564050e3363172ef52a9a948a27f/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=659e82ad0fff564050e3363172ef52a9a948a27f", "patch": "@@ -73,922 +73,1059 @@\n \n namespace __gnu_cxx\n {\n-using std::size_t;\n-using std::ptrdiff_t;\n-using std::forward_iterator_tag;\n-using std::input_iterator_tag;\n-using std::_Construct;\n-using std::_Destroy;\n-using std::distance;\n-using std::vector;\n-using std::pair;\n-using std::__iterator_category;\n-\n-template <class _Val>\n-struct _Hashtable_node\n-{\n-  _Hashtable_node* _M_next;\n-  _Val _M_val;\n-};\n-\n-template <class _Val, class _Key, class _HashFcn, class _ExtractKey, \n-\t  class _EqualKey, class _Alloc = std::allocator<_Val> >\n-class hashtable;\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_iterator;\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_const_iterator;\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_iterator {\n-  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n-          _Hashtable;\n-  typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n-                              _ExtractKey, _EqualKey, _Alloc>\n-          iterator;\n-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n-                                    _ExtractKey, _EqualKey, _Alloc>\n-          const_iterator;\n-  typedef _Hashtable_node<_Val> _Node;\n-\n-  typedef forward_iterator_tag iterator_category;\n-  typedef _Val value_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef size_t size_type;\n-  typedef _Val& reference;\n-  typedef _Val* pointer;\n-\n-  _Node* _M_cur;\n-  _Hashtable* _M_ht;\n-\n-  _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n-    : _M_cur(__n), _M_ht(__tab) {}\n-  _Hashtable_iterator() {}\n-  reference operator*() const { return _M_cur->_M_val; }\n-  pointer operator->() const { return &(operator*()); }\n-  iterator& operator++();\n-  iterator operator++(int);\n-  bool operator==(const iterator& __it) const\n-    { return _M_cur == __it._M_cur; }\n-  bool operator!=(const iterator& __it) const\n-    { return _M_cur != __it._M_cur; }\n-};\n-\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_const_iterator {\n-  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n-          _Hashtable;\n-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n-                              _ExtractKey,_EqualKey,_Alloc>\n-          iterator;\n-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n-                                    _ExtractKey, _EqualKey, _Alloc>\n-          const_iterator;\n-  typedef _Hashtable_node<_Val> _Node;\n-\n-  typedef forward_iterator_tag iterator_category;\n-  typedef _Val value_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef size_t size_type;\n-  typedef const _Val& reference;\n-  typedef const _Val* pointer;\n-\n-  const _Node* _M_cur;\n-  const _Hashtable* _M_ht;\n-\n-  _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n-    : _M_cur(__n), _M_ht(__tab) {}\n-  _Hashtable_const_iterator() {}\n-  _Hashtable_const_iterator(const iterator& __it)\n-    : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}\n-  reference operator*() const { return _M_cur->_M_val; }\n-  pointer operator->() const { return &(operator*()); }\n-  const_iterator& operator++();\n-  const_iterator operator++(int);\n-  bool operator==(const const_iterator& __it) const\n-    { return _M_cur == __it._M_cur; }\n-  bool operator!=(const const_iterator& __it) const\n-    { return _M_cur != __it._M_cur; }\n-};\n-\n-// Note: assumes long is at least 32 bits.\n-enum { _S_num_primes = 28 };\n-\n-static const unsigned long __stl_prime_list[_S_num_primes] =\n-{\n-  53ul,         97ul,         193ul,       389ul,       769ul,\n-  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n-  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n-  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n-  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n-  1610612741ul, 3221225473ul, 4294967291ul\n-};\n-\n-inline unsigned long __stl_next_prime(unsigned long __n)\n-{\n-  const unsigned long* __first = __stl_prime_list;\n-  const unsigned long* __last = __stl_prime_list + (int)_S_num_primes;\n-  const unsigned long* pos = std::lower_bound(__first, __last, __n);\n-  return pos == __last ? *(__last - 1) : *pos;\n-}\n-\n-// Forward declaration of operator==.\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-class hashtable;\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n-                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2);\n-\n-\n-// Hashtables handle allocators a bit differently than other\n-// containers do.  If we're using standard-conforming allocators, then\n-// a hashtable unconditionally has a member variable to hold its\n-// allocator, even if it so happens that all instances of the\n-// allocator type are identical.  This is because, for hashtables,\n-// this extra storage is negligible.  Additionally, a base class\n-// wouldn't serve any other purposes; it wouldn't, for example,\n-// simplify the exception-handling code.\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-class hashtable {\n-public:\n-  typedef _Key key_type;\n-  typedef _Val value_type;\n-  typedef _HashFcn hasher;\n-  typedef _EqualKey key_equal;\n-\n-  typedef size_t            size_type;\n-  typedef ptrdiff_t         difference_type;\n-  typedef value_type*       pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type&       reference;\n-  typedef const value_type& const_reference;\n-\n-  hasher hash_funct() const { return _M_hash; }\n-  key_equal key_eq() const { return _M_equals; }\n-\n-private:\n-  typedef _Hashtable_node<_Val> _Node;\n-\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return _M_node_allocator; }\n-private:\n-  typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n-  typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n-  typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n-\n-  _Node_Alloc _M_node_allocator;\n-  _Node* _M_get_node() { return _M_node_allocator.allocate(1); }\n-  void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }\n-\n-private:\n-  hasher                _M_hash;\n-  key_equal             _M_equals;\n-  _ExtractKey           _M_get_key;\n-  _Vector_type          _M_buckets;\n-  size_type             _M_num_elements;\n-\n-public:\n-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n-          iterator;\n-  typedef _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,\n-                                    _Alloc>\n-          const_iterator;\n-\n-  friend struct\n-  _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;\n-  friend struct\n-  _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;\n-\n-public:\n-  hashtable(size_type __n,\n-            const _HashFcn&    __hf,\n-            const _EqualKey&   __eql,\n-            const _ExtractKey& __ext,\n-            const allocator_type& __a = allocator_type())\n-    : _M_node_allocator(__a),\n-      _M_hash(__hf),\n-      _M_equals(__eql),\n-      _M_get_key(__ext),\n-      _M_buckets(__a),\n-      _M_num_elements(0)\n-  {\n-    _M_initialize_buckets(__n);\n-  }\n-\n-  hashtable(size_type __n,\n-            const _HashFcn&    __hf,\n-            const _EqualKey&   __eql,\n-            const allocator_type& __a = allocator_type())\n-    : _M_node_allocator(__a),\n-      _M_hash(__hf),\n-      _M_equals(__eql),\n-      _M_get_key(_ExtractKey()),\n-      _M_buckets(__a),\n-      _M_num_elements(0)\n-  {\n-    _M_initialize_buckets(__n);\n-  }\n-\n-  hashtable(const hashtable& __ht)\n-    : _M_node_allocator(__ht.get_allocator()),\n-      _M_hash(__ht._M_hash),\n-      _M_equals(__ht._M_equals),\n-      _M_get_key(__ht._M_get_key),\n-      _M_buckets(__ht.get_allocator()),\n-      _M_num_elements(0)\n-  {\n-    _M_copy_from(__ht);\n-  }\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  using std::forward_iterator_tag;\n+  using std::input_iterator_tag;\n+  using std::_Construct;\n+  using std::_Destroy;\n+  using std::distance;\n+  using std::vector;\n+  using std::pair;\n+  using std::__iterator_category;\n+\n+  template <class _Val>\n+    struct _Hashtable_node\n+    {\n+      _Hashtable_node* _M_next;\n+      _Val _M_val;\n+    };\n \n-  hashtable& operator= (const hashtable& __ht)\n-  {\n-    if (&__ht != this) {\n-      clear();\n-      _M_hash = __ht._M_hash;\n-      _M_equals = __ht._M_equals;\n-      _M_get_key = __ht._M_get_key;\n-      _M_copy_from(__ht);\n-    }\n-    return *this;\n-  }\n+  template <class _Val, class _Key, class _HashFcn, class _ExtractKey, \n+\t    class _EqualKey, class _Alloc = std::allocator<_Val> >\n+    class hashtable;\n \n-  ~hashtable() { clear(); }\n+  template <class _Val, class _Key, class _HashFcn,\n+\t    class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_iterator;\n \n-  size_type size() const { return _M_num_elements; }\n-  size_type max_size() const { return size_type(-1); }\n-  bool empty() const { return size() == 0; }\n+  template <class _Val, class _Key, class _HashFcn,\n+\t    class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_const_iterator;\n \n-  void swap(hashtable& __ht)\n+  template <class _Val, class _Key, class _HashFcn,\n+\t    class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_iterator\n+    {\n+      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n+        _Hashtable;\n+      typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t  _ExtractKey, _EqualKey, _Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n+        const_iterator;\n+      typedef _Hashtable_node<_Val> _Node;\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Val value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+      typedef _Val& reference;\n+      typedef _Val* pointer;\n+      \n+      _Node* _M_cur;\n+      _Hashtable* _M_ht;\n+\n+      _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n+      : _M_cur(__n), _M_ht(__tab) {}\n+\n+      _Hashtable_iterator() {}\n+\n+      reference\n+      operator*() const\n+      { return _M_cur->_M_val; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      iterator&\n+      operator++();\n+\n+      iterator\n+      operator++(int);\n+\n+      bool\n+      operator==(const iterator& __it) const\n+      { return _M_cur == __it._M_cur; }\n+\n+      bool\n+      operator!=(const iterator& __it) const\n+      { return _M_cur != __it._M_cur; }\n+    };\n+\n+  template <class _Val, class _Key, class _HashFcn,\n+\t    class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_const_iterator\n+    {\n+      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n+        _Hashtable;\n+      typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n+\t\t\t\t  _ExtractKey,_EqualKey,_Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n+        const_iterator;\n+      typedef _Hashtable_node<_Val> _Node;\n+\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Val value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+      typedef const _Val& reference;\n+      typedef const _Val* pointer;\n+      \n+      const _Node* _M_cur;\n+      const _Hashtable* _M_ht;\n+\n+      _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n+      : _M_cur(__n), _M_ht(__tab) {}\n+\n+      _Hashtable_const_iterator() {}\n+\n+      _Hashtable_const_iterator(const iterator& __it)\n+      : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}\n+\n+      reference\n+      operator*() const\n+      { return _M_cur->_M_val; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      const_iterator&\n+      operator++();\n+\n+      const_iterator\n+      operator++(int);\n+\n+      bool\n+      operator==(const const_iterator& __it) const\n+      { return _M_cur == __it._M_cur; }\n+\n+      bool\n+      operator!=(const const_iterator& __it) const\n+      { return _M_cur != __it._M_cur; }\n+    };\n+\n+  // Note: assumes long is at least 32 bits.\n+  enum { _S_num_primes = 28 };\n+\n+  static const unsigned long __stl_prime_list[_S_num_primes] =\n+    {\n+      53ul,         97ul,         193ul,       389ul,       769ul,\n+      1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n+      49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n+      1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n+      50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n+      1610612741ul, 3221225473ul, 4294967291ul\n+    };\n+\n+  inline unsigned long\n+  __stl_next_prime(unsigned long __n)\n   {\n-    std::swap(_M_hash, __ht._M_hash);\n-    std::swap(_M_equals, __ht._M_equals);\n-    std::swap(_M_get_key, __ht._M_get_key);\n-    _M_buckets.swap(__ht._M_buckets);\n-    std::swap(_M_num_elements, __ht._M_num_elements);\n+    const unsigned long* __first = __stl_prime_list;\n+    const unsigned long* __last = __stl_prime_list + (int)_S_num_primes;\n+    const unsigned long* pos = std::lower_bound(__first, __last, __n);\n+    return pos == __last ? *(__last - 1) : *pos;\n   }\n \n-  iterator begin()\n-  {\n-    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-      if (_M_buckets[__n])\n-        return iterator(_M_buckets[__n], this);\n-    return end();\n-  }\n+  // Forward declaration of operator==.\n+  \n+  template <class _Val, class _Key, class _HF, class _Ex,\n+\t    class _Eq, class _All>\n+    class hashtable;\n+\n+  template <class _Val, class _Key, class _HF, class _Ex,\n+\t    class _Eq, class _All>\n+    bool\n+    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2);\n+\n+  // Hashtables handle allocators a bit differently than other\n+  // containers do.  If we're using standard-conforming allocators, then\n+  // a hashtable unconditionally has a member variable to hold its\n+  // allocator, even if it so happens that all instances of the\n+  // allocator type are identical.  This is because, for hashtables,\n+  // this extra storage is negligible.  Additionally, a base class\n+  // wouldn't serve any other purposes; it wouldn't, for example,\n+  // simplify the exception-handling code.\n+  \n+  template <class _Val, class _Key, class _HashFcn,\n+\t    class _ExtractKey, class _EqualKey, class _Alloc>\n+    class hashtable\n+    {\n+    public:\n+      typedef _Key key_type;\n+      typedef _Val value_type;\n+      typedef _HashFcn hasher;\n+      typedef _EqualKey key_equal;\n+\n+      typedef size_t            size_type;\n+      typedef ptrdiff_t         difference_type;\n+      typedef value_type*       pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type&       reference;\n+      typedef const value_type& const_reference;\n+\n+      hasher\n+      hash_funct() const\n+      { return _M_hash; }\n+\n+      key_equal\n+      key_eq() const\n+      { return _M_equals; }\n+\n+    private:\n+      typedef _Hashtable_node<_Val> _Node;\n+\n+    public:\n+      typedef _Alloc allocator_type;\n+      allocator_type\n+      get_allocator() const\n+      { return _M_node_allocator; }\n+\n+    private:\n+      typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n+      typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n+      typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n+\n+      _Node_Alloc _M_node_allocator;\n+\n+      _Node*\n+      _M_get_node()\n+      { return _M_node_allocator.allocate(1); }\n+\n+      void\n+      _M_put_node(_Node* __p)\n+      { _M_node_allocator.deallocate(__p, 1); }\n+\n+    private:\n+      hasher                _M_hash;\n+      key_equal             _M_equals;\n+      _ExtractKey           _M_get_key;\n+      _Vector_type          _M_buckets;\n+      size_type             _M_num_elements;\n+      \n+    public:\n+      typedef _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t  _EqualKey, _Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t\t_EqualKey, _Alloc>\n+        const_iterator;\n+\n+      friend struct\n+      _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>;\n+\n+      friend struct\n+      _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t_EqualKey, _Alloc>;\n+\n+    public:\n+      hashtable(size_type __n, const _HashFcn& __hf,\n+\t\tconst _EqualKey& __eql, const _ExtractKey& __ext,\n+\t\tconst allocator_type& __a = allocator_type())\n+      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n+\t_M_get_key(__ext), _M_buckets(__a), _M_num_elements(0)\n+      { _M_initialize_buckets(__n); }\n+\n+      hashtable(size_type __n, const _HashFcn& __hf,\n+\t\tconst _EqualKey& __eql,\n+\t\tconst allocator_type& __a = allocator_type())\n+      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n+\t_M_get_key(_ExtractKey()), _M_buckets(__a), _M_num_elements(0)\n+      { _M_initialize_buckets(__n); }\n+\n+      hashtable(const hashtable& __ht)\n+      : _M_node_allocator(__ht.get_allocator()), _M_hash(__ht._M_hash),\n+      _M_equals(__ht._M_equals), _M_get_key(__ht._M_get_key),\n+      _M_buckets(__ht.get_allocator()), _M_num_elements(0)\n+      { _M_copy_from(__ht); }\n+\n+      hashtable&\n+      operator= (const hashtable& __ht)\n+      {\n+\tif (&__ht != this)\n+\t  {\n+\t    clear();\n+\t    _M_hash = __ht._M_hash;\n+\t    _M_equals = __ht._M_equals;\n+\t    _M_get_key = __ht._M_get_key;\n+\t    _M_copy_from(__ht);\n+\t  }\n+\treturn *this;\n+      }\n \n-  iterator end() { return iterator(0, this); }\n+      ~hashtable()\n+      { clear(); }\n \n-  const_iterator begin() const\n-  {\n-    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-      if (_M_buckets[__n])\n-        return const_iterator(_M_buckets[__n], this);\n-    return end();\n-  }\n+      size_type\n+      size() const\n+      { return _M_num_elements; }\n \n-  const_iterator end() const { return const_iterator(0, this); }\n+      size_type\n+      max_size() const\n+      { return size_type(-1); }\n \n-  template <class _Vl, class _Ky, class _HF, class _Ex, class _Eq, class _Al>\n-  friend bool operator== (const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n-                          const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n-public:\n+      bool\n+      empty() const\n+      { return size() == 0; }\n \n-  size_type bucket_count() const { return _M_buckets.size(); }\n+      void\n+      swap(hashtable& __ht)\n+      {\n+\tstd::swap(_M_hash, __ht._M_hash);\n+\tstd::swap(_M_equals, __ht._M_equals);\n+\tstd::swap(_M_get_key, __ht._M_get_key);\n+\t_M_buckets.swap(__ht._M_buckets);\n+\tstd::swap(_M_num_elements, __ht._M_num_elements);\n+      }\n \n-  size_type max_bucket_count() const\n-    { return __stl_prime_list[(int)_S_num_primes - 1]; }\n+      iterator\n+      begin()\n+      {\n+\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+\t  if (_M_buckets[__n])\n+\t    return iterator(_M_buckets[__n], this);\n+\treturn end();\n+      }\n \n-  size_type elems_in_bucket(size_type __bucket) const\n-  {\n-    size_type __result = 0;\n-    for (_Node* __cur = _M_buckets[__bucket]; __cur; __cur = __cur->_M_next)\n-      __result += 1;\n-    return __result;\n-  }\n+      iterator\n+      end()\n+      { return iterator(0, this); }\n \n-  pair<iterator, bool> insert_unique(const value_type& __obj)\n-  {\n-    resize(_M_num_elements + 1);\n-    return insert_unique_noresize(__obj);\n-  }\n+      const_iterator\n+      begin() const\n+      {\n+\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+\t  if (_M_buckets[__n])\n+\t    return const_iterator(_M_buckets[__n], this);\n+\treturn end();\n+      }\n \n-  iterator insert_equal(const value_type& __obj)\n-  {\n-    resize(_M_num_elements + 1);\n-    return insert_equal_noresize(__obj);\n-  }\n+      const_iterator\n+      end() const\n+      { return const_iterator(0, this); }\n \n-  pair<iterator, bool> insert_unique_noresize(const value_type& __obj);\n-  iterator insert_equal_noresize(const value_type& __obj);\n+      template <class _Vl, class _Ky, class _HF, class _Ex, class _Eq,\n+\t\tclass _Al>\n+        friend bool\n+        operator==(const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n+\t\t   const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n \n-  template <class _InputIterator>\n-  void insert_unique(_InputIterator __f, _InputIterator __l)\n-  {\n-    insert_unique(__f, __l, __iterator_category(__f));\n-  }\n+    public:\n+      size_type\n+      bucket_count() const\n+      { return _M_buckets.size(); }\n \n-  template <class _InputIterator>\n-  void insert_equal(_InputIterator __f, _InputIterator __l)\n-  {\n-    insert_equal(__f, __l, __iterator_category(__f));\n-  }\n+      size_type\n+      max_bucket_count() const\n+      { return __stl_prime_list[(int)_S_num_primes - 1]; }\n \n-  template <class _InputIterator>\n-  void insert_unique(_InputIterator __f, _InputIterator __l,\n-                     input_iterator_tag)\n-  {\n-    for ( ; __f != __l; ++__f)\n-      insert_unique(*__f);\n-  }\n+      size_type\n+      elems_in_bucket(size_type __bucket) const\n+      {\n+\tsize_type __result = 0;\n+\tfor (_Node* __cur = _M_buckets[__bucket]; __cur; __cur = __cur->_M_next)\n+\t  __result += 1;\n+\treturn __result;\n+      }\n \n-  template <class _InputIterator>\n-  void insert_equal(_InputIterator __f, _InputIterator __l,\n-                    input_iterator_tag)\n-  {\n-    for ( ; __f != __l; ++__f)\n-      insert_equal(*__f);\n-  }\n+      pair<iterator, bool>\n+      insert_unique(const value_type& __obj)\n+      {\n+\tresize(_M_num_elements + 1);\n+\treturn insert_unique_noresize(__obj);\n+      }\n \n-  template <class _ForwardIterator>\n-  void insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n-                     forward_iterator_tag)\n-  {\n-    size_type __n = distance(__f, __l);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_unique_noresize(*__f);\n-  }\n+      iterator\n+      insert_equal(const value_type& __obj)\n+      {\n+\tresize(_M_num_elements + 1);\n+\treturn insert_equal_noresize(__obj);\n+      }\n \n-  template <class _ForwardIterator>\n-  void insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n-                    forward_iterator_tag)\n-  {\n-    size_type __n = distance(__f, __l);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_equal_noresize(*__f);\n-  }\n+      pair<iterator, bool>\n+      insert_unique_noresize(const value_type& __obj);\n \n-  reference find_or_insert(const value_type& __obj);\n+      iterator\n+      insert_equal_noresize(const value_type& __obj);\n \n-  iterator find(const key_type& __key)\n-  {\n-    size_type __n = _M_bkt_num_key(__key);\n-    _Node* __first;\n-    for ( __first = _M_buckets[__n];\n-          __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-          __first = __first->_M_next)\n-      {}\n-    return iterator(__first, this);\n-  }\n+      template <class _InputIterator>\n+        void\n+        insert_unique(_InputIterator __f, _InputIterator __l)\n+        { insert_unique(__f, __l, __iterator_category(__f)); }\n \n-  const_iterator find(const key_type& __key) const\n-  {\n-    size_type __n = _M_bkt_num_key(__key);\n-    const _Node* __first;\n-    for ( __first = _M_buckets[__n];\n-          __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-          __first = __first->_M_next)\n-      {}\n-    return const_iterator(__first, this);\n-  }\n+      template <class _InputIterator>\n+        void\n+        insert_equal(_InputIterator __f, _InputIterator __l)\n+        { insert_equal(__f, __l, __iterator_category(__f)); }\n \n-  size_type count(const key_type& __key) const\n-  {\n-    const size_type __n = _M_bkt_num_key(__key);\n-    size_type __result = 0;\n+      template <class _InputIterator>\n+        void\n+        insert_unique(_InputIterator __f, _InputIterator __l,\n+\t\t      input_iterator_tag)\n+        {\n+\t  for ( ; __f != __l; ++__f)\n+\t    insert_unique(*__f);\n+\t}\n+\n+      template <class _InputIterator>\n+        void\n+        insert_equal(_InputIterator __f, _InputIterator __l,\n+\t\t     input_iterator_tag)\n+        {\n+\t  for ( ; __f != __l; ++__f)\n+\t    insert_equal(*__f);\n+\t}\n+\n+      template <class _ForwardIterator>\n+        void\n+        insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n+\t\t      forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__f, __l);\n+\t  resize(_M_num_elements + __n);\n+\t  for ( ; __n > 0; --__n, ++__f)\n+\t    insert_unique_noresize(*__f);\n+\t}\n+\n+      template <class _ForwardIterator>\n+        void\n+        insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n+\t\t     forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__f, __l);\n+\t  resize(_M_num_elements + __n);\n+\t  for ( ; __n > 0; --__n, ++__f)\n+\t    insert_equal_noresize(*__f);\n+\t}\n \n-    for (const _Node* __cur = _M_buckets[__n]; __cur; __cur = __cur->_M_next)\n-      if (_M_equals(_M_get_key(__cur->_M_val), __key))\n-        ++__result;\n-    return __result;\n-  }\n+      reference\n+      find_or_insert(const value_type& __obj);\n \n-  pair<iterator, iterator>\n-  equal_range(const key_type& __key);\n+      iterator\n+      find(const key_type& __key)\n+      {\n+\tsize_type __n = _M_bkt_num_key(__key);\n+\t_Node* __first;\n+\tfor (__first = _M_buckets[__n];\n+\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+\t     __first = __first->_M_next)\n+\t  {}\n+\treturn iterator(__first, this);\n+      }\n \n-  pair<const_iterator, const_iterator>\n-  equal_range(const key_type& __key) const;\n+      const_iterator\n+      find(const key_type& __key) const\n+      {\n+\tsize_type __n = _M_bkt_num_key(__key);\n+\tconst _Node* __first;\n+\tfor (__first = _M_buckets[__n];\n+\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+\t     __first = __first->_M_next)\n+\t  {}\n+\treturn const_iterator(__first, this);\n+      }\n \n-  size_type erase(const key_type& __key);\n-  void erase(const iterator& __it);\n-  void erase(iterator __first, iterator __last);\n+      size_type\n+      count(const key_type& __key) const\n+      {\n+\tconst size_type __n = _M_bkt_num_key(__key);\n+\tsize_type __result = 0;\n+\t\n+\tfor (const _Node* __cur = _M_buckets[__n]; __cur;\n+\t     __cur = __cur->_M_next)\n+\t  if (_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t    ++__result;\n+\treturn __result;\n+      }\n \n-  void erase(const const_iterator& __it);\n-  void erase(const_iterator __first, const_iterator __last);\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key);\n \n-  void resize(size_type __num_elements_hint);\n-  void clear();\n+      pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const;\n \n-private:\n-  size_type _M_next_size(size_type __n) const\n-    { return __stl_next_prime(__n); }\n+      size_type\n+      erase(const key_type& __key);\n+      \n+      void\n+      erase(const iterator& __it);\n \n-  void _M_initialize_buckets(size_type __n)\n-  {\n-    const size_type __n_buckets = _M_next_size(__n);\n-    _M_buckets.reserve(__n_buckets);\n-    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n-    _M_num_elements = 0;\n-  }\n+      void\n+      erase(iterator __first, iterator __last);\n \n-  size_type _M_bkt_num_key(const key_type& __key) const\n-  {\n-    return _M_bkt_num_key(__key, _M_buckets.size());\n-  }\n+      void\n+      erase(const const_iterator& __it);\n \n-  size_type _M_bkt_num(const value_type& __obj) const\n-  {\n-    return _M_bkt_num_key(_M_get_key(__obj));\n-  }\n+      void\n+      erase(const_iterator __first, const_iterator __last);\n \n-  size_type _M_bkt_num_key(const key_type& __key, size_t __n) const\n-  {\n-    return _M_hash(__key) % __n;\n-  }\n+      void\n+      resize(size_type __num_elements_hint);\n \n-  size_type _M_bkt_num(const value_type& __obj, size_t __n) const\n-  {\n-    return _M_bkt_num_key(_M_get_key(__obj), __n);\n-  }\n+      void\n+      clear();\n \n-  _Node* _M_new_node(const value_type& __obj)\n-  {\n-    _Node* __n = _M_get_node();\n-    __n->_M_next = 0;\n-    try {\n-      _Construct(&__n->_M_val, __obj);\n-      return __n;\n-    }\n-    catch(...)\n+    private:\n+      size_type\n+      _M_next_size(size_type __n) const\n+      { return __stl_next_prime(__n); }\n+\n+      void\n+      _M_initialize_buckets(size_type __n)\n       {\n-\t_M_put_node(__n);\n-\t__throw_exception_again;\n+\tconst size_type __n_buckets = _M_next_size(__n);\n+\t_M_buckets.reserve(__n_buckets);\n+\t_M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n+\t_M_num_elements = 0;\n       }\n-  }\n \n-  void _M_delete_node(_Node* __n)\n-  {\n-    _Destroy(&__n->_M_val);\n-    _M_put_node(__n);\n-  }\n-\n-  void _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n-  void _M_erase_bucket(const size_type __n, _Node* __last);\n+      size_type\n+      _M_bkt_num_key(const key_type& __key) const\n+      { return _M_bkt_num_key(__key, _M_buckets.size()); }\n \n-  void _M_copy_from(const hashtable& __ht);\n+      size_type\n+      _M_bkt_num(const value_type& __obj) const\n+      { return _M_bkt_num_key(_M_get_key(__obj)); }\n \n-};\n+      size_type\n+      _M_bkt_num_key(const key_type& __key, size_t __n) const\n+      { return _M_hash(__key) % __n; }\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-          class _All>\n-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n-{\n-  const _Node* __old = _M_cur;\n-  _M_cur = _M_cur->_M_next;\n-  if (!_M_cur) {\n-    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-      _M_cur = _M_ht->_M_buckets[__bucket];\n-  }\n-  return *this;\n-}\n+      size_type\n+      _M_bkt_num(const value_type& __obj, size_t __n) const\n+      { return _M_bkt_num_key(_M_get_key(__obj), __n); }\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-          class _All>\n-inline _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n-{\n-  iterator __tmp = *this;\n-  ++*this;\n-  return __tmp;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-          class _All>\n-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n-{\n-  const _Node* __old = _M_cur;\n-  _M_cur = _M_cur->_M_next;\n-  if (!_M_cur) {\n-    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-      _M_cur = _M_ht->_M_buckets[__bucket];\n-  }\n-  return *this;\n-}\n+      _Node*\n+      _M_new_node(const value_type& __obj)\n+      {\n+\t_Node* __n = _M_get_node();\n+\t__n->_M_next = 0;\n+\ttry\n+\t  {\n+\t    _Construct(&__n->_M_val, __obj);\n+\t    return __n;\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    _M_put_node(__n);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-          class _All>\n-inline _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n-{\n-  const_iterator __tmp = *this;\n-  ++*this;\n-  return __tmp;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n-                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2)\n-{\n-  typedef typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::_Node _Node;\n-  if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n-    return false;\n-  for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n) {\n-    _Node* __cur1 = __ht1._M_buckets[__n];\n-    _Node* __cur2 = __ht2._M_buckets[__n];\n-    // Check same length of lists\n-    for ( ; __cur1 && __cur2;\n-          __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n-      {}\n-    if (__cur1 || __cur2)\n-      return false;\n-    // Now check one's elements are in the other\n-    for (__cur1 = __ht1._M_buckets[__n] ; __cur1; __cur1 = __cur1->_M_next)\n-    {\n-      bool _found__cur1 = false;\n-      for (_Node* __cur2 = __ht2._M_buckets[__n];\n-           __cur2; __cur2 = __cur2->_M_next)\n+      void\n+      _M_delete_node(_Node* __n)\n       {\n-        if (__cur1->_M_val == __cur2->_M_val)\n-        {\n-          _found__cur1 = true;\n-          break;\n-        }\n+\t_Destroy(&__n->_M_val);\n+\t_M_put_node(__n);\n       }\n-      if (!_found__cur1)\n-        return false;\n+      \n+      void\n+      _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n+\n+      void\n+      _M_erase_bucket(const size_type __n, _Node* __last);\n+\n+      void\n+      _M_copy_from(const hashtable& __ht);\n+    };\n+\n+  template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++()\n+    {\n+      const _Node* __old = _M_cur;\n+      _M_cur = _M_cur->_M_next;\n+      if (!_M_cur)\n+\t{\n+\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+\t    _M_cur = _M_ht->_M_buckets[__bucket];\n+\t}\n+      return *this;\n     }\n-  }\n-  return true;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n-                       const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {\n-  return !(__ht1 == __ht2);\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n-          class _All>\n-inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n-                 hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2) {\n-  __ht1.swap(__ht2);\n-}\n-\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool>\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::insert_unique_noresize(const value_type& __obj)\n-{\n-  const size_type __n = _M_bkt_num(__obj);\n-  _Node* __first = _M_buckets[__n];\n-\n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-      return pair<iterator, bool>(iterator(__cur, this), false);\n-\n-  _Node* __tmp = _M_new_node(__obj);\n-  __tmp->_M_next = __first;\n-  _M_buckets[__n] = __tmp;\n-  ++_M_num_elements;\n-  return pair<iterator, bool>(iterator(__tmp, this), true);\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::insert_equal_noresize(const value_type& __obj)\n-{\n-  const size_type __n = _M_bkt_num(__obj);\n-  _Node* __first = _M_buckets[__n];\n \n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {\n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __cur->_M_next;\n-      __cur->_M_next = __tmp;\n-      ++_M_num_elements;\n-      return iterator(__tmp, this);\n+  template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    inline _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++(int)\n+    {\n+      iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n     }\n \n-  _Node* __tmp = _M_new_node(__obj);\n-  __tmp->_M_next = __first;\n-  _M_buckets[__n] = __tmp;\n-  ++_M_num_elements;\n-  return iterator(__tmp, this);\n-}\n+  template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++()\n+    {\n+      const _Node* __old = _M_cur;\n+      _M_cur = _M_cur->_M_next;\n+      if (!_M_cur)\n+\t{\n+\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+\t    _M_cur = _M_ht->_M_buckets[__bucket];\n+\t}\n+      return *this;\n+    }\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)\n-{\n-  resize(_M_num_elements + 1);\n-\n-  size_type __n = _M_bkt_num(__obj);\n-  _Node* __first = _M_buckets[__n];\n-\n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-      return __cur->_M_val;\n-\n-  _Node* __tmp = _M_new_node(__obj);\n-  __tmp->_M_next = __first;\n-  _M_buckets[__n] = __tmp;\n-  ++_M_num_elements;\n-  return __tmp->_M_val;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator,\n-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator>\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)\n-{\n-  typedef pair<iterator, iterator> _Pii;\n-  const size_type __n = _M_bkt_num_key(__key);\n-\n-  for (_Node* __first = _M_buckets[__n]; __first; __first = __first->_M_next)\n-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n-      for (_Node* __cur = __first->_M_next; __cur; __cur = __cur->_M_next)\n-        if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-          return _Pii(iterator(__first, this), iterator(__cur, this));\n-      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-        if (_M_buckets[__m])\n-          return _Pii(iterator(__first, this),\n-                     iterator(_M_buckets[__m], this));\n-      return _Pii(iterator(__first, this), end());\n+  template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    inline _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++(int)\n+    {\n+      const_iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n     }\n-  return _Pii(end(), end());\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator,\n-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator>\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::equal_range(const key_type& __key) const\n-{\n-  typedef pair<const_iterator, const_iterator> _Pii;\n-  const size_type __n = _M_bkt_num_key(__key);\n-\n-  for (const _Node* __first = _M_buckets[__n] ;\n-       __first;\n-       __first = __first->_M_next) {\n-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n-      for (const _Node* __cur = __first->_M_next;\n-           __cur;\n-           __cur = __cur->_M_next)\n-        if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-          return _Pii(const_iterator(__first, this),\n-                      const_iterator(__cur, this));\n-      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-        if (_M_buckets[__m])\n-          return _Pii(const_iterator(__first, this),\n-                      const_iterator(_M_buckets[__m], this));\n-      return _Pii(const_iterator(__first, this), end());\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    bool\n+    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n+    {\n+      typedef typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::_Node _Node;\n+\n+      if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n+\treturn false;\n+\n+      for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n)\n+\t{\n+\t  _Node* __cur1 = __ht1._M_buckets[__n];\n+\t  _Node* __cur2 = __ht2._M_buckets[__n];\n+\t  // Check same length of lists\n+\t  for (; __cur1 && __cur2;\n+\t       __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n+\t    {}\n+\t  if (__cur1 || __cur2)\n+\t    return false;\n+\t  // Now check one's elements are in the other\n+\t  for (__cur1 = __ht1._M_buckets[__n] ; __cur1;\n+\t       __cur1 = __cur1->_M_next)\n+\t    {\n+\t      bool _found__cur1 = false;\n+\t      for (_Node* __cur2 = __ht2._M_buckets[__n];\n+\t\t   __cur2; __cur2 = __cur2->_M_next)\n+\t\t{\n+\t\t  if (__cur1->_M_val == __cur2->_M_val)\n+\t\t    {\n+\t\t      _found__cur1 = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (!_found__cur1)\n+\t\treturn false;\n+\t    }\n+\t}\n+      return true;\n     }\n-  }\n-  return _Pii(end(), end());\n-}\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)\n-{\n-  const size_type __n = _M_bkt_num_key(__key);\n-  _Node* __first = _M_buckets[__n];\n-  size_type __erased = 0;\n-\n-  if (__first) {\n-    _Node* __cur = __first;\n-    _Node* __next = __cur->_M_next;\n-    while (__next) {\n-      if (_M_equals(_M_get_key(__next->_M_val), __key)) {\n-        __cur->_M_next = __next->_M_next;\n-        _M_delete_node(__next);\n-        __next = __cur->_M_next;\n-        ++__erased;\n-        --_M_num_elements;\n-      }\n-      else {\n-        __cur = __next;\n-        __next = __cur->_M_next;\n-      }\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline bool\n+    operator!=(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n+    { return !(__ht1 == __ht2); }\n+\n+  template <class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n+\t    class _All>\n+    inline void\n+    swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n+\t hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2)\n+    { __ht1.swap(__ht2); }\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator, bool>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    insert_unique_noresize(const value_type& __obj)\n+    {\n+      const size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  return pair<iterator, bool>(iterator(__cur, this), false);\n+      \n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return pair<iterator, bool>(iterator(__tmp, this), true);\n     }\n-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n-      _M_buckets[__n] = __first->_M_next;\n-      _M_delete_node(__first);\n-      ++__erased;\n-      --_M_num_elements;\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    insert_equal_noresize(const value_type& __obj)\n+    {\n+      const size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  {\n+\t    _Node* __tmp = _M_new_node(__obj);\n+\t    __tmp->_M_next = __cur->_M_next;\n+\t    __cur->_M_next = __tmp;\n+\t    ++_M_num_elements;\n+\t    return iterator(__tmp, this);\n+\t  }\n+\n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return iterator(__tmp, this);\n     }\n-  }\n-  return __erased;\n-}\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const iterator& __it)\n-{\n-  _Node* __p = __it._M_cur;\n-  if (__p) {\n-    const size_type __n = _M_bkt_num(__p->_M_val);\n-    _Node* __cur = _M_buckets[__n];\n-\n-    if (__cur == __p) {\n-      _M_buckets[__n] = __cur->_M_next;\n-      _M_delete_node(__cur);\n-      --_M_num_elements;\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::reference\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    find_or_insert(const value_type& __obj)\n+    {\n+      resize(_M_num_elements + 1);\n+\n+      size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  return __cur->_M_val;\n+      \n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return __tmp->_M_val;\n     }\n-    else {\n-      _Node* __next = __cur->_M_next;\n-      while (__next) {\n-        if (__next == __p) {\n-          __cur->_M_next = __next->_M_next;\n-          _M_delete_node(__next);\n-          --_M_num_elements;\n-          break;\n-        }\n-        else {\n-          __cur = __next;\n-          __next = __cur->_M_next;\n-        }\n-      }\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator,\n+\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    equal_range(const key_type& __key)\n+    {\n+      typedef pair<iterator, iterator> _Pii;\n+      const size_type __n = _M_bkt_num_key(__key);\n+\n+      for (_Node* __first = _M_buckets[__n]; __first;\n+\t   __first = __first->_M_next)\n+\tif (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t  {\n+\t    for (_Node* __cur = __first->_M_next; __cur;\n+\t\t __cur = __cur->_M_next)\n+\t      if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t\treturn _Pii(iterator(__first, this), iterator(__cur, this));\n+\t    for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+\t      if (_M_buckets[__m])\n+\t\treturn _Pii(iterator(__first, this),\n+\t\t\t    iterator(_M_buckets[__m], this));\n+\t    return _Pii(iterator(__first, this), end());\n+\t  }\n+      return _Pii(end(), end());\n     }\n-  }\n-}\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::erase(iterator __first, iterator __last)\n-{\n-  size_type __f_bucket = __first._M_cur ?\n-    _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();\n-  size_type __l_bucket = __last._M_cur ?\n-    _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();\n-\n-  if (__first._M_cur == __last._M_cur)\n-    return;\n-  else if (__f_bucket == __l_bucket)\n-    _M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n-  else {\n-    _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n-    for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n-      _M_erase_bucket(__n, 0);\n-    if (__l_bucket != _M_buckets.size())\n-      _M_erase_bucket(__l_bucket, __last._M_cur);\n-  }\n-}\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator,\n+\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    equal_range(const key_type& __key) const\n+    {\n+      typedef pair<const_iterator, const_iterator> _Pii;\n+      const size_type __n = _M_bkt_num_key(__key);\n+\n+      for (const _Node* __first = _M_buckets[__n]; __first;\n+\t   __first = __first->_M_next)\n+\t{\n+\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t    {\n+\t      for (const _Node* __cur = __first->_M_next; __cur;\n+\t\t   __cur = __cur->_M_next)\n+\t\tif (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t\t  return _Pii(const_iterator(__first, this),\n+\t\t\t      const_iterator(__cur, this));\n+\t      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+\t\tif (_M_buckets[__m])\n+\t\t  return _Pii(const_iterator(__first, this),\n+\t\t\t      const_iterator(_M_buckets[__m], this));\n+\t      return _Pii(const_iterator(__first, this), end());\n+\t    }\n+\t}\n+      return _Pii(end(), end());\n+    }\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-inline void\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const_iterator __first,\n-                                             const_iterator __last)\n-{\n-  erase(iterator(const_cast<_Node*>(__first._M_cur),\n-                 const_cast<hashtable*>(__first._M_ht)),\n-        iterator(const_cast<_Node*>(__last._M_cur),\n-                 const_cast<hashtable*>(__last._M_ht)));\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-inline void\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const const_iterator& __it)\n-{\n-  erase(iterator(const_cast<_Node*>(__it._M_cur),\n-                 const_cast<hashtable*>(__it._M_ht)));\n-}\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::size_type\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const key_type& __key)\n+    {\n+      const size_type __n = _M_bkt_num_key(__key);\n+      _Node* __first = _M_buckets[__n];\n+      size_type __erased = 0;\n+      \n+      if (__first)\n+\t{\n+\t  _Node* __cur = __first;\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next)\n+\t    {\n+\t      if (_M_equals(_M_get_key(__next->_M_val), __key))\n+\t\t{\n+\t\t  __cur->_M_next = __next->_M_next;\n+\t\t  _M_delete_node(__next);\n+\t\t  __next = __cur->_M_next;\n+\t\t  ++__erased;\n+\t\t  --_M_num_elements;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __cur = __next;\n+\t\t  __next = __cur->_M_next;\n+\t\t}\n+\t    }\n+\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t    {\n+\t      _M_buckets[__n] = __first->_M_next;\n+\t      _M_delete_node(__first);\n+\t      ++__erased;\n+\t      --_M_num_elements;\n+\t    }\n+\t}\n+      return __erased;\n+    }\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::resize(size_type __num_elements_hint)\n-{\n-  const size_type __old_n = _M_buckets.size();\n-  if (__num_elements_hint > __old_n) {\n-    const size_type __n = _M_next_size(__num_elements_hint);\n-    if (__n > __old_n) {\n-      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n-      try {\n-        for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {\n-          _Node* __first = _M_buckets[__bucket];\n-          while (__first) {\n-            size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);\n-            _M_buckets[__bucket] = __first->_M_next;\n-            __first->_M_next = __tmp[__new_bucket];\n-            __tmp[__new_bucket] = __first;\n-            __first = _M_buckets[__bucket];\n-          }\n-        }\n-        _M_buckets.swap(__tmp);\n-      }\n-      catch(...) {\n-        for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {\n-          while (__tmp[__bucket]) {\n-            _Node* __next = __tmp[__bucket]->_M_next;\n-            _M_delete_node(__tmp[__bucket]);\n-            __tmp[__bucket] = __next;\n-          }\n-        }\n-        __throw_exception_again;\n-      }\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const iterator& __it)\n+    {\n+      _Node* __p = __it._M_cur;\n+      if (__p)\n+\t{\n+\t  const size_type __n = _M_bkt_num(__p->_M_val);\n+\t  _Node* __cur = _M_buckets[__n];\n+\t  \n+\t  if (__cur == __p)\n+\t    {\n+\t      _M_buckets[__n] = __cur->_M_next;\n+\t      _M_delete_node(__cur);\n+\t      --_M_num_elements;\n+\t    }\n+\t  else\n+\t    {\n+\t      _Node* __next = __cur->_M_next;\n+\t      while (__next)\n+\t\t{\n+\t\t  if (__next == __p)\n+\t\t    {\n+\t\t      __cur->_M_next = __next->_M_next;\n+\t\t      _M_delete_node(__next);\n+\t\t      --_M_num_elements;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      __cur = __next;\n+\t\t      __next = __cur->_M_next;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n-  }\n-}\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::_M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n-{\n-  _Node* __cur = _M_buckets[__n];\n-  if (__cur == __first)\n-    _M_erase_bucket(__n, __last);\n-  else {\n-    _Node* __next;\n-    for (__next = __cur->_M_next;\n-         __next != __first;\n-         __cur = __next, __next = __cur->_M_next)\n-      ;\n-    while (__next != __last) {\n-      __cur->_M_next = __next->_M_next;\n-      _M_delete_node(__next);\n-      __next = __cur->_M_next;\n-      --_M_num_elements;\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      size_type __f_bucket = __first._M_cur ? _M_bkt_num(__first._M_cur->_M_val)\n+\t                                    : _M_buckets.size();\n+\n+      size_type __l_bucket = __last._M_cur ? _M_bkt_num(__last._M_cur->_M_val)\n+\t                                   : _M_buckets.size();\n+\n+      if (__first._M_cur == __last._M_cur)\n+\treturn;\n+      else if (__f_bucket == __l_bucket)\n+\t_M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n+      else\n+\t{\n+\t  _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n+\t  for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n+\t    _M_erase_bucket(__n, 0);\n+\t  if (__l_bucket != _M_buckets.size())\n+\t    _M_erase_bucket(__l_bucket, __last._M_cur);\n+\t}\n     }\n-  }\n-}\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::_M_erase_bucket(const size_type __n, _Node* __last)\n-{\n-  _Node* __cur = _M_buckets[__n];\n-  while (__cur != __last) {\n-    _Node* __next = __cur->_M_next;\n-    _M_delete_node(__cur);\n-    __cur = __next;\n-    _M_buckets[__n] = __cur;\n-    --_M_num_elements;\n-  }\n-}\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      erase(iterator(const_cast<_Node*>(__first._M_cur),\n+\t\t     const_cast<hashtable*>(__first._M_ht)),\n+\t    iterator(const_cast<_Node*>(__last._M_cur),\n+\t\t     const_cast<hashtable*>(__last._M_ht)));\n+    }\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()\n-{\n-  for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {\n-    _Node* __cur = _M_buckets[__i];\n-    while (__cur != 0) {\n-      _Node* __next = __cur->_M_next;\n-      _M_delete_node(__cur);\n-      __cur = __next;\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const const_iterator& __it)\n+    { erase(iterator(const_cast<_Node*>(__it._M_cur),\n+\t\t     const_cast<hashtable*>(__it._M_ht))); }\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    resize(size_type __num_elements_hint)\n+    {\n+      const size_type __old_n = _M_buckets.size();\n+      if (__num_elements_hint > __old_n)\n+\t{\n+\t  const size_type __n = _M_next_size(__num_elements_hint);\n+\t  if (__n > __old_n)\n+\t    {\n+\t      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n+\t      try\n+\t\t{\n+\t\t  for (size_type __bucket = 0; __bucket < __old_n; ++__bucket)\n+\t\t    {\n+\t\t      _Node* __first = _M_buckets[__bucket];\n+\t\t      while (__first)\n+\t\t\t{\n+\t\t\t  size_type __new_bucket = _M_bkt_num(__first->_M_val,\n+\t\t\t\t\t\t\t      __n);\n+\t\t\t  _M_buckets[__bucket] = __first->_M_next;\n+\t\t\t  __first->_M_next = __tmp[__new_bucket];\n+\t\t\t  __tmp[__new_bucket] = __first;\n+\t\t\t  __first = _M_buckets[__bucket];\n+\t\t\t}\n+\t\t    }\n+\t\t  _M_buckets.swap(__tmp);\n+\t\t}\n+\t      catch(...)\n+\t\t{\n+\t\t  for (size_type __bucket = 0; __bucket < __tmp.size();\n+\t\t       ++__bucket)\n+\t\t    {\n+\t\t      while (__tmp[__bucket])\n+\t\t\t{\n+\t\t\t  _Node* __next = __tmp[__bucket]->_M_next;\n+\t\t\t  _M_delete_node(__tmp[__bucket]);\n+\t\t\t  __tmp[__bucket] = __next;\n+\t\t\t}\n+\t\t    }\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t    }\n+\t}\n     }\n-    _M_buckets[__i] = 0;\n-  }\n-  _M_num_elements = 0;\n-}\n \n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n+    {\n+      _Node* __cur = _M_buckets[__n];\n+      if (__cur == __first)\n+\t_M_erase_bucket(__n, __last);\n+      else\n+\t{\n+\t  _Node* __next;\n+\t  for (__next = __cur->_M_next;\n+\t       __next != __first;\n+\t       __cur = __next, __next = __cur->_M_next)\n+\t    ;\n+\t  while (__next != __last)\n+\t    {\n+\t      __cur->_M_next = __next->_M_next;\n+\t      _M_delete_node(__next);\n+\t      __next = __cur->_M_next;\n+\t      --_M_num_elements;\n+\t    }\n+\t}\n+    }\n \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::_M_copy_from(const hashtable& __ht)\n-{\n-  _M_buckets.clear();\n-  _M_buckets.reserve(__ht._M_buckets.size());\n-  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n-  try {\n-    for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n-      const _Node* __cur = __ht._M_buckets[__i];\n-      if (__cur) {\n-        _Node* __local_copy = _M_new_node(__cur->_M_val);\n-        _M_buckets[__i] = __local_copy;\n-\n-        for (_Node* __next = __cur->_M_next;\n-             __next;\n-             __cur = __next, __next = __cur->_M_next) {\n-          __local_copy->_M_next = _M_new_node(__next->_M_val);\n-          __local_copy = __local_copy->_M_next;\n-        }\n-      }\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_erase_bucket(const size_type __n, _Node* __last)\n+    {\n+      _Node* __cur = _M_buckets[__n];\n+      while (__cur != __last)\n+\t{\n+\t  _Node* __next = __cur->_M_next;\n+\t  _M_delete_node(__cur);\n+\t  __cur = __next;\n+\t  _M_buckets[__n] = __cur;\n+\t  --_M_num_elements;\n+\t}\n     }\n-    _M_num_elements = __ht._M_num_elements;\n-  }\n-  catch(...)\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    clear()\n     {\n-      clear();\n-      __throw_exception_again;\n+      for (size_type __i = 0; __i < _M_buckets.size(); ++__i)\n+\t{\n+\t  _Node* __cur = _M_buckets[__i];\n+\t  while (__cur != 0)\n+\t    {\n+\t      _Node* __next = __cur->_M_next;\n+\t      _M_delete_node(__cur);\n+\t      __cur = __next;\n+\t    }\n+\t  _M_buckets[__i] = 0;\n+\t}\n+      _M_num_elements = 0;\n+    }\n+\n+  template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_copy_from(const hashtable& __ht)\n+    {\n+      _M_buckets.clear();\n+      _M_buckets.reserve(__ht._M_buckets.size());\n+      _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n+      try\n+\t{\n+\t  for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n+\t    const _Node* __cur = __ht._M_buckets[__i];\n+\t    if (__cur)\n+\t      {\n+\t\t_Node* __local_copy = _M_new_node(__cur->_M_val);\n+\t\t_M_buckets[__i] = __local_copy;\n+\t\t\n+\t\tfor (_Node* __next = __cur->_M_next;\n+\t\t     __next;\n+\t\t     __cur = __next, __next = __cur->_M_next)\n+\t\t  {\n+\t\t    __local_copy->_M_next = _M_new_node(__next->_M_val);\n+\t\t    __local_copy = __local_copy->_M_next;\n+\t\t  }\n+\t      }\n+\t  }\n+\t  _M_num_elements = __ht._M_num_elements;\n+\t}\n+      catch(...)\n+\t{\n+\t  clear();\n+\t  __throw_exception_again;\n+\t}\n     }\n-}\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "3d7bb35becfa7efb694bcc3ebe983a82d3a957af", "filename": "libstdc++-v3/include/ext/rb_tree", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/659e82ad0fff564050e3363172ef52a9a948a27f/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/659e82ad0fff564050e3363172ef52a9a948a27f/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree?ref=659e82ad0fff564050e3363172ef52a9a948a27f", "patch": "@@ -1,6 +1,6 @@\n // rb_tree extension -*- C++ -*-\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -81,17 +81,18 @@ namespace __gnu_cxx\n    */\n   template <class _Key, class _Value, class _KeyOfValue, class _Compare,\n \t    class _Alloc = allocator<_Value> >\n-  struct rb_tree : public _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc>\n-  {\n-    typedef _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc> _Base;\n-    typedef typename _Base::allocator_type allocator_type;\n+    struct rb_tree\n+    : public _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc>\n+    {\n+      typedef _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc> _Base;\n+      typedef typename _Base::allocator_type allocator_type;\n \n-    rb_tree(const _Compare& __comp = _Compare(),\n-\t    const allocator_type& __a = allocator_type())\n+      rb_tree(const _Compare& __comp = _Compare(),\n+\t      const allocator_type& __a = allocator_type())\n       : _Base(__comp, __a) { }\n \n-    ~rb_tree() { }\n-  };\n+      ~rb_tree() { }\n+    };\n } // namespace __gnu_cxx\n \n #endif"}]}