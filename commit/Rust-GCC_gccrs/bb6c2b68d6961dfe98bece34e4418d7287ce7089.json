{"sha": "bb6c2b68d6961dfe98bece34e4418d7287ce7089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI2YzJiNjhkNjk2MWRmZTk4YmVjZTM0ZTQ0MThkNzI4N2NlNzA4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:59:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:59:59Z"}, "message": "Add support for conditional reductions using SVE CLASTB\n\nThis patch uses SVE CLASTB to optimise conditional reductions.  It means\nthat we no longer need to maintain a separate index vector to record\nthe most recent valid value, and no longer need to worry about overflow\ncases.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/md.texi (fold_extract_last_@var{m}): Document.\n\t* doc/sourcebuild.texi (vect_fold_extract_last): Likewise.\n\t* optabs.def (fold_extract_last_optab): New optab.\n\t* internal-fn.def (FOLD_EXTRACT_LAST): New internal function.\n\t* internal-fn.c (fold_extract_direct): New macro.\n\t(expand_fold_extract_optab_fn): Likewise.\n\t(direct_fold_extract_optab_supported_p): Likewise.\n\t* tree-vectorizer.h (EXTRACT_LAST_REDUCTION): New vect_reduction_type.\n\t* tree-vect-loop.c (vect_model_reduction_cost): Handle\n\tEXTRACT_LAST_REDUCTION.\n\t(get_initial_def_for_reduction): Do not create an initial vector\n\tfor EXTRACT_LAST_REDUCTION reductions.\n\t(vectorizable_reduction): Leave the scalar phi in place for\n\tEXTRACT_LAST_REDUCTIONs.  Try using EXTRACT_LAST_REDUCTION\n\tahead of INTEGER_INDUC_COND_REDUCTION.  Do not check for an\n\tepilogue code for EXTRACT_LAST_REDUCTION and defer the\n\ttransform phase to vectorizable_condition.\n\t* tree-vect-stmts.c (vect_finish_stmt_generation_1): New function,\n\tsplit out from...\n\t(vect_finish_stmt_generation): ...here.\n\t(vect_finish_replace_stmt): New function.\n\t(vectorizable_condition): Handle EXTRACT_LAST_REDUCTION.\n\t* config/aarch64/aarch64-sve.md (fold_extract_last_<mode>): New\n\tpattern.\n\t* config/aarch64/aarch64.md (UNSPEC_CLASTB): New unspec.\n\ngcc/testsuite/\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_fold_extract_last): New proc.\n\t* gcc.dg/vect/pr65947-1.c: Update dump messages.  Add markup\n\tfor fold_extract_last.\n\t* gcc.dg/vect/pr65947-2.c: Likewise.\n\t* gcc.dg/vect/pr65947-3.c: Likewise.\n\t* gcc.dg/vect/pr65947-4.c: Likewise.\n\t* gcc.dg/vect/pr65947-5.c: Likewise.\n\t* gcc.dg/vect/pr65947-6.c: Likewise.\n\t* gcc.dg/vect/pr65947-9.c: Likewise.\n\t* gcc.dg/vect/pr65947-10.c: Likewise.\n\t* gcc.dg/vect/pr65947-12.c: Likewise.\n\t* gcc.dg/vect/pr65947-14.c: Likewise.\n\t* gcc.dg/vect/pr80631-1.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_1.c: New test.\n\t* gcc.target/aarch64/sve/clastb_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_2.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_3.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_3_run.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_4.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_4_run.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_5.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_5_run.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_6.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_6_run.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_7.c: Likewise.\n\t* gcc.target/aarch64/sve/clastb_7_run.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256633", "tree": {"sha": "ecb67de45fc3758acd23d527e406c0441be496d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecb67de45fc3758acd23d527e406c0441be496d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb6c2b68d6961dfe98bece34e4418d7287ce7089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6c2b68d6961dfe98bece34e4418d7287ce7089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6c2b68d6961dfe98bece34e4418d7287ce7089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6c2b68d6961dfe98bece34e4418d7287ce7089/comments", "author": null, "committer": null, "parents": [{"sha": "bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe1bb57ba4dfd78f8c1ac7d46cf27e8e7408676"}], "stats": {"total": 649, "additions": 569, "deletions": 80}, "files": [{"sha": "169cae0b06edca5cbc067dfa7fe162298bb21afe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -1,3 +1,33 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/md.texi (fold_extract_last_@var{m}): Document.\n+\t* doc/sourcebuild.texi (vect_fold_extract_last): Likewise.\n+\t* optabs.def (fold_extract_last_optab): New optab.\n+\t* internal-fn.def (FOLD_EXTRACT_LAST): New internal function.\n+\t* internal-fn.c (fold_extract_direct): New macro.\n+\t(expand_fold_extract_optab_fn): Likewise.\n+\t(direct_fold_extract_optab_supported_p): Likewise.\n+\t* tree-vectorizer.h (EXTRACT_LAST_REDUCTION): New vect_reduction_type.\n+\t* tree-vect-loop.c (vect_model_reduction_cost): Handle\n+\tEXTRACT_LAST_REDUCTION.\n+\t(get_initial_def_for_reduction): Do not create an initial vector\n+\tfor EXTRACT_LAST_REDUCTION reductions.\n+\t(vectorizable_reduction): Leave the scalar phi in place for\n+\tEXTRACT_LAST_REDUCTIONs.  Try using EXTRACT_LAST_REDUCTION\n+\tahead of INTEGER_INDUC_COND_REDUCTION.  Do not check for an\n+\tepilogue code for EXTRACT_LAST_REDUCTION and defer the\n+\ttransform phase to vectorizable_condition.\n+\t* tree-vect-stmts.c (vect_finish_stmt_generation_1): New function,\n+\tsplit out from...\n+\t(vect_finish_stmt_generation): ...here.\n+\t(vect_finish_replace_stmt): New function.\n+\t(vectorizable_condition): Handle EXTRACT_LAST_REDUCTION.\n+\t* config/aarch64/aarch64-sve.md (fold_extract_last_<mode>): New\n+\tpattern.\n+\t* config/aarch64/aarch64.md (UNSPEC_CLASTB): New unspec.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "f4bd987d8070ee75bc8a611cf5bfa9939d05bd65", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -1427,6 +1427,21 @@\n   \"<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Set operand 0 to the last active element in operand 3, or to tied\n+;; operand 1 if no elements are active.\n+(define_insn \"fold_extract_last_<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\" \"=r, w\")\n+\t(unspec:<VEL>\n+\t  [(match_operand:<VEL> 1 \"register_operand\" \"0, 0\")\n+\t   (match_operand:<VPRED> 2 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand:SVE_ALL 3 \"register_operand\" \"w, w\")]\n+\t  UNSPEC_CLASTB))]\n+  \"TARGET_SVE\"\n+  \"@\n+   clastb\\t%<vwcore>0, %2, %<vwcore>0, %3.<Vetype>\n+   clastb\\t%<vw>0, %2, %<vw>0, %3.<Vetype>\"\n+)\n+\n ;; Unpredicated integer add reduction.\n (define_expand \"reduc_plus_scal_<mode>\"\n   [(set (match_operand:<VEL> 0 \"register_operand\")"}, {"sha": "c38f2011efd46cce94e7666775b14136fa5eb55f", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -164,6 +164,7 @@\n     UNSPEC_LDN\n     UNSPEC_STN\n     UNSPEC_INSR\n+    UNSPEC_CLASTB\n ])\n \n (define_c_enum \"unspecv\" ["}, {"sha": "d31577bed6dff445ada247c40b891513ce64cfed", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -5227,6 +5227,15 @@ has vector mode @var{m} while operand 0 has the mode appropriate for one\n element of @var{m}.  Operand 1 has the usual mask mode for vectors of mode\n @var{m}; see @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n \n+@cindex @code{fold_extract_last_@var{m}} instruction pattern\n+@item @code{fold_extract_last_@var{m}}\n+If any bits of mask operand 2 are set, find the last set bit, extract\n+the associated element from vector operand 3, and store the result\n+in operand 0.  Store operand 1 in operand 0 otherwise.  Operand 3\n+has mode @var{m} and operands 0 and 1 have the mode appropriate for\n+one element of @var{m}.  Operand 2 has the usual mask mode for vectors\n+of mode @var{m}; see @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n+\n @cindex @code{sdot_prod@var{m}} instruction pattern\n @item @samp{sdot_prod@var{m}}\n @cindex @code{udot_prod@var{m}} instruction pattern"}, {"sha": "e02d4da9b0f9d94742177966b8cab4057f74e530", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -1588,6 +1588,9 @@ Target supports 32- and 16-bytes vectors.\n \n @item vect_logical_reduc\n Target supports AND, IOR and XOR reduction on vectors.\n+\n+@item vect_fold_extract_last\n+Target supports the @code{fold_extract_last} optab.\n @end table\n \n @subsubsection Thread Local Storage attributes"}, {"sha": "0cc59e84514355bed13cdf34ac2ae551ed152621", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -91,6 +91,7 @@ init_internal_fns ()\n #define cond_unary_direct { 1, 1, true }\n #define cond_binary_direct { 1, 1, true }\n #define while_direct { 0, 2, false }\n+#define fold_extract_direct { 2, 2, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n@@ -2893,6 +2894,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_cond_binary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n+#define expand_fold_extract_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n+\n /* RETURN_TYPE and ARGS are a return type and argument list that are\n    in principle compatible with FN (which satisfies direct_internal_fn_p).\n    Return the types that should be used to determine whether the\n@@ -2975,6 +2979,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_while_optab_supported_p convert_optab_supported_p\n+#define direct_fold_extract_optab_supported_p direct_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n "}, {"sha": "44330466cfdb1ba7f8f2d5ff98ae09529168e052", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -158,6 +158,11 @@ DEF_INTERNAL_OPTAB_FN (REDUC_XOR, ECF_CONST | ECF_NOTHROW,\n DEF_INTERNAL_OPTAB_FN (EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n \t\t       extract_last, cond_unary)\n \n+/* Same, but return the first argument if no elements are active.  */\n+DEF_INTERNAL_OPTAB_FN (FOLD_EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n+\t\t       fold_extract_last, fold_extract)\n+\n+\n /* Unary math functions.  */\n DEF_INTERNAL_FLT_FN (ACOS, ECF_CONST, acos, unary)\n DEF_INTERNAL_FLT_FN (ASIN, ECF_CONST, asin, unary)"}, {"sha": "e19d4a50c963396d518c69c350660adba07fb42e", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -308,6 +308,7 @@ OPTAB_D (reduc_ior_scal_optab,  \"reduc_ior_scal_$a\")\n OPTAB_D (reduc_xor_scal_optab,  \"reduc_xor_scal_$a\")\n \n OPTAB_D (extract_last_optab, \"extract_last_$a\")\n+OPTAB_D (fold_extract_last_optab, \"fold_extract_last_$a\")\n \n OPTAB_D (sdot_prod_optab, \"sdot_prod$I$a\")\n OPTAB_D (ssum_widen_optab, \"widen_ssum$I$a3\")"}, {"sha": "df572fda5ba7177fe21b0090da48aa796268d699", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -1,3 +1,36 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_fold_extract_last): New proc.\n+\t* gcc.dg/vect/pr65947-1.c: Update dump messages.  Add markup\n+\tfor fold_extract_last.\n+\t* gcc.dg/vect/pr65947-2.c: Likewise.\n+\t* gcc.dg/vect/pr65947-3.c: Likewise.\n+\t* gcc.dg/vect/pr65947-4.c: Likewise.\n+\t* gcc.dg/vect/pr65947-5.c: Likewise.\n+\t* gcc.dg/vect/pr65947-6.c: Likewise.\n+\t* gcc.dg/vect/pr65947-9.c: Likewise.\n+\t* gcc.dg/vect/pr65947-10.c: Likewise.\n+\t* gcc.dg/vect/pr65947-12.c: Likewise.\n+\t* gcc.dg/vect/pr65947-14.c: Likewise.\n+\t* gcc.dg/vect/pr80631-1.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_1.c: New test.\n+\t* gcc.target/aarch64/sve/clastb_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_3_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_4_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_5_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_6_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/clastb_7_run.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "879819d576ac738a6b18cbc2ebe3f5be8c1c2d29", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -41,4 +41,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { target { ! vect_fold_extract_last } } } } */"}, {"sha": "f37aecab082468722ed7cd9c7858b3f59fb28209", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-10.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -42,5 +42,6 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */\n "}, {"sha": "b84fd41bc63ef89874ff9ae2ba28fc7c5bf63d6a", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-12.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-12.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -42,4 +42,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "9f1e4e1eb6a6ffe731a12de08899f8d1230b7d18", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-14.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-14.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -41,4 +41,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { target { ! vect_fold_extract_last } } } } */"}, {"sha": "18d33c436a526fb091163a9b82f17e1198f85cd3", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -42,4 +42,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "427abdb4140090cec89835eaa4b72d3c874d217f", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -52,4 +52,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "186e03a63465da695d25db76b17f80862b7768b3", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-4.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -41,5 +41,6 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { target { ! vect_fold_extract_last } } } } */\n "}, {"sha": "c91b648aa056c670d391111a0fea2efa50ca8ea0", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-5.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -50,6 +50,8 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" { target { ! vect_fold_extract_last } } } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" { xfail vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "b072c8d33a2143426556aefbda592df1c7ced7c4", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-6.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -41,4 +41,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n /* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "e43e0e473bed36ca7a34ba2dd62b04499f6e9de1", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-9.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-9.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -45,5 +45,8 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */\n-/* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" { target { ! vect_fold_extract_last } } } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" { target { ! vect_fold_extract_last } } } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 2 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "92bf35a0a3e9fc6dc7acdd6a669dbf4cf06f12a1", "filename": "gcc/testsuite/gcc.dg/vect/pr80631-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -73,4 +73,5 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 5 \"vect\" { target vect_condition } } } */\n-/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 10 \"vect\" { target vect_condition } } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 10 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 10 \"vect\" { target { { ! vect_fold_extract_last } && vect_condition } } } } */"}, {"sha": "d4f9b0b6a94a4c054fc7ce3dac3236307459a2ee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_1.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define N 32\n+\n+/* Simple condition reduction.  */\n+\n+int __attribute__ ((noinline, noclone))\n+condition_reduction (int *a, int min_v)\n+{\n+  int last = 66; /* High start value.  */\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+/* { dg-final { scan-assembler {\\tclastb\\tw[0-9]+, p[0-7], w[0-9]+, z[0-9]+\\.s} } } */"}, {"sha": "fafc70ca3e4198ac72e973ddeb2d5f6da7c13f83", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_1_run.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_1_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"clastb_1.c\"\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  int a[N] = {\n+    11, -12, 13, 14, 15, 16, 17, 18, 19, 20,\n+    1, 2, -3, 4, 5, 6, 7, -8, 9, 10,\n+    21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+    31, 32\n+  };\n+\n+  int ret = condition_reduction (a, 1);\n+\n+  if (ret != 17)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "2c49bd3b0f0ec0f99fe2c65ca98af88212b9d9b2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_2.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#if !defined(TYPE)\n+#define TYPE uint32_t\n+#endif\n+\n+#define N 254\n+\n+/* Non-simple condition reduction.  */\n+\n+TYPE __attribute__ ((noinline, noclone))\n+condition_reduction (TYPE *a, TYPE min_v)\n+{\n+  TYPE last = 65;\n+\n+  for (TYPE i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+/* { dg-final { scan-assembler {\\tclastb\\tw[0-9]+, p[0-7]+, w[0-9]+, z[0-9]+\\.s} } } */"}, {"sha": "dcbacf90fef46f049b9fb9d9339c1a5ffe4e3968", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_2_run.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_2_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"clastb_2.c\"\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  unsigned int a[N] = {\n+    11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+    21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+    31, 32\n+  };\n+  __builtin_memset (a + 32, 43, (N - 32) * sizeof (int));\n+\n+  unsigned int ret = condition_reduction (a, 16);\n+\n+  if (ret != 10)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "35344f446c666f6e44b8ccd1524cac244dfa6f0a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_3.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_3.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define TYPE uint8_t\n+\n+#include \"clastb_2.c\"\n+\n+/* { dg-final { scan-assembler {\\tclastb\\tw[0-9]+, p[0-7]+, w[0-9]+, z[0-9]+\\.b} } } */"}, {"sha": "2ff1605c60538cd371f789874d1239d25db3ee86", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_3_run.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_3_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_3_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_3_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"clastb_3.c\"\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  unsigned char a[N] = {\n+    11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+    21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+    31, 32\n+  };\n+  __builtin_memset (a + 32, 43, N - 32);\n+\n+  unsigned char ret = condition_reduction (a, 16);\n+\n+  if (ret != 10)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "ce58abd6161c133082692f677e4fe8dafb6e64c0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_4.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_4.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define TYPE int16_t\n+\n+#include \"clastb_2.c\"\n+\n+/* { dg-final { scan-assembler {\\tclastb\\tw[0-9]+, p[0-7], w[0-9]+, z[0-9]+\\.h} } } */"}, {"sha": "d0c4af8c0da9065148df8fad10a4d5143b584b01", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_4_run.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_4_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_4_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_4_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-inline\" } */\n+\n+#include \"clastb_4.c\"\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  short a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+  __builtin_memset (a+32, 43, (N-32)*sizeof (short));\n+\n+  short ret = condition_reduction (a, 16);\n+\n+  if (ret != 10)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "2b9783d6627acb90824d4e2337c6c9ed6fd8425e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_5.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_5.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define TYPE uint64_t\n+\n+#include \"clastb_2.c\"\n+\n+/* { dg-final { scan-assembler {\\tclastb\\tx[0-9]+, p[0-7], x[0-9]+, z[0-9]+\\.d} } } */"}, {"sha": "3c9d0542eb4ae4d0abd0b414908b0e946a387ce9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_5_run.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_5_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_5_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_5_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"clastb_5.c\"\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  long a[N] = {\n+    11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+    21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+    31, 32\n+  };\n+  __builtin_memset (a + 32, 43, (N - 32) * sizeof (long));\n+\n+  long ret = condition_reduction (a, 16);\n+\n+  if (ret != 10)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "c47d303f7301f8a9af574e82e157129e080308cd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_6.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_6.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define N 32\n+\n+#ifndef TYPE\n+#define TYPE float\n+#endif\n+\n+/* Non-integer data types.  */\n+\n+TYPE __attribute__ ((noinline, noclone))\n+condition_reduction (TYPE *a, TYPE min_v)\n+{\n+  TYPE last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+/* { dg-final { scan-assembler {\\tclastb\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s} } } */"}, {"sha": "1c673c6e0c0550dd19d72e552d843d2f55d240cd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_6_run.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_6_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_6_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_6_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"clastb_6.c\"\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  float a[N] = {\n+    11.5, 12.2, 13.22, 14.1, 15.2, 16.3, 17, 18.7, 19, 20,\n+    1, 2, 3.3, 4.3333, 5.5, 6.23, 7, 8.63, 9, 10.6,\n+    21, 22.12, 23.55, 24.76, 25, 26, 27.34, 28.765, 29, 30,\n+    31.111, 32.322\n+  };\n+\n+  float ret = condition_reduction (a, 16.7);\n+\n+  if (ret != (float) 10.6)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "3345f874a39eb81358c9a1761ac4c333ecf3c192", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_7.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_7.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define TYPE double\n+#include \"clastb_6.c\"\n+\n+/* { dg-final { scan-assembler {\\tclastb\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d} } } */"}, {"sha": "12ced127fe6a4975b3f8cf97d24a043cb477e64a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/clastb_7_run.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_7_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_7_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fclastb_7_run.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"clastb_7.c\"\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  double a[N] = {\n+    11.5, 12.2, 13.22, 14.1, 15.2, 16.3, 17, 18.7, 19, 20,\n+    1, 2, 3.3, 4.3333, 5.5, 6.23, 7, 8.63, 9, 10.6,\n+    21, 22.12, 23.55, 24.76, 25, 26, 27.34, 28.765, 29, 30,\n+    31.111, 32.322\n+  };\n+\n+  double ret = condition_reduction (a, 16.7);\n+\n+  if (ret != 10.6)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "850260f0ee08b073082f16e23ff041d107ccf950", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -7234,6 +7234,12 @@ proc check_effective_target_vect_logical_reduc { } {\n     return [check_effective_target_aarch64_sve]\n }\n \n+# Return 1 if the target supports the fold_extract_last optab.\n+\n+proc check_effective_target_vect_fold_extract_last { } {\n+    return [check_effective_target_aarch64_sve]\n+}\n+\n # Return 1 if the target supports section-anchors\n \n proc check_effective_target_section_anchors { } {"}, {"sha": "b3779e752ad9ada89ba00a9999bb4c842e7463fa", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 86, "deletions": 43, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -4036,7 +4036,7 @@ static void\n vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t\t\t   int ncopies)\n {\n-  int prologue_cost = 0, epilogue_cost = 0;\n+  int prologue_cost = 0, epilogue_cost = 0, inside_cost;\n   enum tree_code code;\n   optab optab;\n   tree vectype;\n@@ -4055,13 +4055,11 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n     target_cost_data = BB_VINFO_TARGET_COST_DATA (STMT_VINFO_BB_VINFO (stmt_info));\n \n   /* Condition reductions generate two reductions in the loop.  */\n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+  vect_reduction_type reduction_type\n+    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n+  if (reduction_type == COND_REDUCTION)\n     ncopies *= 2;\n \n-  /* Cost of reduction op inside loop.  */\n-  unsigned inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n-\t\t\t\t\tstmt_info, 0, vect_body);\n-\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n   mode = TYPE_MODE (vectype);\n   orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n@@ -4071,14 +4069,30 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \n   code = gimple_assign_rhs_code (orig_stmt);\n \n-  /* Add in cost for initial definition.\n-     For cond reduction we have four vectors: initial index, step, initial\n-     result of the data reduction, initial value of the index reduction.  */\n-  int prologue_stmts = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t       == COND_REDUCTION ? 4 : 1;\n-  prologue_cost += add_stmt_cost (target_cost_data, prologue_stmts,\n-\t\t\t\t  scalar_to_vec, stmt_info, 0,\n-\t\t\t\t  vect_prologue);\n+  if (reduction_type == EXTRACT_LAST_REDUCTION)\n+    {\n+      /* No extra instructions needed in the prologue.  */\n+      prologue_cost = 0;\n+\n+      /* Count NCOPIES FOLD_EXTRACT_LAST operations.  */\n+      inside_cost = add_stmt_cost (target_cost_data, ncopies, vec_to_scalar,\n+\t\t\t\t   stmt_info, 0, vect_body);\n+    }\n+  else\n+    {\n+      /* Add in cost for initial definition.\n+\t For cond reduction we have four vectors: initial index, step,\n+\t initial result of the data reduction, initial value of the index\n+\t reduction.  */\n+      int prologue_stmts = reduction_type == COND_REDUCTION ? 4 : 1;\n+      prologue_cost += add_stmt_cost (target_cost_data, prologue_stmts,\n+\t\t\t\t      scalar_to_vec, stmt_info, 0,\n+\t\t\t\t      vect_prologue);\n+\n+      /* Cost of reduction op inside loop.  */\n+      inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n+\t\t\t\t   stmt_info, 0, vect_body);\n+    }\n \n   /* Determine cost of epilogue code.\n \n@@ -4089,7 +4103,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n     {\n       if (reduc_fn != IFN_LAST)\n \t{\n-\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+\t  if (reduction_type == COND_REDUCTION)\n \t    {\n \t      /* An EQ stmt and an COND_EXPR stmt.  */\n \t      epilogue_cost += add_stmt_cost (target_cost_data, 2,\n@@ -4114,7 +4128,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t\t\t\t\t      vect_epilogue);\n \t    }\n \t}\n-      else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+      else if (reduction_type == COND_REDUCTION)\n \t{\n \t  unsigned estimated_nunits = vect_nunits_for_cost (vectype);\n \t  /* Extraction of scalar elements.  */\n@@ -4128,6 +4142,9 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t\t\t\t\t  scalar_stmt, stmt_info, 0,\n \t\t\t\t\t  vect_epilogue);\n \t}\n+      else if (reduction_type == EXTRACT_LAST_REDUCTION)\n+\t/* No extra instructions need in the epilogue.  */\n+\t;\n       else\n \t{\n \t  int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n@@ -4292,6 +4309,9 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n       return vect_create_destination_var (init_val, vectype);\n     }\n \n+  vect_reduction_type reduction_type\n+    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_vinfo);\n+\n   /* In case of a nested reduction do not use an adjustment def as\n      that case is not supported by the epilogue generation correctly\n      if ncopies is not one.  */\n@@ -4364,7 +4384,8 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \tif (adjustment_def)\n           {\n \t    *adjustment_def = NULL_TREE;\n-\t    if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_vinfo) != COND_REDUCTION)\n+\t    if (reduction_type != COND_REDUCTION\n+\t\t&& reduction_type != EXTRACT_LAST_REDUCTION)\n \t      {\n \t\tinit_def = vect_get_vec_def_for_operand (init_val, stmt);\n \t\tbreak;\n@@ -6179,6 +6200,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (reduc_stmt)))\n \treduc_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (reduc_stmt));\n \n+      if (STMT_VINFO_VEC_REDUCTION_TYPE (vinfo_for_stmt (reduc_stmt))\n+\t  == EXTRACT_LAST_REDUCTION)\n+\t/* Leave the scalar phi in place.  */\n+\treturn true;\n+\n       gcc_assert (is_gimple_assign (reduc_stmt));\n       for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n \t{\n@@ -6435,7 +6461,28 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* If we have a condition reduction, see if we can simplify it further.  */\n   if (v_reduc_type == COND_REDUCTION)\n     {\n-      if (cond_reduc_dt == vect_induction_def)\n+      /* Loop peeling modifies initial value of reduction PHI, which\n+\t makes the reduction stmt to be transformed different to the\n+\t original stmt analyzed.  We need to record reduction code for\n+\t CONST_COND_REDUCTION type reduction at analyzing stage, thus\n+\t it can be used directly at transform stage.  */\n+      if (STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info) == MAX_EXPR\n+\t  || STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info) == MIN_EXPR)\n+\t{\n+\t  /* Also set the reduction type to CONST_COND_REDUCTION.  */\n+\t  gcc_assert (cond_reduc_dt == vect_constant_def);\n+\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = CONST_COND_REDUCTION;\n+\t}\n+      else if (direct_internal_fn_supported_p (IFN_FOLD_EXTRACT_LAST,\n+\t\t\t\t\t       vectype_in, OPTIMIZE_FOR_SPEED))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"optimizing condition reduction with\"\n+\t\t\t     \" FOLD_EXTRACT_LAST.\\n\");\n+\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = EXTRACT_LAST_REDUCTION;\n+\t}\n+      else if (cond_reduc_dt == vect_induction_def)\n \t{\n \t  stmt_vec_info cond_stmt_vinfo = vinfo_for_stmt (cond_reduc_def_stmt);\n \t  tree base\n@@ -6478,19 +6525,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t= INTEGER_INDUC_COND_REDUCTION;\n \t    }\n \t}\n-\n-      /* Loop peeling modifies initial value of reduction PHI, which\n-\t makes the reduction stmt to be transformed different to the\n-\t original stmt analyzed.  We need to record reduction code for\n-\t CONST_COND_REDUCTION type reduction at analyzing stage, thus\n-\t it can be used directly at transform stage.  */\n-      if (STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info) == MAX_EXPR\n-\t  || STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info) == MIN_EXPR)\n-\t{\n-\t  /* Also set the reduction type to CONST_COND_REDUCTION.  */\n-\t  gcc_assert (cond_reduc_dt == vect_constant_def);\n-\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = CONST_COND_REDUCTION;\n-\t}\n       else if (cond_reduc_dt == vect_constant_def)\n \t{\n \t  enum vect_def_type cond_initial_dt;\n@@ -6644,12 +6678,12 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n           (and also the same tree-code) when generating the epilog code and\n           when generating the code inside the loop.  */\n \n-  if (orig_stmt)\n+  vect_reduction_type reduction_type\n+    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n+  if (orig_stmt && reduction_type == TREE_CODE_REDUCTION)\n     {\n       /* This is a reduction pattern: get the vectype from the type of the\n          reduction variable, and get the tree-code from orig_stmt.  */\n-      gcc_assert (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t  == TREE_CODE_REDUCTION);\n       orig_code = gimple_assign_rhs_code (orig_stmt);\n       gcc_assert (vectype_out);\n       vec_mode = TYPE_MODE (vectype_out);\n@@ -6665,13 +6699,12 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       /* For simple condition reductions, replace with the actual expression\n \t we want to base our reduction around.  */\n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == CONST_COND_REDUCTION)\n+      if (reduction_type == CONST_COND_REDUCTION)\n \t{\n \t  orig_code = STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info);\n \t  gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n \t}\n-      else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t       == INTEGER_INDUC_COND_REDUCTION)\n+      else if (reduction_type == INTEGER_INDUC_COND_REDUCTION)\n \torig_code = cond_reduc_op_code;\n     }\n \n@@ -6693,7 +6726,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   reduc_fn = IFN_LAST;\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) != COND_REDUCTION)\n+  if (reduction_type == TREE_CODE_REDUCTION\n+      || reduction_type == INTEGER_INDUC_COND_REDUCTION\n+      || reduction_type == CONST_COND_REDUCTION)\n     {\n       if (reduction_fn_for_scalar_code (orig_code, &reduc_fn))\n \t{\n@@ -6720,7 +6755,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t}\n     }\n-  else\n+  else if (reduction_type == COND_REDUCTION)\n     {\n       int scalar_precision\n \t= GET_MODE_PRECISION (SCALAR_TYPE_MODE (scalar_type));\n@@ -6733,7 +6768,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \treduc_fn = IFN_REDUC_MAX;\n     }\n \n-  if (reduc_fn == IFN_LAST && !nunits_out.is_constant ())\n+  if (reduction_type != EXTRACT_LAST_REDUCTION\n+      && reduc_fn == IFN_LAST\n+      && !nunits_out.is_constant ())\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6742,8 +6779,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  if ((double_reduc\n-       || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) != TREE_CODE_REDUCTION)\n+  if ((double_reduc || reduction_type != TREE_CODE_REDUCTION)\n       && ncopies > 1)\n     {\n       if (dump_enabled_p ())\n@@ -6833,7 +6869,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         }\n     }\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+  if (reduction_type == COND_REDUCTION)\n     {\n       widest_int ni;\n \n@@ -6970,6 +7006,13 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   bool masked_loop_p = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n \n+  if (reduction_type == EXTRACT_LAST_REDUCTION)\n+    {\n+      gcc_assert (!slp_node);\n+      return vectorizable_condition (stmt, gsi, vec_stmt,\n+\t\t\t\t     NULL, reduc_index, NULL);\n+    }\n+\n   /* Create the destination vector  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n "}, {"sha": "5bb61319b669ee27133a6acdeeba04869da2491c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 84, "deletions": 28, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -1603,6 +1603,47 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n     }\n }\n \n+/* Helper function called by vect_finish_replace_stmt and\n+   vect_finish_stmt_generation.  Set the location of the new\n+   statement and create a stmt_vec_info for it.  */\n+\n+static void\n+vect_finish_stmt_generation_1 (gimple *stmt, gimple *vec_stmt)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n+\n+  set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, vinfo));\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n+    }\n+\n+  gimple_set_location (vec_stmt, gimple_location (stmt));\n+\n+  /* While EH edges will generally prevent vectorization, stmt might\n+     e.g. be in a must-not-throw region.  Ensure newly created stmts\n+     that could throw are part of the same region.  */\n+  int lp_nr = lookup_stmt_eh_lp (stmt);\n+  if (lp_nr != 0 && stmt_could_throw_p (vec_stmt))\n+    add_stmt_to_eh_lp (vec_stmt, lp_nr);\n+}\n+\n+/* Replace the scalar statement STMT with a new vector statement VEC_STMT,\n+   which sets the same scalar result as STMT did.  */\n+\n+void\n+vect_finish_replace_stmt (gimple *stmt, gimple *vec_stmt)\n+{\n+  gcc_assert (gimple_get_lhs (stmt) == gimple_get_lhs (vec_stmt));\n+\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gsi_replace (&gsi, vec_stmt, false);\n+\n+  vect_finish_stmt_generation_1 (stmt, vec_stmt);\n+}\n \n /* Function vect_finish_stmt_generation.\n \n@@ -1612,9 +1653,6 @@ void\n vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  vec_info *vinfo = stmt_info->vinfo;\n-\n   gcc_assert (gimple_code (stmt) != GIMPLE_LABEL);\n \n   if (!gsi_end_p (*gsi)\n@@ -1644,23 +1682,7 @@ vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t}\n     }\n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n-\n-  set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, vinfo));\n-\n-  if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n-    }\n-\n-  gimple_set_location (vec_stmt, gimple_location (stmt));\n-\n-  /* While EH edges will generally prevent vectorization, stmt might\n-     e.g. be in a must-not-throw region.  Ensure newly created stmts\n-     that could throw are part of the same region.  */\n-  int lp_nr = lookup_stmt_eh_lp (stmt);\n-  if (lp_nr != 0 && stmt_could_throw_p (vec_stmt))\n-    add_stmt_to_eh_lp (vec_stmt, lp_nr);\n+  vect_finish_stmt_generation_1 (stmt, vec_stmt);\n }\n \n /* We want to vectorize a call to combined function CFN with function\n@@ -8107,7 +8129,9 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (reduc_index && STMT_SLP_TYPE (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == TREE_CODE_REDUCTION)\n+  vect_reduction_type reduction_type\n+    = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n+  if (reduction_type == TREE_CODE_REDUCTION)\n     {\n       if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n \treturn false;\n@@ -8266,12 +8290,13 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   /* Handle def.  */\n   scalar_dest = gimple_assign_lhs (stmt);\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  if (reduction_type != EXTRACT_LAST_REDUCTION)\n+    vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Handle cond expr.  */\n   for (j = 0; j < ncopies; j++)\n     {\n-      gassign *new_stmt = NULL;\n+      gimple *new_stmt = NULL;\n       if (j == 0)\n \t{\n           if (slp_node)\n@@ -8405,11 +8430,42 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    }\n \t\t}\n \t    }\n-          new_temp = make_ssa_name (vec_dest);\n-          new_stmt = gimple_build_assign (new_temp, VEC_COND_EXPR,\n-\t\t\t\t\t  vec_compare, vec_then_clause,\n-\t\t\t\t\t  vec_else_clause);\n-          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  if (reduction_type == EXTRACT_LAST_REDUCTION)\n+\t    {\n+\t      if (!is_gimple_val (vec_compare))\n+\t\t{\n+\t\t  tree vec_compare_name = make_ssa_name (vec_cmp_type);\n+\t\t  new_stmt = gimple_build_assign (vec_compare_name,\n+\t\t\t\t\t\t  vec_compare);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  vec_compare = vec_compare_name;\n+\t\t}\n+\t      gcc_assert (reduc_index == 2);\n+\t      new_stmt = gimple_build_call_internal\n+\t\t(IFN_FOLD_EXTRACT_LAST, 3, else_clause, vec_compare,\n+\t\t vec_then_clause);\n+\t      gimple_call_set_lhs (new_stmt, scalar_dest);\n+\t      SSA_NAME_DEF_STMT (scalar_dest) = new_stmt;\n+\t      if (stmt == gsi_stmt (*gsi))\n+\t\tvect_finish_replace_stmt (stmt, new_stmt);\n+\t      else\n+\t\t{\n+\t\t  /* In this case we're moving the definition to later in the\n+\t\t     block.  That doesn't matter because the only uses of the\n+\t\t     lhs are in phi statements.  */\n+\t\t  gimple_stmt_iterator old_gsi = gsi_for_stmt (stmt);\n+\t\t  gsi_remove (&old_gsi, true);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      new_temp = make_ssa_name (vec_dest);\n+\t      new_stmt = gimple_build_assign (new_temp, VEC_COND_EXPR,\n+\t\t\t\t\t      vec_compare, vec_then_clause,\n+\t\t\t\t\t      vec_else_clause);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t    }\n           if (slp_node)\n             SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n         }"}, {"sha": "22dfbed332ca51691db4b088dd0c558709486564", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6c2b68d6961dfe98bece34e4418d7287ce7089/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bb6c2b68d6961dfe98bece34e4418d7287ce7089", "patch": "@@ -67,7 +67,14 @@ enum vect_reduction_type {\n   TREE_CODE_REDUCTION,\n   COND_REDUCTION,\n   INTEGER_INDUC_COND_REDUCTION,\n-  CONST_COND_REDUCTION\n+  CONST_COND_REDUCTION,\n+\n+  /* Retain a scalar phi and use a FOLD_EXTRACT_LAST within the loop\n+     to implement:\n+\n+       for (int i = 0; i < VF; ++i)\n+         res = cond[i] ? val[i] : res;  */\n+  EXTRACT_LAST_REDUCTION\n };\n \n #define VECTORIZABLE_CYCLE_DEF(D) (((D) == vect_reduction_def)           \\"}]}