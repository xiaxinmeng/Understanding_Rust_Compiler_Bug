{"sha": "3ba781d3b5c8efadb60866c9743b657e8f0eb222", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhNzgxZDNiNWM4ZWZhZGI2MDg2NmM5NzQzYjY1N2U4ZjBlYjIyMg==", "commit": {"author": {"name": "Senthil Kumar Selvaraj", "email": "saaadhu@gcc.gnu.org", "date": "2021-04-28T17:29:12Z"}, "committer": {"name": "Senthil Kumar Selvaraj", "email": "saaadhu@gcc.gnu.org", "date": "2021-04-28T17:42:01Z"}, "message": "AVR cc0 conversion\n\nSee https://gcc.gnu.org/pipermail/gcc-patches/2021-January/563638.html\nfor background.\n\nThis patch converts the avr backend to MODE_CC. It addresses some of\nthe comments made in the previous submission over here\n(https://gcc.gnu.org/pipermail/gcc-patches/2020-December/561757.html).\n\nSpecifically, this patch has\n\n1. Automatic clobber of REG_CC in inline asm statements, via\nTARGET_MD_ASM_ADJUST hook.\n\n2. Direct clobber of REG_CC in insns emitted after reload (pro and\nepilogue).\n\n3. Regression testing done on atmega8, atmega128, attiny40 and\natxmega128a3 devices (more details below).\n\n4. Verification and fixes for casesi and avr_compare_pattern related\ncode that inspects insns, by looking at avr-casesi and mach RTL dumps.\n\n5. Use length of parallel instead of passing in operand counts when\ngenerating code for shift patterns.\n\n6. Fixes for indentation glitches.\n\n7. Removal of CC_xxx stuff in avr-protos.h. In the places where the\nmacros were still used (cond_string), I've replaced them with a bool\nhardcoded to false. I expect this will go away/get fixed when I\neventually add specific CC modes.\n\nThings still to do:\n\n1. Adjustment of peepholes/define_splits to match against patterns\n   with REG_CC clobber.\n2. Model effect of non-compare insns on REG_CC using additional CC\n   modes. I'm hoping to use of a modified version of the cc attribute\n   and define_subst (again inspired by the cris port), to do this.\n3. RTX cost adjustment.\n\ngcc/\n\t* config/avr/avr-dimode.md: Turn existing patterns into\n\tdefine_insn_and_split style patterns where the splitter\n\tadds a clobber of the condition code register.  Drop \"cc\"\n\tattribute.  Add new patterns to match output of\n\tthe splitters.\n\t* config/avr/avr-fixed.md: Likewise.\n\t* config/avr/avr.c (cc_reg_rtx): New.\n\t(avr_parallel_insn_from_insns): Adjust insn count\n\tfor removal of set of cc0.\n\t(avr_is_casesi_sequence): Likewise.\n\t(avr_casei_sequence_check_operands): Likewise.\n\t(avr_optimize_casesi): Likewise. Also insert\n\tnew insns after jump_insn.\n\t(avr_pass_casesi::avr_rest_of_handle_casesi): Adjust\n\tfor removal of set of cc0.\n\t(avr_init_expanders): Initialize cc_reg_rtx.\n\t(avr_regno_reg_class): Handle REG_CC.\n\t(cond_string): Remove usage of CC_OVERFLOW_UNUSABLE.\n\t(avr_notice_update_cc): Remove function.\n\t(ret_cond_branch): Remove usage of CC_OVERFLOW_UNUSABLE.\n\t(compare_condition): Adjust for PARALLEL with\n\tREG_CC clobber.\n\t(out_shift_with_cnt): Likewise.\n\t(ashlhi3_out): Likewise.\n\t(ashrhi3_out): Likewise.\n\t(lshrhi3_out): Likewise.\n\t(avr_class_max_nregs): Return single reg for REG_CC.\n\t(avr_compare_pattern): Check for REG_CC instead\n\tof cc0_rtx.\n\t(avr_reorg_remove_redundant_compare): Likewise.\n\t(avr_reorg):Adjust for PARALLEL with REG_CC clobber.\n\t(avr_hard_regno_nregs): Return single reg for REG_CC.\n\t(avr_hard_regno_mode_ok): Allow only CCmode for REG_CC.\n\t(avr_md_asm_adjust): Clobber REG_CC.\n\t(TARGET_HARD_REGNO_NREGS): Define.\n\t(TARGET_CLASS_MAX_NREGS): Define.\n\t(TARGET_MD_ASM_ADJUST): Define.\n\t* config/avr/avr.h (FIRST_PSEUDO_REGISTER): Adjust\n\tfor REG_CC.\n\t(enum reg_class): Add CC_REG class.\n\t(NOTICE_UPDATE_CC): Remove.\n\t(CC_OVERFLOW_UNUSABLE): Remove.\n\t(CC_NO_CARRY): Remove.\n\t* config/avr/avr.md: Turn existing patterns into\n\tdefine_insn_and_split style patterns where the splitter\n\tadds a clobber of the condition code register.  Drop \"cc\"\n\tattribute.  Add new patterns to match output of\n\tthe splitters.\n\t(sez): Remove unused pattern.", "tree": {"sha": "cae42c5f7f165eedebca004b3b75dacabcdb847e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cae42c5f7f165eedebca004b3b75dacabcdb847e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ba781d3b5c8efadb60866c9743b657e8f0eb222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba781d3b5c8efadb60866c9743b657e8f0eb222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba781d3b5c8efadb60866c9743b657e8f0eb222", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba781d3b5c8efadb60866c9743b657e8f0eb222/comments", "author": {"login": "saaadhu", "id": 532256, "node_id": "MDQ6VXNlcjUzMjI1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/532256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saaadhu", "html_url": "https://github.com/saaadhu", "followers_url": "https://api.github.com/users/saaadhu/followers", "following_url": "https://api.github.com/users/saaadhu/following{/other_user}", "gists_url": "https://api.github.com/users/saaadhu/gists{/gist_id}", "starred_url": "https://api.github.com/users/saaadhu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saaadhu/subscriptions", "organizations_url": "https://api.github.com/users/saaadhu/orgs", "repos_url": "https://api.github.com/users/saaadhu/repos", "events_url": "https://api.github.com/users/saaadhu/events{/privacy}", "received_events_url": "https://api.github.com/users/saaadhu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saaadhu", "id": 532256, "node_id": "MDQ6VXNlcjUzMjI1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/532256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saaadhu", "html_url": "https://github.com/saaadhu", "followers_url": "https://api.github.com/users/saaadhu/followers", "following_url": "https://api.github.com/users/saaadhu/following{/other_user}", "gists_url": "https://api.github.com/users/saaadhu/gists{/gist_id}", "starred_url": "https://api.github.com/users/saaadhu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saaadhu/subscriptions", "organizations_url": "https://api.github.com/users/saaadhu/orgs", "repos_url": "https://api.github.com/users/saaadhu/repos", "events_url": "https://api.github.com/users/saaadhu/events{/privacy}", "received_events_url": "https://api.github.com/users/saaadhu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8767ee9f9355a63bfeb8318df32bc39c5b0f3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8767ee9f9355a63bfeb8318df32bc39c5b0f3ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8767ee9f9355a63bfeb8318df32bc39c5b0f3ad"}], "stats": {"total": 5312, "additions": 4120, "deletions": 1192}, "files": [{"sha": "1eb95990c593607c1fb5801f3a034de4085670d9", "filename": "gcc/config/avr/avr-dimode.md", "status": "modified", "additions": 270, "deletions": 66, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr-dimode.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr-dimode.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-dimode.md?ref=3ba781d3b5c8efadb60866c9743b657e8f0eb222", "patch": "@@ -95,39 +95,77 @@\n ;; \"adddq3_insn\" \"addudq3_insn\"\n ;; \"addda3_insn\" \"adduda3_insn\"\n ;; \"addta3_insn\" \"adduta3_insn\"\n-(define_insn \"add<mode>3_insn\"\n+(define_insn_and_split \"add<mode>3_insn\"\n   [(set (reg:ALL8 ACC_A)\n         (plus:ALL8 (reg:ALL8 ACC_A)\n                    (reg:ALL8 ACC_B)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8 ACC_A)\n+                   (plus:ALL8 (reg:ALL8 ACC_A)\n+                              (reg:ALL8 ACC_B)))\n+   (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*add<mode>3_insn\"\n+  [(set (reg:ALL8 ACC_A)\n+        (plus:ALL8 (reg:ALL8 ACC_A)\n+                   (reg:ALL8 ACC_B)))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __adddi3\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n-(define_insn \"adddi3_const8_insn\"\n+(define_insn_and_split \"adddi3_const8_insn\"\n   [(set (reg:DI ACC_A)\n         (plus:DI (reg:DI ACC_A)\n                  (sign_extend:DI (reg:QI REG_X))))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:DI ACC_A)\n+                   (plus:DI (reg:DI ACC_A)\n+                            (sign_extend:DI (reg:QI REG_X))))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*adddi3_const8_insn\"\n+  [(set (reg:DI ACC_A)\n+        (plus:DI (reg:DI ACC_A)\n+                 (sign_extend:DI (reg:QI REG_X))))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __adddi3_s8\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n ;; \"adddi3_const_insn\"\n ;; \"adddq3_const_insn\" \"addudq3_const_insn\"\n ;; \"addda3_const_insn\" \"adduda3_const_insn\"\n ;; \"addta3_const_insn\" \"adduta3_const_insn\"\n-(define_insn \"add<mode>3_const_insn\"\n+(define_insn_and_split \"add<mode>3_const_insn\"\n   [(set (reg:ALL8 ACC_A)\n         (plus:ALL8 (reg:ALL8 ACC_A)\n                    (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))]\n   \"avr_have_dimode\n    && !s8_operand (operands[0], VOIDmode)\"\n+   \"#\"\n+   \"&& reload_completed\"\n+   [(parallel [(set (reg:ALL8 ACC_A)\n+                    (plus:ALL8 (reg:ALL8 ACC_A)\n+                               (match_dup 0)))\n+               (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*add<mode>3_const_insn\"\n+  [(set (reg:ALL8 ACC_A)\n+        (plus:ALL8 (reg:ALL8 ACC_A)\n+                   (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode\n+   && !s8_operand (operands[0], VOIDmode)\n+   && reload_completed\"\n   {\n     return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"plus\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"plus\")])\n \n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n@@ -167,29 +205,53 @@\n ;; \"subdq3_insn\" \"subudq3_insn\"\n ;; \"subda3_insn\" \"subuda3_insn\"\n ;; \"subta3_insn\" \"subuta3_insn\"\n-(define_insn \"sub<mode>3_insn\"\n+(define_insn_and_split \"sub<mode>3_insn\"\n   [(set (reg:ALL8 ACC_A)\n         (minus:ALL8 (reg:ALL8 ACC_A)\n                     (reg:ALL8 ACC_B)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8 ACC_A)\n+                   (minus:ALL8 (reg:ALL8 ACC_A)\n+                               (reg:ALL8 ACC_B)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*sub<mode>3_insn\"\n+  [(set (reg:ALL8 ACC_A)\n+        (minus:ALL8 (reg:ALL8 ACC_A)\n+                    (reg:ALL8 ACC_B)))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __subdi3\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"set_czn\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n ;; \"subdi3_const_insn\"\n ;; \"subdq3_const_insn\" \"subudq3_const_insn\"\n ;; \"subda3_const_insn\" \"subuda3_const_insn\"\n ;; \"subta3_const_insn\" \"subuta3_const_insn\"\n-(define_insn \"sub<mode>3_const_insn\"\n+(define_insn_and_split \"sub<mode>3_const_insn\"\n   [(set (reg:ALL8 ACC_A)\n         (minus:ALL8 (reg:ALL8 ACC_A)\n                     (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8 ACC_A)\n+                   (minus:ALL8 (reg:ALL8 ACC_A)\n+                               (match_dup 0)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*sub<mode>3_const_insn\"\n+  [(set (reg:ALL8 ACC_A)\n+        (minus:ALL8 (reg:ALL8 ACC_A)\n+                    (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   {\n     return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"plus\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"plus\")])\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Signed Saturating Addition and Subtraction\n@@ -220,25 +282,49 @@\n     DONE;\n   })\n \n-(define_insn \"<code_stdname><mode>3_insn\"\n+(define_insn_and_split \"<code_stdname><mode>3_insn\"\n   [(set (reg:ALL8S ACC_A)\n         (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n                          (reg:ALL8S ACC_B)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8S ACC_A)\n+                   (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n+                                    (reg:ALL8S ACC_B)))\n+             (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3_insn\"\n+  [(set (reg:ALL8S ACC_A)\n+        (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n+                         (reg:ALL8S ACC_B)))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __<code_stdname><mode>3\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n-(define_insn \"<code_stdname><mode>3_const_insn\"\n+(define_insn_and_split \"<code_stdname><mode>3_const_insn\"\n   [(set (reg:ALL8S ACC_A)\n         (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n                          (match_operand:ALL8S 0 \"const_operand\" \"n Ynn\")))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8S ACC_A)\n+                   (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n+                                    (match_dup 0)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3_const_insn\"\n+  [(set (reg:ALL8S ACC_A)\n+        (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n+                         (match_operand:ALL8S 0 \"const_operand\" \"n Ynn\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   {\n     return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"plus\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"plus\")])\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Unsigned Saturating Addition and Subtraction\n@@ -269,25 +355,49 @@\n     DONE;\n   })\n \n-(define_insn \"<code_stdname><mode>3_insn\"\n+(define_insn_and_split \"<code_stdname><mode>3_insn\"\n   [(set (reg:ALL8U ACC_A)\n         (us_addsub:ALL8U (reg:ALL8U ACC_A)\n                          (reg:ALL8U ACC_B)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8U ACC_A)\n+                   (us_addsub:ALL8U (reg:ALL8U ACC_A)\n+                                    (reg:ALL8U ACC_B)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3_insn\"\n+  [(set (reg:ALL8U ACC_A)\n+        (us_addsub:ALL8U (reg:ALL8U ACC_A)\n+                         (reg:ALL8U ACC_B)))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __<code_stdname><mode>3\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n-(define_insn \"<code_stdname><mode>3_const_insn\"\n+(define_insn_and_split \"<code_stdname><mode>3_const_insn\"\n   [(set (reg:ALL8U ACC_A)\n         (us_addsub:ALL8U (reg:ALL8U ACC_A)\n                          (match_operand:ALL8U 0 \"const_operand\" \"n Ynn\")))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8U ACC_A)\n+                   (us_addsub:ALL8U (reg:ALL8U ACC_A)\n+                                    (match_operand:ALL8U 0 \"const_operand\" \"n Ynn\")))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3_const_insn\"\n+  [(set (reg:ALL8U ACC_A)\n+        (us_addsub:ALL8U (reg:ALL8U ACC_A)\n+                         (match_operand:ALL8U 0 \"const_operand\" \"n Ynn\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   {\n     return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"plus\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"plus\")])\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Negation\n@@ -306,13 +416,23 @@\n     DONE;\n   })\n \n-(define_insn \"negdi2_insn\"\n+(define_insn_and_split \"negdi2_insn\"\n   [(set (reg:DI ACC_A)\n         (neg:DI (reg:DI ACC_A)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:DI ACC_A)\n+                   (neg:DI (reg:DI ACC_A)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*negdi2_insn\"\n+  [(set (reg:DI ACC_A)\n+        (neg:DI (reg:DI ACC_A)))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __negdi2\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n@@ -322,7 +442,7 @@\n (define_expand \"conditional_jump\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+         (match_operator 0 \"ordered_comparison_operator\" [(reg:CC REG_CC)\n                                                           (const_int 0)])\n          (label_ref (match_operand 1 \"\" \"\"))\n          (pc)))]\n@@ -333,13 +453,14 @@\n ;; \"cbranchda4\" \"cbranchuda4\"\n ;; \"cbranchta4\" \"cbranchuta4\"\n (define_expand \"cbranch<mode>4\"\n-  [(parallel [(match_operand:ALL8 1 \"register_operand\" \"\")\n-              (match_operand:ALL8 2 \"nonmemory_operand\" \"\")\n-              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n-                                                               (const_int 0)])\n-              (label_ref (match_operand 3 \"\" \"\"))])]\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                        [(match_operand:ALL8 1 \"register_operand\"  \"\")\n+                         (match_operand:ALL8 2 \"nonmemory_operand\" \"\")])\n+         (label_ref (match_operand 3 \"\" \"\"))\n+         (pc)))]\n   \"avr_have_dimode\"\n-  {\n+   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n     avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n@@ -348,19 +469,36 @@\n     if (s8_operand (operands[2], VOIDmode))\n       {\n         emit_move_insn (gen_rtx_REG (QImode, REG_X), operands[2]);\n-        emit_insn (gen_compare_const8_di2 ());\n+        emit_jump_insn (gen_cbranch_const8_di2_split (operands[0], operands[3]));\n       }\n     else if (const_operand (operands[2], GET_MODE (operands[2])))\n       {\n-        emit_insn (gen_compare_const_<mode>2 (operands[2]));\n+        emit_jump_insn (gen_cbranch_const_<mode>2_split (operands[0],\n+                                                         operands[2],\n+                                                         operands[3]));\n       }\n     else\n       {\n         emit_move_insn (gen_rtx_REG (<MODE>mode, ACC_B), operands[2]);\n-        emit_insn (gen_compare_<mode>2 ());\n+        emit_jump_insn (gen_cbranch_<mode>2_split (operands[0], operands[3]));\n       }\n+    DONE;\n+   })\n \n-    emit_jump_insn (gen_conditional_jump (operands[0], operands[3]));\n+(define_insn_and_split \"cbranch_<mode>2_split\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                        [(reg:ALL8 ACC_A)\n+                         (reg:ALL8 ACC_B)])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n+  \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    emit_insn (gen_compare_<mode>2 ());\n+    emit_jump_insn (gen_conditional_jump (operands[0], operands[1]));\n     DONE;\n   })\n \n@@ -369,39 +507,74 @@\n ;; \"compare_da2\" \"compare_uda2\"\n ;; \"compare_ta2\" \"compare_uta2\"\n (define_insn \"compare_<mode>2\"\n-  [(set (cc0)\n-        (compare (reg:ALL8 ACC_A)\n-                 (reg:ALL8 ACC_B)))]\n-  \"avr_have_dimode\"\n+  [(set (reg:CC REG_CC)\n+        (compare:CC (reg:ALL8 ACC_A)\n+                    (reg:ALL8 ACC_B)))]\n+  \"reload_completed && avr_have_dimode\"\n   \"%~call __cmpdi2\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"compare\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n-(define_insn \"compare_const8_di2\"\n-  [(set (cc0)\n-        (compare (reg:DI ACC_A)\n-                 (sign_extend:DI (reg:QI REG_X))))]\n+(define_insn_and_split \"cbranch_const8_di2_split\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                        [(reg:DI ACC_A)\n+                         (sign_extend:DI (reg:QI REG_X))])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    emit_insn (gen_compare_const8_di2 ());\n+    emit_jump_insn (gen_conditional_jump (operands[0], operands[1]));\n+    DONE;\n+  })\n+\n+(define_insn \"compare_const8_di2\"\n+  [(set (reg:CC REG_CC)\n+        (compare:CC (reg:DI ACC_A)\n+                    (sign_extend:DI (reg:QI REG_X))))]\n+  \"reload_completed && avr_have_dimode\"\n   \"%~call __cmpdi2_s8\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"compare\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n+\n+(define_insn_and_split \"cbranch_const_<mode>2_split\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                        [(reg:ALL8 ACC_A)\n+                         (match_operand:ALL8 1 \"const_operand\" \"n Ynn\")])\n+         (label_ref (match_operand 2 \"\" \"\"))\n+         (pc)))\n+   (clobber (match_scratch:QI 3 \"=&d\"))]\n+  \"avr_have_dimode\n+   && !s8_operand (operands[1], VOIDmode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    emit_insn (gen_compare_const_<mode>2 (operands[1], operands[3]));\n+    emit_jump_insn (gen_conditional_jump (operands[0], operands[2]));\n+    DONE;\n+  })\n+\n \n ;; \"compare_const_di2\"\n ;; \"compare_const_dq2\" \"compare_const_udq2\"\n ;; \"compare_const_da2\" \"compare_const_uda2\"\n ;; \"compare_const_ta2\" \"compare_const_uta2\"\n (define_insn \"compare_const_<mode>2\"\n-  [(set (cc0)\n-        (compare (reg:ALL8 ACC_A)\n-                 (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))\n-   (clobber (match_scratch:QI 1 \"=&d\"))]\n-  \"avr_have_dimode\n+  [(set (reg:CC REG_CC)\n+        (compare:CC (reg:ALL8 ACC_A)\n+                    (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))\n+   (clobber (match_operand:QI 1 \"register_operand\" \"=&d\"))]\n+  \"reload_completed\n+   && avr_have_dimode\n    && !s8_operand (operands[0], VOIDmode)\"\n   {\n     return avr_out_compare64 (insn, operands, NULL);\n   }\n-  [(set_attr \"adjust_len\" \"compare64\")\n-   (set_attr \"cc\" \"compare\")])\n+  [(set_attr \"adjust_len\" \"compare64\")])\n \n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n@@ -444,14 +617,26 @@\n ;; \"ashludq3_insn\"  \"ashrudq3_insn\"  \"lshrudq3_insn\"  \"rotludq3_insn\"\n ;; \"ashluda3_insn\"  \"ashruda3_insn\"  \"lshruda3_insn\"  \"rotluda3_insn\"\n ;; \"ashluta3_insn\"  \"ashruta3_insn\"  \"lshruta3_insn\"  \"rotluta3_insn\"\n-(define_insn \"<code_stdname><mode>3_insn\"\n+(define_insn_and_split \"<code_stdname><mode>3_insn\"\n   [(set (reg:ALL8 ACC_A)\n         (di_shifts:ALL8 (reg:ALL8 ACC_A)\n                         (reg:QI 16)))]\n   \"avr_have_dimode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL8 ACC_A)\n+                   (di_shifts:ALL8 (reg:ALL8 ACC_A)\n+                                   (reg:QI 16)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3_insn\"\n+  [(set (reg:ALL8 ACC_A)\n+        (di_shifts:ALL8 (reg:ALL8 ACC_A)\n+                        (reg:QI 16)))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode && reload_completed\"\n   \"%~call __<code_stdname>di3\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])\n \n ;; \"umulsidi3\"\n ;; \"mulsidi3\"\n@@ -475,14 +660,33 @@\n \n ;; \"umulsidi3_insn\"\n ;; \"mulsidi3_insn\"\n-(define_insn \"<extend_u>mulsidi3_insn\"\n+\n+(define_insn_and_split \"<extend_u>mulsidi3_insn\"\n   [(set (reg:DI ACC_A)\n         (mult:DI (any_extend:DI (reg:SI 18))\n                  (any_extend:DI (reg:SI 22))))\n    (clobber (reg:HI REG_X))\n    (clobber (reg:HI REG_Z))]\n   \"avr_have_dimode\n    && AVR_HAVE_MUL\"\n+   \"#\"\n+   \"&& reload_completed\"\n+   [(parallel [(set (reg:DI ACC_A)\n+                    (mult:DI (any_extend:DI (reg:SI 18))\n+                             (any_extend:DI (reg:SI 22))))\n+               (clobber (reg:HI REG_X))\n+               (clobber (reg:HI REG_Z))\n+               (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<extend_u>mulsidi3_insn\"\n+  [(set (reg:DI ACC_A)\n+        (mult:DI (any_extend:DI (reg:SI 18))\n+                 (any_extend:DI (reg:SI 22))))\n+   (clobber (reg:HI REG_X))\n+   (clobber (reg:HI REG_Z))\n+   (clobber (reg:CC REG_CC))]\n+  \"avr_have_dimode\n+   && AVR_HAVE_MUL\n+   && reload_completed\"\n   \"%~call __<extend_u>mulsidi3\"\n-  [(set_attr \"adjust_len\" \"call\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"adjust_len\" \"call\")])"}, {"sha": "1c4902f8bbc4c6b4967200a5e88925675bac2c5f", "filename": "gcc/config/avr/avr-fixed.md", "status": "modified", "additions": 320, "deletions": 60, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr-fixed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr-fixed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-fixed.md?ref=3ba781d3b5c8efadb60866c9743b657e8f0eb222", "patch": "@@ -56,27 +56,53 @@\n    TA UTA\n    QI HI SI DI])\n \n-(define_insn \"fract<FIXED_B:mode><FIXED_A:mode>2\"\n+(define_insn_and_split \"fract<FIXED_B:mode><FIXED_A:mode>2\"\n   [(set (match_operand:FIXED_A 0 \"register_operand\" \"=r\")\n         (fract_convert:FIXED_A\n          (match_operand:FIXED_B 1 \"register_operand\" \"r\")))]\n   \"<FIXED_B:MODE>mode != <FIXED_A:MODE>mode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (fract_convert:FIXED_A\n+                    (match_dup 1)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*fract<FIXED_B:mode><FIXED_A:mode>2\"\n+  [(set (match_operand:FIXED_A 0 \"register_operand\" \"=r\")\n+        (fract_convert:FIXED_A\n+         (match_operand:FIXED_B 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"<FIXED_B:MODE>mode != <FIXED_A:MODE>mode\n+   && reload_completed\"\n   {\n     return avr_out_fract (insn, operands, true, NULL);\n   }\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"adjust_len\" \"sfract\")])\n+  [(set_attr \"adjust_len\" \"sfract\")])\n \n-(define_insn \"fractuns<FIXED_B:mode><FIXED_A:mode>2\"\n+(define_insn_and_split \"fractuns<FIXED_B:mode><FIXED_A:mode>2\"\n   [(set (match_operand:FIXED_A 0 \"register_operand\" \"=r\")\n         (unsigned_fract_convert:FIXED_A\n          (match_operand:FIXED_B 1 \"register_operand\" \"r\")))]\n   \"<FIXED_B:MODE>mode != <FIXED_A:MODE>mode\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (unsigned_fract_convert:FIXED_A\n+                    (match_dup 1)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*fractuns<FIXED_B:mode><FIXED_A:mode>2\"\n+  [(set (match_operand:FIXED_A 0 \"register_operand\" \"=r\")\n+        (unsigned_fract_convert:FIXED_A\n+         (match_operand:FIXED_B 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"<FIXED_B:MODE>mode != <FIXED_A:MODE>mode\n+   && reload_completed\"\n   {\n     return avr_out_fract (insn, operands, false, NULL);\n   }\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"adjust_len\" \"ufract\")])\n+  [(set_attr \"adjust_len\" \"ufract\")])\n \n ;******************************************************************************\n ;** Saturated Addition and Subtraction\n@@ -92,29 +118,53 @@\n \n ;; \"ssaddqq3\"  \"ssaddhq3\"  \"ssaddha3\"  \"ssaddsq3\"  \"ssaddsa3\"\n ;; \"sssubqq3\"  \"sssubhq3\"  \"sssubha3\"  \"sssubsq3\"  \"sssubsa3\"\n-(define_insn \"<code_stdname><mode>3\"\n+(define_insn_and_split \"<code_stdname><mode>3\"\n   [(set (match_operand:ALL124S 0 \"register_operand\"                          \"=??d,d\")\n         (ss_addsub:ALL124S (match_operand:ALL124S 1 \"register_operand\" \"<abelian>0,0\")\n                            (match_operand:ALL124S 2 \"nonmemory_operand\"         \"r,Ynn\")))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (ss_addsub:ALL124S (match_dup 1)\n+                                      (match_dup 2)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3\"\n+  [(set (match_operand:ALL124S 0 \"register_operand\"                          \"=??d,d\")\n+        (ss_addsub:ALL124S (match_operand:ALL124S 1 \"register_operand\" \"<abelian>0,0\")\n+                           (match_operand:ALL124S 2 \"nonmemory_operand\"         \"r,Ynn\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   {\n     return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"adjust_len\" \"plus\")])\n+  [(set_attr \"adjust_len\" \"plus\")])\n \n ;; \"usadduqq3\"  \"usadduhq3\"  \"usadduha3\" \"usaddusq3\"  \"usaddusa3\"\n ;; \"ussubuqq3\"  \"ussubuhq3\"  \"ussubuha3\" \"ussubusq3\"  \"ussubusa3\"\n-(define_insn \"<code_stdname><mode>3\"\n+(define_insn_and_split \"<code_stdname><mode>3\"\n   [(set (match_operand:ALL124U 0 \"register_operand\"                          \"=??r,d\")\n         (us_addsub:ALL124U (match_operand:ALL124U 1 \"register_operand\" \"<abelian>0,0\")\n                            (match_operand:ALL124U 2 \"nonmemory_operand\"         \"r,Ynn\")))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (us_addsub:ALL124U (match_dup 1)\n+                                      (match_dup 2)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>3\"\n+  [(set (match_operand:ALL124U 0 \"register_operand\"                          \"=??r,d\")\n+        (us_addsub:ALL124U (match_operand:ALL124U 1 \"register_operand\" \"<abelian>0,0\")\n+                           (match_operand:ALL124U 2 \"nonmemory_operand\"         \"r,Ynn\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   {\n     return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"adjust_len\" \"plus\")])\n+  [(set_attr \"adjust_len\" \"plus\")])\n \n ;******************************************************************************\n ;** Saturated Negation and Absolute Value\n@@ -134,21 +184,41 @@\n     DONE;\n   })\n \n-(define_insn \"ssnegqq2\"\n+(define_insn_and_split \"ssnegqq2\"\n   [(set (match_operand:QQ 0 \"register_operand\"            \"=r\")\n         (ss_neg:QQ (match_operand:QQ 1 \"register_operand\"  \"0\")))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (ss_neg:QQ (match_dup 1)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*ssnegqq2\"\n+  [(set (match_operand:QQ 0 \"register_operand\"            \"=r\")\n+        (ss_neg:QQ (match_operand:QQ 1 \"register_operand\"  \"0\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"neg %0\\;brvc 0f\\;dec %0\\;0:\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"3\")])\n+  [(set_attr \"length\" \"3\")])\n \n-(define_insn \"ssabsqq2\"\n+(define_insn_and_split \"ssabsqq2\"\n   [(set (match_operand:QQ 0 \"register_operand\"            \"=r\")\n         (ss_abs:QQ (match_operand:QQ 1 \"register_operand\"  \"0\")))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (ss_abs:QQ (match_dup 1)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*ssabsqq2\"\n+  [(set (match_operand:QQ 0 \"register_operand\"            \"=r\")\n+        (ss_abs:QQ (match_operand:QQ 1 \"register_operand\"  \"0\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"sbrc %0,7\\;neg %0\\;sbrc %0,7\\;dec %0\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")])\n \n ;; \"ssneghq2\"  \"ssnegha2\"  \"ssnegsq2\"  \"ssnegsa2\"\n ;; \"ssabshq2\"  \"ssabsha2\"  \"ssabssq2\"  \"ssabssa2\"\n@@ -166,23 +236,43 @@\n \n ;; \"*ssneghq2\"  \"*ssnegha2\"\n ;; \"*ssabshq2\"  \"*ssabsha2\"\n-(define_insn \"*<code_stdname><mode>2\"\n+(define_insn_and_split \"*<code_stdname><mode>2_split\"\n   [(set (reg:ALL2S 24)\n         (ss_abs_neg:ALL2S (reg:ALL2S 24)))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL2S 24)\n+                   (ss_abs_neg:ALL2S (reg:ALL2S 24)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>2\"\n+  [(set (reg:ALL2S 24)\n+        (ss_abs_neg:ALL2S (reg:ALL2S 24)))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __<code_stdname>_2\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ;; \"*ssnegsq2\"  \"*ssnegsa2\"\n ;; \"*ssabssq2\"  \"*ssabssa2\"\n-(define_insn \"*<code_stdname><mode>2\"\n+(define_insn_and_split \"*<code_stdname><mode>2_split\"\n   [(set (reg:ALL4S 22)\n         (ss_abs_neg:ALL4S (reg:ALL4S 22)))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL4S 22)\n+                   (ss_abs_neg:ALL4S (reg:ALL4S 22)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code_stdname><mode>2\"\n+  [(set (reg:ALL4S 22)\n+        (ss_abs_neg:ALL4S (reg:ALL4S 22)))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __<code_stdname>_4\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ;******************************************************************************\n ; mul\n@@ -200,23 +290,47 @@\n     DONE;\n   })\n \n-(define_insn \"mulqq3_enh\"\n+(define_insn_and_split \"mulqq3_enh\"\n   [(set (match_operand:QQ 0 \"register_operand\"         \"=r\")\n         (mult:QQ (match_operand:QQ 1 \"register_operand\" \"a\")\n                  (match_operand:QQ 2 \"register_operand\" \"a\")))]\n   \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (mult:QQ (match_dup 1)\n+                            (match_dup 2)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*mulqq3_enh\"\n+  [(set (match_operand:QQ 0 \"register_operand\"         \"=r\")\n+        (mult:QQ (match_operand:QQ 1 \"register_operand\" \"a\")\n+                 (match_operand:QQ 2 \"register_operand\" \"a\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"AVR_HAVE_MUL && reload_completed\"\n   \"fmuls %1,%2\\;dec r1\\;brvs 0f\\;inc r1\\;0:\\;mov %0,r1\\;clr __zero_reg__\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"length\" \"6\")])\n \n-(define_insn \"muluqq3_enh\"\n+(define_insn_and_split \"muluqq3_enh\"\n   [(set (match_operand:UQQ 0 \"register_operand\"          \"=r\")\n         (mult:UQQ (match_operand:UQQ 1 \"register_operand\" \"r\")\n                   (match_operand:UQQ 2 \"register_operand\" \"r\")))]\n   \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (mult:UQQ (match_dup 1)\n+                             (match_dup 2)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*muluqq3_enh\"\n+  [(set (match_operand:UQQ 0 \"register_operand\"          \"=r\")\n+        (mult:UQQ (match_operand:UQQ 1 \"register_operand\" \"r\")\n+                  (match_operand:UQQ 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC REG_CC))]\n+  \"AVR_HAVE_MUL && reload_completed\"\n   \"mul %1,%2\\;mov %0,r1\\;clr __zero_reg__\"\n-  [(set_attr \"length\" \"3\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"length\" \"3\")])\n \n (define_expand \"mulqq3_nomul\"\n   [(set (reg:QQ 24)\n@@ -255,16 +369,32 @@\n     avr_fix_inputs (operands, 1 << 2, regmask (UQQmode, 22));\n   })\n \n-(define_insn \"*mulqq3.call\"\n+(define_insn_and_split \"*mulqq3.call_split\"\n   [(set (reg:QQ 23)\n         (mult:QQ (reg:QQ 24)\n                  (reg:QQ 25)))\n    (clobber (reg:QI 22))\n    (clobber (reg:HI 24))]\n   \"!AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:QQ 23)\n+                   (mult:QQ (reg:QQ 24)\n+                            (reg:QQ 25)))\n+              (clobber (reg:QI 22))\n+              (clobber (reg:HI 24))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*mulqq3.call\"\n+  [(set (reg:QQ 23)\n+        (mult:QQ (reg:QQ 24)\n+                 (reg:QQ 25)))\n+   (clobber (reg:QI 22))\n+   (clobber (reg:HI 24))\n+   (clobber (reg:CC REG_CC))]\n+  \"!AVR_HAVE_MUL && reload_completed\"\n   \"%~call __mulqq3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n \n ;; \"mulhq3\" \"muluhq3\"\n@@ -288,15 +418,29 @@\n \n ;; \"*mulhq3.call\"  \"*muluhq3.call\"\n ;; \"*mulha3.call\"  \"*muluha3.call\"\n-(define_insn \"*mul<mode>3.call\"\n+(define_insn_and_split \"*mul<mode>3.call_split\"\n   [(set (reg:ALL2QA 24)\n         (mult:ALL2QA (reg:ALL2QA 18)\n                      (reg:ALL2QA 26)))\n    (clobber (reg:HI 22))]\n   \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL2QA 24)\n+                   (mult:ALL2QA (reg:ALL2QA 18)\n+                                (reg:ALL2QA 26)))\n+              (clobber (reg:HI 22))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*mul<mode>3.call\"\n+  [(set (reg:ALL2QA 24)\n+        (mult:ALL2QA (reg:ALL2QA 18)\n+                     (reg:ALL2QA 26)))\n+   (clobber (reg:HI 22))\n+   (clobber (reg:CC REG_CC))]\n+  \"AVR_HAVE_MUL && reload_completed\"\n   \"%~call __mul<mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n \n ;; On the enhanced core, don't clobber either input and use a separate output\n@@ -318,14 +462,26 @@\n   })\n \n ;; \"*mulsa3.call\" \"*mulusa3.call\"\n-(define_insn \"*mul<mode>3.call\"\n+(define_insn_and_split \"*mul<mode>3.call_split\"\n   [(set (reg:ALL4A 24)\n         (mult:ALL4A (reg:ALL4A 16)\n                     (reg:ALL4A 20)))]\n   \"AVR_HAVE_MUL\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL4A 24)\n+                   (mult:ALL4A (reg:ALL4A 16)\n+                               (reg:ALL4A 20)))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*mul<mode>3.call\"\n+  [(set (reg:ALL4A 24)\n+        (mult:ALL4A (reg:ALL4A 16)\n+                    (reg:ALL4A 20)))\n+   (clobber (reg:CC REG_CC))]\n+  \"AVR_HAVE_MUL && reload_completed\"\n   \"%~call __mul<mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ; / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /\n ; div\n@@ -351,15 +507,29 @@\n \n \n ;; \"*divqq3.call\" \"*udivuqq3.call\"\n-(define_insn \"*<code><mode>3.call\"\n+(define_insn_and_split \"*<code><mode>3.call_split\"\n   [(set (reg:ALL1Q 24)\n         (usdiv:ALL1Q (reg:ALL1Q 25)\n                      (reg:ALL1Q 22)))\n    (clobber (reg:QI 25))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL1Q 24)\n+                   (usdiv:ALL1Q (reg:ALL1Q 25)\n+                                (reg:ALL1Q 22)))\n+              (clobber (reg:QI 25))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code><mode>3.call\"\n+  [(set (reg:ALL1Q 24)\n+        (usdiv:ALL1Q (reg:ALL1Q 25)\n+                     (reg:ALL1Q 22)))\n+   (clobber (reg:QI 25))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __<code><mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ;; \"divhq3\" \"udivuhq3\"\n ;; \"divha3\" \"udivuha3\"\n@@ -382,16 +552,32 @@\n \n ;; \"*divhq3.call\" \"*udivuhq3.call\"\n ;; \"*divha3.call\" \"*udivuha3.call\"\n-(define_insn \"*<code><mode>3.call\"\n+(define_insn_and_split \"*<code><mode>3.call_split\"\n   [(set (reg:ALL2QA 24)\n         (usdiv:ALL2QA (reg:ALL2QA 26)\n                       (reg:ALL2QA 22)))\n    (clobber (reg:HI 26))\n    (clobber (reg:QI 21))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL2QA 24)\n+                   (usdiv:ALL2QA (reg:ALL2QA 26)\n+                                 (reg:ALL2QA 22)))\n+              (clobber (reg:HI 26))\n+              (clobber (reg:QI 21))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code><mode>3.call\"\n+  [(set (reg:ALL2QA 24)\n+        (usdiv:ALL2QA (reg:ALL2QA 26)\n+                      (reg:ALL2QA 22)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:QI 21))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __<code><mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ;; Note the first parameter gets passed in already offset by 2 bytes\n \n@@ -414,16 +600,32 @@\n   })\n \n ;; \"*divsa3.call\" \"*udivusa3.call\"\n-(define_insn \"*<code><mode>3.call\"\n+(define_insn_and_split \"*<code><mode>3.call_split\"\n   [(set (reg:ALL4A 22)\n         (usdiv:ALL4A (reg:ALL4A 24)\n                      (reg:ALL4A 18)))\n    (clobber (reg:HI 26))\n    (clobber (reg:HI 30))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL4A 22)\n+                   (usdiv:ALL4A (reg:ALL4A 24)\n+                                (reg:ALL4A 18)))\n+              (clobber (reg:HI 26))\n+              (clobber (reg:HI 30))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*<code><mode>3.call\"\n+  [(set (reg:ALL4A 22)\n+        (usdiv:ALL4A (reg:ALL4A 24)\n+                     (reg:ALL4A 18)))\n+   (clobber (reg:HI 26))\n+   (clobber (reg:HI 30))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __<code><mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n \n ;******************************************************************************\n@@ -474,51 +676,109 @@\n ;; \"roundqq3_const\"  \"rounduqq3_const\"\n ;; \"roundhq3_const\"  \"rounduhq3_const\"  \"roundha3_const\"  \"rounduha3_const\"\n ;; \"roundsq3_const\"  \"roundusq3_const\"  \"roundsa3_const\"  \"roundusa3_const\"\n-(define_insn \"round<mode>3_const\"\n+(define_insn_and_split \"round<mode>3_const\"\n   [(set (match_operand:ALL124QA 0 \"register_operand\"                  \"=d\")\n         (unspec:ALL124QA [(match_operand:ALL124QA 1 \"register_operand\" \"0\")\n                           (match_operand:HI 2 \"const_int_operand\"      \"n\")\n                           (const_int 0)]\n                          UNSPEC_ROUND))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+                   (unspec:ALL124QA [(match_dup 1)\n+                                     (match_dup 2)\n+                                     (const_int 0)]\n+                                    UNSPEC_ROUND))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*round<mode>3_const\"\n+  [(set (match_operand:ALL124QA 0 \"register_operand\"                  \"=d\")\n+        (unspec:ALL124QA [(match_operand:ALL124QA 1 \"register_operand\" \"0\")\n+                          (match_operand:HI 2 \"const_int_operand\"      \"n\")\n+                          (const_int 0)]\n+                         UNSPEC_ROUND))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   {\n     return avr_out_round (insn, operands);\n   }\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"adjust_len\" \"round\")])\n+  [(set_attr \"adjust_len\" \"round\")])\n \n \n ;; \"*roundqq3.libgcc\"  \"*rounduqq3.libgcc\"\n-(define_insn \"*round<mode>3.libgcc\"\n+(define_insn_and_split \"*round<mode>3.libgcc_split\"\n   [(set (reg:ALL1Q 24)\n         (unspec:ALL1Q [(reg:ALL1Q 22)\n                        (reg:QI 24)] UNSPEC_ROUND))\n    (clobber (reg:ALL1Q 22))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL1Q 24)\n+                   (unspec:ALL1Q [(reg:ALL1Q 22)\n+                                  (reg:QI 24)] UNSPEC_ROUND))\n+              (clobber (reg:ALL1Q 22))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*round<mode>3.libgcc\"\n+  [(set (reg:ALL1Q 24)\n+        (unspec:ALL1Q [(reg:ALL1Q 22)\n+                       (reg:QI 24)] UNSPEC_ROUND))\n+   (clobber (reg:ALL1Q 22))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __round<mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ;; \"*roundhq3.libgcc\"  \"*rounduhq3.libgcc\"\n ;; \"*roundha3.libgcc\"  \"*rounduha3.libgcc\"\n-(define_insn \"*round<mode>3.libgcc\"\n+(define_insn_and_split \"*round<mode>3.libgcc_split\"\n   [(set (reg:ALL2QA 24)\n         (unspec:ALL2QA [(reg:ALL2QA 22)\n                         (reg:QI 24)] UNSPEC_ROUND))\n    (clobber (reg:ALL2QA 22))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL2QA 24)\n+                   (unspec:ALL2QA [(reg:ALL2QA 22)\n+                                   (reg:QI 24)] UNSPEC_ROUND))\n+              (clobber (reg:ALL2QA 22))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*round<mode>3.libgcc\"\n+  [(set (reg:ALL2QA 24)\n+        (unspec:ALL2QA [(reg:ALL2QA 22)\n+                        (reg:QI 24)] UNSPEC_ROUND))\n+   (clobber (reg:ALL2QA 22))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __round<mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])\n \n ;; \"*roundsq3.libgcc\"  \"*roundusq3.libgcc\"\n ;; \"*roundsa3.libgcc\"  \"*roundusa3.libgcc\"\n-(define_insn \"*round<mode>3.libgcc\"\n+(define_insn_and_split \"*round<mode>3.libgcc_split\"\n   [(set (reg:ALL4QA 22)\n         (unspec:ALL4QA [(reg:ALL4QA 18)\n                         (reg:QI 24)] UNSPEC_ROUND))\n    (clobber (reg:ALL4QA 18))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:ALL4QA 22)\n+                   (unspec:ALL4QA [(reg:ALL4QA 18)\n+                                   (reg:QI 24)] UNSPEC_ROUND))\n+              (clobber (reg:ALL4QA 18))\n+              (clobber (reg:CC REG_CC))])])\n+\n+(define_insn \"*round<mode>3.libgcc\"\n+  [(set (reg:ALL4QA 22)\n+        (unspec:ALL4QA [(reg:ALL4QA 18)\n+                        (reg:QI 24)] UNSPEC_ROUND))\n+   (clobber (reg:ALL4QA 18))\n+   (clobber (reg:CC REG_CC))]\n+  \"reload_completed\"\n   \"%~call __round<mode>3\"\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n+  [(set_attr \"type\" \"xcall\")])"}, {"sha": "06c84d583e6fdf1f5048b67bda293b13d73a6320", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 130, "deletions": 188, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=3ba781d3b5c8efadb60866c9743b657e8f0eb222", "patch": "@@ -195,6 +195,10 @@ rtx tmp_reg_rtx;\n extern GTY(()) rtx zero_reg_rtx;\n rtx zero_reg_rtx;\n \n+/* Condition Code register RTX (reg:CC REG_CC) */\n+extern GTY(()) rtx cc_reg_rtx;\n+rtx cc_reg_rtx;\n+\n /* RTXs for all general purpose registers as QImode */\n extern GTY(()) rtx all_regs_rtx[32];\n rtx all_regs_rtx[32];\n@@ -376,10 +380,10 @@ make_avr_pass_casesi (gcc::context *ctxt)\n /* Make one parallel insn with all the patterns from insns i[0]..i[5].  */\n \n static rtx_insn*\n-avr_parallel_insn_from_insns (rtx_insn *i[6])\n+avr_parallel_insn_from_insns (rtx_insn *i[5])\n {\n-  rtvec vec = gen_rtvec (6, PATTERN (i[0]), PATTERN (i[1]), PATTERN (i[2]),\n-                         PATTERN (i[3]), PATTERN (i[4]), PATTERN (i[5]));\n+  rtvec vec = gen_rtvec (5, PATTERN (i[0]), PATTERN (i[1]), PATTERN (i[2]),\n+                         PATTERN (i[3]), PATTERN (i[4]));\n   start_sequence();\n   emit (gen_rtx_PARALLEL (VOIDmode, vec));\n   rtx_insn *insn = get_insns();\n@@ -397,22 +401,21 @@ avr_parallel_insn_from_insns (rtx_insn *i[6])\n    pattern casesi_<mode>_sequence forged from the sequence to recog_data.  */\n \n static bool\n-avr_is_casesi_sequence (basic_block bb, rtx_insn *insn, rtx_insn *insns[6])\n+avr_is_casesi_sequence (basic_block bb, rtx_insn *insn, rtx_insn *insns[5])\n {\n-  rtx set_5, set_0;\n+  rtx set_4, set_0;\n \n   /* A first and quick test for a casesi sequences.  As a side effect of\n-     the test, harvest respective insns to INSNS[0..5].  */\n+     the test, harvest respective insns to INSNS[0..4].  */\n \n-  if (!(JUMP_P (insns[5] = insn)\n+  if (!(JUMP_P (insns[4] = insn)\n         // casesi is the only insn that comes up with UNSPEC_INDEX_JMP,\n         // hence the following test ensures that we are actually dealing\n         // with code from casesi.\n-        && (set_5 = single_set (insns[5]))\n-        && UNSPEC == GET_CODE (SET_SRC (set_5))\n-        && UNSPEC_INDEX_JMP == XINT (SET_SRC (set_5), 1)\n+        && (set_4 = single_set (insns[4]))\n+        && UNSPEC == GET_CODE (SET_SRC (set_4))\n+        && UNSPEC_INDEX_JMP == XINT (SET_SRC (set_4), 1)\n \n-        && (insns[4] = prev_real_insn (insns[5]))\n         && (insns[3] = prev_real_insn (insns[4]))\n         && (insns[2] = prev_real_insn (insns[3]))\n         && (insns[1] = prev_real_insn (insns[2]))\n@@ -429,7 +432,7 @@ avr_is_casesi_sequence (basic_block bb, rtx_insn *insn, rtx_insn *insns[6])\n     {\n       fprintf (dump_file, \";; Sequence from casesi in \"\n                \"[bb %d]:\\n\\n\", bb->index);\n-      for (int i = 0; i < 6; i++)\n+      for (int i = 0; i < 5; i++)\n         print_rtl_single (dump_file, insns[i]);\n     }\n \n@@ -519,7 +522,7 @@ avr_casei_sequence_check_operands (rtx *xop)\n }\n \n \n-/* INSNS[1..5] is a sequence as generated by casesi and INSNS[0] is an\n+/* INSNS[1..4] is a sequence as generated by casesi and INSNS[0] is an\n    extension of an 8-bit or 16-bit integer to SImode.  XOP contains the\n    operands of INSNS as extracted by insn_extract from pattern\n    casesi_<mode>_sequence:\n@@ -541,7 +544,7 @@ avr_casei_sequence_check_operands (rtx *xop)\n    switch value instead of SImode.  */\n \n static void\n-avr_optimize_casesi (rtx_insn *insns[6], rtx *xop)\n+avr_optimize_casesi (rtx_insn *insns[5], rtx *xop)\n {\n   // Original mode of the switch value; this is QImode or HImode.\n   machine_mode mode = GET_MODE (xop[10]);\n@@ -597,16 +600,21 @@ avr_optimize_casesi (rtx_insn *insns[6], rtx *xop)\n   rtx reg = copy_to_mode_reg (mode, xop[10]);\n \n   rtx (*gen_add)(rtx,rtx,rtx) = QImode == mode ? gen_addqi3 : gen_addhi3;\n-  rtx (*gen_cmp)(rtx,rtx) = QImode == mode ? gen_cmpqi3 : gen_cmphi3;\n+  rtx (*gen_cbranch)(rtx,rtx,rtx,rtx)\n+    = QImode == mode ? gen_cbranchqi4 : gen_cbranchhi4;\n \n   emit_insn (gen_add (reg, reg, gen_int_mode (-low_idx, mode)));\n-  emit_insn (gen_cmp (reg, gen_int_mode (num_idx, mode)));\n+  rtx op0 = reg; rtx op1 = gen_int_mode (num_idx, mode);\n+  rtx labelref = copy_rtx (xop[4]);\n+  emit_jump_insn (gen_cbranch (gen_rtx_fmt_ee (GTU, VOIDmode, op0, op1),\n+                               op0, op1,\n+                               labelref));\n \n   seq1 = get_insns();\n   last1 = get_last_insn();\n   end_sequence();\n \n-  emit_insn_before (seq1, insns[1]);\n+  emit_insn_after (seq1, insns[2]);\n \n   // After the out-of-bounds test and corresponding branch, use a\n   // 16-bit index.  If QImode is used, extend it to HImode first.\n@@ -627,7 +635,7 @@ avr_optimize_casesi (rtx_insn *insns[6], rtx *xop)\n   last2 = get_last_insn();\n   end_sequence();\n \n-  emit_insn_after (seq2, insns[4]);\n+  emit_insn_after (seq2, insns[3]);\n \n   if (dump_file)\n     {\n@@ -648,7 +656,7 @@ avr_optimize_casesi (rtx_insn *insns[6], rtx *xop)\n         }\n \n       fprintf (dump_file, \";; Deleting insns: %d, %d, %d.\\n\\n\",\n-               INSN_UID (insns[1]), INSN_UID (insns[2]), INSN_UID (insns[4]));\n+               INSN_UID (insns[1]), INSN_UID (insns[2]), INSN_UID (insns[3]));\n     }\n \n   // Pseudodelete the SImode and subreg of SImode insns.  We don't care\n@@ -657,7 +665,7 @@ avr_optimize_casesi (rtx_insn *insns[6], rtx *xop)\n \n   SET_INSN_DELETED (insns[1]);\n   SET_INSN_DELETED (insns[2]);\n-  SET_INSN_DELETED (insns[4]);\n+  SET_INSN_DELETED (insns[3]);\n }\n \n \n@@ -668,7 +676,7 @@ avr_pass_casesi::avr_rest_of_handle_casesi (function *func)\n \n   FOR_EACH_BB_FN (bb, func)\n     {\n-      rtx_insn *insn, *insns[6];\n+      rtx_insn *insn, *insns[5];\n \n       FOR_BB_INSNS (bb, insn)\n         {\n@@ -814,6 +822,8 @@ avr_init_expanders (void)\n   tmp_reg_rtx  = all_regs_rtx[AVR_TMP_REGNO];\n   zero_reg_rtx = all_regs_rtx[AVR_ZERO_REGNO];\n \n+  cc_reg_rtx  = gen_rtx_REG (CCmode, REG_CC);\n+\n   lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);\n \n   sreg_rtx = gen_rtx_MEM (QImode, GEN_INT (avr_addr.sreg));\n@@ -864,6 +874,9 @@ avr_regno_reg_class (int r)\n   if (r <= 33)\n     return reg_class_tab[r];\n \n+  if (r == REG_CC)\n+    return CC_REG;\n+\n   return ALL_REGS;\n }\n \n@@ -2641,19 +2654,21 @@ ptrreg_to_str (int regno)\n static const char*\n cond_string (enum rtx_code code)\n {\n+  bool cc_overflow_unusable = false;\n+\n   switch (code)\n     {\n     case NE:\n       return \"ne\";\n     case EQ:\n       return \"eq\";\n     case GE:\n-      if (cc_prev_status.flags & CC_OVERFLOW_UNUSABLE)\n+      if (cc_overflow_unusable)\n         return \"pl\";\n       else\n         return \"ge\";\n     case LT:\n-      if (cc_prev_status.flags & CC_OVERFLOW_UNUSABLE)\n+      if (cc_overflow_unusable)\n         return \"mi\";\n       else\n         return \"lt\";\n@@ -2989,152 +3004,6 @@ avr_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n   return size <= MOVE_MAX_PIECES;\n }\n \n-\n-/* Worker function for `NOTICE_UPDATE_CC'.  */\n-/* Update the condition code in the INSN.  */\n-\n-void\n-avr_notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx_insn *insn)\n-{\n-  rtx set;\n-  enum attr_cc cc = get_attr_cc (insn);\n-\n-  switch (cc)\n-    {\n-    default:\n-      break;\n-\n-    case CC_PLUS:\n-    case CC_LDI:\n-      {\n-        rtx *op = recog_data.operand;\n-        int len_dummy, icc;\n-\n-        /* Extract insn's operands.  */\n-        extract_constrain_insn_cached (insn);\n-\n-        switch (cc)\n-          {\n-          default:\n-            gcc_unreachable();\n-\n-          case CC_PLUS:\n-            avr_out_plus (insn, op, &len_dummy, &icc);\n-            cc = (enum attr_cc) icc;\n-            break;\n-\n-          case CC_LDI:\n-\n-            cc = (op[1] == CONST0_RTX (GET_MODE (op[0]))\n-                  && reg_overlap_mentioned_p (op[0], zero_reg_rtx))\n-              /* Loading zero-reg with 0 uses CLR and thus clobbers cc0.  */\n-              ? CC_CLOBBER\n-              /* Any other \"r,rL\" combination does not alter cc0.  */\n-              : CC_NONE;\n-\n-            break;\n-          } /* inner switch */\n-\n-        break;\n-      }\n-    } /* outer swicth */\n-\n-  switch (cc)\n-    {\n-    default:\n-      /* Special values like CC_OUT_PLUS from above have been\n-         mapped to \"standard\" CC_* values so we never come here.  */\n-\n-      gcc_unreachable();\n-      break;\n-\n-    case CC_NONE:\n-      /* Insn does not affect CC at all, but it might set some registers\n-         that are stored in cc_status.  If such a register is affected by\n-         the current insn, for example by means of a SET or a CLOBBER,\n-         then we must reset cc_status; cf. PR77326.\n-\n-         Unfortunately, set_of cannot be used as reg_overlap_mentioned_p\n-         will abort on COMPARE (which might be found in cc_status.value1/2).\n-         Thus work out the registers set by the insn and regs mentioned\n-         in cc_status.value1/2.  */\n-\n-      if (cc_status.value1\n-          || cc_status.value2)\n-        {\n-          HARD_REG_SET regs_used;\n-          HARD_REG_SET regs_set;\n-          CLEAR_HARD_REG_SET (regs_used);\n-\n-          if (cc_status.value1\n-              && !CONSTANT_P (cc_status.value1))\n-            {\n-              find_all_hard_regs (cc_status.value1, &regs_used);\n-            }\n-\n-          if (cc_status.value2\n-              && !CONSTANT_P (cc_status.value2))\n-            {\n-              find_all_hard_regs (cc_status.value2, &regs_used);\n-            }\n-\n-          find_all_hard_reg_sets (insn, &regs_set, false);\n-\n-          if (hard_reg_set_intersect_p (regs_used, regs_set))\n-            {\n-              CC_STATUS_INIT;\n-            }\n-        }\n-\n-      break; // CC_NONE\n-\n-    case CC_SET_N:\n-      CC_STATUS_INIT;\n-      break;\n-\n-    case CC_SET_ZN:\n-      set = single_set (insn);\n-      CC_STATUS_INIT;\n-      if (set)\n-        {\n-          cc_status.flags |= CC_NO_OVERFLOW;\n-          cc_status.value1 = SET_DEST (set);\n-        }\n-      break;\n-\n-    case CC_SET_VZN:\n-      /* Insn like INC, DEC, NEG that set Z,N,V.  We currently don't make use\n-         of this combination, cf. also PR61055.  */\n-      CC_STATUS_INIT;\n-      break;\n-\n-    case CC_SET_CZN:\n-      /* Insn sets the Z,N,C flags of CC to recog_operand[0].\n-         The V flag may or may not be known but that's ok because\n-         alter_cond will change tests to use EQ/NE.  */\n-      set = single_set (insn);\n-      CC_STATUS_INIT;\n-      if (set)\n-        {\n-          cc_status.value1 = SET_DEST (set);\n-          cc_status.flags |= CC_OVERFLOW_UNUSABLE;\n-        }\n-      break;\n-\n-    case CC_COMPARE:\n-      set = single_set (insn);\n-      CC_STATUS_INIT;\n-      if (set)\n-        cc_status.value1 = SET_SRC (set);\n-      break;\n-\n-    case CC_CLOBBER:\n-      /* Insn doesn't leave CC in a usable state.  */\n-      CC_STATUS_INIT;\n-      break;\n-    }\n-}\n-\n /* Choose mode for jump insn:\n    1 - relative jump in range -63 <= x <= 62 ;\n    2 - relative jump in range -2046 <= x <= 2045 ;\n@@ -3167,11 +3036,12 @@ const char*\n ret_cond_branch (rtx x, int len, int reverse)\n {\n   RTX_CODE cond = reverse ? reverse_condition (GET_CODE (x)) : GET_CODE (x);\n+  bool cc_overflow_unusable = false;\n \n   switch (cond)\n     {\n     case GT:\n-      if (cc_prev_status.flags & CC_OVERFLOW_UNUSABLE)\n+      if (cc_overflow_unusable)\n \treturn (len == 1 ? (\"breq .+2\" CR_TAB\n \t\t\t    \"brpl %0\") :\n \t\tlen == 2 ? (\"breq .+4\" CR_TAB\n@@ -3200,7 +3070,7 @@ ret_cond_branch (rtx x, int len, int reverse)\n                \"brlo .+4\" CR_TAB\n                \"jmp %0\"));\n     case LE:\n-      if (cc_prev_status.flags & CC_OVERFLOW_UNUSABLE)\n+      if (cc_overflow_unusable)\n \treturn (len == 1 ? (\"breq %0\" CR_TAB\n \t\t\t    \"brmi %0\") :\n \t\tlen == 2 ? (\"breq .+2\" CR_TAB\n@@ -5820,6 +5690,8 @@ compare_condition (rtx_insn *insn)\n   if (next && JUMP_P (next))\n     {\n       rtx pat = PATTERN (next);\n+      if (GET_CODE (pat) == PARALLEL)\n+        pat = XVECEXP (pat, 0, 0);\n       rtx src = SET_SRC (pat);\n \n       if (IF_THEN_ELSE == GET_CODE (src))\n@@ -6179,7 +6051,13 @@ out_shift_with_cnt (const char *templ, rtx_insn *insn, rtx operands[],\n \n   if (CONST_INT_P (operands[2]))\n     {\n+      /* Operand 3 is a scratch register if this is a\n+         parallel with three elements i.e. a set,\n+         a clobber of a scratch, and clobber of REG_CC.\n+         If a scratch reg is not available, then the parallel\n+         will contain only a set and clobber of REG_CC. */\n       bool scratch = (GET_CODE (PATTERN (insn)) == PARALLEL\n+                      && XVECLEN (PATTERN (insn), 0) == 3\n                       && REG_P (operands[3]));\n       int count = INTVAL (operands[2]);\n       int max_len = 10;  /* If larger than this, always use a loop.  */\n@@ -6376,7 +6254,9 @@ ashlhi3_out (rtx_insn *insn, rtx operands[], int *len)\n {\n   if (CONST_INT_P (operands[2]))\n     {\n-      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL\n+                     && XVECLEN (PATTERN (insn), 0) == 3\n+                     && REG_P (operands[3]));\n       int ldi_ok = test_hard_reg_class (LD_REGS, operands[0]);\n       int k;\n       int *t = len;\n@@ -6857,7 +6737,9 @@ ashrhi3_out (rtx_insn *insn, rtx operands[], int *len)\n {\n   if (CONST_INT_P (operands[2]))\n     {\n-      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL\n+                     && XVECLEN (PATTERN (insn), 0) == 3\n+                     && REG_P (operands[3]));\n       int ldi_ok = test_hard_reg_class (LD_REGS, operands[0]);\n       int k;\n       int *t = len;\n@@ -7271,7 +7153,9 @@ lshrhi3_out (rtx_insn *insn, rtx operands[], int *len)\n {\n   if (CONST_INT_P (operands[2]))\n     {\n-      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL\n+                     && XVECLEN (PATTERN (insn), 0) == 3\n+                     && REG_P (operands[3]));\n       int ldi_ok = test_hard_reg_class (LD_REGS, operands[0]);\n       int k;\n       int *t = len;\n@@ -9619,6 +9503,18 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n   return default_assemble_integer (x, size, aligned_p);\n }\n \n+/* Implement TARGET_CLASS_MAX_NREGS. Reasons described in comments for\n+   avr_hard_regno_nregs. */\n+\n+static unsigned char\n+avr_class_max_nregs (reg_class_t rclass, machine_mode mode)\n+{\n+  if (rclass == CC_REG && mode == CCmode)\n+\treturn 1;\n+\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n \n /* Implement `TARGET_CLASS_LIKELY_SPILLED_P'.  */\n /* Return value is nonzero if pseudos that have been\n@@ -11719,7 +11615,8 @@ avr_compare_pattern (rtx_insn *insn)\n \n   if (pattern\n       && NONJUMP_INSN_P (insn)\n-      && SET_DEST (pattern) == cc0_rtx\n+      && REG_P (SET_DEST (pattern))\n+      && REGNO (SET_DEST (pattern)) == REG_CC\n       && GET_CODE (SET_SRC (pattern)) == COMPARE)\n     {\n       machine_mode mode0 = GET_MODE (XEXP (SET_SRC (pattern), 0));\n@@ -11740,18 +11637,18 @@ avr_compare_pattern (rtx_insn *insn)\n \n /* Expansion of switch/case decision trees leads to code like\n \n-       cc0 = compare (Reg, Num)\n-       if (cc0 == 0)\n+       REG_CC = compare (Reg, Num)\n+       if (REG_CC == 0)\n          goto L1\n \n-       cc0 = compare (Reg, Num)\n-       if (cc0 > 0)\n+       REG_CC = compare (Reg, Num)\n+       if (REG_CC > 0)\n          goto L2\n \n    The second comparison is superfluous and can be deleted.\n    The second jump condition can be transformed from a\n-   \"difficult\" one to a \"simple\" one because \"cc0 > 0\" and\n-   \"cc0 >= 0\" will have the same effect here.\n+   \"difficult\" one to a \"simple\" one because \"REG_CC > 0\" and\n+   \"REG_CC >= 0\" will have the same effect here.\n \n    This function relies on the way switch/case is being expaned\n    as binary decision tree.  For example code see PR 49903.\n@@ -11822,8 +11719,8 @@ avr_reorg_remove_redundant_compare (rtx_insn *insn1)\n       || LABEL_REF != GET_CODE (XEXP (ifelse1, 1))\n       || LABEL_REF != GET_CODE (XEXP (ifelse2, 1))\n       || !COMPARISON_P (XEXP (ifelse2, 0))\n-      || cc0_rtx != XEXP (XEXP (ifelse1, 0), 0)\n-      || cc0_rtx != XEXP (XEXP (ifelse2, 0), 0)\n+      || REG_CC != REGNO (XEXP (XEXP (ifelse1, 0), 0))\n+      || REG_CC != REGNO (XEXP (XEXP (ifelse2, 0), 0))\n       || const0_rtx != XEXP (XEXP (ifelse1, 0), 1)\n       || const0_rtx != XEXP (XEXP (ifelse2, 0), 1))\n     {\n@@ -11832,20 +11729,20 @@ avr_reorg_remove_redundant_compare (rtx_insn *insn1)\n \n   /* We filtered the insn sequence to look like\n \n-        (set (cc0)\n+        (set (reg:CC cc)\n              (compare (reg:M N)\n                       (const_int VAL)))\n         (set (pc)\n-             (if_then_else (eq (cc0)\n+             (if_then_else (eq (reg:CC cc)\n                                (const_int 0))\n                            (label_ref L1)\n                            (pc)))\n \n-        (set (cc0)\n+        (set (reg:CC cc)\n              (compare (reg:M N)\n                       (const_int VAL)))\n         (set (pc)\n-             (if_then_else (CODE (cc0)\n+             (if_then_else (CODE (reg:CC cc)\n                                  (const_int 0))\n                            (label_ref L2)\n                            (pc)))\n@@ -11893,7 +11790,7 @@ avr_reorg_remove_redundant_compare (rtx_insn *insn1)\n   JUMP_LABEL (jump) = JUMP_LABEL (branch1);\n \n   target = XEXP (XEXP (ifelse2, 1), 0);\n-  cond = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n+  cond = gen_rtx_fmt_ee (code, VOIDmode, cc_reg_rtx, const0_rtx);\n   jump = emit_jump_insn_after (gen_branch_unspec (target, cond), insn2);\n \n   JUMP_LABEL (jump) = JUMP_LABEL (branch2);\n@@ -11936,6 +11833,8 @@ avr_reorg (void)\n \n \t  rtx_insn *next = next_real_insn (insn);\n           rtx pat = PATTERN (next);\n+          if (GET_CODE (pat) == PARALLEL)\n+            pat = XVECEXP (pat, 0, 0);\n \n           pattern = SET_SRC (pattern);\n \n@@ -12119,6 +12018,22 @@ jump_over_one_insn_p (rtx_insn *insn, rtx dest)\n               && avr_2word_insn_p (next_active_insn (insn))));\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS. CCmode is four units for historical\n+   reasons. If this hook is not defined, TARGET_HARD_REGNO_NREGS\n+   reports that CCmode requires four registers.\n+   Define this hook to allow CCmode to fit in a single REG_CC. For\n+   other modes and regs, return the number of words in mode (i.e whatever\n+   the default implementation of the hook returned). */\n+\n+static unsigned int\n+avr_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno == REG_CC && mode == CCmode)\n+    return 1;\n+\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n \n /* Implement TARGET_HARD_REGNO_MODE_OK.  On the enhanced core, anything\n    larger than 1 byte must start in even numbered register for \"movw\" to\n@@ -12127,6 +12042,9 @@ jump_over_one_insn_p (rtx_insn *insn, rtx dest)\n static bool\n avr_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n+  if (regno == REG_CC)\n+    return mode == CCmode;\n+\n   /* NOTE: 8-bit values must not be disallowed for R28 or R29.\n         Disallowing QI et al. in these regs might lead to code like\n             (set (subreg:QI (reg:HI 28) n) ...)\n@@ -14575,6 +14493,21 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n   return NULL_TREE;\n }\n \n+/* Prepend to CLOBBERS hard registers that are automatically clobbered\n+   for an asm. We do this for CC_REGNUM to maintain source compatibility\n+   with the original cc0-based compiler.  */\n+\n+static rtx_insn *\n+avr_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n+                   vec<machine_mode> & /*input_modes*/,\n+                   vec<const char *> &/*constraints*/,\n+                   vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n+{\n+  clobbers.safe_push (cc_reg_rtx);\n+  SET_HARD_REG_BIT (clobbered_regs, REG_CC);\n+  return NULL;\n+}\n+\n \n /* Worker function for `FLOAT_LIB_COMPARE_RETURNS_BOOL'.  */\n \n@@ -14669,6 +14602,9 @@ avr_float_lib_compare_returns_bool (machine_mode mode, enum rtx_code)\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS avr_hard_regno_nregs\n+\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK avr_hard_regno_mode_ok\n #undef  TARGET_HARD_REGNO_SCRATCH_OK\n@@ -14694,6 +14630,9 @@ avr_float_lib_compare_returns_bool (machine_mode mode, enum rtx_code)\n #undef  TARGET_CLASS_LIKELY_SPILLED_P\n #define TARGET_CLASS_LIKELY_SPILLED_P avr_class_likely_spilled_p\n \n+#undef  TARGET_CLASS_MAX_NREGS\n+#define TARGET_CLASS_MAX_NREGS avr_class_max_nregs\n+\n #undef  TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE avr_option_override\n \n@@ -14772,6 +14711,9 @@ avr_float_lib_compare_returns_bool (machine_mode mode, enum rtx_code)\n #undef  TARGET_STARTING_FRAME_OFFSET\n #define TARGET_STARTING_FRAME_OFFSET avr_starting_frame_offset\n \n+#undef  TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST avr_md_asm_adjust\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "30ce2baaf492ba5ba551adef45469644df2c80e9", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3ba781d3b5c8efadb60866c9743b657e8f0eb222", "patch": "@@ -155,7 +155,7 @@ FIXME: DRIVER_SELF_SPECS has changed.\n \n #define WCHAR_TYPE_SIZE 16\n \n-#define FIRST_PSEUDO_REGISTER 36\n+#define FIRST_PSEUDO_REGISTER 37\n \n #define GENERAL_REGNO_P(N)\tIN_RANGE (N, 2, 31)\n #define GENERAL_REG_P(X)\t(REG_P (X) && GENERAL_REGNO_P (REGNO (X)))\n@@ -178,7 +178,8 @@ FIXME: DRIVER_SELF_SPECS has changed.\n   0,0,/* r28 r29 */\\\n   0,0,/* r30 r31 */\\\n   1,1,/*  STACK */\\\n-  1,1 /* arg pointer */  }\n+  1,1, /* arg pointer */\t\t\t\t\t\t\\\n+  1 /* CC */ }\n \n #define CALL_USED_REGISTERS {\t\t\t\\\n   1,1,/* r0 r1 */\t\t\t\t\\\n@@ -198,7 +199,8 @@ FIXME: DRIVER_SELF_SPECS has changed.\n     0,0,/* r28 r29 */\t\t\t\t\\\n     1,1,/* r30 r31 */\t\t\t\t\\\n     1,1,/*  STACK */\t\t\t\t\\\n-    1,1 /* arg pointer */  }\n+    1,1, /* arg pointer */\t\t\t\\\n+    1 /* CC */ }\n \n #define REG_ALLOC_ORDER {\t\t\t\\\n     24,25,\t\t\t\t\t\\\n@@ -210,7 +212,7 @@ FIXME: DRIVER_SELF_SPECS has changed.\n     28,29,\t\t\t\t\t\\\n     17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,\t\\\n     0,1,\t\t\t\t\t\\\n-    32,33,34,35\t\t\t\t\t\\\n+    32,33,34,35,36\t\t\t\\\n     }\n \n #define ADJUST_REG_ALLOC_ORDER avr_adjust_reg_alloc_order()\n@@ -230,6 +232,7 @@ enum reg_class {\n   LD_REGS,\t\t\t/* r16 - r31 */\n   NO_LD_REGS,\t\t\t/* r0 - r15 */\n   GENERAL_REGS,\t\t\t/* r0 - r31 */\n+  CC_REG,\t\t\t/* CC */\n   ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -250,6 +253,7 @@ enum reg_class {\n \t\t   \"LD_REGS\",\t/* r16 - r31 */\t\t\t\\\n                    \"NO_LD_REGS\", /* r0 - r15 */                 \\\n \t\t   \"GENERAL_REGS\", /* r0 - r31 */\t\t\\\n+\t\t   \"CC_REG\", /* CC */\t\t\\\n \t\t   \"ALL_REGS\" }\n \n #define REG_CLASS_CONTENTS {\t\t\t\t\t\t\\\n@@ -270,7 +274,8 @@ enum reg_class {\n      0x00000000},\t/* LD_REGS, r16 - r31 */\t\t\t\\\n   {0x0000ffff,0x00000000},\t/* NO_LD_REGS  r0 - r15 */              \\\n   {0xffffffff,0x00000000},\t/* GENERAL_REGS, r0 - r31 */\t\t\\\n-  {0xffffffff,0x00000003}\t/* ALL_REGS */\t\t\t\t\\\n+  {0x00000000,0x00000010},\t/* CC */\t\t\t\t\\\n+  {0xffffffff,0x00000013}\t/* ALL_REGS */\t\t\t\t\\\n }\n \n #define REGNO_REG_CLASS(R) avr_regno_reg_class(R)\n@@ -429,7 +434,7 @@ typedef struct avr_args\n     \"r8\",\"r9\",\"r10\",\"r11\",\"r12\",\"r13\",\"r14\",\"r15\",\t\\\n     \"r16\",\"r17\",\"r18\",\"r19\",\"r20\",\"r21\",\"r22\",\"r23\",\t\\\n     \"r24\",\"r25\",\"r26\",\"r27\",\"r28\",\"r29\",\"r30\",\"r31\",\t\\\n-    \"__SP_L__\",\"__SP_H__\",\"argL\",\"argH\"}\n+    \"__SP_L__\",\"__SP_H__\",\"argL\",\"argH\", \"cc\"}\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop)  \\\n   avr_final_prescan_insn (insn, operand,nop)\n@@ -484,23 +489,6 @@ typedef struct avr_args\n \n #define TRAMPOLINE_SIZE 4\n \n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) avr_notice_update_cc (EXP, INSN)\n-\n-/* The add insns don't set overflow in a usable way.  */\n-#define CC_OVERFLOW_UNUSABLE 01000\n-/* The mov,and,or,xor insns don't set carry.  That's ok though as the\n-   Z bit is all we need when doing unsigned comparisons on the result of\n-   these insns (since they're always with 0).  However, conditions.h has\n-   CC_NO_OVERFLOW defined for this purpose.  Rename it to something more\n-   understandable.  */\n-#define CC_NO_CARRY CC_NO_OVERFLOW\n-\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n "}, {"sha": "2206fa19671f3f5ea218fa74e534737ce8ed551e", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 3389, "deletions": 855, "changes": 4244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba781d3b5c8efadb60866c9743b657e8f0eb222/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=3ba781d3b5c8efadb60866c9743b657e8f0eb222"}]}