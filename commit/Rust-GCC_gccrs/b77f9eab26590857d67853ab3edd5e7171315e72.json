{"sha": "b77f9eab26590857d67853ab3edd5e7171315e72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc3ZjllYWIyNjU5MDg1N2Q2Nzg1M2FiM2VkZDVlNzE3MTMxNWU3Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:27:17Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:27:17Z"}, "message": "cprop.c (struct expr): Split 'expr' field in 'dest' and 'src'.\n\n\t* cprop.c (struct expr): Split 'expr' field in 'dest' and 'src'.\n\t(expr_equiv_p): Remove.\n\t(insert_set_in_table): Look at <dest, src> pair instead of expr.\n\t(hash_scan_set): Update call to insert_set_in_table.\n\t(dump_hash_table): Dump <dest, src> pair.\n\t(lookup_set): Simplify.  Lookup <dest, src> pair.\n\t(compute_transp): Remove, fold heavily simplified code into...\n\t(compute_local_properties): ...here.  Expect COMP and TRANSP\n\tunconditionally.\n\t(find_avail_set): Take set directly from struct expr.\n\t(find_bypass-set): Likewise.\n\t(bypass_block): Likewise.\n\t(cprop_insn): Likewise.  Remove redundant INSN_P test.\n\nFrom-SVN: r171947", "tree": {"sha": "c8cf825d98ff5536e44a49ce4bf011297963122e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8cf825d98ff5536e44a49ce4bf011297963122e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b77f9eab26590857d67853ab3edd5e7171315e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77f9eab26590857d67853ab3edd5e7171315e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b77f9eab26590857d67853ab3edd5e7171315e72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77f9eab26590857d67853ab3edd5e7171315e72/comments", "author": null, "committer": null, "parents": [{"sha": "384d7a5522426eddc7cb7b04a65af0f397133ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/384d7a5522426eddc7cb7b04a65af0f397133ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/384d7a5522426eddc7cb7b04a65af0f397133ab9"}], "stats": {"total": 247, "additions": 86, "deletions": 161}, "files": [{"sha": "fce10f95a7d567e2936094bec8177838bde733ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77f9eab26590857d67853ab3edd5e7171315e72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77f9eab26590857d67853ab3edd5e7171315e72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b77f9eab26590857d67853ab3edd5e7171315e72", "patch": "@@ -1,5 +1,19 @@\n 2011-04-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n+\t* cprop.c (struct expr): Split 'expr' field in 'dest' and 'src'.\n+\t(expr_equiv_p): Remove.\n+\t(insert_set_in_table): Look at <dest, src> pair instead of expr.\n+\t(hash_scan_set): Update call to insert_set_in_table.\n+\t(dump_hash_table): Dump <dest, src> pair.\n+\t(lookup_set): Simplify.  Lookup <dest, src> pair.\n+\t(compute_transp): Remove, fold heavily simplified code into...\n+\t(compute_local_properties): ...here.  Expect COMP and TRANSP\n+\tunconditionally.\n+\t(find_avail_set): Take set directly from struct expr.\n+\t(find_bypass-set): Likewise.\n+\t(bypass_block): Likewise.\n+\t(cprop_insn): Likewise.  Remove redundant INSN_P test.\n+\n \t* cprop.c (implicit_set_cond_p): Assume nothing about COND, move\n \tchecks on form of COND from find_implicit_sets to here.\n \t(find_implicit_sets): Cleanup control flow. Split critical edges"}, {"sha": "b9235f176c37dd2da215fac51c3800e659af90f9", "filename": "gcc/cprop.c", "status": "modified", "additions": 72, "deletions": 161, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77f9eab26590857d67853ab3edd5e7171315e72/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77f9eab26590857d67853ab3edd5e7171315e72/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=b77f9eab26590857d67853ab3edd5e7171315e72", "patch": "@@ -55,23 +55,6 @@ static struct obstack cprop_obstack;\n \n struct reg_use {rtx reg_rtx; };\n \n-/* Hash table of expressions.  */\n-\n-struct expr\n-{\n-  /* The expression (SET_SRC for expressions, PATTERN for assignments).  */\n-  rtx expr;\n-  /* Index in the available expression bitmaps.  */\n-  int bitmap_index;\n-  /* Next entry with the same hash.  */\n-  struct expr *next_same_hash;\n-  /* List of available occurrence in basic blocks in the function.\n-     An \"available occurrence\" is one that is the last occurrence in the\n-     basic block and the operands are not modified by following statements in\n-     the basic block [including this insn].  */\n-  struct occr *avail_occr;\n-};\n-\n /* Occurrence of an expression.\n    There is one per basic block.  If a pattern appears more than once the\n    last appearance is used.  */\n@@ -88,7 +71,26 @@ typedef struct occr *occr_t;\n DEF_VEC_P (occr_t);\n DEF_VEC_ALLOC_P (occr_t, heap);\n \n-/* Expression and copy propagation hash tables.\n+/* Hash table entry for an assignment expressions.  */\n+\n+struct expr\n+{\n+  /* The expression (DEST := SRC).  */\n+  rtx dest;\n+  rtx src;\n+\n+  /* Index in the available expression bitmaps.  */\n+  int bitmap_index;\n+  /* Next entry with the same hash.  */\n+  struct expr *next_same_hash;\n+  /* List of available occurrence in basic blocks in the function.\n+     An \"available occurrence\" is one that is the last occurrence in the\n+     basic block and the operands are not modified by following statements in\n+     the basic block [including this insn].  */\n+  struct occr *avail_occr;\n+};\n+\n+/* Hash table for copy propagation expressions.\n    Each hash table is an array of buckets.\n    ??? It is known that if it were an array of entries, structure elements\n    `next_same_hash' and `bitmap_index' wouldn't be necessary.  However, it is\n@@ -175,40 +177,31 @@ hash_set (int regno, int hash_table_size)\n   return hash % hash_table_size;\n }\n \n-/* Return nonzero if exp1 is equivalent to exp2.  */\n-\n-static int\n-expr_equiv_p (const_rtx x, const_rtx y)\n-{\n-  return exp_equiv_p (x, y, 0, true);\n-}\n-\n-/* Insert pattern X in INSN in the hash table.\n-   X is a SET of a reg to either another reg or a constant.\n-   If it is already present, record it as the last occurrence in INSN's\n-   basic block.  */\n+/* Insert assignment DEST:=SET from INSN in the hash table.\n+   DEST is a register and SET is a register or a suitable constant.\n+   If the assignment is already present in the table, record it as\n+   the last occurrence in INSN's basic block.  */\n \n static void\n-insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n+insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table)\n {\n-  int found;\n+  bool found = false;\n   unsigned int hash;\n   struct expr *cur_expr, *last_expr = NULL;\n   struct occr *cur_occr;\n \n-  gcc_assert (GET_CODE (x) == SET && REG_P (SET_DEST (x)));\n-\n-  hash = hash_set (REGNO (SET_DEST (x)), table->size);\n+  hash = hash_set (REGNO (dest), table->size);\n \n-  cur_expr = table->table[hash];\n-  found = 0;\n-\n-  while (cur_expr && 0 == (found = expr_equiv_p (cur_expr->expr, x)))\n+  for (cur_expr = table->table[hash]; cur_expr;\n+       cur_expr = cur_expr->next_same_hash)\n     {\n-      /* If the expression isn't found, save a pointer to the end of\n-\t the list.  */\n+      if (dest == cur_expr->dest\n+\t  && src == cur_expr->src)\n+\t{\n+\t  found = true;\n+\t  break;\n+\t}\n       last_expr = cur_expr;\n-      cur_expr = cur_expr->next_same_hash;\n     }\n \n   if (! found)\n@@ -225,7 +218,8 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n       /* Set the fields of the expr element.\n \t We must copy X because it can be modified when copy propagation is\n \t performed on its operands.  */\n-      cur_expr->expr = copy_rtx (x);\n+      cur_expr->dest = copy_rtx (dest);\n+      cur_expr->src = copy_rtx (src);\n       cur_expr->bitmap_index = table->n_elems++;\n       cur_expr->next_same_hash = NULL;\n       cur_expr->avail_occr = NULL;\n@@ -290,7 +284,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t for INSN, we miss copy propagation opportunities.\n \n \t Note that this does not impede profitable constant propagations.  We\n-\t \"look through\" reg-reg sets in lookup_avail_set.  */\n+\t \"look through\" reg-reg sets in lookup_set.  */\n       rtx note = find_reg_equal_equiv_note (insn);\n       if (note != 0\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n@@ -304,7 +298,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t   && ! HARD_REGISTER_P (src)\n \t   && reg_available_p (src, insn))\n \t  || cprop_constant_p (src))\n-\tinsert_set_in_table (pat, insn, table);\n+\tinsert_set_in_table (dest, src, insn, table);\n     }\n }\n \n@@ -368,7 +362,9 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n \texpr = flat_table[i];\n \tfprintf (file, \"Index %d (hash value %d)\\n  \",\n \t\t expr->bitmap_index, hash_val[i]);\n-\tprint_rtl (file, expr->expr);\n+\tprint_rtl (file, expr->dest);\n+\tfprintf (file, \" := \");\n+\tprint_rtl (file, expr->src);\n \tfprintf (file, \"\\n\");\n       }\n \n@@ -497,7 +493,7 @@ lookup_set (unsigned int regno, struct hash_table_d *table)\n \n   expr = table->table[hash];\n \n-  while (expr && REGNO (SET_DEST (expr->expr)) != regno)\n+  while (expr && REGNO (expr->dest) != regno)\n     expr = expr->next_same_hash;\n \n   return expr;\n@@ -510,7 +506,7 @@ next_set (unsigned int regno, struct expr *expr)\n {\n   do\n     expr = expr->next_same_hash;\n-  while (expr && REGNO (SET_DEST (expr->expr)) != regno);\n+  while (expr && REGNO (expr->dest) != regno);\n \n   return expr;\n }\n@@ -583,76 +579,6 @@ free_cprop_mem (void)\n   sbitmap_vector_free (cprop_avout);\n }\n \n-/* For each block, compute whether X is transparent.  X is either an\n-   expression or an assignment [though we don't care which, for this context\n-   an assignment is treated as an expression].  For each block where an\n-   element of X is modified, set the INDX bit in BMAP.  */\n-\n-static void\n-compute_transp (const_rtx x, int indx, sbitmap *bmap)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  /* repeat is used to turn tail-recursion into iteration since GCC\n-     can't do it when there's no return value.  */\n- repeat:\n-\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case REG:\n-\t{\n-\t  df_ref def;\n-\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n-\t       def;\n-\t       def = DF_REF_NEXT_REG (def))\n-\t    SET_BIT (bmap[DF_REF_BB (def)->index], indx);\n-\t}\n-      return;\n-\n-    case PC:\n-    case CC0: /*FIXME*/\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    {\n-\t      x = XEXP (x, i);\n-\t      goto repeat;\n-\t    }\n-\n-\t  compute_transp (XEXP (x, i), indx, bmap);\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  compute_transp (XVECEXP (x, i, j), indx, bmap);\n-    }\n-}\n-\n /* Compute the local properties of each recorded expression.\n \n    Local properties are those that are defined by the block, irrespective of\n@@ -665,26 +591,17 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap)\n    at least once and expression would contain the same value if the\n    computation was moved to the end of the block.\n \n-   TRANSP and COMP are destination sbitmaps for recording local properties.\n-   If NULL, then it is not necessary to compute or record that particular\n-   property.\n-\n-   TRANSP is computed as ~TRANSP, since this is really cprop's ABSALTERED.  */\n+   TRANSP and COMP are destination sbitmaps for recording local properties.  */\n \n static void\n compute_local_properties (sbitmap *transp, sbitmap *comp,\n \t\t\t  struct hash_table_d *table)\n {\n   unsigned int i;\n \n-  /* Initialize any bitmaps that were passed in.  */\n-  if (transp)\n-    {\n-      sbitmap_vector_zero (transp, last_basic_block);\n-    }\n-\n-  if (comp)\n-    sbitmap_vector_zero (comp, last_basic_block);\n+  /* Initialize the bitmaps that were passed in.  */\n+  sbitmap_vector_zero (transp, last_basic_block);\n+  sbitmap_vector_zero (comp, last_basic_block);\n \n   for (i = 0; i < table->size; i++)\n     {\n@@ -693,21 +610,27 @@ compute_local_properties (sbitmap *transp, sbitmap *comp,\n       for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n \t{\n \t  int indx = expr->bitmap_index;\n+\t  df_ref def;\n \t  struct occr *occr;\n \n-\t  /* The expression is transparent in this block if it is not killed.\n-\t     We start by assuming all are transparent [none are killed], and\n-\t     then reset the bits for those that are.  */\n-\t  if (transp)\n-\t    compute_transp (expr->expr, indx, transp);\n+\t  /* The expression is transparent in a block if it is not killed,\n+\t     i.e. DEST and SRC are not set or clobbered in the block.\n+\t     We start by assuming all are transparent [none are killed],\n+\t     and then set the bits for those that are.  */\n+\t  for (def = DF_REG_DEF_CHAIN (REGNO (expr->dest));\n+\t       def; def = DF_REF_NEXT_REG (def))\n+\t    SET_BIT (transp[DF_REF_BB (def)->index], indx);\n+\t  if (REG_P (expr->src))\n+\t    for (def = DF_REG_DEF_CHAIN (REGNO (expr->src));\n+\t\t def; def = DF_REF_NEXT_REG (def))\n+\t      SET_BIT (transp[DF_REF_BB (def)->index], indx);\n \n \t  /* The occurrences recorded in avail_occr are exactly those that\n \t     we want to set to nonzero in COMP.  */\n-\t  if (comp)\n-\t    for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n-\t      {\n-\t\tSET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n-\t      }\n+\t  for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n+\t    {\n+\t      SET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n+\t    }\n \t}\n     }\n }\n@@ -892,9 +815,7 @@ find_avail_set (int regno, rtx insn)\n       if (set == 0)\n \tbreak;\n \n-      gcc_assert (GET_CODE (set->expr) == SET);\n-\n-      src = SET_SRC (set->expr);\n+      src = set->src;\n \n       /* We know the set is available.\n \t Now check that SRC is locally anticipatable (i.e. none of the\n@@ -1080,23 +1001,19 @@ cprop_insn (rtx insn)\n   int changed = 0;\n   rtx note;\n \n-  if (!INSN_P (insn))\n-    return 0;\n-\n   reg_use_count = 0;\n   note_uses (&PATTERN (insn), find_used_regs, NULL);\n \n-  note = find_reg_equal_equiv_note (insn);\n-\n   /* We may win even when propagating constants into notes.  */\n+  note = find_reg_equal_equiv_note (insn);\n   if (note)\n     find_used_regs (&XEXP (note, 0), NULL);\n \n   for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n        reg_used++, reg_use_count--)\n     {\n       unsigned int regno = REGNO (reg_used->reg_rtx);\n-      rtx pat, src;\n+      rtx src;\n       struct expr *set;\n \n       /* If the register has already been set in this block, there's\n@@ -1110,11 +1027,7 @@ cprop_insn (rtx insn)\n       if (! set)\n \tcontinue;\n \n-      pat = set->expr;\n-      /* ??? We might be able to handle PARALLELs.  Later.  */\n-      gcc_assert (GET_CODE (pat) == SET);\n-\n-      src = SET_SRC (pat);\n+      src = set->src;\n \n       /* Constant propagation.  */\n       if (cprop_constant_p (src))\n@@ -1150,7 +1063,7 @@ cprop_insn (rtx insn)\n \t\t}\n \n \t      /* The original insn setting reg_used may or may not now be\n-\t\t deletable.  We leave the deletion to flow.  */\n+\t\t deletable.  We leave the deletion to DCE.  */\n \t      /* FIXME: If it turns out that the insn isn't deletable,\n \t\t then we may have unnecessarily extended register lifetimes\n \t\t and made things worse.  */\n@@ -1502,9 +1415,7 @@ find_bypass_set (int regno, int bb)\n       if (set == 0)\n \tbreak;\n \n-      gcc_assert (GET_CODE (set->expr) == SET);\n-\n-      src = SET_SRC (set->expr);\n+      src = set->src;\n       if (cprop_constant_p (src))\n \tresult = set;\n \n@@ -1625,7 +1536,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t\t\t\t\tSET_SRC (PATTERN (setcc)));\n \n \t  new_rtx = simplify_replace_rtx (src, reg_used->reg_rtx,\n-\t\t\t\t\t  SET_SRC (set->expr));\n+\t\t\t\t\t  set->src);\n \n \t  /* Jump bypassing may have already placed instructions on\n \t     edges of the CFG.  We can't bypass an outgoing edge that\n@@ -1677,7 +1588,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t\t  fprintf (dump_file, \"JUMP-BYPASS: Proved reg %d \"\n \t\t\t\t      \"in jump_insn %d equals constant \",\n \t\t\t   regno, INSN_UID (jump));\n-\t\t  print_rtl (dump_file, SET_SRC (set->expr));\n+\t\t  print_rtl (dump_file, set->src);\n \t\t  fprintf (dump_file, \"\\nBypass edge from %d->%d to %d\\n\",\n \t\t\t   e->src->index, old_dest->index, dest->index);\n \t\t}"}]}