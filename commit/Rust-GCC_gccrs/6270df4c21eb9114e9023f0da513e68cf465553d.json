{"sha": "6270df4c21eb9114e9023f0da513e68cf465553d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI3MGRmNGMyMWViOTExNGU5MDIzZjBkYTUxM2U2OGNmNDY1NTUzZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-01-12T17:57:40Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-12T17:57:40Z"}, "message": "loop.texi: Document recording of loop exits.\n\n\t* doc/loop.texi: Document recording of loop exits.\n\t* cfgloopmanip.c (loopify, duplicate_loop): Use alloc_loop.\n\t(update_single_exits_after_duplication,\n\tupdate_single_exit_for_duplicated_loop,\n\tupdate_single_exit_for_duplicated_loops): Removed.\n\t(duplicate_loop_to_header_edge): Do not call\n\tupdate_single_exits_after_duplication and\n\tupdate_single_exit_for_duplicated_loops.\n\t(loop_version): Do not update single_exit information.\n\t(fix_loop_structure): Use record_loop_exits instead of\n\tmark_single_exit_loops.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update\n\tthe lists of loop exits.\n\t* cfghooks.c (redirect_edge_and_branch, redirect_edge_and_branch_force,\n\tsplit_edge, merge_blocks): Update the lists of loop exits.\n\t* modulo-sched.c (sms_schedule): Pass LOOPS_HAVE_RECORDED_EXITS to\n\tloop_optimizer_init.\n\t* loop-init.c (loop_optimizer_init): Call record_loop_exits instead\n\tof mark_single_exit_loops.\n\t(loop_optimizer_finalize): Call release_recorded_exits.\n\t* tree-ssa-loop.c (tree_loop_optimizer_init): Pass\n\tLOOPS_HAVE_RECORDED_EXITS to loop_optimizer_init.\n\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg): Do not\n\tupdate single exit information.\n\t* lambda-code.c (perfect_nestify): Ditto.\n\t* cfgloop.c (flow_loop_free): Destroy the list of exits of the loop.\n\t(mark_single_exit_loops): Removed.\n\t(alloc_loop, loop_exit_hash, loop_exit_eq, loop_exit_free,\n\tget_exit_descriptions, rescan_loop_exit, record_loop_exits,\n\tdump_recorded_exit, dump_recorded_exits, release_recorded_exits): New\n\tfunctions.\n\t(get_loop_exit_edges, single_exit): Use recorded exit lists.\n\t(add_bb_to_loop, remove_bb_from_loops): Update the lists of loop exits.\n\t(verify_loop_structure): Verify consistency of the exit lists.\n\t(flow_loops_find): Use alloc_loop.  Initialize exits hash.\n\t(set_single_exit): Removed.\n\t* cfgloop.h (struct loop_exit): New function.\n\t(struct loop): single_exit_ field replaced by exits field.\n\t(LOOPS_HAVE_MARKED_SINGLE_EXITS): Replaced by LOOPS_HAVE_RECORDED_EXITS.\n\t(struct loops): Added exits hash.\n\t(mark_single_exit_loops, set_single_exit): Declaration removed.\n\t(release_recorded_exits, record_loop_exits, rescan_loop_exit): Declare.\n\nFrom-SVN: r120728", "tree": {"sha": "6cc0ea65afc6e5ab5c27890dd53712843ef3bc17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cc0ea65afc6e5ab5c27890dd53712843ef3bc17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6270df4c21eb9114e9023f0da513e68cf465553d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6270df4c21eb9114e9023f0da513e68cf465553d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6270df4c21eb9114e9023f0da513e68cf465553d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6270df4c21eb9114e9023f0da513e68cf465553d/comments", "author": null, "committer": null, "parents": [{"sha": "1cbe999f085718f7310aa7f8352cce3cbd9e4526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbe999f085718f7310aa7f8352cce3cbd9e4526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbe999f085718f7310aa7f8352cce3cbd9e4526"}], "stats": {"total": 690, "additions": 470, "deletions": 220}, "files": [{"sha": "00dca633fc0f087dc6ffa3a08a791797bb2e1541", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -1,3 +1,48 @@\n+2007-01-12  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* doc/loop.texi: Document recording of loop exits.\n+\t* cfgloopmanip.c (loopify, duplicate_loop): Use alloc_loop.\n+\t(update_single_exits_after_duplication,\n+\tupdate_single_exit_for_duplicated_loop,\n+\tupdate_single_exit_for_duplicated_loops): Removed.\n+\t(duplicate_loop_to_header_edge): Do not call\n+\tupdate_single_exits_after_duplication and\n+\tupdate_single_exit_for_duplicated_loops.\n+\t(loop_version): Do not update single_exit information.\n+\t(fix_loop_structure): Use record_loop_exits instead of\n+\tmark_single_exit_loops.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update\n+\tthe lists of loop exits.\n+\t* cfghooks.c (redirect_edge_and_branch, redirect_edge_and_branch_force,\n+\tsplit_edge, merge_blocks): Update the lists of loop exits.\n+\t* modulo-sched.c (sms_schedule): Pass LOOPS_HAVE_RECORDED_EXITS to\n+\tloop_optimizer_init.\n+\t* loop-init.c (loop_optimizer_init): Call record_loop_exits instead\n+\tof mark_single_exit_loops.\n+\t(loop_optimizer_finalize): Call release_recorded_exits.\n+\t* tree-ssa-loop.c (tree_loop_optimizer_init): Pass\n+\tLOOPS_HAVE_RECORDED_EXITS to loop_optimizer_init.\n+\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg): Do not\n+\tupdate single exit information.\n+\t* lambda-code.c (perfect_nestify): Ditto.\n+\t* cfgloop.c (flow_loop_free): Destroy the list of exits of the loop.\n+\t(mark_single_exit_loops): Removed.\n+\t(alloc_loop, loop_exit_hash, loop_exit_eq, loop_exit_free,\n+\tget_exit_descriptions, rescan_loop_exit, record_loop_exits,\n+\tdump_recorded_exit, dump_recorded_exits, release_recorded_exits): New\n+\tfunctions.\n+\t(get_loop_exit_edges, single_exit): Use recorded exit lists.\n+\t(add_bb_to_loop, remove_bb_from_loops): Update the lists of loop exits.\n+\t(verify_loop_structure): Verify consistency of the exit lists.\n+\t(flow_loops_find): Use alloc_loop.  Initialize exits hash.\n+\t(set_single_exit): Removed.\n+\t* cfgloop.h (struct loop_exit): New function.\n+\t(struct loop): single_exit_ field replaced by exits field.\n+\t(LOOPS_HAVE_MARKED_SINGLE_EXITS): Replaced by LOOPS_HAVE_RECORDED_EXITS.\n+\t(struct loops): Added exits hash.\n+\t(mark_single_exit_loops, set_single_exit): Declaration removed.\n+\t(release_recorded_exits, record_loop_exits, rescan_loop_exit): Declare.\n+\n 2007-01-12  Richard Sandiford  <richard@codesourcery.com>\n \n \t* doc/invoke.texi: Avoid use of @headitem."}, {"sha": "d6a981d1db87165d9c9b47791b4bbc6ba3be96ce", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -310,6 +310,11 @@ redirect_edge_and_branch (edge e, basic_block dest)\n \n   ret = cfg_hooks->redirect_edge_and_branch (e, dest);\n \n+  /* If RET != E, then the edge E was removed since RET already lead to the\n+     same destination.  */\n+  if (ret != NULL && current_loops != NULL)\n+    rescan_loop_exit (e, false, ret != e);\n+\n   return ret;\n }\n \n@@ -320,19 +325,27 @@ redirect_edge_and_branch (edge e, basic_block dest)\n basic_block\n redirect_edge_and_branch_force (edge e, basic_block dest)\n {\n-  basic_block ret;\n+  basic_block ret, src = e->src;\n   struct loop *loop;\n \n   if (!cfg_hooks->redirect_edge_and_branch_force)\n     internal_error (\"%s does not support redirect_edge_and_branch_force\",\n \t\t    cfg_hooks->name);\n \n+  if (current_loops != NULL)\n+    rescan_loop_exit (e, false, true);\n+\n   ret = cfg_hooks->redirect_edge_and_branch_force (e, dest);\n-  if (current_loops != NULL && ret != NULL)\n+  if (current_loops != NULL)\n     {\n-      loop = find_common_loop (single_pred (ret)->loop_father,\n-\t\t\t       single_succ (ret)->loop_father);\n-      add_bb_to_loop (ret, loop);\n+      if (ret != NULL)\n+\t{\n+\t  loop = find_common_loop (single_pred (ret)->loop_father,\n+\t\t\t\t   single_succ (ret)->loop_father);\n+\t  add_bb_to_loop (ret, loop);\n+\t}\n+      else if (find_edge (src, dest) == e)\n+\trescan_loop_exit (e, true, false);\n     }\n \n   return ret;\n@@ -452,6 +465,9 @@ split_edge (edge e)\n   if (!cfg_hooks->split_edge)\n     internal_error (\"%s does not support split_edge\", cfg_hooks->name);\n \n+  if (current_loops != NULL)\n+    rescan_loop_exit (e, false, true);\n+\n   ret = cfg_hooks->split_edge (e);\n   ret->count = count;\n   ret->frequency = freq;\n@@ -595,11 +611,19 @@ merge_blocks (basic_block a, basic_block b)\n      whole lot of them and hope the caller knows what they're doing.  */\n \n   while (EDGE_COUNT (a->succs) != 0)\n-   remove_edge (EDGE_SUCC (a, 0));\n+    {\n+      if (current_loops != NULL)\n+\trescan_loop_exit (EDGE_SUCC (a, 0), false, true);\n+      remove_edge (EDGE_SUCC (a, 0));\n+    }\n \n   /* Adjust the edges out of B for the new owner.  */\n   FOR_EACH_EDGE (e, ei, b->succs)\n-    e->src = a;\n+    {\n+      e->src = a;\n+      if (current_loops != NULL)\n+\trescan_loop_exit (e, true, false);\n+    }\n   a->succs = b->succs;\n   a->flags |= b->flags;\n "}, {"sha": "bd9e6d351da42ccbcda8bb2d4dc4eb6e19a7e98c", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 345, "deletions": 115, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -149,8 +149,22 @@ flow_loops_dump (FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *,\n void\n flow_loop_free (struct loop *loop)\n {\n+  struct loop_exit *exit, *next;\n+\n   if (loop->pred)\n     free (loop->pred);\n+\n+  /* Break the list of the loop exit records.  They will be freed when the\n+     corresponding edge is rescanned or removed, and this avoids\n+     accessing the (already released) head of the list stored in the\n+     loop structure.  */\n+  for (exit = loop->exits.next; exit != &loop->exits; exit = next)\n+    {\n+      next = exit->next;\n+      exit->next = exit;\n+      exit->prev = exit;\n+    }\n+    \n   free (loop);\n }\n \n@@ -227,57 +241,6 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n   return num_nodes;\n }\n \n-/* For each loop that has just a single exit, record the exit edge.  */\n-\n-void\n-mark_single_exit_loops (void)\n-{\n-  basic_block bb;\n-  edge e;\n-  struct loop *loop;\n-  loop_iterator li;\n-\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      set_single_exit (loop, NULL);\n-    }\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      edge_iterator ei;\n-      if (bb->loop_father == current_loops->tree_root)\n-\tcontinue;\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  if (e->dest == EXIT_BLOCK_PTR)\n-\t    continue;\n-\n-\t  if (flow_bb_inside_loop_p (bb->loop_father, e->dest))\n-\t    continue;\n-\n-\t  for (loop = bb->loop_father;\n-\t       loop != e->dest->loop_father;\n-\t       loop = loop->outer)\n-\t    {\n-\t      /* If we have already seen an exit, mark this by the edge that\n-\t\t surely does not occur as any exit.  */\n-\t      if (single_exit (loop))\n-\t\tset_single_exit (loop, single_succ_edge (ENTRY_BLOCK_PTR));\n-\t      else\n-\t\tset_single_exit (loop, e);\n-\t    }\n-\t}\n-    }\n-\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      if (single_exit (loop) == single_succ_edge (ENTRY_BLOCK_PTR))\n-\tset_single_exit (loop, NULL);\n-    }\n-\n-  current_loops->state |= LOOPS_HAVE_MARKED_SINGLE_EXITS;\n-}\n-\n static void\n establish_preds (struct loop *loop)\n {\n@@ -486,6 +449,17 @@ canonicalize_loop_headers (void)\n #endif\n }\n \n+/* Allocates and returns new loop structure.  */\n+\n+struct loop *\n+alloc_loop (void)\n+{\n+  struct loop *loop = XCNEW (struct loop);\n+\n+  loop->exits.next = loop->exits.prev = &loop->exits;\n+  return loop;\n+}\n+\n /* Find all the natural loops in the function and save in LOOPS structure and\n    recalculate loop_depth information in basic block structures.\n    Return the number of natural loops found.  */\n@@ -571,7 +545,7 @@ flow_loops_find (struct loops *loops)\n   loops->larray = VEC_alloc (loop_p, heap, num_loops + 1);\n \n   /* Dummy loop containing whole function.  */\n-  root = XCNEW (struct loop);\n+  root = alloc_loop ();\n   root->num_nodes = n_basic_blocks;\n   root->latch = EXIT_BLOCK_PTR;\n   root->header = ENTRY_BLOCK_PTR;\n@@ -608,7 +582,7 @@ flow_loops_find (struct loops *loops)\n \n \t  header = BASIC_BLOCK (rc_order[b]);\n \n-\t  loop = XCNEW (struct loop);\n+\t  loop = alloc_loop ();\n \t  VEC_quick_push (loop_p, loops->larray, loop);\n \n \t  loop->header = header;\n@@ -638,6 +612,7 @@ flow_loops_find (struct loops *loops)\n \n   sbitmap_free (headers);\n \n+  loops->exits = NULL;\n   loops->state = 0;\n   return VEC_length (loop_p, loops->larray);\n }\n@@ -799,6 +774,181 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   return blocks;\n }\n \n+/* Hash function for struct loop_exit.  */\n+\n+static hashval_t\n+loop_exit_hash (const void *ex)\n+{\n+  struct loop_exit *exit = (struct loop_exit *) ex;\n+\n+  return htab_hash_pointer (exit->e);\n+}\n+\n+/* Equality function for struct loop_exit.  Compares with edge.  */\n+\n+static int\n+loop_exit_eq (const void *ex, const void *e)\n+{\n+  struct loop_exit *exit = (struct loop_exit *) ex;\n+\n+  return exit->e == e;\n+}\n+\n+/* Frees the list of loop exit descriptions EX.  */\n+\n+static void\n+loop_exit_free (void *ex)\n+{\n+  struct loop_exit *exit = (struct loop_exit *) ex, *next;\n+\n+  for (; exit; exit = next)\n+    {\n+      next = exit->next_e;\n+\t  \n+      exit->next->prev = exit->prev;\n+      exit->prev->next = exit->next;\n+\n+      free (exit);\n+    }\n+}\n+\n+/* Returns the list of records for E as an exit of a loop.  */\n+\n+static struct loop_exit *\n+get_exit_descriptions (edge e)\n+{\n+  return htab_find_with_hash (current_loops->exits, e,\n+\t\t\t      htab_hash_pointer (e));\n+}\n+\n+/* Updates the lists of loop exits in that E appears.\n+   If REMOVED is true, E is being removed, and we\n+   just remove it from the lists of exits.\n+   If NEW_EDGE is true and E is not a loop exit, we\n+   do not try to remove it from loop exit lists.  */\n+\n+void\n+rescan_loop_exit (edge e, bool new_edge, bool removed)\n+{\n+  void **slot;\n+  struct loop_exit *exits = NULL, *exit;\n+  struct loop *aloop, *cloop;\n+\n+  if ((current_loops->state & LOOPS_HAVE_RECORDED_EXITS) == 0)\n+    return;\n+\n+  if (!removed\n+      && e->src->loop_father != NULL\n+      && e->dest->loop_father != NULL\n+      && !flow_bb_inside_loop_p (e->src->loop_father, e->dest))\n+    {\n+      cloop = find_common_loop (e->src->loop_father, e->dest->loop_father);\n+      for (aloop = e->src->loop_father;\n+\t   aloop != cloop;\n+\t   aloop = aloop->outer)\n+\t{\n+\t  exit = XNEW (struct loop_exit);\n+\t  exit->e = e;\n+\n+\t  exit->next = aloop->exits.next;\n+\t  exit->prev = &aloop->exits;\n+\t  exit->next->prev = exit;\n+\t  exit->prev->next = exit;\n+\n+\t  exit->next_e = exits;\n+\t  exits = exit;\n+\t}\n+    } \n+\n+  if (!exits && new_edge)\n+    return;\n+\n+  slot = htab_find_slot_with_hash (current_loops->exits, e,\n+\t\t\t\t   htab_hash_pointer (e),\n+\t\t\t\t   exits ? INSERT : NO_INSERT);\n+  if (!slot)\n+    return;\n+\n+  if (exits)\n+    {\n+      if (*slot)\n+\tloop_exit_free (*slot);\n+      *slot = exits;\n+    }\n+  else\n+    htab_clear_slot (current_loops->exits, slot);\n+}\n+\n+/* For each loop, record list of exit edges, and start maintaining these\n+   lists.  */\n+\n+void\n+record_loop_exits (void)\n+{\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+\n+  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n+    return;\n+  current_loops->state |= LOOPS_HAVE_RECORDED_EXITS;\n+\n+  gcc_assert (current_loops->exits == NULL);\n+  current_loops->exits = htab_create (2 * number_of_loops (),\n+\t\t\t\t      loop_exit_hash,\n+\t\t\t\t      loop_exit_eq,\n+\t\t\t\t      loop_exit_free);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  rescan_loop_exit (e, true, false);\n+\t}\n+    }\n+}\n+\n+/* Dumps information about the exit in *SLOT to FILE.\n+   Callback for htab_traverse.  */\n+\n+static int\n+dump_recorded_exit (void **slot, void *file)\n+{\n+  struct loop_exit *exit = *slot;\n+  unsigned n = 0;\n+  edge e = exit->e;\n+\n+  for (; exit != NULL; exit = exit->next_e)\n+    n++;\n+\n+  fprintf (file, \"Edge %d->%d exits %u loops\\n\",\n+\t   e->src->index, e->dest->index, n);\n+\n+  return 1;\n+}\n+\n+/* Dumps the recorded exits of loops to FILE.  */\n+\n+extern void dump_recorded_exits (FILE *);\n+void\n+dump_recorded_exits (FILE *file)\n+{\n+  if (!current_loops->exits)\n+    return;\n+  htab_traverse (current_loops->exits, dump_recorded_exit, file);\n+}\n+\n+/* Releases lists of loop exits.  */\n+\n+void\n+release_recorded_exits (void)\n+{\n+  gcc_assert (current_loops->state & LOOPS_HAVE_RECORDED_EXITS);\n+  htab_delete (current_loops->exits);\n+  current_loops->exits = NULL;\n+  current_loops->state &= ~LOOPS_HAVE_RECORDED_EXITS;\n+}\n+\n /* Returns the list of the exit edges of a LOOP.  */\n \n VEC (edge, heap) *\n@@ -809,15 +959,28 @@ get_loop_exit_edges (const struct loop *loop)\n   unsigned i;\n   basic_block *body;\n   edge_iterator ei;\n+  struct loop_exit *exit;\n \n   gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n-  body = get_loop_body (loop);\n-  for (i = 0; i < loop->num_nodes; i++)\n-    FOR_EACH_EDGE (e, ei, body[i]->succs)\n-      if (!flow_bb_inside_loop_p (loop, e->dest))\n-\tVEC_safe_push (edge, heap, edges, e);\n-  free (body);\n+  /* If we maintain the lists of exits, use them.  Otherwise we must\n+     scan the body of the loop.  */\n+  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n+    {\n+      for (exit = loop->exits.next; exit->e; exit = exit->next)\n+\tVEC_safe_push (edge, heap, edges, exit->e);\n+    }\n+  else\n+    {\n+      body = get_loop_body (loop);\n+      for (i = 0; i < loop->num_nodes; i++)\n+\tFOR_EACH_EDGE (e, ei, body[i]->succs)\n+\t  {\n+\t    if (!flow_bb_inside_loop_p (loop, e->dest))\n+\t      VEC_safe_push (edge, heap, edges, e);\n+\t  }\n+      free (body);\n+    }\n \n   return edges;\n }\n@@ -846,29 +1009,51 @@ num_loop_branches (const struct loop *loop)\n void\n add_bb_to_loop (basic_block bb, struct loop *loop)\n {\n-   int i;\n-\n-   gcc_assert (bb->loop_father == NULL);\n-   bb->loop_father = loop;\n-   bb->loop_depth = loop->depth;\n-   loop->num_nodes++;\n-   for (i = 0; i < loop->depth; i++)\n-     loop->pred[i]->num_nodes++;\n+  int i;\n+  edge_iterator ei;\n+  edge e;\n+\n+  gcc_assert (bb->loop_father == NULL);\n+  bb->loop_father = loop;\n+  bb->loop_depth = loop->depth;\n+  loop->num_nodes++;\n+  for (i = 0; i < loop->depth; i++)\n+    loop->pred[i]->num_nodes++;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      rescan_loop_exit (e, true, false);\n+    }\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      rescan_loop_exit (e, true, false);\n+    }\n }\n \n /* Remove basic block BB from loops.  */\n void\n remove_bb_from_loops (basic_block bb)\n {\n-   int i;\n-   struct loop *loop = bb->loop_father;\n-\n-   gcc_assert (loop != NULL);\n-   loop->num_nodes--;\n-   for (i = 0; i < loop->depth; i++)\n-     loop->pred[i]->num_nodes--;\n-   bb->loop_father = NULL;\n-   bb->loop_depth = 0;\n+  int i;\n+  struct loop *loop = bb->loop_father;\n+  edge_iterator ei;\n+  edge e;\n+\n+  gcc_assert (loop != NULL);\n+  loop->num_nodes--;\n+  for (i = 0; i < loop->depth; i++)\n+    loop->pred[i]->num_nodes--;\n+  bb->loop_father = NULL;\n+  bb->loop_depth = 0;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      rescan_loop_exit (e, false, true);\n+    }\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      rescan_loop_exit (e, false, true);\n+    }\n }\n \n /* Finds nearest common ancestor in loop tree for given loops.  */\n@@ -951,6 +1136,7 @@ verify_loop_structure (void)\n   edge e;\n   unsigned num = number_of_loops ();\n   loop_iterator li;\n+  struct loop_exit *exit, *mexit;\n \n   /* Check sizes.  */\n   sizes = XCNEWVEC (unsigned, num);\n@@ -1088,9 +1274,49 @@ verify_loop_structure (void)\n       free (irreds);\n     }\n \n-  /* Check the single_exit.  */\n-  if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+  /* Check the recorded loop exits.  */\n+  FOR_EACH_LOOP (li, loop, 0)\n     {\n+      if (loop->exits.e != NULL)\n+\t{\n+\t  error (\"corrupted head of the exits list of loop %d\",\n+\t\t loop->num);\n+\t  err = 1;\n+\t}\n+      else\n+\t{\n+\t  /* Check that the list forms a cycle, and all elements except\n+\t     for the head are nonnull.  */\n+\t  for (mexit = &loop->exits, exit = mexit->next, i = 0;\n+\t       exit->e && exit != mexit;\n+\t       exit = exit->next)\n+\t    {\n+\t      if (i++ & 1)\n+\t\tmexit = mexit->next;\n+\t    }\n+\n+\t  if (exit != &loop->exits)\n+\t    {\n+\t      error (\"corrupted exits list of loop %d\", loop->num);\n+\t      err = 1;\n+\t    }\n+\t}\n+\n+      if ((current_loops->state & LOOPS_HAVE_RECORDED_EXITS) == 0)\n+\t{\n+\t  if (loop->exits.next != &loop->exits)\n+\t    {\n+\t      error (\"nonempty exits list of loop %d, but exits are not recorded\",\n+\t\t     loop->num);\n+\t      err = 1;\n+\t    }\n+\t}\n+    }\n+\n+  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n+    {\n+      unsigned n_exits = 0, eloops;\n+\n       memset (sizes, 0, sizeof (unsigned) * num);\n       FOR_EACH_BB (bb)\n \t{\n@@ -1099,50 +1325,53 @@ verify_loop_structure (void)\n \t    continue;\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      if (e->dest == EXIT_BLOCK_PTR)\n-\t\tcontinue;\n-\n \t      if (flow_bb_inside_loop_p (bb->loop_father, e->dest))\n \t\tcontinue;\n \n+\t      n_exits++;\n+\t      exit = get_exit_descriptions (e);\n+\t      if (!exit)\n+\t\t{\n+\t\t  error (\"Exit %d->%d not recorded\", \n+\t\t\t e->src->index, e->dest->index);\n+\t\t  err = 1;\n+\t\t}\n+\t      eloops = 0;\n+\t      for (; exit; exit = exit->next_e)\n+\t\teloops++;\n+\n \t      for (loop = bb->loop_father;\n \t\t   loop != e->dest->loop_father;\n \t\t   loop = loop->outer)\n \t\t{\n+\t\t  eloops--;\n \t\t  sizes[loop->num]++;\n-\t\t  if (single_exit (loop)\n-\t\t      && single_exit (loop) != e)\n-\t\t    {\n-\t\t      error (\"wrong single exit %d->%d recorded for loop %d\",\n-\t\t\t     single_exit (loop)->src->index,\n-\t\t\t     single_exit (loop)->dest->index,\n-\t\t\t     loop->num);\n-\t\t      error (\"right exit is %d->%d\",\n-\t\t\t     e->src->index, e->dest->index);\n-\t\t      err = 1;\n-\t\t    }\n+\t\t}\n+\n+\t      if (eloops != 0)\n+\t\t{\n+\t\t  error (\"Wrong list of exited loops for edge  %d->%d\", \n+\t\t\t e->src->index, e->dest->index);\n+\t\t  err = 1;\n \t\t}\n \t    }\n \t}\n \n-      FOR_EACH_LOOP (li, loop, 0)\n+      if (n_exits != htab_elements (current_loops->exits))\n \t{\n-\t  i = loop->num;\n-\n-\t  if (sizes[i] == 1\n-\t      && !single_exit (loop))\n-\t    {\n-\t      error (\"single exit not recorded for loop %d\", loop->num);\n-\t      err = 1;\n-\t    }\n+\t  error (\"Too many loop exits recorded\");\n+\t  err = 1;\n+\t}\n \n-\t  if (sizes[i] != 1\n-\t      && single_exit (loop))\n+      FOR_EACH_LOOP (li, loop, 0)\n+\t{\n+\t  eloops = 0;\n+\t  for (exit = loop->exits.next; exit->e; exit = exit->next)\n+\t    eloops++;\n+\t  if (eloops != sizes[loop->num])\n \t    {\n-\t      error (\"loop %d should not have single exit (%d -> %d)\",\n-\t\t     loop->num,\n-\t\t     single_exit (loop)->src->index,\n-\t\t     single_exit (loop)->dest->index);\n+\t      error (\"%d exits recorded for loop %d (having %d exits)\",\n+\t\t     eloops, loop->num, sizes[loop->num]);\n \t      err = 1;\n \t    }\n \t}\n@@ -1184,18 +1413,19 @@ loop_exit_edge_p (const struct loop *loop, edge e)\n }\n \n /* Returns the single exit edge of LOOP, or NULL if LOOP has either no exit\n-   or more than one exit.  */\n+   or more than one exit.  If loops do not have the exits recorded, NULL\n+   is returned always.  */\n \n edge\n single_exit (const struct loop *loop)\n {\n-  return loop->single_exit_;\n-}\n+  struct loop_exit *exit = loop->exits.next;\n \n-/* Records E as a single exit edge of LOOP.  */\n+  if ((current_loops->state & LOOPS_HAVE_RECORDED_EXITS) == 0)\n+    return NULL;\n \n-void\n-set_single_exit (struct loop *loop, edge e)\n-{\n-  loop->single_exit_ = e;\n+  if (exit->e && exit->next == &loop->exits)\n+    return exit->e;\n+  else\n+    return NULL;\n }"}, {"sha": "ec1149c8bb822d2d4cf0f548c0d8f5e21abddffc", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -74,6 +74,21 @@ struct nb_iter_bound\n   struct nb_iter_bound *next;\n };\n \n+/* Description of the loop exit.  */\n+\n+struct loop_exit\n+{\n+  /* The exit edge.  */\n+  edge e;\n+\n+  /* Previous and next exit in the list of the exits of the loop.  */\n+  struct loop_exit *prev;\n+  struct loop_exit *next;\n+\n+  /* Next element in the list of loops from that E exits.  */\n+  struct loop_exit *next_e;\n+};\n+\n /* Structure to hold information for each natural loop.  */\n struct loop\n {\n@@ -142,10 +157,8 @@ struct loop\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n \n-  /* If not NULL, loop has just single exit edge stored here (edges to the\n-     EXIT_BLOCK_PTR do not count.  Do not use directly; this field should\n-     only be accessed via single_exit/set_single_exit functions.  */\n-  edge single_exit_;\n+  /* Head of the cyclic list of the exits of the loop.  */\n+  struct loop_exit exits;\n };\n \n /* Flags for state of loop structure.  */\n@@ -154,7 +167,7 @@ enum\n   LOOPS_HAVE_PREHEADERS = 1,\n   LOOPS_HAVE_SIMPLE_LATCHES = 2,\n   LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4,\n-  LOOPS_HAVE_MARKED_SINGLE_EXITS = 8\n+  LOOPS_HAVE_RECORDED_EXITS = 8\n };\n \n #define LOOPS_NORMAL (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES \\\n@@ -173,6 +186,11 @@ struct loops\n   /* Array of the loops.  */\n   VEC (loop_p, heap) *larray;\n \n+  /* Maps edges to the list of their descriptions as loop exits.  Edges\n+     whose sources or destinations have loop_father == NULL (which may\n+     happen during the cfg manipulations) should not appear in EXITS.  */\n+  htab_t exits;\n+\n   /* Pointer to root of loop hierarchy tree.  */\n   struct loop *tree_root;\n };\n@@ -184,11 +202,14 @@ extern void flow_loops_dump (FILE *,\n \t\t\t     void (*)(const struct loop *, FILE *, int), int);\n extern void flow_loop_dump (const struct loop *, FILE *,\n \t\t\t    void (*)(const struct loop *, FILE *, int), int);\n+struct loop *alloc_loop (void);\n extern void flow_loop_free (struct loop *);\n int flow_loop_nodes_find (basic_block, struct loop *);\n void fix_loop_structure (bitmap changed_bbs);\n void mark_irreducible_loops (void);\n-void mark_single_exit_loops (void);\n+void release_recorded_exits (void);\n+void record_loop_exits (void);\n+void rescan_loop_exit (edge, bool, bool);\n \n /* Loop data structure manipulation/querying.  */\n extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n@@ -210,7 +231,6 @@ extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n extern VEC (edge, heap) *get_loop_exit_edges (const struct loop *);\n edge single_exit (const struct loop *);\n-void set_single_exit (struct loop *, edge);\n extern unsigned num_loop_branches (const struct loop *);\n \n extern edge loop_preheader_edge (const struct loop *);"}, {"sha": "222bcb3623c14900816368ff0aedc2804996e916", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 9, "deletions": 81, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -425,7 +425,7 @@ loopify (edge latch_edge, edge header_edge,\n   basic_block *dom_bbs, *body;\n   unsigned n_dom_bbs, i;\n   sbitmap seen;\n-  struct loop *loop = XCNEW (struct loop);\n+  struct loop *loop = alloc_loop ();\n   struct loop *outer = succ_bb->loop_father->outer;\n   int freq;\n   gcov_type cnt;\n@@ -643,7 +643,7 @@ struct loop *\n duplicate_loop (struct loop *loop, struct loop *target)\n {\n   struct loop *cloop;\n-  cloop = XCNEW (struct loop);\n+  cloop = alloc_loop ();\n   place_new_loop (cloop);\n \n   /* Mark the new loop as copy of LOOP.  */\n@@ -746,65 +746,6 @@ can_duplicate_loop_p (struct loop *loop)\n   return ret;\n }\n \n-/* The NBBS blocks in BBS will get duplicated and the copies will be placed\n-   to LOOP.  Update the single_exit information in superloops of LOOP.  */\n-\n-static void\n-update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n-\t\t\t\t       struct loop *loop)\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < nbbs; i++)\n-    bbs[i]->flags |= BB_DUPLICATED;\n-\n-  for (; loop->outer; loop = loop->outer)\n-    {\n-      if (!single_exit (loop))\n-\tcontinue;\n-\n-      if (single_exit (loop)->src->flags & BB_DUPLICATED)\n-\tset_single_exit (loop, NULL);\n-    }\n-\n-  for (i = 0; i < nbbs; i++)\n-    bbs[i]->flags &= ~BB_DUPLICATED;\n-}\n-\n-/* Updates single exit information for the copy of LOOP.  */\n-\n-static void\n-update_single_exit_for_duplicated_loop (struct loop *loop)\n-{\n-  struct loop *copy = loop->copy;\n-  basic_block src, dest;\n-  edge exit = single_exit (loop);\n-\n-  if (!exit)\n-    return;\n-\n-  src = get_bb_copy (exit->src);\n-  dest = exit->dest;\n-  if (dest->flags & BB_DUPLICATED)\n-    dest = get_bb_copy (dest);\n-\n-  exit = find_edge (src, dest);\n-  gcc_assert (exit != NULL);\n-  set_single_exit (copy, exit);\n-}\n-\n-/* Updates single exit information for copies of ORIG_LOOPS and their subloops.\n-   N is the number of the loops in the ORIG_LOOPS array.  */\n-\n-static void\n-update_single_exit_for_duplicated_loops (struct loop *orig_loops[], unsigned n)\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < n; i++)\n-    update_single_exit_for_duplicated_loop (orig_loops[i]);\n-}\n-\n /* Sets probability and count of edge E to zero.  The probability and count\n    is redistributed evenly to the remaining edges coming from E->src.  */\n \n@@ -1018,10 +959,6 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       first_active_latch = latch;\n     }\n \n-  /* Update the information about single exits.  */\n-  if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-    update_single_exits_after_duplication (bbs, n, target);\n-\n   spec_edges[SE_ORIG] = orig;\n   spec_edges[SE_LATCH] = latch_edge;\n \n@@ -1036,15 +973,6 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t\tplace_after);\n       place_after = new_spec_edges[SE_LATCH]->src;\n \n-      if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-\t{\n-\t  for (i = 0; i < n; i++)\n-\t    bbs[i]->flags |= BB_DUPLICATED;\n-\t  update_single_exit_for_duplicated_loops (orig_loops, n_orig_loops);\n-\t  for (i = 0; i < n; i++)\n-\t    bbs[i]->flags &= ~BB_DUPLICATED;\n-\t}\n-\n       if (flags & DLTHE_RECORD_COPY_NUMBER)\n \tfor (i = 0; i < n; i++)\n \t  {\n@@ -1378,7 +1306,7 @@ loop_version (struct loop *loop,\n \t      bool place_after)\n {\n   basic_block first_head, second_head;\n-  edge entry, latch_edge, exit, true_edge, false_edge;\n+  edge entry, latch_edge, true_edge, false_edge;\n   int irred_flag;\n   struct loop *nloop;\n   basic_block cond_bb;\n@@ -1425,10 +1353,6 @@ loop_version (struct loop *loop,\n \t\t   false /* Do not redirect all edges.  */,\n \t\t   then_scale, else_scale);\n \n-  exit = single_exit (loop);\n-  if (exit)\n-    set_single_exit (nloop, find_edge (get_bb_copy (exit->src), exit->dest));\n-\n   /* loopify redirected latch_edge. Update its PENDING_STMTS.  */\n   lv_flush_pending_stmts (latch_edge);\n \n@@ -1539,8 +1463,12 @@ fix_loop_structure (bitmap changed_bbs)\n       bb->aux = NULL;\n     }\n \n-  if (current_loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-    mark_single_exit_loops ();\n   if (current_loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n     mark_irreducible_loops ();\n+\n+  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n+    {\n+      release_recorded_exits ();\n+      record_loop_exits ();\n+    }\n }"}, {"sha": "fee30f8ec655c12a2c896c98e0f472d6fe481256", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -108,14 +108,16 @@ edges in the strongly connected components that are not natural loops\n flag is not set for blocks and edges that belong to natural loops that\n are in such an irreducible region (but it is set for the entry and exit\n edges of such a loop, if they lead to/from this region).\n-@item @code{LOOPS_HAVE_MARKED_SINGLE_EXITS}: If a loop has exactly one\n-exit edge, this edge is recorded in the loop structure.  @code{single_exit}\n-function can be used to retrieve this edge.\n+@item @code{LOOPS_HAVE_RECORDED_EXITS}: The lists of exits are recorded\n+and updated for each loop.  This makes some functions (e.g.,\n+@code{get_loop_exit_edges}) more efficient.  Some functions (e.g.,\n+@code{single_exit}) can be used only if the lists of exits are\n+recorded.\n @end itemize\n \n These properties may also be computed/enforced later, using functions\n @code{create_preheaders}, @code{force_single_succ_latches},\n-@code{mark_irreducible_loops} and @code{mark_single_exit_loops}.\n+@code{mark_irreducible_loops} and @code{record_loop_exits}.\n \n The memory occupied by the loops structures should be freed with\n @code{loop_optimizer_finalize} function."}, {"sha": "60e78a25072057008f4320335866e02fc108d918", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -2511,7 +2511,6 @@ perfect_nestify (struct loop *loop,\n   newloop = duplicate_loop (loop, olddest->loop_father);  \n   newloop->header = headerbb;\n   newloop->latch = latchbb;\n-  set_single_exit (newloop, e);\n   add_bb_to_loop (latchbb, newloop);\n   add_bb_to_loop (bodybb, newloop);\n   add_bb_to_loop (headerbb, newloop);"}, {"sha": "1f049c1ad4de9c5175ac1c73ce24dac54e33a6ad", "filename": "gcc/loop-init.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -88,8 +88,8 @@ loop_optimizer_init (unsigned flags)\n   if (flags & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n     mark_irreducible_loops ();\n \n-  if (flags & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n-    mark_single_exit_loops ();\n+  if (flags & LOOPS_HAVE_RECORDED_EXITS)\n+    record_loop_exits ();\n \n   /* Dump loops.  */\n   flow_loops_dump (dump_file, NULL, 1);\n@@ -118,6 +118,8 @@ loop_optimizer_finalize (void)\n     }\n \n   /* Clean up.  */\n+  if (current_loops->state & LOOPS_HAVE_RECORDED_EXITS)\n+    release_recorded_exits ();\n   flow_loops_free (current_loops);\n   free (current_loops);\n   current_loops = NULL;"}, {"sha": "1b6f7eec13c36592a1b6d8deee453efdabd86063", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -892,7 +892,7 @@ sms_schedule (void)\n   gcov_type trip_count = 0;\n \n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n-\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n+\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n   if (!current_loops)\n     return;  /* There are no loops to schedule.  */\n "}, {"sha": "580692104d9fd979311c538efc82a72424fd076c", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -895,6 +895,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \t\t\t   tree_block_label (rest));\n   bsi_insert_after (&bsi, exit_if, BSI_NEW_STMT);\n   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n+  rescan_loop_exit (new_exit, true, false);\n   new_exit->count = 0;\n   new_exit->probability = 0;\n   new_nonexit = single_pred_edge (loop->latch);"}, {"sha": "f6392c5392c78f8e23574ad4267d698114842adb", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -44,7 +44,7 @@ static void\n tree_loop_optimizer_init (void)\n {\n   loop_optimizer_init (LOOPS_NORMAL\n-\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n+\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n   if (!current_loops)\n     return;\n "}, {"sha": "c3b64e2ed6e4bb1159049513c9d36176eb11c37f", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6270df4c21eb9114e9023f0da513e68cf465553d/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6270df4c21eb9114e9023f0da513e68cf465553d", "patch": "@@ -862,7 +862,6 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n   copy_bbs (bbs, loop->num_nodes, new_bbs,\n \t    &exit, 1, &new_exit, NULL,\n \t    e->src);\n-  set_single_exit (new_loop, new_exit);\n \n   /* Duplicating phi args at exit bbs as coming \n      also from exit of duplicated loop.  */"}]}