{"sha": "8434cfc76762f3306fca614b875e3d7625ff001f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQzNGNmYzc2NzYyZjMzMDZmY2E2MTRiODc1ZTNkNzYyNWZmMDAxZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-16T13:14:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-16T13:14:24Z"}, "message": "[multiple changes]\n\n2015-10-16  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration):\n\tIndefinite or limited library level objects are now returned on\n\tthe heap.\n\t* exp_ch7.adb (Build_Finalization_Master): Add formal\n\tparameter For_Lib_Level. Add context specific insertion for a\n\tfinalization master created for an access result type related\n\tto a build-in-place function call used to initialize a library\n\tlevel object.\n\t* exp_ch7.ads (Build_Finalization_Master): Add formal parameter\n\tFor_Lib_Level. Update the comment on usage.\n\t* sem_util.adb (Mark_Coextensions): Code cleanup.\n\n2015-10-16  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb (For_Every_Project_Imported_Context): Fix handling\n\tof aggregated projects with duplicate names.\n\t* a-ngelfu.ads: Minor whitespace fix.\n\nFrom-SVN: r228899", "tree": {"sha": "0c182a7cb8e311b958c08b38b325e33b68455359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c182a7cb8e311b958c08b38b325e33b68455359"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8434cfc76762f3306fca614b875e3d7625ff001f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8434cfc76762f3306fca614b875e3d7625ff001f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8434cfc76762f3306fca614b875e3d7625ff001f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8434cfc76762f3306fca614b875e3d7625ff001f/comments", "author": null, "committer": null, "parents": [{"sha": "f99a9fea99d0fb4ff9d065c7ce558e78fd6900b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99a9fea99d0fb4ff9d065c7ce558e78fd6900b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f99a9fea99d0fb4ff9d065c7ce558e78fd6900b9"}], "stats": {"total": 168, "additions": 124, "deletions": 44}, "files": [{"sha": "a4696b5ad4ef9aae374a6bfdbd7207ab20e6ebaa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -1,3 +1,23 @@\n+2015-10-16  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration):\n+\tIndefinite or limited library level objects are now returned on\n+\tthe heap.\n+\t* exp_ch7.adb (Build_Finalization_Master): Add formal\n+\tparameter For_Lib_Level. Add context specific insertion for a\n+\tfinalization master created for an access result type related\n+\tto a build-in-place function call used to initialize a library\n+\tlevel object.\n+\t* exp_ch7.ads (Build_Finalization_Master): Add formal parameter\n+\tFor_Lib_Level. Update the comment on usage.\n+\t* sem_util.adb (Mark_Coextensions): Code cleanup.\n+\n+2015-10-16  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb (For_Every_Project_Imported_Context): Fix handling\n+\tof aggregated projects with duplicate names.\n+\t* a-ngelfu.ads: Minor whitespace fix.\n+\n 2015-10-16  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Build_Predicate_Functions): The expression for"}, {"sha": "8b257b62b41ba6234423d8038d2d16e368df240b", "filename": "gcc/ada/a-ngelfu.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fa-ngelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fa-ngelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngelfu.ads?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2012-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2012-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -61,8 +61,7 @@ package Ada.Numerics.Generic_Elementary_Functions is\n \n        and then (if X >= Float_Type'Succ (0.0) then Sqrt'Result > 0.0);\n \n-   function Log (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Log (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 1.0 then Log'Result = 0.0);\n \n    function Log (X, Base : Float_Type'Base) return Float_Type'Base with"}, {"sha": "4733eb4f83a5bb22ed5dcfde9396e47febcc391c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -8921,13 +8921,13 @@ package body Exp_Ch6 is\n             end if;\n \n             Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call,\n-               Function_Id,\n+              (Function_Call  => Func_Call,\n+               Function_Id    => Function_Id,\n                Alloc_Form_Exp =>\n                  New_Occurrence_Of\n-                   (Build_In_Place_Formal (Enclosing_Func, BIP_Alloc_Form),\n-                    Loc),\n-               Pool_Actual => Pool_Actual);\n+                   (Build_In_Place_Formal\n+                     (Enclosing_Func, BIP_Alloc_Form), Loc),\n+               Pool_Actual    => Pool_Actual);\n \n          --  Otherwise, if enclosing function has a definite result subtype,\n          --  then caller allocation will be used.\n@@ -8979,6 +8979,35 @@ package body Exp_Ch6 is\n          Add_Unconstrained_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n+      --  The allocation for indefinite library level objects occurs on the\n+      --  heap as opposed to the secondary stack. This accomodates DLLs where\n+      --  the secondary stack is destroyed after each library unload. This is\n+      --  a hybrid mechanism where a stack-allocated object lives on the heap.\n+\n+      elsif Is_Library_Level_Entity (Defining_Identifier (Object_Decl))\n+        and then not Restriction_Active (No_Implicit_Heap_Allocations)\n+      then\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+         Caller_Object := Empty;\n+\n+         --  Create a finalization master for the access result type to ensure\n+         --  that the heap allocation can properly chain the object and later\n+         --  finalize it when the library unit does out of scope.\n+\n+         if Needs_Finalization (Etype (Func_Call)) then\n+            Build_Finalization_Master\n+              (Typ            => Ptr_Typ,\n+               For_Lib_Level  => True,\n+               Insertion_Node => Ptr_Typ_Decl);\n+\n+            Fmaster_Actual :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  New_Occurrence_Of (Finalization_Master (Ptr_Typ), Loc),\n+                Attribute_Name => Name_Unrestricted_Access);\n+         end if;\n+\n       --  In other indefinite cases, pass an indication to do the allocation\n       --  on the secondary stack and set Caller_Object to Empty so that a null\n       --  value will be passed for the caller's object address. A transient"}, {"sha": "2f90c92cbe326f4bbeaf699ad9bd04717b6bedf4", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -763,6 +763,7 @@ package body Exp_Ch7 is\n    procedure Build_Finalization_Master\n      (Typ            : Entity_Id;\n       For_Anonymous  : Boolean   := False;\n+      For_Lib_Level  : Boolean   := False;\n       For_Private    : Boolean   := False;\n       Context_Scope  : Entity_Id := Empty;\n       Insertion_Node : Node_Id   := Empty)\n@@ -1039,6 +1040,15 @@ package body Exp_Ch7 is\n \n             Pop_Scope;\n \n+         --  The finalization master belongs to an access result type related\n+         --  to a build-in-place function call used to initialize a library\n+         --  level object. The master must be inserted in front of the access\n+         --  result type declaration denoted by Insertion_Node.\n+\n+         elsif For_Lib_Level then\n+            pragma Assert (Present (Insertion_Node));\n+            Insert_Actions (Insertion_Node, Actions);\n+\n          --  Otherwise the finalization master and its initialization become a\n          --  part of the freeze node.\n "}, {"sha": "3f90f31580ea7100cca88d2117017082ff7e781f", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -100,18 +100,21 @@ package Exp_Ch7 is\n    procedure Build_Finalization_Master\n      (Typ            : Entity_Id;\n       For_Anonymous  : Boolean   := False;\n+      For_Lib_Level  : Boolean   := False;\n       For_Private    : Boolean   := False;\n       Context_Scope  : Entity_Id := Empty;\n       Insertion_Node : Node_Id   := Empty);\n    --  Build a finalization master for an access type. The designated type may\n    --  not necessarely be controlled or need finalization actions depending on\n    --  the context. Flag For_Anonymous must be set when creating a master for\n-   --  an anonymous access type. Flag For_Private must be set when the\n-   --  designated type contains a private component. Parameters Context_Scope\n-   --  and Insertion_Node must be used in conjunction with flags For_Anonymous\n-   --  and For_Private. Context_Scope is the scope of the context where the\n-   --  finalization master must be analyzed. Insertion_Node is the insertion\n-   --  point before which the master is inserted.\n+   --  an anonymous access type. Flag For_Lib_Level must be set when creating\n+   --  a master for a build-in-place function call access result type. Flag\n+   --  For_Private must be set when the designated type contains a private\n+   --  component. Parameters Context_Scope and Insertion_Node must be used in\n+   --  conjunction with flags For_Anonymous and For_Private. Context_Scope is\n+   --  the scope of the context where the finalization master must be analyzed.\n+   --  Insertion_Node is the insertion point before which the master is to be\n+   --  inserted.\n \n    procedure Build_Late_Proc (Typ : Entity_Id; Nam : Name_Id);\n    --  Build one controlling procedure when a late body overrides one of"}, {"sha": "3d71bde387459c6acc5be5342bf4410c4bf93b9a", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -592,9 +592,14 @@ package body Prj is\n          In_Aggregate_Lib      : Boolean;\n          From_Encapsulated_Lib : Boolean)\n       is\n+         package Name_Id_Set is\n+           new Ada.Containers.Ordered_Sets (Element_Type => Path_Name_Type);\n+\n          Seen_Name : Name_Id_Set.Set;\n          --  This set is needed to ensure that we do not handle the same\n          --  project twice in the context of aggregate libraries.\n+         --  Since duplicate project names are possible in the context of\n+         --  aggregated projects, we need to check the full paths\n \n          procedure Recursive_Check\n            (Project               : Project_Id;\n@@ -673,12 +678,12 @@ package body Prj is\n          --  Start of processing for Recursive_Check\n \n          begin\n-            if not Seen_Name.Contains (Project.Name) then\n+            if not Seen_Name.Contains (Project.Path.Name) then\n \n                --  Even if a project is aggregated multiple times in an\n                --  aggregated library, we will only return it once.\n \n-               Seen_Name.Include (Project.Name);\n+               Seen_Name.Include (Project.Path.Name);\n \n                if not Imported_First then\n                   Action"}, {"sha": "bd47c150a833349ef5493a04723ee87c6ca00e7b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8434cfc76762f3306fca614b875e3d7625ff001f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8434cfc76762f3306fca614b875e3d7625ff001f", "patch": "@@ -14214,41 +14214,55 @@ package body Sem_Util is\n    --  Start of processing Mark_Coextensions\n \n    begin\n-      case Nkind (Context_Nod) is\n+      --  An allocator that appears on the right hand side of an assignment is\n+      --  treated as a potentially dynamic coextension when the right hand side\n+      --  is an allocator or a qualified expression.\n \n-         --  Comment here ???\n+      --    Obj := new ...'(new Coextension ...);\n \n-         when N_Assignment_Statement    =>\n-            Is_Dynamic := Nkind (Expression (Context_Nod)) = N_Allocator;\n+      if Nkind (Context_Nod) = N_Assignment_Statement then\n+         Is_Dynamic :=\n+           Nkind_In (Expression (Context_Nod), N_Allocator,\n+                                               N_Qualified_Expression);\n \n-         --  An allocator that is a component of a returned aggregate\n-         --  must be dynamic.\n+      --  An allocator that appears within the expression of a simple return\n+      --  statement is treated as a potentially dynamic coextension when the\n+      --  expression is either aggregate, allocator or qualified expression.\n \n-         when N_Simple_Return_Statement =>\n-            declare\n-               Expr : constant Node_Id := Expression (Context_Nod);\n-            begin\n-               Is_Dynamic :=\n-                 Nkind (Expr) = N_Allocator\n-                   or else\n-                     (Nkind (Expr) = N_Qualified_Expression\n-                       and then Nkind (Expression (Expr)) = N_Aggregate);\n-            end;\n+      --    return (new Coextension ...);\n+      --    return new ...'(new Coextension ...);\n \n-         --  An alloctor within an object declaration in an extended return\n-         --  statement is of necessity dynamic.\n+      elsif Nkind (Context_Nod) = N_Simple_Return_Statement then\n+         Is_Dynamic :=\n+           Nkind_In (Expression (Context_Nod), N_Aggregate,\n+                                               N_Allocator,\n+                                               N_Qualified_Expression);\n \n-         when N_Object_Declaration =>\n-            Is_Dynamic := Nkind (Root_Nod) = N_Allocator\n-              or else\n-                Nkind (Parent (Context_Nod)) = N_Extended_Return_Statement;\n+      --  An alloctor that appears within the initialization expression of an\n+      --  object declaration is considered a potentially dynamic coextension\n+      --  when the initialization expression is an allocator or a qualified\n+      --  expression.\n \n-         --  This routine should not be called for constructs which may not\n-         --  contain coextensions.\n+      --    Obj : ... := new ...'(new Coextension ...);\n \n-         when others =>\n-            raise Program_Error;\n-      end case;\n+      --  A similar case arises when the object declaration is part of an\n+      --  extended return statement.\n+\n+      --    return Obj : ... := new ...'(new Coextension ...);\n+      --    return Obj : ... := (new Coextension ...);\n+\n+      elsif Nkind (Context_Nod) = N_Object_Declaration then\n+         Is_Dynamic :=\n+           Nkind_In (Root_Nod, N_Allocator, N_Qualified_Expression)\n+             or else\n+               Nkind (Parent (Context_Nod)) = N_Extended_Return_Statement;\n+\n+      --  This routine should not be called with constructs which may not\n+      --  contain coextensions.\n+\n+      else\n+         raise Program_Error;\n+      end if;\n \n       Mark_Allocators (Root_Nod);\n    end Mark_Coextensions;"}]}