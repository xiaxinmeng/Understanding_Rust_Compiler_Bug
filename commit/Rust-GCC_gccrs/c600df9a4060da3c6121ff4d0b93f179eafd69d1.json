{"sha": "c600df9a4060da3c6121ff4d0b93f179eafd69d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYwMGRmOWE0MDYwZGEzYzYxMjFmZjRkMGI5M2YxNzllYWZkNjlkMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-29T09:08:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-29T09:08:47Z"}, "message": "[AArch64] Add support for the SVE PCS\n\nThe AAPCS64 specifies that if a function takes arguments in SVE\nregisters or returns them in SVE registers, it must preserve all\nof Z8-Z23 and all of P4-P11.  (Normal functions only preserve the\nlow 64 bits of Z8-Z15 and clobber all of the predicate registers.)\n\nThis variation is known informally as the \"SVE PCS\" and functions\nthat use it are known informally as \"SVE functions\".  The SVE PCS\nis mutually interoperable with functions that follow the standard\nAAPCS64 rules and those that use the aarch64_vector_pcs attribute.\n(Note that it's an error to use the attribute for SVE functions.)\n\nOne complication -- although it's not really that complicated --\nis that SVE registers need to be saved at a VL-dependent offset while\nother registers need to be saved at a constant offset.  The easiest way\nof handling this seemed to be to group the SVE registers together below\nthe hard frame pointer.  In common cases, the frame pointer is then\nusually an easy-to-compute VL multiple above the stack pointer and a\nconstant amount below the incoming stack pointer.\n\nA bigger complication is that, because the base AAPCS64 specifies that\nonly the low 64 bits of V8-V15 are preserved by calls, the associated\nDWARF frame registers are also treated as 64 bits by the unwinder.\nThe 64 bits must also have the same layout as they would for a base\nAAPCS64 function, otherwise unwinding won't work correctly.  (This is\nactually a problem for the existing aarch64_vector_pcs support too,\nbut I'll fix that separately.)\n\nThis falls out naturally for little-endian targets but not for\nbig-endian targets.  The easiest way of meeting the requirement for them\nwas to use ST1D and LD1D to save and restore Z8-Z15, which also has the\nnice property of storing the 64 bits at the start of the slot.  However,\nusing ST1D and LD1D requires a spare predicate register, and since all\nof P0-P7 are either argument registers or call-preserved, we may need\nto spill P4 in order to save the vector registers, even if P4 wouldn't\nneed to be saved otherwise.\n\nSince Z16-Z23 are fully clobbered by base AAPCS64 functions, we don't\nneed to emit frame information for them at all.  This avoids having\nto decide whether the registers should be treated as having 64 bits\n(as for Z8-Z15), 128 bits (for Advanced SIMD) or the full SVE width.\n\nThere are two ways of dealing with stack-clash protection when\nsaving SVE registers:\n\n(1) If the area between the hard frame pointer and the incoming stack\n    pointer is allocated via a store with writeback (callee_adjust != 0),\n    the SVE save area is allocated separately and becomes the \"initial\"\n    allocation as far as stack-clash protection goes.  In this case\n    the store with writeback acts as a probe at the hard frame pointer\n    position.\n\n(2) If the area between the hard frame pointer and the incoming stack\n    pointer is allocated via aarch64_allocate_and_probe_stack_space,\n    the SVE save area is added to this initial allocation, so that the\n    SP ends up pointing at the SVE register saves.  It's then necessary\n    to use a temporary base register to save the non-SVE registers.\n    Setting up this temporary register requires a single instruction\n    only and so should be more efficient than doing two allocations\n    and probes.\n\nWhen SVE registers need to be saved, saving them below the frame pointer\nmakes it harder to rely on the LR save as a stack probe, since the LR\nregister's offset won't usually be a compile-time constant.  The patch\ncopes with that by using the lowest SVE register save as a stack probe\ntoo, and thus prevents the save from being shrink-wrapped if stack clash\nprotection is enabled.\n\nThe changelog describes the low-level details.\n\n2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* calls.c (pass_by_reference): Leave the target to decide whether\n\tPOLY_INT_CST-sized arguments should be passed by value or reference,\n\trather than forcing them to be passed by reference.\n\t(must_pass_in_stack_var_size): Likewise.\n\t* config/aarch64/aarch64.md (LAST_SAVED_REGNUM): Redefine from\n\tV31_REGNUM to P15_REGNUM.\n\t* config/aarch64/aarch64-protos.h (aarch64_init_cumulative_args):\n\tTake an extra \"silent_p\" parameter, defaulting to false.\n\t(aarch64_sve::svbool_type_p): Declare.\n\t(aarch64_sve::nvectors_if_data_type): Likewise.\n\t* config/aarch64/aarch64.h (NUM_PR_ARG_REGS): New macro.\n\t(aarch64_frame::reg_offset): Turn into poly_int64s.\n\t(aarch64_frame::save_regs_size): Likewise.\n\t(aarch64_frame::below_hard_fp_saved_regs_size): New field.\n\t(aarch64_frame::sve_callee_adjust): Likewise.\n\t(aarch64_frame::spare_reg_reg): Likewise.\n\t(ARM_PCS_SVE): New arm_pcs value.\n\t(CUMULATIVE_ARGS::aapcs_nprn): New field.\n\t(CUMULATIVE_ARGS::aapcs_nextnprn): Likewise.\n\t(CUMULATIVE_ARGS::silent_p): Likewise.\n\t(BITS_PER_SVE_PRED): New macro.\n\t* config/aarch64/aarch64.c (handle_aarch64_vector_pcs_attribute): New\n\tfunction.  Reject aarch64_vector_pcs attributes on SVE functions.\n\t(aarch64_attribute_table): Use the above handler.\n\t(aarch64_sve_abi): New function.\n\t(aarch64_sve_argument_p): Likewise.\n\t(aarch64_returns_value_in_sve_regs_p): Likewise.\n\t(aarch64_takes_arguments_in_sve_regs_p): Likewise.\n\t(aarch64_fntype_abi): Check for SVE functions and return the SVE PCS\n\tdescriptor for them.\n\t(aarch64_simd_decl_p): Delete.\n\t(aarch64_emit_cfi_for_reg_p): New function.\n\t(aarch64_reg_save_mode): Remove the fndecl argument and instead use\n\tcrtl->abi to choose the mode for FP registers.  Handle the SVE PCS.\n\t(aarch64_hard_regno_call_part_clobbered): Do not treat FP registers\n\tas partly clobbered for the SVE PCS.\n\t(aarch64_function_ok_for_sibcall): Check whether the two functions\n\tuse the same ABI, rather than checking specifically for whether\n\tthey're aarch64_vector_pcs functions.\n\t(aarch64_pass_by_reference): Raise an error for attempts to pass\n\tSVE arguments when SVE is disabled.  Pass SVE arguments by reference\n\tif there are not enough free registers left, or if the argument is\n\tvariadic.\n\t(aarch64_function_value): Handle SVE predicates, vectors and tuples.\n\t(aarch64_return_in_memory): Do not return SVE predicates, vectors and\n\ttuples in memory.\n\t(aarch64_layout_arg): Take a function_arg_info rather than\n\tindividual properties.  Handle SVE predicates, vectors and tuples.\n\tRaise an error if they are passed to unprototyped functions.\n\t(aarch64_function_arg): If the silent_p flag is set, suppress the\n\tusual error about using float registers without TARGET_FLOAT.\n\t(aarch64_init_cumulative_args): Take a silent_p parameter and store\n\tit in the cumulative_args structure.  Initialize aapcs_nprn and\n\taapcs_nextnprn.  If the silent_p flag is set, suppress the usual\n\terror about using float registers without TARGET_FLOAT.\n\tIf the silent_p flag is not set, also raise an error about\n\tusing SVE functions when SVE is disabled.\n\t(aarch64_function_arg_advance): Update the call to aarch64_layout_arg,\n\tand call it for SVE functions too.  Update aapcs_nprn similarly\n\tto the other register counts.\n\t(aarch64_layout_frame): If a big-endian function needs to save\n\tand restore Z8-Z15, search for a spare predicate that it can use.\n\tStore SVE predicates at the bottom of the register save area,\n\tfollowed by SVE vectors, then followed by the normal slots.\n\tKeep pointing the hard frame pointer at the base of the normal slots,\n\tabove the SVE vectors.  Update the various frame creation and\n\ttear-down strategies for the new layout, initializing the new\n\tsve_callee_adjust field.  Add an additional layout for frames\n\twhose saved registers are all SVE registers.\n\t(aarch64_register_saved_on_entry): Cope with poly_int64 reg_offsets.\n\t(aarch64_return_address_signing_enabled): Likewise.\n\t(aarch64_push_regs, aarch64_pop_regs): Update calls to\n\taarch64_reg_save_mode.\n\t(aarch64_adjust_sve_callee_save_base): New function.\n\t(aarch64_add_cfa_expression): Move earlier in file.  Take the\n\tsaved register as an rtx rather than a register number and use\n\tits mode for the MEM slot.\n\t(aarch64_save_callee_saves): Remove the mode argument and instead\n\tuse aarch64_reg_save_mode to get the mode of each save slot.\n\tAdd a hard_fp_valid_p parameter.  Cope with poly_int64 register\n\toffsets.  Allow GP offsets to be saved at a VL-based offset from\n\tthe stack, handling this case using the frame pointer if available\n\tor a temporary register otherwise.  Use ST1D to save Z8-Z15 for\n\tbig-endian SVE functions; use normal moves for other SVE saves.\n\tOnly mark the save as frame-related if aarch64_emit_cfi_for_reg_p\n\treturns true.  Add explicit CFA notes when not storing via the\n\tstack pointer.  Do not try to pair SVE saves.\n\t(aarch64_restore_callee_saves): Cope with poly_int64 register\n\toffsets.  Use LD1D to restore Z8-Z15 for big-endian SVE functions;\n\tuse normal moves for other SVE restores.  Only add CFA restore notes\n\tif aarch64_emit_cfi_for_reg_p returns true.  Do not try to pair\n\tSVE restores.\n\t(aarch64_get_separate_components): Always keep the first SVE save\n\tin the prologue if we need to use it as a stack probe.  Don't allow\n\tZ8-Z15 saves and loads to be shrink-wrapped for big-endian targets.\n\tLikewise the spare predicate register that they need.  Update the\n\toffset calculation to account for the SVE save area.  Use the\n\tappropriate range check for SVE LDR and STR instructions.\n\t(aarch64_components_for_bb): Cope with poly_int64 reg_offsets.\n\t(aarch64_process_components): Likewise.  Update the offset\n\tcalculation to account for the SVE save area.  Only mark the\n\tsave as frame-related if aarch64_emit_cfi_for_reg_p returns true.\n\tDo not try to pair SVE saves.\n\t(aarch64_allocate_and_probe_stack_space): Cope with poly_int64\n\treg_offsets.  When handling the final allocation, expect the\n\tfirst SVE register save to be part of the initial allocation\n\tand for it to act as a probe at SP.  Account for the SVE callee\n\tsave area in the dump information.\n\t(aarch64_expand_prologue): Update the frame diagram.  Fold the\n\tSVE callee allocation into the initial allocation if stack clash\n\tprotection is enabled.  Use new variables to track the offset\n\tof the frame chain (and hard frame pointer) from the current\n\tstack pointer, and likewise the offset of the bottom of the\n\tregister save area.  Update calls to aarch64_save_callee_saves\n\tand aarch64_add_cfa_expression.  Apply sve_callee_adjust before\n\tsaving the FP&SIMD registers.  Save the predicate registers.\n\t(aarch64_expand_epilogue): Take below_hard_fp_saved_regs_size\n\tinto account when setting the stack pointer from the frame pointer,\n\tand when deciding whether we can inherit the initial adjustment\n\tamount from the prologue.  Restore the predicate registers after\n\tthe vector registers, then apply sve_callee_adjust, then restore\n\tthe general registers.\n\t(aarch64_secondary_reload): Don't use secondary SVE reloads\n\tfor VNx16BImode.\n\t(aapcs_vfp_sub_candidate): Assert that the type is not an SVE type.\n\t(aarch64_short_vector_p): Return false for SVE types.\n\t(aarch64_vfp_is_call_or_return_candidate): Initialize *is_ha\n\tat the start of the function.  Return false for SVE types.\n\t(aarch64_asm_output_variant_pcs): Output .variant_pcs for SVE\n\tfunctions too.\n\t(TARGET_STRICT_ARGUMENT_NAMING): Redefine to request strict naming.\n\t* config/aarch64/aarch64-sve.md (*aarch64_sve_mov<mode>_le): Extend\n\tto big-endian targets for bytewise moves.\n\t(*aarch64_sve_mov<mode>_be): Exclude the bytewise case.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/pcs/aarch64-sve-pcs.exp: New file.\n\t* gcc.target/aarch64/sve/pcs/annotate_1.c: New test.\n\t* gcc.target/aarch64/sve/pcs/annotate_2.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/annotate_3.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/annotate_4.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/annotate_5.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/annotate_6.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/annotate_7.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_10.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_11_nosc.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_11_sc.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_2.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_3.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_4.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_f16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_f32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_f64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_s16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_s32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_s64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_s8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_u16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_u32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_u64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_be_u8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_f16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_f32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_f64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_s16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_s32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_s64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_s8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_u16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_u32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_u64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_5_le_u8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_f16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_f32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_f64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_s16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_s32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_s64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_s8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_u16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_u32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_u64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_be_u8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_f16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_f32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_f64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_s16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_s32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_s64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_s8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_u16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_u32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_u64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_6_le_u8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_7.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/args_9.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_2.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_3.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_4.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_5.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_6.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_7.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/nosve_8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_1_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_1_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_1_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_1_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_2.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_3.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_4.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_4_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_4_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_4_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_4_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_5.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_5_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_5_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_5_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_5_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_6.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_6_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_6_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_6_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_6_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_7.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/return_9.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_1_be_nowrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_1_be_wrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_1_le_nowrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_1_le_wrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_2_be_nowrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_2_be_wrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_2_le_nowrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_2_le_wrap.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_3.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_4_be.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_4_le.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_5_be.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/saves_5_le.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_1_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_1_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_1_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_1_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_2.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_2_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_2_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_2_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_2_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/stack_clash_3.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/unprototyped_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_1.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_f16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_f32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_f64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_s16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_s32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_s64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_s8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_u16.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_u32.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_u64.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_2_u8.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_3_nosc.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/varargs_3_sc.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/vpcs_1.c: Likewise.\n\t* g++.target/aarch64/sve/catch_7.C: Likewise.\n\nFrom-SVN: r277564", "tree": {"sha": "3ab057ceb11b2b41ed5b4de9fc9e08b33da249fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ab057ceb11b2b41ed5b4de9fc9e08b33da249fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c600df9a4060da3c6121ff4d0b93f179eafd69d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c600df9a4060da3c6121ff4d0b93f179eafd69d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c600df9a4060da3c6121ff4d0b93f179eafd69d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c600df9a4060da3c6121ff4d0b93f179eafd69d1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc"}], "stats": {"total": 17631, "additions": 17406, "deletions": 225}, "files": [{"sha": "a9a22934c1267755c2ba89319f2cb286b84179a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -1,3 +1,140 @@\n+2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* calls.c (pass_by_reference): Leave the target to decide whether\n+\tPOLY_INT_CST-sized arguments should be passed by value or reference,\n+\trather than forcing them to be passed by reference.\n+\t(must_pass_in_stack_var_size): Likewise.\n+\t* config/aarch64/aarch64.md (LAST_SAVED_REGNUM): Redefine from\n+\tV31_REGNUM to P15_REGNUM.\n+\t* config/aarch64/aarch64-protos.h (aarch64_init_cumulative_args):\n+\tTake an extra \"silent_p\" parameter, defaulting to false.\n+\t(aarch64_sve::svbool_type_p): Declare.\n+\t(aarch64_sve::nvectors_if_data_type): Likewise.\n+\t* config/aarch64/aarch64.h (NUM_PR_ARG_REGS): New macro.\n+\t(aarch64_frame::reg_offset): Turn into poly_int64s.\n+\t(aarch64_frame::save_regs_size): Likewise.\n+\t(aarch64_frame::below_hard_fp_saved_regs_size): New field.\n+\t(aarch64_frame::sve_callee_adjust): Likewise.\n+\t(aarch64_frame::spare_reg_reg): Likewise.\n+\t(ARM_PCS_SVE): New arm_pcs value.\n+\t(CUMULATIVE_ARGS::aapcs_nprn): New field.\n+\t(CUMULATIVE_ARGS::aapcs_nextnprn): Likewise.\n+\t(CUMULATIVE_ARGS::silent_p): Likewise.\n+\t(BITS_PER_SVE_PRED): New macro.\n+\t* config/aarch64/aarch64.c (handle_aarch64_vector_pcs_attribute): New\n+\tfunction.  Reject aarch64_vector_pcs attributes on SVE functions.\n+\t(aarch64_attribute_table): Use the above handler.\n+\t(aarch64_sve_abi): New function.\n+\t(aarch64_sve_argument_p): Likewise.\n+\t(aarch64_returns_value_in_sve_regs_p): Likewise.\n+\t(aarch64_takes_arguments_in_sve_regs_p): Likewise.\n+\t(aarch64_fntype_abi): Check for SVE functions and return the SVE PCS\n+\tdescriptor for them.\n+\t(aarch64_simd_decl_p): Delete.\n+\t(aarch64_emit_cfi_for_reg_p): New function.\n+\t(aarch64_reg_save_mode): Remove the fndecl argument and instead use\n+\tcrtl->abi to choose the mode for FP registers.  Handle the SVE PCS.\n+\t(aarch64_hard_regno_call_part_clobbered): Do not treat FP registers\n+\tas partly clobbered for the SVE PCS.\n+\t(aarch64_function_ok_for_sibcall): Check whether the two functions\n+\tuse the same ABI, rather than checking specifically for whether\n+\tthey're aarch64_vector_pcs functions.\n+\t(aarch64_pass_by_reference): Raise an error for attempts to pass\n+\tSVE arguments when SVE is disabled.  Pass SVE arguments by reference\n+\tif there are not enough free registers left, or if the argument is\n+\tvariadic.\n+\t(aarch64_function_value): Handle SVE predicates, vectors and tuples.\n+\t(aarch64_return_in_memory): Do not return SVE predicates, vectors and\n+\ttuples in memory.\n+\t(aarch64_layout_arg): Take a function_arg_info rather than\n+\tindividual properties.  Handle SVE predicates, vectors and tuples.\n+\tRaise an error if they are passed to unprototyped functions.\n+\t(aarch64_function_arg): If the silent_p flag is set, suppress the\n+\tusual error about using float registers without TARGET_FLOAT.\n+\t(aarch64_init_cumulative_args): Take a silent_p parameter and store\n+\tit in the cumulative_args structure.  Initialize aapcs_nprn and\n+\taapcs_nextnprn.  If the silent_p flag is set, suppress the usual\n+\terror about using float registers without TARGET_FLOAT.\n+\tIf the silent_p flag is not set, also raise an error about\n+\tusing SVE functions when SVE is disabled.\n+\t(aarch64_function_arg_advance): Update the call to aarch64_layout_arg,\n+\tand call it for SVE functions too.  Update aapcs_nprn similarly\n+\tto the other register counts.\n+\t(aarch64_layout_frame): If a big-endian function needs to save\n+\tand restore Z8-Z15, search for a spare predicate that it can use.\n+\tStore SVE predicates at the bottom of the register save area,\n+\tfollowed by SVE vectors, then followed by the normal slots.\n+\tKeep pointing the hard frame pointer at the base of the normal slots,\n+\tabove the SVE vectors.  Update the various frame creation and\n+\ttear-down strategies for the new layout, initializing the new\n+\tsve_callee_adjust field.  Add an additional layout for frames\n+\twhose saved registers are all SVE registers.\n+\t(aarch64_register_saved_on_entry): Cope with poly_int64 reg_offsets.\n+\t(aarch64_return_address_signing_enabled): Likewise.\n+\t(aarch64_push_regs, aarch64_pop_regs): Update calls to\n+\taarch64_reg_save_mode.\n+\t(aarch64_adjust_sve_callee_save_base): New function.\n+\t(aarch64_add_cfa_expression): Move earlier in file.  Take the\n+\tsaved register as an rtx rather than a register number and use\n+\tits mode for the MEM slot.\n+\t(aarch64_save_callee_saves): Remove the mode argument and instead\n+\tuse aarch64_reg_save_mode to get the mode of each save slot.\n+\tAdd a hard_fp_valid_p parameter.  Cope with poly_int64 register\n+\toffsets.  Allow GP offsets to be saved at a VL-based offset from\n+\tthe stack, handling this case using the frame pointer if available\n+\tor a temporary register otherwise.  Use ST1D to save Z8-Z15 for\n+\tbig-endian SVE functions; use normal moves for other SVE saves.\n+\tOnly mark the save as frame-related if aarch64_emit_cfi_for_reg_p\n+\treturns true.  Add explicit CFA notes when not storing via the\n+\tstack pointer.  Do not try to pair SVE saves.\n+\t(aarch64_restore_callee_saves): Cope with poly_int64 register\n+\toffsets.  Use LD1D to restore Z8-Z15 for big-endian SVE functions;\n+\tuse normal moves for other SVE restores.  Only add CFA restore notes\n+\tif aarch64_emit_cfi_for_reg_p returns true.  Do not try to pair\n+\tSVE restores.\n+\t(aarch64_get_separate_components): Always keep the first SVE save\n+\tin the prologue if we need to use it as a stack probe.  Don't allow\n+\tZ8-Z15 saves and loads to be shrink-wrapped for big-endian targets.\n+\tLikewise the spare predicate register that they need.  Update the\n+\toffset calculation to account for the SVE save area.  Use the\n+\tappropriate range check for SVE LDR and STR instructions.\n+\t(aarch64_components_for_bb): Cope with poly_int64 reg_offsets.\n+\t(aarch64_process_components): Likewise.  Update the offset\n+\tcalculation to account for the SVE save area.  Only mark the\n+\tsave as frame-related if aarch64_emit_cfi_for_reg_p returns true.\n+\tDo not try to pair SVE saves.\n+\t(aarch64_allocate_and_probe_stack_space): Cope with poly_int64\n+\treg_offsets.  When handling the final allocation, expect the\n+\tfirst SVE register save to be part of the initial allocation\n+\tand for it to act as a probe at SP.  Account for the SVE callee\n+\tsave area in the dump information.\n+\t(aarch64_expand_prologue): Update the frame diagram.  Fold the\n+\tSVE callee allocation into the initial allocation if stack clash\n+\tprotection is enabled.  Use new variables to track the offset\n+\tof the frame chain (and hard frame pointer) from the current\n+\tstack pointer, and likewise the offset of the bottom of the\n+\tregister save area.  Update calls to aarch64_save_callee_saves\n+\tand aarch64_add_cfa_expression.  Apply sve_callee_adjust before\n+\tsaving the FP&SIMD registers.  Save the predicate registers.\n+\t(aarch64_expand_epilogue): Take below_hard_fp_saved_regs_size\n+\tinto account when setting the stack pointer from the frame pointer,\n+\tand when deciding whether we can inherit the initial adjustment\n+\tamount from the prologue.  Restore the predicate registers after\n+\tthe vector registers, then apply sve_callee_adjust, then restore\n+\tthe general registers.\n+\t(aarch64_secondary_reload): Don't use secondary SVE reloads\n+\tfor VNx16BImode.\n+\t(aapcs_vfp_sub_candidate): Assert that the type is not an SVE type.\n+\t(aarch64_short_vector_p): Return false for SVE types.\n+\t(aarch64_vfp_is_call_or_return_candidate): Initialize *is_ha\n+\tat the start of the function.  Return false for SVE types.\n+\t(aarch64_asm_output_variant_pcs): Output .variant_pcs for SVE\n+\tfunctions too.\n+\t(TARGET_STRICT_ARGUMENT_NAMING): Redefine to request strict naming.\n+\t* config/aarch64/aarch64-sve.md (*aarch64_sve_mov<mode>_le): Extend\n+\tto big-endian targets for bytewise moves.\n+\t(*aarch64_sve_mov<mode>_be): Exclude the bytewise case.\n+\n 2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>"}, {"sha": "e2b770fc277bd6f20fef77d5c3df64955dda561b", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -911,7 +911,7 @@ pass_by_reference (CUMULATIVE_ARGS *ca, function_arg_info arg)\n \treturn true;\n \n       /* GCC post 3.4 passes *all* variable sized types by reference.  */\n-      if (!TYPE_SIZE (type) || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+      if (!TYPE_SIZE (type) || !poly_int_tree_p (TYPE_SIZE (type)))\n \treturn true;\n \n       /* If a record type should be passed the same as its first (and only)\n@@ -5878,7 +5878,7 @@ must_pass_in_stack_var_size (const function_arg_info &arg)\n     return false;\n \n   /* If the type has variable size...  */\n-  if (TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST)\n+  if (!poly_int_tree_p (TYPE_SIZE (arg.type)))\n     return true;\n \n   /* If the type is marked as addressable (it is required"}, {"sha": "1d4f4fd488863c9faebc7ccaa459b957e71bb4df", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -617,7 +617,7 @@ void aarch64_expand_prologue (void);\n void aarch64_expand_vector_init (rtx, rtx);\n void aarch64_sve_expand_vector_init (rtx, rtx);\n void aarch64_init_cumulative_args (CUMULATIVE_ARGS *, const_tree, rtx,\n-\t\t\t\t   const_tree, unsigned);\n+\t\t\t\t   const_tree, unsigned, bool = false);\n void aarch64_init_expanders (void);\n void aarch64_init_simd_builtins (void);\n void aarch64_emit_call_insn (rtx);\n@@ -705,6 +705,8 @@ namespace aarch64_sve {\n   void handle_arm_sve_h ();\n   tree builtin_decl (unsigned, bool);\n   bool builtin_type_p (const_tree);\n+  bool svbool_type_p (const_tree);\n+  unsigned int nvectors_if_data_type (const_tree);\n   const char *mangle_builtin_type (const_tree);\n   tree resolve_overloaded_builtin (location_t, unsigned int,\n \t\t\t\t   vec<tree, va_gc> *);"}, {"sha": "0cda88287b07072dd5da1b7dab7992dba058ad32", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -586,14 +586,14 @@\n   }\n )\n \n-;; Unpredicated moves (little-endian).  Only allow memory operations\n-;; during and after RA; before RA we want the predicated load and\n-;; store patterns to be used instead.\n+;; Unpredicated moves (bytes or little-endian).  Only allow memory operations\n+;; during and after RA; before RA we want the predicated load and store\n+;; patterns to be used instead.\n (define_insn \"*aarch64_sve_mov<mode>_le\"\n   [(set (match_operand:SVE_ALL 0 \"aarch64_sve_nonimmediate_operand\" \"=w, Utr, w, w\")\n \t(match_operand:SVE_ALL 1 \"aarch64_sve_general_operand\" \"Utr, w, w, Dn\"))]\n   \"TARGET_SVE\n-   && !BYTES_BIG_ENDIAN\n+   && (<MODE>mode == VNx16QImode || !BYTES_BIG_ENDIAN)\n    && ((lra_in_progress || reload_completed)\n        || (register_operand (operands[0], <MODE>mode)\n \t   && nonmemory_operand (operands[1], <MODE>mode)))\"\n@@ -604,12 +604,12 @@\n    * return aarch64_output_sve_mov_immediate (operands[1]);\"\n )\n \n-;; Unpredicated moves (big-endian).  Memory accesses require secondary\n+;; Unpredicated moves (non-byte big-endian).  Memory accesses require secondary\n ;; reloads.\n (define_insn \"*aarch64_sve_mov<mode>_be\"\n   [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w, w\")\n \t(match_operand:SVE_ALL 1 \"aarch64_nonmemory_operand\" \"w, Dn\"))]\n-  \"TARGET_SVE && BYTES_BIG_ENDIAN\"\n+  \"TARGET_SVE && BYTES_BIG_ENDIAN && <MODE>mode != VNx16QImode\"\n   \"@\n    mov\\t%0.d, %1.d\n    * return aarch64_output_sve_mov_immediate (operands[1]);\""}, {"sha": "599d07a729e7438080f8b5240ee95037a49fb983", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 784, "deletions": 210, "changes": 994, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -1212,12 +1212,41 @@ enum aarch64_key_type aarch64_ra_sign_key = AARCH64_KEY_A;\n /* The current tuning set.  */\n struct tune_params aarch64_tune_params = generic_tunings;\n \n+/* Check whether an 'aarch64_vector_pcs' attribute is valid.  */\n+\n+static tree\n+handle_aarch64_vector_pcs_attribute (tree *node, tree name, tree,\n+\t\t\t\t     int, bool *no_add_attrs)\n+{\n+  /* Since we set fn_type_req to true, the caller should have checked\n+     this for us.  */\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (*node));\n+  switch ((arm_pcs) fntype_abi (*node).id ())\n+    {\n+    case ARM_PCS_AAPCS64:\n+    case ARM_PCS_SIMD:\n+      return NULL_TREE;\n+\n+    case ARM_PCS_SVE:\n+      error (\"the %qE attribute cannot be applied to an SVE function type\",\n+\t     name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+\n+    case ARM_PCS_TLSDESC:\n+    case ARM_PCS_UNKNOWN:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Table of machine attributes.  */\n static const struct attribute_spec aarch64_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n        affects_type_identity, handler, exclude } */\n-  { \"aarch64_vector_pcs\", 0, 0, false, true,  true,  true,  NULL, NULL },\n+  { \"aarch64_vector_pcs\", 0, 0, false, true,  true,  true,\n+\t\t\t  handle_aarch64_vector_pcs_attribute, NULL },\n   { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -1384,6 +1413,25 @@ aarch64_simd_abi (void)\n   return simd_abi;\n }\n \n+/* Return the descriptor of the SVE PCS.  */\n+\n+static const predefined_function_abi &\n+aarch64_sve_abi (void)\n+{\n+  predefined_function_abi &sve_abi = function_abis[ARM_PCS_SVE];\n+  if (!sve_abi.initialized_p ())\n+    {\n+      HARD_REG_SET full_reg_clobbers\n+\t= default_function_abi.full_reg_clobbers ();\n+      for (int regno = V8_REGNUM; regno <= V23_REGNUM; ++regno)\n+\tCLEAR_HARD_REG_BIT (full_reg_clobbers, regno);\n+      for (int regno = P4_REGNUM; regno <= P11_REGNUM; ++regno)\n+\tCLEAR_HARD_REG_BIT (full_reg_clobbers, regno);\n+      sve_abi.initialize (ARM_PCS_SVE, full_reg_clobbers);\n+    }\n+  return sve_abi;\n+}\n+\n /* Generate code to enable conditional branches in functions over 1 MiB.  */\n const char *\n aarch64_gen_far_branch (rtx * operands, int pos_label, const char * dest,\n@@ -1878,47 +1926,140 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n   return false;\n }\n \n+/* Return true if TYPE is a type that should be passed or returned in\n+   SVE registers, assuming enough registers are available.  When returning\n+   true, set *NUM_ZR and *NUM_PR to the number of required Z and P registers\n+   respectively.  */\n+\n+static bool\n+aarch64_sve_argument_p (const_tree type, unsigned int *num_zr,\n+\t\t\tunsigned int *num_pr)\n+{\n+  if (aarch64_sve::svbool_type_p (type))\n+    {\n+      *num_pr = 1;\n+      *num_zr = 0;\n+      return true;\n+    }\n+\n+  if (unsigned int nvectors = aarch64_sve::nvectors_if_data_type (type))\n+    {\n+      *num_pr = 0;\n+      *num_zr = nvectors;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if a function with type FNTYPE returns its value in\n+   SVE vector or predicate registers.  */\n+\n+static bool\n+aarch64_returns_value_in_sve_regs_p (const_tree fntype)\n+{\n+  unsigned int num_zr, num_pr;\n+  tree return_type = TREE_TYPE (fntype);\n+  return (return_type != error_mark_node\n+\t  && aarch64_sve_argument_p (return_type, &num_zr, &num_pr));\n+}\n+\n+/* Return true if a function with type FNTYPE takes arguments in\n+   SVE vector or predicate registers.  */\n+\n+static bool\n+aarch64_takes_arguments_in_sve_regs_p (const_tree fntype)\n+{\n+  CUMULATIVE_ARGS args_so_far_v;\n+  aarch64_init_cumulative_args (&args_so_far_v, NULL_TREE, NULL_RTX,\n+\t\t\t\tNULL_TREE, 0, true);\n+  cumulative_args_t args_so_far = pack_cumulative_args (&args_so_far_v);\n+\n+  for (tree chain = TYPE_ARG_TYPES (fntype);\n+       chain && chain != void_list_node;\n+       chain = TREE_CHAIN (chain))\n+    {\n+      tree arg_type = TREE_VALUE (chain);\n+      if (arg_type == error_mark_node)\n+\treturn false;\n+\n+      function_arg_info arg (arg_type, /*named=*/true);\n+      apply_pass_by_reference_rules (&args_so_far_v, arg);\n+      unsigned int num_zr, num_pr;\n+      if (aarch64_sve_argument_p (arg.type, &num_zr, &num_pr))\n+\treturn true;\n+\n+      targetm.calls.function_arg_advance (args_so_far, arg);\n+    }\n+  return false;\n+}\n+\n /* Implement TARGET_FNTYPE_ABI.  */\n \n static const predefined_function_abi &\n aarch64_fntype_abi (const_tree fntype)\n {\n   if (lookup_attribute (\"aarch64_vector_pcs\", TYPE_ATTRIBUTES (fntype)))\n     return aarch64_simd_abi ();\n+\n+  if (aarch64_returns_value_in_sve_regs_p (fntype)\n+      || aarch64_takes_arguments_in_sve_regs_p (fntype))\n+    return aarch64_sve_abi ();\n+\n   return default_function_abi;\n }\n \n-/* Return true if this is a definition of a vectorized simd function.  */\n+/* Return true if we should emit CFI for register REGNO.  */\n \n static bool\n-aarch64_simd_decl_p (tree fndecl)\n+aarch64_emit_cfi_for_reg_p (unsigned int regno)\n {\n-  tree fntype;\n-\n-  if (fndecl == NULL)\n-    return false;\n-  fntype = TREE_TYPE (fndecl);\n-  if (fntype == NULL)\n-    return false;\n-\n-  /* Functions with the aarch64_vector_pcs attribute use the simd ABI.  */\n-  if (lookup_attribute (\"aarch64_vector_pcs\", TYPE_ATTRIBUTES (fntype)) != NULL)\n-    return true;\n-\n-  return false;\n+  return (GP_REGNUM_P (regno)\n+\t  || !default_function_abi.clobbers_full_reg_p (regno));\n }\n \n-/* Return the mode a register save/restore should use.  DImode for integer\n-   registers, DFmode for FP registers in non-SIMD functions (they only save\n-   the bottom half of a 128 bit register), or TFmode for FP registers in\n-   SIMD functions.  */\n+/* Return the mode we should use to save and restore register REGNO.  */\n \n static machine_mode\n-aarch64_reg_save_mode (tree fndecl, unsigned regno)\n+aarch64_reg_save_mode (unsigned int regno)\n {\n-  return GP_REGNUM_P (regno)\n-\t   ? E_DImode\n-\t   : (aarch64_simd_decl_p (fndecl) ? E_TFmode : E_DFmode);\n+  if (GP_REGNUM_P (regno))\n+    return DImode;\n+\n+  if (FP_REGNUM_P (regno))\n+    switch (crtl->abi->id ())\n+      {\n+      case ARM_PCS_AAPCS64:\n+\t/* Only the low 64 bits are saved by the base PCS.  */\n+\treturn DFmode;\n+\n+      case ARM_PCS_SIMD:\n+\t/* The vector PCS saves the low 128 bits (which is the full\n+\t   register on non-SVE targets).  */\n+\treturn TFmode;\n+\n+      case ARM_PCS_SVE:\n+\t/* Use vectors of DImode for registers that need frame\n+\t   information, so that the first 64 bytes of the save slot\n+\t   are always the equivalent of what storing D<n> would give.  */\n+\tif (aarch64_emit_cfi_for_reg_p (regno))\n+\t  return VNx2DImode;\n+\n+\t/* Use vectors of bytes otherwise, so that the layout is\n+\t   endian-agnostic, and so that we can use LDR and STR for\n+\t   big-endian targets.  */\n+\treturn VNx16QImode;\n+\n+      case ARM_PCS_TLSDESC:\n+      case ARM_PCS_UNKNOWN:\n+\tbreak;\n+      }\n+\n+  if (PR_REGNUM_P (regno))\n+    /* Save the full predicate register.  */\n+    return VNx16BImode;\n+\n+  gcc_unreachable ();\n }\n \n /* Implement TARGET_INSN_CALLEE_ABI.  */\n@@ -1943,7 +2084,7 @@ aarch64_hard_regno_call_part_clobbered (unsigned int abi_id,\n \t\t\t\t\tunsigned int regno,\n \t\t\t\t\tmachine_mode mode)\n {\n-  if (FP_REGNUM_P (regno))\n+  if (FP_REGNUM_P (regno) && abi_id != ARM_PCS_SVE)\n     {\n       poly_int64 per_register_size = GET_MODE_SIZE (mode);\n       unsigned int nregs = hard_regno_nregs (regno, mode);\n@@ -4582,10 +4723,9 @@ aarch64_split_sve_subreg_move (rtx dest, rtx ptrue, rtx src)\n }\n \n static bool\n-aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n-\t\t\t\t tree exp ATTRIBUTE_UNUSED)\n+aarch64_function_ok_for_sibcall (tree, tree exp)\n {\n-  if (aarch64_simd_decl_p (cfun->decl) != aarch64_simd_decl_p (decl))\n+  if (crtl->abi->id () != expr_callee_abi (exp).id ())\n     return false;\n \n   return true;\n@@ -4594,12 +4734,30 @@ aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n /* Implement TARGET_PASS_BY_REFERENCE.  */\n \n static bool\n-aarch64_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n+aarch64_pass_by_reference (cumulative_args_t pcum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   HOST_WIDE_INT size;\n   machine_mode dummymode;\n   int nregs;\n \n+  unsigned int num_zr, num_pr;\n+  if (arg.type && aarch64_sve_argument_p (arg.type, &num_zr, &num_pr))\n+    {\n+      if (pcum && !pcum->silent_p && !TARGET_SVE)\n+\t/* We can't gracefully recover at this point, so make this a\n+\t   fatal error.  */\n+\tfatal_error (input_location, \"arguments of type %qT require\"\n+\t\t     \" the SVE ISA extension\", arg.type);\n+\n+      /* Variadic SVE types are passed by reference.  Normal non-variadic\n+\t arguments are too if we've run out of registers.  */\n+      return (!arg.named\n+\t      || pcum->aapcs_nvrn + num_zr > NUM_FP_ARG_REGS\n+\t      || pcum->aapcs_nprn + num_pr > NUM_PR_ARG_REGS);\n+    }\n+\n   /* GET_MODE_SIZE (BLKmode) is useless since it is 0.  */\n   if (arg.mode == BLKmode && arg.type)\n     size = int_size_in_bytes (arg.type);\n@@ -4673,6 +4831,29 @@ aarch64_function_value (const_tree type, const_tree func,\n   if (INTEGRAL_TYPE_P (type))\n     mode = promote_function_mode (type, mode, &unsignedp, func, 1);\n \n+  unsigned int num_zr, num_pr;\n+  if (type && aarch64_sve_argument_p (type, &num_zr, &num_pr))\n+    {\n+      /* Don't raise an error here if we're called when SVE is disabled,\n+\t since this is really just a query function.  Other code must\n+\t do that where appropriate.  */\n+      mode = TYPE_MODE_RAW (type);\n+      gcc_assert (VECTOR_MODE_P (mode)\n+\t\t  && (!TARGET_SVE || aarch64_sve_mode_p (mode)));\n+\n+      if (num_zr > 0 && num_pr == 0)\n+\treturn gen_rtx_REG (mode, V0_REGNUM);\n+\n+      if (num_zr == 0 && num_pr == 1)\n+\treturn gen_rtx_REG (mode, P0_REGNUM);\n+\n+      gcc_unreachable ();\n+    }\n+\n+  /* Generic vectors that map to SVE modes with -msve-vector-bits=N are\n+     returned in memory, not by value.  */\n+  gcc_assert (!aarch64_sve_mode_p (mode));\n+\n   if (aarch64_return_in_msb (type))\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n@@ -4755,6 +4936,16 @@ aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n     /* Simple scalar types always returned in registers.  */\n     return false;\n \n+  unsigned int num_zr, num_pr;\n+  if (type && aarch64_sve_argument_p (type, &num_zr, &num_pr))\n+    {\n+      /* All SVE types we support fit in registers.  For example, it isn't\n+\t yet possible to define an aggregate of 9+ SVE vectors or 5+ SVE\n+\t predicates.  */\n+      gcc_assert (num_zr <= NUM_FP_ARG_REGS && num_pr <= NUM_PR_ARG_REGS);\n+      return false;\n+    }\n+\n   if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (type),\n \t\t\t\t\t       type,\n \t\t\t\t\t       &ag_mode,\n@@ -4830,11 +5021,11 @@ aarch64_function_arg_alignment (machine_mode mode, const_tree type,\n    numbers refer to the rule numbers in the AAPCS64.  */\n \n static void\n-aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t    const_tree type,\n-\t\t    bool named ATTRIBUTE_UNUSED)\n+aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n   int ncrn, nvrn, nregs;\n   bool allocate_ncrn, allocate_nvrn;\n   HOST_WIDE_INT size;\n@@ -4846,6 +5037,46 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n \n   pcum->aapcs_arg_processed = true;\n \n+  unsigned int num_zr, num_pr;\n+  if (type && aarch64_sve_argument_p (type, &num_zr, &num_pr))\n+    {\n+      /* The PCS says that it is invalid to pass an SVE value to an\n+\t unprototyped function.  There is no ABI-defined location we\n+\t can return in this case, so we have no real choice but to raise\n+\t an error immediately, even though this is only a query function.  */\n+      if (arg.named && pcum->pcs_variant != ARM_PCS_SVE)\n+\t{\n+\t  gcc_assert (!pcum->silent_p);\n+\t  error (\"SVE type %qT cannot be passed to an unprototyped function\",\n+\t\t arg.type);\n+\t  /* Avoid repeating the message, and avoid tripping the assert\n+\t     below.  */\n+\t  pcum->pcs_variant = ARM_PCS_SVE;\n+\t}\n+\n+      /* We would have converted the argument into pass-by-reference\n+\t form if it didn't fit in registers.  */\n+      pcum->aapcs_nextnvrn = pcum->aapcs_nvrn + num_zr;\n+      pcum->aapcs_nextnprn = pcum->aapcs_nprn + num_pr;\n+      gcc_assert (arg.named\n+\t\t  && pcum->pcs_variant == ARM_PCS_SVE\n+\t\t  && aarch64_sve_mode_p (mode)\n+\t\t  && pcum->aapcs_nextnvrn <= NUM_FP_ARG_REGS\n+\t\t  && pcum->aapcs_nextnprn <= NUM_PR_ARG_REGS);\n+\n+      if (num_zr > 0 && num_pr == 0)\n+\tpcum->aapcs_reg = gen_rtx_REG (mode, V0_REGNUM + pcum->aapcs_nvrn);\n+      else if (num_zr == 0 && num_pr == 1)\n+\tpcum->aapcs_reg = gen_rtx_REG (mode, P0_REGNUM + pcum->aapcs_nprn);\n+      else\n+\tgcc_unreachable ();\n+      return;\n+    }\n+\n+  /* Generic vectors that map to SVE modes with -msve-vector-bits=N are\n+     passed by reference, not by value.  */\n+  gcc_assert (!aarch64_sve_mode_p (mode));\n+\n   /* Size in bytes, rounded to the nearest multiple of 8 bytes.  */\n   if (type)\n     size = int_size_in_bytes (type);\n@@ -4870,7 +5101,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n      and homogenous short-vector aggregates (HVA).  */\n   if (allocate_nvrn)\n     {\n-      if (!TARGET_FLOAT)\n+      if (!pcum->silent_p && !TARGET_FLOAT)\n \taarch64_err_no_fpadvsimd (mode);\n \n       if (nvrn + nregs <= NUM_FP_ARG_REGS)\n@@ -4990,12 +5221,13 @@ aarch64_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   gcc_assert (pcum->pcs_variant == ARM_PCS_AAPCS64\n-\t      || pcum->pcs_variant == ARM_PCS_SIMD);\n+\t      || pcum->pcs_variant == ARM_PCS_SIMD\n+\t      || pcum->pcs_variant == ARM_PCS_SVE);\n \n   if (arg.end_marker_p ())\n     return gen_int_mode (pcum->pcs_variant, DImode);\n \n-  aarch64_layout_arg (pcum_v, arg.mode, arg.type, arg.named);\n+  aarch64_layout_arg (pcum_v, arg);\n   return pcum->aapcs_reg;\n }\n \n@@ -5004,12 +5236,15 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,\n \t\t\t      const_tree fntype,\n \t\t\t      rtx libname ATTRIBUTE_UNUSED,\n \t\t\t      const_tree fndecl ATTRIBUTE_UNUSED,\n-\t\t\t      unsigned n_named ATTRIBUTE_UNUSED)\n+\t\t\t      unsigned n_named ATTRIBUTE_UNUSED,\n+\t\t\t      bool silent_p)\n {\n   pcum->aapcs_ncrn = 0;\n   pcum->aapcs_nvrn = 0;\n+  pcum->aapcs_nprn = 0;\n   pcum->aapcs_nextncrn = 0;\n   pcum->aapcs_nextnvrn = 0;\n+  pcum->aapcs_nextnprn = 0;\n   if (fntype)\n     pcum->pcs_variant = (arm_pcs) fntype_abi (fntype).id ();\n   else\n@@ -5018,8 +5253,10 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,\n   pcum->aapcs_arg_processed = false;\n   pcum->aapcs_stack_words = 0;\n   pcum->aapcs_stack_size = 0;\n+  pcum->silent_p = silent_p;\n \n-  if (!TARGET_FLOAT\n+  if (!silent_p\n+      && !TARGET_FLOAT\n       && fndecl && TREE_PUBLIC (fndecl)\n       && fntype && fntype != error_mark_node)\n     {\n@@ -5030,7 +5267,20 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,\n \t\t\t\t\t\t   &mode, &nregs, NULL))\n \taarch64_err_no_fpadvsimd (TYPE_MODE (type));\n     }\n-  return;\n+\n+  if (!silent_p\n+      && !TARGET_SVE\n+      && pcum->pcs_variant == ARM_PCS_SVE)\n+    {\n+      /* We can't gracefully recover at this point, so make this a\n+\t fatal error.  */\n+      if (fndecl)\n+\tfatal_error (input_location, \"%qE requires the SVE ISA extension\",\n+\t\t     fndecl);\n+      else\n+\tfatal_error (input_location, \"calls to functions of type %qT require\"\n+\t\t     \" the SVE ISA extension\", fntype);\n+    }\n }\n \n static void\n@@ -5039,14 +5289,16 @@ aarch64_function_arg_advance (cumulative_args_t pcum_v,\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   if (pcum->pcs_variant == ARM_PCS_AAPCS64\n-      || pcum->pcs_variant == ARM_PCS_SIMD)\n+      || pcum->pcs_variant == ARM_PCS_SIMD\n+      || pcum->pcs_variant == ARM_PCS_SVE)\n     {\n-      aarch64_layout_arg (pcum_v, arg.mode, arg.type, arg.named);\n+      aarch64_layout_arg (pcum_v, arg);\n       gcc_assert ((pcum->aapcs_reg != NULL_RTX)\n \t\t  != (pcum->aapcs_stack_words != 0));\n       pcum->aapcs_arg_processed = false;\n       pcum->aapcs_ncrn = pcum->aapcs_nextncrn;\n       pcum->aapcs_nvrn = pcum->aapcs_nextnvrn;\n+      pcum->aapcs_nprn = pcum->aapcs_nextnprn;\n       pcum->aapcs_stack_size += pcum->aapcs_stack_words;\n       pcum->aapcs_stack_words = 0;\n       pcum->aapcs_reg = NULL_RTX;\n@@ -5479,9 +5731,11 @@ aarch64_needs_frame_chain (void)\n static void\n aarch64_layout_frame (void)\n {\n-  HOST_WIDE_INT offset = 0;\n+  poly_int64 offset = 0;\n   int regno, last_fp_reg = INVALID_REGNUM;\n-  bool simd_function = (crtl->abi->id () == ARM_PCS_SIMD);\n+  machine_mode vector_save_mode = aarch64_reg_save_mode (V8_REGNUM);\n+  poly_int64 vector_save_size = GET_MODE_SIZE (vector_save_mode);\n+  bool frame_related_fp_reg_p = false;\n   aarch64_frame &frame = cfun->machine->frame;\n \n   frame.emit_frame_chain = aarch64_needs_frame_chain ();\n@@ -5495,12 +5749,10 @@ aarch64_layout_frame (void)\n \n   frame.wb_candidate1 = INVALID_REGNUM;\n   frame.wb_candidate2 = INVALID_REGNUM;\n+  frame.spare_pred_reg = INVALID_REGNUM;\n \n   /* First mark all the registers that really need to be saved...  */\n-  for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n-    frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n-\n-  for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n+  for (regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n     frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n \n   /* ... that includes the eh data registers (if needed)...  */\n@@ -5523,25 +5775,83 @@ aarch64_layout_frame (void)\n       {\n \tframe.reg_offset[regno] = SLOT_REQUIRED;\n \tlast_fp_reg = regno;\n+\tif (aarch64_emit_cfi_for_reg_p (regno))\n+\t  frame_related_fp_reg_p = true;\n       }\n \n+  /* Big-endian SVE frames need a spare predicate register in order\n+     to save Z8-Z15.  Decide which register they should use.  Prefer\n+     an unused argument register if possible, so that we don't force P4\n+     to be saved unnecessarily.  */\n+  if (frame_related_fp_reg_p\n+      && crtl->abi->id () == ARM_PCS_SVE\n+      && BYTES_BIG_ENDIAN)\n+    {\n+      bitmap live1 = df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+      bitmap live2 = df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun));\n+      for (regno = P0_REGNUM; regno <= P7_REGNUM; regno++)\n+\tif (!bitmap_bit_p (live1, regno) && !bitmap_bit_p (live2, regno))\n+\t  break;\n+      gcc_assert (regno <= P7_REGNUM);\n+      frame.spare_pred_reg = regno;\n+      df_set_regs_ever_live (regno, true);\n+    }\n+\n+  for (regno = P0_REGNUM; regno <= P15_REGNUM; regno++)\n+    if (df_regs_ever_live_p (regno)\n+\t&& !fixed_regs[regno]\n+\t&& !crtl->abi->clobbers_full_reg_p (regno))\n+      frame.reg_offset[regno] = SLOT_REQUIRED;\n+\n+  /* With stack-clash, LR must be saved in non-leaf functions.  */\n+  gcc_assert (crtl->is_leaf\n+\t      || maybe_ne (frame.reg_offset[R30_REGNUM], SLOT_NOT_REQUIRED));\n+\n+  /* Now assign stack slots for the registers.  Start with the predicate\n+     registers, since predicate LDR and STR have a relatively small\n+     offset range.  These saves happen below the hard frame pointer.  */\n+  for (regno = P0_REGNUM; regno <= P15_REGNUM; regno++)\n+    if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))\n+      {\n+\tframe.reg_offset[regno] = offset;\n+\toffset += BYTES_PER_SVE_PRED;\n+      }\n+\n+  /* We save a maximum of 8 predicate registers, and since vector\n+     registers are 8 times the size of a predicate register, all the\n+     saved predicates fit within a single vector.  Doing this also\n+     rounds the offset to a 128-bit boundary.  */\n+  if (maybe_ne (offset, 0))\n+    {\n+      gcc_assert (known_le (offset, vector_save_size));\n+      offset = vector_save_size;\n+    }\n+\n+  /* If we need to save any SVE vector registers, add them next.  */\n+  if (last_fp_reg != (int) INVALID_REGNUM && crtl->abi->id () == ARM_PCS_SVE)\n+    for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n+      if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))\n+\t{\n+\t  frame.reg_offset[regno] = offset;\n+\t  offset += vector_save_size;\n+\t}\n+\n+  /* OFFSET is now the offset of the hard frame pointer from the bottom\n+     of the callee save area.  */\n+  bool saves_below_hard_fp_p = maybe_ne (offset, 0);\n+  frame.below_hard_fp_saved_regs_size = offset;\n   if (frame.emit_frame_chain)\n     {\n       /* FP and LR are placed in the linkage record.  */\n-      frame.reg_offset[R29_REGNUM] = 0;\n+      frame.reg_offset[R29_REGNUM] = offset;\n       frame.wb_candidate1 = R29_REGNUM;\n-      frame.reg_offset[R30_REGNUM] = UNITS_PER_WORD;\n+      frame.reg_offset[R30_REGNUM] = offset + UNITS_PER_WORD;\n       frame.wb_candidate2 = R30_REGNUM;\n-      offset = 2 * UNITS_PER_WORD;\n+      offset += 2 * UNITS_PER_WORD;\n     }\n \n-  /* With stack-clash, LR must be saved in non-leaf functions.  */\n-  gcc_assert (crtl->is_leaf\n-\t      || frame.reg_offset[R30_REGNUM] != SLOT_NOT_REQUIRED);\n-\n-  /* Now assign stack slots for them.  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n-    if (frame.reg_offset[regno] == SLOT_REQUIRED)\n+    if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))\n       {\n \tframe.reg_offset[regno] = offset;\n \tif (frame.wb_candidate1 == INVALID_REGNUM)\n@@ -5551,19 +5861,19 @@ aarch64_layout_frame (void)\n \toffset += UNITS_PER_WORD;\n       }\n \n-  HOST_WIDE_INT max_int_offset = offset;\n-  offset = ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n-  bool has_align_gap = offset != max_int_offset;\n+  poly_int64 max_int_offset = offset;\n+  offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n+  bool has_align_gap = maybe_ne (offset, max_int_offset);\n \n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n-    if (frame.reg_offset[regno] == SLOT_REQUIRED)\n+    if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))\n       {\n \t/* If there is an alignment gap between integer and fp callee-saves,\n \t   allocate the last fp register to it if possible.  */\n \tif (regno == last_fp_reg\n \t    && has_align_gap\n-\t    && !simd_function\n-\t    && (offset & 8) == 0)\n+\t    && known_eq (vector_save_size, 8)\n+\t    && multiple_p (offset, 16))\n \t  {\n \t    frame.reg_offset[regno] = max_int_offset;\n \t    break;\n@@ -5575,31 +5885,34 @@ aarch64_layout_frame (void)\n \telse if (frame.wb_candidate2 == INVALID_REGNUM\n \t\t && frame.wb_candidate1 >= V0_REGNUM)\n \t  frame.wb_candidate2 = regno;\n-\toffset += simd_function ? UNITS_PER_VREG : UNITS_PER_WORD;\n+\toffset += vector_save_size;\n       }\n \n-  offset = ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n+  offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n \n   frame.saved_regs_size = offset;\n \n-  HOST_WIDE_INT varargs_and_saved_regs_size\n-    = offset + frame.saved_varargs_size;\n+  poly_int64 varargs_and_saved_regs_size = offset + frame.saved_varargs_size;\n \n-  frame.hard_fp_offset\n+  poly_int64 above_outgoing_args\n     = aligned_upper_bound (varargs_and_saved_regs_size\n \t\t\t   + get_frame_size (),\n \t\t\t   STACK_BOUNDARY / BITS_PER_UNIT);\n \n+  frame.hard_fp_offset\n+    = above_outgoing_args - frame.below_hard_fp_saved_regs_size;\n+\n   /* Both these values are already aligned.  */\n   gcc_assert (multiple_p (crtl->outgoing_args_size,\n \t\t\t  STACK_BOUNDARY / BITS_PER_UNIT));\n-  frame.frame_size = frame.hard_fp_offset + crtl->outgoing_args_size;\n+  frame.frame_size = above_outgoing_args + crtl->outgoing_args_size;\n \n   frame.locals_offset = frame.saved_varargs_size;\n \n   frame.initial_adjust = 0;\n   frame.final_adjust = 0;\n   frame.callee_adjust = 0;\n+  frame.sve_callee_adjust = 0;\n   frame.callee_offset = 0;\n \n   HOST_WIDE_INT max_push_offset = 0;\n@@ -5609,53 +5922,86 @@ aarch64_layout_frame (void)\n     max_push_offset = 256;\n \n   HOST_WIDE_INT const_size, const_outgoing_args_size, const_fp_offset;\n+  HOST_WIDE_INT const_saved_regs_size;\n   if (frame.frame_size.is_constant (&const_size)\n       && const_size < max_push_offset\n-      && known_eq (crtl->outgoing_args_size, 0))\n+      && known_eq (frame.hard_fp_offset, const_size))\n     {\n       /* Simple, small frame with no outgoing arguments:\n+\n \t stp reg1, reg2, [sp, -frame_size]!\n \t stp reg3, reg4, [sp, 16]  */\n       frame.callee_adjust = const_size;\n     }\n   else if (crtl->outgoing_args_size.is_constant (&const_outgoing_args_size)\n-\t   && const_outgoing_args_size + frame.saved_regs_size < 512\n+\t   && frame.saved_regs_size.is_constant (&const_saved_regs_size)\n+\t   && const_outgoing_args_size + const_saved_regs_size < 512\n+\t   /* We could handle this case even with outgoing args, provided\n+\t      that the number of args left us with valid offsets for all\n+\t      predicate and vector save slots.  It's such a rare case that\n+\t      it hardly seems worth the effort though.  */\n+\t   && (!saves_below_hard_fp_p || const_outgoing_args_size == 0)\n \t   && !(cfun->calls_alloca\n \t\t&& frame.hard_fp_offset.is_constant (&const_fp_offset)\n \t\t&& const_fp_offset < max_push_offset))\n     {\n       /* Frame with small outgoing arguments:\n+\n \t sub sp, sp, frame_size\n \t stp reg1, reg2, [sp, outgoing_args_size]\n \t stp reg3, reg4, [sp, outgoing_args_size + 16]  */\n       frame.initial_adjust = frame.frame_size;\n       frame.callee_offset = const_outgoing_args_size;\n     }\n+  else if (saves_below_hard_fp_p\n+\t   && known_eq (frame.saved_regs_size,\n+\t\t\tframe.below_hard_fp_saved_regs_size))\n+    {\n+      /* Frame in which all saves are SVE saves:\n+\n+\t sub sp, sp, hard_fp_offset + below_hard_fp_saved_regs_size\n+\t save SVE registers relative to SP\n+\t sub sp, sp, outgoing_args_size  */\n+      frame.initial_adjust = (frame.hard_fp_offset\n+\t\t\t      + frame.below_hard_fp_saved_regs_size);\n+      frame.final_adjust = crtl->outgoing_args_size;\n+    }\n   else if (frame.hard_fp_offset.is_constant (&const_fp_offset)\n \t   && const_fp_offset < max_push_offset)\n     {\n-      /* Frame with large outgoing arguments but a small local area:\n+      /* Frame with large outgoing arguments or SVE saves, but with\n+\t a small local area:\n+\n \t stp reg1, reg2, [sp, -hard_fp_offset]!\n \t stp reg3, reg4, [sp, 16]\n+\t [sub sp, sp, below_hard_fp_saved_regs_size]\n+\t [save SVE registers relative to SP]\n \t sub sp, sp, outgoing_args_size  */\n       frame.callee_adjust = const_fp_offset;\n+      frame.sve_callee_adjust = frame.below_hard_fp_saved_regs_size;\n       frame.final_adjust = crtl->outgoing_args_size;\n     }\n   else\n     {\n-      /* Frame with large local area and outgoing arguments using frame pointer:\n+      /* Frame with large local area and outgoing arguments or SVE saves,\n+\t using frame pointer:\n+\n \t sub sp, sp, hard_fp_offset\n \t stp x29, x30, [sp, 0]\n \t add x29, sp, 0\n \t stp reg3, reg4, [sp, 16]\n+\t [sub sp, sp, below_hard_fp_saved_regs_size]\n+\t [save SVE registers relative to SP]\n \t sub sp, sp, outgoing_args_size  */\n       frame.initial_adjust = frame.hard_fp_offset;\n+      frame.sve_callee_adjust = frame.below_hard_fp_saved_regs_size;\n       frame.final_adjust = crtl->outgoing_args_size;\n     }\n \n   /* Make sure the individual adjustments add up to the full frame size.  */\n   gcc_assert (known_eq (frame.initial_adjust\n \t\t\t+ frame.callee_adjust\n+\t\t\t+ frame.sve_callee_adjust\n \t\t\t+ frame.final_adjust, frame.frame_size));\n \n   frame.laid_out = true;\n@@ -5667,7 +6013,7 @@ aarch64_layout_frame (void)\n static bool\n aarch64_register_saved_on_entry (int regno)\n {\n-  return cfun->machine->frame.reg_offset[regno] >= 0;\n+  return known_ge (cfun->machine->frame.reg_offset[regno], 0);\n }\n \n /* Return the next register up from REGNO up to LIMIT for the callee\n@@ -5734,7 +6080,7 @@ static void\n aarch64_push_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment)\n {\n   rtx_insn *insn;\n-  machine_mode mode = aarch64_reg_save_mode (cfun->decl, regno1);\n+  machine_mode mode = aarch64_reg_save_mode (regno1);\n \n   if (regno2 == INVALID_REGNUM)\n     return aarch64_pushwb_single_reg (mode, regno1, adjustment);\n@@ -5780,7 +6126,7 @@ static void\n aarch64_pop_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment,\n \t\t  rtx *cfi_ops)\n {\n-  machine_mode mode = aarch64_reg_save_mode (cfun->decl, regno1);\n+  machine_mode mode = aarch64_reg_save_mode (regno1);\n   rtx reg1 = gen_rtx_REG (mode, regno1);\n \n   *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg1, *cfi_ops);\n@@ -5859,7 +6205,7 @@ aarch64_return_address_signing_enabled (void)\n      if its LR is pushed onto stack.  */\n   return (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL\n \t  || (aarch64_ra_sign_scope == AARCH64_FUNCTION_NON_LEAF\n-\t      && cfun->machine->frame.reg_offset[LR_REGNUM] >= 0));\n+\t      && known_ge (cfun->machine->frame.reg_offset[LR_REGNUM], 0)));\n }\n \n /* Return TRUE if Branch Target Identification Mechanism is enabled.  */\n@@ -5869,125 +6215,234 @@ aarch64_bti_enabled (void)\n   return (aarch64_enable_bti == 1);\n }\n \n+/* The caller is going to use ST1D or LD1D to save or restore an SVE\n+   register in mode MODE at BASE_RTX + OFFSET, where OFFSET is in\n+   the range [1, 16] * GET_MODE_SIZE (MODE).  Prepare for this by:\n+\n+     (1) updating BASE_RTX + OFFSET so that it is a legitimate ST1D\n+\t or LD1D address\n+\n+     (2) setting PRED to a valid predicate register for the ST1D or LD1D,\n+\t if the variable isn't already nonnull\n+\n+   (1) is needed when OFFSET is in the range [8, 16] * GET_MODE_SIZE (MODE).\n+   Handle this case using a temporary base register that is suitable for\n+   all offsets in that range.  Use ANCHOR_REG as this base register if it\n+   is nonnull, otherwise create a new register and store it in ANCHOR_REG.  */\n+\n+static inline void\n+aarch64_adjust_sve_callee_save_base (machine_mode mode, rtx &base_rtx,\n+\t\t\t\t     rtx &anchor_reg, poly_int64 &offset,\n+\t\t\t\t     rtx &ptrue)\n+{\n+  if (maybe_ge (offset, 8 * GET_MODE_SIZE (mode)))\n+    {\n+      /* This is the maximum valid offset of the anchor from the base.\n+\t Lower values would be valid too.  */\n+      poly_int64 anchor_offset = 16 * GET_MODE_SIZE (mode);\n+      if (!anchor_reg)\n+\t{\n+\t  anchor_reg = gen_rtx_REG (Pmode, STACK_CLASH_SVE_CFA_REGNUM);\n+\t  emit_insn (gen_add3_insn (anchor_reg, base_rtx,\n+\t\t\t\t    gen_int_mode (anchor_offset, Pmode)));\n+\t}\n+      base_rtx = anchor_reg;\n+      offset -= anchor_offset;\n+    }\n+  if (!ptrue)\n+    {\n+      int pred_reg = cfun->machine->frame.spare_pred_reg;\n+      emit_move_insn (gen_rtx_REG (VNx16BImode, pred_reg),\n+\t\t      CONSTM1_RTX (VNx16BImode));\n+      ptrue = gen_rtx_REG (VNx2BImode, pred_reg);\n+    }\n+}\n+\n+/* Add a REG_CFA_EXPRESSION note to INSN to say that register REG\n+   is saved at BASE + OFFSET.  */\n+\n+static void\n+aarch64_add_cfa_expression (rtx_insn *insn, rtx reg,\n+\t\t\t    rtx base, poly_int64 offset)\n+{\n+  rtx mem = gen_frame_mem (GET_MODE (reg),\n+\t\t\t   plus_constant (Pmode, base, offset));\n+  add_reg_note (insn, REG_CFA_EXPRESSION, gen_rtx_SET (mem, reg));\n+}\n+\n /* Emit code to save the callee-saved registers from register number START\n    to LIMIT to the stack at the location starting at offset START_OFFSET,\n-   skipping any write-back candidates if SKIP_WB is true.  */\n+   skipping any write-back candidates if SKIP_WB is true.  HARD_FP_VALID_P\n+   is true if the hard frame pointer has been set up.  */\n \n static void\n-aarch64_save_callee_saves (machine_mode mode, poly_int64 start_offset,\n-\t\t\t   unsigned start, unsigned limit, bool skip_wb)\n+aarch64_save_callee_saves (poly_int64 start_offset,\n+\t\t\t   unsigned start, unsigned limit, bool skip_wb,\n+\t\t\t   bool hard_fp_valid_p)\n {\n   rtx_insn *insn;\n   unsigned regno;\n   unsigned regno2;\n+  rtx anchor_reg = NULL_RTX, ptrue = NULL_RTX;\n \n   for (regno = aarch64_next_callee_save (start, limit);\n        regno <= limit;\n        regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n       rtx reg, mem;\n       poly_int64 offset;\n-      int offset_diff;\n+      bool frame_related_p = aarch64_emit_cfi_for_reg_p (regno);\n \n       if (skip_wb\n \t  && (regno == cfun->machine->frame.wb_candidate1\n \t      || regno == cfun->machine->frame.wb_candidate2))\n \tcontinue;\n \n       if (cfun->machine->reg_is_wrapped_separately[regno])\n-       continue;\n+\tcontinue;\n \n+      machine_mode mode = aarch64_reg_save_mode (regno);\n       reg = gen_rtx_REG (mode, regno);\n       offset = start_offset + cfun->machine->frame.reg_offset[regno];\n-      mem = gen_frame_mem (mode, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\toffset));\n+      rtx base_rtx = stack_pointer_rtx;\n+      poly_int64 sp_offset = offset;\n \n-      regno2 = aarch64_next_callee_save (regno + 1, limit);\n-      offset_diff = cfun->machine->frame.reg_offset[regno2]\n-\t\t    - cfun->machine->frame.reg_offset[regno];\n+      HOST_WIDE_INT const_offset;\n+      if (mode == VNx2DImode && BYTES_BIG_ENDIAN)\n+\taarch64_adjust_sve_callee_save_base (mode, base_rtx, anchor_reg,\n+\t\t\t\t\t     offset, ptrue);\n+      else if (GP_REGNUM_P (regno)\n+\t       && (!offset.is_constant (&const_offset) || const_offset >= 512))\n+\t{\n+\t  gcc_assert (known_eq (start_offset, 0));\n+\t  poly_int64 fp_offset\n+\t    = cfun->machine->frame.below_hard_fp_saved_regs_size;\n+\t  if (hard_fp_valid_p)\n+\t    base_rtx = hard_frame_pointer_rtx;\n+\t  else\n+\t    {\n+\t      if (!anchor_reg)\n+\t\t{\n+\t\t  anchor_reg = gen_rtx_REG (Pmode, STACK_CLASH_SVE_CFA_REGNUM);\n+\t\t  emit_insn (gen_add3_insn (anchor_reg, base_rtx,\n+\t\t\t\t\t    gen_int_mode (fp_offset, Pmode)));\n+\t\t}\n+\t      base_rtx = anchor_reg;\n+\t    }\n+\t  offset -= fp_offset;\n+\t}\n+      mem = gen_frame_mem (mode, plus_constant (Pmode, base_rtx, offset));\n+      bool need_cfa_note_p = (base_rtx != stack_pointer_rtx);\n \n-      if (regno2 <= limit\n+      if (!aarch64_sve_mode_p (mode)\n+\t  && (regno2 = aarch64_next_callee_save (regno + 1, limit)) <= limit\n \t  && !cfun->machine->reg_is_wrapped_separately[regno2]\n-\t  && known_eq (GET_MODE_SIZE (mode), offset_diff))\n+\t  && known_eq (GET_MODE_SIZE (mode),\n+\t\t       cfun->machine->frame.reg_offset[regno2]\n+\t\t       - cfun->machine->frame.reg_offset[regno]))\n \t{\n \t  rtx reg2 = gen_rtx_REG (mode, regno2);\n \t  rtx mem2;\n \n-\t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n-\t  mem2 = gen_frame_mem (mode, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t     offset));\n+\t  offset += GET_MODE_SIZE (mode);\n+\t  mem2 = gen_frame_mem (mode, plus_constant (Pmode, base_rtx, offset));\n \t  insn = emit_insn (aarch64_gen_store_pair (mode, mem, reg, mem2,\n \t\t\t\t\t\t    reg2));\n \n \t  /* The first part of a frame-related parallel insn is\n \t     always assumed to be relevant to the frame\n \t     calculations; subsequent parts, are only\n \t     frame-related if explicitly marked.  */\n-\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t  if (aarch64_emit_cfi_for_reg_p (regno2))\n+\t    {\n+\t      if (need_cfa_note_p)\n+\t\taarch64_add_cfa_expression (insn, reg2, stack_pointer_rtx,\n+\t\t\t\t\t    sp_offset + GET_MODE_SIZE (mode));\n+\t      else\n+\t\tRTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t    }\n+\n \t  regno = regno2;\n \t}\n+      else if (mode == VNx2DImode && BYTES_BIG_ENDIAN)\n+\t{\n+\t  insn = emit_insn (gen_aarch64_pred_mov (mode, mem, ptrue, reg));\n+\t  need_cfa_note_p = true;\n+\t}\n+      else if (aarch64_sve_mode_p (mode))\n+\tinsn = emit_insn (gen_rtx_SET (mem, reg));\n       else\n \tinsn = emit_move_insn (mem, reg);\n \n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n+      if (frame_related_p && need_cfa_note_p)\n+\taarch64_add_cfa_expression (insn, reg, stack_pointer_rtx, sp_offset);\n     }\n }\n \n-/* Emit code to restore the callee registers of mode MODE from register\n-   number START up to and including LIMIT.  Restore from the stack offset\n-   START_OFFSET, skipping any write-back candidates if SKIP_WB is true.\n-   Write the appropriate REG_CFA_RESTORE notes into CFI_OPS.  */\n+/* Emit code to restore the callee registers from register number START\n+   up to and including LIMIT.  Restore from the stack offset START_OFFSET,\n+   skipping any write-back candidates if SKIP_WB is true.  Write the\n+   appropriate REG_CFA_RESTORE notes into CFI_OPS.  */\n \n static void\n-aarch64_restore_callee_saves (machine_mode mode,\n-\t\t\t      poly_int64 start_offset, unsigned start,\n+aarch64_restore_callee_saves (poly_int64 start_offset, unsigned start,\n \t\t\t      unsigned limit, bool skip_wb, rtx *cfi_ops)\n {\n-  rtx base_rtx = stack_pointer_rtx;\n   unsigned regno;\n   unsigned regno2;\n   poly_int64 offset;\n+  rtx anchor_reg = NULL_RTX, ptrue = NULL_RTX;\n \n   for (regno = aarch64_next_callee_save (start, limit);\n        regno <= limit;\n        regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n+      bool frame_related_p = aarch64_emit_cfi_for_reg_p (regno);\n       if (cfun->machine->reg_is_wrapped_separately[regno])\n-       continue;\n+\tcontinue;\n \n       rtx reg, mem;\n-      int offset_diff;\n \n       if (skip_wb\n \t  && (regno == cfun->machine->frame.wb_candidate1\n \t      || regno == cfun->machine->frame.wb_candidate2))\n \tcontinue;\n \n+      machine_mode mode = aarch64_reg_save_mode (regno);\n       reg = gen_rtx_REG (mode, regno);\n       offset = start_offset + cfun->machine->frame.reg_offset[regno];\n+      rtx base_rtx = stack_pointer_rtx;\n+      if (mode == VNx2DImode && BYTES_BIG_ENDIAN)\n+\taarch64_adjust_sve_callee_save_base (mode, base_rtx, anchor_reg,\n+\t\t\t\t\t     offset, ptrue);\n       mem = gen_frame_mem (mode, plus_constant (Pmode, base_rtx, offset));\n \n-      regno2 = aarch64_next_callee_save (regno + 1, limit);\n-      offset_diff = cfun->machine->frame.reg_offset[regno2]\n-\t\t    - cfun->machine->frame.reg_offset[regno];\n-\n-      if (regno2 <= limit\n+      if (!aarch64_sve_mode_p (mode)\n+\t  && (regno2 = aarch64_next_callee_save (regno + 1, limit)) <= limit\n \t  && !cfun->machine->reg_is_wrapped_separately[regno2]\n-\t  && known_eq (GET_MODE_SIZE (mode), offset_diff))\n+\t  && known_eq (GET_MODE_SIZE (mode),\n+\t\t       cfun->machine->frame.reg_offset[regno2]\n+\t\t       - cfun->machine->frame.reg_offset[regno]))\n \t{\n \t  rtx reg2 = gen_rtx_REG (mode, regno2);\n \t  rtx mem2;\n \n-\t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n+\t  offset += GET_MODE_SIZE (mode);\n \t  mem2 = gen_frame_mem (mode, plus_constant (Pmode, base_rtx, offset));\n \t  emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2, mem2));\n \n \t  *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg2, *cfi_ops);\n \t  regno = regno2;\n \t}\n+      else if (mode == VNx2DImode && BYTES_BIG_ENDIAN)\n+\temit_insn (gen_aarch64_pred_mov (mode, reg, ptrue, mem));\n+      else if (aarch64_sve_mode_p (mode))\n+\temit_insn (gen_rtx_SET (reg, mem));\n       else\n \temit_move_insn (reg, mem);\n-      *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg, *cfi_ops);\n+      if (frame_related_p)\n+\t*cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg, *cfi_ops);\n     }\n }\n \n@@ -6069,20 +6524,48 @@ aarch64_get_separate_components (void)\n   for (unsigned regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n     if (aarch64_register_saved_on_entry (regno))\n       {\n+\t/* Punt on saves and restores that use ST1D and LD1D.  We could\n+\t   try to be smarter, but it would involve making sure that the\n+\t   spare predicate register itself is safe to use at the save\n+\t   and restore points.  Also, when a frame pointer is being used,\n+\t   the slots are often out of reach of ST1D and LD1D anyway.  */\n+\tmachine_mode mode = aarch64_reg_save_mode (regno);\n+\tif (mode == VNx2DImode && BYTES_BIG_ENDIAN)\n+\t  continue;\n+\n \tpoly_int64 offset = cfun->machine->frame.reg_offset[regno];\n-\tif (!frame_pointer_needed)\n-\t  offset += cfun->machine->frame.frame_size\n-\t\t    - cfun->machine->frame.hard_fp_offset;\n+\n+\t/* If the register is saved in the first SVE save slot, we use\n+\t   it as a stack probe for -fstack-clash-protection.  */\n+\tif (flag_stack_clash_protection\n+\t    && maybe_ne (cfun->machine->frame.below_hard_fp_saved_regs_size, 0)\n+\t    && known_eq (offset, 0))\n+\t  continue;\n+\n+\t/* Get the offset relative to the register we'll use.  */\n+\tif (frame_pointer_needed)\n+\t  offset -= cfun->machine->frame.below_hard_fp_saved_regs_size;\n+\telse\n+\t  offset += crtl->outgoing_args_size;\n+\n \t/* Check that we can access the stack slot of the register with one\n \t   direct load with no adjustments needed.  */\n-\tif (offset_12bit_unsigned_scaled_p (DImode, offset))\n+\tif (aarch64_sve_mode_p (mode)\n+\t    ? offset_9bit_signed_scaled_p (mode, offset)\n+\t    : offset_12bit_unsigned_scaled_p (mode, offset))\n \t  bitmap_set_bit (components, regno);\n       }\n \n   /* Don't mess with the hard frame pointer.  */\n   if (frame_pointer_needed)\n     bitmap_clear_bit (components, HARD_FRAME_POINTER_REGNUM);\n \n+  /* If the spare predicate register used by big-endian SVE code\n+     is call-preserved, it must be saved in the main prologue\n+     before any saves that use it.  */\n+  if (cfun->machine->frame.spare_pred_reg != INVALID_REGNUM)\n+    bitmap_clear_bit (components, cfun->machine->frame.spare_pred_reg);\n+\n   unsigned reg1 = cfun->machine->frame.wb_candidate1;\n   unsigned reg2 = cfun->machine->frame.wb_candidate2;\n   /* If registers have been chosen to be stored/restored with\n@@ -6136,18 +6619,19 @@ aarch64_components_for_bb (basic_block bb)\n \t    || bitmap_bit_p (gen, regno)\n \t    || bitmap_bit_p (kill, regno)))\n       {\n-\tunsigned regno2, offset, offset2;\n \tbitmap_set_bit (components, regno);\n \n \t/* If there is a callee-save at an adjacent offset, add it too\n \t   to increase the use of LDP/STP.  */\n-\toffset = cfun->machine->frame.reg_offset[regno];\n-\tregno2 = ((offset & 8) == 0) ? regno + 1 : regno - 1;\n+\tpoly_int64 offset = cfun->machine->frame.reg_offset[regno];\n+\tunsigned regno2 = multiple_p (offset, 16) ? regno + 1 : regno - 1;\n \n \tif (regno2 <= LAST_SAVED_REGNUM)\n \t  {\n-\t    offset2 = cfun->machine->frame.reg_offset[regno2];\n-\t    if ((offset & ~8) == (offset2 & ~8))\n+\t    poly_int64 offset2 = cfun->machine->frame.reg_offset[regno2];\n+\t    if (regno < regno2\n+\t\t? known_eq (offset + 8, offset2)\n+\t\t: multiple_p (offset2, 16) && known_eq (offset2 + 8, offset))\n \t      bitmap_set_bit (components, regno2);\n \t  }\n       }\n@@ -6202,16 +6686,16 @@ aarch64_process_components (sbitmap components, bool prologue_p)\n \n   while (regno != last_regno)\n     {\n-      /* AAPCS64 section 5.1.2 requires only the low 64 bits to be saved\n-\t so DFmode for the vector registers is enough.  For simd functions\n-\t we want to save the low 128 bits.  */\n-      machine_mode mode = aarch64_reg_save_mode (cfun->decl, regno);\n+      bool frame_related_p = aarch64_emit_cfi_for_reg_p (regno);\n+      machine_mode mode = aarch64_reg_save_mode (regno);\n       \n       rtx reg = gen_rtx_REG (mode, regno);\n       poly_int64 offset = cfun->machine->frame.reg_offset[regno];\n-      if (!frame_pointer_needed)\n-\toffset += cfun->machine->frame.frame_size\n-\t\t  - cfun->machine->frame.hard_fp_offset;\n+      if (frame_pointer_needed)\n+\toffset -= cfun->machine->frame.below_hard_fp_saved_regs_size;\n+      else\n+\toffset += crtl->outgoing_args_size;\n+\n       rtx addr = plus_constant (Pmode, ptr_reg, offset);\n       rtx mem = gen_frame_mem (mode, addr);\n \n@@ -6222,39 +6706,49 @@ aarch64_process_components (sbitmap components, bool prologue_p)\n       if (regno2 == last_regno)\n \t{\n \t  insn = emit_insn (set);\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  if (prologue_p)\n-\t    add_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set));\n-\t  else\n-\t    add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t  if (frame_related_p)\n+\t    {\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      if (prologue_p)\n+\t\tadd_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set));\n+\t      else\n+\t\tadd_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t    }\n \t  break;\n \t}\n \n       poly_int64 offset2 = cfun->machine->frame.reg_offset[regno2];\n       /* The next register is not of the same class or its offset is not\n \t mergeable with the current one into a pair.  */\n-      if (!satisfies_constraint_Ump (mem)\n+      if (aarch64_sve_mode_p (mode)\n+\t  || !satisfies_constraint_Ump (mem)\n \t  || GP_REGNUM_P (regno) != GP_REGNUM_P (regno2)\n \t  || (crtl->abi->id () == ARM_PCS_SIMD && FP_REGNUM_P (regno))\n \t  || maybe_ne ((offset2 - cfun->machine->frame.reg_offset[regno]),\n \t\t       GET_MODE_SIZE (mode)))\n \t{\n \t  insn = emit_insn (set);\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  if (prologue_p)\n-\t    add_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set));\n-\t  else\n-\t    add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t  if (frame_related_p)\n+\t    {\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      if (prologue_p)\n+\t\tadd_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set));\n+\t      else\n+\t\tadd_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t    }\n \n \t  regno = regno2;\n \t  continue;\n \t}\n \n+      bool frame_related2_p = aarch64_emit_cfi_for_reg_p (regno2);\n+\n       /* REGNO2 can be saved/restored in a pair with REGNO.  */\n       rtx reg2 = gen_rtx_REG (mode, regno2);\n-      if (!frame_pointer_needed)\n-\toffset2 += cfun->machine->frame.frame_size\n-\t\t  - cfun->machine->frame.hard_fp_offset;\n+      if (frame_pointer_needed)\n+\toffset2 -= cfun->machine->frame.below_hard_fp_saved_regs_size;\n+      else\n+\toffset2 += crtl->outgoing_args_size;\n       rtx addr2 = plus_constant (Pmode, ptr_reg, offset2);\n       rtx mem2 = gen_frame_mem (mode, addr2);\n       rtx set2 = prologue_p ? gen_rtx_SET (mem2, reg2)\n@@ -6265,16 +6759,23 @@ aarch64_process_components (sbitmap components, bool prologue_p)\n       else\n \tinsn = emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2, mem2));\n \n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      if (prologue_p)\n+      if (frame_related_p || frame_related2_p)\n \t{\n-\t  add_reg_note (insn, REG_CFA_OFFSET, set);\n-\t  add_reg_note (insn, REG_CFA_OFFSET, set2);\n-\t}\n-      else\n-\t{\n-\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  if (prologue_p)\n+\t    {\n+\t      if (frame_related_p)\n+\t\tadd_reg_note (insn, REG_CFA_OFFSET, set);\n+\t      if (frame_related2_p)\n+\t\tadd_reg_note (insn, REG_CFA_OFFSET, set2);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (frame_related_p)\n+\t\tadd_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t      if (frame_related2_p)\n+\t\tadd_reg_note (insn, REG_CFA_RESTORE, reg2);\n+\t    }\n \t}\n \n       regno = aarch64_get_next_set_bit (components, regno2 + 1);\n@@ -6343,15 +6844,31 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,\n   HOST_WIDE_INT guard_size\n     = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n   HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;\n-  /* When doing the final adjustment for the outgoing argument size we can't\n-     assume that LR was saved at position 0.  So subtract it's offset from the\n-     ABI safe buffer so that we don't accidentally allow an adjustment that\n-     would result in an allocation larger than the ABI buffer without\n-     probing.  */\n   HOST_WIDE_INT min_probe_threshold\n-    = final_adjustment_p\n-      ? guard_used_by_caller - cfun->machine->frame.reg_offset[LR_REGNUM]\n-      : guard_size - guard_used_by_caller;\n+    = (final_adjustment_p\n+       ? guard_used_by_caller\n+       : guard_size - guard_used_by_caller);\n+  /* When doing the final adjustment for the outgoing arguments, take into\n+     account any unprobed space there is above the current SP.  There are\n+     two cases:\n+\n+     - When saving SVE registers below the hard frame pointer, we force\n+       the lowest save to take place in the prologue before doing the final\n+       adjustment (i.e. we don't allow the save to be shrink-wrapped).\n+       This acts as a probe at SP, so there is no unprobed space.\n+\n+     - When there are no SVE register saves, we use the store of the link\n+       register as a probe.  We can't assume that LR was saved at position 0\n+       though, so treat any space below it as unprobed.  */\n+  if (final_adjustment_p\n+      && known_eq (cfun->machine->frame.below_hard_fp_saved_regs_size, 0))\n+    {\n+      poly_int64 lr_offset = cfun->machine->frame.reg_offset[LR_REGNUM];\n+      if (known_ge (lr_offset, 0))\n+\tmin_probe_threshold -= lr_offset.to_constant ();\n+      else\n+\tgcc_assert (!flag_stack_clash_protection || known_eq (poly_size, 0));\n+    }\n \n   poly_int64 frame_size = cfun->machine->frame.frame_size;\n \n@@ -6361,13 +6878,15 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,\n   if (flag_stack_clash_protection && !final_adjustment_p)\n     {\n       poly_int64 initial_adjust = cfun->machine->frame.initial_adjust;\n+      poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;\n       poly_int64 final_adjust = cfun->machine->frame.final_adjust;\n \n       if (known_eq (frame_size, 0))\n \t{\n \t  dump_stack_clash_frame_info (NO_PROBE_NO_FRAME, false);\n \t}\n-      else if (known_lt (initial_adjust, guard_size - guard_used_by_caller)\n+      else if (known_lt (initial_adjust + sve_callee_adjust,\n+\t\t\t guard_size - guard_used_by_caller)\n \t       && known_lt (final_adjust, guard_used_by_caller))\n \t{\n \t  dump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);\n@@ -6571,18 +7090,6 @@ aarch64_epilogue_uses (int regno)\n   return 0;\n }\n \n-/* Add a REG_CFA_EXPRESSION note to INSN to say that register REG\n-   is saved at BASE + OFFSET.  */\n-\n-static void\n-aarch64_add_cfa_expression (rtx_insn *insn, unsigned int reg,\n-\t\t\t    rtx base, poly_int64 offset)\n-{\n-  rtx mem = gen_frame_mem (DImode, plus_constant (Pmode, base, offset));\n-  add_reg_note (insn, REG_CFA_EXPRESSION,\n-\t\tgen_rtx_SET (mem, regno_reg_rtx[reg]));\n-}\n-\n /* AArch64 stack frames generated by this compiler look like:\n \n \t+-------------------------------+\n@@ -6604,8 +7111,12 @@ aarch64_add_cfa_expression (rtx_insn *insn, unsigned int reg,\n \t+-------------------------------+  |\n \t|  LR'                          |  |\n \t+-------------------------------+  |\n-\t|  FP'                          | / <- hard_frame_pointer_rtx (aligned)\n-        +-------------------------------+\n+\t|  FP'                          |  |\n+\t+-------------------------------+  |<- hard_frame_pointer_rtx (aligned)\n+\t|  SVE vector registers         |  | \\\n+\t+-------------------------------+  |  | below_hard_fp_saved_regs_size\n+\t|  SVE predicate registers      | /  /\n+\t+-------------------------------+\n \t|  dynamic allocation           |\n \t+-------------------------------+\n \t|  padding                      |\n@@ -6638,7 +7149,8 @@ aarch64_add_cfa_expression (rtx_insn *insn, unsigned int reg,\n    The following registers are reserved during frame layout and should not be\n    used for any other purpose:\n \n-   - r11: Used by stack clash protection when SVE is enabled.\n+   - r11: Used by stack clash protection when SVE is enabled, and also\n+\t  as an anchor register when saving and restoring registers\n    - r12(EP0) and r13(EP1): Used as temporaries for stack adjustment.\n    - r14 and r15: Used for speculation tracking.\n    - r16(IP0), r17(IP1): Used by indirect tailcalls.\n@@ -6661,11 +7173,23 @@ aarch64_expand_prologue (void)\n   HOST_WIDE_INT callee_adjust = cfun->machine->frame.callee_adjust;\n   poly_int64 final_adjust = cfun->machine->frame.final_adjust;\n   poly_int64 callee_offset = cfun->machine->frame.callee_offset;\n+  poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;\n+  poly_int64 below_hard_fp_saved_regs_size\n+    = cfun->machine->frame.below_hard_fp_saved_regs_size;\n   unsigned reg1 = cfun->machine->frame.wb_candidate1;\n   unsigned reg2 = cfun->machine->frame.wb_candidate2;\n   bool emit_frame_chain = cfun->machine->frame.emit_frame_chain;\n   rtx_insn *insn;\n \n+  if (flag_stack_clash_protection && known_eq (callee_adjust, 0))\n+    {\n+      /* Fold the SVE allocation into the initial allocation.\n+\t We don't do this in aarch64_layout_arg to avoid pessimizing\n+\t the epilogue code.  */\n+      initial_adjust += sve_callee_adjust;\n+      sve_callee_adjust = 0;\n+    }\n+\n   /* Sign return address for functions.  */\n   if (aarch64_return_address_signing_enabled ())\n     {\n@@ -6718,18 +7242,27 @@ aarch64_expand_prologue (void)\n   if (callee_adjust != 0)\n     aarch64_push_regs (reg1, reg2, callee_adjust);\n \n+  /* The offset of the frame chain record (if any) from the current SP.  */\n+  poly_int64 chain_offset = (initial_adjust + callee_adjust\n+\t\t\t     - cfun->machine->frame.hard_fp_offset);\n+  gcc_assert (known_ge (chain_offset, 0));\n+\n+  /* The offset of the bottom of the save area from the current SP.  */\n+  poly_int64 saved_regs_offset = chain_offset - below_hard_fp_saved_regs_size;\n+\n   if (emit_frame_chain)\n     {\n-      poly_int64 reg_offset = callee_adjust;\n       if (callee_adjust == 0)\n \t{\n \t  reg1 = R29_REGNUM;\n \t  reg2 = R30_REGNUM;\n-\t  reg_offset = callee_offset;\n-\t  aarch64_save_callee_saves (DImode, reg_offset, reg1, reg2, false);\n+\t  aarch64_save_callee_saves (saved_regs_offset, reg1, reg2,\n+\t\t\t\t     false, false);\n \t}\n+      else\n+\tgcc_assert (known_eq (chain_offset, 0));\n       aarch64_add_offset (Pmode, hard_frame_pointer_rtx,\n-\t\t\t  stack_pointer_rtx, callee_offset,\n+\t\t\t  stack_pointer_rtx, chain_offset,\n \t\t\t  tmp1_rtx, tmp0_rtx, frame_pointer_needed);\n       if (frame_pointer_needed && !frame_size.is_constant ())\n \t{\n@@ -6756,23 +7289,31 @@ aarch64_expand_prologue (void)\n \n \t  /* Change the save slot expressions for the registers that\n \t     we've already saved.  */\n-\t  reg_offset -= callee_offset;\n-\t  aarch64_add_cfa_expression (insn, reg2, hard_frame_pointer_rtx,\n-\t\t\t\t      reg_offset + UNITS_PER_WORD);\n-\t  aarch64_add_cfa_expression (insn, reg1, hard_frame_pointer_rtx,\n-\t\t\t\t      reg_offset);\n+\t  aarch64_add_cfa_expression (insn, regno_reg_rtx[reg2],\n+\t\t\t\t      hard_frame_pointer_rtx, UNITS_PER_WORD);\n+\t  aarch64_add_cfa_expression (insn, regno_reg_rtx[reg1],\n+\t\t\t\t      hard_frame_pointer_rtx, 0);\n \t}\n       emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n     }\n \n-  aarch64_save_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n-\t\t\t     callee_adjust != 0 || emit_frame_chain);\n-  if (crtl->abi->id () == ARM_PCS_SIMD)\n-    aarch64_save_callee_saves (TFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t       callee_adjust != 0 || emit_frame_chain);\n-  else\n-    aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t       callee_adjust != 0 || emit_frame_chain);\n+  aarch64_save_callee_saves (saved_regs_offset, R0_REGNUM, R30_REGNUM,\n+\t\t\t     callee_adjust != 0 || emit_frame_chain,\n+\t\t\t     emit_frame_chain);\n+  if (maybe_ne (sve_callee_adjust, 0))\n+    {\n+      gcc_assert (!flag_stack_clash_protection\n+\t\t  || known_eq (initial_adjust, 0));\n+      aarch64_allocate_and_probe_stack_space (tmp1_rtx, tmp0_rtx,\n+\t\t\t\t\t      sve_callee_adjust,\n+\t\t\t\t\t      !frame_pointer_needed, false);\n+      saved_regs_offset += sve_callee_adjust;\n+    }\n+  aarch64_save_callee_saves (saved_regs_offset, P0_REGNUM, P15_REGNUM,\n+\t\t\t     false, emit_frame_chain);\n+  aarch64_save_callee_saves (saved_regs_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t     callee_adjust != 0 || emit_frame_chain,\n+\t\t\t     emit_frame_chain);\n \n   /* We may need to probe the final adjustment if it is larger than the guard\n      that is assumed by the called.  */\n@@ -6810,6 +7351,9 @@ aarch64_expand_epilogue (bool for_sibcall)\n   HOST_WIDE_INT callee_adjust = cfun->machine->frame.callee_adjust;\n   poly_int64 final_adjust = cfun->machine->frame.final_adjust;\n   poly_int64 callee_offset = cfun->machine->frame.callee_offset;\n+  poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;\n+  poly_int64 below_hard_fp_saved_regs_size\n+    = cfun->machine->frame.below_hard_fp_saved_regs_size;\n   unsigned reg1 = cfun->machine->frame.wb_candidate1;\n   unsigned reg2 = cfun->machine->frame.wb_candidate2;\n   rtx cfi_ops = NULL;\n@@ -6823,15 +7367,23 @@ aarch64_expand_epilogue (bool for_sibcall)\n     = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n   HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;\n \n-  /* We can re-use the registers when the allocation amount is smaller than\n-     guard_size - guard_used_by_caller because we won't be doing any probes\n-     then.  In such situations the register should remain live with the correct\n+  /* We can re-use the registers when:\n+\n+     (a) the deallocation amount is the same as the corresponding\n+\t allocation amount (which is false if we combine the initial\n+\t and SVE callee save allocations in the prologue); and\n+\n+     (b) the allocation amount doesn't need a probe (which is false\n+\t if the amount is guard_size - guard_used_by_caller or greater).\n+\n+     In such situations the register should remain live with the correct\n      value.  */\n   bool can_inherit_p = (initial_adjust.is_constant ()\n-\t\t\t&& final_adjust.is_constant ())\n+\t\t\t&& final_adjust.is_constant ()\n \t\t\t&& (!flag_stack_clash_protection\n-\t\t\t    || known_lt (initial_adjust,\n-\t\t\t\t\t guard_size - guard_used_by_caller));\n+\t\t\t    || (known_lt (initial_adjust,\n+\t\t\t\t\t  guard_size - guard_used_by_caller)\n+\t\t\t\t&& known_eq (sve_callee_adjust, 0))));\n \n   /* We need to add memory barrier to prevent read from deallocated stack.  */\n   bool need_barrier_p\n@@ -6856,22 +7408,26 @@ aarch64_expand_epilogue (bool for_sibcall)\n     /* If writeback is used when restoring callee-saves, the CFA\n        is restored on the instruction doing the writeback.  */\n     aarch64_add_offset (Pmode, stack_pointer_rtx,\n-\t\t\thard_frame_pointer_rtx, -callee_offset,\n+\t\t\thard_frame_pointer_rtx,\n+\t\t\t-callee_offset - below_hard_fp_saved_regs_size,\n \t\t\ttmp1_rtx, tmp0_rtx, callee_adjust == 0);\n   else\n      /* The case where we need to re-use the register here is very rare, so\n \tavoid the complicated condition and just always emit a move if the\n \timmediate doesn't fit.  */\n      aarch64_add_sp (tmp1_rtx, tmp0_rtx, final_adjust, true);\n \n-  aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n+  /* Restore the vector registers before the predicate registers,\n+     so that we can use P4 as a temporary for big-endian SVE frames.  */\n+  aarch64_restore_callee_saves (callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t\tcallee_adjust != 0, &cfi_ops);\n+  aarch64_restore_callee_saves (callee_offset, P0_REGNUM, P15_REGNUM,\n+\t\t\t\tfalse, &cfi_ops);\n+  if (maybe_ne (sve_callee_adjust, 0))\n+    aarch64_add_sp (NULL_RTX, NULL_RTX, sve_callee_adjust, true);\n+  aarch64_restore_callee_saves (callee_offset - sve_callee_adjust,\n+\t\t\t\tR0_REGNUM, R30_REGNUM,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);\n-  if (crtl->abi->id () == ARM_PCS_SIMD)\n-    aarch64_restore_callee_saves (TFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t\t  callee_adjust != 0, &cfi_ops);\n-  else\n-    aarch64_restore_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t\t  callee_adjust != 0, &cfi_ops);\n \n   if (need_barrier_p)\n     emit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n@@ -9397,13 +9953,14 @@ aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t  secondary_reload_info *sri)\n {\n   /* Use aarch64_sve_reload_be for SVE reloads that cannot be handled\n-     directly by the *aarch64_sve_mov<mode>_be move pattern.  See the\n+     directly by the *aarch64_sve_mov<mode>_[lb]e move patterns.  See the\n      comment at the head of aarch64-sve.md for more details about the\n      big-endian handling.  */\n   if (BYTES_BIG_ENDIAN\n       && reg_class_subset_p (rclass, FP_REGS)\n       && !((REG_P (x) && HARD_REGISTER_P (x))\n \t   || aarch64_simd_valid_immediate (x, NULL))\n+      && mode != VNx16QImode\n       && aarch64_sve_data_mode_p (mode))\n     {\n       sri->icode = CODE_FOR_aarch64_sve_reload_be;\n@@ -14983,6 +15540,10 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n   machine_mode mode;\n   HOST_WIDE_INT size;\n \n+  /* SVE types (and types containing SVE types) must be handled\n+     before calling this function.  */\n+  gcc_assert (!aarch64_sve::builtin_type_p (type));\n+\n   switch (TREE_CODE (type))\n     {\n     case REAL_TYPE:\n@@ -15154,6 +15715,9 @@ aarch64_short_vector_p (const_tree type,\n {\n   poly_int64 size = -1;\n \n+  if (type && aarch64_sve::builtin_type_p (type))\n+    return false;\n+\n   if (type && TREE_CODE (type) == VECTOR_TYPE)\n     size = int_size_in_bytes (type);\n   else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n@@ -15214,11 +15778,14 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n \t\t\t\t\t int *count,\n \t\t\t\t\t bool *is_ha)\n {\n+  if (is_ha != NULL) *is_ha = false;\n+\n+  if (type && aarch64_sve::builtin_type_p (type))\n+    return false;\n+\n   machine_mode new_mode = VOIDmode;\n   bool composite_p = aarch64_composite_type_p (type, mode);\n \n-  if (is_ha != NULL) *is_ha = false;\n-\n   if ((!composite_p && GET_MODE_CLASS (mode) == MODE_FLOAT)\n       || aarch64_short_vector_p (type, mode))\n     {\n@@ -17121,11 +17688,15 @@ aarch64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)\n static void\n aarch64_asm_output_variant_pcs (FILE *stream, const tree decl, const char* name)\n {\n-  if (aarch64_simd_decl_p (decl))\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      fprintf (stream, \"\\t.variant_pcs\\t\");\n-      assemble_name (stream, name);\n-      fprintf (stream, \"\\n\");\n+      arm_pcs pcs = (arm_pcs) fndecl_abi (decl).id ();\n+      if (pcs == ARM_PCS_SIMD || pcs == ARM_PCS_SVE)\n+\t{\n+\t  fprintf (stream, \"\\t.variant_pcs\\t\");\n+\t  assemble_name (stream, name);\n+\t  fprintf (stream, \"\\n\");\n+\t}\n     }\n }\n \n@@ -21373,6 +21944,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_ASM_POST_CFI_STARTPROC\n #define TARGET_ASM_POST_CFI_STARTPROC aarch64_post_cfi_startproc\n \n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-aarch64.h\""}, {"sha": "425a36332cd8d3a34aef8ae2e34de6d7900a1808", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -479,9 +479,10 @@ extern unsigned aarch64_architecture_version;\n #define ARG_POINTER_REGNUM\t\tAP_REGNUM\n #define FIRST_PSEUDO_REGISTER\t\t(FFRT_REGNUM + 1)\n \n-/* The number of (integer) argument register available.  */\n+/* The number of argument registers available for each class.  */\n #define NUM_ARG_REGS\t\t\t8\n #define NUM_FP_ARG_REGS\t\t\t8\n+#define NUM_PR_ARG_REGS\t\t\t4\n \n /* A Homogeneous Floating-Point or Short-Vector Aggregate may have at most\n    four members.  */\n@@ -725,17 +726,20 @@ extern enum aarch64_processor aarch64_tune;\n #ifdef HAVE_POLY_INT_H\n struct GTY (()) aarch64_frame\n {\n-  HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n+  poly_int64 reg_offset[LAST_SAVED_REGNUM + 1];\n \n   /* The number of extra stack bytes taken up by register varargs.\n      This area is allocated by the callee at the very top of the\n      frame.  This value is rounded up to a multiple of\n      STACK_BOUNDARY.  */\n   HOST_WIDE_INT saved_varargs_size;\n \n-  /* The size of the saved callee-save int/FP registers.  */\n+  /* The size of the callee-save registers with a slot in REG_OFFSET.  */\n+  poly_int64 saved_regs_size;\n \n-  HOST_WIDE_INT saved_regs_size;\n+  /* The size of the callee-save registers with a slot in REG_OFFSET that\n+     are saved below the hard frame pointer.  */\n+  poly_int64 below_hard_fp_saved_regs_size;\n \n   /* Offset from the base of the frame (incomming SP) to the\n      top of the locals area.  This value is always a multiple of\n@@ -763,6 +767,10 @@ struct GTY (()) aarch64_frame\n      It may be non-zero if no push is used (ie. callee_adjust == 0).  */\n   poly_int64 callee_offset;\n \n+  /* The size of the stack adjustment before saving or after restoring\n+     SVE registers.  */\n+  poly_int64 sve_callee_adjust;\n+\n   /* The size of the stack adjustment after saving callee-saves.  */\n   poly_int64 final_adjust;\n \n@@ -772,6 +780,11 @@ struct GTY (()) aarch64_frame\n   unsigned wb_candidate1;\n   unsigned wb_candidate2;\n \n+  /* Big-endian SVE frames need a spare predicate register in order\n+     to save vector registers in the correct layout for unwinding.\n+     This is the register they should use.  */\n+  unsigned spare_pred_reg;\n+\n   bool laid_out;\n };\n \n@@ -800,6 +813,8 @@ enum arm_pcs\n {\n   ARM_PCS_AAPCS64,\t\t/* Base standard AAPCS for 64 bit.  */\n   ARM_PCS_SIMD,\t\t\t/* For aarch64_vector_pcs functions.  */\n+  ARM_PCS_SVE,\t\t\t/* For functions that pass or return\n+\t\t\t\t   values in SVE registers.  */\n   ARM_PCS_TLSDESC,\t\t/* For targets of tlsdesc calls.  */\n   ARM_PCS_UNKNOWN\n };\n@@ -827,6 +842,8 @@ typedef struct\n   int aapcs_nextncrn;\t\t/* Next next core register number.  */\n   int aapcs_nvrn;\t\t/* Next Vector register number.  */\n   int aapcs_nextnvrn;\t\t/* Next Next Vector register number.  */\n+  int aapcs_nprn;\t\t/* Next Predicate register number.  */\n+  int aapcs_nextnprn;\t\t/* Next Next Predicate register number.  */\n   rtx aapcs_reg;\t\t/* Register assigned to this argument.  This\n \t\t\t\t   is NULL_RTX if this parameter goes on\n \t\t\t\t   the stack.  */\n@@ -837,6 +854,8 @@ typedef struct\n \t\t\t\t   aapcs_reg == NULL_RTX.  */\n   int aapcs_stack_size;\t\t/* The total size (in words, per 8 byte) of the\n \t\t\t\t   stack arg area so far.  */\n+  bool silent_p;\t\t/* True if we should act silently, rather than\n+\t\t\t\t   raise an error for invalid calls.  */\n } CUMULATIVE_ARGS;\n #endif\n \n@@ -1144,7 +1163,8 @@ extern poly_uint16 aarch64_sve_vg;\n #define BITS_PER_SVE_VECTOR (poly_uint16 (aarch64_sve_vg * 64))\n #define BYTES_PER_SVE_VECTOR (poly_uint16 (aarch64_sve_vg * 8))\n \n-/* The number of bytes in an SVE predicate.  */\n+/* The number of bits and bytes in an SVE predicate.  */\n+#define BITS_PER_SVE_PRED BYTES_PER_SVE_VECTOR\n #define BYTES_PER_SVE_PRED aarch64_sve_vg\n \n /* The SVE mode for a vector of bytes.  */"}, {"sha": "f19e2272750f7d1aefbd74f2908e629675067443", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -85,7 +85,6 @@\n     (V29_REGNUM\t\t61)\n     (V30_REGNUM\t\t62)\n     (V31_REGNUM\t\t63)\n-    (LAST_SAVED_REGNUM\t63)\n     (SFP_REGNUM\t\t64)\n     (AP_REGNUM\t\t65)\n     (CC_REGNUM\t\t66)\n@@ -107,6 +106,7 @@\n     (P13_REGNUM\t\t81)\n     (P14_REGNUM\t\t82)\n     (P15_REGNUM\t\t83)\n+    (LAST_SAVED_REGNUM\t83)\n     (FFR_REGNUM\t\t84)\n     ;; \"FFR token\": a fake register used for representing the scheduling\n     ;; restrictions on FFR-related operations."}, {"sha": "e2656d54e370ab689586d950a151d8ee3f31f861", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -1,3 +1,142 @@\n+2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/pcs/aarch64-sve-pcs.exp: New file.\n+\t* gcc.target/aarch64/sve/pcs/annotate_1.c: New test.\n+\t* gcc.target/aarch64/sve/pcs/annotate_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/annotate_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/annotate_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/annotate_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/annotate_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/annotate_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_10.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_11_nosc.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_11_sc.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_f16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_f32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_f64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_s16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_s32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_s64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_s8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_u16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_u32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_u64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_be_u8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_f16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_f32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_f64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_s16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_s32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_s64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_s8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_u16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_u32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_u64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_5_le_u8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_f16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_f32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_f64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_s16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_s32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_s64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_s8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_u16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_u32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_u64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_be_u8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_f16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_f32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_f64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_s16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_s32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_s64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_s8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_u16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_u32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_u64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_6_le_u8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/args_9.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/nosve_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_1_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_1_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_1_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_1_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_4_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_4_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_4_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_4_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_5_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_5_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_5_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_5_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_6_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_6_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_6_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_6_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/return_9.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_1_be_nowrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_1_be_wrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_1_le_nowrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_1_le_wrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_2_be_nowrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_2_be_wrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_2_le_nowrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_2_le_wrap.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_4_be.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_4_le.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_5_be.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/saves_5_le.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_1_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_1_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_1_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_1_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_2_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_2_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_2_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_2_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/stack_clash_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/unprototyped_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_f16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_f32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_f64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_s16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_s32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_s64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_s8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_u16.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_u32.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_u64.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_2_u8.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_3_nosc.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/varargs_3_sc.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/vpcs_1.c: Likewise.\n+\t* g++.target/aarch64/sve/catch_7.C: Likewise.\n+\n 2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>"}, {"sha": "ac10b6984349f1b561c5a6eafdb10547872235cc", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_7.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_7.C?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O\" } */\n+\n+#include <arm_sve.h>\n+\n+void __attribute__ ((noipa))\n+f1 (void)\n+{\n+  throw 1;\n+}\n+\n+void __attribute__ ((noipa))\n+f2 (svbool_t)\n+{\n+  register svint8_t z8 asm (\"z8\") = svindex_s8 (11, 1);\n+  asm volatile (\"\" :: \"w\" (z8));\n+  f1 ();\n+}\n+\n+void __attribute__ ((noipa))\n+f3 (int n)\n+{\n+  register double d8 asm (\"v8\") = 42.0;\n+  for (int i = 0; i < n; ++i)\n+    {\n+      asm volatile (\"\" : \"=w\" (d8) : \"w\" (d8));\n+      try { f2 (svptrue_b8 ()); } catch (int) { break; }\n+    }\n+  if (d8 != 42.0)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  f3 (100);\n+  return 0;\n+}"}, {"sha": "7458875937c08713f5682e76d610a7fae34302ca", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/aarch64-sve-pcs.exp", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Faarch64-sve-pcs.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Faarch64-sve-pcs.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Faarch64-sve-pcs.exp?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,52 @@\n+#  Specific regression driver for AArch64 SVE.\n+#  Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+#  Contributed by ARM Ltd.\n+#\n+#  This file is part of GCC.\n+#\n+#  GCC is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3, or (at your option)\n+#  any later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but\n+#  WITHOUT ANY WARRANTY; without even the implied warranty of\n+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+#  General Public License for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.  */\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an AArch64 target.\n+if {![istarget aarch64*-*-*] } then {\n+    return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Force SVE if we're not testing it already.\n+if { [check_effective_target_aarch64_sve] } {\n+    set sve_flags \"\"\n+} else {\n+    set sve_flags \"-march=armv8.2-a+sve\"\n+}\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \\\n+    $sve_flags $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "1172be5ebf1c8210b283d16969c4935538814811", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_1.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svbool_t ret_b (void) { return svptrue_b8 (); }\n+\n+svint8_t ret_s8 (void) { return svdup_s8 (0); }\n+svint16_t ret_s16 (void) { return svdup_s16 (0); }\n+svint32_t ret_s32 (void) { return svdup_s32 (0); }\n+svint64_t ret_s64 (void) { return svdup_s64 (0); }\n+svuint8_t ret_u8 (void) { return svdup_u8 (0); }\n+svuint16_t ret_u16 (void) { return svdup_u16 (0); }\n+svuint32_t ret_u32 (void) { return svdup_u32 (0); }\n+svuint64_t ret_u64 (void) { return svdup_u64 (0); }\n+svfloat16_t ret_f16 (void) { return svdup_f16 (0); }\n+svfloat32_t ret_f32 (void) { return svdup_f32 (0); }\n+svfloat64_t ret_f64 (void) { return svdup_f64 (0); }\n+\n+svint8x2_t ret_s8x2 (void) { return svundef2_s8 (); }\n+svint16x2_t ret_s16x2 (void) { return svundef2_s16 (); }\n+svint32x2_t ret_s32x2 (void) { return svundef2_s32 (); }\n+svint64x2_t ret_s64x2 (void) { return svundef2_s64 (); }\n+svuint8x2_t ret_u8x2 (void) { return svundef2_u8 (); }\n+svuint16x2_t ret_u16x2 (void) { return svundef2_u16 (); }\n+svuint32x2_t ret_u32x2 (void) { return svundef2_u32 (); }\n+svuint64x2_t ret_u64x2 (void) { return svundef2_u64 (); }\n+svfloat16x2_t ret_f16x2 (void) { return svundef2_f16 (); }\n+svfloat32x2_t ret_f32x2 (void) { return svundef2_f32 (); }\n+svfloat64x2_t ret_f64x2 (void) { return svundef2_f64 (); }\n+\n+svint8x3_t ret_s8x3 (void) { return svundef3_s8 (); }\n+svint16x3_t ret_s16x3 (void) { return svundef3_s16 (); }\n+svint32x3_t ret_s32x3 (void) { return svundef3_s32 (); }\n+svint64x3_t ret_s64x3 (void) { return svundef3_s64 (); }\n+svuint8x3_t ret_u8x3 (void) { return svundef3_u8 (); }\n+svuint16x3_t ret_u16x3 (void) { return svundef3_u16 (); }\n+svuint32x3_t ret_u32x3 (void) { return svundef3_u32 (); }\n+svuint64x3_t ret_u64x3 (void) { return svundef3_u64 (); }\n+svfloat16x3_t ret_f16x3 (void) { return svundef3_f16 (); }\n+svfloat32x3_t ret_f32x3 (void) { return svundef3_f32 (); }\n+svfloat64x3_t ret_f64x3 (void) { return svundef3_f64 (); }\n+\n+svint8x4_t ret_s8x4 (void) { return svundef4_s8 (); }\n+svint16x4_t ret_s16x4 (void) { return svundef4_s16 (); }\n+svint32x4_t ret_s32x4 (void) { return svundef4_s32 (); }\n+svint64x4_t ret_s64x4 (void) { return svundef4_s64 (); }\n+svuint8x4_t ret_u8x4 (void) { return svundef4_u8 (); }\n+svuint16x4_t ret_u16x4 (void) { return svundef4_u16 (); }\n+svuint32x4_t ret_u32x4 (void) { return svundef4_u32 (); }\n+svuint64x4_t ret_u64x4 (void) { return svundef4_u64 (); }\n+svfloat16x4_t ret_f16x4 (void) { return svundef4_f16 (); }\n+svfloat32x4_t ret_f32x4 (void) { return svundef4_f32 (); }\n+svfloat64x4_t ret_f64x4 (void) { return svundef4_f64 (); }\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_b\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f64\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f64x2\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f64x3\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s8x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_s64x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u8x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_u64x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tret_f64x4\\n} } } */"}, {"sha": "6f10f90d12dfffcb8f961b6a63d709704971514f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_2.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_2.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void fn_b (svbool_t x) {}\n+\n+void fn_s8 (svint8_t x) {}\n+void fn_s16 (svint16_t x) {}\n+void fn_s32 (svint32_t x) {}\n+void fn_s64 (svint64_t x) {}\n+void fn_u8 (svuint8_t x) {}\n+void fn_u16 (svuint16_t x) {}\n+void fn_u32 (svuint32_t x) {}\n+void fn_u64 (svuint64_t x) {}\n+void fn_f16 (svfloat16_t x) {}\n+void fn_f32 (svfloat32_t x) {}\n+void fn_f64 (svfloat64_t x) {}\n+\n+void fn_s8x2 (svint8x2_t x) {}\n+void fn_s16x2 (svint16x2_t x) {}\n+void fn_s32x2 (svint32x2_t x) {}\n+void fn_s64x2 (svint64x2_t x) {}\n+void fn_u8x2 (svuint8x2_t x) {}\n+void fn_u16x2 (svuint16x2_t x) {}\n+void fn_u32x2 (svuint32x2_t x) {}\n+void fn_u64x2 (svuint64x2_t x) {}\n+void fn_f16x2 (svfloat16x2_t x) {}\n+void fn_f32x2 (svfloat32x2_t x) {}\n+void fn_f64x2 (svfloat64x2_t x) {}\n+\n+void fn_s8x3 (svint8x3_t x) {}\n+void fn_s16x3 (svint16x3_t x) {}\n+void fn_s32x3 (svint32x3_t x) {}\n+void fn_s64x3 (svint64x3_t x) {}\n+void fn_u8x3 (svuint8x3_t x) {}\n+void fn_u16x3 (svuint16x3_t x) {}\n+void fn_u32x3 (svuint32x3_t x) {}\n+void fn_u64x3 (svuint64x3_t x) {}\n+void fn_f16x3 (svfloat16x3_t x) {}\n+void fn_f32x3 (svfloat32x3_t x) {}\n+void fn_f64x3 (svfloat64x3_t x) {}\n+\n+void fn_s8x4 (svint8x4_t x) {}\n+void fn_s16x4 (svint16x4_t x) {}\n+void fn_s32x4 (svint32x4_t x) {}\n+void fn_s64x4 (svint64x4_t x) {}\n+void fn_u8x4 (svuint8x4_t x) {}\n+void fn_u16x4 (svuint16x4_t x) {}\n+void fn_u32x4 (svuint32x4_t x) {}\n+void fn_u64x4 (svuint64x4_t x) {}\n+void fn_f16x4 (svfloat16x4_t x) {}\n+void fn_f32x4 (svfloat32x4_t x) {}\n+void fn_f64x4 (svfloat64x4_t x) {}\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_b\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x2\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x3\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x4\\n} } } */"}, {"sha": "d922a8a2290dafb2b5eebfecc768595b3d840d6f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_3.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_3.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void fn_s8 (float d0, float d1, float d2, float d3, svint8_t x) {}\n+void fn_s16 (float d0, float d1, float d2, float d3, svint16_t x) {}\n+void fn_s32 (float d0, float d1, float d2, float d3, svint32_t x) {}\n+void fn_s64 (float d0, float d1, float d2, float d3, svint64_t x) {}\n+void fn_u8 (float d0, float d1, float d2, float d3, svuint8_t x) {}\n+void fn_u16 (float d0, float d1, float d2, float d3, svuint16_t x) {}\n+void fn_u32 (float d0, float d1, float d2, float d3, svuint32_t x) {}\n+void fn_u64 (float d0, float d1, float d2, float d3, svuint64_t x) {}\n+void fn_f16 (float d0, float d1, float d2, float d3, svfloat16_t x) {}\n+void fn_f32 (float d0, float d1, float d2, float d3, svfloat32_t x) {}\n+void fn_f64 (float d0, float d1, float d2, float d3, svfloat64_t x) {}\n+\n+void fn_s8x2 (float d0, float d1, float d2, float d3, svint8x2_t x) {}\n+void fn_s16x2 (float d0, float d1, float d2, float d3, svint16x2_t x) {}\n+void fn_s32x2 (float d0, float d1, float d2, float d3, svint32x2_t x) {}\n+void fn_s64x2 (float d0, float d1, float d2, float d3, svint64x2_t x) {}\n+void fn_u8x2 (float d0, float d1, float d2, float d3, svuint8x2_t x) {}\n+void fn_u16x2 (float d0, float d1, float d2, float d3, svuint16x2_t x) {}\n+void fn_u32x2 (float d0, float d1, float d2, float d3, svuint32x2_t x) {}\n+void fn_u64x2 (float d0, float d1, float d2, float d3, svuint64x2_t x) {}\n+void fn_f16x2 (float d0, float d1, float d2, float d3, svfloat16x2_t x) {}\n+void fn_f32x2 (float d0, float d1, float d2, float d3, svfloat32x2_t x) {}\n+void fn_f64x2 (float d0, float d1, float d2, float d3, svfloat64x2_t x) {}\n+\n+void fn_s8x3 (float d0, float d1, float d2, float d3, svint8x3_t x) {}\n+void fn_s16x3 (float d0, float d1, float d2, float d3, svint16x3_t x) {}\n+void fn_s32x3 (float d0, float d1, float d2, float d3, svint32x3_t x) {}\n+void fn_s64x3 (float d0, float d1, float d2, float d3, svint64x3_t x) {}\n+void fn_u8x3 (float d0, float d1, float d2, float d3, svuint8x3_t x) {}\n+void fn_u16x3 (float d0, float d1, float d2, float d3, svuint16x3_t x) {}\n+void fn_u32x3 (float d0, float d1, float d2, float d3, svuint32x3_t x) {}\n+void fn_u64x3 (float d0, float d1, float d2, float d3, svuint64x3_t x) {}\n+void fn_f16x3 (float d0, float d1, float d2, float d3, svfloat16x3_t x) {}\n+void fn_f32x3 (float d0, float d1, float d2, float d3, svfloat32x3_t x) {}\n+void fn_f64x3 (float d0, float d1, float d2, float d3, svfloat64x3_t x) {}\n+\n+void fn_s8x4 (float d0, float d1, float d2, float d3, svint8x4_t x) {}\n+void fn_s16x4 (float d0, float d1, float d2, float d3, svint16x4_t x) {}\n+void fn_s32x4 (float d0, float d1, float d2, float d3, svint32x4_t x) {}\n+void fn_s64x4 (float d0, float d1, float d2, float d3, svint64x4_t x) {}\n+void fn_u8x4 (float d0, float d1, float d2, float d3, svuint8x4_t x) {}\n+void fn_u16x4 (float d0, float d1, float d2, float d3, svuint16x4_t x) {}\n+void fn_u32x4 (float d0, float d1, float d2, float d3, svuint32x4_t x) {}\n+void fn_u64x4 (float d0, float d1, float d2, float d3, svuint64x4_t x) {}\n+void fn_f16x4 (float d0, float d1, float d2, float d3, svfloat16x4_t x) {}\n+void fn_f32x4 (float d0, float d1, float d2, float d3, svfloat32x4_t x) {}\n+void fn_f64x4 (float d0, float d1, float d2, float d3, svfloat64x4_t x) {}\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x2\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x3\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x4\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x4\\n} } } */"}, {"sha": "d057158346ff153d409599778bc8a208c1edc0bb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_4.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_4.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,143 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void fn_s8 (float d0, float d1, float d2, float d3,\n+\t    float d4, svint8_t x) {}\n+void fn_s16 (float d0, float d1, float d2, float d3,\n+\t     float d4, svint16_t x) {}\n+void fn_s32 (float d0, float d1, float d2, float d3,\n+\t     float d4, svint32_t x) {}\n+void fn_s64 (float d0, float d1, float d2, float d3,\n+\t     float d4, svint64_t x) {}\n+void fn_u8 (float d0, float d1, float d2, float d3,\n+\t    float d4, svuint8_t x) {}\n+void fn_u16 (float d0, float d1, float d2, float d3,\n+\t     float d4, svuint16_t x) {}\n+void fn_u32 (float d0, float d1, float d2, float d3,\n+\t     float d4, svuint32_t x) {}\n+void fn_u64 (float d0, float d1, float d2, float d3,\n+\t     float d4, svuint64_t x) {}\n+void fn_f16 (float d0, float d1, float d2, float d3,\n+\t     float d4, svfloat16_t x) {}\n+void fn_f32 (float d0, float d1, float d2, float d3,\n+\t     float d4, svfloat32_t x) {}\n+void fn_f64 (float d0, float d1, float d2, float d3,\n+\t     float d4, svfloat64_t x) {}\n+\n+void fn_s8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, svint8x2_t x) {}\n+void fn_s16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint16x2_t x) {}\n+void fn_s32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint32x2_t x) {}\n+void fn_s64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint64x2_t x) {}\n+void fn_u8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, svuint8x2_t x) {}\n+void fn_u16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint16x2_t x) {}\n+void fn_u32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint32x2_t x) {}\n+void fn_u64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint64x2_t x) {}\n+void fn_f16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat16x2_t x) {}\n+void fn_f32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat32x2_t x) {}\n+void fn_f64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat64x2_t x) {}\n+\n+void fn_s8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, svint8x3_t x) {}\n+void fn_s16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint16x3_t x) {}\n+void fn_s32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint32x3_t x) {}\n+void fn_s64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint64x3_t x) {}\n+void fn_u8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, svuint8x3_t x) {}\n+void fn_u16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint16x3_t x) {}\n+void fn_u32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint32x3_t x) {}\n+void fn_u64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint64x3_t x) {}\n+void fn_f16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat16x3_t x) {}\n+void fn_f32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat32x3_t x) {}\n+void fn_f64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat64x3_t x) {}\n+\n+void fn_s8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, svint8x4_t x) {}\n+void fn_s16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint16x4_t x) {}\n+void fn_s32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint32x4_t x) {}\n+void fn_s64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svint64x4_t x) {}\n+void fn_u8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, svuint8x4_t x) {}\n+void fn_u16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint16x4_t x) {}\n+void fn_u32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint32x4_t x) {}\n+void fn_u64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svuint64x4_t x) {}\n+void fn_f16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat16x4_t x) {}\n+void fn_f32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat32x4_t x) {}\n+void fn_f64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, svfloat64x4_t x) {}\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x2\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x3\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x3\\n} } } */\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s8x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s64x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u8x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u64x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f64x4\\n} } } */"}, {"sha": "3523528f6afd3ec14974cc50ca80322e350dee79", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_5.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_5.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,143 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void fn_s8 (float d0, float d1, float d2, float d3,\n+\t    float d4, float d5, svint8_t x) {}\n+void fn_s16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svint16_t x) {}\n+void fn_s32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svint32_t x) {}\n+void fn_s64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svint64_t x) {}\n+void fn_u8 (float d0, float d1, float d2, float d3,\n+\t    float d4, float d5, svuint8_t x) {}\n+void fn_u16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svuint16_t x) {}\n+void fn_u32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svuint32_t x) {}\n+void fn_u64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svuint64_t x) {}\n+void fn_f16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svfloat16_t x) {}\n+void fn_f32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svfloat32_t x) {}\n+void fn_f64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, svfloat64_t x) {}\n+\n+void fn_s8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, svint8x2_t x) {}\n+void fn_s16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint16x2_t x) {}\n+void fn_s32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint32x2_t x) {}\n+void fn_s64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint64x2_t x) {}\n+void fn_u8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, svuint8x2_t x) {}\n+void fn_u16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint16x2_t x) {}\n+void fn_u32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint32x2_t x) {}\n+void fn_u64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint64x2_t x) {}\n+void fn_f16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat16x2_t x) {}\n+void fn_f32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat32x2_t x) {}\n+void fn_f64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat64x2_t x) {}\n+\n+void fn_s8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, svint8x3_t x) {}\n+void fn_s16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint16x3_t x) {}\n+void fn_s32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint32x3_t x) {}\n+void fn_s64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint64x3_t x) {}\n+void fn_u8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, svuint8x3_t x) {}\n+void fn_u16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint16x3_t x) {}\n+void fn_u32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint32x3_t x) {}\n+void fn_u64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint64x3_t x) {}\n+void fn_f16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat16x3_t x) {}\n+void fn_f32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat32x3_t x) {}\n+void fn_f64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat64x3_t x) {}\n+\n+void fn_s8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, svint8x4_t x) {}\n+void fn_s16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint16x4_t x) {}\n+void fn_s32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint32x4_t x) {}\n+void fn_s64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svint64x4_t x) {}\n+void fn_u8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, svuint8x4_t x) {}\n+void fn_u16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint16x4_t x) {}\n+void fn_u32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint32x4_t x) {}\n+void fn_u64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svuint64x4_t x) {}\n+void fn_f16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat16x4_t x) {}\n+void fn_f32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat32x4_t x) {}\n+void fn_f64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, svfloat64x4_t x) {}\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64\\n} } } */\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32x2\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64x2\\n} } } */\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s8x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s16x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s32x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s64x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u8x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u16x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u32x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u64x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f16x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f32x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f64x3\\n} } } */\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s8x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s64x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u8x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u64x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f64x4\\n} } } */"}, {"sha": "1f89dcef4d27a3fcbcb590d2d2713918b4561c8d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_6.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_6.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,143 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void fn_s8 (float d0, float d1, float d2, float d3,\n+\t    float d4, float d5, float d6, svint8_t x) {}\n+void fn_s16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svint16_t x) {}\n+void fn_s32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svint32_t x) {}\n+void fn_s64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svint64_t x) {}\n+void fn_u8 (float d0, float d1, float d2, float d3,\n+\t    float d4, float d5, float d6, svuint8_t x) {}\n+void fn_u16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svuint16_t x) {}\n+void fn_u32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svuint32_t x) {}\n+void fn_u64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svuint64_t x) {}\n+void fn_f16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svfloat16_t x) {}\n+void fn_f32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svfloat32_t x) {}\n+void fn_f64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, svfloat64_t x) {}\n+\n+void fn_s8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, svint8x2_t x) {}\n+void fn_s16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint16x2_t x) {}\n+void fn_s32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint32x2_t x) {}\n+void fn_s64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint64x2_t x) {}\n+void fn_u8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, svuint8x2_t x) {}\n+void fn_u16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint16x2_t x) {}\n+void fn_u32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint32x2_t x) {}\n+void fn_u64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint64x2_t x) {}\n+void fn_f16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat16x2_t x) {}\n+void fn_f32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat32x2_t x) {}\n+void fn_f64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat64x2_t x) {}\n+\n+void fn_s8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, svint8x3_t x) {}\n+void fn_s16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint16x3_t x) {}\n+void fn_s32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint32x3_t x) {}\n+void fn_s64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint64x3_t x) {}\n+void fn_u8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, svuint8x3_t x) {}\n+void fn_u16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint16x3_t x) {}\n+void fn_u32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint32x3_t x) {}\n+void fn_u64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint64x3_t x) {}\n+void fn_f16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat16x3_t x) {}\n+void fn_f32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat32x3_t x) {}\n+void fn_f64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat64x3_t x) {}\n+\n+void fn_s8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, svint8x4_t x) {}\n+void fn_s16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint16x4_t x) {}\n+void fn_s32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint32x4_t x) {}\n+void fn_s64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svint64x4_t x) {}\n+void fn_u8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, svuint8x4_t x) {}\n+void fn_u16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint16x4_t x) {}\n+void fn_u32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint32x4_t x) {}\n+void fn_u64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svuint64x4_t x) {}\n+void fn_f16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat16x4_t x) {}\n+void fn_f32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat32x4_t x) {}\n+void fn_f64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, svfloat64x4_t x) {}\n+\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_s64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u8\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_u64\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f16\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f32\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tfn_f64\\n} } } */\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s8x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s16x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s32x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s64x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u8x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u16x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u32x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u64x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f16x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f32x2\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f64x2\\n} } } */\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s8x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s16x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s32x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s64x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u8x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u16x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u32x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u64x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f16x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f32x3\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f64x3\\n} } } */\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s8x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_s64x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u8x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_u64x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f16x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f32x4\\n} } } */\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tfn_f64x4\\n} } } */"}, {"sha": "e67d1801d60b5fccc1375eac45c09949abde24ed", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/annotate_7.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fannotate_7.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void fn_s8 (float d0, float d1, float d2, float d3,\n+\t    float d4, float d5, float d6, float d7, svint8_t x) {}\n+void fn_s16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svint16_t x) {}\n+void fn_s32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svint32_t x) {}\n+void fn_s64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svint64_t x) {}\n+void fn_u8 (float d0, float d1, float d2, float d3,\n+\t    float d4, float d5, float d6, float d7, svuint8_t x) {}\n+void fn_u16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svuint16_t x) {}\n+void fn_u32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svuint32_t x) {}\n+void fn_u64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svuint64_t x) {}\n+void fn_f16 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svfloat16_t x) {}\n+void fn_f32 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svfloat32_t x) {}\n+void fn_f64 (float d0, float d1, float d2, float d3,\n+\t     float d4, float d5, float d6, float d7, svfloat64_t x) {}\n+\n+void fn_s8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, float d7, svint8x2_t x) {}\n+void fn_s16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint16x2_t x) {}\n+void fn_s32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint32x2_t x) {}\n+void fn_s64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint64x2_t x) {}\n+void fn_u8x2 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, float d7, svuint8x2_t x) {}\n+void fn_u16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint16x2_t x) {}\n+void fn_u32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint32x2_t x) {}\n+void fn_u64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint64x2_t x) {}\n+void fn_f16x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat16x2_t x) {}\n+void fn_f32x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat32x2_t x) {}\n+void fn_f64x2 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat64x2_t x) {}\n+\n+void fn_s8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, float d7, svint8x3_t x) {}\n+void fn_s16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint16x3_t x) {}\n+void fn_s32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint32x3_t x) {}\n+void fn_s64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint64x3_t x) {}\n+void fn_u8x3 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, float d7, svuint8x3_t x) {}\n+void fn_u16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint16x3_t x) {}\n+void fn_u32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint32x3_t x) {}\n+void fn_u64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint64x3_t x) {}\n+void fn_f16x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat16x3_t x) {}\n+void fn_f32x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat32x3_t x) {}\n+void fn_f64x3 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat64x3_t x) {}\n+\n+void fn_s8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, float d7, svint8x4_t x) {}\n+void fn_s16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint16x4_t x) {}\n+void fn_s32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint32x4_t x) {}\n+void fn_s64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svint64x4_t x) {}\n+void fn_u8x4 (float d0, float d1, float d2, float d3,\n+\t      float d4, float d5, float d6, float d7, svuint8x4_t x) {}\n+void fn_u16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint16x4_t x) {}\n+void fn_u32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint32x4_t x) {}\n+void fn_u64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svuint64x4_t x) {}\n+void fn_f16x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat16x4_t x) {}\n+void fn_f32x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat32x4_t x) {}\n+void fn_f64x4 (float d0, float d1, float d2, float d3,\n+\t       float d4, float d5, float d6, float d7, svfloat64x4_t x) {}\n+\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\t\\n} } } */"}, {"sha": "d0c3e5a9d142ac6774b4c649a9c4edd0b6176c68", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_pred:\n+**\tldr\t(p[0-9]+), \\[x0\\]\n+**\tldr\t(p[0-9]+), \\[x1\\]\n+**\tbrkpa\t(p[0-7])\\.b, p0/z, p1\\.b, p2\\.b\n+**\tbrkpb\t(p[0-7])\\.b, \\3/z, p3\\.b, \\1\\.b\n+**\tbrka\tp0\\.b, \\4/z, \\2\\.b\n+**\tret\n+*/\n+__SVBool_t __attribute__((noipa))\n+callee_pred (__SVBool_t p0, __SVBool_t p1, __SVBool_t p2, __SVBool_t p3,\n+\t     __SVBool_t mem0, __SVBool_t mem1)\n+{\n+  p0 = svbrkpa_z (p0, p1, p2);\n+  p0 = svbrkpb_z (p0, p3, mem0);\n+  return svbrka_z (p0, mem1);\n+}\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tptrue\t(p[0-9]+)\\.b, vl5\n+**\tstr\t\\1, \\[x0\\]\n+**\t...\n+**\tptrue\t(p[0-9]+)\\.h, vl6\n+**\tstr\t\\2, \\[x1\\]\n+**\tptrue\tp3\\.d, vl4\n+**\tptrue\tp2\\.s, vl3\n+**\tptrue\tp1\\.h, vl2\n+**\tptrue\tp0\\.b, vl1\n+**\tbl\tcallee_pred\n+**\t...\n+*/\n+__SVBool_t __attribute__((noipa))\n+caller_pred (void)\n+{\n+  return callee_pred (svptrue_pat_b8 (SV_VL1),\n+\t\t      svptrue_pat_b16 (SV_VL2),\n+\t\t      svptrue_pat_b32 (SV_VL3),\n+\t\t      svptrue_pat_b64 (SV_VL4),\n+\t\t      svptrue_pat_b8 (SV_VL5),\n+\t\t      svptrue_pat_b16 (SV_VL6));\n+}"}, {"sha": "1bbcb770dc1e3c7785491ef164c62298c5dac2ac", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_10.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_10.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee:\n+**\tfadd\ts0, (s0, s6|s6, s0)\n+**\tret\n+*/\n+float __attribute__((noipa))\n+callee (float s0, double d1, svfloat32x4_t z2, svfloat64x4_t stack1,\n+\tfloat s6, double d7)\n+{\n+  return s0 + s6;\n+}\n+\n+float __attribute__((noipa))\n+caller (float32_t *x0, float64_t *x1)\n+{\n+  return callee (0.0f, 1.0,\n+\t\t svld4 (svptrue_b8 (), x0),\n+\t\t svld4 (svptrue_b8 (), x1),\n+\t\t 6.0f, 7.0);\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z2\\.s - z5\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - z[0-9]+\\.d}, p[0-7]/z, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmovi\\tv0\\.[24]s, #0\\n} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\td1, #?1\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\ts6, #?6\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\td7, #?7\\.0} } } */"}, {"sha": "0f62e0b0846140fd61fa86f577fff290c67ef34f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_11_nosc.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_11_nosc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_11_nosc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_11_nosc.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O0 -g\" } */\n+\n+#include <arm_sve.h>\n+\n+void __attribute__((noipa))\n+callee (svbool_t p, svint8_t s8, svuint16x4_t u16, svfloat32x3_t f32,\n+\tsvint64x2_t s64)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+\n+  if (svptest_any (pg, sveor_z (pg, p, svptrue_pat_b8 (SV_VL7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, s8, svindex_s8 (1, 2))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 0), svindex_u16 (2, 3))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 1), svindex_u16 (3, 4))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 2), svindex_u16 (4, 5))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 3), svindex_u16 (5, 6))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 0), svdup_f32 (1.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 1), svdup_f32 (2.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 2), svdup_f32 (3.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 0), svindex_s64 (6, 7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 1), svindex_s64 (7, 8))))\n+    __builtin_abort ();\n+}\n+\n+int __attribute__((noipa))\n+main (void)\n+{\n+  callee (svptrue_pat_b8 (SV_VL7),\n+\t  svindex_s8 (1, 2),\n+\t  svcreate4 (svindex_u16 (2, 3),\n+\t\t     svindex_u16 (3, 4),\n+\t\t     svindex_u16 (4, 5),\n+\t\t     svindex_u16 (5, 6)),\n+\t  svcreate3 (svdup_f32 (1.0),\n+\t\t     svdup_f32 (2.0),\n+\t\t     svdup_f32 (3.0)),\n+\t  svcreate2 (svindex_s64 (6, 7),\n+\t\t     svindex_s64 (7, 8)));\n+}"}, {"sha": "8a98d58ce91e8eb24f931a335668d4bd3cc8c70d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_11_sc.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_11_sc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_11_sc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_11_sc.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O0 -fstack-clash-protection -g\" } */\n+\n+#include <arm_sve.h>\n+\n+void __attribute__((noipa))\n+callee (svbool_t p, svint8_t s8, svuint16x4_t u16, svfloat32x3_t f32,\n+\tsvint64x2_t s64)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+\n+  if (svptest_any (pg, sveor_z (pg, p, svptrue_pat_b8 (SV_VL7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, s8, svindex_s8 (1, 2))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 0), svindex_u16 (2, 3))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 1), svindex_u16 (3, 4))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 2), svindex_u16 (4, 5))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 3), svindex_u16 (5, 6))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 0), svdup_f32 (1.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 1), svdup_f32 (2.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 2), svdup_f32 (3.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 0), svindex_s64 (6, 7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 1), svindex_s64 (7, 8))))\n+    __builtin_abort ();\n+}\n+\n+int __attribute__((noipa))\n+main (void)\n+{\n+  callee (svptrue_pat_b8 (SV_VL7),\n+\t  svindex_s8 (1, 2),\n+\t  svcreate4 (svindex_u16 (2, 3),\n+\t\t     svindex_u16 (3, 4),\n+\t\t     svindex_u16 (4, 5),\n+\t\t     svindex_u16 (5, 6)),\n+\t  svcreate3 (svdup_f32 (1.0),\n+\t\t     svdup_f32 (2.0),\n+\t\t     svdup_f32 (3.0)),\n+\t  svcreate2 (svindex_s64 (6, 7),\n+\t\t     svindex_s64 (7, 8)));\n+}"}, {"sha": "a5dd73b03630f928f48388b9a1513d457122f63b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_2.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_int:\n+**\tptrue\tp3\\.b, all\n+**\tld1b\t(z(?:2[4-9]|3[0-1]).b), p3/z, \\[x4\\]\n+**\tst1b\t\\1, p2, \\[x0\\]\n+**\tst1b\tz4\\.b, p1, \\[x0\\]\n+**\tst1h\tz5\\.h, p1, \\[x1\\]\n+**\tst1w\tz6\\.s, p1, \\[x2\\]\n+**\tst1d\tz7\\.d, p1, \\[x3\\]\n+**\tst1b\tz0\\.b, p0, \\[x0\\]\n+**\tst1h\tz1\\.h, p0, \\[x1\\]\n+**\tst1w\tz2\\.s, p0, \\[x2\\]\n+**\tst1d\tz3\\.d, p0, \\[x3\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_int (int8_t *x0, int16_t *x1, int32_t *x2, int64_t *x3,\n+\t    svint8_t z0, svint16_t z1, svint32_t z2, svint64_t z3,\n+\t    svint8_t z4, svint16_t z5, svint32_t z6, svint64_t z7,\n+\t    svint8_t z8,\n+\t    svbool_t p0, svbool_t p1, svbool_t p2)\n+{\n+  svst1 (p2, x0, z8);\n+  svst1 (p1, x0, z4);\n+  svst1 (p1, x1, z5);\n+  svst1 (p1, x2, z6);\n+  svst1 (p1, x3, z7);\n+  svst1 (p0, x0, z0);\n+  svst1 (p0, x1, z1);\n+  svst1 (p0, x2, z2);\n+  svst1 (p0, x3, z3);\n+}\n+\n+void __attribute__((noipa))\n+caller_int (int8_t *x0, int16_t *x1, int32_t *x2, int64_t *x3)\n+{\n+  callee_int (x0, x1, x2, x3,\n+\t      svdup_s8 (0),\n+\t      svdup_s16 (1),\n+\t      svdup_s32 (2),\n+\t      svdup_s64 (3),\n+\t      svdup_s8 (4),\n+\t      svdup_s16 (5),\n+\t      svdup_s32 (6),\n+\t      svdup_s64 (7),\n+\t      svdup_s8 (8),\n+\t      svptrue_pat_b8 (SV_VL1),\n+\t      svptrue_pat_b16 (SV_VL2),\n+\t      svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tmov\\tz0\\.b, #0\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz1\\.h, #1\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz2\\.s, #2\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz3\\.d, #3\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz4\\.b, #4\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz5\\.h, #5\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz6\\.s, #6\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz7\\.d, #7\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx4, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\t(z[0-9]+\\.b), #8\\n.*\\tst1b\\t\\1, p[0-7], \\[x4\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "b44243a9fe4b8e14903b5f08ede5e5b7ed7ed87b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_3.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_uint:\n+**\tptrue\tp3\\.b, all\n+**\tld1b\t(z(?:2[4-9]|3[0-1]).b), p3/z, \\[x4\\]\n+**\tst1b\t\\1, p2, \\[x0\\]\n+**\tst1b\tz4\\.b, p1, \\[x0\\]\n+**\tst1h\tz5\\.h, p1, \\[x1\\]\n+**\tst1w\tz6\\.s, p1, \\[x2\\]\n+**\tst1d\tz7\\.d, p1, \\[x3\\]\n+**\tst1b\tz0\\.b, p0, \\[x0\\]\n+**\tst1h\tz1\\.h, p0, \\[x1\\]\n+**\tst1w\tz2\\.s, p0, \\[x2\\]\n+**\tst1d\tz3\\.d, p0, \\[x3\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_uint (uint8_t *x0, uint16_t *x1, uint32_t *x2, uint64_t *x3,\n+\t     svuint8_t z0, svuint16_t z1, svuint32_t z2, svuint64_t z3,\n+\t     svuint8_t z4, svuint16_t z5, svuint32_t z6, svuint64_t z7,\n+\t     svuint8_t z8,\n+\t     svbool_t p0, svbool_t p1, svbool_t p2)\n+{\n+  svst1 (p2, x0, z8);\n+  svst1 (p1, x0, z4);\n+  svst1 (p1, x1, z5);\n+  svst1 (p1, x2, z6);\n+  svst1 (p1, x3, z7);\n+  svst1 (p0, x0, z0);\n+  svst1 (p0, x1, z1);\n+  svst1 (p0, x2, z2);\n+  svst1 (p0, x3, z3);\n+}\n+\n+void __attribute__((noipa))\n+caller_uint (uint8_t *x0, uint16_t *x1, uint32_t *x2, uint64_t *x3)\n+{\n+  callee_uint (x0, x1, x2, x3,\n+\t       svdup_u8 (0),\n+\t       svdup_u16 (1),\n+\t       svdup_u32 (2),\n+\t       svdup_u64 (3),\n+\t       svdup_u8 (4),\n+\t       svdup_u16 (5),\n+\t       svdup_u32 (6),\n+\t       svdup_u64 (7),\n+\t       svdup_u8 (8),\n+\t       svptrue_pat_b8 (SV_VL1),\n+\t       svptrue_pat_b16 (SV_VL2),\n+\t       svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tmov\\tz0\\.b, #0\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz1\\.h, #1\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz2\\.s, #2\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz3\\.d, #3\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz4\\.b, #4\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz5\\.h, #5\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz6\\.s, #6\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tz7\\.d, #7\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx4, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\t(z[0-9]+\\.b), #8\\n.*\\tst1b\\t\\1, p[0-7], \\[x4\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "0f9966368a3eedced82469ccbc8b72b95bfb85b1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_4.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_4.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_float:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z(?:2[4-9]|3[0-1]).h), p3/z, \\[x4\\]\n+**\tst1h\t\\1, p2, \\[x0\\]\n+**\tst1h\tz4\\.h, p1, \\[x0\\]\n+**\tst1h\tz5\\.h, p1, \\[x1\\]\n+**\tst1w\tz6\\.s, p1, \\[x2\\]\n+**\tst1d\tz7\\.d, p1, \\[x3\\]\n+**\tst1h\tz0\\.h, p0, \\[x0\\]\n+**\tst1h\tz1\\.h, p0, \\[x1\\]\n+**\tst1w\tz2\\.s, p0, \\[x2\\]\n+**\tst1d\tz3\\.d, p0, \\[x3\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_float (float16_t *x0, float16_t *x1, float32_t *x2, float64_t *x3,\n+\t      svfloat16_t z0, svfloat16_t z1, svfloat32_t z2, svfloat64_t z3,\n+\t      svfloat16_t z4, svfloat16_t z5, svfloat32_t z6, svfloat64_t z7,\n+\t      svfloat16_t z8,\n+\t      svbool_t p0, svbool_t p1, svbool_t p2)\n+{\n+  svst1 (p2, x0, z8);\n+  svst1 (p1, x0, z4);\n+  svst1 (p1, x1, z5);\n+  svst1 (p1, x2, z6);\n+  svst1 (p1, x3, z7);\n+  svst1 (p0, x0, z0);\n+  svst1 (p0, x1, z1);\n+  svst1 (p0, x2, z2);\n+  svst1 (p0, x3, z3);\n+}\n+\n+void __attribute__((noipa))\n+caller_float (float16_t *x0, float16_t *x1, float32_t *x2, float64_t *x3)\n+{\n+  callee_float (x0, x1, x2, x3,\n+\t\tsvdup_f16 (0),\n+\t\tsvdup_f16 (1),\n+\t\tsvdup_f32 (2),\n+\t\tsvdup_f64 (3),\n+\t\tsvdup_f16 (4),\n+\t\tsvdup_f16 (5),\n+\t\tsvdup_f32 (6),\n+\t\tsvdup_f64 (7),\n+\t\tsvdup_f16 (8),\n+\t\tsvptrue_pat_b8 (SV_VL1),\n+\t\tsvptrue_pat_b16 (SV_VL2),\n+\t\tsvptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tmov\\tz0\\.[bhsd], #0\\n} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz1\\.h, #1\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz2\\.s, #2\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz3\\.d, #3\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz4\\.h, #4\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz5\\.h, #5\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz6\\.s, #6\\.0} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\tz7\\.d, #7\\.0} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx4, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tfmov\\t(z[0-9]+\\.h), #8\\.0.*\\tst1h\\t\\1, p[0-7], \\[x4\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "6a9157bda51b72069d11f8c5208282656897f151", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_f16.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1\\]\n+**\tst2h\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1\\]\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2h\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4h\t{z0\\.h - z3\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z4\\.h - z6\\.h}, p2, \\[x0\\]\n+**\tst1h\tz7\\.h, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svfloat16x4_t z0, svfloat16x3_t z4, svfloat16x2_t stack,\n+\tsvfloat16_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_f16 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_f16 (pg, x0, -8),\n+\t  svld3_vnum_f16 (pg, x0, -3),\n+\t  svld2_vnum_f16 (pg, x0, 0),\n+\t  svld1_vnum_f16 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4h\\t{z0\\.h - z3\\.h}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z4\\.h - z6\\.h}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz7\\.h, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{(z[0-9]+\\.h) - z[0-9]+\\.h}.*\\tst1h\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z[0-9]+\\.h - (z[0-9]+\\.h)}.*\\tst1h\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "85dff59397ca8d1720be342fca79ba719b2814aa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_f32.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1\\]\n+**\tst2w\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1\\]\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2w\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4w\t{z0\\.s - z3\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z4\\.s - z6\\.s}, p2, \\[x0\\]\n+**\tst1w\tz7\\.s, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svfloat32x4_t z0, svfloat32x3_t z4, svfloat32x2_t stack,\n+\tsvfloat32_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_f32 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_f32 (pg, x0, -8),\n+\t  svld3_vnum_f32 (pg, x0, -3),\n+\t  svld2_vnum_f32 (pg, x0, 0),\n+\t  svld1_vnum_f32 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z0\\.s - z3\\.s}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z4\\.s - z6\\.s}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz7\\.s, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{(z[0-9]+\\.s) - z[0-9]+\\.s}.*\\tst1w\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z[0-9]+\\.s - (z[0-9]+\\.s)}.*\\tst1w\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "8cedd99868a2152e9fc803faadf3af7e825ed54f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_f64.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_f64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1\\]\n+**\tst2d\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1\\]\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2d\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4d\t{z0\\.d - z3\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z4\\.d - z6\\.d}, p2, \\[x0\\]\n+**\tst1d\tz7\\.d, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svfloat64x4_t z0, svfloat64x3_t z4, svfloat64x2_t stack,\n+\tsvfloat64_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_f64 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_f64 (pg, x0, -8),\n+\t  svld3_vnum_f64 (pg, x0, -3),\n+\t  svld2_vnum_f64 (pg, x0, 0),\n+\t  svld1_vnum_f64 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4d\\t{z0\\.d - z3\\.d}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z4\\.d - z6\\.d}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz7\\.d, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{(z[0-9]+\\.d) - z[0-9]+\\.d}.*\\tst1d\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z[0-9]+\\.d - (z[0-9]+\\.d)}.*\\tst1d\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "9486b301dd5e6bfce27b190f4c8c643a802cef68", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_s16.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1\\]\n+**\tst2h\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1\\]\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2h\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4h\t{z0\\.h - z3\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z4\\.h - z6\\.h}, p2, \\[x0\\]\n+**\tst1h\tz7\\.h, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint16x4_t z0, svint16x3_t z4, svint16x2_t stack,\n+\tsvint16_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s16 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s16 (pg, x0, -8),\n+\t  svld3_vnum_s16 (pg, x0, -3),\n+\t  svld2_vnum_s16 (pg, x0, 0),\n+\t  svld1_vnum_s16 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4h\\t{z0\\.h - z3\\.h}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z4\\.h - z6\\.h}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz7\\.h, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{(z[0-9]+\\.h) - z[0-9]+\\.h}.*\\tst1h\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z[0-9]+\\.h - (z[0-9]+\\.h)}.*\\tst1h\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "6643c3af927e2d5cd5e289e0c1fdca446746cc18", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_s32.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1\\]\n+**\tst2w\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1\\]\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2w\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4w\t{z0\\.s - z3\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z4\\.s - z6\\.s}, p2, \\[x0\\]\n+**\tst1w\tz7\\.s, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint32x4_t z0, svint32x3_t z4, svint32x2_t stack,\n+\tsvint32_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s32 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s32 (pg, x0, -8),\n+\t  svld3_vnum_s32 (pg, x0, -3),\n+\t  svld2_vnum_s32 (pg, x0, 0),\n+\t  svld1_vnum_s32 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z0\\.s - z3\\.s}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z4\\.s - z6\\.s}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz7\\.s, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{(z[0-9]+\\.s) - z[0-9]+\\.s}.*\\tst1w\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z[0-9]+\\.s - (z[0-9]+\\.s)}.*\\tst1w\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "f9c8b134b496784a2d3e581ef92d7625b297957e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_s64.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1\\]\n+**\tst2d\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1\\]\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2d\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4d\t{z0\\.d - z3\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z4\\.d - z6\\.d}, p2, \\[x0\\]\n+**\tst1d\tz7\\.d, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint64x4_t z0, svint64x3_t z4, svint64x2_t stack,\n+\tsvint64_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s64 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s64 (pg, x0, -8),\n+\t  svld3_vnum_s64 (pg, x0, -3),\n+\t  svld2_vnum_s64 (pg, x0, 0),\n+\t  svld1_vnum_s64 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4d\\t{z0\\.d - z3\\.d}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z4\\.d - z6\\.d}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz7\\.d, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{(z[0-9]+\\.d) - z[0-9]+\\.d}.*\\tst1d\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z[0-9]+\\.d - (z[0-9]+\\.d)}.*\\tst1d\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "63118f5f903b6e5f6b5575424fb598091901b859", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_s8.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_s8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1\\]\n+**\tst2b\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1\\]\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2b\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4b\t{z0\\.b - z3\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z4\\.b - z6\\.b}, p2, \\[x0\\]\n+**\tst1b\tz7\\.b, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint8x4_t z0, svint8x3_t z4, svint8x2_t stack,\n+\tsvint8_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s8 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s8 (pg, x0, -8),\n+\t  svld3_vnum_s8 (pg, x0, -3),\n+\t  svld2_vnum_s8 (pg, x0, 0),\n+\t  svld1_vnum_s8 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4b\\t{z0\\.b - z3\\.b}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z4\\.b - z6\\.b}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\tz7\\.b, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{(z[0-9]+\\.b) - z[0-9]+\\.b}.*\\tst1b\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z[0-9]+\\.b - (z[0-9]+\\.b)}.*\\tst1b\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "29af146dfffb58b163076f880568194651103b71", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_u16.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1\\]\n+**\tst2h\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1\\]\n+**\tld1h\t(z[0-9]+\\.h), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2h\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4h\t{z0\\.h - z3\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z4\\.h - z6\\.h}, p2, \\[x0\\]\n+**\tst1h\tz7\\.h, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint16x4_t z0, svuint16x3_t z4, svuint16x2_t stack,\n+\tsvuint16_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u16 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u16 (pg, x0, -8),\n+\t  svld3_vnum_u16 (pg, x0, -3),\n+\t  svld2_vnum_u16 (pg, x0, 0),\n+\t  svld1_vnum_u16 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4h\\t{z0\\.h - z3\\.h}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z4\\.h - z6\\.h}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz7\\.h, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{(z[0-9]+\\.h) - z[0-9]+\\.h}.*\\tst1h\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z[0-9]+\\.h - (z[0-9]+\\.h)}.*\\tst1h\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "0a9ca9da850419e3d9ef2a7a2186c68479d8a52b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_u32.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1\\]\n+**\tst2w\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1\\]\n+**\tld1w\t(z[0-9]+\\.s), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2w\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4w\t{z0\\.s - z3\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z4\\.s - z6\\.s}, p2, \\[x0\\]\n+**\tst1w\tz7\\.s, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint32x4_t z0, svuint32x3_t z4, svuint32x2_t stack,\n+\tsvuint32_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u32 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u32 (pg, x0, -8),\n+\t  svld3_vnum_u32 (pg, x0, -3),\n+\t  svld2_vnum_u32 (pg, x0, 0),\n+\t  svld1_vnum_u32 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z0\\.s - z3\\.s}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z4\\.s - z6\\.s}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz7\\.s, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{(z[0-9]+\\.s) - z[0-9]+\\.s}.*\\tst1w\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z[0-9]+\\.s - (z[0-9]+\\.s)}.*\\tst1w\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "50b71ec6f284bf99eb985336b2f8f2121db04fc6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_u64.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1\\]\n+**\tst2d\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1\\]\n+**\tld1d\t(z[0-9]+\\.d), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2d\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4d\t{z0\\.d - z3\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z4\\.d - z6\\.d}, p2, \\[x0\\]\n+**\tst1d\tz7\\.d, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint64x4_t z0, svuint64x3_t z4, svuint64x2_t stack,\n+\tsvuint64_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u64 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u64 (pg, x0, -8),\n+\t  svld3_vnum_u64 (pg, x0, -3),\n+\t  svld2_vnum_u64 (pg, x0, 0),\n+\t  svld1_vnum_u64 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4d\\t{z0\\.d - z3\\.d}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z4\\.d - z6\\.d}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz7\\.d, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{(z[0-9]+\\.d) - z[0-9]+\\.d}.*\\tst1d\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z[0-9]+\\.d - (z[0-9]+\\.d)}.*\\tst1d\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "bb6de3f65724632441713b80c68cc044b0cb5803", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_be_u8.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_be_u8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+** (\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1, #1, mul vl\\]\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1\\]\n+**\tst2b\t{\\2 - \\1}, p0, \\[x0\\]\n+** |\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1\\]\n+**\tld1b\t(z[0-9]+\\.b), p4/z, \\[x1, #1, mul vl\\]\n+**\tst2b\t{\\3 - \\4}, p0, \\[x0\\]\n+** )\n+**\tst4b\t{z0\\.b - z3\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z4\\.b - z6\\.b}, p2, \\[x0\\]\n+**\tst1b\tz7\\.b, p3, \\[x0\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint8x4_t z0, svuint8x3_t z4, svuint8x2_t stack,\n+\tsvuint8_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u8 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u8 (pg, x0, -8),\n+\t  svld3_vnum_u8 (pg, x0, -3),\n+\t  svld2_vnum_u8 (pg, x0, 0),\n+\t  svld1_vnum_u8 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4b\\t{z0\\.b - z3\\.b}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z4\\.b - z6\\.b}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\tz7\\.b, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{(z[0-9]+\\.b) - z[0-9]+\\.b}.*\\tst1b\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z[0-9]+\\.b - (z[0-9]+\\.b)}.*\\tst1b\\t\\1, p[0-7], \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "bd57fe40c2f6f983e9d871d3ad2010be45990307", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_f16.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2h\t{\\2\\.h - \\1\\.h}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2h\t{\\3\\.h - \\4\\.h}, p0, \\[x0\\]\n+** )\n+**\tst4h\t{z0\\.h - z3\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z4\\.h - z6\\.h}, p2, \\[x0\\]\n+**\tst1h\tz7\\.h, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svfloat16x4_t z0, svfloat16x3_t z4, svfloat16x2_t stack,\n+\tsvfloat16_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_f16 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_f16 (pg, x0, -8),\n+\t  svld3_vnum_f16 (pg, x0, -3),\n+\t  svld2_vnum_f16 (pg, x0, 0),\n+\t  svld1_vnum_f16 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4h\\t{z0\\.h - z3\\.h}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z4\\.h - z6\\.h}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz7\\.h, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{(z[0-9]+)\\.h - z[0-9]+\\.h}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z[0-9]+\\.h - (z[0-9]+)\\.h}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "7263cfc6af71d609ab4d89fd29ffe20ca038b899", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_f32.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2w\t{\\2\\.s - \\1\\.s}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2w\t{\\3\\.s - \\4\\.s}, p0, \\[x0\\]\n+** )\n+**\tst4w\t{z0\\.s - z3\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z4\\.s - z6\\.s}, p2, \\[x0\\]\n+**\tst1w\tz7\\.s, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svfloat32x4_t z0, svfloat32x3_t z4, svfloat32x2_t stack,\n+\tsvfloat32_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_f32 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_f32 (pg, x0, -8),\n+\t  svld3_vnum_f32 (pg, x0, -3),\n+\t  svld2_vnum_f32 (pg, x0, 0),\n+\t  svld1_vnum_f32 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z0\\.s - z3\\.s}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z4\\.s - z6\\.s}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz7\\.s, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{(z[0-9]+)\\.s - z[0-9]+\\.s}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z[0-9]+\\.s - (z[0-9]+)\\.s}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "5e24791cd4641f2d43031e4960a4054186fffca2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_f64.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_f64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2d\t{\\2\\.d - \\1\\.d}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2d\t{\\3\\.d - \\4\\.d}, p0, \\[x0\\]\n+** )\n+**\tst4d\t{z0\\.d - z3\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z4\\.d - z6\\.d}, p2, \\[x0\\]\n+**\tst1d\tz7\\.d, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svfloat64x4_t z0, svfloat64x3_t z4, svfloat64x2_t stack,\n+\tsvfloat64_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_f64 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_f64 (pg, x0, -8),\n+\t  svld3_vnum_f64 (pg, x0, -3),\n+\t  svld2_vnum_f64 (pg, x0, 0),\n+\t  svld1_vnum_f64 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4d\\t{z0\\.d - z3\\.d}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z4\\.d - z6\\.d}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz7\\.d, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{(z[0-9]+)\\.d - z[0-9]+\\.d}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z[0-9]+\\.d - (z[0-9]+)\\.d}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "82500f2d505888942ad4885402293098bcb506f5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_s16.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2h\t{\\2\\.h - \\1\\.h}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2h\t{\\3\\.h - \\4\\.h}, p0, \\[x0\\]\n+** )\n+**\tst4h\t{z0\\.h - z3\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z4\\.h - z6\\.h}, p2, \\[x0\\]\n+**\tst1h\tz7\\.h, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint16x4_t z0, svint16x3_t z4, svint16x2_t stack,\n+\tsvint16_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s16 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s16 (pg, x0, -8),\n+\t  svld3_vnum_s16 (pg, x0, -3),\n+\t  svld2_vnum_s16 (pg, x0, 0),\n+\t  svld1_vnum_s16 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4h\\t{z0\\.h - z3\\.h}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z4\\.h - z6\\.h}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz7\\.h, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{(z[0-9]+)\\.h - z[0-9]+\\.h}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z[0-9]+\\.h - (z[0-9]+)\\.h}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "70ed319ff3a6761b8c62adb16346ff9a79ebb48d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_s32.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2w\t{\\2\\.s - \\1\\.s}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2w\t{\\3\\.s - \\4\\.s}, p0, \\[x0\\]\n+** )\n+**\tst4w\t{z0\\.s - z3\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z4\\.s - z6\\.s}, p2, \\[x0\\]\n+**\tst1w\tz7\\.s, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint32x4_t z0, svint32x3_t z4, svint32x2_t stack,\n+\tsvint32_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s32 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s32 (pg, x0, -8),\n+\t  svld3_vnum_s32 (pg, x0, -3),\n+\t  svld2_vnum_s32 (pg, x0, 0),\n+\t  svld1_vnum_s32 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z0\\.s - z3\\.s}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z4\\.s - z6\\.s}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz7\\.s, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{(z[0-9]+)\\.s - z[0-9]+\\.s}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z[0-9]+\\.s - (z[0-9]+)\\.s}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "80cb1fb1da39a2ddf57b2310ac28afd2db007de4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_s64.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2d\t{\\2\\.d - \\1\\.d}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2d\t{\\3\\.d - \\4\\.d}, p0, \\[x0\\]\n+** )\n+**\tst4d\t{z0\\.d - z3\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z4\\.d - z6\\.d}, p2, \\[x0\\]\n+**\tst1d\tz7\\.d, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint64x4_t z0, svint64x3_t z4, svint64x2_t stack,\n+\tsvint64_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s64 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s64 (pg, x0, -8),\n+\t  svld3_vnum_s64 (pg, x0, -3),\n+\t  svld2_vnum_s64 (pg, x0, 0),\n+\t  svld1_vnum_s64 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4d\\t{z0\\.d - z3\\.d}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z4\\.d - z6\\.d}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz7\\.d, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{(z[0-9]+)\\.d - z[0-9]+\\.d}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z[0-9]+\\.d - (z[0-9]+)\\.d}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "12d5d4f70f09892efd82a33cfb22eb94c71d0a5e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_s8.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_s8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2b\t{\\2\\.b - \\1\\.b}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2b\t{\\3\\.b - \\4\\.b}, p0, \\[x0\\]\n+** )\n+**\tst4b\t{z0\\.b - z3\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z4\\.b - z6\\.b}, p2, \\[x0\\]\n+**\tst1b\tz7\\.b, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svint8x4_t z0, svint8x3_t z4, svint8x2_t stack,\n+\tsvint8_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_s8 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_s8 (pg, x0, -8),\n+\t  svld3_vnum_s8 (pg, x0, -3),\n+\t  svld2_vnum_s8 (pg, x0, 0),\n+\t  svld1_vnum_s8 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4b\\t{z0\\.b - z3\\.b}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z4\\.b - z6\\.b}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\tz7\\.b, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{(z[0-9]+)\\.b - z[0-9]+\\.b}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z[0-9]+\\.b - (z[0-9]+)\\.b}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "5d3ed923480fdd8a7f4e400b26459824ec839b54", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_u16.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2h\t{\\2\\.h - \\1\\.h}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2h\t{\\3\\.h - \\4\\.h}, p0, \\[x0\\]\n+** )\n+**\tst4h\t{z0\\.h - z3\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z4\\.h - z6\\.h}, p2, \\[x0\\]\n+**\tst1h\tz7\\.h, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint16x4_t z0, svuint16x3_t z4, svuint16x2_t stack,\n+\tsvuint16_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u16 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u16 (pg, x0, -8),\n+\t  svld3_vnum_u16 (pg, x0, -3),\n+\t  svld2_vnum_u16 (pg, x0, 0),\n+\t  svld1_vnum_u16 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4h\\t{z0\\.h - z3\\.h}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z4\\.h - z6\\.h}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz7\\.h, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{(z[0-9]+)\\.h - z[0-9]+\\.h}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z[0-9]+\\.h - (z[0-9]+)\\.h}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "d08a7a81d6539844c08be3081772d49bf1a7fd45", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_u32.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2w\t{\\2\\.s - \\1\\.s}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2w\t{\\3\\.s - \\4\\.s}, p0, \\[x0\\]\n+** )\n+**\tst4w\t{z0\\.s - z3\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z4\\.s - z6\\.s}, p2, \\[x0\\]\n+**\tst1w\tz7\\.s, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint32x4_t z0, svuint32x3_t z4, svuint32x2_t stack,\n+\tsvuint32_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u32 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u32 (pg, x0, -8),\n+\t  svld3_vnum_u32 (pg, x0, -3),\n+\t  svld2_vnum_u32 (pg, x0, 0),\n+\t  svld1_vnum_u32 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4w\\t{z0\\.s - z3\\.s}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z4\\.s - z6\\.s}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz7\\.s, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{(z[0-9]+)\\.s - z[0-9]+\\.s}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z[0-9]+\\.s - (z[0-9]+)\\.s}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "84c27d5017aa854d0cc4c532cba177a31b15369e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_u64.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2d\t{\\2\\.d - \\1\\.d}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2d\t{\\3\\.d - \\4\\.d}, p0, \\[x0\\]\n+** )\n+**\tst4d\t{z0\\.d - z3\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z4\\.d - z6\\.d}, p2, \\[x0\\]\n+**\tst1d\tz7\\.d, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint64x4_t z0, svuint64x3_t z4, svuint64x2_t stack,\n+\tsvuint64_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u64 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u64 (pg, x0, -8),\n+\t  svld3_vnum_u64 (pg, x0, -3),\n+\t  svld2_vnum_u64 (pg, x0, 0),\n+\t  svld1_vnum_u64 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4d\\t{z0\\.d - z3\\.d}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z4\\.d - z6\\.d}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz7\\.d, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{(z[0-9]+)\\.d - z[0-9]+\\.d}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z[0-9]+\\.d - (z[0-9]+)\\.d}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "e8b599cadb8ebcbeb1965e395eba2eb243f1a350", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_5_le_u8.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_5_le_u8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee:\n+** (\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tst2b\t{\\2\\.b - \\1\\.b}, p0, \\[x0\\]\n+** |\n+**\tldr\t(z[0-9]+), \\[x1\\]\n+**\tldr\t(z[0-9]+), \\[x1, #1, mul vl\\]\n+**\tst2b\t{\\3\\.b - \\4\\.b}, p0, \\[x0\\]\n+** )\n+**\tst4b\t{z0\\.b - z3\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z4\\.b - z6\\.b}, p2, \\[x0\\]\n+**\tst1b\tz7\\.b, p3, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (void *x0, svuint8x4_t z0, svuint8x3_t z4, svuint8x2_t stack,\n+\tsvuint8_t z7, svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  svst2 (p0, x0, stack);\n+  svst4 (p1, x0, z0);\n+  svst3 (p2, x0, z4);\n+  svst1_u8 (p3, x0, z7);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee (x0,\n+\t  svld4_vnum_u8 (pg, x0, -8),\n+\t  svld3_vnum_u8 (pg, x0, -3),\n+\t  svld2_vnum_u8 (pg, x0, 0),\n+\t  svld1_vnum_u8 (pg, x0, 2),\n+\t  svptrue_pat_b8 (SV_VL1),\n+\t  svptrue_pat_b16 (SV_VL2),\n+\t  svptrue_pat_b32 (SV_VL3),\n+\t  svptrue_pat_b64 (SV_VL4));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld4b\\t{z0\\.b - z3\\.b}, p[0-7]/z, \\[x0, #-8, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z4\\.b - z6\\.b}, p[0-7]/z, \\[x0, #-3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\tz7\\.b, p[0-7]/z, \\[x0, #2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tmov\\tx1, sp\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{(z[0-9]+)\\.b - z[0-9]+\\.b}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z[0-9]+\\.b - (z[0-9]+)\\.b}.*\\tstr\\t\\1, \\[x1, #1, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp3\\.d, vl4\\n} } } */"}, {"sha": "f898cadf6879a34a51124dcebc010ac36bb9a0db", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_f16.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4h\t{z[0-9]+\\.h - \\1}, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z5\\.h - z7\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svfloat16x3_t z0, svfloat16x2_t z3, svfloat16x3_t z5,\n+\t svfloat16x4_t stack1, svfloat16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_f16 (p0, x0, stack1);\n+  svst2_f16 (p1, x0, z3);\n+  svst3_f16 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x2\\]\n+**\tst1h\t\\1, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z0\\.h - z2\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svfloat16x3_t z0, svfloat16x2_t z3, svfloat16x3_t z5,\n+\t svfloat16x4_t stack1, svfloat16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_f16 (p0, x0, stack2);\n+  svst2_f16 (p1, x0, z3);\n+  svst3_f16 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_f16 (pg, x0, -9),\n+\t   svld2_vnum_f16 (pg, x0, -2),\n+\t   svld3_vnum_f16 (pg, x0, 0),\n+\t   svld4_vnum_f16 (pg, x0, 8),\n+\t   svld1_vnum_f16 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3h\\t{z0\\.h - z2\\.h}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z3\\.h - z4\\.h}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z5\\.h - z7\\.h}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{(z[0-9]+\\.h) - z[0-9]+\\.h}.*\\tst1h\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{z[0-9]+\\.h - (z[0-9]+\\.h)}.*\\tst1h\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\t(z[0-9]+\\.h), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1h\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "dd23dbb4d1aa7f4ce21b9d89130bf800fb8ac0cf", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_f32.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4w\t{z[0-9]+\\.s - \\1}, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z5\\.s - z7\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svfloat32x3_t z0, svfloat32x2_t z3, svfloat32x3_t z5,\n+\t svfloat32x4_t stack1, svfloat32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_f32 (p0, x0, stack1);\n+  svst2_f32 (p1, x0, z3);\n+  svst3_f32 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x2\\]\n+**\tst1w\t\\1, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z0\\.s - z2\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svfloat32x3_t z0, svfloat32x2_t z3, svfloat32x3_t z5,\n+\t svfloat32x4_t stack1, svfloat32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_f32 (p0, x0, stack2);\n+  svst2_f32 (p1, x0, z3);\n+  svst3_f32 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_f32 (pg, x0, -9),\n+\t   svld2_vnum_f32 (pg, x0, -2),\n+\t   svld3_vnum_f32 (pg, x0, 0),\n+\t   svld4_vnum_f32 (pg, x0, 8),\n+\t   svld1_vnum_f32 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3w\\t{z0\\.s - z2\\.s}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z3\\.s - z4\\.s}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z5\\.s - z7\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{(z[0-9]+\\.s) - z[0-9]+\\.s}.*\\tst1w\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{z[0-9]+\\.s - (z[0-9]+\\.s)}.*\\tst1w\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\t(z[0-9]+\\.s), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1w\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "090a91d34a9a789cb651460664da2a17f2679e6a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_f64.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_f64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4d\t{z[0-9]+\\.d - \\1}, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z5\\.d - z7\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svfloat64x3_t z0, svfloat64x2_t z3, svfloat64x3_t z5,\n+\t svfloat64x4_t stack1, svfloat64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_f64 (p0, x0, stack1);\n+  svst2_f64 (p1, x0, z3);\n+  svst3_f64 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x2\\]\n+**\tst1d\t\\1, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z0\\.d - z2\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svfloat64x3_t z0, svfloat64x2_t z3, svfloat64x3_t z5,\n+\t svfloat64x4_t stack1, svfloat64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_f64 (p0, x0, stack2);\n+  svst2_f64 (p1, x0, z3);\n+  svst3_f64 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_f64 (pg, x0, -9),\n+\t   svld2_vnum_f64 (pg, x0, -2),\n+\t   svld3_vnum_f64 (pg, x0, 0),\n+\t   svld4_vnum_f64 (pg, x0, 8),\n+\t   svld1_vnum_f64 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3d\\t{z0\\.d - z2\\.d}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z3\\.d - z4\\.d}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z5\\.d - z7\\.d}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{(z[0-9]+\\.d) - z[0-9]+\\.d}.*\\tst1d\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - (z[0-9]+\\.d)}.*\\tst1d\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\t(z[0-9]+\\.d), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1d\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "f28ac71b66ea2eec44697401bd3180a6e524005e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_s16.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4h\t{z[0-9]+\\.h - \\1}, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z5\\.h - z7\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint16x3_t z0, svint16x2_t z3, svint16x3_t z5,\n+\t svint16x4_t stack1, svint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s16 (p0, x0, stack1);\n+  svst2_s16 (p1, x0, z3);\n+  svst3_s16 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x2\\]\n+**\tst1h\t\\1, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z0\\.h - z2\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint16x3_t z0, svint16x2_t z3, svint16x3_t z5,\n+\t svint16x4_t stack1, svint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s16 (p0, x0, stack2);\n+  svst2_s16 (p1, x0, z3);\n+  svst3_s16 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s16 (pg, x0, -9),\n+\t   svld2_vnum_s16 (pg, x0, -2),\n+\t   svld3_vnum_s16 (pg, x0, 0),\n+\t   svld4_vnum_s16 (pg, x0, 8),\n+\t   svld1_vnum_s16 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3h\\t{z0\\.h - z2\\.h}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z3\\.h - z4\\.h}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z5\\.h - z7\\.h}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{(z[0-9]+\\.h) - z[0-9]+\\.h}.*\\tst1h\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{z[0-9]+\\.h - (z[0-9]+\\.h)}.*\\tst1h\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\t(z[0-9]+\\.h), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1h\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "701c8a96474f56847698e42f1ac1d52f3b27a2d0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_s32.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4w\t{z[0-9]+\\.s - \\1\\}, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z5\\.s - z7\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint32x3_t z0, svint32x2_t z3, svint32x3_t z5,\n+\t svint32x4_t stack1, svint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s32 (p0, x0, stack1);\n+  svst2_s32 (p1, x0, z3);\n+  svst3_s32 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x2\\]\n+**\tst1w\t\\1, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z0\\.s - z2\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint32x3_t z0, svint32x2_t z3, svint32x3_t z5,\n+\t svint32x4_t stack1, svint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s32 (p0, x0, stack2);\n+  svst2_s32 (p1, x0, z3);\n+  svst3_s32 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s32 (pg, x0, -9),\n+\t   svld2_vnum_s32 (pg, x0, -2),\n+\t   svld3_vnum_s32 (pg, x0, 0),\n+\t   svld4_vnum_s32 (pg, x0, 8),\n+\t   svld1_vnum_s32 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3w\\t{z0\\.s - z2\\.s}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z3\\.s - z4\\.s}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z5\\.s - z7\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{(z[0-9]+\\.s) - z[0-9]+\\.s}.*\\tst1w\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{z[0-9]+\\.s - (z[0-9]+\\.s)}.*\\tst1w\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\t(z[0-9]+\\.s), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1w\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "7aad40f64032def9036a96f476c740b7dc9245ea", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_s64.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4d\t{z[0-9]+\\.d - \\1}, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z5\\.d - z7\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint64x3_t z0, svint64x2_t z3, svint64x3_t z5,\n+\t svint64x4_t stack1, svint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s64 (p0, x0, stack1);\n+  svst2_s64 (p1, x0, z3);\n+  svst3_s64 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x2\\]\n+**\tst1d\t\\1, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z0\\.d - z2\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint64x3_t z0, svint64x2_t z3, svint64x3_t z5,\n+\t svint64x4_t stack1, svint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s64 (p0, x0, stack2);\n+  svst2_s64 (p1, x0, z3);\n+  svst3_s64 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s64 (pg, x0, -9),\n+\t   svld2_vnum_s64 (pg, x0, -2),\n+\t   svld3_vnum_s64 (pg, x0, 0),\n+\t   svld4_vnum_s64 (pg, x0, 8),\n+\t   svld1_vnum_s64 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3d\\t{z0\\.d - z2\\.d}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z3\\.d - z4\\.d}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z5\\.d - z7\\.d}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{(z[0-9]+\\.d) - z[0-9]+\\.d}.*\\tst1d\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - (z[0-9]+\\.d)}.*\\tst1d\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\t(z[0-9]+\\.d), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1d\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "66ee82e77cace3c369dd91cd3825c3c624a0e887", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_s8.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_s8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4b\t{z[0-9]+\\.b - \\1}, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z5\\.b - z7\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint8x3_t z0, svint8x2_t z3, svint8x3_t z5,\n+\t svint8x4_t stack1, svint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s8 (p0, x0, stack1);\n+  svst2_s8 (p1, x0, z3);\n+  svst3_s8 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1b\t(z[0-9]+\\.b), p3/z, \\[x2\\]\n+**\tst1b\t\\1, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z0\\.b - z2\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint8x3_t z0, svint8x2_t z3, svint8x3_t z5,\n+\t svint8x4_t stack1, svint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s8 (p0, x0, stack2);\n+  svst2_s8 (p1, x0, z3);\n+  svst3_s8 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s8 (pg, x0, -9),\n+\t   svld2_vnum_s8 (pg, x0, -2),\n+\t   svld3_vnum_s8 (pg, x0, 0),\n+\t   svld4_vnum_s8 (pg, x0, 8),\n+\t   svld1_vnum_s8 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3b\\t{z0\\.b - z2\\.b}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z3\\.b - z4\\.b}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z5\\.b - z7\\.b}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{(z[0-9]+\\.b) - z[0-9]+\\.b}.*\\tst1b\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{z[0-9]+\\.b - (z[0-9]+\\.b)}.*\\tst1b\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\t(z[0-9]+\\.b), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1b\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "b9370e128bea37c112c4c472da2b958da5a27857", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_u16.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4h\t{z[0-9]+\\.h - \\1}, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z5\\.h - z7\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint16x3_t z0, svuint16x2_t z3, svuint16x3_t z5,\n+\t svuint16x4_t stack1, svuint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u16 (p0, x0, stack1);\n+  svst2_u16 (p1, x0, z3);\n+  svst3_u16 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x2\\]\n+**\tst1h\t\\1, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z0\\.h - z2\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint16x3_t z0, svuint16x2_t z3, svuint16x3_t z5,\n+\t svuint16x4_t stack1, svuint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u16 (p0, x0, stack2);\n+  svst2_u16 (p1, x0, z3);\n+  svst3_u16 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u16 (pg, x0, -9),\n+\t   svld2_vnum_u16 (pg, x0, -2),\n+\t   svld3_vnum_u16 (pg, x0, 0),\n+\t   svld4_vnum_u16 (pg, x0, 8),\n+\t   svld1_vnum_u16 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3h\\t{z0\\.h - z2\\.h}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z3\\.h - z4\\.h}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z5\\.h - z7\\.h}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{(z[0-9]+\\.h) - z[0-9]+\\.h}.*\\tst1h\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{z[0-9]+\\.h - (z[0-9]+\\.h)}.*\\tst1h\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\t(z[0-9]+\\.h), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1h\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "983c26c0c1466de7fcdac249681a378fa6ccf49d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_u32.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4w\t{z[0-9]+\\.s - \\1}, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z5\\.s - z7\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint32x3_t z0, svuint32x2_t z3, svuint32x3_t z5,\n+\t svuint32x4_t stack1, svuint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u32 (p0, x0, stack1);\n+  svst2_u32 (p1, x0, z3);\n+  svst3_u32 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x2\\]\n+**\tst1w\t\\1, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z0\\.s - z2\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint32x3_t z0, svuint32x2_t z3, svuint32x3_t z5,\n+\t svuint32x4_t stack1, svuint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u32 (p0, x0, stack2);\n+  svst2_u32 (p1, x0, z3);\n+  svst3_u32 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u32 (pg, x0, -9),\n+\t   svld2_vnum_u32 (pg, x0, -2),\n+\t   svld3_vnum_u32 (pg, x0, 0),\n+\t   svld4_vnum_u32 (pg, x0, 8),\n+\t   svld1_vnum_u32 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3w\\t{z0\\.s - z2\\.s}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z3\\.s - z4\\.s}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z5\\.s - z7\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{(z[0-9]+\\.s) - z[0-9]+\\.s}.*\\tst1w\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{z[0-9]+\\.s - (z[0-9]+\\.s)}.*\\tst1w\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\t(z[0-9]+\\.s), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1w\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "89755d6a4db0e1805317374bcc5a910ac6c92324", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_u64.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4d\t{z[0-9]+\\.d - \\1}, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z5\\.d - z7\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint64x3_t z0, svuint64x2_t z3, svuint64x3_t z5,\n+\t svuint64x4_t stack1, svuint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u64 (p0, x0, stack1);\n+  svst2_u64 (p1, x0, z3);\n+  svst3_u64 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x2\\]\n+**\tst1d\t\\1, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z0\\.d - z2\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint64x3_t z0, svuint64x2_t z3, svuint64x3_t z5,\n+\t svuint64x4_t stack1, svuint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u64 (p0, x0, stack2);\n+  svst2_u64 (p1, x0, z3);\n+  svst3_u64 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u64 (pg, x0, -9),\n+\t   svld2_vnum_u64 (pg, x0, -2),\n+\t   svld3_vnum_u64 (pg, x0, 0),\n+\t   svld4_vnum_u64 (pg, x0, 8),\n+\t   svld1_vnum_u64 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3d\\t{z0\\.d - z2\\.d}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z3\\.d - z4\\.d}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z5\\.d - z7\\.d}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{(z[0-9]+\\.d) - z[0-9]+\\.d}.*\\tst1d\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - (z[0-9]+\\.d)}.*\\tst1d\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\t(z[0-9]+\\.d), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1d\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "7324bd61aaa986c8e22cdb53f9fc46b798d26b14", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_be_u8.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_be_u8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\tptrue\tp3\\.b, all\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), p3/z, \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4b\t{z[0-9]+\\.b - \\1}, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z5\\.b - z7\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint8x3_t z0, svuint8x2_t z3, svuint8x3_t z5,\n+\t svuint8x4_t stack1, svuint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u8 (p0, x0, stack1);\n+  svst2_u8 (p1, x0, z3);\n+  svst3_u8 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1b\t(z[0-9]+\\.b), p3/z, \\[x2\\]\n+**\tst1b\t\\1, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z0\\.b - z2\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint8x3_t z0, svuint8x2_t z3, svuint8x3_t z5,\n+\t svuint8x4_t stack1, svuint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u8 (p0, x0, stack2);\n+  svst2_u8 (p1, x0, z3);\n+  svst3_u8 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u8 (pg, x0, -9),\n+\t   svld2_vnum_u8 (pg, x0, -2),\n+\t   svld3_vnum_u8 (pg, x0, 0),\n+\t   svld4_vnum_u8 (pg, x0, 8),\n+\t   svld1_vnum_u8 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3b\\t{z0\\.b - z2\\.b}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z3\\.b - z4\\.b}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z5\\.b - z7\\.b}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{(z[0-9]+\\.b) - z[0-9]+\\.b}.*\\tst1b\\t\\1, p[0-7], \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{z[0-9]+\\.b - (z[0-9]+\\.b)}.*\\tst1b\\t\\1, p[0-7], \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\t(z[0-9]+\\.b), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1b\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "9392c67d9e16351538887199affeaac52d72856a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_f16.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4h\t{z[0-9]+\\.h - \\1\\.h}, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z5\\.h - z7\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svfloat16x3_t z0, svfloat16x2_t z3, svfloat16x3_t z5,\n+\t svfloat16x4_t stack1, svfloat16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_f16 (p0, x0, stack1);\n+  svst2_f16 (p1, x0, z3);\n+  svst3_f16 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x2\\]\n+**\tst1h\t\\1, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z0\\.h - z2\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svfloat16x3_t z0, svfloat16x2_t z3, svfloat16x3_t z5,\n+\t svfloat16x4_t stack1, svfloat16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_f16 (p0, x0, stack2);\n+  svst2_f16 (p1, x0, z3);\n+  svst3_f16 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_f16 (pg, x0, -9),\n+\t   svld2_vnum_f16 (pg, x0, -2),\n+\t   svld3_vnum_f16 (pg, x0, 0),\n+\t   svld4_vnum_f16 (pg, x0, 8),\n+\t   svld1_vnum_f16 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3h\\t{z0\\.h - z2\\.h}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z3\\.h - z4\\.h}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z5\\.h - z7\\.h}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{(z[0-9]+)\\.h - z[0-9]+\\.h}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{z[0-9]+\\.h - (z[0-9]+)\\.h}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\t(z[0-9]+\\.h), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1h\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "8b22cf31aba968ea56b6166be94fa0c1b9e53ef6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_f32.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4w\t{z[0-9]+\\.s - \\1\\.s}, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z5\\.s - z7\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svfloat32x3_t z0, svfloat32x2_t z3, svfloat32x3_t z5,\n+\t svfloat32x4_t stack1, svfloat32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_f32 (p0, x0, stack1);\n+  svst2_f32 (p1, x0, z3);\n+  svst3_f32 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x2\\]\n+**\tst1w\t\\1, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z0\\.s - z2\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svfloat32x3_t z0, svfloat32x2_t z3, svfloat32x3_t z5,\n+\t svfloat32x4_t stack1, svfloat32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_f32 (p0, x0, stack2);\n+  svst2_f32 (p1, x0, z3);\n+  svst3_f32 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_f32 (pg, x0, -9),\n+\t   svld2_vnum_f32 (pg, x0, -2),\n+\t   svld3_vnum_f32 (pg, x0, 0),\n+\t   svld4_vnum_f32 (pg, x0, 8),\n+\t   svld1_vnum_f32 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3w\\t{z0\\.s - z2\\.s}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z3\\.s - z4\\.s}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z5\\.s - z7\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{(z[0-9]+)\\.s - z[0-9]+\\.s}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{z[0-9]+\\.s - (z[0-9]+)\\.s}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\t(z[0-9]+\\.s), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1w\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "94a1d40d409ea9aa43ec97c0c278bdc739133761", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_f64.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_f64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4d\t{z[0-9]+\\.d - \\1\\.d}, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z5\\.d - z7\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svfloat64x3_t z0, svfloat64x2_t z3, svfloat64x3_t z5,\n+\t svfloat64x4_t stack1, svfloat64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_f64 (p0, x0, stack1);\n+  svst2_f64 (p1, x0, z3);\n+  svst3_f64 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x2\\]\n+**\tst1d\t\\1, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z0\\.d - z2\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svfloat64x3_t z0, svfloat64x2_t z3, svfloat64x3_t z5,\n+\t svfloat64x4_t stack1, svfloat64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_f64 (p0, x0, stack2);\n+  svst2_f64 (p1, x0, z3);\n+  svst3_f64 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_f64 (pg, x0, -9),\n+\t   svld2_vnum_f64 (pg, x0, -2),\n+\t   svld3_vnum_f64 (pg, x0, 0),\n+\t   svld4_vnum_f64 (pg, x0, 8),\n+\t   svld1_vnum_f64 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3d\\t{z0\\.d - z2\\.d}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z3\\.d - z4\\.d}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z5\\.d - z7\\.d}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{(z[0-9]+)\\.d - z[0-9]+\\.d}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - (z[0-9]+)\\.d}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\t(z[0-9]+\\.d), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1d\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "992ab1870c2319b6cf00716d467159cccf665727", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_s16.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4h\t{z[0-9]+\\.h - \\1\\.h}, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z5\\.h - z7\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint16x3_t z0, svint16x2_t z3, svint16x3_t z5,\n+\t svint16x4_t stack1, svint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s16 (p0, x0, stack1);\n+  svst2_s16 (p1, x0, z3);\n+  svst3_s16 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x2\\]\n+**\tst1h\t\\1, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z0\\.h - z2\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint16x3_t z0, svint16x2_t z3, svint16x3_t z5,\n+\t svint16x4_t stack1, svint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s16 (p0, x0, stack2);\n+  svst2_s16 (p1, x0, z3);\n+  svst3_s16 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s16 (pg, x0, -9),\n+\t   svld2_vnum_s16 (pg, x0, -2),\n+\t   svld3_vnum_s16 (pg, x0, 0),\n+\t   svld4_vnum_s16 (pg, x0, 8),\n+\t   svld1_vnum_s16 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3h\\t{z0\\.h - z2\\.h}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z3\\.h - z4\\.h}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z5\\.h - z7\\.h}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{(z[0-9]+)\\.h - z[0-9]+\\.h}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{z[0-9]+\\.h - (z[0-9]+)\\.h}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\t(z[0-9]+\\.h), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1h\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "6a497e9b254595659bb37fc2a0db5164b84fd893", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_s32.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4w\t{z[0-9]+\\.s - \\1\\.s}, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z5\\.s - z7\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint32x3_t z0, svint32x2_t z3, svint32x3_t z5,\n+\t svint32x4_t stack1, svint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s32 (p0, x0, stack1);\n+  svst2_s32 (p1, x0, z3);\n+  svst3_s32 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x2\\]\n+**\tst1w\t\\1, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z0\\.s - z2\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint32x3_t z0, svint32x2_t z3, svint32x3_t z5,\n+\t svint32x4_t stack1, svint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s32 (p0, x0, stack2);\n+  svst2_s32 (p1, x0, z3);\n+  svst3_s32 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s32 (pg, x0, -9),\n+\t   svld2_vnum_s32 (pg, x0, -2),\n+\t   svld3_vnum_s32 (pg, x0, 0),\n+\t   svld4_vnum_s32 (pg, x0, 8),\n+\t   svld1_vnum_s32 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3w\\t{z0\\.s - z2\\.s}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z3\\.s - z4\\.s}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z5\\.s - z7\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{(z[0-9]+)\\.s - z[0-9]+\\.s}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{z[0-9]+\\.s - (z[0-9]+)\\.s}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\t(z[0-9]+\\.s), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1w\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "d2e4c440dd08c44596c5d1abdf9c10729678a403", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_s64.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4d\t{z[0-9]+\\.d - \\1\\.d}, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z5\\.d - z7\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint64x3_t z0, svint64x2_t z3, svint64x3_t z5,\n+\t svint64x4_t stack1, svint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s64 (p0, x0, stack1);\n+  svst2_s64 (p1, x0, z3);\n+  svst3_s64 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x2\\]\n+**\tst1d\t\\1, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z0\\.d - z2\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint64x3_t z0, svint64x2_t z3, svint64x3_t z5,\n+\t svint64x4_t stack1, svint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s64 (p0, x0, stack2);\n+  svst2_s64 (p1, x0, z3);\n+  svst3_s64 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s64 (pg, x0, -9),\n+\t   svld2_vnum_s64 (pg, x0, -2),\n+\t   svld3_vnum_s64 (pg, x0, 0),\n+\t   svld4_vnum_s64 (pg, x0, 8),\n+\t   svld1_vnum_s64 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3d\\t{z0\\.d - z2\\.d}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z3\\.d - z4\\.d}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z5\\.d - z7\\.d}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{(z[0-9]+)\\.d - z[0-9]+\\.d}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - (z[0-9]+)\\.d}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\t(z[0-9]+\\.d), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1d\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "eb7a374af92bcb248d60676d78f3b9f502c110b4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_s8.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_s8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4b\t{z[0-9]+\\.b - \\1\\.b}, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z5\\.b - z7\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svint8x3_t z0, svint8x2_t z3, svint8x3_t z5,\n+\t svint8x4_t stack1, svint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_s8 (p0, x0, stack1);\n+  svst2_s8 (p1, x0, z3);\n+  svst3_s8 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1b\t(z[0-9]+\\.b), p3/z, \\[x2\\]\n+**\tst1b\t\\1, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z0\\.b - z2\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svint8x3_t z0, svint8x2_t z3, svint8x3_t z5,\n+\t svint8x4_t stack1, svint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_s8 (p0, x0, stack2);\n+  svst2_s8 (p1, x0, z3);\n+  svst3_s8 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_s8 (pg, x0, -9),\n+\t   svld2_vnum_s8 (pg, x0, -2),\n+\t   svld3_vnum_s8 (pg, x0, 0),\n+\t   svld4_vnum_s8 (pg, x0, 8),\n+\t   svld1_vnum_s8 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3b\\t{z0\\.b - z2\\.b}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z3\\.b - z4\\.b}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z5\\.b - z7\\.b}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{(z[0-9]+)\\.b - z[0-9]+\\.b}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{z[0-9]+\\.b - (z[0-9]+)\\.b}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\t(z[0-9]+\\.b), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1b\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "0d5b304bd7be6d7b6a01df144a71b3333124b537", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_u16.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4h\t{z[0-9]+\\.h - \\1\\.h}, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z5\\.h - z7\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint16x3_t z0, svuint16x2_t z3, svuint16x3_t z5,\n+\t svuint16x4_t stack1, svuint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u16 (p0, x0, stack1);\n+  svst2_u16 (p1, x0, z3);\n+  svst3_u16 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1h\t(z[0-9]+\\.h), p3/z, \\[x2\\]\n+**\tst1h\t\\1, p0, \\[x0\\]\n+**\tst2h\t{z3\\.h - z4\\.h}, p1, \\[x0\\]\n+**\tst3h\t{z0\\.h - z2\\.h}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint16x3_t z0, svuint16x2_t z3, svuint16x3_t z5,\n+\t svuint16x4_t stack1, svuint16_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u16 (p0, x0, stack2);\n+  svst2_u16 (p1, x0, z3);\n+  svst3_u16 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u16 (pg, x0, -9),\n+\t   svld2_vnum_u16 (pg, x0, -2),\n+\t   svld3_vnum_u16 (pg, x0, 0),\n+\t   svld4_vnum_u16 (pg, x0, 8),\n+\t   svld1_vnum_u16 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3h\\t{z0\\.h - z2\\.h}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2h\\t{z3\\.h - z4\\.h}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t{z5\\.h - z7\\.h}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{(z[0-9]+)\\.h - z[0-9]+\\.h}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4h\\t{z[0-9]+\\.h - (z[0-9]+)\\.h}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\t(z[0-9]+\\.h), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1h\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "962ccc928900260e7e40f3dee4e5782fd4d095a8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_u32.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4w\t{z[0-9]+\\.s - \\1\\.s}, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z5\\.s - z7\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint32x3_t z0, svuint32x2_t z3, svuint32x3_t z5,\n+\t svuint32x4_t stack1, svuint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u32 (p0, x0, stack1);\n+  svst2_u32 (p1, x0, z3);\n+  svst3_u32 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), p3/z, \\[x2\\]\n+**\tst1w\t\\1, p0, \\[x0\\]\n+**\tst2w\t{z3\\.s - z4\\.s}, p1, \\[x0\\]\n+**\tst3w\t{z0\\.s - z2\\.s}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint32x3_t z0, svuint32x2_t z3, svuint32x3_t z5,\n+\t svuint32x4_t stack1, svuint32_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u32 (p0, x0, stack2);\n+  svst2_u32 (p1, x0, z3);\n+  svst3_u32 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u32 (pg, x0, -9),\n+\t   svld2_vnum_u32 (pg, x0, -2),\n+\t   svld3_vnum_u32 (pg, x0, 0),\n+\t   svld4_vnum_u32 (pg, x0, 8),\n+\t   svld1_vnum_u32 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3w\\t{z0\\.s - z2\\.s}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2w\\t{z3\\.s - z4\\.s}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t{z5\\.s - z7\\.s}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{(z[0-9]+)\\.s - z[0-9]+\\.s}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4w\\t{z[0-9]+\\.s - (z[0-9]+)\\.s}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\t(z[0-9]+\\.s), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1w\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "930ed96581290ec99e3f9fb80da1352ea7480490", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_u64.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4d\t{z[0-9]+\\.d - \\1\\.d}, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z5\\.d - z7\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint64x3_t z0, svuint64x2_t z3, svuint64x3_t z5,\n+\t svuint64x4_t stack1, svuint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u64 (p0, x0, stack1);\n+  svst2_u64 (p1, x0, z3);\n+  svst3_u64 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1d\t(z[0-9]+\\.d), p3/z, \\[x2\\]\n+**\tst1d\t\\1, p0, \\[x0\\]\n+**\tst2d\t{z3\\.d - z4\\.d}, p1, \\[x0\\]\n+**\tst3d\t{z0\\.d - z2\\.d}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint64x3_t z0, svuint64x2_t z3, svuint64x3_t z5,\n+\t svuint64x4_t stack1, svuint64_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u64 (p0, x0, stack2);\n+  svst2_u64 (p1, x0, z3);\n+  svst3_u64 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u64 (pg, x0, -9),\n+\t   svld2_vnum_u64 (pg, x0, -2),\n+\t   svld3_vnum_u64 (pg, x0, 0),\n+\t   svld4_vnum_u64 (pg, x0, 8),\n+\t   svld1_vnum_u64 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3d\\t{z0\\.d - z2\\.d}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2d\\t{z3\\.d - z4\\.d}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t{z5\\.d - z7\\.d}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{(z[0-9]+)\\.d - z[0-9]+\\.d}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4d\\t{z[0-9]+\\.d - (z[0-9]+)\\.d}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\t(z[0-9]+\\.d), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1d\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "83208435ca0116ae1dee670e95e56190d35e7cb1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_6_le_u8.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_6_le_u8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** callee1:\n+**\t...\n+**\tldr\t(z[0-9]+), \\[x1, #3, mul vl\\]\n+**\t...\n+**\tst4b\t{z[0-9]+\\.b - \\1\\.b}, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z5\\.b - z7\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee1 (void *x0, svuint8x3_t z0, svuint8x2_t z3, svuint8x3_t z5,\n+\t svuint8x4_t stack1, svuint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst4_u8 (p0, x0, stack1);\n+  svst2_u8 (p1, x0, z3);\n+  svst3_u8 (p2, x0, z5);\n+}\n+\n+/*\n+** callee2:\n+**\tptrue\tp3\\.b, all\n+**\tld1b\t(z[0-9]+\\.b), p3/z, \\[x2\\]\n+**\tst1b\t\\1, p0, \\[x0\\]\n+**\tst2b\t{z3\\.b - z4\\.b}, p1, \\[x0\\]\n+**\tst3b\t{z0\\.b - z2\\.b}, p2, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee2 (void *x0, svuint8x3_t z0, svuint8x2_t z3, svuint8x3_t z5,\n+\t svuint8x4_t stack1, svuint8_t stack2, svbool_t p0,\n+\t svbool_t p1, svbool_t p2)\n+{\n+  svst1_u8 (p0, x0, stack2);\n+  svst2_u8 (p1, x0, z3);\n+  svst3_u8 (p2, x0, z0);\n+}\n+\n+void __attribute__((noipa))\n+caller (void *x0)\n+{\n+  svbool_t pg;\n+  pg = svptrue_b8 ();\n+  callee1 (x0,\n+\t   svld3_vnum_u8 (pg, x0, -9),\n+\t   svld2_vnum_u8 (pg, x0, -2),\n+\t   svld3_vnum_u8 (pg, x0, 0),\n+\t   svld4_vnum_u8 (pg, x0, 8),\n+\t   svld1_vnum_u8 (pg, x0, 5),\n+\t   svptrue_pat_b8 (SV_VL1),\n+\t   svptrue_pat_b16 (SV_VL2),\n+\t   svptrue_pat_b32 (SV_VL3));\n+}\n+\n+/* { dg-final { scan-assembler {\\tld3b\\t{z0\\.b - z2\\.b}, p[0-7]/z, \\[x0, #-9, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld2b\\t{z3\\.b - z4\\.b}, p[0-7]/z, \\[x0, #-2, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t{z5\\.b - z7\\.b}, p[0-7]/z, \\[x0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{(z[0-9]+)\\.b - z[0-9]+\\.b}.*\\tstr\\t\\1, \\[x1\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld4b\\t{z[0-9]+\\.b - (z[0-9]+)\\.b}.*\\tstr\\t\\1, \\[x1, #3, mul vl\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tld1b\\t(z[0-9]+\\.b), p[0-7]/z, \\[x0, #5, mul vl\\]\\n.*\\tst1b\\t\\1, p[0-7], \\[x2\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp0\\.b, vl1\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp1\\.h, vl2\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\tp2\\.s, vl3\\n} } } */"}, {"sha": "99ba24824ae592811807428101821a72a0c48357", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_7.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_7.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee:\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp\\]\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), p[1-3]/z, \\[\\1\\]\n+**\tst1b\t\\2, p0, \\[x0, x7\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (int8_t *x0, int x1, int x2, int x3,\n+\tint x4, int x5, svbool_t p0, int x6, int64_t x7,\n+\tsvint32x4_t z0, svint32x4_t z4, svint8_t stack)\n+{\n+  svst1 (p0, x0 + x7, stack);\n+}\n+\n+void __attribute__((noipa))\n+caller (int8_t *x0, svbool_t p0, svint32x4_t z0, svint32x4_t z4)\n+{\n+  callee (x0, 1, 2, 3, 4, 5, p0, 6, 7, z0, z4, svdup_s8 (42));\n+}\n+\n+/* { dg-final { scan-assembler {\\tmov\\t(z[0-9]+\\.b), #42\\n.*\\tst1b\\t\\1, p[0-7], \\[(x[0-9]+)\\]\\n.*\\tstr\\t\\2, \\[sp\\]\\n} } } */"}, {"sha": "53aa4cd6a2f82ebc69e6d986b15f0f100db1d7c5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_8.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee:\n+**\tptrue\t(p[1-3])\\.b, all\n+**\tld1b\t(z[0-9]+\\.b), \\1/z, \\[x4\\]\n+**\tst1b\t\\2, p0, \\[x0, x7\\]\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee (int8_t *x0, int x1, int x2, int x3,\n+\tsvint32x4_t z0, svint32x4_t z4, svint8_t stack,\n+\tint x5, svbool_t p0, int x6, int64_t x7)\n+{\n+  svst1 (p0, x0 + x7, stack);\n+}\n+\n+void __attribute__((noipa))\n+caller (int8_t *x0, svbool_t p0, svint32x4_t z0, svint32x4_t z4)\n+{\n+  callee (x0, 1, 2, 3, z0, z4, svdup_s8 (42), 5, p0, 6, 7);\n+}\n+\n+/* { dg-final { scan-assembler {\\tmov\\t(z[0-9]+\\.b), #42\\n.*\\tst1b\\t\\1, p[0-7], \\[x4\\]\\n} } } */"}, {"sha": "921ee39258885957715b250eb5fcb6baa4b60873", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/args_9.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fargs_9.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee:\n+**\tldr\t(x[0-9]+), \\[sp, 8\\]\n+**\tldr\tp0, \\[\\1\\]\n+**\tret\n+*/\n+svbool_t __attribute__((noipa))\n+callee (svint64x4_t z0, svint16x4_t z4,\n+\tsvint64_t stack1, svint32_t stack2,\n+\tsvint16_t stack3, svint8_t stack4,\n+\tsvuint64_t stack5, svuint32_t stack6,\n+\tsvuint16_t stack7, svuint8_t stack8,\n+\tsvbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3,\n+\tsvbool_t stack9, svbool_t stack10)\n+{\n+  return stack10;\n+}\n+\n+uint64_t __attribute__((noipa))\n+caller (int64_t *x0, int16_t *x1, svbool_t p0)\n+{\n+  svbool_t res;\n+  res = callee (svld4 (p0, x0),\n+\t\tsvld4 (p0, x1),\n+\t\tsvdup_s64 (1),\n+\t\tsvdup_s32 (2),\n+\t\tsvdup_s16 (3),\n+\t\tsvdup_s8 (4),\n+\t\tsvdup_u64 (5),\n+\t\tsvdup_u32 (6),\n+\t\tsvdup_u16 (7),\n+\t\tsvdup_u8 (8),\n+\t\tsvptrue_pat_b8 (SV_VL5),\n+\t\tsvptrue_pat_b16 (SV_VL6),\n+\t\tsvptrue_pat_b32 (SV_VL7),\n+\t\tsvptrue_pat_b64 (SV_VL8),\n+\t\tsvptrue_pat_b8 (SV_MUL3),\n+\t\tsvptrue_pat_b16 (SV_MUL3));\n+  return svcntp_b8 (res, res);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\t(p[0-9]+)\\.b, mul3\\n\\tstr\\t\\1, \\[(x[0-9]+)\\]\\n.*\\tstr\\t\\2, \\[sp\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\tptrue\\t(p[0-9]+)\\.h, mul3\\n\\tstr\\t\\1, \\[(x[0-9]+)\\]\\n.*\\tstr\\t\\2, \\[sp, 8\\]\\n} } } */"}, {"sha": "26802c87f5c4f54548d63d8ee7447cee08a9f3ce", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+svbool_t return_bool ();\n+\n+void\n+f (void)\n+{\n+  return_bool (); /* { dg-error {'return_bool' requires the SVE ISA extension} } */\n+}"}, {"sha": "663165f892d5f9f557d5a3880749fcc1b3383e7f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_2.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+svbool_t return_bool ();\n+\n+void\n+f (svbool_t *ptr)\n+{\n+  *ptr = return_bool (); /* { dg-error {'return_bool' requires the SVE ISA extension} } */\n+}"}, {"sha": "6d5823cfde1c4200bee39c1398c04d20f41d1023", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_3.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+svbool_t (*return_bool) ();\n+\n+void\n+f (svbool_t *ptr)\n+{\n+  *ptr = return_bool (); /* { dg-error {calls to functions of type 'svbool_t\\(\\)' require the SVE ISA extension} } */\n+}"}, {"sha": "81e31cf4f1e17edd61a2afb2c5a406580c1674de", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_4.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+void take_svuint8 (svuint8_t);\n+\n+void\n+f (svuint8_t *ptr)\n+{\n+  take_svuint8 (*ptr); /* { dg-error {'take_svuint8' requires the SVE ISA extension} } */\n+}"}, {"sha": "300ed00a086cfb5620ccac9c597ecd5bec8ccc1c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_5.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+void take_svuint8_eventually (float, float, float, float,\n+\t\t\t      float, float, float, float, svuint8_t);\n+\n+void\n+f (svuint8_t *ptr)\n+{\n+  take_svuint8_eventually (0, 0, 0, 0, 0, 0, 0, 0, *ptr); /* { dg-error {arguments of type '(svuint8_t|__SVUint8_t)' require the SVE ISA extension} } */\n+}"}, {"sha": "4bddf76f8ed737ff0e47f18f689998c6023f3ace", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_6.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+void unprototyped ();\n+\n+void\n+f (svuint8_t *ptr)\n+{\n+  unprototyped (*ptr); /* { dg-error {arguments of type '(svuint8_t|__SVUint8_t)' require the SVE ISA extension} } */\n+}"}, {"sha": "ef742711dd0af4979123b3860f02efd89d21be98", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_7.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_7.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+void f (svuint8_t x) {} /* { dg-error {'f' requires the SVE ISA extension} } */"}, {"sha": "45b549f120bd5bb8f069457f0ec800b7c6edcc71", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/nosve_8.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fnosve_8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-prune-output \"compilation terminated\" } */\n+\n+#include <arm_sve.h>\n+\n+#pragma GCC target \"+nosve\"\n+\n+void\n+f (float a, float b, float c, float d, float e, float f, float g, float h, svuint8_t x) /* { dg-error {arguments of type '(svuint8_t|__SVUint8_t)' require the SVE ISA extension} } */\n+{\n+}"}, {"sha": "121053915099101ff2c13737a8364429686ab3d9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+__SVBool_t __attribute__((noipa))\n+callee_pred (__SVBool_t *ptr)\n+{\n+  return *ptr;\n+}\n+\n+#include <arm_sve.h>\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (__SVBool_t *ptr1)\n+{\n+  __SVBool_t p;\n+  p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "a44a988616f2e141d85b0e37fa855a15454a1876", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_1_1024.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_1024.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=1024 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+__SVBool_t __attribute__((noipa))\n+callee_pred (__SVBool_t *ptr)\n+{\n+  return *ptr;\n+}\n+\n+#include <arm_sve.h>\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (__SVBool_t *ptr1)\n+{\n+  __SVBool_t p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "d5030ce8e7d25a64b4595e2f03231df9949b25ee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_1_2048.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_2048.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=2048 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+__SVBool_t __attribute__((noipa))\n+callee_pred (__SVBool_t *ptr)\n+{\n+  return *ptr;\n+}\n+\n+#include <arm_sve.h>\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (__SVBool_t *ptr1)\n+{\n+  __SVBool_t p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "a59af1931a464f6dbf62deb3aeb40da0e83c4b65", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_1_256.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_256.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=256 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+__SVBool_t __attribute__((noipa))\n+callee_pred (__SVBool_t *ptr)\n+{\n+  return *ptr;\n+}\n+\n+#include <arm_sve.h>\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (__SVBool_t *ptr1)\n+{\n+  __SVBool_t p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "774c308cfbbcdb1ec707404a0bf18d1d6dc512a1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_1_512.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_1_512.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=512 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+__SVBool_t __attribute__((noipa))\n+callee_pred (__SVBool_t *ptr)\n+{\n+  return *ptr;\n+}\n+\n+#include <arm_sve.h>\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (__SVBool_t *ptr1)\n+{\n+  __SVBool_t p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "4c0f598197dc9e282ae2e371aef99da083c7a139", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_2.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+svbool_t __attribute__((noipa))\n+callee_pred (svbool_t *ptr)\n+{\n+  return *ptr;\n+}\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (svbool_t *ptr1)\n+{\n+  svbool_t p;\n+  p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "e9c50b651a853fae7dab66f23722152d51d0a613", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_3.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+typedef svbool_t my_pred;\n+\n+/*\n+** callee_pred:\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+my_pred __attribute__((noipa))\n+callee_pred (my_pred *ptr)\n+{\n+  return *ptr;\n+}\n+\n+/*\n+** caller_pred:\n+**\t...\n+**\tbl\tcallee_pred\n+**\tcntp\tx0, p0, p0.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_pred (my_pred *ptr1)\n+{\n+  my_pred p;\n+  p = callee_pred (ptr1);\n+  return svcntp_b8 (p, p);\n+}"}, {"sha": "8167305ba30bd6b5a1cfc55675ec109d306987ad", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_4.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, __SVInt8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, __SVUint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, __SVInt16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, __SVUint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, __SVFloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, __SVInt32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, __SVUint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, __SVFloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, __SVInt64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, __SVUint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, __SVFloat64_t)\n+\n+#include <arm_sve.h>\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, __SVInt8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, __SVUint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, __SVInt16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, __SVUint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, __SVFloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, __SVInt32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, __SVUint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, __SVFloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, __SVInt64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, __SVUint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, __SVFloat64_t)"}, {"sha": "bfbb911e50478bc63d9487f0cdf8275a79cb197f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_4_1024.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_1024.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=1024 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, __SVInt8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, __SVUint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, __SVInt16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, __SVUint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, __SVFloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, __SVInt32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, __SVUint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, __SVFloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, __SVInt64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, __SVUint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, __SVFloat64_t)\n+\n+#include <arm_sve.h>\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, __SVInt8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, __SVUint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, __SVInt16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, __SVUint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, __SVFloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, __SVInt32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, __SVUint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, __SVFloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, __SVInt64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, __SVUint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, __SVFloat64_t)"}, {"sha": "751b1f5e1cf0f63bc9c7835e0d968207bad29bb2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_4_2048.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_2048.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=2048 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, __SVInt8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, __SVUint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, __SVInt16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, __SVUint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, __SVFloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, __SVInt32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, __SVUint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, __SVFloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, __SVInt64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, __SVUint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, __SVFloat64_t)\n+\n+#include <arm_sve.h>\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, __SVInt8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, __SVUint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, __SVInt16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, __SVUint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, __SVFloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, __SVInt32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, __SVUint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, __SVFloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, __SVInt64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, __SVUint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, __SVFloat64_t)"}, {"sha": "5bc467b107df20e8a15b65f4ec9e24f5f77b93a2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_4_256.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_256.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=256 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, __SVInt8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, __SVUint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, __SVInt16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, __SVUint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, __SVFloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, __SVInt32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, __SVUint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, __SVFloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, __SVInt64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, __SVUint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, __SVFloat64_t)\n+\n+#include <arm_sve.h>\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, __SVInt8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, __SVUint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, __SVInt16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, __SVUint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, __SVFloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, __SVInt32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, __SVUint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, __SVFloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, __SVInt64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, __SVUint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, __SVFloat64_t)"}, {"sha": "46b38ac7697ac7a59f577c249e913d40c2682b97", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_4_512.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_4_512.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=512 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, __SVInt8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, __SVUint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, __SVInt16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, __SVUint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, __SVFloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, __SVInt32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, __SVUint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, __SVFloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, __SVInt64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, __SVUint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, __SVFloat64_t)\n+\n+#include <arm_sve.h>\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, __SVInt8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, __SVUint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, __SVInt16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, __SVUint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, __SVFloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, __SVInt32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, __SVUint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, __SVFloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, __SVInt64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, __SVUint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, __SVFloat64_t)"}, {"sha": "becabd92e74e56e8e104269f60e012d192447f8f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_5.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "f2a3fd56f14997d3b44c9a35970a6d0a8631d149", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_5_1024.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_1024.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=1024 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "0875acc56ff803a38166ee3e7a5eb6da1ef12fe3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_5_2048.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_2048.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=2048 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "bcd052b1921c09b9bfdc8bf965cbd9c76b14baa9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_5_256.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_256.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=256 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "2122c3279e9a17c34ec4eca7b347369b16caa1e8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_5_512.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_5_512.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,237 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=512 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\t\t\\\n+  typeof (svaddv (svptrue_b8 (), *(TYPE *) 0))\t\t\t\\\n+  __attribute__((noipa))\t\t\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    return svaddv (svptrue_b8 (), callee_##SUFFIX (ptr1));\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.b\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.h\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tfaddv\th0, \\1, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tsaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.s\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tfaddv\ts0, \\1, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tuaddv\t(d[0-9]+), \\1, z0\\.d\n+**\tfmov\tx0, \\2\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tfaddv\td0, \\1, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "33bb2d9414fb7851b5b0c9fcc4d302eaf9f8ab50", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_6.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,258 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+typedef int8_t svint8_t __attribute__ ((vector_size (32)));\n+typedef uint8_t svuint8_t __attribute__ ((vector_size (32)));\n+\n+typedef int16_t svint16_t __attribute__ ((vector_size (32)));\n+typedef uint16_t svuint16_t __attribute__ ((vector_size (32)));\n+typedef __fp16 svfloat16_t __attribute__ ((vector_size (32)));\n+\n+typedef int32_t svint32_t __attribute__ ((vector_size (32)));\n+typedef uint32_t svuint32_t __attribute__ ((vector_size (32)));\n+typedef float svfloat32_t __attribute__ ((vector_size (32)));\n+\n+typedef int64_t svint64_t __attribute__ ((vector_size (32)));\n+typedef uint64_t svuint64_t __attribute__ ((vector_size (32)));\n+typedef double svfloat64_t __attribute__ ((vector_size (32)));\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/* Currently we scalarize this.  */\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/* Currently we scalarize this.  */\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+** (\n+**\tld1\t({v.*}), \\[x0\\]\n+**\tst1\t\\1, \\[x8\\]\n+** |\n+**\tldp\t(q[0-9]+, q[0-9]+), \\[x0\\]\n+**\tstp\t\\2, \\[x8\\]\n+** )\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/* Currently we scalarize this.  */\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\\\n+  typeof ((*(TYPE *) 0)[0])\t\t\\\n+  __attribute__((noipa))\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1)\t\t\\\n+  {\t\t\t\t\t\\\n+    return callee_##SUFFIX (ptr1)[0];\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tldrb\tw0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tldrb\tw0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tldrh\tw0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tldrh\tw0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tldr\th0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tldr\tw0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tldr\tw0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tldr\ts0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tldr\tx0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tldr\tx0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tldr\td0, \\[sp, 16\\]\n+**\tldp\tx29, x30, \\[sp\\], 48\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "696f26a446e9d0be05d3f2115c5a42b6f9b2165f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_6_1024.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_1024.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,265 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=1024 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+typedef int8_t svint8_t __attribute__ ((vector_size (128)));\n+typedef uint8_t svuint8_t __attribute__ ((vector_size (128)));\n+\n+typedef int16_t svint16_t __attribute__ ((vector_size (128)));\n+typedef uint16_t svuint16_t __attribute__ ((vector_size (128)));\n+typedef __fp16 svfloat16_t __attribute__ ((vector_size (128)));\n+\n+typedef int32_t svint32_t __attribute__ ((vector_size (128)));\n+typedef uint32_t svuint32_t __attribute__ ((vector_size (128)));\n+typedef float svfloat32_t __attribute__ ((vector_size (128)));\n+\n+typedef int64_t svint64_t __attribute__ ((vector_size (128)));\n+typedef uint64_t svuint64_t __attribute__ ((vector_size (128)));\n+typedef double svfloat64_t __attribute__ ((vector_size (128)));\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl128\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1, TYPE *ptr2)\t\\\n+  {\t\t\t\t\t\t\\\n+    *ptr2 = callee_##SUFFIX (ptr1);\t\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "254a36ba8372296f3a1efe7307dec8d0362c92ea", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_6_2048.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_2048.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,265 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=2048 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+typedef int8_t svint8_t __attribute__ ((vector_size (256)));\n+typedef uint8_t svuint8_t __attribute__ ((vector_size (256)));\n+\n+typedef int16_t svint16_t __attribute__ ((vector_size (256)));\n+typedef uint16_t svuint16_t __attribute__ ((vector_size (256)));\n+typedef __fp16 svfloat16_t __attribute__ ((vector_size (256)));\n+\n+typedef int32_t svint32_t __attribute__ ((vector_size (256)));\n+typedef uint32_t svuint32_t __attribute__ ((vector_size (256)));\n+typedef float svfloat32_t __attribute__ ((vector_size (256)));\n+\n+typedef int64_t svint64_t __attribute__ ((vector_size (256)));\n+typedef uint64_t svuint64_t __attribute__ ((vector_size (256)));\n+typedef double svfloat64_t __attribute__ ((vector_size (256)));\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl256\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1, TYPE *ptr2)\t\\\n+  {\t\t\t\t\t\t\\\n+    *ptr2 = callee_##SUFFIX (ptr1);\t\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "414f66f2bcaf48174a915ca15805e430146ab677", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_6_256.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_256.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,265 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=256 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+typedef int8_t svint8_t __attribute__ ((vector_size (32)));\n+typedef uint8_t svuint8_t __attribute__ ((vector_size (32)));\n+\n+typedef int16_t svint16_t __attribute__ ((vector_size (32)));\n+typedef uint16_t svuint16_t __attribute__ ((vector_size (32)));\n+typedef __fp16 svfloat16_t __attribute__ ((vector_size (32)));\n+\n+typedef int32_t svint32_t __attribute__ ((vector_size (32)));\n+typedef uint32_t svuint32_t __attribute__ ((vector_size (32)));\n+typedef float svfloat32_t __attribute__ ((vector_size (32)));\n+\n+typedef int64_t svint64_t __attribute__ ((vector_size (32)));\n+typedef uint64_t svuint64_t __attribute__ ((vector_size (32)));\n+typedef double svfloat64_t __attribute__ ((vector_size (32)));\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1, TYPE *ptr2)\t\\\n+  {\t\t\t\t\t\t\\\n+    *ptr2 = callee_##SUFFIX (ptr1);\t\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "7673ea2ab670603d11945600241a98875ee9588f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_6_512.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_6_512.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,265 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msve-vector-bits=512 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+typedef int8_t svint8_t __attribute__ ((vector_size (64)));\n+typedef uint8_t svuint8_t __attribute__ ((vector_size (64)));\n+\n+typedef int16_t svint16_t __attribute__ ((vector_size (64)));\n+typedef uint16_t svuint16_t __attribute__ ((vector_size (64)));\n+typedef __fp16 svfloat16_t __attribute__ ((vector_size (64)));\n+\n+typedef int32_t svint32_t __attribute__ ((vector_size (64)));\n+typedef uint32_t svuint32_t __attribute__ ((vector_size (64)));\n+typedef float svfloat32_t __attribute__ ((vector_size (64)));\n+\n+typedef int64_t svint64_t __attribute__ ((vector_size (64)));\n+typedef uint64_t svuint64_t __attribute__ ((vector_size (64)));\n+typedef double svfloat64_t __attribute__ ((vector_size (64)));\n+\n+#define CALLEE(SUFFIX, TYPE)\t\t\t\\\n+  TYPE __attribute__((noipa))\t\t\t\\\n+  callee_##SUFFIX (TYPE *ptr)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return *ptr;\t\t\t\t\\\n+  }\n+\n+/*\n+** callee_s8:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s8, svint8_t)\n+\n+/*\n+** callee_u8:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tst1b\tz0\\.b, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u8, svuint8_t)\n+\n+/*\n+** callee_s16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s16, svint16_t)\n+\n+/*\n+** callee_u16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u16, svuint16_t)\n+\n+/*\n+** callee_f16:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tst1h\tz0\\.h, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f16, svfloat16_t)\n+\n+/*\n+** callee_s32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s32, svint32_t)\n+\n+/*\n+** callee_u32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u32, svuint32_t)\n+\n+/*\n+** callee_f32:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tst1w\tz0\\.s, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f32, svfloat32_t)\n+\n+/*\n+** callee_s64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (s64, svint64_t)\n+\n+/*\n+** callee_u64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (u64, svuint64_t)\n+\n+/*\n+** callee_f64:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tst1d\tz0\\.d, \\1, \\[x8\\]\n+**\tret\n+*/\n+CALLEE (f64, svfloat64_t)\n+\n+#define CALLER(SUFFIX, TYPE)\t\t\t\\\n+  void __attribute__((noipa))\t\t\t\\\n+  caller_##SUFFIX (TYPE *ptr1, TYPE *ptr2)\t\\\n+  {\t\t\t\t\t\t\\\n+    *ptr2 = callee_##SUFFIX (ptr1);\t\t\\\n+  }\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s8, svint8_t)\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1b\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u8, svuint8_t)\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s16, svint16_t)\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u16, svuint16_t)\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1h\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f16, svfloat16_t)\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s32, svint32_t)\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u32, svuint32_t)\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1w\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f32, svfloat32_t)\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (s64, svint64_t)\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (u64, svuint64_t)\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[[^]]*\\]\n+**\tst1d\t\\1, \\2, \\[[^]]*\\]\n+**\t...\n+**\tret\n+*/\n+CALLER (f64, svfloat64_t)"}, {"sha": "d03ef69de0e7cd65d1e39c36947d62c85ec242fc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_7.c", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_7.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,313 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_s8:\n+**\tmov\tz0\\.b, #1\n+**\tmov\tz1\\.b, #2\n+**\tret\n+*/\n+svint8x2_t __attribute__((noipa))\n+callee_s8 (void)\n+{\n+  return svcreate2 (svdup_s8 (1), svdup_s8 (2));\n+}\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\ttrn1\tz0\\.b, z0\\.b, z1\\.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint8_t __attribute__((noipa))\n+caller_s8 (void)\n+{\n+  svint8x2_t res;\n+  res = callee_s8 ();\n+  return svtrn1 (svget2 (res, 0), svget2 (res, 1));\n+}\n+\n+/*\n+** callee_u8:\n+**\tmov\tz0\\.b, #3\n+**\tmov\tz1\\.b, #4\n+**\tret\n+*/\n+svuint8x2_t __attribute__((noipa))\n+callee_u8 (void)\n+{\n+  return svcreate2 (svdup_u8 (3), svdup_u8 (4));\n+}\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\ttrn2\tz0\\.b, z1\\.b, z0\\.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint8_t __attribute__((noipa))\n+caller_u8 (void)\n+{\n+  svuint8x2_t res;\n+  res = callee_u8 ();\n+  return svtrn2 (svget2 (res, 1), svget2 (res, 0));\n+}\n+\n+/*\n+** callee_s16:\n+**\tmov\tz0\\.h, #1\n+**\tmov\tz1\\.h, #2\n+**\tret\n+*/\n+svint16x2_t __attribute__((noipa))\n+callee_s16 (void)\n+{\n+  return svcreate2 (svdup_s16 (1), svdup_s16 (2));\n+}\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\ttrn1\tz0\\.h, z0\\.h, z1\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint16_t __attribute__((noipa))\n+caller_s16 (void)\n+{\n+  svint16x2_t res;\n+  res = callee_s16 ();\n+  return svtrn1 (svget2 (res, 0), svget2 (res, 1));\n+}\n+\n+/*\n+** callee_u16:\n+**\tmov\tz0\\.h, #3\n+**\tmov\tz1\\.h, #4\n+**\tret\n+*/\n+svuint16x2_t __attribute__((noipa))\n+callee_u16 (void)\n+{\n+  return svcreate2 (svdup_u16 (3), svdup_u16 (4));\n+}\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\ttrn2\tz0\\.h, z1\\.h, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint16_t __attribute__((noipa))\n+caller_u16 (void)\n+{\n+  svuint16x2_t res;\n+  res = callee_u16 ();\n+  return svtrn2 (svget2 (res, 1), svget2 (res, 0));\n+}\n+\n+/*\n+** callee_f16:\n+**\tfmov\tz0\\.h, #5\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.h, #6\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat16x2_t __attribute__((noipa))\n+callee_f16 (void)\n+{\n+  return svcreate2 (svdup_f16 (5), svdup_f16 (6));\n+}\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tzip1\tz0\\.h, z1\\.h, z0\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat16_t __attribute__((noipa))\n+caller_f16 (void)\n+{\n+  svfloat16x2_t res;\n+  res = callee_f16 ();\n+  return svzip1 (svget2 (res, 1), svget2 (res, 0));\n+}\n+\n+/*\n+** callee_s32:\n+**\tmov\tz0\\.s, #1\n+**\tmov\tz1\\.s, #2\n+**\tret\n+*/\n+svint32x2_t __attribute__((noipa))\n+callee_s32 (void)\n+{\n+  return svcreate2 (svdup_s32 (1), svdup_s32 (2));\n+}\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\ttrn1\tz0\\.s, z0\\.s, z1\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint32_t __attribute__((noipa))\n+caller_s32 (void)\n+{\n+  svint32x2_t res;\n+  res = callee_s32 ();\n+  return svtrn1 (svget2 (res, 0), svget2 (res, 1));\n+}\n+\n+/*\n+** callee_u32:\n+**\tmov\tz0\\.s, #3\n+**\tmov\tz1\\.s, #4\n+**\tret\n+*/\n+svuint32x2_t __attribute__((noipa))\n+callee_u32 (void)\n+{\n+  return svcreate2 (svdup_u32 (3), svdup_u32 (4));\n+}\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\ttrn2\tz0\\.s, z1\\.s, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint32_t __attribute__((noipa))\n+caller_u32 (void)\n+{\n+  svuint32x2_t res;\n+  res = callee_u32 ();\n+  return svtrn2 (svget2 (res, 1), svget2 (res, 0));\n+}\n+\n+/*\n+** callee_f32:\n+**\tfmov\tz0\\.s, #5\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.s, #6\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat32x2_t __attribute__((noipa))\n+callee_f32 (void)\n+{\n+  return svcreate2 (svdup_f32 (5), svdup_f32 (6));\n+}\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tzip1\tz0\\.s, z1\\.s, z0\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat32_t __attribute__((noipa))\n+caller_f32 (void)\n+{\n+  svfloat32x2_t res;\n+  res = callee_f32 ();\n+  return svzip1 (svget2 (res, 1), svget2 (res, 0));\n+}\n+\n+/*\n+** callee_s64:\n+**\tmov\tz0\\.d, #1\n+**\tmov\tz1\\.d, #2\n+**\tret\n+*/\n+svint64x2_t __attribute__((noipa))\n+callee_s64 (void)\n+{\n+  return svcreate2 (svdup_s64 (1), svdup_s64 (2));\n+}\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\ttrn1\tz0\\.d, z0\\.d, z1\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint64_t __attribute__((noipa))\n+caller_s64 (void)\n+{\n+  svint64x2_t res;\n+  res = callee_s64 ();\n+  return svtrn1 (svget2 (res, 0), svget2 (res, 1));\n+}\n+\n+/*\n+** callee_u64:\n+**\tmov\tz0\\.d, #3\n+**\tmov\tz1\\.d, #4\n+**\tret\n+*/\n+svuint64x2_t __attribute__((noipa))\n+callee_u64 (void)\n+{\n+  return svcreate2 (svdup_u64 (3), svdup_u64 (4));\n+}\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\ttrn2\tz0\\.d, z1\\.d, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint64_t __attribute__((noipa))\n+caller_u64 (void)\n+{\n+  svuint64x2_t res;\n+  res = callee_u64 ();\n+  return svtrn2 (svget2 (res, 1), svget2 (res, 0));\n+}\n+\n+/*\n+** callee_f64:\n+**\tfmov\tz0\\.d, #5\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.d, #6\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat64x2_t __attribute__((noipa))\n+callee_f64 (void)\n+{\n+  return svcreate2 (svdup_f64 (5), svdup_f64 (6));\n+}\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tzip1\tz0\\.d, z1\\.d, z0\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat64_t __attribute__((noipa))\n+caller_f64 (void)\n+{\n+  svfloat64x2_t res;\n+  res = callee_f64 ();\n+  return svzip1 (svget2 (res, 1), svget2 (res, 0));\n+}"}, {"sha": "6a094bbf86920a6d80f0030d819281c4abf4d216", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_8.c", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,346 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -frename-registers -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_s8:\n+**\tmov\tz0\\.b, #1\n+**\tmov\tz1\\.b, #2\n+**\tmov\tz2\\.b, #3\n+**\tret\n+*/\n+svint8x3_t __attribute__((noipa))\n+callee_s8 (void)\n+{\n+  return svcreate3 (svdup_s8 (1), svdup_s8 (2), svdup_s8 (3));\n+}\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmad\tz0\\.b, \\1/m, z1\\.b, z2\\.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint8_t __attribute__((noipa))\n+caller_s8 (void)\n+{\n+  svint8x3_t res;\n+  res = callee_s8 ();\n+  return svmad_x (svptrue_b8 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_u8:\n+**\tmov\tz0\\.b, #4\n+**\tmov\tz1\\.b, #5\n+**\tmov\tz2\\.b, #6\n+**\tret\n+*/\n+svuint8x3_t __attribute__((noipa))\n+callee_u8 (void)\n+{\n+  return svcreate3 (svdup_u8 (4), svdup_u8 (5), svdup_u8 (6));\n+}\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmsb\tz0\\.b, \\1/m, z1\\.b, z2\\.b\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint8_t __attribute__((noipa))\n+caller_u8 (void)\n+{\n+  svuint8x3_t res;\n+  res = callee_u8 ();\n+  return svmsb_x (svptrue_b8 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_s16:\n+**\tmov\tz0\\.h, #1\n+**\tmov\tz1\\.h, #2\n+**\tmov\tz2\\.h, #3\n+**\tret\n+*/\n+svint16x3_t __attribute__((noipa))\n+callee_s16 (void)\n+{\n+  return svcreate3 (svdup_s16 (1), svdup_s16 (2), svdup_s16 (3));\n+}\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmls\tz0\\.h, \\1/m, z1\\.h, z2\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint16_t __attribute__((noipa))\n+caller_s16 (void)\n+{\n+  svint16x3_t res;\n+  res = callee_s16 ();\n+  return svmls_x (svptrue_b16 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_u16:\n+**\tmov\tz0\\.h, #4\n+**\tmov\tz1\\.h, #5\n+**\tmov\tz2\\.h, #6\n+**\tret\n+*/\n+svuint16x3_t __attribute__((noipa))\n+callee_u16 (void)\n+{\n+  return svcreate3 (svdup_u16 (4), svdup_u16 (5), svdup_u16 (6));\n+}\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmla\tz0\\.h, \\1/m, z1\\.h, z2\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint16_t __attribute__((noipa))\n+caller_u16 (void)\n+{\n+  svuint16x3_t res;\n+  res = callee_u16 ();\n+  return svmla_x (svptrue_b16 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_f16:\n+**\tfmov\tz0\\.h, #1\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.h, #2\\.0(?:e\\+0)?\n+**\tfmov\tz2\\.h, #3\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat16x3_t __attribute__((noipa))\n+callee_f16 (void)\n+{\n+  return svcreate3 (svdup_f16 (1), svdup_f16 (2), svdup_f16 (3));\n+}\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfmla\tz0\\.h, \\1/m, z1\\.h, z2\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat16_t __attribute__((noipa))\n+caller_f16 (void)\n+{\n+  svfloat16x3_t res;\n+  res = callee_f16 ();\n+  return svmla_x (svptrue_b16 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_s32:\n+**\tmov\tz0\\.s, #1\n+**\tmov\tz1\\.s, #2\n+**\tmov\tz2\\.s, #3\n+**\tret\n+*/\n+svint32x3_t __attribute__((noipa))\n+callee_s32 (void)\n+{\n+  return svcreate3 (svdup_s32 (1), svdup_s32 (2), svdup_s32 (3));\n+}\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmad\tz0\\.s, \\1/m, z1\\.s, z2\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint32_t __attribute__((noipa))\n+caller_s32 (void)\n+{\n+  svint32x3_t res;\n+  res = callee_s32 ();\n+  return svmad_x (svptrue_b32 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_u32:\n+**\tmov\tz0\\.s, #4\n+**\tmov\tz1\\.s, #5\n+**\tmov\tz2\\.s, #6\n+**\tret\n+*/\n+svuint32x3_t __attribute__((noipa))\n+callee_u32 (void)\n+{\n+  return svcreate3 (svdup_u32 (4), svdup_u32 (5), svdup_u32 (6));\n+}\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmsb\tz0\\.s, \\1/m, z1\\.s, z2\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint32_t __attribute__((noipa))\n+caller_u32 (void)\n+{\n+  svuint32x3_t res;\n+  res = callee_u32 ();\n+  return svmsb_x (svptrue_b32 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_f32:\n+**\tfmov\tz0\\.s, #1\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.s, #2\\.0(?:e\\+0)?\n+**\tfmov\tz2\\.s, #3\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat32x3_t __attribute__((noipa))\n+callee_f32 (void)\n+{\n+  return svcreate3 (svdup_f32 (1), svdup_f32 (2), svdup_f32 (3));\n+}\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfmla\tz0\\.s, \\1/m, z1\\.s, z2\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat32_t __attribute__((noipa))\n+caller_f32 (void)\n+{\n+  svfloat32x3_t res;\n+  res = callee_f32 ();\n+  return svmla_x (svptrue_b32 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_s64:\n+**\tmov\tz0\\.d, #1\n+**\tmov\tz1\\.d, #2\n+**\tmov\tz2\\.d, #3\n+**\tret\n+*/\n+svint64x3_t __attribute__((noipa))\n+callee_s64 (void)\n+{\n+  return svcreate3 (svdup_s64 (1), svdup_s64 (2), svdup_s64 (3));\n+}\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmls\tz0\\.d, \\1/m, z1\\.d, z2\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint64_t __attribute__((noipa))\n+caller_s64 (void)\n+{\n+  svint64x3_t res;\n+  res = callee_s64 ();\n+  return svmls_x (svptrue_b64 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_u64:\n+**\tmov\tz0\\.d, #4\n+**\tmov\tz1\\.d, #5\n+**\tmov\tz2\\.d, #6\n+**\tret\n+*/\n+svuint64x3_t __attribute__((noipa))\n+callee_u64 (void)\n+{\n+  return svcreate3 (svdup_u64 (4), svdup_u64 (5), svdup_u64 (6));\n+}\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmla\tz0\\.d, \\1/m, z1\\.d, z2\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint64_t __attribute__((noipa))\n+caller_u64 (void)\n+{\n+  svuint64x3_t res;\n+  res = callee_u64 ();\n+  return svmla_x (svptrue_b64 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}\n+\n+/*\n+** callee_f64:\n+**\tfmov\tz0\\.d, #1\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.d, #2\\.0(?:e\\+0)?\n+**\tfmov\tz2\\.d, #3\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat64x3_t __attribute__((noipa))\n+callee_f64 (void)\n+{\n+  return svcreate3 (svdup_f64 (1), svdup_f64 (2), svdup_f64 (3));\n+}\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tfmla\tz0\\.d, \\1/m, z1\\.d, z2\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat64_t __attribute__((noipa))\n+caller_f64 (void)\n+{\n+  svfloat64x3_t res;\n+  res = callee_f64 ();\n+  return svmla_x (svptrue_b64 (),\n+\t\t  svget3 (res, 0), svget3 (res, 1), svget3 (res, 2));\n+}"}, {"sha": "caadbb9ab2493a3f65d188146a354bfe85c40058", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/return_9.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Freturn_9.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,405 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -frename-registers -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+/*\n+** callee_s8:\n+**\tmov\tz0\\.b, #1\n+**\tmov\tz1\\.b, #2\n+**\tmov\tz2\\.b, #3\n+**\tmov\tz3\\.b, #4\n+**\tret\n+*/\n+svint8x4_t __attribute__((noipa))\n+callee_s8 (void)\n+{\n+  return svcreate4 (svdup_s8 (1), svdup_s8 (2), svdup_s8 (3), svdup_s8 (4));\n+}\n+\n+/*\n+** caller_s8:\n+**\t...\n+**\tbl\tcallee_s8\n+**\tadd\t(z[2-7]\\.b), z2\\.b, z3\\.b\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmla\tz0\\.b, \\2/m, (z1\\.b, \\1|\\1, z1\\.b)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint8_t __attribute__((noipa))\n+caller_s8 (void)\n+{\n+  svint8x4_t res;\n+  res = callee_s8 ();\n+  return svmla_x (svptrue_b8 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svadd_x (svptrue_b8 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_u8:\n+**\tmov\tz0\\.b, #4\n+**\tmov\tz1\\.b, #5\n+**\tmov\tz2\\.b, #6\n+**\tmov\tz3\\.b, #7\n+**\tret\n+*/\n+svuint8x4_t __attribute__((noipa))\n+callee_u8 (void)\n+{\n+  return svcreate4 (svdup_u8 (4), svdup_u8 (5), svdup_u8 (6), svdup_u8 (7));\n+}\n+\n+/*\n+** caller_u8:\n+**\t...\n+**\tbl\tcallee_u8\n+**\tsub\t(z[2-7]\\.b), z2\\.b, z3\\.b\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmla\tz0\\.b, \\2/m, (z1\\.b, \\1|\\1, z1\\.b)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint8_t __attribute__((noipa))\n+caller_u8 (void)\n+{\n+  svuint8x4_t res;\n+  res = callee_u8 ();\n+  return svmla_x (svptrue_b8 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svsub_x (svptrue_b8 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_s16:\n+**\tmov\tz0\\.h, #1\n+**\tmov\tz1\\.h, #2\n+**\tmov\tz2\\.h, #3\n+**\tmov\tz3\\.h, #4\n+**\tret\n+*/\n+svint16x4_t __attribute__((noipa))\n+callee_s16 (void)\n+{\n+  return svcreate4 (svdup_s16 (1), svdup_s16 (2),\n+\t\t    svdup_s16 (3), svdup_s16 (4));\n+}\n+\n+/*\n+** caller_s16:\n+**\t...\n+**\tbl\tcallee_s16\n+**\tadd\t(z[2-7]\\.h), z2\\.h, z3\\.h\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmad\tz0\\.h, \\2/m, (z1\\.h, \\1|\\1, z1\\.h)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint16_t __attribute__((noipa))\n+caller_s16 (void)\n+{\n+  svint16x4_t res;\n+  res = callee_s16 ();\n+  return svmad_x (svptrue_b16 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svadd_x (svptrue_b16 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_u16:\n+**\tmov\tz0\\.h, #4\n+**\tmov\tz1\\.h, #5\n+**\tmov\tz2\\.h, #6\n+**\tmov\tz3\\.h, #7\n+**\tret\n+*/\n+svuint16x4_t __attribute__((noipa))\n+callee_u16 (void)\n+{\n+  return svcreate4 (svdup_u16 (4), svdup_u16 (5),\n+\t\t    svdup_u16 (6), svdup_u16 (7));\n+}\n+\n+/*\n+** caller_u16:\n+**\t...\n+**\tbl\tcallee_u16\n+**\tsub\t(z[2-7]\\.h), z2\\.h, z3\\.h\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmad\tz0\\.h, \\2/m, (z1\\.h, \\1|\\1, z1\\.h)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint16_t __attribute__((noipa))\n+caller_u16 (void)\n+{\n+  svuint16x4_t res;\n+  res = callee_u16 ();\n+  return svmad_x (svptrue_b16 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svsub_x (svptrue_b16 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_f16:\n+**\tfmov\tz0\\.h, #1\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.h, #2\\.0(?:e\\+0)?\n+**\tfmov\tz2\\.h, #3\\.0(?:e\\+0)?\n+**\tfmov\tz3\\.h, #4\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat16x4_t __attribute__((noipa))\n+callee_f16 (void)\n+{\n+  return svcreate4 (svdup_f16 (1), svdup_f16 (2),\n+\t\t    svdup_f16 (3), svdup_f16 (4));\n+}\n+\n+/*\n+** caller_f16:\n+**\t...\n+**\tbl\tcallee_f16\n+**\tfadd\t(z[0-9]+\\.h), z0\\.h, z1\\.h\n+**\tfmul\t(z[0-9]+\\.h), \\1, z2\\.h\n+**\tfadd\tz0\\.h, \\2, z3\\.h\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat16_t __attribute__((noipa))\n+caller_f16 (void)\n+{\n+  svfloat16x4_t res;\n+  res = callee_f16 ();\n+  return svadd_x (svptrue_b16 (),\n+\t\t  svmul_x (svptrue_b16 (),\n+\t\t\t   svadd_x (svptrue_b16 (), svget4 (res, 0),\n+\t\t\t\t    svget4 (res, 1)),\n+\t\t\t   svget4 (res, 2)),\n+\t\t  svget4 (res, 3));\n+}\n+\n+/*\n+** callee_s32:\n+**\tmov\tz0\\.s, #1\n+**\tmov\tz1\\.s, #2\n+**\tmov\tz2\\.s, #3\n+**\tmov\tz3\\.s, #4\n+**\tret\n+*/\n+svint32x4_t __attribute__((noipa))\n+callee_s32 (void)\n+{\n+  return svcreate4 (svdup_s32 (1), svdup_s32 (2),\n+\t\t    svdup_s32 (3), svdup_s32 (4));\n+}\n+\n+/*\n+** caller_s32:\n+**\t...\n+**\tbl\tcallee_s32\n+**\tadd\t(z[2-7]\\.s), z2\\.s, z3\\.s\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmsb\tz0\\.s, \\2/m, (z1\\.s, \\1|\\1, z1\\.s)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint32_t __attribute__((noipa))\n+caller_s32 (void)\n+{\n+  svint32x4_t res;\n+  res = callee_s32 ();\n+  return svmsb_x (svptrue_b32 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svadd_x (svptrue_b32 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_u32:\n+**\tmov\tz0\\.s, #4\n+**\tmov\tz1\\.s, #5\n+**\tmov\tz2\\.s, #6\n+**\tmov\tz3\\.s, #7\n+**\tret\n+*/\n+svuint32x4_t __attribute__((noipa))\n+callee_u32 (void)\n+{\n+  return svcreate4 (svdup_u32 (4), svdup_u32 (5),\n+\t\t    svdup_u32 (6), svdup_u32 (7));\n+}\n+\n+/*\n+** caller_u32:\n+**\t...\n+**\tbl\tcallee_u32\n+**\tsub\t(z[2-7]\\.s), z2\\.s, z3\\.s\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmsb\tz0\\.s, \\2/m, (z1\\.s, \\1|\\1, z1\\.s)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint32_t __attribute__((noipa))\n+caller_u32 (void)\n+{\n+  svuint32x4_t res;\n+  res = callee_u32 ();\n+  return svmsb_x (svptrue_b32 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svsub_x (svptrue_b32 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_f32:\n+**\tfmov\tz0\\.s, #1\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.s, #2\\.0(?:e\\+0)?\n+**\tfmov\tz2\\.s, #3\\.0(?:e\\+0)?\n+**\tfmov\tz3\\.s, #4\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat32x4_t __attribute__((noipa))\n+callee_f32 (void)\n+{\n+  return svcreate4 (svdup_f32 (1), svdup_f32 (2),\n+\t\t    svdup_f32 (3), svdup_f32 (4));\n+}\n+\n+/*\n+** caller_f32:\n+**\t...\n+**\tbl\tcallee_f32\n+**\tfadd\t(z[0-9]+\\.s), z0\\.s, z1\\.s\n+**\tfmul\t(z[0-9]+\\.s), \\1, z2\\.s\n+**\tfadd\tz0\\.s, \\2, z3\\.s\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat32_t __attribute__((noipa))\n+caller_f32 (void)\n+{\n+  svfloat32x4_t res;\n+  res = callee_f32 ();\n+  return svadd_x (svptrue_b32 (),\n+\t\t  svmul_x (svptrue_b32 (),\n+\t\t\t   svadd_x (svptrue_b32 (), svget4 (res, 0),\n+\t\t\t\t    svget4 (res, 1)),\n+\t\t\t   svget4 (res, 2)),\n+\t\t  svget4 (res, 3));\n+}\n+\n+/*\n+** callee_s64:\n+**\tmov\tz0\\.d, #1\n+**\tmov\tz1\\.d, #2\n+**\tmov\tz2\\.d, #3\n+**\tmov\tz3\\.d, #4\n+**\tret\n+*/\n+svint64x4_t __attribute__((noipa))\n+callee_s64 (void)\n+{\n+  return svcreate4 (svdup_s64 (1), svdup_s64 (2),\n+\t\t    svdup_s64 (3), svdup_s64 (4));\n+}\n+\n+/*\n+** caller_s64:\n+**\t...\n+**\tbl\tcallee_s64\n+**\tadd\t(z[2-7]\\.d), z2\\.d, z3\\.d\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmls\tz0\\.d, \\2/m, (z1\\.d, \\1|\\1, z1\\.d)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svint64_t __attribute__((noipa))\n+caller_s64 (void)\n+{\n+  svint64x4_t res;\n+  res = callee_s64 ();\n+  return svmls_x (svptrue_b64 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svadd_x (svptrue_b64 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_u64:\n+**\tmov\tz0\\.d, #4\n+**\tmov\tz1\\.d, #5\n+**\tmov\tz2\\.d, #6\n+**\tmov\tz3\\.d, #7\n+**\tret\n+*/\n+svuint64x4_t __attribute__((noipa))\n+callee_u64 (void)\n+{\n+  return svcreate4 (svdup_u64 (4), svdup_u64 (5),\n+\t\t    svdup_u64 (6), svdup_u64 (7));\n+}\n+\n+/*\n+** caller_u64:\n+**\t...\n+**\tbl\tcallee_u64\n+**\tsub\t(z[2-7]\\.d), z2\\.d, z3\\.d\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tmls\tz0\\.d, \\2/m, (z1\\.d, \\1|\\1, z1\\.d)\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svuint64_t __attribute__((noipa))\n+caller_u64 (void)\n+{\n+  svuint64x4_t res;\n+  res = callee_u64 ();\n+  return svmls_x (svptrue_b64 (), svget4 (res, 0), svget4 (res, 1),\n+\t\t  svsub_x (svptrue_b64 (),\n+\t\t\t   svget4 (res, 2),\n+\t\t\t   svget4 (res, 3)));\n+}\n+\n+/*\n+** callee_f64:\n+**\tfmov\tz0\\.d, #1\\.0(?:e\\+0)?\n+**\tfmov\tz1\\.d, #2\\.0(?:e\\+0)?\n+**\tfmov\tz2\\.d, #3\\.0(?:e\\+0)?\n+**\tfmov\tz3\\.d, #4\\.0(?:e\\+0)?\n+**\tret\n+*/\n+svfloat64x4_t __attribute__((noipa))\n+callee_f64 (void)\n+{\n+  return svcreate4 (svdup_f64 (1), svdup_f64 (2),\n+\t\t    svdup_f64 (3), svdup_f64 (4));\n+}\n+\n+/*\n+** caller_f64:\n+**\t...\n+**\tbl\tcallee_f64\n+**\tfadd\t(z[0-9]+\\.d), z0\\.d, z1\\.d\n+**\tfmul\t(z[0-9]+\\.d), \\1, z2\\.d\n+**\tfadd\tz0\\.d, \\2, z3\\.d\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svfloat64_t __attribute__((noipa))\n+caller_f64 (void)\n+{\n+  svfloat64x4_t res;\n+  res = callee_f64 ();\n+  return svadd_x (svptrue_b64 (),\n+\t\t  svmul_x (svptrue_b64 (),\n+\t\t\t   svadd_x (svptrue_b64 (), svget4 (res, 0),\n+\t\t\t\t    svget4 (res, 1)),\n+\t\t\t   svget4 (res, 2)),\n+\t\t  svget4 (res, 3));\n+}"}, {"sha": "4eee04226875db54f006a7aabf986a76982a8734", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_1_be_nowrap.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_be_nowrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_be_nowrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_be_nowrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-shrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp1\\.b, all\n+**\tst1d\tz8\\.d, p1, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p1, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p1, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p1, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p1, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p1, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p1, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p1, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tptrue\tp1\\.b, all\n+**\tld1d\tz8\\.d, p1/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p1/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p1/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p1/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p1/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p1/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p1/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p1/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, all\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\taddvl\tsp, sp, #-6\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tptrue\tp1\\.b, all\n+**\tst1d\tz8\\.d, p1, \\[sp, #1, mul vl\\]\n+**\tst1d\tz13\\.d, p1, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tptrue\tp1\\.b, all\n+**\tld1d\tz8\\.d, p1/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz13\\.d, p1/z, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\taddvl\tsp, sp, #6\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\taddvl\tsp, sp, #-1\n+**\tptrue\tp1\\.b, all\n+**\tst1d\tz15\\.d, p1, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tptrue\tp1\\.b, all\n+**\tld1d\tz15\\.d, p1/z, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\taddvl\tsp, sp, #-2\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+**\tst1d\tz15\\.d, p4, \\[sp, #1, mul vl\\]\n+**\tmov\tz0\\.b, #1\n+**\tptrue\tp4\\.b, all\n+**\tld1d\tz15\\.d, p4/z, \\[sp, #1, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #2\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz16, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "e88a3dd1da8b6786520c254c7174250055b754c4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_1_be_wrap.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_be_wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_be_wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_be_wrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fshrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp1\\.b, all\n+**\tst1d\tz8\\.d, p1, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p1, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p1, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p1, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p1, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p1, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p1, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p1, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tptrue\tp1\\.b, all\n+**\tld1d\tz8\\.d, p1/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p1/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p1/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p1/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p1/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p1/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p1/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p1/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, all\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\taddvl\tsp, sp, #-6\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tptrue\tp1\\.b, all\n+**\tst1d\tz8\\.d, p1, \\[sp, #1, mul vl\\]\n+**\tst1d\tz13\\.d, p1, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tptrue\tp1\\.b, all\n+**\tld1d\tz8\\.d, p1/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz13\\.d, p1/z, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\taddvl\tsp, sp, #6\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\taddvl\tsp, sp, #-1\n+**\tptrue\tp1\\.b, all\n+**\tst1d\tz15\\.d, p1, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tptrue\tp1\\.b, all\n+**\tld1d\tz15\\.d, p1/z, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\taddvl\tsp, sp, #-2\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp4\\.b, all\n+**\tst1d\tz15\\.d, p4, \\[sp, #1, mul vl\\]\n+**\tmov\tz0\\.b, #1\n+**\tptrue\tp4\\.b, all\n+**\tld1d\tz15\\.d, p4/z, \\[sp, #1, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #2\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz16, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "d14cd79b18267d0cc6a2314b631944b76218e4d7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_1_le_nowrap.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_le_nowrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_le_nowrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_le_nowrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,184 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-shrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, all\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\taddvl\tsp, sp, #-6\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\taddvl\tsp, sp, #6\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz15, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz16, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "d81dd8e6bcd456c68ea8f49aab57d4a63b27b525", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_1_le_wrap.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_le_wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_le_wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_1_le_wrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,184 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, all\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\taddvl\tsp, sp, #-6\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\taddvl\tsp, sp, #6\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz15, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\taddvl\tsp, sp, #-1\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz16, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "d72601bbf9d6d8611cdfdb660d2f35503e2ccaf2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_2_be_nowrap.c", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_be_nowrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_be_nowrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_be_nowrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,271 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-shrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (void);\n+__attribute__((aarch64_vector_pcs)) void vpcs_callee (void);\n+\n+/*\n+** calls_standard:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tstandard_callee\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_standard (__SVInt8_t x) { standard_callee (); }\n+\n+/*\n+** calls_vpcs:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tvpcs_callee\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_vpcs (__SVInt8_t x) { vpcs_callee (); }\n+\n+/*\n+** calls_standard_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_standard_ptr (__SVInt8_t x, void (*fn) (void))\n+{\n+  fn ();\n+}\n+\n+/*\n+** calls_vpcs_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_vpcs_ptr (__SVInt8_t x,\n+\t\tvoid (*__attribute__((aarch64_vector_pcs)) fn) (void))\n+{\n+  fn ();\n+}"}, {"sha": "f715f01407d02ec2fd6273cd2550d87f49dd1878", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_2_be_wrap.c", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_be_wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_be_wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_be_wrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,271 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fshrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (void);\n+__attribute__((aarch64_vector_pcs)) void vpcs_callee (void);\n+\n+/*\n+** calls_standard:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tstandard_callee\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_standard (__SVInt8_t x) { standard_callee (); }\n+\n+/*\n+** calls_vpcs:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tvpcs_callee\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_vpcs (__SVInt8_t x) { vpcs_callee (); }\n+\n+/*\n+** calls_standard_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_standard_ptr (__SVInt8_t x, void (*fn) (void))\n+{\n+  fn ();\n+}\n+\n+/*\n+** calls_vpcs_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_vpcs_ptr (__SVInt8_t x,\n+\t\tvoid (*__attribute__((aarch64_vector_pcs)) fn) (void))\n+{\n+  fn ();\n+}"}, {"sha": "cb709e759ae4624c40eb0ae1b17add3317d0676e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_2_le_nowrap.c", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_le_nowrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_le_nowrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_le_nowrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,255 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-shrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (void);\n+__attribute__((aarch64_vector_pcs)) void vpcs_callee (void);\n+\n+/*\n+** calls_standard:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tstandard_callee\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_standard (__SVInt8_t x) { standard_callee (); }\n+\n+/*\n+** calls_vpcs:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tvpcs_callee\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_vpcs (__SVInt8_t x) { vpcs_callee (); }\n+\n+/*\n+** calls_standard_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_standard_ptr (__SVInt8_t x, void (*fn) (void))\n+{\n+  fn ();\n+}\n+\n+/*\n+** calls_vpcs_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_vpcs_ptr (__SVInt8_t x,\n+\t\tvoid (*__attribute__((aarch64_vector_pcs)) fn) (void))\n+{\n+  fn ();\n+}"}, {"sha": "ef24c7affa887bab67c1a908c0a2446a3021e994", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_2_le_wrap.c", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_le_wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_le_wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_2_le_wrap.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,255 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (void);\n+__attribute__((aarch64_vector_pcs)) void vpcs_callee (void);\n+\n+/*\n+** calls_standard:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tstandard_callee\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_standard (__SVInt8_t x) { standard_callee (); }\n+\n+/*\n+** calls_vpcs:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tbl\tvpcs_callee\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void calls_vpcs (__SVInt8_t x) { vpcs_callee (); }\n+\n+/*\n+** calls_standard_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_standard_ptr (__SVInt8_t x, void (*fn) (void))\n+{\n+  fn ();\n+}\n+\n+/*\n+** calls_vpcs_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tblr\tx0\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+void\n+calls_vpcs_ptr (__SVInt8_t x,\n+\t\tvoid (*__attribute__((aarch64_vector_pcs)) fn) (void))\n+{\n+  fn ();\n+}"}, {"sha": "283c5bbae6d9f1f75b2c440aff90afce25c69fed", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_3.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_3.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+int sve_callee (svint8_t);\n+\n+/*\n+** standard_caller:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tmov\tz0\\.b, #1\n+**\tbl\tsve_callee\n+**\tadd\tw0, w0, #?1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+int standard_caller (void) { return sve_callee (svdup_s8 (1)) + 1; }\n+\n+/*\n+** vpcs_caller:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tmov\tz0\\.b, #1\n+**\tbl\tsve_callee\n+**\tadd\tw0, w0, #?1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+__attribute__((aarch64_vector_pcs))\n+int vpcs_caller (void) { return sve_callee (svdup_s8 (1)) + 1; }\n+\n+/*\n+** sve_caller:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tmov\tz0\\.b, #1\n+**\tbl\tsve_callee\n+**\tadd\tw0, w0, #?1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+int sve_caller (svbool_t p0) { return sve_callee (svdup_s8 (1)) + 1; }\n+\n+/*\n+** standard_caller_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tmov\tz0\\.h, #1\n+**\tblr\tx0\n+**\tadd\tw0, w0, #?1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+int\n+standard_caller_ptr (int (*fn) (__SVInt16_t))\n+{\n+  return fn (svdup_s16 (1)) + 1;\n+}\n+\n+/*\n+** vpcs_caller_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tmov\tz0\\.h, #1\n+**\tblr\tx0\n+**\tadd\tw0, w0, #?1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+int __attribute__((aarch64_vector_pcs))\n+vpcs_caller_ptr (int (*fn) (__SVInt16_t))\n+{\n+  return fn (svdup_s16 (1)) + 1;\n+}\n+\n+/*\n+** sve_caller_ptr:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tmov\tz0\\.h, #1\n+**\tblr\tx0\n+**\tadd\tw0, w0, #?1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+int\n+sve_caller_ptr (svbool_t pg, int (*fn) (svint16_t))\n+{\n+  return fn (svdup_s16 (1)) + 1;\n+}"}, {"sha": "aaf8abdc9b3c29ada4a336f9ce2ca712a842170c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_4_be.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_4_be.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_4_be.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_4_be.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (__SVInt8_t *);\n+\n+/*\n+** calls_standard:\n+**\taddvl\tsp, sp, #-1\n+** (\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+** |\n+**\tsub\tsp, sp, #?16\n+**\tstp\tx29, x30, \\[sp\\]\n+** )\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\taddvl\tx0, sp, #17\n+**\tadd\tx0, x0, #?16\n+**\tbl\tstandard_callee\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+** (\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\taddvl\tsp, sp, #1\n+** |\n+**\tldp\tx29, x30, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tadd\tsp, sp, #?16\n+** )\n+**\tret\n+*/\n+void calls_standard (__SVInt8_t x) { __SVInt8_t tmp; standard_callee (&tmp); }"}, {"sha": "648f8a0c09bf7995e473734a3205c1d73cd6ac0a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_4_le.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_4_le.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_4_le.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_4_le.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (__SVInt8_t *);\n+\n+/*\n+** calls_standard:\n+**\taddvl\tsp, sp, #-1\n+** (\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+** |\n+**\tsub\tsp, sp, #?16\n+**\tstp\tx29, x30, \\[sp\\]\n+** )\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\taddvl\tx0, sp, #17\n+**\tadd\tx0, x0, #?16\n+**\tbl\tstandard_callee\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+** (\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\taddvl\tsp, sp, #1\n+** |\n+**\tldp\tx29, x30, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tadd\tsp, sp, #?16\n+** )\n+**\tret\n+*/\n+void calls_standard (__SVInt8_t x) { __SVInt8_t tmp; standard_callee (&tmp); }"}, {"sha": "dc3282eee61ea6cca38b272d8db8265adef38728", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_5_be.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_5_be.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_5_be.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_5_be.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mbig-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (void);\n+\n+/*\n+** calls_standard:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tptrue\tp0\\.b, all\n+**\tst1d\tz8\\.d, p0, \\[sp, #1, mul vl\\]\n+**\tst1d\tz9\\.d, p0, \\[sp, #2, mul vl\\]\n+**\tst1d\tz10\\.d, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz11\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tst1d\tz12\\.d, p0, \\[sp, #5, mul vl\\]\n+**\tst1d\tz13\\.d, p0, \\[sp, #6, mul vl\\]\n+**\tst1d\tz14\\.d, p0, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tst1d\tz15\\.d, p0, \\[x11, #-8, mul vl\\]\n+**\tcbnz\tw0, \\.L[0-9]+\n+**\tptrue\tp0\\.b, all\n+**\tld1d\tz8\\.d, p0/z, \\[sp, #1, mul vl\\]\n+**\tld1d\tz9\\.d, p0/z, \\[sp, #2, mul vl\\]\n+**\tld1d\tz10\\.d, p0/z, \\[sp, #3, mul vl\\]\n+**\tld1d\tz11\\.d, p0/z, \\[sp, #4, mul vl\\]\n+**\tld1d\tz12\\.d, p0/z, \\[sp, #5, mul vl\\]\n+**\tld1d\tz13\\.d, p0/z, \\[sp, #6, mul vl\\]\n+**\tld1d\tz14\\.d, p0/z, \\[sp, #7, mul vl\\]\n+**\taddvl\tx11, sp, #16\n+**\tld1d\tz15\\.d, p0/z, \\[x11, #-8, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+**\t...\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tbl\tstandard_callee\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\tb\t\\.L[0-9]+\n+*/\n+void\n+calls_standard (__SVInt8_t x, int y)\n+{\n+  asm volatile (\"\" ::: \"z8\");\n+  if (__builtin_expect (y, 0))\n+    standard_callee ();\n+}"}, {"sha": "0d29ff2fd4726c486be28994b9c80a30e7e21891", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/saves_5_le.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_5_le.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_5_le.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fsaves_5_le.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+void standard_callee (void);\n+\n+/*\n+** calls_standard:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\taddvl\tsp, sp, #-17\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tcbnz\tw0, \\.L[0-9]+\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+**\t...\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tbl\tstandard_callee\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\tb\t\\.L[0-9]+\n+*/\n+void\n+calls_standard (__SVInt8_t x, int y)\n+{\n+  asm volatile (\"\" ::: \"z8\");\n+  if (__builtin_expect (y, 0))\n+    standard_callee ();\n+}"}, {"sha": "485d01875cd59476ba7cfc4a138de95da3a65dc5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_1.c", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,204 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fstack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\tcntb\tx12\n+**\tmov\tx13, #?17\n+**\tmul\tx12, x12, x13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\taddvl\tsp, sp, #17\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, all\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tcntb\tx12, all, mul #6\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\taddvl\tsp, sp, #6\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tcntb\tx12\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\tcntb\tx12\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz15, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\tcntb\tx12\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\tcntb\tx12\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, all\n+**\tldr\tz16, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "087e8db9e836d06b94da856d0c5e34a14c9326b3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_1_1024.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_1024.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,184 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fstack-clash-protection -msve-vector-bits=1024 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #2176\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\tadd\tsp, sp, #?2176\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, vl128\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tsub\tsp, sp, #768\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\tadd\tsp, sp, #?768\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #128\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #128\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\tsub\tsp, sp, #128\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\tsub\tsp, sp, #128\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tz16, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "e8dc5d5e4c4a086a1585da031debce147cecdd6a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_1_2048.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_2048.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,185 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fstack-clash-protection -msve-vector-bits=2048 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\tmov\tx12, #?4352\n+**\tsub\tsp, sp, x12\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, vl256\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tsub\tsp, sp, #1536\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\tadd\tsp, sp, #?1536\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #256\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #256\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\tsub\tsp, sp, #256\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\tsub\tsp, sp, #256\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tz16, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "73c49e4d4f72a1aa9ce62b06e2bc763f63e93d69", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_1_256.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_256.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,184 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fstack-clash-protection -msve-vector-bits=256 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #544\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\tadd\tsp, sp, #?544\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, vl32\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tsub\tsp, sp, #192\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\tadd\tsp, sp, #?192\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #32\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #32\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\tsub\tsp, sp, #32\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\tsub\tsp, sp, #32\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tz16, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "d4b524147a024b8112a4445e838a901f79caaba9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_1_512.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_1_512.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,184 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mlittle-endian -fshrink-wrap -fstack-clash-protection -msve-vector-bits=512 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #1088\n+**\tstr\tp4, \\[sp\\]\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\tstr\tp7, \\[sp, #3, mul vl\\]\n+**\tstr\tp8, \\[sp, #4, mul vl\\]\n+**\tstr\tp9, \\[sp, #5, mul vl\\]\n+**\tstr\tp10, \\[sp, #6, mul vl\\]\n+**\tstr\tp11, \\[sp, #7, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz9, \\[sp, #2, mul vl\\]\n+**\tstr\tz10, \\[sp, #3, mul vl\\]\n+**\tstr\tz11, \\[sp, #4, mul vl\\]\n+**\tstr\tz12, \\[sp, #5, mul vl\\]\n+**\tstr\tz13, \\[sp, #6, mul vl\\]\n+**\tstr\tz14, \\[sp, #7, mul vl\\]\n+**\tstr\tz15, \\[sp, #8, mul vl\\]\n+**\tstr\tz16, \\[sp, #9, mul vl\\]\n+**\tstr\tz17, \\[sp, #10, mul vl\\]\n+**\tstr\tz18, \\[sp, #11, mul vl\\]\n+**\tstr\tz19, \\[sp, #12, mul vl\\]\n+**\tstr\tz20, \\[sp, #13, mul vl\\]\n+**\tstr\tz21, \\[sp, #14, mul vl\\]\n+**\tstr\tz22, \\[sp, #15, mul vl\\]\n+**\tstr\tz23, \\[sp, #16, mul vl\\]\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz9, \\[sp, #2, mul vl\\]\n+**\tldr\tz10, \\[sp, #3, mul vl\\]\n+**\tldr\tz11, \\[sp, #4, mul vl\\]\n+**\tldr\tz12, \\[sp, #5, mul vl\\]\n+**\tldr\tz13, \\[sp, #6, mul vl\\]\n+**\tldr\tz14, \\[sp, #7, mul vl\\]\n+**\tldr\tz15, \\[sp, #8, mul vl\\]\n+**\tldr\tz16, \\[sp, #9, mul vl\\]\n+**\tldr\tz17, \\[sp, #10, mul vl\\]\n+**\tldr\tz18, \\[sp, #11, mul vl\\]\n+**\tldr\tz19, \\[sp, #12, mul vl\\]\n+**\tldr\tz20, \\[sp, #13, mul vl\\]\n+**\tldr\tz21, \\[sp, #14, mul vl\\]\n+**\tldr\tz22, \\[sp, #15, mul vl\\]\n+**\tldr\tz23, \\[sp, #16, mul vl\\]\n+**\tldr\tp4, \\[sp\\]\n+**\tldr\tp5, \\[sp, #1, mul vl\\]\n+**\tldr\tp6, \\[sp, #2, mul vl\\]\n+**\tldr\tp7, \\[sp, #3, mul vl\\]\n+**\tldr\tp8, \\[sp, #4, mul vl\\]\n+**\tldr\tp9, \\[sp, #5, mul vl\\]\n+**\tldr\tp10, \\[sp, #6, mul vl\\]\n+**\tldr\tp11, \\[sp, #7, mul vl\\]\n+**\tadd\tsp, sp, #?1088\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z8\", \"z9\", \"z10\", \"z11\", \"z12\", \"z13\", \"z14\", \"z15\",\n+\t\t\"z16\", \"z17\", \"z18\", \"z19\", \"z20\", \"z21\", \"z22\", \"z23\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+\t\t\"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tptrue\tp0\\.b, vl64\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\n+\t\t\"z24\", \"z25\", \"z26\", \"z27\", \"z28\", \"z29\", \"z30\", \"z31\",\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p12\", \"p13\", \"p14\", \"p15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tsub\tsp, sp, #384\n+**\tstr\tp5, \\[sp\\]\n+**\tstr\tp6, \\[sp, #1, mul vl\\]\n+**\tstr\tp11, \\[sp, #2, mul vl\\]\n+**\tstr\tz8, \\[sp, #1, mul vl\\]\n+**\tstr\tz13, \\[sp, #2, mul vl\\]\n+**\tstr\tz19, \\[sp, #3, mul vl\\]\n+**\tstr\tz20, \\[sp, #4, mul vl\\]\n+**\tstr\tz22, \\[sp, #5, mul vl\\]\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tz8, \\[sp, #1, mul vl\\]\n+**\tldr\tz13, \\[sp, #2, mul vl\\]\n+**\tldr\tz19, \\[sp, #3, mul vl\\]\n+**\tldr\tz20, \\[sp, #4, mul vl\\]\n+**\tldr\tz22, \\[sp, #5, mul vl\\]\n+**\tldr\tp5, \\[sp\\]\n+**\tldr\tp6, \\[sp, #1, mul vl\\]\n+**\tldr\tp11, \\[sp, #2, mul vl\\]\n+**\tadd\tsp, sp, #?384\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  asm volatile (\"\" :::\n+\t\t\"z8\", \"z13\", \"z19\", \"z20\", \"z22\",\n+\t\t\"p5\", \"p6\", \"p11\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #64\n+**\tstr\tp4, \\[sp\\]\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #64\n+**\tstr\tz15, \\[sp\\]\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  asm volatile (\"\" ::: \"z15\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_6:\n+**\tsub\tsp, sp, #64\n+**\tstr\tz15, \\[sp\\]\n+**\tmov\tz0\\.b, #1\n+**\tldr\tz15, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+svint8_t\n+test_6 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3)\n+{\n+  asm volatile (\"\" :: \"Upa\" (p0), \"Upa\" (p1), \"Upa\" (p2), \"Upa\" (p3) : \"z15\");\n+  return svdup_s8 (1);\n+}\n+\n+/*\n+** test_7:\n+**\tsub\tsp, sp, #64\n+**\tstr\tz16, \\[sp\\]\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tz16, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  asm volatile (\"\" ::: \"z16\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "4622a1eed0ab4517cf6e5e3bee7400c50e43a66c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_2.c", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,336 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fshrink-wrap -fstack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svbool_t take_stack_args (volatile void *, void *, int, int, int,\n+\t\t\t  int, int, int, int);\n+\n+/*\n+** test_1:\n+**\tcntb\tx12\n+**\tadd\tx12, x12, #?16\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tstp\tx24, x25, \\[sp, -48\\]!\n+**\tstr\tx26, \\[sp, 16\\]\n+**\tcntb\tx13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x13\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldr\tx26, \\[sp, 16\\]\n+**\tldp\tx24, x25, \\[sp\\], 48\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tcntb\tx12\n+**\tmov\tx13, #?4128\n+**\tadd\tx12, x12, x13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx24, x25, \\[x11\\]\n+**\tstr\tx26, \\[x11, 16\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx24, x25, \\[sp\\]\n+**\tldr\tx26, \\[sp, 16\\]\n+**\tmov\tx12, #?4128\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  volatile int x[1024];\n+  asm volatile (\"\" :: \"r\" (x) : \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tcntb\tx12, all, mul #2\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #2\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_5:\n+**\tcntb\tx12, all, mul #2\n+**\tadd\tx12, x12, #?32\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx24, x25, \\[x11\\]\n+**\tstr\tx26, \\[x11, 16\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx24, x25, \\[sp\\]\n+**\tldr\tx26, \\[sp, 16\\]\n+**\taddvl\tsp, sp, #1\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_6:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tcntb\tx13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x13\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #?16\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svbool_t\n+test_6 (void)\n+{\n+  take_stack_args (0, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_7:\n+**\tcntb\tx12\n+**\tmov\tx13, #?4112\n+**\tadd\tx12, x12, x13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx29, x30, \\[x11\\]\n+**\taddvl\tx29, sp, #1\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #?16\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_8:\n+**\tcntb\tx12\n+**\tmov\tx13, #?4144\n+**\tadd\tx12, x12, x13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx29, x30, \\[x11\\]\n+**\taddvl\tx29, sp, #1\n+**\tstp\tx24, x25, \\[x29, 16\\]\n+**\tstr\tx26, \\[x29, 32\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #?16\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_8 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_9:\n+**\tcntb\tx12\n+**\tmov\tx13, #?4112\n+**\tadd\tx12, x12, x13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx29, x30, \\[x11\\]\n+**\taddvl\tx29, sp, #1\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #?16\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\taddvl\tsp, x29, #-1\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_9 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_10:\n+**\tcntb\tx12\n+**\tmov\tx13, #?4144\n+**\tadd\tx12, x12, x13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx29, x30, \\[x11\\]\n+**\taddvl\tx29, sp, #1\n+**\tstp\tx24, x25, \\[x29, 16\\]\n+**\tstr\tx26, \\[x29, 32\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #?16\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\taddvl\tsp, x29, #-1\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_10 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_11:\n+**\tcntb\tx12\n+**\tadd\tx12, x12, #?3008\n+**\tadd\tx12, x12, #?126976\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x12\n+**\taddvl\tx11, sp, #1\n+**\tstp\tx29, x30, \\[x11\\]\n+**\taddvl\tx29, sp, #1\n+**\tstp\tx24, x25, \\[x29, 16\\]\n+**\tstr\tx26, \\[x29, 32\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #?16\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\taddvl\tsp, x29, #-1\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tadd\tsp, sp, #?3008\n+**\tadd\tsp, sp, #?126976\n+**\tret\n+*/\n+svbool_t\n+test_11 (int n)\n+{\n+  volatile int x[0x7ee4];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "d5a9d4444b3c1e9bbd9cc3c75bd830a93421bdfc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_2_1024.c", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_1024.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,285 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fshrink-wrap -fstack-clash-protection -msve-vector-bits=1024 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svbool_t take_stack_args (volatile void *, void *, int, int, int,\n+\t\t\t  int, int, int, int);\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #144\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?144\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tsub\tsp, sp, #176\n+**\tstp\tx24, x25, \\[sp, 128\\]\n+**\tstr\tx26, \\[sp, 144\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 128\\]\n+**\tldr\tx26, \\[sp, 144\\]\n+**\tadd\tsp, sp, #?176\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tmov\tx12, #?4256\n+**\tsub\tsp, sp, x12\n+**\tstp\tx24, x25, \\[sp, 128\\]\n+**\tstr\tx26, \\[sp, 144\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 128\\]\n+**\tldr\tx26, \\[sp, 144\\]\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  volatile int x[1024];\n+  asm volatile (\"\" :: \"r\" (x) : \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #256\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl64\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #288\n+**\tstp\tx24, x25, \\[sp, 128\\]\n+**\tstr\tx26, \\[sp, 144\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl64\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 128\\]\n+**\tldr\tx26, \\[sp, 144\\]\n+**\tadd\tsp, sp, #?288\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_6:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tsub\tsp, sp, #128\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svbool_t\n+test_6 (void)\n+{\n+  take_stack_args (0, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_7:\n+**\tmov\tx12, #?4240\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 128\\]\n+**\tadd\tx29, sp, #?128\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_8:\n+**\tmov\tx12, #?4272\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 128\\]\n+**\tadd\tx29, sp, #?128\n+**\tstp\tx24, x25, \\[sp, 144\\]\n+**\tstr\tx26, \\[sp, 160\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_8 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_9:\n+**\tmov\tx12, #?4240\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 128\\]\n+**\tadd\tx29, sp, #?128\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tsub\tsp, x29, #128\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_9 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_10:\n+**\tmov\tx12, #?4272\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 128\\]\n+**\tadd\tx29, sp, #?128\n+**\tstp\tx24, x25, \\[sp, 144\\]\n+**\tstr\tx26, \\[sp, 160\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tsub\tsp, x29, #128\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_10 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_11:\n+**\tsub\tsp, sp, #65536\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tmov\tx12, #?64576\n+**\tsub\tsp, sp, x12\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tstp\tx29, x30, \\[sp, 128\\]\n+**\tadd\tx29, sp, #?128\n+**\tstp\tx24, x25, \\[sp, 144\\]\n+**\tstr\tx26, \\[sp, 160\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl128\n+**\tsub\tsp, x29, #128\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tadd\tsp, sp, #?3008\n+**\tadd\tsp, sp, #?126976\n+**\tret\n+*/\n+svbool_t\n+test_11 (int n)\n+{\n+  volatile int x[0x7ee4];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "c185e2e36286776be5fdb929f7f72106e057a909", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_2_2048.c", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_2048.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,285 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fshrink-wrap -fstack-clash-protection -msve-vector-bits=2048 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svbool_t take_stack_args (volatile void *, void *, int, int, int,\n+\t\t\t  int, int, int, int);\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #272\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?272\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tsub\tsp, sp, #304\n+**\tstp\tx24, x25, \\[sp, 256\\]\n+**\tstr\tx26, \\[sp, 272\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 256\\]\n+**\tldr\tx26, \\[sp, 272\\]\n+**\tadd\tsp, sp, #?304\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tmov\tx12, #?4384\n+**\tsub\tsp, sp, x12\n+**\tstp\tx24, x25, \\[sp, 256\\]\n+**\tstr\tx26, \\[sp, 272\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 256\\]\n+**\tldr\tx26, \\[sp, 272\\]\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  volatile int x[1024];\n+  asm volatile (\"\" :: \"r\" (x) : \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #512\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl128\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?512\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #544\n+**\tstp\tx24, x25, \\[sp, 256\\]\n+**\tstr\tx26, \\[sp, 272\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl128\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 256\\]\n+**\tldr\tx26, \\[sp, 272\\]\n+**\tadd\tsp, sp, #?544\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_6:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tsub\tsp, sp, #256\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svbool_t\n+test_6 (void)\n+{\n+  take_stack_args (0, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_7:\n+**\tmov\tx12, #?4368\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 256\\]\n+**\tadd\tx29, sp, #?256\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_8:\n+**\tmov\tx12, #?4400\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 256\\]\n+**\tadd\tx29, sp, #?256\n+**\tstp\tx24, x25, \\[sp, 272\\]\n+**\tstr\tx26, \\[sp, 288\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_8 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_9:\n+**\tmov\tx12, #?4368\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 256\\]\n+**\tadd\tx29, sp, #?256\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tsub\tsp, x29, #256\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_9 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_10:\n+**\tmov\tx12, #?4400\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 256\\]\n+**\tadd\tx29, sp, #?256\n+**\tstp\tx24, x25, \\[sp, 272\\]\n+**\tstr\tx26, \\[sp, 288\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tsub\tsp, x29, #256\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_10 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_11:\n+**\tsub\tsp, sp, #65536\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tmov\tx12, #?64704\n+**\tsub\tsp, sp, x12\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tstp\tx29, x30, \\[sp, 256\\]\n+**\tadd\tx29, sp, #?256\n+**\tstp\tx24, x25, \\[sp, 272\\]\n+**\tstr\tx26, \\[sp, 288\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl256\n+**\tsub\tsp, x29, #256\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?256\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tadd\tsp, sp, #?3008\n+**\tadd\tsp, sp, #?126976\n+**\tret\n+*/\n+svbool_t\n+test_11 (int n)\n+{\n+  volatile int x[0x7ee4];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "f8318b354a0a8418c8d27e1e7fd2c82e63a8a792", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_2_256.c", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_256.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,284 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fshrink-wrap -fstack-clash-protection -msve-vector-bits=256 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svbool_t take_stack_args (volatile void *, void *, int, int, int,\n+\t\t\t  int, int, int, int);\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #48\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?48\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tsub\tsp, sp, #80\n+**\tstp\tx24, x25, \\[sp, 32\\]\n+**\tstr\tx26, \\[sp, 48\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 32\\]\n+**\tldr\tx26, \\[sp, 48\\]\n+**\tadd\tsp, sp, #?80\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tmov\tx12, #?4160\n+**\tsub\tsp, sp, x12\n+**\tstp\tx24, x25, \\[sp, 32\\]\n+**\tstr\tx26, \\[sp, 48\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 32\\]\n+**\tldr\tx26, \\[sp, 48\\]\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  volatile int x[1024];\n+  asm volatile (\"\" :: \"r\" (x) : \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #64\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #96\n+**\tstp\tx24, x25, \\[sp, 32\\]\n+**\tstr\tx26, \\[sp, 48\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl16\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 32\\]\n+**\tldr\tx26, \\[sp, 48\\]\n+**\tadd\tsp, sp, #?96\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_6:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tsub\tsp, sp, #32\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svbool_t\n+test_6 (void)\n+{\n+  take_stack_args (0, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_7:\n+**\tmov\tx12, #?4144\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 32\\]\n+**\tadd\tx29, sp, #?32\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_8:\n+**\tmov\tx12, #?4176\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 32\\]\n+**\tadd\tx29, sp, #?32\n+**\tstp\tx24, x25, \\[sp, 48\\]\n+**\tstr\tx26, \\[sp, 64\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_8 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_9:\n+**\tmov\tx12, #?4144\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 32\\]\n+**\tadd\tx29, sp, #?32\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tsub\tsp, x29, #32\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_9 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_10:\n+**\tmov\tx12, #?4176\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 32\\]\n+**\tadd\tx29, sp, #?32\n+**\tstp\tx24, x25, \\[sp, 48\\]\n+**\tstr\tx26, \\[sp, 64\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tsub\tsp, x29, #32\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_10 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_11:\n+**\tsub\tsp, sp, #65536\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tmov\tx12, #?64480\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 32\\]\n+**\tadd\tx29, sp, #?32\n+**\tstp\tx24, x25, \\[sp, 48\\]\n+**\tstr\tx26, \\[sp, 64\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl32\n+**\tsub\tsp, x29, #32\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?32\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tadd\tsp, sp, #?3008\n+**\tadd\tsp, sp, #?126976\n+**\tret\n+*/\n+svbool_t\n+test_11 (int n)\n+{\n+  volatile int x[0x7ee4];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "45a23ad4909a5aa08ecce8aea6c9405fe44d0c00", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_2_512.c", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_2_512.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,285 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fshrink-wrap -fstack-clash-protection -msve-vector-bits=512 -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svbool_t take_stack_args (volatile void *, void *, int, int, int,\n+\t\t\t  int, int, int, int);\n+\n+/*\n+** test_1:\n+**\tsub\tsp, sp, #80\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?80\n+**\tret\n+*/\n+svbool_t\n+test_1 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tsub\tsp, sp, #112\n+**\tstp\tx24, x25, \\[sp, 64\\]\n+**\tstr\tx26, \\[sp, 80\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 64\\]\n+**\tldr\tx26, \\[sp, 80\\]\n+**\tadd\tsp, sp, #?112\n+**\tret\n+*/\n+svbool_t\n+test_2 (void)\n+{\n+  volatile int x = 1;\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_3:\n+**\tmov\tx12, #?4192\n+**\tsub\tsp, sp, x12\n+**\tstp\tx24, x25, \\[sp, 64\\]\n+**\tstr\tx26, \\[sp, 80\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 64\\]\n+**\tldr\tx26, \\[sp, 80\\]\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_3 (void)\n+{\n+  volatile int x[1024];\n+  asm volatile (\"\" :: \"r\" (x) : \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_4:\n+**\tsub\tsp, sp, #128\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl32\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+svbool_t\n+test_4 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_5:\n+**\tsub\tsp, sp, #160\n+**\tstp\tx24, x25, \\[sp, 64\\]\n+**\tstr\tx26, \\[sp, 80\\]\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.h, vl32\n+**\tldr\tp4, \\[sp\\]\n+**\tldp\tx24, x25, \\[sp, 64\\]\n+**\tldr\tx26, \\[sp, 80\\]\n+**\tadd\tsp, sp, #?160\n+**\tret\n+*/\n+svbool_t\n+test_5 (void)\n+{\n+  volatile svint32_t b;\n+  b = svdup_s32 (1);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b16 ();\n+}\n+\n+/*\n+** test_6:\n+**\tstp\tx29, x30, \\[sp, -16\\]!\n+**\tmov\tx29, sp\n+**\tsub\tsp, sp, #64\n+**\tstr\tp4, \\[sp\\]\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tldp\tx29, x30, \\[sp\\], 16\n+**\tret\n+*/\n+svbool_t\n+test_6 (void)\n+{\n+  take_stack_args (0, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_7:\n+**\tmov\tx12, #?4176\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 64\\]\n+**\tadd\tx29, sp, #?64\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_7 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_8:\n+**\tmov\tx12, #?4208\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 64\\]\n+**\tadd\tx29, sp, #?64\n+**\tstp\tx24, x25, \\[sp, 80\\]\n+**\tstr\tx26, \\[sp, 96\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tadd\tsp, sp, #?16\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_8 (void)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, 0, 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_9:\n+**\tmov\tx12, #?4176\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 64\\]\n+**\tadd\tx29, sp, #?64\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tsub\tsp, x29, #64\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4112\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_9 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_10:\n+**\tmov\tx12, #?4208\n+**\tsub\tsp, sp, x12\n+**\tstp\tx29, x30, \\[sp, 64\\]\n+**\tadd\tx29, sp, #?64\n+**\tstp\tx24, x25, \\[sp, 80\\]\n+**\tstr\tx26, \\[sp, 96\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tsub\tsp, x29, #64\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tmov\tx12, #?4144\n+**\tadd\tsp, sp, x12\n+**\tret\n+*/\n+svbool_t\n+test_10 (int n)\n+{\n+  volatile int x[1024];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_11:\n+**\tsub\tsp, sp, #65536\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tmov\tx12, #?64512\n+**\tsub\tsp, sp, x12\n+**\tstr\txzr, \\[sp, 1024\\]\n+**\tstp\tx29, x30, \\[sp, 64\\]\n+**\tadd\tx29, sp, #?64\n+**\tstp\tx24, x25, \\[sp, 80\\]\n+**\tstr\tx26, \\[sp, 96\\]\n+**\tstr\tp4, \\[sp\\]\n+**\tsub\tsp, sp, #16\n+**\t...\n+**\tptrue\tp0\\.b, vl64\n+**\tsub\tsp, x29, #64\n+**\tldr\tp4, \\[sp\\]\n+**\tadd\tsp, sp, #?64\n+**\tldp\tx24, x25, \\[sp, 16\\]\n+**\tldr\tx26, \\[sp, 32\\]\n+**\tldp\tx29, x30, \\[sp\\]\n+**\tadd\tsp, sp, #?3008\n+**\tadd\tsp, sp, #?126976\n+**\tret\n+*/\n+svbool_t\n+test_11 (int n)\n+{\n+  volatile int x[0x7ee4];\n+  take_stack_args (x, __builtin_alloca (n), 1, 2, 3, 4, 5, 6, 7);\n+  asm volatile (\"\" ::: \"p4\", \"x24\", \"x25\", \"x26\");\n+  return svptrue_b8 ();\n+}"}, {"sha": "3e01ec36c3a417f7ab5b54c8ff73a92ca180adde", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_3.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstack_clash_3.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fshrink-wrap -fstack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+/*\n+** test_1:\n+**\tstr\tx24, \\[sp, -32\\]!\n+**\tcntb\tx13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x13\n+**\tstr\tp4, \\[sp\\]\n+**\tcbz\tw0, [^\\n]*\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldr\tx24, \\[sp\\], 32\n+**\tret\n+*/\n+svbool_t\n+test_1 (int n)\n+{\n+  asm volatile (\"\" ::: \"x24\");\n+  if (n)\n+    {\n+      volatile int x = 1;\n+      asm volatile (\"\" ::: \"p4\");\n+    }\n+  return svptrue_b8 ();\n+}\n+\n+/*\n+** test_2:\n+**\tstr\tx24, \\[sp, -32\\]!\n+**\tcntb\tx13\n+**\tmov\tx11, sp\n+**\t...\n+**\tsub\tsp, sp, x13\n+**\tstr\tp4, \\[sp\\]\n+**\tcbz\tw0, [^\\n]*\n+**\tstr\tp5, \\[sp, #1, mul vl\\]\n+**\tstr\tp6, \\[sp, #2, mul vl\\]\n+**\t...\n+**\tptrue\tp0\\.b, all\n+**\tldr\tp4, \\[sp\\]\n+**\taddvl\tsp, sp, #1\n+**\tldr\tx24, \\[sp\\], 32\n+**\tret\n+*/\n+svbool_t\n+test_2 (int n)\n+{\n+  asm volatile (\"\" ::: \"x24\");\n+  if (n)\n+    {\n+      volatile int x = 1;\n+      asm volatile (\"\" ::: \"p4\", \"p5\", \"p6\");\n+    }\n+  return svptrue_b8 ();\n+}"}, {"sha": "5c7ed516704d5683aaa499e2dd55b79ad067ee5b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/unprototyped_1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Funprototyped_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Funprototyped_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Funprototyped_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void unprototyped ();\n+\n+void\n+f (svuint8_t *ptr)\n+{\n+  unprototyped (*ptr); /* { dg-error {SVE type '(svuint8_t|__SVUint8_t)' cannot be passed to an unprototyped function} } */\n+}"}, {"sha": "305a35f09dc8123c9172aa227c012fc29a94cc2d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_1.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tldr\t(p[0-7]), \\[x1\\]\n+**\t...\n+**\tcntp\tx0, \\1, \\1\\.b\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+callee_0 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svbool_t pg;\n+\n+  va_start (va, ptr);\n+  pg = va_arg (va, svbool_t);\n+  va_end (va);\n+  return svcntp_b8 (pg, pg);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tptrue\t(p[0-7])\\.d, vl7\n+**\t...\n+**\tstr\t\\1, \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_0 (int64_t *ptr)\n+{\n+  return callee_0 (ptr, svptrue_pat_b64 (SV_VL7));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tldr\t(p[0-7]), \\[x2\\]\n+**\t...\n+**\tcntp\tx0, \\1, \\1\\.b\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+callee_1 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svbool_t pg;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  pg = va_arg (va, svbool_t);\n+  va_end (va);\n+  return svcntp_b8 (pg, pg);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tptrue\t(p[0-7])\\.d, vl7\n+**\t...\n+**\tstr\t\\1, \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_1 (int64_t *ptr)\n+{\n+  return callee_1 (ptr, 1, svptrue_pat_b64 (SV_VL7));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tldr\t(p[0-7]), \\[x7\\]\n+**\t...\n+**\tcntp\tx0, \\1, \\1\\.b\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+callee_7 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svbool_t pg;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  pg = va_arg (va, svbool_t);\n+  va_end (va);\n+  return svcntp_b8 (pg, pg);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tptrue\t(p[0-7])\\.d, vl7\n+**\t...\n+**\tstr\t\\1, \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_7 (int64_t *ptr)\n+{\n+  return callee_7 (ptr, 1, 2, 3, 4, 5, 6, svptrue_pat_b64 (SV_VL7));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tldr\t(p[0-7]), \\[\\2\\]\n+**\t...\n+**\tcntp\tx0, \\3, \\3\\.b\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+callee_8 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svbool_t pg;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  pg = va_arg (va, svbool_t);\n+  va_end (va);\n+  return svcntp_b8 (pg, pg);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tptrue\t(p[0-7])\\.d, vl7\n+**\t...\n+**\tstr\t\\1, \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+uint64_t __attribute__((noipa))\n+caller_8 (int64_t *ptr)\n+{\n+  return callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svptrue_pat_b64 (SV_VL7));\n+}"}, {"sha": "3d7d6b64bfb9c2537cd833d72b34b49f438eab38", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_f16.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1h\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.h), #9\\.0[^\\n]*\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int16_t *ptr)\n+{\n+  callee_0 (ptr, svdup_f16 (9));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.h), #9\\.0[^\\n]*\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int16_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_f16 (9));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.h), #9\\.0[^\\n]*\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int16_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_f16 (9));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1h\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.h), #9\\.0[^\\n]*\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int16_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_f16 (9));\n+}"}, {"sha": "769b76460c2b2e3fafb6d85b2c96d156b457f119", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_f32.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1w\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.s), #9\\.0[^\\n]*\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int32_t *ptr)\n+{\n+  callee_0 (ptr, svdup_f32 (9));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.s), #9\\.0[^\\n]*\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int32_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_f32 (9));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.s), #9\\.0[^\\n]*\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int32_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_f32 (9));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1w\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.s), #9\\.0[^\\n]*\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int32_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_f32 (9));\n+}"}, {"sha": "8067eee88824b7b387111265399ccd3f55d1b136", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_f64.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_f64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1d\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.d), #9\\.0[^\\n]*\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int64_t *ptr)\n+{\n+  callee_0 (ptr, svdup_f64 (9));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.d), #9\\.0[^\\n]*\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int64_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_f64 (9));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.d), #9\\.0[^\\n]*\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int64_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_f64 (9));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1d\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tfmov\t(z[0-9]+\\.d), #9\\.0[^\\n]*\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int64_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_f64 (9));\n+}"}, {"sha": "d69551839a39f8d2180198bb22e4779c1fb22d6d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_s16.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1h\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int16_t *ptr)\n+{\n+  callee_0 (ptr, svdup_s16 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int16_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_s16 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int16_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_s16 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1h\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int16_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_s16 (42));\n+}"}, {"sha": "fddc0b87979dfbcb8aa1405e874b177a51240fb5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_s32.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1w\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int32_t *ptr)\n+{\n+  callee_0 (ptr, svdup_s32 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int32_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_s32 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int32_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_s32 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1w\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int32_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_s32 (42));\n+}"}, {"sha": "e6c4447bcb5609ed0f5d98ffe647d02da6a3fe3a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_s64.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1d\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int64_t *ptr)\n+{\n+  callee_0 (ptr, svdup_s64 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int64_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_s64 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int64_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_s64 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1d\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int64_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_s64 (42));\n+}"}, {"sha": "3f1d5f1e8eb38fa9d1499469da94aab8db8c9b70", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_s8.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_s8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1b\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int8_t *ptr)\n+{\n+  callee_0 (ptr, svdup_s8 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int8_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_s8 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int8_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_s8 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1b\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int8_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_s8 (42));\n+}"}, {"sha": "658aadcd0127ff91a51ca4b5328fb961302fc802", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_u16.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u16.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1h\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int16_t *ptr)\n+{\n+  callee_0 (ptr, svdup_u16 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int16_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_u16 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int16_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_u16 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1h\t(z[0-9]+\\.h), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1h\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int16_t *ptr, ...)\n+{\n+  va_list va;\n+  svint16_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint16_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.h), #42\n+**\t...\n+**\tst1h\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int16_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_u16 (42));\n+}"}, {"sha": "2ab320a3ac3342531014b7dad0d36e465ba69f2d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_u32.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u32.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1w\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int32_t *ptr)\n+{\n+  callee_0 (ptr, svdup_u32 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int32_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_u32 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int32_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_u32 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1w\t(z[0-9]+\\.s), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1w\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int32_t *ptr, ...)\n+{\n+  va_list va;\n+  svint32_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint32_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.s), #42\n+**\t...\n+**\tst1w\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int32_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_u32 (42));\n+}"}, {"sha": "1326af5f9aa73cafd260e171b683aa1517d8c193", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_u64.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u64.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1d\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int64_t *ptr)\n+{\n+  callee_0 (ptr, svdup_u64 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int64_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_u64 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int64_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_u64 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1d\t(z[0-9]+\\.d), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1d\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int64_t *ptr, ...)\n+{\n+  va_list va;\n+  svint64_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint64_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.d), #42\n+**\t...\n+**\tst1d\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int64_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_u64 (42));\n+}"}, {"sha": "a2b812dfc4c607d0e89932c341f447b61bae6822", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_2_u8.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_2_u8.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-stack-clash-protection -g\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+/*\n+** callee_0:\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[x1\\]\n+**\t...\n+**\tst1b\t\\1, \\2, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_0 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_0:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x1\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_0 (int8_t *ptr)\n+{\n+  callee_0 (ptr, svdup_u8 (42));\n+}\n+\n+/*\n+** callee_1:\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[x2\\]\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_1 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_1:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x2\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_1 (int8_t *ptr)\n+{\n+  callee_1 (ptr, 1, svdup_u8 (42));\n+}\n+\n+/*\n+** callee_7:\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[x7\\]\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_7 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_7:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[x7\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_7 (int8_t *ptr)\n+{\n+  callee_7 (ptr, 1, 2, 3, 4, 5, 6, svdup_u8 (42));\n+}\n+\n+/* FIXME: We should be able to get rid of the va_list object.  */\n+/*\n+** callee_8:\n+**\tsub\tsp, sp, #([0-9]+)\n+**\t...\n+**\tldr\t(x[0-9]+), \\[sp, \\1\\]\n+**\t...\n+**\tld1b\t(z[0-9]+\\.b), (p[0-7])/z, \\[\\2\\]\n+**\t...\n+**\tst1b\t\\3, \\4, \\[x0\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+callee_8 (int8_t *ptr, ...)\n+{\n+  va_list va;\n+  svint8_t vec;\n+\n+  va_start (va, ptr);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  va_arg (va, int);\n+  vec = va_arg (va, svint8_t);\n+  va_end (va);\n+  svst1 (svptrue_b8 (), ptr, vec);\n+}\n+\n+/*\n+** caller_8:\n+**\t...\n+**\tmov\t(z[0-9]+\\.b), #42\n+**\t...\n+**\tst1b\t\\1, p[0-7], \\[(x[0-9]+)\\]\n+**\t...\n+**\tstr\t\\2, \\[sp\\]\n+**\t...\n+**\tret\n+*/\n+void __attribute__((noipa))\n+caller_8 (int8_t *ptr)\n+{\n+  callee_8 (ptr, 1, 2, 3, 4, 5, 6, 7, svdup_u8 (42));\n+}"}, {"sha": "cea69cc880b68820dc450d6dbb21b47eb710fa98", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_3_nosc.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_3_nosc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_3_nosc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_3_nosc.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O0 -g\" } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+void __attribute__((noipa))\n+callee (int foo, ...)\n+{\n+  va_list va;\n+  svbool_t pg, p;\n+  svint8_t s8;\n+  svuint16x4_t u16;\n+  svfloat32x3_t f32;\n+  svint64x2_t s64;\n+\n+  va_start (va, foo);\n+  p = va_arg (va, svbool_t);\n+  s8 = va_arg (va, svint8_t);\n+  u16 = va_arg (va, svuint16x4_t);\n+  f32 = va_arg (va, svfloat32x3_t);\n+  s64 = va_arg (va, svint64x2_t);\n+\n+  pg = svptrue_b8 ();\n+\n+  if (svptest_any (pg, sveor_z (pg, p, svptrue_pat_b8 (SV_VL7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, s8, svindex_s8 (1, 2))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 0), svindex_u16 (2, 3))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 1), svindex_u16 (3, 4))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 2), svindex_u16 (4, 5))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 3), svindex_u16 (5, 6))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 0), svdup_f32 (1.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 1), svdup_f32 (2.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 2), svdup_f32 (3.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 0), svindex_s64 (6, 7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 1), svindex_s64 (7, 8))))\n+    __builtin_abort ();\n+}\n+\n+int __attribute__((noipa))\n+main (void)\n+{\n+  callee (100,\n+\t  svptrue_pat_b8 (SV_VL7),\n+\t  svindex_s8 (1, 2),\n+\t  svcreate4 (svindex_u16 (2, 3),\n+\t\t     svindex_u16 (3, 4),\n+\t\t     svindex_u16 (4, 5),\n+\t\t     svindex_u16 (5, 6)),\n+\t  svcreate3 (svdup_f32 (1.0),\n+\t\t     svdup_f32 (2.0),\n+\t\t     svdup_f32 (3.0)),\n+\t  svcreate2 (svindex_s64 (6, 7),\n+\t\t     svindex_s64 (7, 8)));\n+}"}, {"sha": "b939aa5ea1b8098c49ae433c15e567aa26e8339b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/varargs_3_sc.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_3_sc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_3_sc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvarargs_3_sc.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O0 -fstack-clash-protection -g\" } */\n+\n+#include <arm_sve.h>\n+#include <stdarg.h>\n+\n+void __attribute__((noipa))\n+callee (int foo, ...)\n+{\n+  va_list va;\n+  svbool_t pg, p;\n+  svint8_t s8;\n+  svuint16x4_t u16;\n+  svfloat32x3_t f32;\n+  svint64x2_t s64;\n+\n+  va_start (va, foo);\n+  p = va_arg (va, svbool_t);\n+  s8 = va_arg (va, svint8_t);\n+  u16 = va_arg (va, svuint16x4_t);\n+  f32 = va_arg (va, svfloat32x3_t);\n+  s64 = va_arg (va, svint64x2_t);\n+\n+  pg = svptrue_b8 ();\n+\n+  if (svptest_any (pg, sveor_z (pg, p, svptrue_pat_b8 (SV_VL7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, s8, svindex_s8 (1, 2))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 0), svindex_u16 (2, 3))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 1), svindex_u16 (3, 4))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 2), svindex_u16 (4, 5))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget4 (u16, 3), svindex_u16 (5, 6))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 0), svdup_f32 (1.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 1), svdup_f32 (2.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget3 (f32, 2), svdup_f32 (3.0))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 0), svindex_s64 (6, 7))))\n+    __builtin_abort ();\n+\n+  if (svptest_any (pg, svcmpne (pg, svget2 (s64, 1), svindex_s64 (7, 8))))\n+    __builtin_abort ();\n+}\n+\n+int __attribute__((noipa))\n+main (void)\n+{\n+  callee (100,\n+\t  svptrue_pat_b8 (SV_VL7),\n+\t  svindex_s8 (1, 2),\n+\t  svcreate4 (svindex_u16 (2, 3),\n+\t\t     svindex_u16 (3, 4),\n+\t\t     svindex_u16 (4, 5),\n+\t\t     svindex_u16 (5, 6)),\n+\t  svcreate3 (svdup_f32 (1.0),\n+\t\t     svdup_f32 (2.0),\n+\t\t     svdup_f32 (3.0)),\n+\t  svcreate2 (svindex_s64 (6, 7),\n+\t\t     svindex_s64 (7, 8)));\n+}"}, {"sha": "d9f4e6c4113769ff68e99defc80f1438b581009c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/vpcs_1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvpcs_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600df9a4060da3c6121ff4d0b93f179eafd69d1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvpcs_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fvpcs_1.c?ref=c600df9a4060da3c6121ff4d0b93f179eafd69d1", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+\n+__attribute__ ((aarch64_vector_pcs)) void f1 (__SVBool_t); /* { dg-error {the 'aarch64_vector_pcs' attribute cannot be applied to an SVE function type} } */\n+__attribute__ ((aarch64_vector_pcs)) void f2 (__SVInt8_t s8) {} /* { dg-error {the 'aarch64_vector_pcs' attribute cannot be applied to an SVE function type} } */\n+__attribute__ ((aarch64_vector_pcs)) void (*f3) (__SVInt16_t); /* { dg-error {the 'aarch64_vector_pcs' attribute cannot be applied to an SVE function type} } */\n+typedef __attribute__ ((aarch64_vector_pcs)) void (*f4) (__SVInt32_t); /* { dg-error {the 'aarch64_vector_pcs' attribute cannot be applied to an SVE function type} } */"}]}