{"sha": "a015ef67374d81c9468dfa5ca031ef0f8b394314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxNWVmNjczNzRkODFjOTQ2OGRmYTVjYTAzMWVmMGY4YjM5NDMxNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T12:13:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T12:13:11Z"}, "message": "[multiple changes]\n\n2015-10-20  Tristan Gingold  <gingold@adacore.com>\n\n\t* sem_util.adb (Is_Protected_Self_Reference): Remove reference to\n\tUET_Address in comment.\n\t* sem_attr.adb (Check_Unit_Name): Adjust comment.\n\t(Analyze_Attribute): Remove handling of UET_Address.\n\t* sem_attr.ads (Attribute_Impl_Def): Remove Attribute_UET_Address.\n\t* snames.ads-tmpl Remove Name_UET_Address, Attribute_UET_Address.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Remove\n\tAttribute_UET_Address.\n\n2015-10-20  Bob Duff  <duff@adacore.com>\n\n\t* a-cbdlli.adb, a-cdlili.adb, a-chtgop.adb, a-cidlli.adb,\n\t* a-cobove.adb, a-coinve.adb, a-convec.adb, a-crbtgo.adb (\"=\"): Avoid\n\tmodifying the tampering counts unnecessarily.\n\t(Adjust): Zero tampering counts unconditionally.\n\n2015-10-20  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* init.c: Fix build issue on arm-vx6 when building the RTP\n\trun-time.\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): If the expression\n\tis an aggregate and compilation is in -gnatI mode (ignore rep\n\tclauses) do not delay resolution of aggregate, to prevent freeze\n\tactions out of order in the backend.\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.ads, sem_prag.adb (Build_Generic_Class_Condition):\n\tNew procedure to construct a generic function for a class-wide\n\tprecondition, to implement AI12-0113  concerning the new semantics\n\tof class-wide preconditions for overriding uperations.\n\nFrom-SVN: r229060", "tree": {"sha": "bc993cacd1970a808c9c3609d9348661e2e735c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc993cacd1970a808c9c3609d9348661e2e735c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a015ef67374d81c9468dfa5ca031ef0f8b394314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a015ef67374d81c9468dfa5ca031ef0f8b394314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a015ef67374d81c9468dfa5ca031ef0f8b394314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a015ef67374d81c9468dfa5ca031ef0f8b394314/comments", "author": null, "committer": null, "parents": [{"sha": "c386239f4dc9ba15abed10f87d5e775ca509a1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c386239f4dc9ba15abed10f87d5e775ca509a1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c386239f4dc9ba15abed10f87d5e775ca509a1bb"}], "stats": {"total": 758, "additions": 512, "deletions": 246}, "files": [{"sha": "5584a44eeef01d5139ba6bd1500baa0a49c68a89", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -1,3 +1,40 @@\n+2015-10-20  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* sem_util.adb (Is_Protected_Self_Reference): Remove reference to\n+\tUET_Address in comment.\n+\t* sem_attr.adb (Check_Unit_Name): Adjust comment.\n+\t(Analyze_Attribute): Remove handling of UET_Address.\n+\t* sem_attr.ads (Attribute_Impl_Def): Remove Attribute_UET_Address.\n+\t* snames.ads-tmpl Remove Name_UET_Address, Attribute_UET_Address.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Remove\n+\tAttribute_UET_Address.\n+\n+2015-10-20  Bob Duff  <duff@adacore.com>\n+\n+\t* a-cbdlli.adb, a-cdlili.adb, a-chtgop.adb, a-cidlli.adb,\n+\t* a-cobove.adb, a-coinve.adb, a-convec.adb, a-crbtgo.adb (\"=\"): Avoid\n+\tmodifying the tampering counts unnecessarily.\n+\t(Adjust): Zero tampering counts unconditionally.\n+\n+2015-10-20  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* init.c: Fix build issue on arm-vx6 when building the RTP\n+\trun-time.\n+\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): If the expression\n+\tis an aggregate and compilation is in -gnatI mode (ignore rep\n+\tclauses) do not delay resolution of aggregate, to prevent freeze\n+\tactions out of order in the backend.\n+\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.ads, sem_prag.adb (Build_Generic_Class_Condition):\n+\tNew procedure to construct a generic function for a class-wide\n+\tprecondition, to implement AI12-0113  concerning the new semantics\n+\tof class-wide preconditions for overriding uperations.\n+\n 2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_util.adb (Find_Actual): The routine is"}, {"sha": "14aad946d491df49452d1c8b082a1558511da8c1", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -84,32 +84,37 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n-\n-      LN : Node_Array renames Left.Nodes;\n-      RN : Node_Array renames Right.Nodes;\n-\n-      LI : Count_Type;\n-      RI : Count_Type;\n    begin\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n \n-      LI := Left.First;\n-      RI := Right.First;\n-      for J in 1 .. Left.Length loop\n-         if LN (LI).Element /= RN (RI).Element then\n-            return False;\n-         end if;\n+      if Left.Length = 0 then\n+         return True;\n+      end if;\n \n-         LI := LN (LI).Next;\n-         RI := RN (RI).Next;\n-      end loop;\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+\n+         LN : Node_Array renames Left.Nodes;\n+         RN : Node_Array renames Right.Nodes;\n+\n+         LI : Count_Type := Left.First;\n+         RI : Count_Type := Right.First;\n+      begin\n+         for J in 1 .. Left.Length loop\n+            if LN (LI).Element /= RN (RI).Element then\n+               return False;\n+            end if;\n+\n+            LI := LN (LI).Next;\n+            RI := RN (RI).Next;\n+         end loop;\n+      end;\n \n       return True;\n    end \"=\";"}, {"sha": "036f0aba1692585565f316c595b832fa9ef6cefe", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -73,30 +73,34 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n-\n-      L      : Node_Access;\n-      R      : Node_Access;\n-\n    begin\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n \n-      L := Left.First;\n-      R := Right.First;\n-      for J in 1 .. Left.Length loop\n-         if L.Element /= R.Element then\n-            return False;\n-         end if;\n+      if Left.Length = 0 then\n+         return True;\n+      end if;\n \n-         L := L.Next;\n-         R := R.Next;\n-      end loop;\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+\n+         L : Node_Access := Left.First;\n+         R : Node_Access := Right.First;\n+      begin\n+         for J in 1 .. Left.Length loop\n+            if L.Element /= R.Element then\n+               return False;\n+            end if;\n+\n+            L := L.Next;\n+            R := R.Next;\n+         end loop;\n+      end;\n \n       return True;\n    end \"=\";\n@@ -109,10 +113,15 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Src : Node_Access := Container.First;\n \n    begin\n+      --  If the counts are nonzero, execution is technically erroneous, but\n+      --  it seems friendly to allow things like concurrent \"=\" on shared\n+      --  constants.\n+\n+      Zero_Counts (Container.TC);\n+\n       if Src = null then\n          pragma Assert (Container.Last = null);\n          pragma Assert (Container.Length = 0);\n-         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n "}, {"sha": "0d7f88fa3fb5c9c1fb525443af6fb2cd387c0569", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -357,22 +357,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    function Generic_Equal\n      (L, R : Hash_Table_Type) return Boolean\n    is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_L : With_Lock (L.TC'Unrestricted_Access);\n-      Lock_R : With_Lock (R.TC'Unrestricted_Access);\n-\n-      L_Index : Hash_Type;\n-      L_Node  : Node_Access;\n-\n-      N : Count_Type;\n-\n    begin\n-      if L'Address = R'Address then\n-         return True;\n-      end if;\n-\n       if L.Length /= R.Length then\n          return False;\n       end if;\n@@ -381,44 +366,57 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return True;\n       end if;\n \n-      --  Find the first node of hash table L\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-      L_Index := 0;\n-      loop\n-         L_Node := L.Buckets (L_Index);\n-         exit when L_Node /= null;\n-         L_Index := L_Index + 1;\n-      end loop;\n+         Lock_L : With_Lock (L.TC'Unrestricted_Access);\n+         Lock_R : With_Lock (R.TC'Unrestricted_Access);\n \n-      --  For each node of hash table L, search for an equivalent node in hash\n-      --  table R.\n+         L_Index : Hash_Type;\n+         L_Node  : Node_Access;\n \n-      N := L.Length;\n-      loop\n-         if not Find (HT => R, Key => L_Node) then\n-            return False;\n-         end if;\n-\n-         N := N - 1;\n+         N : Count_Type;\n+      begin\n+         --  Find the first node of hash table L\n \n-         L_Node := Next (L_Node);\n+         L_Index := 0;\n+         loop\n+            L_Node := L.Buckets (L_Index);\n+            exit when L_Node /= null;\n+            L_Index := L_Index + 1;\n+         end loop;\n \n-         if L_Node = null then\n-            --  We have exhausted the nodes in this bucket\n+         --  For each node of hash table L, search for an equivalent node in\n+         --  hash table R.\n \n-            if N = 0 then\n-               return True;\n+         N := L.Length;\n+         loop\n+            if not Find (HT => R, Key => L_Node) then\n+               return False;\n             end if;\n \n-            --  Find the next bucket\n+            N := N - 1;\n \n-            loop\n-               L_Index := L_Index + 1;\n-               L_Node := L.Buckets (L_Index);\n-               exit when L_Node /= null;\n-            end loop;\n-         end if;\n-      end loop;\n+            L_Node := Next (L_Node);\n+\n+            if L_Node = null then\n+               --  We have exhausted the nodes in this bucket\n+\n+               if N = 0 then\n+                  return True;\n+               end if;\n+\n+               --  Find the next bucket\n+\n+               loop\n+                  L_Index := L_Index + 1;\n+                  L_Node := L.Buckets (L_Index);\n+                  exit when L_Node /= null;\n+               end loop;\n+            end if;\n+         end loop;\n+      end;\n    end Generic_Equal;\n \n    -----------------------"}, {"sha": "7cb4c87f611c444b47036e27e2d3f058dbb2107a", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -76,30 +76,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n-\n-      L      : Node_Access;\n-      R      : Node_Access;\n-\n    begin\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n \n-      L := Left.First;\n-      R := Right.First;\n-      for J in 1 .. Left.Length loop\n-         if L.Element.all /= R.Element.all then\n-            return False;\n-         end if;\n+      if Left.Length = 0 then\n+         return True;\n+      end if;\n \n-         L := L.Next;\n-         R := R.Next;\n-      end loop;\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+\n+         L : Node_Access := Left.First;\n+         R : Node_Access := Right.First;\n+      begin\n+         for J in 1 .. Left.Length loop\n+            if L.Element.all /= R.Element.all then\n+               return False;\n+            end if;\n+\n+            L := L.Next;\n+            R := R.Next;\n+         end loop;\n+      end;\n \n       return True;\n    end \"=\";\n@@ -113,10 +117,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Dst : Node_Access;\n \n    begin\n+      --  If the counts are nonzero, execution is technically erroneous, but\n+      --  it seems friendly to allow things like concurrent \"=\" on shared\n+      --  constants.\n+\n+      Zero_Counts (Container.TC);\n+\n       if Src = null then\n          pragma Assert (Container.Last = null);\n          pragma Assert (Container.Length = 0);\n-         pragma Assert (Container.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n@@ -127,7 +136,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Container.First := null;\n       Container.Last := null;\n       Container.Length := 0;\n-      Zero_Counts (Container.TC);\n \n       declare\n          Element : Element_Access := new Element_Type'(Src.Element.all);"}, {"sha": "fca300d41d6bb0d278c9c38747b9e06700135cb3", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -269,21 +269,28 @@ package body Ada.Containers.Bounded_Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n    begin\n       if Left.Last /= Right.Last then\n          return False;\n       end if;\n \n-      for J in Count_Type range 1 .. Left.Length loop\n-         if Left.Elements (J) /= Right.Elements (J) then\n-            return False;\n-         end if;\n-      end loop;\n+      if Left.Length = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+      begin\n+         for J in Count_Type range 1 .. Left.Length loop\n+            if Left.Elements (J) /= Right.Elements (J) then\n+               return False;\n+            end if;\n+         end loop;\n+      end;\n \n       return True;\n    end \"=\";"}, {"sha": "0053de0f4428dc9b689e4e92345776e9344340c8", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -103,29 +103,36 @@ package body Ada.Containers.Indefinite_Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n    begin\n       if Left.Last /= Right.Last then\n          return False;\n       end if;\n \n-      for J in Index_Type range Index_Type'First .. Left.Last loop\n-         if Left.Elements.EA (J) = null then\n-            if Right.Elements.EA (J) /= null then\n-               return False;\n-            end if;\n+      if Left.Length = 0 then\n+         return True;\n+      end if;\n \n-         elsif Right.Elements.EA (J) = null then\n-            return False;\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-         elsif Left.Elements.EA (J).all /= Right.Elements.EA (J).all then\n-            return False;\n-         end if;\n-      end loop;\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+      begin\n+         for J in Index_Type range Index_Type'First .. Left.Last loop\n+            if Left.Elements.EA (J) = null then\n+               if Right.Elements.EA (J) /= null then\n+                  return False;\n+               end if;\n+\n+            elsif Right.Elements.EA (J) = null then\n+               return False;\n+\n+            elsif Left.Elements.EA (J).all /= Right.Elements.EA (J).all then\n+               return False;\n+            end if;\n+         end loop;\n+      end;\n \n       return True;\n    end \"=\";\n@@ -136,6 +143,12 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    procedure Adjust (Container : in out Vector) is\n    begin\n+      --  If the counts are nonzero, execution is technically erroneous, but\n+      --  it seems friendly to allow things like concurrent \"=\" on shared\n+      --  constants.\n+\n+      Zero_Counts (Container.TC);\n+\n       if Container.Last = No_Index then\n          Container.Elements := null;\n          return;\n@@ -149,7 +162,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       begin\n          Container.Elements := null;\n          Container.Last := No_Index;\n-         Zero_Counts (Container.TC);\n \n          Container.Elements := new Elements_Type (L);\n "}, {"sha": "ff11fa952723d9ecc76a452ba3720b0e4fc0e378", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -100,21 +100,28 @@ package body Ada.Containers.Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n    begin\n       if Left.Last /= Right.Last then\n          return False;\n       end if;\n \n-      for J in Index_Type range Index_Type'First .. Left.Last loop\n-         if Left.Elements.EA (J) /= Right.Elements.EA (J) then\n-            return False;\n-         end if;\n-      end loop;\n+      if Left.Length = 0 then\n+         return True;\n+      end if;\n+\n+      declare\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+      begin\n+         for J in Index_Type range Index_Type'First .. Left.Last loop\n+            if Left.Elements.EA (J) /= Right.Elements.EA (J) then\n+               return False;\n+            end if;\n+         end loop;\n+      end;\n \n       return True;\n    end \"=\";\n@@ -125,6 +132,12 @@ package body Ada.Containers.Vectors is\n \n    procedure Adjust (Container : in out Vector) is\n    begin\n+      --  If the counts are nonzero, execution is technically erroneous, but\n+      --  it seems friendly to allow things like concurrent \"=\" on shared\n+      --  constants.\n+\n+      Zero_Counts (Container.TC);\n+\n       if Container.Last = No_Index then\n          Container.Elements := null;\n          return;\n@@ -137,7 +150,6 @@ package body Ada.Containers.Vectors is\n \n       begin\n          Container.Elements := null;\n-         Zero_Counts (Container.TC);\n \n          --  Note: it may seem that the following assignment to Container.Last\n          --  is useless, since we assign it to L below. However this code is"}, {"sha": "bfc0bcf3a42909bf154e583e4403e8a568e96865", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -514,9 +514,14 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n       Root : constant Node_Access := Tree.Root;\n       use type Helpers.Tamper_Counts;\n    begin\n+      --  If the counts are nonzero, execution is technically erroneous, but\n+      --  it seems friendly to allow things like concurrent \"=\" on shared\n+      --  constants.\n+\n+      Zero_Counts (Tree.TC);\n+\n       if N = 0 then\n          pragma Assert (Root = null);\n-         pragma Assert (Tree.TC = (Busy => 0, Lock => 0));\n          return;\n       end if;\n \n@@ -623,16 +628,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n    -------------------\n \n    function Generic_Equal (Left, Right : Tree_Type) return Boolean is\n-      Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n-      Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n-\n-      L_Node : Node_Access;\n-      R_Node : Node_Access;\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       if Left.Length /= Right.Length then\n          return False;\n       end if;\n@@ -644,16 +640,22 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n          return True;\n       end if;\n \n-      L_Node := Left.First;\n-      R_Node := Right.First;\n-      while L_Node /= null loop\n-         if not Is_Equal (L_Node, R_Node) then\n-            return False;\n-         end if;\n+      declare\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n \n-         L_Node := Next (L_Node);\n-         R_Node := Next (R_Node);\n-      end loop;\n+         L_Node : Node_Access := Left.First;\n+         R_Node : Node_Access := Right.First;\n+      begin\n+         while L_Node /= null loop\n+            if not Is_Equal (L_Node, R_Node) then\n+               return False;\n+            end if;\n+\n+            L_Node := Next (L_Node);\n+            R_Node := Next (R_Node);\n+         end loop;\n+      end;\n \n       return True;\n    end Generic_Equal;"}, {"sha": "781f3a9248796ecbdbfde11b8493da9cc03ad009", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -6152,49 +6152,6 @@ package body Exp_Attr is\n             Expand_Fpt_Attribute_R (N);\n          end if;\n \n-      -----------------\n-      -- UET_Address --\n-      -----------------\n-\n-      when Attribute_UET_Address => UET_Address : declare\n-         Ent : constant Entity_Id := Make_Temporary (Loc, 'T');\n-\n-      begin\n-         Insert_Action (N,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Ent,\n-             Aliased_Present     => True,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Address), Loc)));\n-\n-         --  Construct name __gnat_xxx__SDP, where xxx is the unit name\n-         --  in normal external form.\n-\n-         Get_External_Unit_Name_String (Get_Unit_Name (Pref));\n-         Name_Buffer (1 + 7 .. Name_Len + 7) := Name_Buffer (1 .. Name_Len);\n-         Name_Len := Name_Len + 7;\n-         Name_Buffer (1 .. 7) := \"__gnat_\";\n-         Name_Buffer (Name_Len + 1 .. Name_Len + 5) := \"__SDP\";\n-         Name_Len := Name_Len + 5;\n-\n-         Set_Is_Imported (Ent);\n-         Set_Interface_Name (Ent,\n-           Make_String_Literal (Loc,\n-             Strval => String_From_Name_Buffer));\n-\n-         --  Set entity as internal to ensure proper Sprint output of its\n-         --  implicit importation.\n-\n-         Set_Is_Internal (Ent);\n-\n-         Rewrite (N,\n-           Make_Attribute_Reference (Loc,\n-             Prefix => New_Occurrence_Of (Ent, Loc),\n-             Attribute_Name => Name_Address));\n-\n-         Analyze_And_Resolve (N, Typ);\n-      end UET_Address;\n-\n       ------------\n       -- Update --\n       ------------"}, {"sha": "443b33893791aefce5a5c26e65b284ba681e96f9", "filename": "gcc/ada/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -1715,7 +1715,7 @@ __gnat_install_handler (void)\n #include <iv.h>\n #endif\n \n-#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6)\n+#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) && !defined(__RTP__)\n #include <vmLib.h>\n #endif\n \n@@ -1862,7 +1862,7 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n      page if there's a match.  Additionally we're are assured this is a\n      genuine stack overflow condition and and set the message and exception\n      to that effect.  */\n-#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6)\n+#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) && !defined(__RTP__)\n \n   /* We re-arm the guard page by marking it invalid */\n \n@@ -1896,7 +1896,7 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n \t  }\n        }\n     }\n-#endif /* defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) */\n+#endif /* defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) && !defined(__RTP__) */\n \n   __gnat_clear_exception_count ();\n   Raise_From_Signal_Handler (exception, msg);"}, {"sha": "4d6bf7c5a18f8a8e1461c2cf67b82a4f8f0dd673", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -388,8 +388,8 @@ package body Sem_Attr is\n       --  itself of the form of a library unit name. Note that this is\n       --  quite different from Check_Program_Unit, since it only checks\n       --  the syntactic form of the name, not the semantic identity. This\n-      --  is because it is used with attributes (Elab_Body, Elab_Spec,\n-      --  UET_Address and Elaborated) which can refer to non-visible unit.\n+      --  is because it is used with attributes (Elab_Body, Elab_Spec and\n+      --  Elaborated) which can refer to non-visible unit.\n \n       procedure Error_Attr (Msg : String; Error_Node : Node_Id);\n       pragma No_Return (Error_Attr);\n@@ -2675,7 +2675,6 @@ package body Sem_Attr is\n       if Aname /= Name_Elab_Body       and then\n          Aname /= Name_Elab_Spec       and then\n          Aname /= Name_Elab_Subp_Body  and then\n-         Aname /= Name_UET_Address     and then\n          Aname /= Name_Enabled         and then\n          Aname /= Name_Old\n       then\n@@ -6026,15 +6025,6 @@ package body Sem_Attr is\n \n          Analyze_And_Resolve (N, Standard_String);\n \n-      -----------------\n-      -- UET_Address --\n-      -----------------\n-\n-      when Attribute_UET_Address =>\n-         Check_E0;\n-         Check_Unit_Name (P);\n-         Set_Etype (N, RTE (RE_Address));\n-\n       -----------------------\n       -- Unbiased_Rounding --\n       -----------------------\n@@ -9710,7 +9700,6 @@ package body Sem_Attr is\n            Attribute_Terminated                   |\n            Attribute_To_Address                   |\n            Attribute_Type_Key                     |\n-           Attribute_UET_Address                  |\n            Attribute_Unchecked_Access             |\n            Attribute_Universal_Literal_String     |\n            Attribute_Unrestricted_Access          |\n@@ -11060,16 +11049,6 @@ package body Sem_Attr is\n          when Attribute_Result =>\n             null;\n \n-         -----------------\n-         -- UET_Address --\n-         -----------------\n-\n-         --  Prefix must not be resolved in this case, since it is not a\n-         --  real entity reference. No action of any kind is require.\n-\n-         when Attribute_UET_Address =>\n-            return;\n-\n          ----------------------\n          -- Unchecked_Access --\n          ----------------------"}, {"sha": "d71acb33140063f80a6f6b181aeeee2308560ad5", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -508,16 +508,6 @@ package Sem_Attr is\n       --  Aux_DEC into System, then the type Type_Class can be referenced\n       --  as an entity within System, as can its enumeration literals.\n \n-      -----------------\n-      -- UET_Address --\n-      -----------------\n-\n-      Attribute_UET_Address => True,\n-      --  Unit'UET_Address, where Unit is a program unit, yields the address\n-      --  of the unit exception table for the specified unit. This is only\n-      --  used in the internal implementation of exception handling. See the\n-      --  implementation of unit Ada.Exceptions for details on its use.\n-\n       ------------------------------\n       -- Universal_Literal_String --\n       ------------------------------"}, {"sha": "22e7cbb9d128d273993296241be989bd7607aa3f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -3883,11 +3883,18 @@ package body Sem_Ch3 is\n          --  the possible presence of an address clause, and defer resolution\n          --  and expansion of the aggregate to the freeze point of the entity.\n \n+         --  This is not always legal because the aggregate may contain other\n+         --  references that need freezing, e.g. references to other entities\n+         --  with address clauses. In any case, when compiling with -gnatI the\n+         --  presence of the address clause must be ignored.\n+\n          if Comes_From_Source (N)\n            and then Expander_Active\n            and then Nkind (E) = N_Aggregate\n-           and then (Present (Following_Address_Clause (N))\n-                      or else Delayed_Aspect_Present)\n+           and then\n+             ((Present (Following_Address_Clause (N))\n+                            and then not Ignore_Rep_Clauses)\n+              or else Delayed_Aspect_Present)\n          then\n             Set_Etype (E, T);\n "}, {"sha": "bb64634c2ad9ecf451a0b725ceb04ffe6dab1074", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -22210,6 +22210,10 @@ package body Sem_Prag is\n          end if;\n       end if;\n \n+      if Class_Present (N) then\n+         Build_Generic_Class_Condition (Spec_Id, N);\n+      end if;\n+\n       Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n \n       --  For a class-wide condition, a reference to a controlling formal must\n@@ -25063,6 +25067,236 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n+   -----------------------------------\n+   -- Build_Generic_Class_Condition --\n+   -----------------------------------\n+\n+   procedure Build_Generic_Class_Condition\n+     (Subp : Entity_Id;\n+      Prag : Node_Id)\n+   is\n+      Expr     : constant Node_Id :=\n+                   Get_Pragma_Arg\n+                     (First (Pragma_Argument_Associations (Prag)));\n+      Loc      : constant Source_Ptr := Sloc (Prag);\n+      Map      : constant Elist_Id   := New_Elmt_List;\n+      New_Expr : constant Node_Id    := New_Copy_Tree (Expr);\n+      New_Pred : constant Entity_Id  :=\n+                   Make_Defining_Identifier (Loc,\n+                     New_External_Name (Chars (Subp), \"Pre\", -1));\n+      Typ      : constant Entity_Id  := Find_Dispatching_Type (Subp);\n+\n+      function Replace_Formal (N : Node_Id) return Traverse_Result;\n+      --  Replace an occurence of a formal parameter of the original expression\n+      --  in the precondition, with the formal of the generic function created\n+      --  for it.\n+\n+      --------------------\n+      -- Replace_Formal --\n+      --------------------\n+\n+      function Replace_Formal (N : Node_Id) return Traverse_Result is\n+         Loc   : constant Source_Ptr := Sloc (N);\n+         El    : Elmt_Id;\n+         F     : Entity_Id;\n+         New_F : Entity_Id;\n+\n+      begin\n+         if Nkind (N) = N_Identifier\n+           and then (Nkind (Parent (N)) /= N_Parameter_Association\n+             or else N /= Selector_Name (Parent (N)))\n+           and then Present (Entity (N))\n+           and then Is_Formal (Entity (N))\n+         then\n+            El := First_Elmt (Map);\n+            while Present (El) loop\n+               F := Node (El);\n+               if Chars (F) = Chars (N) then\n+                  New_F := Node (Next_Elmt (El));\n+\n+                  --  If this is a controlling formal, in the generic it\n+                  --  becomes a conversion to the controlling formal of the\n+                  --  operation with the classwide precondition. If the formal\n+                  --  is an access parameter, a reference to F becomes\n+                  --  Root (New_F.all)'access.\n+\n+                  if Is_Controlling_Formal (F) then\n+                     if Is_Access_Type (Etype (F)) then\n+                        Rewrite (N,\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         =>\n+                              Unchecked_Convert_To (\n+                                Designated_Type (Etype (F)),\n+                                  Make_Explicit_Dereference (Loc,\n+                                    Prefix => New_Occurrence_Of (New_F, Loc))),\n+                            Attribute_Name => Name_Access));\n+\n+                     else\n+                        Rewrite (N,\n+                          Unchecked_Convert_To\n+                            (Etype (F), New_Occurrence_Of (New_F, Sloc (N))));\n+                     end if;\n+\n+                  --  Non-controlling formals retain their original type\n+\n+                  else\n+                     Rewrite (N, New_Occurrence_Of (New_F, Sloc (N)));\n+                  end if;\n+\n+                  return OK;\n+               end if;\n+\n+               Next_Elmt (El);\n+               Next_Elmt (El);\n+            end loop;\n+\n+         elsif Nkind (N) = N_Parameter_Association then\n+            Set_Next_Named_Actual (N, Empty);\n+\n+         elsif Nkind (N) = N_Function_Call then\n+            Set_First_Named_Actual (N, Empty);\n+         end if;\n+\n+         return OK;\n+      end Replace_Formal;\n+\n+      procedure Map_Formals is new Traverse_Proc (Replace_Formal);\n+\n+      --  Local variables\n+\n+      Bod      : Node_Id;\n+      Decl     : Node_Id;\n+      F        : Entity_Id;\n+      New_F    : Entity_Id;\n+      New_Form : List_Id;\n+      New_Typ  : Entity_Id;\n+      Par_Typ  : Entity_Id;\n+      Spec     : Node_Id;\n+\n+   --  Start of processing for Build_Generic_Class_Pre\n+\n+   begin\n+      --  Nothing to do if previous error or expansion disabled.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n+      if Chars (Pragma_Identifier (Prag)) = Name_Postcondition then\n+         return;\n+      end if;\n+\n+      --  Build list of controlling formals and their renamings in the new\n+      --  generic operation.\n+\n+      New_Form := New_List;\n+      New_Typ  := Empty;\n+\n+      F := First_Formal (Subp);\n+      while Present (F) loop\n+         New_F :=\n+           Make_Defining_Identifier (Loc, New_External_Name (Chars (F), \"GF\"));\n+         Set_Ekind (New_F, Ekind (F));\n+         Append_Elmt (F, Map);\n+         Append_Elmt (New_F, Map);\n+\n+         if Is_Controlling_Formal (F) then\n+            if Is_Access_Type (Etype (F)) then\n+               New_Typ :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars =>\n+                     New_External_Name\n+                       (Chars (Designated_Type (Etype (F))), \"GT\"));\n+               Par_Typ :=\n+                 Make_Access_Definition (Loc,\n+                   Subtype_Mark => New_Occurrence_Of (New_Typ, Loc));\n+            else\n+               New_Typ :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (Etype (F)), \"GT\"));\n+               Par_Typ := New_Occurrence_Of (New_Typ, Loc);\n+            end if;\n+\n+            Append_To (New_Form,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => New_F,\n+                Parameter_Type      => Par_Typ));\n+         else\n+            --  If formal has a class-wide type, build same attribute for new\n+            --  formal.\n+\n+            if Is_Class_Wide_Type (Etype (F)) then\n+               Append_To (New_Form,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier => New_F,\n+                   Parameter_Type      =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         New_Occurrence_Of (Etype (Etype (F)), Loc),\n+                       Attribute_Name => Name_Class)));\n+            else\n+               Append_To (New_Form,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier => New_F,\n+                   Parameter_Type      => New_Occurrence_Of (Etype (F), Loc)));\n+            end if;\n+         end if;\n+\n+         Next_Formal (F);\n+      end loop;\n+\n+      --  If no controlling formal found, pre/postcondition is incorrect.\n+\n+      if No (New_Typ) then\n+         return;\n+      end if;\n+\n+      Spec :=\n+        Make_Function_Specification (Loc,\n+          Defining_Unit_Name       => New_Pred,\n+          Parameter_Specifications => New_Form,\n+          Result_Definition        =>\n+            New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+      Decl :=\n+        Make_Generic_Subprogram_Declaration (Loc,\n+          Specification               => Spec,\n+          Generic_Formal_Declarations => New_List (\n+            Make_Formal_Type_Declaration (Loc,\n+              Defining_Identifier    => New_Typ,\n+              Formal_Type_Definition =>\n+                Make_Formal_Private_Type_Definition (Loc))));\n+\n+      Preanalyze (New_Expr);\n+      Map_Formals (New_Expr);\n+\n+      Bod :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              => New_Copy_Tree (Spec),\n+          Declarations               => New_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (\n+                Make_Simple_Return_Statement (Loc,\n+                  Expression => New_Expr))));\n+\n+      --  Generic function must be analyzed after type is frozen, and will be\n+      --  instantiated when subprogram contract for operation or any of its\n+      --  overridings is expanded.\n+\n+      Append_Freeze_Actions (Typ, New_List (Decl, Bod));\n+\n+      --  We need to convey the existence of the generic to the point at which\n+      --  we expand the contract. We replace the expression in the pragma with\n+      --  name of the generic function, to be instantiated when expanding the\n+      --  contract for the subprogram or some overriding of it. See\n+      --  Exp_ch6.Expand_Subprogram_Contract.Build_Pragma_Check_Equivalent.\n+      --  (TBD)\n+\n+      Set_Ekind (New_Pred, E_Generic_Function);\n+      Set_Scope (New_Pred, Current_Scope);\n+   end Build_Generic_Class_Condition;\n+\n    -----------------------------\n    -- Check_Applicable_Policy --\n    -----------------------------"}, {"sha": "862c564f0da8adefcc453afc9d7f74d1bd43b092", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -215,6 +215,17 @@ package Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n \n+   procedure Build_Generic_Class_Condition\n+     (Subp : Entity_Id;\n+      Prag : Node_Id);\n+   --  AI12-113 modifies the semantics of classwide pre- and postconditions,\n+   --  as well as type invariants, so that the expression used in an inherited\n+   --  operation uses the actual type and is statically bound, rather than\n+   --  using T'Class and dispatching. This new semantics is implemented by\n+   --  building a generic function for the corresponding condition and\n+   --  instantiating it for each descendant type. Checking the condition is\n+   --  implemented as a call to that instantiation.\n+\n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n    --  the name of the aspect or pragma is not one of those recognized as"}, {"sha": "e0c857b1177782967d613440f50e087ba786e11d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -12730,9 +12730,9 @@ package body Sem_Util is\n \n    begin\n       --  Verify that prefix is analyzed and has the proper form. Note that\n-      --  the attributes Elab_Spec, Elab_Body, Elab_Subp_Body and UET_Address,\n-      --  which also produce the address of an entity, do not analyze their\n-      --  prefix because they denote entities that are not necessarily visible.\n+      --  the attributes Elab_Spec, Elab_Body and Elab_Subp_Body which also\n+      --  produce the address of an entity, do not analyze their prefix\n+      --  because they denote entities that are not necessarily visible.\n       --  Neither of them can apply to a protected type.\n \n       return Ada_Version >= Ada_2005"}, {"sha": "881f36589f86e704b8a84a13f8fa66fc24a550cb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a015ef67374d81c9468dfa5ca031ef0f8b394314/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a015ef67374d81c9468dfa5ca031ef0f8b394314", "patch": "@@ -938,7 +938,6 @@ package Snames is\n    Name_To_Address                     : constant Name_Id := N + $; -- GNAT\n    Name_Type_Class                     : constant Name_Id := N + $; -- GNAT\n    Name_Type_Key                       : constant Name_Id := N + $; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + $; -- GNAT\n    Name_Unbiased_Rounding              : constant Name_Id := N + $;\n    Name_Unchecked_Access               : constant Name_Id := N + $;\n    Name_Unconstrained_Array            : constant Name_Id := N + $; -- GNAT\n@@ -1575,7 +1574,6 @@ package Snames is\n       Attribute_To_Address,\n       Attribute_Type_Class,\n       Attribute_Type_Key,\n-      Attribute_UET_Address,\n       Attribute_Unbiased_Rounding,\n       Attribute_Unchecked_Access,\n       Attribute_Unconstrained_Array,"}]}