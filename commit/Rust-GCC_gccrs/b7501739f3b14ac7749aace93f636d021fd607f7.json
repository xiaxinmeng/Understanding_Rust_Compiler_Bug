{"sha": "b7501739f3b14ac7749aace93f636d021fd607f7", "node_id": "C_kwDOANBUbNoAKGI3NTAxNzM5ZjNiMTRhYzc3NDlhYWNlOTNmNjM2ZDAyMWZkNjA3Zjc", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-09T19:35:14Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-17T18:38:03Z"}, "message": "Add side effect infrastructure.\n\nReplace the non-null procesing with a generic side effect implementation that\ncan handle arbitrary side effects.\n\n\t* Makefile.in (OBJS): Add gimple-range-side-effect.o.\n\t* gimple-range-cache.cc (non_null_ref::non_null_ref): Delete.\n\t(non_null_ref::~non_null_ref): Delete.\n\t(non_null_ref::set_nonnull): Delete.\n\t(non_null_ref::non_null_deref_p): Delete.\n\t(non_null_ref::process_name): Delete.\n\t(ranger_cache::ranger_cache): Initialize m_exit object.\n\t(ranger_cache::fill_block_cache): Use m_exit object intead of nonnull.\n\t(ranger_cache::range_from_dom): Use side_effect class and m_exit object.\n\t(ranger_cache::update_to_nonnull): Delete.\n\t(non_null_loadstore): Delete.\n\t(ranger_cache::block_apply_nonnull): Delete.\n\t(ranger_cache::apply_side_effects): New.\n\t* gimple-range-cache.h (class non_null_ref): Delete.\n\t(non_null_ref::adjust_range): Delete.\n\t(class ranger_cache): Adjust prototypes, add side effect manager.\n\t* gimple-range-path.cc (path_range_query::range_defined_in_block): Use\n\tside effect manager for queries.\n\t(path_range_query::adjust_for_non_null_uses): Ditto.\n\t* gimple-range-path.h (class path_range_query): Delete non_null_ref.\n\t* gimple-range-side-effect.cc: New.\n\t* gimple-range-side-effect.h: New.\n\t* gimple-range.cc (gimple_ranger::gimple_ranger): Update contructor.\n\t(gimple_ranger::range_of_expr): Check def block for override value.\n\t(gimple_ranger::range_on_entry): Don't scan dominators for non-null.\n\t(gimple_ranger::range_on_edge): Check for outgoing side-effects.\n\t(gimple_ranger::register_side_effects): Call apply_side_effects.\n\t(enable_ranger): Update contructor.\n\t* gimple-range.h (class gimple_ranger): Update prototype.\n\t(enable_ranger): Update prototype.\n\t* tree-vrp.cc (execute_ranger_vrp): Invoke without immediate-use flag.", "tree": {"sha": "5c359661a70191c7ee4cc92b6d001a78ff26c099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c359661a70191c7ee4cc92b6d001a78ff26c099"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7501739f3b14ac7749aace93f636d021fd607f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7501739f3b14ac7749aace93f636d021fd607f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7501739f3b14ac7749aace93f636d021fd607f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7501739f3b14ac7749aace93f636d021fd607f7/comments", "author": null, "committer": null, "parents": [{"sha": "451894cadcf1210883ceefb2d69a0ed2d6a8cd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451894cadcf1210883ceefb2d69a0ed2d6a8cd8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/451894cadcf1210883ceefb2d69a0ed2d6a8cd8b"}], "stats": {"total": 746, "additions": 464, "deletions": 282}, "files": [{"sha": "97e5450ecb59359adbed022839fadd0ce14ce9d5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -1410,6 +1410,7 @@ OBJS = \\\n \tgimple-range-edge.o \\\n \tgimple-range-fold.o \\\n \tgimple-range-gori.o \\\n+\tgimple-range-side-effect.o \\\n \tgimple-range-trace.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-evrp.o \\"}, {"sha": "56f4577cfbb5c80feb8f122c1a4081a7cf217fbe", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 46, "deletions": 204, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -38,120 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #define DEBUG_RANGE_CACHE (dump_file\t\t\t\t\t\\\n \t\t\t   && (param_ranger_debug & RANGER_DEBUG_CACHE))\n \n-// During contructor, allocate the vector of ssa_names.\n-\n-non_null_ref::non_null_ref ()\n-{\n-  m_nn.create (num_ssa_names);\n-  m_nn.quick_grow_cleared (num_ssa_names);\n-  bitmap_obstack_initialize (&m_bitmaps);\n-}\n-\n-// Free any bitmaps which were allocated,a swell as the vector itself.\n-\n-non_null_ref::~non_null_ref ()\n-{\n-  bitmap_obstack_release (&m_bitmaps);\n-  m_nn.release ();\n-}\n-\n-// This routine will update NAME in BB to be nonnull if it is not already.\n-// return TRUE if the update happens.\n-\n-bool\n-non_null_ref::set_nonnull (basic_block bb, tree name)\n-{\n-  gcc_checking_assert (gimple_range_ssa_p (name)\n-\t\t       && POINTER_TYPE_P (TREE_TYPE (name)));\n-  // Only process when its not already set.\n-  if (non_null_deref_p  (name, bb, false))\n-    return false;\n-  bitmap_set_bit (m_nn[SSA_NAME_VERSION (name)], bb->index);\n-  return true;\n-}\n-\n-// Return true if NAME has a non-null dereference in block bb.  If this is the\n-// first query for NAME, calculate the summary first.\n-// If SEARCH_DOM is true, the search the dominator tree as well.\n-\n-bool\n-non_null_ref::non_null_deref_p (tree name, basic_block bb, bool search_dom)\n-{\n-  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-    return false;\n-\n-  unsigned v = SSA_NAME_VERSION (name);\n-  if (v >= m_nn.length ())\n-    m_nn.safe_grow_cleared (num_ssa_names + 1);\n-\n-  if (!m_nn[v])\n-    process_name (name);\n-\n-  if (bitmap_bit_p (m_nn[v], bb->index))\n-    return true;\n-\n-  // See if any dominator has set non-zero.\n-  if (search_dom && dom_info_available_p (CDI_DOMINATORS))\n-    {\n-      // Search back to the Def block, or the top, whichever is closer.\n-      basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n-      basic_block def_dom = def_bb\n-\t\t\t    ? get_immediate_dominator (CDI_DOMINATORS, def_bb)\n-\t\t\t    : NULL;\n-      for ( ;\n-\t    bb && bb != def_dom;\n-\t    bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n-\tif (bitmap_bit_p (m_nn[v], bb->index))\n-\t  return true;\n-    }\n-  return false;\n-}\n-\n-// Allocate an populate the bitmap for NAME.  An ON bit for a block\n-// index indicates there is a non-null reference in that block.  In\n-// order to populate the bitmap, a quick run of all the immediate uses\n-// are made and the statement checked to see if a non-null dereference\n-// is made on that statement.\n-\n-void\n-non_null_ref::process_name (tree name)\n-{\n-  unsigned v = SSA_NAME_VERSION (name);\n-  use_operand_p use_p;\n-  imm_use_iterator iter;\n-  bitmap b;\n-\n-  // Only tracked for pointers.\n-  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-    return;\n-\n-  // Already processed if a bitmap has been allocated.\n-  if (m_nn[v])\n-    return;\n-\n-  b = BITMAP_ALLOC (&m_bitmaps);\n-\n-  // Loop over each immediate use and see if it implies a non-null value.\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n-    {\n-      gimple *s = USE_STMT (use_p);\n-      unsigned index = gimple_bb (s)->index;\n-\n-      // If bit is already set for this block, dont bother looking again.\n-      if (bitmap_bit_p (b, index))\n-\tcontinue;\n-\n-      // If we can infer a nonnull range, then set the bit for this BB\n-      if (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name)\n-\t  && infer_nonnull_range (s, name))\n-\tbitmap_set_bit (b, index);\n-    }\n-\n-  m_nn[v] = b;\n-}\n-\n-// -------------------------------------------------------------------------\n-\n // This class represents the API into a cache of ranges for an SSA_NAME.\n // Routines must be implemented to set, get, and query if a value is set.\n \n@@ -859,8 +745,9 @@ update_list::pop ()\n \n // --------------------------------------------------------------------------\n \n-ranger_cache::ranger_cache (int not_executable_flag)\n-\t\t\t\t\t\t: m_gori (not_executable_flag)\n+ranger_cache::ranger_cache (int not_executable_flag, bool use_imm_uses)\n+\t\t\t\t\t\t: m_gori (not_executable_flag),\n+\t\t\t\t\t\t  m_exit (use_imm_uses)\n {\n   m_workback.create (0);\n   m_workback.safe_grow_cleared (last_basic_block_for_fn (cfun));\n@@ -1057,9 +944,9 @@ bool\n ranger_cache::edge_range (irange &r, edge e, tree name, enum rfd_mode mode)\n {\n   exit_range (r, name, e->src, mode);\n-  // If this is not an abnormal edge, check for a non-null exit.\n+  // If this is not an abnormal edge, check for side effects on exit.\n   if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n-    m_non_null.adjust_range (r, name, e->src, false);\n+    m_exit.maybe_adjust_range (r, name, e->src);\n   int_range_max er;\n   if (m_gori.outgoing_edge_range_p (er, e, name, *this))\n     r.intersect (er);\n@@ -1364,12 +1251,12 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t    }\n \n \t  // Regardless of whether we have visited pred or not, if the\n-\t  // pred has a non-null reference, revisit this block.\n+\t  // pred has side_effects, revisit this block.\n \t  // Don't search the DOM tree.\n-\t  if (m_non_null.non_null_deref_p (name, pred, false))\n+\t  if (m_exit.has_range_p (name, pred))\n \t    {\n \t      if (DEBUG_RANGE_CACHE)\n-\t\tfprintf (dump_file, \"nonnull: update \");\n+\t\tfprintf (dump_file, \"side effect: update \");\n \t      m_update->add (node);\n \t    }\n \n@@ -1429,8 +1316,9 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n \n   basic_block bb;\n   basic_block prev_bb = start_bb;\n-  // Flag if we encounter a block with non-null set.\n-  bool non_null = false;\n+\n+  // Track any side effects seen\n+  int_range_max side_effect (TREE_TYPE (name));\n \n   // Range on entry to the DEF block should not be queried.\n   gcc_checking_assert (start_bb != def_bb);\n@@ -1444,8 +1332,8 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n        bb;\n        prev_bb = bb, bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n-      if (!non_null)\n-\tnon_null |= m_non_null.non_null_deref_p (name, bb, false);\n+      // Accumulate any block exit side effects.\n+      m_exit.maybe_adjust_range (side_effect, name, bb);\n \n       // This block has an outgoing range.\n       if (m_gori.has_edge_range_p (name, bb))\n@@ -1511,14 +1399,10 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n       if (m_gori.outgoing_edge_range_p (er, e, name, *this))\n \t{\n \t  r.intersect (er);\n-\t  if (r.varying_p () && ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0))\n-\t    {\n-\t      if (m_non_null.non_null_deref_p (name, bb, false))\n-\t\t{\n-\t\t  gcc_checking_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n-\t\t  r.set_nonzero (TREE_TYPE (name));\n-\t\t}\n-\t    }\n+\t  // If this is a normal edge, apply any side effects.\n+\t  if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n+\t    m_exit.maybe_adjust_range (r, name, bb);\n+\n \t  if (DEBUG_RANGE_CACHE)\n \t    {\n \t      fprintf (dump_file, \"CACHE: Adjusted edge range for %d->%d : \",\n@@ -1530,12 +1414,9 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n     }\n \n   // Apply non-null if appropriate.\n-  if (non_null && r.varying_p ()\n-      && !has_abnormal_call_or_eh_pred_edge_p (start_bb))\n-    {\n-      gcc_checking_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n-      r.set_nonzero (TREE_TYPE (name));\n-    }\n+  if (!has_abnormal_call_or_eh_pred_edge_p (start_bb))\n+    r.intersect (side_effect);\n+\n   if (DEBUG_RANGE_CACHE)\n     {\n       fprintf (dump_file, \"CACHE: Range for DOM returns : \");\n@@ -1545,81 +1426,42 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n   return true;\n }\n \n-// This routine will update NAME in block BB to the nonnull state.\n-// It will then update the on-entry cache for this block to be non-null\n-// if it isn't already.\n+// This routine is used during a block walk to move the state of non-null for\n+// any operands on stmt S to nonnull.\n \n void\n-ranger_cache::update_to_nonnull (basic_block bb, tree name)\n+ranger_cache::apply_side_effects (gimple *s)\n {\n-  tree type = TREE_TYPE (name);\n-  if (gimple_range_ssa_p (name) && POINTER_TYPE_P (type))\n-    {\n-      m_non_null.set_nonnull (bb, name);\n-      // Update the on-entry cache for BB to be non-zero.  Note this can set\n-      // the on entry value in the DEF block, which can override the def.\n-      int_range_max r;\n-      exit_range (r, name, bb, RFD_READ_ONLY);\n-      if (r.varying_p ())\n-\t{\n-\t  r.set_nonzero (type);\n-\t  m_on_entry.set_bb_range (name, bb, r);\n-\t}\n-    }\n-}\n+  int_range_max r;\n+  bool update = true;\n \n-// Adapted from infer_nonnull_range_by_dereference and check_loadstore\n-// to process nonnull ssa_name OP in S.  DATA contains the ranger_cache.\n+  basic_block bb = gimple_bb (s);\n+  stmt_side_effects se(s);\n+  if (se.num () == 0)\n+    return;\n \n-static bool\n-non_null_loadstore (gimple *s, tree op, tree, void *data)\n-{\n-  if (TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n+  // Do not update the on-netry cache for block ending stmts.\n+  if (stmt_ends_bb_p (s))\n     {\n-      /* Some address spaces may legitimately dereference zero.  */\n-      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (op));\n-      if (!targetm.addr_space.zero_address_valid (as))\n-\t{\n-\t  tree ssa = TREE_OPERAND (op, 0);\n-\t  basic_block bb = gimple_bb (s);\n-\t  ((ranger_cache *)data)->update_to_nonnull (bb, ssa);\n-\t}\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, gimple_bb (s)->succs)\n+\tif (!(e->flags & (EDGE_ABNORMAL|EDGE_EH)))\n+\t  break;\n+      if (e == NULL)\n+\tupdate = false;\n     }\n-  return false;\n-}\n-\n-// This routine is used during a block walk to move the state of non-null for\n-// any operands on stmt S to nonnull.\n \n-void\n-ranger_cache::block_apply_nonnull (gimple *s)\n-{\n-  if (!flag_delete_null_pointer_checks)\n-    return;\n-  if (is_a<gphi *> (s))\n-    return;\n-  if (gimple_code (s) == GIMPLE_ASM || gimple_clobber_p (s))\n-    return;\n-  if (is_a<gcall *> (s))\n+  for (unsigned x = 0; x < se.num (); x++)\n     {\n-      tree fntype = gimple_call_fntype (s);\n-      bitmap nonnullargs = get_nonnull_args (fntype);\n-      // Process any non-null arguments\n-      if (nonnullargs)\n+      tree name = se.name (x);\n+      m_exit.add_range (name, bb, se.range (x));\n+      if (update)\n \t{\n-\t  basic_block bb = gimple_bb (s);\n-\t  for (unsigned i = 0; i < gimple_call_num_args (s); i++)\n-\t    {\n-\t      if (bitmap_empty_p (nonnullargs) || bitmap_bit_p (nonnullargs, i))\n-\t\t{\n-\t\t  tree op = gimple_call_arg (s, i);\n-\t\t  update_to_nonnull (bb, op);\n-\t\t}\n-\t    }\n-\t  BITMAP_FREE (nonnullargs);\n+\t  if (!m_on_entry.get_bb_range (r, name, bb))\n+\t    exit_range (r, name, bb, RFD_READ_ONLY);\n+\t  if (r.intersect (se.range (x)))\n+\t    m_on_entry.set_bb_range (name, bb, r);\n \t}\n-      // Fallthru and walk load/store ops now.\n     }\n-  walk_stmt_load_store_ops (s, (void *)this, non_null_loadstore,\n-\t\t\t    non_null_loadstore);\n }"}, {"sha": "42aa41ba3940e2baf5501dcd23b5bd4ce9be4942", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -22,56 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_SSA_RANGE_CACHE_H\n \n #include \"gimple-range-gori.h\" \n-\n-// Class used to track non-null references of an SSA name.  A vector\n-// of bitmaps indexed by SSA name is maintained.  When indexed by\n-// basic block, an on-bit indicates there is a non-null dereference\n-// for that SSA in that block.\n-\n-class non_null_ref\n-{\n-public:\n-  non_null_ref ();\n-  ~non_null_ref ();\n-  bool non_null_deref_p (tree name, basic_block bb, bool search_dom = true);\n-  bool adjust_range (irange &r, tree name, basic_block bb,\n-\t\t     bool search_dom = true);\n-  bool set_nonnull (basic_block bb, tree name);\n-private:\n-  vec <bitmap> m_nn;\n-  void process_name (tree name);\n-  bitmap_obstack m_bitmaps;\n-};\n-\n-// If NAME has a non-null dereference in block BB, adjust R with the\n-// non-zero information from non_null_deref_p, and return TRUE.  If\n-// SEARCH_DOM is true, non_null_deref_p should search the dominator tree.\n-\n-inline bool\n-non_null_ref::adjust_range (irange &r, tree name, basic_block bb,\n-\t\t\t    bool search_dom)\n-{\n-  // Non-call exceptions mean we could throw in the middle of the\n-  // block, so just punt on those for now.\n-  if (cfun->can_throw_non_call_exceptions)\n-    return false;\n-  // We only care about the null / non-null property of pointers.\n-  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-    return false;\n-  if (r.undefined_p () || r.lower_bound () != 0 || r.upper_bound () == 0)\n-    return false;\n-  // Check if pointers have any non-null dereferences.\n-  if (non_null_deref_p (name, bb, search_dom))\n-    {\n-      // Remove zero from the range.\n-      gcc_checking_assert (TYPE_UNSIGNED (TREE_TYPE (name)));\n-      int_range<2> nz;\n-      nz.set_nonzero (TREE_TYPE (name));\n-      r.intersect (nz);\n-      return true;\n-    }\n-  return false;\n-}\n+#include \"gimple-range-side-effect.h\"\n \n // This class manages a vector of pointers to ssa_block ranges.  It\n // provides the basis for the \"range on entry\" cache for all\n@@ -123,7 +74,7 @@ class ssa_global_cache\n class ranger_cache : public range_query\n {\n public:\n-  ranger_cache (int not_executable_flag);\n+  ranger_cache (int not_executable_flag, bool use_imm_uses);\n   ~ranger_cache ();\n \n   virtual bool range_of_expr (irange &r, tree name, gimple *stmt);\n@@ -136,10 +87,9 @@ class ranger_cache : public range_query\n \n   void propagate_updated_value (tree name, basic_block bb);\n \n-  void block_apply_nonnull (gimple *s);\n-  void update_to_nonnull (basic_block bb, tree name);\n-  non_null_ref m_non_null;\n+  void apply_side_effects (gimple *s);\n   gori_compute m_gori;\n+  side_effect_manager m_exit;\n \n   void dump_bb (FILE *f, basic_block bb);\n   virtual void dump (FILE *f) OVERRIDE;"}, {"sha": "459d3797da76712fe0736028d36c5dc1f88f8c8b", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -357,8 +357,8 @@ path_range_query::range_defined_in_block (irange &r, tree name, basic_block bb)\n \tr.set_varying (TREE_TYPE (name));\n     }\n \n-  if (bb)\n-    m_non_null.adjust_range (r, name, bb, false);\n+  if (bb && POINTER_TYPE_P (TREE_TYPE (name)))\n+    m_ranger->m_cache.m_exit.maybe_adjust_range (r, name, bb);\n \n   if (DEBUG_SOLVER && (bb || !r.varying_p ()))\n     {\n@@ -528,7 +528,7 @@ path_range_query::adjust_for_non_null_uses (basic_block bb)\n       else\n \tr.set_varying (TREE_TYPE (name));\n \n-      if (m_non_null.adjust_range (r, name, bb, false))\n+      if (m_ranger->m_cache.m_exit.maybe_adjust_range (r, name, bb))\n \tset_cache (r, name);\n     }\n }"}, {"sha": "914983bb0aad48fde9bd9175f9475fcfdeaebfcc", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -91,7 +91,6 @@ class path_range_query : public range_query\n \n   auto_bitmap m_imports;\n   gimple_ranger *m_ranger;\n-  non_null_ref m_non_null;\n \n   // Current path position.\n   unsigned m_pos;"}, {"sha": "2c8c77dc56950749165f96674c02061092ef42ae", "filename": "gcc/gimple-range-side-effect.cc", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-side-effect.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-side-effect.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-side-effect.cc?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -0,0 +1,310 @@\n+/* Gimple range side effect implementation.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"insn-codes.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gimple-range.h\"\n+#include \"tree-cfg.h\"\n+#include \"target.h\"\n+#include \"attribs.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"cfganal.h\"\n+\n+// Adapted from infer_nonnull_range_by_dereference and check_loadstore\n+// to process nonnull ssa_name OP in S.  DATA contains a pointer to a\n+// stmt side effects instance.\n+\n+static bool\n+non_null_loadstore (gimple *, tree op, tree, void *data)\n+{\n+  if (TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n+    {\n+      /* Some address spaces may legitimately dereference zero.  */\n+      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (op));\n+      if (!targetm.addr_space.zero_address_valid (as))\n+\t{\n+\t  tree ssa = TREE_OPERAND (op, 0);\n+\t  ((stmt_side_effects *)data)->add_nonzero (ssa);\n+\t}\n+    }\n+  return false;\n+}\n+\n+// Add NAME and RANGE to the the side effect summary.\n+\n+void\n+stmt_side_effects::add_range (tree name, irange &range)\n+{\n+  m_names[num_args] = name;\n+  m_ranges[num_args] = range;\n+  if (num_args < size_limit - 1)\n+    num_args++;\n+}\n+\n+// Add a nonzero range for NAME to the side effect summary.\n+\n+void\n+stmt_side_effects::add_nonzero (tree name)\n+{\n+  if (!gimple_range_ssa_p (name))\n+    return;\n+  int_range<2> nz;\n+  nz.set_nonzero (TREE_TYPE (name));\n+  add_range (name, nz);\n+}\n+\n+// Process S for side effects and fill in the summary list.\n+// This is the routine where new side effects should be added.\n+\n+stmt_side_effects::stmt_side_effects (gimple *s)\n+{\n+  num_args = 0;\n+\n+  if (is_a<gphi *> (s))\n+    return;\n+\n+  if (is_a<gcall *> (s) && flag_delete_null_pointer_checks)\n+    {\n+      tree fntype = gimple_call_fntype (s);\n+      bitmap nonnullargs = get_nonnull_args (fntype);\n+      // Process any non-null arguments\n+      if (nonnullargs)\n+\t{\n+\t  for (unsigned i = 0; i < gimple_call_num_args (s); i++)\n+\t    {\n+\t      if (bitmap_empty_p (nonnullargs)\n+\t\t  || bitmap_bit_p (nonnullargs, i))\n+\t\t{\n+\t\t  tree op = gimple_call_arg (s, i);\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (op)))\n+\t\t    add_nonzero (op);\n+\t\t}\n+\t    }\n+\t  BITMAP_FREE (nonnullargs);\n+\t}\n+      // Fallthru and walk load/store ops now.\n+    }\n+\n+  // Look for possible non-null values.\n+  if (flag_delete_null_pointer_checks && gimple_code (s) != GIMPLE_ASM\n+      && !gimple_clobber_p (s))\n+    walk_stmt_load_store_ops (s, (void *)this, non_null_loadstore,\n+\t\t\t      non_null_loadstore);\n+\n+}\n+\n+// -------------------------------------------------------------------------\n+\n+// This class is an element in list of side effect ranges.\n+\n+class exit_range\n+{\n+public:\n+  tree name;\n+  irange *range;\n+  exit_range *next;\n+};\n+\n+// If there is an element which matches SSA, return a pointer to the element.\n+// Otherwise return NULL.\n+\n+exit_range *\n+side_effect_manager::exit_range_head::find_ptr (tree ssa)\n+{\n+  // Return NULL if SSA is not in this list.\n+  if (!m_names || !bitmap_bit_p (m_names, SSA_NAME_VERSION (ssa)))\n+    return NULL;\n+  for (exit_range *ptr = head; ptr != NULL; ptr = ptr->next)\n+    if (ptr->name == ssa)\n+      return ptr;\n+  // Should be unreachable.\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+// Construct a side effects manager.  DO_SEARCH indicates whether an immediate\n+// use scan should be made the first time a name is processed.  This is for\n+// on-demand clients who may not visit every statement and may miss uses.\n+\n+side_effect_manager::side_effect_manager (bool do_search)\n+{\n+  bitmap_obstack_initialize (&m_bitmaps);\n+  m_on_exit.create (0);\n+  m_on_exit.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n+  // m_seen == NULL indicates no scanning.  Otherwise the bit indicates a\n+  // scan has been performed on NAME.\n+  if (do_search)\n+    m_seen = BITMAP_ALLOC (&m_bitmaps);\n+  else\n+    m_seen = NULL;\n+  obstack_init (&m_list_obstack);\n+  // Non-zero elements are very common, so cache them for each ssa-name.\n+  m_nonzero.create (0);\n+  m_nonzero.safe_grow_cleared (num_ssa_names + 1);\n+}\n+\n+// Destruct a side effects manager.\n+\n+side_effect_manager::~side_effect_manager ()\n+{\n+  m_nonzero.release ();\n+  obstack_free (&m_list_obstack, NULL);\n+  m_on_exit.release ();\n+  bitmap_obstack_release (&m_bitmaps);\n+}\n+\n+// Return a non-zero range value of the appropriate type for NAME from\n+// the cache, creating it if necessary.\n+\n+const irange&\n+side_effect_manager::get_nonzero (tree name)\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (v >= m_nonzero.length ())\n+    m_nonzero.safe_grow_cleared (num_ssa_names + 20);\n+  if (!m_nonzero[v])\n+    {\n+      m_nonzero[v] = m_range_allocator.allocate (2);\n+      m_nonzero[v]->set_nonzero (TREE_TYPE (name));\n+    }\n+  return *(m_nonzero[v]);\n+}\n+\n+// Return TRUE if NAME has a side effect range in block BB.\n+\n+bool\n+side_effect_manager::has_range_p (tree name, basic_block bb)\n+{\n+  // Check if this is an immediate use search model.\n+  if (m_seen && !bitmap_bit_p (m_seen, SSA_NAME_VERSION (name)))\n+    register_all_uses (name);\n+\n+  if (bb->index >= (int)m_on_exit.length ())\n+    return false;\n+  if (!m_on_exit[bb->index].m_names)\n+    return false;\n+  if (!bitmap_bit_p (m_on_exit[bb->index].m_names, SSA_NAME_VERSION (name)))\n+    return false;\n+  return true;\n+}\n+\n+// Return TRUE if NAME has a side effect range in block BB, and adjust range R\n+// to include it.\n+\n+bool\n+side_effect_manager::maybe_adjust_range (irange &r, tree name, basic_block bb)\n+{\n+  if (!has_range_p (name, bb))\n+    return false;\n+  exit_range *ptr = m_on_exit[bb->index].find_ptr (name);\n+  gcc_checking_assert (ptr);\n+  // Return true if this exit range changes R, otherwise false.\n+  return r.intersect (*(ptr->range));\n+}\n+\n+// Add range R as a side effect for NAME in block BB.\n+\n+void\n+side_effect_manager::add_range (tree name, basic_block bb, const irange &r)\n+{\n+  if (bb->index >= (int)m_on_exit.length ())\n+    m_on_exit.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n+\n+  // Create the summary list bitmap if it doesn't exist.\n+  if (!m_on_exit[bb->index].m_names)\n+      m_on_exit[bb->index].m_names = BITMAP_ALLOC (&m_bitmaps);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+   {\n+     fprintf (dump_file, \"   on-exit update \");\n+     print_generic_expr (dump_file, name, TDF_SLIM);\n+     fprintf (dump_file, \" in BB%d : \",bb->index);\n+     r.dump (dump_file);\n+     fprintf (dump_file, \"\\n\");\n+   }\n+\n+  // If NAME already has a range, intersect them and done.\n+  exit_range *ptr = m_on_exit[bb->index].find_ptr (name);\n+  if (ptr)\n+    {\n+      int_range_max cur = r;\n+      // If no new info is added, just return.\n+      if (!cur.intersect (*(ptr->range)))\n+\treturn;\n+      if (ptr->range->fits_p (cur))\n+\t*(ptr->range) = cur;\n+      else\n+\tptr->range = m_range_allocator.allocate (cur);\n+      return;\n+    }\n+\n+  // Otherwise create a record.\n+  bitmap_set_bit (m_on_exit[bb->index].m_names, SSA_NAME_VERSION (name));\n+  ptr = (exit_range *)obstack_alloc (&m_list_obstack, sizeof (exit_range));\n+  ptr->range = m_range_allocator.allocate (r);\n+  ptr->name = name;\n+  ptr->next = m_on_exit[bb->index].head;\n+  m_on_exit[bb->index].head = ptr;\n+}\n+\n+// Add a non-zero side effect for NAME in block BB.\n+\n+void\n+side_effect_manager::add_nonzero (tree name, basic_block bb)\n+{\n+  add_range (name, bb, get_nonzero (name));\n+}\n+\n+// Follow immediate use chains and find all side effects for NAME.\n+\n+void\n+side_effect_manager::register_all_uses (tree name)\n+{\n+  gcc_checking_assert (m_seen);\n+\n+  // Check if we've already processed this name.\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (bitmap_bit_p (m_seen, v))\n+     return;\n+  bitmap_set_bit (m_seen, v);\n+\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+\n+  // Loop over each immediate use and see if it has a side effect.\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n+    {\n+      gimple *s = USE_STMT (use_p);\n+      stmt_side_effects se (s);\n+      for (unsigned x = 0; x < se.num (); x++)\n+\t{\n+\t  if (name == se.name (x))\n+\t    add_range (name, gimple_bb (s), se.range (x));\n+\t}\n+    }\n+}"}, {"sha": "848d94ba6d7d50e7bfb4d6cf7a996bf4c1741ca5", "filename": "gcc/gimple-range-side-effect.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-side-effect.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range-side-effect.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-side-effect.h?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -0,0 +1,82 @@\n+/* Header file for gimple range side effects.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_RANGE_SIDE_H\n+#define GCC_GIMPLE_RANGE_SIDE_H\n+\n+// This class manages an on-demand summary of side effects for a statement.\n+// It can be instantiated as required and provides a list of side effects.\n+\n+// New side effects should added in the constructor of this class.\n+\n+class stmt_side_effects\n+{\n+public:\n+  stmt_side_effects (gimple *s);\n+  inline unsigned num () const { return num_args; }\n+  inline tree name (unsigned index) const\n+    { gcc_checking_assert (index < num_args); return m_names[index]; }\n+  inline const irange& range (unsigned index) const\n+    { gcc_checking_assert (index < num_args); return m_ranges[index]; }\n+  void add_range (tree name, irange &range);\n+  void add_nonzero (tree name);\n+private:\n+  unsigned num_args;\n+  static const int size_limit = 10;\n+  tree m_names[size_limit];\n+  int_range<3> m_ranges[size_limit];\n+  inline void bump_index () { if (num_args < size_limit - 1) num_args++; }\n+};\n+\n+// This class manages a list of side effect ranges for each basic block.\n+// As side effects are seen, they can be registered to a block and later\n+// queried.  WHen constructed with a TRUE flag, immediate uses chains are\n+// followed the first time a name is referenced and block populated if\n+// thre are any side effects.\n+\n+class side_effect_manager\n+{\n+public:\n+  side_effect_manager (bool do_search);\n+  ~side_effect_manager ();\n+  void add_range (tree name, basic_block bb, const irange &r);\n+  void add_nonzero (tree name, basic_block bb);\n+  bool has_range_p (tree name, basic_block bb);\n+  bool maybe_adjust_range (irange &r, tree name, basic_block bb);\n+private:\n+  class exit_range_head\n+  {\n+  public:\n+    bitmap m_names;\t\t// list of names with an outgoing range.\n+    class exit_range *head;\n+    int m_num_ranges;\n+    exit_range *find_ptr (tree name);\n+  };\n+  void register_all_uses (tree name);\n+  vec <exit_range_head> m_on_exit;\n+  const irange &get_nonzero (tree name);\n+  vec <irange *> m_nonzero;\n+  bitmap m_seen;\n+  bitmap_obstack m_bitmaps;\n+  struct obstack m_list_obstack;\n+  irange_allocator m_range_allocator;\n+};\n+\n+#endif // GCC_GIMPLE_RANGE_SIDE_H"}, {"sha": "f5e9e77bc71959f226a99eafc5af807b06dd71a2", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -37,9 +37,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n #include \"gimple-walk.h\"\n \n-gimple_ranger::gimple_ranger () :\n+gimple_ranger::gimple_ranger (bool use_imm_uses) :\n \tnon_executable_edge_flag (cfun),\n-\tm_cache (non_executable_edge_flag),\n+\tm_cache (non_executable_edge_flag, use_imm_uses),\n \ttracer (\"\"),\n \tcurrent_bb (NULL)\n {\n@@ -118,9 +118,11 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n       // If name is defined in this block, try to get an range from S.\n       if (def_stmt && gimple_bb (def_stmt) == bb)\n \t{\n-\t  // Check for a definition override from a block walk.\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (expr))\n-\t      || !m_cache.block_range (r, bb, expr, false))\n+\t  // Declared in ths block, if it has a global set, check for an\n+\t  // override from a block walk, otherwise calculate it.\n+\t  if (m_cache.get_global_range (r, expr))\n+\t    m_cache.block_range (r, bb, expr, false);\n+\t  else\n \t    range_of_stmt (r, def_stmt, expr);\n \t}\n       // Otherwise OP comes from outside this block, use range on entry.\n@@ -154,13 +156,6 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n   if (m_cache.block_range (entry_range, bb, name))\n     r.intersect (entry_range);\n \n-  if (dom_info_available_p (CDI_DOMINATORS))\n-    {\n-      basic_block dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-      if (dom_bb)\n-\tm_cache.m_non_null.adjust_range (r, name, dom_bb, true);\n-    }\n-\n   if (idx)\n     tracer.trailer (idx, \"range_on_entry\", true, name, r);\n }\n@@ -237,7 +232,7 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n       range_on_exit (r, e->src, name);\n       // If this is not an abnormal edge, check for a non-null exit .\n       if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n-\tm_cache.m_non_null.adjust_range (r, name, e->src, false);\n+\tm_cache.m_exit.maybe_adjust_range (r, name, e->src);\n       gcc_checking_assert  (r.undefined_p ()\n \t\t\t    || range_compatible_p (r.type(), TREE_TYPE (name)));\n \n@@ -480,7 +475,7 @@ gimple_ranger::register_side_effects (gimple *s)\n \t  fputc ('\\n', dump_file);\n \t}\n     }\n-  m_cache.block_apply_nonnull (s);\n+  m_cache.apply_side_effects (s);\n }\n \n // This routine will export whatever global ranges are known to GCC\n@@ -625,12 +620,12 @@ gimple_ranger::debug ()\n    resources.  */\n \n gimple_ranger *\n-enable_ranger (struct function *fun)\n+enable_ranger (struct function *fun, bool use_imm_uses)\n {\n   gimple_ranger *r;\n \n   gcc_checking_assert (!fun->x_range_query);\n-  r = new gimple_ranger;\n+  r = new gimple_ranger (use_imm_uses);\n   fun->x_range_query = r;\n \n   return r;"}, {"sha": "ae6c4028a98d8f074cf9c70041715062a34342ee", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n class gimple_ranger : public range_query\n {\n public:\n-  gimple_ranger ();\n+  gimple_ranger (bool use_imm_uses = true);\n   ~gimple_ranger ();\n   virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL) OVERRIDE;\n   virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) OVERRIDE;\n@@ -69,12 +69,15 @@ class gimple_ranger : public range_query\n   range_tracer tracer;\n   basic_block current_bb;\n   vec<tree> m_stmt_list;\n+  friend class path_range_query;\n };\n \n /* Create a new ranger instance and associate it with a function.\n    Each call must be paired with a call to disable_ranger to release\n-   resources.  */\n-extern gimple_ranger *enable_ranger (struct function *);\n+   resources.  If USE_IMM_USES is true, pre-calculate sideffects like\n+   non-null uses as required using the immediate use chains.  */\n+extern gimple_ranger *enable_ranger (struct function *m,\n+\t\t\t\t     bool use_imm_uses = true);\n extern void disable_ranger (struct function *);\n \n #endif // GCC_GIMPLE_RANGE_H"}, {"sha": "77c1912958001f6e516a7d22c9e2bcf7a54d7fe6", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7501739f3b14ac7749aace93f636d021fd607f7/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=b7501739f3b14ac7749aace93f636d021fd607f7", "patch": "@@ -4345,7 +4345,7 @@ execute_ranger_vrp (struct function *fun, bool warn_array_bounds_p)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   set_all_edges_as_executable (fun);\n-  gimple_ranger *ranger = enable_ranger (fun);\n+  gimple_ranger *ranger = enable_ranger (fun, false);\n   rvrp_folder folder (ranger);\n   folder.substitute_and_fold ();\n   if (dump_file && (dump_flags & TDF_DETAILS))"}]}