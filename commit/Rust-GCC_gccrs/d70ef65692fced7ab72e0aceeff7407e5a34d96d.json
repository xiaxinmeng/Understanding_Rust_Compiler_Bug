{"sha": "d70ef65692fced7ab72e0aceeff7407e5a34d96d", "node_id": "C_kwDOANBUbNoAKGQ3MGVmNjU2OTJmY2VkN2FiNzJlMGFjZWVmZjc0MDdlNWEzNGQ5NmQ", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-10T12:08:41Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-10T12:08:41Z"}, "message": "Make EAF flags more regular (and expressive)\n\nI hoped that I am done with EAF flags related changes, but while looking into\nthe Fortran testcases I noticed that I have designed them in unnecesarily\nrestricted way.  I followed the scheme of NOESCAPE and NODIRECTESCAPE which is\nhowever the only property tht is naturally transitive.\n\nThis patch replaces the existing flags by 9 flags:\n\nEAF_UNUSED\nEAF_NO_DIRECT_CLOBBER and EAF_NO_INDIRECT_CLOBBER\nEAF_NO_DIRECT_READ and EAF_NO_INDIRECT_READ\nEAF_NO_DIRECT_ESCAPE and EAF_NO_INDIRECT_ESCAPE\nEAF_NO_DIRECT_READ and EAF_NO_INDIRECT_READ\n\nSo I have removed the unified EAF_DIRECT flag and made each of the flags to come\nin direct and indirect variant.  Newly the indirect variant is not implied by direct\n(well except for escape but it is not special cased in the code)\nConsequently we can analyse i.e. the case where function reads directly and clobber\nindirectly as in the following testcase:\n\nstruct wrap {\n\tvoid **array;\n};\n__attribute__ ((noinline))\nvoid\nwrite_array (struct wrap *ptr)\n{\n\tptr->array[0]=0;\n}\nint\ntest ()\n{\n\tvoid *arrayval;\n\tstruct wrap w = {&arrayval};\n\twrite_array (&w);\n\treturn w.array == &arrayval;\n}\n\nThis is pretty common in array descriptors and also C++ pointer wrappers or structures\ncontaining pointers to arrays.\n\nOther advantage is that !binds_to_current_def_p functions we can still track the fact\nthat the value is not clobbered indirectly while previously we implied EAF_DIRECT\nfor all three cases.\n\nFinally the propagation becomes more regular and I hope easier to understand\nbecause the flags are handled in a symmetric way.\n\nIn tree-ssa-structalias I now produce \"callarg\" var_info as before and if necessary\nalso \"indircallarg\" for the indirect accesses.  I added some logic to optimize the\ncommon case where we can not make difference between direct and indirect.\n\ngcc/ChangeLog:\n\n2021-11-09  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* tree-core.h (EAF_DIRECT): Remove.\n\t(EAF_NOCLOBBER): Remove.\n\t(EAF_UNUSED): Remove.\n\t(EAF_NOESCAPE): Remove.\n\t(EAF_NO_DIRECT_CLOBBER): New.\n\t(EAF_NO_INDIRECT_CLOBBER): New.\n\t(EAF_NODIRECTESCAPE): Remove.\n\t(EAF_NO_DIRECT_ESCAPE): New.\n\t(EAF_NO_INDIRECT_ESCAPE): New.\n\t(EAF_NOT_RETURNED): Remove.\n\t(EAF_NOT_RETURNED_INDIRECTLY): New.\n\t(EAF_NOREAD): Remove.\n\t(EAF_NO_DIRECT_READ): New.\n\t(EAF_NO_INDIRECT_READ): New.\n\t* gimple.c (gimple_call_arg_flags): Update for new flags.\n\t(gimple_call_retslot_flags): Update for new flags.\n\t* ipa-modref.c (dump_eaf_flags): Likewise.\n\t(remove_useless_eaf_flags): Likewise.\n\t(deref_flags): Likewise.\n\t(modref_lattice::init): Likewise.\n\t(modref_lattice::merge): Likewise.\n\t(modref_lattice::merge_direct_load): Likewise.\n\t(modref_lattice::merge_direct_store): Likewise.\n\t(modref_eaf_analysis::merge_call_lhs_flags): Likewise.\n\t(callee_to_caller_flags): Likewise.\n\t(modref_eaf_analysis::analyze_ssa_name): Likewise.\n\t(modref_eaf_analysis::propagate): Likewise.\n\t(modref_merge_call_site_flags): Likewise.\n\t* ipa-modref.h (interposable_eaf_flags): Likewise.\n\t* tree-ssa-alias.c: (ref_maybe_used_by_call_p_1) Likewise.\n\t* tree-ssa-structalias.c (handle_call_arg): Likewise.\n\t(handle_rhs_call): Likewise.\n\t* tree-ssa-uninit.c (maybe_warn_pass_by_reference): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ipa/modref-1.C: Update template.\n\t* gcc.dg/ipa/modref-3.c: Update template.\n\t* gcc.dg/lto/modref-3_0.c: Update template.\n\t* gcc.dg/lto/modref-4_0.c: Update template.\n\t* gcc.dg/tree-ssa/modref-10.c: Update template.\n\t* gcc.dg/tree-ssa/modref-11.c: Update template.\n\t* gcc.dg/tree-ssa/modref-5.c: Update template.\n\t* gcc.dg/tree-ssa/modref-6.c: Update template.\n\t* gcc.dg/tree-ssa/modref-13.c: New test.", "tree": {"sha": "de1a8f2fb5906a8f448b2b8665b911e78ee335d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de1a8f2fb5906a8f448b2b8665b911e78ee335d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d70ef65692fced7ab72e0aceeff7407e5a34d96d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70ef65692fced7ab72e0aceeff7407e5a34d96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70ef65692fced7ab72e0aceeff7407e5a34d96d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70ef65692fced7ab72e0aceeff7407e5a34d96d/comments", "author": null, "committer": null, "parents": [{"sha": "0cf6065ce4997774de66db4de83d461013e0f0e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf6065ce4997774de66db4de83d461013e0f0e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cf6065ce4997774de66db4de83d461013e0f0e1"}], "stats": {"total": 474, "additions": 302, "deletions": 172}, "files": [{"sha": "1e0fad92e15c8cb85170db89675dc082789d27c7", "filename": "gcc/gimple.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -1575,11 +1575,12 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n       else\n \t{\n \t  if (fnspec.arg_direct_p (arg))\n-\t    flags |= EAF_DIRECT;\n+\t    flags |= EAF_NO_INDIRECT_READ | EAF_NO_INDIRECT_ESCAPE\n+\t\t     | EAF_NOT_RETURNED_INDIRECTLY | EAF_NO_INDIRECT_CLOBBER;\n \t  if (fnspec.arg_noescape_p (arg))\n-\t    flags |= EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n+\t    flags |= EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE;\n \t  if (fnspec.arg_readonly_p (arg))\n-\t    flags |= EAF_NOCLOBBER;\n+\t    flags |= EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER;\n \t}\n     }\n   tree callee = gimple_call_fndecl (stmt);\n@@ -1608,7 +1609,7 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n int\n gimple_call_retslot_flags (const gcall *stmt)\n {\n-  int flags = EAF_DIRECT | EAF_NOREAD;\n+  int flags = implicit_retslot_eaf_flags;\n \n   tree callee = gimple_call_fndecl (stmt);\n   if (callee)"}, {"sha": "14c3894d7ba3160fb2dce891141767b2d7d3174c", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 107, "deletions": 97, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -148,22 +148,24 @@ struct escape_entry\n static void\n dump_eaf_flags (FILE *out, int flags, bool newline = true)\n {\n-  if (flags & EAF_DIRECT)\n-    fprintf (out, \" direct\");\n-  if (flags & EAF_NOCLOBBER)\n-    fprintf (out, \" noclobber\");\n-  if (flags & EAF_NOESCAPE)\n-    fprintf (out, \" noescape\");\n-  if (flags & EAF_NODIRECTESCAPE)\n-    fprintf (out, \" nodirectescape\");\n   if (flags & EAF_UNUSED)\n     fprintf (out, \" unused\");\n-  if (flags & EAF_NOT_RETURNED)\n-    fprintf (out, \" not_returned\");\n+  if (flags & EAF_NO_DIRECT_CLOBBER)\n+    fprintf (out, \" no_direct_clobber\");\n+  if (flags & EAF_NO_INDIRECT_CLOBBER)\n+    fprintf (out, \" no_indirect_clobber\");\n+  if (flags & EAF_NO_DIRECT_ESCAPE)\n+    fprintf (out, \" no_direct_escape\");\n+  if (flags & EAF_NO_INDIRECT_ESCAPE)\n+    fprintf (out, \" no_indirect_escape\");\n   if (flags & EAF_NOT_RETURNED_DIRECTLY)\n     fprintf (out, \" not_returned_directly\");\n-  if (flags & EAF_NOREAD)\n-    fprintf (out, \" noread\");\n+  if (flags & EAF_NOT_RETURNED_INDIRECTLY)\n+    fprintf (out, \" not_returned_indirectly\");\n+  if (flags & EAF_NO_DIRECT_READ)\n+    fprintf (out, \" no_direct_read\");\n+  if (flags & EAF_NO_INDIRECT_READ)\n+    fprintf (out, \" no_indirect_read\");\n   if (newline)\n   fprintf (out, \"\\n\");\n }\n@@ -296,7 +298,7 @@ remove_useless_eaf_flags (int eaf_flags, int ecf_flags, bool returns_void)\n   else if (ecf_flags & ECF_PURE)\n     eaf_flags &= ~implicit_pure_eaf_flags;\n   else if ((ecf_flags & ECF_NORETURN) || returns_void)\n-    eaf_flags &= ~(EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY);\n+    eaf_flags &= ~(EAF_NOT_RETURNED_DIRECTLY | EAF_NOT_RETURNED_INDIRECTLY);\n   return eaf_flags;\n }\n \n@@ -1412,35 +1414,32 @@ memory_access_to (tree op, tree ssa_name)\n static int\n deref_flags (int flags, bool ignore_stores)\n {\n-  int ret = EAF_NODIRECTESCAPE | EAF_NOT_RETURNED_DIRECTLY;\n+  /* Dereference is also a direct read but dereferenced value does not\n+     yield any other direct use.  */\n+  int ret = EAF_NO_DIRECT_CLOBBER | EAF_NO_DIRECT_ESCAPE\n+\t    | EAF_NOT_RETURNED_DIRECTLY;\n   /* If argument is unused just account for\n      the read involved in dereference.  */\n   if (flags & EAF_UNUSED)\n-    ret |= EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOT_RETURNED;\n+    ret |= EAF_NO_INDIRECT_READ | EAF_NO_INDIRECT_CLOBBER\n+\t   | EAF_NO_INDIRECT_ESCAPE;\n   else\n     {\n-      if ((flags & EAF_NOCLOBBER) || ignore_stores)\n-\tret |= EAF_NOCLOBBER;\n-      if ((flags & EAF_NOESCAPE) || ignore_stores)\n-\tret |= EAF_NOESCAPE;\n-      /* If the value dereferenced is not used for another load or store\n-\t we can still consider ARG as used only directly.\n-\n-\t Consider\n-\n-\t int\n-\t test (int *a)\n-\t   {\n-\t     return *a!=0;\n-\t   }\n-\n-\t*/\n-      if ((flags & (EAF_NOREAD | EAF_NOT_RETURNED | EAF_NOESCAPE | EAF_DIRECT))\n-\t  == (EAF_NOREAD | EAF_NOT_RETURNED | EAF_NOESCAPE | EAF_DIRECT)\n-\t  && ((flags & EAF_NOCLOBBER) || ignore_stores))\n-\tret |= EAF_DIRECT;\n-      if (flags & EAF_NOT_RETURNED)\n-\tret |= EAF_NOT_RETURNED;\n+      /* Direct or indirect accesses leads to indirect accesses.  */\n+      if (((flags & EAF_NO_DIRECT_CLOBBER)\n+\t   && (flags & EAF_NO_INDIRECT_CLOBBER))\n+\t  || ignore_stores)\n+\tret |= EAF_NO_INDIRECT_CLOBBER;\n+      if (((flags & EAF_NO_DIRECT_ESCAPE)\n+\t   && (flags & EAF_NO_INDIRECT_ESCAPE))\n+\t  || ignore_stores)\n+\tret |= EAF_NO_INDIRECT_ESCAPE;\n+      if ((flags & EAF_NO_DIRECT_READ)\n+\t   && (flags & EAF_NO_INDIRECT_READ))\n+\tret |= EAF_NO_INDIRECT_READ;\n+      if ((flags & EAF_NOT_RETURNED_DIRECTLY)\n+\t  && (flags & EAF_NOT_RETURNED_INDIRECTLY))\n+\tret |= EAF_NOT_RETURNED_INDIRECTLY;\n     }\n   return ret;\n }\n@@ -1508,9 +1507,11 @@ void\n modref_lattice::init ()\n {\n   /* All flags we track.  */\n-  int f = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED\n-\t  | EAF_NODIRECTESCAPE | EAF_NOT_RETURNED |\n-\t  EAF_NOT_RETURNED_DIRECTLY | EAF_NOREAD;\n+  int f = EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER\n+\t  | EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE\n+\t  | EAF_NO_DIRECT_READ | EAF_NO_INDIRECT_READ\n+\t  | EAF_NOT_RETURNED_DIRECTLY | EAF_NOT_RETURNED_INDIRECTLY\n+\t  | EAF_UNUSED;\n   flags = f;\n   /* Check that eaf_flags_t is wide enough to hold all flags.  */\n   gcc_checking_assert (f == flags);\n@@ -1589,12 +1590,6 @@ modref_lattice::merge (int f)\n {\n   if (f & EAF_UNUSED)\n     return false;\n-  /* Noescape implies that value also does not escape directly.\n-     Fnspec machinery does set both so compensate for this.  */\n-  if (f & EAF_NOESCAPE)\n-    f |= EAF_NODIRECTESCAPE;\n-  if (f & EAF_NOT_RETURNED)\n-    f |= EAF_NOT_RETURNED_DIRECTLY;\n   if ((flags & f) != flags)\n     {\n       flags &= f;\n@@ -1664,15 +1659,15 @@ modref_lattice::merge_deref (const modref_lattice &with, bool ignore_stores)\n bool\n modref_lattice::merge_direct_load ()\n {\n-  return merge (~(EAF_UNUSED | EAF_NOREAD));\n+  return merge (~(EAF_UNUSED | EAF_NO_DIRECT_READ));\n }\n \n /* Merge in flags for direct store.  */\n \n bool\n modref_lattice::merge_direct_store ()\n {\n-  return merge (~(EAF_UNUSED | EAF_NOCLOBBER));\n+  return merge (~(EAF_UNUSED | EAF_NO_DIRECT_CLOBBER));\n }\n \n /* Analyzer of EAF flags.\n@@ -1729,22 +1724,30 @@ class modref_eaf_analysis\n   auto_vec<int> m_names_to_propagate;\n \n   void merge_with_ssa_name (tree dest, tree src, bool deref);\n-  void merge_call_lhs_flags (gcall *call, int arg, tree name, bool deref);\n+  void merge_call_lhs_flags (gcall *call, int arg, tree name, bool direct,\n+\t\t\t     bool deref);\n };\n \n \n-/* Call statements may return their parameters.  Consider argument number\n+/* Call statements may return tgeir parameters.  Consider argument number\n    ARG of USE_STMT and determine flags that can needs to be cleared\n    in case pointer possibly indirectly references from ARG I is returned.\n+   If DIRECT is true consider direct returns and if INDIRECT consider\n+   indirect returns.\n    LATTICE, DEPTH and ipa are same as in analyze_ssa_name.\n    ARG is set to -1 for static chain.  */\n \n void\n modref_eaf_analysis::merge_call_lhs_flags (gcall *call, int arg,\n-\t\t\t\t\t   tree name, bool deref)\n+\t\t\t\t\t   tree name, bool direct,\n+\t\t\t\t\t   bool indirect)\n {\n   int index = SSA_NAME_VERSION (name);\n \n+  /* If value is not returned at all, do nothing.  */\n+  if (!direct && !indirect)\n+    return;\n+\n   /* If there is no return value, no flags are affected.  */\n   if (!gimple_call_lhs (call))\n     return;\n@@ -1763,10 +1766,13 @@ modref_eaf_analysis::merge_call_lhs_flags (gcall *call, int arg,\n   if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n     {\n       tree lhs = gimple_call_lhs (call);\n-      merge_with_ssa_name (name, lhs, deref);\n+      if (direct)\n+\tmerge_with_ssa_name (name, lhs, false);\n+      if (indirect)\n+\tmerge_with_ssa_name (name, lhs, true);\n     }\n   /* In the case of memory store we can do nothing.  */\n-  else if (deref)\n+  else if (!direct)\n     m_lattice[index].merge (deref_flags (0, false));\n   else\n     m_lattice[index].merge (0);\n@@ -1782,18 +1788,19 @@ callee_to_caller_flags (int call_flags, bool ignore_stores,\n {\n   /* call_flags is about callee returning a value\n      that is not the same as caller returning it.  */\n-  call_flags |= EAF_NOT_RETURNED\n-\t\t| EAF_NOT_RETURNED_DIRECTLY;\n+  call_flags |= EAF_NOT_RETURNED_DIRECTLY\n+\t\t| EAF_NOT_RETURNED_INDIRECTLY;\n   /* TODO: We miss return value propagation.\n      Be conservative and if value escapes to memory\n      also mark it as escaping.  */\n   if (!ignore_stores && !(call_flags & EAF_UNUSED))\n     {\n-      if (!(call_flags & EAF_NOESCAPE))\n-\tlattice.merge (~(EAF_NOT_RETURNED | EAF_UNUSED));\n-      if (!(call_flags & (EAF_NODIRECTESCAPE | EAF_NOESCAPE)))\n+      if (!(call_flags & EAF_NO_DIRECT_ESCAPE))\n \tlattice.merge (~(EAF_NOT_RETURNED_DIRECTLY\n-\t\t\t | EAF_NOT_RETURNED\n+\t\t\t | EAF_NOT_RETURNED_INDIRECTLY\n+\t\t\t | EAF_UNUSED));\n+      if (!(call_flags & EAF_NO_INDIRECT_ESCAPE))\n+\tlattice.merge (~(EAF_NOT_RETURNED_INDIRECTLY\n \t\t\t | EAF_UNUSED));\n     }\n   else\n@@ -1869,13 +1876,13 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n \t    ;\n \t  else if (gimple_return_retval (ret) == name)\n-\t    m_lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n+\t    m_lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED_DIRECTLY\n \t\t\t\t      | EAF_NOT_RETURNED_DIRECTLY));\n \t  else if (memory_access_to (gimple_return_retval (ret), name))\n \t    {\n \t      m_lattice[index].merge_direct_load ();\n-\t      m_lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n-\t\t\t\t\t| EAF_NOT_RETURNED_DIRECTLY));\n+\t      m_lattice[index].merge (~(EAF_UNUSED\n+\t\t\t\t\t| EAF_NOT_RETURNED_INDIRECTLY));\n \t    }\n \t}\n       /* Account for LHS store, arg loads and flags from callee function.  */\n@@ -1889,7 +1896,7 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t     is on since that would allow propagation of this from -fno-ipa-pta\n \t     to -fipa-pta functions.  */\n \t  if (gimple_call_fn (use_stmt) == name)\n-\t    m_lattice[index].merge (~(EAF_NOCLOBBER | EAF_UNUSED));\n+\t    m_lattice[index].merge (~(EAF_NO_DIRECT_CLOBBER | EAF_UNUSED));\n \n \t  /* Recursion would require bit of propagation; give up for now.  */\n \t  if (callee && !m_ipa && recursive_call_p (current_function_decl,\n@@ -1932,14 +1939,14 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\t\t arg is written to itself which is an escape.  */\n \t\t      if (!isretslot)\n \t\t\t{\n-\t\t\t  if (!(call_flags & (EAF_NOT_RETURNED | EAF_UNUSED)))\n-\t\t\t    m_lattice[index].merge (~(EAF_NOESCAPE\n-\t\t\t\t\t\t      | EAF_UNUSED));\n \t\t\t  if (!(call_flags & (EAF_NOT_RETURNED_DIRECTLY\n-\t\t\t\t\t      | EAF_UNUSED\n-\t\t\t\t\t      | EAF_NOT_RETURNED)))\n-\t\t\t    m_lattice[index].merge (~(EAF_NODIRECTESCAPE\n-\t\t\t\t\t\t      | EAF_NOESCAPE\n+\t\t\t\t\t      | EAF_UNUSED)))\n+\t\t\t    m_lattice[index].merge (~(EAF_NO_DIRECT_ESCAPE\n+\t\t\t\t\t\t      | EAF_NO_INDIRECT_ESCAPE\n+\t\t\t\t\t\t      | EAF_UNUSED));\n+\t\t\t  if (!(call_flags & (EAF_NOT_RETURNED_INDIRECTLY\n+\t\t\t\t\t      | EAF_UNUSED)))\n+\t\t\t    m_lattice[index].merge (~(EAF_NO_INDIRECT_ESCAPE\n \t\t\t\t\t\t      | EAF_UNUSED));\n \t\t\t  call_flags = callee_to_caller_flags\n \t\t\t\t\t   (call_flags, false,\n@@ -1953,9 +1960,11 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\t  && (gimple_call_chain (call) == name))\n \t\t{\n \t\t  int call_flags = gimple_call_static_chain_flags (call);\n-\t\t  if (!ignore_retval\n-\t\t       && !(call_flags & (EAF_NOT_RETURNED | EAF_UNUSED)))\n-\t\t    merge_call_lhs_flags (call, -1, name, false);\n+\t\t  if (!ignore_retval && !(call_flags & EAF_UNUSED))\n+\t\t    merge_call_lhs_flags\n+\t\t\t (call, -1, name,\n+\t\t\t  !(call_flags & EAF_NOT_RETURNED_DIRECTLY),\n+\t\t\t  !(call_flags & EAF_NOT_RETURNED_INDIRECTLY));\n \t\t  call_flags = callee_to_caller_flags\n \t\t\t\t   (call_flags, ignore_stores,\n \t\t\t\t    m_lattice[index]);\n@@ -1974,11 +1983,11 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\tif (gimple_call_arg (call, i) == name)\n \t\t  {\n \t\t    int call_flags = gimple_call_arg_flags (call, i);\n-\t\t    if (!ignore_retval && !(call_flags\n-\t\t\t\t\t    & (EAF_NOT_RETURNED | EAF_UNUSED)))\n+\t\t    if (!ignore_retval && !(call_flags & EAF_UNUSED))\n \t\t      merge_call_lhs_flags\n \t\t\t      (call, i, name,\n-\t\t\t       call_flags & EAF_NOT_RETURNED_DIRECTLY);\n+\t\t\t       !(call_flags & EAF_NOT_RETURNED_DIRECTLY),\n+\t\t\t       !(call_flags & EAF_NOT_RETURNED_INDIRECTLY));\n \t\t    if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS)))\n \t\t      {\n \t\t\tcall_flags = callee_to_caller_flags\n@@ -1996,9 +2005,10 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\t  {\n \t\t    int call_flags = deref_flags\n \t\t\t    (gimple_call_arg_flags (call, i), ignore_stores);\n-\t\t    if (!ignore_retval\n-\t\t\t && !(call_flags & (EAF_NOT_RETURNED | EAF_UNUSED)))\n-\t\t      merge_call_lhs_flags (call, i, name, true);\n+\t\t    if (!ignore_retval && !(call_flags & EAF_UNUSED)\n+\t\t\t&& !(call_flags & EAF_NOT_RETURNED_DIRECTLY)\n+\t\t\t&& !(call_flags & EAF_NOT_RETURNED_INDIRECTLY))\n+\t\t      merge_call_lhs_flags (call, i, name, false, true);\n \t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n \t\t      m_lattice[index].merge_direct_load ();\n \t\t    else\n@@ -2281,8 +2291,7 @@ modref_eaf_analysis::propagate ()\n \t\t      fprintf (dump_file, \"   New lattice: \");\n \t\t      m_lattice[target].dump (dump_file);\n \t\t    }\n-\t\t  if (target <= (int)i)\n-\t\t    changed = true;\n+\t\t  changed = true;\n \t\t  m_lattice[target].changed = true;\n \t\t}\n \t    }\n@@ -2820,6 +2829,14 @@ modref_generate (void)\n \n }  /* ANON namespace.  */\n \n+/* Debugging helper.  */\n+\n+void\n+debug_eaf_flags (int flags)\n+{\n+   dump_eaf_flags (stderr, flags, true);\n+}\n+\n /* Called when a new function is inserted to callgraph late.  */\n \n void\n@@ -4232,7 +4249,8 @@ modref_merge_call_site_flags (escape_summary *sum,\n       int flags = 0;\n       int flags_lto = 0;\n       /* Returning the value is already accounted to at local propagation.  */\n-      int implicit_flags = EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY;\n+      int implicit_flags = EAF_NOT_RETURNED_DIRECTLY\n+\t\t\t   | EAF_NOT_RETURNED_INDIRECTLY;\n \n       if (summary && ee->arg < summary->arg_flags.length ())\n \tflags = summary->arg_flags[ee->arg];\n@@ -4263,11 +4281,15 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t      else\n \t\t{\n \t\t  if (fnspec.arg_direct_p (ee->arg))\n-\t\t    fnspec_flags |= EAF_DIRECT;\n+\t\t    fnspec_flags |= EAF_NO_INDIRECT_READ\n+\t\t\t     | EAF_NO_INDIRECT_ESCAPE\n+\t\t\t     | EAF_NOT_RETURNED_INDIRECTLY\n+\t\t\t     | EAF_NO_INDIRECT_CLOBBER;\n \t\t  if (fnspec.arg_noescape_p (ee->arg))\n-\t\t    fnspec_flags |= EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n+\t\t    fnspec_flags |= EAF_NO_DIRECT_ESCAPE\n+\t\t\t\t    | EAF_NO_INDIRECT_ESCAPE;\n \t\t  if (fnspec.arg_readonly_p (ee->arg))\n-\t\t    fnspec_flags |= EAF_NOCLOBBER;\n+\t\t    flags |= EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER;\n \t\t}\n \t    }\n \t  implicit_flags |= fnspec_flags;\n@@ -4281,16 +4303,6 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  flags = interposable_eaf_flags (flags, implicit_flags);\n \t  flags_lto = interposable_eaf_flags (flags_lto, implicit_flags);\n \t}\n-      /* Noescape implies that value also does not escape directly.\n-\t Fnspec machinery does set both so compensate for this.  */\n-      if (flags & EAF_NOESCAPE)\n-\tflags |= EAF_NODIRECTESCAPE;\n-      if (flags_lto & EAF_NOESCAPE)\n-\tflags_lto |= EAF_NODIRECTESCAPE;\n-      if (flags & EAF_NOT_RETURNED)\n-\tflags |= EAF_NOT_RETURNED_DIRECTLY;\n-      if (flags_lto & EAF_NOT_RETURNED)\n-\tflags_lto |= EAF_NOT_RETURNED_DIRECTLY;\n       if (!(flags & EAF_UNUSED)\n \t  && cur_summary && ee->parm_index < (int)cur_summary->arg_flags.length ())\n \t{\n@@ -4695,8 +4707,6 @@ ipa_modref_c_finalize ()\n   if (optimization_summaries)\n     ggc_delete (optimization_summaries);\n   optimization_summaries = NULL;\n-  gcc_checking_assert (!summaries\n-\t\t       || flag_incremental_link == INCREMENTAL_LINK_LTO);\n   if (summaries_lto)\n     ggc_delete (summaries_lto);\n   summaries_lto = NULL;"}, {"sha": "482c4e4633e6dec41af953b83a64e653def2b605", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define IPA_MODREF_H\n \n typedef modref_tree <alias_set_type> modref_records;\n-typedef unsigned char eaf_flags_t;\n+typedef unsigned short eaf_flags_t;\n \n /* Single function summary.  */\n \n@@ -48,15 +48,28 @@ void ipa_modref_c_finalize ();\n void ipa_merge_modref_summary_after_inlining (cgraph_edge *e);\n \n /* All flags that are implied by the ECF_CONST functions.  */\n-static const int implicit_const_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t     | EAF_NODIRECTESCAPE | EAF_NOREAD;\n+static const int implicit_const_eaf_flags\n+   = EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER\n+    | EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE\n+    | EAF_NO_DIRECT_READ | EAF_NO_INDIRECT_READ\n+    | EAF_NOT_RETURNED_INDIRECTLY;\n+\n /* All flags that are implied by the ECF_PURE function.  */\n-static const int implicit_pure_eaf_flags = EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t    | EAF_NODIRECTESCAPE;\n+static const int implicit_pure_eaf_flags\n+   = EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER\n+    | EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE;\n+\n /* All flags implied when we know we can ignore stores (i.e. when handling\n    call to noreturn).  */\n-static const int ignore_stores_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t    | EAF_NODIRECTESCAPE;\n+static const int ignore_stores_eaf_flags\n+   = EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER\n+    | EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE;\n+\n+/* Return slot is write-only.  */\n+static const int implicit_retslot_eaf_flags\n+   = EAF_NO_DIRECT_READ | EAF_NO_INDIRECT_READ\n+     | EAF_NO_INDIRECT_ESCAPE | EAF_NO_INDIRECT_CLOBBER\n+     | EAF_NOT_RETURNED_INDIRECTLY;\n \n /* If function does not bind to current def (i.e. it is inline in comdat\n    section), the modref analysis may not match the behaviour of function\n@@ -74,16 +87,15 @@ interposable_eaf_flags (int modref_flags, int flags)\n   if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n     {\n       modref_flags &= ~EAF_UNUSED;\n-      modref_flags |= EAF_NOESCAPE | EAF_NOT_RETURNED\n-\t\t      | EAF_NOT_RETURNED_DIRECTLY | EAF_NOCLOBBER;\n+      modref_flags |= EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE\n+\t\t      | EAF_NOT_RETURNED_DIRECTLY | EAF_NOT_RETURNED_INDIRECTLY\n+\t\t      | EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER;\n     }\n   /* We can not deterine that value is not read at all.  */\n-  if ((modref_flags & EAF_NOREAD) && !(flags & EAF_NOREAD))\n-    modref_flags &= ~EAF_NOREAD;\n-  /* Clear direct flags so we also know that value is possibly read\n-     indirectly.  */\n-  if ((modref_flags & EAF_DIRECT) && !(flags & EAF_DIRECT))\n-    modref_flags &= ~EAF_DIRECT;\n+  if ((modref_flags & EAF_NO_DIRECT_READ) && !(flags & EAF_NO_DIRECT_READ))\n+    modref_flags &= ~EAF_NO_DIRECT_READ;\n+  if ((modref_flags & EAF_NO_INDIRECT_READ) && !(flags & EAF_NO_INDIRECT_READ))\n+    modref_flags &= ~EAF_NO_INDIRECT_READ;\n   return modref_flags;\n }\n "}, {"sha": "c57aaca02303e9eb093030ac6eb2c757bfa7ebc6", "filename": "gcc/testsuite/g++.dg/ipa/modref-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -31,5 +31,5 @@ int main()\n \treturn 0;\n }\n /* { dg-final { scan-tree-dump \"Function found to be const: {anonymous}::B::genB\" \"local-pure-const1\"  } } */\n-/* { dg-final { scan-tree-dump \"Retslot flags: direct noescape nodirectescape not_returned not_returned_directly noread\" \"modref1\" } } */\n+/* { dg-final { scan-tree-dump \"Retslot flags: no_indirect_clobber no_direct_escape no_indirect_escape not_returned_directly not_returned_indirectly no_direct_read no_indirect_read\" \"modref1\" } } */\n   "}, {"sha": "9a20e018ae1f3462c09e269e7b060debf7c92404", "filename": "gcc/testsuite/gcc.dg/ipa/modref-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-3.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -17,4 +17,4 @@ main ()\n     linker_error ();\n   return 0;\n }\n-/* { dg-final { scan-ipa-dump \"Static chain flags: noclobber noescape nodirectescape\" \"modref\" } } */\n+/* { dg-final { scan-ipa-dump \"Static chain flags: no_direct_clobber no_indirect_clobber no_direct_escape no_indirect_escape not_returned_directly no_indirect_read\" \"modref\" } } */"}, {"sha": "0210d1151114e8e4d770ce3c7dc2008a04cbc15a", "filename": "gcc/testsuite/gcc.dg/lto/modref-3_0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-3_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-3_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-3_0.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -14,4 +14,4 @@ main()\n     __builtin_abort ();\n   return 0;\n }\n-/* { dg-final { scan-wpa-ipa-dump \"parm 1 flags: nodirectescape\"  \"modref\"  } } */\n+/* { dg-final { scan-wpa-ipa-dump \"parm 1 flags: no_direct_clobber no_direct_escape\"  \"modref\"  } } */"}, {"sha": "943758511462b3e9e4c656440e0a75a515de907c", "filename": "gcc/testsuite/gcc.dg/lto/modref-4_0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-4_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-4_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fmodref-4_0.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -14,4 +14,4 @@ main()\n     __builtin_abort ();\n   return 0;\n }\n-/* { dg-final { scan-wpa-ipa-dump \"parm 1 flags: nodirectescape\"  \"modref\"  } } */\n+/* { dg-final { scan-wpa-ipa-dump \"parm 1 flags: no_direct_clobber no_direct_escape\"  \"modref\"  } } */"}, {"sha": "4a6d9e54c23399034539ec9255f4f7115b5e5d48", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-10.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -17,4 +17,4 @@ main()\n \t\tlinker_error ();\n \treturn 0;\n }\n-/* { dg-final { scan-tree-dump \"parm 0 flags: noclobber noescape nodirectescape not_returned_directly\" \"modref1\"} } */\n+/* { dg-final { scan-tree-dump \"no_direct_clobber no_indirect_clobber no_direct_escape no_indirect_escape not_returned_directly no_indirect_read\" \"modref1\"} } */"}, {"sha": "cafb4f34894544299d0199abc4375ccdabfb3b77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-11.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -10,4 +10,4 @@ find_last (struct linkedlist *l)\n    l = l->next;\n   return l;\n }\n-/* { dg-final { scan-tree-dump \"noclobber noescape nodirectescape\" \"modref1\"} } */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: no_direct_clobber no_indirect_clobber no_direct_escape no_indirect_escape\" \"modref1\"} } */"}, {"sha": "5a5750425d2da8a8d4aaf0a23b934a0edb64f98b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-13.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-13.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-release_ssa\"  } */\n+struct wrap {\n+\tvoid **array;\n+};\n+__attribute__ ((noinline))\n+void\n+write_array (struct wrap *ptr)\n+{\n+\tptr->array[0]=0;\n+}\n+int\n+test ()\n+{\n+\tvoid *arrayval;\n+\tstruct wrap w = {&arrayval};\n+\twrite_array (&w);\n+\treturn w.array == &arrayval;\n+}\n+/* We should deterine that write_array writes to PTR only indirectly.  */\n+/* { dg-final { scan-tree-dump \"return 1\" \"releae_ssa\"  } } */"}, {"sha": "0bee79d769d5a15e5ed14d4ed05bbabd73efce7e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-5.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -24,4 +24,4 @@ main()\n     __builtin_abort ();\n   return 0;\n }\n-/* { dg-final { scan-tree-dump \"parm 1 flags: nodirectescape\" \"modref1\"  } } */\n+/* { dg-final { scan-tree-dump \"parm 1 flags: no_direct_clobber no_direct_escape\" \"modref1\"  } } */"}, {"sha": "7146389a5b413937b68551a44230c7669452e62a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-6.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-6.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -28,10 +28,10 @@ int test2()\n    return a;\n }\n /* Flags for normal call.  */\n-/* { dg-final { scan-tree-dump \"parm 0 flags: direct noclobber noescape nodirectescape not_returned\" \"modref1\"  } } */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: no_direct_clobber no_indirect_clobber no_direct_escape no_indirect_escape not_returned_directly not_returned_indirectly no_indirect_read\" \"modref1\"  } } */\n /* Flags for pure call.  */\n-/* { dg-final { scan-tree-dump \"parm 0 flags: direct not_returned\" \"modref1\"  } } */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: not_returned_directly not_returned_indirectly no_indirect_read\" \"modref1\"  } } */\n /* Flags for const call.  */\n-/* { dg-final { scan-tree-dump \"parm 0 flags: not_returned\" \"modref1\"  } } */\n+/* { dg-final { scan-tree-dump \"parm 0 flags: not_returned_directly\" \"modref1\"  } } */\n /* Overall we want to make \"int a\" non escaping.  */\n /* { dg-final { scan-tree-dump \"return 42\" \"optimized\"  } } */"}, {"sha": "8ab119dc9a2a548ccf29ca7579c85e13845db26f", "filename": "gcc/tree-core.h", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -97,32 +97,29 @@ struct die_struct;\n #define ECF_COLD\t\t  (1 << 15)\n \n /* Call argument flags.  */\n-/* Nonzero if the argument is not dereferenced recursively, thus only\n-   directly reachable memory is read or written.  */\n-#define EAF_DIRECT\t\t(1 << 0)\n \n-/* Nonzero if memory reached by the argument is not clobbered.  */\n-#define EAF_NOCLOBBER\t\t(1 << 1)\n+/* Nonzero if the argument is not used by the function.  */\n+#define EAF_UNUSED\t\t(1 << 1)\n \n-/* Nonzero if the argument does not escape.  */\n-#define EAF_NOESCAPE\t\t(1 << 2)\n+/* Following flags come in pairs.  First one is about direct dereferences\n+   from the parameter, while the second is about memory reachable by\n+   recursive dereferences.  */\n \n-/* Nonzero if the argument is not used by the function.  */\n-#define EAF_UNUSED\t\t(1 << 3)\n+/* Nonzero if memory reached by the argument is not clobbered.  */\n+#define EAF_NO_DIRECT_CLOBBER\t(1 << 2)\n+#define EAF_NO_INDIRECT_CLOBBER\t(1 << 3)\n \n-/* Nonzero if the argument itself does not escape but memory\n-   referenced by it can escape.  */\n-#define EAF_NODIRECTESCAPE\t(1 << 4)\n+/* Nonzero if the argument does not escape.  */\n+#define EAF_NO_DIRECT_ESCAPE\t(1 << 4)\n+#define EAF_NO_INDIRECT_ESCAPE\t(1 << 5)\n \n /* Nonzero if the argument does not escape to return value.  */\n-#define EAF_NOT_RETURNED\t(1 << 5)\n-\n-/* Nonzero if the argument itself does not escape\n-   to return value but memory referenced by it may escape.  */\n #define EAF_NOT_RETURNED_DIRECTLY (1 << 6)\n+#define EAF_NOT_RETURNED_INDIRECTLY (1 << 7)\n \n /* Nonzero if the argument is not read.  */\n-#define EAF_NOREAD\t\t(1 << 7)\n+#define EAF_NO_DIRECT_READ\t(1 << 8)\n+#define EAF_NO_INDIRECT_READ\t(1 << 9)\n \n /* Call return flags.  */\n /* Mask for the argument number that is returned.  Lower two bits of"}, {"sha": "17ff6bb582cfa359c7c9d3180cfc238e4ee8f92a", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -2874,7 +2874,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       tree op = gimple_call_arg (call, i);\n       int flags = gimple_call_arg_flags (call, i);\n \n-      if (flags & (EAF_UNUSED | EAF_NOREAD))\n+      if (flags & (EAF_UNUSED | EAF_NO_DIRECT_READ))\n \tcontinue;\n \n       if (TREE_CODE (op) == WITH_SIZE_EXPR)"}, {"sha": "153ddf57a61ce5f72daf9e557b9d33fa96dffb65", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 115, "deletions": 27, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -4060,48 +4060,117 @@ static void\n handle_call_arg (gcall *stmt, tree arg, vec<ce_s> *results, int flags,\n \t\t int callescape_id, bool writes_global_memory)\n {\n+  int relevant_indirect_flags = EAF_NO_INDIRECT_CLOBBER | EAF_NO_INDIRECT_READ\n+\t\t\t\t| EAF_NO_INDIRECT_ESCAPE;\n+  int relevant_flags = relevant_indirect_flags\n+\t\t       | EAF_NO_DIRECT_CLOBBER\n+\t\t       | EAF_NO_DIRECT_READ\n+\t\t       | EAF_NO_DIRECT_ESCAPE;\n+  if (gimple_call_lhs (stmt))\n+    {\n+      relevant_flags |= EAF_NOT_RETURNED_DIRECTLY | EAF_NOT_RETURNED_INDIRECTLY;\n+      relevant_indirect_flags |= EAF_NOT_RETURNED_INDIRECTLY;\n+\n+      /* If value is never read from it can not be returned indirectly\n+\t (except through the escape solution).\n+\t For all flags we get these implications right except for\n+\t not_returned because we miss return functions in ipa-prop.  */\n+\t \n+      if (flags & EAF_NO_DIRECT_READ)\n+\tflags |= EAF_NOT_RETURNED_INDIRECTLY;\n+    }\n+\n   /* If the argument is not used we can ignore it.\n      Similarly argument is invisile for us if it not clobbered, does not\n      escape, is not read and can not be returned.  */\n-  if ((flags & EAF_UNUSED)\n-      || ((flags & (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n-\t\t    | EAF_NOT_RETURNED))\n-\t  == (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n-\t      | EAF_NOT_RETURNED)))\n+  if ((flags & EAF_UNUSED) || ((flags & relevant_flags) == relevant_flags))\n     return;\n \n+  /* Produce varinfo for direct accesses to ARG.  */\n   varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n   tem->is_reg_var = true;\n   make_constraint_to (tem->id, arg);\n   make_any_offset_constraints (tem);\n \n-  if (!(flags & EAF_DIRECT))\n-    make_transitive_closure_constraints (tem);\n+  bool callarg_transitive = false;\n+\n+  /* As an compile time optimization if we make no difference between\n+     direct and indirect accesses make arg transitively closed.\n+     This avoids the need to build indir arg and do everything twice.  */\n+  if (((flags & EAF_NO_INDIRECT_CLOBBER) != 0)\n+      == ((flags & EAF_NO_DIRECT_CLOBBER) != 0)\n+      && (((flags & EAF_NO_INDIRECT_READ) != 0)\n+\t  == ((flags & EAF_NO_DIRECT_READ) != 0))\n+      && (((flags & EAF_NO_INDIRECT_ESCAPE) != 0)\n+\t  == ((flags & EAF_NO_DIRECT_ESCAPE) != 0))\n+      && (((flags & EAF_NOT_RETURNED_INDIRECTLY) != 0)\n+\t  == ((flags & EAF_NOT_RETURNED_DIRECTLY) != 0)))\n+    {\n+      make_transitive_closure_constraints (tem);\n+      callarg_transitive = true;\n+      gcc_checking_assert (!(flags & EAF_NO_DIRECT_READ));\n+    }\n+\n+  /* If necessary, produce varinfo for indirect accesses to ARG.  */\n+  varinfo_t indir_tem = NULL;\n+  if (!callarg_transitive\n+      && (flags & relevant_indirect_flags) != relevant_indirect_flags)\n+    {\n+      struct constraint_expr lhs, rhs;\n+      indir_tem = new_var_info (NULL_TREE, \"indircallarg\", true);\n+      indir_tem->is_reg_var = true;\n+\n+      /* indir_term = *tem.  */\n+      lhs.type = SCALAR;\n+      lhs.var = indir_tem->id;\n+      lhs.offset = 0;\n+\n+      rhs.type = DEREF;\n+      rhs.var = tem->id;\n+      rhs.offset = UNKNOWN_OFFSET;\n+      process_constraint (new_constraint (lhs, rhs));\n+\n+      make_any_offset_constraints (indir_tem);\n \n-  if (!(flags & EAF_NOT_RETURNED))\n+      /* If we do not read indirectly there is no need for transitive closure.\n+\t We know there is only one level of indirection.  */\n+      if (!(flags & EAF_NO_INDIRECT_READ))\n+\tmake_transitive_closure_constraints (indir_tem);\n+      gcc_checking_assert (!(flags & EAF_NO_DIRECT_READ));\n+    }\n+\n+  if (gimple_call_lhs (stmt))\n     {\n-      struct constraint_expr cexpr;\n-      cexpr.var = tem->id;\n-      if (flags & EAF_NOT_RETURNED_DIRECTLY)\n+      if (!(flags & EAF_NOT_RETURNED_DIRECTLY))\n \t{\n-\t  cexpr.type = DEREF;\n-\t  cexpr.offset = UNKNOWN_OFFSET;\n+\t  struct constraint_expr cexpr;\n+\t  cexpr.var = tem->id;\n+\t  cexpr.type = SCALAR;\n+\t  cexpr.offset = 0;\n+\t  results->safe_push (cexpr);\n \t}\n-      else\n+      if (!callarg_transitive & !(flags & EAF_NOT_RETURNED_INDIRECTLY))\n \t{\n+\t  struct constraint_expr cexpr;\n+\t  cexpr.var = indir_tem->id;\n \t  cexpr.type = SCALAR;\n \t  cexpr.offset = 0;\n+\t  results->safe_push (cexpr);\n \t}\n-      results->safe_push (cexpr);\n     }\n \n-  if (!(flags & EAF_NOREAD))\n+  if (!(flags & EAF_NO_DIRECT_READ))\n     {\n       varinfo_t uses = get_call_use_vi (stmt);\n       make_copy_constraint (uses, tem->id);\n+      if (!callarg_transitive & !(flags & EAF_NO_INDIRECT_READ))\n+\tmake_copy_constraint (uses, indir_tem->id);\n     }\n+  else\n+    /* To read indirectly we need to read directly.  */\n+    gcc_checking_assert (flags & EAF_NO_INDIRECT_READ);\n \n-  if (!(flags & EAF_NOCLOBBER))\n+  if (!(flags & EAF_NO_DIRECT_CLOBBER))\n     {\n       struct constraint_expr lhs, rhs;\n \n@@ -4118,8 +4187,25 @@ handle_call_arg (gcall *stmt, tree arg, vec<ce_s> *results, int flags,\n       /* callclobbered = arg.  */\n       make_copy_constraint (get_call_clobber_vi (stmt), tem->id);\n     }\n+  if (!callarg_transitive & !(flags & EAF_NO_INDIRECT_CLOBBER))\n+    {\n+      struct constraint_expr lhs, rhs;\n \n-  if (!(flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE)))\n+      /* *indir_arg = callescape.  */\n+      lhs.type = DEREF;\n+      lhs.var = indir_tem->id;\n+      lhs.offset = 0;\n+\n+      rhs.type = SCALAR;\n+      rhs.var = callescape_id;\n+      rhs.offset = 0;\n+      process_constraint (new_constraint (lhs, rhs));\n+\n+      /* callclobbered = indir_arg.  */\n+      make_copy_constraint (get_call_clobber_vi (stmt), indir_tem->id);\n+    }\n+\n+  if (!(flags & (EAF_NO_DIRECT_ESCAPE | EAF_NO_INDIRECT_ESCAPE)))\n     {\n       struct constraint_expr lhs, rhs;\n \n@@ -4136,18 +4222,18 @@ handle_call_arg (gcall *stmt, tree arg, vec<ce_s> *results, int flags,\n       if (writes_global_memory)\n \tmake_escape_constraint (arg);\n     }\n-  else if (!(flags & EAF_NOESCAPE))\n+  else if (!callarg_transitive & !(flags & EAF_NO_INDIRECT_ESCAPE))\n     {\n       struct constraint_expr lhs, rhs;\n \n-      /* callescape = *(arg + UNKNOWN);  */\n+      /* callescape = *(indir_arg + UNKNOWN);  */\n       lhs.var = callescape_id;\n       lhs.offset = 0;\n       lhs.type = SCALAR;\n \n-      rhs.var = tem->id;\n-      rhs.offset = UNKNOWN_OFFSET;\n-      rhs.type = DEREF;\n+      rhs.var = indir_tem->id;\n+      rhs.offset = 0;\n+      rhs.type = SCALAR;\n       process_constraint (new_constraint (lhs, rhs));\n \n       if (writes_global_memory)\n@@ -4264,20 +4350,22 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results,\n       && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n     {\n       int flags = gimple_call_retslot_flags (stmt);\n-      if ((flags & (EAF_NOESCAPE | EAF_NOT_RETURNED))\n-\t  != (EAF_NOESCAPE | EAF_NOT_RETURNED))\n+      const int relevant_flags = EAF_NO_DIRECT_ESCAPE\n+\t\t\t\t | EAF_NOT_RETURNED_DIRECTLY;\n+\n+      if (!(flags & EAF_UNUSED) && (flags & relevant_flags) != relevant_flags)\n \t{\n \t  auto_vec<ce_s> tmpc;\n \n \t  get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n \n-\t  if (!(flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE)))\n+\t  if (!(flags & EAF_NO_DIRECT_ESCAPE))\n \t    {\n \t      make_constraints_to (callescape->id, tmpc);\n \t      if (writes_global_memory)\n \t\tmake_constraints_to (escaped_id, tmpc);\n \t    }\n-\t  if (!(flags & EAF_NOT_RETURNED))\n+\t  if (!(flags & EAF_NOT_RETURNED_DIRECTLY))\n \t    {\n \t      struct constraint_expr *c;\n \t      unsigned i;"}, {"sha": "1df0bcc42c0558a797d8f527226267659a5afc6b", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ef65692fced7ab72e0aceeff7407e5a34d96d/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=d70ef65692fced7ab72e0aceeff7407e5a34d96d", "patch": "@@ -744,7 +744,8 @@ maybe_warn_pass_by_reference (gcall *stmt, wlimits &wlims)\n \twlims.always_executed = false;\n \n       /* Ignore args we are not going to read from.  */\n-      if (gimple_call_arg_flags (stmt, argno - 1) & (EAF_UNUSED | EAF_NOREAD))\n+      if (gimple_call_arg_flags (stmt, argno - 1)\n+\t  & (EAF_UNUSED | EAF_NO_DIRECT_READ))\n \tcontinue;\n \n       tree arg = gimple_call_arg (stmt, argno - 1);"}]}