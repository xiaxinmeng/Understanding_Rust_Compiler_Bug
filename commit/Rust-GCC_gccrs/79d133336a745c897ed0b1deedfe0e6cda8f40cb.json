{"sha": "79d133336a745c897ed0b1deedfe0e6cda8f40cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlkMTMzMzM2YTc0NWM4OTdlZDBiMWRlZWRmZTBlNmNkYThmNDBjYg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-08-19T20:37:04Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-08-19T20:37:04Z"}, "message": "re GNATS gcj/17 (Internal error: segfault on import-classname clash)\n\nThu Aug 19 10:26:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (method_header): Return a null pointer if the current\n        class node is null.\n        (finish_method_declaration): Return if the current function decl\n        is null.\n        (source_start_java_method): Likewise.\n        (java_method_add_stmt): Likewise.\n\nThis fixes the net PR #17.\n\nFrom-SVN: r28765", "tree": {"sha": "1ac66ba96f8381766f2d36c668fef7cd934a08a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac66ba96f8381766f2d36c668fef7cd934a08a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79d133336a745c897ed0b1deedfe0e6cda8f40cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d133336a745c897ed0b1deedfe0e6cda8f40cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d133336a745c897ed0b1deedfe0e6cda8f40cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d133336a745c897ed0b1deedfe0e6cda8f40cb/comments", "author": null, "committer": null, "parents": [{"sha": "852be00c009c96d573dacad6007a63f8076a6c9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852be00c009c96d573dacad6007a63f8076a6c9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852be00c009c96d573dacad6007a63f8076a6c9c"}], "stats": {"total": 67, "additions": 57, "deletions": 10}, "files": [{"sha": "de425bb782c2d08bebcbfb2f97c020d61dc55f0e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d133336a745c897ed0b1deedfe0e6cda8f40cb/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d133336a745c897ed0b1deedfe0e6cda8f40cb/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=79d133336a745c897ed0b1deedfe0e6cda8f40cb", "patch": "@@ -1,3 +1,12 @@\n+Thu Aug 19 10:26:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (method_header): Return a null pointer if the current\n+ \tclass node is null.\n+\t(finish_method_declaration): Return if the current function decl\n+ \tis null.\n+\t(source_start_java_method): Likewise.\n+\t(java_method_add_stmt): Likewise.\n+\n Wed Aug 18 13:17:15 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* class.c (emit_register_class): Removed unnecessary call to"}, {"sha": "2c7cf889851969e11e568fdab456af7fea4e86e2", "filename": "gcc/java/parse.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d133336a745c897ed0b1deedfe0e6cda8f40cb/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d133336a745c897ed0b1deedfe0e6cda8f40cb/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=79d133336a745c897ed0b1deedfe0e6cda8f40cb", "patch": "@@ -2231,7 +2231,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 3 \"/usr/share/misc/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2248,7 +2248,7 @@ static const short yycheck[] = {     3,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n@@ -2382,8 +2382,10 @@ int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n \n /* Prevent warning if -Wstrict-prototypes.  */\n #ifdef __GNUC__\n+#ifndef YYPARSE_PARAM\n int yyparse (void);\n #endif\n+#endif\n \f\n #if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n #define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n@@ -2424,7 +2426,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 196 \"/usr/share/misc/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4713,7 +4715,7 @@ case 495:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 498 \"/usr/share/misc/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -5922,13 +5924,18 @@ method_header (flags, type, mdecl, throws)\n {\n   tree meth = TREE_VALUE (mdecl);\n   tree id = TREE_PURPOSE (mdecl);\n-  tree this_class = TREE_TYPE (ctxp->current_parsed_class);\n   tree type_wfl = NULL_TREE;\n-  tree meth_name = NULL_TREE, current, orig_arg;\n+  tree meth_name = NULL_TREE;\n+  tree current, orig_arg, this_class;\n   int saved_lineno;\n   int constructor_ok = 0, must_chain;\n   \n   check_modifiers_consistency (flags);\n+\n+  if (ctxp->current_parsed_class)\n+    this_class = TREE_TYPE (ctxp->current_parsed_class);\n+  else\n+    return NULL_TREE;\n   \n   /* There are some forbidden modifiers for an abstract method and its\n      class must be abstract as well.  */\n@@ -6124,7 +6131,12 @@ static void\n finish_method_declaration (method_body)\n      tree method_body;\n {\n-  int flags = get_access_flags_from_decl (current_function_decl);\n+  int flags;\n+\n+  if (!current_function_decl)\n+    return;\n+\n+  flags = get_access_flags_from_decl (current_function_decl);\n \n   /* 8.4.5 Method Body */\n   if ((flags & ACC_ABSTRACT || flags & ACC_NATIVE) && method_body)\n@@ -8101,6 +8113,9 @@ source_start_java_method (fndecl)\n   tree parm_decl;\n   int i;\n \n+  if (!fndecl)\n+    return;\n+\n   current_function_decl = fndecl;\n \n   /* New scope for the function */\n@@ -8219,6 +8234,9 @@ source_end_java_method ()\n   tree fndecl = current_function_decl;\n   int flag_asynchronous_exceptions = asynchronous_exceptions;\n \n+  if (!fndecl)\n+    return;\n+\n   java_parser_context_save_global ();\n   lineno = ctxp->last_ccb_indent1;\n \n@@ -8274,6 +8292,8 @@ tree\n java_method_add_stmt (fndecl, expr)\n      tree fndecl, expr;\n {\n+  if (!fndecl)\n+    return NULL;\n   return add_stmt_to_block (GET_CURRENT_BLOCK (fndecl), NULL_TREE, expr);\n }\n "}, {"sha": "d62b2770b66c0f17d127ce139bd981afb96eca7f", "filename": "gcc/java/parse.y", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d133336a745c897ed0b1deedfe0e6cda8f40cb/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d133336a745c897ed0b1deedfe0e6cda8f40cb/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=79d133336a745c897ed0b1deedfe0e6cda8f40cb", "patch": "@@ -3337,13 +3337,18 @@ method_header (flags, type, mdecl, throws)\n {\n   tree meth = TREE_VALUE (mdecl);\n   tree id = TREE_PURPOSE (mdecl);\n-  tree this_class = TREE_TYPE (ctxp->current_parsed_class);\n   tree type_wfl = NULL_TREE;\n-  tree meth_name = NULL_TREE, current, orig_arg;\n+  tree meth_name = NULL_TREE;\n+  tree current, orig_arg, this_class;\n   int saved_lineno;\n   int constructor_ok = 0, must_chain;\n   \n   check_modifiers_consistency (flags);\n+\n+  if (ctxp->current_parsed_class)\n+    this_class = TREE_TYPE (ctxp->current_parsed_class);\n+  else\n+    return NULL_TREE;\n   \n   /* There are some forbidden modifiers for an abstract method and its\n      class must be abstract as well.  */\n@@ -3539,7 +3544,12 @@ static void\n finish_method_declaration (method_body)\n      tree method_body;\n {\n-  int flags = get_access_flags_from_decl (current_function_decl);\n+  int flags;\n+\n+  if (!current_function_decl)\n+    return;\n+\n+  flags = get_access_flags_from_decl (current_function_decl);\n \n   /* 8.4.5 Method Body */\n   if ((flags & ACC_ABSTRACT || flags & ACC_NATIVE) && method_body)\n@@ -5516,6 +5526,9 @@ source_start_java_method (fndecl)\n   tree parm_decl;\n   int i;\n \n+  if (!fndecl)\n+    return;\n+\n   current_function_decl = fndecl;\n \n   /* New scope for the function */\n@@ -5634,6 +5647,9 @@ source_end_java_method ()\n   tree fndecl = current_function_decl;\n   int flag_asynchronous_exceptions = asynchronous_exceptions;\n \n+  if (!fndecl)\n+    return;\n+\n   java_parser_context_save_global ();\n   lineno = ctxp->last_ccb_indent1;\n \n@@ -5689,6 +5705,8 @@ tree\n java_method_add_stmt (fndecl, expr)\n      tree fndecl, expr;\n {\n+  if (!fndecl)\n+    return NULL;\n   return add_stmt_to_block (GET_CURRENT_BLOCK (fndecl), NULL_TREE, expr);\n }\n "}]}