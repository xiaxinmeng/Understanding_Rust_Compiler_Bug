{"sha": "1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYwNmVlOGQwZGI5Yzc0NDRlMmZmMjIxMGEyMWNjYTZjOTYwMjUxNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-01-15T18:43:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-15T18:43:47Z"}, "message": "expr.c (queued_subexp_p): Make public.\n\n        * expr.c (queued_subexp_p): Make public.\n        * expr.h (queued_subexp_p): Declare it.\n        * recog.c (asm_operand_ok): New function.\n        (check_asm_operands): Use it.  After reload, use constrain_operands\n        instead.\n        * recog.h (asm_operand_ok): Declare it.\n        * stmt.c (expand_asm_operands): Use it to try harder to make\n        asms initially satisfy their constraints.\n\nFrom-SVN: r24686", "tree": {"sha": "76723342d0b784ed2b82cb4bb0bd1558554ff0a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76723342d0b784ed2b82cb4bb0bd1558554ff0a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/comments", "author": null, "committer": null, "parents": [{"sha": "d3694e346d97482464bc724ebecab03f20bf602b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3694e346d97482464bc724ebecab03f20bf602b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3694e346d97482464bc724ebecab03f20bf602b"}], "stats": {"total": 345, "additions": 306, "deletions": 39}, "files": [{"sha": "199a8d42c21e6cf2e60e8726bd2fb620a6a50865", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "patch": "@@ -1,3 +1,14 @@\n+Fri Jan 15 18:42:12 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* expr.c (queued_subexp_p): Make public.\n+\t* expr.h (queued_subexp_p): Declare it.\n+\t* recog.c (asm_operand_ok): New function.\n+\t(check_asm_operands): Use it.  After reload, use constrain_operands \n+\tinstead.\n+\t* recog.h (asm_operand_ok): Declare it.\n+\t* stmt.c (expand_asm_operands): Use it to try harder to make\n+\tasms initially satisfy their constraints.\n+\n Fri Jan 15 17:43:59 1999  Jeffrey A. Law  <law@rtl.cygnus.com>\n \n \t* sparc.h (LEGITIMIZE_RELOAD_ADDRESS): Do not create"}, {"sha": "1d2a399bb492d17fce16f21b4974baeb85d91dd9", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "patch": "@@ -149,7 +149,6 @@ extern rtx arg_pointer_save_area;\n static rtx get_push_address\tPROTO ((int));\n \n static rtx enqueue_insn\t\tPROTO((rtx, rtx));\n-static int queued_subexp_p\tPROTO((rtx));\n static void init_queue\t\tPROTO((void));\n static int move_by_pieces_ninsns PROTO((unsigned int, int));\n static void move_by_pieces_1\tPROTO((rtx (*) (rtx, ...), enum machine_mode,\n@@ -478,7 +477,7 @@ protect_from_queue (x, modify)\n    We handle only combinations of MEM, PLUS, MINUS and MULT operators\n    since memory addresses generally contain only those.  */\n \n-static int\n+int\n queued_subexp_p (x)\n      rtx x;\n {"}, {"sha": "5b3293765169745d87b6ba862a31ca1c8cc2d9fb", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "patch": "@@ -716,6 +716,9 @@ extern rtx protect_from_queue PROTO((rtx, int));\n /* Perform all the pending incrementations.  */\n extern void emit_queue PROTO((void));\n \n+/* Tell if something has a queued subexpression.  */\n+extern int queued_subexp_p PROTO((rtx));\n+\n /* Emit some rtl insns to move data between rtx's, converting machine modes.\n    Both modes must be floating or both fixed.  */\n extern void convert_move PROTO((rtx, rtx, int));"}, {"sha": "0d87386cdb7ecb5fd8f7edaaa57e9a793983184d", "filename": "gcc/recog.c", "status": "modified", "additions": 222, "deletions": 5, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used by or related to instruction recognition.\n-   Copyright (C) 1987, 1988, 91-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 91-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -152,21 +152,40 @@ int\n check_asm_operands (x)\n      rtx x;\n {\n-  int noperands = asm_noperands (x);\n+  int noperands;\n   rtx *operands;\n+  char **constraints;\n   int i;\n \n+  /* Post-reload, be more strict with things.  */\n+  if (reload_completed)\n+    {\n+      /* ??? Doh!  We've not got the wrapping insn.  Cook one up.  */\n+      extract_insn (make_insn_raw (x));\n+      constrain_operands (1);\n+      return which_alternative >= 0;\n+    }\n+\n+  noperands = asm_noperands (x);\n   if (noperands < 0)\n     return 0;\n   if (noperands == 0)\n     return 1;\n \n   operands = (rtx *) alloca (noperands * sizeof (rtx));\n-  decode_asm_operands (x, operands, NULL_PTR, NULL_PTR, NULL_PTR);\n+  constraints = (char **) alloca (noperands * sizeof (char *));\n+\n+  decode_asm_operands (x, operands, NULL_PTR, constraints, NULL_PTR);\n \n   for (i = 0; i < noperands; i++)\n-    if (!general_operand (operands[i], VOIDmode))\n-      return 0;\n+    {\n+      char *c = constraints[i];\n+      if (ISDIGIT ((unsigned char)c[0]))\n+\tc = constraints[c[0] - '0'];\n+\n+      if (! asm_operand_ok (operands[i], c))\n+        return 0;\n+    }\n \n   return 1;\n }\n@@ -1493,6 +1512,204 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n \n   return template;\n }\n+\n+/* Check if an asm_operand matches it's constraints.  */\n+\n+int\n+asm_operand_ok (op, constraint)\n+     rtx op;\n+     const char *constraint;\n+{\n+  /* Use constrain_operands after reload.  */\n+  if (reload_completed)\n+    abort ();\n+\n+  while (*constraint)\n+    {\n+      switch (*constraint++)\n+\t{\n+\tcase '=':\n+\tcase '+':\n+\tcase '*':\n+\tcase '%':\n+\tcase '?':\n+\tcase '!':\n+\tcase '#':\n+\tcase '&':\n+\tcase ',':\n+\t  break;\n+\n+\tcase '0': case '1': case '2': case '3': case '4':\n+\tcase '5': case '6': case '7': case '8': case '9':\n+\t  /* Our caller is supposed to have given us the proper\n+\t     matching constraint.  */\n+\t  /* abort (); */\n+\t  break;\n+\n+\tcase 'p':\n+\t  if (address_operand (op, VOIDmode))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'm':\n+\tcase 'V': /* non-offsettable */\n+\t  if (memory_operand (op, VOIDmode))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'o': /* offsettable */\n+\t  if (offsettable_nonstrict_memref_p (op))\n+\t    return 1;\n+\t  break;\n+\n+\tcase '<':\n+\t  if (GET_CODE (op) == MEM\n+\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+                  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t    return 1;\n+\t  break;\n+\n+\tcase '>':\n+\t  if (GET_CODE (op) == MEM\n+\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+                  || GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'E':\n+#ifndef REAL_ARITHMETIC\n+\t  /* Match any floating double constant, but only if\n+\t     we can examine the bits of it reliably.  */\n+\t  if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+\t       || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n+\t      && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n+\t    break;\n+#endif\n+\t  /* FALLTHRU */\n+\n+\tcase 'F':\n+\t  if (GET_CODE (op) == CONST_DOUBLE)\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'G':\n+\t  if (GET_CODE (op) == CONST_DOUBLE\n+\t      && CONST_DOUBLE_OK_FOR_LETTER_P (op, 'G'))\n+\t    return 1;\n+\t  break;\n+\tcase 'H':\n+\t  if (GET_CODE (op) == CONST_DOUBLE\n+\t      && CONST_DOUBLE_OK_FOR_LETTER_P (op, 'H'))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 's':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      || (GET_CODE (op) == CONST_DOUBLE\n+\t\t  && GET_MODE (op) == VOIDmode))\n+\t    break;\n+\t  /* FALLTHRU */\n+\n+\tcase 'i':\n+\t  if (CONSTANT_P (op)\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+#endif\n+\t      )\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'n':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      || (GET_CODE (op) == CONST_DOUBLE\n+\t\t  && GET_MODE (op) == VOIDmode))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'I':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'I'))\n+\t    return 1;\n+\t  break;\n+\tcase 'J':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'J'))\n+\t    return 1;\n+\t  break;\n+\tcase 'K':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'K'))\n+\t    return 1;\n+\t  break;\n+\tcase 'L':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'))\n+\t    return 1;\n+\t  break;\n+\tcase 'M':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'M'))\n+\t    return 1;\n+\t  break;\n+\tcase 'N':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'N'))\n+\t    return 1;\n+\t  break;\n+\tcase 'O':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'O'))\n+\t    return 1;\n+\t  break;\n+\tcase 'P':\n+\t  if (GET_CODE (op) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'P'))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'X':\n+\t  return 1;\n+\n+\tcase 'g':\n+\t  if (general_operand (op, VOIDmode))\n+\t    return 1;\n+\t  break;\n+\n+#ifdef EXTRA_CONSTRAINT\n+\tcase 'Q':\n+\t  if (EXTRA_CONSTRAINT (op, 'Q'))\n+\t    return 1;\n+\t  break;\n+\tcase 'R':\n+\t  if (EXTRA_CONSTRAINT (op, 'R'))\n+\t    return 1;\n+\t  break;\n+\tcase 'S':\n+\t  if (EXTRA_CONSTRAINT (op, 'S'))\n+\t    return 1;\n+\t  break;\n+\tcase 'T':\n+\t  if (EXTRA_CONSTRAINT (op, 'T'))\n+\t    return 1;\n+\t  break;\n+\tcase 'U':\n+\t  if (EXTRA_CONSTRAINT (op, 'U'))\n+\t    return 1;\n+\t  break;\n+#endif\n+\n+\tcase 'r':\n+\tdefault:\n+\t  if (GET_MODE (op) == BLKmode)\n+\t    break;\n+\t  if (register_operand (op, VOIDmode))\n+\t    return 1;\n+\t  break;\n+\t}\n+    }\n+\n+  return 0;\n+}\n \f\n /* Given an rtx *P, if it is a sum containing an integer constant term,\n    return the location (type rtx *) of the pointer to that constant term."}, {"sha": "d85cc0f71e14ece284bf868883d499c6c63e1f47", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "patch": "@@ -70,6 +70,7 @@ extern void init_recog\t\t\tPROTO((void));\n extern void init_recog_no_volatile\tPROTO((void));\n extern int recog_memoized\t\tPROTO((rtx));\n extern int check_asm_operands\t\tPROTO((rtx));\n+extern int asm_operand_ok\t\tPROTO((rtx, const char *));\n extern int validate_change\t\tPROTO((rtx, rtx *, rtx, int));\n extern int apply_change_group\t\tPROTO((void));\n extern int num_validated_changes\tPROTO((void));"}, {"sha": "4e972e94606087ee329307457474188c4a93a776", "filename": "gcc/stmt.c", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f06ee8d0db9c7444e2ff2210a21cca6c9602517/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1f06ee8d0db9c7444e2ff2210a21cca6c9602517", "patch": "@@ -1397,9 +1397,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n     {\n       int j;\n-      int allows_reg = 0;\n-      char *constraint;\n+      int allows_reg = 0, allows_mem = 0;\n+      char *constraint, *orig_constraint;\n       int c_len;\n+      rtx op;\n \n       /* If there's an erroneous arg, emit no insn,\n \t because the ASM_INPUT would get VOIDmode\n@@ -1417,26 +1418,36 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       c_len = TREE_STRING_LENGTH (TREE_PURPOSE (tail)) - 1;\n       constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n+      orig_constraint = constraint;\n \n       /* Make sure constraint has neither `=', `+', nor '&'.  */\n \n       for (j = 0; j < c_len; j++)\n \tswitch (constraint[j])\n \t  {\n \t  case '+':  case '=':  case '&':\n-\t    error (\"input operand constraint contains `%c'\", constraint[j]);\n-\t    return;\n+\t    if (constraint == orig_constraint)\n+\t      {\n+\t        error (\"input operand constraint contains `%c'\", constraint[j]);\n+\t        return;\n+\t      }\n+\t    break;\n \n \t  case '%':\n-\t    if (i + 1 == ninputs - ninout)\n+\t    if (constraint == orig_constraint\n+\t\t&& i + 1 == ninputs - ninout)\n \t      {\n \t\terror (\"`%%' constraint used with last operand\");\n \t\treturn;\n \t      }\n \t    break;\n \n+\t  case 'V':  case 'm':  case 'o':\n+\t    allows_mem = 1;\n+\t    break;\n+\n+\t  case '<':  case '>':\n \t  case '?':  case '!':  case '*':\n-\t  case 'V':  case 'm':  case 'o':  case '<':  case '>':\n \t  case 'E':  case 'F':  case 'G':  case 'H':  case 'X':\n \t  case 's':  case 'i':  case 'n':\n \t  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n@@ -1460,48 +1471,73 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t\treturn;\n \t      }\n \n+\t    /* Try and find the real constraint for this dup.  */\n+\t    if (j == 0 && c_len == 1)\n+\t      {\n+\t\ttree o = outputs;\n+\t\tfor (j = constraint[j] - '0'; j > 0; --j)\n+\t\t  o = TREE_CHAIN (o);\n+\t\n+\t\tc_len = TREE_STRING_LENGTH (TREE_PURPOSE (o)) - 1;\n+\t\tconstraint = TREE_STRING_POINTER (TREE_PURPOSE (o));\n+\t\tj = 0;\n+\t\tbreak;\n+\t      }\n+\n \t    /* ... fall through ... */\n \n-\t  case 'p':  case 'g':  case 'r':\n+\t  case 'p':  case 'r':\n \t  default:\n \t    allows_reg = 1;\n \t    break;\n+\n+\t  case 'g':\n+\t    allows_reg = 1;\n+\t    allows_mem = 1;\n+\t    break;\n \t  }\n \n-      if (! allows_reg)\n+      if (! allows_reg && allows_mem)\n \tmark_addressable (TREE_VALUE (tail));\n \n-      XVECEXP (body, 3, i)      /* argvec */\n-\t= expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n-      if (CONSTANT_P (XVECEXP (body, 3, i))\n-\t  && ! general_operand (XVECEXP (body, 3, i),\n-\t\t\t\tTYPE_MODE (TREE_TYPE (TREE_VALUE (tail)))))\n-\t{\n-\t  if (allows_reg)\n-\t    XVECEXP (body, 3, i)\n-\t      = force_reg (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n-\t\t\t   XVECEXP (body, 3, i));\n-\t  else\n-\t    XVECEXP (body, 3, i)\n-\t      = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n-\t\t\t\t XVECEXP (body, 3, i));\n-\t}\n+      op = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n \n-      if (! allows_reg\n-\t  && (GET_CODE (XVECEXP (body, 3, i)) == REG\n-\t      || GET_CODE (XVECEXP (body, 3, i)) == SUBREG\n-\t      || GET_CODE (XVECEXP (body, 3, i)) == CONCAT))\n+      if (! asm_operand_ok (op, constraint))\n \t{\n-\t  tree type = TREE_TYPE (TREE_VALUE (tail));\n-\t  rtx memloc = assign_temp (type, 1, 1, 1);\n+\t  if (allows_reg)\n+\t    op = force_reg (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))), op);\n+\t  else if (!allows_mem)\n+\t    warning (\"asm operand %d probably doesn't match constraints\", i);\n+\t  else if (CONSTANT_P (op))\n+\t    op = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n+\t\t\t\t  op);\n+\t  else if (GET_CODE (op) == REG\n+\t\t   || GET_CODE (op) == SUBREG\n+\t\t   || GET_CODE (op) == CONCAT)\n+\t    {\n+\t      tree type = TREE_TYPE (TREE_VALUE (tail));\n+\t      rtx memloc = assign_temp (type, 1, 1, 1);\n \n-\t  emit_move_insn (memloc, XVECEXP (body, 3, i));\n-\t  XVECEXP (body, 3, i) = memloc;\n+\t      emit_move_insn (memloc, op);\n+\t      op = memloc;\n+\t    }\n+\t  else if (GET_CODE (op) == MEM && MEM_VOLATILE_P (op))\n+\t    /* We won't recognize volatile memory as available a\n+\t       memory_operand at this point.  Ignore it.  */\n+\t    ;\n+\t  else if (queued_subexp_p (op))\n+\t    ;\n+\t  else\n+\t    /* ??? Leave this only until we have experience with what\n+\t       happens in combine and elsewhere when constraints are\n+\t       not satisfied.  */\n+\t    warning (\"asm operand %d probably doesn't match constraints\", i);\n \t}\n+      XVECEXP (body, 3, i) = op;\n \n       XVECEXP (body, 4, i)      /* constraints */\n \t= gen_rtx_ASM_INPUT (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n-\t\t\t     constraint);\n+\t\t\t     orig_constraint);\n       i++;\n     }\n "}]}