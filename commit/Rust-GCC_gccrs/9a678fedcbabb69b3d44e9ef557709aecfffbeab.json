{"sha": "9a678fedcbabb69b3d44e9ef557709aecfffbeab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE2NzhmZWRjYmFiYjY5YjNkNDRlOWVmNTU3NzA5YWVjZmZmYmVhYg==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-08-19T00:38:21Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-22T12:11:25Z"}, "message": "[Ada] Implement AI12-0280's interactions with container aggregates\n\ngcc/ada/\n\n\t* sem_util.adb (Is_Container_Aggregate): A new local predicates\n\twhich indicates whether a given expression is a container\n\taggregate. The implementation of this function is incomplete; in\n\tthe unusual case of a record aggregate (i.e., not a container\n\taggregate) of a type whose Aggregate aspect is specified, the\n\tfunction will incorrectly return True.\n\t(Immediate_Context_Implies_Is_Potentially_Unevaluated): Improve\n\thandling of aggregate components.\n\t(Is_Repeatedly_Evaluated): Test for container aggregate\n\tcomponents along with existing test for array aggregate\n\tcomponents.", "tree": {"sha": "087552c28a46b9505f709aa0018d017db031baa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/087552c28a46b9505f709aa0018d017db031baa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a678fedcbabb69b3d44e9ef557709aecfffbeab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a678fedcbabb69b3d44e9ef557709aecfffbeab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a678fedcbabb69b3d44e9ef557709aecfffbeab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a678fedcbabb69b3d44e9ef557709aecfffbeab/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7a6aa4969869138117312ec48a2b995f8252793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a6aa4969869138117312ec48a2b995f8252793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a6aa4969869138117312ec48a2b995f8252793"}], "stats": {"total": 147, "additions": 91, "deletions": 56}, "files": [{"sha": "a08ffeb2010174626ca1f23a405aa327f4c00f06", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 91, "deletions": 56, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a678fedcbabb69b3d44e9ef557709aecfffbeab/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a678fedcbabb69b3d44e9ef557709aecfffbeab/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9a678fedcbabb69b3d44e9ef557709aecfffbeab", "patch": "@@ -134,6 +134,9 @@ package body Sem_Util is\n    --  Determine whether arbitrary entity Id denotes an atomic object as per\n    --  RM C.6(7).\n \n+   function Is_Container_Aggregate (Exp : Node_Id) return Boolean;\n+   --  Is the given expression a container aggregate?\n+\n    generic\n       with function Is_Effectively_Volatile_Entity\n         (Id : Entity_Id) return Boolean;\n@@ -12360,6 +12363,27 @@ package body Sem_Util is\n            (Directly_Designated_Type (Etype (Formal))) = E;\n    end Is_Access_Subprogram_Wrapper;\n \n+   ----------------------------\n+   -- Is_Container_Aggregate --\n+   ----------------------------\n+\n+   function Is_Container_Aggregate (Exp : Node_Id) return Boolean is\n+\n+      function Is_Record_Aggregate return Boolean is (False);\n+      --  ??? Unimplemented. Given an aggregate whose type is a\n+      --  record type with specified Aggregate aspect, how do we\n+      --  determine whether it is a record aggregate or a container\n+      --  aggregate? If the code where the aggregate occurs can see only\n+      --  a partial view of the aggregate's type then the aggregate\n+      --  cannot be a record type; an aggregate of a private type has to\n+      --  be a container aggregate.\n+\n+   begin\n+      return Nkind (Exp) = N_Aggregate\n+        and then Present (Find_Aspect (Etype (Exp), Aspect_Aggregate))\n+        and then not Is_Record_Aggregate;\n+   end Is_Container_Aggregate;\n+\n    ---------------------------------\n    -- Side_Effect_Free_Statements --\n    ---------------------------------\n@@ -18406,6 +18430,7 @@ package body Sem_Util is\n       is\n          Par : constant Node_Id := Parent (Expr);\n \n+         function Aggregate_Type return Node_Id is (Etype (Parent (Par)));\n       begin\n          if Nkind (Par) = N_If_Expression then\n             return Is_Elsif (Par) or else Expr /= First (Expressions (Par));\n@@ -18433,55 +18458,69 @@ package body Sem_Util is\n          elsif Nkind (Par) = N_Quantified_Expression then\n             return Expr = Condition (Par);\n \n-         elsif Nkind (Par) = N_Aggregate\n-           and then Present (Etype (Par))\n-           and then Etype (Par) /= Any_Composite\n-           and then Is_Array_Type (Etype (Par))\n-           and then Nkind (Expr) = N_Component_Association\n+         elsif Nkind (Par) = N_Component_Association\n+           and then Expr = Expression (Par)\n+           and then Nkind (Parent (Par))\n+              in N_Aggregate | N_Delta_Aggregate | N_Extension_Aggregate\n+           and then Present (Aggregate_Type)\n+           and then Aggregate_Type /= Any_Composite\n          then\n-            declare\n-               Choice           : Node_Id;\n-               In_Others_Choice : Boolean := False;\n-\n-            begin\n-               --  The expression of an array_component_association is\n-               --  potentially unevaluated if the associated choice is a\n-               --  subtype_indication or range that defines a nonstatic or\n-               --  null range.\n+            if Is_Array_Type (Aggregate_Type) then\n+               if Ada_Version >= Ada_2020 then\n+                  --  For Ada_2020, this predicate returns True for\n+                  --  any \"repeatedly evaluated\" expression.\n+                  return True;\n+               end if;\n \n-               Choice := First (Choices (Expr));\n-               while Present (Choice) loop\n-                  if Nkind (Choice) = N_Range\n-                    and then Non_Static_Or_Null_Range (Choice)\n-                  then\n-                     return True;\n+               declare\n+                  Choice           : Node_Id;\n+                  In_Others_Choice : Boolean := False;\n+                  Array_Agg        : constant Node_Id := Parent (Par);\n+               begin\n+                  --  The expression of an array_component_association is\n+                  --  potentially unevaluated if the associated choice is a\n+                  --  subtype_indication or range that defines a nonstatic or\n+                  --  null range.\n+\n+                  Choice := First (Choices (Par));\n+                  while Present (Choice) loop\n+                     if Nkind (Choice) = N_Range\n+                       and then Non_Static_Or_Null_Range (Choice)\n+                     then\n+                        return True;\n \n-                  elsif Nkind (Choice) = N_Identifier\n-                    and then Present (Scalar_Range (Etype (Choice)))\n-                    and then\n-                      Non_Static_Or_Null_Range (Scalar_Range (Etype (Choice)))\n-                  then\n-                     return True;\n+                     elsif Nkind (Choice) = N_Identifier\n+                       and then Present (Scalar_Range (Etype (Choice)))\n+                       and then\n+                         Non_Static_Or_Null_Range\n+                           (Scalar_Range (Etype (Choice)))\n+                     then\n+                        return True;\n \n-                  elsif Nkind (Choice) = N_Others_Choice then\n-                     In_Others_Choice := True;\n-                  end if;\n+                     elsif Nkind (Choice) = N_Others_Choice then\n+                        In_Others_Choice := True;\n+                     end if;\n \n-                  Next (Choice);\n-               end loop;\n+                     Next (Choice);\n+                  end loop;\n \n-               --  It is also potentially unevaluated if the associated choice\n-               --  is an others choice and the applicable index constraint is\n-               --  nonstatic or null.\n+                  --  It is also potentially unevaluated if the associated\n+                  --  choice is an others choice and the applicable index\n+                  --  constraint is nonstatic or null.\n \n-               if In_Others_Choice then\n-                  if not Compile_Time_Known_Bounds (Etype (Par)) then\n-                     return True;\n-                  else\n-                     return Has_Null_Others_Choice (Par);\n+                  if In_Others_Choice then\n+                     if not Compile_Time_Known_Bounds (Aggregate_Type) then\n+                        return True;\n+                     else\n+                        return Has_Null_Others_Choice (Array_Agg);\n+                     end if;\n                   end if;\n-               end if;\n-            end;\n+               end;\n+\n+            elsif Is_Container_Aggregate (Parent (Par)) then\n+               --  a component of a container aggregate\n+               return True;\n+            end if;\n \n             return False;\n \n@@ -30253,10 +30292,7 @@ package body Sem_Util is\n                Trailer : Node_Id := Empty;\n \n                --  There are three ways that an expression can be repeatedly\n-               --  evaluated. We only test for two of them here because\n-               --  container aggregates and the Aggregate aspect are not\n-               --  implemented yet. ???\n-\n+               --  evaluated.\n             begin\n                --  An aspect_specification is transformed into a pragma, so\n                --  reaching a pragma is our termination condition. We want to\n@@ -30275,34 +30311,33 @@ package body Sem_Util is\n                      return True;\n                   end if;\n \n-                  --  test for case 2:\n+                  --  test for cases 2 and 3:\n                   --    A subexpression of the expression of an\n-                  --    array_component_association\n+                  --    array_component_association or of\n+                  --    a container_element_associatiation.\n \n                   if Nkind (Par) = N_Component_Association\n                     and then Trailer = Expression (Par)\n                   then\n-\n                      --  determine whether Par is part of an array aggregate\n+                     --  or a container aggregate\n                      declare\n                         Rover : Node_Id := Par;\n                      begin\n                         while Nkind (Rover) not in N_Has_Etype loop\n                            pragma Assert (Present (Rover));\n                            Rover := Parent (Rover);\n                         end loop;\n-                        if Present (Etype (Rover))\n-                          and then Is_Array_Type (Etype (Rover))\n-                        then\n-                           return True;\n+                        if Present (Etype (Rover)) then\n+                           if Is_Array_Type (Etype (Rover))\n+                             or else Is_Container_Aggregate (Rover)\n+                           then\n+                              return True;\n+                           end if;\n                         end if;\n                      end;\n                   end if;\n \n-                  --  As noted above, there is a case 3 that we don't yet\n-                  --  test for. When we do, that test goes here. ???\n-                  null;\n-\n                   Trailer := Par;\n                   Par := Parent (Par);\n                end loop;"}]}