{"sha": "3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I2M2NhN2VhMjg1M2QzYjhlZDM1ZTYwNGIyZTBkMjU0NjY5NDY2ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-11-04T23:37:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-11-04T23:37:04Z"}, "message": "Use spawnve on cygwin.\n\n\t* configure.ac (AC_CHECK_HEADERS): Add process.h.\n\t(checkfuncs): Add dup3, spawnve, spawnvpe; sort the list.\n\t(AC_CHECK_FUNCS): Add dup3, spawnve, spawnvpe.\n\t* configure, config.in: Rebuild.\n\t* pex-unix.c [HAVE_SPAWNVE] (pex_unix_exec_child): New function.\n\t[HAVE_SPAWNVE] (save_and_install_fd, restore_fd): New functions.\n\nFrom-SVN: r166339", "tree": {"sha": "a8e47bd7b81ca30b70a929fe67d0b89f47e6963b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8e47bd7b81ca30b70a929fe67d0b89f47e6963b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/comments", "author": null, "committer": null, "parents": [{"sha": "9690aa8eff9815594b2eaa176c4dccb390baf452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9690aa8eff9815594b2eaa176c4dccb390baf452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9690aa8eff9815594b2eaa176c4dccb390baf452"}], "stats": {"total": 250, "additions": 237, "deletions": 13}, "files": [{"sha": "62c60bdc23b608b4259e36bb05be61b6aaeb07c1", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "patch": "@@ -1,3 +1,12 @@\n+2010-11-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.ac (AC_CHECK_HEADERS): Add process.h.\n+\t(checkfuncs): Add dup3, spawnve, spawnvpe; sort the list.\n+\t(AC_CHECK_FUNCS): Add dup3, spawnve, spawnvpe.\n+\t* configure, config.in: Rebuild.\n+\t* pex-unix.c [HAVE_SPAWNVE] (pex_unix_exec_child): New function.\n+\t[HAVE_SPAWNVE] (save_and_install_fd, restore_fd): New functions.\n+\n 2010-11-02  Ian Lance Taylor  <iant@google.com>\n \t    Dave Korn  <dave.korn.cygwin@gmail.com>\n \t    Iain Sandoe  <iains@gcc.gnu.org>"}, {"sha": "3febdad804a7c98945c182691707a2020197eddc", "filename": "libiberty/config.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.in?ref=3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "patch": "@@ -91,6 +91,9 @@\n    don't. */\n #undef HAVE_DECL_VSNPRINTF\n \n+/* Define to 1 if you have the `dup3' function. */\n+#undef HAVE_DUP3\n+\n /* Define to 1 if you have the <fcntl.h> header file. */\n #undef HAVE_FCNTL_H\n \n@@ -169,6 +172,9 @@\n /* Define if you have prctl PR_SET_NAME */\n #undef HAVE_PRCTL_SET_NAME\n \n+/* Define to 1 if you have the <process.h> header file. */\n+#undef HAVE_PROCESS_H\n+\n /* Define to 1 if you have the `psignal' function. */\n #undef HAVE_PSIGNAL\n \n@@ -208,6 +214,12 @@\n /* Define to 1 if you have the `snprintf' function. */\n #undef HAVE_SNPRINTF\n \n+/* Define to 1 if you have the `spawnve' function. */\n+#undef HAVE_SPAWNVE\n+\n+/* Define to 1 if you have the `spawnvpe' function. */\n+#undef HAVE_SPAWNVPE\n+\n /* Define to 1 if you have the <stdint.h> header file. */\n #undef HAVE_STDINT_H\n "}, {"sha": "c16ced9281518de034675dbd91010b3583b63c87", "filename": "libiberty/configure", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "patch": "@@ -4895,7 +4895,7 @@ host_makefile_frag=${frag}\n # It's OK to check for header files.  Although the compiler may not be\n # able to link anything, it had better be able to at least compile\n # something.\n-for ac_header in sys/file.h sys/param.h limits.h stdlib.h malloc.h string.h unistd.h strings.h sys/time.h time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h alloca.h sys/pstat.h sys/sysmp.h sys/sysinfo.h machine/hal_sysinfo.h sys/table.h sys/sysctl.h sys/systemcfg.h stdint.h stdio_ext.h\n+for ac_header in sys/file.h sys/param.h limits.h stdlib.h malloc.h string.h unistd.h strings.h sys/time.h time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h alloca.h sys/pstat.h sys/sysmp.h sys/sysinfo.h machine/hal_sysinfo.h sys/table.h sys/sysctl.h sys/systemcfg.h stdint.h stdio_ext.h process.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_preproc \"$LINENO\" \"$ac_header\" \"$as_ac_Header\"\n@@ -5293,25 +5293,27 @@ funcs=\"$funcs setproctitle\"\n \n vars=\"sys_errlist sys_nerr sys_siglist\"\n \n-checkfuncs=\"getrusage on_exit psignal strerror strsignal sysconf times sbrk gettimeofday\"\n-checkfuncs=\"$checkfuncs realpath canonicalize_file_name pstat_getstatic pstat_getdynamic sysmp\"\n-checkfuncs=\"$checkfuncs getsysinfo table sysctl wait3 wait4 __fsetlocking\"\n+checkfuncs=\"__fsetlocking canonicalize_file_name dup3 getrusage getsysinfo \\\n+ gettimeofday on_exit psignal pstat_getdynamic pstat_getstatic realpath \\\n+ sbrk spawnve spawnvpe strerror strsignal sysconf sysctl sysmp table \\\n+ times wait3 wait4\"\n \n # These are neither executed nor required, but they help keep\n # autoheader happy without adding a bunch of text to acconfig.h.\n if test \"x\" = \"y\"; then\n   for ac_func in asprintf atexit \\\n     basename bcmp bcopy bsearch bzero \\\n     calloc canonicalize_file_name clock \\\n+    dup3 \\\n     ffs __fsetlocking \\\n     getcwd getpagesize getrusage getsysinfo gettimeofday \\\n     index insque \\\n     memchr memcmp memcpy memmem memmove memset mkstemps \\\n     on_exit \\\n     psignal pstat_getdynamic pstat_getstatic putenv \\\n     random realpath rename rindex \\\n-    sbrk setenv setproctitle sigsetmask snprintf stpcpy stpncpy strcasecmp strchr \\\n-    strdup \\\n+    sbrk setenv setproctitle sigsetmask snprintf spawnve spawnvpe \\\n+     stpcpy stpncpy strcasecmp strchr strdup \\\n      strerror strncasecmp strndup strrchr strsignal strstr strtod strtol \\\n      strtoul strverscmp sysconf sysctl sysmp \\\n     table times tmpnam \\"}, {"sha": "d9ecfdd1fd50fef45e745b8d4d24eb49fd3b6a42", "filename": "libiberty/configure.ac", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.ac?ref=3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "patch": "@@ -246,7 +246,7 @@ AC_SUBST_FILE(host_makefile_frag)\n # It's OK to check for header files.  Although the compiler may not be\n # able to link anything, it had better be able to at least compile\n # something.\n-AC_CHECK_HEADERS(sys/file.h sys/param.h limits.h stdlib.h malloc.h string.h unistd.h strings.h sys/time.h time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h alloca.h sys/pstat.h sys/sysmp.h sys/sysinfo.h machine/hal_sysinfo.h sys/table.h sys/sysctl.h sys/systemcfg.h stdint.h stdio_ext.h)\n+AC_CHECK_HEADERS(sys/file.h sys/param.h limits.h stdlib.h malloc.h string.h unistd.h strings.h sys/time.h time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h alloca.h sys/pstat.h sys/sysmp.h sys/sysinfo.h machine/hal_sysinfo.h sys/table.h sys/sysctl.h sys/systemcfg.h stdint.h stdio_ext.h process.h)\n AC_HEADER_SYS_WAIT\n AC_HEADER_TIME\n \n@@ -358,25 +358,27 @@ funcs=\"$funcs setproctitle\"\n \n vars=\"sys_errlist sys_nerr sys_siglist\"\n \n-checkfuncs=\"getrusage on_exit psignal strerror strsignal sysconf times sbrk gettimeofday\"\n-checkfuncs=\"$checkfuncs realpath canonicalize_file_name pstat_getstatic pstat_getdynamic sysmp\"\n-checkfuncs=\"$checkfuncs getsysinfo table sysctl wait3 wait4 __fsetlocking\"\n+checkfuncs=\"__fsetlocking canonicalize_file_name dup3 getrusage getsysinfo \\\n+ gettimeofday on_exit psignal pstat_getdynamic pstat_getstatic realpath \\\n+ sbrk spawnve spawnvpe strerror strsignal sysconf sysctl sysmp table \\\n+ times wait3 wait4\"\n \n # These are neither executed nor required, but they help keep\n # autoheader happy without adding a bunch of text to acconfig.h.\n if test \"x\" = \"y\"; then\n   AC_CHECK_FUNCS(asprintf atexit \\\n     basename bcmp bcopy bsearch bzero \\\n     calloc canonicalize_file_name clock \\\n+    dup3 \\\n     ffs __fsetlocking \\\n     getcwd getpagesize getrusage getsysinfo gettimeofday \\\n     index insque \\\n     memchr memcmp memcpy memmem memmove memset mkstemps \\\n     on_exit \\\n     psignal pstat_getdynamic pstat_getstatic putenv \\\n     random realpath rename rindex \\\n-    sbrk setenv setproctitle sigsetmask snprintf stpcpy stpncpy strcasecmp strchr \\\n-    strdup \\\n+    sbrk setenv setproctitle sigsetmask snprintf spawnve spawnvpe \\\n+     stpcpy stpncpy strcasecmp strchr strdup \\\n      strerror strncasecmp strndup strrchr strsignal strstr strtod strtol \\\n      strtoul strverscmp sysconf sysctl sysmp \\\n     table times tmpnam \\"}, {"sha": "c4a69ad07c09388563a6e0dea3f49af967ad62c4", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 200, "deletions": 1, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b63ca7ea2853d3b8ed35e604b2e0d254669466d/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=3b63ca7ea2853d3b8ed35e604b2e0d254669466d", "patch": "@@ -55,7 +55,9 @@ extern int errno;\n #ifdef HAVE_SYS_STAT_H\n #include <sys/stat.h>\n #endif\n-\n+#ifdef HAVE_PROCESS_H\n+#include <process.h>\n+#endif\n \n #ifdef vfork /* Autoconf may define this to fork for us. */\n # define VFORK_STRING \"fork\"\n@@ -387,6 +389,202 @@ pex_child_error (struct pex_obj *obj, const char *executable,\n \n extern char **environ;\n \n+#if defined(HAVE_SPAWNVE) && defined(HAVE_SPAWNVPE)\n+/* Implementation of pex->exec_child using the Cygwin spawn operation.  */\n+\n+/* Subroutine of pex_unix_exec_child.  Move OLD_FD to a new file descriptor\n+   to be stored in *PNEW_FD, save the flags in *PFLAGS, and arrange for the\n+   saved copy to be close-on-exec.  Move CHILD_FD into OLD_FD.  If CHILD_FD\n+   is -1, OLD_FD is to be closed.  Return -1 on error.  */\n+\n+static int\n+save_and_install_fd(int *pnew_fd, int *pflags, int old_fd, int child_fd)\n+{\n+  int new_fd, flags;\n+\n+  flags = fcntl (old_fd, F_GETFD);\n+\n+  /* If we could not retrieve the flags, then OLD_FD was not open.  */\n+  if (flags < 0)\n+    {\n+      new_fd = -1, flags = 0;\n+      if (child_fd >= 0 && dup2 (child_fd, old_fd) < 0)\n+\treturn -1;\n+    }\n+  /* If we wish to close OLD_FD, just mark it CLOEXEC.  */\n+  else if (child_fd == -1)\n+    {\n+      new_fd = old_fd;\n+      if ((flags & FD_CLOEXEC) == 0 && fcntl (old_fd, F_SETFD, FD_CLOEXEC) < 0)\n+\treturn -1;\n+    }\n+  /* Otherwise we need to save a copy of OLD_FD before installing CHILD_FD.  */\n+  else\n+    {\n+#ifdef F_DUPFD_CLOEXEC\n+      new_fd = fcntl (old_fd, F_DUPFD_CLOEXEC, 3);\n+      if (new_fd < 0)\n+\treturn -1;\n+#else\n+      /* Prefer F_DUPFD over dup in order to avoid getting a new fd\n+\t in the range 0-2, right where a new stderr fd might get put.  */\n+      new_fd = fcntl (old_fd, F_DUPFD, 3);\n+      if (new_fd < 0)\n+\treturn -1;\n+      if (fcntl (new_fd, F_SETFD, FD_CLOEXEC) < 0)\n+\treturn -1;\n+#endif\n+      if (dup2 (child_fd, old_fd) < 0)\n+\treturn -1;\n+    }\n+\n+  *pflags = flags;\n+  if (pnew_fd)\n+    *pnew_fd = new_fd;\n+  else if (new_fd != old_fd)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* Subroutine of pex_unix_exec_child.  Move SAVE_FD back to OLD_FD\n+   restoring FLAGS.  If SAVE_FD < 0, OLD_FD is to be closed.  */\n+\n+static int\n+restore_fd(int old_fd, int save_fd, int flags)\n+{\n+  /* For SAVE_FD < 0, all we have to do is restore the\n+     \"closed-ness\" of the original.  */\n+  if (save_fd < 0)\n+    return close (old_fd);\n+\n+  /* For SAVE_FD == OLD_FD, all we have to do is restore the\n+     original setting of the CLOEXEC flag.  */\n+  if (save_fd == old_fd)\n+    {\n+      if (flags & FD_CLOEXEC)\n+\treturn 0;\n+      return fcntl (old_fd, F_SETFD, flags);\n+    }\n+\n+  /* Otherwise we have to move the descriptor back, restore the flags,\n+     and close the saved copy.  */\n+#ifdef HAVE_DUP3\n+  if (flags == FD_CLOEXEC)\n+    {\n+      if (dup3 (save_fd, old_fd, O_CLOEXEC) < 0)\n+\treturn -1;\n+    }\n+  else\n+#endif\n+    {\n+      if (dup2 (save_fd, old_fd) < 0)\n+\treturn -1;\n+      if (flags != 0 && fcntl (old_fd, F_SETFD, flags) < 0)\n+\treturn -1;\n+    }\n+  return close (save_fd);\n+}\n+\n+static pid_t\n+pex_unix_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED,\n+\t\t     int flags, const char *executable,\n+\t\t     char * const * argv, char * const * env,\n+                     int in, int out, int errdes, int toclose,\n+\t\t     const char **errmsg, int *err)\n+{\n+  int fl_in = 0, fl_out = 0, fl_err = 0, fl_tc = 0;\n+  int save_in = -1, save_out = -1, save_err = -1;\n+  int max, retries;\n+  pid_t pid;\n+\n+  if (flags & PEX_STDERR_TO_STDOUT)\n+    errdes = out;\n+\n+  /* We need the three standard file descriptors to be set up as for\n+     the child before we perform the spawn.  The file descriptors for\n+     the parent need to be moved and marked for close-on-exec.  */\n+  if (in != STDIN_FILE_NO\n+      && save_and_install_fd (&save_in, &fl_in, STDIN_FILE_NO, in) < 0)\n+    goto error_dup2;\n+  if (out != STDOUT_FILE_NO\n+      && save_and_install_fd (&save_out, &fl_out, STDOUT_FILE_NO, out) < 0)\n+    goto error_dup2;\n+  if (errdes != STDERR_FILE_NO\n+      && save_and_install_fd (&save_err, &fl_err, STDERR_FILE_NO, errdes) < 0)\n+    goto error_dup2;\n+  if (toclose >= 0\n+      && save_and_install_fd (NULL, &fl_tc, toclose, -1) < 0)\n+    goto error_dup2;\n+\n+  /* Now that we've moved the file descriptors for the child into place,\n+     close the originals.  Be careful not to close any of the standard\n+     file descriptors that we just set up.  */\n+  max = -1;\n+  if (errdes >= 0)\n+    max = STDERR_FILE_NO;\n+  else if (out >= 0)\n+    max = STDOUT_FILE_NO;\n+  else if (in >= 0)\n+    max = STDIN_FILE_NO;\n+  if (in > max)\n+    close (in);\n+  if (out > max)\n+    close (out);\n+  if (errdes > max && errdes != out)\n+    close (errdes);\n+\n+  /* If we were not given an environment, use the global environment.  */\n+  if (env == NULL)\n+    env = environ;\n+\n+  /* Launch the program.  If we get EAGAIN (normally out of pid's), try\n+     again a few times with increasing backoff times.  */\n+  retries = 0;\n+  while (1)\n+    {\n+      typedef const char * const *cc_cp;\n+\n+      if (flags & PEX_SEARCH)\n+\tpid = spawnvpe (_P_NOWAITO, executable, (cc_cp)argv, (cc_cp)env);\n+      else\n+\tpid = spawnve (_P_NOWAITO, executable, (cc_cp)argv, (cc_cp)env);\n+\n+      if (pid > 0)\n+\tbreak;\n+\n+      *err = errno;\n+      *errmsg = \"spawn\";\n+      if (errno != EAGAIN || ++retries == 4)\n+\treturn (pid_t) -1;\n+      sleep (1 << retries);\n+    }\n+\n+  /* Success.  Restore the parent's file descriptors that we saved above.  */\n+  if (toclose >= 0\n+      && restore_fd (toclose, toclose, fl_tc) < 0)\n+    goto error_dup2;\n+  if (in != STDIN_FILE_NO\n+      && restore_fd (STDIN_FILE_NO, save_in, fl_in) < 0)\n+    goto error_dup2;\n+  if (out != STDOUT_FILE_NO\n+      && restore_fd (STDOUT_FILE_NO, save_out, fl_out) < 0)\n+    goto error_dup2;\n+  if (errdes != STDERR_FILE_NO\n+      && restore_fd (STDERR_FILE_NO, save_err, fl_err) < 0)\n+    goto error_dup2;\n+\n+  return pid;\n+\n+ error_dup2:\n+  *err = errno;\n+  *errmsg = \"dup2\";\n+  return (pid_t) -1;\n+}\n+\n+#else\n+/* Implementation of pex->exec_child using standard vfork + exec.  */\n+\n static pid_t\n pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t\t     char * const * argv, char * const * env,\n@@ -521,6 +719,7 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n       return pid;\n     }\n }\n+#endif /* SPAWN */\n \n /* Wait for a child process to complete.  */\n "}]}