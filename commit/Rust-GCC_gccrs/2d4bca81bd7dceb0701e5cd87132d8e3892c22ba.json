{"sha": "2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ0YmNhODFiZDdkY2ViMDcwMWU1Y2Q4NzEzMmQ4ZTM4OTJjMjJiYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-08-01T15:14:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-08-01T15:14:48Z"}, "message": "[06/11] Handle VMAT_INVARIANT separately\n\nInvariant loads were handled as a variation on the code for contiguous\nloads.  We detected whether they were invariant or not as a byproduct of\ncreating the vector pointer ivs: vect_create_data_ref_ptr passed back an\ninv_p to say whether the pointer was invariant.\n\nBut vectorised invariant loads just keep the original scalar load,\nso this meant that detecting invariant loads had the side-effect of\ncreating an unwanted vector pointer iv.  The placement of the code\nalso meant that we'd create a vector load and then not use the result.\nIn principle this is wrong code, since there's no guarantee that there's\na vector's worth of accessible data at that address, but we rely on DCE\nto get rid of the load before any harm is done.\n\nE.g., for an invariant load in an inner loop (which seems like the more\ncommon use case for this code), we'd create:\n\n   vectp_a.6_52 = &a + 4;\n\n   # vectp_a.5_53 = PHI <vectp_a.5_54(9), vectp_a.6_52(2)>\n\n   # vectp_a.5_55 = PHI <vectp_a.5_53(3), vectp_a.5_56(10)>\n\n   vect_next_a_11.7_57 = MEM[(int *)vectp_a.5_55];\n   next_a_11 = a[_1];\n   vect_cst__58 = {next_a_11, next_a_11, next_a_11, next_a_11};\n\n   vectp_a.5_56 = vectp_a.5_55 + 4;\n\n   vectp_a.5_54 = vectp_a.5_53 + 0;\n\nwhereas all we want is:\n\n   next_a_11 = a[_1];\n   vect_cst__58 = {next_a_11, next_a_11, next_a_11, next_a_11};\n\nThis patch moves the handling to its own block and makes\nvect_create_data_ref_ptr assert (when creating a full iv) that the\naddress isn't invariant.\n\nThe ncopies handling is unfortunate, but a preexisting issue.\nRichi's suggestion of using a vector of vector statements would\nlet us reuse one statement for all copies.\n\n2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_create_data_ref_ptr): Remove inv_p\n\tparameter.\n\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Likewise.\n\tWhen creating an iv, assert that the step is not known to be zero.\n\t(vect_setup_realignment): Update call accordingly.\n\t* tree-vect-stmts.c (vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.  Handle VMAT_INVARIANT separately.\n\nFrom-SVN: r263220", "tree": {"sha": "f3215594fb5835125d435736eccfac2bfe693c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3215594fb5835125d435736eccfac2bfe693c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e6b18e5fbe6be62334c9007a58224fb3700d43a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6b18e5fbe6be62334c9007a58224fb3700d43a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6b18e5fbe6be62334c9007a58224fb3700d43a"}], "stats": {"total": 169, "additions": 86, "deletions": 83}, "files": [{"sha": "fb735149918f308338efcd5344e801dafcfc967f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "patch": "@@ -1,3 +1,13 @@\n+2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_create_data_ref_ptr): Remove inv_p\n+\tparameter.\n+\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Likewise.\n+\tWhen creating an iv, assert that the step is not known to be zero.\n+\t(vect_setup_realignment): Update call accordingly.\n+\t* tree-vect-stmts.c (vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.  Handle VMAT_INVARIANT separately.\n+\n 2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_stmt_to_vectorize): New function."}, {"sha": "e20b502b719a65cdaf75404913401f315f0a5905", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "patch": "@@ -4674,16 +4674,13 @@ vect_create_addr_base_for_vector_ref (stmt_vec_info stmt_info,\n \n       Return the increment stmt that updates the pointer in PTR_INCR.\n \n-   3. Set INV_P to true if the access pattern of the data reference in the\n-      vectorized loop is invariant.  Set it to false otherwise.\n-\n-   4. Return the pointer.  */\n+   3. Return the pointer.  */\n \n tree\n vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n \t\t\t  struct loop *at_loop, tree offset,\n \t\t\t  tree *initial_address, gimple_stmt_iterator *gsi,\n-\t\t\t  gimple **ptr_incr, bool only_init, bool *inv_p,\n+\t\t\t  gimple **ptr_incr, bool only_init,\n \t\t\t  tree byte_offset, tree iv_step)\n {\n   const char *base_name;\n@@ -4705,7 +4702,6 @@ vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n   bool insert_after;\n   tree indx_before_incr, indx_after_incr;\n   gimple *incr;\n-  tree step;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n \n   gcc_assert (iv_step != NULL_TREE\n@@ -4726,14 +4722,6 @@ vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n       *ptr_incr = NULL;\n     }\n \n-  /* Check the step (evolution) of the load in LOOP, and record\n-     whether it's invariant.  */\n-  step = vect_dr_behavior (dr_info)->step;\n-  if (integer_zerop (step))\n-    *inv_p = true;\n-  else\n-    *inv_p = false;\n-\n   /* Create an expression for the first address accessed by this load\n      in LOOP.  */\n   base_name = get_name (DR_BASE_ADDRESS (dr));\n@@ -4849,15 +4837,17 @@ vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n     aptr = aggr_ptr_init;\n   else\n     {\n+      /* Accesses to invariant addresses should be handled specially\n+\t by the caller.  */\n+      tree step = vect_dr_behavior (dr_info)->step;\n+      gcc_assert (!integer_zerop (step));\n+\n       if (iv_step == NULL_TREE)\n \t{\n-\t  /* The step of the aggregate pointer is the type size.  */\n+\t  /* The step of the aggregate pointer is the type size,\n+\t     negated for downward accesses.  */\n \t  iv_step = TYPE_SIZE_UNIT (aggr_type);\n-\t  /* One exception to the above is when the scalar step of the load in\n-\t     LOOP is zero. In this case the step here is also zero.  */\n-\t  if (*inv_p)\n-\t    iv_step = size_zero_node;\n-\t  else if (tree_int_cst_sgn (step) == -1)\n+\t  if (tree_int_cst_sgn (step) == -1)\n \t    iv_step = fold_build1 (NEGATE_EXPR, TREE_TYPE (iv_step), iv_step);\n \t}\n \n@@ -5462,7 +5452,6 @@ vect_setup_realignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   gphi *phi_stmt;\n   tree msq = NULL_TREE;\n   gimple_seq stmts = NULL;\n-  bool inv_p;\n   bool compute_in_loop = false;\n   bool nested_in_vect_loop = false;\n   struct loop *containing_loop = (gimple_bb (stmt_info->stmt))->loop_father;\n@@ -5556,7 +5545,7 @@ vect_setup_realignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       ptr = vect_create_data_ref_ptr (stmt_info, vectype,\n \t\t\t\t      loop_for_initial_load, NULL_TREE,\n-\t\t\t\t      &init_addr, NULL, &inc, true, &inv_p);\n+\t\t\t\t      &init_addr, NULL, &inc, true);\n       if (TREE_CODE (ptr) == SSA_NAME)\n \tnew_temp = copy_ssa_name (ptr);\n       else"}, {"sha": "3989fdea251a66712da58c101481dbe323f5a1d4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 64, "deletions": 60, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "patch": "@@ -6254,7 +6254,6 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   unsigned int group_size, i;\n   vec<tree> oprnds = vNULL;\n   vec<tree> result_chain = vNULL;\n-  bool inv_p;\n   tree offset = NULL_TREE;\n   vec<tree> vec_oprnds = vNULL;\n   bool slp = (slp_node != NULL);\n@@ -7018,22 +7017,16 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    {\n \t      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr_info->dr));\n \t      dataref_offset = build_int_cst (ref_type, 0);\n-\t      inv_p = false;\n \t    }\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-\t    {\n-\t      vect_get_gather_scatter_ops (loop, stmt_info, &gs_info,\n-\t\t\t\t\t   &dataref_ptr, &vec_offset);\n-\t      inv_p = false;\n-\t    }\n+\t    vect_get_gather_scatter_ops (loop, stmt_info, &gs_info,\n+\t\t\t\t\t &dataref_ptr, &vec_offset);\n \t  else\n \t    dataref_ptr\n \t      = vect_create_data_ref_ptr (first_stmt_info, aggr_type,\n \t\t\t\t\t  simd_lane_access_p ? loop : NULL,\n \t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n-\t\t\t\t\t  simd_lane_access_p, &inv_p,\n-\t\t\t\t\t  NULL_TREE, bump);\n-\t  gcc_assert (bb_vinfo || !inv_p);\n+\t\t\t\t\t  simd_lane_access_p, NULL_TREE, bump);\n \t}\n       else\n \t{\n@@ -7419,7 +7412,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   bool grouped_load = false;\n   stmt_vec_info first_stmt_info;\n   stmt_vec_info first_stmt_info_for_drptr = NULL;\n-  bool inv_p;\n   bool compute_in_loop = false;\n   struct loop *at_loop;\n   int vec_num;\n@@ -7669,6 +7661,63 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       return true;\n     }\n \n+  if (memory_access_type == VMAT_INVARIANT)\n+    {\n+      gcc_assert (!grouped_load && !mask && !bb_vinfo);\n+      /* If we have versioned for aliasing or the loop doesn't\n+\t have any data dependencies that would preclude this,\n+\t then we are sure this is a loop invariant load and\n+\t thus we can insert it on the preheader edge.  */\n+      bool hoist_p = (LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo)\n+\t\t      && !nested_in_vect_loop\n+\t\t      && hoist_defs_of_uses (stmt_info, loop));\n+      if (hoist_p)\n+\t{\n+\t  gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"hoisting out of the vectorized loop: \");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+\t    }\n+\t  scalar_dest = copy_ssa_name (scalar_dest);\n+\t  tree rhs = unshare_expr (gimple_assign_rhs1 (stmt));\n+\t  gsi_insert_on_edge_immediate\n+\t    (loop_preheader_edge (loop),\n+\t     gimple_build_assign (scalar_dest, rhs));\n+\t}\n+      /* These copies are all equivalent, but currently the representation\n+\t requires a separate STMT_VINFO_VEC_STMT for each one.  */\n+      prev_stmt_info = NULL;\n+      gimple_stmt_iterator gsi2 = *gsi;\n+      gsi_next (&gsi2);\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  stmt_vec_info new_stmt_info;\n+\t  if (hoist_p)\n+\t    {\n+\t      new_temp = vect_init_vector (stmt_info, scalar_dest,\n+\t\t\t\t\t   vectype, NULL);\n+\t      gimple *new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t      new_stmt_info = vinfo->add_stmt (new_stmt);\n+\t    }\n+\t  else\n+\t    {\n+\t      new_temp = vect_init_vector (stmt_info, scalar_dest,\n+\t\t\t\t\t   vectype, &gsi2);\n+\t      new_stmt_info = vinfo->lookup_def (new_temp);\n+\t    }\n+\t  if (slp)\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t  else if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n+\t}\n+      return true;\n+    }\n+\n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_STRIDED_SLP)\n     {\n@@ -8177,7 +8226,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    {\n \t      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr_info->dr));\n \t      dataref_offset = build_int_cst (ref_type, 0);\n-\t      inv_p = false;\n \t    }\n \t  else if (first_stmt_info_for_drptr\n \t\t   && first_stmt_info != first_stmt_info_for_drptr)\n@@ -8186,7 +8234,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t= vect_create_data_ref_ptr (first_stmt_info_for_drptr,\n \t\t\t\t\t    aggr_type, at_loop, offset, &dummy,\n \t\t\t\t\t    gsi, &ptr_incr, simd_lane_access_p,\n-\t\t\t\t\t    &inv_p, byte_offset, bump);\n+\t\t\t\t\t    byte_offset, bump);\n \t      /* Adjust the pointer by the difference to first_stmt.  */\n \t      data_reference_p ptrdr\n \t\t= STMT_VINFO_DATA_REF (first_stmt_info_for_drptr);\n@@ -8199,16 +8247,13 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t\t     stmt_info, diff);\n \t    }\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-\t    {\n-\t      vect_get_gather_scatter_ops (loop, stmt_info, &gs_info,\n-\t\t\t\t\t   &dataref_ptr, &vec_offset);\n-\t      inv_p = false;\n-\t    }\n+\t    vect_get_gather_scatter_ops (loop, stmt_info, &gs_info,\n+\t\t\t\t\t &dataref_ptr, &vec_offset);\n \t  else\n \t    dataref_ptr\n \t      = vect_create_data_ref_ptr (first_stmt_info, aggr_type, at_loop,\n \t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n-\t\t\t\t\t  simd_lane_access_p, &inv_p,\n+\t\t\t\t\t  simd_lane_access_p,\n \t\t\t\t\t  byte_offset, bump);\n \t  if (mask)\n \t    vec_mask = vect_get_vec_def_for_operand (mask, stmt_info,\n@@ -8492,47 +8537,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    }\n \t\t}\n \n-\t      /* 4. Handle invariant-load.  */\n-\t      if (inv_p && !bb_vinfo)\n-\t\t{\n-\t\t  gcc_assert (!grouped_load);\n-\t\t  /* If we have versioned for aliasing or the loop doesn't\n-\t\t     have any data dependencies that would preclude this,\n-\t\t     then we are sure this is a loop invariant load and\n-\t\t     thus we can insert it on the preheader edge.  */\n-\t\t  if (LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo)\n-\t\t      && !nested_in_vect_loop\n-\t\t      && hoist_defs_of_uses (stmt_info, loop))\n-\t\t    {\n-\t\t      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n-\t\t      if (dump_enabled_p ())\n-\t\t\t{\n-\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t   \"hoisting out of the vectorized \"\n-\t\t\t\t\t   \"loop: \");\n-\t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t\t\t}\n-\t\t      tree tem = copy_ssa_name (scalar_dest);\n-\t\t      gsi_insert_on_edge_immediate\n-\t\t\t(loop_preheader_edge (loop),\n-\t\t\t gimple_build_assign (tem,\n-\t\t\t\t\t      unshare_expr\n-\t\t\t\t\t        (gimple_assign_rhs1 (stmt))));\n-\t\t      new_temp = vect_init_vector (stmt_info, tem,\n-\t\t\t\t\t\t   vectype, NULL);\n-\t\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n-\t\t      new_stmt_info = vinfo->add_stmt (new_stmt);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      gimple_stmt_iterator gsi2 = *gsi;\n-\t\t      gsi_next (&gsi2);\n-\t\t      new_temp = vect_init_vector (stmt_info, scalar_dest,\n-\t\t\t\t\t\t   vectype, &gsi2);\n-\t\t      new_stmt_info = vinfo->lookup_def (new_temp);\n-\t\t    }\n-\t\t}\n-\n \t      if (memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n \t\t{\n \t\t  tree perm_mask = perm_mask_for_reverse (vectype);"}, {"sha": "d91cc075f0ea2cc747d2ed2fb747725f02c193d3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4bca81bd7dceb0701e5cd87132d8e3892c22ba/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2d4bca81bd7dceb0701e5cd87132d8e3892c22ba", "patch": "@@ -1527,7 +1527,7 @@ extern bool vect_analyze_data_refs (vec_info *, poly_uint64 *);\n extern void vect_record_base_alignments (vec_info *);\n extern tree vect_create_data_ref_ptr (stmt_vec_info, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n-\t\t\t\t      gimple **, bool, bool *,\n+\t\t\t\t      gimple **, bool,\n \t\t\t\t      tree = NULL_TREE, tree = NULL_TREE);\n extern tree bump_vector_ptr (tree, gimple *, gimple_stmt_iterator *,\n \t\t\t     stmt_vec_info, tree);"}]}