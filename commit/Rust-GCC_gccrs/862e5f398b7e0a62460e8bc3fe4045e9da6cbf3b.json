{"sha": "862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "node_id": "C_kwDOANBUbNoAKDg2MmU1ZjM5OGI3ZTBhNjI0NjBlOGJjM2ZlNDA0NWU5ZGE2Y2JmM2I", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-12-20T15:14:46Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-01-13T09:42:17Z"}, "message": "Enhance OpenACC 'kernels' decomposition testing\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/kernels-decompose-1.c: Enhance.\n\t* c-c++-common/goacc/kernels-decompose-2.c: Likewise.\n\t* c-c++-common/goacc/kernels-decompose-ice-1.c: Likewise.\n\t* c-c++-common/goacc/kernels-decompose-ice-2.c: Likewise.\n\t* gfortran.dg/goacc/kernels-decompose-1.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-decompose-2.f95: Likewise.\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose-ice-1.c:\n\tEnhance.\n\t* testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/declare-vla.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/f-asyncwait-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/f-asyncwait-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/f-asyncwait-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-decompose-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/pr94358-1.f90: Likewise.", "tree": {"sha": "5f9e8061441c4ed6494666d9d1786bfb1294fef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f9e8061441c4ed6494666d9d1786bfb1294fef2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff496134a99de876cde331a3c12b3335c197bf52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff496134a99de876cde331a3c12b3335c197bf52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff496134a99de876cde331a3c12b3335c197bf52"}], "stats": {"total": 746, "additions": 593, "deletions": 153}, "files": [{"sha": "e58bc179f306e080e890b9b69d7da669f781c35b", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-1.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-1.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,10 +1,16 @@\n /* Test OpenACC 'kernels' construct decomposition.  */\n \n /* { dg-additional-options \"-fopt-info-omp-all\" } */\n+\n /* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n /* { dg-additional-options \"--param=openacc-kernels=decompose\" }\n    { dg-additional-options \"-fdump-tree-omp_oacc_kernels_decompose\" } */\n \n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n /* { dg-additional-options \"-Wopenacc-parallelism\" } for testing/documenting\n    aspects of that functionality.  */\n \n@@ -14,7 +20,7 @@\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n    so to maintain compatibility with earlier Tcl releases, we manually\n    initialize counter variables:\n-   { dg-line l_dummy[variable c_loop_i 0] }\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n    { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n    \"WARNING: dg-line var l_dummy defined, but not used\".  */\n \n@@ -28,36 +34,43 @@ main (void)\n   int i;\n   unsigned int sum = 1;\n \n-#pragma acc kernels copyin(a[0:N]) copy(sum)\n-  /* { dg-bogus \"optimized: assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } .-1 }\n+#pragma acc kernels copyin(a[0:N]) copy(sum) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'sum\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* { dg-bogus {optimized: assigned OpenACC seq loop parallelism} TODO { xfail *-*-* } l_compute$c_compute }\n      TODO Is this maybe the report that belongs to the XFAILed report further down?  */\n   {\n     #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < N; ++i)\n       sum += a[i];\n \n-    sum++; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    sum++;\n     a[0]++;\n \n     #pragma acc loop independent /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < N; ++i)\n       sum += a[i];\n \n-    if (sum > 10) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    if (sum > 10)\n       { \n         #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n \t/* { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+\t/* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n \t/*TODO { dg-optimized \"assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } l_loop_i$c_loop_i } */\n         for (i = 0; i < N; ++i)\n           sum += a[i];\n       }\n \n     #pragma acc loop auto /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < N; ++i)\n       sum += a[i];"}, {"sha": "4dd55eb46802a8ff87aa9da688fc3608d806efb8", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-2.c", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-2.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,9 +1,14 @@\n /* Test OpenACC 'kernels' construct decomposition.  */\n \n /* { dg-additional-options \"-fopt-info-omp-all\" } */\n+\n /* { dg-additional-options \"--param=openacc-kernels=decompose\" }\n /* { dg-additional-options \"-O2\" } for 'parloops'.  */\n \n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n /* { dg-additional-options \"-Wopenacc-parallelism\" } for testing/documenting\n    aspects of that functionality.  */\n \n@@ -13,7 +18,7 @@\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n    so to maintain compatibility with earlier Tcl releases, we manually\n    initialize counter variables:\n-   { dg-line l_dummy[variable c_loop_i 0 c_loop_j 0 c_loop_k 0 c_part 0] }\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0 c_part 0] }\n    { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n    \"WARNING: dg-line var l_dummy defined, but not used\".  */\n \n@@ -40,68 +45,90 @@ main ()\n #define N 10\n   int a[N], b[N], c[N];\n \n-#pragma acc kernels\n+#pragma acc kernels /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'x\\.0' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n-    x = 0; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    x = 0;\n     y = x < 10;\n     z = x++;\n     ;\n   }\n \n   { /*TODO Instead of using 'for (int i = 0; [...])', move 'int i' outside, to work around for ICE detailed in 'kernels-decompose-ice-1.c'.  */\n     int i;\n-#pragma acc kernels /* { dg-optimized \"assigned OpenACC gang loop parallelism\" } */\n-  for (i = 0; i < N; i++) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+#pragma acc kernels /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+  for (i = 0; i < N; i++)\n     a[i] = 0;\n   }\n \n #pragma acc kernels loop /* { dg-line l_loop_i[incr c_loop_i] } */\n-  /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n   /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; i++)\n     b[i] = a[N - i - 1];\n \n #pragma acc kernels\n   {\n #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; i++)\n       b[i] = a[N - i - 1];\n \n #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; i++)\n       c[i] = a[i] * b[i];\n \n-    a[z] = 0; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    a[z] = 0;\n \n #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; i++)\n       c[i] += a[i];\n \n #pragma acc loop seq /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0 + 1; i < N; i++)\n       c[i] += c[i - 1];\n   }\n \n-#pragma acc kernels\n+#pragma acc kernels /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   /*TODO What does this mean?\n-    TODO { dg-optimized \"assigned OpenACC worker vector loop parallelism\" \"\" { target *-*-* } .-2 } */\n+    TODO { dg-optimized \"assigned OpenACC worker vector loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n   {\n #pragma acc loop independent /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n-    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n #pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n+      /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+      /* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n       /* { dg-optimized \"assigned OpenACC worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n       for (int j = 0; j < N; ++j)\n #pragma acc loop independent /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t/* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t/* { dg-warning \"insufficient partitioning available to parallelize loop\" \"\" { target *-*-* } l_loop_k$c_loop_k } */\n \t/* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_k$c_loop_k } */\n \tfor (int k = 0; k < N; ++k)\n@@ -111,42 +138,51 @@ main ()\n \n     /*TODO Should the following turn into \"gang-single\" instead of \"parloops\"?\n       TODO The problem is that the first STMT is 'if (y <= 4) goto <D.2547>; else goto <D.2548>;', thus \"parloops\".  */\n-    if (y < 5) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    if (y < 5)\n #pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n+      /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n       /* { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n       for (int j = 0; j < N; ++j)\n \tb[j] = f_w (c[j]);\n   }\n \n-#pragma acc kernels\n-  /* { dg-bogus \"warning: region contains gang partitioned code but is not gang partitioned\" \"TODO 'kernels'\" { xfail *-*-* } .-1 } */\n+#pragma acc kernels /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-bogus \"warning: region contains gang partitioned code but is not gang partitioned\" \"TODO 'kernels'\" { xfail *-*-* } l_compute$c_compute } */\n   {\n     y = f_g (a[5]); /* { dg-line l_part[incr c_part] } */\n     /*TODO If such a construct is placed in its own part (like it is, here), can't this actually use gang paralelism, instead of \"gang-single\"?\n-      { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" \"\" { target *-*-* } l_part$c_part } */\n+      { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } l_part$c_part } */\n     /* { dg-optimized \"assigned OpenACC gang worker vector loop parallelism\" \"\" { target *-*-* } l_part$c_part } */\n \n #pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n-    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n     /* { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n     for (int j = 0; j < N; ++j)\n       b[j] = y + f_w (c[j]); /* { dg-optimized \"assigned OpenACC worker vector loop parallelism\" } */\n   }\n \n #pragma acc kernels\n   {\n-    y = 3; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    y = 3;\n \n #pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n-    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n     /* { dg-optimized \"assigned OpenACC gang worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n     for (int j = 0; j < N; ++j)\n       b[j] = y + f_v (c[j]); /* { dg-optimized \"assigned OpenACC vector loop parallelism\" } */\n \n-    z = 2; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    z = 2;\n   }\n \n-#pragma acc kernels /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+#pragma acc kernels\n   ;\n \n   return 0;"}, {"sha": "e83b451f2b8edd0ab509a4eaa5cec4852cccad5f", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-1.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,10 +1,13 @@\n /* Test OpenACC 'kernels' construct decomposition.  */\n \n /* { dg-additional-options \"-fopt-info-omp-all\" } */\n+\n /* { dg-additional-options \"-fchecking --param=openacc-kernels=decompose\" } */\n /* { dg-ice \"TODO\" }\n    { dg-prune-output \"during GIMPLE pass: omplower\" } */\n \n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" } */\n+\n /* Reduced from 'kernels-decompose-2.c'.\n    (Hopefully) similar instances:\n      - 'kernels-decompose-ice-2.c'\n@@ -18,7 +21,9 @@ main ()\n #define N 10\n \n #pragma acc kernels\n-  for (int i = 0; i < N; i++) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } .-1 } */\n+  /* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+  for (int i = 0; i < N; i++)\n     ;\n \n   return 0;"}, {"sha": "16af57d5f8748119568d0d354357dd1d3aa25f7f", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-2.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,15 +1,21 @@\n /* Test OpenACC 'kernels' construct decomposition.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" } */\n+\n /* { dg-additional-options \"-fchecking --param=openacc-kernels=decompose\" } */\n /* { dg-ice \"TODO\" }\n    { dg-prune-output \"during GIMPLE pass: omplower\" } */\n \n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" } */\n+\n /* Reduced from 'kernels-decompose-ice-1.c'.  */\n \n int\n main ()\n {\n #pragma acc kernels\n+  /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .-1 } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } .-2 } */\n   {\n     int i;\n   }"}, {"sha": "1a26844f96d43a7d9f015bd87b876c05b534102e", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-decompose-1.f95", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-1.f95?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,10 +1,16 @@\n ! Test OpenACC 'kernels' construct decomposition.\n \n ! { dg-additional-options \"-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"-fdump-tree-gimple\" }\n+\n ! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n ! { dg-additional-options \"-fdump-tree-omp_oacc_kernels_decompose\" }\n \n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n+\n ! { dg-additional-options \"-Wopenacc-parallelism\" } for testing/documenting\n ! aspects of that functionality.\n \n@@ -14,7 +20,7 @@\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n ! so to maintain compatibility with earlier Tcl releases, we manually\n ! initialize counter variables:\n-! { dg-line l_dummy[variable c_loop_i 0] }\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n ! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n ! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n@@ -24,38 +30,45 @@ program main\n   integer, dimension (1:N)   :: a\n   integer                    :: i, sum\n \n-  !$acc kernels copyin(a(1:N)) copy(sum)\n-  ! { dg-bogus \"optimized: assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } .-1 }\n+  !$acc kernels copyin(a(1:N)) copy(sum) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-note {variable 'sum\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute }\n+  ! { dg-bogus \"optimized: assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } l_compute$c_compute }\n   !TODO Is this maybe the report that belongs to the XFAILed report further down?  */\n \n   !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     sum = sum + a(i)\n   end do\n \n-  sum = sum + 1 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  sum = sum + 1\n   a(1) = a(1) + 1\n \n   !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     sum = sum + a(i)\n   end do\n \n-  if (sum .gt. 10) then ! { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  if (sum .gt. 10) then\n     !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n     ! { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+    ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n     !TODO { dg-optimized \"assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } l_loop_i$c_loop_i }\n     do i = 1, N\n       sum = sum + a(i)\n     end do\n   end if\n \n   !$acc loop auto ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     sum = sum + a(i)"}, {"sha": "59990135c752664050bbf59c9c2e68582d2f80e6", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-decompose-2.f95", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-2.f95?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,9 +1,14 @@\n ! Test OpenACC 'kernels' construct decomposition.\n \n ! { dg-additional-options \"-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n ! { dg-additional-options \"-O2\" } for 'parloops'.\n \n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n+\n ! { dg-additional-options \"-Wopenacc-parallelism\" } for testing/documenting\n ! aspects of that functionality.\n \n@@ -13,7 +18,7 @@\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n ! so to maintain compatibility with earlier Tcl releases, we manually\n ! initialize counter variables:\n-! { dg-line l_dummy[variable c_loop_i 0 c_loop_j 0 c_loop_k 0 c_part 0] }\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0 c_part 0] }\n ! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n ! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n@@ -36,70 +41,82 @@ program main\n   integer :: a(N), b(N), c(N)\n \n   !$acc kernels\n-  x = 0 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  x = 0\n   y = 0\n   y_l = x < 10\n   z = x\n   x = x + 1\n   ;\n   !$acc end kernels\n \n-  !$acc kernels ! { dg-optimized \"assigned OpenACC gang loop parallelism\" }\n-  do i = 1, N ! { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" }\n+  !$acc kernels ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  do i = 1, N\n      a(i) = 0\n   end do\n   !$acc end kernels\n \n   !$acc kernels loop ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      b(i) = a(N - i + 1)\n   end do\n \n   !$acc kernels\n   !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      b(i) = a(N - i + 1)\n   end do\n \n   !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      c(i) = a(i) * b(i)\n   end do\n \n-  a(z) = 0 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  a(z) = 0\n \n   !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      c(i) = c(i) + a(i)\n   end do\n \n   !$acc loop seq ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1 + 1, N\n      c(i) = c(i) + c(i - 1)\n   end do\n   !$acc end kernels\n \n-  !$acc kernels\n+  !$acc kernels ! { dg-line l_compute[incr c_compute] }\n   !TODO What does this mean?\n-  !TODO { dg-optimized \"assigned OpenACC worker vector loop parallelism\" \"\" { target *-*-* } .-2 }\n+  !TODO { dg-optimized \"assigned OpenACC worker vector loop parallelism\" \"\" { target *-*-* } l_compute$c_compute }\n   !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      ! { dg-optimized \"assigned OpenACC worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n      do j = 1, N\n         !$acc loop independent ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         ! { dg-warning \"insufficient partitioning available to parallelize loop\" \"\" { target *-*-* } l_loop_k$c_loop_k }\n         ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_k$c_loop_k }\n         do k = 1, N\n@@ -112,43 +129,50 @@ program main\n \n   !TODO Should the following turn into \"gang-single\" instead of \"parloops\"?\n   !TODO The problem is that the first STMT is 'if (y <= 4) goto <D.2547>; else goto <D.2548>;', thus \"parloops\".\n-  if (y < 5) then ! { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  if (y < 5) then\n      !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n      ! { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 1, N\n         b(j) = f_w (c(j))\n      end do\n   end if\n   !$acc end kernels\n \n-  !$acc kernels\n-  ! { dg-bogus \"\\[Ww\\]arning: region contains gang partitioned code but is not gang partitioned\" \"TODO 'kernels'\" { xfail *-*-* } .-1 }\n+  !$acc kernels ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-bogus \"\\[Ww\\]arning: region contains gang partitioned code but is not gang partitioned\" \"TODO 'kernels'\" { xfail *-*-* } l_compute$c_compute }\n   y = f_g (a(5)) ! { dg-line l_part[incr c_part] }\n   !TODO If such a construct is placed in its own part (like it is, here), can't this actually use gang paralelism, instead of \"gang-single\"?\n-  ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" \"\" { target *-*-* } l_part$c_part }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } l_part$c_part }\n   ! { dg-optimized \"assigned OpenACC gang worker vector loop parallelism\" \"\" { target *-*-* } l_part$c_part }\n \n   !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_j$c_loop_j }\n+  ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n   ! { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n   do j = 1, N\n      b(j) = y + f_w (c(j)) ! { dg-optimized \"assigned OpenACC worker vector loop parallelism\" }\n   end do\n   !$acc end kernels\n \n   !$acc kernels\n-  y = 3 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  y = 3\n \n   !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_j$c_loop_j }\n+  ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n   ! { dg-optimized \"assigned OpenACC gang worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n   do j = 1, N\n      b(j) = y + f_v (c(j)) ! { dg-optimized \"assigned OpenACC vector loop parallelism\" }\n   end do\n \n-  z = 2 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  z = 2\n   !$acc end kernels\n \n-  !$acc kernels ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  ! { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n+  !$acc kernels\n   !$acc end kernels  \n end program main"}, {"sha": "a6eb82b87195665656ce3b7abc78066a9bdcf707", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose-ice-1.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose-ice-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose-ice-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose-ice-1.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -4,5 +4,19 @@\n    TODO { dg-prune-output \"during GIMPLE pass: omplower\" }\n    TODO { dg-do link } */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n #undef KERNELS_DECOMPOSE_ICE_HACK\n #include \"declare-vla.c\"\n+\n+/* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } 27 } */\n+\n+/* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } 61 } */\n+\n+/* { dg-bogus {note: variable [^\\n\\r]+ candidate for adjusting OpenACC privatization level} {TODO 'data'} { xfail *-*-* } 42 } */"}, {"sha": "142aceec9cd4e99a8a0c759576f44586680c90f7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -2,5 +2,28 @@\n \n /* See also 'declare-vla-kernels-decompose-ice-1.c'.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n #define KERNELS_DECOMPOSE_ICE_HACK\n #include \"declare-vla.c\"\n+\n+/* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } 27 } */\n+\n+/* { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } 61 } */\n+\n+/* { dg-bogus {note: variable [^\\n\\r]+ candidate for adjusting OpenACC privatization level} {TODO 'data'} { xfail *-*-* } 42 } */\n+\n+/* { dg-note {variable 'i\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } 58 }\n+   { dg-note {variable 'N\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } 58 } */\n+\n+/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { ! __OPTIMIZE__ } } 24 }\n+   { dg-optimized {assigned OpenACC gang loop parallelism} {} { target { __OPTIMIZE__ } } 24 } */\n+\n+/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { ! __OPTIMIZE__ } } 58 }\n+   { dg-optimized {assigned OpenACC gang loop parallelism} {} { target { __OPTIMIZE__ } } 58 } */"}, {"sha": "4ce2e6d1f1875fcb8fb4ca86bbea687cc8503fed", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,5 +1,13 @@\n /* Verify OpenACC 'declare' with VLAs.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n #include <assert.h>\n \n \n@@ -14,6 +22,8 @@ f (void)\n     A[i] = -i;\n \n #pragma acc kernels\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { ! __OPTIMIZE__ } } .-1 }\n+     { dg-optimized {assigned OpenACC gang loop parallelism} {} { target { __OPTIMIZE__ } } .-2 } */\n   for (i = 0; i < N; i++)\n     A[i] = i;\n \n@@ -30,6 +40,7 @@ void\n f_data (void)\n {\n #pragma acc data\n+  /* { dg-bogus {note: variable [^\\n\\r]+ candidate for adjusting OpenACC privatization level} {TODO 'data'} { xfail *-*-* } .-1 } */\n   {\n     int N = 1000;\n     int i, A[N];\n@@ -45,6 +56,8 @@ f_data (void)\n #endif\n \n # pragma acc kernels\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { ! __OPTIMIZE__ } } .-1 }\n+     { dg-optimized {assigned OpenACC gang loop parallelism} {} { target { __OPTIMIZE__ } } .-2 } */\n     for (i = 0; i < N; i++)\n       A[i] = i;\n \n@@ -65,3 +78,6 @@ main ()\n \n   return 0;\n }\n+\n+\n+/* { dg-note dummy \"\" { target n-on-e } } to disable 'prune_notes'.  */"}, {"sha": "e4e58158cf7d538961c254edb824a3293f6df8bb", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/f-asyncwait-1.c", "status": "modified", "additions": 98, "deletions": 31, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-1.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,6 +1,25 @@\n /* { dg-do run } */\n \n-/* Based on asyncwait-1.f90.  */\n+/* Based on '../libgomp.oacc-fortran/asyncwait-1.f90'.  */\n+\n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+/* TODO To avoid PR100280 ICE { dg-additional-options \"--param=openacc-kernels=parloops\" } */\n+\n+/* { dg-additional-options \"-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable '[Di]\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n \n #include <stdlib.h>\n \n@@ -26,8 +45,11 @@ main (void)\n #pragma acc data copy (a[0:N]) copy (b[0:N])\n   {\n \n-#pragma acc parallel async\n-#pragma acc loop\n+#pragma acc parallel async /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       b[i] = a[i];\n \n@@ -50,8 +72,11 @@ main (void)\n \n #pragma acc data copy (a[0:N]) copy (b[0:N])\n   {\n-#pragma acc parallel async (1)\n-#pragma acc loop\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       b[i] = a[i];\n \n@@ -75,17 +100,22 @@ main (void)\n #pragma acc data copy (a[0:N]) copy (b[0:N]) copy (c[0:N]) copy (d[0:N])\n   {\n \n-#pragma acc parallel async (1)\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n     for (int i = 0; i < N; ++i)\n       b[i] = (a[i] * a[i] * a[i]) / a[i];\n \n-#pragma acc parallel async (1)\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n     for (int i = 0; i < N; ++i)\n       c[i] = (a[i] * 4) / a[i];\n \n \n-#pragma acc parallel async (1)\n-#pragma acc loop\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       d[i] = ((a[i] * a[i] + a[i]) / a[i]) - a[i];\n \n@@ -116,23 +146,33 @@ main (void)\n #pragma acc data copy (a[0:N], b[0:N], c[0:N], d[0:N], e[0:N])\n   {\n \n-#pragma acc parallel async (1)\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n     for (int i = 0; i < N; ++i)\n       b[i] = (a[i] * a[i] * a[i]) / a[i];\n \n-#pragma acc parallel async (1)\n-#pragma acc loop\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       c[i] = (a[i] * 4) / a[i];\n \n-#pragma acc parallel async (1)\n-#pragma acc loop\n+#pragma acc parallel async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       d[i] = ((a[i] * a[i] + a[i]) / a[i]) - a[i];\n \n \n-#pragma acc parallel wait (1) async (1)\n-#pragma acc loop\n+#pragma acc parallel wait (1) async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       e[i] = a[i] + b[i] + c[i] + d[i];\n \n@@ -162,8 +202,11 @@ main (void)\n #pragma acc data copy (a[0:N]) copy (b[0:N])\n   {\n \n-#pragma acc kernels async\n-#pragma acc loop\n+#pragma acc kernels async /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       b[i] = a[i];\n \n@@ -186,8 +229,11 @@ main (void)\n \n #pragma acc data copy (a[0:N]) copy (b[0:N])\n   {\n-#pragma acc kernels async (1)\n-#pragma acc loop\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       b[i] = a[i];\n \n@@ -212,16 +258,25 @@ main (void)\n \n #pragma acc data copy (a[0:N]) copy (b[0:N]) copy (c[0:N]) copy (d[0:N])\n   {\n-#pragma acc kernels async (1)\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target { ! __OPTIMIZE__ } } l_compute$c_compute }\n+       { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target { __OPTIMIZE__ } } l_compute$c_compute } */\n     for (int i = 0; i < N; ++i)\n       b[i] = (a[i] * a[i] * a[i]) / a[i];\n \n-#pragma acc kernels async (1)\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target { ! __OPTIMIZE__ } } l_compute$c_compute }\n+       { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target { __OPTIMIZE__ } } l_compute$c_compute } */\n     for (int i = 0; i < N; ++i)\n       c[i] = (a[i] * 4) / a[i];\n \n-#pragma acc kernels async (1)\n-#pragma acc loop\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       d[i] = ((a[i] * a[i] + a[i]) / a[i]) - a[i];\n \n@@ -251,22 +306,34 @@ main (void)\n \n #pragma acc data copy (a[0:N], b[0:N], c[0:N], d[0:N], e[0:N])\n   {\n-#pragma acc kernels async (1)\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target { ! __OPTIMIZE__ } } l_compute$c_compute }\n+       { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target { __OPTIMIZE__ } } l_compute$c_compute } */\n     for (int i = 0; i < N; ++i)\n       b[i] = (a[i] * a[i] * a[i]) / a[i];\n \n-#pragma acc kernels async (1)\n-#pragma acc loop\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       c[i] = (a[i] * 4) / a[i];\n \n-#pragma acc kernels async (1)\n-#pragma acc loop\n+#pragma acc kernels async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       d[i] = ((a[i] * a[i] + a[i]) / a[i]) - a[i];\n \n-#pragma acc kernels wait (1) async (1)\n-#pragma acc loop\n+#pragma acc kernels wait (1) async (1) /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       e[i] = a[i] + b[i] + c[i] + d[i];\n "}, {"sha": "2dd7b5257befc38d007ede2a04ed95d7ec08b9ad", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/f-asyncwait-2.c", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-2.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,6 +1,24 @@\n /* { dg-do run } */\n \n-/* Based on asyncwait-2.f90.  */\n+/* Based on '../libgomp.oacc-fortran/asyncwait-2.f90'.  */\n+\n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n+/* { dg-additional-options \"-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable '[Di]\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n \n #include <stdlib.h>\n \n@@ -15,18 +33,27 @@ main (void)\n   b = (int *)malloc (N * sizeof (*b));\n   c = (int *)malloc (N * sizeof (*c));\n \n-#pragma acc parallel copy (a[0:N]) async (0)\n-#pragma acc loop\n+#pragma acc parallel copy (a[0:N]) async (0) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     a[i] = 1;\n \n-#pragma acc parallel copy (b[0:N]) async (1)\n-#pragma acc loop\n+#pragma acc parallel copy (b[0:N]) async (1) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     b[i] = 1;\n \n-#pragma acc parallel copy (a[0:N], b[0:N], c[0:N]) wait (0, 1)\n-#pragma acc loop\n+#pragma acc parallel copy (a[0:N], b[0:N], c[0:N]) wait (0, 1) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     c[i] = a[i] + b[i];\n \n@@ -35,18 +62,35 @@ main (void)\n       abort ();\n \n #if 1\n-#pragma acc kernels copy (a[0:N]) async (0)\n-#pragma acc loop\n+#pragma acc kernels copy (a[0:N]) async (0) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'a\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     a[i] = 1;\n \n-#pragma acc kernels copy (b[0:N]) async (1)\n-#pragma acc loop\n+#pragma acc kernels copy (b[0:N]) async (1) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'b\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     b[i] = 1;\n \n-#pragma acc kernels copy (a[0:N], b[0:N], c[0:N]) wait (0, 1)\n-#pragma acc loop\n+#pragma acc kernels copy (a[0:N], b[0:N], c[0:N]) wait (0, 1) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'a\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'b\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'c\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     c[i] = a[i] + b[i];\n "}, {"sha": "9d35250b02c962d66bd967af32e849e605ed8aed", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/f-asyncwait-3.c", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ff-asyncwait-3.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,6 +1,24 @@\n /* { dg-do run } */\n \n-/* Based on asyncwait-3.f90.  */\n+/* Based on '../libgomp.oacc-fortran/asyncwait-3.f90'.  */\n+\n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n+/* { dg-additional-options \"-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable '[Di]\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n \n #include <stdlib.h>\n \n@@ -15,20 +33,29 @@ main (void)\n   b = (int *)malloc (N * sizeof (*b));\n   c = (int *)malloc (N * sizeof (*c));\n \n-#pragma acc parallel copy (a[0:N]) async (0)\n-#pragma acc loop\n+#pragma acc parallel copy (a[0:N]) async (0) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     a[i] = 1;\n \n-#pragma acc parallel copy (b[0:N]) async (1)\n-#pragma acc loop\n+#pragma acc parallel copy (b[0:N]) async (1) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     b[i] = 1;\n \n #pragma acc wait (0, 1)\n \n-#pragma acc parallel copy (a[0:N], b[0:N], c[0:N])\n-#pragma acc loop\n+#pragma acc parallel copy (a[0:N], b[0:N], c[0:N]) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     c[i] = a[i] + b[i];\n \n@@ -37,19 +64,31 @@ main (void)\n       abort ();\n \n #pragma acc kernels copy (a[0:N]) async (0)\n-#pragma acc loop\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     a[i] = 1;\n \n #pragma acc kernels copy (b[0:N]) async (1)\n-#pragma acc loop\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     b[i] = 1;\n \n #pragma acc wait (0, 1)\n \n #pragma acc kernels copy (a[0:N], b[0:N], c[0:N])\n-#pragma acc loop\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n   for (int i = 0; i < N; ++i)\n     c[i] = a[i] + b[i];\n "}, {"sha": "b3b4c490f7f34013b30bf84e6f912014475619be", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-decompose-1.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-decompose-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-decompose-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-decompose-1.c?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,11 +1,11 @@\n /* Test OpenACC 'kernels' construct decomposition.  */\n \n-/* { dg-additional-options \"-fopt-info-omp-all\" } */\n /* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n \n /* { dg-additional-options \"-fopt-info-all-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n    { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n    for testing/documenting aspects of that functionality.  */\n \n@@ -30,22 +30,24 @@ int main()\n \n #pragma acc kernels /* { dg-line l_compute[incr c_compute] } */\n   {\n-    int c = 234; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    int c = 234;\n     /* { dg-note {variable 'c' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_compute$c_compute }\n        { dg-note {variable 'c\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n \n     /*TODO Hopefully, this is the same issue as '../../../gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c'.  */\n     (volatile int *) &c;\n \n #pragma acc loop independent gang /* { dg-line l_loop_i[incr c_loop_i] } */\n-    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n     for (int i = 0; i < N; ++i)\n       b[i] = c;\n \n-    a = c; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 } */\n+    a = c;\n   }\n \n   for (int i = 0; i < N; ++i)"}, {"sha": "9440cd7f1b54058879dbda41e72c0f4d7da4b241", "filename": "libgomp/testsuite/libgomp.oacc-fortran/asyncwait-1.f90", "status": "modified", "additions": 71, "deletions": 15, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-1.f90?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,5 +1,25 @@\n ! { dg-do run }\n \n+! See also '../libgomp.oacc-c-c++-common/f-asyncwait-1.c'.\n+\n+! { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n+! { dg-additional-options \"-fopt-info-all-omp\" }\n+! { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n program asyncwait\n   integer, parameter :: N = 64\n   real, allocatable :: a(:), b(:), c(:), d(:), e(:)\n@@ -17,7 +37,9 @@ program asyncwait\n   !$acc data copy (a(1:N)) copy (b(1:N))\n \n   !$acc parallel async\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      b(i) = a(i)\n   end do\n@@ -37,7 +59,9 @@ program asyncwait\n   !$acc data copy (a(1:N)) copy (b(1:N))\n \n   !$acc parallel async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      b(i) = a(i)\n   end do\n@@ -71,7 +95,9 @@ program asyncwait\n   !$acc end parallel\n \n   !$acc parallel async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      d(i) = ((a(i) * a(i) + a(i)) / a(i)) - a(i)\n   end do\n@@ -102,21 +128,27 @@ program asyncwait\n   !$acc end parallel\n \n   !$acc parallel async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      c(i) = (a(i) * 4) / a(i)\n   end do\n   !$acc end parallel\n \n   !$acc parallel async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      d(i) = ((a(i) * a(i) + a(i)) / a(i)) - a(i)\n   end do\n   !$acc end parallel\n \n   !$acc parallel wait (1) async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      e(i) = a(i) + b(i) + c(i) + d(i)\n   end do\n@@ -139,7 +171,10 @@ program asyncwait\n   !$acc data copy (a(1:N)) copy (b(1:N))\n \n   !$acc kernels async\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      b(i) = a(i)\n   end do\n@@ -159,7 +194,10 @@ program asyncwait\n   !$acc data copy (a(1:N)) copy (b(1:N))\n \n   !$acc kernels async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      b(i) = a(i)\n   end do\n@@ -180,20 +218,27 @@ program asyncwait\n \n   !$acc data copy (a(1:N)) copy (b(1:N)) copy (c(1:N)) copy (d(1:N))\n \n-  !$acc kernels async (1)\n+  !$acc kernels async (1) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n   do i = 1, N\n      b(i) = (a(i) * a(i) * a(i)) / a(i)\n   end do\n   !$acc end kernels\n \n-  !$acc kernels async (1)\n+  !$acc kernels async (1) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n   do i = 1, N\n      c(i) = (a(i) * 4) / a(i)\n   end do\n   !$acc end kernels\n \n   !$acc kernels async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      d(i) = ((a(i) * a(i) + a(i)) / a(i)) - a(i)\n   end do\n@@ -217,28 +262,39 @@ program asyncwait\n \n   !$acc data copy (a(1:N), b(1:N), c(1:N), d(1:N), e(1:N))\n \n-  !$acc kernels async (1)\n+  !$acc kernels async (1) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {beginning 'parloops' part in OpenACC 'kernels' region} {} { target *-*-* } .+1 }\n   do i = 1, N\n      b(i) = (a(i) * a(i) * a(i)) / a(i)\n   end do\n   !$acc end kernels\n \n   !$acc kernels async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      c(i) = (a(i) * 4) / a(i)\n   end do\n   !$acc end kernels\n \n   !$acc kernels async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      d(i) = ((a(i) * a(i) + a(i)) / a(i)) - a(i)\n   end do\n   !$acc end kernels\n \n   !$acc kernels wait (1) async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n      e(i) = a(i) + b(i) + c(i) + d(i)\n   end do"}, {"sha": "0cc07ad4d2ae702132de6990f8d0cbd9d486eea3", "filename": "libgomp/testsuite/libgomp.oacc-fortran/asyncwait-2.f90", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-2.f90?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,5 +1,25 @@\n ! { dg-do run }\n \n+! See also '../libgomp.oacc-c-c++-common/f-asyncwait-2.c'.\n+\n+! { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n+! { dg-additional-options \"-fopt-info-all-omp\" }\n+! { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n program asyncwait\n   integer, parameter :: N = 64\n   real, allocatable :: a(:), b(:), c(:)\n@@ -10,21 +30,27 @@ program asyncwait\n   allocate (c(N))\n \n   !$acc parallel async (0)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     a(i) = 1\n   end do\n   !$acc end parallel\n \n   !$acc parallel async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     b(i) = 1\n   end do\n   !$acc end parallel\n \n   !$acc parallel wait (0, 1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     c(i) = a(i) + b(i)\n   end do\n@@ -35,21 +61,30 @@ program asyncwait\n   end do\n \n   !$acc kernels async (0)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     a(i) = 1\n   end do\n   !$acc end kernels\n \n   !$acc kernels async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     b(i) = 1\n   end do\n   !$acc end kernels\n \n   !$acc kernels wait (0, 1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     c(i) = a(i) + b(i)\n   end do"}, {"sha": "dbccec206da695a8f6514b6159d0d069becfb9c1", "filename": "libgomp/testsuite/libgomp.oacc-fortran/asyncwait-3.f90", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-3.f90?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,5 +1,25 @@\n ! { dg-do run }\n \n+! See also '../libgomp.oacc-c-c++-common/f-asyncwait-3.c'.\n+\n+! { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n+! { dg-additional-options \"-fopt-info-all-omp\" }\n+! { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n program asyncwait\n   integer, parameter :: N = 64\n   real, allocatable :: a(:), b(:), c(:)\n@@ -10,14 +30,18 @@ program asyncwait\n   allocate (c(N))\n \n   !$acc parallel async (0)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     a(i) = 1\n   end do\n   !$acc end parallel\n \n   !$acc parallel async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     b(i) = 1\n   end do\n@@ -26,7 +50,9 @@ program asyncwait\n   !$acc wait (0, 1)\n \n   !$acc parallel\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     c(i) = a(i) + b(i)\n   end do\n@@ -37,14 +63,20 @@ program asyncwait\n   end do\n \n   !$acc kernels async (0)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     a(i) = 1\n   end do\n   !$acc end kernels\n \n   !$acc kernels async (1)\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     b(i) = 1\n   end do\n@@ -53,7 +85,10 @@ program asyncwait\n   !$acc wait (0, 1)\n \n   !$acc kernels\n-  !$acc loop\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, N\n     c(i) = a(i) + b(i)\n   end do"}, {"sha": "6db25719a97042a30d8f01332fe12c6c8151cdcd", "filename": "libgomp/testsuite/libgomp.oacc-fortran/pr94358-1.f90", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr94358-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr94358-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr94358-1.f90?ref=862e5f398b7e0a62460e8bc3fe4045e9da6cbf3b", "patch": "@@ -1,12 +1,20 @@\n ! { dg-do run }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-all-omp\" }\n+\n ! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n \n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n+\n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n ! so to maintain compatibility with earlier Tcl releases, we manually\n ! initialize counter variables:\n-! { dg-line l_dummy[variable c_loop_i 0] }\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n ! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n ! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n@@ -15,15 +23,19 @@ subroutine kernel(lo, hi, a, b, c)\n   integer :: lo, hi, i\n   real, dimension(lo:hi) :: a, b, c\n \n-  !$acc kernels copyin(lo, hi)\n+  !$acc kernels copyin(lo, hi) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-note {variable 'lo\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {variable 'hi\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute }\n   !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = lo, hi\n      b(i) = a(i)\n   end do\n   !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n-  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = lo, hi\n      c(i) = b(i)"}]}