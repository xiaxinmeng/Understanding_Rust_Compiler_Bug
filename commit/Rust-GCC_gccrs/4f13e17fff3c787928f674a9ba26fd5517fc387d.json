{"sha": "4f13e17fff3c787928f674a9ba26fd5517fc387d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYxM2UxN2ZmZjNjNzg3OTI4ZjY3NGE5YmEyNmZkNTUxN2ZjMzg3ZA==", "commit": {"author": {"name": "Daniel Carrera", "email": "dcarrera@gmail.com", "date": "2011-07-27T10:10:06Z"}, "committer": {"name": "Daniel Carrera", "email": "dcarrera@gcc.gnu.org", "date": "2011-07-27T10:10:06Z"}, "message": "re PR fortran/49755 (ALLOCATE with STAT= produces invalid code for already allocated vars)\n\n2011-07-26  Daniel Carrera  <dcarrera@gmail.com>\n\n\tPR fortran/49755\n\t* trans.c (gfc_allocate_using_malloc): Change function signature.\n\tReturn nothing. New parameter \"pointer\". Eliminate temorary variables.\n\t(gfc_allocate_using_lib): Ditto.\n\t(gfc_allocate_allocatable): Ditto. Update call to gfc_allocate_using_lib\n\tand gfc_allocate_using_malloc. Do not free and then reallocate a\n\tvariable that is already allocated.\n\t(gfc_likely): New function. Basedon gfc_unlikely.\n\t* trans-array.c (gfc_array_init_size): New parameter \"descriptor_block\".\n\tInstructions to modify the array descriptor are stored in this block\n\twhile other instructions continue to be stored in \"pblock\".\n\t(gfc_array_allocate): Update call to gfc_array_init_size. Move the\n\tdescriptor_block so that the array descriptor is only updated if\n\tthe array was allocated successfully.\n\tUpdate calls to gfc_allocate_allocatable and gfc_allocate_using_malloc.\n\t* trans.h (gfc_allocate_allocatable): Change function signature.\n\tFunction now returns void.\n\t(gfc_allocate_using_lib): Ditto, and new function parameter.\n\t(gfc_allocate_using_malloc): Ditto.\n\t* trans-openmp.c (gfc_omp_clause_default_ctor,\n\tgfc_omp_clause_copy_ctor,gfc_trans_omp_array_reduction): Replace a call\n\tto gfc_allocate_allocatable with gfc_allocate_using_malloc.\n\t* trans-stmt.c (gfc_trans_allocate): Update function calls for\n\tgfc_allocate_allocatable and gfc_allocate_using_malloc.\n\n\n\n2011-07-26  Daniel Carrera  <dcarrera@gmail.com>\n\n\tPR fortran/49755\n\t* gfortran.dg/multiple_allocation_1.f90: Fix test. Allocating an\n\tallocated array should *not* change its size.\n\t* gfortran.dg/multiple_allocation_3.f90: New test.\n\nFrom-SVN: r176822", "tree": {"sha": "0ce63aa3e4271ca28e6a80ffa44834d9407308ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ce63aa3e4271ca28e6a80ffa44834d9407308ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f13e17fff3c787928f674a9ba26fd5517fc387d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f13e17fff3c787928f674a9ba26fd5517fc387d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f13e17fff3c787928f674a9ba26fd5517fc387d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f13e17fff3c787928f674a9ba26fd5517fc387d/comments", "author": {"login": "dcarrera", "id": 89128, "node_id": "MDQ6VXNlcjg5MTI4", "avatar_url": "https://avatars.githubusercontent.com/u/89128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcarrera", "html_url": "https://github.com/dcarrera", "followers_url": "https://api.github.com/users/dcarrera/followers", "following_url": "https://api.github.com/users/dcarrera/following{/other_user}", "gists_url": "https://api.github.com/users/dcarrera/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcarrera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcarrera/subscriptions", "organizations_url": "https://api.github.com/users/dcarrera/orgs", "repos_url": "https://api.github.com/users/dcarrera/repos", "events_url": "https://api.github.com/users/dcarrera/events{/privacy}", "received_events_url": "https://api.github.com/users/dcarrera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7bbdd4e9c3f0647ee683a7e433128737139275fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bbdd4e9c3f0647ee683a7e433128737139275fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bbdd4e9c3f0647ee683a7e433128737139275fe"}], "stats": {"total": 275, "additions": 166, "deletions": 109}, "files": [{"sha": "a2614a046728b7a80bbcb9ee1697de4877b21540", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -1,3 +1,30 @@\n+2011-07-27  Daniel Carrera  <dcarrera@gmail.com>\n+\n+\tPR fortran/49755\n+\t* trans.c (gfc_allocate_using_malloc): Change function signature.\n+\tReturn nothing. New parameter \"pointer\". Eliminate temorary variables. \n+\t(gfc_allocate_using_lib): Ditto.\n+\t(gfc_allocate_allocatable): Ditto. Update call to gfc_allocate_using_lib\n+\tand gfc_allocate_using_malloc. Do not free and then reallocate a\n+\tvariable that is already allocated.\n+\t(gfc_likely): New function. Basedon gfc_unlikely.\n+\t* trans-array.c (gfc_array_init_size): New parameter \"descriptor_block\".\n+\tInstructions to modify the array descriptor are stored in this block\n+\twhile other instructions continue to be stored in \"pblock\".\n+\t(gfc_array_allocate): Update call to gfc_array_init_size. Move the\n+\tdescriptor_block so that the array descriptor is only updated if\n+\tthe array was allocated successfully.\n+\tUpdate calls to gfc_allocate_allocatable and gfc_allocate_using_malloc.\n+\t* trans.h (gfc_allocate_allocatable): Change function signature.\n+\tFunction now returns void.\n+\t(gfc_allocate_using_lib): Ditto, and new function parameter.\n+\t(gfc_allocate_using_malloc): Ditto.\n+\t* trans-openmp.c (gfc_omp_clause_default_ctor,\n+\tgfc_omp_clause_copy_ctor,gfc_trans_omp_array_reduction): Replace a call\n+\tto gfc_allocate_allocatable with gfc_allocate_using_malloc.\n+\t* trans-stmt.c (gfc_trans_allocate): Update function calls for\n+\tgfc_allocate_allocatable and gfc_allocate_using_malloc.\n+\n 2011-07-26  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-array.c (CAF_TOKEN_FIELD): New macro constant."}, {"sha": "dc8fdb8dff196c5c79f31fcfbae1c43ede22fd4e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -4164,7 +4164,7 @@ gfc_conv_descriptor_cosize (tree desc, int rank, int corank)\n \tsize = 1 - lbound;\n \ta.ubound[n] = specified_upper_bound;\n \ta.stride[n] = stride;\n-\tsize = siz >= 0 ? ubound + size : 0; //size = ubound + 1 - lbound\n+\tsize = size >= 0 ? ubound + size : 0; //size = ubound + 1 - lbound\n \toverflow += size == 0 ? 0: (MAX/size < stride ? 1: 0);\n \tstride = stride * size;\n       }\n@@ -4182,8 +4182,8 @@ gfc_conv_descriptor_cosize (tree desc, int rank, int corank)\n \n static tree\n gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n-\t\t     gfc_expr ** lower, gfc_expr ** upper,\n-\t\t     stmtblock_t * pblock, tree * overflow)\n+\t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n+\t\t     stmtblock_t * descriptor_block, tree * overflow)\n {\n   tree type;\n   tree tmp;\n@@ -4209,7 +4209,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n   /* Set the dtype.  */\n   tmp = gfc_conv_descriptor_dtype (descriptor);\n-  gfc_add_modify (pblock, tmp, gfc_get_dtype (TREE_TYPE (descriptor)));\n+  gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (TREE_TYPE (descriptor)));\n \n   or_expr = boolean_false_node;\n \n@@ -4242,8 +4242,8 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t      ubound = lower[n];\n \t    }\n \t}\n-      gfc_conv_descriptor_lbound_set (pblock, descriptor, gfc_rank_cst[n],\n-\t\t\t\t      se.expr);\n+      gfc_conv_descriptor_lbound_set (descriptor_block, descriptor, \n+\t\t\t\t      gfc_rank_cst[n], se.expr);\n       conv_lbound = se.expr;\n \n       /* Work out the offset for this component.  */\n@@ -4258,12 +4258,12 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n       gfc_add_block_to_block (pblock, &se.pre);\n \n-      gfc_conv_descriptor_ubound_set (pblock, descriptor,\n+      gfc_conv_descriptor_ubound_set (descriptor_block, descriptor,\n \t\t\t\t      gfc_rank_cst[n], se.expr);\n       conv_ubound = se.expr;\n \n       /* Store the stride.  */\n-      gfc_conv_descriptor_stride_set (pblock, descriptor,\n+      gfc_conv_descriptor_stride_set (descriptor_block, descriptor,\n \t\t\t\t      gfc_rank_cst[n], stride);\n \n       /* Calculate size and check whether extent is negative.  */\n@@ -4323,16 +4323,16 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t      ubound = lower[n];\n \t    }\n \t}\n-      gfc_conv_descriptor_lbound_set (pblock, descriptor, gfc_rank_cst[n],\n-\t\t\t\t      se.expr);\n+      gfc_conv_descriptor_lbound_set (descriptor_block, descriptor, \n+\t\t\t\t      gfc_rank_cst[n], se.expr);\n \n       if (n < rank + corank - 1)\n \t{\n \t  gfc_init_se (&se, NULL);\n \t  gcc_assert (ubound);\n \t  gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n \t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  gfc_conv_descriptor_ubound_set (pblock, descriptor,\n+\t  gfc_conv_descriptor_ubound_set (descriptor_block, descriptor,\n \t\t\t\t\t  gfc_rank_cst[n], se.expr);\n \t}\n     }\n@@ -4415,6 +4415,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   tree overflow; /* Boolean storing whether size calculation overflows.  */\n   tree var_overflow = NULL_TREE;\n   tree cond;\n+  tree set_descriptor;\n+  stmtblock_t set_descriptor_block;\n   stmtblock_t elseblock;\n   gfc_expr **lower;\n   gfc_expr **upper;\n@@ -4481,9 +4483,12 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n     }\n \n   overflow = integer_zero_node;\n+\n+  gfc_init_block (&set_descriptor_block);\n   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n-\t\t\t      &se->pre, &overflow);\n+\t\t\t      &se->pre, &set_descriptor_block, &overflow);\n+\n   if (dimension)\n     {\n \n@@ -4511,22 +4516,17 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n     }\n \n   gfc_start_block (&elseblock);\n-  \n+\n   /* Allocate memory to store the data.  */\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n   STRIP_NOPS (pointer);\n \n   /* The allocatable variant takes the old pointer as first argument.  */\n   if (allocatable)\n-    tmp = gfc_allocate_allocatable (&elseblock, pointer, size,\n-\t\t\t\t    status, errmsg, errlen, expr);\n+    gfc_allocate_allocatable (&elseblock, pointer, size,\n+\t\t\t      status, errmsg, errlen, expr);\n   else\n-    tmp = gfc_allocate_using_malloc (&elseblock, size, status);\n-\n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t\t pointer, tmp);\n-\n-  gfc_add_expr_to_block (&elseblock, tmp);\n+    gfc_allocate_using_malloc (&elseblock, pointer, size, status);\n \n   if (dimension)\n     {\n@@ -4540,8 +4540,23 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n   gfc_add_expr_to_block (&se->pre, tmp);\n \n+  /* Update the array descriptors. */\n   if (dimension)\n-    gfc_conv_descriptor_offset_set (&se->pre, se->expr, offset);\n+    gfc_conv_descriptor_offset_set (&set_descriptor_block, se->expr, offset);\n+  \n+  set_descriptor = gfc_finish_block (&set_descriptor_block);\n+  if (status != NULL_TREE)\n+    {\n+      cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t  boolean_type_node, status,\n+\t\t\t  build_int_cst (TREE_TYPE (status), 0));\n+      gfc_add_expr_to_block (&se->pre,\n+\t\t fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t  gfc_likely (cond), set_descriptor,\n+\t\t\t\t  build_empty_stmt (input_location))); \n+    }\n+  else\n+      gfc_add_expr_to_block (&se->pre, set_descriptor);\n \n   if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)\n \t&& expr->ts.u.derived->attr.alloc_comp)"}, {"sha": "29e342f13fbf0c0d877bd74ff941dafabe4884e9", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -188,10 +188,11 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n   size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n-  ptr = gfc_allocate_allocatable (&cond_block,\n-\t\t\t  build_int_cst (pvoid_type_node, 0),\n-\t\t\t  size, NULL_TREE, NULL_TREE, NULL_TREE, NULL);\n+\n+  ptr = gfc_create_var (pvoid_type_node, NULL);\n+  gfc_allocate_using_malloc (&cond_block, ptr, size, NULL_TREE);\n   gfc_conv_descriptor_data_set (&cond_block, decl, ptr);\n+\n   then_b = gfc_finish_block (&cond_block);\n \n   gfc_init_block (&cond_block);\n@@ -241,10 +242,11 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n-  ptr = gfc_allocate_allocatable (&block,\n-\t\t\t  build_int_cst (pvoid_type_node, 0),\n-\t\t\t  size, NULL_TREE, NULL_TREE, NULL_TREE, NULL);\n+\n+  ptr = gfc_create_var (pvoid_type_node, NULL);\n+  gfc_allocate_using_malloc (&block, ptr, size, NULL_TREE);\n   gfc_conv_descriptor_data_set (&block, dest, ptr);\n+\n   call = build_call_expr_loc (input_location,\n \t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n \t\t\t  fold_convert (pvoid_type_node,\n@@ -663,10 +665,11 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t      size, esize);\n       size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n-      ptr = gfc_allocate_allocatable (&block,\n-\t\t\t      build_int_cst (pvoid_type_node, 0),\n-\t\t\t      size, NULL_TREE, NULL_TREE, NULL_TREE, NULL);\n+\n+      ptr = gfc_create_var (pvoid_type_node, NULL);\n+      gfc_allocate_using_malloc (&block, ptr, size, NULL_TREE);\n       gfc_conv_descriptor_data_set (&block, decl, ptr);\n+\n       gfc_add_expr_to_block (&block, gfc_trans_assignment (e1, e2, false,\n \t\t\t     false));\n       stmt = gfc_finish_block (&block);"}, {"sha": "defa44565389984ef16905139c9f7909643c3bd0", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -4867,15 +4867,10 @@ gfc_trans_allocate (gfc_code * code)\n \n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n \t  if (gfc_expr_attr (expr).allocatable)\n-\t    tmp = gfc_allocate_allocatable (&se.pre, se.expr, memsz,\n-\t\t\t\t\t    stat, errmsg, errlen, expr);\n+\t    gfc_allocate_allocatable (&se.pre, se.expr, memsz,\n+\t\t\t\t      stat, errmsg, errlen, expr);\n \t  else\n-\t    tmp = gfc_allocate_using_malloc (&se.pre, memsz, stat);\n-\n-\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t\t\t se.expr,\n-\t\t\t\t fold_convert (TREE_TYPE (se.expr), tmp));\n-\t  gfc_add_expr_to_block (&se.pre, tmp);\n+\t    gfc_allocate_using_malloc (&se.pre, se.expr, memsz, stat);\n \n \t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n \t    {\n@@ -4901,7 +4896,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t  boolean_type_node, stat,\n \t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t parm, tmp,\n+\t\t\t\t gfc_unlikely(parm), tmp,\n \t\t\t\t     build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}"}, {"sha": "2f8c7fdc440185921f2e362a4e32e21c81da4883", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -582,31 +582,27 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       }\n       return newmem;\n     }  */\n-tree\n-gfc_allocate_using_malloc (stmtblock_t * block, tree size, tree status)\n+void\n+gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n+\t\t\t   tree size, tree status)\n {\n-  stmtblock_t alloc_block;\n-  tree res, tmp, on_error;\n+  tree tmp, on_error, error_cond;\n   tree status_type = status ? TREE_TYPE (status) : NULL_TREE;\n \n   /* Evaluate size only once, and make sure it has the right type.  */\n   size = gfc_evaluate_now (size, block);\n   if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n     size = fold_convert (size_type_node, size);\n \n-  /* Create a variable to hold the result.  */\n-  res = gfc_create_var (prvoid_type_node, NULL);\n-\n-  /* Set the optional status variable to zero.  */\n+  /* If successful and stat= is given, set status to 0.  */\n   if (status != NULL_TREE)\n       gfc_add_expr_to_block (block,\n \t     fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n \t\t\t      status, build_int_cst (status_type, 0)));\n \n   /* The allocation itself.  */\n-  gfc_start_block (&alloc_block);\n-  gfc_add_modify (&alloc_block, res,\n-\t  fold_convert (prvoid_type_node,\n+  gfc_add_modify (block, pointer,\n+\t  fold_convert (TREE_TYPE (pointer),\n \t\tbuild_call_expr_loc (input_location,\n \t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n \t\t\t     fold_build2_loc (input_location,\n@@ -623,16 +619,14 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree size, tree status)\n \t\t\t\t gfc_build_localized_cstring_const\n \t\t\t\t (\"Allocation would exceed memory limit\")));\n \n+  error_cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\tboolean_type_node, pointer,\n+\t\t\t\tbuild_int_cst (prvoid_type_node, 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t\t  boolean_type_node, res,\n-\t\t\t\t\t  build_int_cst (prvoid_type_node, 0)),\n-\t\t\t on_error, build_empty_stmt (input_location));\n-\n-  gfc_add_expr_to_block (&alloc_block, tmp);\n-  gfc_add_expr_to_block (block, gfc_finish_block (&alloc_block));\n+\t\t\t gfc_unlikely(error_cond), on_error,\n+\t\t\t build_empty_stmt (input_location));\n \n-  return res;\n+  gfc_add_expr_to_block (block, tmp);\n }\n \n \n@@ -648,20 +642,17 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree size, tree status)\n       newmem = _caf_register ( size, regtype, NULL, &stat, NULL, NULL);\n       return newmem;\n     }  */\n-tree\n-gfc_allocate_using_lib (stmtblock_t * block, tree size, tree status,\n-\t\t\ttree errmsg, tree errlen)\n+void\n+gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n+\t\t\ttree status, tree errmsg, tree errlen)\n {\n-  tree res, pstat;\n+  tree tmp, pstat;\n \n   /* Evaluate size only once, and make sure it has the right type.  */\n   size = gfc_evaluate_now (size, block);\n   if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n     size = fold_convert (size_type_node, size);\n \n-  /* Create a variable to hold the result.  */\n-  res = gfc_create_var (prvoid_type_node, NULL);\n-\n   /* The allocation itself.  */\n   if (status == NULL_TREE)\n     pstat  = null_pointer_node;\n@@ -675,19 +666,20 @@ gfc_allocate_using_lib (stmtblock_t * block, tree size, tree status,\n       errlen = build_int_cst (integer_type_node, 0);\n     }\n \n-  gfc_add_modify (block, res,\n-\t  fold_convert (prvoid_type_node,\n-\t\tbuild_call_expr_loc (input_location,\n-\t\t     gfor_fndecl_caf_register, 6,\n-\t\t     fold_build2_loc (input_location,\n+  tmp = build_call_expr_loc (input_location,\n+\t     gfor_fndecl_caf_register, 6,\n+\t     fold_build2_loc (input_location,\n \t\t\t      MAX_EXPR, size_type_node, size,\n \t\t\t      build_int_cst (size_type_node, 1)),\n-\t\t     build_int_cst (integer_type_node,\n+\t     build_int_cst (integer_type_node,\n \t\t\t    GFC_CAF_COARRAY_ALLOC),\n-\t\t     null_pointer_node,  /* token  */\n-\t\t     pstat, errmsg, errlen)));\n+\t     null_pointer_node,  /* token  */\n+\t     pstat, errmsg, errlen);\n \n-  return res;\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t TREE_TYPE (pointer), pointer,\n+\t\t\t fold_convert ( TREE_TYPE (pointer), tmp));\n+  gfc_add_expr_to_block (block, tmp);\n }\n \n \n@@ -705,32 +697,25 @@ gfc_allocate_using_lib (stmtblock_t * block, tree size, tree status,\n       else\n       {\n \tif (stat)\n-\t{\n-\t  free (mem);\n-\t  mem = allocate (size, stat);\n \t  stat = LIBERROR_ALLOCATION;\n-\t  return mem;\n-\t}\n \telse\n \t  runtime_error (\"Attempting to allocate already allocated variable\");\n       }\n     }\n     \n     expr must be set to the original expression being allocated for its locus\n     and variable name in case a runtime error has to be printed.  */\n-tree\n+void\n gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree status,\n \t\t\t  tree errmsg, tree errlen, gfc_expr* expr)\n {\n   stmtblock_t alloc_block;\n-  tree res, tmp, null_mem, alloc, error;\n+  tree tmp, null_mem, alloc, error;\n   tree type = TREE_TYPE (mem);\n \n   if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n     size = fold_convert (size_type_node, size);\n \n-  /* Create a variable to hold the result.  */\n-  res = gfc_create_var (type, NULL);\n   null_mem = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t    boolean_type_node, mem,\n \t\t\t\t\t    build_int_cst (type, 0)));\n@@ -741,12 +726,11 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree status,\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB\n       && gfc_expr_attr (expr).codimension)\n-    tmp = gfc_allocate_using_lib (&alloc_block, size, status,\n-\t\t\t\t  errmsg, errlen);\n+    gfc_allocate_using_lib (&alloc_block, mem, size, status,\n+\t\t\t    errmsg, errlen);\n   else\n-    tmp = gfc_allocate_using_malloc (&alloc_block, size, status);\n+    gfc_allocate_using_malloc (&alloc_block, mem, size, status);\n \n-  gfc_add_modify (&alloc_block, res, fold_convert (type, tmp));\n   alloc = gfc_finish_block (&alloc_block);\n \n   /* If mem is not NULL, we issue a runtime error or set the\n@@ -772,27 +756,14 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree status,\n   if (status != NULL_TREE)\n     {\n       tree status_type = TREE_TYPE (status);\n-      stmtblock_t set_status_block;\n-\n-      gfc_start_block (&set_status_block);\n-      tmp = build_call_expr_loc (input_location,\n-\t\t\t     built_in_decls[BUILT_IN_FREE], 1,\n-\t\t\t     fold_convert (pvoid_type_node, mem));\n-      gfc_add_expr_to_block (&set_status_block, tmp);\n-\n-      tmp = gfc_allocate_using_malloc (&set_status_block, size, status);\n-      gfc_add_modify (&set_status_block, res, fold_convert (type, tmp));\n \n-      gfc_add_modify (&set_status_block, status,\n-\t\t      build_int_cst (status_type, LIBERROR_ALLOCATION));\n-      error = gfc_finish_block (&set_status_block);\n+      error = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t      status, build_int_cst (status_type, LIBERROR_ALLOCATION));\n     }\n \n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, null_mem,\n \t\t\t error, alloc);\n   gfc_add_expr_to_block (block, tmp);\n-\n-  return res;\n }\n \n \n@@ -1619,3 +1590,19 @@ gfc_unlikely (tree cond)\n   cond = fold_convert (boolean_type_node, cond);\n   return cond;\n }\n+\n+\n+/* Helper function for marking a boolean expression tree as likely.  */\n+\n+tree\n+gfc_likely (tree cond)\n+{\n+  tree tmp;\n+\n+  cond = fold_convert (long_integer_type_node, cond);\n+  tmp = build_one_cst (long_integer_type_node);\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+  cond = fold_convert (boolean_type_node, cond);\n+  return cond;\n+}"}, {"sha": "a53360feb7d4e1c21de9d576734057d266d3d41c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -517,7 +517,8 @@ void gfc_generate_constructors (void);\n /* Get the string length of an array constructor.  */\n bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor_base, tree *);\n \n-/* Mark a condition as unlikely.  */\n+/* Mark a condition as likely or unlikely.  */\n+tree gfc_likely (tree);\n tree gfc_unlikely (tree);\n \n /* Generate a runtime error call.  */\n@@ -541,12 +542,12 @@ tree gfc_call_malloc (stmtblock_t *, tree, tree);\n tree gfc_build_memcpy_call (tree, tree, tree);\n \n /* Allocate memory for allocatable variables, with optional status variable.  */\n-tree gfc_allocate_allocatable (stmtblock_t*, tree, tree,\n+void gfc_allocate_allocatable (stmtblock_t*, tree, tree,\n \t\t\t       tree, tree, tree, gfc_expr*);\n \n /* Allocate memory, with optional status variable.  */\n-tree gfc_allocate_using_malloc (stmtblock_t *, tree, tree);\n-tree gfc_allocate_using_lib (stmtblock_t *, tree, tree, tree, tree);\n+void gfc_allocate_using_malloc (stmtblock_t *, tree, tree, tree);\n+void gfc_allocate_using_lib (stmtblock_t *, tree, tree, tree, tree, tree);\n \n /* Generate code to deallocate an array.  */\n tree gfc_deallocate_with_status (tree, tree, bool, gfc_expr*);"}, {"sha": "a1df3d19816eddafcdaa036289f638eac86679c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -1,3 +1,10 @@\n+2011-07-27  Daniel Carrera  <dcarrera@gmail.com>\n+\n+\tPR fortran/49755\n+\t* gfortran.dg/multiple_allocation_1.f90: Fix test. Allocating an\n+\tallocated array should *not* change its size.\n+\t* gfortran.dg/multiple_allocation_3.f90: New test.\n+\n 2011-07-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/49776"}, {"sha": "58888f0e31b00b7f3a374b4dc1fc167e6b887013", "filename": "gcc/testsuite/gfortran.dg/multiple_allocation_1.f90", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_1.f90?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -1,18 +1,21 @@\n ! { dg-do run }\n ! PR 25031 - We didn't cause an error when allocating an already\n !            allocated array.\n+!\n+! This testcase has been modified to fix PR 49755. \n program alloc_test\n   implicit none\n   integer :: i\n   integer, allocatable :: a(:)\n   integer, pointer :: b(:)\n \n   allocate(a(4))\n-  ! This should set the stat code and change the size.\n+  ! This should set the stat code but not change the size.\n   allocate(a(3),stat=i)\n   if (i == 0) call abort\n   if (.not. allocated(a)) call abort\n-  if (size(a) /= 3) call abort\n+  if (size(a) /= 4) call abort\n+\n   ! It's OK to allocate pointers twice (even though this causes\n   ! a memory leak)\n   allocate(b(4))"}, {"sha": "482b388a4d5dff0b5c864fa2724ff549598f40ef", "filename": "gcc/testsuite/gfortran.dg/multiple_allocation_3.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f13e17fff3c787928f674a9ba26fd5517fc387d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmultiple_allocation_3.f90?ref=4f13e17fff3c787928f674a9ba26fd5517fc387d", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! PR 49755 - If allocating an already allocated array, and stat=\n+!            is given, set stat to non zero and do not touch the array.\n+program test\n+    integer, allocatable :: A(:, :)\n+    integer :: stat\n+\n+    allocate(A(20,20))\n+    A = 42\n+\n+    ! Allocate of already allocated variable\n+    allocate (A(5,5), stat=stat)\n+\n+    ! Expected: Error stat and previous allocation status\n+    if (stat == 0) call abort ()\n+    if (any (shape (A) /= [20, 20])) call abort ()\n+    if (any (A /= 42)) call abort ()\n+end program\n+"}]}