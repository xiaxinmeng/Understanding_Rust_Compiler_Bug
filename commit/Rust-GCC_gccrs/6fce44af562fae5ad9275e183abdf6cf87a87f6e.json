{"sha": "6fce44af562fae5ad9275e183abdf6cf87a87f6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZjZTQ0YWY1NjJmYWU1YWQ5Mjc1ZTE4M2FiZGY2Y2Y4N2E4N2Y2ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-03-21T18:09:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-03-21T18:09:20Z"}, "message": "alias.c (get_alias_set): Remove handling of PLACEHOLDER_EXPR.\n\n\t* alias.c (get_alias_set): Remove handling of PLACEHOLDER_EXPR.\n\t* emit-rtl.c (component_ref_for_mem_expr): Likewise.\n\t(set_mem_attributes_minus_bitpos): Call SUBSTITUTE_PLACEHOLDER_IN_EXPR.\n\t* explow.c (expr_size): Likewise.\n\t* expr.h (placeholder_list, find_placeholder): Deleted.\n\t* expr.c (store_constructor): Likewise.\n\t(get_inner_reference): Likewise.  Also don't call find_placeholder.\n\t(placeholder_list, find_placeholder): Deleted.\n\t(is_aligning_offset): Don't handle WITH_RECORD_EXPR, PLACEHOLDER_EXPR.\n\t(expand_expr_real, cases PLACEHOLDER_EXPR, WITH_RECORD_EXPR): Likewise.\n\t(highest_pow2_factor, case WITH_RECORD_EXPR): Remove.\n\t* dojump.c (do_jump, case WITH_RECORD_EXPR): Likewise.\n\t* dwarf2out.c (loc_descriptor_from_tree, case WITH_RECORD_EXPR):\n\tLikewise.\n\t* fold-const.c (invert_truthvalue, case WITH_RECORD_EXPR): Likewise.\n\t(extract_muldiv, case WITH_RECORD_EXPR): Likewise.\n\t* tree.c (expr_align, case WITH_RECORD_EXPR): Likewise.\n\t(contains_placeholder_p): Don't handle WITH_RECORD_EXPR.\n\tClean up by using first_rtl_op.\n\t(substitute_in_expr): Use SUBSTITUTE_IN_EXPR for recursive call.\n\t(substitute_placeholder_in_expr): New function.\n\t* tree.def (WITH_RECORD_EXPR): Deleted.\n\t* tree.h (SUBSTITUTE_IN_EXPR, SUBSTITUTE_PLACEHOLDER_IN_EXPR): New.\n\t(substitute_placeholder_in_expr): New.\n\n\t* ada/decl.c (gnat_to_gnu_entity): Use SUBSTITUTE_PLACEHOLDER_IN_EXPR.\n\t* ada/trans.c (tree_transform, emit_index_check): Likewise.\n\t* ada/utils.c (build_template): Likewise.\n\t(max_size, convert): Remove handling of WITH_RECORD_EXPR.\n\t(maybe_unconstrained_array, unchecked_convert): Likewise.\n\t* ada/utils2.c (gnat_truthvalue_conversion, build_binary_op): Likewise.\n\t(build_unary_op): Likewise.\n\t(compare_arrays, build_allocator): Use SUBSTITUTE_PLACEHOLDER_IN_EXPR.\n\t(fill_vms_descriptor): Likewise.\n\t(build_call_alloc_dealloc): Likewise.\n\tALIGN is unsigned.\n\t* ada/gigi.h (build_call_alloc_dealloc): Alignment is unsigned.\n\nFrom-SVN: r79789", "tree": {"sha": "7935f9b36f94acbc172af472df20b0384eb56ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7935f9b36f94acbc172af472df20b0384eb56ff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fce44af562fae5ad9275e183abdf6cf87a87f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fce44af562fae5ad9275e183abdf6cf87a87f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fce44af562fae5ad9275e183abdf6cf87a87f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fce44af562fae5ad9275e183abdf6cf87a87f6e/comments", "author": null, "committer": null, "parents": [{"sha": "fc5fccdee994a93c1360b9a2934f0232820f9333", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5fccdee994a93c1360b9a2934f0232820f9333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5fccdee994a93c1360b9a2934f0232820f9333"}], "stats": {"total": 651, "additions": 260, "deletions": 391}, "files": [{"sha": "93f379d6b404f762d64ff227d02f1e8411977db5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -1,3 +1,30 @@\n+2004-03-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (get_alias_set): Remove handling of PLACEHOLDER_EXPR.\n+\t* emit-rtl.c (component_ref_for_mem_expr): Likewise.\n+\t(set_mem_attributes_minus_bitpos): Call SUBSTITUTE_PLACEHOLDER_IN_EXPR.\n+\t* explow.c (expr_size): Likewise.\n+\t* expr.h (placeholder_list, find_placeholder): Deleted.\n+\t* expr.c (store_constructor): Likewise.\n+\t(get_inner_reference): Likewise.  Also don't call find_placeholder.\n+\t(placeholder_list, find_placeholder): Deleted.\n+\t(is_aligning_offset): Don't handle WITH_RECORD_EXPR, PLACEHOLDER_EXPR.\n+\t(expand_expr_real, cases PLACEHOLDER_EXPR, WITH_RECORD_EXPR): Likewise.\n+\t(highest_pow2_factor, case WITH_RECORD_EXPR): Remove.\n+\t* dojump.c (do_jump, case WITH_RECORD_EXPR): Likewise.\n+\t* dwarf2out.c (loc_descriptor_from_tree, case WITH_RECORD_EXPR):\n+\tLikewise.\n+\t* fold-const.c (invert_truthvalue, case WITH_RECORD_EXPR): Likewise.\n+\t(extract_muldiv, case WITH_RECORD_EXPR): Likewise.\n+\t* tree.c (expr_align, case WITH_RECORD_EXPR): Likewise.\n+\t(contains_placeholder_p): Don't handle WITH_RECORD_EXPR.\n+\tClean up by using first_rtl_op.\n+\t(substitute_in_expr): Use SUBSTITUTE_IN_EXPR for recursive call.\n+\t(substitute_placeholder_in_expr): New function.\n+\t* tree.def (WITH_RECORD_EXPR): Deleted.\n+\t* tree.h (SUBSTITUTE_IN_EXPR, SUBSTITUTE_PLACEHOLDER_IN_EXPR): New.\n+\t(substitute_placeholder_in_expr): New.\n+\n 2004-03-21  Andrew Pinski  <pinskia@gcc.gnu.org>\n \n \t* dojump.c (prefer_and_bit_test): Fix which part of"}, {"sha": "ee6e709807d38a23a6c15566403378a390330995", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -1,3 +1,18 @@\n+2004-03-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (gnat_to_gnu_entity): Use SUBSTITUTE_PLACEHOLDER_IN_EXPR.\n+\t* trans.c (tree_transform, emit_index_check): Likewise.\n+\t* utils.c (build_template): Likewise.\n+\t(max_size, convert): Remove handling of WITH_RECORD_EXPR.\n+\t(maybe_unconstrained_array, unchecked_convert): Likewise.\n+\t* utils2.c (gnat_truthvalue_conversion, build_binary_op): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(compare_arrays, build_allocator): Use SUBSTITUTE_PLACEHOLDER_IN_EXPR.\n+\t(fill_vms_descriptor): Likewise.\n+\t(build_call_alloc_dealloc): Likewise.\n+\tALIGN is unsigned.\n+\t* gigi.h (build_call_alloc_dealloc): Alignment is unsigned.\n+\n 2004-03-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR other/14630"}, {"sha": "458213e08b1c344666318a3f4c6ed4f97bce8a06", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -565,12 +565,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n \t  {\n \t    if (gnu_expr != 0 && kind == E_Constant)\n-\t      {\n-\t\tgnu_size = TYPE_SIZE (TREE_TYPE (gnu_expr));\n-\t\tif (CONTAINS_PLACEHOLDER_P (gnu_size))\n-\t\t  gnu_size = build (WITH_RECORD_EXPR, bitsizetype,\n-\t\t\t\t    gnu_size, gnu_expr);\n-\t      }\n+\t      gnu_size\n+\t\t= SUBSTITUTE_PLACEHOLDER_IN_EXPR\n+\t\t  (TYPE_SIZE (TREE_TYPE (gnu_expr)), gnu_expr);\n \n \t    /* We may have no GNU_EXPR because No_Initialization is\n \t       set even though there's an Expression.  */"}, {"sha": "423b8980b338ae36e8d1b9f7ce6951dc0ba8589c", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -701,7 +701,7 @@ extern tree build_component_ref (tree, tree, tree, int);\n    GNU_SIZE is the size of the object and ALIGN is the alignment.\n    GNAT_PROC, if present is a procedure to call and GNAT_POOL is the\n    storage pool to use.  If not preset, malloc and free will be used.  */\n-extern tree build_call_alloc_dealloc (tree, tree, int, Entity_Id,\n+extern tree build_call_alloc_dealloc (tree, tree, unsigned int, Entity_Id,\n \t\t\t\t      Entity_Id, Node_Id);\n \n /* Build a GCC tree to correspond to allocating an object of TYPE whose"}, {"sha": "dc34b725cf6dc980f4ddb6184efd361674ddce0d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -1236,8 +1236,8 @@ tree_transform (Node_Id gnat_node)\n \t    if (CONTAINS_PLACEHOLDER_P (gnu_result))\n \t      {\n \t\tif (TREE_CODE (gnu_prefix) != TYPE_DECL)\n-\t\t  gnu_result = build (WITH_RECORD_EXPR, TREE_TYPE (gnu_result),\n-\t\t\t\t      gnu_result, gnu_expr);\n+\t\t  gnu_result = substitute_placeholder_in_expr (gnu_result,\n+\t\t\t\t\t\t\t       gnu_expr);\n \t\telse\n \t\t  gnu_result = max_size (gnu_result, 1);\n \t      }\n@@ -1381,9 +1381,8 @@ tree_transform (Node_Id gnat_node)\n \t      /* If this has a PLACEHOLDER_EXPR, qualify it by the object\n \t\t we are handling.  Note that these attributes could not\n \t\t have been used on an unconstrained array type.  */\n-\t      if (CONTAINS_PLACEHOLDER_P (gnu_result))\n-\t\tgnu_result = build (WITH_RECORD_EXPR, TREE_TYPE (gnu_result),\n-\t\t\t\t    gnu_result, gnu_prefix);\n+\t      gnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result,\n+\t\t\t\t\t\t\t   gnu_prefix);\n \n \t      break;\n \t    }\n@@ -1486,17 +1485,16 @@ tree_transform (Node_Id gnat_node)\n \n \t      /* If this has a PLACEHOLDER_EXPR, qualify it by the object\n \t\t we are handling. */\n-\t      if (CONTAINS_PLACEHOLDER_P (gnu_result))\n-\t\tgnu_result = build (WITH_RECORD_EXPR, TREE_TYPE (gnu_result),\n-\t\t\t\t    gnu_result, gnu_prefix);\n+\t      gnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result,\n+\t\t\t\t\t\t\t   gnu_prefix);\n \n \t      break;\n \t    }\n \n \t  case Attr_Min:\n \t  case Attr_Max:\n \t    gnu_lhs = gnat_to_gnu (First (Expressions (gnat_node)));\n-\t    gnu_rhs =  gnat_to_gnu (Next (First (Expressions (gnat_node))));\n+\t    gnu_rhs = gnat_to_gnu (Next (First (Expressions (gnat_node))));\n \n \t    gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \t    gnu_result = build_binary_op (attribute == Attr_Min\n@@ -4622,13 +4620,8 @@ emit_index_check (tree gnu_array_object,\n \n   /* If GNU_LOW or GNU_HIGH are a PLACEHOLDER_EXPR, qualify them by\n      the object we are handling. */\n-  if (CONTAINS_PLACEHOLDER_P (gnu_low))\n-    gnu_low = build (WITH_RECORD_EXPR, TREE_TYPE (gnu_low),\n-\t\t     gnu_low, gnu_array_object);\n-\n-  if (CONTAINS_PLACEHOLDER_P (gnu_high))\n-    gnu_high = build (WITH_RECORD_EXPR, TREE_TYPE (gnu_high),\n-\t\t      gnu_high, gnu_array_object);\n+  gnu_low = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_low, gnu_array_object);\n+  gnu_high = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_high, gnu_array_object);\n \n   /* There's no good type to use here, so we might as well use\n      integer_type_node.   */"}, {"sha": "cd3f47c5b63b27194499ce8d0f239bb42bd3a6e3", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -2180,8 +2180,6 @@ max_size (tree exp, int max_p)\n \t    gigi_abort (407);\n \t  else if (code == COMPOUND_EXPR)\n \t    return max_size (TREE_OPERAND (exp, 1), max_p);\n-\t  else if (code == WITH_RECORD_EXPR)\n-\t    return exp;\n \n \t  {\n \t    tree lhs = max_size (TREE_OPERAND (exp, 0), max_p);\n@@ -2275,12 +2273,9 @@ build_template (tree template_type, tree array_type, tree expr)\n       max = convert (TREE_TYPE (field), TYPE_MAX_VALUE (bounds));\n \n       /* If either MIN or MAX involve a PLACEHOLDER_EXPR, we must\n-\t surround them with a WITH_RECORD_EXPR giving EXPR as the\n-\t OBJECT.  */\n-      if (CONTAINS_PLACEHOLDER_P (min))\n-\tmin = build (WITH_RECORD_EXPR, TREE_TYPE (min), min, expr);\n-      if (CONTAINS_PLACEHOLDER_P (max))\n-\tmax = build (WITH_RECORD_EXPR, TREE_TYPE (max), max, expr);\n+\t substitute it from OBJECT.  */\n+      min = SUBSTITUTE_PLACEHOLDER_IN_EXPR (min, expr);\n+      max = SUBSTITUTE_PLACEHOLDER_IN_EXPR (max, expr);\n \n       template_elts = tree_cons (TREE_CHAIN (field), max,\n \t\t\t\t tree_cons (field, min, template_elts));\n@@ -2865,12 +2860,6 @@ convert (tree type, tree expr)\n   else if (AGGREGATE_TYPE_P (type)\n \t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n     return build1 (NOP_EXPR, type, expr);\n-  /* If EXPR is a WITH_RECORD_EXPR, do the conversion inside and then make a\n-     new one.  */\n-  else if (TREE_CODE (expr) == WITH_RECORD_EXPR)\n-    return build (WITH_RECORD_EXPR, type,\n-\t\t  convert (type, TREE_OPERAND (expr, 0)),\n-\t\t  TREE_OPERAND (expr, 1));\n \n   /* If the input type has padding, remove it by doing a component reference\n      to the field.  If the output type has padding, make a constructor\n@@ -3250,13 +3239,6 @@ maybe_unconstrained_array (tree exp)\n \t\t\t\t\t     (TREE_TYPE (TREE_TYPE (exp))))),\n \t\t       TREE_OPERAND (exp, 0));\n \n-      else if (code == WITH_RECORD_EXPR\n-\t       && (TREE_OPERAND (exp, 0)\n-\t\t   != (new = maybe_unconstrained_array\n-\t\t       (TREE_OPERAND (exp, 0)))))\n-\treturn build (WITH_RECORD_EXPR, TREE_TYPE (new), new,\n-\t\t      TREE_OPERAND (exp, 1));\n-\n     case RECORD_TYPE:\n       /* If this is a padded type, convert to the unpadded type and see if\n \t it contains a template.  */\n@@ -3295,13 +3277,6 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n   if (etype == type)\n     return expr;\n \n-  /* If EXPR is a WITH_RECORD_EXPR, do the conversion inside and then make a\n-     new one.  */\n-  if (TREE_CODE (expr) == WITH_RECORD_EXPR)\n-    return build (WITH_RECORD_EXPR, type,\n-\t\t  unchecked_convert (type, TREE_OPERAND (expr, 0), notrunc_p),\n-\t\t  TREE_OPERAND (expr, 1));\n-\n   /* If both types types are integral just do a normal conversion.\n      Likewise for a conversion to an unconstrained array.  */\n   if ((((INTEGRAL_TYPE_P (type)"}, {"sha": "a0d33db6580e7e2dfa5a7839e81b3569fcbdf983", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 18, "deletions": 87, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -90,11 +90,6 @@ gnat_truthvalue_conversion (tree expr)\n \t\tgnat_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n \t\tgnat_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n \n-    case WITH_RECORD_EXPR:\n-      return build (WITH_RECORD_EXPR, type,\n-\t\t    gnat_truthvalue_conversion (TREE_OPERAND (expr, 0)),\n-\t\t    TREE_OPERAND (expr, 1));\n-\n     default:\n       return build_binary_op (NE_EXPR, type, expr,\n \t\t\t      convert (type, integer_zero_node));\n@@ -381,15 +376,10 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \n \t  comparison = build_binary_op (LT_EXPR, result_type, ub, lb);\n-\n-\t  if (CONTAINS_PLACEHOLDER_P (comparison))\n-\t    comparison = build (WITH_RECORD_EXPR, result_type,\n-\t\t\t\tcomparison, a1);\n-\t  if (CONTAINS_PLACEHOLDER_P (length1))\n-\t    length1 = build (WITH_RECORD_EXPR, bt, length1, a1);\n+\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n \n \t  length_zero_p = 1;\n-\n \t  this_a1_is_null = comparison;\n \t  this_a2_is_null = convert (result_type, integer_one_node);\n \t}\n@@ -413,10 +403,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  /* Note that we know that UB2 and LB2 are constant and hence\n \t     cannot contain a PLACEHOLDER_EXPR.  */\n \n-\t  if (CONTAINS_PLACEHOLDER_P (comparison))\n-\t    comparison = build (WITH_RECORD_EXPR, result_type, comparison, a1);\n-\t  if (CONTAINS_PLACEHOLDER_P (length1))\n-\t    length1 = build (WITH_RECORD_EXPR, bt, length1, a1);\n+\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n \n \t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n \t  this_a2_is_null = convert (result_type, integer_zero_node);\n@@ -425,10 +413,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       /* Otherwise compare the computed lengths.  */\n       else\n \t{\n-\t  if (CONTAINS_PLACEHOLDER_P (length1))\n-\t    length1 = build (WITH_RECORD_EXPR, bt, length1, a1);\n-\t  if (CONTAINS_PLACEHOLDER_P (length2))\n-\t    length2 = build (WITH_RECORD_EXPR, bt, length2, a2);\n+\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n+\t  length2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length2, a2);\n \n \t  comparison\n \t    = build_binary_op (EQ_EXPR, result_type, length1, length2);\n@@ -606,39 +592,6 @@ build_binary_op (enum tree_code op_code,\n   tree result;\n   int has_side_effects = 0;\n \n-  /* If one (but not both, unless they have the same object) operands are a\n-     WITH_RECORD_EXPR, do the operation and then surround it with the\n-     WITH_RECORD_EXPR.  Don't do this for assignment, for an ARRAY_REF, or\n-     for an ARRAY_RANGE_REF because we need to keep track of the\n-     WITH_RECORD_EXPRs on both operands very carefully.  */\n-  if (op_code != MODIFY_EXPR && op_code != ARRAY_REF\n-      && op_code != ARRAY_RANGE_REF\n-      && TREE_CODE (left_operand) == WITH_RECORD_EXPR\n-      && (TREE_CODE (right_operand) != WITH_RECORD_EXPR\n-\t  || operand_equal_p (TREE_OPERAND (left_operand, 1),\n-\t\t\t      TREE_OPERAND (right_operand, 1), 0)))\n-    {\n-      tree right = right_operand;\n-\n-      if (TREE_CODE (right) == WITH_RECORD_EXPR)\n-\tright = TREE_OPERAND (right, 0);\n-\n-      result = build_binary_op (op_code, result_type,\n-\t\t\t\tTREE_OPERAND (left_operand, 0), right);\n-      return build (WITH_RECORD_EXPR, TREE_TYPE (result), result,\n-\t\t    TREE_OPERAND (left_operand, 1));\n-    }\n-  else if (op_code != MODIFY_EXPR && op_code != ARRAY_REF\n-\t   && op_code != ARRAY_RANGE_REF\n-\t   && TREE_CODE (left_operand) != WITH_RECORD_EXPR\n-\t   && TREE_CODE (right_operand) == WITH_RECORD_EXPR)\n-    {\n-      result = build_binary_op (op_code, result_type, left_operand,\n-\t\t\t\tTREE_OPERAND (right_operand, 0));\n-      return build (WITH_RECORD_EXPR, TREE_TYPE (result), result,\n-\t\t    TREE_OPERAND (right_operand, 1));\n-    }\n-\n   if (operation_type != 0\n       && TREE_CODE (operation_type) == RECORD_TYPE\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n@@ -755,7 +708,6 @@ build_binary_op (enum tree_code op_code,\n \t      result = TREE_OPERAND (result, 0);\n \t  else if (TREE_CODE (result) == REALPART_EXPR\n \t\t   || TREE_CODE (result) == IMAGPART_EXPR\n-\t\t   || TREE_CODE (result) == WITH_RECORD_EXPR\n \t\t   || ((TREE_CODE (result) == NOP_EXPR\n \t\t\t|| TREE_CODE (result) == CONVERT_EXPR)\n \t\t       && (((TREE_CODE (restype)\n@@ -1091,17 +1043,6 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n   tree result;\n   int side_effects = 0;\n \n-  /* If we have a WITH_RECORD_EXPR as our operand, do the operation first,\n-     then surround it with the WITH_RECORD_EXPR.  This allows GCC to do better\n-     expression folding.  */\n-  if (TREE_CODE (operand) == WITH_RECORD_EXPR)\n-    {\n-      result = build_unary_op (op_code, result_type,\n-\t\t\t       TREE_OPERAND (operand, 0));\n-      return build (WITH_RECORD_EXPR, TREE_TYPE (result), result,\n-\t\t    TREE_OPERAND (operand, 1));\n-    }\n-\n   if (operation_type != 0\n       && TREE_CODE (operation_type) == RECORD_TYPE\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (operation_type))\n@@ -1716,18 +1657,13 @@ build_component_ref (tree record_variable,\n    object dynamically on the stack frame.  */\n \n tree\n-build_call_alloc_dealloc (tree gnu_obj,\n-                          tree gnu_size,\n-                          int align,\n-                          Entity_Id gnat_proc,\n-                          Entity_Id gnat_pool,\n+build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n+                          Entity_Id gnat_proc, Entity_Id gnat_pool,\n                           Node_Id gnat_node)\n {\n   tree gnu_align = size_int (align / BITS_PER_UNIT);\n \n-  if (CONTAINS_PLACEHOLDER_P (gnu_size))\n-    gnu_size = build (WITH_RECORD_EXPR, sizetype, gnu_size,\n-\t\t      build_unary_op (INDIRECT_REF, NULL_TREE, gnu_obj));\n+  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_obj);\n \n   if (Present (gnat_proc))\n     {\n@@ -1868,10 +1804,8 @@ build_allocator (tree type,\n       tree storage;\n       tree template_cons = NULL_TREE;\n \n-      size = TYPE_SIZE_UNIT (storage_type);\n-\n-      if (CONTAINS_PLACEHOLDER_P (size))\n-\tsize = build (WITH_RECORD_EXPR, sizetype, size, init);\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n+\t\t\t\t\t     init);\n \n       /* If the size overflows, pass -1 so the allocator will raise\n \t storage error.  */\n@@ -1943,7 +1877,7 @@ build_allocator (tree type,\n       if (init == 0)\n \tsize = max_size (size, 1);\n       else\n-\tsize = build (WITH_RECORD_EXPR, sizetype, size, init);\n+\tsize = substitute_placeholder_in_expr (size, init);\n     }\n \n   /* If the size overflows, pass -1 so the allocator will raise\n@@ -2012,15 +1946,12 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n   gnat_mark_addressable (expr);\n \n   for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n-    {\n-      tree init = DECL_INITIAL (field);\n-\n-      if (CONTAINS_PLACEHOLDER_P (init))\n-\tinit = build (WITH_RECORD_EXPR, TREE_TYPE (init), init, expr);\n-\n-      const_list = tree_cons (field, convert (TREE_TYPE (field), init),\n-\t\t\t      const_list);\n-    }\n+    const_list\n+      = tree_cons (field,\n+\t\t   convert (TREE_TYPE (field),\n+\t\t\t    SUBSTITUTE_PLACEHOLDER_IN_EXPR\n+\t\t\t    (DECL_INITIAL (field), expr)),\n+\t\t   const_list);\n \n   return gnat_build_constructor (record_type, nreverse (const_list));\n }"}, {"sha": "be10ba688a6754ede04c60a3f6c6b1fdb2d64f24", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -481,7 +481,6 @@ get_alias_set (tree t)\n   if (! TYPE_P (t))\n     {\n       tree inner = t;\n-      tree placeholder_ptr = 0;\n \n       /* Remove any nops, then give the language a chance to do\n \t something with this tree before we look at it.  */\n@@ -491,16 +490,10 @@ get_alias_set (tree t)\n \treturn set;\n \n       /* First see if the actual object referenced is an INDIRECT_REF from a\n-\t restrict-qualified pointer or a \"void *\".  Replace\n-\t PLACEHOLDER_EXPRs.  */\n-      while (TREE_CODE (inner) == PLACEHOLDER_EXPR\n-\t     || handled_component_p (inner))\n+\t restrict-qualified pointer or a \"void *\".  */\n+      while (handled_component_p (inner))\n \t{\n-\t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n-\t    inner = find_placeholder (inner, &placeholder_ptr);\n-\t  else\n-\t    inner = TREE_OPERAND (inner, 0);\n-\n+\t  inner = TREE_OPERAND (inner, 0);\n \t  STRIP_NOPS (inner);\n \t}\n \n@@ -546,16 +539,10 @@ get_alias_set (tree t)\n \t}\n \n       /* Otherwise, pick up the outermost object that we could have a pointer\n-\t to, processing conversion and PLACEHOLDER_EXPR as above.  */\n-      placeholder_ptr = 0;\n-      while (TREE_CODE (t) == PLACEHOLDER_EXPR\n-\t     || (handled_component_p (t) && ! can_address_p (t)))\n+\t to, processing conversions as above.  */\n+      while (handled_component_p (t) && ! can_address_p (t))\n \t{\n-\t  if (TREE_CODE (t) == PLACEHOLDER_EXPR)\n-\t    t = find_placeholder (t, &placeholder_ptr);\n-\t  else\n-\t    t = TREE_OPERAND (t, 0);\n-\n+\t  t = TREE_OPERAND (t, 0);\n \t  STRIP_NOPS (t);\n \t}\n "}, {"sha": "f19cbcc3d9144cc8448648408c35e8cd49af6852", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -217,15 +217,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n       break;\n \n-    case WITH_RECORD_EXPR:\n-      /* Put the object on the placeholder list, recurse through our first\n-         operand, and pop the list.  */\n-      placeholder_list = tree_cons (TREE_OPERAND (exp, 1), NULL_TREE,\n-                                    placeholder_list);\n-      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n-      placeholder_list = TREE_CHAIN (placeholder_list);\n-      break;\n-\n #if 0\n       /* This is never less insns than evaluating the PLUS_EXPR followed by\n          a test and can be longer if the test is eliminated.  */"}, {"sha": "b3dcda0c5c05831e7fe6a8b002338176809df8b5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -8705,7 +8705,6 @@ loc_descriptor_from_tree (tree loc, int addressp)\n     case ERROR_MARK:\n       return 0;\n \n-    case WITH_RECORD_EXPR:\n     case PLACEHOLDER_EXPR:\n       /* This case involves extracting fields from an object to determine the\n \t position of other fields.  We don't try to encode this here.  The"}, {"sha": "8d8ead16f0920dfb071bf21912f83b51f4e45cc0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -1409,19 +1409,13 @@ component_ref_for_mem_expr (tree ref)\n     inner = component_ref_for_mem_expr (inner);\n   else\n     {\n-      tree placeholder_ptr = 0;\n-\n       /* Now remove any conversions: they don't change what the underlying\n-\t object is.  Likewise for SAVE_EXPR.  Also handle PLACEHOLDER_EXPR.  */\n+\t object is.  Likewise for SAVE_EXPR.  */\n       while (TREE_CODE (inner) == NOP_EXPR || TREE_CODE (inner) == CONVERT_EXPR\n \t     || TREE_CODE (inner) == NON_LVALUE_EXPR\n \t     || TREE_CODE (inner) == VIEW_CONVERT_EXPR\n-\t     || TREE_CODE (inner) == SAVE_EXPR\n-\t     || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n-\tif (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n-\t  inner = find_placeholder (inner, &placeholder_ptr);\n-\telse\n-\t  inner = TREE_OPERAND (inner, 0);\n+\t     || TREE_CODE (inner) == SAVE_EXPR)\n+\tinner = TREE_OPERAND (inner, 0);\n \n       if (! DECL_P (inner))\n \tinner = NULL_TREE;\n@@ -1608,20 +1602,14 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\tindex = fold (build (MINUS_EXPR, TREE_TYPE (index),\n \t\t\t\t     index, low_bound));\n \n-\t      /* If the index has a self-referential type, pass it to a\n-\t\t WITH_RECORD_EXPR; if the component size is, pass our\n-\t\t component to one.  */\n-\t      if (CONTAINS_PLACEHOLDER_P (index))\n-\t\tindex = build (WITH_RECORD_EXPR, TREE_TYPE (index), index, t2);\n-\t      if (CONTAINS_PLACEHOLDER_P (unit_size))\n-\t\tunit_size = build (WITH_RECORD_EXPR, sizetype,\n-\t\t\t\t   unit_size, array);\n-\n+\t      /* If the index has a self-referential type, instantiate it;\n+\t\t likewise for the component size.  */\n+\t      index = SUBSTITUTE_PLACEHOLDER_IN_EXPR (index, t2);\n+\t      unit_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (unit_size, array);\n \t      off_tree\n \t\t= fold (build (PLUS_EXPR, sizetype,\n \t\t\t       fold (build (MULT_EXPR, sizetype,\n-\t\t\t\t\t    index,\n-\t\t\t\t\t    unit_size)),\n+\t\t\t\t\t    index, unit_size)),\n \t\t\t       off_tree));\n \t      t2 = TREE_OPERAND (t2, 0);\n \t    }"}, {"sha": "1eec943eb26e9e5e8281283622d94897df48ee65", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -240,10 +240,7 @@ eliminate_constant_term (rtx x, rtx *constptr)\n rtx\n expr_size (tree exp)\n {\n-  tree size = lang_hooks.expr_size (exp);\n-\n-  if (CONTAINS_PLACEHOLDER_P (size))\n-    size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n+  tree size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (lang_hooks.expr_size (exp), exp);\n \n   return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype), 0);\n }"}, {"sha": "80647265ef4690a468ce911def707a71189e6198", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 132, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -90,9 +90,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the same indirect address eventually.  */\n int cse_not_expected;\n \n-/* Chain of pending expressions for PLACEHOLDER_EXPR to replace.  */\n-tree placeholder_list = 0;\n-\n /* This structure is used by move_by_pieces to describe the move to\n    be performed.  */\n struct move_by_pieces\n@@ -4610,9 +4607,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    {\n \t      rtx offset_rtx;\n \n-\t      if (CONTAINS_PLACEHOLDER_P (offset))\n-\t\toffset = build (WITH_RECORD_EXPR, sizetype,\n-\t\t\t\toffset, make_tree (TREE_TYPE (exp), target));\n+\t      offset\n+\t\t= SUBSTITUTE_PLACEHOLDER_IN_EXPR (offset,\n+\t\t\t\t\t\t  make_tree (TREE_TYPE (exp),\n+\t\t\t\t\t\t\t     target));\n \n \t      offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n \t      if (GET_CODE (to_rtx) != MEM)\n@@ -5401,7 +5399,6 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   enum machine_mode mode = VOIDmode;\n   tree offset = size_zero_node;\n   tree bit_offset = bitsize_zero_node;\n-  tree placeholder_ptr = 0;\n   tree tem;\n \n   /* First get the mode, signedness, and size.  We do this from just the\n@@ -5454,8 +5451,8 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t     made during type construction.  */\n \t  if (this_offset == 0)\n \t    break;\n-\t  else if (CONTAINS_PLACEHOLDER_P (this_offset))\n-\t    this_offset = build (WITH_RECORD_EXPR, sizetype, this_offset, exp);\n+\t  else\n+\t    this_offset = SUBSTITUTE_PLACEHOLDER_IN_EXPR (this_offset, exp);\n \n \t  offset = size_binop (PLUS_EXPR, offset, this_offset);\n \t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n@@ -5481,35 +5478,16 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t    index = fold (build (MINUS_EXPR, TREE_TYPE (index),\n \t\t\t\t index, low_bound));\n \n-\t  /* If the index has a self-referential type, pass it to a\n-\t     WITH_RECORD_EXPR; if the component size is, pass our\n-\t     component to one.  */\n-\t  if (CONTAINS_PLACEHOLDER_P (index))\n-\t    index = build (WITH_RECORD_EXPR, TREE_TYPE (index), index, exp);\n-\t  if (CONTAINS_PLACEHOLDER_P (unit_size))\n-\t    unit_size = build (WITH_RECORD_EXPR, sizetype, unit_size, array);\n-\n+\t  /* If the index has a self-referential type, instantiate it with\n+\t     the object; likewise fkor the component size.  */\n+\t  index = SUBSTITUTE_PLACEHOLDER_IN_EXPR (index, exp);\n+\t  unit_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (unit_size, array);\n \t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       size_binop (MULT_EXPR,\n \t\t\t\t\t   convert (sizetype, index),\n \t\t\t\t\t   unit_size));\n \t}\n \n-      else if (TREE_CODE (exp) == PLACEHOLDER_EXPR)\n-\t{\n-\t  tree new = find_placeholder (exp, &placeholder_ptr);\n-\n-\t  /* If we couldn't find the replacement, return the PLACEHOLDER_EXPR.\n-\t     We might have been called from tree optimization where we\n-\t     haven't set up an object yet.  */\n-\t  if (new == 0)\n-\t    break;\n-\t  else\n-\t    exp = new;\n-\n-\t  continue;\n-\t}\n-\n       /* We can go inside most conversions: all NON_VALUE_EXPRs, all normal\n \t conversions that don't change the mode, and all view conversions\n \t except those that need to \"step up\" the alignment.  */\n@@ -6033,7 +6011,7 @@ highest_pow2_factor (tree exp)\n       break;\n \n     case NON_LVALUE_EXPR:  case NOP_EXPR:  case CONVERT_EXPR:\n-    case SAVE_EXPR: case WITH_RECORD_EXPR:\n+    case SAVE_EXPR:\n       return highest_pow2_factor (TREE_OPERAND (exp, 0));\n \n     case COMPOUND_EXPR:\n@@ -6069,70 +6047,6 @@ highest_pow2_factor_for_target (tree target, tree exp)\n   return MAX (factor, target_align);\n }\n \f\n-/* Return an object on the placeholder list that matches EXP, a\n-   PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n-   PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n-   tree.def.  If no such object is found, return 0.  If PLIST is nonzero, it\n-   is a location which initially points to a starting location in the\n-   placeholder list (zero means start of the list) and where a pointer into\n-   the placeholder list at which the object is found is placed.  */\n-\n-tree\n-find_placeholder (tree exp, tree *plist)\n-{\n-  tree type = TREE_TYPE (exp);\n-  tree placeholder_expr;\n-\n-  for (placeholder_expr\n-       = plist && *plist ? TREE_CHAIN (*plist) : placeholder_list;\n-       placeholder_expr != 0;\n-       placeholder_expr = TREE_CHAIN (placeholder_expr))\n-    {\n-      tree need_type = TYPE_MAIN_VARIANT (type);\n-      tree elt;\n-\n-      /* Find the outermost reference that is of the type we want.  If none,\n-\t see if any object has a type that is a pointer to the type we\n-\t want.  */\n-      for (elt = TREE_PURPOSE (placeholder_expr); elt != 0;\n-\t   elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t\t   || TREE_CODE (elt) == COND_EXPR)\n-\t\t  ? TREE_OPERAND (elt, 1)\n-\t\t  : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n-\t\t  ? TREE_OPERAND (elt, 0) : 0))\n-\tif (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n-\t  {\n-\t    if (plist)\n-\t      *plist = placeholder_expr;\n-\t    return elt;\n-\t  }\n-\n-      for (elt = TREE_PURPOSE (placeholder_expr); elt != 0;\n-\t   elt\n-\t   = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t       || TREE_CODE (elt) == COND_EXPR)\n-\t      ? TREE_OPERAND (elt, 1)\n-\t      : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n-\t      ? TREE_OPERAND (elt, 0) : 0))\n-\tif (POINTER_TYPE_P (TREE_TYPE (elt))\n-\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n-\t\t== need_type))\n-\t  {\n-\t    if (plist)\n-\t      *plist = placeholder_expr;\n-\t    return build1 (INDIRECT_REF, need_type, elt);\n-\t  }\n-    }\n-\n-  return 0;\n-}\n-\n /* Subroutine of expand_expr.  Expand the two operands of a binary\n    expression EXP0 and EXP1 placing the results in OP0 and OP1.\n    The value may be stored in TARGET if TARGET is nonzero.  The\n@@ -6653,31 +6567,6 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \treturn temp;\n       }\n \n-    case PLACEHOLDER_EXPR:\n-      {\n-\ttree old_list = placeholder_list;\n-\ttree placeholder_expr = 0;\n-\n-\texp = find_placeholder (exp, &placeholder_expr);\n-\tif (exp == 0)\n-\t  abort ();\n-\n-\tplaceholder_list = TREE_CHAIN (placeholder_expr);\n-\ttemp = expand_expr (exp, original_target, tmode, modifier);\n-\tplaceholder_list = old_list;\n-\treturn temp;\n-      }\n-\n-    case WITH_RECORD_EXPR:\n-      /* Put the object on the placeholder list, expand our first operand,\n-\t and pop the list.  */\n-      placeholder_list = tree_cons (TREE_OPERAND (exp, 1), NULL_TREE,\n-\t\t\t\t    placeholder_list);\n-      target = expand_expr (TREE_OPERAND (exp, 0), original_target, tmode,\n-\t\t\t    modifier);\n-      placeholder_list = TREE_CHAIN (placeholder_list);\n-      return target;\n-\n     case GOTO_EXPR:\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == LABEL_DECL)\n \texpand_goto (TREE_OPERAND (exp, 0));\n@@ -9095,11 +8984,10 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n static int\n is_aligning_offset (tree offset, tree exp)\n {\n-  /* Strip off any conversions and WITH_RECORD_EXPR nodes.  */\n+  /* Strip off any conversions.  */\n   while (TREE_CODE (offset) == NON_LVALUE_EXPR\n \t || TREE_CODE (offset) == NOP_EXPR\n-\t || TREE_CODE (offset) == CONVERT_EXPR\n-\t || TREE_CODE (offset) == WITH_RECORD_EXPR)\n+\t || TREE_CODE (offset) == CONVERT_EXPR)\n     offset = TREE_OPERAND (offset, 0);\n \n   /* We must now have a BIT_AND_EXPR with a constant that is one less than\n@@ -9128,13 +9016,8 @@ is_aligning_offset (tree offset, tree exp)\n \t || TREE_CODE (offset) == CONVERT_EXPR)\n     offset = TREE_OPERAND (offset, 0);\n \n-  /* This must now be the address either of EXP or of a PLACEHOLDER_EXPR\n-     whose type is the same as EXP.  */\n-  return (TREE_CODE (offset) == ADDR_EXPR\n-\t  && (TREE_OPERAND (offset, 0) == exp\n-\t      || (TREE_CODE (TREE_OPERAND (offset, 0)) == PLACEHOLDER_EXPR\n-\t\t  && (TREE_TYPE (TREE_OPERAND (offset, 0))\n-\t\t      == TREE_TYPE (exp)))));\n+  /* This must now be the address of EXP.  */\n+  return TREE_CODE (offset) == ADDR_EXPR && TREE_OPERAND (offset, 0) == exp;\n }\n \f\n /* Return the tree node if an ARG corresponds to a string constant or zero"}, {"sha": "5c7bbbe6c51525b41cf4ff842669c4a28b677918", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -505,15 +505,6 @@ extern rtx store_expr (tree, rtx, int);\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand (rtx, rtx);\n \n-/* Return an object on the placeholder list that matches EXP, a\n-   PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n-   PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n-   tree.def.  If no such object is found, abort.  If PLIST is nonzero, it is\n-   a location which initially points to a starting location in the\n-   placeholder list (zero means start of the list) and where a pointer into\n-   the placeholder list at which the object is found is placed.  */\n-extern tree find_placeholder (tree, tree *);\n-\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.  */\n@@ -808,5 +799,3 @@ extern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,\n extern void mark_seen_cases (tree, unsigned char *, HOST_WIDE_INT, int);\n \n extern int vector_mode_valid_p (enum machine_mode);\n-\n-extern tree placeholder_list;"}, {"sha": "84c605528baf8af20a9537d7605e0b12e50abebe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -2718,11 +2718,6 @@ invert_truthvalue (tree arg)\n       return build (COMPOUND_EXPR, type, TREE_OPERAND (arg, 0),\n \t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n-    case WITH_RECORD_EXPR:\n-      return build (WITH_RECORD_EXPR, type,\n-\t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n-\t\t    TREE_OPERAND (arg, 1));\n-\n     case NON_LVALUE_EXPR:\n       return invert_truthvalue (TREE_OPERAND (arg, 0));\n \n@@ -4560,12 +4555,6 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t}\n       break;\n \n-    case WITH_RECORD_EXPR:\n-      if ((t1 = extract_muldiv (TREE_OPERAND (t, 0), c, code, wide_type)) != 0)\n-\treturn build (WITH_RECORD_EXPR, TREE_TYPE (t1), t1,\n-\t\t      TREE_OPERAND (t, 1));\n-      break;\n-\n     case LSHIFT_EXPR:  case RSHIFT_EXPR:\n       /* If the second operand is constant, this is a multiplication\n \t or floor division, by a power of two, so we can treat it that"}, {"sha": "240d3357454e2219c8be61e04d0661abe2765101", "filename": "gcc/tree.c", "status": "modified", "additions": 127, "deletions": 24, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -1211,7 +1211,7 @@ expr_align (tree t)\n \n     case SAVE_EXPR:         case COMPOUND_EXPR:       case MODIFY_EXPR:\n     case INIT_EXPR:         case TARGET_EXPR:         case WITH_CLEANUP_EXPR:\n-    case WITH_RECORD_EXPR:  case CLEANUP_POINT_EXPR:  case UNSAVE_EXPR:\n+    case CLEANUP_POINT_EXPR:  case UNSAVE_EXPR:\n       /* These don't change the alignment of an object.  */\n       return expr_align (TREE_OPERAND (t, 0));\n \n@@ -1699,12 +1699,8 @@ contains_placeholder_p (tree exp)\n   if (!exp)\n     return 0;\n \n-  /* If we have a WITH_RECORD_EXPR, it \"cancels\" any PLACEHOLDER_EXPR\n-     in it since it is supplying a value for it.  */\n   code = TREE_CODE (exp);\n-  if (code == WITH_RECORD_EXPR)\n-    return 0;\n-  else if (code == PLACEHOLDER_EXPR)\n+  if (code == PLACEHOLDER_EXPR)\n     return 1;\n \n   switch (TREE_CODE_CLASS (code))\n@@ -1731,10 +1727,6 @@ contains_placeholder_p (tree exp)\n \t  /* Ignoring the first operand isn't quite right, but works best.  */\n \t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1));\n \n-\tcase RTL_EXPR:\n-\tcase CONSTRUCTOR:\n-\t  return 0;\n-\n \tcase COND_EXPR:\n \t  return (CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0))\n \t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1))\n@@ -1753,14 +1745,11 @@ contains_placeholder_p (tree exp)\n \n \t  return result;\n \n-\tcase CALL_EXPR:\n-\t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1));\n-\n \tdefault:\n \t  break;\n \t}\n \n-      switch (TREE_CODE_LENGTH (code))\n+      switch (first_rtl_op (code))\n \t{\n \tcase 1:\n \t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0));\n@@ -1954,9 +1943,8 @@ substitute_in_expr (tree exp, tree f, tree r)\n   /* We handle TREE_LIST and COMPONENT_REF separately.  */\n   if (code == TREE_LIST)\n     {\n-      op0 = (TREE_CHAIN (exp) == 0\n-\t     ? 0 : substitute_in_expr (TREE_CHAIN (exp), f, r));\n-      op1 = substitute_in_expr (TREE_VALUE (exp), f, r);\n+      op0 = SUBSTITUTE_IN_EXPR (TREE_CHAIN (exp), f, r);\n+      op1 = SUBSTITUTE_IN_EXPR (TREE_VALUE (exp), f, r);\n       if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n \treturn exp;\n \n@@ -1979,7 +1967,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && TREE_TYPE (inner) == 0)\n        return exp;\n \n-     op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+     op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n      if (op0 == TREE_OPERAND (exp, 0))\n        return exp;\n \n@@ -2004,16 +1992,16 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    return exp;\n \n \t  case 1:\n-\t    op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t    op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n \t    if (op0 == TREE_OPERAND (exp, 0))\n \t      return exp;\n \n \t    new = fold (build1 (code, TREE_TYPE (exp), op0));\n \t    break;\n \n \t  case 2:\n-\t    op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n+\t    op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 1), f, r);\n \n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n \t      return exp;\n@@ -2022,9 +2010,9 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    break;\n \n \t  case 3:\n-\t    op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n-\t    op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);\n+\t    op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 1), f, r);\n+\t    op2 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 2), f, r);\n \n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n \t\t&& op2 == TREE_OPERAND (exp, 2))\n@@ -2045,6 +2033,121 @@ substitute_in_expr (tree exp, tree f, tree r)\n   TREE_READONLY (new) = TREE_READONLY (exp);\n   return new;\n }\n+\n+/* Similar, but look for a PLACEHOLDER_EXPR in EXP and find a replacement\n+   for it within OBJ, a tree that is an object or a chain of references.  */\n+\n+tree\n+substitute_placeholder_in_expr (tree exp, tree obj)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  tree op0, op1, op2;\n+\n+  /* If this is a PLACEHOLDER_EXPR, see if we find a corresponding type\n+     in the chain of OBJ.  */\n+  if (code == PLACEHOLDER_EXPR)\n+    {\n+      tree need_type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n+      tree elt;\n+\n+      for (elt = obj; elt != 0;\n+\t   elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t   || TREE_CODE (elt) == COND_EXPR)\n+\t\t  ? TREE_OPERAND (elt, 1)\n+\t\t  : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t  ? TREE_OPERAND (elt, 0) : 0))\n+\tif (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n+\t  return elt;\n+\n+      for (elt = obj; elt != 0;\n+\t   elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t   || TREE_CODE (elt) == COND_EXPR)\n+\t\t  ? TREE_OPERAND (elt, 1)\n+\t\t  : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t  ? TREE_OPERAND (elt, 0) : 0))\n+\tif (POINTER_TYPE_P (TREE_TYPE (elt))\n+\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n+\t\t== need_type))\n+\t  return fold (build1 (INDIRECT_REF, need_type, elt));\n+\n+      /* If we didn't find it, return the original PLACEHOLDER_EXPR.  If it\n+\t survives until RTL generation, there will be an error.  */\n+      return exp;\n+    }\n+\n+  /* TREE_LIST is special because we need to look at TREE_VALUE\n+     and TREE_CHAIN, not TREE_OPERANDS.  */\n+  else if (code == TREE_LIST)\n+    {\n+      op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_CHAIN (exp), obj);\n+      op1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_VALUE (exp), obj);\n+      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n+\treturn exp;\n+\n+      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n+    }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case 'c':\n+      case 'd':\n+      case 'b':\n+\treturn exp;\n+\n+      case 'x':\n+      case '1':\n+      case '2':\n+      case '<':\n+      case 'e':\n+      case 'r':\n+      case 's':\n+\tswitch (first_rtl_op (code))\n+\t  {\n+\t  case 0:\n+\t    return exp;\n+\n+\t  case 1:\n+\t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n+\t    if (op0 == TREE_OPERAND (exp, 0))\n+\t      return exp;\n+\t    else\n+\t      return fold (build1 (code, TREE_TYPE (exp), op0));\n+\n+\t  case 2:\n+\t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n+\t    op1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 1), obj);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t      return exp;\n+\t    else\n+\t      return fold (build2 (code, TREE_TYPE (exp), op0, op1));\n+\n+\t  case 3:\n+\t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n+\t    op1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 1), obj);\n+\t    op2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 2), obj);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2))\n+\t      return exp;\n+\t    else\n+\t      return fold (build3 (code, TREE_TYPE (exp), op0, op1, op2));\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+}\n \f\n /* Stabilize a reference so that we can use it any number of times\n    without causing its operands to be evaluated more than once."}, {"sha": "d56142f4e814ec7fbebd2cc374753ef1059a7fb1", "filename": "gcc/tree.def", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -541,35 +541,22 @@ DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n    actual size at run-time.  In the following, we describe how this\n    calculation is done.\n \n-   When we wish to evaluate a size or offset, we check whether it\n-   contains a PLACEHOLDER_EXPR.  If it does, we construct a\n-   WITH_RECORD_EXPR that contains both the expression we wish to\n-   evaluate and an expression within which the object may be found.\n-   The latter expression is the object itself in the simple case of an\n-   Ada record with discriminant, but it can be the array in the case of\n-   an unconstrained array.\n+   When we wish to evaluate a size or offset, we check whether it contains a\n+   PLACEHOLDER_EXPR.  If it does, we call substitute_placeholder_in_expr\n+   passing both that tree and an expression within which the object may be\n+   found.  The latter expression is the object itself in the simple case of\n+   an Ada record with discriminant, but it can be the array in the case of an\n+   unconstrained array.\n \n    In the latter case, we need the fat pointer, because the bounds of\n    the array can only be accessed from it.  However, we rely here on the\n    fact that the expression for the array contains the dereference of\n-   the fat pointer that obtained the array pointer.\n+   the fat pointer that obtained the array pointer.  */\n \n-   Accordingly, when looking for the object to substitute in place of\n-   a PLACEHOLDER_EXPR, we look down the first operand of the expression\n-   passed as the second operand to WITH_RECORD_EXPR until we find\n-   something of the desired type or reach a constant.  */\n-\n-/* Denotes a record to later be supplied with a WITH_RECORD_EXPR when\n-   evaluating this expression.  The type of this expression is used to\n-   find the record to replace it.  */\n+/* Denotes a record to later be substitued before evaluating this expression.\n+   The type of this expression is used to find the record to replace it.  */\n DEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", 'x', 0)\n \n-/* Provide an expression that references a record to be used in place\n-   of a PLACEHOLDER_EXPR.  The record to be used is the record within\n-   operand 1 that has the same type as the PLACEHOLDER_EXPR in\n-   operand 0.  */\n-DEFTREECODE (WITH_RECORD_EXPR, \"with_record_expr\", 'e', 2)\n-\n /* Simple arithmetic.  */\n DEFTREECODE (PLUS_EXPR, \"plus_expr\", '2', 2)\n DEFTREECODE (MINUS_EXPR, \"minus_expr\", '2', 2)"}, {"sha": "28b26deb865fd21477a75e50550008b85776a15d", "filename": "gcc/tree.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fce44af562fae5ad9275e183abdf6cf87a87f6e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6fce44af562fae5ad9275e183abdf6cf87a87f6e", "patch": "@@ -2675,6 +2675,24 @@ extern int has_cleanups (tree);\n \n extern tree substitute_in_expr (tree, tree, tree);\n \n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time and also checks for NULL.  */\n+\n+#define SUBSTITUTE_IN_EXPR(EXP, F, R) \\\n+  ((EXP) == 0 || TREE_CONSTANT (EXP) ? (EXP) : substitute_in_expr (EXP, F, R))\n+\n+/* Similar, but look for a PLACEHOLDER_EXPR in EXP and find a replacement\n+   for it within OBJ, a tree that is an object or a chain of references.  */\n+\n+extern tree substitute_placeholder_in_expr (tree, tree);\n+\n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time and also checks for NULL.  */\n+\n+#define SUBSTITUTE_PLACEHOLDER_IN_EXPR(EXP, OBJ) \\\n+  ((EXP) == 0 || TREE_CONSTANT (EXP) ? (EXP)\t\\\n+   : substitute_placeholder_in_expr (EXP, OBJ))\n+\n /* variable_size (EXP) is like save_expr (EXP) except that it\n    is for the special case of something that is part of a\n    variable size for a data type.  It makes special arrangements"}]}