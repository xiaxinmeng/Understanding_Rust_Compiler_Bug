{"sha": "ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY5YzdiOGVlZGMxOTJjOTdkZWQyOTAyZGZlOTlmMjVjOTRmMGNlNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-02-15T06:55:42Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-02-15T06:55:42Z"}, "message": "re PR libgcj/5695 (verify.cc test that target is an object before running down interfaces)\n\n\tFix for PR libgcj/5695:\n\t* verify.cc (is_assignable_from_slow): Check to see if target is\n\tan Object before checking to see if source is an interface.\n\t(verify_instructions_0) [op_invokeinterface]: Handle case where\n\twe're making an interface call on Object.\n\nFrom-SVN: r49783", "tree": {"sha": "bf4df495a5c9b138460a843a0849e987d9305402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf4df495a5c9b138460a843a0849e987d9305402"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4/comments", "author": null, "committer": null, "parents": [{"sha": "15b28697de9a1f3ca0cbfb7cfb7fba09e13c8bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b28697de9a1f3ca0cbfb7cfb7fba09e13c8bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b28697de9a1f3ca0cbfb7cfb7fba09e13c8bec"}], "stats": {"total": 38, "additions": 34, "deletions": 4}, "files": [{"sha": "24e87e6fdea82b533f22ca7bf0e1763feb6acf2f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4", "patch": "@@ -1,3 +1,11 @@\n+2002-02-15  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR libgcj/5695:\n+\t* verify.cc (is_assignable_from_slow): Check to see if target is\n+\tan Object before checking to see if source is an interface.\n+\t(verify_instructions_0) [op_invokeinterface]: Handle case where\n+\twe're making an interface call on Object.\n+\n 2002-02-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* Makefile.in: Rebuilt with Eric's change below."}, {"sha": "cbadd9f2f2f96d7d29ad4d9734ce7d989e66d5f0", "filename": "libjava/verify.cc", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=ef9c7b8eedc192c97ded2902dfe99f25c94f0ce4", "patch": "@@ -259,6 +259,11 @@ class _Jv_BytecodeVerifier\n \t    if (source == NULL)\n \t      return false;\n \t  }\n+\t// We must do this check before we check to see if SOURCE is\n+\t// an interface.  This way we know that any interface is\n+\t// assignable to an Object.\n+\telse if (target == &java::lang::Object::class$)\n+\t  return true;\n \telse if (source->isInterface ())\n \t  {\n \t    for (int i = 0; i < target->interface_count; ++i)\n@@ -272,8 +277,6 @@ class _Jv_BytecodeVerifier\n \t    if (target == NULL)\n \t      return false;\n \t  }\n-\telse if (target == &java::lang::Object::class$)\n-\t  return true;\n \telse if (source == &java::lang::Object::class$)\n \t  return false;\n \telse\n@@ -2786,9 +2789,28 @@ class _Jv_BytecodeVerifier\n \t\t      // In this case the PC doesn't matter.\n \t\t      t.set_uninitialized (type::UNINIT, this);\n \t\t    }\n-\t\t  t = pop_type (t);\n+\t\t  type raw = pop_raw ();\n+\t\t  bool ok = false;\n+\t\t  if (t.compatible (raw, this))\n+\t\t    {\n+\t\t      ok = true;\n+\t\t    }\n+\t\t  else if (opcode == op_invokeinterface)\n+\t\t    {\n+\t\t      // This is a hack.  We might have merged two\n+\t\t      // items and gotten `Object'.  This can happen\n+\t\t      // because we don't keep track of where merges\n+\t\t      // come from.  This is safe as long as the\n+\t\t      // interpreter checks interfaces at runtime.\n+\t\t      type obj (&java::lang::Object::class$);\n+\t\t      ok = raw.compatible (obj, this);\n+\t\t    }\n+\n+\t\t  if (! ok)\n+\t\t    verify_fail (\"incompatible type on stack\");\n+\n \t\t  if (is_init)\n-\t\t    current_state->set_initialized (t.get_pc (),\n+\t\t    current_state->set_initialized (raw.get_pc (),\n \t\t\t\t\t\t    current_method->max_locals);\n \t\t}\n "}]}