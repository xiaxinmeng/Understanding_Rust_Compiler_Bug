{"sha": "269e379528abdb4f20494e7830a9912d7d5bc2e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5ZTM3OTUyOGFiZGI0ZjIwNDk0ZTc4MzBhOTkxMmQ3ZDViYzJlNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-10-13T08:40:44Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-10-13T08:40:44Z"}, "message": "avr.c, [...]: Convert to ISO C90 function declarations and definitions.\n\n\t* config/avr/avr.c, config/avr/avr-protos.h: Convert to\n\tISO C90 function declarations and definitions.\n\nFrom-SVN: r72423", "tree": {"sha": "ec39a5dfcbaab0ed4a4b96f16aeef6d94b50ca7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec39a5dfcbaab0ed4a4b96f16aeef6d94b50ca7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/269e379528abdb4f20494e7830a9912d7d5bc2e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269e379528abdb4f20494e7830a9912d7d5bc2e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269e379528abdb4f20494e7830a9912d7d5bc2e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269e379528abdb4f20494e7830a9912d7d5bc2e5/comments", "author": null, "committer": null, "parents": [{"sha": "3c94ac3565a840b32e695a79cbce1218144e3116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c94ac3565a840b32e695a79cbce1218144e3116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c94ac3565a840b32e695a79cbce1218144e3116"}], "stats": {"total": 690, "additions": 242, "deletions": 448}, "files": [{"sha": "71e9d40e41ae7f7da4b46a5ba035fd4f3a08da24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e379528abdb4f20494e7830a9912d7d5bc2e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e379528abdb4f20494e7830a9912d7d5bc2e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=269e379528abdb4f20494e7830a9912d7d5bc2e5", "patch": "@@ -1,3 +1,8 @@\n+2003-10-12  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* config/avr/avr.c, config/avr/avr-protos.h: Convert to\n+\tISO C90 function declarations and definitions.\n+\n 2003-10-12  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* config.gcc (*-*-freebsd*): Use tm_defines instead of tiny"}, {"sha": "19ee9e85b2db7966dc9495daac0cecd97aeebee1", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 96, "deletions": 114, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e379528abdb4f20494e7830a9912d7d5bc2e5/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e379528abdb4f20494e7830a9912d7d5bc2e5/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=269e379528abdb4f20494e7830a9912d7d5bc2e5", "patch": "@@ -1,6 +1,6 @@\n /* Prototypes for exported functions defined in avr.c\n    \n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Denis Chertykov (denisc@overta.ru)\n \n    This file is part of GCC.\n@@ -21,133 +21,115 @@\n    Boston, MA 02111-1307, USA.  */\n \n \n-extern int    function_arg_regno_p              PARAMS ((int r));\n-extern void   avr_init_once                     PARAMS ((void));\n-extern void   avr_override_options              PARAMS ((void));\n-extern void   avr_optimization_options\t\tPARAMS ((int level, int size));\n-extern char * avr_change_section                PARAMS ((char *sect_name));\n-extern int    avr_ret_register                  PARAMS ((void));\n-extern enum reg_class class_likely_spilled_p    PARAMS ((int c));\n-extern enum reg_class avr_regno_reg_class       PARAMS ((int r));\n-extern enum reg_class avr_reg_class_from_letter PARAMS ((int c));\n-extern int    frame_pointer_required_p          PARAMS ((void));\n-extern void   asm_globalize_label         PARAMS ((FILE *file, const char *name));\n-extern void   order_regs_for_local_alloc  PARAMS ((void));\n-extern int    initial_elimination_offset  PARAMS ((int from, int to));\n-extern int    avr_simple_epilogue         PARAMS ((void));\n-extern void   progmem_section             PARAMS ((void));\n-extern int    mask_one_bit_p              PARAMS ((HOST_WIDE_INT mask));\n-extern void   gas_output_limited_string PARAMS ((FILE *file, const char *str));\n-extern void   gas_output_ascii          PARAMS ((FILE *file, const char *str,\n-\t\t\t\t\t\t\t size_t length));\n-#ifdef TREE_CODE\n-extern void   asm_output_external          PARAMS ((FILE *file, tree decl,\n-\t\t\t\t\t\t   char *name));\n-extern int    avr_progmem_p                PARAMS ((tree decl));\n+extern int function_arg_regno_p (int r);\n+extern void avr_init_once (void);\n+extern void avr_override_options (void);\n+extern void avr_optimization_options (int level, int size);\n+extern char *avr_change_section (char *sect_name);\n+extern int avr_ret_register (void);\n+extern enum reg_class class_likely_spilled_p (int c);\n+extern enum reg_class avr_regno_reg_class (int r);\n+extern enum reg_class avr_reg_class_from_letter (int c);\n+extern int frame_pointer_required_p (void);\n+extern void asm_globalize_label (FILE *file, const char *name);\n+extern void order_regs_for_local_alloc (void);\n+extern int initial_elimination_offset (int from, int to);\n+extern int avr_simple_epilogue (void);\n+extern void progmem_section (void);\n+extern int mask_one_bit_p (HOST_WIDE_INT mask);\n+extern void gas_output_limited_string (FILE *file, const char *str);\n+extern void gas_output_ascii (FILE *file, const char *str, size_t length);\n \n+#ifdef TREE_CODE\n+extern void asm_output_external (FILE *file, tree decl, char *name);\n+extern int avr_progmem_p (tree decl);\n \n #ifdef RTX_CODE /* inside TREE_CODE */\n-extern rtx    avr_function_value           PARAMS ((tree type, tree func));\n-extern void   init_cumulative_args         PARAMS ((CUMULATIVE_ARGS *cum,\n-\t\t\t\t\t\t   tree fntype, rtx libname,\n-\t\t\t\t\t\t   tree fndecl));\n-extern rtx    function_arg         PARAMS ((CUMULATIVE_ARGS *cum,\n-\t\t\t\t\t   enum machine_mode mode,\n-\t\t\t\t\t   tree type, int named));\n-\n-\n+extern rtx avr_function_value (tree type, tree func);\n+extern void init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n+\t\t\t\t  rtx libname, tree fndecl);\n+extern rtx function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t tree type, int named);\n #endif /* RTX_CODE inside TREE_CODE */\n \n #ifdef HAVE_MACHINE_MODES /* inside TREE_CODE */\n-extern void   function_arg_advance PARAMS ((CUMULATIVE_ARGS *cum,\n-\t\t\t\t\t   enum machine_mode mode, tree type,\n-\t\t\t\t\t   int named));\n+extern void function_arg_advance (CUMULATIVE_ARGS *cum,\n+\t\t\t\t  enum machine_mode mode, tree type,\n+\t\t\t\t  int named);\n #endif /* HAVE_MACHINE_MODES inside TREE_CODE*/\n #endif /* TREE_CODE */\n \n #ifdef RTX_CODE\n-extern void   asm_output_external_libcall PARAMS ((FILE *file, rtx symref));\n-extern int    legitimate_address_p    PARAMS ((enum machine_mode mode, rtx x,\n-\t\t\t\t\tint strict));\n-extern int    compare_diff_p  PARAMS ((rtx insn));\n-extern const char * output_movqi    PARAMS ((rtx insn, rtx operands[], int *l));\n-extern const char * output_movhi    PARAMS ((rtx insn, rtx operands[], int *l));\n-extern const char * out_movqi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n-extern const char * out_movqi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern const char * out_movhi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n-extern const char * out_movhi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern const char * out_movsi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n-extern const char * out_movsi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern const char * output_movsisf  PARAMS ((rtx insn, rtx operands[], int *l));\n-extern const char * out_tstsi       PARAMS ((rtx insn, int *l));\n-extern const char * out_tsthi       PARAMS ((rtx insn, int *l));\n-extern const char * ret_cond_branch PARAMS ((rtx x, int len, int reverse));\n-\n-extern const char * ashlqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-extern const char * ashlhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-extern const char * ashlsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-\n-extern const char * ashrqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-extern const char * ashrhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-extern const char * ashrsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-\n-extern const char * lshrqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-extern const char * lshrhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-extern const char * lshrsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n-\n-extern void avr_output_bld PARAMS ((rtx operands[], int bit_nr));\n-extern void avr_output_addr_vec_elt PARAMS ((FILE *stream, int value));\n-extern const char *avr_out_sbxx_branch PARAMS ((rtx insn, rtx operands[]));\n-\n-extern enum reg_class preferred_reload_class PARAMS ((rtx x,\n-\t\t\t\t\t\t     enum reg_class class));\n-extern int    extra_constraint       PARAMS ((rtx x, int c));\n-extern rtx    legitimize_address     PARAMS ((rtx x, rtx oldx,\n-\t\t\t\t\t     enum machine_mode mode));\n-extern int    adjust_insn_length     PARAMS ((rtx insn, int len));\n-extern rtx    avr_libcall_value      PARAMS ((enum machine_mode mode));\n-extern const char * output_reload_inhi PARAMS ((rtx insn, rtx *operands,\n-\t\t\t\t\t\tint *len));\n-extern const char * output_reload_insisf PARAMS ((rtx insn, rtx *operands,\n-\t\t\t\t\t\tint *len));\n-extern enum reg_class secondary_input_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t\t\t   rtx));\n-extern void   notice_update_cc       PARAMS ((rtx body, rtx insn));\n-extern void   print_operand          PARAMS ((FILE *file, rtx x, int code));\n-extern void   print_operand_address  PARAMS ((FILE *file, rtx addr));\n-extern int    reg_unused_after       PARAMS ((rtx insn, rtx reg));\n-extern int    _reg_unused_after      PARAMS ((rtx insn, rtx reg));\n-extern int    avr_jump_mode          PARAMS ((rtx x, rtx insn));\n-extern int    byte_immediate_operand PARAMS ((register rtx op,\n-\t\t\t\t\t     enum machine_mode mode));\n-extern int    test_hard_reg_class    PARAMS ((enum reg_class class, rtx x));\n-extern int    jump_over_one_insn_p   PARAMS ((rtx insn, rtx dest));\n-\n-extern int    avr_hard_regno_mode_ok PARAMS ((int regno,\n-\t\t\t\t\t     enum machine_mode mode));\n-extern int    call_insn_operand      PARAMS ((rtx op, enum machine_mode mode));\n-extern void   final_prescan_insn     PARAMS ((rtx insn, rtx *operand,\n-\t\t\t\t\t      int num_operands));\n-extern int    avr_simplify_comparison_p PARAMS ((enum machine_mode mode,\n-\t\t\t\t\t      RTX_CODE operator, rtx x));\n-extern RTX_CODE avr_normalize_condition  PARAMS ((RTX_CODE condition));\n-extern int    compare_eq_p           PARAMS ((rtx insn));\n-extern void   out_shift_with_cnt     PARAMS ((const char *template, rtx insn,\n-\t\t\t\t\t      rtx operands[], int *len,\n-\t\t\t\t\t      int t_len));\n-extern int    avr_io_address_p\t     PARAMS ((rtx x, int size));\n-extern int    const_int_pow2_p       PARAMS ((rtx x));\n-extern int    avr_peep2_scratch_safe PARAMS ((rtx reg_rtx));\n+extern void asm_output_external_libcall (FILE *file, rtx symref);\n+extern int legitimate_address_p (enum machine_mode mode, rtx x,\tint strict);\n+extern int compare_diff_p (rtx insn);\n+extern const char *output_movqi (rtx insn, rtx operands[], int *l);\n+extern const char *output_movhi (rtx insn, rtx operands[], int *l);\n+extern const char *out_movqi_r_mr (rtx insn, rtx op[], int *l);\n+extern const char *out_movqi_mr_r (rtx insn, rtx op[], int *l);\n+extern const char *out_movhi_r_mr (rtx insn, rtx op[], int *l);\n+extern const char *out_movhi_mr_r (rtx insn, rtx op[], int *l);\n+extern const char *out_movsi_r_mr (rtx insn, rtx op[], int *l);\n+extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n+extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n+extern const char *out_tstsi (rtx insn, int *l);\n+extern const char *out_tsthi (rtx insn, int *l);\n+extern const char *ret_cond_branch (rtx x, int len, int reverse);\n+\n+extern const char *ashlqi3_out (rtx insn, rtx operands[], int *len);\n+extern const char *ashlhi3_out (rtx insn, rtx operands[], int *len);\n+extern const char *ashlsi3_out (rtx insn, rtx operands[], int *len);\n+\n+extern const char *ashrqi3_out (rtx insn, rtx operands[], int *len);\n+extern const char *ashrhi3_out (rtx insn, rtx operands[], int *len);\n+extern const char *ashrsi3_out (rtx insn, rtx operands[], int *len);\n+\n+extern const char *lshrqi3_out (rtx insn, rtx operands[], int *len);\n+extern const char *lshrhi3_out (rtx insn, rtx operands[], int *len);\n+extern const char *lshrsi3_out (rtx insn, rtx operands[], int *len);\n+\n+extern void avr_output_bld (rtx operands[], int bit_nr);\n+extern void avr_output_addr_vec_elt (FILE *stream, int value);\n+extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n+\n+extern enum reg_class preferred_reload_class (rtx x, enum reg_class class);\n+extern int extra_constraint (rtx x, int c);\n+extern rtx legitimize_address (rtx x, rtx oldx, enum machine_mode mode);\n+extern int adjust_insn_length (rtx insn, int len);\n+extern rtx avr_libcall_value (enum machine_mode mode);\n+extern const char *output_reload_inhi (rtx insn, rtx *operands, int *len);\n+extern const char *output_reload_insisf (rtx insn, rtx *operands, int *len);\n+extern enum reg_class secondary_input_reload_class (enum reg_class,\n+\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t    rtx);\n+extern void notice_update_cc (rtx body, rtx insn);\n+extern void print_operand (FILE *file, rtx x, int code);\n+extern void print_operand_address (FILE *file, rtx addr);\n+extern int reg_unused_after (rtx insn, rtx reg);\n+extern int _reg_unused_after (rtx insn, rtx reg);\n+extern int avr_jump_mode (rtx x, rtx insn);\n+extern int byte_immediate_operand (rtx op, enum machine_mode mode);\n+extern int test_hard_reg_class (enum reg_class class, rtx x);\n+extern int jump_over_one_insn_p (rtx insn, rtx dest);\n+\n+extern int avr_hard_regno_mode_ok (int regno, enum machine_mode mode);\n+extern int call_insn_operand (rtx op, enum machine_mode mode);\n+extern void final_prescan_insn (rtx insn, rtx *operand, int num_operands);\n+extern int avr_simplify_comparison_p (enum machine_mode mode,\n+\t\t\t\t      RTX_CODE operator, rtx x);\n+extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n+extern int compare_eq_p (rtx insn);\n+extern void out_shift_with_cnt (const char *template, rtx insn,\n+\t\t\t\trtx operands[], int *len, int t_len);\n+extern int avr_io_address_p (rtx x, int size);\n+extern int const_int_pow2_p (rtx x);\n+extern int avr_peep2_scratch_safe (rtx reg_rtx);\n #endif /* RTX_CODE */\n \n #ifdef HAVE_MACHINE_MODES\n-extern int    class_max_nregs        PARAMS ((enum reg_class class,\n-\t\t\t\t\t     enum machine_mode mode));\n+extern int class_max_nregs (enum reg_class class, enum machine_mode mode);\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef REAL_VALUE_TYPE\n-\n-extern void   asm_output_float       PARAMS ((FILE *file, REAL_VALUE_TYPE n));\n-\n+extern void asm_output_float (FILE *file, REAL_VALUE_TYPE n);\n #endif"}, {"sha": "a7a71871552c5ba0cdaf43e8b46a4843de7dc765", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 141, "deletions": 334, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e379528abdb4f20494e7830a9912d7d5bc2e5/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e379528abdb4f20494e7830a9912d7d5bc2e5/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=269e379528abdb4f20494e7830a9912d7d5bc2e5", "patch": "@@ -46,36 +46,36 @@\n /* Maximal allowed offset for an address in the LD command */\n #define MAX_LD_OFFSET(MODE) (64 - (signed)GET_MODE_SIZE (MODE))\n \n-static int    avr_naked_function_p PARAMS ((tree));\n-static int    interrupt_function_p PARAMS ((tree));\n-static int    signal_function_p    PARAMS ((tree));\n-static int    avr_regs_to_save     PARAMS ((HARD_REG_SET *));\n-static int    sequent_regs_live    PARAMS ((void));\n-static const char * ptrreg_to_str  PARAMS ((int));\n-static const char * cond_string    PARAMS ((enum rtx_code));\n-static int    avr_num_arg_regs     PARAMS ((enum machine_mode, tree));\n-static int    out_adj_frame_ptr    PARAMS ((FILE *, int));\n-static int    out_set_stack_ptr    PARAMS ((FILE *, int, int));\n-static RTX_CODE compare_condition  PARAMS ((rtx insn));\n-static int    compare_sign_p       PARAMS ((rtx insn));\n-static tree   avr_handle_progmem_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree   avr_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static int avr_naked_function_p (tree);\n+static int interrupt_function_p (tree);\n+static int signal_function_p (tree);\n+static int avr_regs_to_save (HARD_REG_SET *);\n+static int sequent_regs_live (void);\n+static const char *ptrreg_to_str (int);\n+static const char *cond_string (enum rtx_code);\n+static int avr_num_arg_regs (enum machine_mode, tree);\n+static int out_adj_frame_ptr (FILE *, int);\n+static int out_set_stack_ptr (FILE *, int, int);\n+static RTX_CODE compare_condition (rtx insn);\n+static int compare_sign_p (rtx insn);\n+static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);\n+static tree avr_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n const struct attribute_spec avr_attribute_table[];\n-static bool   avr_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void   avr_file_start PARAMS ((void));\n-static void   avr_file_end PARAMS ((void));\n-static void   avr_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void   avr_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void   avr_unique_section PARAMS ((tree, int));\n-static void   avr_insert_attributes PARAMS ((tree, tree *));\n-static unsigned int avr_section_type_flags PARAMS ((tree, const char *, int));\n-\n-static void avr_reorg PARAMS ((void));\n-static void   avr_asm_out_ctor PARAMS ((rtx, int));\n-static void   avr_asm_out_dtor PARAMS ((rtx, int));\n-static int default_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));\n-static bool avr_rtx_costs PARAMS ((rtx, int, int, int *));\n-static int avr_address_cost PARAMS ((rtx));\n+static bool avr_assemble_integer (rtx, unsigned int, int);\n+static void avr_file_start (void);\n+static void avr_file_end (void);\n+static void avr_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void avr_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void avr_unique_section (tree, int);\n+static void avr_insert_attributes (tree, tree *);\n+static unsigned int avr_section_type_flags (tree, const char *, int);\n+\n+static void avr_reorg (void);\n+static void avr_asm_out_ctor (rtx, int);\n+static void avr_asm_out_dtor (rtx, int);\n+static int default_rtx_costs (rtx, enum rtx_code, enum rtx_code);\n+static bool avr_rtx_costs (rtx, int, int, int *);\n+static int avr_address_cost (rtx);\n \n /* Allocate registers from r25 to r8 for parameters for function calls */\n #define FIRST_CUM_REG 26\n@@ -248,7 +248,7 @@ int avr_case_values_threshold = 30000;\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n-avr_override_options ()\n+avr_override_options (void)\n {\n   const struct mcu_type_s *t;\n   const struct base_arch_s *base;\n@@ -279,7 +279,7 @@ avr_override_options ()\n #if 0 /* Does not play nice with GC.  FIXME. */\n /* Initialize TMP_REG_RTX and ZERO_REG_RTX */\n void\n-avr_init_once ()\n+avr_init_once (void)\n {\n   tmp_reg_rtx = xcalloc (1, sizeof (struct rtx_def) + 1 * sizeof (rtunion));\n   PUT_CODE (tmp_reg_rtx, REG);\n@@ -317,8 +317,7 @@ static const int reg_class_tab[]={\n /* Return register class for register R */\n \n enum reg_class\n-avr_regno_reg_class (r)\n-     int r;\n+avr_regno_reg_class (int r)\n {\n   if (r <= 33)\n     return reg_class_tab[r];\n@@ -334,8 +333,7 @@ avr_regno_reg_class (r)\n    passed to this macro; you do not need to handle it.  */\n \n enum reg_class\n-avr_reg_class_from_letter  (c)\n-     int c;\n+avr_reg_class_from_letter  (int c)\n {\n   switch (c)\n     {\n@@ -358,8 +356,7 @@ avr_reg_class_from_letter  (c)\n /* Return nonzero if FUNC is a naked function.  */\n \n static int\n-avr_naked_function_p (func)\n-     tree func;\n+avr_naked_function_p (tree func)\n {\n   tree a;\n \n@@ -374,8 +371,7 @@ avr_naked_function_p (func)\n    by the \"interrupt\" attribute.  */\n \n static int\n-interrupt_function_p (func)\n-     tree func;\n+interrupt_function_p (tree func)\n {\n   tree a;\n \n@@ -390,8 +386,7 @@ interrupt_function_p (func)\n    by the \"signal\" attribute.  */\n \n static int\n-signal_function_p (func)\n-     tree func;\n+signal_function_p (tree func)\n {\n   tree a;\n \n@@ -406,8 +401,7 @@ signal_function_p (func)\n    of the current function, and optionally store these registers in SET.  */\n \n static int\n-avr_regs_to_save (set)\n-     HARD_REG_SET *set;\n+avr_regs_to_save (HARD_REG_SET *set)\n {\n   int reg, count;\n   int int_or_sig_p = (interrupt_function_p (current_function_decl)\n@@ -446,9 +440,7 @@ avr_regs_to_save (set)\n /* Compute offset between arg_pointer and frame_pointer */\n \n int\n-initial_elimination_offset (from, to)\n-     int from;\n-     int to;\n+initial_elimination_offset (int from, int to)\n {\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return 0;\n@@ -464,7 +456,7 @@ initial_elimination_offset (from, to)\n /* Return 1 if the function epilogue is just a single \"ret\".  */\n \n int\n-avr_simple_epilogue ()\n+avr_simple_epilogue (void)\n {\n   return (! frame_pointer_needed\n \t  && get_frame_size () == 0\n@@ -479,7 +471,7 @@ avr_simple_epilogue ()\n /* This function checks sequence of live registers */\n \n static int\n-sequent_regs_live ()\n+sequent_regs_live (void)\n {\n   int reg;\n   int live_seq=0;\n@@ -531,9 +523,7 @@ sequent_regs_live ()\n    (epilogue).  Returns the number of instructions generated.  */\n \n static int\n-out_adj_frame_ptr (file, adj)\n-     FILE *file;\n-     int adj;\n+out_adj_frame_ptr (FILE *file, int adj)\n {\n   int size = 0;\n \n@@ -578,10 +568,7 @@ out_adj_frame_ptr (file, adj)\n    Returns the number of instructions generated.  */\n \n static int\n-out_set_stack_ptr (file, before, after)\n-     FILE *file;\n-     int before;\n-     int after;\n+out_set_stack_ptr (FILE *file, int before, int after)\n {\n   int do_sph, do_cli, do_save, do_sei, lock_sph, size;\n \n@@ -641,9 +628,7 @@ out_set_stack_ptr (file, before, after)\n /* Output function prologue */\n \n static void\n-avr_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+avr_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n {\n   int reg;\n   int interrupt_func_p;\n@@ -773,9 +758,7 @@ avr_output_function_prologue (file, size)\n /* Output function epilogue */\n \n static void\n-avr_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+avr_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n {\n   int reg;\n   int interrupt_func_p;\n@@ -924,10 +907,7 @@ avr_output_function_epilogue (file, size)\n    machine for a memory operand of mode MODE.  */\n \n int\n-legitimate_address_p (mode, x, strict)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict;\n+legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   enum reg_class r = NO_REGS;\n   \n@@ -992,10 +972,7 @@ legitimate_address_p (mode, x, strict)\n    memory address for an operand of mode MODE  */\n \n rtx\n-legitimize_address (x, oldx, mode)\n-     rtx x;\n-     rtx oldx;\n-     enum machine_mode mode;\n+legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n {\n   x = oldx;\n   if (TARGET_ALL_DEBUG)\n@@ -1028,8 +1005,7 @@ legitimize_address (x, oldx, mode)\n /* Return a pointer register name as a string */\n \n static const char *\n-ptrreg_to_str (regno)\n-     int regno;\n+ptrreg_to_str (int regno)\n {\n   switch (regno)\n     {\n@@ -1046,8 +1022,7 @@ ptrreg_to_str (regno)\n    Used in conditional jump constructing  */\n \n static const char *\n-cond_string (code)\n-     enum rtx_code code;\n+cond_string (enum rtx_code code)\n {\n   switch (code)\n     {\n@@ -1077,9 +1052,7 @@ cond_string (code)\n /* Output ADDR to FILE as address */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -1113,10 +1086,7 @@ print_operand_address (file, addr)\n /* Output X as assembler operand to file FILE */\n      \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   int abcd = 0;\n \n@@ -1187,9 +1157,7 @@ print_operand (file, x, code)\n /* Recognize operand OP of mode MODE used in call instructions */\n \n int\n-call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -1205,9 +1173,7 @@ call_insn_operand (op, mode)\n /* Update the condition code in the INSN.  */\n \n void\n-notice_update_cc (body, insn)\n-     rtx body ATTRIBUTE_UNUSED;\n-     rtx insn;\n+notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n {\n   rtx set;\n   \n@@ -1282,9 +1248,7 @@ notice_update_cc (body, insn)\n    class CLASS needed to hold a value of mode MODE.  */\n \n int\n-class_max_nregs (class, mode)\n-     enum reg_class class ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+class_max_nregs (enum reg_class class ATTRIBUTE_UNUSED,enum machine_mode mode)\n {\n   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n }\n@@ -1295,9 +1259,7 @@ class_max_nregs (class, mode)\n    3 - absolute jump (only for ATmega[16]03).  */\n \n int\n-avr_jump_mode (x, insn)\n-     rtx x;                     /* jump operand */\n-     rtx insn;                  /* jump insn */\n+avr_jump_mode (rtx x, rtx insn)\n {\n   int dest_addr = INSN_ADDRESSES (INSN_UID (GET_MODE (x) == LABEL_REF\n \t\t\t\t\t    ? XEXP (x, 0) : x));\n@@ -1320,10 +1282,7 @@ avr_jump_mode (x, insn)\n    if REVERSE nonzero then condition code in X must be reversed.  */\n \n const char *\n-ret_cond_branch (x, len, reverse)\n-     rtx x;\n-     int len;\n-     int reverse;\n+ret_cond_branch (rtx x, int len, int reverse)\n {\n   RTX_CODE cond = reverse ? reverse_condition (GET_CODE (x)) : GET_CODE (x);\n   \n@@ -1422,9 +1381,7 @@ ret_cond_branch (x, len, reverse)\n /* Predicate function for immediate operand which fits to byte (8bit) */\n \n int\n-byte_immediate_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+byte_immediate_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n           && INTVAL (op) <= 0xff && INTVAL (op) >= 0);\n@@ -1436,9 +1393,8 @@ byte_immediate_operand (op, mode)\n    Output insn cost for next insn.  */\n \n void\n-final_prescan_insn (insn, operand, num_operands)\n-     rtx insn, *operand ATTRIBUTE_UNUSED;\n-     int num_operands ATTRIBUTE_UNUSED;\n+final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n+\t\t    int num_operands ATTRIBUTE_UNUSED)\n {\n   int uid = INSN_UID (insn);\n \n@@ -1455,10 +1411,7 @@ final_prescan_insn (insn, operand, num_operands)\n /* Return 0 if undefined, 1 if always true or always false.  */\n \n int\n-avr_simplify_comparison_p (mode, operator, x)\n-     enum machine_mode mode;\n-     RTX_CODE operator;\n-     rtx x;\n+avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE operator, rtx x)\n {\n   unsigned int max = (mode == QImode ? 0xff :\n                       mode == HImode ? 0xffff :\n@@ -1480,8 +1433,7 @@ avr_simplify_comparison_p (mode, operator, x)\n    register in which function arguments are sometimes passed.  */\n \n int\n-function_arg_regno_p(r)\n-     int r;\n+function_arg_regno_p(int r)\n {\n   return (r >= 8 && r <= 25);\n }\n@@ -1490,11 +1442,8 @@ function_arg_regno_p(r)\n    of the argument list.  */\n \n void\n-init_cumulative_args (cum, fntype, libname, fndecl)\n-     CUMULATIVE_ARGS *cum;\n-     tree fntype;\n-     rtx libname;\n-     tree fndecl ATTRIBUTE_UNUSED;\n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname,\n+\t\t      tree fndecl ATTRIBUTE_UNUSED)\n {\n   cum->nregs = 18;\n   cum->regno = FIRST_CUM_REG;\n@@ -1511,9 +1460,7 @@ init_cumulative_args (cum, fntype, libname, fndecl)\n /* Returns the number of registers to allocate for a function argument.  */\n \n static int\n-avr_num_arg_regs (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+avr_num_arg_regs (enum machine_mode mode, tree type)\n {\n   int size;\n \n@@ -1532,11 +1479,8 @@ avr_num_arg_regs (mode, type)\n    in a register, and which register. */\n \n rtx\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t      int named ATTRIBUTE_UNUSED)\n {\n   int bytes = avr_num_arg_regs (mode, type);\n \n@@ -1550,11 +1494,8 @@ function_arg (cum, mode, type, named)\n    in the argument list.  */\n    \n void\n-function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;      /* current arg information */\n-     enum machine_mode mode;    /* current arg mode */\n-     tree type;                 /* type of the argument or 0 if lib support */\n-     int named ATTRIBUTE_UNUSED; /* whether or not the argument was named */\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t\t      int named ATTRIBUTE_UNUSED)\n {\n   int bytes = avr_num_arg_regs (mode, type);\n \n@@ -1572,10 +1513,7 @@ function_arg_advance (cum, mode, type, named)\n   Functions for outputting various mov's for a various modes\n ************************************************************************/\n const char *\n-output_movqi (insn, operands, l)\n-     rtx insn;\n-     rtx operands[];\n-     int *l;\n+output_movqi (rtx insn, rtx operands[], int *l)\n {\n   int dummy;\n   rtx dest = operands[0];\n@@ -1667,10 +1605,7 @@ output_movqi (insn, operands, l)\n \n \n const char *\n-output_movhi (insn, operands, l)\n-     rtx insn;\n-     rtx operands[];\n-     int *l;\n+output_movhi (rtx insn, rtx operands[], int *l)\n {\n   int dummy;\n   rtx dest = operands[0];\n@@ -1833,10 +1768,7 @@ output_movhi (insn, operands, l)\n }\n \n const char *\n-out_movqi_r_mr (insn, op, l)\n-     rtx insn;\n-     rtx op[];\n-     int *l; /* instruction length */\n+out_movqi_r_mr (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -1899,10 +1831,7 @@ out_movqi_r_mr (insn, op, l)\n }\n \n const char *\n-out_movhi_r_mr (insn, op, l)\n-     rtx insn;\n-     rtx op[];\n-     int *l; /* instruction length */\n+out_movhi_r_mr (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -2033,10 +1962,7 @@ out_movhi_r_mr (insn, op, l)\n }\n \n const char *\n-out_movsi_r_mr (insn, op, l)\n-     rtx insn;\n-     rtx op[];\n-     int *l; /* instruction length */\n+out_movsi_r_mr (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -2197,10 +2123,7 @@ out_movsi_r_mr (insn, op, l)\n }\n \n const char *\n-out_movsi_mr_r (insn, op, l)\n-     rtx insn;\n-     rtx op[];\n-     int *l;\n+out_movsi_mr_r (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -2355,10 +2278,7 @@ out_movsi_mr_r (insn, op, l)\n }\n \n const char *\n-output_movsisf(insn, operands, l)\n-     rtx insn;\n-     rtx operands[];\n-     int *l;\n+output_movsisf(rtx insn, rtx operands[], int *l)\n {\n   int dummy;\n   rtx dest = operands[0];\n@@ -2509,10 +2429,7 @@ output_movsisf(insn, operands, l)\n }\n \n const char *\n-out_movqi_mr_r (insn, op, l)\n-     rtx insn;\n-     rtx op[];\n-     int *l; /* instruction length */\n+out_movqi_mr_r (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -2587,10 +2504,7 @@ out_movqi_mr_r (insn, op, l)\n }\n \n const char *\n-out_movhi_mr_r (insn, op, l)\n-     rtx insn;\n-     rtx op[];\n-     int *l;\n+out_movhi_mr_r (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -2703,7 +2617,7 @@ out_movhi_mr_r (insn, op, l)\n /* Return 1 if frame pointer for current function required */\n \n int\n-frame_pointer_required_p ()\n+frame_pointer_required_p (void)\n {\n   return (current_function_calls_alloca\n \t  || current_function_args_info.nregs == 0\n@@ -2713,8 +2627,7 @@ frame_pointer_required_p ()\n /* Returns the condition of compare insn INSN, or UNKNOWN.  */\n \n static RTX_CODE\n-compare_condition (insn)\n-     rtx insn;\n+compare_condition (rtx insn)\n {\n   rtx next = next_real_insn (insn);\n   RTX_CODE cond = UNKNOWN;\n@@ -2731,8 +2644,7 @@ compare_condition (insn)\n /* Returns nonzero if INSN is a tst insn that only tests the sign.  */\n \n static int\n-compare_sign_p (insn)\n-     rtx insn;\n+compare_sign_p (rtx insn)\n {\n   RTX_CODE cond = compare_condition (insn);\n   return (cond == GE || cond == LT);\n@@ -2742,8 +2654,7 @@ compare_sign_p (insn)\n    that needs to be swapped (GT, GTU, LE, LEU).  */\n \n int\n-compare_diff_p (insn)\n-     rtx insn;\n+compare_diff_p (rtx insn)\n {\n   RTX_CODE cond = compare_condition (insn);\n   return (cond == GT || cond == GTU || cond == LE || cond == LEU) ? cond : 0;\n@@ -2752,8 +2663,7 @@ compare_diff_p (insn)\n /* Returns nonzero if INSN is a compare insn with the EQ or NE condition.  */\n \n int\n-compare_eq_p (insn)\n-     rtx insn;\n+compare_eq_p (rtx insn)\n {\n   RTX_CODE cond = compare_condition (insn);\n   return (cond == EQ || cond == NE);\n@@ -2763,9 +2673,7 @@ compare_eq_p (insn)\n /* Output test instruction for HImode */\n \n const char *\n-out_tsthi (insn, l)\n-     rtx insn;\n-     int *l;\n+out_tsthi (rtx insn, int *l)\n {\n   if (compare_sign_p (insn))\n     {\n@@ -2793,9 +2701,7 @@ out_tsthi (insn, l)\n /* Output test instruction for SImode */\n \n const char *\n-out_tstsi (insn, l)\n-     rtx insn;\n-     int *l;\n+out_tstsi (rtx insn, int *l)\n {\n   if (compare_sign_p (insn))\n     {\n@@ -2823,12 +2729,8 @@ out_tstsi (insn, l)\n    carefully hand-optimized in ?sh??i3_out.  */\n \n void\n-out_shift_with_cnt (template, insn, operands, len, t_len)\n-     const char *template;\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n-     int t_len;  /* Length of template.  */\n+out_shift_with_cnt (const char *template, rtx insn, rtx operands[],\n+\t\t    int *len, int t_len)\n {\n   rtx op[10];\n   char str[500];\n@@ -2961,10 +2863,7 @@ out_shift_with_cnt (template, insn, operands, len, t_len)\n /* 8bit shift left ((char)x << i)   */\n \n const char *\n-ashlqi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\t\t\t/* insn length (may be NULL) */\n+ashlqi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3058,10 +2957,7 @@ ashlqi3_out (insn, operands, len)\n /* 16bit shift left ((short)x << i)   */\n \n const char *\n-ashlhi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+ashlhi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3314,10 +3210,7 @@ ashlhi3_out (insn, operands, len)\n /* 32bit shift left ((long)x << i)   */\n \n const char *\n-ashlsi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+ashlsi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3418,10 +3311,7 @@ ashlsi3_out (insn, operands, len)\n /* 8bit arithmetic shift right  ((signed char)x >> i) */\n \n const char *\n-ashrqi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len; /* insn length */\n+ashrqi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3488,10 +3378,7 @@ ashrqi3_out (insn, operands, len)\n /* 16bit arithmetic shift right  ((signed short)x >> i) */\n \n const char *\n-ashrhi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+ashrhi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3653,10 +3540,7 @@ ashrhi3_out (insn, operands, len)\n /* 32bit arithmetic shift right  ((signed long)x >> i) */\n \n const char *\n-ashrsi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+ashrsi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3772,10 +3656,7 @@ ashrsi3_out (insn, operands, len)\n /* 8bit logic shift right ((unsigned char)x >> i) */\n \n const char *\n-lshrqi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+lshrqi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3867,10 +3748,7 @@ lshrqi3_out (insn, operands, len)\n /* 16bit logic shift right ((unsigned short)x >> i) */\n \n const char *\n-lshrhi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+lshrhi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -4122,10 +4000,7 @@ lshrhi3_out (insn, operands, len)\n /* 32bit logic shift right ((unsigned int)x >> i) */\n \n const char *\n-lshrsi3_out (insn, operands, len)\n-     rtx insn;\n-     rtx operands[];\n-     int *len;\n+lshrsi3_out (rtx insn, rtx operands[], int *len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -4217,9 +4092,7 @@ lshrsi3_out (insn, operands, len)\n  LEN is the initially computed length of the insn.  */\n \n int\n-adjust_insn_length (insn, len)\n-     rtx insn;\n-     int len;\n+adjust_insn_length (rtx insn, int len)\n {\n   rtx patt = PATTERN (insn);\n   rtx set;\n@@ -4367,9 +4240,7 @@ adjust_insn_length (insn, len)\n /* Return nonzero if register REG dead after INSN */\n \n int\n-reg_unused_after (insn, reg)\n-     rtx insn;\n-     rtx reg;\n+reg_unused_after (rtx insn, rtx reg)\n {\n   return (dead_or_set_p (insn, reg)\n \t  || (REG_P(reg) && _reg_unused_after (insn, reg)));\n@@ -4380,9 +4251,7 @@ reg_unused_after (insn, reg)\n    not live past labels.  It may live past calls or jumps though.  */\n \n int\n-_reg_unused_after (insn, reg)\n-     rtx insn;\n-     rtx reg;\n+_reg_unused_after (rtx insn, rtx reg)\n {\n   enum rtx_code code;\n   rtx set;\n@@ -4485,10 +4354,7 @@ _reg_unused_after (insn, reg)\n    special handling for references to certain labels.  */\n \n static bool\n-avr_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (size == POINTER_SIZE / BITS_PER_UNIT && aligned_p\n       && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))\n@@ -4505,9 +4371,7 @@ avr_assemble_integer (x, size, aligned_p)\n /* Sets section name for declaration DECL */\n   \n static void\n-avr_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc ATTRIBUTE_UNUSED;\n+avr_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n {\n   int len;\n   const char *name, *prefix;\n@@ -4544,9 +4408,7 @@ avr_unique_section (decl, reloc)\n    comma separated lists of numbers).   */\n \n void\n-gas_output_limited_string(file, str)\n-     FILE *file;\n-     const char * str;\n+gas_output_limited_string(FILE *file, const char *str)\n {\n   const unsigned char *_limited_str = (unsigned char *) str;\n   unsigned ch;\n@@ -4579,10 +4441,7 @@ gas_output_limited_string(file, str)\n    STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n \n void\n-gas_output_ascii(file, str, length)\n-     FILE * file;\n-     const char * str;\n-     size_t length;\n+gas_output_ascii(FILE *file, const char *str, size_t length)\n {\n   const unsigned char *_ascii_bytes = (const unsigned char *) str;\n   const unsigned char *limit = _ascii_bytes + length;\n@@ -4640,8 +4499,7 @@ gas_output_ascii(file, str, length)\n    because registers of CLASS are needed for spill registers.  */\n \n enum reg_class\n-class_likely_spilled_p (c)\n-     int c;\n+class_likely_spilled_p (int c)\n {\n   return (c != ALL_REGS && c != ADDW_REGS);\n }\n@@ -4669,12 +4527,10 @@ const struct attribute_spec avr_attribute_table[] =\n /* Handle a \"progmem\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-avr_handle_progmem_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+avr_handle_progmem_attribute (tree *node, tree name,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t      bool *no_add_attrs)\n {\n   if (DECL_P (*node))\n     {\n@@ -4712,13 +4568,12 @@ avr_handle_progmem_attribute (node, name, args, flags, no_add_attrs)\n \n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n    struct attribute_spec.handler.  */\n+\n static tree\n-avr_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+avr_handle_fndecl_attribute (tree *node, tree name,\n+\t\t\t     tree args ATTRIBUTE_UNUSED,\n+\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t     bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -4734,8 +4589,7 @@ avr_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n    if found return 1, otherwise 0.  */\n \n int\n-avr_progmem_p (decl)\n-     tree decl;\n+avr_progmem_p (tree decl)\n {\n   tree a;\n \n@@ -4763,9 +4617,7 @@ avr_progmem_p (decl)\n /* Add the section attribute if the variable is in progmem.  */\n \n static void\n-avr_insert_attributes (node, attributes)\n-     tree node;\n-     tree *attributes;\n+avr_insert_attributes (tree node, tree *attributes)\n {\n   if (TREE_CODE (node) == VAR_DECL\n       && (TREE_STATIC (node) || DECL_EXTERNAL (node))\n@@ -4783,10 +4635,7 @@ avr_insert_attributes (node, attributes)\n }\n \n static unsigned int\n-avr_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+avr_section_type_flags (tree decl, const char *name, int reloc)\n {\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n \n@@ -4807,7 +4656,7 @@ avr_section_type_flags (decl, name, reloc)\n    file.  */\n \n static void\n-avr_file_start ()\n+avr_file_start (void)\n {\n   if (avr_asm_only_p)\n     error (\"MCU `%s' supported for assembler only\", avr_mcu_name);\n@@ -4837,7 +4686,7 @@ avr_file_start ()\n    appropriate text to go at the end of an assembler file.  */\n \n static void\n-avr_file_end ()\n+avr_file_end (void)\n {\n   fputs (\"/* File \", asm_out_file);\n   output_quoted_string (asm_out_file, main_input_filename);\n@@ -4857,7 +4706,7 @@ avr_file_end ()\n    next register; and so on.  */\n \n void\n-order_regs_for_local_alloc ()\n+order_regs_for_local_alloc (void)\n {\n   unsigned int i;\n   static const int order_0[] = {\n@@ -4909,10 +4758,7 @@ order_regs_for_local_alloc ()\n    found in OUTER_CODE */\n \n static int\n-default_rtx_costs (X, code, outer_code)\n-     rtx X;\n-     enum rtx_code code;\n-     enum rtx_code outer_code;\n+default_rtx_costs (rtx X, enum rtx_code code, enum rtx_code outer_code)\n {\n   int cost=0;\n   switch (code)\n@@ -4968,10 +4814,7 @@ default_rtx_costs (X, code, outer_code)\n }\n \n static bool\n-avr_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+avr_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   int cst;\n \n@@ -5020,8 +4863,7 @@ avr_rtx_costs (x, code, outer_code, total)\n /* Calculate the cost of a memory address */\n \n static int\n-avr_address_cost (x)\n-     rtx x;\n+avr_address_cost (rtx x)\n {\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x,1)) == CONST_INT\n@@ -5040,9 +4882,7 @@ avr_address_cost (x)\n /*  EXTRA_CONSTRAINT helper */\n \n int\n-extra_constraint (x, c)\n-     rtx x;\n-     int c;\n+extra_constraint (rtx x, int c)\n {\n   if (c == 'Q'\n       && GET_CODE (x) == MEM\n@@ -5088,8 +4928,7 @@ extra_constraint (x, c)\n /* Convert condition code CONDITION to the valid AVR condition code */\n \n RTX_CODE\n-avr_normalize_condition (condition)\n-     RTX_CODE condition;\n+avr_normalize_condition (RTX_CODE condition)\n {\n   switch (condition)\n     {\n@@ -5109,7 +4948,7 @@ avr_normalize_condition (condition)\n /* This function optimizes conditional jumps.  */\n \n static void\n-avr_reorg ()\n+avr_reorg (void)\n {\n   rtx insn, pattern;\n   \n@@ -5188,7 +5027,7 @@ avr_reorg ()\n /* Returns register number for function return value.*/\n \n int\n-avr_ret_register ()\n+avr_ret_register (void)\n {\n   return 24;\n }\n@@ -5197,8 +5036,7 @@ avr_ret_register ()\n    library function returns a value of mode MODE.  */\n \n rtx\n-avr_libcall_value (mode)\n-     enum machine_mode mode;\n+avr_libcall_value (enum machine_mode mode)\n {\n   int offs = GET_MODE_SIZE (mode);\n   if (offs < 2)\n@@ -5210,9 +5048,7 @@ avr_libcall_value (mode)\n    function returns a value of data type VALTYPE.  */\n \n rtx\n-avr_function_value (type, func)\n-     tree type;\n-     tree func ATTRIBUTE_UNUSED;\n+avr_function_value (tree type, tree func ATTRIBUTE_UNUSED)\n {\n   unsigned int offs;\n   \n@@ -5233,8 +5069,7 @@ avr_function_value (type, func)\n /* Returns nonzero if the number MASK has only one bit set.  */\n \n int\n-mask_one_bit_p (mask)\n-     HOST_WIDE_INT mask;\n+mask_one_bit_p (HOST_WIDE_INT mask)\n {\n   int i;\n   unsigned HOST_WIDE_INT n=mask;\n@@ -5258,17 +5093,13 @@ mask_one_bit_p (mask)\n    in class CLASS.  */\n \n enum reg_class\n-preferred_reload_class (x, class)\n-     rtx x ATTRIBUTE_UNUSED;\n-     enum reg_class class;\n+preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n {\n   return class;\n }\n \n int\n-test_hard_reg_class (class, x)\n-     enum reg_class class;\n-     rtx x;\n+test_hard_reg_class (enum reg_class class, rtx x)\n {\n   int regno = true_regnum (x);\n   if (regno < 0)\n@@ -5282,9 +5113,7 @@ test_hard_reg_class (class, x)\n \n \n int\n-jump_over_one_insn_p (insn, dest)\n-     rtx insn;\n-     rtx dest;\n+jump_over_one_insn_p (rtx insn, rtx dest)\n {\n   int uid = INSN_UID (GET_CODE (dest) == LABEL_REF\n \t\t      ? XEXP (dest, 0)\n@@ -5300,9 +5129,7 @@ jump_over_one_insn_p (insn, dest)\n    (this way we don't have to check for odd registers everywhere).  */\n \n int\n-avr_hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n+avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   /* Bug workaround: recog.c (peep2_find_free_register) and probably\n      a few other places assume that the frame pointer is a single hard\n@@ -5323,9 +5150,7 @@ avr_hard_regno_mode_ok (regno, mode)\n    to check for the lower half of I/O space (for cbi/sbi/sbic/sbis).  */\n \n int\n-avr_io_address_p (x, size)\n-     rtx x;\n-     int size;\n+avr_io_address_p (rtx x, int size)\n {\n   return (optimize > 0 && GET_CODE (x) == CONST_INT\n \t  && INTVAL (x) >= 0x20 && INTVAL (x) <= 0x60 - size);\n@@ -5334,8 +5159,7 @@ avr_io_address_p (x, size)\n /* Returns nonzero (bit number + 1) if X, or -X, is a constant power of 2.  */\n \n int\n-const_int_pow2_p (x)\n-     rtx x;\n+const_int_pow2_p (rtx x)\n {\n   if (GET_CODE (x) == CONST_INT)\n     {\n@@ -5347,10 +5171,7 @@ const_int_pow2_p (x)\n }\n \n const char *\n-output_reload_inhi (insn, operands, len)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx *operands;\n-     int *len;\n+output_reload_inhi (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n {\n   int tmp;\n   if (!len)\n@@ -5390,10 +5211,7 @@ output_reload_inhi (insn, operands, len)\n \n \n const char *\n-output_reload_insisf (insn, operands, len)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx *operands;\n-     int *len;\n+output_reload_insisf (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n {\n   rtx src = operands[1];\n   int cnst = (GET_CODE (src) == CONST_INT);\n@@ -5443,9 +5261,7 @@ output_reload_insisf (insn, operands, len)\n }\n \n void\n-avr_output_bld (operands, bit_nr)\n-     rtx operands[];\n-     int bit_nr;\n+avr_output_bld (rtx operands[], int bit_nr)\n {\n   static char s[] = \"bld %A0,0\";\n \n@@ -5455,9 +5271,7 @@ avr_output_bld (operands, bit_nr)\n }\n \n void\n-avr_output_addr_vec_elt (stream, value)\n-     FILE *stream;\n-     int value;\n+avr_output_addr_vec_elt (FILE *stream, int value)\n {\n   if (AVR_MEGA)\n     fprintf (stream, \"\\t.word pm(.L%d)\\n\", value);\n@@ -5471,8 +5285,7 @@ avr_output_addr_vec_elt (stream, value)\n    registers (for a define_peephole2) in the current function.  */\n \n int\n-avr_peep2_scratch_safe (scratch)\n-     rtx scratch;\n+avr_peep2_scratch_safe (rtx scratch)\n {\n   if ((interrupt_function_p (current_function_decl)\n        || signal_function_p (current_function_decl))\n@@ -5500,9 +5313,7 @@ avr_peep2_scratch_safe (scratch)\n    Operand 3: label to jump to if the test is true.  */\n \n const char *\n-avr_out_sbxx_branch (insn, operands)\n-     rtx insn;\n-     rtx operands[];\n+avr_out_sbxx_branch (rtx insn, rtx operands[])\n {\n   enum rtx_code comp = GET_CODE (operands[0]);\n   int long_jump = (get_attr_length (insn) >= 4);\n@@ -5565,18 +5376,14 @@ avr_out_sbxx_branch (insn, operands)\n }\n \n static void\n-avr_asm_out_ctor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+avr_asm_out_ctor (rtx symbol, int priority)\n {\n   fputs (\"\\t.global __do_global_ctors\\n\", asm_out_file);\n   default_ctor_section_asm_out_constructor (symbol, priority);\n }\n \n static void\n-avr_asm_out_dtor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+avr_asm_out_dtor (rtx symbol, int priority)\n {\n   fputs (\"\\t.global __do_global_dtors\\n\", asm_out_file);\n   default_dtor_section_asm_out_destructor (symbol, priority);"}]}