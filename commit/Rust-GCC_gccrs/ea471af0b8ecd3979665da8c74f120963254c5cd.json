{"sha": "ea471af0b8ecd3979665da8c74f120963254c5cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE0NzFhZjBiOGVjZDM5Nzk2NjVkYThjNzRmMTIwOTYzMjU0YzVjZA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2008-07-19T11:14:13Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2008-07-19T11:14:13Z"}, "message": "re PR target/36780 (Wrong reload generated for subreg address on SH)\n\n\tPR target/36780\n\tPR target/36827\n\t* reload.c (find_reloads_subreg_address): Only reload address if\n\treloaded == 0, not for reloaded != 1.\n\n\tRevert:\n\t2008-07-16  Joseph Myers  <joseph@codesourcery.com>\n\t* config/m32c/m32c.c (BIG_FB_ADJ): Move definition earlier.\n\t(m32c_legitimate_address_p): Handle \"++rii\" addresses created by\n\tm32c_legitimize_reload_address.\n\n\t2008-07-15  Kaz Kojima  <kkojima@gcc.gnu.org>\n\t* config/sh/sh.h (GO_IF_LEGITIMATE_ADDRESS): Allow\n\t(plus (plus (reg) (const_int)) (const_int)) when reload_in_progress.\n\nFrom-SVN: r137976", "tree": {"sha": "3ea13d8ae72f15d919974c9c7f445f4112ff2f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ea13d8ae72f15d919974c9c7f445f4112ff2f24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea471af0b8ecd3979665da8c74f120963254c5cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea471af0b8ecd3979665da8c74f120963254c5cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea471af0b8ecd3979665da8c74f120963254c5cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea471af0b8ecd3979665da8c74f120963254c5cd/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa8884d805ef576b616dbaf062eb882b80efb467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8884d805ef576b616dbaf062eb882b80efb467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8884d805ef576b616dbaf062eb882b80efb467"}], "stats": {"total": 47, "additions": 20, "deletions": 27}, "files": [{"sha": "4464f1190e78665d7049b74bf99661f3d8232211", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea471af0b8ecd3979665da8c74f120963254c5cd", "patch": "@@ -1,3 +1,20 @@\n+2008-07-19  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR target/36780\n+\tPR target/36827\n+\t* reload.c (find_reloads_subreg_address): Only reload address if\n+\treloaded == 0, not for reloaded != 1.\n+\n+\tRevert:\n+\t2008-07-16  Joseph Myers  <joseph@codesourcery.com>\n+\t* config/m32c/m32c.c (BIG_FB_ADJ): Move definition earlier.\n+\t(m32c_legitimate_address_p): Handle \"++rii\" addresses created by\n+\tm32c_legitimize_reload_address.\n+\n+\t2008-07-15  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\t* config/sh/sh.h (GO_IF_LEGITIMATE_ADDRESS): Allow\n+\t(plus (plus (reg) (const_int)) (const_int)) when reload_in_progress.\n+\n 2008-07-19  Olivier Hainque  <hainque@adacore.com>\n \n \t* dwarf2out.c (add_subscript_info): New explicit COLLAPSE_P"}, {"sha": "b0733dd83645c79679590bc14440cf1a2184eea2", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=ea471af0b8ecd3979665da8c74f120963254c5cd", "patch": "@@ -1778,8 +1778,6 @@ m32c_init_libfuncs (void)\n \n /* Addressing Modes */\n \n-#define BIG_FB_ADJ 0\n-\n /* Used by GO_IF_LEGITIMATE_ADDRESS.  The r8c/m32c family supports a\n    wide range of non-orthogonal addressing modes, including the\n    ability to double-indirect on *some* of them.  Not all insns\n@@ -1897,17 +1895,6 @@ m32c_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n \t  return 0;\n \t}\n     }\n-  if (RTX_IS (\"++rii\"))\n-    {\n-      rtx reg = patternr[2];\n-      HOST_WIDE_INT offs = INTVAL (patternr[3]);\n-\n-      /* Avoid reloads for addresses generated by\n-\t m32c_legitimize_reload_address being generated by\n-\t find_reloads_subreg_address.  */\n-      if (REGNO (reg) == FB_REGNO && offs == -BIG_FB_ADJ)\n-\treturn 1;\n-    }\n   return 0;\n }\n \n@@ -1955,6 +1942,8 @@ m32c_reg_ok_for_base_p (rtx x, int strict)\n    frame, so the third case seems best.  Note that we subtract the\n    zero, but detect that in the addhi3 pattern.  */\n \n+#define BIG_FB_ADJ 0\n+\n /* Implements LEGITIMIZE_ADDRESS.  The only address we really have to\n    worry about is frame base offsets, as $fb has a limited\n    displacement range.  We deal with this by attempting to reload $fb"}, {"sha": "5204847abc5d2e90fada3c23252e5aefa91d911a", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ea471af0b8ecd3979665da8c74f120963254c5cd", "patch": "@@ -2501,19 +2501,6 @@ struct sh_args {\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  /* FIXME: This is a temporary hack which should be removed.\t\t\\\n-     When reload in progress, find_reloads_subreg_address tries to\t\\\n-     make a new reload for some types of address.  Unfortunately it\t\\\n-     generates wrong code on SH.  See PR36780.  The following is to\t\\\n-     avoid this issue.  */\t\t\t\t\t\t\\\n-  if (!TARGET_SHMEDIA && reload_in_progress\t\t\t\t\\\n-      && GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n-      && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\t\\\n-      && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT\t\t\\\n-      && BASE_REGISTER_RTX_P (XEXP (XEXP ((X), 0), 0))\t\t\t\\\n-      && GET_CODE (XEXP ((X), 1)) == CONST_INT)\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n }\n \f\n /* Try machine-dependent ways of modifying an illegitimate address"}, {"sha": "a6ea4ff4e5a2c73c47b0f7e800ffea15cb113853", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea471af0b8ecd3979665da8c74f120963254c5cd/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ea471af0b8ecd3979665da8c74f120963254c5cd", "patch": "@@ -6103,7 +6103,7 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t doesn't find any, then we may have just converted a\n \t\t valid address into an invalid one.  Check for that\n \t\t here.  */\n-\t      if (reloaded != 1\n+\t      if (reloaded == 0\n \t\t  && !strict_memory_address_p (GET_MODE (tem),\n \t\t\t\t\t       XEXP (tem, 0)))\n \t\tpush_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,"}]}