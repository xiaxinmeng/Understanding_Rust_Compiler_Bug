{"sha": "26033479fb7d724061af07716f0077934032bbf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYwMzM0NzlmYjdkNzI0MDYxYWYwNzcxNmYwMDc3OTM0MDMyYmJmOQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-10-31T14:26:57Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-10-31T14:26:57Z"}, "message": "re PR fortran/33162 (INTRINSIC functions as ACTUAL argument)\n\n2007-10-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/33162\n\t* interface.c (compare_intr_interfaces): New function to check intrinsic\n\tfunction arguments against formal arguments. (compare_interfaces): Fix\n\tlogic in comparison of function and subroutine attributes.\n\t(compare_parameter): Use new function for intrinsic as argument.\n\t* resolve.c (resolve_actual_arglist): Allow an intrinsic without\n\tfunction attribute to be checked further.  Set function attribute if\n\tintrinsic symbol is found, return FAILURE if not.\n\nFrom-SVN: r129798", "tree": {"sha": "225d18b5b7c428001a8dd82bb1f810f3a517d524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/225d18b5b7c428001a8dd82bb1f810f3a517d524"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26033479fb7d724061af07716f0077934032bbf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26033479fb7d724061af07716f0077934032bbf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26033479fb7d724061af07716f0077934032bbf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26033479fb7d724061af07716f0077934032bbf9/comments", "author": null, "committer": null, "parents": [{"sha": "2c26cbfd237121530e5f3b74d48de1688e3b31e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c26cbfd237121530e5f3b74d48de1688e3b31e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c26cbfd237121530e5f3b74d48de1688e3b31e6"}], "stats": {"total": 74, "additions": 70, "deletions": 4}, "files": [{"sha": "96e7a73c8843c74e6c2655732ec50866ae4749af", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26033479fb7d724061af07716f0077934032bbf9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26033479fb7d724061af07716f0077934032bbf9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=26033479fb7d724061af07716f0077934032bbf9", "patch": "@@ -1,3 +1,14 @@\n+2007-10-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/33162\n+\t* interface.c (compare_intr_interfaces): New function to check intrinsic\n+\tfunction arguments against formal arguments. (compare_interfaces): Fix\n+\tlogic in comparison of function and subroutine attributes.\n+\t(compare_parameter): Use new function for intrinsic as argument.\n+\t* resolve.c (resolve_actual_arglist): Allow an intrinsic without\n+\tfunction attribute to be checked further.  Set function attribute if\n+\tintrinsic symbol is found, return FAILURE if not.\n+\n 2007-10-31  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33897"}, {"sha": "39f4e9283a2b639542328bf8ed8b415167cc96ac", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26033479fb7d724061af07716f0077934032bbf9/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26033479fb7d724061af07716f0077934032bbf9/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=26033479fb7d724061af07716f0077934032bbf9", "patch": "@@ -468,6 +468,7 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n \n \n static int compare_interfaces (gfc_symbol *, gfc_symbol *, int);\n+static int compare_intr_interfaces (gfc_symbol *, gfc_symbol *);\n \n /* Given two symbols that are formal arguments, compare their types\n    and rank and their formal interfaces if they are both dummy\n@@ -942,7 +943,7 @@ compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n   gfc_formal_arglist *f1, *f2;\n \n   if (s1->attr.function != s2->attr.function\n-      && s1->attr.subroutine != s2->attr.subroutine)\n+      || s1->attr.subroutine != s2->attr.subroutine)\n     return 0;\t\t/* Disagreement between function/subroutine.  */\n \n   f1 = s1->formal;\n@@ -973,6 +974,56 @@ compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n }\n \n \n+static int\n+compare_intr_interfaces (gfc_symbol *s1, gfc_symbol *s2)\n+{\n+  static gfc_formal_arglist *f, *f1;\n+  static gfc_intrinsic_arg *fi, *f2;\n+  gfc_intrinsic_sym *isym;\n+\n+  if (s1->attr.function != s2->attr.function\n+      || s1->attr.subroutine != s2->attr.subroutine)\n+    return 0;\t\t/* Disagreement between function/subroutine.  */\n+\n+  isym = gfc_find_function (s2->name);\n+  \n+  /* This should already have been checked in\n+     resolve.c (resolve_actual_arglist).  */\n+  gcc_assert (isym);\n+\n+  f1 = s1->formal;\n+  f2 = isym->formal;\n+\n+  /* Special case.  */\n+  if (f1 == NULL && f2 == NULL)\n+    return 1;\n+  \n+  /* First scan through the formal argument list and check the intrinsic.  */\n+  fi = f2;\n+  for (f = f1; f; f = f->next)\n+    {\n+      if (fi == NULL)\n+\treturn 0;\n+      if ((fi->ts.type != f->sym->ts.type) || (fi->ts.kind != f->sym->ts.kind))\n+\treturn 0;\n+      fi = fi->next;\n+    }\n+\n+  /* Now scan through the intrinsic argument list and check the formal.  */\n+  f = f1;\n+  for (fi = f2; fi; fi = fi->next)\n+    {\n+      if (f == NULL)\n+\treturn 0;\n+      if ((fi->ts.type != f->sym->ts.type) || (fi->ts.kind != f->sym->ts.kind))\n+\treturn 0;\n+      f = f->next;\n+    }\n+\n+  return 1;\n+}\n+\n+\n /* Given a pointer to an interface pointer, remove duplicate\n    interfaces and make sure that all symbols are either functions or\n    subroutines.  Returns nonzero if something goes wrong.  */\n@@ -1323,7 +1374,10 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  || actual->symtree->n.sym->attr.external)\n \treturn 1;\t\t/* Assume match.  */\n \n-      return compare_interfaces (formal, actual->symtree->n.sym, 0);\n+      if (actual->symtree->n.sym->attr.intrinsic)\n+\treturn compare_intr_interfaces (formal, actual->symtree->n.sym);\n+      else\n+\treturn compare_interfaces (formal, actual->symtree->n.sym, 0);\n     }\n \n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)"}, {"sha": "3542b1e9c5543f1c9586a73c5120418cfbc899cc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26033479fb7d724061af07716f0077934032bbf9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26033479fb7d724061af07716f0077934032bbf9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=26033479fb7d724061af07716f0077934032bbf9", "patch": "@@ -1071,8 +1071,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t    goto got_variable;\n \n \t  /* If all else fails, see if we have a specific intrinsic.  */\n-\t  if (sym->attr.function\n-\t      && sym->ts.type == BT_UNKNOWN && sym->attr.intrinsic)\n+\t  if (sym->ts.type == BT_UNKNOWN && sym->attr.intrinsic)\n \t    {\n \t      gfc_intrinsic_sym *isym;\n \t      isym = gfc_find_function (sym->name);\n@@ -1081,8 +1080,10 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t\t  gfc_error (\"Unable to find a specific INTRINSIC procedure \"\n \t\t\t     \"for the reference '%s' at %L\", sym->name,\n \t\t\t     &e->where);\n+\t\t  return FAILURE;\n \t\t}\n \t      sym->ts = isym->ts;\n+\t      sym->attr.function = 1;\n \t    }\n \t  goto argument_list;\n \t}"}]}