{"sha": "145f748f0ca4c9716e242ec03f134b7140f0e2c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ1Zjc0OGYwY2E0Yzk3MTZlMjQyZWMwM2YxMzRiNzE0MGYwZTJjMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2019-06-20T21:07:38Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-06-20T21:07:38Z"}, "message": "alpha.md (@unaligned_store<mode>): Rename from unaligned_store<mode>.\n\n\t* config/alpha/alpha.md (@unaligned_store<mode>):\n\tRename from unaligned_store<mode>.\n\t(@reload_in<mode>_aligned): Rename from reload_in<mode>_aligned.\n\t* config/alpha/sync.md (@load_locked_<mode>): Rename\n\tfrom load_locked_<mode>.\n\t(@store_conditional_<mode>): Rename from store_conditional_<mode>.\n\t(@atomic_compare_and_swap<mode>_1): Rename\n\tfrom atomic_compare_and_swap<mode>_1.\n\t(@atomic_exchange<mode>_1): Rename from atomic_exchange<mode>_1.\n\t* config/alpha/alpha.c (alpha_expand_mov_nobwx):\n\tUse gen_reload_in_aligned and gen_unaligned_store.\n\t(emit_load_locked): Remove.\n\t(emit_store_conditional): Ditto.\n\t(alpha_split_atomic_op): Use gen_load_locked and gen_store_conditional.\n\t(alpha_split_compare_and_swap): Ditto.\n\t(alpha_expand_compare_and_swap_12): Use gen_atomic_compare_and_swap_1.\n\t(alpha_split_compare_and_swap_12): Use gen_load_locked\n\tand gen_store_conditional.\n\t(alpha_split_atomic_exchange): Ditto.\n\t(alpha_expand_atomic_exchange_12): Use gen_atomic_exchange_1.\n\t(alpha_split_atomic_exchange_12): Use gen_load_locked\n\tand gen_store_conditional.\n\nFrom-SVN: r272523", "tree": {"sha": "7a9b1b183589a4c475dd68140c4b27483719459e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a9b1b183589a4c475dd68140c4b27483719459e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/145f748f0ca4c9716e242ec03f134b7140f0e2c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/145f748f0ca4c9716e242ec03f134b7140f0e2c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/145f748f0ca4c9716e242ec03f134b7140f0e2c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/145f748f0ca4c9716e242ec03f134b7140f0e2c3/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bd48717072151f5b77e4e3158a51ffc9ff8f106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd48717072151f5b77e4e3158a51ffc9ff8f106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd48717072151f5b77e4e3158a51ffc9ff8f106"}], "stats": {"total": 114, "additions": 49, "deletions": 65}, "files": [{"sha": "1724c49706111102d63d4c738891c6f58e0db97f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=145f748f0ca4c9716e242ec03f134b7140f0e2c3", "patch": "@@ -1,3 +1,28 @@\n+2019-06-20  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/alpha/alpha.md (@unaligned_store<mode>):\n+\tRename from unaligned_store<mode>.\n+\t(@reload_in<mode>_aligned): Rename from reload_in<mode>_aligned.\n+\t* config/alpha/sync.md (@load_locked_<mode>): Rename\n+\tfrom load_locked_<mode>.\n+\t(@store_conditional_<mode>): Rename from store_conditional_<mode>.\n+\t(@atomic_compare_and_swap<mode>_1): Rename\n+\tfrom atomic_compare_and_swap<mode>_1.\n+\t(@atomic_exchange<mode>_1): Rename from atomic_exchange<mode>_1.\n+\t* config/alpha/alpha.c (alpha_expand_mov_nobwx):\n+\tUse gen_reload_in_aligned and gen_unaligned_store.\n+\t(emit_load_locked): Remove.\n+\t(emit_store_conditional): Ditto.\n+\t(alpha_split_atomic_op): Use gen_load_locked and gen_store_conditional.\n+\t(alpha_split_compare_and_swap): Ditto.\n+\t(alpha_expand_compare_and_swap_12): Use gen_atomic_compare_and_swap_1.\n+\t(alpha_split_compare_and_swap_12): Use gen_load_locked\n+\tand gen_store_conditional.\n+\t(alpha_split_atomic_exchange): Ditto.\n+\t(alpha_expand_atomic_exchange_12): Use gen_atomic_exchange_1.\n+\t(alpha_split_atomic_exchange_12): Use gen_load_locked\n+\tand gen_store_conditional.\n+\n 2019-06-20  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/aarch64/aarch64-errata.h: New file."}, {"sha": "10656bea58c068b3dd195bdf269ea7ec19662b4d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 18, "deletions": 59, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=145f748f0ca4c9716e242ec03f134b7140f0e2c3", "patch": "@@ -2292,10 +2292,7 @@ alpha_expand_mov_nobwx (machine_mode mode, rtx *operands)\n \t{\n \t  if (reload_in_progress)\n \t    {\n-\t      if (mode == QImode)\n-\t\tseq = gen_reload_inqi_aligned (operands[0], operands[1]);\n-\t      else\n-\t\tseq = gen_reload_inhi_aligned (operands[0], operands[1]);\n+\t      seq = gen_reload_in_aligned (mode, operands[0], operands[1]);\n \t      emit_insn (seq);\n \t    }\n \t  else\n@@ -2378,10 +2375,8 @@ alpha_expand_mov_nobwx (machine_mode mode, rtx *operands)\n \t  rtx temp3 = gen_reg_rtx (DImode);\n \t  rtx ua = get_unaligned_address (operands[0]);\n \n-\t  if (mode == QImode)\n-\t    seq = gen_unaligned_storeqi (ua, operands[1], temp1, temp2, temp3);\n-\t  else\n-\t    seq = gen_unaligned_storehi (ua, operands[1], temp1, temp2, temp3);\n+\t  seq = gen_unaligned_store\n+\t    (mode, ua, operands[1], temp1, temp2, temp3);\n \n \t  alpha_set_memflags (seq, operands[0]);\n \t  emit_insn (seq);\n@@ -4349,34 +4344,6 @@ emit_unlikely_jump (rtx cond, rtx label)\n   add_reg_br_prob_note (insn, profile_probability::very_unlikely ());\n }\n \n-/* A subroutine of the atomic operation splitters.  Emit a load-locked\n-   instruction in MODE.  */\n-\n-static void\n-emit_load_locked (machine_mode mode, rtx reg, rtx mem)\n-{\n-  rtx (*fn) (rtx, rtx) = NULL;\n-  if (mode == SImode)\n-    fn = gen_load_locked_si;\n-  else if (mode == DImode)\n-    fn = gen_load_locked_di;\n-  emit_insn (fn (reg, mem));\n-}\n-\n-/* A subroutine of the atomic operation splitters.  Emit a store-conditional\n-   instruction in MODE.  */\n-\n-static void\n-emit_store_conditional (machine_mode mode, rtx res, rtx mem, rtx val)\n-{\n-  rtx (*fn) (rtx, rtx, rtx) = NULL;\n-  if (mode == SImode)\n-    fn = gen_store_conditional_si;\n-  else if (mode == DImode)\n-    fn = gen_store_conditional_di;\n-  emit_insn (fn (res, mem, val));\n-}\n-\n /* Subroutines of the atomic operation splitters.  Emit barriers\n    as needed for the memory MODEL.  */\n \n@@ -4448,7 +4415,7 @@ alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val, rtx before,\n \n   if (before == NULL)\n     before = scratch;\n-  emit_load_locked (mode, before, mem);\n+  emit_insn (gen_load_locked (mode, before, mem));\n \n   if (code == NOT)\n     {\n@@ -4463,7 +4430,7 @@ alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val, rtx before,\n     emit_insn (gen_rtx_SET (after, copy_rtx (x)));\n   emit_insn (gen_rtx_SET (scratch, x));\n \n-  emit_store_conditional (mode, cond, mem, scratch);\n+  emit_insn (gen_store_conditional (mode, cond, mem, scratch));\n \n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n   emit_unlikely_jump (x, label);\n@@ -4502,7 +4469,7 @@ alpha_split_compare_and_swap (rtx operands[])\n     }\n   label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n \n-  emit_load_locked (mode, retval, mem);\n+  emit_insn (gen_load_locked (mode, retval, mem));\n \n   x = gen_lowpart (DImode, retval);\n   if (oldval == const0_rtx)\n@@ -4519,7 +4486,8 @@ alpha_split_compare_and_swap (rtx operands[])\n   emit_unlikely_jump (x, label2);\n \n   emit_move_insn (cond, newval);\n-  emit_store_conditional (mode, cond, mem, gen_lowpart (mode, cond));\n+  emit_insn (gen_store_conditional\n+\t     (mode, cond, mem, gen_lowpart (mode, cond)));\n \n   if (!is_weak)\n     {\n@@ -4542,7 +4510,6 @@ alpha_expand_compare_and_swap_12 (rtx operands[])\n   rtx cond, dst, mem, oldval, newval, is_weak, mod_s, mod_f;\n   machine_mode mode;\n   rtx addr, align, wdst;\n-  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n \n   cond = operands[0];\n   dst = operands[1];\n@@ -4567,12 +4534,9 @@ alpha_expand_compare_and_swap_12 (rtx operands[])\n     newval = emit_insxl (mode, newval, addr);\n \n   wdst = gen_reg_rtx (DImode);\n-  if (mode == QImode)\n-    gen = gen_atomic_compare_and_swapqi_1;\n-  else\n-    gen = gen_atomic_compare_and_swaphi_1;\n-  emit_insn (gen (cond, wdst, mem, oldval, newval, align,\n-\t\t  is_weak, mod_s, mod_f));\n+  emit_insn (gen_atomic_compare_and_swap_1\n+\t     (mode, cond, wdst, mem, oldval, newval, align,\n+\t      is_weak, mod_s, mod_f));\n \n   emit_move_insn (dst, gen_lowpart (mode, wdst));\n }\n@@ -4614,7 +4578,7 @@ alpha_split_compare_and_swap_12 (rtx operands[])\n     }\n   label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n \n-  emit_load_locked (DImode, scratch, mem);\n+  emit_insn (gen_load_locked (DImode, scratch, mem));\n   \n   width = GEN_INT (GET_MODE_BITSIZE (mode));\n   mask = GEN_INT (mode == QImode ? 0xff : 0xffff);\n@@ -4638,7 +4602,7 @@ alpha_split_compare_and_swap_12 (rtx operands[])\n   if (newval != const0_rtx)\n     emit_insn (gen_iordi3 (cond, cond, newval));\n \n-  emit_store_conditional (DImode, cond, mem, cond);\n+  emit_insn (gen_store_conditional (DImode, cond, mem, cond));\n \n   if (!is_weak)\n     {\n@@ -4678,9 +4642,9 @@ alpha_split_atomic_exchange (rtx operands[])\n   label = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n   emit_label (XEXP (label, 0));\n \n-  emit_load_locked (mode, retval, mem);\n+  emit_insn (gen_load_locked (mode, retval, mem));\n   emit_move_insn (scratch, val);\n-  emit_store_conditional (mode, cond, mem, scratch);\n+  emit_insn (gen_store_conditional (mode, cond, mem, scratch));\n \n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n   emit_unlikely_jump (x, label);\n@@ -4694,7 +4658,6 @@ alpha_expand_atomic_exchange_12 (rtx operands[])\n   rtx dst, mem, val, model;\n   machine_mode mode;\n   rtx addr, align, wdst;\n-  rtx (*gen) (rtx, rtx, rtx, rtx, rtx);\n \n   dst = operands[0];\n   mem = operands[1];\n@@ -4714,11 +4677,7 @@ alpha_expand_atomic_exchange_12 (rtx operands[])\n     val = emit_insxl (mode, val, addr);\n \n   wdst = gen_reg_rtx (DImode);\n-  if (mode == QImode)\n-    gen = gen_atomic_exchangeqi_1;\n-  else\n-    gen = gen_atomic_exchangehi_1;\n-  emit_insn (gen (wdst, mem, val, align, model));\n+  emit_insn (gen_atomic_exchange_1 (mode, wdst, mem, val, align, model));\n \n   emit_move_insn (dst, gen_lowpart (mode, wdst));\n }\n@@ -4750,7 +4709,7 @@ alpha_split_atomic_exchange_12 (rtx operands[])\n   label = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n   emit_label (XEXP (label, 0));\n \n-  emit_load_locked (DImode, scratch, mem);\n+  emit_insn (gen_load_locked (DImode, scratch, mem));\n   \n   width = GEN_INT (GET_MODE_BITSIZE (mode));\n   mask = GEN_INT (mode == QImode ? 0xff : 0xffff);\n@@ -4759,7 +4718,7 @@ alpha_split_atomic_exchange_12 (rtx operands[])\n   if (val != const0_rtx)\n     emit_insn (gen_iordi3 (scratch, scratch, val));\n \n-  emit_store_conditional (DImode, scratch, mem, scratch);\n+  emit_insn (gen_store_conditional (DImode, scratch, mem, scratch));\n \n   x = gen_rtx_EQ (DImode, scratch, const0_rtx);\n   emit_unlikely_jump (x, label);"}, {"sha": "d15295d06f3bb12fc1c6c6a5ba2b3e2af48e9734", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=145f748f0ca4c9716e242ec03f134b7140f0e2c3", "patch": "@@ -4232,7 +4232,7 @@\n ;; be the same temporary, if desired.  If the address is in a register,\n ;; operand 2 can be that register.\n \n-(define_expand \"unaligned_store<mode>\"\n+(define_expand \"@unaligned_store<mode>\"\n   [(set (match_operand:DI 3 \"register_operand\")\n \t(mem:DI (and:DI (match_operand:DI 0 \"address_operand\")\n \t\t\t(const_int -8))))\n@@ -4417,7 +4417,7 @@\n ;; always get a proper address for a stack slot during reload_foo\n ;; expansion, so we must delay our address manipulations until after.\n \n-(define_insn_and_split \"reload_in<mode>_aligned\"\n+(define_insn_and_split \"@reload_in<mode>_aligned\"\n   [(set (match_operand:I12MODE 0 \"register_operand\" \"=r\")\n         (match_operand:I12MODE 1 \"memory_operand\" \"m\"))]\n   \"!TARGET_BWX && (reload_in_progress || reload_completed)\""}, {"sha": "ef08854c8396c12e23f300ad17795f52683df25c", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145f748f0ca4c9716e242ec03f134b7140f0e2c3/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=145f748f0ca4c9716e242ec03f134b7140f0e2c3", "patch": "@@ -43,7 +43,7 @@\n   \"mb\"\n   [(set_attr \"type\" \"mb\")])\n \n-(define_insn \"load_locked_<mode>\"\n+(define_insn \"@load_locked_<mode>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n \t(unspec_volatile:I48MODE\n \t  [(match_operand:I48MODE 1 \"memory_operand\" \"m\")]\n@@ -52,7 +52,7 @@\n   \"ld<modesuffix>_l %0,%1\"\n   [(set_attr \"type\" \"ld_l\")])\n \n-(define_insn \"store_conditional_<mode>\"\n+(define_insn \"@store_conditional_<mode>\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (unspec_volatile:DI [(const_int 0)] UNSPECV_SC))\n    (set (match_operand:I48MODE 1 \"memory_operand\" \"=m\")\n@@ -132,7 +132,7 @@\n   DONE;\n })\n \n-(define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n+(define_insn_and_split \"@atomic_compare_and_swap<mode>_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\t\t;; bool out\n \t(unspec_volatile:DI [(const_int 0)] UNSPECV_CMPXCHG))\n    (set (match_operand:DI 1 \"register_operand\" \"=&r\")\t\t;; val out\n@@ -189,7 +189,7 @@\n   DONE;\n })\n \n-(define_insn_and_split \"atomic_exchange<mode>_1\"\n+(define_insn_and_split \"@atomic_exchange<mode>_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\t\t;; output\n \t(zero_extend:DI\n \t  (match_operand:I12MODE 1 \"mem_noofs_operand\" \"+w\")))\t;; memory"}]}