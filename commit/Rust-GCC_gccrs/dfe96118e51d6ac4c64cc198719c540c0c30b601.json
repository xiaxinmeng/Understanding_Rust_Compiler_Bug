{"sha": "dfe96118e51d6ac4c64cc198719c540c0c30b601", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZlOTYxMThlNTFkNmFjNGM2NGNjMTk4NzE5YzU0MGMwYzMwYjYwMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-11-16T13:04:01Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-11-16T13:04:01Z"}, "message": "reload1.c (reload_reg_free_before_p): Delete.\n\n\t* reload1.c (reload_reg_free_before_p): Delete.\n\tChanged all callers to use reload_reg_free_for_value_p instead.\n\t(reload_reg_free_for_value_p): Handle more reload types.\n\tA RELOAD_FOR_INPUT doesn't conflict with its\n\tRELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS.\n\tAdd special case for OUT == const0_rtx.\n\tAdded ignore_address_reloads argument.  Changed all callers.\n\nFrom-SVN: r23675", "tree": {"sha": "59d55b1818ca417921cf07df3ea6477a26cfb47c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59d55b1818ca417921cf07df3ea6477a26cfb47c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfe96118e51d6ac4c64cc198719c540c0c30b601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe96118e51d6ac4c64cc198719c540c0c30b601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe96118e51d6ac4c64cc198719c540c0c30b601", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe96118e51d6ac4c64cc198719c540c0c30b601/comments", "author": null, "committer": null, "parents": [{"sha": "fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbf1c34bfa83a4b08f9ee8651250cd989d0bd0ba"}], "stats": {"total": 368, "additions": 122, "deletions": 246}, "files": [{"sha": "af1367a8bbd51e1a7450b20124b50acca0627ce2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe96118e51d6ac4c64cc198719c540c0c30b601/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe96118e51d6ac4c64cc198719c540c0c30b601/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfe96118e51d6ac4c64cc198719c540c0c30b601", "patch": "@@ -1,3 +1,13 @@\n+Mon Nov 16 21:02:52 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload1.c (reload_reg_free_before_p): Delete.\n+\tChanged all callers to use reload_reg_free_for_value_p instead.\n+\t(reload_reg_free_for_value_p): Handle more reload types.\n+\tA RELOAD_FOR_INPUT doesn't conflict with its\n+\tRELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS.\n+\tAdd special case for OUT == const0_rtx.\n+\tAdded ignore_address_reloads argument.  Changed all callers.\n+\n Mon Nov 16 02:22:29 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* toplev.c (compile_file): Don't pedwarn about undefined static"}, {"sha": "f21b6223fb4bbd4e3d5a8525bcab207c82d2b59e", "filename": "gcc/reload1.c", "status": "modified", "additions": 112, "deletions": 246, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfe96118e51d6ac4c64cc198719c540c0c30b601/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfe96118e51d6ac4c64cc198719c540c0c30b601/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=dfe96118e51d6ac4c64cc198719c540c0c30b601", "patch": "@@ -406,8 +406,7 @@ static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n-static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type, int));\n-static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx, rtx, int));\n+static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx, rtx, int, int));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int,\n \t\t\t\t\t       int));\n@@ -4817,175 +4816,6 @@ reload_reg_free_p (regno, opnum, type)\n   abort ();\n }\n \n-/* Return 1 if the value in reload reg REGNO, as used by a reload\n-   needed for the part of the insn specified by OPNUM and TYPE,\n-   is not in use for a reload in any prior part of the insn.\n-\n-   We can assume that the reload reg was already tested for availability\n-   at the time it is needed, and we should not check this again,\n-   in case the reg has already been marked in use.\n-\n-   However, if EQUIV is set, we are checking the availability of a register\n-   holding an equivalence to the value to be loaded into the reload register,\n-   not the availability of the reload register itself.\n-\n-   This is still less stringent than what reload_reg_free_p checks; for\n-   example, compare the checks for RELOAD_OTHER.  */\n-\n-static int\n-reload_reg_free_before_p (regno, opnum, type, equiv)\n-     int regno;\n-     int opnum;\n-     enum reload_type type;\n-     int equiv;\n-{\n-  int i;\n-\n-  /* The code to handle EQUIV below is wrong.\n-\n-     If we wnat to know if a value in a particular reload register is available\n-     at a particular point in time during reloading, we must check *all*\n-     prior reloads to see if they clobber the value.\n-\n-     Note this is significantly different from determining when a register is\n-     free for usage in a reload!\n-\n-     This change is temporary.  It will go away.  */\n-  if (equiv)\n-    return 0;\n-\n-  switch (type)\n-    {\n-    case RELOAD_FOR_OTHER_ADDRESS:\n-      /* These always come first.  */\n-      if (equiv && TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno))\n-\treturn 0;\n-      return 1;\n-\n-    case RELOAD_OTHER:\n-      if (equiv && TEST_HARD_REG_BIT (reload_reg_used, regno))\n-\treturn 0;\n-      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n-\n-      /* If this use is for part of the insn,\n-\t check the reg is not in use for any prior part.  It is tempting\n-\t to try to do this by falling through from objecs that occur\n-\t later in the insn to ones that occur earlier, but that will not\n-\t correctly take into account the fact that here we MUST ignore\n-\t things that would prevent the register from being allocated in\n-\t the first place, since we know that it was allocated.  */\n-\n-    case RELOAD_FOR_OUTPUT_ADDRESS:\n-      if (equiv\n-\t  && TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], regno))\n-\treturn 0;\n-      /* Earlier reloads include RELOAD_FOR_OUTADDR_ADDRESS reloads.  */\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], regno))\n-\treturn 0;\n-      /* ... fall through ...  */\n-    case RELOAD_FOR_OUTADDR_ADDRESS:\n-      if (equiv\n-\t  && (TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], regno)\n-\t      || TEST_HARD_REG_BIT (reload_reg_used, regno)))\n-\treturn 0;\n-      /* Earlier reloads are for earlier outputs or their addresses,\n-\t any RELOAD_FOR_INSN reloads, any inputs or their addresses, or any\n-\t RELOAD_FOR_OTHER_ADDRESS reloads (we know it can't conflict with\n-\t RELOAD_OTHER)..  */\n-      for (i = 0; i < opnum; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno))\n-\t  return 0;\n-\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno))\n-\treturn 0;\n-\n-      for (i = 0; i < reload_n_operands; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n-\t  return 0;\n-\n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n-\t\t\t\t   \n-    case RELOAD_FOR_OUTPUT:\n-    case RELOAD_FOR_INSN:\n-      /* There is no reason to call this function for output reloads, thus\n-\t anything we'd put here wouldn't be tested.  So just abort.  */\n-       abort ();\n-\n-    case RELOAD_FOR_OPERAND_ADDRESS:\n-      if (equiv && TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno))\n-\treturn 0;\n-\n-      /* Earlier reloads include RELOAD_FOR_OPADDR_ADDR reloads.  */\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno))\n-\treturn 0;\n-\n-      /* ... fall through ...  */\n-\n-    case RELOAD_FOR_OPADDR_ADDR:\n-      if (equiv)\n-\t{\n-\t  if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno)\n-\t      || TEST_HARD_REG_BIT (reload_reg_used, regno))\n-\t    return 0;\n-\t  for (i = 0; i < reload_n_operands; i++)\n-\t    if (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n-\t      return 0;\n-\t}\n-      /* These can't conflict with inputs, or each other, so all we have to\n-\t test is input addresses and the addresses of OTHER items.  */\n-\n-      for (i = 0; i < reload_n_operands; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n-\t  return 0;\n-\n-      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n-\n-    case RELOAD_FOR_INPUT:\n-      if (equiv && TEST_HARD_REG_BIT (reload_reg_used, regno))\n-\treturn 0;\n-\n-      /* The only things earlier are the address for this and\n-\t earlier inputs, other inputs (which we know we don't conflict\n-\t with), and addresses of RELOAD_OTHER objects.\n-\t We can ignore the conflict with addresses of this operand, since\n-         when we inherit this operand, its address reloads are discarded.  */\n-\n-      for (i = 0; i < opnum; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n-\t  return 0;\n-\n-      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n-\n-    case RELOAD_FOR_INPUT_ADDRESS:\n-      /* Earlier reloads include RELOAD_FOR_INPADDR_ADDRESS reloads.  */\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], regno))\n-\treturn 0;\n-      /* ... fall through ...  */\n-    case RELOAD_FOR_INPADDR_ADDRESS:\n-      if (equiv && TEST_HARD_REG_BIT (reload_reg_used, regno))\n-\treturn 0;\n-\n-      /* Similarly, all we have to check is for use in earlier inputs'\n-\t addresses.  */\n-      for (i = 0; i < opnum; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n-\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n-\t  return 0;\n-\n-      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n-    }\n-  abort ();\n-}\n-\n /* Return 1 if the value in reload reg REGNO, as used by a reload\n    needed for the part of the insn specified by OPNUM and TYPE,\n    is still available in REGNO at the end of the insn.\n@@ -5222,14 +5052,21 @@ int reload_spill_index[MAX_RELOADS];\n    Other read-only reloads with the same value do not conflict\n    unless OUT is non-zero and these other reloads have to live while\n    output reloads live.\n+   If OUT is CONST0_RTX, this is a special case: it means that the\n+   test should not be for using register REGNO as reload register, but\n+   for copying from register REGNO into the reload register.\n \n    RELOADNUM is the number of the reload we want to load this value for;\n    a reload does not conflict with itself.\n \n+   When IGNORE_ADDRESS_RELOADS is set, we can not have conflicts with\n+   reloads that load an address for the very reload we are considering.\n+\n    The caller has to make sure that there is no conflict with the return\n    register.  */\n static int\n-reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n+reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n+                             ignore_address_reloads)\n      int regno;\n      int opnum;\n      enum reload_type type;\n@@ -5238,6 +5075,13 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n {\n   int time1;\n   int i;\n+  int copy = 0;\n+\n+  if (out == const0_rtx)\n+    {\n+      copy = 1;\n+      out = NULL_RTX;\n+    }\n \n   /* We use some pseudo 'time' value to check if the lifetimes of the\n      new register use would overlap with the one of a previous reload\n@@ -5259,38 +5103,44 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n     case RELOAD_FOR_OTHER_ADDRESS:\n       time1 = 0;\n       break;\n+    case RELOAD_OTHER:\n+      time1 = copy ? 1 : MAX_RECOG_OPERANDS * 5 + 5;\n+      break;\n     /* For each input, we might have a sequence of RELOAD_FOR_INPADDR_ADDRESS,\n        RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 ,\n        respectively, to the time values for these, we get distinct time\n        values.  To get distinct time values for each operand, we have to\n        multiply opnum by at least three.  We round that up to four because\n        multiply by four is often cheaper.  */\n     case RELOAD_FOR_INPADDR_ADDRESS:\n-      time1 = opnum * 4 + 1;\n+      time1 = opnum * 4 + 2;\n       break;\n     case RELOAD_FOR_INPUT_ADDRESS:\n-      time1 = opnum * 4 + 2;\n+      time1 = opnum * 4 + 3;\n+      break;\n+    case RELOAD_FOR_INPUT:\n+      /* All RELOAD_FOR_INPUT reloads remain live till the instruction\n+\t executes (inclusive).  */\n+      time1 = copy ? opnum * 4 + 4 : MAX_RECOG_OPERANDS * 4 + 3;\n       break;\n     case RELOAD_FOR_OPADDR_ADDR:\n-    /* opnum * 4 + 3 < opnum * 4 + 4\n+    /* opnum * 4 + 4\n        <= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */\n-      time1 = MAX_RECOG_OPERANDS * 4;\n-      break;\n-    case RELOAD_FOR_INPUT:\n-      /* All RELOAD_FOR_INPUT reloads remain live till just before the\n-\t instruction is executed.  */\n       time1 = MAX_RECOG_OPERANDS * 4 + 1;\n       break;\n     case RELOAD_FOR_OPERAND_ADDRESS:\n       /* RELOAD_FOR_OPERAND_ADDRESS reloads are live even while the insn\n \t is executed.  */\n-      time1 = MAX_RECOG_OPERANDS * 4 + 2;\n+      time1 = copy ? MAX_RECOG_OPERANDS * 4 + 2 : MAX_RECOG_OPERANDS * 4 + 3;\n+      break;\n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n+      time1 = MAX_RECOG_OPERANDS * 4 + 4 + opnum;\n       break;\n     case RELOAD_FOR_OUTPUT_ADDRESS:\n-      time1 = MAX_RECOG_OPERANDS * 4 + 3 + opnum;\n+      time1 = MAX_RECOG_OPERANDS * 4 + 5 + opnum;\n       break;\n     default:\n-      time1 = MAX_RECOG_OPERANDS * 5 + 3;\n+      time1 = MAX_RECOG_OPERANDS * 5 + 5;\n     }\n \n   for (i = 0; i < n_reloads; i++)\n@@ -5301,11 +5151,6 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n \t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - (unsigned)1)\n \t  && i != reloadnum)\n \t{\n-\t  if (out\n-\t      && reload_when_needed[i] != RELOAD_FOR_INPUT\n-\t      && reload_when_needed[i] != RELOAD_FOR_INPUT_ADDRESS\n-\t      && reload_when_needed[i] != RELOAD_FOR_INPADDR_ADDRESS)\n-\t    return 0;\n \t  if (! reload_in[i] || ! rtx_equal_p (reload_in[i], value)\n \t      || reload_out[i])\n \t    {\n@@ -5322,48 +5167,87 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n \t\t     RELOAD_FOR_{INPUT,OPERAND,OUTPUT}_ADDRESS .  If the\n \t\t     address reload is inherited, the address address reload\n \t\t     goes away, so we can ignore this conflict.  */\n-\t\t  if (type == RELOAD_FOR_INPUT_ADDRESS && reloadnum == i + 1)\n+\t\t  if (type == RELOAD_FOR_INPUT_ADDRESS && reloadnum == i + 1\n+\t\t      && ignore_address_reloads\n+\t\t      /* Unless the RELOAD_FOR_INPUT is an auto_inc expression.\n+\t\t\t Then the address address is still needed to store\n+\t\t\t back the new address.  */\n+\t\t      && ! reload_out[reloadnum])\n \t\t    continue;\n-\t\t  time2 = reload_opnum[i] * 4 + 1;\n+\t\t  /* Likewise, if a RELOAD_FOR_INPUT can inherit a value, its\n+\t\t     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS\n+\t\t     reloads go away.  */\n+\t\t  if (type == RELOAD_FOR_INPUT && opnum == reload_opnum[i]\n+\t\t      && ignore_address_reloads\n+\t\t      /* Unless we are reloading an auto_inc expression.  */\n+\t\t      && ! reload_out[reloadnum])\n+\t\t    continue;\n+\t\t  time2 = reload_opnum[i] * 4 + 2;\n \t\t  break;\n \t\tcase RELOAD_FOR_INPUT_ADDRESS:\n-\t\t  time2 = reload_opnum[i] * 4 + 2;\n+\t\t  if (type == RELOAD_FOR_INPUT && opnum == reload_opnum[i]\n+\t\t      && ignore_address_reloads\n+\t\t      && ! reload_out[reloadnum])\n+\t\t    continue;\n+\t\t  time2 = reload_opnum[i] * 4 + 3;\n \t\t  break;\n \t\tcase RELOAD_FOR_INPUT:\n-\t\t  time2 = reload_opnum[i] * 4 + 3;\n+\t\t  time2 = reload_opnum[i] * 4 + 4;\n \t\t  break;\n+\t\t/* reload_opnum[i] * 4 + 4 <= (MAX_RECOG_OPERAND - 1) * 4 + 4\n+\t\t   == MAX_RECOG_OPERAND * 4  */\n \t\tcase RELOAD_FOR_OPADDR_ADDR:\n-\t\t  if (type == RELOAD_FOR_OPERAND_ADDRESS && reloadnum == i + 1)\n+\t\t  if (type == RELOAD_FOR_OPERAND_ADDRESS && reloadnum == i + 1\n+\t\t      && ignore_address_reloads\n+\t\t      && ! reload_out[reloadnum])\n \t\t    continue;\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4;\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 1;\n \t\t  break;\n \t\tcase RELOAD_FOR_OPERAND_ADDRESS:\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 1;\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 2;\n+\t\t  break;\n+\t\tcase RELOAD_FOR_INSN:\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3;\n \t\t  break;\n \t\tcase RELOAD_FOR_OUTPUT:\n \t\t/* All RELOAD_FOR_OUTPUT reloads become live just after the\n \t\t   instruction is executed.  */\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3;\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 4;\n \t\t  break;\n+\t\t/* The first RELOAD_FOR_OUTADDR_ADDRESS reload conflicts with\n+\t\t   the RELOAD_FOR_OUTPUT reloads, so assign it the same time\n+\t\t   value.  */\n \t\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n-\t\t  if (type == RELOAD_FOR_OUTPUT_ADDRESS && reloadnum == i + 1)\n+\t\t  if (type == RELOAD_FOR_OUTPUT_ADDRESS && reloadnum == i + 1\n+\t\t      && ignore_address_reloads\n+\t\t      && ! reload_out[reloadnum])\n \t\t    continue;\n-\t\t/* fall through. */\n-\t\t/* The first RELOAD_FOR_OUTPUT_ADDRESS reload conflicts with the\n-\t\t   RELOAD_FOR_OUTPUT reloads, so assign it the same time value.  */\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 4 + reload_opnum[i];\n+\t\t  break;\n \t\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3 + reload_opnum[i];\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 5 + reload_opnum[i];\n \t\t  break;\n \t\tcase RELOAD_OTHER:\n+\t\t  /* If there is no conflict in the input part, handle this\n+\t\t     like an output reload.  */\n \t\t  if (! reload_in[i] || rtx_equal_p (reload_in[i], value))\n \t\t    {\n-\t\t      time2 = MAX_RECOG_OPERANDS * 4 + 3;\n+\t\t      time2 = MAX_RECOG_OPERANDS * 4 + 4;\n \t\t      break;\n \t\t    }\n+\t\t  time2 = 1;\n+\t\t  /* RELOAD_OTHER might be live beyond instruction execution,\n+\t\t     but this is not obvious when we set time2 = 1.  So check\n+\t\t     here if there might be a problem with the new reload\n+\t\t     clobbering the register used by the RELOAD_OTHER.  */\n+\t\t  if (out)\n+\t\t    return 0;\n+\t\t  break;\n \t\tdefault:\n-\t\t  time2 = 0;\n+\t\t  return 0;\n \t\t}\n-\t      if (time1 >= time2)\n+\t      if (time1 >= time2\n+\t\t  || (out && time2 >= MAX_RECOG_OPERANDS * 4 + 4))\n \t\treturn 0;\n \t    }\n \t}\n@@ -5455,7 +5339,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t\t\t\t\t  reload_opnum[r],\n \t\t\t\t\t\t  reload_when_needed[r],\n \t\t\t\t\t\t  reload_in[r],\n-\t\t\t\t\t\t  reload_out[r], r)))\n+\t\t\t\t\t\t  reload_out[r], r, 1)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], regnum)\n \t      && HARD_REGNO_MODE_OK (regnum, reload_mode[r])\n \t      /* Look first for regs to share, then for unshared.  But\n@@ -5903,15 +5787,10 @@ choose_reload_regs (chain)\n \t\t      && (reload_nregs[r] == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n-\t\t      && ((reload_reg_free_p (i, reload_opnum[r],\n-\t\t\t\t\t      reload_when_needed[r])\n-\t\t\t   && reload_reg_free_before_p (i, reload_opnum[r],\n-\t\t\t\t\t\t\treload_when_needed[r],\n-\t\t\t\t\t\t\t0))\n-\t\t\t  || reload_reg_free_for_value_p (i, reload_opnum[r],\n-\t\t\t\t\t\t\t  reload_when_needed[r],\n-\t\t\t\t\t\t\t  reload_in[r],\n-\t\t\t\t\t\t\t  reload_out[r], r)))\n+\t\t      && reload_reg_free_for_value_p (i, reload_opnum[r],\n+\t\t\t\t\t\t      reload_when_needed[r],\n+\t\t\t\t\t\t      reload_in[r],\n+\t\t\t\t\t\t      const0_rtx, r, 1))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n@@ -5945,6 +5824,9 @@ choose_reload_regs (chain)\n \t\t\t      break;\n \n \t\t\t  if (i1 != n_earlyclobbers\n+\t\t\t      || ! (reload_reg_free_for_value_p\n+\t\t\t\t    (i, reload_opnum[r], reload_when_needed[r],\n+\t\t\t\t     reload_in[r], reload_out[r], r, 1))\n \t\t\t      /* Don't use it if we'd clobber a pseudo reg.  */\n \t\t\t      || (TEST_HARD_REG_BIT (reg_used_by_pseudo, i)\n \t\t\t\t  && reload_out[r]\n@@ -6032,7 +5914,7 @@ choose_reload_regs (chain)\n \t\t       && ! reload_reg_free_for_value_p (regno, reload_opnum[r],\n \t\t\t\t\t\t\t reload_when_needed[r],\n \t\t\t\t\t\t\t reload_in[r],\n-\t\t\t\t\t\t\t reload_out[r], r))\n+\t\t\t\t\t\t\t reload_out[r], r, 1))\n \t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n@@ -6240,14 +6122,13 @@ choose_reload_regs (chain)\n \t    check_reg = reload_override_in[r];\n \t  else\n \t    continue;\n-\t  if (! (reload_reg_free_before_p (true_regnum (check_reg),\n-\t    \t\t\t       reload_opnum[r], reload_when_needed[r],\n-\t    \t\t\t       ! reload_inherited[r])\n-\t\t || reload_reg_free_for_value_p (true_regnum (check_reg),\n+\t  if (! reload_reg_free_for_value_p (true_regnum (check_reg),\n \t    \t\t\t\t     reload_opnum[r],\n \t    \t\t\t\t     reload_when_needed[r],\n \t    \t\t\t\t     reload_in[r],\n-\t    \t\t\t\t     reload_out[r], r)))\n+\t    \t\t\t\t     (reload_inherited[r]\n+\t\t\t\t\t      ? reload_out[r] : const0_rtx),\n+\t\t\t\t\t     r, 1))\n \t    {\n \t      if (pass)\n \t\tcontinue;\n@@ -6600,31 +6481,14 @@ emit_reload_insns (chain)\n \t    {\n \t      int regno = true_regnum (oldequiv);\n \n-\t      /* If OLDEQUIV is a spill register, don't use it for this\n-\t\t if any other reload needs it at an earlier stage of this insn\n-\t\t or at this stage.  */\n-\t      if (spill_reg_order[regno] >= 0\n-\t\t  && (! reload_reg_free_p (regno, reload_opnum[j],\n-\t\t\t\t\t   reload_when_needed[j])\n-\t\t      || ! reload_reg_free_before_p (regno, reload_opnum[j],\n-\t\t\t\t\t\t     reload_when_needed[j], 1)))\n+\t      /* Don't use OLDEQUIV if any other reload changes it at an\n+\t\t earlier stage of this insn or at this stage.  */\n+\t      if (! reload_reg_free_for_value_p (regno, reload_opnum[j],\n+\t\t\t\t\t\t reload_when_needed[j],\n+\t\t\t\t\t\t reload_in[j], const0_rtx, j,\n+\t\t\t\t\t\t 0))\n \t\toldequiv = 0;\n \n-\t      /* If OLDEQUIV is not a spill register,\n-\t\t don't use it if any other reload wants it.  */\n-\t      if (spill_reg_order[regno] < 0)\n-\t\t{\n-\t\t  int k;\n-\t\t  for (k = 0; k < n_reloads; k++)\n-\t\t    if (reload_reg_rtx[k] != 0 && k != j\n-\t\t\t&& reg_overlap_mentioned_for_reload_p (reload_reg_rtx[k],\n-\t\t\t\t\t\t\t       oldequiv))\n-\t\t      {\n-\t\t\toldequiv = 0;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t}\n-\n \t      /* If it is no cheaper to copy from OLDEQUIV into the\n \t\t reload register than it would be to move from memory,\n \t\t don't use it. Likewise, if we need a secondary register\n@@ -6772,9 +6636,11 @@ emit_reload_insns (chain)\n \t\t   && dead_or_set_p (insn, old)\n \t\t   /* This is unsafe if some other reload\n \t\t      uses the same reg first.  */\n-\t\t   && reload_reg_free_before_p (REGNO (reloadreg),\n-\t\t\t\t\t\treload_opnum[j],\n-\t\t\t\t\t\treload_when_needed[j], 0))\n+\t\t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n+\t\t\t\t\t\t   reload_opnum[j],\n+\t\t\t\t\t\t   reload_when_needed[j], \n+\t\t\t\t\t\t   old, reload_out[j],\n+\t\t\t\t\t\t   j, 0))\n \t    {\n \t      rtx temp = PREV_INSN (insn);\n \t      while (temp && GET_CODE (temp) == NOTE)"}]}