{"sha": "d71cc23f717aa36fdff3fd6591cb27acd0f09366", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcxY2MyM2Y3MTdhYTM2ZmRmZjNmZDY1OTFjYjI3YWNkMGYwOTM2Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-04T20:23:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-04T20:23:13Z"}, "message": "cgraphunit.c (cgraph_reset_node): Break out from ...\n\n\n\t* cgraphunit.c (cgraph_reset_node): Break out from ...\n\t(cgraph_finalize_function): ... here.\n\t(cgraph_finalize_compilation_unit): Reset nodes where backend\n\tremoved the body.\n\nFrom-SVN: r100599", "tree": {"sha": "49de3349f4e4a3390f6487bc8f97bcac008f2344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49de3349f4e4a3390f6487bc8f97bcac008f2344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d71cc23f717aa36fdff3fd6591cb27acd0f09366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d71cc23f717aa36fdff3fd6591cb27acd0f09366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d71cc23f717aa36fdff3fd6591cb27acd0f09366", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d71cc23f717aa36fdff3fd6591cb27acd0f09366/comments", "author": null, "committer": null, "parents": [{"sha": "0f1341c792afc09924b573f5228778dbdd33b805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1341c792afc09924b573f5228778dbdd33b805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1341c792afc09924b573f5228778dbdd33b805"}], "stats": {"total": 122, "additions": 71, "deletions": 51}, "files": [{"sha": "b8f94966744da055c55a40376ff860abdeb0e34f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d71cc23f717aa36fdff3fd6591cb27acd0f09366/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d71cc23f717aa36fdff3fd6591cb27acd0f09366/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d71cc23f717aa36fdff3fd6591cb27acd0f09366", "patch": "@@ -1,3 +1,10 @@\n+2005-06-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (cgraph_reset_node): Break out from ...\n+\t(cgraph_finalize_function): ... here.\n+\t(cgraph_finalize_compilation_unit): Reset nodes where backend\n+\tremoved the body.\n+\n 2005-06-04  Richard Henderson  <rth@redhat.com>\n \n \tPR target/21888"}, {"sha": "0cedbd62086b6ceb4a133e956f76017364854f34", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 64, "deletions": 51, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d71cc23f717aa36fdff3fd6591cb27acd0f09366/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d71cc23f717aa36fdff3fd6591cb27acd0f09366/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d71cc23f717aa36fdff3fd6591cb27acd0f09366", "patch": "@@ -339,6 +339,59 @@ cgraph_assemble_pending_functions (void)\n \n   return output;\n }\n+/* As an GCC extension we allow redefinition of the function.  The\n+   semantics when both copies of bodies differ is not well defined.\n+   We replace the old body with new body so in unit at a time mode\n+   we always use new body, while in normal mode we may end up with\n+   old body inlined into some functions and new body expanded and\n+   inlined in others.\n+\n+   ??? It may make more sense to use one body for inlining and other\n+   body for expanding the function but this is difficult to do.  */\n+\n+static void\n+cgraph_reset_node (struct cgraph_node *node)\n+{\n+  /* If node->output is set, then this is a unit-at-a-time compilation\n+     and we have already begun whole-unit analysis.  This is *not*\n+     testing for whether we've already emitted the function.  That\n+     case can be sort-of legitimately seen with real function \n+     redefinition errors.  I would argue that the front end should\n+     never present us with such a case, but don't enforce that for now.  */\n+  gcc_assert (!node->output);\n+\n+  /* Reset our data structures so we can analyze the function again.  */\n+  memset (&node->local, 0, sizeof (node->local));\n+  memset (&node->global, 0, sizeof (node->global));\n+  memset (&node->rtl, 0, sizeof (node->rtl));\n+  node->analyzed = false;\n+  node->local.redefined_extern_inline = true;\n+  node->local.finalized = false;\n+\n+  if (!flag_unit_at_a_time)\n+    {\n+      struct cgraph_node *n;\n+\n+      for (n = cgraph_nodes; n; n = n->next)\n+\tif (n->global.inlined_to == node)\n+\t  cgraph_remove_node (n);\n+    }\n+\n+  cgraph_node_remove_callees (node);\n+\n+  /* We may need to re-queue the node for assembling in case\n+     we already proceeded it and ignored as not needed.  */\n+  if (node->reachable && !flag_unit_at_a_time)\n+    {\n+      struct cgraph_node *n;\n+\n+      for (n = cgraph_nodes_queue; n; n = n->next_needed)\n+\tif (n == node)\n+\t  break;\n+      if (!n)\n+\tnode->reachable = 0;\n+    }\n+}\n \n /* DECL has been parsed.  Take it, queue it, compile it at the whim of the\n    logic in effect.  If NESTED is true, then our caller cannot stand to have\n@@ -351,56 +404,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   struct cgraph_node *node = cgraph_node (decl);\n \n   if (node->local.finalized)\n-    {\n-      /* As an GCC extension we allow redefinition of the function.  The\n-\t semantics when both copies of bodies differ is not well defined.\n-\t We replace the old body with new body so in unit at a time mode\n-\t we always use new body, while in normal mode we may end up with\n-\t old body inlined into some functions and new body expanded and\n-\t inlined in others.\n-\t \n-\t ??? It may make more sense to use one body for inlining and other\n-\t body for expanding the function but this is difficult to do.  */\n-\n-      /* If node->output is set, then this is a unit-at-a-time compilation\n-\t and we have already begun whole-unit analysis.  This is *not*\n-\t testing for whether we've already emitted the function.  That\n-\t case can be sort-of legitimately seen with real function \n-\t redefinition errors.  I would argue that the front end should\n-\t never present us with such a case, but don't enforce that for now.  */\n-      gcc_assert (!node->output);\n-\n-      /* Reset our data structures so we can analyze the function again.  */\n-      memset (&node->local, 0, sizeof (node->local));\n-      memset (&node->global, 0, sizeof (node->global));\n-      memset (&node->rtl, 0, sizeof (node->rtl));\n-      node->analyzed = false;\n-      node->local.redefined_extern_inline = true;\n-\n-      if (!flag_unit_at_a_time)\n-\t{\n-\t  struct cgraph_node *n;\n-\n-\t  for (n = cgraph_nodes; n; n = n->next)\n-\t    if (n->global.inlined_to == node)\n-\t      cgraph_remove_node (n);\n-\t}\n-\n-      cgraph_node_remove_callees (node);\n-\n-      /* We may need to re-queue the node for assembling in case\n-         we already proceeded it and ignored as not needed.  */\n-      if (node->reachable && !flag_unit_at_a_time)\n-\t{\n-\t  struct cgraph_node *n;\n-\n-\t  for (n = cgraph_nodes_queue; n; n = n->next_needed)\n-\t    if (n == node)\n-\t      break;\n-\t  if (!n)\n-\t    node->reachable = 0;\n-\t}\n-    }\n+    cgraph_reset_node (node);\n \n   notice_global_symbol (decl);\n   node->decl = decl;\n@@ -837,7 +841,10 @@ cgraph_finalize_compilation_unit (void)\n \t weak alias attribute to kill its body. See\n \t gcc.c-torture/compile/20011119-1.c  */\n       if (!DECL_SAVED_TREE (decl))\n-\tcontinue;\n+\t{\n+\t  cgraph_reset_node (node);\n+\t  continue;\n+\t}\n \n       gcc_assert (!node->analyzed && node->reachable);\n       gcc_assert (DECL_SAVED_TREE (decl));\n@@ -870,14 +877,20 @@ cgraph_finalize_compilation_unit (void)\n     {\n       tree decl = node->decl;\n \n+      if (node->local.finalized && !DECL_SAVED_TREE (decl))\n+        cgraph_reset_node (node);\n+\n       if (!node->reachable && DECL_SAVED_TREE (decl))\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n \t  cgraph_remove_node (node);\n+\t  continue;\n \t}\n       else\n \tnode->next_needed = NULL;\n+      gcc_assert (!node->local.finalized || DECL_SAVED_TREE (decl));\n+      gcc_assert (node->analyzed == node->local.finalized);\n     }\n   if (cgraph_dump_file)\n     {"}]}