{"sha": "5bab4c9631c478b7940e952ea57de680321d5a8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJhYjRjOTYzMWM0NzhiNzk0MGU5NTJlYTU3ZGU2ODAzMjFkNWE4ZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-09T11:10:42Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-09T11:10:42Z"}, "message": "decl.c: Add decl_type_param_list...\n\n2017-09-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* decl.c : Add decl_type_param_list, type_param_spec_list as\n\tstatic variables to hold PDT spec lists.\n\t(build_sym): Copy 'type_param_spec_list' to symbol spec_list.\n\t(build_struct): Copy the 'saved_kind_expr' to the component\n\t'kind_expr'. Check that KIND or LEN components appear in the\n\tdecl_type_param_list. These should appear as symbols in the\n\tf2k_derived namespace. If the component is itself a PDT type,\n\tcopy the decl_type_param_list to the component param_list.\n\t(gfc_match_kind_spec): If the KIND expression is parameterized\n\tset KIND to zero and store the expression in 'saved_kind_expr'.\n\t(insert_parameter_exprs): New function.\n\t(gfc_insert_kind_parameter_exprs): New function.\n\t(gfc_insert_parameter_exprs): New function.\n\t(gfc_get_pdt_instance): New function.\n\t(gfc_match_decl_type_spec): Match the decl_type_spec_list if it\n\tis present. If it is, call 'gfc_get_pdt_instance' to obtain the\n\tspecific instance of the PDT.\n\t(match_attr_spec): Match KIND and LEN attributes. Check for the\n\tstandard and for type/kind of the parameter. They are also not\n\tallowed outside a derived type definition.\n\t(gfc_match_data_decl): Null the decl_type_param_list and the\n\ttype_param_spec_list on entry and free them on exit.\n\t(gfc_match_formal_arglist): If 'typeparam' is true, add the\n\tformal symbol to the f2k_derived namespace.\n\t(gfc_match_derived_decl): Register the decl_type_param_list\n\tif this is a PDT. If this is a type extension, gather up all\n\tthe type parameters and put them in the right order.\n\t*dump-parse-tree.c (show_attr): Signal PDT templates and the\n\tparameter attributes.\n\t(show_components): Output parameter atrributes and component\n\tparameter list.\n\t(show_symbol): Show variable parameter lists.\n\t* expr.c (expr.c): Copy the expression parameter list.\n\t(gfc_is_constant_expr): Pass on symbols representing PDT\n\tparameters.\n\t(gfc_check_init_expr): Break on PDT KIND parameters and\n\tPDT parameter expressions.\n\t(gfc_check_assign): Assigning to KIND or LEN components is an\n\terror.\n\t(derived_parameter_expr): New function.\n\t(gfc_derived_parameter_expr): New function.\n\t(gfc_spec_list_type): New function.\n\t* gfortran.h : Add enum gfc_param_spec_type. Add the PDT attrs\n\tto the structure symbol_attr. Add the 'kind_expr' and\n\t'param_list' field to the gfc_component structure. Comment on\n\tthe reuse of the gfc_actual_arglist structure as storage for\n\ttype parameter spec lists. Add the new field 'spec_type' to\n\tthis structure. Add 'param_list' fields to gfc_symbol and\n\tgfc_expr. Add prototypes for gfc_insert_kind_parameter_exprs,\n\tgfc_insert_parameter_exprs, gfc_add_kind, gfc_add_len,\n\tgfc_derived_parameter_expr and gfc_spec_list_type.\n\t* interface.c (gfc_compare_derived_types): Treat PDTs in the\n\tsame way as sequence types.\n\t* match.c : Add variable 'type_param_spec_list'.\n\t(gfc_op2string, gfc_match_member_sep, gfc_match_label): Remove\n\ttrailing whitespace.\n\t(match_derived_type_spec): Match PDTs and find specific\n\tinstance.\n\t(gfc_match_type_spec): Remove more trailing whitespace.\n\t(gfc_match_allocate): Assumed or deferred parameters cannot\n\tappear here. Copy the type parameter spec list to the expr for\n\tthe allocatable entity. Free 'type_param_spec_list'.\n\t(gfc_match_common, gfc_match_namelist, gfc_match_module): Still\n\tmore trailing whitespace to remove.\n\t(gfc_match_type_is): Allow PDT typespecs.\n\t* match.h : Modify prototypes for gfc_match_formal_arglist and\n\tgfc_match_actual_arglist.\n\t* module.c (ab_attribute, mstring attr_bits): PDT attributes\n\tadded.\n\t(mio_symbol_attribute): PDT attributes handled.\n\t(mio_component): Deal with 'kind_expr' field.\n\t(mio_full_f2k_derived): For PDT templates, transfer the formal\n\tnamespace symroot to the f2k_derived namespace.\n\t*primary.c (match_keyword_arg, gfc_match_actual_arglist): Add\n\tmodifications to handle PDT spec lists. These are flagged in\n\tboth cases by new boolean arguments, whose prototype defaults\n\tare false.\n\t(gfc_match_structure_constructor, match_variable): Remove yet\n\tmore trailing whitespace.\n\t* resolve.c (get_pdt_spec_expr, get_pdt_constructor): New\n\tfunctions.\n\t(resolve_structure_cons): If the constructor is a PDT template,\n\tcall get_pdt_constructor to build it using the parameter lists\n\tand then get the specific instance of the PDT.\n\t(resolve_component): PDT strings need a hidden string length\n\tcomponent like deferred characters.\n\t(resolve_symbol): Dummy PDTs cannot have deferred parameters.\n\t* symbol.c (gfc_add_kind, gfc_add_len): New functions.\n\t(free_components): Free 'kind_expr' and 'param_list' fields.\n\t(gfc_free_symbol): Free the 'param_list' field.\n\t(gfc_find_sym_tree): If the current state is a PDT template,\n\tlook for the symtree in the f2k_derived namspaces.\n\ttrans-array.c (structure_alloc_comps): Allocate and deallocate\n\tPDTs. Check dummy arguments for compliance of LEN parameters.\n\tAdd the new functions to the preceeding enum.\n\t(gfc_allocate_pdt_comp, gfc_deallocate_pdt_comp and\n\tgfc_check_pdt_dummy): New functions calling above.\n\t* trans-array.h : Add prototypes for these functions.\n\ttrans-decl.c (gfc_get_symbol_decl): Call gfc_defer_symbol_init\n\tas appropriate for PDT symbols.\n\t(gfc_trans_deferred_vars): Allocate/deallocate PDT entities as\n\tthey come into and out of scope. Exclude pdt_types from being\n\t'gcc_unreachable'.\n\t(gfc_trans_subcomponent_assign): PDT array components must be\n\thandles as if they are allocatable.\n\t* trans-stmt.c (gfc_trans_allocate): Handle initialization of\n\tPDT entities.\n\t(gfc_trans_deallocate): Likewise.\n\t* trans-types.c (gfc_get_derived_type): PDT templates must not\n\tarrive here. PDT string components are handles as if deferred.\n\tSimilarly, PDT arrays are treated as if allocatable. PDT\n\tstrings are pointer types.\n\t* trans.c (gfc_deferred_strlen): Handle PDT strings in the same\n\tway as deferred characters.\n\n\n2017-09-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/pdt_1.f03 : New test.\n\t* gfortran.dg/pdt_2.f03 : New test.\n\t* gfortran.dg/pdt_3.f03 : New test.\n\t* gfortran.dg/pdt_4.f03 : New test.\n\t* gfortran.dg/pdt_5.f03 : New test.\n\nFrom-SVN: r251925", "tree": {"sha": "fe34213cb8a220dbd5072eaf2b7addbbc4709085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe34213cb8a220dbd5072eaf2b7addbbc4709085"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bab4c9631c478b7940e952ea57de680321d5a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bab4c9631c478b7940e952ea57de680321d5a8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bab4c9631c478b7940e952ea57de680321d5a8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bab4c9631c478b7940e952ea57de680321d5a8e/comments", "author": null, "committer": null, "parents": [{"sha": "66c9b3f50f70b1503629b94cc2e33f7e5df64b08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66c9b3f50f70b1503629b94cc2e33f7e5df64b08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66c9b3f50f70b1503629b94cc2e33f7e5df64b08"}], "stats": {"total": 2326, "additions": 2279, "deletions": 47}, "files": [{"sha": "140caf508c3dac9d98dd86cf465906296aa49240", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1,3 +1,120 @@\n+2017-09-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* decl.c : Add decl_type_param_list, type_param_spec_list as\n+\tstatic variables to hold PDT spec lists.\n+\t(build_sym): Copy 'type_param_spec_list' to symbol spec_list.\n+\t(build_struct): Copy the 'saved_kind_expr' to the component\n+\t'kind_expr'. Check that KIND or LEN components appear in the\n+\tdecl_type_param_list. These should appear as symbols in the\n+\tf2k_derived namespace. If the component is itself a PDT type,\n+\tcopy the decl_type_param_list to the component param_list.\n+\t(gfc_match_kind_spec): If the KIND expression is parameterized\n+\tset KIND to zero and store the expression in 'saved_kind_expr'.\n+\t(insert_parameter_exprs): New function.\n+\t(gfc_insert_kind_parameter_exprs): New function.\n+\t(gfc_insert_parameter_exprs): New function.\n+\t(gfc_get_pdt_instance): New function.\n+\t(gfc_match_decl_type_spec): Match the decl_type_spec_list if it\n+\tis present. If it is, call 'gfc_get_pdt_instance' to obtain the\n+\tspecific instance of the PDT.\n+\t(match_attr_spec): Match KIND and LEN attributes. Check for the\n+\tstandard and for type/kind of the parameter. They are also not\n+\tallowed outside a derived type definition.\n+\t(gfc_match_data_decl): Null the decl_type_param_list and the\n+\ttype_param_spec_list on entry and free them on exit.\n+\t(gfc_match_formal_arglist): If 'typeparam' is true, add the\n+\tformal symbol to the f2k_derived namespace.\n+\t(gfc_match_derived_decl): Register the decl_type_param_list\n+\tif this is a PDT. If this is a type extension, gather up all\n+\tthe type parameters and put them in the right order.\n+\t*dump-parse-tree.c (show_attr): Signal PDT templates and the\n+\tparameter attributes.\n+\t(show_components): Output parameter atrributes and component\n+\tparameter list.\n+\t(show_symbol): Show variable parameter lists.\n+\t* expr.c (expr.c): Copy the expression parameter list.\n+\t(gfc_is_constant_expr): Pass on symbols representing PDT\n+\tparameters.\n+\t(gfc_check_init_expr): Break on PDT KIND parameters and\n+\tPDT parameter expressions.\n+\t(gfc_check_assign): Assigning to KIND or LEN components is an\n+\terror.\n+\t(derived_parameter_expr): New function.\n+\t(gfc_derived_parameter_expr): New function.\n+\t(gfc_spec_list_type): New function.\n+\t* gfortran.h : Add enum gfc_param_spec_type. Add the PDT attrs\n+\tto the structure symbol_attr. Add the 'kind_expr' and\n+\t'param_list' field to the gfc_component structure. Comment on\n+\tthe reuse of the gfc_actual_arglist structure as storage for\n+\ttype parameter spec lists. Add the new field 'spec_type' to\n+\tthis structure. Add 'param_list' fields to gfc_symbol and\n+\tgfc_expr. Add prototypes for gfc_insert_kind_parameter_exprs,\n+\tgfc_insert_parameter_exprs, gfc_add_kind, gfc_add_len,\n+\tgfc_derived_parameter_expr and gfc_spec_list_type.\n+\t* interface.c (gfc_compare_derived_types): Treat PDTs in the\n+\tsame way as sequence types.\n+\t* match.c : Add variable 'type_param_spec_list'.\n+\t(gfc_op2string, gfc_match_member_sep, gfc_match_label): Remove\n+\ttrailing whitespace.\n+\t(match_derived_type_spec): Match PDTs and find specific\n+\tinstance.\n+\t(gfc_match_type_spec): Remove more trailing whitespace.\n+\t(gfc_match_allocate): Assumed or deferred parameters cannot\n+\tappear here. Copy the type parameter spec list to the expr for\n+\tthe allocatable entity. Free 'type_param_spec_list'.\n+\t(gfc_match_common, gfc_match_namelist, gfc_match_module): Still\n+\tmore trailing whitespace to remove.\n+\t(gfc_match_type_is): Allow PDT typespecs.\n+\t* match.h : Modify prototypes for gfc_match_formal_arglist and\n+\tgfc_match_actual_arglist.\n+\t* module.c (ab_attribute, mstring attr_bits): PDT attributes\n+\tadded.\n+\t(mio_symbol_attribute): PDT attributes handled.\n+\t(mio_component): Deal with 'kind_expr' field.\n+\t(mio_full_f2k_derived): For PDT templates, transfer the formal\n+\tnamespace symroot to the f2k_derived namespace.\n+\t*primary.c (match_keyword_arg, gfc_match_actual_arglist): Add\n+\tmodifications to handle PDT spec lists. These are flagged in\n+\tboth cases by new boolean arguments, whose prototype defaults\n+\tare false.\n+\t(gfc_match_structure_constructor, match_variable): Remove yet\n+\tmore trailing whitespace.\n+\t* resolve.c (get_pdt_spec_expr, get_pdt_constructor): New\n+\tfunctions.\n+\t(resolve_structure_cons): If the constructor is a PDT template,\n+\tcall get_pdt_constructor to build it using the parameter lists\n+\tand then get the specific instance of the PDT.\n+\t(resolve_component): PDT strings need a hidden string length\n+\tcomponent like deferred characters.\n+\t(resolve_symbol): Dummy PDTs cannot have deferred parameters.\n+\t* symbol.c (gfc_add_kind, gfc_add_len): New functions.\n+\t(free_components): Free 'kind_expr' and 'param_list' fields.\n+\t(gfc_free_symbol): Free the 'param_list' field.\n+\t(gfc_find_sym_tree): If the current state is a PDT template,\n+\tlook for the symtree in the f2k_derived namspaces.\n+\ttrans-array.c (structure_alloc_comps): Allocate and deallocate\n+\tPDTs. Check dummy arguments for compliance of LEN parameters.\n+\tAdd the new functions to the preceeding enum.\n+\t(gfc_allocate_pdt_comp, gfc_deallocate_pdt_comp and\n+\tgfc_check_pdt_dummy): New functions calling above.\n+\t* trans-array.h : Add prototypes for these functions.\n+\ttrans-decl.c (gfc_get_symbol_decl): Call gfc_defer_symbol_init\n+\tas appropriate for PDT symbols.\n+\t(gfc_trans_deferred_vars): Allocate/deallocate PDT entities as\n+\tthey come into and out of scope. Exclude pdt_types from being\n+\t'gcc_unreachable'.\n+\t(gfc_trans_subcomponent_assign): PDT array components must be\n+\thandles as if they are allocatable.\n+\t* trans-stmt.c (gfc_trans_allocate): Handle initialization of\n+\tPDT entities.\n+\t(gfc_trans_deallocate): Likewise.\n+\t* trans-types.c (gfc_get_derived_type): PDT templates must not\n+\tarrive here. PDT string components are handles as if deferred.\n+\tSimilarly, PDT arrays are treated as if allocatable. PDT\n+\tstrings are pointer types.\n+\t* trans.c (gfc_deferred_strlen): Handle PDT strings in the same\n+\tway as deferred characters.\n+\n 2017-09-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/81887"}, {"sha": "0609152477da736c3d236d09ac38d267d709816d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 693, "deletions": 7, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -95,6 +95,15 @@ gfc_symbol *gfc_new_block;\n \n bool gfc_matching_function;\n \n+/* If a kind expression of a component of a parameterized derived type is\n+   parameterized, temporarily store the expression here.  */\n+static gfc_expr *saved_kind_expr = NULL;\n+\n+/* Used to store the parameter list arising in a PDT declaration and\n+   in the typespec of a PDT variable or component.  */\n+static gfc_actual_arglist *decl_type_param_list;\n+static gfc_actual_arglist *type_param_spec_list;\n+\n \n /********************* DATA statement subroutines *********************/\n \n@@ -1500,6 +1509,11 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n \n   sym->attr.implied_index = 0;\n \n+  /* Use the parameter expressions for a parameterized derived type.  */\n+  if ((sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n+      && sym->ts.u.derived->attr.pdt_type && type_param_spec_list)\n+    sym->param_list = gfc_copy_actual_arglist (type_param_spec_list);\n+\n   if (sym->ts.type == BT_CLASS)\n     return gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as);\n \n@@ -1946,6 +1960,11 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n   c->ts = current_ts;\n   if (c->ts.type == BT_CHARACTER)\n     c->ts.u.cl = cl;\n+\n+  if (c->ts.type != BT_CLASS && c->ts.type != BT_DERIVED\n+      && c->ts.kind == 0 && saved_kind_expr != NULL)\n+    c->kind_expr = gfc_copy_expr (saved_kind_expr);\n+\n   c->attr = current_attr;\n \n   c->initializer = *init;\n@@ -1999,6 +2018,31 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n   if (c->ts.type == BT_CLASS)\n     return gfc_build_class_symbol (&c->ts, &c->attr, &c->as);\n \n+  if (c->attr.pdt_kind || c->attr.pdt_len)\n+    {\n+      gfc_symbol *sym;\n+      gfc_find_symbol (c->name, gfc_current_block ()->f2k_derived,\n+\t\t       0, &sym);\n+      if (sym == NULL)\n+\t{\n+\t  gfc_error (\"Type parameter %qs at %C has no corresponding entry \"\n+\t\t     \"in the type parameter name list at %L\",\n+\t\t     c->name, &gfc_current_block ()->declared_at);\n+\t  return false;\n+\t}\n+      sym->ts = c->ts;\n+      sym->attr.pdt_kind = c->attr.pdt_kind;\n+      sym->attr.pdt_len = c->attr.pdt_len;\n+      if (c->initializer)\n+\tsym->value = gfc_copy_expr (c->initializer);\n+      sym->attr.flavor = FL_VARIABLE;\n+    }\n+\n+  if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+      && c->ts.u.derived && c->ts.u.derived->attr.pdt_template\n+      && decl_type_param_list)\n+    c->param_list = gfc_copy_actual_arglist (decl_type_param_list);\n+\n   return true;\n }\n \n@@ -2612,6 +2656,7 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n   m = MATCH_NO;\n   n = MATCH_YES;\n   e = NULL;\n+  saved_kind_expr = NULL;\n \n   where = loc = gfc_current_locus;\n \n@@ -2628,8 +2673,16 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n   loc = gfc_current_locus;\n \n kind_expr:\n+\n   n = gfc_match_init_expr (&e);\n \n+  if (gfc_derived_parameter_expr (e))\n+    {\n+      ts->kind = 0;\n+      saved_kind_expr = gfc_copy_expr (e);\n+      goto close_brackets;\n+    }\n+\n   if (n != MATCH_YES)\n     {\n       if (gfc_matching_function)\n@@ -2707,6 +2760,8 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n \t\t     \"is %s\", gfc_basic_typename (ts->f90_type), &where,\n \t\t     gfc_basic_typename (ts->type));\n \n+close_brackets:\n+\n   gfc_gobble_whitespace ();\n   if ((c = gfc_next_ascii_char ()) != ')'\n       && (ts->type != BT_CHARACTER || c != ','))\n@@ -3030,6 +3085,423 @@ match_record_decl (char *name)\n   return MATCH_ERROR;\n }\n \n+\n+/* This function uses the gfc_actual_arglist 'type_param_spec_list' as a source\n+   of expressions to substitute into the possibly parameterized expression\n+   'e'. Using a list is inefficient but should not be too bad since the\n+   number of type parameters is not likely to be large.  */\n+static bool\n+insert_parameter_exprs (gfc_expr* e, gfc_symbol* sym ATTRIBUTE_UNUSED,\n+\t\t\tint* f)\n+{\n+  gfc_actual_arglist *param;\n+  gfc_expr *copy;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  gcc_assert (e->symtree);\n+  if (e->symtree->n.sym->attr.pdt_kind\n+      || (*f != 0 && e->symtree->n.sym->attr.pdt_len))\n+    {\n+      for (param = type_param_spec_list; param; param = param->next)\n+\tif (strcmp (e->symtree->n.sym->name, param->name) == 0)\n+\t  break;\n+\n+      if (param)\n+\t{\n+\t  copy = gfc_copy_expr (param->expr);\n+\t  *e = *copy;\n+\t  free (copy);\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+\n+bool\n+gfc_insert_kind_parameter_exprs (gfc_expr *e)\n+{\n+  return gfc_traverse_expr (e, NULL, &insert_parameter_exprs, 0);\n+}\n+\n+\n+bool\n+gfc_insert_parameter_exprs (gfc_expr *e, gfc_actual_arglist *param_list)\n+{\n+  gfc_actual_arglist *old_param_spec_list = type_param_spec_list;\n+  type_param_spec_list = param_list;\n+  return gfc_traverse_expr (e, NULL, &insert_parameter_exprs, 1);\n+  type_param_spec_list = NULL;\n+  type_param_spec_list = old_param_spec_list;\n+}\n+\n+/* Determines the instance of a parameterized derived type to be used by\n+   matching determining the values of the kind parameters and using them\n+   in the name of the instance. If the instance exists, it is used, otherwise\n+   a new derived type is created.  */\n+match\n+gfc_get_pdt_instance (gfc_actual_arglist *param_list, gfc_symbol **sym,\n+\t\t      gfc_actual_arglist **ext_param_list)\n+{\n+  /* The PDT template symbol.  */\n+  gfc_symbol *pdt = *sym;\n+  /* The symbol for the parameter in the template f2k_namespace.  */\n+  gfc_symbol *param;\n+  /* The hoped for instance of the PDT.  */\n+  gfc_symbol *instance;\n+  /* The list of parameters appearing in the PDT declaration.  */\n+  gfc_formal_arglist *type_param_name_list;\n+  /* Used to store the parameter specification list during recursive calls.  */\n+  gfc_actual_arglist *old_param_spec_list;\n+  /* Pointers to the parameter specification being used.  */\n+  gfc_actual_arglist *actual_param;\n+  gfc_actual_arglist *tail = NULL;\n+  /* Used to build up the name of the PDT instance. The prefix uses 4\n+     characters and each KIND parameter 2 more.  Allow 8 of the latter. */\n+  char name[GFC_MAX_SYMBOL_LEN + 21];\n+\n+  bool name_seen = (param_list == NULL);\n+  bool assumed_seen = false;\n+  bool deferred_seen = false;\n+  bool spec_error = false;\n+  int kind_value, i;\n+  gfc_expr *kind_expr;\n+  gfc_component *c1, *c2;\n+  match m;\n+\n+  type_param_spec_list = NULL;\n+\n+  type_param_name_list = pdt->formal;\n+  actual_param = param_list;\n+  sprintf (name, \"Pdt%s\", pdt->name);\n+\n+  /* Run through the parameter name list and pick up the actual\n+     parameter values or use the default values in the PDT declaration.  */\n+  for (; type_param_name_list;\n+       type_param_name_list = type_param_name_list->next)\n+    {\n+      if (actual_param && actual_param->spec_type != SPEC_EXPLICIT)\n+\t{\n+\t  if (actual_param->spec_type == SPEC_ASSUMED)\n+\t    spec_error = deferred_seen;\n+\t  else\n+\t    spec_error = assumed_seen;\n+\n+\t  if (spec_error)\n+\t    {\n+\t      gfc_error (\"The type parameter spec list at %C cannot contain \"\n+\t\t\t \"both ASSUMED and DEFERRED parameters\");\n+\t      gfc_free_actual_arglist (type_param_spec_list);\n+\t      return MATCH_ERROR;\n+\t    }\n+\t}\n+\n+      if (actual_param && actual_param->name)\n+\tname_seen = true;\n+      param = type_param_name_list->sym;\n+\n+      kind_expr = NULL;\n+      if (!name_seen)\n+\t{\n+\t  if (actual_param && actual_param->spec_type == SPEC_EXPLICIT)\n+\t    kind_expr = gfc_copy_expr (actual_param->expr);\n+\t}\n+      else\n+\t{\n+\t  actual_param = param_list;\n+\t  for (;actual_param; actual_param = actual_param->next)\n+\t    if (actual_param->name\n+\t        && strcmp (actual_param->name, param->name) == 0)\n+\t      break;\n+\t  if (actual_param && actual_param->spec_type == SPEC_EXPLICIT)\n+\t    kind_expr = gfc_copy_expr (actual_param->expr);\n+\t  else\n+\t    {\n+\t      if (param->value)\n+\t\tkind_expr = gfc_copy_expr (param->value);\n+\t      else if (!(actual_param && param->attr.pdt_len))\n+\t\t{\n+\t\t  gfc_error (\"The derived parameter '%qs' at %C does not \"\n+\t\t\t     \"have a default value\", param->name);\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Store the current parameter expressions in a temporary actual\n+\t arglist 'list' so that they can be substituted in the corresponding\n+\t expressions in the PDT instance.  */\n+      if (type_param_spec_list == NULL)\n+\t{\n+\t  type_param_spec_list = gfc_get_actual_arglist ();\n+\t  tail = type_param_spec_list;\n+\t}\n+      else\n+\t{\n+\t  tail->next = gfc_get_actual_arglist ();\n+\t  tail = tail->next;\n+\t}\n+      tail->name = param->name;\n+\n+      if (kind_expr)\n+\t{\n+\t  tail->expr = gfc_copy_expr (kind_expr);\n+\t  /* Try simplification even for LEN expressions.  */\n+\t  gfc_simplify_expr (tail->expr, 1);\n+\t}\n+\n+      if (actual_param)\n+\ttail->spec_type = actual_param->spec_type;\n+\n+      if (!param->attr.pdt_kind)\n+\t{\n+\t  if (!name_seen)\n+\t    actual_param = actual_param->next;\n+\t  if (kind_expr)\n+\t    {\n+\t      gfc_free_expr (kind_expr);\n+\t      kind_expr = NULL;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      if (actual_param\n+\t  && (actual_param->spec_type == SPEC_ASSUMED\n+\t      || actual_param->spec_type == SPEC_DEFERRED))\n+\t{\n+\t  gfc_error (\"The KIND parameter '%qs' at %C cannot either be \"\n+\t\t     \"ASSUMED or DEFERRED\", param->name);\n+\t  gfc_free_actual_arglist (type_param_spec_list);\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (!kind_expr || !gfc_is_constant_expr (kind_expr))\n+\t{\n+\t  gfc_error (\"The value for the KIND parameter '%qs' at %C does not \"\n+\t\t     \"reduce to a constant expression\", param->name);\n+\t  gfc_free_actual_arglist (type_param_spec_list);\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      gfc_extract_int (kind_expr, &kind_value);\n+      sprintf (name, \"%s_%d\", name, kind_value);\n+\n+      if (!name_seen && actual_param)\n+\tactual_param = actual_param->next;\n+      gfc_free_expr (kind_expr);\n+    }\n+\n+  /* Now we search for the PDT instance 'name'. If it doesn't exist, we\n+     build it, using 'pdt' as a template.  */\n+  if (gfc_get_symbol (name, pdt->ns, &instance))\n+    {\n+      gfc_error (\"Parameterized derived type at %C is ambiguous\");\n+      return MATCH_ERROR;\n+    }\n+\n+  m = MATCH_YES;\n+\n+  if (instance->attr.flavor == FL_DERIVED\n+      && instance->attr.pdt_type)\n+    {\n+      instance->refs++;\n+      if (ext_param_list)\n+        *ext_param_list = type_param_spec_list;\n+      *sym = instance;\n+      gfc_commit_symbols ();\n+      return m;\n+    }\n+\n+  /* Start building the new instance of the parameterized type.  */\n+  gfc_copy_attr (&instance->attr, &pdt->attr, &pdt->declared_at);\n+  instance->attr.pdt_template = 0;\n+  instance->attr.pdt_type = 1;\n+  instance->declared_at = gfc_current_locus;\n+\n+  /* Add the components, replacing the parameters in all expressions\n+     with the expressions for their values in 'type_param_spec_list'.  */\n+  c1 = pdt->components;\n+  tail = type_param_spec_list;\n+  for (; c1; c1 = c1->next)\n+    {\n+      gfc_add_component (instance, c1->name, &c2);\n+      c2->ts = c1->ts;\n+      c2->attr = c1->attr;\n+\n+      /* Deal with type extension by recursively calling this function\n+\t to obtain the instance of the extended type.  */\n+      if (gfc_current_state () != COMP_DERIVED\n+\t  && c1 == pdt->components\n+\t  && (c1->ts.type == BT_DERIVED || c1->ts.type == BT_CLASS)\n+\t  && c1->ts.u.derived && c1->ts.u.derived->attr.pdt_template\n+\t  && gfc_get_derived_super_type (*sym) == c2->ts.u.derived)\n+\t{\n+\t  gfc_formal_arglist *f;\n+\n+\t  old_param_spec_list = type_param_spec_list;\n+\n+\t  /* Obtain a spec list appropriate to the extended type..*/\n+\t  actual_param = gfc_copy_actual_arglist (type_param_spec_list);\n+\t  type_param_spec_list = actual_param;\n+\t  for (f = c1->ts.u.derived->formal; f && f->next; f = f->next)\n+\t    actual_param = actual_param->next;\n+\t  if (actual_param)\n+\t    {\n+\t      gfc_free_actual_arglist (actual_param->next);\n+\t      actual_param->next = NULL;\n+\t    }\n+\n+\t  /* Now obtain the PDT instance for the extended type.  */\n+\t  c2->param_list = type_param_spec_list;\n+\t  m = gfc_get_pdt_instance (type_param_spec_list, &c2->ts.u.derived,\n+\t\t\t\t    NULL);\n+\t  type_param_spec_list = old_param_spec_list;\n+\n+\t  c2->ts.u.derived->refs++;\n+\t  gfc_set_sym_referenced (c2->ts.u.derived);\n+\n+\t  /* Set extension level.  */\n+\t  if (c2->ts.u.derived->attr.extension == 255)\n+\t    {\n+\t      /* Since the extension field is 8 bit wide, we can only have\n+\t\t up to 255 extension levels.  */\n+\t      gfc_error (\"Maximum extension level reached with type %qs at %L\",\n+\t\t\t c2->ts.u.derived->name,\n+\t\t\t &c2->ts.u.derived->declared_at);\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  instance->attr.extension = c2->ts.u.derived->attr.extension + 1;\n+\n+\t  /* Advance the position in the spec list by the number of\n+\t     parameters in the extended type.  */\n+\t  tail = type_param_spec_list;\n+\t  for (f = c1->ts.u.derived->formal; f && f->next; f = f->next)\n+\t    tail = tail->next;\n+\n+\t  continue;\n+\t}\n+\n+      /* Set the component kind using the parameterized expression.  */\n+      if (c1->ts.kind == 0 && c1->kind_expr != NULL)\n+\t{\n+\t  gfc_expr *e = gfc_copy_expr (c1->kind_expr);\n+\t  gfc_insert_kind_parameter_exprs (e);\n+\t  gfc_extract_int (e, &c2->ts.kind);\n+\t  gfc_free_expr (e);\n+\t}\n+\n+      /* Similarly, set the string length if parameterized.  */\n+      if (c1->ts.type == BT_CHARACTER\n+\t  && c1->ts.u.cl->length\n+\t  && gfc_derived_parameter_expr (c1->ts.u.cl->length))\n+\t{\n+\t  gfc_expr *e;\n+\t  e = gfc_copy_expr (c1->ts.u.cl->length);\n+\t  gfc_insert_kind_parameter_exprs (e);\n+\t  gfc_simplify_expr (e, 1);\n+\t  c2->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n+\t  c2->ts.u.cl->length = e;\n+\t  c2->attr.pdt_string = 1;\n+\t}\n+\n+      /* Set up either the KIND/LEN initializer, if constant,\n+\t or the parameterized expression. Use the template\n+\t initializer if one is not already set in this instance.  */\n+      if (c2->attr.pdt_kind || c2->attr.pdt_len)\n+\t{\n+\t  if (tail && tail->expr && gfc_is_constant_expr (tail->expr))\n+\t    c2->initializer = gfc_copy_expr (tail->expr);\n+\t  else if (tail && tail->expr)\n+\t    {\n+\t      c2->param_list = gfc_get_actual_arglist ();\n+\t      c2->param_list->name = tail->name;\n+\t      c2->param_list->expr = gfc_copy_expr (tail->expr);\n+\t      c2->param_list->next = NULL;\n+\t    }\n+\n+\t  if (!c2->initializer && c1->initializer)\n+\t    c2->initializer = gfc_copy_expr (c1->initializer);\n+\n+\t  tail = tail->next;\n+\t}\n+\n+      /* Copy the array spec.  */\n+      c2->as = gfc_copy_array_spec (c1->as);\n+      if (c1->ts.type == BT_CLASS)\n+\tCLASS_DATA (c2)->as = gfc_copy_array_spec (CLASS_DATA (c1)->as);\n+\n+      /* Determine if an array spec is parameterized. If so, substitute\n+\t in the parameter expressions for the bounds and set the pdt_array\n+\t attribute. Notice that this attribute must be unconditionally set\n+\t if this is an array of parameterized character length.  */\n+      if (c1->as && c1->as->type == AS_EXPLICIT)\n+\t{\n+\t  bool pdt_array = false;\n+\n+\t  /* Are the bounds of the array parameterized?  */\n+\t  for (i = 0; i < c1->as->rank; i++)\n+\t    {\n+\t      if (gfc_derived_parameter_expr (c1->as->lower[i]))\n+\t\tpdt_array = true;\n+\t      if (gfc_derived_parameter_expr (c1->as->upper[i]))\n+\t\tpdt_array = true;\n+\t    }\n+\n+\t  /* If they are, free the expressions for the bounds and\n+\t     replace them with the template expressions with substitute\n+\t     values.  */\n+\t  for (i = 0; pdt_array && i < c1->as->rank; i++)\n+\t    {\n+\t      gfc_expr *e;\n+\t      e = gfc_copy_expr (c1->as->lower[i]);\n+\t      gfc_insert_kind_parameter_exprs (e);\n+\t      gfc_simplify_expr (e, 1);\n+\t      gfc_free_expr (c2->as->lower[i]);\n+\t      c2->as->lower[i] = e;\n+\t      e = gfc_copy_expr (c1->as->upper[i]);\n+\t      gfc_insert_kind_parameter_exprs (e);\n+\t      gfc_simplify_expr (e, 1);\n+\t      gfc_free_expr (c2->as->upper[i]);\n+\t      c2->as->upper[i] = e;\n+\t    }\n+\t  c2->attr.pdt_array = pdt_array ? 1 : c2->attr.pdt_string;\n+\t}\n+\n+      /* Recurse into this function for PDT components.  */\n+      if ((c1->ts.type == BT_DERIVED || c1->ts.type == BT_CLASS)\n+\t  && c1->ts.u.derived && c1->ts.u.derived->attr.pdt_template)\n+\t{\n+\t  gfc_actual_arglist *params;\n+\t  /* The component in the template has a list of specification\n+\t     expressions derived from its declaration.  */\n+\t  params = gfc_copy_actual_arglist (c1->param_list);\n+\t  actual_param = params;\n+\t  /* Substitute the template parameters with the expressions\n+\t     from the specification list.  */\n+\t  for (;actual_param; actual_param = actual_param->next)\n+\t    gfc_insert_parameter_exprs (actual_param->expr,\n+\t\t\t\t\ttype_param_spec_list);\n+\n+\t  /* Now obtain the PDT instance for the component.  */\n+\t  old_param_spec_list = type_param_spec_list;\n+\t  m = gfc_get_pdt_instance (params, &c2->ts.u.derived, NULL);\n+\t  type_param_spec_list = old_param_spec_list;\n+\n+\t  c2->param_list = params;\n+\t  c2->initializer = gfc_default_initializer (&c2->ts);\n+\t}\n+    }\n+\n+  gfc_commit_symbol (instance);\n+  if (ext_param_list)\n+    *ext_param_list = type_param_spec_list;\n+  *sym = instance;\n+  return m;\n+}\n+\n+\n /* Matches a declaration-type-spec (F03:R502).  If successful, sets the ts\n    structure to the matched specification.  This is necessary for FUNCTION and\n    IMPLICIT statements.\n@@ -3048,6 +3520,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n   bool seen_deferred_kind, matched_type;\n   const char *dt_name;\n \n+  decl_type_param_list = NULL;\n+\n   /* A belt and braces check that the typespec is correctly being treated\n      as a deferred characteristic association.  */\n   seen_deferred_kind = (gfc_current_state () == COMP_FUNCTION)\n@@ -3196,7 +3670,13 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n     }\n \n   if (matched_type)\n+    {\n+      m = gfc_match_actual_arglist (1, &decl_type_param_list, true);\n+      if (m == MATCH_ERROR)\n+\treturn m;\n+\n     m = gfc_match_char (')');\n+    }\n \n   if (m != MATCH_YES)\n     m = match_record_decl (name);\n@@ -3211,6 +3691,19 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n           gfc_error (\"Type name %qs at %C is ambiguous\", name);\n           return MATCH_ERROR;\n         }\n+\n+      if (sym && sym->attr.flavor == FL_DERIVED\n+\t  && sym->attr.pdt_template\n+\t  && gfc_current_state () != COMP_DERIVED)\n+\t{\n+\t  m = gfc_get_pdt_instance (decl_type_param_list, &sym,  NULL);\n+\t  if (m != MATCH_YES)\n+\t    return m;\n+\t  gcc_assert (!sym->attr.pdt_template && sym->attr.pdt_type);\n+\t  ts->u.derived = sym;\n+\t  strcpy (name, gfc_dt_lower_string (sym->name));\n+\t}\n+\n       if (sym && sym->attr.flavor == FL_STRUCT)\n         {\n           ts->u.derived = sym;\n@@ -3279,13 +3772,27 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t  return m;\n \t}\n \n-      m = gfc_match (\" class ( %n )\", name);\n+      m = gfc_match (\" class (\");\n+\n+      if (m == MATCH_YES)\n+\tm = gfc_match (\"%n\", name);\n+      else\n+\treturn m;\n+\n       if (m != MATCH_YES)\n \treturn m;\n       ts->type = BT_CLASS;\n \n       if (!gfc_notify_std (GFC_STD_F2003, \"CLASS statement at %C\"))\n \treturn MATCH_ERROR;\n+\n+      m = gfc_match_actual_arglist (1, &decl_type_param_list, true);\n+      if (m == MATCH_ERROR)\n+\treturn m;\n+\n+      m = gfc_match_char (')');\n+      if (m != MATCH_YES)\n+\treturn m;\n     }\n \n   /* Defer association of the derived type until the end of the\n@@ -3351,6 +3858,18 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       return MATCH_ERROR;\n     }\n \n+  if (sym && sym->attr.flavor == FL_DERIVED\n+      && sym->attr.pdt_template\n+      && gfc_current_state () != COMP_DERIVED)\n+\t{\n+\t  m = gfc_get_pdt_instance (decl_type_param_list, &sym, NULL);\n+\t  if (m != MATCH_YES)\n+\t    return m;\n+\t  gcc_assert (!sym->attr.pdt_template && sym->attr.pdt_type);\n+\t  ts->u.derived = sym;\n+\t  strcpy (name, gfc_dt_lower_string (sym->name));\n+\t}\n+\n   gfc_save_symbol_data (sym);\n   gfc_set_sym_referenced (sym);\n   if (!sym->attr.generic\n@@ -3361,6 +3880,16 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       && !gfc_add_function (&sym->attr, sym->name, NULL))\n     return MATCH_ERROR;\n \n+  if (dt_sym && dt_sym->attr.flavor == FL_DERIVED\n+      && dt_sym->attr.pdt_template\n+      && gfc_current_state () != COMP_DERIVED)\n+    {\n+      m = gfc_get_pdt_instance (decl_type_param_list, &dt_sym, NULL);\n+      if (m != MATCH_YES)\n+\treturn m;\n+      gcc_assert (!dt_sym->attr.pdt_template && dt_sym->attr.pdt_type);\n+    }\n+\n   if (!dt_sym)\n     {\n       gfc_interface *intr, *head;\n@@ -3890,7 +4419,7 @@ match_attr_spec (void)\n     DECL_STATIC, DECL_AUTOMATIC,\n     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n     DECL_IS_BIND_C, DECL_CODIMENSION, DECL_ASYNCHRONOUS, DECL_CONTIGUOUS,\n-    DECL_NONE, GFC_DECL_END /* Sentinel */\n+    DECL_LEN, DECL_KIND, DECL_NONE, GFC_DECL_END /* Sentinel */\n   };\n \n /* GFC_DECL_END is the sentinel, index starts at 0.  */\n@@ -4033,6 +4562,16 @@ match_attr_spec (void)\n \t\t}\n \t      break;\n \n+\t    case 'k':\n+\t      if (match_string_p (\"kind\"))\n+\t\td = DECL_KIND;\n+\t      break;\n+\n+\t    case 'l':\n+\t      if (match_string_p (\"len\"))\n+\t\td = DECL_LEN;\n+\t      break;\n+\n \t    case 'o':\n \t      if (match_string_p (\"optional\"))\n \t\td = DECL_OPTIONAL;\n@@ -4226,6 +4765,12 @@ match_attr_spec (void)\n \t  case DECL_OPTIONAL:\n \t    attr = \"OPTIONAL\";\n \t    break;\n+\t  case DECL_KIND:\n+\t    attr = \"KIND\";\n+\t    break;\n+\t  case DECL_LEN:\n+\t    attr = \"LEN\";\n+\t    break;\n \t  case DECL_PARAMETER:\n \t    attr = \"PARAMETER\";\n \t    break;\n@@ -4307,6 +4852,54 @@ match_attr_spec (void)\n \t\t  goto cleanup;\n \t\t}\n \t    }\n+\t  else if (d == DECL_KIND)\n+\t    {\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"KIND \"\n+\t\t\t\t   \"attribute at %C in a TYPE definition\"))\n+\t\t{\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t      if (current_ts.type != BT_INTEGER)\n+\t\t{\n+\t\t  gfc_error (\"Component with KIND attribute at %C must be \"\n+\t\t\t     \"INTEGER\");\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t      if (current_ts.kind != gfc_default_integer_kind)\n+\t\t{\n+\t\t  gfc_error (\"Component with KIND attribute at %C must be \"\n+\t\t\t     \"default integer kind (%d)\",\n+\t\t\t      gfc_default_integer_kind);\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t    }\n+\t  else if (d == DECL_LEN)\n+\t    {\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"LEN \"\n+\t\t\t\t   \"attribute at %C in a TYPE definition\"))\n+\t\t{\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t      if (current_ts.type != BT_INTEGER)\n+\t\t{\n+\t\t  gfc_error (\"Component with LEN attribute at %C must be \"\n+\t\t\t     \"INTEGER\");\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t      if (current_ts.kind != gfc_default_integer_kind)\n+\t\t{\n+\t\t  gfc_error (\"Component with LEN attribute at %C must be \"\n+\t\t\t     \"default integer kind (%d)\",\n+\t\t\t      gfc_default_integer_kind);\n+\t\t  m = MATCH_ERROR;\n+\t\t  goto cleanup;\n+\t\t}\n+\t    }\n \t  else\n \t    {\n \t      gfc_error (\"Attribute at %L is not allowed in a TYPE definition\",\n@@ -4344,6 +4937,15 @@ match_attr_spec (void)\n \t    }\n \t}\n \n+      if (gfc_current_state () != COMP_DERIVED\n+\t  && (d == DECL_KIND || d == DECL_LEN))\n+\t{\n+\t  gfc_error (\"Attribute at %L is not allowed outside a TYPE \"\n+\t\t     \"definition\", &seen_at[d]);\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+\n       switch (d)\n \t{\n \tcase DECL_ALLOCATABLE:\n@@ -4396,6 +4998,14 @@ match_attr_spec (void)\n \t  t = gfc_add_optional (&current_attr, &seen_at[d]);\n \t  break;\n \n+\tcase DECL_KIND:\n+\t  t = gfc_add_kind (&current_attr, &seen_at[d]);\n+\t  break;\n+\n+\tcase DECL_LEN:\n+\t  t = gfc_add_len (&current_attr, &seen_at[d]);\n+\t  break;\n+\n \tcase DECL_PARAMETER:\n \t  t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, &seen_at[d]);\n \t  break;\n@@ -4886,6 +5496,9 @@ gfc_match_data_decl (void)\n   match m;\n   int elem;\n \n+  type_param_spec_list = NULL;\n+  decl_type_param_list = NULL;\n+\n   num_idents_on_line = 0;\n \n   m = gfc_match_decl_type_spec (&current_ts, 0);\n@@ -5000,6 +5613,13 @@ gfc_match_data_decl (void)\n   gfc_free_data_all (gfc_current_ns);\n \n cleanup:\n+  if (saved_kind_expr)\n+    gfc_free_expr (saved_kind_expr);\n+  if (type_param_spec_list)\n+    gfc_free_actual_arglist (type_param_spec_list);\n+  if (decl_type_param_list)\n+    gfc_free_actual_arglist (decl_type_param_list);\n+  saved_kind_expr = NULL;\n   gfc_free_array_spec (current_as);\n   current_as = NULL;\n   return m;\n@@ -5173,10 +5793,12 @@ copy_prefix (symbol_attribute *dest, locus *where)\n }\n \n \n-/* Match a formal argument list.  */\n+/* Match a formal argument list or, if typeparam is true, a\n+   type_param_name_list.  */\n \n match\n-gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n+gfc_match_formal_arglist (gfc_symbol *progname, int st_flag,\n+\t\t\t  int null_flag, bool typeparam)\n {\n   gfc_formal_arglist *head, *tail, *p, *q;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n@@ -5228,7 +5850,10 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n \t  if (m != MATCH_YES)\n \t    goto cleanup;\n \n-\t  if (gfc_get_symbol (name, NULL, &sym))\n+\t  if (!typeparam && gfc_get_symbol (name, NULL, &sym))\n+\t    goto cleanup;\n+\t  else if (typeparam\n+\t\t   && gfc_get_symbol (name, progname->f2k_derived, &sym))\n \t    goto cleanup;\n \t}\n \n@@ -8945,6 +9570,8 @@ gfc_match_derived_decl (void)\n   match is_type_attr_spec = MATCH_NO;\n   bool seen_attr = false;\n   gfc_interface *intr = NULL, *head;\n+  bool parameterized_type = false;\n+  bool seen_colons = false;\n \n   if (gfc_comp_struct (gfc_current_state ()))\n     return MATCH_NO;\n@@ -8972,16 +9599,38 @@ gfc_match_derived_decl (void)\n   if (parent[0] && !extended)\n     return MATCH_ERROR;\n \n-  if (gfc_match (\" ::\") != MATCH_YES && seen_attr)\n+  m = gfc_match (\" ::\");\n+  if (m == MATCH_YES)\n+    {\n+      seen_colons = true;\n+    }\n+  else if (seen_attr)\n     {\n       gfc_error (\"Expected :: in TYPE definition at %C\");\n       return MATCH_ERROR;\n     }\n \n-  m = gfc_match (\" %n%t\", name);\n+  m = gfc_match (\" %n \", name);\n   if (m != MATCH_YES)\n     return m;\n \n+  /* Make sure that we don't identify TYPE IS (...) as a parameterized\n+     derived type named 'is'.\n+     TODO Expand the check, when 'name' = \"is\" by matching \" (tname) \"\n+     and checking if this is a(n intrinsic) typename. his picks up\n+     misplaced TYPE IS statements such as in select_type_1.f03.  */\n+  if (gfc_peek_ascii_char () == '(')\n+    {\n+      if (gfc_current_state () == COMP_SELECT_TYPE\n+\t  || (!seen_colons && !strcmp (name, \"is\")))\n+\treturn MATCH_NO;\n+      parameterized_type = true;\n+    }\n+\n+  m = gfc_match_eos ();\n+  if (m != MATCH_YES && !parameterized_type)\n+    return m;\n+\n   /* Make sure the name is not the name of an intrinsic type.  */\n   if (gfc_is_intrinsic_typename (name))\n     {\n@@ -9062,9 +9711,21 @@ gfc_match_derived_decl (void)\n   if (!sym->f2k_derived)\n     sym->f2k_derived = gfc_get_namespace (NULL, 0);\n \n+  if (parameterized_type)\n+    {\n+      m = gfc_match_formal_arglist (sym, 0, 0, true);\n+      if (m != MATCH_YES)\n+\treturn m;\n+      m = gfc_match_eos ();\n+      if (m != MATCH_YES)\n+\treturn m;\n+      sym->attr.pdt_template = 1;\n+    }\n+\n   if (extended && !sym->components)\n     {\n       gfc_component *p;\n+      gfc_formal_arglist *f, *g, *h;\n \n       /* Add the extended derived type as the first component.  */\n       gfc_add_component (sym, parent, &p);\n@@ -9089,6 +9750,31 @@ gfc_match_derived_decl (void)\n       /* Provide the links between the extended type and its extension.  */\n       if (!extended->f2k_derived)\n \textended->f2k_derived = gfc_get_namespace (NULL, 0);\n+\n+      /* Copy the extended type-param-name-list from the extended type,\n+\t append those of the extension and add the whole lot to the\n+\t extension.  */\n+      if (extended->attr.pdt_template)\n+\t{\n+\t  g = h = NULL;\n+\t  sym->attr.pdt_template = 1;\n+\t  for (f = extended->formal; f; f = f->next)\n+\t    {\n+\t      if (f == extended->formal)\n+\t\t{\n+\t\t  g = gfc_get_formal_arglist ();\n+\t\t  h = g;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  g->next = gfc_get_formal_arglist ();\n+\t\t  g = g->next;\n+\t\t}\n+\t      g->sym = f->sym;\n+\t    }\n+\t  g->next = sym->formal;\n+\t  sym->formal = h;\n+\t}\n     }\n \n   if (!sym->hash_value)"}, {"sha": "a9107c15e59b67bfc452e12b83c6b99d15d0be21", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -627,7 +627,12 @@ static void\n show_attr (symbol_attribute *attr, const char * module)\n {\n   if (attr->flavor != FL_UNKNOWN)\n+    {\n+      if (attr->flavor == FL_DERIVED && attr->pdt_template)\n+\tfputs (\" (PDT template\", dumpfile);\n+      else\n     fprintf (dumpfile, \"(%s \", gfc_code2string (flavors, attr->flavor));\n+    }\n   if (attr->access != ACCESS_UNKNOWN)\n     fprintf (dumpfile, \"%s \", gfc_code2string (access_types, attr->access));\n   if (attr->proc != PROC_UNKNOWN)\n@@ -653,6 +658,10 @@ show_attr (symbol_attribute *attr, const char * module)\n     fputs (\" INTRINSIC\", dumpfile);\n   if (attr->optional)\n     fputs (\" OPTIONAL\", dumpfile);\n+  if (attr->pdt_kind)\n+    fputs (\" KIND\", dumpfile);\n+  if (attr->pdt_len)\n+    fputs (\" LEN\", dumpfile);\n   if (attr->pointer)\n     fputs (\" POINTER\", dumpfile);\n   if (attr->is_protected)\n@@ -724,10 +733,26 @@ show_components (gfc_symbol *sym)\n \n   for (c = sym->components; c; c = c->next)\n     {\n+      show_indent ();\n       fprintf (dumpfile, \"(%s \", c->name);\n       show_typespec (&c->ts);\n+      if (c->kind_expr)\n+\t{\n+\t  fputs (\" kind_expr: \", dumpfile);\n+\t  show_expr (c->kind_expr);\n+\t}\n+      if (c->param_list)\n+\t{\n+\t  fputs (\"PDT parameters\", dumpfile);\n+\t  show_actual_arglist (c->param_list);\n+\t}\n+\n       if (c->attr.allocatable)\n \tfputs (\" ALLOCATABLE\", dumpfile);\n+      if (c->attr.pdt_kind)\n+\tfputs (\" KIND\", dumpfile);\n+      if (c->attr.pdt_len)\n+\tfputs (\" LEN\", dumpfile);\n       if (c->attr.pointer)\n \tfputs (\" POINTER\", dumpfile);\n       if (c->attr.proc_pointer)\n@@ -935,6 +960,15 @@ show_symbol (gfc_symbol *sym)\n       fputs (\"Formal namespace\", dumpfile);\n       show_namespace (sym->formal_ns);\n     }\n+\n+  if (sym->attr.flavor == FL_VARIABLE\n+      && sym->param_list)\n+    {\n+      show_indent ();\n+      fputs (\"PDT parameters\", dumpfile);\n+      show_actual_arglist (sym->param_list);\n+\n+    }\n   --show_level;\n }\n "}, {"sha": "079a2ba9dbefb0d4b3b3d2f675e1b4afc40a14cd", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -394,6 +394,9 @@ gfc_copy_expr (gfc_expr *p)\n \n   q->ref = gfc_copy_ref (p->ref);\n \n+  if (p->param_list)\n+    q->param_list = gfc_copy_actual_arglist (p->param_list);\n+\n   return q;\n }\n \n@@ -499,6 +502,8 @@ free_expr0 (gfc_expr *e)\n \n   gfc_free_ref_list (e->ref);\n \n+  gfc_free_actual_arglist (e->param_list);\n+\n   memset (e, '\\0', sizeof (gfc_expr));\n }\n \n@@ -525,6 +530,7 @@ gfc_free_actual_arglist (gfc_actual_arglist *a1)\n   while (a1)\n     {\n       a2 = a1->next;\n+      if (a1->expr)\n       gfc_free_expr (a1->expr);\n       free (a1);\n       a1 = a2;\n@@ -917,6 +923,11 @@ gfc_is_constant_expr (gfc_expr *e)\n \t\t  || gfc_is_constant_expr (e->value.op.op2)));\n \n     case EXPR_VARIABLE:\n+      /* The only context in which this can occur is in a parameterized\n+\t derived type declaration, so returning true is OK.  */\n+      if (e->symtree->n.sym->attr.pdt_len\n+\t  || e->symtree->n.sym->attr.pdt_kind)\n+        return true;\n       return false;\n \n     case EXPR_FUNCTION:\n@@ -2531,6 +2542,10 @@ gfc_check_init_expr (gfc_expr *e)\n     case EXPR_VARIABLE:\n       t = true;\n \n+      /* This occurs when parsing pdt templates.  */\n+      if (e->symtree->n.sym->attr.pdt_kind)\n+\tbreak;\n+\n       if (gfc_check_iter_variable (e))\n \tbreak;\n \n@@ -2700,6 +2715,13 @@ gfc_match_init_expr (gfc_expr **result)\n       return m;\n     }\n \n+  if (gfc_derived_parameter_expr (expr))\n+    {\n+      *result = expr;\n+      gfc_init_expr_flag = false;\n+      return m;\n+    }\n+\n   t = gfc_reduce_init_expr (expr);\n   if (!t)\n     {\n@@ -3282,6 +3304,14 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,\n \t}\n     }\n \n+  if (gfc_expr_attr (lvalue).pdt_kind || gfc_expr_attr (lvalue).pdt_len)\n+    {\n+      gfc_error (\"The assignment to a KIND or LEN component of a \"\n+\t\t \"parameterized type at %L is not allowed\",\n+\t\t &lvalue->where);\n+      return false;\n+    }\n+\n   if (gfc_compare_types (&lvalue->ts, &rvalue->ts))\n     return true;\n \n@@ -4837,6 +4867,76 @@ gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n }\n \n \n+/* This function returns true if it contains any references to PDT KIND\n+   or LEN parameters.  */\n+\n+static bool\n+derived_parameter_expr (gfc_expr* e, gfc_symbol* sym ATTRIBUTE_UNUSED,\n+\t\t\tint* f ATTRIBUTE_UNUSED)\n+{\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  gcc_assert (e->symtree);\n+  if (e->symtree->n.sym->attr.pdt_kind\n+      || e->symtree->n.sym->attr.pdt_len)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+bool\n+gfc_derived_parameter_expr (gfc_expr *e)\n+{\n+  return gfc_traverse_expr (e, NULL, &derived_parameter_expr, 0);\n+}\n+\n+\n+/* This function returns the overall type of a type parameter spec list.\n+   If all the specs are explicit, SPEC_EXPLICIT is returned. If any of the\n+   parameters are assumed/deferred then SPEC_ASSUMED/DEFERRED is returned\n+   unless derived is not NULL.  In this latter case, all the LEN parameters\n+   must be either assumed or deferred for the return argument to be set to\n+   anything other than SPEC_EXPLICIT.  */\n+\n+gfc_param_spec_type\n+gfc_spec_list_type (gfc_actual_arglist *param_list, gfc_symbol *derived)\n+{\n+  gfc_param_spec_type res = SPEC_EXPLICIT;\n+  gfc_component *c;\n+  bool seen_assumed = false;\n+  bool seen_deferred = false;\n+\n+  if (derived == NULL)\n+    {\n+      for (; param_list; param_list = param_list->next)\n+\tif (param_list->spec_type == SPEC_ASSUMED\n+\t    || param_list->spec_type == SPEC_DEFERRED)\n+\t  return param_list->spec_type;\n+    }\n+  else\n+    {\n+      for (; param_list; param_list = param_list->next)\n+\t{\n+\t  c = gfc_find_component (derived, param_list->name,\n+\t\t\t\t  true, true, NULL);\n+\t  gcc_assert (c != NULL);\n+\t  if (c->attr.pdt_kind)\n+\t    continue;\n+\t  else if (param_list->spec_type == SPEC_EXPLICIT)\n+\t    return SPEC_EXPLICIT;\n+\t  seen_assumed = param_list->spec_type == SPEC_ASSUMED;\n+\t  seen_deferred = param_list->spec_type == SPEC_DEFERRED;\n+\t  if (seen_assumed && seen_deferred)\n+\t    return SPEC_EXPLICIT;\n+\t}\n+      res = seen_assumed ? SPEC_ASSUMED : SPEC_DEFERRED;\n+    }\n+  return res;\n+}\n+\n+\n bool\n gfc_ref_this_image (gfc_ref *ref)\n {"}, {"sha": "18a534d3c9d6f6226e2082d23ab9ae4a00564267", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -646,6 +646,13 @@ enum gfc_reverse\n   GFC_INHIBIT_REVERSE\n };\n \n+enum gfc_param_spec_type\n+{\n+  SPEC_EXPLICIT,\n+  SPEC_ASSUMED,\n+  SPEC_DEFERRED\n+};\n+\n /************************* Structures *****************************/\n \n /* Used for keeping things in balanced binary trees.  */\n@@ -869,6 +876,11 @@ typedef struct\n      variable for SELECT_TYPE or ASSOCIATE.  */\n   unsigned select_type_temporary:1, associate_var:1;\n \n+  /* These are the attributes required for parameterized derived\n+     types.  */\n+  unsigned pdt_kind:1, pdt_len:1, pdt_type:1, pdt_template:1,\n+\t   pdt_array:1, pdt_string:1;\n+\n   /* This is omp_{out,in,priv,orig} artificial variable in\n      !$OMP DECLARE REDUCTION.  */\n   unsigned omp_udr_artificial_var:1;\n@@ -1053,6 +1065,11 @@ typedef struct gfc_component\n   tree norestrict_decl;\n   locus loc;\n   struct gfc_expr *initializer;\n+  /* Used in parameterized derived type declarations to store parameterized\n+     kind expressions.  */\n+  struct gfc_expr *kind_expr;\n+  struct gfc_actual_arglist *param_list;\n+\n   struct gfc_component *next;\n \n   /* Needed for procedure pointer components.  */\n@@ -1077,7 +1094,8 @@ gfc_formal_arglist;\n #define gfc_get_formal_arglist() XCNEW (gfc_formal_arglist)\n \n \n-/* The gfc_actual_arglist structure is for actual arguments.  */\n+/* The gfc_actual_arglist structure is for actual arguments and\n+   for type parameter specification lists.  */\n typedef struct gfc_actual_arglist\n {\n   const char *name;\n@@ -1089,6 +1107,8 @@ typedef struct gfc_actual_arglist\n      argument has to be added to a function call.  */\n   bt missing_arg_type;\n \n+  gfc_param_spec_type spec_type;\n+\n   struct gfc_expr *expr;\n   struct gfc_actual_arglist *next;\n }\n@@ -1507,6 +1527,9 @@ typedef struct gfc_symbol\n   struct gfc_namespace *formal_ns;\n   struct gfc_namespace *f2k_derived;\n \n+  /* List of PDT parameter expressions  */\n+  struct gfc_actual_arglist *param_list;\n+\n   struct gfc_expr *value;\t/* Parameter/Initializer value */\n   gfc_array_spec *as;\n   struct gfc_symbol *result;\t/* function result symbol */\n@@ -2179,6 +2202,9 @@ typedef struct gfc_expr\n   }\n   value;\n \n+  /* Used to store PDT expression lists associated with expressions.  */\n+  gfc_actual_arglist *param_list;\n+\n }\n gfc_expr;\n \n@@ -2699,6 +2725,12 @@ gfc_finalizer;\n bool gfc_in_match_data (void);\n match gfc_match_char_spec (gfc_typespec *);\n \n+/* Handling Parameterized Derived Types  */\n+bool gfc_insert_kind_parameter_exprs (gfc_expr *);\n+bool gfc_insert_parameter_exprs (gfc_expr *, gfc_actual_arglist *);\n+match gfc_get_pdt_instance (gfc_actual_arglist *, gfc_symbol **,\n+\t\t\t    gfc_actual_arglist **);\n+\n /* scanner.c */\n void gfc_scanner_done_1 (void);\n void gfc_scanner_init_1 (void);\n@@ -2880,6 +2912,8 @@ bool gfc_add_dimension (symbol_attribute *, const char *, locus *);\n bool gfc_add_external (symbol_attribute *, locus *);\n bool gfc_add_intrinsic (symbol_attribute *, locus *);\n bool gfc_add_optional (symbol_attribute *, locus *);\n+bool gfc_add_kind (symbol_attribute *, locus *);\n+bool gfc_add_len (symbol_attribute *, locus *);\n bool gfc_add_pointer (symbol_attribute *, locus *);\n bool gfc_add_cray_pointer (symbol_attribute *, locus *);\n bool gfc_add_cray_pointee (symbol_attribute *, locus *);\n@@ -3143,7 +3177,8 @@ bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n \t\t\tint);\n void gfc_expr_set_symbols_referenced (gfc_expr *);\n bool gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n-\n+bool gfc_derived_parameter_expr (gfc_expr *);\n+gfc_param_spec_type gfc_spec_list_type (gfc_actual_arglist *, gfc_symbol *);\n gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);\n bool gfc_is_proc_ptr_comp (gfc_expr *);\n bool gfc_is_alloc_class_scalar_function (gfc_expr *);"}, {"sha": "fb6db21449df4f16e71b5db53f3778ea9f3c9389", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -645,7 +645,8 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n     return false;\n \n   if (!(derived1->attr.sequence && derived2->attr.sequence)\n-      && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c))\n+      && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c)\n+      && !(derived1->attr.pdt_type && derived2->attr.pdt_type))\n     return false;\n \n   /* Protect against null components.  */"}, {"sha": "6e9125f9a71af6fafb618018e41f3a92bfc24d6c", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 93, "deletions": 16, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -33,6 +33,9 @@ bool gfc_matching_prefix = false;\n /* Stack of SELECT TYPE statements.  */\n gfc_select_type_stack *select_type_stack = NULL;\n \n+/* List of type parameter expressions.  */\n+gfc_actual_arglist *type_param_spec_list;\n+\n /* For debugging and diagnostic purposes.  Return the textual representation\n    of the intrinsic operator OP.  */\n const char *\n@@ -132,12 +135,12 @@ gfc_op2string (gfc_intrinsic_op op)\n      (1) If any user defined operator \".y.\" exists, this is always y(x,z)\n          (even if \".y.\" is the wrong type and/or x has a member y).\n      (2) Otherwise if x has a member y, and y is itself a derived type,\n-         this is (x->y)->z, even if an intrinsic operator exists which \n-         can handle (x,z). \n-     (3) If x has no member y or (x->y) is not a derived type but \".y.\" \n+         this is (x->y)->z, even if an intrinsic operator exists which\n+         can handle (x,z).\n+     (3) If x has no member y or (x->y) is not a derived type but \".y.\"\n          is an intrinsic operator (such as \".eq.\"), this is y(x,z).\n      (4) Lastly if there is no operator \".y.\" and x has no member \"y\", it is an\n-         error.  \n+         error.\n    It is worth noting that the logic here does not support mixed use of member\n    accessors within a single string. That is, even if x has component y and y\n    has component z, the following are all syntax errors:\n@@ -165,7 +168,7 @@ gfc_match_member_sep(gfc_symbol *sym)\n   tsym = NULL;\n \n   /* We may be given either a derived type variable or the derived type\n-    declaration itself (which actually contains the components); \n+    declaration itself (which actually contains the components);\n     we need the latter to search for components.  */\n   if (gfc_fl_struct (sym->attr.flavor))\n     tsym = sym;\n@@ -205,7 +208,7 @@ gfc_match_member_sep(gfc_symbol *sym)\n   if (gfc_find_uop (name, sym->ns) != NULL)\n     goto no;\n \n-  /* Match accesses to existing derived-type components for \n+  /* Match accesses to existing derived-type components for\n     derived-type vars: \"x.y.z\" = (x->y)->z  */\n   c = gfc_find_component(tsym, name, false, true, NULL);\n   if (c && (gfc_bt_struct (c->ts.type) || c->ts.type == BT_CLASS))\n@@ -216,7 +219,7 @@ gfc_match_member_sep(gfc_symbol *sym)\n   if (gfc_match_intrinsic_op (&iop) != MATCH_YES)\n     {\n       /* If \".y.\" is not an intrinsic operator but y was a valid non-\n-        structure component, match and leave the trailing dot to be \n+        structure component, match and leave the trailing dot to be\n         dealt with later.  */\n       if (c)\n         goto yes;\n@@ -623,7 +626,7 @@ gfc_match_label (void)\n       return MATCH_ERROR;\n     }\n \n-  if (!gfc_add_flavor (&gfc_new_block->attr, FL_LABEL, \n+  if (!gfc_add_flavor (&gfc_new_block->attr, FL_LABEL,\n \t\t       gfc_new_block->name, NULL))\n     return MATCH_ERROR;\n \n@@ -1955,7 +1958,10 @@ match_derived_type_spec (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   locus old_locus;\n-  gfc_symbol *derived;\n+  gfc_symbol *derived, *der_type;\n+  match m = MATCH_YES;\n+  gfc_actual_arglist *decl_type_param_list = NULL;\n+  bool is_pdt_template = false;\n \n   old_locus = gfc_current_locus;\n \n@@ -1967,9 +1973,51 @@ match_derived_type_spec (gfc_typespec *ts)\n \n   gfc_find_symbol (name, NULL, 1, &derived);\n \n+  /* Match the PDT spec list, if there.  */\n+  if (derived && derived->attr.flavor == FL_PROCEDURE)\n+    {\n+      gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &der_type);\n+      is_pdt_template = der_type\n+\t\t\t&& der_type->attr.flavor == FL_DERIVED\n+\t\t\t&& der_type->attr.pdt_template;\n+    }\n+\n+  if (is_pdt_template)\n+    m = gfc_match_actual_arglist (1, &decl_type_param_list, true);\n+\n+  if (m == MATCH_ERROR)\n+    {\n+      gfc_free_actual_arglist (decl_type_param_list);\n+      return m;\n+    }\n+\n   if (derived && derived->attr.flavor == FL_PROCEDURE && derived->attr.generic)\n     derived = gfc_find_dt_in_generic (derived);\n \n+  /* If this is a PDT, find the specific instance.  */\n+  if (m == MATCH_YES && is_pdt_template)\n+    {\n+      gfc_namespace *old_ns;\n+\n+      old_ns = gfc_current_ns;\n+      while (gfc_current_ns && gfc_current_ns->parent)\n+\tgfc_current_ns = gfc_current_ns->parent;\n+\n+      if (type_param_spec_list)\n+\tgfc_free_actual_arglist (type_param_spec_list);\n+      m = gfc_get_pdt_instance (decl_type_param_list, &der_type,\n+\t\t\t\t&type_param_spec_list);\n+      gfc_free_actual_arglist (decl_type_param_list);\n+\n+      if (m != MATCH_YES)\n+\treturn m;\n+      derived = der_type;\n+      gcc_assert (!derived->attr.pdt_template && derived->attr.pdt_type);\n+      gfc_set_sym_referenced (derived);\n+\n+      gfc_current_ns = old_ns;\n+    }\n+\n   if (derived && derived->attr.flavor == FL_DERIVED)\n     {\n       ts->type = BT_DERIVED;\n@@ -1999,6 +2047,7 @@ gfc_match_type_spec (gfc_typespec *ts)\n   gfc_clear_ts (ts);\n   gfc_gobble_whitespace ();\n   old_locus = gfc_current_locus;\n+  type_param_spec_list = NULL;\n \n   if (match_derived_type_spec (ts) == MATCH_YES)\n     {\n@@ -2869,7 +2918,7 @@ gfc_match_stopcode (gfc_statement st)\n \t\t\t\t | GFC_STD_F2008_OBS);\n \n   /* Set f03 for -std=f2003.  */\n-  f03 = gfc_option.allow_std == (GFC_STD_F95_OBS | GFC_STD_F95 | GFC_STD_F77 \n+  f03 = gfc_option.allow_std == (GFC_STD_F95_OBS | GFC_STD_F95 | GFC_STD_F77\n \t\t\t\t | GFC_STD_F2008_OBS | GFC_STD_F2003);\n \n   /* Look for a blank between STOP and the stop-code for F2008 or later.  */\n@@ -3935,7 +3984,7 @@ gfc_match_allocate (void)\n     {\n       if (gfc_match (\" :: \") == MATCH_YES)\n \t{\n-\t  if (!gfc_notify_std (GFC_STD_F2003, \"typespec in ALLOCATE at %L\", \n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"typespec in ALLOCATE at %L\",\n \t\t\t       &old_locus))\n \t    goto cleanup;\n \n@@ -3948,6 +3997,16 @@ gfc_match_allocate (void)\n \n \t  if (ts.type == BT_CHARACTER)\n \t    ts.u.cl->length_from_typespec = true;\n+\n+\t  /* TODO understand why this error does not appear but, instead,\n+\t     the derived type is caught as a variable in primary.c.  */\n+\t  if (gfc_spec_list_type (type_param_spec_list, NULL) != SPEC_EXPLICIT)\n+\t    {\n+\t      gfc_error (\"The type parameter spec list in the type-spec at \"\n+\t\t\t \"%L cannot contain ASSUMED or DEFERRED parameters\",\n+\t\t\t &old_locus);\n+\t      goto cleanup;\n+\t    }\n \t}\n       else\n \t{\n@@ -4059,6 +4118,9 @@ gfc_match_allocate (void)\n       if (tail->expr->ts.type == BT_DERIVED)\n \ttail->expr->ts.u.derived = gfc_use_derived (tail->expr->ts.u.derived);\n \n+      if (type_param_spec_list)\n+\ttail->expr->param_list = gfc_copy_actual_arglist (type_param_spec_list);\n+\n       saw_unlimited = saw_unlimited | UNLIMITED_POLY (tail->expr);\n \n       if (gfc_peek_ascii_char () == '(' && !sym->attr.dimension)\n@@ -4143,7 +4205,7 @@ gfc_match_allocate (void)\n \n \t  if (head->next\n \t      && !gfc_notify_std (GFC_STD_F2008, \"SOURCE tag at %L\"\n-\t\t\t\t  \" with more than a single allocate object\", \n+\t\t\t\t  \" with more than a single allocate object\",\n \t\t\t\t  &tmp->where))\n \t    goto cleanup;\n \n@@ -4236,6 +4298,9 @@ gfc_match_allocate (void)\n   new_st.ext.alloc.list = head;\n   new_st.ext.alloc.ts = ts;\n \n+  if (type_param_spec_list)\n+    gfc_free_actual_arglist (type_param_spec_list);\n+\n   return MATCH_YES;\n \n syntax:\n@@ -4248,6 +4313,8 @@ gfc_match_allocate (void)\n   gfc_free_expr (mold);\n   if (tmp && tmp->expr_type) gfc_free_expr (tmp);\n   gfc_free_alloc_list (head);\n+  if (type_param_spec_list)\n+    gfc_free_actual_arglist (type_param_spec_list);\n   return MATCH_ERROR;\n }\n \n@@ -4901,7 +4968,7 @@ gfc_match_common (void)\n \t       || sym->attr.data) && gfc_current_state () != COMP_BLOCK_DATA)\n \t    {\n \t      if (!gfc_notify_std (GFC_STD_GNU, \"Initialized symbol %qs at \"\n-\t\t\t\t   \"%C can only be COMMON in BLOCK DATA\", \n+\t\t\t\t   \"%C can only be COMMON in BLOCK DATA\",\n \t\t\t\t   sym->name))\n \t\tgoto cleanup;\n \t    }\n@@ -5114,7 +5181,7 @@ gfc_match_namelist (void)\n \treturn MATCH_ERROR;\n \n       if (group_name->attr.flavor != FL_NAMELIST\n-\t  && !gfc_add_flavor (&group_name->attr, FL_NAMELIST, \n+\t  && !gfc_add_flavor (&group_name->attr, FL_NAMELIST,\n \t\t\t      group_name->name, NULL))\n \treturn MATCH_ERROR;\n \n@@ -5193,7 +5260,7 @@ gfc_match_module (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (!gfc_add_flavor (&gfc_new_block->attr, FL_MODULE, \n+  if (!gfc_add_flavor (&gfc_new_block->attr, FL_MODULE,\n \t\t       gfc_new_block->name, NULL))\n     return MATCH_ERROR;\n \n@@ -6114,13 +6181,23 @@ gfc_match_type_is (void)\n       return MATCH_ERROR;\n     }\n \n+  if (c->ts.type == BT_DERIVED\n+      && c->ts.u.derived && c->ts.u.derived->attr.pdt_type\n+      && gfc_spec_list_type (type_param_spec_list, c->ts.u.derived)\n+\t\t\t\t\t\t\t!= SPEC_ASSUMED)\n+    {\n+      gfc_error (\"All the LEN type parameters in the TYPE IS statement \"\n+\t\t \"at %C must be ASSUMED\");\n+      return MATCH_ERROR;\n+    }\n+\n   /* Create temporary variable.  */\n   select_type_set_tmp (&c->ts);\n \n   return MATCH_YES;\n \n syntax:\n-  gfc_error (\"Syntax error in TYPE IS specification at %C\");\n+  gfc_error (\"Ssyntax error in TYPE IS specification at %C\");\n \n cleanup:\n   if (c != NULL)"}, {"sha": "d6df349532c3b0d1a23b7d52420479ddb54ac2a3", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -213,7 +213,7 @@ match gfc_match_decl_type_spec (gfc_typespec *, int);\n \n match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);\n-match gfc_match_formal_arglist (gfc_symbol *, int, int);\n+match gfc_match_formal_arglist (gfc_symbol *, int, int, bool = false);\n match gfc_match_procedure (void);\n match gfc_match_generic (void);\n match gfc_match_function_decl (void);\n@@ -274,7 +274,7 @@ match gfc_get_type_attr_spec (symbol_attribute *, char*);\n match gfc_match_structure_constructor (gfc_symbol *, gfc_expr **);\n match gfc_match_variable (gfc_expr **, int);\n match gfc_match_equiv_variable (gfc_expr **);\n-match gfc_match_actual_arglist (int, gfc_actual_arglist **);\n+match gfc_match_actual_arglist (int, gfc_actual_arglist **, bool = false);\n match gfc_match_literal_constant (gfc_expr **, int);\n \n /* expr.c -- FIXME: this one should be eliminated by moving the"}, {"sha": "d71221ca966a0afd945963cd028601ae1f04960b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1998,7 +1998,8 @@ enum ab_attribute\n   AB_ARRAY_OUTER_DEPENDENCY, AB_MODULE_PROCEDURE, AB_OACC_DECLARE_CREATE,\n   AB_OACC_DECLARE_COPYIN, AB_OACC_DECLARE_DEVICEPTR,\n   AB_OACC_DECLARE_DEVICE_RESIDENT, AB_OACC_DECLARE_LINK,\n-  AB_OMP_DECLARE_TARGET_LINK\n+  AB_OMP_DECLARE_TARGET_LINK, AB_PDT_KIND, AB_PDT_LEN, AB_PDT_TYPE,\n+  AB_PDT_TEMPLATE, AB_PDT_ARRAY, AB_PDT_STRING\n };\n \n static const mstring attr_bits[] =\n@@ -2062,6 +2063,12 @@ static const mstring attr_bits[] =\n     minit (\"OACC_DECLARE_DEVICE_RESIDENT\", AB_OACC_DECLARE_DEVICE_RESIDENT),\n     minit (\"OACC_DECLARE_LINK\", AB_OACC_DECLARE_LINK),\n     minit (\"OMP_DECLARE_TARGET_LINK\", AB_OMP_DECLARE_TARGET_LINK),\n+    minit (\"PDT_KIND\", AB_PDT_KIND),\n+    minit (\"PDT_LEN\", AB_PDT_LEN),\n+    minit (\"PDT_TYPE\", AB_PDT_TYPE),\n+    minit (\"PDT_TEMPLATE\", AB_PDT_TEMPLATE),\n+    minit (\"PDT_ARRAY\", AB_PDT_ARRAY),\n+    minit (\"PDT_STRING\", AB_PDT_STRING),\n     minit (NULL, -1)\n };\n \n@@ -2260,6 +2267,18 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_OACC_DECLARE_LINK, attr_bits);\n       if (attr->omp_declare_target_link)\n \tMIO_NAME (ab_attribute) (AB_OMP_DECLARE_TARGET_LINK, attr_bits);\n+      if (attr->pdt_kind)\n+\tMIO_NAME (ab_attribute) (AB_PDT_KIND, attr_bits);\n+      if (attr->pdt_len)\n+\tMIO_NAME (ab_attribute) (AB_PDT_LEN, attr_bits);\n+      if (attr->pdt_type)\n+\tMIO_NAME (ab_attribute) (AB_PDT_TYPE, attr_bits);\n+      if (attr->pdt_template)\n+\tMIO_NAME (ab_attribute) (AB_PDT_TEMPLATE, attr_bits);\n+      if (attr->pdt_array)\n+\tMIO_NAME (ab_attribute) (AB_PDT_ARRAY, attr_bits);\n+      if (attr->pdt_string)\n+\tMIO_NAME (ab_attribute) (AB_PDT_STRING, attr_bits);\n \n       mio_rparen ();\n \n@@ -2453,6 +2472,24 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_OACC_DECLARE_LINK:\n \t      attr->oacc_declare_link = 1;\n \t      break;\n+\t    case AB_PDT_KIND:\n+\t      attr->pdt_kind = 1;\n+\t      break;\n+\t    case AB_PDT_LEN:\n+\t      attr->pdt_len = 1;\n+\t      break;\n+\t    case AB_PDT_TYPE:\n+\t      attr->pdt_type = 1;\n+\t      break;\n+\t    case AB_PDT_TEMPLATE:\n+\t      attr->pdt_template = 1;\n+\t      break;\n+\t    case AB_PDT_ARRAY:\n+\t      attr->pdt_array = 1;\n+\t      break;\n+\t    case AB_PDT_STRING:\n+\t      attr->pdt_string = 1;\n+\t      break;\n \t    }\n \t}\n     }\n@@ -2779,6 +2816,9 @@ mio_component (gfc_component *c, int vtype)\n   mio_typespec (&c->ts);\n   mio_array_spec (&c->as);\n \n+  /* PDT templates store the expression for the kind of a component here.  */\n+  mio_expr (&c->kind_expr);\n+\n   mio_symbol_attribute (&c->attr);\n   if (c->ts.type == BT_CLASS)\n     c->attr.class_ok = 1;\n@@ -3998,7 +4038,24 @@ mio_full_f2k_derived (gfc_symbol *sym)\n     {\n       if (peek_atom () != ATOM_RPAREN)\n \t{\n+\t  gfc_namespace *ns;\n+\n \t  sym->f2k_derived = gfc_get_namespace (NULL, 0);\n+\n+\t  /* PDT templates make use of the mechanisms for formal args\n+\t     and so the parameter symbols are stored in the formal\n+\t     namespace.  Transfer the sym_root to f2k_derived and then\n+\t     free the formal namespace since it is uneeded.  */\n+\t  if (sym->attr.pdt_template && sym->formal && sym->formal->sym)\n+\t    {\n+\t      ns = sym->formal->sym->ns;\n+\t      sym->f2k_derived->sym_root = ns->sym_root;\n+\t      ns->sym_root = NULL;\n+\t      ns->refs++;\n+\t      gfc_free_namespace (ns);\n+\t      ns = NULL;\n+\t    }\n+\n \t  mio_f2k_derived (sym->f2k_derived);\n \t}\n       else"}, {"sha": "883141fe56565dc17437d081e9d10ae1f3bd2618", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1609,10 +1609,10 @@ match_actual_arg (gfc_expr **result)\n }\n \n \n-/* Match a keyword argument.  */\n+/* Match a keyword argument or type parameter spec list..  */\n \n static match\n-match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base)\n+match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base, bool pdt)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_actual_arglist *a;\n@@ -1630,12 +1630,28 @@ match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base)\n       goto cleanup;\n     }\n \n+  if (pdt)\n+    {\n+      if (gfc_match_char ('*') == MATCH_YES)\n+\t{\n+\t  actual->spec_type = SPEC_ASSUMED;\n+\t  goto add_name;\n+\t}\n+      else if (gfc_match_char (':') == MATCH_YES)\n+\t{\n+\t  actual->spec_type = SPEC_DEFERRED;\n+\t  goto add_name;\n+\t}\n+      else\n+\tactual->spec_type = SPEC_EXPLICIT;\n+    }\n+\n   m = match_actual_arg (&actual->expr);\n   if (m != MATCH_YES)\n     goto cleanup;\n \n   /* Make sure this name has not appeared yet.  */\n-\n+add_name:\n   if (name[0] != '\\0')\n     {\n       for (a = base; a; a = a->next)\n@@ -1737,10 +1753,15 @@ match_arg_list_function (gfc_actual_arglist *result)\n    list is assumed to allow keyword arguments because we don't know if\n    the symbol associated with the procedure has an implicit interface\n    or not.  We make sure keywords are unique. If sub_flag is set,\n-   we're matching the argument list of a subroutine.  */\n+   we're matching the argument list of a subroutine.\n+\n+   NOTE: An alternative use for this function is to match type parameter\n+   spec lists, which are so similar to actual argument lists that the\n+   machinery can be reused. This use is flagged by the optional argument\n+   'pdt'.  */\n \n match\n-gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n+gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp, bool pdt)\n {\n   gfc_actual_arglist *head, *tail;\n   int seen_keyword;\n@@ -1758,6 +1779,7 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n \n   if (gfc_match_char (')') == MATCH_YES)\n     return MATCH_YES;\n+\n   head = NULL;\n \n   matching_actual_arglist++;\n@@ -1772,8 +1794,13 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n \t  tail = tail->next;\n \t}\n \n-      if (sub_flag && gfc_match_char ('*') == MATCH_YES)\n+      if (sub_flag && !pdt && gfc_match_char ('*') == MATCH_YES)\n \t{\n+\t  if (pdt)\n+\t    {\n+\t      tail->spec_type = SPEC_ASSUMED;\n+\t      goto next;\n+\t    }\n \t  m = gfc_match_st_label (&label);\n \t  if (m == MATCH_NO)\n \t    gfc_error (\"Expected alternate return label at %C\");\n@@ -1788,11 +1815,27 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n \t  goto next;\n \t}\n \n+      if (pdt && !seen_keyword)\n+\t{\n+\t  if (gfc_match_char (':') == MATCH_YES)\n+\t    {\n+\t      tail->spec_type = SPEC_DEFERRED;\n+\t      goto next;\n+\t    }\n+\t  else if (gfc_match_char ('*') == MATCH_YES)\n+\t    {\n+\t      tail->spec_type = SPEC_ASSUMED;\n+\t      goto next;\n+\t    }\n+\t  else\n+\t    tail->spec_type = SPEC_EXPLICIT;\n+\t}\n+\n       /* After the first keyword argument is seen, the following\n \t arguments must also have keywords.  */\n       if (seen_keyword)\n \t{\n-\t  m = match_keyword_arg (tail, head);\n+\t  m = match_keyword_arg (tail, head, pdt);\n \n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n@@ -1813,7 +1856,7 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n \t  /* See if we have the first keyword argument.  */\n \t  if (m == MATCH_NO)\n \t    {\n-\t      m = match_keyword_arg (tail, head);\n+\t      m = match_keyword_arg (tail, head, false);\n \t      if (m == MATCH_YES)\n \t\tseen_keyword = 1;\n \t      if (m == MATCH_ERROR)\n@@ -2948,7 +2991,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n      expression here.  */\n   if (gfc_in_match_data ())\n     gfc_reduce_init_expr (e);\n- \n+\n   *result = e;\n   return MATCH_YES;\n }\n@@ -3662,7 +3705,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \timplicit_ns = gfc_current_ns;\n       else\n \timplicit_ns = sym->ns;\n-\t\n+\n       old_loc = gfc_current_locus;\n       if (gfc_match_member_sep (sym) == MATCH_YES\n \t  && sym->ts.type == BT_UNKNOWN"}, {"sha": "91d05b3e23bec6efe05571ddcb9dcc79d19bb073", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1130,6 +1130,89 @@ resolve_contained_functions (gfc_namespace *ns)\n }\n \n \n+\n+/* A Parameterized Derived Type constructor must contain values for\n+   the PDT KIND parameters or they must have a default initializer.\n+   Go through the constructor picking out the KIND expressions,\n+   storing them in 'param_list' and then call gfc_get_pdt_instance\n+   to obtain the PDT instance.  */\n+\n+static gfc_actual_arglist *param_list, *param_tail, *param;\n+\n+static bool\n+get_pdt_spec_expr (gfc_component *c, gfc_expr *expr)\n+{\n+  param = gfc_get_actual_arglist ();\n+  if (!param_list)\n+    param_list = param_tail = param;\n+  else\n+    {\n+      param_tail->next = param;\n+      param_tail = param_tail->next;\n+    }\n+\n+  param_tail->name = c->name;\n+  if (expr)\n+    param_tail->expr = gfc_copy_expr (expr);\n+  else if (c->initializer)\n+    param_tail->expr = gfc_copy_expr (c->initializer);\n+  else\n+    {\n+      param_tail->spec_type = SPEC_ASSUMED;\n+      if (c->attr.pdt_kind)\n+\t{\n+\t  gfc_error (\"The KIND parameter in the PDT constructor \"\n+\t\t     \"at %C has no value\");\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+static bool\n+get_pdt_constructor (gfc_expr *expr, gfc_constructor **constr,\n+\t\t     gfc_symbol *derived)\n+{\n+  gfc_constructor *cons;\n+  gfc_component *comp;\n+  bool t = true;\n+\n+  if (expr && expr->expr_type == EXPR_STRUCTURE)\n+    cons = gfc_constructor_first (expr->value.constructor);\n+  else if (constr)\n+    cons = *constr;\n+  gcc_assert (cons);\n+\n+  comp = derived->components;\n+\n+  for (; comp && cons; comp = comp->next, cons = gfc_constructor_next (cons))\n+    {\n+      if (cons->expr->expr_type == EXPR_STRUCTURE\n+\t  && comp->ts.type == BT_DERIVED)\n+\t{\n+\t  t = get_pdt_constructor (cons->expr, NULL, comp->ts.u.derived);\n+\t  if (!t)\n+\t    return t;\n+\t}\n+      else if (comp->ts.type == BT_DERIVED)\n+\t{\n+\t  t = get_pdt_constructor (NULL, &cons, comp->ts.u.derived);\n+\t  if (!t)\n+\t    return t;\n+\t}\n+     else if ((comp->attr.pdt_kind || comp->attr.pdt_len)\n+\t       && derived->attr.pdt_template)\n+\t{\n+\t  t = get_pdt_spec_expr (comp, cons->expr);\n+\t  if (!t)\n+\t    return t;\n+\t}\n+    }\n+  return t;\n+}\n+\n+\n static bool resolve_fl_derived0 (gfc_symbol *sym);\n static bool resolve_fl_struct (gfc_symbol *sym);\n \n@@ -1154,6 +1237,25 @@ resolve_structure_cons (gfc_expr *expr, int init)\n         resolve_fl_derived0 (expr->ts.u.derived);\n       else\n         resolve_fl_struct (expr->ts.u.derived);\n+\n+      /* If this is a Parameterized Derived Type template, find the\n+\t instance corresponding to the PDT kind parameters.  */\n+      if (expr->ts.u.derived->attr.pdt_template)\n+\t{\n+\t  param_list = NULL;\n+\t  t = get_pdt_constructor (expr, NULL, expr->ts.u.derived);\n+\t  if (!t)\n+\t    return t;\n+\t  gfc_get_pdt_instance (param_list, &expr->ts.u.derived, NULL);\n+\n+\t  expr->param_list = gfc_copy_actual_arglist (param_list);\n+\n+\t  if (param_list)\n+\t    gfc_free_actual_arglist (param_list);\n+\n+\t  if (!expr->ts.u.derived->attr.pdt_type)\n+\t    return false;\n+\t}\n     }\n \n   cons = gfc_constructor_first (expr->value.constructor);\n@@ -13547,7 +13649,9 @@ resolve_component (gfc_component *c, gfc_symbol *sym)\n     }\n \n   /* Add the hidden deferred length field.  */\n-  if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function\n+  if (c->ts.type == BT_CHARACTER\n+      && (c->ts.deferred || c->attr.pdt_string)\n+      && !c->attr.function\n       && !sym->attr.is_class)\n     {\n       char name[GFC_MAX_SYMBOL_LEN+9];\n@@ -13647,6 +13751,7 @@ resolve_component (gfc_component *c, gfc_symbol *sym)\n     return false;\n \n   if (c->initializer && !sym->attr.vtype\n+      && !c->attr.pdt_kind && !c->attr.pdt_len\n       && !gfc_check_assign_symbol (sym, c, c->initializer))\n     return false;\n \n@@ -14276,6 +14381,15 @@ resolve_symbol (gfc_symbol *sym)\n       return;\n     }\n \n+  if (sym->attr.dummy && sym->ts.type == BT_DERIVED\n+      && sym->ts.u.derived->attr.pdt_type\n+      && gfc_spec_list_type (sym->param_list, NULL) == SPEC_DEFERRED)\n+    {\n+      gfc_error (\"%qs at %L cannot have DEFERRED type parameters because \"\n+\t\t \"it is a dummy argument\", sym->name, &sym->declared_at);\n+      return;\n+    }\n+\n   if (sym->attr.value && sym->ts.type == BT_CHARACTER)\n     {\n       gfc_charlen *cl = sym->ts.u.cl;"}, {"sha": "61ee94bdd6619d0c342d025a6fff72b8cd8181f3", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1106,6 +1106,32 @@ gfc_add_optional (symbol_attribute *attr, locus *where)\n   return check_conflict (attr, NULL, where);\n }\n \n+bool\n+gfc_add_kind (symbol_attribute *attr, locus *where)\n+{\n+  if (attr->pdt_kind)\n+    {\n+      duplicate_attr (\"KIND\", where);\n+      return false;\n+    }\n+\n+  attr->pdt_kind = 1;\n+  return check_conflict (attr, NULL, where);\n+}\n+\n+bool\n+gfc_add_len (symbol_attribute *attr, locus *where)\n+{\n+  if (attr->pdt_len)\n+    {\n+      duplicate_attr (\"LEN\", where);\n+      return false;\n+    }\n+\n+  attr->pdt_len = 1;\n+  return check_conflict (attr, NULL, where);\n+}\n+\n \n bool\n gfc_add_pointer (symbol_attribute *attr, locus *where)\n@@ -2447,6 +2473,10 @@ free_components (gfc_component *p)\n \n       gfc_free_array_spec (p->as);\n       gfc_free_expr (p->initializer);\n+      if (p->kind_expr)\n+\tgfc_free_expr (p->kind_expr);\n+      if (p->param_list)\n+\tgfc_free_actual_arglist (p->param_list);\n       free (p->tb);\n \n       free (p);\n@@ -2929,6 +2959,9 @@ gfc_free_symbol (gfc_symbol *sym)\n \n   set_symbol_common_block (sym, NULL);\n \n+  if (sym->param_list)\n+    gfc_free_actual_arglist (sym->param_list);\n+\n   free (sym);\n }\n \n@@ -3091,7 +3124,25 @@ gfc_find_sym_tree (const char *name, gfc_namespace *ns, int parent_flag,\n     }\n   while (ns != NULL);\n \n+  if (gfc_current_state() == COMP_DERIVED\n+      && gfc_current_block ()->attr.pdt_template)\n+    {\n+      gfc_symbol *der = gfc_current_block ();\n+      for (; der; der = gfc_get_derived_super_type (der))\n+\t{\n+\t  if (der->f2k_derived && der->f2k_derived->sym_root)\n+\t    {\n+\t      st = gfc_find_symtree (der->f2k_derived->sym_root, name);\n+\t      if (st)\n+\t\tbreak;\n+\t    }\n+\t}\n+      *result = st;\n+      return 0;\n+    }\n+\n   *result = NULL;\n+\n   return 0;\n }\n \n@@ -3890,6 +3941,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   ns->refs--;\n   if (ns->refs > 0)\n     return;\n+\n   gcc_assert (ns->refs == 0);\n \n   gfc_free_statements (ns->code);"}, {"sha": "2b06903bffd1ca0add20bb4f3795e243d2dd0f65", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 297, "deletions": 1, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -8073,7 +8073,10 @@ gfc_caf_is_dealloc_only (int caf_mode)\n    function for the functions named in this enum.  */\n \n enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP,\n-      COPY_ALLOC_COMP, COPY_ONLY_ALLOC_COMP, REASSIGN_CAF_COMP};\n+      COPY_ALLOC_COMP, COPY_ONLY_ALLOC_COMP, REASSIGN_CAF_COMP,\n+      ALLOCATE_PDT_COMP, DEALLOCATE_PDT_COMP, CHECK_PDT_DUMMY};\n+\n+static gfc_actual_arglist *pdt_param_list;\n \n static tree\n structure_alloc_comps (gfc_symbol * der_type, tree decl,\n@@ -8735,6 +8738,255 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  break;\n \n+\tcase ALLOCATE_PDT_COMP:\n+\n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n+\n+\t  /* Set the PDT KIND and LEN fields.  */\n+\t  if (c->attr.pdt_kind || c->attr.pdt_len)\n+\t    {\n+\t      gfc_se tse;\n+\t      gfc_expr *c_expr = NULL;\n+\t      gfc_actual_arglist *param = pdt_param_list;\n+\t      gfc_init_se (&tse, NULL);\n+\t      for (; param; param = param->next)\n+\t\tif (!strcmp (c->name, param->name))\n+\t\t  c_expr = param->expr;\n+\n+\t      if (!c_expr)\n+\t\tc_expr = c->initializer;\n+\n+\t      if (c_expr)\n+\t\t{\n+\t\t  gfc_conv_expr_type (&tse, c_expr, TREE_TYPE (comp));\n+\t\t  gfc_add_modify (&fnblock, comp, tse.expr);\n+\t\t}\n+\t    }\n+\n+\t  if (c->attr.pdt_string)\n+\t    {\n+\t      gfc_se tse;\n+\t      gfc_init_se (&tse, NULL);\n+\t      tree strlen;\n+\t      /* Convert the parameterized string length to its value. The\n+\t\t string length is stored in a hidden field in the same way as\n+\t\t deferred string lengths.  */\n+\t      gfc_insert_parameter_exprs (c->ts.u.cl->length, pdt_param_list);\n+\t      if (gfc_deferred_strlen (c, &strlen) && strlen != NULL_TREE)\n+\t\t{\n+\t\t  gfc_conv_expr_type (&tse, c->ts.u.cl->length,\n+\t\t\t\t      TREE_TYPE (strlen));\n+\t\t  strlen = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t    TREE_TYPE (strlen),\n+\t\t\t\t\t    decl, strlen, NULL_TREE);\n+\t\t  gfc_add_modify (&fnblock, strlen, tse.expr);\n+\t\t  c->ts.u.cl->backend_decl = strlen;\n+\t\t}\n+\t      /* Scalar parameterizied strings can be allocated now.  */\n+\t      if (!c->as)\n+\t\t{\n+\t\t  tmp = fold_convert (gfc_array_index_type, strlen);\n+\t\t  tmp = size_of_string_in_bytes (c->ts.kind, tmp);\n+\t\t  tmp = gfc_evaluate_now (tmp, &fnblock);\n+\t\t  tmp = gfc_call_malloc (&fnblock, TREE_TYPE (comp), tmp);\n+\t\t  gfc_add_modify (&fnblock, comp, tmp);\n+\t\t}\n+\t    }\n+\n+\t  /* Allocate paramterized arrays of parameterized derived types.  */\n+\t  if (!(c->attr.pdt_array && c->as && c->as->type == AS_EXPLICIT)\n+\t      && !((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t\t   && (c->ts.u.derived && c->ts.u.derived->attr.pdt_type)))\n+\t    continue;\n+\n+\t  if (c->ts.type == BT_CLASS)\n+\t    comp = gfc_class_data_get (comp);\n+\n+\t  if (c->attr.pdt_array)\n+\t    {\n+\t      gfc_se tse;\n+\t      int i;\n+\t      tree size = gfc_index_one_node;\n+\t      tree offset = gfc_index_zero_node;\n+\t      tree lower, upper;\n+\t      gfc_expr *e;\n+\n+\t      /* This chunk takes the expressions for 'lower' and 'upper'\n+\t\t in the arrayspec and substitutes in the expressions for\n+\t\t the parameters from 'pdt_param_list'. The descriptor\n+\t\t fields can then be filled from the values so obtained.  */\n+\t      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)));\n+\t      for (i = 0; i < c->as->rank; i++)\n+\t\t{\n+\t\t  gfc_init_se (&tse, NULL);\n+\t\t  e = gfc_copy_expr (c->as->lower[i]);\n+\t\t  gfc_insert_parameter_exprs (e, pdt_param_list);\n+\t\t  gfc_conv_expr_type (&tse, e, gfc_array_index_type);\n+\t\t  gfc_free_expr (e);\n+\t\t  lower = tse.expr;\n+\t\t  gfc_conv_descriptor_lbound_set (&fnblock, comp,\n+\t\t\t\t\t\t  gfc_rank_cst[i],\n+\t\t\t\t\t\t  lower);\n+\t\t  e = gfc_copy_expr (c->as->upper[i]);\n+\t\t  gfc_insert_parameter_exprs (e, pdt_param_list);\n+\t\t  gfc_conv_expr_type (&tse, e, gfc_array_index_type);\n+\t\t  gfc_free_expr (e);\n+\t\t  upper = tse.expr;\n+\t\t  gfc_conv_descriptor_ubound_set (&fnblock, comp,\n+\t\t\t\t\t\t  gfc_rank_cst[i],\n+\t\t\t\t\t\t  upper);\n+\t\t  gfc_conv_descriptor_stride_set (&fnblock, comp,\n+\t\t\t\t\t\t  gfc_rank_cst[i],\n+\t\t\t\t\t\t  size);\n+\t\t  size = gfc_evaluate_now (size, &fnblock);\n+\t\t  offset = fold_build2_loc (input_location,\n+\t\t\t\t\t    MINUS_EXPR,\n+\t\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t\t    offset, size);\n+\t\t  offset = gfc_evaluate_now (offset, &fnblock);\n+\t\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t upper, lower);\n+\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t tmp, gfc_index_one_node);\n+\t\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, size, tmp);\n+\t\t}\n+\t      gfc_conv_descriptor_offset_set (&fnblock, comp, offset);\n+\t      if (c->ts.type == BT_CLASS)\n+\t\t{\n+\t\t  tmp = gfc_get_vptr_from_expr (comp);\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t\t    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t\t  tmp = gfc_vptr_size_get (tmp);\n+\t\t}\n+\t      else\n+\t\ttmp = TYPE_SIZE_UNIT (gfc_get_element_type (ctype));\n+\t      tmp = fold_convert (gfc_array_index_type, tmp);\n+\t      size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t      gfc_array_index_type, size, tmp);\n+\t      size = gfc_evaluate_now (size, &fnblock);\n+\t      tmp = gfc_call_malloc (&fnblock, NULL, size);\n+\t      gfc_conv_descriptor_data_set (&fnblock, comp, tmp);\n+\t      tmp = gfc_conv_descriptor_dtype (comp);\n+\t      gfc_add_modify (&fnblock, tmp, gfc_get_dtype (ctype));\n+\t    }\n+\n+\t  /* Recurse in to PDT components.  */\n+\t  if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t      && c->ts.u.derived && c->ts.u.derived->attr.pdt_type)\n+\t    {\n+\t      bool is_deferred = false;\n+\t      gfc_actual_arglist *tail = c->param_list;\n+\n+\t      for (; tail; tail = tail->next)\n+\t\tif (!tail->expr)\n+\t\t  is_deferred = true;\n+\n+\t      tail = is_deferred ? pdt_param_list : c->param_list;\n+\t      tmp = gfc_allocate_pdt_comp (c->ts.u.derived, comp,\n+\t\t\t\t\t   c->as ? c->as->rank : 0,\n+\t\t\t\t\t   tail);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\n+\t  break;\n+\n+\tcase DEALLOCATE_PDT_COMP:\n+\t  /* Deallocate array or parameterized string length components\n+\t     of parameterized derived types.  */\n+\t  if (!(c->attr.pdt_array && c->as && c->as->type == AS_EXPLICIT)\n+\t      && !c->attr.pdt_string\n+\t      && !((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t\t   && (c->ts.u.derived && c->ts.u.derived->attr.pdt_type)))\n+\t    continue;\n+\n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n+\t  if (c->ts.type == BT_CLASS)\n+\t    comp = gfc_class_data_get (comp);\n+\n+\t  /* Recurse in to PDT components.  */\n+\t  if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t      && c->ts.u.derived && c->ts.u.derived->attr.pdt_type)\n+\t    {\n+\t      tmp = gfc_deallocate_pdt_comp (c->ts.u.derived, comp,\n+\t\t\t\t\t     c->as ? c->as->rank : 0);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\n+\t  if (c->attr.pdt_array)\n+\t    {\n+\t      tmp = gfc_conv_descriptor_data_get (comp);\n+\t      tmp = gfc_call_free (tmp);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      gfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n+\t    }\n+\t  else if (c->attr.pdt_string)\n+\t    {\n+\t      tmp = gfc_call_free (comp);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      tmp = fold_convert (TREE_TYPE (comp), null_pointer_node);\n+\t      gfc_add_modify (&fnblock, comp, tmp);\n+\t    }\n+\n+\t  break;\n+\n+\tcase CHECK_PDT_DUMMY:\n+\n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n+\t  if (c->ts.type == BT_CLASS)\n+\t    comp = gfc_class_data_get (comp);\n+\n+\t  /* Recurse in to PDT components.  */\n+\t  if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t      && c->ts.u.derived && c->ts.u.derived->attr.pdt_type)\n+\t    {\n+\t      tmp = gfc_check_pdt_dummy (c->ts.u.derived, comp,\n+\t\t\t\t\t c->as ? c->as->rank : 0,\n+\t\t\t\t\t pdt_param_list);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t    }\n+\n+\t  if (!c->attr.pdt_len)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      gfc_se tse;\n+\t      gfc_expr *c_expr = NULL;\n+\t      gfc_actual_arglist *param = pdt_param_list;\n+\n+\t      gfc_init_se (&tse, NULL);\n+\t      for (; param; param = param->next)\n+\t\tif (!strcmp (c->name, param->name))\n+\t\t  c_expr = param->expr;\n+\n+\t      if (c_expr)\n+\t\t{\n+\t\t  tree error, cond, cname;\n+\t\t  gfc_conv_expr_type (&tse, c_expr, TREE_TYPE (comp));\n+\t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  comp, tse.expr);\n+\t\t  cname = gfc_build_cstring_const (c->name);\n+\t\t  cname = gfc_build_addr_expr (pchar_type_node, cname);\n+\t\t  error = gfc_trans_runtime_error (true, NULL,\n+\t\t\t\t\t\t   \"The value of the PDT LEN \"\n+\t\t\t\t\t\t   \"parameter '%s' does not \"\n+\t\t\t\t\t\t   \"agree with that in the \"\n+\t\t\t\t\t\t   \"dummy declaration\",\n+\t\t\t\t\t\t   cname);\n+\t\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t void_type_node, cond, error,\n+\t\t\t\t\t build_empty_stmt (input_location));\n+\t\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t\t}\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t  break;\n@@ -8814,6 +9066,50 @@ gfc_copy_only_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n }\n \n \n+/* Recursively traverse an object of paramterized derived type, generating\n+   code to allocate parameterized components.  */\n+\n+tree\n+gfc_allocate_pdt_comp (gfc_symbol * der_type, tree decl, int rank,\n+\t\t       gfc_actual_arglist *param_list)\n+{\n+  tree res;\n+  gfc_actual_arglist *old_param_list = pdt_param_list;\n+  pdt_param_list = param_list;\n+  res = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n+\t\t\t       ALLOCATE_PDT_COMP, 0);\n+  pdt_param_list = old_param_list;\n+  return res;\n+}\n+\n+/* Recursively traverse an object of paramterized derived type, generating\n+   code to deallocate parameterized components.  */\n+\n+tree\n+gfc_deallocate_pdt_comp (gfc_symbol * der_type, tree decl, int rank)\n+{\n+  return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n+\t\t\t\tDEALLOCATE_PDT_COMP, 0);\n+}\n+\n+\n+/* Recursively traverse a dummy of paramterized derived type to check the\n+   values of LEN parameters.  */\n+\n+tree\n+gfc_check_pdt_dummy (gfc_symbol * der_type, tree decl, int rank,\n+\t\t     gfc_actual_arglist *param_list)\n+{\n+  tree res;\n+  gfc_actual_arglist *old_param_list = pdt_param_list;\n+  pdt_param_list = param_list;\n+  res = structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n+\t\t\t       CHECK_PDT_DUMMY, 0);\n+  pdt_param_list = old_param_list;\n+  return res;\n+}\n+\n+\n /* Returns the value of LBOUND for an expression.  This could be broken out\n    from gfc_conv_intrinsic_bound but this seemed to be simpler.  This is\n    called by gfc_alloc_allocatable_for_assignment.  */"}, {"sha": "3cc08b346ff09fb113db2aaf5cfc4c8c0ca7abae", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -59,6 +59,10 @@ tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int, int);\n \n tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n \n+tree gfc_allocate_pdt_comp (gfc_symbol *, tree, int, gfc_actual_arglist *);\n+tree gfc_deallocate_pdt_comp (gfc_symbol *, tree, int);\n+tree gfc_check_pdt_dummy (gfc_symbol *, tree, int, gfc_actual_arglist *);\n+\n tree gfc_alloc_allocatable_for_assignment (gfc_loopinfo*, gfc_expr*, gfc_expr*);\n \n /* Add initialization for deferred arrays.  */"}, {"sha": "30477c27994641a42f3b64abc3b75ec0df86cf25", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1483,6 +1483,21 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t}\n     }\n \n+  /* PDT parameterized array components and string_lengths must have the\n+     'len' parameters substituted for the expressions appearing in the\n+     declaration of the entity and memory allocated/deallocated.  */\n+  if ((sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n+      && sym->param_list != NULL\n+      && !(sym->attr.host_assoc || sym->attr.use_assoc || sym->attr.dummy))\n+    gfc_defer_symbol_init (sym);\n+\n+  /* Dummy PDT 'len' parameters should be checked when they are explicit.  */\n+  if ((sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n+      && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+      && sym->param_list != NULL\n+      && sym->attr.dummy)\n+    gfc_defer_symbol_init (sym);\n+\n   /* All deferred character length procedures need to retain the backend\n      decl, which is a pointer to the character length in the caller's\n      namespace and to declare a local character length.  */\n@@ -4159,6 +4174,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n   gfc_formal_arglist *f;\n   stmtblock_t tmpblock;\n   bool seen_trans_deferred_array = false;\n+  bool is_pdt_type = false;\n   tree tmp = NULL;\n   gfc_expr *e;\n   gfc_se se;\n@@ -4269,6 +4285,68 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n       if (sym->assoc)\n \tcontinue;\n \n+      if (sym->ts.type == BT_DERIVED\n+\t  && sym->ts.u.derived\n+\t  && sym->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  is_pdt_type = true;\n+\t  gfc_init_block (&tmpblock);\n+\t  if (!(sym->attr.dummy\n+\t\t|| sym->attr.pointer\n+\t\t|| sym->attr.allocatable))\n+\t    {\n+\t      tmp = gfc_allocate_pdt_comp (sym->ts.u.derived,\n+\t\t\t\t\t   sym->backend_decl,\n+\t\t\t\t\t   sym->as ? sym->as->rank : 0,\n+\t\t\t\t\t   sym->param_list);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\t      tmp = gfc_deallocate_pdt_comp (sym->ts.u.derived,\n+\t\t\t\t\t     sym->backend_decl,\n+\t\t\t\t\t     sym->as ? sym->as->rank : 0);\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), tmp);\n+\t    }\n+\t  else if (sym->attr.dummy)\n+\t    {\n+\t      tmp = gfc_check_pdt_dummy (sym->ts.u.derived,\n+\t\t\t\t\t sym->backend_decl,\n+\t\t\t\t\t sym->as ? sym->as->rank : 0,\n+\t\t\t\t\t sym->param_list);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), NULL);\n+\t    }\n+\t}\n+      else if (sym->ts.type == BT_CLASS\n+\t       && CLASS_DATA (sym)->ts.u.derived\n+\t       && CLASS_DATA (sym)->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  gfc_component *data = CLASS_DATA (sym);\n+\t  is_pdt_type = true;\n+\t  gfc_init_block (&tmpblock);\n+\t  if (!(sym->attr.dummy\n+\t\t|| CLASS_DATA (sym)->attr.pointer\n+\t\t|| CLASS_DATA (sym)->attr.allocatable))\n+\t    {\n+\t      tmp = gfc_class_data_get (sym->backend_decl);\n+\t      tmp = gfc_allocate_pdt_comp (data->ts.u.derived, tmp,\n+\t\t\t\t\t   data->as ? data->as->rank : 0,\n+\t\t\t\t\t   sym->param_list);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\t      tmp = gfc_class_data_get (sym->backend_decl);\n+\t      tmp = gfc_deallocate_pdt_comp (data->ts.u.derived, tmp,\n+\t\t\t\t\t     data->as ? data->as->rank : 0);\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), tmp);\n+\t    }\n+\t  else if (sym->attr.dummy)\n+\t    {\n+\t      tmp = gfc_class_data_get (sym->backend_decl);\n+\t      tmp = gfc_check_pdt_dummy (data->ts.u.derived, tmp,\n+\t\t\t\t\t data->as ? data->as->rank : 0,\n+\t\t\t\t\t sym->param_list);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), NULL);\n+\t    }\n+\t}\n+\n       if (sym->attr.subref_array_pointer\n \t  && GFC_DECL_SPAN (sym->backend_decl)\n \t  && !TREE_STATIC (GFC_DECL_SPAN (sym->backend_decl)))\n@@ -4601,7 +4679,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t  gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock),\n \t\t\t\tNULL_TREE);\n \t}\n-      else if (!(UNLIMITED_POLY(sym)))\n+      else if (!(UNLIMITED_POLY(sym)) && !is_pdt_type)\n \tgcc_unreachable ();\n     }\n "}, {"sha": "b3104586ca6841122c1e6b637abaafe6ea9a9ebd", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -7286,7 +7286,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n     {\n       if (cm->attr.allocatable && expr->expr_type == EXPR_NULL)\n  \tgfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n-      else if (cm->attr.allocatable)\n+      else if (cm->attr.allocatable || cm->attr.pdt_array)\n \t{\n \t  tmp = gfc_trans_alloc_subarray_assign (dest, cm, expr);\n \t  gfc_add_expr_to_block (&block, tmp);"}, {"sha": "6a407f92614e6c149fe8c0faa9a7fd8f386d454f", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -5545,6 +5545,7 @@ gfc_trans_allocate (gfc_code * code)\n   bool needs_caf_sync, caf_refs_comp;\n   gfc_symtree *newsym = NULL;\n   symbol_attribute caf_attr;\n+  gfc_actual_arglist *param_list;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n@@ -6326,6 +6327,35 @@ gfc_trans_allocate (gfc_code * code)\n \t    gfc_free_expr (rhs);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n+      /* Set KIND and LEN PDT components and allocate those that are\n+         parameterized.  */\n+      else if (expr->ts.type == BT_DERIVED\n+\t       && expr->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  if (code->expr3 && code->expr3->param_list)\n+\t    param_list = code->expr3->param_list;\n+\t  else if (expr->param_list)\n+\t    param_list = expr->param_list;\n+\t  else\n+\t    param_list = expr->symtree->n.sym->param_list;\n+\t  tmp = gfc_allocate_pdt_comp (expr->ts.u.derived, se.expr,\n+\t\t\t\t       expr->rank, param_list);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      /* Ditto for CLASS expressions.  */\n+      else if (expr->ts.type == BT_CLASS\n+\t       && CLASS_DATA (expr)->ts.u.derived->attr.pdt_type)\n+\t{\n+\t  if (code->expr3 && code->expr3->param_list)\n+\t    param_list = code->expr3->param_list;\n+\t  else if (expr->param_list)\n+\t    param_list = expr->param_list;\n+\t  else\n+\t    param_list = expr->symtree->n.sym->param_list;\n+\t  tmp = gfc_allocate_pdt_comp (CLASS_DATA (expr)->ts.u.derived,\n+\t\t\t\t       se.expr, expr->rank, param_list);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n       else if (code->expr3 && code->expr3->mold\n \t       && code->expr3->ts.type == BT_CLASS)\n \t{\n@@ -6533,6 +6563,21 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n+      /* Deallocate PDT components that are parameterized.  */\n+      tmp = NULL;\n+      if (expr->ts.type == BT_DERIVED\n+\t  && expr->ts.u.derived->attr.pdt_type\n+\t  && expr->symtree->n.sym->param_list)\n+\ttmp = gfc_deallocate_pdt_comp (expr->ts.u.derived, se.expr, expr->rank);\n+      else if (expr->ts.type == BT_CLASS\n+\t       && CLASS_DATA (expr)->ts.u.derived->attr.pdt_type\n+\t       && expr->symtree->n.sym->param_list)\n+\ttmp = gfc_deallocate_pdt_comp (CLASS_DATA (expr)->ts.u.derived,\n+\t\t\t\t       se.expr, expr->rank);\n+\n+      if (tmp)\n+\tgfc_add_expr_to_block (&block, tmp);\n+\n       if (flag_coarray == GFC_FCOARRAY_LIB\n \t  || flag_coarray == GFC_FCOARRAY_SINGLE)\n \t{"}, {"sha": "061222f5083476837c4f161bcca34479b1044582", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -2441,6 +2441,8 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n   gfc_namespace *ns;\n   tree tmp;\n \n+  gcc_assert (!derived->attr.pdt_template);\n+\n   if (derived->attr.unlimited_polymorphic\n       || (flag_coarray == GFC_FCOARRAY_LIB\n \t  && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n@@ -2635,7 +2637,8 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n         field_type = c->ts.u.derived->backend_decl;\n       else\n \t{\n-\t  if (c->ts.type == BT_CHARACTER && !c->ts.deferred)\n+\t  if (c->ts.type == BT_CHARACTER\n+\t      && !c->ts.deferred && !c->attr.pdt_string)\n \t    {\n \t      /* Evaluate the string length.  */\n \t      gfc_conv_const_charlen (c->ts.u.cl);\n@@ -2652,7 +2655,7 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n          required.  */\n       if ((c->attr.dimension || c->attr.codimension) && !c->attr.proc_pointer )\n \t{\n-\t  if (c->attr.pointer || c->attr.allocatable)\n+\t  if (c->attr.pointer || c->attr.allocatable || c->attr.pdt_array)\n \t    {\n \t      enum gfc_array_kind akind;\n \t      if (c->attr.pointer)\n@@ -2673,7 +2676,7 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n \t\t\t\t\t\t    PACKED_STATIC,\n \t\t\t\t\t\t    !c->attr.target);\n \t}\n-      else if ((c->attr.pointer || c->attr.allocatable)\n+      else if ((c->attr.pointer || c->attr.allocatable || c->attr.pdt_string)\n \t       && !c->attr.proc_pointer\n \t       && !(unlimited_entity && c == derived->components))\n \tfield_type = build_pointer_type (field_type);"}, {"sha": "cb6a57f600186728ccaf83d414d9f5b1f92eed69", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -2302,7 +2302,8 @@ gfc_deferred_strlen (gfc_component *c, tree *decl)\n {\n   char name[GFC_MAX_SYMBOL_LEN+9];\n   gfc_component *strlen;\n-  if (!(c->ts.type == BT_CHARACTER && c->ts.deferred))\n+  if (!(c->ts.type == BT_CHARACTER\n+\t&& (c->ts.deferred || c->attr.pdt_string)))\n     return false;\n   sprintf (name, \"_%s_length\", c->name);\n   for (strlen = c; strlen; strlen = strlen->next)"}, {"sha": "cdbb5557011becb88014e1ee5f18c508b86f666f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -1,3 +1,11 @@\n+2017-09-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/pdt_1.f03 : New test.\n+\t* gfortran.dg/pdt_2.f03 : New test.\n+\t* gfortran.dg/pdt_3.f03 : New test.\n+\t* gfortran.dg/pdt_4.f03 : New test.\n+\t* gfortran.dg/pdt_5.f03 : New test.\n+\n 2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/pr81988.c: New test."}, {"sha": "ac57633978b26547b244d52b02c9534b6e8ac1be", "filename": "gcc/testsuite/gfortran.dg/pdt_1.f03", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_1.f03?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=all\" }\n+!\n+! Basic check of Parameterized Derived Types.\n+!\n+! -fcheck=all is used here to ensure that when the parameter\n+! 'b' of the dummy in 'foo' is assumed, there is no error.\n+! Likewise in 'bar' and 'foobar', when 'b' has the correct\n+! explicit value.\n+!\n+  implicit none\n+  integer, parameter :: ftype = kind(0.0e0)\n+  integer :: pdt_len = 4\n+  integer :: i\n+  type :: mytype (a,b)\n+    integer, kind :: a = kind(0.0d0)\n+    integer, LEN :: b\n+    integer :: i\n+    real(kind = a) :: d(b, b)\n+    character (len = b*b) :: chr\n+  end type\n+\n+  type(mytype(b=4)) :: z(2)\n+  type(mytype(ftype, pdt_len)) :: z2\n+\n+  z(1)%i = 1\n+  z(2)%i = 2\n+  z(1)%d = reshape ([(real(i), i = 1, 16)],[4,4])\n+  z(2)%d = 10*z(1)%d\n+  z(1)%chr = \"hello pdt\"\n+  z(2)%chr = \"goodbye pdt\"\n+\n+  z2%d = z(1)%d * 10 - 1\n+  z2%chr = \"scalar pdt\"\n+\n+  call foo (z)\n+  call bar (z)\n+  call foobar (z2)\n+contains\n+  elemental subroutine foo (arg)\n+    type(mytype(8,*)), intent(in) :: arg\n+    if (arg%i .eq. 1) then\n+      if (trim (arg%chr) .ne. \"hello pdt\") error stop\n+      if (int (sum (arg%d)) .ne. 136) error stop\n+    else if (arg%i .eq. 2 ) then\n+      if (trim (arg%chr) .ne. \"goodbye pdt\") error stop\n+      if (int (sum (arg%d)) .ne. 1360) error stop\n+    else\n+      error stop\n+    end if\n+  end subroutine\n+  subroutine bar (arg)\n+    type(mytype(b=4)) :: arg(:)\n+    if (int (sum (arg(1)%d)) .ne. 136) call abort\n+    if (trim (arg(2)%chr) .ne. \"goodbye pdt\") call abort\n+  end subroutine\n+  subroutine foobar (arg)\n+    type(mytype(ftype, pdt_len)) :: arg\n+    if (int (sum (arg%d)) .ne. 1344) call abort\n+    if (trim (arg%chr) .ne. \"scalar pdt\") call abort\n+  end subroutine\n+end"}, {"sha": "f34a9b7f25811366f23ba95e105ab8ddea82a573", "filename": "gcc/testsuite/gfortran.dg/pdt_2.f03", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_2.f03?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=all\" }\n+! { dg-shouldfail \"value of the PDT LEN parameter\" }\n+!\n+! Reduced version of pdt_1.f03 to check that an incorrect\n+! value for the parameter 'b' in the dummy is picked up.\n+!\n+  implicit none\n+  integer, parameter :: ftype = kind(0.0e0)\n+  integer :: pdt_len = 4\n+  integer :: i\n+  type :: mytype (a,b)\n+    integer, kind :: a = kind(0.0d0)\n+    integer, LEN :: b\n+    integer :: i\n+    real(kind = a) :: d(b, b)\n+    character (len = b*b) :: chr\n+  end type\n+\n+  type(mytype(ftype, pdt_len)) :: z2\n+  call foobar (z2)\n+contains\n+  subroutine foobar (arg)\n+    type(mytype(ftype, 8)) :: arg\n+    print *, arg%i\n+  end subroutine\n+end"}, {"sha": "a097149aab7ef670cbb877e0a469a4790f8a5718", "filename": "gcc/testsuite/gfortran.dg/pdt_3.f03", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_3.f03?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -0,0 +1,79 @@\n+! { dg-do run }\n+!\n+! Check PDT type extension and simple OOP.\n+!\n+module vars\n+  integer :: d_dim = 4\n+  integer :: mat_dim = 256\n+  integer, parameter :: ftype = kind(0.0d0)\n+end module\n+\n+  use vars\n+  implicit none\n+  integer :: i\n+  type :: mytype (a,b)\n+    integer, kind :: a = kind(0.0e0)\n+    integer, LEN :: b = 4\n+    integer :: i\n+    real(kind = a) :: d(b, b)\n+  end type\n+\n+  type, extends(mytype) :: thytype(h)\n+    integer, kind :: h\n+    integer(kind = h) :: j\n+  end type\n+\n+  type x (q, r, s)\n+    integer, kind :: q\n+    integer, kind :: r\n+    integer, LEN :: s\n+    integer(kind = q) :: idx_mat(2,2)  ! check these do not get treated as pdt_arrays.\n+    type (mytype (b=s)) :: mat1\n+    type (mytype (b=s*2)) :: mat2\n+  end type x\n+\n+  real, allocatable :: matrix (:,:)\n+  type(thytype(ftype, 4, 4)) :: w\n+  type(x(8,4,mat_dim)) :: q\n+  class(mytype(ftype, :)), allocatable :: cz\n+\n+  w%d = reshape ([(real(i), i = 1, d_dim*d_dim)],[d_dim,d_dim])\n+\n+! Make sure that the type extension is ordering the parameters correctly.\n+  if (w%a .ne. ftype) call abort\n+  if (w%b .ne. 4) call abort\n+  if (w%h .ne. 4) call abort\n+  if (size (w%d) .ne. 16) call abort\n+  if (int (w%d(2,4)) .ne. 14) call abort\n+  if (kind (w%j) .ne. w%h) call abort\n+\n+! As a side issue, ensure PDT components are OK\n+  if (q%mat1%b .ne. q%s) call abort\n+  if (q%mat2%b .ne. q%s*2) call abort\n+  if (size (q%mat1%d) .ne. mat_dim**2) call abort\n+  if (size (q%mat2%d) .ne. 4*mat_dim**2) call abort\n+\n+! Now check some basic OOP with PDTs\n+  matrix = w%d\n+\n+! TODO - for some reason, using w%d directly in the source causes a seg fault.\n+  allocate (cz, source = mytype(ftype, d_dim, 0, matrix))\n+  select type (cz)\n+    type is (mytype(ftype, *))\n+      if (int (sum (cz%d)) .ne. 136) call abort\n+    type is (thytype(ftype, *, 8))\n+      call abort\n+  end select\n+  deallocate (cz)\n+\n+  allocate (thytype(ftype, d_dim*2, 8) :: cz)\n+  cz%d = reshape ([(i*10, i = 1, cz%b**2)], [cz%b,cz%b])\n+  select type (cz)\n+    type is (mytype(ftype, *))\n+      call abort\n+    type is (thytype(ftype, *, 8))\n+      if (int (sum (cz%d)) .ne. 20800) call abort\n+  end select\n+\n+  deallocate (cz)\n+end"}, {"sha": "ea4ece4b64603b64a74ea80c15dcd4bba49151f8", "filename": "gcc/testsuite/gfortran.dg/pdt_4.f03", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_4.f03?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do compile }\n+!\n+! Test bad PDT coding: Based on pdt_3.f03\n+!\n+module vars\n+  integer :: d_dim = 4\n+  integer :: mat_dim = 256\n+  integer, parameter :: ftype = kind(0.0d0)\n+end module\n+\n+  use vars\n+  implicit none\n+  integer :: i\n+  integer, kind :: bad_kind    ! { dg-error \"not allowed outside a TYPE definition\" }\n+  integer, len :: bad_len      ! { dg-error \"not allowed outside a TYPE definition\" }\n+\n+  type :: bad_pdt (a,b, c, d)\n+    real, kind :: a            ! { dg-error \"must be INTEGER\" }\n+    INTEGER(8), kind :: b      ! { dg-error \"be default integer kind\" }\n+    real, LEN :: c             ! { dg-error \"must be INTEGER\" }\n+    INTEGER(8), LEN :: d       ! { dg-error \"be default integer kind\" }\n+  end type\n+\n+  type :: mytype (a,b)\n+    integer, kind :: a = kind(0.0e0)\n+    integer, LEN :: b = 4\n+    integer :: i\n+    real(kind = a) :: d(b, b)\n+  end type\n+\n+  type, extends(mytype) :: thytype(h)\n+    integer, kind :: h\n+    integer(kind = h) :: j\n+  end type\n+\n+  type x (q, r, s)\n+    integer, kind :: q\n+    integer, kind :: r\n+    integer, LEN :: s\n+    integer(kind = q) :: idx_mat(2,2)\n+    type (mytype (b=s)) :: mat1\n+    type (mytype (b=s*2)) :: mat2\n+  end type x\n+\n+  real, allocatable :: matrix (:,:)\n+\n+! Bad KIND parameters\n+  type(thytype(d_dim, 4, 4)) :: wbad ! { dg-error \"does not reduce to a constant\" }\n+  type(thytype(*, 4, 4)) :: worse    ! { dg-error \"cannot either be ASSUMED or DEFERRED\" }\n+  type(thytype(:, 4, 4)) :: w_ugh    ! { dg-error \"cannot either be ASSUMED or DEFERRED\" }\n+\n+  type(thytype(ftype, b=4, h=4)) :: w\n+  type(x(8,4,mat_dim)) :: q\n+  class(mytype(ftype, :)), allocatable :: cz\n+\n+  w%a = 1                           ! { dg-error \"assignment to a KIND or LEN component\" }\n+  w%b = 2                           ! { dg-error \"assignment to a KIND or LEN component\" }\n+  w%h = 3                           ! { dg-error \"assignment to a KIND or LEN component\" }\n+\n+  w%d = reshape ([(real(i), i = 1, d_dim*d_dim)],[d_dim,d_dim])\n+\n+  matrix = w%d\n+\n+  allocate (cz, source = mytype(*, d_dim, 0, matrix)) ! { dg-error \"Syntax error\" }\n+  allocate (cz, source = mytype(ftype, :, 0, matrix)) ! { dg-error \"Syntax error\" }\n+  select type (cz)\n+    type is (mytype(ftype, d_dim))  ! { dg-error \"must be ASSUMED\" }\n+      if (int (sum (cz%d)) .ne. 136) call abort ! { dg-error \"Expected TYPE IS\" }\n+    type is (thytype(ftype, *, 8))\n+      call abort\n+  end select\n+  deallocate (cz)\n+\n+  allocate (thytype(ftype, d_dim*2, 8) :: cz)\n+  cz%d = reshape ([(i*10, i = 1, cz%b**2)], [cz%b,cz%b])\n+  select type (cz)\n+    type is (mytype(4, *))        !  { dg-error \"must be an extension\" }\n+      call abort\n+    type is (thytype(ftype, *, 8))\n+      if (int (sum (cz%d)) .ne. 20800) call abort\n+  end select\n+  deallocate (cz)\n+contains\n+  subroutine foo(arg)               ! { dg-error \"has no IMPLICIT type\" }\n+    type (mytype(4, *)) :: arg      ! { dg-error \"is being used before it is defined\" }\n+  end subroutine\n+  subroutine bar(arg)               ! { dg-error \"cannot have DEFERRED type parameters\" }\n+    type (thytype(8, :, 4) :: arg\n+  end subroutine\n+end"}, {"sha": "f888c3bb1ec5599451d65bd51446c8ad3df0e3be", "filename": "gcc/testsuite/gfortran.dg/pdt_5.f03", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bab4c9631c478b7940e952ea57de680321d5a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpdt_5.f03?ref=5bab4c9631c478b7940e952ea57de680321d5a8e", "patch": "@@ -0,0 +1,223 @@\n+! { dg-do run }\n+!\n+! Third, complete example from the PGInsider article:\n+! \"Object-Oriented Programming in Fortran 2003 Part 3: Parameterized Derived Types\"\n+! by Mark Leair\n+!\n+!     Copyright (c) 2013, NVIDIA CORPORATION.  All rights reserved.\n+!\n+! NVIDIA CORPORATION and its licensors retain all intellectual property\n+! and proprietary rights in and to this software, related documentation\n+! and any modifications thereto.  Any use, reproduction, disclosure or\n+! distribution of this software and related documentation without an express\n+! license agreement from NVIDIA CORPORATION is strictly prohibited.\n+!\n+\n+!          THIS CODE AND INFORMATION ARE PROVIDED \"AS IS\" WITHOUT\n+!   WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT\n+!   NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR\n+!   FITNESS FOR A PARTICULAR PURPOSE.\n+!\n+! Note that modification had to be made all of which are commented.\n+!\n+module matrix\n+\n+type :: base_matrix(k,c,r)\n+  private\n+    integer, kind :: k = 4\n+    integer, len :: c = 1\n+    integer, len :: r = 1\n+end type base_matrix\n+\n+type, extends(base_matrix) ::  adj_matrix\n+  private\n+    class(*), pointer :: m(:,:) => null()\n+end type adj_matrix\n+\n+interface getKind\n+  module procedure getKind4\n+  module procedure getKind8\n+end interface getKind\n+\n+interface getColumns\n+  module procedure getNumCols4\n+  module procedure getNumCols8\n+end interface getColumns\n+\n+interface getRows\n+  module procedure getNumRows4\n+  module procedure getNumRows8\n+end interface getRows\n+\n+interface adj_matrix\n+   module procedure construct_4   ! kind=4 constructor\n+   module procedure construct_8   ! kind=8 constructor\n+end interface adj_matrix\n+\n+interface assignment(=)\n+   module procedure m2m4          ! assign kind=4 matrix\n+   module procedure a2m4          ! assign kind=4 array\n+   module procedure m2m8          ! assign kind=8 matrix\n+   module procedure a2m8          ! assign kind=8 array\n+   module procedure m2a4          ! assign kind=4 matrix to array\n+   module procedure m2a8          ! assign kind=8 matrix to array\n+end interface assignment(=)\n+\n+\n+contains\n+\n+  function getKind4(this) result(rslt)\n+   class(adj_matrix(4,*,*)) :: this\n+   integer :: rslt\n+   rslt = this%k\n+  end function getKind4\n+\n+ function getKind8(this) result(rslt)\n+   class(adj_matrix(8,*,*)) :: this\n+   integer :: rslt\n+   rslt = this%k\n+ end function getKind8\n+\n+  function getNumCols4(this) result(rslt)\n+   class(adj_matrix(4,*,*)) :: this\n+   integer :: rslt\n+   rslt = this%c\n+  end function getNumCols4\n+\n+  function getNumCols8(this) result(rslt)\n+   class(adj_matrix(8,*,*)) :: this\n+   integer :: rslt\n+   rslt = this%c\n+  end function getNumCols8\n+\n+  function getNumRows4(this) result(rslt)\n+   class(adj_matrix(4,*,*)) :: this\n+   integer :: rslt\n+   rslt = this%r\n+  end function getNumRows4\n+\n+  function getNumRows8(this) result(rslt)\n+   class(adj_matrix(8,*,*)) :: this\n+   integer :: rslt\n+   rslt = this%r\n+  end function getNumRows8\n+\n+\n+ function construct_4(k,c,r) result(mat)\n+     integer(4) :: k\n+     integer :: c\n+     integer :: r\n+     class(adj_matrix(4,:,:)),allocatable :: mat\n+\n+     allocate(adj_matrix(4,c,r)::mat)\n+\n+  end function construct_4\n+\n+  function construct_8(k,c,r) result(mat)\n+     integer(8) :: k\n+     integer :: c\n+     integer :: r\n+     class(adj_matrix(8,:,:)),allocatable :: mat\n+\n+     allocate(adj_matrix(8,c,r)::mat)\n+\n+  end function construct_8\n+\n+  subroutine a2m4(d,s)\n+   class(adj_matrix(4,:,:)),allocatable :: d\n+   class(*),dimension(:,:) :: s\n+\n+   if (allocated(d)) deallocate(d)\n+!    allocate(adj_matrix(4,size(s,1),size(s,2))::d)     ! generates assembler error\n+   allocate(d, mold = adj_matrix(4,size(s,1),size(s,2)))\n+   allocate(d%m(size(s,1),size(s,2)),source=s)\n+ end subroutine a2m4\n+\n+ subroutine a2m8(d,s)\n+   class(adj_matrix(8,:,:)),allocatable :: d\n+   class(*),dimension(:,:) :: s\n+\n+   if (allocated(d)) deallocate(d)\n+!    allocate(adj_matrix(8,size(s,1),size(s,2))::d)     ! generates assembler error\n+   allocate(d, mold = adj_matrix(8_8,size(s,1),size(s,2))) ! Needs 8_8 to match arg1 of 'construct_8'\n+   allocate(d%m(size(s,1),size(s,2)),source=s)\n+ end subroutine a2m8\n+\n+subroutine m2a8(a,this)\n+class(adj_matrix(8,*,*)), intent(in) :: this         ! Intents required for\n+real(8),allocatable, intent(out) :: a(:,:)           ! defined assignment\n+  select type (array => this%m)                      ! Added SELECT TYPE because...\n+    type is (real(8))\n+  if (allocated(a)) deallocate(a)\n+  allocate(a,source=array)\n+  end select\n+!   allocate(a(size(this%m,1),size(this%m,2)),source=this%m) ! ...CLASS(*) source does not work in gfortran\n+ end subroutine m2a8\n+\n+ subroutine m2a4(a,this)\n+ class(adj_matrix(4,*,*)), intent(in) :: this        ! Intents required for\n+ real(4),allocatable, intent(out) :: a(:,:)          ! defined assignment\n+  select type (array => this%m)                      ! Added SELECT TYPE because...\n+    type is (real(4))\n+   if (allocated(a)) deallocate(a)\n+   allocate(a,source=array)\n+  end select\n+!   allocate(a(size(this%m,1),size(this%m,2)),source=this%m) ! ...CLASS(*) source does not work in gfortran\n+ end subroutine m2a4\n+\n+  subroutine m2m4(d,s)\n+   CLASS(adj_matrix(4,:,:)),allocatable, intent(OUT) :: d   ! Intents required for\n+   CLASS(adj_matrix(4,*,*)), intent(in) :: s                ! defined assignment\n+\n+   if (allocated(d)) deallocate(d)\n+   allocate(d,source=s)\n+ end subroutine m2m4\n+\n+ subroutine m2m8(d,s)\n+   CLASS(adj_matrix(8,:,:)),allocatable, intent(OUT) :: d   ! Intents required for\n+   CLASS(adj_matrix(8,*,*)), intent(in) :: s                ! defined assignment\n+\n+   if (allocated(d)) deallocate(d)\n+   allocate(d,source=s)\n+ end subroutine m2m8\n+\n+\n+end module matrix\n+\n+\n+program adj3\n+\n+  use matrix\n+  implicit none\n+  integer(8) :: i\n+\n+  class(adj_matrix(8,:,:)),allocatable :: adj             ! Was TYPE: Fails in\n+  real(8) :: a(2,3)                                       ! defined assignment\n+  real(8),allocatable :: b(:,:)\n+\n+  class(adj_matrix(4,:,:)),allocatable :: adj_4           ! Ditto and ....\n+  real(4) :: a_4(3,2)                                     ! ... these declarations were\n+  real(4),allocatable :: b_4(:,:)                         ! added to check KIND=4\n+\n+! Check constructor of PDT and instrinsic assignment\n+  adj = adj_matrix(INT(8,8),2,4)\n+  if (adj%k .ne. 8) call abort\n+  if (adj%c .ne. 2) call abort\n+  if (adj%r .ne. 4) call abort\n+  a = reshape ([(i, i = 1, 6)], [2,3])\n+  adj = a\n+  b = adj\n+  if (any (b .ne. a)) call abort\n+\n+! Check allocation with MOLD of PDT. Note that only KIND parameters set.\n+  allocate (adj_4, mold = adj_matrix(4,3,2))           ! Added check of KIND = 4\n+  if (adj_4%k .ne. 4) call abort\n+  a_4 = reshape (a, [3,2])\n+  adj_4 = a_4\n+  b_4 = adj_4\n+  if (any (b_4 .ne. a_4)) call abort\n+\n+end program adj3\n+\n+\n+"}]}