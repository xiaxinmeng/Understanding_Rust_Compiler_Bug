{"sha": "437c23222436111f80b29ec24d2fb863b567e589", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM3YzIzMjIyNDM2MTExZjgwYjI5ZWMyNGQyZmI4NjNiNTY3ZTU4OQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-29T03:15:40Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-29T03:15:40Z"}, "message": "In gcc/objc/: 2010-11-29 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc-act.c (objc_eh_runtime_type): Avoid ICE if error_mark_node\n\tis passed as argument.\n\t(objc_begin_catch_clause): Added code to deal with an\n\terror_mark_node or NULL_TREE argument.  Improved checks for\n\tinvalid arguments.  Added code to traverse typedefs.\n\nIn gcc/testsuite/:\n2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc.dg/exceptions-1.m: New.\n\t* objc.dg/exceptions-2.m: New.\n\t* objc.dg/exceptions-3.m: New.\n\t* objc.dg/exceptions-4.m: New.\n\t* objc.dg/exceptions-5.m: New.\n\t* obj-c++.dg/exceptions-1.mm: New.\n\t* obj-c++.dg/exceptions-2.mm: New.\n\t* obj-c++.dg/exceptions-3.mm: New.\n\t* obj-c++.dg/exceptions-4.mm: New.\n\t* obj-c++.dg/exceptions-5.mm: New.\n\nIn gcc/cp/:\n2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* parser.c (cp_parser_objc_try_catch_finally_statement): Parse\n\t@catch(...)  and pass NULL_TREE to objc_begin_catch_clause() in\n\tthat case.  Improved error recovery.  Reorganized code to be\n\talmost identical to c_parser_objc_try_catch_finally_statement.\n\nIn gcc/:\n2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* c-parser.c (c_parser_objc_try_catch_statement): Renamed to\n\tc_parser_objc_try_catch_finally_statement for consistency with the\n\tC++ parser.  Parse @catch(...) and pass NULL_TREE to\n\tobjc_begin_catch_clause() in that case.  Improved error recovery.\n\tReorganized code to be almost identical to\n\tcp_parser_objc_try_catch_finally_statement.\n\nFrom-SVN: r167233", "tree": {"sha": "44406a903b8b5e0d042b1c9cd87592f05480f94d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44406a903b8b5e0d042b1c9cd87592f05480f94d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/437c23222436111f80b29ec24d2fb863b567e589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437c23222436111f80b29ec24d2fb863b567e589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437c23222436111f80b29ec24d2fb863b567e589", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437c23222436111f80b29ec24d2fb863b567e589/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45f9cadb2a94bbb57bfd0a3f68afe42346c79c57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f9cadb2a94bbb57bfd0a3f68afe42346c79c57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f9cadb2a94bbb57bfd0a3f68afe42346c79c57"}], "stats": {"total": 1105, "additions": 1035, "deletions": 70}, "files": [{"sha": "c20e57e9928cc566ba1e83ccd03a4398b74de367", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -1,3 +1,12 @@\n+2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-parser.c (c_parser_objc_try_catch_statement): Renamed to\n+\tc_parser_objc_try_catch_finally_statement for consistency with the\n+\tC++ parser.  Parse @catch(...) and pass NULL_TREE to\n+\tobjc_begin_catch_clause() in that case.  Improved error recovery.\n+\tReorganized code to be almost identical to\n+\tcp_parser_objc_try_catch_finally_statement.\n+\t\n 2010-11-29  Joern Rennecke  <amylaar@spamcop.net>\n \n \tPR tree-optimization/46621"}, {"sha": "879e106ff4db1c9a21d0969f086612925b1beb1f", "filename": "gcc/c-parser.c", "status": "modified", "additions": 67, "deletions": 23, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -1155,7 +1155,7 @@ static void c_parser_objc_methodproto (c_parser *);\n static tree c_parser_objc_method_decl (c_parser *, bool, tree *);\n static tree c_parser_objc_type_name (c_parser *);\n static tree c_parser_objc_protocol_refs (c_parser *);\n-static void c_parser_objc_try_catch_statement (c_parser *);\n+static void c_parser_objc_try_catch_finally_statement (c_parser *);\n static void c_parser_objc_synchronized_statement (c_parser *);\n static tree c_parser_objc_selector (c_parser *);\n static tree c_parser_objc_selector_arg (c_parser *);\n@@ -4371,7 +4371,7 @@ c_parser_statement_after_labels (c_parser *parser)\n \t  break;\n \tcase RID_AT_TRY:\n \t  gcc_assert (c_dialect_objc ());\n-\t  c_parser_objc_try_catch_statement (parser);\n+\t  c_parser_objc_try_catch_finally_statement (parser);\n \t  break;\n \tcase RID_AT_SYNCHRONIZED:\n \t  gcc_assert (c_dialect_objc ());\n@@ -7468,53 +7468,97 @@ c_parser_objc_protocol_refs (c_parser *parser)\n   return list;\n }\n \n-/* Parse an objc-try-catch-statement.\n+/* Parse an objc-try-catch-finally-statement.\n \n-   objc-try-catch-statement:\n+   objc-try-catch-finally-statement:\n      @try compound-statement objc-catch-list[opt]\n      @try compound-statement objc-catch-list[opt] @finally compound-statement\n \n    objc-catch-list:\n-     @catch ( parameter-declaration ) compound-statement\n-     objc-catch-list @catch ( parameter-declaration ) compound-statement\n-*/\n+     @catch ( objc-catch-parameter-declaration ) compound-statement\n+     objc-catch-list @catch ( objc-catch-parameter-declaration ) compound-statement\n+\n+   objc-catch-parameter-declaration:\n+     parameter-declaration\n+     '...'\n+\n+   where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.\n+\n+   PS: This function is identical to cp_parser_objc_try_catch_finally_statement\n+   for C++.  Keep them in sync.  */   \n \n static void\n-c_parser_objc_try_catch_statement (c_parser *parser)\n+c_parser_objc_try_catch_finally_statement (c_parser *parser)\n {\n-  location_t loc;\n+  location_t location;\n   tree stmt;\n+\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_TRY));\n   c_parser_consume_token (parser);\n-  loc = c_parser_peek_token (parser)->location;\n+  location = c_parser_peek_token (parser)->location;\n   stmt = c_parser_compound_statement (parser);\n-  objc_begin_try_stmt (loc, stmt);\n+  objc_begin_try_stmt (location, stmt);\n+\n   while (c_parser_next_token_is_keyword (parser, RID_AT_CATCH))\n     {\n       struct c_parm *parm;\n+      tree parameter_declaration = error_mark_node;\n+      bool seen_open_paren = false;\n+\n       c_parser_consume_token (parser);\n       if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\tbreak;\n-      parm = c_parser_parameter_declaration (parser, NULL_TREE);\n-      if (parm == NULL)\n+\tseen_open_paren = true;\n+      if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n \t{\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t  break;\n+\t  /* We have \"@catch (...)\" (where the '...' are literally\n+\t     what is in the code).  Skip the '...'.\n+\t     parameter_declaration is set to NULL_TREE, and\n+\t     objc_being_catch_clauses() knows that that means\n+\t     '...'.  */\n+\t  c_parser_consume_token (parser);\n+\t  parameter_declaration = NULL_TREE;\n \t}\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n-      objc_begin_catch_clause (grokparm (parm));\n+      else\n+\t{\n+\t  /* We have \"@catch (NSException *exception)\" or something\n+\t     like that.  Parse the parameter declaration.  */\n+\t  parm = c_parser_parameter_declaration (parser, NULL_TREE);\n+\t  if (parm == NULL)\n+\t    parameter_declaration = error_mark_node;\n+\t  else\n+\t    parameter_declaration = grokparm (parm);\n+\t}\n+      if (seen_open_paren)\n+\tc_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      else\n+\t{\n+\t  /* If there was no open parenthesis, we are recovering from\n+\t     an error, and we are trying to figure out what mistake\n+\t     the user has made.  */\n+\n+\t  /* If there is an immediate closing parenthesis, the user\n+\t     probably forgot the opening one (ie, they typed \"@catch\n+\t     NSException *e)\".  Parse the closing parenthesis and keep\n+\t     going.  */\n+\t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\t    c_parser_consume_token (parser);\n+\t  \n+\t  /* If these is no immediate closing parenthesis, the user\n+\t     probably doesn't know that parenthesis are required at\n+\t     all (ie, they typed \"@catch NSException *e\").  So, just\n+\t     forget about the closing parenthesis and keep going.  */\n+\t}\n+      objc_begin_catch_clause (parameter_declaration);\n       if (c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n \tc_parser_compound_statement_nostart (parser);\n       objc_finish_catch_clause ();\n     }\n   if (c_parser_next_token_is_keyword (parser, RID_AT_FINALLY))\n     {\n-      location_t finloc;\n-      tree finstmt;\n       c_parser_consume_token (parser);\n-      finloc = c_parser_peek_token (parser)->location;\n-      finstmt = c_parser_compound_statement (parser);\n-      objc_build_finally_clause (finloc, finstmt);\n+      location = c_parser_peek_token (parser)->location;\n+      stmt = c_parser_compound_statement (parser);\n+      objc_build_finally_clause (location, stmt);\n     }\n   objc_finish_try_stmt ();\n }"}, {"sha": "6e3bbbe7eb0ab23c2b8534a52411e3f35a63fc67", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -1,3 +1,10 @@\n+2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* parser.c (cp_parser_objc_try_catch_finally_statement): Parse\n+\t@catch(...)  and pass NULL_TREE to objc_begin_catch_clause() in\n+\tthat case.  Improved error recovery.  Reorganized code to be\n+\talmost identical to c_parser_objc_try_catch_finally_statement.\n+\n 2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc++/46222"}, {"sha": "917f75043b30ed02ed8d9650aa6b53962687b69e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -22598,15 +22598,25 @@ cp_parser_objc_declaration (cp_parser* parser, tree attributes)\n      objc-catch-clause objc-catch-clause-seq [opt]\n \n    objc-catch-clause:\n-     @catch ( exception-declaration ) compound-statement\n+     @catch ( objc-exception-declaration ) compound-statement\n \n-   objc-finally-clause\n+   objc-finally-clause:\n      @finally compound-statement\n \n-   Returns NULL_TREE.  */\n+   objc-exception-declaration:\n+     parameter-declaration\n+     '...'\n+\n+   where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.\n+\n+   Returns NULL_TREE.\n+\n+   PS: This function is identical to c_parser_objc_try_catch_finally_statement\n+   for C.  Keep them in sync.  */   \n \n static tree\n-cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n+cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n+{\n   location_t location;\n   tree stmt;\n \n@@ -22620,22 +22630,60 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n \n   while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n     {\n-      cp_parameter_declarator *parmdecl;\n-      tree parm;\n+      cp_parameter_declarator *parm;\n+      tree parameter_declaration = error_mark_node;\n+      bool seen_open_paren = false;\n \n       cp_lexer_consume_token (parser->lexer);\n-      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n-      parm = grokdeclarator (parmdecl->declarator,\n-\t\t\t     &parmdecl->decl_specifiers,\n-\t\t\t     PARM, /*initialized=*/0,\n-\t\t\t     /*attrlist=*/NULL);\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      objc_begin_catch_clause (parm);\n+      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+\tseen_open_paren = true;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t{\n+\t  /* We have \"@catch (...)\" (where the '...' are literally\n+\t     what is in the code).  Skip the '...'.\n+\t     parameter_declaration is set to NULL_TREE, and\n+\t     objc_being_catch_clauses() knows that that means\n+\t     '...'.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  parameter_declaration = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* We have \"@catch (NSException *exception)\" or something\n+\t     like that.  Parse the parameter declaration.  */\n+\t  parm = cp_parser_parameter_declaration (parser, false, NULL);\n+\t  if (parm == NULL)\n+\t    parameter_declaration = error_mark_node;\n+\t  else\n+\t    parameter_declaration = grokdeclarator (parm->declarator,\n+\t\t\t\t\t\t    &parm->decl_specifiers,\n+\t\t\t\t\t\t    PARM, /*initialized=*/0,\n+\t\t\t\t\t\t    /*attrlist=*/NULL);\n+\t}\n+      if (seen_open_paren)\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      else\n+\t{\n+\t  /* If there was no open parenthesis, we are recovering from\n+\t     an error, and we are trying to figure out what mistake\n+\t     the user has made.  */\n+\n+\t  /* If there is an immediate closing parenthesis, the user\n+\t     probably forgot the opening one (ie, they typed \"@catch\n+\t     NSException *e)\".  Parse the closing parenthesis and keep\n+\t     going.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  \n+\t  /* If these is no immediate closing parenthesis, the user\n+\t     probably doesn't know that parenthesis are required at\n+\t     all (ie, they typed \"@catch NSException *e\").  So, just\n+\t     forget about the closing parenthesis and keep going.  */\n+\t}\n+      objc_begin_catch_clause (parameter_declaration);\n       cp_parser_compound_statement (parser, NULL, false);\n       objc_finish_catch_clause ();\n     }\n-\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n     {\n       cp_lexer_consume_token (parser->lexer);"}, {"sha": "644129bbc1637b3440dfd0f9a7a77235f3633d28", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -1,3 +1,11 @@\n+2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_eh_runtime_type): Avoid ICE if error_mark_node\n+\tis passed as argument.\n+\t(objc_begin_catch_clause): Added code to deal with an\n+\terror_mark_node or NULL_TREE argument.  Improved checks for\n+\tinvalid arguments.  Added code to traverse typedefs.\n+\n 2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_demangle): Return immediately if the string is"}, {"sha": "810a53af95324a25d3e58109618ea761c66c179a", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 94, "deletions": 32, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -5024,7 +5024,14 @@ static GTY(()) tree objc_eh_personality_decl;\n tree\n objc_eh_runtime_type (tree type)\n {\n-  return add_objc_string (OBJC_TYPE_NAME (TREE_TYPE (type)), class_names);\n+  /* Use 'ErrorMarkNode' as class name when error_mark_node is found\n+     to prevent an ICE.  Note that we know that the compiler will\n+     terminate with an error and this 'ErrorMarkNode' class name will\n+     never be actually used.  */\n+  if (type == error_mark_node)\n+    return add_objc_string (get_identifier (\"ErrorMarkNode\"), class_names);\n+  else\n+    return add_objc_string (OBJC_TYPE_NAME (TREE_TYPE (type)), class_names);\n }\n \n tree\n@@ -5355,7 +5362,9 @@ objc_begin_try_stmt (location_t try_locus, tree body)\n \n /* Called just after parsing \"@catch (parm)\".  Open a binding level,\n    enter DECL into the binding level, and initialize it.  Leave the\n-   binding level open while the body of the compound statement is parsed.  */\n+   binding level open while the body of the compound statement is\n+   parsed.  If DECL is NULL_TREE, then we are compiling \"@catch(...)\"\n+   which we compile as \"@catch(id tmp_variable)\".  */\n \n void\n objc_begin_catch_clause (tree decl)\n@@ -5365,46 +5374,99 @@ objc_begin_catch_clause (tree decl)\n   /* Begin a new scope that the entire catch clause will live in.  */\n   compound = c_begin_compound_stmt (true);\n \n-  /* The parser passed in a PARM_DECL, but what we really want is a VAR_DECL.  */\n-  decl = build_decl (input_location,\n-\t\t     VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n-  lang_hooks.decls.pushdecl (decl);\n+  /* Create the appropriate declaration for the argument.  */\n+ if (decl == error_mark_node)\n+   type = error_mark_node;\n+ else\n+   {\n+     if (decl == NULL_TREE)\n+       {\n+\t /* If @catch(...) was specified, create a temporary variable of\n+\t    type 'id' and use it.  */\n+\t decl = objc_create_temporary_var (objc_object_type, \"__objc_generic_catch_var\");\n+\t DECL_SOURCE_LOCATION (decl) = input_location;\n+       }\n+     else\n+       {\n+\t /* The parser passed in a PARM_DECL, but what we really want is a VAR_DECL.  */\n+\t decl = build_decl (input_location,\n+\t\t\t    VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+       }\n+     lang_hooks.decls.pushdecl (decl);\n \n-  /* Since a decl is required here by syntax, don't warn if its unused.  */\n-  /* ??? As opposed to __attribute__((unused))?  Anyway, this appears to\n-     be what the previous objc implementation did.  */\n-  TREE_USED (decl) = 1;\n-  DECL_READ_P (decl) = 1;\n+     /* Mark the declaration as used so you never any warnings whether\n+\tyou use the exception argument or not.  TODO: Implement a\n+\t-Wunused-exception-parameter flag, which would cause warnings\n+\tif exception parameter is not used.  */\n+     TREE_USED (decl) = 1;\n+     DECL_READ_P (decl) = 1;\n \n-  /* Verify that the type of the catch is valid.  It must be a pointer\n-     to an Objective-C class, or \"id\" (which is catch-all).  */\n-  type = TREE_TYPE (decl);\n+     type = TREE_TYPE (decl);\n+   }\n \n-  if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n-    type = NULL;\n-  else if (!POINTER_TYPE_P (type) || !TYPED_OBJECT (TREE_TYPE (type)))\n+ /* Verify that the type of the catch is valid.  It must be a pointer\n+    to an Objective-C class, or \"id\" (which is catch-all).  */\n+ if (type == error_mark_node)\n+   {\n+     ;/* Just keep going.  */\n+   }\n+ else if (!objc_type_valid_for_messaging (type, false))\n     {\n       error (\"@catch parameter is not a known Objective-C class type\");\n       type = error_mark_node;\n     }\n-  else if (cur_try_context->catch_list)\n+  else if (TYPE_HAS_OBJC_INFO (TREE_TYPE (type))\n+\t   && TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (type)))\n     {\n-      /* Examine previous @catch clauses and see if we've already\n-\t caught the type in question.  */\n-      tree_stmt_iterator i = tsi_start (cur_try_context->catch_list);\n-      for (; !tsi_end_p (i); tsi_next (&i))\n+      error (\"@catch parameter can not be protocol-qualified\");\n+      type = error_mark_node;      \n+    }\n+  else if (objc_is_object_id (TREE_TYPE (type)))\n+    type = NULL;\n+  else\n+    {\n+      /* If 'type' was built using typedefs, we need to get rid of\n+\t them and get a simple pointer to the class.  */\n+      bool is_typedef = false;\n+      tree x = TYPE_MAIN_VARIANT (type);\n+      \n+      /* Skip from the pointer to the pointee.  */\n+      if (TREE_CODE (x) == POINTER_TYPE)\n+\tx = TREE_TYPE (x);\n+      \n+      /* Traverse typedef aliases */\n+      while (TREE_CODE (x) == RECORD_TYPE && OBJC_TYPE_NAME (x)\n+\t     && TREE_CODE (OBJC_TYPE_NAME (x)) == TYPE_DECL\n+\t     && DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (x)))\n \t{\n-\t  tree stmt = tsi_stmt (i);\n-\t  t = CATCH_TYPES (stmt);\n-\t  if (t == error_mark_node)\n-\t    continue;\n-\t  if (!t || DERIVED_FROM_P (TREE_TYPE (t), TREE_TYPE (type)))\n+\t  is_typedef = true;\n+\t  x = DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (x));\n+\t}\n+\n+      /* If it was a typedef, build a pointer to the final, original\n+\t class.  */\n+      if (is_typedef)\n+\ttype = build_pointer_type (x);\n+\n+      if (cur_try_context->catch_list)\n+\t{\n+\t  /* Examine previous @catch clauses and see if we've already\n+\t     caught the type in question.  */\n+\t  tree_stmt_iterator i = tsi_start (cur_try_context->catch_list);\n+\t  for (; !tsi_end_p (i); tsi_next (&i))\n \t    {\n-\t      warning (0, \"exception of type %<%T%> will be caught\",\n-\t\t       TREE_TYPE (type));\n-\t      warning_at  (EXPR_LOCATION (stmt), 0, \"   by earlier handler for %<%T%>\",\n-\t\t\t   TREE_TYPE (t ? t : objc_object_type));\n-\t      break;\n+\t      tree stmt = tsi_stmt (i);\n+\t      t = CATCH_TYPES (stmt);\n+\t      if (t == error_mark_node)\n+\t\tcontinue;\n+\t      if (!t || DERIVED_FROM_P (TREE_TYPE (t), TREE_TYPE (type)))\n+\t\t{\n+\t\t  warning (0, \"exception of type %<%T%> will be caught\",\n+\t\t\t   TREE_TYPE (type));\n+\t\t  warning_at  (EXPR_LOCATION (stmt), 0, \"   by earlier handler for %<%T%>\",\n+\t\t\t       TREE_TYPE (t ? t : objc_object_type));\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "6185f595b4d71678b8fe4157b68bddb9aa695b9a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -1,3 +1,16 @@\n+2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/exceptions-1.m: New.\n+\t* objc.dg/exceptions-2.m: New.\n+\t* objc.dg/exceptions-3.m: New.\n+\t* objc.dg/exceptions-4.m: New.\n+\t* objc.dg/exceptions-5.m: New.\n+\t* obj-c++.dg/exceptions-1.mm: New.\n+\t* obj-c++.dg/exceptions-2.mm: New.\n+\t* obj-c++.dg/exceptions-3.mm: New.\n+\t* obj-c++.dg/exceptions-4.mm: New.\n+\t* obj-c++.dg/exceptions-5.mm: New.\n+\n 2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* obj-c++.dg/property/at-property-1.mm: Fixed testcase."}, {"sha": "0f3b7e8ae14706fbe9e453c61c25629383deddc1", "filename": "gcc/testsuite/obj-c++.dg/exceptions-1.mm", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-1.mm?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,42 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* This test checks the syntax @catch (...) which catches any\n+   exceptions.  At the moment, @catch (...) is identical to @catch (id\n+   exception).  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+int test (id object)\n+{\n+  int i = 0;\n+\n+  @try\n+    {\n+      @throw object;\n+    }\n+  @catch (MyObject *o)\n+    {\n+      i += 1;\n+    }\n+  @catch (...)\n+    {\n+      i += 2;\n+    }\n+  @finally\n+    {\n+      i += 4;\n+    }\n+\n+  return i;\n+}"}, {"sha": "ce85b73132564f1737cd72da474f55332852b00e", "filename": "gcc/testsuite/obj-c++.dg/exceptions-2.mm", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-2.mm?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,54 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+\n+/* FIXME: This does not test running the code, because Objective-C exceptions at the moment\n+   do not execute correctly in Objective-C++.  See PR objc++/23616.  Once that is fixed,\n+   this test should be changed to use 'dg-run' instead of just 'dg-compile'.  */\n+/* { dg-compile } */\n+\n+/* This test checks the syntax @catch (...) which catches any\n+   exceptions.  Check that code using it runs correctly.  */\n+\n+#include \"../objc-obj-c++-shared/Object1.h\"\n+#include <stdlib.h>\n+\n+@interface MyObject : Object\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+int test (id object)\n+{\n+  int i = 0;\n+\n+  @try\n+    {\n+      @throw object;\n+    }\n+  @catch (MyObject *o)\n+    {\n+      i += 1;\n+    }\n+  @catch (...)\n+    {\n+      i += 2;\n+    }\n+  @finally\n+    {\n+      i += 4;\n+    }\n+\n+  return i;\n+}\n+\n+int main (void)\n+{\n+  if (test ([MyObject new]) != 5)\n+    abort ();\n+\n+  if (test ([Object new]) != 6)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b1ba1852725ce8a6c8ddfb35b153f4fb2de51400", "filename": "gcc/testsuite/obj-c++.dg/exceptions-3.mm", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-3.mm?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,114 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* Test that the compiler is checking the argument of @catch(), and\n+   produce errors when invalid types are used.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+@protocol MyProtocol;\n+\n+typedef MyObject MyObjectTypedef;\n+typedef MyObject *MyObjectPtrTypedef;\n+typedef int intTypedef;\n+\n+int test (id object)\n+{\n+  int dummy = 0;\n+\n+  @try { @throw object; }\n+  @catch (int x)          /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (intTypedef x)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (int *x)         /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }  \n+\n+  @try { @throw object; }\n+  @catch (id x)           /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (id <MyProtocol> x) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject *x)    /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject <MyProtocol> *x)  /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject x)     /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {                     /* { dg-error \"no matching function\" \"\" { target *-*-* } 72 } */\n+      dummy++;            /* { dg-warning \"MyObject\" \"\" { target *-*-* } 13 } */\n+    }\n+\n+  @try { @throw object; }\n+  @catch (static MyObject *x) /* { dg-error \"storage class\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef *x) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef <MyProtocol> *x) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectPtrTypedef x) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (Class x)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (...)            /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  return dummy;\n+}"}, {"sha": "85debe444b6ca298b65babf351331a4da18d5be9", "filename": "gcc/testsuite/obj-c++.dg/exceptions-4.mm", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-4.mm?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,64 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* Test warnings when parsing syntax errors in @catch().  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+@interface MyObject2\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject2\n+@end\n+\n+@protocol MyProtocol;\n+\n+int test (id object)\n+{\n+  int dummy = 0;\n+\n+  @try { @throw object; }\n+  @catch\n+    {          /* { dg-error \"expected\" } */\n+      dummy++; /* { dg-error \"@catch parameter is not a known Objective-C class type\" \"\" { target *-*-* } 35 } */\n+    }\n+  @catch ()  /* { dg-error \"expected identifier before\" } */\n+    {        /* { dg-error \"@catch parameter is not a known Objective-C class type\" \"\" { target *-*-* } 38 } */\n+      dummy++;\n+    }\n+  @catch (i) /* { dg-error \".i. has not been declared\" } */\n+    {        /* { dg-error \"@catch parameter is not a known Objective-C class type\" \"\" { target *-*-* } 42 } */\n+      dummy++;\n+    }\n+  @catch (id <MyProtocol x) /* { dg-error \"expected ... before .x.\" } */\n+    {                       /* { dg-error \"@catch parameter can not be protocol-qualified\" \"\" { target *-*-* } 46 } */\n+      dummy++;\n+    }\n+  @catch MyObject *x       /* { dg-error \"expected ... before .MyObject.\" } */\n+    {\n+      dummy++;\n+    }\n+  @catch MyObject2 *x)     /* { dg-error \"expected ... before .MyObject2.\" } */\n+   {\n+     dummy++;\n+   }\n+\n+  @try { @throw object; }\n+  @catch (MyObject *x)\n+  @catch (MyObject2 *y)    /* { dg-error \"expected ... before .catch.\" } */\n+\n+  return dummy;            /* { dg-error \"expected ... before .return.\" } */\n+}"}, {"sha": "f740496884468cb4cd967445f8e867aabd597152", "filename": "gcc/testsuite/obj-c++.dg/exceptions-5.mm", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fexceptions-5.mm?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,114 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* Test that you can use an unnamed argument with @catch.  This test is the same\n+   as exceptions-3.mm, but with no name for @catch arguments.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+@protocol MyProtocol;\n+\n+typedef MyObject MyObjectTypedef;\n+typedef MyObject *MyObjectPtrTypedef;\n+typedef int intTypedef;\n+\n+int test (id object)\n+{\n+  int dummy = 0;\n+\n+  @try { @throw object; }\n+  @catch (int)          /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (intTypedef)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (int *)         /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }  \n+\n+  @try { @throw object; }\n+  @catch (id)           /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (id <MyProtocol>) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject *)    /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject <MyProtocol> *)  /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject)     /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {                     /* { dg-error \"no matching function\" \"\" { target *-*-* } 72 } */\n+      dummy++;            /* { dg-warning \"MyObject\" \"\" { target *-*-* } 13 } */\n+    }\n+\n+  @try { @throw object; }\n+  @catch (static MyObject *) /* { dg-error \"storage class\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef *) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef <MyProtocol> *) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectPtrTypedef) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (Class)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (...)            /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  return dummy;\n+}"}, {"sha": "0f3b7e8ae14706fbe9e453c61c25629383deddc1", "filename": "gcc/testsuite/objc.dg/exceptions-1.m", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-1.m?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,42 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* This test checks the syntax @catch (...) which catches any\n+   exceptions.  At the moment, @catch (...) is identical to @catch (id\n+   exception).  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+int test (id object)\n+{\n+  int i = 0;\n+\n+  @try\n+    {\n+      @throw object;\n+    }\n+  @catch (MyObject *o)\n+    {\n+      i += 1;\n+    }\n+  @catch (...)\n+    {\n+      i += 2;\n+    }\n+  @finally\n+    {\n+      i += 4;\n+    }\n+\n+  return i;\n+}"}, {"sha": "3e4227cb9655e076dfcdd5c1b4798fa31db464e2", "filename": "gcc/testsuite/objc.dg/exceptions-2.m", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-2.m?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,52 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-additional-sources \"../objc-obj-c++-shared/Object1.m\" } */\n+\n+/* This test checks the syntax @catch (...) which catches any\n+   exceptions.  Check that code using it runs correctly.  */\n+\n+#include \"../objc-obj-c++-shared/Object1.h\"\n+#include <stdlib.h>\n+\n+@interface MyObject : Object\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+int test (id object)\n+{\n+  int i = 0;\n+\n+  @try\n+    {\n+      @throw object;\n+    }\n+  @catch (MyObject *o)\n+    {\n+      i += 1;\n+    }\n+  @catch (...)\n+    {\n+      i += 2;\n+    }\n+  @finally\n+    {\n+      i += 4;\n+    }\n+\n+  return i;\n+}\n+\n+int main (void)\n+{\n+  if (test ([MyObject new]) != 5)\n+    abort ();\n+\n+  if (test ([Object new]) != 6)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "fe9dbfbfa06179d2689b610af4441a0571f3cc1b", "filename": "gcc/testsuite/objc.dg/exceptions-3.m", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-3.m?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,114 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* Test that the compiler is checking the argument of @catch(), and\n+   produce errors when invalid types are used.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+@protocol MyProtocol;\n+\n+typedef MyObject MyObjectTypedef;\n+typedef MyObject *MyObjectPtrTypedef;\n+typedef int intTypedef;\n+\n+int test (id object)\n+{\n+  int dummy = 0;\n+\n+  @try { @throw object; }\n+  @catch (int x)          /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (intTypedef x)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (int *x)         /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }  \n+\n+  @try { @throw object; }\n+  @catch (id x)           /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (id <MyProtocol> x) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject *x)    /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject <MyProtocol> *x)  /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject x)     /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {                     /* { dg-error \"conversion to non-scalar type requested\" \"\" { target *-*-* } 72 } */\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (static MyObject *x) /* { dg-error \"storage class specified for\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef *x) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef <MyProtocol> *x) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectPtrTypedef x) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (Class x)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (...)            /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  return dummy;\n+}"}, {"sha": "a8a26ecebb21a265621749c797701be05a99e837", "filename": "gcc/testsuite/objc.dg/exceptions-4.m", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-4.m?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,64 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* Test warnings when parsing syntax errors in @catch().  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+@interface MyObject2\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject2\n+@end\n+\n+@protocol MyProtocol;\n+\n+int test (id object)\n+{\n+  int dummy = 0;\n+\n+  @try { @throw object; }\n+  @catch\n+    { /* { dg-error \"expected ... before ... token\" } */\n+      dummy++;\n+    }\n+  @catch ()  /* { dg-error \"expected declaration specifiers or ..... before ...\" } */\n+    {\n+      dummy++;\n+    }\n+  @catch (i) /* { dg-error \"expected declaration specifiers or ..... before .i.\" } */\n+    {\n+      dummy++;\n+    }\n+  @catch (id <MyProtocol x) /* { dg-error \"expected ... before .x.\" } */\n+    {                       /* { dg-error \"@catch parameter can not be protocol-qualified\" \"\" { target *-*-* } 46 } */\n+      dummy++;\n+    }\n+  @catch MyObject *x       /* { dg-error \"expected ... before .MyObject.\" } */\n+    {\n+      dummy++;\n+    }\n+  @catch MyObject2 *x)      /* { dg-error \"expected ... before .MyObject2.\" } */\n+   {\n+     dummy++;\n+   }\n+\n+  @try { @throw object; }\n+  @catch (MyObject *x)\n+  @catch (MyObject2 *y)    /* { dg-error \"expected ... before .catch.\" } */\n+\n+  return dummy;\n+}"}, {"sha": "d89ad2967c03f49f2c102ab957d3f4dd3609b389", "filename": "gcc/testsuite/objc.dg/exceptions-5.m", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437c23222436111f80b29ec24d2fb863b567e589/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fexceptions-5.m?ref=437c23222436111f80b29ec24d2fb863b567e589", "patch": "@@ -0,0 +1,114 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-options \"-fobjc-exceptions\" } */\n+/* { dg-do compile } */\n+\n+/* Test that you can use an unnamed argument with @catch.  This test is the same\n+   as exceptions-3.m, but with no name for @catch arguments.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyObject\n+@end\n+\n+@protocol MyProtocol;\n+\n+typedef MyObject MyObjectTypedef;\n+typedef MyObject *MyObjectPtrTypedef;\n+typedef int intTypedef;\n+\n+int test (id object)\n+{\n+  int dummy = 0;\n+\n+  @try { @throw object; }\n+  @catch (int)          /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (intTypedef)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (int *)         /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }  \n+\n+  @try { @throw object; }\n+  @catch (id)           /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (id <MyProtocol>) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject *)    /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject <MyProtocol> *)  /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObject)     /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {                     /* { dg-error \"conversion to non-scalar type requested\" \"\" { target *-*-* } 72 } */\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (static MyObject *) /* { dg-error \"storage class specified for\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef *) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectTypedef <MyProtocol> *) /* { dg-error \"@catch parameter can not be protocol-qualified\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (MyObjectPtrTypedef) /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (Class)   /* { dg-error \"@catch parameter is not a known Objective-C class type\" } */\n+    {\n+      dummy++;\n+    }\n+\n+  @try { @throw object; }\n+  @catch (...)            /* Ok */\n+    {\n+      dummy++;\n+    }\n+\n+  return dummy;\n+}"}]}