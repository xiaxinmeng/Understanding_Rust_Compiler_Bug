{"sha": "f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg2ODJmZjYyZmI3ZjBkNGI1ZWNmMjVlZjE4NGUwOTU2YzdhMmYwYQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-11-30T07:34:55Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-11-30T07:34:55Z"}, "message": "re PR rtl-optimization/41812 (test 20071030-1.c fails execution on powerpc64)\n\n2009-11-30  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/41812\n\t* fwprop.c (local_md, local_lr): New globals.\n\t(process_defs, process_uses): Remove local_md argument.  Never\n\tconsider dead pseudos to have singleton def-use chains.\n\t(single_def_use_enter_block): Perform LR simulation.\n\t(build_single_def_use_links): Remove local_md local variable.\n\tAdd DF_NOTE.  Allocate local_lr.\n\t(fwprop_done): Do not remove DF_CHAIN, we do not use it anymore.\n\t* df-problems.c (df_md_scratch): New.\n\t(df_md_alloc, df_md_free): Allocate/free it.\n\t(df_md_local_compute): Only include live registers in init.\n\t(df_md_transfer_function): Prune the in-set computed by\n\tthe confluence function, and the gen-set too.\n\t(df_simulate_one_insn_forwards): Fix typo.\n\nFrom-SVN: r154753", "tree": {"sha": "f00884f0bf62a839c7294b60335acdff07cd665b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f00884f0bf62a839c7294b60335acdff07cd665b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da55c6dac1184af5d8bb1dbe772574943c6146d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da55c6dac1184af5d8bb1dbe772574943c6146d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da55c6dac1184af5d8bb1dbe772574943c6146d7"}], "stats": {"total": 102, "additions": 73, "deletions": 29}, "files": [{"sha": "a2a90f8b2a5265921691df4c8d57ff0010ab16e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "patch": "@@ -1,3 +1,20 @@\n+2009-11-30  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/41812\n+\t* fwprop.c (local_md, local_lr): New globals.\n+\t(process_defs, process_uses): Remove local_md argument.  Never\n+\tconsider dead pseudos to have singleton def-use chains.\n+\t(single_def_use_enter_block): Perform LR simulation.\n+\t(build_single_def_use_links): Remove local_md local variable.\n+\tAdd DF_NOTE.  Allocate local_lr.\n+\t(fwprop_done): Do not remove DF_CHAIN, we do not use it anymore.\n+\t* df-problems.c (df_md_scratch): New.\n+\t(df_md_alloc, df_md_free): Allocate/free it.\n+\t(df_md_local_compute): Only include live registers in init.\n+\t(df_md_transfer_function): Prune the in-set computed by\n+\tthe confluence function, and the gen-set too.\n+\t(df_simulate_one_insn_forwards): Fix typo.\n+\n 2009-11-30  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR rtl-optimization/40086"}, {"sha": "e0ec16778f0d1bf251dc69a4b03f4915624a3e5d", "filename": "gcc/df-problems.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "patch": "@@ -1574,10 +1574,9 @@ df_live_transfer_function (int bb_index)\n   bitmap gen = bb_info->gen;\n   bitmap kill = bb_info->kill;\n \n-  /* We need to use a scratch set here so that the value returned from\n-     this function invocation properly reflects if the sets changed in\n-     a significant way; i.e. not just because the lr set was anded\n-     in.  */\n+  /* We need to use a scratch set here so that the value returned from this\n+     function invocation properly reflects whether the sets changed in a\n+     significant way; i.e. not just because the lr set was anded in.  */\n   bitmap_and (df_live_scratch, gen, bb_lr_info->out);\n   /* No register may reach a location where it is not used.  Thus\n      we trim the rr result to the places where it is used.  */\n@@ -3975,8 +3974,8 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n    MULTIPLE DEFINITIONS\n \n    Find the locations in the function reached by multiple definition sites\n-   for a pseudo.  In and out bitvectors are built for each basic\n-   block.\n+   for a live pseudo.  In and out bitvectors are built for each basic\n+   block.  They are restricted for efficiency to live registers.\n \n    The gen and kill sets for the problem are obvious.  Together they\n    include all defined registers in a basic block; the gen set includes\n@@ -4018,6 +4017,10 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n     propagating the information to BB3's successors.\n    ---------------------------------------------------------------------------*/\n \n+/* Scratch var used by transfer functions.  This is used to do md analysis\n+   only for live registers.  */\n+static bitmap df_md_scratch;\n+\n /* Set basic block info.  */\n \n static void\n@@ -4061,6 +4064,7 @@ df_md_alloc (bitmap all_blocks)\n                                            sizeof (struct df_md_bb_info), 50);\n \n   df_grow_bb_info (df_md);\n+  df_md_scratch = BITMAP_ALLOC (NULL);\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -4236,8 +4240,10 @@ df_md_local_compute (bitmap all_blocks)\n       bitmap kill = df_md_get_bb_info (bb_index)->kill;\n       EXECUTE_IF_SET_IN_BITMAP (frontiers[bb_index], 0, df_bb_index, bi2)\n \t{\n+\t  basic_block bb = BASIC_BLOCK (df_bb_index);\n \t  if (bitmap_bit_p (all_blocks, df_bb_index))\n-\t    bitmap_ior_into (df_md_get_bb_info (df_bb_index)->init, kill);\n+\t    bitmap_ior_and_into (df_md_get_bb_info (df_bb_index)->init, kill,\n+\t\t\t\t df_get_live_in (bb));\n \t}\n     }\n \n@@ -4267,13 +4273,23 @@ df_md_reset (bitmap all_blocks)\n static bool\n df_md_transfer_function (int bb_index)\n {\n+  basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n   bitmap in = bb_info->in;\n   bitmap out = bb_info->out;\n   bitmap gen = bb_info->gen;\n   bitmap kill = bb_info->kill;\n \n-  return bitmap_ior_and_compl (out, gen, in, kill);\n+  /* We need to use a scratch set here so that the value returned from this\n+     function invocation properly reflects whether the sets changed in a\n+     significant way; i.e. not just because the live set was anded in.  */\n+  bitmap_and (df_md_scratch, gen, df_get_live_out (bb));\n+\n+  /* Multiple definitions of a register are not relevant if it is not\n+     live.  Thus we trim the result to the places where it is live.  */\n+  bitmap_and_into (in, df_get_live_in (bb));\n+\n+  return bitmap_ior_and_compl (out, df_md_scratch, in, kill);\n }\n \n /* Initialize the solution bit vectors for problem.  */\n@@ -4336,6 +4352,7 @@ df_md_free (void)\n \t}\n     }\n \n+  BITMAP_FREE (df_md_scratch);\n   free_alloc_pool (df_md->block_pool);\n \n   df_md->block_info_size = 0;"}, {"sha": "32264cda90cfde800be973a5e72e6d760413d89e", "filename": "gcc/fwprop.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=f8682ff62fb7f0d4b5ecf25ef184e0956c7a2f0a", "patch": "@@ -118,10 +118,16 @@ static int num_changes;\n \n DEF_VEC_P(df_ref);\n DEF_VEC_ALLOC_P(df_ref,heap);\n-VEC(df_ref,heap) *use_def_ref;\n-VEC(df_ref,heap) *reg_defs;\n-VEC(df_ref,heap) *reg_defs_stack;\n+static VEC(df_ref,heap) *use_def_ref;\n+static VEC(df_ref,heap) *reg_defs;\n+static VEC(df_ref,heap) *reg_defs_stack;\n \n+/* The MD bitmaps are trimmed to include only live registers to cut\n+   memory usage on testcases like insn-recog.c.  Track live registers\n+   in the basic block and do not perform forward propagation if the\n+   destination is a dead pseudo occurring in a note.  */\n+static bitmap local_md;\n+static bitmap local_lr;\n \n /* Return the only def in USE's use-def chain, or NULL if there is\n    more than one def in the chain.  */\n@@ -143,7 +149,7 @@ get_def_for_use (df_ref use)\n \t(DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER)\n \n static void\n-process_defs (bitmap local_md, df_ref *def_rec, int top_flag)\n+process_defs (df_ref *def_rec, int top_flag)\n {\n   df_ref def;\n   while ((def = *def_rec++) != NULL)\n@@ -188,48 +194,53 @@ process_defs (bitmap local_md, df_ref *def_rec, int top_flag)\n    is an artificial use vector.  */\n \n static void\n-process_uses (bitmap local_md, df_ref *use_rec, int top_flag)\n+process_uses (df_ref *use_rec, int top_flag)\n {\n   df_ref use;\n   while ((use = *use_rec++) != NULL)\n     if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == top_flag)\n       {\n         unsigned int uregno = DF_REF_REGNO (use);\n         if (VEC_index (df_ref, reg_defs, uregno)\n-\t    && !bitmap_bit_p (local_md, uregno))\n+\t    && !bitmap_bit_p (local_md, uregno)\n+\t    && bitmap_bit_p (local_lr, uregno))\n \t  VEC_replace (df_ref, use_def_ref, DF_REF_ID (use),\n \t\t       VEC_index (df_ref, reg_defs, uregno));\n       }\n }\n \n \n static void\n-single_def_use_enter_block (struct dom_walk_data *walk_data, basic_block bb)\n+single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t    basic_block bb)\n {\n-  bitmap local_md = (bitmap) walk_data->global_data;\n   int bb_index = bb->index;\n-  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+  struct df_md_bb_info *md_bb_info = df_md_get_bb_info (bb_index);\n+  struct df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n   rtx insn;\n \n-  bitmap_copy (local_md, bb_info->in);\n+  bitmap_copy (local_md, md_bb_info->in);\n+  bitmap_copy (local_lr, lr_bb_info->in);\n \n   /* Push a marker for the leave_block callback.  */\n   VEC_safe_push (df_ref, heap, reg_defs_stack, NULL);\n \n-  process_uses (local_md, df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n-  process_defs (local_md, df_get_artificial_defs (bb_index), DF_REF_AT_TOP);\n+  process_uses (df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n+  process_defs (df_get_artificial_defs (bb_index), DF_REF_AT_TOP);\n+  df_simulate_initialize_forwards (bb, local_lr);\n \n   FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))\n       {\n         unsigned int uid = INSN_UID (insn);\n-        process_uses (local_md, DF_INSN_UID_USES (uid), 0);\n-        process_uses (local_md, DF_INSN_UID_EQ_USES (uid), 0);\n-        process_defs (local_md, DF_INSN_UID_DEFS (uid), 0);\n+        process_uses (DF_INSN_UID_USES (uid), 0);\n+        process_uses (DF_INSN_UID_EQ_USES (uid), 0);\n+        process_defs (DF_INSN_UID_DEFS (uid), 0);\n+\tdf_simulate_one_insn_forwards (bb, insn, local_lr);\n       }\n \n-  process_uses (local_md, df_get_artificial_uses (bb_index), 0);\n-  process_defs (local_md, df_get_artificial_defs (bb_index), 0);\n+  process_uses (df_get_artificial_uses (bb_index), 0);\n+  process_defs (df_get_artificial_defs (bb_index), 0);\n }\n \n /* Pop the definitions created in this basic block when leaving its\n@@ -260,12 +271,12 @@ static void\n build_single_def_use_links (void)\n {\n   struct dom_walk_data walk_data;\n-  bitmap local_md;\n \n   /* We use the multiple definitions problem to compute our restricted\n      use-def chains.  */\n   df_set_flags (DF_EQ_NOTES);\n   df_md_add_problem ();\n+  df_note_add_problem ();\n   df_analyze ();\n   df_maybe_reorganize_use_refs (DF_REF_ORDER_BY_INSN_WITH_NOTES);\n \n@@ -277,19 +288,20 @@ build_single_def_use_links (void)\n \n   reg_defs_stack = VEC_alloc (df_ref, heap, n_basic_blocks * 10);\n   local_md = BITMAP_ALLOC (NULL);\n+  local_lr = BITMAP_ALLOC (NULL);\n \n   /* Walk the dominator tree looking for single reaching definitions\n      dominating the uses.  This is similar to how SSA form is built.  */\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children = single_def_use_enter_block;\n   walk_data.after_dom_children = single_def_use_leave_block;\n-  walk_data.global_data = local_md;\n \n   init_walk_dominator_tree (&walk_data);\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n   fini_walk_dominator_tree (&walk_data);\n \n+  BITMAP_FREE (local_lr);\n   BITMAP_FREE (local_md);\n   VEC_free (df_ref, heap, reg_defs);\n   VEC_free (df_ref, heap, reg_defs_stack);\n@@ -1385,11 +1397,9 @@ fwprop_done (void)\n     fprintf (dump_file,\n \t     \"\\nNumber of successful forward propagations: %d\\n\\n\",\n \t     num_changes);\n-  df_remove_problem (df_chain);\n }\n \n \n-\n /* Main entry point.  */\n \n static bool"}]}