{"sha": "d5f4edddeb609ad93c7a69ad4575b082de8dc707", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmNGVkZGRlYjYwOWFkOTNjN2E2OWFkNDU3NWIwODJkZThkYzcwNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-09-30T03:01:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-09-30T03:01:30Z"}, "message": "merge in cxx0x-lambdas-branch@152308\n\nFrom-SVN: r152318", "tree": {"sha": "a0717adf99d475ef98d9002044972a7ab9c3e5d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0717adf99d475ef98d9002044972a7ab9c3e5d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5f4edddeb609ad93c7a69ad4575b082de8dc707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f4edddeb609ad93c7a69ad4575b082de8dc707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f4edddeb609ad93c7a69ad4575b082de8dc707", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f4edddeb609ad93c7a69ad4575b082de8dc707/comments", "author": null, "committer": null, "parents": [{"sha": "300ea2831b894fc143539fe0319f39062b6e4daf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/300ea2831b894fc143539fe0319f39062b6e4daf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/300ea2831b894fc143539fe0319f39062b6e4daf"}], "stats": {"total": 3146, "additions": 3004, "deletions": 142}, "files": [{"sha": "483ca638e6c513da3ed999ef35ef73ce4092288a", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -328,6 +328,7 @@ Chris Fairles\t\t\t\t\tcfairles@gcc.gnu.org\n Li Feng\t\t\t\t\t\tnemokingdom@gmail.com\n Thomas Fitzsimmons\t\t\t\tfitzsim@redhat.com\n Brian Ford\t\t\t\t\tford@vss.fsi.com\n+John Freeman\t\t\t\t\tjfreeman08@gmail.com\n Nathan Froyd\t\t\t\t\tfroydnj@codesourcery.com\n Chao-ying Fu\t\t\t\t\tfu@mips.com\n Gary Funck\t\t\t\t\tgary@intrepid.com"}, {"sha": "44c196deb4e304d0ce016691d07091f1e4b2bd40", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1,3 +1,94 @@\n+2009-09-29  John Freeman  <jfreeman08@gmail.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tAdd support for lambda-expressions as per N2927.\n+\t* cp-tree.def (VEC_INIT_EXPR, LAMBDA_EXPR): New.\n+\t* cp-tree.h (LAMBDA_TYPE_P, LAMBDA_FUNCTION_P): New.\n+\t(LAMBDA_EXPR_DEFAULT_CAPTURE_MODE): New.\n+\t(LAMBDA_EXPR_DEFAULT_CAPTURE_LIST): New.\n+\t(LAMBDA_EXPR_THIS_CAPTURE, LAMBDA_EXPR_CAPTURES_THIS_P): New.\n+\t(LAMBDA_EXPR_MUTABLE_P, LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P): New.\n+\t(LAMBDA_EXPR_RETURN_TYPE, LAMBDA_EXPR_LOCATION): New.\n+\t(LAMBDA_EXPR_EXTRA_SCOPE, LAMBDA_EXPR_DISCRIMINATOR): New.\n+\t(struct tree_lambda_expr): New.\n+\t(union lang_tree_node): Add lambda_expression.\n+\t(struct lang_type_class): Add lazy_move_ctor flag, lambda_expr field.\n+\t(CLASSTYPE_LAZY_MOVE_CTOR, CLASSTYPE_LAMBDA_EXPR): New.\n+\t(LAMBDA_TYPE_EXTRA_SCOPE, VEC_INIT_EXPR_SLOT): New.\n+\t(VEC_INIT_EXPR_INIT, DECLTYPE_FOR_LAMBDA_CAPTURE): New.\n+\t(DECLTYPE_FOR_LAMBDA_RETURN): New.\n+\t(enum special_function_kind): Add sfk_move_constructor.\n+\t(LAMBDANAME_PREFIX, LAMBDANAME_FORMAT, LAMBDANAME_P): New.\n+\t* parser.c (cp_parser_lambda_expression, cp_parser_lambda_introducer)\n+\t(cp_parser_lambda_declarator_opt, cp_parser_lambda_body): New.\n+\t(start_lambda_scope, record_lambda_scope, finish_lambda_scope): New.\n+\t(no_linkage_lambda_type_p): New.\n+\t(cp_parser_primary_expression): Recognize lambda expression.\n+\t(cp_parser_init_declarator): Note lambda scope.\n+\t(cp_parser_function_definition_after_declarator): Likewise.\n+\t(cp_parser_late_parsing_default_args): Likewise.\n+\t(cp_parser_skip_to_closing_parenthesis): Skip to end of lambda capture\n+\tlists, too.\n+\t(cp_parser_parameter_declaration): Don't defer lambda default args.\n+\t* semantics.c (finish_non_static_data_member, finish_id_expression):\n+\tHandle default capture for lambda expressions.\n+\t(finish_this_expr): Handle 'this' keyword inside of lambda expressions.\n+\t(outer_automatic_var_p): New.\n+\t(finish_decltype_type): Handle decltypes within lambda expressions.\n+\t(classtype_has_nothrow_assign_or_copy_p): Synthesized move constructor.\n+\t(build_lambda_expr, build_lambda_object, begin_lambda_type)\n+\t(lambda_return_type, lambda_capture_field_type, apply_lambda_return_type)\n+\t(capture_decltype, add_capture, add_default_capture)\n+\t(lambda_expr_this_capture): New.\n+\t* mangle.c (write_unnamed_type_name): New. Incomplete.\n+\t(write_closure_type_name): New.\n+\t(write_unqualified_name): Recognize unnamed, closure types.\n+\t(write_type): Do not write decltypes from lambda expressions.\n+\t(decl_mangling_context): New.\n+\t(write_name): Use it.  Handle PARM_DECL scope.\n+\t(write_prefix): Likewise.  Handle VAR_DECL/FIELD_DECL scope.\n+\t(write_compact_number): Factor out from...\n+\t(write_expression, write_template_param): ...here.\n+\t(discriminator_for_local_entity): Recognize lambdas.\n+\t(write_local_name): Handle PARM_DECL scope.\n+\t* typeck.c (structural_comptypes): Compare decltypes from lambda\n+\texpressions.\n+\t(check_return_expr): Deduce lambda return type from multiple return\n+\tstatements.\n+\t* class.c (add_implicitly_declared_members): Add lazy move constructor\n+\tfor lambda types.\n+\t(check_bases_and_members): Delete default constructor and assignment\n+\toperator for lambda types.\n+\t(maybe_note_name_used_in_class): Do not confuse lambda expression with\n+\tdefining a class.\n+\t* decl.c (reshape_init_r): Array copy.\n+\t(grokfndecl): Synthesized move constructor.\n+\t(cp_tree_node_structure): Lambda expression.\n+\t* method.c (use_thunk): Synthesized move constructor.\n+\t(do_build_copy_constructor): Likewise.\n+\t(locate_copy): Likewise.\n+\t(implicitly_declare_fn): Likewise.\n+\t* cp-objcp-common.c (cp_tree_size): Handle LAMBDA_EXPR.\n+\t* error.c (dump_aggr_type): Recognize lambda type.\n+\t(dump_function_decl): Recognize lambda function.\n+\t(function_category): Likewise.\n+\t(dump_function_name): Hide lambda name.\n+\t* tree.c (build_array_copy, move): New.\n+\t(special_function_p): Synthesized move constructor.\n+\t(no_linkage_check): Handle lambdas.\n+\t* search.c (lookup_fnfields_1): Synthesized move constructor.\n+\t* cp-gimplify.c (cp_gimplify_init_expr, cp_gimplify_expr):\n+\tHandle VEC_INIT_EXPR.\n+\t* typeck2.c (digest_init_r): Array copy.\n+\t* pt.c (get_template_info): Don't touch typedefs.\n+\t(instantiate_decl): Don't resubstitute artificial decls.\n+\t(tsubst_decl, tsubst, tsubst_copy_and_build): Handle lambdas.\n+\t(lookup_template_class): Don't fall back on name lookup.\n+\t* name-lookup.c (make_lambda_name): New.\n+\t(pushdecl_class_level): Handle default capture for lambda expressions.\n+\t(qualify_lookup): Handle decltypes within lambda expressions.\n+\t(pushtag): Handle ts_within_enclosing_non_class in function scope.\n+\n 2009-09-28  Janis Johnson  <janis187@us.ibm.com>\n \n \t* mangle.c (write_builtin_type): Support decimal float types."}, {"sha": "d29d6615f331552c1f502040ba84b0c242ed5923", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -2677,6 +2677,10 @@ add_implicitly_declared_members (tree t,\n       CLASSTYPE_LAZY_COPY_CTOR (t) = 1;\n     }\n \n+  /* Currently only lambdas get a lazy move ctor.  */\n+  if (LAMBDA_TYPE_P (t))\n+    CLASSTYPE_LAZY_MOVE_CTOR (t) = 1;\n+\n   /* If there is no assignment operator, one will be created if and\n      when it is needed.  For now, just record whether or not the type\n      of the parameter to the assignment operator will be a const or\n@@ -4449,6 +4453,20 @@ check_bases_and_members (tree t)\n \t\t\t\t   cant_have_const_ctor,\n \t\t\t\t   no_const_asn_ref);\n \n+  if (LAMBDA_TYPE_P (t))\n+    {\n+      /* \"The closure type associated with a lambda-expression has a deleted\n+\t default constructor and a deleted copy assignment operator.\"  */\n+      TYPE_NEEDS_CONSTRUCTING (t) = 1;\n+      TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n+      CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 0;\n+      TYPE_HAS_ASSIGN_REF (t) = 0;\n+      CLASSTYPE_LAZY_ASSIGNMENT_OP (t) = 0;\n+\n+      /* \"This class type is not an aggregate.\"  */\n+      CLASSTYPE_NON_AGGREGATE (t) = 1;\n+    }\n+\n   /* Create the in-charge and not-in-charge variants of constructors\n      and destructors.  */\n   clone_constructors_and_destructors (t);\n@@ -6601,7 +6619,8 @@ maybe_note_name_used_in_class (tree name, tree decl)\n \n   /* If we're not defining a class, there's nothing to do.  */\n   if (!(innermost_scope_kind() == sk_class\n-\t&& TYPE_BEING_DEFINED (current_class_type)))\n+\t&& TYPE_BEING_DEFINED (current_class_type)\n+\t&& !LAMBDA_TYPE_P (current_class_type)))\n     return;\n \n   /* If there's already a binding for this NAME, then we don't have"}, {"sha": "017c8a98e454372fd8bfe79097bbc5fe61639425", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -452,10 +452,14 @@ cp_gimplify_init_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \n \t Should we add a target parm to gimplify_expr instead?  No, as in this\n \t case we want to replace the INIT_EXPR.  */\n-      if (TREE_CODE (sub) == AGGR_INIT_EXPR)\n+      if (TREE_CODE (sub) == AGGR_INIT_EXPR\n+\t  || TREE_CODE (sub) == VEC_INIT_EXPR)\n \t{\n \t  gimplify_expr (&to, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n-\t  AGGR_INIT_EXPR_SLOT (sub) = to;\n+\t  if (TREE_CODE (sub) == AGGR_INIT_EXPR)\n+\t    AGGR_INIT_EXPR_SLOT (sub) = to;\n+\t  else\n+\t    VEC_INIT_EXPR_SLOT (sub) = to;\n \t  *expr_p = from;\n \n \t  /* The initialization is now a side-effect, so the container can\n@@ -523,6 +527,19 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       ret = GS_OK;\n       break;\n \n+    case VEC_INIT_EXPR:\n+      {\n+\tlocation_t loc = input_location;\n+\tgcc_assert (EXPR_HAS_LOCATION (*expr_p));\n+\tinput_location = EXPR_LOCATION (*expr_p);\n+\t*expr_p = build_vec_init (VEC_INIT_EXPR_SLOT (*expr_p), NULL_TREE,\n+\t\t\t\t  VEC_INIT_EXPR_INIT (*expr_p), false, 1,\n+\t\t\t\t  tf_warning_or_error);\n+\tret = GS_OK;\n+\tinput_location = loc;\n+      }\n+      break;\n+\n     case THROW_EXPR:\n       /* FIXME communicate throw type to back end, probably by moving\n \t THROW_EXPR into ../tree.def.  */"}, {"sha": "da6f8291ba4586aa40edbbfcf8fd8f631389c3db", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -138,6 +138,8 @@ cp_tree_size (enum tree_code code)\n     case TRAIT_EXPR:\n       return sizeof (struct tree_trait_expr);\n \n+    case LAMBDA_EXPR:           return sizeof (struct tree_lambda_expr);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "4df01a8e205316d88ec83374351b51602264f3a3", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -81,6 +81,11 @@ DEFTREECODE (TYPE_EXPR, \"type_expr\", tcc_expression, 1)\n    the remaining operands are the arguments to the initialization function.  */\n DEFTREECODE (AGGR_INIT_EXPR, \"aggr_init_expr\", tcc_vl_exp, 3)\n \n+/* Initialization of an array from another array, expressed at a high level\n+   so that it works with TARGET_EXPR.  Operand 0 is the target, operand 1\n+   is the initializer.  */\n+DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", tcc_expression, 2)\n+\n /* A throw expression.  operand 0 is the expression, if there was one,\n    else it is NULL_TREE.  */\n DEFTREECODE (THROW_EXPR, \"throw_expr\", tcc_expression, 1)\n@@ -416,11 +421,22 @@ DEFTREECODE (ARGUMENT_PACK_SELECT, \"argument_pack_select\", tcc_exceptional, 0)\n /* Represents a trait expression during template expansion.  */\n DEFTREECODE (TRAIT_EXPR, \"trait_expr\", tcc_exceptional, 0)\n \n+/* A lambda expression.  This is a C++0x extension.\n+   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE is an enum for the default, which may be\n+   none.\n+   LAMBDA_EXPR_CAPTURE_LIST holds the capture-list, including `this'.\n+   LAMBDA_EXPR_THIS_CAPTURE goes straight to the capture of `this', if it exists.\n+   LAMBDA_EXPR_MUTABLE_P signals whether this lambda was declared mutable.\n+   LAMBDA_EXPR_RETURN_TYPE holds the return type, if it was specified.  */\n+DEFTREECODE (LAMBDA_EXPR, \"lambda_expr\", tcc_exceptional, 0)\n+\n /* The declared type of an expression.  This is a C++0x extension.\n    DECLTYPE_TYPE_EXPR is the expression whose type we are computing.\n    DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P states whether the\n    expression was parsed as an id-expression or a member access\n-   expression. When false, it was parsed as a full expression.  */\n+   expression. When false, it was parsed as a full expression.\n+   DECLTYPE_FOR_LAMBDA_CAPTURE is set if we want lambda capture semantics.\n+   DECLTYPE_FOR_LAMBDA_RETURN is set if we want lambda return deduction.  */\n DEFTREECODE (DECLTYPE_TYPE, \"decltype_type\", tcc_type, 0)\n \n /*"}, {"sha": "0487a9f0aacb4cf04744342f712f55cf715034b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -77,6 +77,8 @@ framework extensions, you must include this file before toplev.h, not after.\n       TYPE_REF_IS_RVALUE (in REFERENCE_TYPE)\n       ATTR_IS_DEPENDENT (in the TREE_LIST for an attribute)\n       CONSTRUCTOR_IS_DIRECT_INIT (in CONSTRUCTOR)\n+      LAMBDA_EXPR_CAPTURES_THIS_P (in LAMBDA_EXPR)\n+      DECLTYPE_FOR_LAMBDA_CAPTURE (in DECLTYPE_TYPE)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -87,11 +89,14 @@ framework extensions, you must include this file before toplev.h, not after.\n       TYPENAME_IS_CLASS_P (in TYPENAME_TYPE)\n       STMT_IS_FULL_EXPR_P (in _STMT)\n       TARGET_EXPR_LIST_INIT_P (in TARGET_EXPR)\n+      LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)\n+      DECLTYPE_FOR_LAMBDA_RETURN (in DECLTYPE_TYPE)\n    2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n       TYPENAME_IS_RESOLVING_P (in TYPE_NAME_TYPE)\n+      LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (in LAMBDA_EXPR)\n    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n@@ -517,6 +522,81 @@ struct GTY (()) tree_trait_expr {\n   enum cp_trait_kind kind;\n };\n \n+/* Based off of TYPE_ANONYMOUS_P.  */\n+#define LAMBDA_TYPE_P(NODE) \\\n+  (CLASS_TYPE_P (NODE) && LAMBDANAME_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n+\n+/* Test if FUNCTION_DECL is a lambda function.  */\n+#define LAMBDA_FUNCTION_P(FNDECL) \\\n+  (DECL_OVERLOADED_OPERATOR_P (FNDECL) == CALL_EXPR \\\n+   && LAMBDA_TYPE_P (CP_DECL_CONTEXT (FNDECL)))\n+\n+enum cp_lambda_default_capture_mode_type {\n+  CPLD_NONE,\n+  CPLD_COPY,\n+  CPLD_REFERENCE\n+};\n+\n+/* The method of default capture, if any.  */\n+#define LAMBDA_EXPR_DEFAULT_CAPTURE_MODE(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->default_capture_mode)\n+\n+/* The capture-list, including `this'.  Each capture is stored as a FIELD_DECL\n+ * so that the name, type, and field are all together, whether or not it has\n+ * been added to the lambda's class type.\n+   TREE_LIST:\n+     TREE_PURPOSE: The FIELD_DECL for this capture.\n+     TREE_VALUE: The initializer. This is part of a GNU extension.  */\n+#define LAMBDA_EXPR_CAPTURE_LIST(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->capture_list)\n+\n+/* The node in the capture-list that holds the 'this' capture.  */\n+#define LAMBDA_EXPR_THIS_CAPTURE(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->this_capture)\n+\n+/* Predicate tracking whether `this' is in the effective capture set.  */\n+#define LAMBDA_EXPR_CAPTURES_THIS_P(NODE) \\\n+  LAMBDA_EXPR_THIS_CAPTURE(NODE)\n+\n+/* Predicate tracking whether the lambda was declared 'mutable'.  */\n+#define LAMBDA_EXPR_MUTABLE_P(NODE) \\\n+  TREE_LANG_FLAG_1 (LAMBDA_EXPR_CHECK (NODE))\n+\n+/* True iff we should try to deduce the lambda return type from any return\n+   statement.  */\n+#define LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P(NODE) \\\n+  TREE_LANG_FLAG_2 (LAMBDA_EXPR_CHECK (NODE))\n+\n+/* The return type in the expression.\n+ * NULL_TREE indicates that none was specified.  */\n+#define LAMBDA_EXPR_RETURN_TYPE(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->return_type)\n+\n+/* The source location of the lambda.  */\n+#define LAMBDA_EXPR_LOCATION(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->locus)\n+\n+/* The mangling scope for the lambda: FUNCTION_DECL, PARM_DECL, VAR_DECL,\n+   FIELD_DECL or NULL_TREE.  If this is NULL_TREE, we have no linkage.  */\n+#define LAMBDA_EXPR_EXTRA_SCOPE(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->extra_scope)\n+\n+/* If EXTRA_SCOPE, this is the number of the lambda within that scope.  */\n+#define LAMBDA_EXPR_DISCRIMINATOR(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->discriminator)\n+\n+struct GTY (()) tree_lambda_expr\n+{\n+  struct tree_common common;\n+  location_t locus;\n+  enum cp_lambda_default_capture_mode_type default_capture_mode;\n+  tree capture_list;\n+  tree this_capture;\n+  tree return_type;\n+  tree extra_scope;\n+  int discriminator;\n+};\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_GENERIC,\n   TS_CP_IDENTIFIER,\n@@ -530,6 +610,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_STATIC_ASSERT,\n   TS_CP_ARGUMENT_PACK_SELECT,\n   TS_CP_TRAIT_EXPR,\n+  TS_CP_LAMBDA_EXPR,\n   LAST_TS_CP_ENUM\n };\n \n@@ -550,6 +631,8 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n     argument_pack_select;\n   struct tree_trait_expr GTY ((tag (\"TS_CP_TRAIT_EXPR\")))\n     trait_expression;\n+  struct tree_lambda_expr GTY ((tag (\"TS_CP_LAMBDA_EXPR\")))\n+    lambda_expression;\n };\n \n \f\n@@ -1127,6 +1210,7 @@ struct GTY(()) lang_type_class {\n   unsigned has_complex_dflt : 1;\n   unsigned has_list_ctor : 1;\n   unsigned non_std_layout : 1;\n+  unsigned lazy_move_ctor : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1135,7 +1219,7 @@ struct GTY(()) lang_type_class {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 9;\n+  unsigned dummy : 8;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -1159,6 +1243,8 @@ struct GTY(()) lang_type_class {\n      to resort it if pointers get rearranged.  */\n   struct sorted_fields_type * GTY ((reorder (\"resort_sorted_fields\")))\n     sorted_fields;\n+  /* FIXME reuse another field?  */\n+  tree lambda_expr;\n };\n \n struct GTY(()) lang_type_ptrmem {\n@@ -1221,6 +1307,11 @@ struct GTY(()) lang_type {\n #define CLASSTYPE_LAZY_COPY_CTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->lazy_copy_ctor)\n \n+/* Nonzero means that NODE (a class type) has a move constructor --\n+   but that it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_MOVE_CTOR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_move_ctor)\n+\n /* Nonzero means that NODE (a class type) has an assignment operator\n    -- but that it has not yet been declared.  */\n #define CLASSTYPE_LAZY_ASSIGNMENT_OP(NODE) \\\n@@ -1426,6 +1517,13 @@ struct GTY(()) lang_type {\n #define CLASSTYPE_BEFRIENDING_CLASSES(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->befriending_classes)\n \n+/* The associated LAMBDA_EXPR that made this class.  */\n+#define CLASSTYPE_LAMBDA_EXPR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lambda_expr)\n+/* The extra mangling scope for this closure type.  */\n+#define LAMBDA_TYPE_EXTRA_SCOPE(NODE) \\\n+  (LAMBDA_EXPR_EXTRA_SCOPE (CLASSTYPE_LAMBDA_EXPR (NODE)))\n+\n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->declared_class)\n@@ -2625,6 +2723,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   for ((arg) = first_aggr_init_expr_arg ((call), &(iter)); (arg);\t\\\n        (arg) = next_aggr_init_expr_arg (&(iter)))\n \n+/* VEC_INIT_EXPR accessors.  */\n+#define VEC_INIT_EXPR_SLOT(NODE) TREE_OPERAND (NODE, 0)\n+#define VEC_INIT_EXPR_INIT(NODE) TREE_OPERAND (NODE, 1)\n+\n /* The TYPE_MAIN_DECL for a class template type is a TYPE_DECL, not a\n    TEMPLATE_DECL.  This macro determines whether or not a given class\n    type is really a template type, as opposed to an instantiation or\n@@ -3058,6 +3160,14 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P(NODE) \\\n   (DECLTYPE_TYPE_CHECK (NODE))->type.string_flag\n \n+/* These flags indicate that we want different semantics from normal\n+   decltype: lambda capture just drops references, lambda return also does\n+   type decay.  */\n+#define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \\\n+  TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))\n+#define DECLTYPE_FOR_LAMBDA_RETURN(NODE) \\\n+  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))\n+\n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  This can also be set for an\n    erroneously declared PARM_DECL.  */\n@@ -3570,6 +3680,7 @@ typedef enum special_function_kind {\n \t\t\t      special_function_p.  */\n   sfk_constructor,\t   /* A constructor.  */\n   sfk_copy_constructor,    /* A copy constructor.  */\n+  sfk_move_constructor,    /* A move constructor.  */\n   sfk_assignment_operator, /* An assignment operator.  */\n   sfk_destructor,\t   /* A destructor.  */\n   sfk_complete_destructor, /* A destructor for complete objects.  */\n@@ -3778,6 +3889,13 @@ extern GTY(()) VEC(tree,gc) *local_classes;\n #define VTABLE_DELTA_NAME\t\"__delta\"\n #define VTABLE_PFN_NAME\t\t\"__pfn\"\n \n+#define LAMBDANAME_PREFIX \"__lambda\"\n+#define LAMBDANAME_FORMAT LAMBDANAME_PREFIX \"%d\"\n+#define LAMBDANAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), \\\n+             LAMBDANAME_PREFIX, \\\n+\t     sizeof (LAMBDANAME_PREFIX) - 1))\n+\n #if !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL)\n \n #define VTABLE_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == 'v' \\\n@@ -4377,6 +4495,7 @@ enum cp_tree_node_structure_enum cp_tree_node_structure\n extern void finish_scope\t\t\t(void);\n extern void push_switch\t\t\t\t(tree);\n extern void pop_switch\t\t\t\t(void);\n+extern tree make_lambda_name\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n extern tree duplicate_decls\t\t\t(tree, tree, bool);\n extern tree declare_local_label\t\t\t(tree);\n@@ -4897,6 +5016,16 @@ extern void finish_static_assert                (tree, tree, location_t,\n extern tree describable_type\t\t\t(tree);\n extern tree finish_decltype_type                (tree, bool);\n extern tree finish_trait_expr\t\t\t(enum cp_trait_kind, tree, tree);\n+extern tree build_lambda_expr                   (void);\n+extern tree build_lambda_object\t\t\t(tree);\n+extern tree begin_lambda_type                   (tree);\n+extern tree lambda_capture_field_type\t\t(tree);\n+extern tree lambda_return_type\t\t\t(tree);\n+extern tree lambda_function\t\t\t(tree);\n+extern void apply_lambda_return_type            (tree, tree);\n+extern tree add_capture                         (tree, tree, tree, bool);\n+extern tree add_default_capture                 (tree, tree, tree);\n+extern tree lambda_expr_this_capture            (tree);\n \n /* in tree.c */\n void cp_free_lang_data \t\t\t\t(tree t);\n@@ -4934,6 +5063,7 @@ extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree build_array_of_n_type\t\t(tree, int);\n+extern tree build_array_copy\t\t\t(tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern tree build_qualified_name\t\t(tree, tree, tree, bool);\n@@ -4965,6 +5095,7 @@ extern const struct attribute_spec cxx_attribute_table[];\n extern tree make_ptrmem_cst\t\t\t(tree, tree);\n extern tree cp_build_type_attribute_variant     (tree, tree);\n extern tree cp_build_reference_type\t\t(tree, bool);\n+extern tree move\t\t\t\t(tree);\n extern tree cp_build_qualified_type_real\t(tree, int, tsubst_flags_t);\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), tf_warning_or_error)\n@@ -5157,6 +5288,9 @@ extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n extern void cxx_omp_finish_clause\t\t(tree);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n \n+/* in parser.c */\n+extern bool no_linkage_lambda_type_p\t\t(tree);\n+\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "80238c18881de55bb02a5398dbcf0799def5dc84", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -4921,7 +4921,8 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n \t looking through the outermost braces; A a2 = { a1 }; is not a\n \t valid aggregate initialization.  */\n       && !first_initializer_p\n-      && can_convert_arg (type, TREE_TYPE (init), init, LOOKUP_NORMAL))\n+      && (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (init))\n+\t  || can_convert_arg (type, TREE_TYPE (init), init, LOOKUP_NORMAL)))\n     {\n       d->cur++;\n       return init;\n@@ -6622,6 +6623,7 @@ grokfndecl (tree ctype,\n     {\n     case sfk_constructor:\n     case sfk_copy_constructor:\n+    case sfk_move_constructor:\n       DECL_CONSTRUCTOR_P (decl) = 1;\n       break;\n     case sfk_destructor:\n@@ -12687,6 +12689,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case STATIC_ASSERT:\t\treturn TS_CP_STATIC_ASSERT;\n     case ARGUMENT_PACK_SELECT:  return TS_CP_ARGUMENT_PACK_SELECT;\n     case TRAIT_EXPR:\t\treturn TS_CP_TRAIT_EXPR;\n+    case LAMBDA_EXPR:\t\treturn TS_CP_LAMBDA_EXPR;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "b50704a3ae4663f1555d79fd2ab94cdb912b245d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -597,6 +597,15 @@ dump_aggr_type (tree t, int flags)\n       else\n \tpp_printf (pp_base (cxx_pp), M_(\"<anonymous %s>\"), variety);\n     }\n+  else if (LAMBDANAME_P (name))\n+    {\n+      /* A lambda's \"type\" is essentially its signature.  */\n+      pp_string (cxx_pp, M_(\"<lambda\"));\n+      if (lambda_function (t))\n+\tdump_parameters (FUNCTION_FIRST_USER_PARMTYPE (lambda_function (t)),\n+\t\t\t flags);\n+      pp_character(cxx_pp, '>');\n+    }\n   else\n     pp_cxx_tree_identifier (cxx_pp, name);\n   if (tmplate)\n@@ -1224,6 +1233,14 @@ dump_function_decl (tree t, int flags)\n   tree exceptions;\n   VEC(tree,gc) *typenames = NULL;\n \n+  if (LAMBDA_FUNCTION_P (t))\n+    {\n+      /* A lambda's signature is essentially its \"type\", so defer.  */\n+      gcc_assert (LAMBDA_TYPE_P (DECL_CONTEXT (t)));\n+      dump_type (DECL_CONTEXT (t), flags);\n+      return;\n+    }\n+\n   flags &= ~TFF_UNQUALIFIED_NAME;\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n@@ -1401,7 +1418,12 @@ dump_function_name (tree t, int flags)\n   /* Don't let the user see __comp_ctor et al.  */\n   if (DECL_CONSTRUCTOR_P (t)\n       || DECL_DESTRUCTOR_P (t))\n-    name = constructor_name (DECL_CONTEXT (t));\n+    {\n+      if (LAMBDA_TYPE_P (DECL_CONTEXT (t)))\n+\tname = get_identifier (\"<lambda>\");\n+      else\n+\tname = constructor_name (DECL_CONTEXT (t));\n+    }\n \n   if (DECL_DESTRUCTOR_P (t))\n     {\n@@ -2676,6 +2698,8 @@ function_category (tree fn)\n \treturn _(\"In constructor %qs\");\n       else if (DECL_DESTRUCTOR_P (fn))\n \treturn _(\"In destructor %qs\");\n+      else if (LAMBDA_FUNCTION_P (fn))\n+\treturn _(\"In lambda function\");\n       else\n \treturn _(\"In member function %qs\");\n     }"}, {"sha": "1e08465195cce6163af246c32ee887270e54f9cf", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 133, "deletions": 24, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -182,10 +182,13 @@ static void write_template_prefix (const tree);\n static void write_unqualified_name (const tree);\n static void write_conversion_operator_name (const tree);\n static void write_source_name (tree);\n+static void write_unnamed_type_name (const tree);\n+static void write_closure_type_name (const tree);\n static int hwint_to_ascii (unsigned HOST_WIDE_INT, const unsigned int, char *,\n \t\t\t   const unsigned int);\n static void write_number (unsigned HOST_WIDE_INT, const int,\n \t\t\t  const unsigned int);\n+static void write_compact_number (int num);\n static void write_integer_cst (const tree);\n static void write_real_cst (const tree);\n static void write_identifier (const char *);\n@@ -211,7 +214,7 @@ static void write_substitution (const int);\n static int discriminator_for_local_entity (tree);\n static int discriminator_for_string_literal (tree, tree);\n static void write_discriminator (const int);\n-static void write_local_name (const tree, const tree, const tree);\n+static void write_local_name (tree, const tree, const tree);\n static void dump_substitution_candidates (void);\n static tree mangle_decl_string (const tree);\n \n@@ -744,6 +747,22 @@ needs_fake_anon (const_tree decl)\n \t  && TREE_CODE (decl) == FUNCTION_DECL);\n }\n \n+/* Lambdas can have a bit more context for mangling, specifically VAR_DECL\n+   or PARM_DECL context, which doesn't belong in DECL_CONTEXT.  */\n+\n+static tree\n+decl_mangling_context (tree decl)\n+{\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      tree extra = LAMBDA_TYPE_EXTRA_SCOPE (TREE_TYPE (decl));\n+      if (extra)\n+\treturn extra;\n+    }\n+  return CP_DECL_CONTEXT (decl);\n+}\n+\n /* <name> ::= <unscoped-name>\n \t  ::= <unscoped-template-name> <template-args>\n \t  ::= <nested-name>\n@@ -767,10 +786,9 @@ write_name (tree decl, const int ignore_local_scope)\n       /* In case this is a typedef, fish out the corresponding\n \t TYPE_DECL for the main variant.  */\n       decl = TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n-      context = CP_TYPE_CONTEXT (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n     }\n-  else\n-    context = CP_DECL_CONTEXT (decl);\n+\n+  context = decl_mangling_context (decl);\n \n   gcc_assert (context != NULL_TREE);\n \n@@ -822,7 +840,8 @@ write_name (tree decl, const int ignore_local_scope)\n \t      if (TYPE_P (context))\n \t\tcontext = TYPE_NAME (context);\n \t      /* Is this a function?  */\n-\t      if (TREE_CODE (context) == FUNCTION_DECL)\n+\t      if (TREE_CODE (context) == FUNCTION_DECL\n+\t\t  || TREE_CODE (context) == PARM_DECL)\n \t\t{\n \t\t  /* Yes, we have local scope.  Use the <local-name>\n \t\t     production for the innermost function scope.  */\n@@ -831,7 +850,7 @@ write_name (tree decl, const int ignore_local_scope)\n \t\t}\n \t      /* Up one scope level.  */\n \t      local_entity = context;\n-\t      context = CP_DECL_CONTEXT (context);\n+\t      context = decl_mangling_context (context);\n \t    }\n \n \t  /* No local scope found?  Fall through to <nested-name>.  */\n@@ -955,23 +974,24 @@ write_prefix (const tree node)\n   /* Non-NULL if NODE represents a template-id.  */\n   tree template_info = NULL;\n \n-  MANGLE_TRACE_TREE (\"prefix\", node);\n-\n   if (node == NULL\n       || node == global_namespace)\n     return;\n \n+  MANGLE_TRACE_TREE (\"prefix\", node);\n+\n   if (find_substitution (node))\n     return;\n \n   if (DECL_P (node))\n     {\n-      /* If this is a function decl, that means we've hit function\n+      /* If this is a function or parm decl, that means we've hit function\n \t scope, so this prefix must be for a local name.  In this\n \t case, we're under the <local-name> production, which encodes\n \t the enclosing function scope elsewhere.  So don't continue\n \t here.  */\n-      if (TREE_CODE (node) == FUNCTION_DECL)\n+      if (TREE_CODE (node) == FUNCTION_DECL\n+\t  || TREE_CODE (node) == PARM_DECL)\n \treturn;\n \n       decl = node;\n@@ -1016,8 +1036,15 @@ write_prefix (const tree node)\n   else\n     /* Not templated.  */\n     {\n-      write_prefix (CP_DECL_CONTEXT (decl));\n+      write_prefix (decl_mangling_context (decl));\n       write_unqualified_name (decl);\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == FIELD_DECL)\n+\t{\n+\t  /* <data-member-prefix> := <member source-name> M */\n+\t  write_char ('M');\n+\t  return;\n+\t}\n     }\n \n   add_substitution (node);\n@@ -1107,6 +1134,7 @@ write_template_prefix (const tree node)\n     <unqualified-name>  ::= <operator-name>\n \t\t\t::= <special-name>\n \t\t\t::= <source-name>\n+\t\t\t::= <unnamed-type-name>\n \t\t\t::= <local-source-name> \n \n     <local-source-name>\t::= L <source-name> <discriminator> */\n@@ -1172,7 +1200,19 @@ write_unqualified_name (const tree decl)\n \t so there's no code to output one here.  */\n     }\n   else\n-    write_source_name (DECL_NAME (decl));\n+    {\n+      tree type = TREE_TYPE (decl);\n+\n+      if (TREE_CODE (decl) == TYPE_DECL\n+          && TYPE_ANONYMOUS_P (type)\n+          && !ANON_UNION_TYPE_P (type))\n+        write_unnamed_type_name (type);\n+      else if (TREE_CODE (decl) == TYPE_DECL\n+               && LAMBDA_TYPE_P (type))\n+        write_closure_type_name (type);\n+      else\n+        write_source_name (DECL_NAME (decl));\n+    }\n }\n \n /* Write the unqualified-name for a conversion operator to TYPE.  */\n@@ -1202,6 +1242,44 @@ write_source_name (tree identifier)\n   write_identifier (IDENTIFIER_POINTER (identifier));\n }\n \n+/* Encode 0 as _, and 1+ as n-1_.  */\n+\n+static void\n+write_compact_number (int num)\n+{\n+  if (num > 0)\n+    write_unsigned_number (num - 1);\n+  write_char ('_');\n+}\n+\n+static void\n+write_unnamed_type_name (const tree type __attribute__ ((__unused__)))\n+{\n+  MANGLE_TRACE_TREE (\"unnamed-type-name\", type);\n+\n+  write_string (\"Ut\");\n+  /* TODO: Implement discriminators for unnamed-types.  */\n+  write_char ('_');\n+}\n+\n+/* <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _\n+   <lambda-sig> ::= <parameter type>+  # Parameter types or \"v\" if the lambda has no parameters */\n+\n+static void\n+write_closure_type_name (const tree type)\n+{\n+  tree fn = lambda_function (type);\n+  tree lambda = CLASSTYPE_LAMBDA_EXPR (type);\n+  tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\n+  MANGLE_TRACE_TREE (\"closure-type-name\", type);\n+\n+  write_string (\"Ul\");\n+  write_method_parms (parms, /*method_p=*/1, fn);\n+  write_char ('E');\n+  write_compact_number (LAMBDA_EXPR_DISCRIMINATOR (lambda));\n+}\n+\n /* Convert NUMBER to ascii using base BASE and generating at least\n    MIN_DIGITS characters. BUFFER points to the _end_ of the buffer\n    into which to store the characters. Returns the number of\n@@ -1479,6 +1557,11 @@ discriminator_for_local_entity (tree entity)\n \n       /* Scan the list of local classes.  */\n       entity = TREE_TYPE (entity);\n+\n+      /* Lambdas and unnamed types have their own discriminators.  */\n+      if (LAMBDA_TYPE_P (entity) || TYPE_ANONYMOUS_P (entity))\n+\treturn 0;\n+\n       for (ix = 0; ; ix++)\n \t{\n \t  tree type = VEC_index (tree, local_classes, ix);\n@@ -1523,23 +1606,49 @@ write_discriminator (const int discriminator)\n }\n \n /* Mangle the name of a function-scope entity.  FUNCTION is the\n-   FUNCTION_DECL for the enclosing function.  ENTITY is the decl for\n-   the entity itself.  LOCAL_ENTITY is the entity that's directly\n-   scoped in FUNCTION_DECL, either ENTITY itself or an enclosing scope\n-   of ENTITY.\n+   FUNCTION_DECL for the enclosing function, or a PARM_DECL for lambdas in\n+   default argument scope.  ENTITY is the decl for the entity itself.\n+   LOCAL_ENTITY is the entity that's directly scoped in FUNCTION_DECL,\n+   either ENTITY itself or an enclosing scope of ENTITY.\n \n      <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n-\t\t  := Z <function encoding> E s [<discriminator>]  */\n+\t\t  := Z <function encoding> E s [<discriminator>]\n+\t\t  := Z <function encoding> Ed [ <parameter number> ] _ <entity name> */\n \n static void\n-write_local_name (const tree function, const tree local_entity,\n+write_local_name (tree function, const tree local_entity,\n \t\t  const tree entity)\n {\n+  tree parm = NULL_TREE;\n+\n   MANGLE_TRACE_TREE (\"local-name\", entity);\n \n+  if (TREE_CODE (function) == PARM_DECL)\n+    {\n+      parm = function;\n+      function = DECL_CONTEXT (parm);\n+    }\n+\n   write_char ('Z');\n   write_encoding (function);\n   write_char ('E');\n+\n+  /* For this purpose, parameters are numbered from right-to-left.  */\n+  if (parm)\n+    {\n+      tree t;\n+      int i = 0;\n+      for (t = DECL_ARGUMENTS (function); t; t = TREE_CHAIN (t))\n+\t{\n+\t  if (t == parm)\n+\t    i = 1;\n+\t  else if (i)\n+\t    ++i;\n+\t}\n+      write_char ('d');\n+      write_compact_number (i - 1);\n+    }\n+\n   if (TREE_CODE (entity) == STRING_CST)\n     {\n       write_char ('s');\n@@ -1718,6 +1827,10 @@ write_type (tree type)\n               break;\n \n             case DECLTYPE_TYPE:\n+\t      /* These shouldn't make it into mangling.  */\n+\t      gcc_assert (!DECLTYPE_FOR_LAMBDA_CAPTURE (type)\n+\t\t\t  && !DECLTYPE_FOR_LAMBDA_RETURN (type));\n+\n               write_char ('D');\n               if (DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type))\n                 write_char ('t');\n@@ -2236,9 +2349,7 @@ write_expression (tree expr)\n       int index = DECL_PARM_INDEX (expr);\n       gcc_assert (index >= 1);\n       write_string (\"fp\");\n-      if (index > 1)\n-\twrite_unsigned_number (index - 2);\n-      write_char ('_');\n+      write_compact_number (index - 1);\n     }\n   else if (DECL_P (expr))\n     {\n@@ -2701,9 +2812,7 @@ write_template_param (const tree parm)\n   write_char ('T');\n   /* NUMBER as it appears in the mangling is (-1)-indexed, with the\n      earliest template param denoted by `_'.  */\n-  if (parm_index > 0)\n-    write_unsigned_number (parm_index - 1);\n-  write_char ('_');\n+  write_compact_number (parm_index);\n }\n \n /*  <template-template-param>"}, {"sha": "e8b28d877d7744605ff8e38070b4fe277d622848", "filename": "gcc/cp/method.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -530,12 +530,13 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \f\n /* Code for synthesizing methods which have default semantics defined.  */\n \n-/* Generate code for default X(X&) constructor.  */\n+/* Generate code for default X(X&) or X(X&&) constructor.  */\n \n static void\n do_build_copy_constructor (tree fndecl)\n {\n   tree parm = FUNCTION_FIRST_USER_PARM (fndecl);\n+  bool move_p = DECL_MOVE_CONSTRUCTOR_P (fndecl);\n \n   parm = convert_from_reference (parm);\n \n@@ -555,6 +556,7 @@ do_build_copy_constructor (tree fndecl)\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n       tree binfo, base_binfo;\n+      tree init;\n       VEC(tree,gc) *vbases;\n \n       /* Initialize all the base-classes with the parameter converted\n@@ -565,11 +567,12 @@ do_build_copy_constructor (tree fndecl)\n       for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n \t   VEC_iterate (tree, vbases, i, binfo); i++)\n \t{\n+\t  init = build_base_path (PLUS_EXPR, parm, binfo, 1);\n+\t  if (move_p)\n+\t    init = move (init);\n \t  member_init_list\n \t    = tree_cons (binfo,\n-\t\t\t build_tree_list (NULL_TREE,\n-\t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n-\t\t\t\t\t\t\t   binfo, 1)),\n+\t\t\t build_tree_list (NULL_TREE, init),\n \t\t\t member_init_list);\n \t}\n \n@@ -579,17 +582,17 @@ do_build_copy_constructor (tree fndecl)\n \t  if (BINFO_VIRTUAL_P (base_binfo))\n \t    continue;\n \n+\t  init = build_base_path (PLUS_EXPR, parm, base_binfo, 1);\n+\t  if (move_p)\n+\t    init = move (init);\n \t  member_init_list\n \t    = tree_cons (base_binfo,\n-\t\t\t build_tree_list (NULL_TREE,\n-\t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n-\t\t\t\t\t\t\t   base_binfo, 1)),\n+\t\t\t build_tree_list (NULL_TREE, init),\n \t\t\t member_init_list);\n \t}\n \n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n-\t  tree init = parm;\n \t  tree field = fields;\n \t  tree expr_type;\n \n@@ -622,7 +625,9 @@ do_build_copy_constructor (tree fndecl)\n \t      expr_type = cp_build_qualified_type (expr_type, quals);\n \t    }\n \n-\t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n+\t  init = build3 (COMPONENT_REF, expr_type, parm, field, NULL_TREE);\n+\t  if (move_p && TREE_CODE (expr_type) != REFERENCE_TYPE)\n+\t    init = move (init);\n \t  init = build_tree_list (NULL_TREE, init);\n \n \t  member_init_list = tree_cons (field, init, member_init_list);\n@@ -936,6 +941,8 @@ locate_copy (tree type, void *client_)\n \t it now.  */\n       if (CLASSTYPE_LAZY_COPY_CTOR (type))\n \tlazily_declare_fn (sfk_copy_constructor, type);\n+      if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n+\tlazily_declare_fn (sfk_move_constructor, type);\n       fns = CLASSTYPE_CONSTRUCTORS (type);\n     }\n   else\n@@ -1036,6 +1043,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n \n     case sfk_copy_constructor:\n     case sfk_assignment_operator:\n+    case sfk_move_constructor:\n     {\n       struct copy_data data;\n \n@@ -1057,7 +1065,9 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n \t}\n       else\n \trhs_parm_type = type;\n-      rhs_parm_type = build_reference_type (rhs_parm_type);\n+      rhs_parm_type\n+\t= cp_build_reference_type (rhs_parm_type,\n+\t\t\t\t   kind == sfk_move_constructor);\n       parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n       raises = synthesize_exception_spec (type, &locate_copy, &data);\n       break;\n@@ -1072,7 +1082,8 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     fn_type = build_exception_variant (fn_type, raises);\n   fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (TYPE_NAME (type));\n-  if (kind == sfk_constructor || kind == sfk_copy_constructor)\n+  if (kind == sfk_constructor || kind == sfk_copy_constructor\n+      || kind == sfk_move_constructor)\n     DECL_CONSTRUCTOR_P (fn) = 1;\n   else if (kind == sfk_destructor)\n     DECL_DESTRUCTOR_P (fn) = 1;\n@@ -1175,6 +1186,8 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n \tCLASSTYPE_LAZY_DEFAULT_CTOR (type) = 0;\n       else if (sfk == sfk_copy_constructor)\n \tCLASSTYPE_LAZY_COPY_CTOR (type) = 0;\n+      else if (sfk == sfk_move_constructor)\n+\tCLASSTYPE_LAZY_MOVE_CTOR (type) = 0;\n       else if (sfk == sfk_destructor)\n \tCLASSTYPE_LAZY_DESTRUCTOR (type) = 0;\n       /* Create appropriate clones.  */"}, {"sha": "459e7390805f069638c21894aabe491d7f1dbebe", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1834,6 +1834,23 @@ make_anon_name (void)\n   return get_identifier (buf);\n }\n \n+/* This code is practically identical to that for creating\n+   anonymous names, but is just used for lambdas instead.  This is necessary\n+   because anonymous names are recognized and cannot be passed to template\n+   functions.  */\n+/* FIXME is this still necessary? */\n+\n+static GTY(()) int lambda_cnt = 0;\n+\n+tree\n+make_lambda_name (void)\n+{\n+  char buf[32];\n+\n+  sprintf (buf, LAMBDANAME_FORMAT, lambda_cnt++);\n+  return get_identifier (buf);\n+}\n+\n /* Return (from the stack of) the BINDING, if any, established at SCOPE.  */\n \n static inline cxx_binding *\n@@ -2637,6 +2654,11 @@ pushdecl_class_level (tree x)\n   tree name;\n   bool is_valid = true;\n \n+  /* Do nothing if we're adding to an outer lambda closure type,\n+     outer_binding will add it later if it's needed.  */\n+  if (current_class_type != class_binding_level->this_entity)\n+    return true;\n+\n   timevar_push (TV_NAME_LOOKUP);\n   /* Get the name of X.  */\n   if (TREE_CODE (x) == OVERLOAD)\n@@ -3735,6 +3757,11 @@ qualify_lookup (tree val, int flags)\n     return true;\n   if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n     return false;\n+  /* In unevaluated context, look past capture fields.  */\n+  /* FIXME this will cause trouble with the initializer extension.  */\n+  if (cp_unevaluated_operand && TREE_CODE (val) == FIELD_DECL\n+      && LAMBDA_TYPE_P (DECL_CONTEXT (val)))\n+    return false;\n   return true;\n }\n \n@@ -5114,7 +5141,8 @@ pushtag (tree name, tree type, tag_scope scope)\n \t{\n \t  tree cs = current_scope ();\n \n-\t  if (scope == ts_current)\n+\t  if (scope == ts_current\n+\t      || (cs && TREE_CODE (cs) == FUNCTION_DECL))\n \t    context = cs;\n \t  else if (cs != NULL_TREE && TYPE_P (cs))\n \t    /* When declaring a friend class of a local class, we want"}, {"sha": "84cdef4b8d5432a706d060eb5026ac15f89f55d0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 586, "deletions": 17, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1626,6 +1626,14 @@ static tree cp_parser_constant_expression\n   (cp_parser *, bool, bool *);\n static tree cp_parser_builtin_offsetof\n   (cp_parser *);\n+static tree cp_parser_lambda_expression\n+  (cp_parser *);\n+static void cp_parser_lambda_introducer\n+  (cp_parser *, tree);\n+static void cp_parser_lambda_declarator_opt\n+  (cp_parser *, tree);\n+static void cp_parser_lambda_body\n+  (cp_parser *, tree);\n \n /* Statements [gram.stmt.stmt]  */\n \n@@ -2452,6 +2460,7 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n {\n   unsigned paren_depth = 0;\n   unsigned brace_depth = 0;\n+  unsigned square_depth = 0;\n \n   if (recovering && !or_comma\n       && cp_parser_uncommitted_to_tentative_parse_p (parser))\n@@ -2468,6 +2477,15 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n \t  /* If we've run out of tokens, then there is no closing `)'.  */\n \t  return 0;\n \n+        /* This is good for lambda expression capture-lists.  */\n+        case CPP_OPEN_SQUARE:\n+          ++square_depth;\n+          break;\n+        case CPP_CLOSE_SQUARE:\n+          if (!square_depth--)\n+            return 0;\n+          break;\n+\n \tcase CPP_SEMICOLON:\n \t  /* This matches the processing in skip_to_end_of_statement.  */\n \t  if (!brace_depth)\n@@ -2483,7 +2501,8 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n \t  break;\n \n \tcase CPP_COMMA:\n-\t  if (recovering && or_comma && !brace_depth && !paren_depth)\n+\t  if (recovering && or_comma && !brace_depth && !paren_depth\n+\t      && !square_depth)\n \t    return -1;\n \t  break;\n \n@@ -3283,6 +3302,20 @@ cp_parser_primary_expression (cp_parser *parser,\n \treturn expr;\n       }\n \n+    case CPP_OPEN_SQUARE:\n+      if (c_dialect_objc ())\n+        /* We have an Objective-C++ message. */\n+        return cp_parser_objc_expression (parser);\n+      maybe_warn_cpp0x (\"lambda expressions\");\n+      return cp_parser_lambda_expression (parser);\n+\n+    case CPP_OBJC_STRING:\n+      if (c_dialect_objc ())\n+\t/* We have an Objective-C++ string literal. */\n+        return cp_parser_objc_expression (parser);\n+      cp_parser_error (parser, \"expected primary-expression\");\n+      return error_mark_node;\n+\n     case CPP_KEYWORD:\n       switch (token->keyword)\n \t{\n@@ -3540,13 +3573,6 @@ cp_parser_primary_expression (cp_parser *parser,\n \n       /* Anything else is an error.  */\n     default:\n-      /* ...unless we have an Objective-C++ message or string literal,\n-         that is.  */\n-      if (c_dialect_objc ()\n-\t  && (token->type == CPP_OPEN_SQUARE\n-              || token->type == CPP_OBJC_STRING))\n-\treturn cp_parser_objc_expression (parser);\n-\n       cp_parser_error (parser, \"expected primary-expression\");\n       return error_mark_node;\n     }\n@@ -6925,6 +6951,525 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n   return finish_trait_expr (kind, type1, type2);\n }\n \n+/* Lambdas that appear in variable initializer or default argument scope\n+   get that in their mangling, so we need to record it.  We might as well\n+   use the count for function and namespace scopes as well.  */\n+static tree lambda_scope;\n+static int lambda_count;\n+typedef struct GTY(()) tree_int\n+{\n+  tree t;\n+  int i;\n+} tree_int;\n+DEF_VEC_O(tree_int);\n+DEF_VEC_ALLOC_O(tree_int,gc);\n+static GTY(()) VEC(tree_int,gc) *lambda_scope_stack;\n+\n+static void\n+start_lambda_scope (tree decl)\n+{\n+  tree_int ti;\n+  gcc_assert (decl);\n+  /* Once we're inside a function, we ignore other scopes and just push\n+     the function again so that popping works properly.  */\n+  if (current_function_decl && TREE_CODE (decl) != FUNCTION_DECL)\n+    decl = current_function_decl;\n+  ti.t = lambda_scope;\n+  ti.i = lambda_count;\n+  VEC_safe_push (tree_int, gc, lambda_scope_stack, &ti);\n+  if (lambda_scope != decl)\n+    {\n+      /* Don't reset the count if we're still in the same function.  */\n+      lambda_scope = decl;\n+      lambda_count = 0;\n+    }\n+}\n+\n+static void\n+record_lambda_scope (tree lambda)\n+{\n+  LAMBDA_EXPR_EXTRA_SCOPE (lambda) = lambda_scope;\n+  LAMBDA_EXPR_DISCRIMINATOR (lambda) = lambda_count++;\n+}\n+\n+static void\n+finish_lambda_scope (void)\n+{\n+  tree_int *p = VEC_last (tree_int, lambda_scope_stack);\n+  if (lambda_scope != p->t)\n+    {\n+      lambda_scope = p->t;\n+      lambda_count = p->i;\n+    }\n+  VEC_pop (tree_int, lambda_scope_stack);\n+}\n+\n+/* We want to determine the linkage of a lambda type at pushtag time,\n+   before CLASSTYPE_LAMBDA_EXPR has been set.  So this callback allows us\n+   to find out whether the current lambda mangling scope will give us\n+   linkage or not.  */\n+\n+bool\n+no_linkage_lambda_type_p (tree type)\n+{\n+  tree lambda, scope;\n+  if (!LAMBDA_TYPE_P (type))\n+    return false;\n+\n+  lambda = CLASSTYPE_LAMBDA_EXPR (type);\n+  if (lambda)\n+    scope = LAMBDA_EXPR_EXTRA_SCOPE (lambda);\n+  else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+    /* We can't use lambda_scope, and CLASSTYPE_TEMPLATE_INFO won't be set\n+       yet either, so guess it's public for now.  */\n+    return false;\n+  else\n+    scope = lambda_scope;\n+\n+  return (scope == NULL_TREE);\n+}\n+\n+/* Parse a lambda expression.\n+\n+   lambda-expression:\n+     lambda-introducer lambda-declarator [opt] compound-statement\n+\n+   Returns a representation of the expression.  */\n+\n+static tree\n+cp_parser_lambda_expression (cp_parser* parser)\n+{\n+  tree lambda_expr = build_lambda_expr ();\n+  tree type;\n+\n+  LAMBDA_EXPR_LOCATION (lambda_expr)\n+    = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  /* We may be in the middle of deferred access check.  Disable\n+     it now.  */\n+  push_deferring_access_checks (dk_no_deferred);\n+\n+  type = begin_lambda_type (lambda_expr);\n+\n+  record_lambda_scope (lambda_expr);\n+\n+  {\n+    /* Inside the class, surrounding template-parameter-lists do not apply.  */\n+    unsigned int saved_num_template_parameter_lists\n+        = parser->num_template_parameter_lists;\n+\n+    parser->num_template_parameter_lists = 0;\n+\n+    cp_parser_lambda_introducer (parser, lambda_expr);\n+\n+    /* By virtue of defining a local class, a lambda expression has access to\n+       the private variables of enclosing classes.  */\n+\n+    cp_parser_lambda_declarator_opt (parser, lambda_expr);\n+\n+    cp_parser_lambda_body (parser, lambda_expr);\n+\n+    /* The capture list was built up in reverse order; fix that now.  */\n+    {\n+      tree newlist = NULL_TREE;\n+      tree elt, next;\n+\n+      for (elt = LAMBDA_EXPR_CAPTURE_LIST (lambda_expr);\n+\t   elt; elt = next)\n+\t{\n+\t  /* Also add __ to the beginning of the field name so that code\n+\t     outside the lambda body can't see the captured name.  We could\n+\t     just remove the name entirely, but this is more useful for\n+\t     debugging.  */\n+\t  tree field = TREE_PURPOSE (elt);\n+\t  char *buf\n+\t    = (char *) alloca (IDENTIFIER_LENGTH (DECL_NAME (field)) + 3);\n+\t  buf[1] = buf[0] = '_';\n+\t  memcpy (buf + 2, IDENTIFIER_POINTER (DECL_NAME (field)),\n+\t\t  IDENTIFIER_LENGTH (DECL_NAME (field)) + 1);\n+\t  DECL_NAME (field) = get_identifier (buf);\n+\n+\t  next = TREE_CHAIN (elt);\n+\t  TREE_CHAIN (elt) = newlist;\n+\t  newlist = elt;\n+\t}\n+      LAMBDA_EXPR_CAPTURE_LIST (lambda_expr) = newlist;\n+    }\n+\n+    type = finish_struct (type, /*attributes=*/NULL_TREE);\n+\n+    parser->num_template_parameter_lists = saved_num_template_parameter_lists;\n+  }\n+\n+  pop_deferring_access_checks ();\n+\n+  return build_lambda_object (lambda_expr);\n+}\n+\n+/* Parse the beginning of a lambda expression.\n+\n+   lambda-introducer:\n+     [ lambda-capture [opt] ]\n+\n+   LAMBDA_EXPR is the current representation of the lambda expression.  */\n+\n+static void\n+cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n+{\n+  /* Need commas after the first capture.  */\n+  bool first = true;\n+\n+  /* Eat the leading `['.  */\n+  cp_parser_require (parser, CPP_OPEN_SQUARE, \"%<[%>\");\n+\n+  /* Record default capture mode.  \"[&\" \"[=\" \"[&,\" \"[=,\"  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_AND)\n+      && cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_NAME)\n+    LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) = CPLD_REFERENCE;\n+  else if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+    LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) = CPLD_COPY;\n+\n+  if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      first = false;\n+    }\n+\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_SQUARE))\n+    {\n+      cp_token* capture_token;\n+      tree capture_id;\n+      tree capture_init_expr;\n+      cp_id_kind idk = CP_ID_KIND_NONE;\n+\n+      enum capture_kind_type\n+      {\n+\tBY_COPY,\n+\tBY_REFERENCE\n+      };\n+      enum capture_kind_type capture_kind = BY_COPY;\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+\t{\n+\t  error (\"expected end of capture-list\");\n+\t  return;\n+\t}\n+\n+      if (first)\n+\tfirst = false;\n+      else\n+\tcp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+\n+      /* Possibly capture `this'.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_THIS))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  add_capture (lambda_expr,\n+\t\t       /*id=*/get_identifier (\"__this\"),\n+\t\t       /*initializer=*/finish_this_expr(),\n+\t\t       /*by_reference_p=*/false);\n+\t  continue;\n+\t}\n+\n+      /* Remember whether we want to capture as a reference or not.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_AND))\n+\t{\n+\t  capture_kind = BY_REFERENCE;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+\n+      /* Get the identifier.  */\n+      capture_token = cp_lexer_peek_token (parser->lexer);\n+      capture_id = cp_parser_identifier (parser);\n+\n+      if (capture_id == error_mark_node)\n+\t/* Would be nice to have a cp_parser_skip_to_closing_x for general\n+           delimiters, but I modified this to stop on unnested ']' as well.  It\n+           was already changed to stop on unnested '}', so the\n+           \"closing_parenthesis\" name is no more misleading with my change.  */\n+\t{\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/true,\n+\t\t\t\t\t\t /*consume_paren=*/true);\n+\t  continue;\n+\t}\n+\n+      /* Find the initializer for this capture.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t{\n+\t  /* An explicit expression exists.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+          pedwarn (input_location, OPT_pedantic,\n+                   \"ISO C++ does not allow initializers \"\n+                   \"in lambda expression capture lists\");\n+\t  capture_init_expr = cp_parser_assignment_expression (parser,\n+\t\t\t\t\t\t\t       /*cast_p=*/true,\n+\t\t\t\t\t\t\t       &idk);\n+\t}\n+      else\n+\t{\n+\t  const char* error_msg;\n+\n+\t  /* Turn the identifier into an id-expression.  */\n+\t  capture_init_expr\n+            = cp_parser_lookup_name\n+                (parser,\n+\t\t capture_id,\n+                 none_type,\n+                 /*is_template=*/false,\n+                 /*is_namespace=*/false,\n+                 /*check_dependency=*/true,\n+                 /*ambiguous_decls=*/NULL,\n+                 capture_token->location);\n+\n+\t  capture_init_expr\n+            = finish_id_expression\n+                (capture_id,\n+\t\t capture_init_expr,\n+                 parser->scope,\n+                 &idk,\n+                 /*integral_constant_expression_p=*/false,\n+                 /*allow_non_integral_constant_expression_p=*/false,\n+                 /*non_integral_constant_expression_p=*/NULL,\n+                 /*template_p=*/false,\n+                 /*done=*/true,\n+                 /*address_p=*/false,\n+                 /*template_arg_p=*/false,\n+                 &error_msg,\n+                 capture_token->location);\n+\t}\n+\n+      if (TREE_CODE (capture_init_expr) == IDENTIFIER_NODE)\n+\tcapture_init_expr\n+\t  = unqualified_name_lookup_error (capture_init_expr);\n+\n+      add_capture (lambda_expr,\n+\t\t   capture_id,\n+\t\t   capture_init_expr,\n+\t\t   /*by_reference_p=*/capture_kind == BY_REFERENCE);\n+    }\n+\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+}\n+\n+/* Parse the (optional) middle of a lambda expression.\n+\n+   lambda-declarator:\n+     ( parameter-declaration-clause [opt] )\n+       attribute-specifier [opt]\n+       mutable [opt]\n+       exception-specification [opt]\n+       lambda-return-type-clause [opt]\n+\n+   LAMBDA_EXPR is the current representation of the lambda expression.  */\n+\n+static void\n+cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n+{\n+  /* 5.1.1.4 of the standard says:\n+       If a lambda-expression does not include a lambda-declarator, it is as if\n+       the lambda-declarator were ().\n+     This means an empty parameter list, no attributes, and no exception\n+     specification.  */\n+  tree param_list = void_list_node;\n+  tree attributes = NULL_TREE;\n+  tree exception_spec = NULL_TREE;\n+  tree t;\n+\n+  /* The lambda-declarator is optional, but must begin with an opening\n+     parenthesis if present.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      begin_scope (sk_function_parms, /*entity=*/NULL_TREE);\n+\n+      /* Parse parameters.  */\n+      param_list = cp_parser_parameter_declaration_clause (parser);\n+\n+      /* Default arguments shall not be specified in the\n+\t parameter-declaration-clause of a lambda-declarator.  */\n+      for (t = param_list; t; t = TREE_CHAIN (t))\n+\tif (TREE_PURPOSE (t))\n+\t  pedwarn (DECL_SOURCE_LOCATION (TREE_VALUE (t)), OPT_pedantic,\n+\t\t   \"default argument specified for lambda parameter\");\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\n+      attributes = cp_parser_attributes_opt (parser);\n+\n+      /* Parse optional `mutable' keyword.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_MUTABLE))\n+        {\n+          cp_lexer_consume_token (parser->lexer);\n+          LAMBDA_EXPR_MUTABLE_P (lambda_expr) = 1;\n+        }\n+\n+      /* Parse optional exception specification.  */\n+      exception_spec = cp_parser_exception_specification_opt (parser);\n+\n+      /* Parse optional trailing return type.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_DEREF))\n+        {\n+          cp_lexer_consume_token (parser->lexer);\n+          LAMBDA_EXPR_RETURN_TYPE (lambda_expr) = cp_parser_type_id (parser);\n+        }\n+\n+      /* The function parameters must be in scope all the way until after the\n+         trailing-return-type in case of decltype.  */\n+      for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n+\tpop_binding (DECL_NAME (t), t);\n+\n+      leave_scope ();\n+    }\n+\n+  /* Create the function call operator.\n+\n+     Messing with declarators like this is no uglier than building up the\n+     FUNCTION_DECL by hand, and this is less likely to get out of sync with\n+     other code.  */\n+  {\n+    cp_decl_specifier_seq return_type_specs;\n+    cp_declarator* declarator;\n+    tree fco;\n+    int quals;\n+    void *p;\n+\n+    clear_decl_specs (&return_type_specs);\n+    if (LAMBDA_EXPR_RETURN_TYPE (lambda_expr))\n+      return_type_specs.type = LAMBDA_EXPR_RETURN_TYPE (lambda_expr);\n+    else\n+      /* Maybe we will deduce the return type later, but we can use void\n+\t as a placeholder return type anyways.  */\n+      return_type_specs.type = void_type_node;\n+\n+    p = obstack_alloc (&declarator_obstack, 0);\n+\n+    declarator = make_id_declarator (NULL_TREE, ansi_opname (CALL_EXPR),\n+\t\t\t\t     sfk_none);\n+\n+    quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)\n+\t     ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);\n+    declarator = make_call_declarator (declarator, param_list, quals,\n+\t\t\t\t       exception_spec,\n+                                       /*late_return_type=*/NULL_TREE);\n+\n+    fco = grokmethod (&return_type_specs,\n+                        declarator,\n+                        attributes);\n+    DECL_INITIALIZED_IN_CLASS_P (fco) = 1;\n+    DECL_ARTIFICIAL (fco) = 1;\n+\n+    finish_member_declaration (fco);\n+\n+    obstack_free (&declarator_obstack, p);\n+  }\n+}\n+\n+/* Parse the body of a lambda expression, which is simply\n+\n+   compound-statement\n+\n+   but which requires special handling.\n+   LAMBDA_EXPR is the current representation of the lambda expression.  */\n+\n+static void\n+cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n+{\n+  bool nested = (current_function_decl != NULL_TREE);\n+  if (nested)\n+    push_function_context ();\n+\n+  /* Finish the function call operator\n+     - class_specifier\n+     + late_parsing_for_member\n+     + function_definition_after_declarator\n+     + ctor_initializer_opt_and_function_body  */\n+  {\n+    tree fco = lambda_function (lambda_expr);\n+    tree body;\n+    bool done = false;\n+\n+    /* Let the front end know that we are going to be defining this\n+       function.  */\n+    start_preparsed_function (fco,\n+\t\t\t      NULL_TREE,\n+\t\t\t      SF_PRE_PARSED | SF_INCLASS_INLINE);\n+\n+    start_lambda_scope (fco);\n+    body = begin_function_body ();\n+\n+    /* 5.1.1.4 of the standard says:\n+         If a lambda-expression does not include a trailing-return-type, it\n+         is as if the trailing-return-type denotes the following type:\n+           \u2014 if the compound-statement is of the form\n+               { return attribute-specifier [opt] expression ; }\n+             the type of the returned expression after lvalue-to-rvalue\n+             conversion (_conv.lval_ 4.1), array-to-pointer conversion\n+             (_conv.array_ 4.2), and function-to-pointer conversion\n+             (_conv.func_ 4.3);\n+           \u2014 otherwise, void.  */\n+\n+    /* In a lambda that has neither a lambda-return-type-clause\n+       nor a deducible form, errors should be reported for return statements\n+       in the body.  Since we used void as the placeholder return type, parsing\n+       the body as usual will give such desired behavior.  */\n+    if (!LAMBDA_EXPR_RETURN_TYPE (lambda_expr)\n+        && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)\n+        && cp_lexer_peek_nth_token (parser->lexer, 2)->keyword == RID_RETURN\n+        && cp_lexer_peek_nth_token (parser->lexer, 3)->type != CPP_SEMICOLON)\n+      {\n+\ttree compound_stmt;\n+\ttree expr = NULL_TREE;\n+\tcp_id_kind idk = CP_ID_KIND_NONE;\n+\n+\t/* Parse tentatively in case there's more after the initial return\n+\t   statement.  */\n+\tcp_parser_parse_tentatively (parser);\n+\n+\tcp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n+\tcp_parser_require_keyword (parser, RID_RETURN, \"%<return%>\");\n+\n+\texpr = cp_parser_expression (parser, /*cast_p=*/false, &idk);\n+\n+\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+\tcp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+\n+\tif (cp_parser_parse_definitely (parser))\n+\t  {\n+\t    apply_lambda_return_type (lambda_expr, lambda_return_type (expr));\n+\n+\t    compound_stmt = begin_compound_stmt (0);\n+\t    /* Will get error here if type not deduced yet.  */\n+\t    finish_return_stmt (expr);\n+\t    finish_compound_stmt (compound_stmt);\n+\n+\t    done = true;\n+\t  }\n+      }\n+\n+    if (!done)\n+      {\n+\tif (!LAMBDA_EXPR_RETURN_TYPE (lambda_expr))\n+\t  LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda_expr) = true;\n+\t/* TODO: does begin_compound_stmt want BCS_FN_BODY?\n+\t   cp_parser_compound_stmt does not pass it.  */\n+\tcp_parser_function_body (parser);\n+\tLAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda_expr) = false;\n+      }\n+\n+    finish_function_body (body);\n+    finish_lambda_scope ();\n+\n+    /* Finish the function and generate code for it if necessary.  */\n+    expand_or_defer_fn (finish_function (/*inline*/2));\n+  }\n+\n+  if (nested)\n+    pop_function_context();\n+}\n+\n /* Statements [gram.stmt.stmt]  */\n \n /* Parse a statement.\n@@ -13033,9 +13578,21 @@ cp_parser_init_declarator (cp_parser* parser,\n \t     }\n \t}\n       else\n-\tinitializer = cp_parser_initializer (parser,\n-\t\t\t\t\t     &is_direct_init,\n-\t\t\t\t\t     &is_non_constant_init);\n+\t{\n+\t  /* We want to record the extra mangling scope for in-class\n+\t     initializers of class members and initializers of static data\n+\t     member templates.  The former is a C++0x feature which isn't\n+\t     implemented yet, and I expect it will involve deferring\n+\t     parsing of the initializer until end of class as with default\n+\t     arguments.  So right here we only handle the latter.  */\n+\t  if (!member_p && processing_template_decl)\n+\t    start_lambda_scope (decl);\n+\t  initializer = cp_parser_initializer (parser,\n+\t\t\t\t\t       &is_direct_init,\n+\t\t\t\t\t       &is_non_constant_init);\n+\t  if (!member_p && processing_template_decl)\n+\t    finish_lambda_scope ();\n+\t}\n     }\n \n   /* The old parser allows attributes to appear after a parenthesized\n@@ -14453,7 +15010,8 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       /* If we are defining a class, then the tokens that make up the\n \t default argument must be saved and processed later.  */\n       if (!template_parm_p && at_class_scope_p ()\n-\t  && TYPE_BEING_DEFINED (current_class_type))\n+\t  && TYPE_BEING_DEFINED (current_class_type)\n+\t  && !LAMBDA_TYPE_P (current_class_type))\n \t{\n \t  unsigned depth = 0;\n \t  int maybe_template_id = 0;\n@@ -17841,7 +18399,7 @@ cp_parser_function_definition_from_specifiers_and_declarator\n \n /* Parse the part of a function-definition that follows the\n    declarator.  INLINE_P is TRUE iff this function is an inline\n-   function defined with a class-specifier.\n+   function defined within a class-specifier.\n \n    Returns the function defined.  */\n \n@@ -17893,6 +18451,9 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n   saved_num_template_parameter_lists\n     = parser->num_template_parameter_lists;\n   parser->num_template_parameter_lists = 0;\n+\n+  start_lambda_scope (current_function_decl);\n+\n   /* If the next token is `try', then we are looking at a\n      function-try-block.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRY))\n@@ -17903,6 +18464,8 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n     ctor_initializer_p\n       = cp_parser_ctor_initializer_opt_and_function_body (parser);\n \n+  finish_lambda_scope ();\n+\n   /* Finish the function.  */\n   fn = finish_function ((ctor_initializer_p ? 1 : 0) |\n \t\t\t(inline_p ? 2 : 0));\n@@ -18530,7 +19093,7 @@ static void\n cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n {\n   bool saved_local_variables_forbidden_p;\n-  tree parm;\n+  tree parm, parmdecl;\n \n   /* While we're parsing the default args, we might (due to the\n      statement expression extension) encounter more classes.  We want\n@@ -18544,9 +19107,11 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n   saved_local_variables_forbidden_p = parser->local_variables_forbidden_p;\n   parser->local_variables_forbidden_p = true;\n \n-  for (parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-       parm;\n-       parm = TREE_CHAIN (parm))\n+  for (parm = TYPE_ARG_TYPES (TREE_TYPE (fn)),\n+\t parmdecl = DECL_ARGUMENTS (fn);\n+       parm && parm != void_list_node;\n+       parm = TREE_CHAIN (parm),\n+\t parmdecl = TREE_CHAIN (parmdecl))\n     {\n       cp_token_cache *tokens;\n       tree default_arg = TREE_PURPOSE (parm);\n@@ -18568,6 +19133,8 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n       tokens = DEFARG_TOKENS (default_arg);\n       cp_parser_push_lexer_for_tokens (parser, tokens);\n \n+      start_lambda_scope (parmdecl);\n+\n       /* Parse the assignment-expression.  */\n       parsed_arg = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n       if (parsed_arg == error_mark_node)\n@@ -18586,6 +19153,8 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \t   VEC_iterate (tree, insts, ix, copy); ix++)\n \tTREE_PURPOSE (copy) = parsed_arg;\n \n+      finish_lambda_scope ();\n+\n       /* If the token stream has not been completely used up, then\n \t there was extra junk after the end of the default\n \t argument.  */"}, {"sha": "86b4d9e43bce0caa2d04ec672ea9bc4fcd2ead1b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -300,7 +300,7 @@ get_template_info (const_tree t)\n   if (DECL_P (t) && DECL_LANG_SPECIFIC (t))\n     tinfo = DECL_TEMPLATE_INFO (t);\n \n-  if (!tinfo && TREE_CODE (t) == TYPE_DECL)\n+  if (!tinfo && DECL_IMPLICIT_TYPEDEF_P (t))\n     t = TREE_TYPE (t);\n \n   if (TAGGED_TYPE_P (t))\n@@ -6230,6 +6230,7 @@ lookup_template_class (tree d1,\n \n       if (!is_partial_instantiation\n \t  && !PRIMARY_TEMPLATE_P (gen_tmpl)\n+\t  && !LAMBDA_TYPE_P (TREE_TYPE (gen_tmpl))\n \t  && TREE_CODE (CP_DECL_CONTEXT (gen_tmpl)) == NAMESPACE_DECL)\n \t{\n \t  found = xref_tag_from_type (TREE_TYPE (gen_tmpl),\n@@ -9162,6 +9163,22 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    DECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t  }\n+\telse if (cp_unevaluated_operand)\n+\t  {\n+\t    /* We're substituting this var in a decltype outside of its\n+\t       scope, such as for a lambda return type.  Don't add it to\n+\t       local_specializations, do perform auto deduction.  */\n+\t    tree auto_node = type_uses_auto (type);\n+\t    tree init\n+\t      = tsubst_expr (DECL_INITIAL (t), args, complain, in_decl,\n+\t\t\t     /*constant_expression_p=*/false);\n+\n+\t    if (auto_node && init && describable_type (init))\n+\t      {\n+\t\ttype = do_auto_deduction (type, init, auto_node);\n+\t\tTREE_TYPE (r) = type;\n+\t      }\n+\t  }\n \telse\n \t  register_local_specialization (r, t);\n \n@@ -10153,9 +10170,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n \n-\ttype =\n-          finish_decltype_type (type,\n-                                DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t));\n+\tif (DECLTYPE_FOR_LAMBDA_CAPTURE (t))\n+\t  type = lambda_capture_field_type (type);\n+\telse if (DECLTYPE_FOR_LAMBDA_RETURN (t))\n+\t  type = lambda_return_type (type);\n+\telse\n+\t  type = finish_decltype_type\n+\t    (type, DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t));\n \treturn cp_build_qualified_type_real (type,\n \t\t\t\t\t     cp_type_quals (t)\n \t\t\t\t\t     | cp_type_quals (type),\n@@ -12359,6 +12380,39 @@ tsubst_copy_and_build (tree t,\n \t}\n       return t;\n \n+    case LAMBDA_EXPR:\n+      {\n+\ttree r = build_lambda_expr ();\n+\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, NULL_TREE);\n+\tTREE_TYPE (r) = type;\n+\tCLASSTYPE_LAMBDA_EXPR (type) = r;\n+\n+\tLAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)\n+\t  = LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (t);\n+\tLAMBDA_EXPR_MUTABLE_P (r) = LAMBDA_EXPR_MUTABLE_P (t);\n+\tLAMBDA_EXPR_DISCRIMINATOR (r)\n+\t  = (LAMBDA_EXPR_DISCRIMINATOR (t));\n+\tLAMBDA_EXPR_CAPTURE_LIST (r)\n+\t  = RECUR (LAMBDA_EXPR_CAPTURE_LIST (t));\n+\tLAMBDA_EXPR_THIS_CAPTURE (r)\n+\t  = RECUR (LAMBDA_EXPR_THIS_CAPTURE (t));\n+\tLAMBDA_EXPR_EXTRA_SCOPE (r)\n+\t  = RECUR (LAMBDA_EXPR_EXTRA_SCOPE (t));\n+\n+\t/* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */\n+\tdetermine_visibility (TYPE_NAME (type));\n+\t/* Now that we know visibility, instantiate the type so we have a\n+\t   declaration of the op() for later calls to lambda_function.  */\n+\tcomplete_type (type);\n+\n+\ttype = tsubst (LAMBDA_EXPR_RETURN_TYPE (t), args, complain, in_decl);\n+\tif (type)\n+\t  apply_lambda_return_type (r, type);\n+\n+\treturn build_lambda_object (r);\n+      }\n+\n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */\n       {\n@@ -15959,10 +16013,11 @@ instantiate_decl (tree d, int defer_ok,\n       SET_DECL_IMPLICIT_INSTANTIATION (d);\n     }\n \n-  if (!defer_ok)\n+  /* Recheck the substitutions to obtain any warning messages\n+     about ignoring cv qualifiers.  Don't do this for artificial decls,\n+     as it breaks the context-sensitive substitution for lambda op(). */\n+  if (!defer_ok && !DECL_ARTIFICIAL (d))\n     {\n-      /* Recheck the substitutions to obtain any warning messages\n-\t about ignoring cv qualifiers.  */\n       tree gen = DECL_TEMPLATE_RESULT (gen_tmpl);\n       tree type = TREE_TYPE (gen);\n "}, {"sha": "d6521fb6f823ec942f9658061bc85ec498dd9084", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1380,6 +1380,8 @@ lookup_fnfields_1 (tree type, tree name)\n \t    lazily_declare_fn (sfk_constructor, type);\n \t  if (CLASSTYPE_LAZY_COPY_CTOR (type))\n \t    lazily_declare_fn (sfk_copy_constructor, type);\n+\t  if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n+\t    lazily_declare_fn (sfk_move_constructor, type);\n \t}\n       else if (name == ansi_assopname(NOP_EXPR)\n \t       && CLASSTYPE_LAZY_ASSIGNMENT_OP (type))"}, {"sha": "6dec9f8a339654c3ad454712031a73966c547d21", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 516, "deletions": 6, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static tree maybe_convert_cond (tree);\n static tree finalize_nrv_r (tree *, int *, void *);\n+static tree capture_decltype (tree);\n \n \n /* Deferred Access Checking Overview\n@@ -1445,6 +1446,21 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \n       return error_mark_node;\n     }\n+\n+  /* If decl is a field, object has a lambda type, and decl is not a member\n+     of that type, then we have a reference to a member of 'this' from a\n+     lambda inside a non-static member function, and we must get to decl\n+     through the 'this' capture.  If decl is not a member of that object,\n+     either, then its access will still fail later.  */\n+  if (LAMBDA_TYPE_P (TREE_TYPE (object))\n+      && !same_type_ignoring_top_level_qualifiers_p (DECL_CONTEXT (decl),\n+                                                     TREE_TYPE (object)))\n+    object = cp_build_indirect_ref (lambda_expr_this_capture\n+\t\t\t\t    (CLASSTYPE_LAMBDA_EXPR\n+\t\t\t\t     (TREE_TYPE (object))),\n+                                    /*errorstring=*/\"\",\n+                                    /*complain=*/tf_warning_or_error);\n+\n   if (current_class_ptr)\n     TREE_USED (current_class_ptr) = 1;\n   if (processing_template_decl && !qualifying_scope)\n@@ -2049,7 +2065,14 @@ finish_this_expr (void)\n \n   if (current_class_ptr)\n     {\n-      result = current_class_ptr;\n+      tree type = TREE_TYPE (current_class_ref);\n+\n+      /* In a lambda expression, 'this' refers to the captured 'this'.  */\n+      if (LAMBDA_TYPE_P (type))\n+        result = lambda_expr_this_capture (CLASSTYPE_LAMBDA_EXPR (type));\n+      else\n+        result = current_class_ptr;\n+\n     }\n   else if (current_function_decl\n \t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n@@ -2613,6 +2636,18 @@ baselink_for_fns (tree fns)\n   return build_baselink (cl, cl, fns, /*optype=*/NULL_TREE);\n }\n \n+/* Returns true iff DECL is an automatic variable from a function outside\n+   the current one.  */\n+\n+static bool\n+outer_automatic_var_p (tree decl)\n+{\n+  return ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+\t  && DECL_FUNCTION_SCOPE_P (decl)\n+\t  && !TREE_STATIC (decl)\n+\t  && DECL_CONTEXT (decl) != current_function_decl);\n+}\n+\n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n    if non-NULL, is the type or namespace used to explicitly qualify\n@@ -2714,12 +2749,61 @@ finish_id_expression (tree id_expression,\n       if (!scope && decl != error_mark_node)\n \tmaybe_note_name_used_in_class (id_expression, decl);\n \n-      /* Disallow uses of local variables from containing functions.  */\n-      if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+      /* Disallow uses of local variables from containing functions, except\n+\t within lambda-expressions.  */\n+      if (outer_automatic_var_p (decl)\n+\t  /* It's not a use (3.2) if we're in an unevaluated context.  */\n+\t  && !cp_unevaluated_operand)\n \t{\n-\t  tree context = decl_function_context (decl);\n-\t  if (context != NULL_TREE && context != current_function_decl\n-\t      && ! TREE_STATIC (decl))\n+\t  tree context = DECL_CONTEXT (decl);\n+\t  tree containing_function = current_function_decl;\n+\t  tree lambda_stack = NULL_TREE;\n+\t  tree lambda_expr = NULL_TREE;\n+\n+\t  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n+\t     support for an approach in which a reference to a local\n+\t     [constant] automatic variable in a nested class or lambda body\n+\t     would enter the expression as an rvalue, which would reduce\n+\t     the complexity of the problem\"\n+\n+\t     FIXME update for final resolution of core issue 696.  */\n+\t  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n+\t    return integral_constant_value (decl);\n+\n+\t  /* If we are in a lambda function, we can move out until we hit\n+\t     1. the context,\n+\t     2. a non-lambda function, or\n+\t     3. a non-default capturing lambda function.  */\n+\t  while (context != containing_function\n+\t\t && LAMBDA_FUNCTION_P (containing_function))\n+\t    {\n+\t      lambda_expr = CLASSTYPE_LAMBDA_EXPR\n+\t\t(DECL_CONTEXT (containing_function));\n+\n+\t      if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr)\n+\t\t  == CPLD_NONE)\n+\t\tbreak;\n+\n+\t      lambda_stack = tree_cons (NULL_TREE,\n+\t\t\t\t\tlambda_expr,\n+\t\t\t\t\tlambda_stack);\n+\n+\t      containing_function\n+\t\t= decl_function_context (containing_function);\n+\t    }\n+\n+\t  if (context == containing_function)\n+\t    {\n+\t      decl = add_default_capture (lambda_stack,\n+\t\t\t\t\t  /*id=*/DECL_NAME (decl),\n+\t\t\t\t\t  /*initializer=*/decl);\n+\t    }\n+\t  else if (lambda_expr)\n+\t    {\n+\t      error (\"%qD is not captured\", decl);\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n \t    {\n \t      error (TREE_CODE (decl) == VAR_DECL\n \t\t     ? \"use of %<auto%> variable from containing function\"\n@@ -4788,6 +4872,18 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n               if (real_lvalue_p (expr))\n                 type = build_reference_type (type);\n             }\n+\t  /* Within a lambda-expression:\n+\n+\t     Every occurrence of decltype((x)) where x is a possibly\n+\t     parenthesized id-expression that names an entity of\n+\t     automatic storage duration is treated as if x were\n+\t     transformed into an access to a corresponding data member\n+\t     of the closure type that would have been declared if x\n+\t     were a use of the denoted entity.  */\n+\t  else if (outer_automatic_var_p (expr)\n+\t\t   && current_function_decl\n+\t\t   && LAMBDA_FUNCTION_P (current_function_decl))\n+\t    type = capture_decltype (expr);\n           else\n             {\n               /* Otherwise, where T is the type of e, if e is an lvalue,\n@@ -4842,6 +4938,8 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n \t it now.  */\n       if (CLASSTYPE_LAZY_COPY_CTOR (type))\n \tlazily_declare_fn (sfk_copy_constructor, type);\n+      if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n+\tlazily_declare_fn (sfk_move_constructor, type);\n       fns = CLASSTYPE_CONSTRUCTORS (type);\n     }\n   else\n@@ -5105,4 +5203,416 @@ float_const_decimal64_p (void)\n   return 0;\n }\n \n+/* Constructor for a lambda expression.  */\n+\n+tree\n+build_lambda_expr (void)\n+{\n+  tree lambda = make_node (LAMBDA_EXPR);\n+  LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) = CPLD_NONE;\n+  LAMBDA_EXPR_CAPTURE_LIST         (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_THIS_CAPTURE         (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_RETURN_TYPE          (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_MUTABLE_P            (lambda) = false;\n+  return lambda;\n+}\n+\n+/* Create the closure object for a LAMBDA_EXPR.  */\n+\n+tree\n+build_lambda_object (tree lambda_expr)\n+{\n+  /* Build aggregate constructor call.\n+     - cp_parser_braced_list\n+     - cp_parser_functional_cast  */\n+  VEC(constructor_elt,gc) *elts = NULL;\n+  tree node, expr, type;\n+  location_t saved_loc;\n+\n+  if (processing_template_decl)\n+    return lambda_expr;\n+\n+  /* Make sure any error messages refer to the lambda-introducer.  */\n+  saved_loc = input_location;\n+  input_location = LAMBDA_EXPR_LOCATION (lambda_expr);\n+\n+  for (node = LAMBDA_EXPR_CAPTURE_LIST (lambda_expr);\n+       node;\n+       node = TREE_CHAIN (node))\n+    {\n+      tree field = TREE_PURPOSE (node);\n+      tree val = TREE_VALUE (node);\n+\n+      /* Mere mortals can't copy arrays with aggregate initialization, so\n+\t do some magic to make it work here.  */\n+      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n+\tval = build_array_copy (val);\n+\n+      CONSTRUCTOR_APPEND_ELT (elts, DECL_NAME (field), val);\n+    }\n+\n+  expr = build_constructor (init_list_type_node, elts);\n+  CONSTRUCTOR_IS_DIRECT_INIT (expr) = 1;\n+\n+  /* N2927: \"[The closure] class type is not an aggregate.\"\n+     But we briefly treat it as an aggregate to make this simpler.  */\n+  type = TREE_TYPE (lambda_expr);\n+  CLASSTYPE_NON_AGGREGATE (type) = 0;\n+  expr = finish_compound_literal (type, expr);\n+  CLASSTYPE_NON_AGGREGATE (type) = 1;\n+\n+  input_location = saved_loc;\n+  return expr;\n+}\n+\n+/* Return an initialized RECORD_TYPE for LAMBDA.\n+   LAMBDA must have its explicit captures already.  */\n+\n+tree\n+begin_lambda_type (tree lambda)\n+{\n+  tree type;\n+\n+  {\n+    /* Unique name.  This is just like an unnamed class, but we cannot use\n+       make_anon_name because of certain checks against TYPE_ANONYMOUS_P.  */\n+    tree name;\n+    name = make_lambda_name ();\n+\n+    /* Create the new RECORD_TYPE for this lambda.  */\n+    type = xref_tag (/*tag_code=*/record_type,\n+                     name,\n+                     /*scope=*/ts_within_enclosing_non_class,\n+                     /*template_header_p=*/false);\n+  }\n+\n+  /* Designate it as a struct so that we can use aggregate initialization.  */\n+  CLASSTYPE_DECLARED_CLASS (type) = false;\n+\n+  /* Clear base types.  */\n+  xref_basetypes (type, /*bases=*/NULL_TREE);\n+\n+  /* Start the class.  */\n+  type = begin_class_definition (type, /*attributes=*/NULL_TREE);\n+\n+  /* Cross-reference the expression and the type.  */\n+  TREE_TYPE (lambda) = type;\n+  CLASSTYPE_LAMBDA_EXPR (type) = lambda;\n+\n+  return type;\n+}\n+\n+/* Returns the type to use for the return type of the operator() of a\n+   closure class.  */\n+\n+tree\n+lambda_return_type (tree expr)\n+{\n+  tree type;\n+  if (type_dependent_expression_p (expr))\n+    {\n+      type = cxx_make_type (DECLTYPE_TYPE);\n+      DECLTYPE_TYPE_EXPR (type) = expr;\n+      DECLTYPE_FOR_LAMBDA_RETURN (type) = true;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n+    }\n+  else\n+    type = type_decays_to (unlowered_expr_type (expr));\n+  return type;\n+}\n+\n+/* Given a LAMBDA_EXPR or closure type LAMBDA, return the op() of the\n+   closure type.  */\n+\n+tree\n+lambda_function (tree lambda)\n+{\n+  tree type;\n+  if (TREE_CODE (lambda) == LAMBDA_EXPR)\n+    type = TREE_TYPE (lambda);\n+  else\n+    type = lambda;\n+  gcc_assert (LAMBDA_TYPE_P (type));\n+  /* Don't let debug_tree cause instantiation.  */\n+  if (CLASSTYPE_TEMPLATE_INSTANTIATION (type) && !COMPLETE_TYPE_P (type))\n+    return NULL_TREE;\n+  lambda = lookup_member (type, ansi_opname (CALL_EXPR),\n+\t\t\t  /*protect=*/0, /*want_type=*/false);\n+  if (lambda)\n+    lambda = BASELINK_FUNCTIONS (lambda);\n+  return lambda;\n+}\n+\n+/* Returns the type to use for the FIELD_DECL corresponding to the\n+   capture of EXPR.\n+   The caller should add REFERENCE_TYPE for capture by reference.  */\n+\n+tree\n+lambda_capture_field_type (tree expr)\n+{\n+  tree type;\n+  if (type_dependent_expression_p (expr))\n+    {\n+      type = cxx_make_type (DECLTYPE_TYPE);\n+      DECLTYPE_TYPE_EXPR (type) = expr;\n+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n+    }\n+  else\n+    type = non_reference (unlowered_expr_type (expr));\n+  return type;\n+}\n+\n+/* Recompute the return type for LAMBDA with body of the form:\n+     { return EXPR ; }  */\n+\n+void\n+apply_lambda_return_type (tree lambda, tree return_type)\n+{\n+  tree fco = lambda_function (lambda);\n+  tree result;\n+\n+  LAMBDA_EXPR_RETURN_TYPE (lambda) = return_type;\n+\n+  /* If we got a DECLTYPE_TYPE, don't stick it in the function yet,\n+     it would interfere with instantiating the closure type.  */\n+  if (dependent_type_p (return_type))\n+    return;\n+  if (return_type == error_mark_node)\n+    return;\n+\n+  /* TREE_TYPE (FUNCTION_DECL) == METHOD_TYPE\n+     TREE_TYPE (METHOD_TYPE)   == return-type  */\n+  TREE_TYPE (TREE_TYPE (fco)) = return_type;\n+\n+  result = DECL_RESULT (fco);\n+  if (result == NULL_TREE)\n+    return;\n+\n+  /* We already have a DECL_RESULT from start_preparsed_function.\n+     Now we need to redo the work it and allocate_struct_function\n+     did to reflect the new type.  */\n+  result = build_decl (input_location, RESULT_DECL, NULL_TREE,\n+\t\t       TYPE_MAIN_VARIANT (return_type));\n+  DECL_ARTIFICIAL (result) = 1;\n+  DECL_IGNORED_P (result) = 1;\n+  cp_apply_type_quals_to_decl (cp_type_quals (return_type),\n+                               result);\n+\n+  DECL_RESULT (fco) = result;\n+\n+  if (!processing_template_decl && aggregate_value_p (result, fco))\n+    {\n+#ifdef PCC_STATIC_STRUCT_RETURN\n+      cfun->returns_pcc_struct = 1;\n+#endif\n+      cfun->returns_struct = 1;\n+    }\n+\n+}\n+\n+/* DECL is a local variable or parameter from the surrounding scope of a\n+   lambda-expression.  Returns the decltype for a use of the capture field\n+   for DECL even if it hasn't been captured yet.  */\n+\n+static tree\n+capture_decltype (tree decl)\n+{\n+  tree lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n+  /* FIXME do lookup instead of list walk? */\n+  tree cap = value_member (decl, LAMBDA_EXPR_CAPTURE_LIST (lam));\n+  tree type;\n+\n+  if (cap)\n+    type = TREE_TYPE (TREE_PURPOSE (cap));\n+  else\n+    switch (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam))\n+      {\n+      case CPLD_NONE:\n+\terror (\"%qD is not captured\", decl);\n+\treturn error_mark_node;\n+\n+      case CPLD_COPY:\n+\ttype = TREE_TYPE (decl);\n+\tif (TREE_CODE (type) == REFERENCE_TYPE\n+\t    && TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE)\n+\t  type = TREE_TYPE (type);\n+\tbreak;\n+\n+      case CPLD_REFERENCE:\n+\ttype = TREE_TYPE (decl);\n+\tif (TREE_CODE (type) != REFERENCE_TYPE)\n+\t  type = build_reference_type (TREE_TYPE (decl));\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  if (TREE_CODE (type) != REFERENCE_TYPE)\n+    {\n+      if (!LAMBDA_EXPR_MUTABLE_P (lam))\n+\ttype = cp_build_qualified_type (type, (TYPE_QUALS (type)\n+\t\t\t\t\t       |TYPE_QUAL_CONST));\n+      type = build_reference_type (type);\n+    }\n+  return type;\n+}\n+\n+/* From an ID and INITIALIZER, create a capture (by reference if\n+   BY_REFERENCE_P is true), add it to the capture-list for LAMBDA,\n+   and return it.  */\n+\n+tree\n+add_capture (tree lambda, tree id, tree initializer, bool by_reference_p)\n+{\n+  tree type;\n+  tree member;\n+\n+  type = lambda_capture_field_type (initializer);\n+  if (by_reference_p)\n+    {\n+      type = build_reference_type (type);\n+      if (!real_lvalue_p (initializer))\n+\terror (\"cannot capture %qE by reference\", initializer);\n+    }\n+\n+  /* Make member variable.  */\n+  member = build_lang_decl (FIELD_DECL, id, type);\n+\n+  /* Add it to the appropriate closure class.  */\n+  finish_member_declaration (member);\n+\n+  LAMBDA_EXPR_CAPTURE_LIST (lambda)\n+    = tree_cons (member, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n+\n+  if (id == get_identifier (\"__this\"))\n+    {\n+      if (LAMBDA_EXPR_CAPTURES_THIS_P (lambda))\n+        error (\"already captured %<this%> in lambda expression\");\n+      LAMBDA_EXPR_THIS_CAPTURE (lambda) = member;\n+    }\n+\n+  return member;\n+}\n+\n+/* Similar to add_capture, except this works on a stack of nested lambdas.\n+   BY_REFERENCE_P in this case is derived from the default capture mode.\n+   Returns the capture for the lambda at the bottom of the stack.  */\n+\n+tree\n+add_default_capture (tree lambda_stack, tree id, tree initializer)\n+{\n+  bool this_capture_p = (id == get_identifier (\"__this\"));\n+\n+  tree member = NULL_TREE;\n+\n+  tree saved_class_type = current_class_type;\n+\n+  tree node;\n+\n+  for (node = lambda_stack;\n+       node;\n+       node = TREE_CHAIN (node))\n+    {\n+      tree lambda = TREE_VALUE (node);\n+\n+      current_class_type = TREE_TYPE (lambda);\n+      member = add_capture (lambda,\n+                            id,\n+                            initializer,\n+                            /*by_reference_p=*/\n+\t\t\t    (!this_capture_p\n+\t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n+\t\t\t\t == CPLD_REFERENCE)));\n+\n+      {\n+        /* Have to get the old value of current_class_ref.  */\n+        tree object = cp_build_indirect_ref (DECL_ARGUMENTS\n+                                               (lambda_function (lambda)),\n+                                             /*errorstring=*/\"\",\n+                                             /*complain=*/tf_warning_or_error);\n+        initializer = finish_non_static_data_member\n+                        (member, object, /*qualifying_scope=*/NULL_TREE);\n+      }\n+    }\n+\n+  current_class_type = saved_class_type;\n+\n+  return member;\n+\n+}\n+\n+/* Return the capture pertaining to a use of 'this' in LAMBDA, in the form of an\n+   INDIRECT_REF, possibly adding it through default capturing.  */\n+\n+tree\n+lambda_expr_this_capture (tree lambda)\n+{\n+  tree result;\n+\n+  tree this_capture = LAMBDA_EXPR_THIS_CAPTURE (lambda);\n+\n+  /* Try to default capture 'this' if we can.  */\n+  if (!this_capture\n+      && LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) != CPLD_NONE)\n+    {\n+      tree containing_function = TYPE_CONTEXT (TREE_TYPE (lambda));\n+      tree lambda_stack = tree_cons (NULL_TREE, lambda, NULL_TREE);\n+\n+      /* If we are in a lambda function, we can move out until we hit:\n+           1. a non-lambda function,\n+           2. a lambda function capturing 'this', or\n+           3. a non-default capturing lambda function.  */\n+      while (LAMBDA_FUNCTION_P (containing_function))\n+        {\n+          tree lambda\n+            = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (containing_function));\n+\n+          if (LAMBDA_EXPR_THIS_CAPTURE (lambda)\n+              || LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) == CPLD_NONE)\n+            break;\n+\n+          lambda_stack = tree_cons (NULL_TREE,\n+                                    lambda,\n+                                    lambda_stack);\n+\n+          containing_function = decl_function_context (containing_function);\n+        }\n+\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (containing_function))\n+        {\n+          this_capture = add_default_capture (lambda_stack,\n+                                              /*id=*/get_identifier (\"__this\"),\n+                                              /* First parameter is 'this'.  */\n+                                              /*initializer=*/DECL_ARGUMENTS\n+                                                (containing_function));\n+        }\n+\n+    }\n+\n+  if (!this_capture)\n+    {\n+      error (\"%<this%> was not captured for this lambda function\");\n+      result = error_mark_node;\n+    }\n+  else\n+    {\n+      /* To make sure that current_class_ref is for the lambda.  */\n+      gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref)) == TREE_TYPE (lambda));\n+\n+      result = finish_non_static_data_member (this_capture,\n+                                              current_class_ref,\n+                                              /*qualifying_scope=*/NULL_TREE);\n+\n+      /* If 'this' is captured, each use of 'this' is transformed into an\n+\t access to the corresponding unnamed data member of the closure\n+\t type cast (_expr.cast_ 5.4) to the type of 'this'. [ The cast\n+\t ensures that the transformed expression is an rvalue. ] */\n+      result = rvalue (result);\n+    }\n+\n+  return result;\n+}\n+\n #include \"gt-cp-semantics.h\""}, {"sha": "7476aa03a434989a70ec317f2b15403ba5e0b653", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -456,6 +456,22 @@ build_cplus_new (tree type, tree init)\n   return rval;\n }\n \n+/* Return a TARGET_EXPR which expresses the direct-initialization of one\n+   array from another.  */\n+\n+tree\n+build_array_copy (tree init)\n+{\n+  tree type = TREE_TYPE (init);\n+  tree slot = build_local_temp (type);\n+  init = build2 (VEC_INIT_EXPR, type, slot, init);\n+  SET_EXPR_LOCATION (init, input_location);\n+  init = build_target_expr (slot, init);\n+  TARGET_EXPR_IMPLICIT_P (init) = 1;\n+\n+  return init;\n+}\n+\n /* Build a TARGET_EXPR using INIT to initialize a new temporary of the\n    indicated TYPE.  */\n \n@@ -726,6 +742,17 @@ cp_build_reference_type (tree to_type, bool rval)\n \n }\n \n+/* Returns EXPR cast to rvalue reference type, like std::move.  */\n+\n+tree\n+move (tree expr)\n+{\n+  tree type = TREE_TYPE (expr);\n+  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);\n+  type = cp_build_reference_type (type, /*rval*/true);\n+  return build_static_cast (type, expr, tf_warning_or_error);\n+}\n+\n /* Used by the C++ front end to build qualified array types.  However,\n    the C version of this function does not properly maintain canonical\n    types (which are not used in C).  */\n@@ -1558,6 +1585,8 @@ no_linkage_check (tree t, bool relaxed_p)\n \t namespace scope.  This doesn't have a core issue number yet.  */\n       if (TYPE_ANONYMOUS_P (t) && TYPE_NAMESPACE_SCOPE_P (t))\n \treturn t;\n+      if (no_linkage_lambda_type_p (t))\n+\treturn t;\n \n       r = CP_TYPE_CONTEXT (t);\n       if (TYPE_P (r))\n@@ -2759,6 +2788,8 @@ special_function_p (const_tree decl)\n      DECL_LANG_SPECIFIC.  */\n   if (DECL_COPY_CONSTRUCTOR_P (decl))\n     return sfk_copy_constructor;\n+  if (DECL_MOVE_CONSTRUCTOR_P (decl))\n+    return sfk_move_constructor;\n   if (DECL_CONSTRUCTOR_P (decl))\n     return sfk_constructor;\n   if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)"}, {"sha": "b4d54fc4089172bca8634d695be3142a89f6eb9b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1161,6 +1161,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n     case DECLTYPE_TYPE:\n       if (DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t1)\n           != DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t2)\n+\t  || (DECLTYPE_FOR_LAMBDA_CAPTURE (t1)\n+\t      != DECLTYPE_FOR_LAMBDA_CAPTURE (t2))\n+\t  || (DECLTYPE_FOR_LAMBDA_RETURN (t1)\n+\t      != DECLTYPE_FOR_LAMBDA_RETURN (t2))\n           || !cp_tree_equal (DECLTYPE_TYPE_EXPR (t1), \n                              DECLTYPE_TYPE_EXPR (t2)))\n         return false;\n@@ -7001,6 +7005,31 @@ check_return_expr (tree retval, bool *no_warning)\n       return NULL_TREE;\n     }\n \n+  /* As an extension, deduce lambda return type from a return statement\n+     anywhere in the body.  */\n+  if (retval && LAMBDA_FUNCTION_P (current_function_decl))\n+    {\n+      tree lambda = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n+      if (LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda))\n+\t{\n+\t  tree type = lambda_return_type (retval);\n+\t  tree oldtype = LAMBDA_EXPR_RETURN_TYPE (lambda);\n+\n+\t  if (VOID_TYPE_P (type))\n+\t    { /* Nothing.  */ }\n+\t  else if (oldtype == NULL_TREE)\n+\t    {\n+\t      pedwarn (input_location, OPT_pedantic, \"lambda return type \"\n+\t\t       \"can only be deduced when the return statement is \"\n+\t\t       \"the only statement in the function body\");\n+\t      apply_lambda_return_type (lambda, type);\n+\t    }\n+\t  else if (!same_type_p (type, oldtype))\n+\t    error (\"inconsistent types %qT and %qT deduced for \"\n+\t\t   \"lambda return type\", type, oldtype);\n+\t}\n+    }\n+\n   if (processing_template_decl)\n     {\n       current_function_returns_value = 1;"}, {"sha": "96fa442f6d11f6cfc4673d8c47c33f117759be9e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -838,6 +838,12 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n       if (TREE_CODE (type) == ARRAY_TYPE\n \t  && TREE_CODE (init) != CONSTRUCTOR)\n \t{\n+\t  /* Allow the result of build_array_copy.  */\n+\t  if (TREE_CODE (init) == TARGET_EXPR\n+\t      && (same_type_ignoring_top_level_qualifiers_p\n+\t\t  (type, TREE_TYPE (init))))\n+\t    return init;\n+\n \t  error (\"array must be initialized with a brace-enclosed\"\n \t\t \" initializer\");\n \t  return error_mark_node;"}, {"sha": "4a7961c807b3edeaa7871f7b3d3f2b93ad84d817", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1,3 +1,46 @@\n+2009-09-29  John Freeman  <jfreeman08@gmail.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/lambda/lambda-array.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-capture-const-ref.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-capture-const-ref-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-const.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-copy-default-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-copy-default.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-copy-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-copy.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-ctor-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-ctors.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-ext-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-ext-neg2.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-ext.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-deduce.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-defarg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-eh.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-errloc.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-field-names.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-in-class-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-in-class.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-lookup-neg.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-mangle.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-mixed.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-mutable.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-nested.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-non-const.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-nop.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-ns-scope.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-pass.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-recursive.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-ref-default.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-ref.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-std-function.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-template.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-this.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-type.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-use.C: New.\n+\t* lib/prune.exp: Accept \"In lambda function\".\n+\n 2009-09-29  Harsha Jagasia  <harsha.jagasia@amd.com>\n \n \t* gcc.target/i386/fma4-check.h"}, {"sha": "2129051ed72b6b0010b1dfb6ad5c23e4e1338d6e", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-array.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-array.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-array.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-array.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,20 @@\n+// Test that array capture by copy works.\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+struct A\n+{\n+  int i;\n+  A(int i): i(i) {}\n+  A(const A& a): i(a.i+1) {}\n+};\n+\n+int main()\n+{\n+  A ar[4][3] = { { 10, 20, 30 },\n+\t\t { 40, 50, 60 },\n+\t\t { 70, 80, 90 },\n+\t\t { 100, 110, 120 } };\n+  int i = [ar] { return ar[1][1]; }().i;\n+  return (i!= 52);\n+}"}, {"sha": "7d1a1bd89d28fbdda91c7d4738a7cb9186c09db2", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-capture-const-ref-neg.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-capture-const-ref-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-capture-const-ref-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-capture-const-ref-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  int i = 1, j = 2;\n+  const int& ci = i;\n+  [&ci, &j] () -> void { j = ci; } ();\n+  assert(i == 1);\n+  assert(j == 1);\n+  [&ci] () -> void { ci = 0; } (); // { dg-error \"\" \"cannot assign to const int&\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "f9cb2d53de28d43c08e933c442e9a9ff867c83ff", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-capture-const-ref.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-capture-const-ref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-capture-const-ref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-capture-const-ref.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  int i = 1, j = 2;\n+  const int& ci = i;\n+  [&ci, &j] () -> void { j = ci; } ();\n+  assert(i == 1);\n+  assert(j == 1);\n+  //[&ci] () -> void { ci = 0; } (); { dg-error: cannot assign to const int& }\n+\n+  return 0;\n+}\n+"}, {"sha": "f48c6c243d65b31fc28c294447c47ee90b530820", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const-neg.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+template<typename F>\n+void call(const F& f) { f(); }\t// { dg-error \"discards qualifiers\" }\n+\n+int main() {\n+  call([] () -> void {});\n+  call([] () mutable -> void {}); // { dg-message \"\" \"`f' does not have const `operator()'\" }\n+\n+  int i = -1;\n+  call([&i] () -> void { i = 0; });\n+  assert(i == 0);\n+  call([i] () -> void { i = 0; }); // { dg-error \"\" \"assignment to non-reference capture in const lambda\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "5bceb9227e0cfb21b00a52cfea6ab378376bfa57", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+template<typename F>\n+void call(const F& f) { f(); }\n+\n+int main() {\n+  call([] () -> void {});\n+  //call([] () mutable -> void {}); // { dg-error: \"`f' does not have const `operator()'\" }\n+\n+  int i = -1;\n+  call([&i] () -> void { i = 0; });\n+  assert(i == 0);\n+  //call([i] () -> void { i = 0; }); // { dg-error: \"assignment to non-reference capture in const lambda\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "1af2a95d8a67c7d94190ac03bf4c64d4f6293f60", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-copy-default-neg.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-default-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-default-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-default-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+int main() {\n+  int i;\n+  const char* s;\n+  [=] () -> void { i; s; i; s; } ();\n+\n+  [] () -> void { i; } (); // { dg-error \"\" \"`i' is not captured\" }\n+  [1] () -> void {} (); // { dg-error \"expected identifier\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "4d4faea470b270e8cdad7f999d798d79aa62f3bd", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-copy-default.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-default.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-default.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-default.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+int main() {\n+  int i;\n+  const char* s;\n+  [=] () -> void { i; s; i; s; } ();\n+\n+  //[] () -> void { i; } (); // { dg-error: \"`i' is not in scope\" }\n+  //[1] () -> void {} (); // { dg-error: \"expected identifier\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "d77e57e6310774262020d5c9d3a4828a133efdaa", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-copy-neg.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+int main() {\n+  int i;\n+  const char* s;\n+  [i, s] () -> void { i; s; } ();\n+\n+  [] () -> void { i; } (); // { dg-error \"\" \"`i' is not captured\" }\n+  [1] () -> void {} (); // { dg-error \"expected identifier\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "d57a01d43e3ecdfb7525872fb5b525974ed35a1b", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-copy.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-copy.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+int main() {\n+  int i;\n+  const char* s;\n+  [i, s] () -> void { i; s; } ();\n+\n+  //[] () -> void { i; } (); // { dg-error: \"`i' is not in scope\" }\n+  //[1] () -> void {} (); // { dg-error: \"expected identifier\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "c38f2955d46c0450dec0c659e7bb9ccb0ca6d250", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ctor-neg.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ctor-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ctor-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ctor-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,25 @@\n+// { dg-options -std=c++0x }\n+\n+void f()\n+{\n+  int i;\n+  auto lam = [i]{};\t\t// { dg-message \"note\" }\n+  decltype(lam) lam2 = { 1 };\t// { dg-error \"\" \"not an aggregate\" }\n+  decltype(lam) lam3;\t\t// { dg-error \"\" \"deleted default ctor\" }\n+  lam3 = lam;\t\t\t// { dg-error \"\" \"deleted assignment op\" }\n+}\n+\n+template <class T>\n+void g(T i)\n+{\n+  auto lam = [i]{};\t\t// { dg-message \"note\" }\n+  decltype(lam) lam2 = { 1 };\t// { dg-error \"\" \"not an aggregate\" }\n+  decltype(lam) lam3;\t\t// { dg-error \"\" \"deleted default ctor\" }\n+  lam3 = lam;\t\t\t// { dg-error \"\" \"deleted assignment op\" }\n+}\n+\n+int main()\n+{\n+  f();\n+  g(1);\n+}"}, {"sha": "e263145b01dc6b9773eed5ec2c1de7c216367a4e", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ctors.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ctors.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ctors.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ctors.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+struct A\n+{\n+  A() { }\n+  A(A&) { }\n+  A(A&&) { }\n+};\n+\n+int main()\n+{\n+  A a;\n+  auto lam4 = [a]{};\t\t// OK, implicit move ctor\n+  lam4();\n+  auto lam5 = lam4;\t\t// OK, implicit copy ctor\n+  lam5();\n+}"}, {"sha": "bfe7acab69bced42b4947f631c0c658c05cf0bd1", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-ext-neg.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,24 @@\n+// Testcase for an extension to allow return type deduction when the lambda\n+// contains more than just a single return-statement.\n+\n+// { dg-options -std=c++0x }\n+\n+bool b;\n+template <class T>\n+T f (T t)\n+{\n+  return [=]\n+    {\n+      auto i = t+1;\n+      if (b)\n+\treturn i+1;\n+      else\n+\treturn i+2;\t\t// { dg-error \"lambda return type\" }\n+    }();\n+}\n+\n+int main()\n+{\n+  if (f(1) != 3)\n+    return 1;\n+}"}, {"sha": "a236e6d116e282ac5773151e1d85992d2c09bbf6", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-ext-neg2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext-neg2.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,22 @@\n+// Test that in pedantic mode, we warn about the extension to allow return\n+// type deduction when the lambda contains more than just a single\n+// return-statement.\n+\n+// { dg-options \"-std=c++0x -pedantic\" }\n+\n+bool b;\n+template <class T>\n+T f (T t)\n+{\n+  [=] { return t+1; };\t\t// OK\n+  return [=] {\n+    auto i = t+1;\n+    return i+1;\t\t\t// { dg-warning \"only statement\" }\n+  }();\n+}\n+\n+int main()\n+{\n+  if (f(1) != 3)\n+    return 1;\n+}"}, {"sha": "9b5ab79837f5c04555f5e6f294065644e24b5200", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-ext.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-ext.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,27 @@\n+// Testcase for an extension to allow return type deduction when the lambda\n+// contains more than just a single return-statement.\n+\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+bool b;\n+template <class T>\n+T f (T t)\n+{\n+  return [=] {\n+    auto i = t+1;\n+    if (b)\n+      return i+1;\n+    else\n+      return i+1;\n+  }();\n+}\n+\n+int main()\n+{\n+  // Pointless, but well-formed.\n+  [] { return 1; return 2; }();\n+\n+  if (f(1) != 3)\n+    return 1;\n+}"}, {"sha": "92dee703e71815821b6af2112321f8a159d30898", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce-neg.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  int i = 0;\n+  int& r = [&] () { return i; } (); // { dg-error \"\" \"invalid initialization of non-const reference of type \u2018int&\u2019 from a temporary of type \u2018int\u2019\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "0b4f92ec7e8073b848c0fdef2e449472eeb905a8", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-deduce.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-deduce.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  [] {};\n+  [] {} ();\n+  [] () {};\n+  [] () {} ();\n+  [] () { return \"lambda\"; };\n+\n+  int i = 1, j = 2;\n+  [&i, j] () { i = j; } ();\n+  assert(i == 2);\n+  assert(j == 2);\n+\n+  i = [] () { return 3; } ();\n+  assert(i == 3);\n+\n+  int k = [&] () { return i; } ();\n+\n+  []{ return; };\n+\n+  int array[] = { 1, 2, 3 };\n+  int* p = [&] () { return array; } ();\n+\n+  return 0;\n+}\n+"}, {"sha": "069935823ea5d566af3e75c8c1f03447a5291766", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-defarg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-defarg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-defarg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options \"-std=c++0x -pedantic-errors\" }\n+\n+int main()\n+{\n+  [](int a = 1) { return a; }(); // { dg-error \"\" }\n+}"}, {"sha": "ea5060d1a3d4363f24404d952d676f7689ca4b72", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-eh.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-eh.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-eh.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-eh.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,35 @@\n+// Test that we properly clean up if we get an exception in the middle of\n+// constructing the closure object.\n+// { dg-options -std=c++0x }\n+\n+// This test fails because of PR 41449; it isn't a lambda issue.\n+// { dg-do run { xfail *-*-* } }\n+\n+struct A\n+{\n+  A() {}\n+  A(const A&) { throw 1; }\n+};\n+\n+int bs;\n+struct B\n+{\n+  B() { ++bs; }\n+  B(const B&) { ++bs; }\n+  ~B() { --bs; }\n+};\n+\n+int main()\n+{\n+  {\n+    B b1, b2;\n+    A a;\n+\n+    try\n+      {\n+\t[b1, a, b2]{ };\n+      }\n+    catch(...) {}\n+  }\n+  return bs;\n+}"}, {"sha": "4037331ee3767fe3e863290f847dc8ea642cc9aa", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-errloc.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-errloc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-errloc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-errloc.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,18 @@\n+// Test that error messages about creating the closure object refer to\n+// the lambda-introducer.\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  A();\n+  A(const A& a) = delete;\t// { dg-error \"deleted\" }\n+};\n+\n+int main()\n+{\n+  A ar[4][3];\n+  [ar] { };\t\t\t// { dg-error \"3:\" }\n+\n+  A a;\n+  [a] { };\t\t\t// { dg-error \"3:\" }\n+}"}, {"sha": "b292d889806fded8cb3bc43bd0986b11bcc725b0", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-field-names.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-field-names.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-field-names.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-field-names.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,21 @@\n+// \"For each entity captured by copy, an unnamed non-static data member is\n+// declared in the closure type\" -- test that there isn't a member of the\n+// closure with the same name as the captured variable.\n+\n+// { dg-options -std=c++0x }\n+\n+template <class T>\n+struct A: public T\n+{\n+  A(T t): T(t) { }\n+  int f() { return this->i; }\t// { dg-error \"\" \"no member named i\" }\n+};\n+\n+int main()\n+{\n+  int i = 42;\n+  auto lam = [i]{ };\n+  lam.i = 24;\t\t\t// { dg-error \"\" \"no member named i\" }\n+  A<decltype(lam)> a(lam);\n+  return a.f();\n+}"}, {"sha": "a93857e46afa25a7718bc3349c7b1184662fee85", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-in-class-neg.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-in-class-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-in-class-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-in-class-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+class C {\n+  private:\n+    int m_i;\n+\n+  public:\n+    C() : m_i(-1) {\n+      [] { this; } ();\t\t// { dg-error \"not captured\" }\n+      [this] () -> void { m_i = 0; } ();\n+      assert(m_i == 0);\n+      [this] () -> void { this->m_i = 1; } ();\n+      assert(m_i == 1);\n+      [&] () -> void { m_i = 2; } ();\n+      assert(m_i == 2);\n+      [&] () -> void { this->m_i = 3; } ();\n+      assert(m_i == 3);\n+      [=] () -> void { m_i = 4; } (); // copies 'this' or --copies-m_i--?\n+      assert(m_i == 4);\n+      [=] () -> void { this->m_i = 5; } ();\n+      assert(m_i == 5);\n+    }\n+\n+};\n+\n+int main() {\n+  C c;\n+\n+  [this] () -> void {} (); // { dg-error \"use of 'this' in non-member function\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "54015fd72f7e903c67f8f335ec4a865a079b8a5a", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-in-class.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-in-class.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-in-class.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-in-class.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+class C {\n+  private:\n+    int m_i;\n+\n+  public:\n+    C() : m_i(-1) {\n+      //[] { this; } ();\n+      [this] () -> void { m_i = 0; } ();\n+      assert(m_i == 0);\n+      [this] () -> void { this->m_i = 1; } ();\n+      assert(m_i == 1);\n+      [&] () -> void { m_i = 2; } ();\n+      assert(m_i == 2);\n+      [&] () -> void { this->m_i = 3; } ();\n+      assert(m_i == 3);\n+      [=] () -> void { m_i = 4; } (); // copies 'this' or --copies-m_i--?\n+      assert(m_i == 4);\n+      [=] () -> void { this->m_i = 5; } ();\n+      assert(m_i == 5);\n+    }\n+\n+};\n+\n+int main() {\n+  C c;\n+\n+  //[this] () -> void {} (); // { dg-error: \"cannot capture `this' outside of class method\" }\n+\n+  return 0;\n+}\n+"}, {"sha": "e07e892a1a3de5f93301d349a5d673b62241fe66", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-lookup-neg.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-lookup-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-lookup-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-lookup-neg.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,7 @@\n+// Test that we don't crash on a failed lookup.\n+// { dg-options -std=c++0x }\n+\n+int main()\n+{\n+  [i]{};\t\t\t// { dg-error \"not declared\" }\n+}"}, {"sha": "dc89d2388fb749d9195b9e197e3ec3b7b865f6ab", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle.C", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,102 @@\n+// Test lambda mangling\n+// { dg-options \"-std=c++0x -fno-inline\" }\n+\n+template<typename F> int algo(F fn) { return fn(); }\n+inline void g(int n) {\n+  int bef(int i = []{ return 1; }());\n+  // Default arguments of block-extern function declarations\n+  // remain in the context of the encloding function body.\n+  // The closure type is encoded as Z1giEUlvE_.\n+  // The call operator of that type is _ZZ1giENKUlvE_clEv.\n+\n+// { dg-final { scan-assembler \"_ZZ1giENKUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZZ1giENKUlvE_clEv\" { target { ! { *-*-darwin* } } } } }\n+\n+  algo([=]{return n+bef();});\n+  // The captured entities do not participate in <lambda-sig>\n+  // and so this closure type has the same <lambda-sig> as\n+  // the previous one.  It encoding is therefore Z1giEUlvE0_\n+  // and the call operator is _ZZ1giENKUlvE0_clEv.  The\n+  // instance of \"algo\" being called is then\n+  // _Z4algoIZ1giEUlvE0_EiT_.\n+\n+// { dg-final { scan-assembler \"_Z4algoIZ1giEUlvE0_EiT_\" } }\n+// { dg-final { scan-assembler \"_ZZ1giENKUlvE0_clEv\" } }\n+\n+  int i = []{return 1;}();\n+\n+}\n+\n+struct S {\n+  void f(int =\n+\t // Type: ZN1S1fEiiEd0_UlvE_\n+\t // Operator: _ZZN1S1fEiiEd0_NKUlvE_clEv\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NKUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZZN1S1fEiiEd0_NKUlvE_clEv\" { target { ! { *-*-darwin* } } } } }\n+\t []{return 1;}()\n+\t // Type: ZN1S1fEiiEd0_UlvE0_\n+\t // Operator: _ZZN1S1fEiiEd0_NKUlvE0_clEv\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NKUlvE0_clEv\" } }\n+\t + []{return 2;}(),\n+\t int =\n+\t // Type: ZN1S1fEiiEd_UlvE_\n+\t // Operator: _ZZN1S1fEiiEd_NKUlvE_clEv\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd_NKUlvE_clEv\" } }\n+\t []{return 3;}());\n+};\n+\n+template<typename T> struct R {\n+  static int x;\n+};\n+template<typename T> int R<T>::x = []{return 1;}();\n+template int R<int>::x;\n+// Type of lambda in intializer of R<int>::x: N1RIiE1xMUlvE_E\n+// Corresponding operator(): _ZNK1RIiE1xMUlvE_clEv\n+// { dg-final { scan-assembler \"_ZNK1RIiE1xMUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZNK1RIiE1xMUlvE_clEv\" } }\n+\n+void bar()\n+{\n+  // lambdas in non-vague linkage functions have internal linkage.\n+  // { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*bar\\[^\\n\\r\\]*Ul\" } }\n+  []{}();\n+}\n+\n+// lambdas used in non-template, non-class body initializers are internal.\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*_ZNKUlv\" } }\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*variable\" } }\n+int variable = []{return 1;}();\n+\n+// And a template instantiated with such a lambda is also internal.\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*algoIUl\" } }\n+int var2 = algo([]{return 1;});\n+\n+// As are lambdas used in non-class-body default arguments.\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*function\" } }\n+void function (int i = []{return 1;}()+[]{return 1;}());\n+\n+struct Foo\n+{\n+  static int Int;\n+  void Bar(int);\n+};\n+\n+int Foo::Int = []{return 1;}();\n+// Even default arguments for member functions that appear outside the\n+// class body are internal.\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*Foo\" } }\n+void Foo::Bar(int i = []{return 1;}()) {}\n+\n+// Even default arguments for function templates.\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*fn2\\[^\\n\\r\\]*Ulv\" } }\n+template <class T>\n+void fn2 (T t = []{return 1;}()) {}\n+\n+int main()\n+{\n+  g(42);\n+  S().f();\n+  function();\n+  Foo().Bar();\n+  fn2<int>();\n+}"}, {"sha": "14c4de9f91278e06b3920877d4aa58d455f337b9", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mixed.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mixed.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mixed.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mixed.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  int i = 1, j = 2;\n+  [&i, j] () mutable -> void { i = 0; j = 0; } ();\n+  assert(i == 0);\n+  assert(j == 2);\n+\n+  return 0;\n+}\n+"}, {"sha": "7065dfb3f21532b0958aad886c381ac7c291ca25", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mutable.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mutable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mutable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mutable.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  int i = 1;\n+  const char* s1 = \"hello\";\n+  const char* s2 = s1;\n+  [i, s2] () mutable -> void { i = 2; s2 = \"world\"; } ();\n+  //[i, s2] () -> void { i = 2; s2 = \"world\"; } (); // { dg-error: \"assignment of data-member in read-only structure\" }\n+  assert(i == 1);\n+  assert(s1 == s2);\n+\n+  return 0;\n+}\n+"}, {"sha": "1689865374ecfc905f3cb37ca3dc23534d599fd1", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+int main() {\n+  int i = 1;\n+\n+  [] (int& i) -> void {\n+    [&] () -> void {\n+      i = 2;\n+    } ();\n+  } (i);\n+\n+  assert(i == 2);\n+\n+  [&] () -> void {\n+    [&i] () -> void {\n+      i = 3;\n+    } ();\n+  } ();\n+\n+  assert(i == 3);\n+\n+  [&] () -> void {\n+    [&] () -> void {\n+      i = 4;\n+    } ();\n+  } ();\n+\n+  assert(i == 4);\n+  i = 4;\n+\n+  [&] () -> void {\n+    [=] () mutable -> void {\n+      i = 5;\n+    } ();\n+  } ();\n+\n+  assert(i == 4);\n+\n+  [=] () mutable -> void {\n+    [&] () -> void {\n+      i = 6;\n+    } ();\n+  } ();\n+\n+  assert(i == 4);\n+\n+  return 0;\n+}\n+"}, {"sha": "9c2b1195af30d21118f66f66192286ebd045c1ca", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-non-const.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+template<typename F>\n+void call(F f) { f(); }\n+\n+int main() {\n+  call([] () -> void {});\n+  call([] () mutable -> void {});\n+\n+  int i = -1;\n+  call([i] () mutable -> void { i = 0; });\n+  assert(i == -1);\n+\n+  return 0;\n+}\n+"}, {"sha": "b366ba1b8fa32be38a20db022039ccb6832fe79d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nop.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nop.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nop.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nop.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+#include <cassert>\n+\n+int main() {\n+  int i = 1, j = 2;\n+  [i, j] () -> void {} ();\n+  assert(i == 1);\n+  assert(j == 2);\n+  [&i, &j] () -> void {} ();\n+  assert(i == 1);\n+  assert(j == 2);\n+  [] (int x) -> void {} (1);\n+  [] (int& x) -> void {} (i);\n+  [] (int x, int y) -> void {} (i, j);\n+\n+  return 0;\n+}\n+"}, {"sha": "cde0c2e5379b25b647ec13de7bf037fc5ec579a4", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ns-scope.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ns-scope.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ns-scope.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ns-scope.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+auto f = [](int i) { return i+1; };\n+\n+int g(int i = [] { return 237; }())\n+{\n+  return i;\n+}\n+\n+int main()\n+{\n+  if (f(41) != 42)\n+    return 1;\n+  if (g() != 237)\n+    return 2;\n+  return 0;\n+}"}, {"sha": "a42de294b6e3d3c4c2bbf71210dc6a4dcd079598", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-pass.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-pass.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-pass.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-pass.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+#include <algorithm>\n+\n+template <typename F, typename A1>\n+void call(F f, const A1& arg1) {\n+  f(arg1);\n+}\n+\n+int main() {\n+  int i = 1;\n+  call(\n+      [&i] (int j) -> void { i = j; },\n+      2\n+  );\n+  assert(i == 2);\n+\n+  int A[] = {1, 2, 3, 4};\n+  int sum = 0;\n+  std::for_each(A, A+4, [&sum] (int n) -> void { sum += n; });\n+  assert(sum == 10);\n+\n+  return 0;\n+}\n+"}, {"sha": "c3c8008d926b37e5012a95d3bbe923d1c40c0319", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-recursive.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-recursive.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-recursive.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-recursive.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+//#include <iostream>\n+#include <functional>\n+#include <cassert>\n+\n+int main() {\n+\n+  std::function<int(int)> fib = [&fib] (int n) -> int {\n+    //std::cerr << \"fib(\" << n << \")\\n\";\n+    if (n <= 2) return 1;\n+    else        return fib(n-1) + fib(n-2);\n+  };\n+\n+  assert(fib(5) == 5);\n+  assert(fib(10) == 55);\n+\n+  return 0;\n+}\n+"}, {"sha": "342e0aeb2cff27b1dc0cf2fd00dd3bc072364378", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ref-default.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ref-default.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ref-default.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ref-default.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+int main() {\n+  int i = 1;\n+  float j = 2.0;\n+  [&] () -> void { i = 3; j = 4.0; } ();\n+  assert(i == 3);\n+  assert(j == 4.0);\n+\n+  return 0;\n+}\n+"}, {"sha": "34ba263b2e57c231bd993eccba7db60fcebbe38f", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ref.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-ref.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cassert>\n+\n+int main() {\n+  int i = 1;\n+  float j = 2.0;\n+  [&i, &j] () -> void { i = 3; j = 4.0; } ();\n+  assert(i == 3);\n+  assert(j == 4.0);\n+\n+  return 0;\n+}\n+"}, {"sha": "26c09fdb119ce215e01d0a096103fcf3740ab87d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-std-function.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-std-function.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-std-function.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-std-function.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,22 @@\n+// Test using std::function wrapper.\n+// { dg-do run }\n+// { dg-options -std=c++0x }\n+\n+#include <functional>\n+\n+typedef std::function<int()> FN;\n+\n+template<typename T>\n+FN f(T fn)\n+{\n+  return [fn]{return fn(2);};\n+}\n+\n+int main()\n+{\n+  auto fn = f([](int i){return i*21;});\n+\n+  if (fn() != 42)\n+    return 1;\n+  return 0;\n+}"}, {"sha": "b4db3b881d10572811fede93f9159c0f41053d70", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-template.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-template.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-template.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+extern \"C\" void abort();\n+\n+template <class T>\n+auto apply (T t) -> decltype (t())\n+{\n+  return t();\n+}\n+\n+template <class T>\n+T f(T t)\n+{\n+  T t2 = t;\n+  if (t != [=]()->T { return t; }())\n+    abort ();\n+  if (t != [=] { return t; }())\n+    abort ();\n+  if (t != [=] { return t2; }())\n+    abort ();\n+  if (t != [&] { return t; }())\n+    abort ();\n+  if (t != apply([=]{return t;}))\n+    abort ();\n+\n+  int i;\n+  [&] (int a)                    { return a+i+t; } (0);\n+  [&] (int a) -> decltype(a)     { return a+i+t; } (0);\n+  [&] (int a) -> decltype(i)     { return a+i+t; } (0);\n+  [&] (int a) -> decltype(t)     { return a+i+t; } (0);\n+  [&] (int a) -> decltype(a+i)   { return a+i+t; } (0);\n+  [&] (int a) -> decltype(a+t)   { return a+i+t; } (0);\n+  [&] (int a) -> decltype(i+t)   { return a+i+t; } (0);\n+  [&] (int a) -> decltype(a+i+t) { return a+i+t; } (0);\n+}\n+\n+int main()\n+{\n+  f(0xbeef);\n+}"}, {"sha": "ed2747654f97fd8cb2f3f51890b4ff8283756a3c", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-this.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,13 @@\n+// Test that implicit 'this' capture works, but that it's still an rvalue.\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  int i;\n+  void f()\n+  {\n+    [=] { i = 0; };\n+    [&] { i = 0; };\n+    [=] { this = 0; };\t\t// { dg-error \"lvalue\" }\n+  }\n+};"}, {"sha": "3b2a2a76a4641f15740f69a9502802ac06f5e091", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-type.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-type.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,74 @@\n+// Every id-expression that is a use (_basic.def.odr_ 3.2) of an entity\n+// captured by copy is transformed into an access to the corresponding\n+// unnamed data member of the closure type.\n+//...\n+// Every occurrence of decltype((x)) where x is a possibly parenthesized\n+// id-expression that names an entity of automatic storage duration is\n+// treated as if x were transformed into an access to a corresponding data\n+// member of the closure type that would have been declared if x were a use\n+// of the denoted entity.\n+\n+// So, other appearances of 'x' within decltype do not refer to the closure\n+// member, because they are not \"use\"s in the sense of 3.2.\n+\n+// { dg-options -std=c++0x }\n+\n+template<class T, class U>\n+struct same_type;\n+template <class T>\n+struct same_type<T,T> { };\n+\n+int main()\n+{\n+  int i;\n+  [=] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int const&>();\n+    i+1;\n+    same_type<decltype((i)),int const&>();\n+    same_type<decltype(i),int>();\n+  };\n+  [=] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int const&>();\n+    same_type<decltype(i),int>();\n+  };\n+  [=] () mutable {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int &>();\n+    same_type<decltype(i),int>();\n+  };\n+  [&] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int &>();\n+    same_type<decltype(i),int>();\n+  };\n+  [i] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int const&>();\n+  };\n+  [&,i] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int const&>();\n+  };\n+  [i] () mutable {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int &>();\n+  };\n+  [&,i] () mutable {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int &>();\n+  };\n+  [&i] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int &>();\n+  };\n+  [=,&i] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int &>();\n+  };\n+  [] {\n+    same_type<decltype(i),int>();\n+    same_type<decltype((i)),int const&>(); // { dg-error \"\" \"not captured\" }\n+  };\n+}"}, {"sha": "b1d6c300cfdbe4b191cc743756fab7e95655a7ea", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-use.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-use.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-use.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-use.C?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++0x }\n+\n+int main(int argc, char** argv)\n+{\n+  int i;\n+  int &ir = i;\n+  const int ci = 0;\n+  const int &cir = ci;\n+\n+  [] { sizeof (argc); sizeof (i); sizeof (ir); sizeof (ci); sizeof (cir); };\n+  [] { int ia[ci]; };\n+}"}, {"sha": "c61ec21c15a6088a57c7fef1db5e5d77ef2b819c", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -20,7 +20,7 @@\n proc prune_gcc_output { text } {\n     #send_user \"Before:$text\\n\"\n \n-    regsub -all \"(^|\\n)(\\[^\\n\\]*: )?In ((static member )?function|member|method|(copy )?constructor|destructor|instantiation|program|subroutine|block-data) \\[^\\n\\]*\" $text \"\" text\n+    regsub -all \"(^|\\n)(\\[^\\n\\]*: )?In ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|program|subroutine|block-data)\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*(: )?At (top level|global scope):\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   instantiated from \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)    inlined from \\[^\\n\\]*\" $text \"\" text"}, {"sha": "6195e348486686862d53f80b6fb42e4590c2d0d6", "filename": "include/ChangeLog.lambda", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/include%2FChangeLog.lambda", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/include%2FChangeLog.lambda", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog.lambda?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -0,0 +1,6 @@\n+2009-09-29  Jason Merrill  <jason@redhat.com>\n+\n+\t* demangle.h (enum demangle_component_type): Add\n+\tDEMANGLE_COMPONENT_LAMBDA, DEMANGLE_COMPONENT_DEFAULT_ARG,\n+\tDEMANGLE_COMPONENT_UNNAMED_TYPE.\n+\t(struct demangle_component): Add s_unary_num."}, {"sha": "76fab0a4582d81b6276c264d7a1dd55e1bf04289", "filename": "include/demangle.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -381,6 +381,12 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS,\n   /* Global destructors keyed to name.  */\n   DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS,\n+  /* A lambda closure type.  */\n+  DEMANGLE_COMPONENT_LAMBDA,\n+  /* A default argument scope.  */\n+  DEMANGLE_COMPONENT_DEFAULT_ARG,\n+  /* An unnamed type.  */\n+  DEMANGLE_COMPONENT_UNNAMED_TYPE,\n   /* A pack expansion.  */\n   DEMANGLE_COMPONENT_PACK_EXPANSION\n };\n@@ -494,6 +500,14 @@ struct demangle_component\n       struct demangle_component *right;\n     } s_binary;\n \n+    struct\n+    {\n+      /* subtree, same place as d_left.  */\n+      struct demangle_component *sub;\n+      /* integer.  */\n+      int num;\n+    } s_unary_num;\n+\n   } u;\n };\n "}, {"sha": "03a84798d30b39f93521b06969d15f324082ac94", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -1,3 +1,14 @@\n+2009-09-29  Jason Merrill  <jason@redhat.com>\n+\n+\t* Makefile.in: Enable demangle target.\n+\t* cp-demangle.c (d_lambda, d_unnamed_type, d_make_default_arg): New.\n+\t(d_name, d_prefix, d_unqualified_name, d_local_name): Handle lambdas.\n+\t(d_parmlist): Factor out from d_bare_function_type.\n+\t(d_compact_number): Factor out from d_template_param and d_expression.\n+\t(d_append_num): Factor out from d_print_comp.\n+\t(d_print_comp, d_print_mod_list): Handle lambdas.\n+\t* testsuite/demangle-expected: Add lambda tests.\n+\n 2009-09-23  Matthew Gingell  <gingell@adacore.com>\n \n \t* cplus-dem.c (ada_demangle): Ensure demangled is freed."}, {"sha": "ba24c6db7a78863168f8d3570dc142bbeadbf4fe", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -371,10 +371,12 @@ TAGS: $(CFILES)\n \tetags `for i in $(CFILES); do echo $(srcdir)/$$i ; done`\n \n # The standalone demangler (c++filt) has been moved to binutils.\n-demangle:\n+# But make this target work anyway for demangler hacking.\n+demangle: $(ALL) $(srcdir)/cp-demangle.c\n \t@echo \"The standalone demangler, now named c++filt, is now\"\n \t@echo \"a part of binutils.\"\n-\t@false\n+\t$(CC) @DEFS@ $(CFLAGS) $(CPPFLAGS) -I. -I$(INCDIR) $(HDEFINES) \\\n+\t  $(srcdir)/cp-demangle.c -DSTANDALONE_DEMANGLER $(TARGETLIB) -o $@\n \n ls:\n \t@echo Makefile $(CFILES)"}, {"sha": "43cf34a36cf2c9ff8cd3b4ebe2c6b826fa554238", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 238, "deletions": 61, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -408,6 +408,10 @@ static struct demangle_component *d_local_name (struct d_info *);\n \n static int d_discriminator (struct d_info *);\n \n+static struct demangle_component *d_lambda (struct d_info *);\n+\n+static struct demangle_component *d_unnamed_type (struct d_info *);\n+\n static int\n d_add_substitution (struct d_info *, struct demangle_component *);\n \n@@ -922,6 +926,20 @@ d_make_extended_operator (struct d_info *di, int args,\n   return p;\n }\n \n+static struct demangle_component *\n+d_make_default_arg (struct d_info *di, int num,\n+\t\t    struct demangle_component *sub)\n+{\n+  struct demangle_component *p = d_make_empty (di);\n+  if (p)\n+    {\n+      p->type = DEMANGLE_COMPONENT_DEFAULT_ARG;\n+      p->u.s_unary_num.num = num;\n+      p->u.s_unary_num.sub = sub;\n+    }\n+  return p;\n+}\n+\n /* Add a new constructor component.  */\n \n static struct demangle_component *\n@@ -1153,8 +1171,9 @@ d_name (struct d_info *di)\n       return d_local_name (di);\n \n     case 'L':\n+    case 'U':\n       return d_unqualified_name (di);\n-\t\n+\n     case 'S':\n       {\n \tint subst;\n@@ -1276,6 +1295,7 @@ d_prefix (struct d_info *di)\n \t  || IS_LOWER (peek)\n \t  || peek == 'C'\n \t  || peek == 'D'\n+\t  || peek == 'U'\n \t  || peek == 'L')\n \tdc = d_unqualified_name (di);\n       else if (peek == 'S')\n@@ -1291,6 +1311,16 @@ d_prefix (struct d_info *di)\n \tdc = d_template_param (di);\n       else if (peek == 'E')\n \treturn ret;\n+      else if (peek == 'M')\n+\t{\n+\t  /* Initializer scope for a lambda.  We don't need to represent\n+\t     this; the normal code will just treat the variable as a type\n+\t     scope, which gives appropriate output.  */\n+\t  if (ret == NULL)\n+\t    return NULL;\n+\t  d_advance (di, 1);\n+\t  continue;\n+\t}\n       else\n \treturn NULL;\n \n@@ -1347,6 +1377,18 @@ d_unqualified_name (struct d_info *di)\n \treturn NULL;\n       return ret;\n     }\n+  else if (peek == 'U')\n+    {\n+      switch (d_peek_next_char (di))\n+\t{\n+\tcase 'l':\n+\t  return d_lambda (di);\n+\tcase 't':\n+\t  return d_unnamed_type (di);\n+\tdefault:\n+\t  return NULL;\n+\t}\n+    }\n   else\n     return NULL;\n }\n@@ -2242,50 +2284,30 @@ d_function_type (struct d_info *di)\n   return ret;\n }\n \n-/* <bare-function-type> ::= [J]<type>+  */\n+/* <type>+ */\n \n static struct demangle_component *\n-d_bare_function_type (struct d_info *di, int has_return_type)\n+d_parmlist (struct d_info *di)\n {\n-  struct demangle_component *return_type;\n   struct demangle_component *tl;\n   struct demangle_component **ptl;\n-  char peek;\n \n-  /* Detect special qualifier indicating that the first argument\n-     is the return type.  */\n-  peek = d_peek_char (di);\n-  if (peek == 'J')\n-    {\n-      d_advance (di, 1);\n-      has_return_type = 1;\n-    }\n-\n-  return_type = NULL;\n   tl = NULL;\n   ptl = &tl;\n   while (1)\n     {\n       struct demangle_component *type;\n \n-      peek = d_peek_char (di);\n+      char peek = d_peek_char (di);\n       if (peek == '\\0' || peek == 'E')\n \tbreak;\n       type = cplus_demangle_type (di);\n       if (type == NULL)\n \treturn NULL;\n-      if (has_return_type)\n-\t{\n-\t  return_type = type;\n-\t  has_return_type = 0;\n-\t}\n-      else\n-\t{\n-\t  *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);\n-\t  if (*ptl == NULL)\n-\t    return NULL;\n-\t  ptl = &d_right (*ptl);\n-\t}\n+      *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);\n+      if (*ptl == NULL)\n+\treturn NULL;\n+      ptl = &d_right (*ptl);\n     }\n \n   /* There should be at least one parameter type besides the optional\n@@ -2300,10 +2322,45 @@ d_bare_function_type (struct d_info *di, int has_return_type)\n       && d_left (tl)->u.s_builtin.type->print == D_PRINT_VOID)\n     {\n       di->expansion -= d_left (tl)->u.s_builtin.type->len;\n-      tl = NULL;\n+      d_left (tl) = NULL;\n     }\n \n-  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE, return_type, tl);\n+  return tl;\n+}\n+\n+/* <bare-function-type> ::= [J]<type>+  */\n+\n+static struct demangle_component *\n+d_bare_function_type (struct d_info *di, int has_return_type)\n+{\n+  struct demangle_component *return_type;\n+  struct demangle_component *tl;\n+  char peek;\n+\n+  /* Detect special qualifier indicating that the first argument\n+     is the return type.  */\n+  peek = d_peek_char (di);\n+  if (peek == 'J')\n+    {\n+      d_advance (di, 1);\n+      has_return_type = 1;\n+    }\n+\n+  if (has_return_type)\n+    {\n+      return_type = cplus_demangle_type (di);\n+      if (return_type == NULL)\n+\treturn NULL;\n+    }\n+  else\n+    return_type = NULL;\n+\n+  tl = d_parmlist (di);\n+  if (tl == NULL)\n+    return NULL;\n+\n+  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE,\n+\t\t      return_type, tl);\n }\n \n /* <class-enum-type> ::= <name>  */\n@@ -2405,6 +2462,24 @@ d_pointer_to_member_type (struct d_info *di)\n   return d_make_comp (di, DEMANGLE_COMPONENT_PTRMEM_TYPE, cl, mem);\n }\n \n+/* <non-negative number> _ */\n+\n+static long\n+d_compact_number (struct d_info *di)\n+{\n+  long num;\n+  if (d_peek_char (di) == '_')\n+    num = 0;\n+  else if (d_peek_char (di) == 'n')\n+    return -1;\n+  else\n+    num = d_number (di) + 1;\n+\n+  if (! d_check_char (di, '_'))\n+    return -1;\n+  return num;\n+}\n+\n /* <template-param> ::= T_\n                     ::= T <(parameter-2 non-negative) number> _\n */\n@@ -2417,17 +2492,8 @@ d_template_param (struct d_info *di)\n   if (! d_check_char (di, 'T'))\n     return NULL;\n \n-  if (d_peek_char (di) == '_')\n-    param = 0;\n-  else\n-    {\n-      param = d_number (di);\n-      if (param < 0)\n-\treturn NULL;\n-      param += 1;\n-    }\n-\n-  if (! d_check_char (di, '_'))\n+  param = d_compact_number (di);\n+  if (param < 0)\n     return NULL;\n \n   ++di->did_subs;\n@@ -2599,17 +2665,8 @@ d_expression (struct d_info *di)\n       /* Function parameter used in a late-specified return type.  */\n       int index;\n       d_advance (di, 2);\n-      if (d_peek_char (di) == '_')\n-\tindex = 1;\n-      else\n-\t{\n-\t  index = d_number (di);\n-\t  if (index < 0)\n-\t    return NULL;\n-\t  index += 2;\n-\t}\n-\n-      if (! d_check_char (di, '_'))\n+      index = d_compact_number (di);\n+      if (index < 0)\n \treturn NULL;\n \n       return d_make_function_param (di, index);\n@@ -2802,10 +2859,31 @@ d_local_name (struct d_info *di)\n   else\n     {\n       struct demangle_component *name;\n+      int num = -1;\n+\n+      if (d_peek_char (di) == 'd')\n+\t{\n+\t  /* Default argument scope: d <number> _.  */\n+\t  d_advance (di, 1);\n+\t  num = d_compact_number (di);\n+\t  if (num < 0)\n+\t    return NULL;\n+\t}\n \n       name = d_name (di);\n-      if (! d_discriminator (di))\n-\treturn NULL;\n+      if (name)\n+\tswitch (name->type)\n+\t  {\n+\t    /* Lambdas and unnamed types have internal discriminators.  */\n+\t  case DEMANGLE_COMPONENT_LAMBDA:\n+\t  case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n+\t    break;\n+\t  default:\n+\t    if (! d_discriminator (di))\n+\t      return NULL;\n+\t  }\n+      if (num >= 0)\n+\tname = d_make_default_arg (di, num, name);\n       return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function, name);\n     }\n }\n@@ -2829,6 +2907,75 @@ d_discriminator (struct d_info *di)\n   return 1;\n }\n \n+/* <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _ */\n+\n+static struct demangle_component *\n+d_lambda (struct d_info *di)\n+{\n+  struct demangle_component *tl;\n+  struct demangle_component *ret;\n+  int num;\n+\n+  if (! d_check_char (di, 'U'))\n+    return NULL;\n+  if (! d_check_char (di, 'l'))\n+    return NULL;\n+\n+  tl = d_parmlist (di);\n+  if (tl == NULL)\n+    return NULL;\n+\n+  if (! d_check_char (di, 'E'))\n+    return NULL;\n+\n+  num = d_compact_number (di);\n+  if (num < 0)\n+    return NULL;\n+\n+  ret = d_make_empty (di);\n+  if (ret)\n+    {\n+      ret->type = DEMANGLE_COMPONENT_LAMBDA;\n+      ret->u.s_unary_num.sub = tl;\n+      ret->u.s_unary_num.num = num;\n+    }\n+\n+  if (! d_add_substitution (di, ret))\n+    return NULL;\n+\n+  return ret;\n+}\n+\n+/* <unnamed-type-name> ::= Ut [ <nonnegative number> ] _ */\n+\n+static struct demangle_component *\n+d_unnamed_type (struct d_info *di)\n+{\n+  struct demangle_component *ret;\n+  long num;\n+\n+  if (! d_check_char (di, 'U'))\n+    return NULL;\n+  if (! d_check_char (di, 't'))\n+    return NULL;\n+\n+  num = d_compact_number (di);\n+  if (num < 0)\n+    return NULL;\n+\n+  ret = d_make_empty (di);\n+  if (ret)\n+    {\n+      ret->type = DEMANGLE_COMPONENT_UNNAMED_TYPE;\n+      ret->u.s_number.number = num;\n+    }\n+\n+  if (! d_add_substitution (di, ret))\n+    return NULL;\n+\n+  return ret;\n+}\n+\n /* Add a new substitution.  */\n \n static int\n@@ -3122,6 +3269,14 @@ d_append_string (struct d_print_info *dpi, const char *s)\n   d_append_buffer (dpi, s, strlen (s));\n }\n \n+static inline void\n+d_append_num (struct d_print_info *dpi, long l)\n+{\n+  char buf[25];\n+  sprintf (buf,\"%ld\", l);\n+  d_append_string (dpi, buf);\n+}\n+\n static inline char\n d_last_char (struct d_print_info *dpi)\n {\n@@ -3398,6 +3553,8 @@ d_print_comp (struct d_print_info *dpi,\n \t    struct demangle_component *local_name;\n \n \t    local_name = d_right (typed_name);\n+\t    if (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)\n+\t      local_name = local_name->u.s_unary_num.sub;\n \t    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n \t\t   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t\t   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS)\n@@ -4048,13 +4205,10 @@ d_print_comp (struct d_print_info *dpi,\n       return;\n \n     case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n-      {\n-\tchar buf[25];\n-\td_append_string (dpi, \"parm#\");\n-\tsprintf(buf,\"%ld\", dc->u.s_number.number);\n-\td_append_string (dpi, buf);\n-\treturn;\n-      }\n+      d_append_string (dpi, \"{parm#\");\n+      d_append_num (dpi, dc->u.s_number.number + 1);\n+      d_append_char (dpi, '}');\n+      return;\n \n     case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n       d_append_string (dpi, \"global constructors keyed to \");\n@@ -4066,6 +4220,20 @@ d_print_comp (struct d_print_info *dpi,\n       d_print_comp (dpi, dc->u.s_binary.left);\n       return;\n \n+    case DEMANGLE_COMPONENT_LAMBDA:\n+      d_append_string (dpi, \"{lambda(\");\n+      d_print_comp (dpi, dc->u.s_unary_num.sub);\n+      d_append_string (dpi, \")#\");\n+      d_append_num (dpi, dc->u.s_unary_num.num + 1);\n+      d_append_char (dpi, '}');\n+      return;\n+\n+    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n+      d_append_string (dpi, \"{unnamed type#\");\n+      d_append_num (dpi, dc->u.s_number.number + 1);\n+      d_append_char (dpi, '}');\n+      return;\n+\n     default:\n       d_print_error (dpi);\n       return;\n@@ -4184,6 +4352,15 @@ d_print_mod_list (struct d_print_info *dpi,\n \td_append_char (dpi, '.');\n \n       dc = d_right (mods->mod);\n+\n+      if (dc->type == DEMANGLE_COMPONENT_DEFAULT_ARG)\n+\t{\n+\t  d_append_string (dpi, \"{default arg#\");\n+\t  d_append_num (dpi, dc->u.s_unary_num.num + 1);\n+\t  d_append_string (dpi, \"}::\");\n+\t  dc = dc->u.s_unary_num.sub;\n+\t}\n+\n       while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n \t     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t     || dc->type == DEMANGLE_COMPONENT_CONST_THIS)"}, {"sha": "6798154d2f3401b8c2f3616a86fe74e9ad2e79f4", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f4edddeb609ad93c7a69ad4575b082de8dc707/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=d5f4edddeb609ad93c7a69ad4575b082de8dc707", "patch": "@@ -3885,11 +3885,11 @@ java resource java/util/iso4217.properties\n # decltype/param placeholder test\n --format=gnu-v3\n _Z3addIidEDTplfp_fp0_ET_T0_\n-decltype (parm#1+parm#2) add<int, double>(int, double)\n+decltype ({parm#1}+{parm#2}) add<int, double>(int, double)\n # decltype/fn call test\n --format=gnu-v3\n _Z4add3IidEDTclL_Z1gEfp_fp0_EET_T0_\n-decltype (g(parm#1, parm#2)) add3<int, double>(int, double)\n+decltype (g({parm#1}, {parm#2})) add3<int, double>(int, double)\n # new (2008) built in types test\n --format=gnu-v3\n _Z1fDfDdDeDhDsDi\n@@ -3901,12 +3901,28 @@ void f<int*, float*, double*>(int*, float*, double*)\n # '.' test\n --format=gnu-v3\n _Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_\n-decltype ((parm#1.(g<double>))()) h<A<int>, double>(A<int>, double)\n+decltype (({parm#1}.(g<double>))()) h<A<int>, double>(A<int>, double)\n # test for typed function in decltype\n --format=gnu-v3\n _ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_\n-decltype (parm#1+((x())())) A<int>::j<int>(int)\n+decltype ({parm#1}+((x())())) A<int>::j<int>(int)\n # test for expansion of function parameter pack\n --format=gnu-v3\n _Z1gIIidEEDTclL_Z1fEspplfp_Li1EEEDpT_\n-decltype (f((parm#1+(1))...)) g<int, double>(int, double)\n+decltype (f(({parm#1}+(1))...)) g<int, double>(int, double)\n+# lambda tests\n+--format=gnu-v3\n+_ZZ1giENKUlvE_clEv\n+g(int)::{lambda()#1}::operator()() const\n+--format=gnu-v3\n+_Z4algoIZ1giEUlvE0_EiT_\n+int algo<g(int)::{lambda()#2}>(g(int)::{lambda()#2})\n+--format=gnu-v3\n+_ZZN1S1fEiiEd0_NKUlvE0_clEv\n+S::f(int, int)::{default arg#2}::{lambda()#2}::operator()() const\n+--format=gnu-v3\n+_ZNK1SIiE1xMUlvE1_clEv\n+S<int>::x::{lambda()#3}::operator()() const\n+--format=gnu-v3\n+_Z1fN1SUt_E\n+f(S::{unnamed type#1})"}]}