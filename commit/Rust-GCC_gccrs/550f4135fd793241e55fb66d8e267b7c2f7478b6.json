{"sha": "550f4135fd793241e55fb66d8e267b7c2f7478b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwZjQxMzVmZDc5MzI0MWU1NWZiNjZkOGUyNjdiN2MyZjc0NzhiNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T13:20:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T13:20:52Z"}, "message": "[multiple changes]\n\n2009-04-10  Thomas Quinot  <quinot@adacore.com>\n\n\t* xsnamest.adb: Use XUtil to have uniform line endings (UNIX style) in\n\tgenerated files on all platforms.\n\n2009-04-10  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aux.adb: Minor reformatting\n\n2009-04-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Access_Definition): Handle properly the case of a\n\tprotected function with formals that returns an anonymous access type.\n\n2009-04-10  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_disp.adb: Minor reformatting\n\n2009-04-10  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* seh_init.c: Do not use the 32-bit specific implementation of\n\t__gnat_install_SEH_handler on 64-bit Windows target (64-bit specific\n\tversion TBD).\n\n2009-04-10  Jose Ruiz  <ruiz@adacore.com>\n\n\t* mlib-tgt-specific-xi.adb (Get_Target_Prefix): Target_Name may contain\n\ta '/' at the end so we better use the complete target name to determine\n\twhether it is a PowerPC 55xx target.\n\nFrom-SVN: r145898", "tree": {"sha": "309d701a8f02c317380ed09fb46ab8e38d5c2cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/309d701a8f02c317380ed09fb46ab8e38d5c2cba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550f4135fd793241e55fb66d8e267b7c2f7478b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550f4135fd793241e55fb66d8e267b7c2f7478b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550f4135fd793241e55fb66d8e267b7c2f7478b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550f4135fd793241e55fb66d8e267b7c2f7478b6/comments", "author": null, "committer": null, "parents": [{"sha": "b8063c9899922632bb7f29508bfd0e532b48f7b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8063c9899922632bb7f29508bfd0e532b48f7b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8063c9899922632bb7f29508bfd0e532b48f7b9"}], "stats": {"total": 191, "additions": 121, "deletions": 70}, "files": [{"sha": "0c842ddb7509a20b9eab4e16b73459a756e5463f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -1,3 +1,33 @@\n+2009-04-10  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* xsnamest.adb: Use XUtil to have uniform line endings (UNIX style) in\n+\tgenerated files on all platforms.\n+\n+2009-04-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aux.adb: Minor reformatting\n+\n+2009-04-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Access_Definition): Handle properly the case of a\n+\tprotected function with formals that returns an anonymous access type.\n+\n+2009-04-10  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_disp.adb: Minor reformatting\n+\n+2009-04-10  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* seh_init.c: Do not use the 32-bit specific implementation of\n+\t__gnat_install_SEH_handler on 64-bit Windows target (64-bit specific\n+\tversion TBD).\n+\n+2009-04-10  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* mlib-tgt-specific-xi.adb (Get_Target_Prefix): Target_Name may contain\n+\ta '/' at the end so we better use the complete target name to determine\n+\twhether it is a PowerPC 55xx target.\n+\n 2009-04-10  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_eval.adb: Minor reformatting"}, {"sha": "97e6e53be1f3c1ce3c7294ff227fed87db9db8e7", "filename": "gcc/ada/mlib-tgt-specific-xi.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-xi.adb?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -155,8 +155,9 @@ package body MLib.Tgt.Specific is\n       elsif Target_Name (Target_Name'First .. Index) = \"leon\" then\n          return \"leon-elf-\";\n       elsif Target_Name (Target_Name'First .. Index) = \"powerpc\" then\n-         if Target_Name'Last - 6 >= Target_Name'First and then\n-           Target_Name (Target_Name'Last - 6 .. Target_Name'Last) = \"eabispe\"\n+         if Target_Name'Length >= 23 and then\n+           Target_Name (Target_Name'First .. Target_Name'First + 22) =\n+           \"powerpc-unknown-eabispe\"\n          then\n             return \"powerpc-eabispe-\";\n          else"}, {"sha": "2bc3d2315c91848659b3b56b40b507a3cdad6920", "filename": "gcc/ada/seh_init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fseh_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fseh_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fseh_init.c?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -59,7 +59,7 @@ extern struct Exception_Data _abort_signal;\n extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n \n \n-#ifdef _WIN32\n+#if defined (_WIN32) && !defined (_WIN64)\n \n #include <windows.h>\n #include <excpt.h>\n@@ -224,7 +224,7 @@ __gnat_install_SEH_handler (void *ER)\n   asm (\"mov %ecx,%fs:(0)\");\n }\n \n-#else /* _WIN32 */\n+#else /* defined (_WIN32) && !defined (_WIN64) */\n /* For all non Windows targets we provide a dummy SEH install handler.  */\n void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n {"}, {"sha": "884c2bd4109c2924554d4514ad0ec89934b77066", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -107,9 +107,9 @@ package body Sem_Aux is\n       Full_D : Node_Id;\n \n    begin\n-      --  If we have no declaration node, then return no constant value.\n-      --  Not clear how this can happen, but it does sometimes and this is\n-      --  the safest approach.\n+      --  If we have no declaration node, then return no constant value. Not\n+      --  clear how this can happen, but it does sometimes and this is the\n+      --  safest approach.\n \n       if No (D) then\n          return Empty;\n@@ -119,9 +119,9 @@ package body Sem_Aux is\n       elsif Nkind (D) = N_Object_Renaming_Declaration then\n          return Renamed_Object (Ent);\n \n-      --  If this is a component declaration whose entity is constant, it\n-      --  is a prival within a protected function. It does not have\n-      --  a constant value.\n+      --  If this is a component declaration whose entity is constant, it is\n+      --  a prival within a protected function. It does not have a constant\n+      --  value.\n \n       elsif Nkind (D) = N_Component_Declaration then\n          return Empty;\n@@ -161,8 +161,8 @@ package body Sem_Aux is\n       S : Entity_Id;\n \n    begin\n-      --  The following test is an error defense against some syntax\n-      --  errors that can leave scopes very messed up.\n+      --  The following test is an error defense against some syntax errors\n+      --  that can leave scopes very messed up.\n \n       if Ent = Standard_Standard then\n          return Ent;\n@@ -314,12 +314,12 @@ package body Sem_Aux is\n \n    begin\n       --  If the base type has no freeze node, it is a type in standard,\n-      --  and always acts as its own first subtype unless it is one of\n-      --  the predefined integer types. If the type is formal, it is also\n-      --  a first subtype, and its base type has no freeze node. On the other\n-      --  hand, a subtype of a generic formal is not its own first_subtype.\n-      --  Its base type, if anonymous, is attached to the formal type decl.\n-      --  from which the first subtype is obtained.\n+      --  and always acts as its own first subtype unless it is one of the\n+      --  predefined integer types. If the type is formal, it is also a first\n+      --  subtype, and its base type has no freeze node. On the other hand, a\n+      --  subtype of a generic formal is not its own first_subtype. Its base\n+      --  type, if anonymous, is attached to the formal type decl. from which\n+      --  the first subtype is obtained.\n \n       if No (F) then\n "}, {"sha": "bc6635ffb8c7fbd09383f472ac4947c0004a6d14", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -726,11 +726,12 @@ package body Sem_Ch3 is\n      (Related_Nod : Node_Id;\n       N           : Node_Id) return Entity_Id\n    is\n-      Loc        : constant Source_Ptr := Sloc (Related_Nod);\n-      Anon_Type  : Entity_Id;\n-      Anon_Scope : Entity_Id;\n-      Desig_Type : Entity_Id;\n-      Decl       : Entity_Id;\n+      Loc                 : constant Source_Ptr := Sloc (Related_Nod);\n+      Anon_Type           : Entity_Id;\n+      Anon_Scope          : Entity_Id;\n+      Desig_Type          : Entity_Id;\n+      Decl                : Entity_Id;\n+      Enclosing_Prot_Type : Entity_Id := Empty;\n \n    begin\n       if Is_Entry (Current_Scope)\n@@ -767,9 +768,23 @@ package body Sem_Ch3 is\n          --  is associated with one of the protected operations, and must\n          --  be available in the scope that encloses the protected declaration.\n          --  Otherwise the type is in the scope enclosing the subprogram.\n+         --  If the function has formals, The return type of a subprogram\n+         --  declaration is analyzed in the scope of the subprogram (see\n+         --  Process_Formals) and thus the protected type, if present, is\n+         --  the scope of the current function scope.\n \n          if Ekind (Current_Scope) = E_Protected_Type then\n-            Anon_Scope := Scope (Scope (Defining_Entity (Related_Nod)));\n+            Enclosing_Prot_Type := Current_Scope;\n+\n+         elsif Ekind (Current_Scope) = E_Function\n+           and then Ekind (Scope (Current_Scope)) = E_Protected_Type\n+         then\n+            Enclosing_Prot_Type := Scope (Current_Scope);\n+         end if;\n+\n+         if Present (Enclosing_Prot_Type) then\n+            Anon_Scope := Scope (Enclosing_Prot_Type);\n+\n          else\n             Anon_Scope := Scope (Defining_Entity (Related_Nod));\n          end if;\n@@ -947,8 +962,8 @@ package body Sem_Ch3 is\n       elsif Nkind (Related_Nod) = N_Function_Specification\n         and then not From_With_Type (Anon_Type)\n       then\n-         if Ekind (Current_Scope) = E_Protected_Type then\n-            Build_Itype_Reference (Anon_Type, Parent (Current_Scope));\n+         if Present (Enclosing_Prot_Type) then\n+            Build_Itype_Reference (Anon_Type, Parent (Enclosing_Prot_Type));\n \n          elsif Is_List_Member (Parent (Related_Nod))\n            and then Nkind (Parent (N)) /= N_Parameter_Specification"}, {"sha": "40778ddc9635bb1b547b53696acde812f329e3bd", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -83,8 +83,8 @@ package body Sem_Disp is\n       List : constant Elist_Id := Primitive_Operations (Tagged_Type);\n \n    begin\n-      --  The dispatching operation may already be on the list, if it the\n-      --  wrapper for an inherited function of a null extension (see exp_ch3\n+      --  The dispatching operation may already be on the list, if it is the\n+      --  wrapper for an inherited function of a null extension (see Exp_Ch3\n       --  for the construction of function wrappers). The list of primitive\n       --  operations must not contain duplicates.\n \n@@ -185,7 +185,7 @@ package body Sem_Disp is\n                Set_Has_Controlling_Result (Subp);\n \n                --  Check that result subtype statically matches first subtype\n-               --  (Ada 2005) : Subp may have a controlling access result.\n+               --  (Ada 2005): Subp may have a controlling access result.\n \n                if Subtypes_Statically_Match (Typ, Etype (Subp))\n                  or else (Ekind (Etype (Subp)) = E_Anonymous_Access_Type\n@@ -236,8 +236,8 @@ package body Sem_Disp is\n                Tagged_Type := Base_Type (Designated_Type (T));\n             end if;\n \n-         --  Ada 2005 : an incomplete type can be tagged. An operation with\n-         --  an access parameter of the type is dispatching.\n+         --  Ada 2005: an incomplete type can be tagged. An operation with an\n+         --  access parameter of the type is dispatching.\n \n          elsif Scope (Designated_Type (T)) = Current_Scope then\n             Tagged_Type := Designated_Type (T);\n@@ -256,14 +256,12 @@ package body Sem_Disp is\n          end if;\n       end if;\n \n-      if No (Tagged_Type)\n-        or else Is_Class_Wide_Type (Tagged_Type)\n-      then\n+      if No (Tagged_Type) or else Is_Class_Wide_Type (Tagged_Type) then\n          return Empty;\n \n-      --  The dispatching type and the primitive operation must be defined\n-      --  in the same scope, except in the case of internal operations and\n-      --  formal abstract subprograms.\n+      --  The dispatching type and the primitive operation must be defined in\n+      --  the same scope, except in the case of internal operations and formal\n+      --  abstract subprograms.\n \n       elsif ((Scope (Subp) = Scope (Tagged_Type) or else Is_Internal (Subp))\n                and then (not Is_Generic_Type (Tagged_Type)\n@@ -300,7 +298,7 @@ package body Sem_Disp is\n \n       Static_Tag : Node_Id := Empty;\n       --  If a controlling formal has a statically tagged actual, the tag of\n-      --  this actual is to be used for any tag-indeterminate actual\n+      --  this actual is to be used for any tag-indeterminate actual.\n \n       procedure Check_Dispatching_Context;\n       --  If the call is tag-indeterminate and the entity being called is\n@@ -323,8 +321,8 @@ package body Sem_Disp is\n               and then not Is_Abstract_Subprogram (Alias (Subp))\n               and then No (DTC_Entity (Subp))\n             then\n-               --  Private overriding of inherited abstract operation,\n-               --  call is legal.\n+               --  Private overriding of inherited abstract operation, call is\n+               --  legal.\n \n                Set_Entity (Name (N), Alias (Subp));\n                return;\n@@ -399,7 +397,7 @@ package body Sem_Disp is\n \n             --  If the formal is controlling but the actual is not, the type\n             --  of the actual is statically known, and may be used as the\n-            --  controlling tag for some other-indeterminate actual.\n+            --  controlling tag for some other tag-indeterminate actual.\n \n             elsif Is_Controlling_Formal (Formal)\n               and then Is_Entity_Name (Actual)\n@@ -412,18 +410,19 @@ package body Sem_Disp is\n             Next_Formal (Formal);\n          end loop;\n \n-         --  If the call doesn't have a controlling actual but does have\n-         --  an indeterminate actual that requires dispatching treatment,\n-         --  then an object is needed that will serve as the controlling\n-         --  argument for a dispatching call on the indeterminate actual.\n-         --  This can only occur in the unusual situation of a default\n-         --  actual given by a tag-indeterminate call and where the type\n-         --  of the call is an ancestor of the type associated with a\n-         --  containing call to an inherited operation (see AI-239).\n-         --  Rather than create an object of the tagged type, which would\n-         --  be problematic for various reasons (default initialization,\n-         --  discriminants), the tag of the containing call's associated\n-         --  tagged type is directly used to control the dispatching.\n+         --  If the call doesn't have a controlling actual but does have an\n+         --  indeterminate actual that requires dispatching treatment, then an\n+         --  object is needed that will serve as the controlling argument for a\n+         --  dispatching call on the indeterminate actual. This can only occur\n+         --  in the unusual situation of a default actual given by a\n+         --  tag-indeterminate call and where the type of the call is an\n+         --  ancestor of the type associated with a containing call to an\n+         --  inherited operation (see AI-239).\n+\n+         --  Rather than create an object of the tagged type, which would be\n+         --  problematic for various reasons (default initialization,\n+         --  discriminants), the tag of the containing call's associated tagged\n+         --  type is directly used to control the dispatching.\n \n          if No (Control)\n            and then Indeterm_Ancestor_Call\n@@ -460,11 +459,11 @@ package body Sem_Disp is\n \n                   elsif Is_Tag_Indeterminate (Actual) then\n \n-                     --  The tag is inherited from the enclosing call (the\n-                     --  node we are currently analyzing). Explicitly expand\n-                     --  the actual, since the previous call to Expand\n-                     --  (from Resolve_Call) had no way of knowing about\n-                     --  the required dispatching.\n+                     --  The tag is inherited from the enclosing call (the node\n+                     --  we are currently analyzing). Explicitly expand the\n+                     --  actual, since the previous call to Expand (from\n+                     --  Resolve_Call) had no way of knowing about the required\n+                     --  dispatching.\n \n                      Propagate_Tag (Control, Actual);\n \n@@ -885,8 +884,8 @@ package body Sem_Disp is\n \n       if Present (Old_Subp) then\n \n-         --  If the type has interfaces we complete this check after we\n-         --  set attribute Is_Dispatching_Operation\n+         --  If the type has interfaces we complete this check after we set\n+         --  attribute Is_Dispatching_Operation.\n \n          Check_Subtype_Conformant (Subp, Old_Subp);\n "}, {"sha": "2d6e8e97e080bc09070898908122a78dc547277d", "filename": "gcc/ada/xsnamest.adb", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fxsnamest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550f4135fd793241e55fb66d8e267b7c2f7478b6/gcc%2Fada%2Fxsnamest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxsnamest.adb?ref=550f4135fd793241e55fb66d8e267b7c2f7478b6", "patch": "@@ -35,18 +35,24 @@ with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n with Ada.Strings.Maps;              use Ada.Strings.Maps;\n with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n with Ada.Text_IO;                   use Ada.Text_IO;\n+with Ada.Streams.Stream_IO;         use Ada.Streams.Stream_IO;\n \n with GNAT.Spitbol;                  use GNAT.Spitbol;\n with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n \n+with XUtil;                         use XUtil;\n+\n procedure XSnamesT is\n \n-   InB  : File_Type;\n-   InT  : File_Type;\n-   OutS : File_Type;\n-   OutB : File_Type;\n-   InH  : File_Type;\n-   OutH : File_Type;\n+   subtype VString is GNAT.Spitbol.VString;\n+\n+   InS  : Ada.Text_IO.File_Type;\n+   InB  : Ada.Text_IO.File_Type;\n+   InH  : Ada.Text_IO.File_Type;\n+\n+   OutS : Ada.Streams.Stream_IO.File_Type;\n+   OutB : Ada.Streams.Stream_IO.File_Type;\n+   OutH : Ada.Streams.Stream_IO.File_Type;\n \n    A, B  : VString := Nul;\n    Line  : VString := Nul;\n@@ -131,7 +137,7 @@ procedure XSnamesT is\n \n       if Header_Current_Symbol /= S then\n          declare\n-            Name2 : Vstring;\n+            Name2 : VString;\n             Pat : constant Pattern := \"#define  \"\n                                        & Header_Prefix (S).all\n                                        & Break (' ') * Name2;\n@@ -175,7 +181,7 @@ procedure XSnamesT is\n --  Start of processing for XSnames\n \n begin\n-   Open (InT, In_File, \"snames.ads-tmpl\");\n+   Open (InS, In_File, \"snames.ads-tmpl\");\n    Open (InB, In_File, \"snames.adb-tmpl\");\n    Open (InH, In_File, \"snames.h-tmpl\");\n \n@@ -194,8 +200,8 @@ begin\n \n    Put_Line (OutB, Line);\n \n-   LoopN : while not End_Of_File (InT) loop\n-      Line := Get_Line (InT);\n+   LoopN : while not End_Of_File (InS) loop\n+      Line := Get_Line (InS);\n \n       if not Match (Line, Name_Ref) then\n          Put_Line (OutS, Line);"}]}