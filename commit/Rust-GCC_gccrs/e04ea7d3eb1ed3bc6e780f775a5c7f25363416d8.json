{"sha": "e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0ZWE3ZDNlYjFlZDNiYzZlNzgwZjc3NWE1YzdmMjUzNjM0MTZkOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-06-24T14:59:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-06-24T14:59:23Z"}, "message": "Revert these two patches:\n\n\tThu Jun 17 21:34:24 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n\t* loop.c (strength_reduce): When doing biv->giv conversion, update\n\treg note of NEXT->insn.\n\tThu Jun 17 17:22:07 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n\t* loop.c (strength_reduce): When doing biv->giv conversion, fix up\n\treg_biv_class.\n\t(recombine_givs): Set ix field after sorting.\n\nFrom-SVN: r27727", "tree": {"sha": "e7eaca5047a884121650e5480c41b0837011dff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7eaca5047a884121650e5480c41b0837011dff7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8/comments", "author": null, "committer": null, "parents": [{"sha": "50cba6ed13e2c67b9abc35d3485b12942a90cdf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50cba6ed13e2c67b9abc35d3485b12942a90cdf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50cba6ed13e2c67b9abc35d3485b12942a90cdf0"}], "stats": {"total": 38, "additions": 18, "deletions": 20}, "files": [{"sha": "d55a44bcdcc9f0fc724d048aa23ef65d0772dd00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8", "patch": "@@ -1,3 +1,16 @@\n+Thu Jun 24 15:00:47 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRevert these two patches:\n+\n+\tThu Jun 17 21:34:24 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\t* loop.c (strength_reduce): When doing biv->giv conversion, update\n+\treg note of NEXT->insn.\n+\n+\tThu Jun 17 17:22:07 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\t* loop.c (strength_reduce): When doing biv->giv conversion, fix up\n+\treg_biv_class.\n+\t(recombine_givs): Set ix field after sorting.\n+\n Wed Jun 23 21:26:00 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* rtlanal.c (reg_referenced_p): Use reg_overlap_mentioned_p"}, {"sha": "b616be0d524ebc127bbddc12281c0b6c94c8bd56", "filename": "gcc/loop.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=e04ea7d3eb1ed3bc6e780f775a5c7f25363416d8", "patch": "@@ -4065,7 +4065,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\tfprintf (loop_dump_stream, \"is giv of biv %d\\n\", bl2->regno);\n \t      /* Let this giv be discovered by the generic code.  */\n \t      REG_IV_TYPE (bl->regno) = UNKNOWN_INDUCT;\n-\t      reg_biv_class[bl->regno] = NULL_PTR;\n \t      /* We can get better optimization if we can move the giv setting\n \t\t before the first giv use.  */\n \t      if (dominator\n@@ -4117,13 +4116,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t}\n \t      /* Remove this biv from the chain.  */\n \t      if (bl->next)\n-\t\t{\n-\t\t  /* We move the following giv from *bl->next into *bl.\n-\t\t     We have to update reg_biv_class for that moved biv\n-\t\t     to point to its new address.  */\n-\t\t  *bl = *bl->next;\n-\t\t  reg_biv_class[bl->regno] = bl;\n-\t\t}\n+\t\t*bl = *bl->next;\n \t      else\n \t\t{\n \t\t  *backbl = 0;\n@@ -4198,7 +4191,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  for (vp = &bl->biv, next = *vp; v = next, next = v->next_iv;)\n \t    {\n \t      HOST_WIDE_INT offset;\n-\t      rtx set, add_val, old_reg, dest_reg, last_use_insn, note;\n+\t      rtx set, add_val, old_reg, dest_reg, last_use_insn;\n \t      int old_regno, new_regno;\n \n \t      if (! v->always_executed\n@@ -4304,13 +4297,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n     \n \t      REG_IV_TYPE (new_regno) = GENERAL_INDUCT;\n \t      REG_IV_INFO (new_regno) = v;\n-\n-\t      /* If next_insn has a REG_EQUAL note that mentiones OLD_REG,\n-\t\t it must be replaced.  */\n-\t      note = find_reg_note (next->insn, REG_EQUAL, NULL_RTX);\n-\t      if (note && reg_mentioned_p (old_reg, XEXP (note, 0)))\n-\t\tXEXP (note, 0) = copy_rtx (SET_SRC (single_set (next->insn)));\n-\n+    \n \t      /* Remove the increment from the list of biv increments,\n \t\t and record it as a giv.  */\n \t      *vp = next;\n@@ -7210,18 +7197,16 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n       for (p = v->insn; INSN_UID (p) >= max_uid_for_loop; )\n \tp = PREV_INSN (p);\n       stats[i].start_luid = INSN_LUID (p);\n+      v->ix = i;\n       i++;\n     }\n \n   qsort (stats, giv_count, sizeof(*stats), cmp_recombine_givs_stats);\n \n-  /* Set up the ix field for each giv in stats to name\n-     the corresponding index into stats, and\n-     do the actual most-recently-used recombination.  */\n+  /* Do the actual most-recently-used recombination.  */\n   for (last_giv = 0, i = giv_count - 1; i >= 0; i--)\n     {\n       v = giv_array[stats[i].giv_number];\n-      v->ix = i;\n       if (v->same)\n \t{\n \t  struct induction *old_same = v->same;"}]}