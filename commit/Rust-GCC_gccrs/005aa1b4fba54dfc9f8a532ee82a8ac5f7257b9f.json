{"sha": "005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1YWExYjRmYmE1NGRmYzlmOGE1MzJlZTgyYThhYzVmNzI1N2I5Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-27T12:50:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-27T12:50:29Z"}, "message": "re PR middle-end/52720 (internal compiler error: in try_move_mult_to_index)\n\n2012-03-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/52720\n\t* fold-const.c (try_move_mult_to_index): Handle &x.array more\n\texplicitely.\n\n\t* gcc.dg/torture/pr52720.c: New testcase.\n\nFrom-SVN: r185865", "tree": {"sha": "8dd9d34e7c52146f545feb63ff4f16d11ba4d954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dd9d34e7c52146f545feb63ff4f16d11ba4d954"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a59b038cc8edf2e34d5c9544a8805bf9b3450709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a59b038cc8edf2e34d5c9544a8805bf9b3450709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a59b038cc8edf2e34d5c9544a8805bf9b3450709"}], "stats": {"total": 191, "additions": 115, "deletions": 76}, "files": [{"sha": "e9acac3165b5a9ddc8a0279e71132ec2df7fabb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "patch": "@@ -1,3 +1,9 @@\n+2012-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/52720\n+\t* fold-const.c (try_move_mult_to_index): Handle &x.array more\n+\texplicitely.\n+\n 2012-03-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* expmed.c (store_bit_field): Assert that BITREGION_START is a multiple"}, {"sha": "df0c05c6e029ea5f4b67bf902bd9b9856b1a7d5b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "patch": "@@ -6826,77 +6826,94 @@ try_move_mult_to_index (location_t loc, tree addr, tree op1)\n       s = integer_one_node;\n     }\n \n-  for (;; ref = TREE_OPERAND (ref, 0))\n+  /* Handle &x.array the same as we would handle &x.array[0].  */\n+  if (TREE_CODE (ref) == COMPONENT_REF\n+      && TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n     {\n-      if (TREE_CODE (ref) == ARRAY_REF)\n+      tree domain;\n+\n+      /* Remember if this was a multi-dimensional array.  */\n+      if (TREE_CODE (TREE_OPERAND (ref, 0)) == ARRAY_REF)\n+\tmdim = true;\n+\n+      domain = TYPE_DOMAIN (TREE_TYPE (ref));\n+      if (! domain)\n+\tgoto cont;\n+      itype = TREE_TYPE (domain);\n+\n+      step = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ref)));\n+      if (TREE_CODE (step) != INTEGER_CST)\n+\tgoto cont;\n+\n+      if (s)\n \t{\n-\t  tree domain;\n+\t  if (! tree_int_cst_equal (step, s))\n+\t    goto cont;\n+\t}\n+      else\n+\t{\n+\t  /* Try if delta is a multiple of step.  */\n+\t  tree tmp = div_if_zero_remainder (EXACT_DIV_EXPR, op1, step);\n+\t  if (! tmp)\n+\t    goto cont;\n+\t  delta = tmp;\n+\t}\n \n-\t  /* Remember if this was a multi-dimensional array.  */\n-\t  if (TREE_CODE (TREE_OPERAND (ref, 0)) == ARRAY_REF)\n-\t    mdim = true;\n+      /* Only fold here if we can verify we do not overflow one\n+\t dimension of a multi-dimensional array.  */\n+      if (mdim)\n+\t{\n+\t  tree tmp;\n \n-\t  domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n-\t  if (! domain)\n-\t    continue;\n-\t  itype = TREE_TYPE (domain);\n+\t  if (!TYPE_MIN_VALUE (domain)\n+\t      || !TYPE_MAX_VALUE (domain)\n+\t      || TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST)\n+\t    goto cont;\n \n-\t  step = array_ref_element_size (ref);\n-\t  if (TREE_CODE (step) != INTEGER_CST)\n-\t    continue;\n+\t  tmp = fold_binary_loc (loc, PLUS_EXPR, itype,\n+\t\t\t\t fold_convert_loc (loc, itype,\n+\t\t\t\t\t\t   TYPE_MIN_VALUE (domain)),\n+\t\t\t\t fold_convert_loc (loc, itype, delta));\n+\t  if (TREE_CODE (tmp) != INTEGER_CST\n+\t      || tree_int_cst_lt (TYPE_MAX_VALUE (domain), tmp))\n+\t    goto cont;\n+\t}\n \n-\t  if (s)\n-\t    {\n-\t      if (! tree_int_cst_equal (step, s))\n-                continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Try if delta is a multiple of step.  */\n-\t      tree tmp = div_if_zero_remainder (EXACT_DIV_EXPR, op1, step);\n-\t      if (! tmp)\n-\t\tcontinue;\n-\t      delta = tmp;\n-\t    }\n+      /* We found a suitable component reference.  */\n \n-\t  /* Only fold here if we can verify we do not overflow one\n-\t     dimension of a multi-dimensional array.  */\n-\t  if (mdim)\n-\t    {\n-\t      tree tmp;\n+      pref = TREE_OPERAND (addr, 0);\n+      ret = copy_node (pref);\n+      SET_EXPR_LOCATION (ret, loc);\n \n-\t      if (TREE_CODE (TREE_OPERAND (ref, 1)) != INTEGER_CST\n-\t\t  || !TYPE_MAX_VALUE (domain)\n-\t\t  || TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST)\n-\t\tcontinue;\n+      ret = build4_loc (loc, ARRAY_REF, TREE_TYPE (TREE_TYPE (ref)), ret,\n+\t\t\tfold_build2_loc\n+\t\t\t  (loc, PLUS_EXPR, itype,\n+\t\t\t   fold_convert_loc (loc, itype,\n+\t\t\t\t\t     TYPE_MIN_VALUE\n+\t\t\t\t\t       (TYPE_DOMAIN (TREE_TYPE (ref)))),\n+\t\t\t   fold_convert_loc (loc, itype, delta)),\n+\t\t\tNULL_TREE, NULL_TREE);\n+      return build_fold_addr_expr_loc (loc, ret);\n+    }\n \n-\t      tmp = fold_binary_loc (loc, PLUS_EXPR, itype,\n-\t\t\t\t     fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t       TREE_OPERAND (ref, 1)),\n-\t\t\t\t     fold_convert_loc (loc, itype, delta));\n-\t      if (!tmp\n-\t\t  || TREE_CODE (tmp) != INTEGER_CST\n-\t\t  || tree_int_cst_lt (TYPE_MAX_VALUE (domain), tmp))\n-\t\tcontinue;\n-\t    }\n+cont:\n \n-\t  break;\n-\t}\n-      else if (TREE_CODE (ref) == COMPONENT_REF\n-\t       && TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n+  for (;; ref = TREE_OPERAND (ref, 0))\n+    {\n+      if (TREE_CODE (ref) == ARRAY_REF)\n \t{\n \t  tree domain;\n \n \t  /* Remember if this was a multi-dimensional array.  */\n \t  if (TREE_CODE (TREE_OPERAND (ref, 0)) == ARRAY_REF)\n \t    mdim = true;\n \n-\t  domain = TYPE_DOMAIN (TREE_TYPE (ref));\n+\t  domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n \t  if (! domain)\n \t    continue;\n \t  itype = TREE_TYPE (domain);\n \n-\t  step = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ref)));\n+\t  step = array_ref_element_size (ref);\n \t  if (TREE_CODE (step) != INTEGER_CST)\n \t    continue;\n \n@@ -6920,16 +6937,17 @@ try_move_mult_to_index (location_t loc, tree addr, tree op1)\n \t    {\n \t      tree tmp;\n \n-\t      if (!TYPE_MIN_VALUE (domain)\n+\t      if (TREE_CODE (TREE_OPERAND (ref, 1)) != INTEGER_CST\n \t\t  || !TYPE_MAX_VALUE (domain)\n \t\t  || TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST)\n \t\tcontinue;\n \n \t      tmp = fold_binary_loc (loc, PLUS_EXPR, itype,\n \t\t\t\t     fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t       TYPE_MIN_VALUE (domain)),\n+\t\t\t\t\t\t       TREE_OPERAND (ref, 1)),\n \t\t\t\t     fold_convert_loc (loc, itype, delta));\n-\t      if (TREE_CODE (tmp) != INTEGER_CST\n+\t      if (!tmp\n+\t\t  || TREE_CODE (tmp) != INTEGER_CST\n \t\t  || tree_int_cst_lt (TYPE_MAX_VALUE (domain), tmp))\n \t\tcontinue;\n \t    }\n@@ -6958,29 +6976,11 @@ try_move_mult_to_index (location_t loc, tree addr, tree op1)\n       pos = TREE_OPERAND (pos, 0);\n     }\n \n-  if (TREE_CODE (ref) == ARRAY_REF)\n-    {\n-      TREE_OPERAND (pos, 1)\n-\t= fold_build2_loc (loc, PLUS_EXPR, itype,\n-\t\t\t   fold_convert_loc (loc, itype, TREE_OPERAND (pos, 1)),\n-\t\t\t   fold_convert_loc (loc, itype, delta));\n-      return fold_build1_loc (loc, ADDR_EXPR, TREE_TYPE (addr), ret);\n-    }\n-  else if (TREE_CODE (ref) == COMPONENT_REF)\n-    {\n-      gcc_assert (ret == pos);\n-      ret = build4_loc (loc, ARRAY_REF, TREE_TYPE (TREE_TYPE (ref)), ret,\n-\t\t\tfold_build2_loc\n-\t\t\t  (loc, PLUS_EXPR, itype,\n-\t\t\t   fold_convert_loc (loc, itype,\n-\t\t\t\t\t     TYPE_MIN_VALUE\n-\t\t\t\t\t       (TYPE_DOMAIN (TREE_TYPE (ref)))),\n-\t\t\t   fold_convert_loc (loc, itype, delta)),\n-\t\t\tNULL_TREE, NULL_TREE);\n-      return build_fold_addr_expr_loc (loc, ret);\n-    }\n-  else\n-    gcc_unreachable ();\n+  TREE_OPERAND (pos, 1)\n+    = fold_build2_loc (loc, PLUS_EXPR, itype,\n+\t\t       fold_convert_loc (loc, itype, TREE_OPERAND (pos, 1)),\n+\t\t       fold_convert_loc (loc, itype, delta));\n+  return fold_build1_loc (loc, ADDR_EXPR, TREE_TYPE (addr), ret);\n }\n \n "}, {"sha": "408184a26b875ac6308b984cfd2fa65d77c6f8fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "patch": "@@ -1,3 +1,8 @@\n+2012-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/52720\n+\t* gcc.dg/torture/pr52720.c: New testcase.\n+\n 2012-03-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/pack17.adb: New test."}, {"sha": "528aa161b13b43abf15ee98405295618127a9165", "filename": "gcc/testsuite/gcc.dg/torture/pr52720.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr52720.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr52720.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr52720.c?ref=005aa1b4fba54dfc9f8a532ee82a8ac5f7257b9f", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=k8-sse3\" { target x86_64-*-* } } */\n+\n+struct alu_bank_swizzle {\n+    int hw_gpr[3][4];\n+    int hw_cfile_addr[4];\n+};\n+static void init_bank_swizzle(struct alu_bank_swizzle *bs)\n+{\n+  int i, cycle, component;\n+  for (cycle = 0; cycle < 3; cycle++)\n+    for (component = 0; component < 4; component++)\n+      bs->hw_gpr[cycle][component] = -1;\n+  for (i = 0; i < 4; i++) \n+    bs->hw_cfile_addr[i] = -1;\n+}\n+int check_and_set_bank_swizzle(int max_slots, int *slots)\n+{\n+  struct alu_bank_swizzle bs;\n+  int i;\n+  for (i = 0; i < max_slots; i++)\n+    {\n+      init_bank_swizzle(&bs);\n+      if (slots[i])\n+\tcheck_vector(&bs); \n+    }\n+}\n+"}]}