{"sha": "8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyMjk0MmNiNmMyMDc2YjA1ZDhhMjQ4ZjFmMGM1YjZmZmU2NzMyMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-14T09:46:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-14T09:46:55Z"}, "message": "typeck.c (c_sizeof): Be strict about casting result value back to c_size_type_node.\n\n        * typeck.c (c_sizeof): Be strict about casting result value\n        back to c_size_type_node.\n        (expr_sizeof, c_sizeof_nowarn, c_alignof): Likewise.\n\nFrom-SVN: r37446", "tree": {"sha": "8782850bab3d2bc39cdcf42a1e18c0557a325e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8782850bab3d2bc39cdcf42a1e18c0557a325e19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8422942cb6c2076b05d8a248f1f0c5b6ffe67321/comments", "author": null, "committer": null, "parents": [{"sha": "187e3bf0b71cabf11bcdbab87a2be0108e3c4ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187e3bf0b71cabf11bcdbab87a2be0108e3c4ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187e3bf0b71cabf11bcdbab87a2be0108e3c4ad5"}], "stats": {"total": 115, "additions": 68, "deletions": 47}, "files": [{"sha": "dd6f5a7f09573aa39dd2ec97637794c5d98ad15b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8422942cb6c2076b05d8a248f1f0c5b6ffe67321/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8422942cb6c2076b05d8a248f1f0c5b6ffe67321/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "patch": "@@ -1,3 +1,9 @@\n+2000-11-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* typeck.c (c_sizeof): Be strict about casting result value\n+\tback to c_size_type_node.\n+\t(expr_sizeof, c_sizeof_nowarn, c_alignof): Likewise.\n+\n 2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* typeck.c (build_unary_op): Use boolean_increment from"}, {"sha": "08d6deea1aef71ab32b0f8efda7008581683bc5e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8422942cb6c2076b05d8a248f1f0c5b6ffe67321/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8422942cb6c2076b05d8a248f1f0c5b6ffe67321/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "patch": "@@ -1557,44 +1557,46 @@ c_sizeof (type)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ISO C++ forbids applying `sizeof' to a function type\");\n-      return size_one_node;\n+      size = size_one_node;\n     }\n-  if (code == METHOD_TYPE)\n+  else if (code == METHOD_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ISO C++ forbids applying `sizeof' to a member function\");\n-      return size_one_node;\n+      size = size_one_node;\n     }\n-  if (code == VOID_TYPE)\n+  else if (code == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ISO C++ forbids applying `sizeof' to type `void' which is an incomplete type\");\n-      return size_one_node;\n+      size = size_one_node;\n     }\n-  if (code == ERROR_MARK)\n-    return size_one_node;\n-\n-  /* ARM $5.3.2: ``When applied to a reference, the result is the size of the\n-     referenced object.'' */\n-  if (code == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  if (code == OFFSET_TYPE)\n+  else if (code == ERROR_MARK)\n+    size = size_one_node;\n+  else\n     {\n-      cp_error (\"`sizeof' applied to non-static member\");\n-      return size_zero_node;\n-    }\n+      /* ARM $5.3.2: ``When applied to a reference, the result is the\n+\t size of the referenced object.'' */\n+      if (code == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n \n-  if (!COMPLETE_TYPE_P (complete_type (type)))\n-    {\n-      cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n-      return size_zero_node;\n+      if (code == OFFSET_TYPE)\n+\t{\n+\t  cp_error (\"`sizeof' applied to non-static member\");\n+\t  size = size_zero_node;\n+\t}\n+      else if (!COMPLETE_TYPE_P (complete_type (type)))\n+\t{\n+\t  cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n+\t  size = size_zero_node;\n+\t}\n+      else\n+\t/* Convert in case a char is more than one unit.  */\n+\tsize = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t\t   size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t     / BITS_PER_UNIT));\n     }\n \n-  /* Convert in case a char is more than one unit.  */\n-  size = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n-\t\t     size_int (TYPE_PRECISION (char_type_node)\n-\t\t\t       / BITS_PER_UNIT));\n   /* SIZE will have an integer type with TYPE_IS_SIZETYPE set.\n      TYPE_IS_SIZETYPE means that certain things (like overflow) will\n      never happen.  However, this node should really have type\n@@ -1619,12 +1621,12 @@ expr_sizeof (e)\n   if (is_overloaded_fn (e))\n     {\n       pedwarn (\"ISO C++ forbids applying `sizeof' to an expression of function type\");\n-      return size_one_node;\n+      e = char_type_node;\n     }\n   else if (type_unknown_p (e))\n     {\n       incomplete_type_error (e, TREE_TYPE (e));\n-      return size_one_node;\n+      e = char_type_node;\n     }\n   /* It's illegal to say `sizeof (X::i)' for `i' a non-static data\n      member unless you're in a non-static member of X.  So hand off to\n@@ -1643,23 +1645,35 @@ c_sizeof_nowarn (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n+  tree size;\n \n   if (code == FUNCTION_TYPE\n       || code == METHOD_TYPE\n       || code == VOID_TYPE\n       || code == ERROR_MARK)\n-    return size_one_node;\n-\n-  if (code == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+    size = size_one_node;\n+  else\n+    {\n+      if (code == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n \n-  if (!COMPLETE_TYPE_P (type))\n-    return size_zero_node;\n+      if (!COMPLETE_TYPE_P (type))\n+\tsize = size_zero_node;\n+      else\n+\t/* Convert in case a char is more than one unit.  */\n+\tsize = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t\t   size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t\t     / BITS_PER_UNIT));\n+    }\n \n-  /* Convert in case a char is more than one unit.  */\n-  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n-\t\t     size_int (TYPE_PRECISION (char_type_node)\n-\t\t\t       / BITS_PER_UNIT));\n+  /* SIZE will have an integer type with TYPE_IS_SIZETYPE set.\n+     TYPE_IS_SIZETYPE means that certain things (like overflow) will\n+     never happen.  However, this node should really have type\n+     `size_t', which is just a typedef for an ordinary integer type.  */\n+  size = fold (build1 (NOP_EXPR, c_size_type_node, size));\n+  my_friendly_assert (!TYPE_IS_SIZETYPE (TREE_TYPE (size)), \n+\t\t      20001021);\n+  return size;\n }\n \n /* Implement the __alignof keyword: Return the minimum required\n@@ -1676,18 +1690,19 @@ c_alignof (type)\n     return build_min (ALIGNOF_EXPR, sizetype, type);\n \n   if (code == FUNCTION_TYPE || code == METHOD_TYPE)\n-    return size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n-\n-  if (code == VOID_TYPE || code == ERROR_MARK)\n-    return size_one_node;\n+    t = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n+  else if (code == VOID_TYPE || code == ERROR_MARK)\n+    t = size_one_node;\n+  else\n+    { \n+      /* Similar to sizeof, __alignof applies to the referant.  */\n+      if (code == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n \n-  /* C++: this is really correct!  */\n-  if (code == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+      t = size_int (TYPE_ALIGN (type) / BITS_PER_UNIT);\n+    }\n \n-  t = size_int (TYPE_ALIGN (type) / BITS_PER_UNIT);\n-  force_fit_type (t, 0);\n-  return t;\n+  return fold (build1 (NOP_EXPR, c_size_type_node, t));\n }\n \f\n /* Perform the array-to-pointer and function-to-pointer conversions"}]}