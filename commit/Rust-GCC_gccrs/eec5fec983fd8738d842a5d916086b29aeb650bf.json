{"sha": "eec5fec983fd8738d842a5d916086b29aeb650bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVjNWZlYzk4M2ZkODczOGQ4NDJhNWQ5MTYwODZiMjlhZWI2NTBiZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-12-25T22:53:54Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-12-25T22:53:54Z"}, "message": "re PR rtl-optimization/19078 (Poor quality code after loop unrolling.)\n\n\tPR rtl-optimization/19078\n\t* tree-ssa-loop-ivopts.c (determine_use_iv_cost_generic,\n\tdetermine_use_iv_cost_outer): Fix computing of cost for the original\n\tbivs.\n\t(dump_use): Handle case related_cands == NULL.\n\nFrom-SVN: r92608", "tree": {"sha": "dd158a2937b61524aac9d3dd24821202ba8b51d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd158a2937b61524aac9d3dd24821202ba8b51d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eec5fec983fd8738d842a5d916086b29aeb650bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec5fec983fd8738d842a5d916086b29aeb650bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eec5fec983fd8738d842a5d916086b29aeb650bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec5fec983fd8738d842a5d916086b29aeb650bf/comments", "author": null, "committer": null, "parents": [{"sha": "6b262ee81e0c4a4d4e2c1afc0b9f6fdb980f7365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b262ee81e0c4a4d4e2c1afc0b9f6fdb980f7365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b262ee81e0c4a4d4e2c1afc0b9f6fdb980f7365"}], "stats": {"total": 42, "additions": 38, "deletions": 4}, "files": [{"sha": "db26b3a7db19772fb88f342faa66b33825fc872f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec5fec983fd8738d842a5d916086b29aeb650bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec5fec983fd8738d842a5d916086b29aeb650bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eec5fec983fd8738d842a5d916086b29aeb650bf", "patch": "@@ -1,3 +1,11 @@\n+2004-12-25  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/19078\n+\t* tree-ssa-loop-ivopts.c (determine_use_iv_cost_generic,\n+\tdetermine_use_iv_cost_outer): Fix computing of cost for the original\n+\tbivs.\n+\t(dump_use): Handle case related_cands == NULL.\n+\n 2004-12-25  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n \n \tPR target/19059"}, {"sha": "73034127a7c9d60d86c54418f43c987ccbf0b3d7", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec5fec983fd8738d842a5d916086b29aeb650bf/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec5fec983fd8738d842a5d916086b29aeb650bf/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=eec5fec983fd8738d842a5d916086b29aeb650bf", "patch": "@@ -444,8 +444,11 @@ dump_use (FILE *file, struct iv_use *use)\n \n   dump_iv (file, use->iv);\n \n-  fprintf (file, \"  related candidates \");\n-  dump_bitmap (file, use->related_cands);\n+  if (use->related_cands)\n+    {\n+      fprintf (file, \"  related candidates \");\n+      dump_bitmap (file, use->related_cands);\n+    }\n }\n \n /* Dumps information about the uses to FILE.  */\n@@ -3116,8 +3119,20 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n-  unsigned cost = get_computation_cost (data, use, cand, false, &depends_on);\n+  unsigned cost;\n+\n+  /* The simple case first -- if we need to express value of the preserved\n+     original biv, the cost is 0.  This also prevents us from counting the\n+     cost of increment twice -- once at this use and once in the cost of\n+     the candidate.  */\n+  if (cand->pos == IP_ORIGINAL\n+      && cand->incremented_at == use->stmt)\n+    {\n+      set_use_iv_cost (data, use, cand, 0, NULL);\n+      return true;\n+    }\n \n+  cost = get_computation_cost (data, use, cand, false, &depends_on);\n   set_use_iv_cost (data, use, cand, cost, depends_on);\n \n   return cost != INFTY;\n@@ -3311,7 +3326,18 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n   edge exit;\n   tree value;\n   struct loop *loop = data->current_loop;\n-\t  \n+\n+  /* The simple case first -- if we need to express value of the preserved\n+     original biv, the cost is 0.  This also prevents us from counting the\n+     cost of increment twice -- once at this use and once in the cost of\n+     the candidate.  */\n+  if (cand->pos == IP_ORIGINAL\n+      && cand->incremented_at == use->stmt)\n+    {\n+      set_use_iv_cost (data, use, cand, 0, NULL);\n+      return true;\n+    }\n+\n   if (!cand->iv)\n     {\n       if (!may_replace_final_value (loop, use, &value))"}]}