{"sha": "5422265ae1d9529e4e58b2a1aa035a7c01395466", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQyMjI2NWFlMWQ5NTI5ZTRlNThiMmExYWEwMzVhN2MwMTM5NTQ2Ng==", "commit": {"author": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-09-11T16:43:53Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-09-11T16:43:53Z"}, "message": "gcov.exp: Move almost everything to a new, language-independent file in lib.\n\n\t* gcc.misc-tests/gcov.exp: Move almost everything to a new,\n\tlanguage-independent file in lib.\n\n\t* lib/gcov.exp: New file.\n\nFrom-SVN: r45546", "tree": {"sha": "57ab57699e1312260a4d39800e9a437f1aa568c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57ab57699e1312260a4d39800e9a437f1aa568c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5422265ae1d9529e4e58b2a1aa035a7c01395466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5422265ae1d9529e4e58b2a1aa035a7c01395466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5422265ae1d9529e4e58b2a1aa035a7c01395466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5422265ae1d9529e4e58b2a1aa035a7c01395466/comments", "author": null, "committer": null, "parents": [{"sha": "3f93d7291be9704669ed48e4a277ff40a74abd19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f93d7291be9704669ed48e4a277ff40a74abd19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f93d7291be9704669ed48e4a277ff40a74abd19"}], "stats": {"total": 318, "additions": 1, "deletions": 317}, "files": [{"sha": "d54c5b96873729beba5a4e491f0dfba5ede64a5a", "filename": "gcc/testsuite/gcc.misc-tests/gcov.exp", "status": "modified", "additions": 1, "deletions": 317, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5422265ae1d9529e4e58b2a1aa035a7c01395466/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5422265ae1d9529e4e58b2a1aa035a7c01395466/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp?ref=5422265ae1d9529e4e58b2a1aa035a7c01395466", "patch": "@@ -18,6 +18,7 @@\n \n # Load support procs.\n load_lib gcc-dg.exp\n+load_lib gcov.exp\n \n global GCC_UNDER_TEST\n \n@@ -28,323 +29,6 @@ if { ![is_remote host] && [string match \"*/*\" [lindex $GCC_UNDER_TEST 0]] } {\n     set GCOV gcov\n }\n \n-# Proc to delete the working files created by the compiler for gcov.\n-\n-proc clean-gcov { testcase } {\n-    set basename [file tail $testcase]\n-    set base [file rootname $basename]\n-    remote_file host delete $base.bb $base.bbg $base.da $basename.gcov\n-}\n-\n-#\n-# verify-lines -- check that line counts are as expected\n-#\n-# TESTCASE is the name of the test.\n-# FILE is the name of the gcov output file.\n-#\n-proc verify-lines { testcase file } {\n-    global subdir\n-    set failed 0\n-    set lmessage \"\"\n-    set output [grep $file \".*count\\\\(\\[0-9\\]+\\\\)\" line]\n-    #send_user \"output:$output\\n\"\n-    foreach line $output {\n-\tverbose \"Processing count line: $line\" 3\n-\t#send_user \"line:$line\\n\"\n-\tif [regexp \"(\\[0-9\\]+) *(\\[0-9\\]+).*count\\\\((\\[0-9\\]+)\\\\)\" \"$line\" all n is shouldbe] {\n-\t    #send_user \"n $n:is $is:shouldbe $shouldbe\\n\"\n-\t    if { $is == \"\" } {\n-\t\tif { $failed == 0 } {\n-\t\t    set lmessage \"$n:no data available for this line\"\n-\t\t}\n-\t\tincr failed\n-\t    } elseif { $is != $shouldbe } {\n-\t\tif { $failed == 0 } {\n-\t\t    set lmessage \"$n:is $is:should be $shouldbe\"\n-\t\t}\n-\t\tincr failed\n-\t    }\n-\t} else {\n-\t    if { $failed == 0 } {\n-\t        set lmessage \"can't parse $line (in wrong place?)\"\n-\t    }\n-\t    incr failed\n-\t}\n-    }\n-    return [list $failed $lmessage]\n-}\n-\n-#\n-# verify-branches -- check that branch percentages are as expected\n-#\n-# TESTCASE is the name of the test.\n-# FILE is the name of the gcov output file.\n-#\n-# Checks are based on comments in the source file.  This means to look for\n-# branch percentages 10 or 90, 20 or 80, and # 70 or 30:\n-#     /* branch(10, 20, 70) */\n-# This means that all specified percentages should have been seen by now:\n-#     /* branch(end) */\n-# All specified percentages must also be seen by the next branch(n) or\n-# by the end of the file.\n-#\n-# Each check depends on the compiler having generated the expected\n-# branch instructions.  Don't check for branches that might be\n-# optimized away or replaced with predicated instructions.\n-#\n-proc verify-branches { testcase file } {\n-    global bmessage\n-    global subdir\n-    set failed 0\n-    set bmessage \"\"\n-    set shouldbe \"\"\n-    set fd [open $file r]\n-    while { [gets $fd line] >= 0 } {\n-\tif [regexp \"branch\" $line] {\n-\t    verbose \"Processing branch line: $line\" 3\n-\t    if [regexp \"branch\\\\((\\[0-9 \\]+)\\\\)\" \"$line\" all new_shouldbe] {\n-\t\t# All percentages in the current list should have been seen.\n-\t\tif {[llength $shouldbe] != 0} {\n-\t\t    if { $failed == 0 } {\n-\t\t        set bmessage \"expected branch percentages not found: $shouldbe\"\n-\t\t    }\n-\t\t    incr failed\n-\t\t    set shouldbe \"\"\n-\t\t}\n-\t\tset shouldbe $new_shouldbe\n-\t        # Record the percentages to check for. Replace percentage\n-\t\t# n > 50 with 100-n, since block ordering affects the\n-\t\t# direction of a branch.\n-\t\tfor {set i 0} {$i < [llength $shouldbe]} {incr i} {\n-\t\t    set num [lindex $shouldbe $i]\n-\t\t    if {$num > 50} {\n-\t\t\tset shouldbe [lreplace $shouldbe $i $i [expr 100 - $num]]\n-\t\t    }\n-\t\t}\n-\t    } elseif [regexp \"branch \\[0-9\\]+ taken = (-\\[0-9\\]+)%\" \"$line\" all taken] {\n-\t\t# Percentages should never be negative.\n-\t\tif { $failed == 0 } {\n-\t\t    set bmessage \"negative percentage: $taken\"\n-\t\t}\n-\t\tincr failed\n-\t    } elseif [regexp \"branch \\[0-9\\]+ taken = (\\[0-9\\]+)%\" \"$line\" all taken] {\n-\t\t# Percentages should never be greater than 100.\n-\t\tif {$taken > 100} {\n-\t\t    if { $failed == 0 } {\n-\t\t\tset bmessage \"percentage greater than 100: $taken\"\n-\t\t    }\n-\t\t    incr failed\n-\t\t}\n-\t\tif {$taken > 50} {\n-\t\t    set taken [expr 100 - $taken]\n-\t\t}\n-\t\t# If this percentage is one to check for then remove it\n-\t\t# from the list.  It's normal to ignore some reports.\n-\t\tset i [lsearch $shouldbe $taken]\n-\t\tif {$i != -1} {\n-\t\t    set shouldbe [lreplace $shouldbe $i $i]\n-\t\t}\n-\t    } elseif [regexp \"branch\\\\(end\\\\)\" \"$line\"] {\n-\t\t# All percentages in the list should have been seen by now.\n-\t\tif {[llength $shouldbe] != 0} {\n-\t\t    if { $failed == 0 } {\n-\t\t\tset bmessage \"expected branch percentages not found: $shouldbe\"\n-\t\t    }\n-\t\t    incr failed\n-\t\t}\n-\t\tset shouldbe \"\"\n-\t    }\n-\t}\n-    }\n-    # All percentages in the list should have been seen.\n-    if {[llength $shouldbe] != 0} {\n-\tif { $failed == 0 } {\n-\t    set bmessage \"expected branch percentages not found: $shouldbe\"\n-\t}\n-\tincr failed\n-    }\n-    close $fd\n-    return [list $failed $bmessage]\n-}\n-\n-#\n-# verify-calls -- check that call return percentages are as expected\n-#\n-# TESTCASE is the name of the test.\n-# FILE is the name of the gcov output file.\n-#\n-# Checks are based on comments in the source file.  This means to look for\n-# call return percentages 50, 20, 33:\n-#     /* returns(50, 20, 33) */\n-# This means that all specified percentages should have been seen by now:\n-#     /* returns(end) */\n-# All specified percentages must also be seen by the next returns(n) or\n-# by the end of the file.\n-#\n-# Each check depends on the compiler having generated the expected\n-# call instructions.  Don't check for calls that are inserted by the\n-# compiler or that might be inlined.\n-#\n-proc verify-calls { testcase file } {\n-    global cmessage\n-    global subdir\n-    set failed 0\n-    set cmessage \"\"\n-    set shouldbe \"\"\n-    set fd [open $file r]\n-    while { [gets $fd line] >= 0 } {\n-\tif [regexp \"returns\" $line] {\n-\t    verbose \"Processing returns line: $line\" 3\n-\t    if [regexp \"returns\\\\((\\[0-9 \\]+)\\\\)\" \"$line\" all new_shouldbe] {\n-\t\t# All percentages in the current list should have been seen.\n-\t\tif {[llength $shouldbe] != 0} {\n-\t\t    if { $failed == 0 } {\n-\t\t        set cmessage \"expected return percentages not found: $shouldbe\"\n-\t\t    }\n-\t\t    incr failed\n-\t\t    set shouldbe \"\"\n-\t\t}\n-\t        # Record the percentages to check for.\n-\t\tset shouldbe $new_shouldbe\n-\t    } elseif [regexp \"call \\[0-9\\]+ returns = (-\\[0-9\\]+)%\" \"$line\" all returns] {\n-\t\t# Percentages should never be negative.\n-\t\tif { $failed == 0 } {\n-\t\t    set cmessage \"negative percentage: $returns\"\n-\t\t}\n-\t\tincr failed\n-\t    } elseif [regexp \"call \\[0-9\\]+ returns = (\\[0-9\\]+)%\" \"$line\" all returns] {\n-\t\t# For branches we check that percentages are not greater than\n-\t\t# 100 but call return percentages can be, as for setjmp(), so\n-\t\t# don't count that as an error.\n-\t\t#\n-\t\t# If this percentage is one to check for then remove it\n-\t\t# from the list.  It's normal to ignore some reports.\n-\t\tset i [lsearch $shouldbe $returns]\n-\t\tif {$i != -1} {\n-\t\t    set shouldbe [lreplace $shouldbe $i $i]\n-\t\t}\n-\t    } elseif [regexp \"returns\\\\(end\\\\)\" \"$line\"] {\n-\t\t# All percentages in the list should have been seen by now.\n-\t\tif {[llength $shouldbe] != 0} {\n-\t\t    if { $failed == 0 } {\n-\t\t\tset cmessage \"expected return percentages not found: $shouldbe\"\n-\t\t    }\n-\t\t    incr failed\n-\t\t}\n-\t\tset shouldbe \"\"\n-\t    }\n-\t}\n-    }\n-    # All percentages in the list should have been seen.\n-    if {[llength $shouldbe] != 0} {\n-\tif { $failed == 0 } {\n-\t    set cmessage \"expected return percentages not found: $shouldbe\"\n-\t}\n-\tincr failed\n-    }\n-    close $fd\n-    return [list $failed $cmessage]\n-}\n-\n-# Called by dg-final to run gcov and analyze the results.\n-#\n-# ARGS is the options to pass to gcov followed by the name of the\n-# test source file.\n-\n-proc run-gcov { args } {\n-    global GCOV\n-    global srcdir subdir\n-\n-    # Extract the test name from the arguments.\n-    set testcase [lindex $args end]\n-\n-    # Get special options for this test from the .x script, if present.\n-    # This can include:\n-    #   gcov_execute_xfail     string to pass to setup_xfail\n-    #   gcov_verify_xfail      string to pass to setup_xfail\n-    #   gcov_verify_branches   if defined, check branch percentages\n-    #   gcov_verify_calls      if defined, check call return percentages\n-    if [file exists [file rootname $srcdir/$subdir/$testcase].x] {\n-\tset done_p 0\n-\tcatch \"set done_p \\[source [file rootname $srcdir/$subdir/$testcase].x\\]\"\n-\tif { $done_p } {\n-\t    return\n-\t}\n-    }\n-\n-    if [info exists gcov_execute_xfail] {\n-\tsetup_xfail $gcov_execute_xfail\n-    }\n-\n-    verbose \"Running $GCOV $testcase\" 2\n-    set testcase [remote_download host $testcase];\n-    set result [remote_exec host $GCOV $args];\n-    if { [lindex $result 0] != 0 } {\n-\tfail \"$subdir/$testcase gcov failed: [lindex $result 1]\"\n-\tclean-gcov $testcase\n-\treturn\n-    }\n-\n-    # Get the gcov output file after making sure it exists.\n-    set files [glob -nocomplain $testcase.gcov]\n-    if { $files == \"\" } {\n-        fail \"$subdir/$testcase gcov failed: $testcase.gcov does not exist\"\n-        clean-gcov $testcase\n-        return;\n-    }\n-    remote_upload host $testcase.gcov $testcase.gcov;\n-\n-    if [info exists gcov_verify_xfail] {\n-\tsetup_xfail $gcov_verify_xfail\n-    }\n-\n-    # Check that line execution counts are as expected.\n-    set loutput [verify-lines $testcase $testcase.gcov]\n-    set lfailed [lindex $loutput 0]\n-    set lmessage [lindex $loutput 1]\n-\n-    # If requested via the .x file, check that branch and call information\n-    # is correct.\n-    if [info exists gcov_verify_branches] {\n-\tset boutput [verify-branches $testcase $testcase.gcov]\n-\tset bfailed [lindex $boutput 0]\n-\tset bmessage [lindex $boutput 1]\n-    } else {\n-\tset bfailed 0\n-\tset bmessage \"\"\n-    }\n-    if [info exists gcov_verify_calls] {\n-\tset coutput [verify-calls $testcase $testcase.gcov]\n-\tset cfailed [lindex $coutput 0]\n-\tset cmessage [lindex $coutput 1]\n-    } else {\n-\tset cfailed 0\n-\tset cmessage \"\"\n-    }\n-\n-    clean-gcov $testcase\n-\n-    # Report whether the gcov test passed or failed.  If there were\n-    # multiple failures then the message is a summary.\n-    set tfailed [expr $lfailed + $bfailed + $cfailed]\n-    if { $tfailed > 0 } {\n-\tif { $tfailed == 1 } {\n-\t    set vmessage \"$lmessage$bmessage$cmessage\"\n-\t} elseif { $bfailed == 0 && $cfailed == 0 } {\n-\t    set vmessage \"$lfailed failures in line counts\"\n-\t} elseif { $lfailed == 0 && $cfailed == 0 } {\n-\t    set vmessage \"$bfailed failures in branch percentages\"\n-\t} elseif { $lfailed == 0 && $bfailed == 0 } {\n-\t    set vmessage \"$cfailed failures in return percentages\"\n-\t} else {\n-\t    set vmessage \"$lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages\"\n-\t}\n-\tfail \"$subdir/$testcase gcov: $vmessage\"\n-    } else {\n-\tpass \"$subdir/$testcase gcov\"\n-    }\n-}\n-\n # Initialize harness.\n dg-init\n "}]}