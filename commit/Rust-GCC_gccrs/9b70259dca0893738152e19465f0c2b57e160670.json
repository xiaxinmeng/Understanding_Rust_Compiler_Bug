{"sha": "9b70259dca0893738152e19465f0c2b57e160670", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3MDI1OWRjYTA4OTM3MzgxNTJlMTk0NjVmMGMyYjU3ZTE2MDY3MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-24T22:18:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-24T22:18:11Z"}, "message": "i386.md (cmpdi): Fix operand predicates.\n\n\n\t* i386.md (cmpdi): Fix operand predicates.\n\t(cmpdi_ccno_1_rex64, cmpdi_minus_1_rex64, cmpdi_1_rex64,\n\t cmpdi_1_insn_rex64): New patterns.\n\t(adddi3): Turn to expander.\n\t(adddi3_1, adddi3_carry_rex64, adddi3_cc_rex64): New patterns.\n\t(addsi3_carry_zext): New pattern.\n\t(adddi_?_rex64): New patterns and splitters.\n\t(addsi_?_zext): New patterns.\n\t(subsi3_carry_zext): New pattern.\n\t(subdi_?_rex64): New patterns and splitters.\n\t(iorsi_?_zext): New patterns.\n\t(iordi_?_rex64): New patterns and splitters.\n\t(iorsi_?_zext): New patterns.\n\t(iorsi_?_zext_imm): New patterns.\n\t(xorsi_?_zext): New patterns.\n\t(xordi_?_rex64): New patterns and splitters.\n\t(xorsi_?_zext): New patterns.\n\t(negdi*): New patterns.\n\t(one_cmpldi*): Likewise.\n\t(one_cmplsi*_zext, negsi*_zext): Likewise.\n\t(testqi_ext_3_rex64): New pattern.\n\nFrom-SVN: r40819", "tree": {"sha": "d3da1dabf8cb0570d9df7989d50bd2bc07e4ebd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3da1dabf8cb0570d9df7989d50bd2bc07e4ebd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b70259dca0893738152e19465f0c2b57e160670", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b70259dca0893738152e19465f0c2b57e160670", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b70259dca0893738152e19465f0c2b57e160670", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b70259dca0893738152e19465f0c2b57e160670/comments", "author": null, "committer": null, "parents": [{"sha": "26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e5b205a7698d76c3e4d5e5f12b41c14b48f66e"}], "stats": {"total": 1660, "additions": 1502, "deletions": 158}, "files": [{"sha": "db5a254c640fc76fd5b76c2529f37a40753bc3ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b70259dca0893738152e19465f0c2b57e160670/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b70259dca0893738152e19465f0c2b57e160670/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b70259dca0893738152e19465f0c2b57e160670", "patch": "@@ -1,3 +1,27 @@\n+Sat Mar 24 23:15:19 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (cmpdi): Fix operand predicates.\n+\t(cmpdi_ccno_1_rex64, cmpdi_minus_1_rex64, cmpdi_1_rex64,\n+\t cmpdi_1_insn_rex64): New patterns.\n+\t(adddi3): Turn to expander.\n+\t(adddi3_1, adddi3_carry_rex64, adddi3_cc_rex64): New patterns.\n+\t(addsi3_carry_zext): New pattern.\n+\t(adddi_?_rex64): New patterns and splitters.\n+\t(addsi_?_zext): New patterns.\n+\t(subsi3_carry_zext): New pattern.\n+\t(subdi_?_rex64): New patterns and splitters.\n+\t(iorsi_?_zext): New patterns.\n+\t(iordi_?_rex64): New patterns and splitters.\n+\t(iorsi_?_zext): New patterns.\n+\t(iorsi_?_zext_imm): New patterns.\n+\t(xorsi_?_zext): New patterns.\n+\t(xordi_?_rex64): New patterns and splitters.\n+\t(xorsi_?_zext): New patterns.\n+\t(negdi*): New patterns.\n+\t(one_cmpldi*): Likewise.\n+\t(one_cmplsi*_zext, negsi*_zext): Likewise.\n+\t(testqi_ext_3_rex64): New pattern.\n+\n Sat Mar 24 21:13:28 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386-protos.h (ix86_split_long_move): Return void."}, {"sha": "0a490a61c23fac59dda52f7bc574ce0132ba1214", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1478, "deletions": 158, "changes": 1636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b70259dca0893738152e19465f0c2b57e160670/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b70259dca0893738152e19465f0c2b57e160670/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9b70259dca0893738152e19465f0c2b57e160670", "patch": "@@ -1002,8 +1002,8 @@\n \n (define_expand \"cmpdi\"\n   [(set (reg:CC 17)\n-\t(compare:CC (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t    (match_operand:DI 1 \"general_operand\" \"\")))]\n+\t(compare:CC (match_operand:DI 0 \"x86_64_general_operand\" \"\")\n+\t\t    (match_operand:DI 1 \"x86_64_general_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -1060,6 +1060,45 @@\n   DONE;\n }\")\n \n+(define_insn \"cmpdi_ccno_1_rex64\"\n+  [(set (reg 17)\n+\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"r,?mr\")\n+\t\t (match_operand:DI 1 \"const0_operand\" \"n,n\")))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"@\n+   test{q}\\\\t{%0, %0|%0, %0}\n+   cmp{q}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"test,icmp\")\n+   (set_attr \"length_immediate\" \"0,1\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*cmpdi_minus_1_rex64\"\n+  [(set (reg 17)\n+\t(compare (minus:DI (match_operand:DI 0 \"nonimmediate_operand\" \"rm,r\")\n+\t\t\t   (match_operand:DI 1 \"x86_64_general_operand\" \"re,mr\"))\n+\t\t (const_int 0)))]\n+  \"ix86_match_ccmode (insn, CCGOCmode)\"\n+  \"cmp{q}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"icmp\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_expand \"cmpdi_1_rex64\"\n+  [(set (reg:CC 17)\n+\t(compare:CC (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:DI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"cmpdi_1_insn_rex64\"\n+  [(set (reg 17)\n+\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"mr,r\")\n+\t\t (match_operand:DI 1 \"x86_64_general_operand\" \"re,mr\")))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\"\n+  \"cmp{q}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"icmp\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+\n (define_insn \"*cmpsi_ccno_1\"\n   [(set (reg 17)\n \t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"r,?mr\")\n@@ -5100,12 +5139,20 @@\n ;\t(plus:DI (match_operand:DI 1 \"general_operand\" \"\")\n ;\t\t (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"\"))))]\n \n-(define_insn \"adddi3\"\n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"\"\n+  \"ix86_expand_binary_operator (PLUS, DImode, operands); DONE;\")\n+\n+(define_insn \"*adddi3_1\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n \t(plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t (match_operand:DI 2 \"general_operand\" \"roiF,riF\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"#\")\n \n (define_split\n@@ -5125,6 +5172,29 @@\n    split_di (operands+1, 1, operands+1, operands+4);\n    split_di (operands+2, 1, operands+2, operands+5);\")\n \n+(define_insn \"*adddi3_carry_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t  (plus:DI (plus:DI (ltu:DI (reg:CC 17) (const_int 0))\n+\t\t\t    (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\"))\n+\t\t   (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"ix86_binary_operator_ok (PLUS, DImode, operands)\"\n+  \"adc{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"*adddi3_cc_rex64\"\n+  [(set (reg:CC 17) (unspec:CC [(match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")] 12))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, DImode, operands)\"\n+  \"add{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"*addsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (plus:SI (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n@@ -5138,6 +5208,20 @@\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"ppro_uops\" \"few\")])\n \n+(define_insn \"*addsi3_carry_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t  (zero_extend:DI \n+\t    (plus:SI (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n+\t\t\t      (match_operand:SI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t     (match_operand:SI 2 \"general_operand\" \"rim\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n+  \"adc{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n (define_insn \"*addsi3_cc\"\n   [(set (reg:CC 17) (unspec:CC [(match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t\t        (match_operand:SI 2 \"general_operand\" \"ri,rm\")] 12))\n@@ -5270,29 +5354,29 @@\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*addsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm,r\")\n-\t(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,r\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmni,rni,rni\")))\n+(define_insn \"*adddi_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r\")\n+\t(plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,r\")\n+\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rme,re,re\")))\n    (clobber (reg:CC 17))]\n-  \"ix86_binary_operator_ok (PLUS, SImode, operands)\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, DImode, operands)\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_LEA:\n       operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n-      return \\\"lea{l}\\\\t{%a2, %0|%0, %a2}\\\";\n+      return \\\"lea{q}\\\\t{%a2, %0|%0, %a2}\\\";\n \n     case TYPE_INCDEC:\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n       if (operands[2] == const1_rtx)\n-        return \\\"inc{l}\\\\t%0\\\";\n+        return \\\"inc{q}\\\\t%0\\\";\n       else if (operands[2] == constm1_rtx)\n-        return \\\"dec{l}\\\\t%0\\\";\n+        return \\\"dec{q}\\\\t%0\\\";\n       else\n-\tabort();\n+\tabort ();\n \n     default:\n       if (! rtx_equal_p (operands[0], operands[1]))\n@@ -5306,61 +5390,47 @@\n \t\t  && INTVAL (operands[2]) != -128)))\n         {\n           operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+          return \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n         }\n-      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+      return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n      (cond [(eq_attr \"alternative\" \"2\")\n \t      (const_string \"lea\")\n \t    ; Current assemblers are broken and do not allow @GOTOFF in\n \t    ; ought but a memory context.\n-\t    (match_operand:SI 2 \"pic_symbolic_operand\" \"\")\n+\t    (match_operand:DI 2 \"pic_symbolic_operand\" \"\")\n \t      (const_string \"lea\")\n-\t    (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t    (match_operand:DI 2 \"incdec_operand\" \"\")\n \t      (const_string \"incdec\")\n \t   ]\n \t   (const_string \"alu\")))\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"DI\")])\n \n ;; Convert lea to the lea pattern to avoid flags dependency.\n (define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(plus (match_operand 1 \"register_operand\" \"\")\n-              (match_operand 2 \"nonmemory_operand\" \"\")))\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"x86_64_nonmemory_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"reload_completed\n+  \"reload_completed && TARGET_64BIT\n    && true_regnum (operands[0]) != true_regnum (operands[1])\"\n-  [(const_int 0)]\n-  \"\n-{\n-  rtx pat;\n-  /* In -fPIC mode the constructs like (const (unspec [symbol_ref]))\n-     may confuse gen_lowpart.  */\n-  if (GET_MODE (operands[0]) != Pmode)\n-    {\n-      operands[1] = gen_lowpart (Pmode, operands[1]);\n-      operands[2] = gen_lowpart (Pmode, operands[2]);\n-    }\n-  operands[0] = gen_lowpart (SImode, operands[0]);\n-  pat = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n-  if (Pmode != SImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n-  DONE;\n-}\")\n+  [(set (match_dup 0)\n+\t(plus:DI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"\")\n \n-(define_insn \"*addsi_2\"\n+(define_insn \"*adddi_2_rex64\"\n   [(set (reg 17)\n \t(compare\n-\t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmni,rni\"))\n+\t  (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t   (match_operand:DI 2 \"x86_64_general_operand\" \"rme,re\"))\n \t  (const_int 0)))\t\t\t\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (PLUS, SImode, operands)\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCGOCmode)\n+   && ix86_binary_operator_ok (PLUS, DImode, operands)\n    /* Current assemblers are broken and do not allow @GOTOFF in\n       ought but a memory context. */\n    && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n@@ -5372,15 +5442,17 @@\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n       if (operands[2] == const1_rtx)\n-        return \\\"inc{l}\\\\t%0\\\";\n+        return \\\"inc{q}\\\\t%0\\\";\n       else if (operands[2] == constm1_rtx)\n-        return \\\"dec{l}\\\\t%0\\\";\n+        return \\\"dec{q}\\\\t%0\\\";\n       else\n-\tabort();\n+\tabort ();\n \n     default:\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n+      /* ???? We ought to handle there the 32bit case too\n+\t - do we need new constrant?  */\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n@@ -5389,22 +5461,22 @@\n \t\t  && INTVAL (operands[2]) != -128)))\n         {\n           operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+          return \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n         }\n-      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+      return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+     (if_then_else (match_operand:DI 2 \"incdec_operand\" \"\")\n \t(const_string \"incdec\")\n \t(const_string \"alu\")))\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"*addsi_3\"\n+(define_insn \"*adddi_3\"\n   [(set (reg 17)\n-\t(compare (neg:SI (match_operand:SI 2 \"general_operand\" \"rmni\"))\n-\t\t (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n+\t(compare (neg:DI (match_operand:DI 2 \"x86_64_general_operand\" \"rme\"))\n+\t\t (match_operand:DI 1 \"x86_64_general_operand\" \"%0\")))\n+   (clobber (match_scratch:DI 0 \"=r\"))]\n   \"ix86_match_ccmode (insn, CCZmode)\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n    /* Current assemblers are broken and do not allow @GOTOFF in\n@@ -5418,15 +5490,17 @@\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n       if (operands[2] == const1_rtx)\n-        return \\\"inc{l}\\\\t%0\\\";\n+        return \\\"inc{q}\\\\t%0\\\";\n       else if (operands[2] == constm1_rtx)\n-        return \\\"dec{l}\\\\t%0\\\";\n+        return \\\"dec{q}\\\\t%0\\\";\n       else\n-\tabort();\n+\tabort ();\n \n     default:\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n+      /* ???? We ought to handle there the 32bit case too\n+\t - do we need new constrant?  */\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n@@ -5435,41 +5509,40 @@\n \t\t  && INTVAL (operands[2]) != -128)))\n         {\n           operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+          return \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n         }\n-      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+      return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+     (if_then_else (match_operand:DI 2 \"incdec_operand\" \"\")\n \t(const_string \"incdec\")\n \t(const_string \"alu\")))\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"DI\")])\n \n-; For comparisons agains 1, -1 and 128, we may generate better code\n+; For comparisons against 1, -1 and 128, we may generate better code\n ; by converting cmp to add, inc or dec as done by peephole2.  This pattern\n ; is matched then.  We can't accept general immediate, because for\n ; case of overflows,  the result is messed up.\n-; This pattern also don't hold of 0x80000000, since the value overflows\n+; This pattern also don't hold of 0x8000000000000000, since the value overflows\n ; when negated.\n ; Also carry flag is reversed compared to cmp, so this converison is valid\n ; only for comparisons not depending on it.\n-(define_insn \"*addsi_4\"\n+(define_insn \"*adddi_4\"\n   [(set (reg 17)\n-\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_scratch:SI 0 \"=rm\"))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && (INTVAL (operands[2]) & 0xffffffff) != 0x80000000\"\n+\t(compare (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"x86_64_immediate_operand\" \"e\")))\n+   (clobber (match_scratch:DI 0 \"=rm\"))]\n+  \"ix86_match_ccmode (insn, CCGCmode)\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_INCDEC:\n       if (operands[2] == constm1_rtx)\n-        return \\\"inc{l}\\\\t%0\\\";\n+        return \\\"inc{q}\\\\t%0\\\";\n       else if (operands[2] == const1_rtx)\n-        return \\\"dec{l}\\\\t%0\\\";\n+        return \\\"dec{q}\\\\t%0\\\";\n       else\n \tabort();\n \n@@ -5481,24 +5554,24 @@\n       if ((INTVAL (operands[2]) == -128\n \t   || (INTVAL (operands[2]) > 0\n \t       && INTVAL (operands[2]) != 128)))\n-\treturn \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+\treturn \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n       operands[2] = GEN_INT (-INTVAL (operands[2]));\n-      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+      return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+     (if_then_else (match_operand:DI 2 \"incdec_operand\" \"\")\n \t(const_string \"incdec\")\n \t(const_string \"alu\")))\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"*addsi_5\"\n+(define_insn \"*adddi_5\"\n   [(set (reg 17)\n \t(compare\n-\t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t  (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t   (match_operand:DI 2 \"x86_64_general_operand\" \"rme\"))\n \t  (const_int 0)))\t\t\t\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n+   (clobber (match_scratch:DI 0 \"=r\"))]\n   \"ix86_match_ccmode (insn, CCGOCmode)\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n    /* Current assemblers are broken and do not allow @GOTOFF in\n@@ -5512,9 +5585,9 @@\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n       if (operands[2] == const1_rtx)\n-        return \\\"inc{l}\\\\t%0\\\";\n+        return \\\"inc{q}\\\\t%0\\\";\n       else if (operands[2] == constm1_rtx)\n-        return \\\"dec{l}\\\\t%0\\\";\n+        return \\\"dec{q}\\\\t%0\\\";\n       else\n \tabort();\n \n@@ -5529,91 +5602,524 @@\n \t\t  && INTVAL (operands[2]) != -128)))\n         {\n           operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+          return \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n         }\n-      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+      return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+     (if_then_else (match_operand:DI 2 \"incdec_operand\" \"\")\n \t(const_string \"incdec\")\n \t(const_string \"alu\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"addhi3\"\n-  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:HI 2 \"general_operand\" \"\")))\n-\t      (clobber (reg:CC 17))])]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (PLUS, HImode, operands); DONE;\")\n+   (set_attr \"mode\" \"DI\")])\n \n-;; %%% After Dave's SUBREG_BYTE stuff goes in, re-enable incb %ah\n-;; type optimizations enabled by define-splits.  This is not important\n-;; for PII, and in fact harmful because of partial register stalls.\n \n-(define_insn \"*addhi_1_lea\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n-\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,r\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"ri,rm,rni\")))\n+(define_insn \"*addsi_1\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm,r\")\n+\t(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,r\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmni,rni,rni\")))\n    (clobber (reg:CC 17))]\n-  \"!TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (PLUS, HImode, operands)\"\n+  \"ix86_binary_operator_ok (PLUS, SImode, operands)\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_LEA:\n-      return \\\"#\\\";\n+      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+      return \\\"lea{l}\\\\t{%a2, %0|%0, %a2}\\\";\n+\n     case TYPE_INCDEC:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n       if (operands[2] == const1_rtx)\n-\treturn \\\"inc{w}\\\\t%0\\\";\n-      else if (operands[2] == constm1_rtx\n-\t       || (GET_CODE (operands[2]) == CONST_INT\n-\t\t   && INTVAL (operands[2]) == 65535))\n-\treturn \\\"dec{w}\\\\t%0\\\";\n-      abort();\n+        return \\\"inc{l}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%0\\\";\n+      else\n+\tabort();\n \n     default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n           && (INTVAL (operands[2]) == 128\n \t      || (INTVAL (operands[2]) < 0\n \t\t  && INTVAL (operands[2]) != -128)))\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \\\"sub{w}\\\\t{%2, %0|%0, %2}\\\";\n-\t}\n-      return \\\"add{w}\\\\t{%2, %0|%0, %2}\\\";\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n     }\n }\"\n   [(set (attr \"type\")\n-     (if_then_else (eq_attr \"alternative\" \"2\")\n-\t(const_string \"lea\")\n-\t(if_then_else (match_operand:HI 2 \"incdec_operand\" \"\")\n-\t   (const_string \"incdec\")\n-\t   (const_string \"alu\"))))\n-   (set_attr \"mode\" \"HI,HI,SI\")])\n+     (cond [(eq_attr \"alternative\" \"2\")\n+\t      (const_string \"lea\")\n+\t    ; Current assemblers are broken and do not allow @GOTOFF in\n+\t    ; ought but a memory context.\n+\t    (match_operand:SI 2 \"pic_symbolic_operand\" \"\")\n+\t      (const_string \"lea\")\n+\t    (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t      (const_string \"incdec\")\n+\t   ]\n+\t   (const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*addhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"ri,rm\")))\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(plus (match_operand 1 \"register_operand\" \"\")\n+              (match_operand 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (PLUS, HImode, operands)\"\n+  \"reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx pat;\n+  /* In -fPIC mode the constructs like (const (unspec [symbol_ref]))\n+     may confuse gen_lowpart.  */\n+  if (GET_MODE (operands[0]) != Pmode)\n+    {\n+      operands[1] = gen_lowpart (Pmode, operands[1]);\n+      operands[2] = gen_lowpart (Pmode, operands[2]);\n+    }\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+  pat = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n+  if (Pmode != SImode)\n+    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n+  DONE;\n+}\")\n+\n+;; It may seem that nonimmediate operand is proper one for operand 1.\n+;; The addsi_1 pattern allows nonimmediate operand at that place and\n+;; we take care in ix86_binary_operator_ok to not allow two memory\n+;; operands so proper swapping will be done in reload.  This allow\n+;; patterns constructed from addsi_1 to match.\n+(define_insn \"addsi_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI\n+\t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,r\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmni,rni\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n   \"*\n {\n   switch (get_attr_type (insn))\n     {\n+    case TYPE_LEA:\n+      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+      return \\\"lea{l}\\\\t{%a2, %k0|%k0, %a2}\\\";\n+\n     case TYPE_INCDEC:\n       if (operands[2] == const1_rtx)\n-\treturn \\\"inc{w}\\\\t%0\\\";\n-      else if (operands[2] == constm1_rtx\n-\t       || (GET_CODE (operands[2]) == CONST_INT\n-\t\t   && INTVAL (operands[2]) == 65535))\n-\treturn \\\"dec{w}\\\\t%0\\\";\n+        return \\\"inc{l}\\\\t%k0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%k0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %k0|%k0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %k0|%k0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (cond [(eq_attr \"alternative\" \"1\")\n+\t      (const_string \"lea\")\n+\t    ; Current assemblers are broken and do not allow @GOTOFF in\n+\t    ; ought but a memory context.\n+\t    (match_operand:SI 2 \"pic_symbolic_operand\" \"\")\n+\t      (const_string \"lea\")\n+\t    (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t      (const_string \"incdec\")\n+\t   ]\n+\t   (const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI\n+\t  (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\"))))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(set (match_dup 0)\n+\t(zero_extend:DI (subreg:SI (plus:DI (match_dup 1) (match_dup 2)) 0)))]\n+  \"\n+{\n+  operands[1] = gen_lowpart (Pmode, operands[1]);\n+  operands[2] = gen_lowpart (Pmode, operands[2]);\n+}\")\n+\n+(define_insn \"*addsi_2\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmni,rni\"))\n+\t  (const_int 0)))\t\t\t\n+   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"ix86_match_ccmode (insn, CCGOCmode)\n+   && ix86_binary_operator_ok (PLUS, SImode, operands)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      if (operands[2] == const1_rtx)\n+        return \\\"inc{l}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+(define_insn \"*addsi_2_zext\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t  (const_int 0)))\t\t\t\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCGOCmode)\n+   && ix86_binary_operator_ok (PLUS, SImode, operands)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+        return \\\"inc{l}\\\\t%k0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%k0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %k0|%k0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %k0|%k0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*addsi_3\"\n+  [(set (reg 17)\n+\t(compare (neg:SI (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t\t (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCZmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      if (operands[2] == const1_rtx)\n+        return \\\"inc{l}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+(define_insn \"*addsi_3_zext\"\n+  [(set (reg 17)\n+\t(compare (neg:SI (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t\t (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCZmode)\n+   && ix86_binary_operator_ok (PLUS, SImode, operands)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+        return \\\"inc{l}\\\\t%k0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%k0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %k0|%k0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %k0|%k0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+; For comparisons agains 1, -1 and 128, we may generate better code\n+; by converting cmp to add, inc or dec as done by peephole2.  This pattern\n+; is matched then.  We can't accept general immediate, because for\n+; case of overflows,  the result is messed up.\n+; This pattern also don't hold of 0x80000000, since the value overflows\n+; when negated.\n+; Also carry flag is reversed compared to cmp, so this converison is valid\n+; only for comparisons not depending on it.\n+(define_insn \"*addsi_4\"\n+  [(set (reg 17)\n+\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_scratch:SI 0 \"=rm\"))]\n+  \"ix86_match_ccmode (insn, CCGCmode)\n+   && (INTVAL (operands[2]) & 0xffffffff) != 0x80000000\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == constm1_rtx)\n+        return \\\"inc{l}\\\\t%0\\\";\n+      else if (operands[2] == const1_rtx)\n+        return \\\"dec{l}\\\\t%0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if ((INTVAL (operands[2]) == -128\n+\t   || (INTVAL (operands[2]) > 0\n+\t       && INTVAL (operands[2]) != 128)))\n+\treturn \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+      operands[2] = GEN_INT (-INTVAL (operands[2]));\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*addsi_5\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t  (const_int 0)))\t\t\t\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCGOCmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      if (operands[2] == const1_rtx)\n+        return \\\"inc{l}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_expand \"addhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n+\t\t\t    (match_operand:HI 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_HIMODE_MATH\"\n+  \"ix86_expand_binary_operator (PLUS, HImode, operands); DONE;\")\n+\n+;; %%% After Dave's SUBREG_BYTE stuff goes in, re-enable incb %ah\n+;; type optimizations enabled by define-splits.  This is not important\n+;; for PII, and in fact harmful because of partial register stalls.\n+\n+(define_insn \"*addhi_1_lea\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n+\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,r\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"ri,rm,rni\")))\n+   (clobber (reg:CC 17))]\n+  \"!TARGET_PARTIAL_REG_STALL\n+   && ix86_binary_operator_ok (PLUS, HImode, operands)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LEA:\n+      return \\\"#\\\";\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"inc{w}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx\n+\t       || (GET_CODE (operands[2]) == CONST_INT\n+\t\t   && INTVAL (operands[2]) == 65535))\n+\treturn \\\"dec{w}\\\\t%0\\\";\n+      abort();\n+\n+    default:\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+\t{\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  return \\\"sub{w}\\\\t{%2, %0|%0, %2}\\\";\n+\t}\n+      return \\\"add{w}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (eq_attr \"alternative\" \"2\")\n+\t(const_string \"lea\")\n+\t(if_then_else (match_operand:HI 2 \"incdec_operand\" \"\")\n+\t   (const_string \"incdec\")\n+\t   (const_string \"alu\"))))\n+   (set_attr \"mode\" \"HI,HI,SI\")])\n+\n+(define_insn \"*addhi_1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"ri,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_PARTIAL_REG_STALL\n+   && ix86_binary_operator_ok (PLUS, HImode, operands)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"inc{w}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx\n+\t       || (GET_CODE (operands[2]) == CONST_INT\n+\t\t   && INTVAL (operands[2]) == 65535))\n+\treturn \\\"dec{w}\\\\t%0\\\";\n       abort();\n \n     default:\n@@ -6188,15 +6694,22 @@\n \f\n ;; Subtract instructions\n \n-;; %%% define_expand from the very first?\n ;; %%% splits for subsidi3\n \n-(define_insn \"subdi3\"\n+(define_expand \"subdi3\"\n+  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t\t     (match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_binary_operator (MINUS, DImode, operands); DONE;\")\n+\n+(define_insn \"*subdi3_1\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n \t(minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n \t\t  (match_operand:DI 2 \"general_operand\" \"roiF,riF\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"#\")\n \n (define_split\n@@ -6216,6 +6729,56 @@\n    split_di (operands+1, 1, operands+1, operands+4);\n    split_di (operands+2, 1, operands+2, operands+5);\")\n \n+(define_insn \"subdi3_carry_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t  (minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n+\t    (plus:DI (ltu:DI (reg:CC 17) (const_int 0))\n+\t       (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\"))))\n+   (clobber (reg:CC 17))]\n+  \"ix86_binary_operator_ok (MINUS, DImode, operands)\"\n+  \"sbb{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*subdi_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t  (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, DImode, operands)\"\n+  \"sub{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*subdi_2_rex64\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t    (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\"))\n+\t  (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(minus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCGOCmode)\n+   && ix86_binary_operator_ok (MINUS, DImode, operands)\"\n+  \"sub{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*subdi_3_rex63\"\n+  [(set (reg 17)\n+\t(compare (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(minus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\n+   && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n+  \"sub{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+\n (define_insn \"subsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (minus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n@@ -6229,6 +6792,20 @@\n    (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"subsi3_carry_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=rm,r\")\n+\t  (zero_extend:DI\n+\t    (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t      (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n+\t\t (match_operand:SI 2 \"general_operand\" \"ri,rm\")))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n+  \"sbb{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"subsi3\"\n   [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t\t   (minus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n@@ -6247,6 +6824,17 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*subsi_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:SI 2 \"general_operand\" \"rim\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n+  \"sub{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*subsi_2\"\n   [(set (reg 17)\n \t(compare\n@@ -6261,6 +6849,22 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*subsi_2_zext\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:SI 2 \"general_operand\" \"rim\"))\n+\t  (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (minus:SI (match_dup 1)\n+\t\t    (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCGOCmode)\n+   && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n+  \"sub{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*subsi_3\"\n   [(set (reg 17)\n \t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n@@ -6273,6 +6877,20 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*subsi_3_zext\"\n+  [(set (reg 17)\n+\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rim\")))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (minus:SI (match_dup 1)\n+\t\t    (match_dup 2))))]\n+  \"ix86_match_ccmode (insn, CCmode)\n+   && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n+  \"sub{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_expand \"subhi3\"\n   [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t\t   (minus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n@@ -6393,6 +7011,29 @@\n \f\n ;; Multiply instructions\n \n+(define_expand \"muldi3\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_64BIT\"\n+  \"\")\n+\n+(define_insn \"*muldi3_1_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%rm,0,0\")\n+\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"K,e,mr\")))\n+   (clobber (reg:CC 17))]\n+  \"(GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n+   && TARGET_64BIT\"\n+  \"@\n+   imul{q}\\\\t{%2, %1, %0|%0, %1, %2}\n+   imul{q}\\\\t{%2, %1, %0|%0, %1, %2}\n+   imul{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"prefix_0f\" \"0,0,1\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_expand \"mulsi3\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -6427,6 +7068,34 @@\n    (set_attr \"prefix_0f\" \"0,0,1\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*mulsi3_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:DI\n+\t  (mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%rm,0,0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"K,i,mr\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  ; For the {r,0,i} alternative (i.e., register <- register * immediate),\n+  ; there are two ways of writing the exact same machine instruction\n+  ; in assembly language.  One, for example, is:\n+  ;\n+  ;   imul $12, %eax\n+  ;\n+  ; while the other is:\n+  ;\n+  ;   imul $12, %eax, %eax\n+  ;\n+  ; The first is simply short-hand for the latter.  But, some assemblers,\n+  ; like the SCO OSR5 COFF assembler, don't handle the first form.\n+  \"@\n+   imul{l}\\\\t{%2, %1, %k0|%k0, %1, %2}\n+   imul{l}\\\\t{%2, %1, %k0|%k0, %1, %2}\n+   imul{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"prefix_0f\" \"0,0,1\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"mulhi3\"\n   [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t\t   (mult:HI (match_operand:HI 1 \"register_operand\" \"\")\n@@ -6484,18 +7153,17 @@\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"umulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))\n+(define_insn \"umulditi3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=A\")\n+\t(mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"%0\"))\n+\t\t (zero_extend:TI (match_operand:DI 2 \"nonimmediate_operand\" \"rm\"))))\n    (clobber (reg:CC 17))]\n-  \"\"\n-  \"mul{l}\\\\t%2\"\n+  \"TARGET_64BIT\"\n+  \"mul{q}\\\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"DI\")])\n \n ;; We can't use this pattern in 64bit mode, since it results in two separate 32bit registers\n (define_insn \"umulsidi3\"\n@@ -6510,6 +7178,17 @@\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"mulditi3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=A\")\n+\t(mult:TI (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"%0\"))\n+\t\t (sign_extend:TI (match_operand:DI 2 \"nonimmediate_operand\" \"rm\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"imul{q}\\\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=A\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n@@ -6521,6 +7200,24 @@\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*umuldi3_highpart_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(truncate:DI\n+\t  (lshiftrt:TI\n+\t    (mult:TI (zero_extend:TI\n+\t\t       (match_operand:DI 1 \"register_operand\" \"%a\"))\n+\t\t     (zero_extend:TI\n+\t\t       (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+\t    (const_int 64))))\n+   (clobber (match_scratch:DI 3 \"=a\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"mul{q}\\\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"umulsi3_highpart\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(truncate:SI\n@@ -6539,6 +7236,23 @@\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*smuldi3_highpart_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(truncate:DI\n+\t  (lshiftrt:TI\n+\t    (mult:TI (sign_extend:TI\n+\t\t       (match_operand:DI 1 \"register_operand\" \"%a\"))\n+\t\t     (sign_extend:TI\n+\t\t       (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+\t    (const_int 64))))\n+   (clobber (match_scratch:DI 3 \"=a\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"imul{q}\\\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"smulsi3_highpart\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(truncate:SI\n@@ -6556,6 +7270,23 @@\n    (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*smulsi3_highpart_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:DI (truncate:SI\n+\t  (lshiftrt:DI\n+\t    (mult:DI (sign_extend:DI\n+\t\t       (match_operand:SI 1 \"register_operand\" \"%a\"))\n+\t\t     (sign_extend:DI\n+\t\t       (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n+\t    (const_int 32)))))\n+   (clobber (match_scratch:SI 3 \"=a\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"imul{l}\\\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"SI\")])\n+\n ;; The patterns that match these are at the end of this file.\n \n (define_expand \"mulxf3\"\n@@ -6641,6 +7372,93 @@\n   \"\")\n \f\n ;; Remainder instructions.\n+\n+(define_expand \"divmoddi4\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (div:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t   (match_operand:DI 2 \"nonimmediate_operand\" \"\")))\n+\t      (set (match_operand:DI 3 \"register_operand\" \"\")\n+\t\t   (mod:DI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_64BIT\"\n+  \"\")\n+\n+;; Allow to come the parameter in eax or edx to avoid extra moves.\n+;; Penalize eax case sligthly because it results in worse scheduling\n+;; of code.\n+(define_insn \"*divmoddi4_nocltd_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&a,?a\")\n+\t(div:DI (match_operand:DI 2 \"register_operand\" \"1,0\")\n+\t\t(match_operand:DI 3 \"nonimmediate_operand\" \"rm,rm\")))\n+   (set (match_operand:DI 1 \"register_operand\" \"=&d,&d\")\n+\t(mod:DI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && !optimize_size && !TARGET_USE_CLTD\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*divmoddi4_cltd_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(div:DI (match_operand:DI 2 \"register_operand\" \"a\")\n+\t\t(match_operand:DI 3 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(mod:DI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && (optimize_size || TARGET_USE_CLTD)\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*divmoddi_noext_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n+\t(mod:DI (match_dup 1) (match_dup 2)))\n+   (use (match_operand:DI 4 \"register_operand\" \"3\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"idiv{q}\\\\t%2\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t(match_operand:DI 2 \"nonimmediate_operand\" \"\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(mod:DI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (ashiftrt:DI (match_dup 4) (const_int 63)))\n+\t      (clobber (reg:CC 17))])\n+   (parallel [(set (match_dup 0)\n+\t           (div:DI (reg:DI 0) (match_dup 2)))\n+\t      (set (match_dup 3)\n+\t\t   (mod:DI (reg:DI 0) (match_dup 2)))\n+\t      (use (match_dup 3))\n+\t      (clobber (reg:CC 17))])]\n+  \"\n+{\n+  /* Avoid use of cltd in favour of a mov+shift.  */\n+  if (!TARGET_USE_CLTD && !optimize_size)\n+    {\n+      if (true_regnum (operands[1]))\n+        emit_move_insn (operands[0], operands[1]);\n+      else\n+\temit_move_insn (operands[3], operands[1]);\n+      operands[4] = operands[3];\n+    }\n+  else\n+    {\n+      if (true_regnum (operands[1]))\n+\tabort();\n+      operands[4] = operands[1];\n+    }\n+}\")\n+\n+\n (define_expand \"divmodsi4\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (div:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -6737,7 +7555,51 @@\n   \"cwtd\\;idiv{w}\\\\t%2\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"udivmoddi4\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=&d\")\n+\t(umod:DI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"xor{q}\\\\t%3, %3\\;div{q}\\\\t%2\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*udivmoddi4_noext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n+\t(umod:DI (match_dup 1) (match_dup 2)))\n+   (use (match_dup 3))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"div{q}\\\\t%2\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"nonimmediate_operand\" \"\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(umod:DI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"reload_completed && TARGET_64BIT\"\n+  [(set (match_dup 3) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (udiv:DI (match_dup 1) (match_dup 2)))\n+\t      (set (match_dup 3)\n+\t\t   (umod:DI (match_dup 1) (match_dup 2)))\n+\t      (use (match_dup 3))\n+\t      (clobber (reg:CC 17))])]\n+  \"\")\n \n (define_insn \"udivmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n@@ -6834,6 +7696,23 @@\n ;; On Pentium, \"test imm, reg\" is pairable only with eax, ax, and al.\n ;; Note that this excludes ah.\n \n+(define_insn \"*testdi_1_rex64\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (and:DI (match_operand:DI 0 \"nonimmediate_operand\" \"%*a,r,*a,r,rm\")\n+\t\t  (match_operand:DI 1 \"x86_64_szext_nonmemory_operand\" \"Z,Z,e,e,re\"))\n+\t  (const_int 0)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"@\n+   test{l}\\\\t{%k1, %k0|%k0, %k1} \n+   test{l}\\\\t{%k1, %k0|%k0, %k1} \n+   test{q}\\\\t{%1, %0|%0, %1} \n+   test{q}\\\\t{%1, %0|%0, %1} \n+   test{q}\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"test\")\n+   (set_attr \"modrm\" \"0,1,0,1,1\")\n+   (set_attr \"mode\" \"SI,SI,DI,DI,DI\")\n+   (set_attr \"pent_pair\" \"uv,np,uv,np,uv\")])\n \n (define_insn \"testsi_1\"\n   [(set (reg 17)\n@@ -6990,16 +7869,32 @@\n \t\t (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n    && (GET_MODE (operands[0]) == SImode\n+       || (TARGET_64BIT && GET_MODE (operands[0]) == DImode)\n+       || GET_MODE (operands[0]) == HImode\n+       || GET_MODE (operands[0]) == QImode)\"\n+  \"#\")\n+\n+(define_insn \"*testqi_ext_3_rex64\"\n+  [(set (reg 17)\n+        (compare (zero_extract:DI\n+\t\t   (match_operand 0 \"nonimmediate_operand\" \"rm\")\n+\t\t   (match_operand:DI 1 \"const_int_operand\" \"\")\n+\t\t   (match_operand:DI 2 \"const_int_operand\" \"\"))\n+\t\t (const_int 0)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && TARGET_64BIT\n+   && (GET_MODE (operands[0]) == SImode\n+       || GET_MODE (operands[0]) == DImode\n        || GET_MODE (operands[0]) == HImode\n        || GET_MODE (operands[0]) == QImode)\"\n   \"#\")\n \n (define_split\n   [(set (reg 17)\n-        (compare (zero_extract:SI\n+        (compare (zero_extract\n \t\t   (match_operand 0 \"nonimmediate_operand\" \"rm\")\n-\t\t   (match_operand:SI 1 \"const_int_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t   (match_operand 1 \"const_int_operand\" \"\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t\t (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\"\n   [(set (reg:CCNO 17) (compare:CCNO (match_dup 3) (const_int 0)))]\n@@ -7038,6 +7933,73 @@\n ;; and sometimes to QImode registers.  If this is considered useful,\n ;; it should be done with splitters.\n \n+(define_expand \"anddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t(match_operand:DI 2 \"x86_64_szext_general_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_binary_operator (AND, DImode, operands); DONE;\")\n+\n+(define_insn \"*anddi_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n+\t(and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,qm\")\n+\t\t(match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm,L\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (AND, DImode, operands)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_IMOVX:\n+      {\n+\tenum machine_mode mode;\n+\n+\tif (GET_CODE (operands[2]) != CONST_INT)\n+\t  abort ();\n+        if (INTVAL (operands[2]) == 0xff)\n+\t  mode = QImode;\n+\telse if (INTVAL (operands[2]) == 0xffff)\n+\t  mode = HImode;\n+\telse\n+\t  abort ();\n+\t\n+\toperands[1] = gen_lowpart (mode, operands[1]);\n+\tif (mode == QImode)\n+\t  return \\\"movz{bq|x}\\\\t{%1,%0|%0, %1}\\\";\n+\telse\n+\t  return \\\"movz{wq|x}\\\\t{%1,%0|%0, %1}\\\";\n+      }\n+\n+    default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      if (get_attr_mode (insn) == MODE_SI)\n+\treturn \\\"and{l}\\\\t{%k2, %k0|%k0, %k2}\\\";\n+      else\n+\treturn \\\"and{q}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"alu,alu,alu,imovx\")\n+   (set_attr \"length_immediate\" \"*,*,*,0\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI\")])\n+\n+(define_insn \"*anddi_2\"\n+  [(set (reg 17)\n+\t(compare (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,rem,re\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,rm\")\n+\t(and:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (AND, DImode, operands)\"\n+  \"@\n+   and{l}\\\\t{%k2, %k0|%k0, %k2} \n+   and{q}\\\\t{%2, %0|%0, %2} \n+   and{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI,DI,DI\")])\n+\n (define_expand \"andsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n@@ -7087,31 +8049,35 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(and:SI (match_dup 0)\n-\t\t(const_int -65536)))\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(and (match_dup 0)\n+\t     (const_int -65536)))\n    (clobber (reg:CC 17))]\n-  \"optimize_size\"\n+  \"optimize_size\n+   && (GET_MODE (operands[0]) == SImode || GET_MODE (operands[0]) == HImode\n+       || (TARGET_64BIT && GET_MODE (operands[0]) == DImode))\"\n   [(set (strict_low_part (match_dup 1)) (const_int 0))]\n   \"operands[1] = gen_lowpart (HImode, operands[0]);\")\n \n (define_split\n   [(set (match_operand 0 \"q_regs_operand\" \"\")\n \t(and (match_dup 0)\n-\t\t(const_int -256)))\n+\t     (const_int -256)))\n    (clobber (reg:CC 17))]\n   \"(optimize_size || !TARGET_PARTIAL_REG_STALL)\n-   && (GET_MODE (operands[0]) == SImode || GET_MODE (operands[0]) == HImode)\"\n+   && (GET_MODE (operands[0]) == SImode || GET_MODE (operands[0]) == HImode\n+       || (TARGET_64BIT && GET_MODE (operands[0]) == DImode))\"\n   [(set (strict_low_part (match_dup 1)) (const_int 0))]\n   \"operands[1] = gen_lowpart (QImode, operands[0]);\")\n \n (define_split\n-  [(set (match_operand 0 \"q_regs_operand\" \"\")\n+  [(set (match_operand 0 \"register_operand\" \"\")\n \t(and (match_dup 0)\n \t     (const_int -65281)))\n    (clobber (reg:CC 17))]\n   \"(optimize_size || !TARGET_PARTIAL_REG_STALL)\n-   && (GET_MODE (operands[0]) == SImode || GET_MODE (operands[0]) == HImode)\"\n+   && (GET_MODE (operands[0]) == SImode || GET_MODE (operands[0]) == HImode\n+       || (TARGET_64BIT && GET_MODE (operands[0]) == DImode))\"\n   [(parallel [(set (zero_extract:SI (match_dup 0)\n \t\t\t\t    (const_int 8)\n \t\t\t\t    (const_int 8))\n@@ -7125,6 +8091,18 @@\n \t      (clobber (reg:CC 17))])]\n   \"operands[0] = gen_lowpart (SImode, operands[0]);\")\n \n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+(define_insn \"*andsi_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"rim\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (AND, SImode, operands)\"\n+  \"and{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*andsi_2\"\n   [(set (reg 17)\n \t(compare (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -7138,6 +8116,20 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+(define_insn \"*andsi_2_zext\"\n+  [(set (reg 17)\n+\t(compare (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (AND, SImode, operands)\"\n+  \"and{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"andhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n@@ -7367,6 +8359,53 @@\n ;; %%% This used to optimize known byte-wide and operations to memory.\n ;; If this is considered useful, it should be done with splitters.\n \n+(define_expand \"iordi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_binary_operator (IOR, DImode, operands); DONE;\")\n+\n+(define_insn \"*iordi_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"re,rme\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\n+   && ix86_binary_operator_ok (IOR, DImode, operands)\"\n+  \"or{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*iordi_2_rex64\"\n+  [(set (reg 17)\n+\t(compare (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem,re\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(ior:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\n+   && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (IOR, DImode, operands)\"\n+  \"or{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*iordi_3_rex64\"\n+  [(set (reg 17)\n+\t(compare (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:DI 0 \"=r\"))]\n+  \"TARGET_64BIT\n+   && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (IOR, DImode, operands)\"\n+  \"or{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n@@ -7385,6 +8424,28 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+(define_insn \"*iorsi_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=rm\")\n+\t(zero_extend:DI\n+\t  (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"rim\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (IOR, SImode, operands)\"\n+  \"or{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*iorsi_1_zext_imm\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=rm\")\n+\t(ior:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\" \"Z\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"or{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*iorsi_2\"\n   [(set (reg 17)\n \t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -7398,6 +8459,34 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+;; ??? Special case for immediate operand is missing - it is tricky.\n+(define_insn \"*iorsi_2_zext\"\n+  [(set (reg 17)\n+\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (ior:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (IOR, SImode, operands)\"\n+  \"or{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*iorsi_2_zext_imm\"\n+  [(set (reg 17)\n+\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand 2 \"x86_64_zext_immediate_operand\" \"Z\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (IOR, SImode, operands)\"\n+  \"or{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*iorsi_3\"\n   [(set (reg 17)\n \t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n@@ -7528,6 +8617,56 @@\n ;; %%% This used to optimize known byte-wide and operations to memory.\n ;; If this is considered useful, it should be done with splitters.\n \n+(define_expand \"xordi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_binary_operator (XOR, DImode, operands); DONE;\")\n+\n+(define_insn \"*xordi_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\n+   && ix86_binary_operator_ok (XOR, DImode, operands)\"\n+  \"@\n+   xor{q}\\\\t{%2, %0|%0, %2} \n+   xor{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI,DI\")])\n+\n+(define_insn \"*xordi_2_rex64\"\n+  [(set (reg 17)\n+\t(compare (xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem,re\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(xor:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\n+   && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (XOR, DImode, operands)\"\n+  \"@\n+   xor{q}\\\\t{%2, %0|%0, %2} \n+   xor{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI,DI\")])\n+\n+(define_insn \"*xordi_3_rex64\"\n+  [(set (reg 17)\n+\t(compare (xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:DI 0 \"=r\"))]\n+  \"TARGET_64BIT\n+   && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (XOR, DImode, operands)\"\n+  \"xor{q}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_expand \"xorsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n@@ -7546,6 +8685,29 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+;; Add speccase for immediates\n+(define_insn \"*xorsi_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"rim\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (XOR, SImode, operands)\"\n+  \"xor{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*xorsi_1_zext_imm\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\" \"Z\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (XOR, SImode, operands)\"\n+  \"xor{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*xorsi_2\"\n   [(set (reg 17)\n \t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -7559,6 +8721,34 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+;; ??? Special case for immediate operand is missing - it is tricky.\n+(define_insn \"*xorsi_2_zext\"\n+  [(set (reg 17)\n+\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (xor:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (XOR, SImode, operands)\"\n+  \"xor{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*xorsi_2_zext_imm\"\n+  [(set (reg 17)\n+\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand 2 \"x86_64_zext_immediate_operand\" \"Z\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (XOR, SImode, operands)\"\n+  \"xor{l}\\\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*xorsi_3\"\n   [(set (reg 17)\n \t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n@@ -7785,6 +8975,31 @@\n   \"split_di (operands+1, 1, operands+2, operands+3);\n    split_di (operands+0, 1, operands+0, operands+1);\")\n \n+(define_insn \"*negdi2_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(neg:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_unary_operator_ok (NEG, DImode, operands)\"\n+  \"neg{q}\\\\t%0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+;; The problem with neg is that it does not perform (compare x 0),\n+;; it really performs (compare 0 x), which leaves us with the zero\n+;; flag being the only useful item.\n+\n+(define_insn \"*negdi2_cmpz_rex64\"\n+  [(set (reg:CCZ 17)\n+\t(compare:CCZ (neg:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\"))\n+\t\t     (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(neg:DI (match_dup 1)))]\n+  \"TARGET_64BIT && ix86_unary_operator_ok (NEG, DImode, operands)\"\n+  \"neg{q}\\\\t%0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+\n (define_expand \"negsi2\"\n   [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t\t   (neg:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))\n@@ -7801,6 +9016,18 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; Combine is quite creative about this pattern.\n+(define_insn \"*negsi2_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DI (neg:DI (ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t\t\t\t(const_int 32)))\n+\t\t     (const_int 32)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT && ix86_unary_operator_ok (NEG, SImode, operands)\"\n+  \"neg{l}\\\\t%k0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"SI\")])\n+\n ;; The problem with neg is that it does not perform (compare x 0),\n ;; it really performs (compare 0 x), which leaves us with the zero\n ;; flag being the only useful item.\n@@ -7816,6 +9043,23 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*negsi2_cmpz_zext\"\n+  [(set (reg:CCZ 17)\n+\t(compare:CCZ (lshiftrt:DI\n+\t\t       (neg:DI (ashift:DI\n+\t\t\t\t (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t\t\t (const_int 32)))\n+\t\t       (const_int 32))\n+\t\t     (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DI (neg:DI (ashift:DI (match_dup 1)\n+\t\t\t\t\t(const_int 32)))\n+\t\t     (const_int 32)))]\n+  \"TARGET_64BIT && ix86_unary_operator_ok (NEG, SImode, operands)\"\n+  \"neg{l}\\\\t%k0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"neghi2\"\n   [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t\t   (neg:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n@@ -8495,6 +9739,46 @@\n \f\n ;; One complement instructions\n \n+(define_expand \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(not:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"ix86_expand_unary_operator (NOT, DImode, operands); DONE;\")\n+\n+(define_insn \"*one_cmpldi2_1_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(not:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")))]\n+  \"TARGET_64BIT && ix86_unary_operator_ok (NOT, DImode, operands)\"\n+  \"not{q}\\\\t%0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*one_cmpldi2_2_rex64\"\n+  [(set (reg 17)\n+\t(compare (not:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(not:DI (match_dup 1)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_unary_operator_ok (NOT, DImode, operands)\"\n+  \"#\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_split\n+  [(set (reg 17)\n+\t(compare (not:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(not:DI (match_dup 1)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  [(parallel [(set (reg:CCNO 17)\n+\t\t   (compare:CCNO (xor:DI (match_dup 1) (const_int -1))\n+\t\t\t\t (const_int 0)))\n+\t      (set (match_dup 0)\n+\t\t   (xor:DI (match_dup 1) (const_int -1)))])]\n+  \"\")\n+\n (define_expand \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n@@ -8509,6 +9793,15 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; ??? Currently never generated - xor is used instead.\n+(define_insn \"*one_cmplsi2_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (not:SI (match_operand:SI 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_64BIT && ix86_unary_operator_ok (NOT, SImode, operands)\"\n+  \"not{l}\\\\t%k0\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*one_cmplsi2_2\"\n   [(set (reg 17)\n \t(compare (not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\"))\n@@ -8535,6 +9828,33 @@\n \t\t   (xor:SI (match_dup 1) (const_int -1)))])]\n   \"\")\n \n+;; ??? Currently never generated - xor is used instead.\n+(define_insn \"*one_cmplsi2_2_zext\"\n+  [(set (reg 17)\n+\t(compare (not:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (not:SI (match_dup 1))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_unary_operator_ok (NOT, SImode, operands)\"\n+  \"#\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_split\n+  [(set (reg 17)\n+\t(compare (not:SI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (not:SI (match_dup 1))))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\"\n+  [(parallel [(set (reg:CCNO 17)\n+\t\t   (compare:CCNO (xor:SI (match_dup 1) (const_int -1))\n+\t\t\t\t (const_int 0)))\n+\t      (set (match_dup 0)\n+\t\t   (zero_extend:DI (xor:SI (match_dup 1) (const_int -1))))])]\n+  \"\")\n+\n (define_expand \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]"}]}