{"sha": "74452ac3234316852e4f63d48f62db44991649b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ0NTJhYzMyMzQzMTY4NTJlNGY2M2Q0OGY2MmRiNDQ5OTE2NDliMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-08T18:41:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-08T18:41:49Z"}, "message": "mn10300.h (RETURN_ADDR_RTX): Define.\n\n        * mn10300.h (RETURN_ADDR_RTX): Define.\n\n        * mn10300.c (count_tst_insns): New function.\n        (expand_prologue): Load zero into data and/or address registers\n        if any are free and the function has optimizable tst insns.\n        (output_tst): If a suitable register is known to have the\n        value zero, use it instead of searching for a suitable register.\n        * mn10300.h (zero_dreg, zero_areg): Declare.\n        (FRAME_POINTER_NEEDED): Frame pointers are not needed if the\n        outgoing argument size is zero.\n        * mn10300.md (movXX): Optimize loading zero i        register if possible.  Optimize loading a DF/DI mode value\n        into an address register from a constant memory address.\n        (addsi3): Provide alternative which doesn't require a matching\n        inout operand.\n        (return): Optimize consecutive return instructions.\n\nFrom-SVN: r13845", "tree": {"sha": "198d4057d7fd056023eb939e423b4fc19553dfba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/198d4057d7fd056023eb939e423b4fc19553dfba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74452ac3234316852e4f63d48f62db44991649b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74452ac3234316852e4f63d48f62db44991649b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74452ac3234316852e4f63d48f62db44991649b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74452ac3234316852e4f63d48f62db44991649b2/comments", "author": null, "committer": null, "parents": [{"sha": "90e6057ba592752ace2fcfdc9043da12cf133932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e6057ba592752ace2fcfdc9043da12cf133932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e6057ba592752ace2fcfdc9043da12cf133932"}], "stats": {"total": 577, "additions": 491, "deletions": 86}, "files": [{"sha": "10e7ae360307b4e4899e3e19ab5a51c2f45d0838", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 165, "deletions": 6, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74452ac3234316852e4f63d48f62db44991649b2/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74452ac3234316852e4f63d48f62db44991649b2/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=74452ac3234316852e4f63d48f62db44991649b2", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Matsushita MN10300 series\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -36,6 +36,26 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"obstack.h\"\n \n+/* Global registers known to hold the value zero.\n+\n+   Normally we'd depend on CSE and combine to put zero into a\n+   register and re-use it.\n+\n+   However, on the mn10x00 processors we implicitly use the constant\n+   zero in tst instructions, so we might be able to do better by\n+   loading the value into a register in the prologue, then re-useing\n+   that register throughout the function.\n+\n+   We could perform similar optimizations for other constants, but with\n+   gcse due soon, it doesn't seem worth the effort.\n+\n+   These variables hold a rtx for a register known to hold the value\n+   zero throughout the entire function, or NULL if no register of\n+   the appropriate class has such a value throughout the life of the\n+   function.  */\n+rtx zero_dreg;\n+rtx zero_areg;\n+\n void\n asm_file_start (file)\n      FILE *file;\n@@ -339,15 +359,124 @@ can_use_return_insn ()\n \t  && !frame_pointer_needed);\n }\n \n+/* Count the number of tst insns which compare a data or address\n+   register with zero.  */\n+static void \n+count_tst_insns (dreg_countp, areg_countp)\n+     int *dreg_countp;\n+     int *areg_countp;\n+{\n+  rtx insn;\n+\n+  /* Assume no tst insns exist.  */\n+  *dreg_countp = 0;\n+  *areg_countp = 0;\n+\n+  /* If not optimizing, then quit now.  */\n+  if (!optimize)\n+    return;\n+\n+  /* Walk through all the insns.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      /* Ignore anything that is not a normal INSN.  */\n+      if (GET_CODE (insn) != INSN)\n+\tcontinue;\n+\n+      /* Ignore anything that isn't a SET.  */\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) != SET)\n+\tcontinue;\n+\n+      /* Check for a tst insn.  */\n+      if (SET_DEST (pat) == cc0_rtx\n+\t  && GET_CODE (SET_SRC (pat)) == REG)\n+\t{\n+\t  if (REGNO_REG_CLASS (REGNO (SET_SRC (pat))) == DATA_REGS)\n+\t    (*dreg_countp)++;\n+    \n+\t  if (REGNO_REG_CLASS (REGNO (SET_SRC (pat))) == ADDRESS_REGS)\n+\t    (*areg_countp)++;\n+\t}\n+\n+      /* Setting an address register to zero can also be optimized,\n+\t so count it just like a tst insn.  */\n+      if (GET_CODE (SET_DEST (pat)) == REG\n+\t  && GET_CODE (SET_SRC (pat)) == CONST_INT\n+\t  && INTVAL (SET_SRC (pat)) == 0\n+\t  && REGNO_REG_CLASS (REGNO (SET_DEST (pat))) == ADDRESS_REGS)\n+\t(*areg_countp)++;\n+    }\n+}\n+\n void\n expand_prologue ()\n {\n   unsigned int size;\n \n-  /* We have to end the current sequence so leaf_function_p will\n-     work.  We then start a new sequence to hold the prologue/epilogue.  */\n+  /* We have to end the current sequence so leaf_function_p and\n+     count_tst_insns will work.  We then start a new sequence to\n+     hold the prologue/epilogue.  */\n   end_sequence ();\n \n+  /* Determine if it is profitable to put the value zero into a register\n+     for the entire function.  If so, set ZERO_DREG and ZERO_AREG.  */\n+  if (regs_ever_live[2] || regs_ever_live[3]\n+       || regs_ever_live[6] || regs_ever_live[7]\n+       || frame_pointer_needed)\n+    {\n+      int dreg_count, areg_count;\n+\n+      /* Get a count of the number of tst insns which use address and\n+\t data registers.  */\n+      count_tst_insns (&dreg_count, &areg_count);\n+\n+      /* If there's more than one tst insn using a data register, then\n+\t this optimization is a win.  */\n+      if (dreg_count > 1\n+\t  && (!regs_ever_live[2] || !regs_ever_live[3]))\n+\t{\n+ \t  if (!regs_ever_live[2])\n+\t    {\n+\t      regs_ever_live[2] = 1;\n+\t      zero_dreg = gen_rtx (REG, SImode, 2);\n+\t    }\n+\t  else\n+\t    {\n+\t      regs_ever_live[3] = 1;\n+\t      zero_dreg = gen_rtx (REG, SImode, 3);\n+\t    }\n+\t}\n+      else\n+\tzero_dreg = NULL_RTX;\n+\n+      /* If there's more than two tst insns using an address register,\n+\t then this optimization is a win.  */\n+      if (areg_count > 2\n+\t  && (!regs_ever_live[6] || !regs_ever_live[7]))\n+\t{\n+ \t  if (!regs_ever_live[6])\n+\t    {\n+\t      regs_ever_live[6] = 1;\n+\t      zero_areg = gen_rtx (REG, SImode, 6);\n+\t    }\n+\t  else\n+\t    {\n+\t      regs_ever_live[7] = 1;\n+\t      zero_areg = gen_rtx (REG, SImode, 7);\n+\t    }\n+\t}\n+      else\n+\tzero_areg = NULL_RTX;\n+    }\n+  else\n+    {\n+      zero_dreg = NULL_RTX;\n+      zero_areg = NULL_RTX;\n+    }\n+\n   /* SIZE includes the fixed stack space needed for function calls.  */\n   size = get_frame_size () + (!leaf_function_p () ? 12 : 0);\n \n@@ -384,6 +513,13 @@ expand_prologue ()\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n \t\t\t   GEN_INT (-size)));\n+\n+  /* Load zeros into registers as needed.  */\n+  if (zero_dreg)\n+    emit_move_insn (zero_dreg, const0_rtx);\n+\n+  if (zero_areg)\n+    emit_move_insn (zero_areg, const0_rtx);\n }\n \n void\n@@ -713,14 +849,36 @@ char *\n output_tst (operand, insn)\n      rtx operand, insn;\n {\n-  \n   rtx temp;\n   int past_call = 0;\n \n+  /* If we have a data register which is known to be zero throughout\n+     the function, then use it instead of doing a search.  */\n+  if (zero_dreg && REGNO_REG_CLASS (REGNO (operand)) == DATA_REGS)\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = operand;\n+      xoperands[1] = zero_dreg;\n+\n+      output_asm_insn (\"cmp %1,%0\", xoperands);\n+      return \"\";\n+    }\n+\n+  /* Similarly for address registers.  */\n+  if (zero_areg && REGNO_REG_CLASS (REGNO (operand)) == ADDRESS_REGS)\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = operand;\n+      xoperands[1] = zero_areg;\n+\n+      output_asm_insn (\"cmp %1,%0\", xoperands);\n+      return \"\";\n+    }\n+\n   /* We can save a byte if we can find a register which has the value\n      zero in it.  */\n   temp = PREV_INSN (insn);\n-  while (temp)\n+  while (optimize && temp)\n     {\n       rtx set;\n \n@@ -759,7 +917,8 @@ output_tst (operand, insn)\n       if (REG_P (SET_DEST (set))\n \t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n \t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n-\t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) == DATA_REGS\n+\t  && (REGNO_REG_CLASS (REGNO (SET_DEST (set)))\n+\t      == REGNO_REG_CLASS (REGNO (operand)))\n \t  && REGNO (SET_DEST (set)) != REGNO (operand)\n \t  && (!past_call \n \t      || !call_used_regs[REGNO (SET_DEST (set))]))"}, {"sha": "c36c6c499f6308b955770f00730eba8255189456", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74452ac3234316852e4f63d48f62db44991649b2/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74452ac3234316852e4f63d48f62db44991649b2/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=74452ac3234316852e4f63d48f62db44991649b2", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler. \n    Matsushita MN10300 series\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -37,6 +37,10 @@ Boston, MA 02111-1307, USA.  */\n \n extern int target_flags;\n \n+/* Global registers known to hold the value zero.  */\n+extern struct rtx_def *zero_dreg;\n+extern struct rtx_def *zero_areg;\n+\n /* Macros used in the machine description to test the flags.  */\n \n /* Macro to define tables used to set the flags.\n@@ -404,8 +408,7 @@ enum reg_class {\n   OFFSET = initial_offset (FROM, TO)\n \n #define FRAME_POINTER_REQUIRED \\\n-  !(leaf_function_p ())\n-\n+  !(leaf_function_p () || current_function_outgoing_args_size == 0)\n #define CAN_DEBUG_WITHOUT_FP\n \n /* A guess for the MN10300.  */\n@@ -562,6 +565,20 @@ extern struct rtx_def *function_arg ();\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x18)),\t\\\n \t\t (FNADDR));\t\t\t\t\t\t\\\n }\n+/* A C expression whose value is RTL representing the value of the return\n+   address for the frame COUNT steps up from the current frame.\n+\n+   On the mn10300, the return address is not at a constant location\n+   due to the frame layout.  Luckily, it is at a constant offset from\n+   the argument pointer, so we define RETURN_ADDR_RTX to return a\n+   MEM using arg_pointer_rtx.  Reload will replace arg_pointer_rtx\n+   with a reference to the stack/frame pointer + an appropriate offset.  */\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAME)   \\\n+  ((COUNT == 0)                         \\\n+   ? gen_rtx (MEM, Pmode, arg_pointer_rtx) \\\n+   : (rtx) 0)\n+\n /* Emit code for a call to builtin_saveregs.  We must emit USE insns which\n    reference the 2 integer arg registers.\n    Ordinarily they are not call used registers, but they are for"}, {"sha": "13628ecf1f325b2ecc32bcff2aee6d9420e88ae4", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 306, "deletions": 77, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74452ac3234316852e4f63d48f62db44991649b2/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74452ac3234316852e4f63d48f62db44991649b2/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=74452ac3234316852e4f63d48f62db44991649b2", "patch": "@@ -1,4 +1,4 @@\n-;; GCC machine description for Matsushita MN10300\n+; GCC machine description for Matsushita MN10300\n ;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n \n ;;   Contributed by Jeff Law (law@cygnus.com).\n@@ -59,21 +59,45 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,a,d,d,a,d,a,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"0,0,I,a,d,di,ia,m,d\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,a,d,a,d,a,d,a,d,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"0,0,I,I,a,d,di,ia,m,d\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\"\n-  \"@\n-  nop\n-  nop\n-  clr %0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  movbu %1,%0\n-  movbu %1,%0\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"nop\\\";\n+    case 2:\n+      return \\\"clr %0\\\";\n+    case 3:\n+      if (zero_areg)\n+\t{\n+\t  rtx xoperands[2];\n+\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = zero_areg;\n+\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n+\t  else\n+\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      /* FALLTHROUGH */\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+      return \\\"mov %1,%0\\\";\n+    case 8:\n+    case 9:\n+      return \\\"movbu %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n ;; movhi\n \n@@ -90,21 +114,45 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,a,d,d,a,d,a,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"0,0,I,a,d,di,ia,m,d\"))]\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,a,d,a,d,a,d,a,d,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"0,0,I,I,a,d,di,ia,m,d\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\"\n-  \"@\n-  nop\n-  nop\n-  clr %0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  movhu %1,%0\n-  movhu %1,%0\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"nop\\\";\n+    case 2:\n+      return \\\"clr %0\\\";\n+    case 3:\n+      if (zero_areg)\n+\t{\n+\t  rtx xoperands[2];\n+\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = zero_areg;\n+\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n+\t  else\n+\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      /* FALLTHROUGH */\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+      return \\\"mov %1,%0\\\";\n+    case 8:\n+    case 9:\n+      return \\\"movhu %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n ;; movsi and helpers\n \n@@ -121,25 +169,50 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a,aR,x\")\n-\t(match_operand:SI 1 \"general_operand\" \"0,0,I,d,a,d,a,dim,aim,dim,aim,x,aR\"))]\n+  [(set (match_operand:SI 0 \"general_operand\"\n+\t\t\t\t\"=d,a,d,a,dm,dm,am,am,d,d,a,a,aR,x\")\n+\t(match_operand:SI 1 \"general_operand\"\n+\t\t\t\t\"0,0,I,I,d,a,d,a,dim,aim,dim,aim,x,aR\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n-  \"@\n-  nop\n-  nop\n-  clr %0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"nop\\\";\n+    case 2:\n+      return \\\"clr %0\\\";\n+    case 3:\n+      if (zero_areg)\n+\t{\n+\t  rtx xoperands[2];\n+\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = zero_areg;\n+\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n+\t  else\n+\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      /* FALLTHROUGH */\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+    case 8:\n+    case 9:\n+    case 10:\n+    case 11:\n+    case 12:\n+    case 13:\n+      return \\\"mov %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -154,17 +227,40 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=d,a,d,dam,da\")\n-\t(match_operand:SF 1 \"general_operand\" \"0,0,G,da,daim\"))]\n+  [(set (match_operand:SF 0 \"general_operand\" \"=d,a,d,a,dam,da\")\n+\t(match_operand:SF 1 \"general_operand\" \"0,0,G,G,da,daim\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n-  \"@\n-  nop\n-  nop\n-  clr %0\n-  mov %1,%0\n-  mov %1,%0\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit\")])\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"nop\\\";\n+    case 2:\n+      return \\\"clr %0\\\";\n+    case 3:\n+      if (zero_areg)\n+\t{\n+\t  rtx xoperands[2];\n+\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = zero_areg;\n+\t  if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t    output_asm_insn (\\\"sub %1,%0\\\", xoperands);\n+\t  else\n+\t    output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      /* FALLTHROUGH */\n+    case 4:\n+    case 5:\n+      return \\\"mov %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit\")])\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -179,8 +275,10 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a\")\n-\t(match_operand:DI 1 \"general_operand\" \"0,0,I,d,a,d,a,dim,aim,dim,aim\"))]\n+  [(set (match_operand:DI 0 \"general_operand\"\n+\t\t\t\t\"=d,a,d,a,dm,dm,am,am,d,d,a,a\")\n+\t(match_operand:DI 1 \"general_operand\"\n+\t\t\t\t\"0,0,I,I,d,a,d,a,dim,aim,dim,aim\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n   \"*\n@@ -198,13 +296,25 @@\n \treturn \\\"clr %L0\\;clr %H0\\\";\n \n       case 3:\n+\t  {\n+\t    rtx xoperands[2];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[1] = zero_areg ? zero_areg : operands[1];\n+\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t      output_asm_insn (\\\"sub %L1,%L0\\;mov %L0,%H0\\\", xoperands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %1,%L0\\;mov %L0,%H0\\\", xoperands);\n+\t    return \\\"\\\";\n+\t  }\n       case 4:\n       case 5:\n       case 6:\n       case 7:\n       case 8:\n       case 9:\n       case 10:\n+      case 11:\n \tif (GET_CODE (operands[1]) == CONST_INT)\n \t  {\n \t    val[0] = INTVAL (operands[1]);\n@@ -243,28 +353,75 @@\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n \t      \n \t  }\n+\telse if (GET_CODE (operands[1]) == MEM\n+\t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n+\t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n+\t  {\n+\t    rtx xoperands[2];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[1] = XEXP (operands[1], 0);\n+\n+\t    output_asm_insn (\\\"mov %1,%L0\\;mov (4,%L0),%H0\\;mov (%L0),%L0\\\",\n+\t\t\t     xoperands);\n+\t    return \\\"\\\";\n+\t  }\n \telse\n \t  {\n \t    if ((GET_CODE (operands[1]) == CONST_INT\n \t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t\t&& val[0] == 0\n-\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t      output_asm_insn (\\\"clr %L0\\\", operands);\n+\t\t&& val[0] == 0)\n+\t      {\n+\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t\t  output_asm_insn (\\\"clr %L0\\\", operands);\n+\t        else if (zero_areg)\n+\t\t  {\n+\t\t    rtx xoperands[2];\n+\n+\t\t    xoperands[0] = operands[0];\n+\t\t    xoperands[1] = zero_areg;\n+\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t\t      output_asm_insn (\\\"sub %L0,%L0\\\", xoperands);\n+\t\t    else\n+\t\t      output_asm_insn (\\\"mov %1,%L0\\\", xoperands);\n+\t\t  }\n+\t\telse\n+\t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\t      }\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n \t    if ((GET_CODE (operands[1]) == CONST_INT\n \t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t\t&& val[1] == 0\n-\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t      output_asm_insn (\\\"clr %H0\\\", operands);\n+\t\t&& val[1] == 0)\n+\t      {\n+\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t\t  output_asm_insn (\\\"clr %H0\\\", operands);\n+\t\telse if (zero_areg)\n+\t\t  {\n+\t\t    rtx xoperands[2];\n+\n+\t\t    xoperands[0] = operands[0];\n+\t\t    xoperands[1] = zero_areg;\n+\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t\t      output_asm_insn (\\\"sub %H0,%H0\\\", xoperands);\n+\t\t    else\n+\t\t      output_asm_insn (\\\"mov %1,%H0\\\", xoperands);\n+\t\t  }\n+\t\telse\n+\t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t      }\n+\t    else if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t     && val[0] == val[1])\n+\t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n \t    else\n \t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t    return \\\"\\\";\n \t  }\n     }\n }\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -279,8 +436,10 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a\")\n-\t(match_operand:DF 1 \"general_operand\" \"0,0,G,d,a,d,a,dim,aim,dim,aim\"))]\n+  [(set (match_operand:DF 0 \"general_operand\"\n+\t\t\t\t\"=d,a,d,a,dm,dm,am,am,d,d,a,a\")\n+\t(match_operand:DF 1 \"general_operand\"\n+\t\t\t\t\"0,0,G,G,d,a,d,a,dim,aim,dim,aim\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n   \"*\n@@ -298,13 +457,25 @@\n \treturn \\\"clr %L0\\;clr %H0\\\";\n \n       case 3:\n+\t  {\n+\t    rtx xoperands[2];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[1] = zero_areg ? zero_areg : operands[1];\n+\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t      output_asm_insn (\\\"sub %L1,%L0\\;mov %L0,%H0\\\", xoperands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %1,%L0\\;mov %L0,%H0\\\", xoperands);\n+\t    return \\\"\\\";\n+\t  }\n       case 4:\n       case 5:\n       case 6:\n       case 7:\n       case 8:\n       case 9:\n       case 10:\n+      case 11:\n \tif (GET_CODE (operands[1]) == CONST_INT)\n \t  {\n \t    val[0] = INTVAL (operands[1]);\n@@ -343,28 +514,75 @@\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n \t      \n \t  }\n+\telse if (GET_CODE (operands[1]) == MEM\n+\t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n+\t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n+\t  {\n+\t    rtx xoperands[2];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[1] = XEXP (operands[1], 0);\n+\n+\t    output_asm_insn (\\\"mov %1,%L0\\;mov (4,%L0),%H0\\;mov (%L0),%L0\\\",\n+\t\t\t     xoperands);\n+\t    return \\\"\\\";\n+\t  }\n \telse\n \t  {\n \t    if ((GET_CODE (operands[1]) == CONST_INT\n \t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t\t&& val[0] == 0\n-\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t      output_asm_insn (\\\"clr %L0\\\", operands);\n+\t\t&& val[0] == 0)\n+\t      {\n+\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t\t  output_asm_insn (\\\"clr %L0\\\", operands);\n+\t        else if (zero_areg)\n+\t\t  {\n+\t\t    rtx xoperands[2];\n+\n+\t\t    xoperands[0] = operands[0];\n+\t\t    xoperands[1] = zero_areg;\n+\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t\t      output_asm_insn (\\\"sub %L0,%L0\\\", xoperands);\n+\t\t    else\n+\t\t      output_asm_insn (\\\"mov %1,%L0\\\", xoperands);\n+\t\t  }\n+\t\telse\n+\t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\t      }\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n \t    if ((GET_CODE (operands[1]) == CONST_INT\n \t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t\t&& val[1] == 0\n-\t\t&& REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t      output_asm_insn (\\\"clr %H0\\\", operands);\n+\t\t&& val[1] == 0)\n+\t      {\n+\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t\t  output_asm_insn (\\\"clr %H0\\\", operands);\n+\t\telse if (zero_areg)\n+\t\t  {\n+\t\t    rtx xoperands[2];\n+\n+\t\t    xoperands[0] = operands[0];\n+\t\t    xoperands[1] = zero_areg;\n+\t\t    if (rtx_equal_p (xoperands[0], xoperands[1]))\n+\t\t      output_asm_insn (\\\"sub %H0,%H0\\\", xoperands);\n+\t\t    else\n+\t\t      output_asm_insn (\\\"mov %1,%H0\\\", xoperands);\n+\t\t  }\n+\t\telse\n+\t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t      }\n+\t    else if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t     && val[0] == val[1])\n+\t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n \t    else\n \t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t    return \\\"\\\";\n \t  }\n     }\n }\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n   \n \n \f\n@@ -428,17 +646,18 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a,da,x\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,dai,i\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a,da,x,!&da\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,da\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,dai,i,da\")))]\n   \"\"\n   \"@\n   inc %0\n   inc %0\n   inc4 %0\n   add %2,%0\n-  add %2,%0\"\n-  [(set_attr \"cc\" \"set_zn_c0,none_0hit,none_0hit,set_zn_c0,none_0hit\")])\n+  add %2,%0\n+  mov %2,%0\\;add %1,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0,none_0hit,none_0hit,set_zn_c0,none_0hit,none_0hit\")])\n \n (define_expand \"adddi3\"\n   [(set (reg:DI 0) (match_operand:DI 1 \"register_operand\" \"\"))\n@@ -1131,7 +1350,17 @@\n (define_insn \"return\"\n   [(return)]\n   \"can_use_return_insn ()\"\n-  \"rets\"\n+  \"*\n+{\n+  rtx next = next_active_insn (insn);\n+\n+  if (next\n+      && GET_CODE (next) == JUMP_INSN\n+      && GET_CODE (PATTERN (next)) == RETURN)\n+    return \\\"\\\";\n+  else\n+    return \\\"rets\\\";\n+}\"\n   [(set_attr \"cc\" \"clobber\")])\n \n ;; Try to combine consecutive updates of the stack pointer (or any"}]}