{"sha": "fb0b291494898e922f9b8def65da1702d2ae756e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwYjI5MTQ5NDg5OGU5MjJmOWI4ZGVmNjVkYTE3MDJkMmFlNzU2ZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-07-16T11:26:05Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-07-16T11:26:05Z"}, "message": "Add new object_allocator and clean-up allocator usage.\n\n\t* c-format.c (static void check_format_info_main): Use\n\tobject_allocator instead of pool_allocator.\n\t(check_format_arg): Likewise.\n\t(check_format_info_main): Likewise.\n\t* alloc-pool.h\n\t(object_allocator): Add new class.\n\t(pool_allocator::initialize): Use the underlying class.\n\t(pool_allocator::allocate): Likewise.\n\t(pool_allocator::remove): Likewise.\n\t(operator new): A new generic allocator.\n\t* asan.c (struct asan_mem_ref): Remove unused members.\n\t(asan_mem_ref_new): Replace new operator with\n\tobject_allocator::allocate.\n\t(free_mem_ref_resources): Change deallocation.\n\t* cfg.c (initialize_original_copy_tables): Replace pool_allocator\n\twith object_allocator.\n\t* config/sh/sh.c (add_constant): Replace new operator with\n\tobject_allocator::allocate.\n\t(sh_reorg): Change call to a release method.\n\t* cselib.c (struct elt_list): Remove unused members.\n\t(new_elt_list): Replace new operator with\n\tobject_allocator::allocate.\n\t(new_elt_loc_list): Likewise.\n\t(new_cselib_val): Likewise.\n\t(unchain_one_elt_list): Change delete operator with remove method.\n\t(unchain_one_elt_loc_list): Likewise.\n\t(unchain_one_value): Likewise.\n\t(cselib_finish): Release newly added static allocators.\n\t* cselib.h (struct cselib_val): Remove unused members.\n\t(struct elt_loc_list): Likewise.\n\t* df-problems.c (df_chain_alloc): Replace pool_allocator with\n\tobject_allocator.\n\t* df-scan.c (struct df_scan_problem_data): Likewise.\n\t(df_scan_alloc): Likewise.\n\t* df.h (struct dataflow): Likewise.\n\t* dse.c (struct read_info_type): Likewise.\n\t(struct insn_info_type): Likewise.\n\t(struct dse_bb_info_type): Likewise.\n\t(struct group_info): Likewise.\n\t(struct deferred_change): Likewise.\n\t(get_group_info): Likewise.\n\t(delete_dead_store_insn): Likewise.\n\t(free_read_records): Likewise.\n\t(replace_read): Likewise.\n\t(check_mem_read_rtx): Likewise.\n\t(scan_insn): Likewise.\n\t(dse_step1): Likewise.\n\t(dse_step7): Likewise.\n\t* et-forest.c (struct et_occ): Remove unused members.\n\t(et_new_occ): Use allocate instead of new operator.\n\t(et_new_tree): Likewise.\n\t(et_free_tree): Call release method explicitly.\n\t(et_free_tree_force): Likewise.\n\t(et_free_pools): Likewise.\n\t(et_split): Use remove instead of delete operator.\n\t* et-forest.h (struct et_node): Remove unused members.\n\t* ipa-cp.c: Change pool_allocator to object_allocator.\n\t* ipa-inline-analysis.c: Likewise.\n\t* ipa-profile.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-prop.h: Likewise.\n\t* ira-build.c (initiate_cost_vectors): Cast return value.\n\t(ira_allocate_cost_vector): Likewise.\n\t* ira-color.c (struct update_cost_record): Remove unused members.\n\t* lra-int.h (struct lra_live_range): Likewise.\n\t(struct lra_copy): Likewise.\n\t(struct lra_insn_reg): Likewise.\n\t* lra-lives.c (lra_live_ranges_finish): Release new static allocator.\n\t* lra.c (new_insn_reg): Replace new operator with allocate method.\n\t(free_insn_regs): Same for operator delete.\n\t(finish_insn_regs): Release new static allocator.\n\t(finish_insn_recog_data): Likewise.\n\t(lra_free_copies): Replace delete operator with remove method.\n\t(lra_create_copy): Replace operator new with allocate method.\n\t(invalidate_insn_data_regno_info): Same for remove method.\n\t* regcprop.c (struct queued_debug_insn_change): Remove unused members.\n\t(free_debug_insn_changes): Replace delete operator with remove method.\n\t(replace_oldest_value_reg): Replace operator new with allocate method.\n\t(pass_cprop_hardreg::execute): Release new static variable.\n\t* sched-deps.c (sched_deps_init): Change pool_allocator to\n\tobject_allocator.\n\t* sel-sched-ir.c: Likewise.\n\t* sel-sched-ir.h: Likewise.\n\t* stmt.c (expand_case): Likewise.\n\t(expand_sjlj_dispatch_table): Likewise.\n\t* tree-sra.c (struct access): Remove unused members.\n\t(struct assign_link): Likewise.\n\t(sra_deinitialize): Release newly added static pools.\n\t(create_access_1):Replace operator new with allocate method.\n\t(build_accesses_from_assign): Likewise.\n\t(create_artificial_child_access): Likewise.\n\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Change\n\tpool_allocator to object_allocator.\n\t* tree-ssa-pre.c: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-ssa-sccvn.c (allocate_vn_table): Likewise.\n\t* tree-ssa-strlen.c: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* var-tracking.c (onepart_pool_allocate): New function.\n\t(unshare_variable): Use the newly added function.\n\t(variable_merge_over_cur): Likewise.\n\t(variable_from_dropped): Likewise.\n\t(variable_was_changed): Likewise.\n\t(set_slot_part): Likewise.\n\t(emit_notes_for_differences_1): Likewise.\n\t(vt_finalize): Release newly added static pools.\n\nFrom-SVN: r225869", "tree": {"sha": "088c31e9845ca484c3b67a274c616d0222800086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/088c31e9845ca484c3b67a274c616d0222800086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb0b291494898e922f9b8def65da1702d2ae756e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0b291494898e922f9b8def65da1702d2ae756e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0b291494898e922f9b8def65da1702d2ae756e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0b291494898e922f9b8def65da1702d2ae756e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56b400624349b998a808ebc3ded750a517e696bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b400624349b998a808ebc3ded750a517e696bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b400624349b998a808ebc3ded750a517e696bb"}], "stats": {"total": 993, "additions": 401, "deletions": 592}, "files": [{"sha": "e945a28d26f8d3740f7e8b8a59731af9ec2639a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -1,3 +1,108 @@\n+2015-07-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* alloc-pool.h\n+\t(object_allocator): Add new class.\n+\t(pool_allocator::initialize): Use the underlying class.\n+\t(pool_allocator::allocate): Likewise.\n+\t(pool_allocator::remove): Likewise.\n+\t(operator new): A new generic allocator.\n+\t* asan.c (struct asan_mem_ref): Remove unused members.\n+\t(asan_mem_ref_new): Replace new operator with\n+\tobject_allocator::allocate.\n+\t(free_mem_ref_resources): Change deallocation.\n+\t* cfg.c (initialize_original_copy_tables): Replace pool_allocator\n+\twith object_allocator.\n+\t* config/sh/sh.c (add_constant): Replace new operator with\n+\tobject_allocator::allocate.\n+\t(sh_reorg): Change call to a release method.\n+\t* cselib.c (struct elt_list): Remove unused members.\n+\t(new_elt_list): Replace new operator with\n+\tobject_allocator::allocate.\n+\t(new_elt_loc_list): Likewise.\n+\t(new_cselib_val): Likewise.\n+\t(unchain_one_elt_list): Change delete operator with remove method.\n+\t(unchain_one_elt_loc_list): Likewise.\n+\t(unchain_one_value): Likewise.\n+\t(cselib_finish): Release newly added static allocators.\n+\t* cselib.h (struct cselib_val): Remove unused members.\n+\t(struct elt_loc_list): Likewise.\n+\t* df-problems.c (df_chain_alloc): Replace pool_allocator with\n+\tobject_allocator.\n+\t* df-scan.c (struct df_scan_problem_data): Likewise.\n+\t(df_scan_alloc): Likewise.\n+\t* df.h (struct dataflow): Likewise.\n+\t* dse.c (struct read_info_type): Likewise.\n+\t(struct insn_info_type): Likewise.\n+\t(struct dse_bb_info_type): Likewise.\n+\t(struct group_info): Likewise.\n+\t(struct deferred_change): Likewise.\n+\t(get_group_info): Likewise.\n+\t(delete_dead_store_insn): Likewise.\n+\t(free_read_records): Likewise.\n+\t(replace_read): Likewise.\n+\t(check_mem_read_rtx): Likewise.\n+\t(scan_insn): Likewise.\n+\t(dse_step1): Likewise.\n+\t(dse_step7): Likewise.\n+\t* et-forest.c (struct et_occ): Remove unused members.\n+\t(et_new_occ): Use allocate instead of new operator.\n+\t(et_new_tree): Likewise.\n+\t(et_free_tree): Call release method explicitly.\n+\t(et_free_tree_force): Likewise.\n+\t(et_free_pools): Likewise.\n+\t(et_split): Use remove instead of delete operator.\n+\t* et-forest.h (struct et_node): Remove unused members.\n+\t* ipa-cp.c: Change pool_allocator to object_allocator.\n+\t* ipa-inline-analysis.c: Likewise.\n+\t* ipa-profile.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-prop.h: Likewise.\n+\t* ira-build.c (initiate_cost_vectors): Cast return value.\n+\t(ira_allocate_cost_vector): Likewise.\n+\t* ira-color.c (struct update_cost_record): Remove unused members.\n+\t* lra-int.h (struct lra_live_range): Likewise.\n+\t(struct lra_copy): Likewise.\n+\t(struct lra_insn_reg): Likewise.\n+\t* lra-lives.c (lra_live_ranges_finish): Release new static allocator.\n+\t* lra.c (new_insn_reg): Replace new operator with allocate method.\n+\t(free_insn_regs): Same for operator delete.\n+\t(finish_insn_regs): Release new static allocator.\n+\t(finish_insn_recog_data): Likewise.\n+\t(lra_free_copies): Replace delete operator with remove method.\n+\t(lra_create_copy): Replace operator new with allocate method.\n+\t(invalidate_insn_data_regno_info): Same for remove method.\n+\t* regcprop.c (struct queued_debug_insn_change): Remove unused members.\n+\t(free_debug_insn_changes): Replace delete operator with remove method.\n+\t(replace_oldest_value_reg): Replace operator new with allocate method.\n+\t(pass_cprop_hardreg::execute): Release new static variable.\n+\t* sched-deps.c (sched_deps_init): Change pool_allocator to\n+\tobject_allocator.\n+\t* sel-sched-ir.c: Likewise.\n+\t* sel-sched-ir.h: Likewise.\n+\t* stmt.c (expand_case): Likewise.\n+\t(expand_sjlj_dispatch_table): Likewise.\n+\t* tree-sra.c (struct access): Remove unused members.\n+\t(struct assign_link): Likewise.\n+\t(sra_deinitialize): Release newly added static pools.\n+\t(create_access_1):Replace operator new with allocate method.\n+\t(build_accesses_from_assign): Likewise.\n+\t(create_artificial_child_access): Likewise.\n+\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Change\n+\tpool_allocator to object_allocator.\n+\t* tree-ssa-pre.c: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-ssa-sccvn.c (allocate_vn_table): Likewise.\n+\t* tree-ssa-strlen.c: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* var-tracking.c (onepart_pool_allocate): New function.\n+\t(unshare_variable): Use the newly added function.\n+\t(variable_merge_over_cur): Likewise.\n+\t(variable_from_dropped): Likewise.\n+\t(variable_was_changed): Likewise.\n+\t(set_slot_part): Likewise.\n+\t(emit_notes_for_differences_1): Likewise.\n+\t(vt_finalize): Release newly added static pools.\n+\n 2015-07-16  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.h (param_aa_status): Rename to ipa_param_aa_status.  Adjust"}, {"sha": "03bde635bf53e1d24366ae7f3f1c2bffce0dc687", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 110, "deletions": 77, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -25,6 +25,9 @@ extern void dump_alloc_pool_statistics (void);\n \n typedef unsigned long ALLOC_POOL_ID_TYPE;\n \n+/* Last used ID.  */\n+extern ALLOC_POOL_ID_TYPE last_id;\n+\n /* Pool allocator memory usage.  */\n struct pool_usage: public mem_usage\n {\n@@ -92,21 +95,18 @@ struct pool_usage: public mem_usage\n \n extern mem_alloc_description<pool_usage> pool_allocator_usage;\n \n-/* Type based memory pool allocator.  */\n-template <typename T>\n+/* Generic pool allocator.  */\n class pool_allocator\n {\n public:\n   /* Default constructor for pool allocator called NAME.  Each block\n-     has NUM elements.  The allocator support EXTRA_SIZE and can\n-     potentially IGNORE_TYPE_SIZE.  */\n-  pool_allocator (const char *name, size_t num, size_t extra_size = 0,\n-\t\t  bool ignore_type_size = false CXX_MEM_STAT_INFO);\n+     has NUM elements.  */\n+  pool_allocator (const char *name, size_t num, size_t size CXX_MEM_STAT_INFO);\n   ~pool_allocator ();\n   void release ();\n   void release_if_empty ();\n-  T *allocate () ATTRIBUTE_MALLOC;\n-  void remove (T *object);\n+  void *allocate () ATTRIBUTE_MALLOC;\n+  void remove (void *object);\n \n private:\n   struct allocation_pool_list\n@@ -117,7 +117,6 @@ class pool_allocator\n   /* Initialize a pool allocator.  */\n   void initialize ();\n \n-  template <typename U>\n   struct allocation_object\n   {\n     /* The ID of alloc pool which the object was allocated from.  */\n@@ -136,18 +135,18 @@ class pool_allocator\n \tint64_t align_i;\n       } u;\n \n-    static inline allocation_object<U> *\n+    static inline allocation_object*\n     get_instance (void *data_ptr)\n     {\n-      return (allocation_object<U> *)(((char *)(data_ptr))\n-\t\t\t\t      - offsetof (allocation_object<U>,\n+      return (allocation_object *)(((char *)(data_ptr))\n+\t\t\t\t      - offsetof (allocation_object,\n \t\t\t\t\t\t  u.data));\n     }\n \n-    static inline U *\n+    static inline void*\n     get_data (void *instance_ptr)\n     {\n-      return (U*)(((allocation_object<U> *) instance_ptr)->u.data);\n+      return (void*)(((allocation_object *) instance_ptr)->u.data);\n     }\n   };\n \n@@ -185,66 +184,33 @@ class pool_allocator\n   size_t m_block_size;\n   /* Size of a pool elements in bytes.  */\n   size_t m_elt_size;\n-  /* Flag if we shoul ignore size of a type.  */\n-  bool m_ignore_type_size;\n-  /* Extra size in bytes that should be allocated for each element.  */\n-  size_t m_extra_size;\n+  /* Size in bytes that should be allocated for each element.  */\n+  size_t m_size;\n   /* Flag if a pool allocator is initialized.  */\n   bool m_initialized;\n   /* Memory allocation location.  */\n   mem_location m_location;\n };\n \n-/* Last used ID.  */\n-extern ALLOC_POOL_ID_TYPE last_id;\n-\n-/* Store information about each particular alloc_pool.  Note that this\n-   will underestimate the amount the amount of storage used by a small amount:\n-   1) The overhead in a pool is not accounted for.\n-   2) The unallocated elements in a block are not accounted for.  Note\n-   that this can at worst case be one element smaller that the block\n-   size for that pool.  */\n-struct alloc_pool_descriptor\n-{\n-  /* Number of pools allocated.  */\n-  unsigned long created;\n-  /* Gross allocated storage.  */\n-  unsigned long allocated;\n-  /* Amount of currently active storage.  */\n-  unsigned long current;\n-  /* Peak amount of storage used.  */\n-  unsigned long peak;\n-  /* Size of element in the pool.  */\n-  int elt_size;\n-};\n-\n-\n-/* Hashtable mapping alloc_pool names to descriptors.  */\n-extern hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n-\n-template <typename T>\n inline\n-pool_allocator<T>::pool_allocator (const char *name, size_t num,\n-\t\t\t\t   size_t extra_size, bool ignore_type_size\n-\t\t\t\t   MEM_STAT_DECL):\n+pool_allocator::pool_allocator (const char *name, size_t num,\n+\t\t\t\tsize_t size MEM_STAT_DECL):\n   m_name (name), m_id (0), m_elts_per_block (num), m_returned_free_list (NULL),\n   m_virgin_free_list (NULL), m_virgin_elts_remaining (0), m_elts_allocated (0),\n   m_elts_free (0), m_blocks_allocated (0), m_block_list (NULL),\n-  m_block_size (0), m_ignore_type_size (ignore_type_size),\n-  m_extra_size (extra_size), m_initialized (false),\n+  m_block_size (0), m_size (size), m_initialized (false),\n   m_location (ALLOC_POOL_ORIGIN, false PASS_MEM_STAT) {}\n \n /* Initialize a pool allocator.  */\n \n-template <typename T>\n-void\n-pool_allocator<T>::initialize ()\n+inline void\n+pool_allocator::initialize ()\n {\n   gcc_checking_assert (!m_initialized);\n   m_initialized = true;\n \n   size_t header_size;\n-  size_t size = (m_ignore_type_size ? 0 : sizeof (T)) + m_extra_size;\n+  size_t size = m_size;\n \n   gcc_checking_assert (m_name);\n \n@@ -256,7 +222,7 @@ pool_allocator<T>::initialize ()\n   size = align_eight (size);\n \n   /* Add the aligned size of ID.  */\n-  size += offsetof (allocation_object<T>, u.data);\n+  size += offsetof (allocation_object, u.data);\n \n   /* Um, we can't really allocate 0 elements per block.  */\n   gcc_checking_assert (m_elts_per_block);\n@@ -289,9 +255,8 @@ pool_allocator<T>::initialize ()\n }\n \n /* Free all memory allocated for the given memory pool.  */\n-template <typename T>\n inline void\n-pool_allocator<T>::release ()\n+pool_allocator::release ()\n {\n   if (!m_initialized)\n     return;\n@@ -320,24 +285,21 @@ pool_allocator<T>::release ()\n   m_block_list = NULL;\n }\n \n-template <typename T>\n void\n-inline pool_allocator<T>::release_if_empty ()\n+inline pool_allocator::release_if_empty ()\n {\n   if (m_elts_free == m_elts_allocated)\n     release ();\n }\n \n-template <typename T>\n-inline pool_allocator<T>::~pool_allocator ()\n+inline pool_allocator::~pool_allocator ()\n {\n   release ();\n }\n \n /* Allocates one element from the pool specified.  */\n-template <typename T>\n-inline T *\n-pool_allocator<T>::allocate ()\n+inline void*\n+pool_allocator::allocate ()\n {\n   if (!m_initialized)\n     initialize ();\n@@ -353,7 +315,7 @@ pool_allocator<T>::allocate ()\n     }\n \n #ifdef ENABLE_VALGRIND_ANNOTATIONS\n-  size = m_elt_size - offsetof (allocation_object<T>, u.data);\n+  size = m_elt_size - offsetof (allocation_object, u.data);\n #endif\n \n   /* If there are no more free elements, make some more!.  */\n@@ -387,11 +349,11 @@ pool_allocator<T>::allocate ()\n       /* We now know that we can take the first elt off the virgin list and\n \t put it on the returned list.  */\n       block = m_virgin_free_list;\n-      header = (allocation_pool_list*) allocation_object<T>::get_data (block);\n+      header = (allocation_pool_list*) allocation_object::get_data (block);\n       header->next = NULL;\n #ifdef ENABLE_CHECKING\n       /* Mark the element to be free.  */\n-      ((allocation_object<T> *) block)->id = 0;\n+      ((allocation_object*) block)->id = 0;\n #endif\n       VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (header,size));\n       m_returned_free_list = header;\n@@ -408,36 +370,34 @@ pool_allocator<T>::allocate ()\n \n #ifdef ENABLE_CHECKING\n   /* Set the ID for element.  */\n-  allocation_object<T>::get_instance (header)->id = m_id;\n+  allocation_object::get_instance (header)->id = m_id;\n #endif\n   VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (header, size));\n \n-  /* Call default constructor.  */\n-  return (T *)(header);\n+  return (void *)(header);\n }\n \n /* Puts PTR back on POOL's free list.  */\n-template <typename T>\n-void\n-pool_allocator<T>::remove (T *object)\n+inline void\n+pool_allocator::remove (void *object)\n {\n   gcc_checking_assert (m_initialized);\n \n   allocation_pool_list *header;\n   int size ATTRIBUTE_UNUSED;\n-  size = m_elt_size - offsetof (allocation_object<T>, u.data);\n+  size = m_elt_size - offsetof (allocation_object, u.data);\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (object\n \t      /* Check if we free more than we allocated, which is Bad (TM).  */\n \t      && m_elts_free < m_elts_allocated\n \t      /* Check whether the PTR was allocated from POOL.  */\n-\t      && m_id == allocation_object<T>::get_instance (object)->id);\n+\t      && m_id == allocation_object::get_instance (object)->id);\n \n   memset (object, 0xaf, size);\n \n   /* Mark the element to be free.  */\n-  allocation_object<T>::get_instance (object)->id = 0;\n+  allocation_object::get_instance (object)->id = 0;\n #endif\n \n   header = (allocation_pool_list*) object;\n@@ -452,4 +412,77 @@ pool_allocator<T>::remove (T *object)\n     }\n }\n \n+/* Type based memory pool allocator.  */\n+template <typename T>\n+class object_allocator\n+{\n+public:\n+  /* Default constructor for pool allocator called NAME.  Each block\n+     has NUM elements.  */\n+  object_allocator (const char *name, size_t num CXX_MEM_STAT_INFO):\n+    m_allocator (name, num, sizeof (T) PASS_MEM_STAT) {}\n+\n+  inline void\n+  release ()\n+  {\n+    m_allocator.release ();\n+  }\n+\n+  inline void release_if_empty ()\n+  {\n+    m_allocator.release_if_empty ();\n+  }\n+\n+  inline T *\n+  allocate () ATTRIBUTE_MALLOC\n+  {\n+    return ::new (m_allocator.allocate ()) T ();\n+  }\n+\n+  inline void\n+  remove (T *object)\n+  {\n+    /* Call destructor.  */\n+    object->~T ();\n+\n+    m_allocator.remove (object);\n+  }\n+\n+private:\n+  pool_allocator m_allocator;\n+};\n+\n+/* Store information about each particular alloc_pool.  Note that this\n+   will underestimate the amount the amount of storage used by a small amount:\n+   1) The overhead in a pool is not accounted for.\n+   2) The unallocated elements in a block are not accounted for.  Note\n+   that this can at worst case be one element smaller that the block\n+   size for that pool.  */\n+struct alloc_pool_descriptor\n+{\n+  /* Number of pools allocated.  */\n+  unsigned long created;\n+  /* Gross allocated storage.  */\n+  unsigned long allocated;\n+  /* Amount of currently active storage.  */\n+  unsigned long current;\n+  /* Peak amount of storage used.  */\n+  unsigned long peak;\n+  /* Size of element in the pool.  */\n+  int elt_size;\n+};\n+\n+/* Helper for classes that do not provide default ctor.  */\n+\n+template <typename T>\n+inline void *\n+operator new (size_t, object_allocator<T> &a)\n+{\n+  return a.allocate ();\n+}\n+\n+/* Hashtable mapping alloc_pool names to descriptors.  */\n+extern hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n+\n+\n #endif"}, {"sha": "4f5adaa60a114c4e1d5332fe57c87e1a64f02b52", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -348,24 +348,9 @@ struct asan_mem_ref\n \n   /* The size of the access.  */\n   HOST_WIDE_INT access_size;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((asan_mem_ref *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<asan_mem_ref> pool;\n };\n \n-pool_allocator<asan_mem_ref> asan_mem_ref::pool (\"asan_mem_ref\", 10);\n+object_allocator <asan_mem_ref> asan_mem_ref_pool (\"asan_mem_ref\", 10);\n \n /* Initializes an instance of asan_mem_ref.  */\n \n@@ -385,7 +370,7 @@ asan_mem_ref_init (asan_mem_ref *ref, tree start, HOST_WIDE_INT access_size)\n static asan_mem_ref*\n asan_mem_ref_new (tree start, HOST_WIDE_INT access_size)\n {\n-  asan_mem_ref *ref = new asan_mem_ref;\n+  asan_mem_ref *ref = asan_mem_ref_pool.allocate ();\n \n   asan_mem_ref_init (ref, start, access_size);\n   return ref;\n@@ -473,7 +458,7 @@ free_mem_ref_resources ()\n   delete asan_mem_ref_ht;\n   asan_mem_ref_ht = NULL;\n \n-  asan_mem_ref::pool.release ();\n+  asan_mem_ref_pool.release ();\n }\n \n /* Return true iff the memory reference REF has been instrumented.  */"}, {"sha": "85582c96653d9cfc64b61d58e3211e0e1b33f6ad", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -1,3 +1,10 @@\n+2015-07-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* c-format.c (static void check_format_info_main): Use\n+\tobject_allocator instead of pool_allocator.\n+\t(check_format_arg): Likewise.\n+\t(check_format_info_main): Likewise.\n+\n 2015-07-15  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-opts.c: Remove multiline #include comment."}, {"sha": "4bc31476d5a862c4772cf220096af19052383f19", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -1025,7 +1025,7 @@ static void check_format_info_main (format_check_results *,\n \t\t\t\t    function_format_info *,\n \t\t\t\t    const char *, int, tree,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n-\t\t\t\t    pool_allocator<format_wanted_type> &);\n+\t\t\t\t    object_allocator<format_wanted_type> &);\n \n static void init_dollar_format_checking (int, tree);\n static int maybe_read_dollar_number (const char **, int,\n@@ -1687,7 +1687,8 @@ check_format_arg (void *ctx, tree format_tree,\n      will decrement it if it finds there are extra arguments, but this way\n      need not adjust it for every return.  */\n   res->number_other++;\n-  pool_allocator <format_wanted_type> fwt_pool (\"format_wanted_type pool\", 10);\n+  object_allocator <format_wanted_type> fwt_pool (\"format_wanted_type pool\",\n+\t\t\t\t\t\t  10);\n   check_format_info_main (res, info, format_chars, format_length,\n \t\t\t  params, arg_num, fwt_pool);\n }\n@@ -1705,7 +1706,7 @@ check_format_info_main (format_check_results *res,\n \t\t\tfunction_format_info *info, const char *format_chars,\n \t\t\tint format_length, tree params,\n \t\t\tunsigned HOST_WIDE_INT arg_num,\n-\t\t\tpool_allocator<format_wanted_type> &fwt_pool)\n+\t\t\tobject_allocator <format_wanted_type> &fwt_pool)\n {\n   const char *orig_format_chars = format_chars;\n   tree first_fillin_param = params;"}, {"sha": "c99849265cf1d34a775a8ad790481c2f1c4610db", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -1044,15 +1044,14 @@ static hash_table<bb_copy_hasher> *bb_copy;\n \n /* And between loops and copies.  */\n static hash_table<bb_copy_hasher> *loop_copy;\n-static pool_allocator<htab_bb_copy_original_entry> *original_copy_bb_pool;\n+static object_allocator<htab_bb_copy_original_entry> *original_copy_bb_pool;\n \n /* Initialize the data structures to maintain mapping between blocks\n    and its copies.  */\n void\n initialize_original_copy_tables (void)\n {\n-\n-  original_copy_bb_pool = new pool_allocator<htab_bb_copy_original_entry>\n+  original_copy_bb_pool = new object_allocator<htab_bb_copy_original_entry>\n     (\"original_copy\", 10);\n   bb_original = new hash_table<bb_copy_hasher> (10);\n   bb_copy = new hash_table<bb_copy_hasher> (10);"}, {"sha": "fe4cf4d64b8ba48aadfc6961a9de63d66ac56d9b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -4652,25 +4652,9 @@ typedef struct label_ref_list_d\n {\n   rtx_code_label *label;\n   struct label_ref_list_d *next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((label_ref_list_d *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<label_ref_list_d> pool;\n-\n } *label_ref_list_t;\n \n-pool_allocator<label_ref_list_d> label_ref_list_d::pool\n+static object_allocator<label_ref_list_d> label_ref_list_d_pool\n   (\"label references list\", 30);\n \n /* The SH cannot load a large constant into a register, constants have to\n@@ -4792,7 +4776,7 @@ add_constant (rtx x, machine_mode mode, rtx last_value)\n \t\t}\n \t      if (lab && pool_window_label)\n \t\t{\n-\t\t  newref = new label_ref_list_d;\n+\t\t  newref = label_ref_list_d_pool.allocate ();\n \t\t  newref->label = pool_window_label;\n \t\t  ref = pool_vector[pool_window_last].wend;\n \t\t  newref->next = ref;\n@@ -4821,7 +4805,7 @@ add_constant (rtx x, machine_mode mode, rtx last_value)\n   pool_vector[pool_size].part_of_sequence_p = (lab == 0);\n   if (lab && pool_window_label)\n     {\n-      newref = new label_ref_list_d;\n+      newref = label_ref_list_d_pool.allocate ();\n       newref->label = pool_window_label;\n       ref = pool_vector[pool_window_last].wend;\n       newref->next = ref;\n@@ -6567,7 +6551,7 @@ sh_reorg (void)\n \t  insn = barrier;\n \t}\n     }\n-  label_ref_list_d::pool.release ();\n+  label_ref_list_d_pool.release ();\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     PUT_MODE (insn, VOIDmode);\n "}, {"sha": "214995927f54fe3c931957e47b819f9e255c9d32", "filename": "gcc/cselib.c", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -45,21 +45,6 @@ struct elt_list\n {\n   struct elt_list *next;\n   cselib_val *elt;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((elt_list *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<elt_list> pool;\n };\n \n static bool cselib_record_memory;\n@@ -261,12 +246,11 @@ static unsigned int cfa_base_preserved_regno = INVALID_REGNUM;\n    each time memory is invalidated.  */\n static cselib_val *first_containing_mem = &dummy_val;\n \n-pool_allocator<elt_list> elt_list::pool (\"elt_list\", 10);\n-pool_allocator<elt_loc_list> elt_loc_list::pool (\"elt_loc_list\", 10);\n-pool_allocator<cselib_val> cselib_val::pool (\"cselib_val_list\", 10);\n+static object_allocator<elt_list> elt_list_pool (\"elt_list\", 10);\n+static object_allocator<elt_loc_list> elt_loc_list_pool (\"elt_loc_list\", 10);\n+static object_allocator<cselib_val> cselib_val_pool (\"cselib_val_list\", 10);\n \n-static pool_allocator<rtx_def> value_pool (\"value\", 100, RTX_CODE_SIZE (VALUE),\n-\t\t\t\t\t   true);\n+static pool_allocator value_pool (\"value\", 100, RTX_CODE_SIZE (VALUE));\n \n /* If nonnull, cselib will call this function before freeing useless\n    VALUEs.  A VALUE is deemed useless if its \"locs\" field is null.  */\n@@ -294,7 +278,7 @@ void (*cselib_record_sets_hook) (rtx_insn *insn, struct cselib_set *sets,\n static inline struct elt_list *\n new_elt_list (struct elt_list *next, cselib_val *elt)\n {\n-  elt_list *el = new elt_list ();\n+  elt_list *el = elt_list_pool.allocate ();\n   el->next = next;\n   el->elt = elt;\n   return el;\n@@ -378,14 +362,14 @@ new_elt_loc_list (cselib_val *val, rtx loc)\n \t}\n \n       /* Chain LOC back to VAL.  */\n-      el = new elt_loc_list;\n+      el = elt_loc_list_pool.allocate ();\n       el->loc = val->val_rtx;\n       el->setting_insn = cselib_current_insn;\n       el->next = NULL;\n       CSELIB_VAL_PTR (loc)->locs = el;\n     }\n \n-  el = new elt_loc_list;\n+  el = elt_loc_list_pool.allocate ();\n   el->loc = loc;\n   el->setting_insn = cselib_current_insn;\n   el->next = next;\n@@ -425,7 +409,7 @@ unchain_one_elt_list (struct elt_list **pl)\n   struct elt_list *l = *pl;\n \n   *pl = l->next;\n-  delete l;\n+  elt_list_pool.remove (l);\n }\n \n /* Likewise for elt_loc_lists.  */\n@@ -436,7 +420,7 @@ unchain_one_elt_loc_list (struct elt_loc_list **pl)\n   struct elt_loc_list *l = *pl;\n \n   *pl = l->next;\n-  delete l;\n+  elt_loc_list_pool.remove (l);\n }\n \n /* Likewise for cselib_vals.  This also frees the addr_list associated with\n@@ -448,7 +432,7 @@ unchain_one_value (cselib_val *v)\n   while (v->addr_list)\n     unchain_one_elt_list (&v->addr_list);\n \n-  delete v;\n+  cselib_val_pool.remove (v);\n }\n \n /* Remove all entries from the hash table.  Also used during\n@@ -1311,7 +1295,7 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n static inline cselib_val *\n new_cselib_val (unsigned int hash, machine_mode mode, rtx x)\n {\n-  cselib_val *e = new cselib_val;\n+  cselib_val *e = cselib_val_pool.allocate ();\n \n   gcc_assert (hash);\n   gcc_assert (next_uid);\n@@ -1323,7 +1307,7 @@ new_cselib_val (unsigned int hash, machine_mode mode, rtx x)\n      precisely when we can have VALUE RTXen (when cselib is active)\n      so we don't need to put them in garbage collected memory.\n      ??? Why should a VALUE be an RTX in the first place?  */\n-  e->val_rtx = value_pool.allocate ();\n+  e->val_rtx = (rtx_def*) value_pool.allocate ();\n   memset (e->val_rtx, 0, RTX_HDR_SIZE);\n   PUT_CODE (e->val_rtx, VALUE);\n   PUT_MODE (e->val_rtx, mode);\n@@ -2775,9 +2759,9 @@ cselib_finish (void)\n   cselib_any_perm_equivs = false;\n   cfa_base_preserved_val = NULL;\n   cfa_base_preserved_regno = INVALID_REGNUM;\n-  elt_list::pool.release ();\n-  elt_loc_list::pool.release ();\n-  cselib_val::pool.release ();\n+  elt_list_pool.release ();\n+  elt_loc_list_pool.release ();\n+  cselib_val_pool.release ();\n   value_pool.release ();\n   cselib_clear_table ();\n   delete cselib_hash_table;"}, {"sha": "1a278d473da6f3c1989141100354f6baa5670b41", "filename": "gcc/cselib.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -41,21 +41,6 @@ struct cselib_val\n   struct elt_list *addr_list;\n \n   struct cselib_val *next_containing_mem;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((cselib_val *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<cselib_val> pool;\n };\n \n /* A list of rtl expressions that hold the same value.  */\n@@ -66,21 +51,6 @@ struct elt_loc_list {\n   rtx loc;\n   /* The insn that made the equivalence.  */\n   rtx_insn *setting_insn;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((elt_loc_list *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<elt_loc_list> pool;\n };\n \n /* Describe a single set that is part of an insn.  */"}, {"sha": "d4b5d76662e8c86e5244421badc78609ba64b138", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -1997,7 +1997,7 @@ static void\n df_chain_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   df_chain_remove_problem ();\n-  df_chain->block_pool = new pool_allocator<df_link> (\"df_chain_block pool\",\n+  df_chain->block_pool = new object_allocator<df_link> (\"df_chain_block pool\",\n \t\t\t\t\t\t      50);\n   df_chain->optional_p = true;\n }"}, {"sha": "93c2eae3e0228518003f924d76cbd08aba86fae8", "filename": "gcc/df-scan.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -138,12 +138,12 @@ static const unsigned int copy_all = copy_defs | copy_uses | copy_eq_uses\n /* Problem data for the scanning dataflow function.  */\n struct df_scan_problem_data\n {\n-  pool_allocator<df_base_ref> *ref_base_pool;\n-  pool_allocator<df_artificial_ref> *ref_artificial_pool;\n-  pool_allocator<df_regular_ref> *ref_regular_pool;\n-  pool_allocator<df_insn_info> *insn_pool;\n-  pool_allocator<df_reg_info> *reg_pool;\n-  pool_allocator<df_mw_hardreg> *mw_reg_pool;\n+  object_allocator<df_base_ref> *ref_base_pool;\n+  object_allocator<df_artificial_ref> *ref_artificial_pool;\n+  object_allocator<df_regular_ref> *ref_regular_pool;\n+  object_allocator<df_insn_info> *insn_pool;\n+  object_allocator<df_reg_info> *reg_pool;\n+  object_allocator<df_mw_hardreg> *mw_reg_pool;\n \n   bitmap_obstack reg_bitmaps;\n   bitmap_obstack insn_bitmaps;\n@@ -252,17 +252,17 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df_scan->problem_data = problem_data;\n   df_scan->computed = true;\n \n-  problem_data->ref_base_pool = new pool_allocator<df_base_ref>\n+  problem_data->ref_base_pool = new object_allocator<df_base_ref>\n     (\"df_scan ref base\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n-  problem_data->ref_artificial_pool = new pool_allocator<df_artificial_ref>\n+  problem_data->ref_artificial_pool = new object_allocator<df_artificial_ref>\n     (\"df_scan ref artificial\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n-  problem_data->ref_regular_pool = new pool_allocator<df_regular_ref>\n+  problem_data->ref_regular_pool = new object_allocator<df_regular_ref>\n     (\"df_scan ref regular\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n-  problem_data->insn_pool = new pool_allocator<df_insn_info>\n+  problem_data->insn_pool = new object_allocator<df_insn_info>\n     (\"df_scan insn\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n-  problem_data->reg_pool = new pool_allocator<df_reg_info>\n+  problem_data->reg_pool = new object_allocator<df_reg_info>\n     (\"df_scan reg\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n-  problem_data->mw_reg_pool = new pool_allocator<df_mw_hardreg>\n+  problem_data->mw_reg_pool = new object_allocator<df_mw_hardreg>\n     (\"df_scan mw_reg\", SCAN_PROBLEM_DATA_BLOCK_SIZE / 16);\n \n   bitmap_obstack_initialize (&problem_data->reg_bitmaps);"}, {"sha": "44e5fdb37a91f23ade14ef9c02d3ad8951053538", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -294,7 +294,7 @@ struct dataflow\n   unsigned int block_info_size;\n \n   /* The pool to allocate the block_info from. */\n-  pool_allocator<df_link> *block_pool;\n+  object_allocator<df_link> *block_pool;\n \n   /* The lr and live problems have their transfer functions recomputed\n      only if necessary.  This is possible for them because, the"}, {"sha": "ff26fc0cb05d246f6784938cb939778c7a9a41e9", "filename": "gcc/dse.c", "status": "modified", "additions": 27, "deletions": 97, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -308,10 +308,10 @@ lowpart_bitmask (int n)\n }\n \n typedef struct store_info *store_info_t;\n-static pool_allocator<store_info> cse_store_info_pool (\"cse_store_info_pool\",\n+static object_allocator<store_info> cse_store_info_pool (\"cse_store_info_pool\",\n \t\t\t\t\t\t       100);\n \n-static pool_allocator<store_info> rtx_store_info_pool (\"rtx_store_info_pool\",\n+static object_allocator<store_info> rtx_store_info_pool (\"rtx_store_info_pool\",\n \t\t\t\t\t\t       100);\n \n /* This structure holds information about a load.  These are only\n@@ -334,25 +334,11 @@ struct read_info_type\n \n   /* The next read_info for this insn.  */\n   struct read_info_type *next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((read_info_type *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<read_info_type> pool;\n };\n typedef struct read_info_type *read_info_t;\n \n-pool_allocator<read_info_type> read_info_type::pool (\"read_info_pool\", 100);\n+static object_allocator<read_info_type> read_info_type_pool\n+  (\"read_info_pool\", 100);\n \n /* One of these records is created for each insn.  */\n \n@@ -438,25 +424,11 @@ struct insn_info_type\n      time it is guaranteed to be correct is when the traversal starts\n      at active_local_stores.  */\n   struct insn_info_type * next_local_store;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((insn_info_type *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<insn_info_type> pool;\n };\n typedef struct insn_info_type *insn_info_t;\n \n-pool_allocator<insn_info_type> insn_info_type::pool (\"insn_info_pool\", 100);\n+static object_allocator<insn_info_type> insn_info_type_pool\n+  (\"insn_info_pool\", 100);\n \n /* The linked list of stores that are under consideration in this\n    basic block.  */\n@@ -518,25 +490,12 @@ struct dse_bb_info_type\n      to assure that shift and/or add sequences that are inserted do not\n      accidentally clobber live hard regs.  */\n   bitmap regs_live;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((dse_bb_info_type *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<dse_bb_info_type> pool;\n };\n \n typedef struct dse_bb_info_type *bb_info_t;\n-pool_allocator<dse_bb_info_type> dse_bb_info_type::pool (\"bb_info_pool\", 100);\n+\n+static object_allocator<dse_bb_info_type> dse_bb_info_type_pool\n+  (\"bb_info_pool\", 100);\n \n /* Table to hold all bb_infos.  */\n static bb_info_t *bb_table;\n@@ -604,26 +563,12 @@ struct group_info\n      care about.  */\n   int *offset_map_n, *offset_map_p;\n   int offset_map_size_n, offset_map_size_p;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((group_info *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<group_info> pool;\n };\n typedef struct group_info *group_info_t;\n typedef const struct group_info *const_group_info_t;\n \n-pool_allocator<group_info> group_info::pool (\"rtx_group_info_pool\", 100);\n+static object_allocator<group_info> group_info_pool\n+  (\"rtx_group_info_pool\", 100);\n \n /* Index into the rtx_group_vec.  */\n static int rtx_group_next_id;\n@@ -644,26 +589,11 @@ struct deferred_change\n   rtx reg;\n \n   struct deferred_change *next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((deferred_change *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<deferred_change> pool;\n };\n \n typedef struct deferred_change *deferred_change_t;\n \n-pool_allocator<deferred_change> deferred_change::pool\n+static object_allocator<deferred_change> deferred_change_pool\n   (\"deferred_change_pool\", 10);\n \n static deferred_change_t deferred_change_list = NULL;\n@@ -769,7 +699,7 @@ get_group_info (rtx base)\n     {\n       if (!clear_alias_group)\n \t{\n-\t  clear_alias_group = gi = new group_info;\n+\t  clear_alias_group = gi = group_info_pool.allocate ();\n \t  memset (gi, 0, sizeof (struct group_info));\n \t  gi->id = rtx_group_next_id++;\n \t  gi->store1_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n@@ -791,7 +721,7 @@ get_group_info (rtx base)\n \n   if (gi == NULL)\n     {\n-      *slot = gi = new group_info;\n+      *slot = gi = group_info_pool.allocate ();\n       gi->rtx_base = base;\n       gi->id = rtx_group_next_id++;\n       gi->base_mem = gen_rtx_MEM (BLKmode, base);\n@@ -1027,7 +957,7 @@ delete_dead_store_insn (insn_info_t insn_info)\n   while (read_info)\n     {\n       read_info_t next = read_info->next;\n-      delete read_info;\n+      read_info_type_pool.remove (read_info);\n       read_info = next;\n     }\n   insn_info->read_rec = NULL;\n@@ -1151,7 +1081,7 @@ free_read_records (bb_info_t bb_info)\n       read_info_t next = (*ptr)->next;\n       if ((*ptr)->alias_set == 0)\n         {\n-\t  delete *ptr;\n+\t  read_info_type_pool.remove (*ptr);\n           *ptr = next;\n         }\n       else\n@@ -2099,7 +2029,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \n   if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n-      deferred_change_t change = new deferred_change;\n+      deferred_change_t change = deferred_change_pool.allocate ();\n \n       /* Insert this right before the store insn where it will be safe\n \t from later insns that might change it before the read.  */\n@@ -2137,7 +2067,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n       /* Get rid of the read_info, from the point of view of the\n \t rest of dse, play like this read never happened.  */\n       read_insn->read_rec = read_info->next;\n-      delete read_info;\n+      read_info_type_pool.remove (read_info);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \" -- replaced the loaded MEM with \");\n@@ -2203,7 +2133,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n   else\n     width = GET_MODE_SIZE (GET_MODE (mem));\n \n-  read_info = new read_info_type;\n+  read_info = read_info_type_pool.allocate ();\n   read_info->group_id = group_id;\n   read_info->mem = mem;\n   read_info->alias_set = spill_alias_set;\n@@ -2519,7 +2449,7 @@ static void\n scan_insn (bb_info_t bb_info, rtx_insn *insn)\n {\n   rtx body;\n-  insn_info_type *insn_info = new insn_info_type;\n+  insn_info_type *insn_info = insn_info_type_pool.allocate ();\n   int mems_found = 0;\n   memset (insn_info, 0, sizeof (struct insn_info_type));\n \n@@ -2778,7 +2708,7 @@ dse_step1 (void)\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n       insn_info_t ptr;\n-      bb_info_t bb_info = new dse_bb_info_type;\n+      bb_info_t bb_info = dse_bb_info_type_pool.allocate ();\n \n       memset (bb_info, 0, sizeof (dse_bb_info_type));\n       bitmap_set_bit (all_blocks, bb->index);\n@@ -2855,7 +2785,7 @@ dse_step1 (void)\n \t      /* There is no reason to validate this change.  That was\n \t\t done earlier.  */\n \t      *deferred_change_list->loc = deferred_change_list->reg;\n-\t      delete deferred_change_list;\n+\t      deferred_change_pool.remove (deferred_change_list);\n \t      deferred_change_list = next;\n \t    }\n \n@@ -3740,11 +3670,11 @@ dse_step7 (void)\n   BITMAP_FREE (scratch);\n \n   rtx_store_info_pool.release ();\n-  read_info_type::pool.release ();\n-  insn_info_type::pool.release ();\n-  dse_bb_info_type::pool.release ();\n-  group_info::pool.release ();\n-  deferred_change::pool.release ();\n+  read_info_type_pool.release ();\n+  insn_info_type_pool.release ();\n+  dse_bb_info_type_pool.release ();\n+  group_info_pool.release ();\n+  deferred_change_pool.release ();\n }\n \n "}, {"sha": "1931285158a6cc7d0bd6cdfa76992c325f06f6df", "filename": "gcc/et-forest.c", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -52,26 +52,10 @@ struct et_occ\n \t\t\t\t   on the path to the root.  */\n   struct et_occ *min_occ;\t/* The occurrence in the subtree with the minimal\n \t\t\t\t   depth.  */\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((et_occ *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<et_occ> pool;\n-\n };\n \n-pool_allocator<et_node> et_node::pool (\"et_nodes pool\", 300);\n-pool_allocator<et_occ> et_occ::pool (\"et_occ pool\", 300);\n+static object_allocator<et_node> et_nodes (\"et_nodes pool\", 300);\n+static object_allocator<et_occ> et_occurrences (\"et_occ pool\", 300);\n \n /* Changes depth of OCC to D.  */\n \n@@ -458,7 +442,7 @@ et_splay (struct et_occ *occ)\n static struct et_occ *\n et_new_occ (struct et_node *node)\n {\n-  et_occ *nw = new et_occ;\n+  et_occ *nw = et_occurrences.allocate ();\n \n   nw->of = node;\n   nw->parent = NULL;\n@@ -477,9 +461,7 @@ et_new_occ (struct et_node *node)\n struct et_node *\n et_new_tree (void *data)\n {\n-  struct et_node *nw;\n-\n-  nw = new et_node;\n+  et_node *nw = et_nodes.allocate ();\n \n   nw->data = data;\n   nw->father = NULL;\n@@ -504,28 +486,28 @@ et_free_tree (struct et_node *t)\n   if (t->father)\n     et_split (t);\n \n-  delete t->rightmost_occ;\n-  delete t;\n+  et_occurrences.remove (t->rightmost_occ);\n+  et_nodes.remove (t);\n }\n \n /* Releases et tree T without maintaining other nodes.  */\n \n void\n et_free_tree_force (struct et_node *t)\n {\n-  delete t->rightmost_occ;\n+  et_occurrences.remove (t->rightmost_occ);\n   if (t->parent_occ)\n-    delete t->parent_occ;\n-  delete t;\n+    et_occurrences.remove (t->parent_occ);\n+  et_nodes.remove (t);\n }\n \n /* Release the alloc pools, if they are empty.  */\n \n void\n et_free_pools (void)\n {\n-  et_occ::pool.release_if_empty ();\n-  et_node::pool.release_if_empty ();\n+  et_occurrences.release_if_empty ();\n+  et_nodes.release_if_empty ();\n }\n \n /* Sets father of et tree T to FATHER.  */\n@@ -617,7 +599,7 @@ et_split (struct et_node *t)\n   rmost->depth = 0;\n   rmost->min = 0;\n \n-  delete p_occ;\n+  et_occurrences.remove (p_occ);\n \n   /* Update the tree.  */\n   if (father->son == t)"}, {"sha": "b507c646e33023c44d34f9147095bd59273751ab", "filename": "gcc/et-forest.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -66,21 +66,6 @@ struct et_node\n \n   struct et_occ *rightmost_occ;\t/* The rightmost occurrence.  */\n   struct et_occ *parent_occ;\t/* The occurrence of the parent node.  */\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((et_node *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<et_node> pool;\n };\n \n struct et_node *et_new_tree (void *data);"}, {"sha": "8de7e56847ef441a996a22ac0616aed5ab5d6022", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -275,16 +275,16 @@ class ipcp_param_lattices\n \n /* Allocation pools for values and their sources in ipa-cp.  */\n \n-pool_allocator<ipcp_value<tree> > ipcp_cst_values_pool\n+object_allocator<ipcp_value<tree> > ipcp_cst_values_pool\n   (\"IPA-CP constant values\", 32);\n \n-pool_allocator<ipcp_value<ipa_polymorphic_call_context> >\n+object_allocator<ipcp_value<ipa_polymorphic_call_context> >\n   ipcp_poly_ctx_values_pool (\"IPA-CP polymorphic contexts\", 32);\n \n-pool_allocator<ipcp_value_source<tree> > ipcp_sources_pool\n+object_allocator<ipcp_value_source<tree> > ipcp_sources_pool\n   (\"IPA-CP value sources\", 64);\n \n-pool_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool\n+object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool\n   (\"IPA_CP aggregate lattices\", 32);\n \n /* Maximal count found in program.  */"}, {"sha": "286335eb4742dd4c1a0356e5ea9db5f4b9e3062f", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -143,7 +143,7 @@ vec<inline_edge_summary_t> inline_edge_summary_vec;\n vec<edge_growth_cache_entry> edge_growth_cache;\n \n /* Edge predicates goes here.  */\n-static pool_allocator<predicate> edge_predicate_pool (\"edge predicates\", 10);\n+static object_allocator<predicate> edge_predicate_pool (\"edge predicates\", 10);\n \n /* Return true predicate (tautology).\n    We represent it by empty list of clauses.  */"}, {"sha": "1b929c6d8ef5fe4849042c198864059adbb6dc93", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -87,7 +87,7 @@ struct histogram_entry\n    duplicate entries.  */\n \n vec<histogram_entry *> histogram;\n-static pool_allocator<histogram_entry> histogram_pool\n+static object_allocator<histogram_entry> histogram_pool\n   (\"IPA histogram\", 10);\n \n /* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */"}, {"sha": "aa659b747e1ddc79ceef5986088aaea302f99ea1", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -94,7 +94,7 @@ struct ipa_cst_ref_desc\n \n /* Allocation pool for reference descriptions.  */\n \n-static pool_allocator<ipa_cst_ref_desc> ipa_refdesc_pool\n+static object_allocator<ipa_cst_ref_desc> ipa_refdesc_pool\n   (\"IPA-PROP ref descriptions\", 32);\n \n /* Return true if DECL_FUNCTION_SPECIFIC_OPTIMIZATION of the decl associated"}, {"sha": "103594dcdc27ccdc41d10793169393ace54dbb9e", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -650,18 +650,18 @@ void ipcp_verify_propagated_values (void);\n template <typename value>\n class ipcp_value;\n \n-extern pool_allocator<ipcp_value<tree> > ipcp_cst_values_pool;\n-extern pool_allocator<ipcp_value<ipa_polymorphic_call_context> >\n+extern object_allocator<ipcp_value<tree> > ipcp_cst_values_pool;\n+extern object_allocator<ipcp_value<ipa_polymorphic_call_context> >\n   ipcp_poly_ctx_values_pool;\n \n template <typename valtype>\n class ipcp_value_source;\n \n-extern pool_allocator<ipcp_value_source<tree> > ipcp_sources_pool;\n+extern object_allocator<ipcp_value_source<tree> > ipcp_sources_pool;\n \n class ipcp_agg_lattice;\n \n-extern pool_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool;\n+extern object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool;\n \n /* Operation to be performed for the parameter in ipa_parm_adjustment\n    below.  */"}, {"sha": "333dfb76b10693991030283d3705f88e6d8b4984", "filename": "gcc/ira-build.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -421,9 +421,9 @@ rebuild_regno_allocno_maps (void)\n \f\n \n /* Pools for allocnos, allocno live ranges and objects.  */\n-static pool_allocator<live_range> live_range_pool (\"live ranges\", 100);\n-static pool_allocator<ira_allocno> allocno_pool (\"allocnos\", 100);\n-static pool_allocator<ira_object> object_pool (\"objects\", 100);\n+static object_allocator<live_range> live_range_pool (\"live ranges\", 100);\n+static object_allocator<ira_allocno> allocno_pool (\"allocnos\", 100);\n+static object_allocator<ira_object> object_pool (\"objects\", 100);\n \n /* Vec containing references to all created allocnos.  It is a\n    container of array allocnos.  */\n@@ -1171,7 +1171,7 @@ finish_allocnos (void)\n \f\n \n /* Pools for allocno preferences.  */\n-static pool_allocator <ira_allocno_pref> pref_pool (\"prefs\", 100);\n+static object_allocator <ira_allocno_pref> pref_pool (\"prefs\", 100);\n \n /* Vec containing references to all created preferences.  It is a\n    container of array ira_prefs.  */\n@@ -1358,7 +1358,7 @@ finish_prefs (void)\n \f\n \n /* Pools for copies.  */\n-static pool_allocator<ira_allocno_copy> copy_pool (\"copies\", 100);\n+static object_allocator<ira_allocno_copy> copy_pool (\"copies\", 100);\n \n /* Vec containing references to all created copies.  It is a\n    container of array ira_copies.  */\n@@ -1617,7 +1617,7 @@ finish_copies (void)\n \f\n \n /* Pools for cost vectors.  It is defined only for allocno classes.  */\n-static pool_allocator<int> * cost_vector_pool[N_REG_CLASSES];\n+static pool_allocator *cost_vector_pool[N_REG_CLASSES];\n \n /* The function initiates work with hard register cost vectors.  It\n    creates allocation pool for each allocno class.  */\n@@ -1630,17 +1630,17 @@ initiate_cost_vectors (void)\n   for (i = 0; i < ira_allocno_classes_num; i++)\n     {\n       aclass = ira_allocno_classes[i];\n-      cost_vector_pool[aclass] = new pool_allocator<int>\n+      cost_vector_pool[aclass] = new pool_allocator\n \t(\"cost vectors\", 100,\n-\t sizeof (int) * (ira_class_hard_regs_num[aclass] - 1));\n+\t sizeof (int) * (ira_class_hard_regs_num[aclass]));\n     }\n }\n \n /* Allocate and return a cost vector VEC for ACLASS.  */\n int *\n ira_allocate_cost_vector (reg_class_t aclass)\n {\n-  return cost_vector_pool[(int) aclass]->allocate ();\n+  return (int*) cost_vector_pool[(int) aclass]->allocate ();\n }\n \n /* Free a cost vector VEC for ACLASS.  */"}, {"sha": "b2b1b7e93c37904d303a624c56330b50bd738247", "filename": "gcc/ira-color.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -106,21 +106,6 @@ struct update_cost_record\n   int divisor;\n   /* Next record for given allocno.  */\n   struct update_cost_record *next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((update_cost_record *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<update_cost_record> pool;\n };\n \n /* To decrease footprint of ira_allocno structure we store all data\n@@ -1162,7 +1147,7 @@ setup_profitable_hard_regs (void)\n    allocnos.  */\n \n /* Pool for update cost records.  */\n-static pool_allocator<update_cost_record> update_cost_record_pool\n+static object_allocator<update_cost_record> update_cost_record_pool\n   (\"update cost records\", 100);\n \n /* Return new update cost record with given params.  */"}, {"sha": "5e78604e1abee085bbde00516de646794e7d32e6", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -46,21 +46,6 @@ struct lra_live_range\n   lra_live_range_t next;\n   /* Pointer to structures with the same start.\t */\n   lra_live_range_t start_next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((lra_live_range *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<lra_live_range> pool;\n };\n \n typedef struct lra_copy *lra_copy_t;\n@@ -76,22 +61,6 @@ struct lra_copy\n   int regno1, regno2;\n   /* Next copy with correspondingly REGNO1 and REGNO2.\t*/\n   lra_copy_t regno1_next, regno2_next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((lra_copy *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<lra_copy> pool;\n-\n };\n \n /* Common info about a register (pseudo or hard register).  */\n@@ -199,21 +168,6 @@ struct lra_insn_reg\n   int regno;\n   /* Next reg info of the same insn.  */\n   struct lra_insn_reg *next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((lra_insn_reg *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<lra_insn_reg> pool;\n };\n \n /* Static part (common info for insns with the same ICODE) of LRA"}, {"sha": "e1398460a77cdac0f51bfd49af2606fe5c24b2e2", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -107,7 +107,8 @@ static sparseset unused_set, dead_set;\n static bitmap_head temp_bitmap;\n \n /* Pool for pseudo live ranges.\t */\n-pool_allocator <lra_live_range> lra_live_range::pool (\"live ranges\", 100);\n+static object_allocator<lra_live_range> lra_live_range_pool\n+  (\"live ranges\", 100);\n \n /* Free live range list LR.  */\n static void\n@@ -1374,5 +1375,5 @@ lra_live_ranges_finish (void)\n {\n   finish_live_solver ();\n   bitmap_clear (&temp_bitmap);\n-  lra_live_range::pool.release ();\n+  lra_live_range_pool.release ();\n }"}, {"sha": "8ced164f6469eb2c20670000eec69ae8b9f6e2b1", "filename": "gcc/lra.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -533,7 +533,7 @@ lra_update_dups (lra_insn_recog_data_t id, signed char *nops)\n    insns.  */\n \n /* Pools for insn reg info.  */\n-pool_allocator<lra_insn_reg> lra_insn_reg::pool (\"insn regs\", 100);\n+object_allocator<lra_insn_reg> lra_insn_reg_pool (\"insn regs\", 100);\n \n /* Create LRA insn related info about a reference to REGNO in INSN with\n    TYPE (in/out/inout), biggest reference mode MODE, flag that it is\n@@ -545,7 +545,7 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n \t      machine_mode mode,\n \t      bool subreg_p, bool early_clobber, struct lra_insn_reg *next)\n {\n-  lra_insn_reg *ir = new lra_insn_reg ();\n+  lra_insn_reg *ir = lra_insn_reg_pool.allocate ();\n   ir->type = type;\n   ir->biggest_mode = mode;\n   if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode)\n@@ -567,15 +567,15 @@ free_insn_regs (struct lra_insn_reg *ir)\n   for (; ir != NULL; ir = next_ir)\n     {\n       next_ir = ir->next;\n-      delete ir;\n+      lra_insn_reg_pool.remove (ir);\n     }\n }\n \n /* Finish pool for insn reg info.  */\n static void\n finish_insn_regs (void)\n {\n-  lra_insn_reg::pool.release ();\n+  lra_insn_reg_pool.release ();\n }\n \n \f\n@@ -745,6 +745,9 @@ free_insn_recog_data (lra_insn_recog_data_t data)\n   free (data);\n }\n \n+/* Pools for copies.  */\n+static object_allocator<lra_copy> lra_copy_pool (\"lra copies\", 100);\n+\n /* Finish LRA data about all insns.  */\n static void\n finish_insn_recog_data (void)\n@@ -756,8 +759,8 @@ finish_insn_recog_data (void)\n     if ((data = lra_insn_recog_data[i]) != NULL)\n       free_insn_recog_data (data);\n   finish_insn_regs ();\n-  lra_copy::pool.release ();\n-  lra_insn_reg::pool.release ();\n+  lra_copy_pool.release ();\n+  lra_insn_reg_pool.release ();\n   free (lra_insn_recog_data);\n }\n \n@@ -1279,9 +1282,6 @@ get_new_reg_value (void)\n   return ++last_reg_value;\n }\n \n-/* Pools for copies.  */\n-pool_allocator<lra_copy> lra_copy::pool (\"lra copies\", 100);\n-\n /* Vec referring to pseudo copies.  */\n static vec<lra_copy_t> copy_vec;\n \n@@ -1360,7 +1360,7 @@ lra_free_copies (void)\n     {\n       cp = copy_vec.pop ();\n       lra_reg_info[cp->regno1].copies = lra_reg_info[cp->regno2].copies = NULL;\n-      delete cp;\n+      lra_copy_pool.remove (cp);\n     }\n }\n \n@@ -1379,7 +1379,7 @@ lra_create_copy (int regno1, int regno2, int freq)\n       std::swap (regno1, regno2);\n       regno1_dest_p = false;\n     }\n-  cp = new lra_copy ();\n+  cp = lra_copy_pool.allocate ();\n   copy_vec.safe_push (cp);\n   cp->regno1_dest_p = regno1_dest_p;\n   cp->freq = freq;\n@@ -1548,7 +1548,7 @@ invalidate_insn_data_regno_info (lra_insn_recog_data_t data, rtx_insn *insn,\n     {\n       i = ir->regno;\n       next_ir = ir->next;\n-      delete ir;\n+      lra_insn_reg_pool.remove (ir);\n       bitmap_clear_bit (&lra_reg_info[i].insn_bitmap, uid);\n       if (i >= FIRST_PSEUDO_REGISTER && ! debug_p)\n \t{"}, {"sha": "97433f04eafcbc7ba4ef75596ba94c76793fed8a", "filename": "gcc/regcprop.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -51,21 +51,6 @@ struct queued_debug_insn_change\n   rtx_insn *insn;\n   rtx *loc;\n   rtx new_rtx;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((queued_debug_insn_change *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<queued_debug_insn_change> pool;\n };\n \n /* For each register, we have a list of registers that contain the same\n@@ -89,7 +74,7 @@ struct value_data\n   unsigned int n_debug_insn_changes;\n };\n \n-pool_allocator<queued_debug_insn_change> queued_debug_insn_change::pool\n+static object_allocator<queued_debug_insn_change> queued_debug_insn_change_pool\n   (\"debug insn changes pool\", 256);\n \n static bool skip_debug_insn_p;\n@@ -130,7 +115,7 @@ free_debug_insn_changes (struct value_data *vd, unsigned int regno)\n     {\n       next = cur->next;\n       --vd->n_debug_insn_changes;\n-      delete cur;\n+      queued_debug_insn_change_pool.remove (cur);\n     }\n   vd->e[regno].debug_insn_changes = NULL;\n }\n@@ -501,7 +486,7 @@ replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx_insn *insn,\n \t    fprintf (dump_file, \"debug_insn %u: queued replacing reg %u with %u\\n\",\n \t\t     INSN_UID (insn), REGNO (*loc), REGNO (new_rtx));\n \n-\t  change = new queued_debug_insn_change;\n+\t  change = queued_debug_insn_change_pool.allocate ();\n \t  change->next = vd->e[REGNO (new_rtx)].debug_insn_changes;\n \t  change->insn = insn;\n \t  change->loc = loc;\n@@ -1308,7 +1293,7 @@ pass_cprop_hardreg::execute (function *fun)\n \t\t}\n \t  }\n \n-      queued_debug_insn_change::pool.release ();\n+      queued_debug_insn_change_pool.release ();\n     }\n \n   sbitmap_free (visited);"}, {"sha": "3ac66e8eeba107df19a06effd8bf85c770a5c3ee", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -321,7 +321,7 @@ dep_link_is_detached_p (dep_link_t link)\n }\n \n /* Pool to hold all dependency nodes (dep_node_t).  */\n-static pool_allocator<_dep_node> *dn_pool;\n+static object_allocator<_dep_node> *dn_pool;\n \n /* Number of dep_nodes out there.  */\n static int dn_pool_diff = 0;\n@@ -362,7 +362,7 @@ delete_dep_node (dep_node_t n)\n }\n \n /* Pool to hold dependencies lists (deps_list_t).  */\n-static pool_allocator<_deps_list> *dl_pool;\n+static object_allocator<_deps_list> *dl_pool;\n \n /* Number of deps_lists out there.  */\n static int dl_pool_diff = 0;\n@@ -4058,10 +4058,10 @@ sched_deps_init (bool global_p)\n \n   if (global_p)\n     {\n-      dl_pool = new pool_allocator<_deps_list> (\"deps_list\",\n+      dl_pool = new object_allocator<_deps_list> (\"deps_list\",\n                                    /* Allocate lists for one block at a time.  */\n                                    insns_in_block);\n-      dn_pool = new pool_allocator<_dep_node> (\"dep_node\",\n+      dn_pool = new object_allocator<_dep_node> (\"dep_node\",\n                                    /* Allocate nodes for one block at a time.\n                                       We assume that average insn has\n                                       5 producers.  */"}, {"sha": "998828593e07ea0ef8ff03bc81a148bca94b87f0", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -59,7 +59,7 @@ vec<sel_region_bb_info_def>\n     sel_region_bb_info = vNULL;\n \n /* A pool for allocating all lists.  */\n-pool_allocator<_list_node> sched_lists_pool (\"sel-sched-lists\", 500);\n+object_allocator<_list_node> sched_lists_pool (\"sel-sched-lists\", 500);\n \n /* This contains information about successors for compute_av_set.  */\n struct succs_info current_succs;"}, {"sha": "09c97ab304d86a87b63e5da4047c01c5b1c0a792", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -357,7 +357,7 @@ struct _list_node\n /* _list_t functions.\n    All of _*list_* functions are used through accessor macros, thus\n    we can't move them in sel-sched-ir.c.  */\n-extern pool_allocator<_list_node> sched_lists_pool;\n+extern object_allocator<_list_node> sched_lists_pool;\n \n static inline _list_t\n _list_alloc (void)"}, {"sha": "391686c02979be7d2acf85f1ce641d099b147bd8", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -730,7 +730,8 @@ do_jump_if_equal (machine_mode mode, rtx op0, rtx op1, rtx_code_label *label,\n \n static struct case_node *\n add_case_node (struct case_node *head, tree low, tree high,\n-\t       tree label, int prob, pool_allocator<case_node> &case_node_pool)\n+\t       tree label, int prob,\n+\t       object_allocator<case_node> &case_node_pool)\n {\n   struct case_node *r;\n \n@@ -1138,7 +1139,7 @@ expand_case (gswitch *stmt)\n   struct case_node *case_list = 0;\n \n   /* A pool for case nodes.  */\n-  pool_allocator<case_node> case_node_pool (\"struct case_node pool\", 100);\n+  object_allocator<case_node> case_node_pool (\"struct case_node pool\", 100);\n \n   /* An ERROR_MARK occurs for various reasons including invalid data type.\n      ??? Can this still happen, with GIMPLE and all?  */\n@@ -1314,7 +1315,7 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n     {\n       /* Similar to expand_case, but much simpler.  */\n       struct case_node *case_list = 0;\n-      pool_allocator<case_node> case_node_pool (\"struct sjlj_case pool\",\n+      object_allocator<case_node> case_node_pool (\"struct sjlj_case pool\",\n \t\t\t\t\t\tncases);\n       tree index_expr = make_tree (index_type, dispatch_index);\n       tree minval = build_int_cst (index_type, 0);"}, {"sha": "818c29078557b50499341fcda7e5175ab5f2e75e", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -271,28 +271,13 @@ struct access\n   /* Set when we discover that this pointer is not safe to dereference in the\n      caller.  */\n   unsigned grp_not_necessarilly_dereferenced : 1;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((access *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<access> pool;\n };\n \n typedef struct access *access_p;\n \n \n /* Alloc pool for allocating access structures.  */\n-pool_allocator<struct access> access::pool (\"SRA accesses\", 16);\n+static object_allocator<struct access> access_pool (\"SRA accesses\", 16);\n \n /* A structure linking lhs and rhs accesses from an aggregate assignment.  They\n    are used to propagate subaccesses from rhs to lhs as long as they don't\n@@ -301,25 +286,10 @@ struct assign_link\n {\n   struct access *lacc, *racc;\n   struct assign_link *next;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((assign_link *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<assign_link> pool;\n };\n \n /* Alloc pool for allocating assign link structures.  */\n-pool_allocator<assign_link> assign_link::pool (\"SRA links\", 16);\n+static object_allocator<assign_link> assign_link_pool (\"SRA links\", 16);\n \n /* Base (tree) -> Vector (vec<access_p> *) map.  */\n static hash_map<tree, auto_vec<access_p> > *base_access_vec;\n@@ -706,8 +676,8 @@ sra_deinitialize (void)\n   candidates = NULL;\n   BITMAP_FREE (should_scalarize_away_bitmap);\n   BITMAP_FREE (cannot_scalarize_away_bitmap);\n-  access::pool.release ();\n-  assign_link::pool.release ();\n+  access_pool.release ();\n+  assign_link_pool.release ();\n   obstack_free (&name_obstack, NULL);\n \n   delete base_access_vec;\n@@ -859,7 +829,7 @@ mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple stmt)\n static struct access *\n create_access_1 (tree base, HOST_WIDE_INT offset, HOST_WIDE_INT size)\n {\n-  struct access *access = new struct access;\n+  struct access *access = access_pool.allocate ();\n \n   memset (access, 0, sizeof (struct access));\n   access->base = base;\n@@ -1235,7 +1205,7 @@ build_accesses_from_assign (gimple stmt)\n     {\n       struct assign_link *link;\n \n-      link = new assign_link;\n+      link = assign_link_pool.allocate ();\n       memset (link, 0, sizeof (struct assign_link));\n \n       link->lacc = lacc;\n@@ -2394,7 +2364,7 @@ create_artificial_child_access (struct access *parent, struct access *model,\n \n   gcc_assert (!model->grp_unscalarizable_region);\n \n-  struct access *access = new struct access;\n+  struct access *access = access_pool.allocate ();\n   memset (access, 0, sizeof (struct access));\n   if (!build_user_friendly_ref_for_offset (&expr, TREE_TYPE (expr), new_offset,\n \t\t\t\t\t   model->type))"}, {"sha": "028a83206718e7a767d73615ff7eb880a6fd0bb6", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -204,7 +204,7 @@ static struct\n static struct occurrence *occ_head;\n \n /* Allocation pool for getting instances of \"struct occurrence\".  */\n-static pool_allocator<occurrence> *occ_pool;\n+static object_allocator<occurrence> *occ_pool;\n \n \n \n@@ -547,7 +547,7 @@ pass_cse_reciprocals::execute (function *fun)\n   basic_block bb;\n   tree arg;\n \n-  occ_pool = new pool_allocator<occurrence>\n+  occ_pool = new object_allocator<occurrence>\n     (\"dominators for recip\", n_basic_blocks_for_fn (fun) / 3 + 1);\n \n   memset (&reciprocal_stats, 0, sizeof (reciprocal_stats));"}, {"sha": "041cb78dc4991bd21fadb39fbedef430be01ed6a", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -349,7 +349,7 @@ clear_expression_ids (void)\n   expressions.release ();\n }\n \n-static pool_allocator<pre_expr_d> pre_expr_pool (\"pre_expr nodes\", 30);\n+static object_allocator<pre_expr_d> pre_expr_pool (\"pre_expr nodes\", 30);\n \n /* Given an SSA_NAME NAME, get or create a pre_expr to represent it.  */\n \n@@ -488,7 +488,7 @@ static unsigned int get_expr_value_id (pre_expr);\n /* We can add and remove elements and entries to and from sets\n    and hash tables, so we use alloc pools for them.  */\n \n-static pool_allocator<bitmap_set> bitmap_set_pool (\"Bitmap sets\", 30);\n+static object_allocator<bitmap_set> bitmap_set_pool (\"Bitmap sets\", 30);\n static bitmap_obstack grand_bitmap_obstack;\n \n /* Set of blocks with statements that have had their EH properties changed.  */"}, {"sha": "efb813c3efaf9d2b2d16349b5cf3ba23b7f04b0d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -209,7 +209,7 @@ typedef struct operand_entry\n   unsigned int count;\n } *operand_entry_t;\n \n-static pool_allocator<operand_entry> operand_entry_pool (\"operand entry pool\",\n+static object_allocator<operand_entry> operand_entry_pool (\"operand entry pool\",\n \t\t\t\t\t\t\t 30);\n \n /* This is used to assign a unique ID to each struct operand_entry"}, {"sha": "c20f1cc94bf2518f36ef8ddd8512448a50e51a6c", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -260,8 +260,8 @@ typedef struct vn_tables_s\n   vn_phi_table_type *phis;\n   vn_reference_table_type *references;\n   struct obstack nary_obstack;\n-  pool_allocator<vn_phi_s> *phis_pool;\n-  pool_allocator<vn_reference_s> *references_pool;\n+  object_allocator<vn_phi_s> *phis_pool;\n+  object_allocator<vn_reference_s> *references_pool;\n } *vn_tables_t;\n \n \n@@ -4125,9 +4125,9 @@ allocate_vn_table (vn_tables_t table)\n   table->references = new vn_reference_table_type (23);\n \n   gcc_obstack_init (&table->nary_obstack);\n-  table->phis_pool = new pool_allocator<vn_phi_s> (\"VN phis\", 30);\n-  table->references_pool = new pool_allocator<vn_reference_s> (\"VN references\",\n-\t\t\t\t\t\t\t       30);\n+  table->phis_pool = new object_allocator<vn_phi_s> (\"VN phis\", 30);\n+  table->references_pool = new object_allocator<vn_reference_s>\n+    (\"VN references\", 30);\n }\n \n /* Free a value number table.  */"}, {"sha": "cfe4dd9b31b01b373c6acd7bd76ad97fdec633bb", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -113,7 +113,8 @@ typedef struct strinfo_struct\n } *strinfo;\n \n /* Pool for allocating strinfo_struct entries.  */\n-static pool_allocator<strinfo_struct> strinfo_pool (\"strinfo_struct pool\", 64);\n+static object_allocator<strinfo_struct> strinfo_pool (\"strinfo_struct pool\",\n+\t\t\t\t\t\t      64);\n \n /* Vector mapping positive string indexes to strinfo, for the\n    current basic block.  The first pointer in the vector is special,"}, {"sha": "c1f3c32b52616d7b4760779b04c80bc8f9a9c804", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -322,7 +322,7 @@ static varinfo_t lookup_vi_for_tree (tree);\n static inline bool type_can_have_subvars (const_tree);\n \n /* Pool of variable info structures.  */\n-static pool_allocator<variable_info> variable_info_pool\n+static object_allocator<variable_info> variable_info_pool\n   (\"Variable info pool\", 30);\n \n /* Map varinfo to final pt_solution.  */\n@@ -523,7 +523,7 @@ struct constraint\n /* List of constraints that we use to build the constraint graph from.  */\n \n static vec<constraint_t> constraints;\n-static pool_allocator<constraint> constraint_pool (\"Constraint pool\", 30);\n+static object_allocator<constraint> constraint_pool (\"Constraint pool\", 30);\n \n /* The constraint graph is represented as an array of bitmaps\n    containing successor nodes.  */"}, {"sha": "da9de28af7b6f0cb38314beae679c97a41a4087b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 27, "deletions": 80, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0b291494898e922f9b8def65da1702d2ae756e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=fb0b291494898e922f9b8def65da1702d2ae756e", "patch": "@@ -261,21 +261,6 @@ typedef struct attrs_def\n \n   /* Offset from start of DECL.  */\n   HOST_WIDE_INT offset;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((attrs_def *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<attrs_def> pool;\n } *attrs;\n \n /* Structure for chaining the locations.  */\n@@ -292,21 +277,6 @@ typedef struct location_chain_def\n \n   /* Initialized? */\n   enum var_init_status init;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((location_chain_def *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<location_chain_def> pool;\n } *location_chain;\n \n /* A vector of loc_exp_dep holds the active dependencies of a one-part\n@@ -324,21 +294,6 @@ typedef struct loc_exp_dep_s\n   /* A pointer to the pointer to this entry (head or prev's next) in\n      the doubly-linked list.  */\n   struct loc_exp_dep_s **pprev;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((loc_exp_dep_s *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<loc_exp_dep_s> pool;\n } loc_exp_dep;\n \n \n@@ -577,21 +532,6 @@ typedef struct shared_hash_def\n \n   /* Actual hash table.  */\n   variable_table_type *htab;\n-\n-  /* Pool allocation new operator.  */\n-  inline void *operator new (size_t)\n-  {\n-    return pool.allocate ();\n-  }\n-\n-  /* Delete operator utilizing pool allocation.  */\n-  inline void operator delete (void *ptr)\n-  {\n-    pool.remove ((shared_hash_def *) ptr);\n-  }\n-\n-  /* Memory allocation pool.  */\n-  static pool_allocator<shared_hash_def> pool;\n } *shared_hash;\n \n /* Structure holding the IN or OUT set for a basic block.  */\n@@ -636,28 +576,28 @@ typedef struct variable_tracking_info_def\n } *variable_tracking_info;\n \n /* Alloc pool for struct attrs_def.  */\n-pool_allocator<attrs_def> attrs_def::pool (\"attrs_def pool\", 1024);\n+object_allocator<attrs_def> attrs_def_pool (\"attrs_def pool\", 1024);\n \n /* Alloc pool for struct variable_def with MAX_VAR_PARTS entries.  */\n \n-static pool_allocator<variable_def> var_pool\n-  (\"variable_def pool\", 64,\n+static pool_allocator var_pool\n+  (\"variable_def pool\", 64, sizeof (variable_def) +\n    (MAX_VAR_PARTS - 1) * sizeof (((variable)NULL)->var_part[0]));\n \n /* Alloc pool for struct variable_def with a single var_part entry.  */\n-static pool_allocator<variable_def> valvar_pool\n-  (\"small variable_def pool\", 256);\n+static pool_allocator valvar_pool\n+  (\"small variable_def pool\", 256, sizeof (variable_def));\n \n /* Alloc pool for struct location_chain_def.  */\n-pool_allocator<location_chain_def> location_chain_def::pool\n+static object_allocator<location_chain_def> location_chain_def_pool\n   (\"location_chain_def pool\", 1024);\n \n /* Alloc pool for struct shared_hash_def.  */\n-pool_allocator<shared_hash_def> shared_hash_def::pool\n+static object_allocator<shared_hash_def> shared_hash_def_pool\n   (\"shared_hash_def pool\", 256);\n \n /* Alloc pool for struct loc_exp_dep_s for NOT_ONEPART variables.  */\n-pool_allocator<loc_exp_dep> loc_exp_dep::pool (\"loc_exp_dep pool\", 64);\n+object_allocator<loc_exp_dep> loc_exp_dep_pool (\"loc_exp_dep pool\", 64);\n \n /* Changed variables, notes will be emitted for them.  */\n static variable_table_type *changed_variables;\n@@ -1418,12 +1358,19 @@ dv_onepart_p (decl_or_value dv)\n }\n \n /* Return the variable pool to be used for a dv of type ONEPART.  */\n-static inline pool_allocator <variable_def> &\n+static inline pool_allocator &\n onepart_pool (onepart_enum_t onepart)\n {\n   return onepart ? valvar_pool : var_pool;\n }\n \n+/* Allocate a variable_def from the corresponding variable pool.  */\n+static inline variable_def *\n+onepart_pool_allocate (onepart_enum_t onepart)\n+{\n+  return (variable_def*) onepart_pool (onepart).allocate ();\n+}\n+\n /* Build a decl_or_value out of a decl.  */\n static inline decl_or_value\n dv_from_decl (tree decl)\n@@ -1778,7 +1725,7 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n   variable new_var;\n   int i;\n \n-  new_var = onepart_pool (var->onepart).allocate ();\n+  new_var = onepart_pool_allocate (var->onepart);\n   new_var->dv = var->dv;\n   new_var->refcount = 1;\n   var->refcount--;\n@@ -4056,7 +4003,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t{\n \t  if (node)\n \t    {\n-\t      dvar = onepart_pool (onepart).allocate ();\n+\t      dvar = onepart_pool_allocate (onepart);\n \t      dvar->dv = dv;\n \t      dvar->refcount = 1;\n \t      dvar->n_var_parts = 1;\n@@ -4192,7 +4139,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t\t\t\t\t\t\t  INSERT);\n \t\t  if (!*slot)\n \t\t    {\n-\t\t      variable var = onepart_pool (ONEPART_VALUE).allocate ();\n+\t\t      variable var = onepart_pool_allocate (ONEPART_VALUE);\n \t\t      var->dv = dv;\n \t\t      var->refcount = 1;\n \t\t      var->n_var_parts = 1;\n@@ -7341,7 +7288,7 @@ variable_from_dropped (decl_or_value dv, enum insert_option insert)\n \n   gcc_checking_assert (onepart == ONEPART_VALUE || onepart == ONEPART_DEXPR);\n \n-  empty_var = onepart_pool (onepart).allocate ();\n+  empty_var = onepart_pool_allocate (onepart);\n   empty_var->dv = dv;\n   empty_var->refcount = 1;\n   empty_var->n_var_parts = 0;\n@@ -7445,7 +7392,7 @@ variable_was_changed (variable var, dataflow_set *set)\n \n \t  if (!empty_var)\n \t    {\n-\t      empty_var = onepart_pool (onepart).allocate ();\n+\t      empty_var = onepart_pool_allocate (onepart);\n \t      empty_var->dv = var->dv;\n \t      empty_var->refcount = 1;\n \t      empty_var->n_var_parts = 0;\n@@ -7569,7 +7516,7 @@ set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n   if (!var)\n     {\n       /* Create new variable information.  */\n-      var = onepart_pool (onepart).allocate ();\n+      var = onepart_pool_allocate (onepart);\n       var->dv = dv;\n       var->refcount = 1;\n       var->n_var_parts = 1;\n@@ -9049,7 +8996,7 @@ emit_notes_for_differences_1 (variable_def **slot, variable_table_type *new_vars\n \n       if (!empty_var)\n \t{\n-\t  empty_var = onepart_pool (old_var->onepart).allocate ();\n+\t  empty_var = onepart_pool_allocate (old_var->onepart);\n \t  empty_var->dv = old_var->dv;\n \t  empty_var->refcount = 0;\n \t  empty_var->n_var_parts = 0;\n@@ -10266,17 +10213,17 @@ vt_finalize (void)\n   empty_shared_hash->htab = NULL;\n   delete changed_variables;\n   changed_variables = NULL;\n-  attrs_def::pool.release ();\n+  attrs_def_pool.release ();\n   var_pool.release ();\n-  location_chain_def::pool.release ();\n-  shared_hash_def::pool.release ();\n+  location_chain_def_pool.release ();\n+  shared_hash_def_pool.release ();\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       if (global_get_addr_cache)\n \tdelete global_get_addr_cache;\n       global_get_addr_cache = NULL;\n-      loc_exp_dep::pool.release ();\n+      loc_exp_dep_pool.release ();\n       valvar_pool.release ();\n       preserved_values.release ();\n       cselib_finish ();"}]}