{"sha": "e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "node_id": "C_kwDOANBUbNoAKGU1YmNiY2QwNGNmY2IyZjg2MzVlYTg0MzFmNGU3NzA2NWU0NGIwYmQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-07T14:15:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-07T14:15:50Z"}, "message": "libstdc++: Add _Float128 to_chars/from_chars support for x86, ia64 and ppc64le with glibc\n\nThe following patch adds std::{to,from}_chars support for std::float128_t\non glibc 2.26+ for {i?86,x86_64,ia64,powerpc64le}-linux.\nWhen long double is already IEEE quad, previous changes already handle\nit by using long double overloads in _Float128 overloads.\nThe powerpc64le case (with explicit or implicit -mabi=ibmlongdouble)\nis handled by using the __float128/__ieee128 entrypoints which are\nalready in the library and used for -mabi=ieeelongdouble.\nFor i?86, x86_64 and ia64 this patch adds new library entrypoints,\nmostly by enabling the code that was already there for powerpc64le-linux.\nThose use __float128 or __ieee128, the patch uses _Float128 for the\nexported overloads and internally as template parameter.  While\npowerpc64le-linux uses __sprintfieee128 and __strtoieee128,\nfor _Float128 the patch uses the glibc 2.26 strfromf128 and strtof128\nAPIs.  So that one can build gcc against older glibc and then compile\nuser programs on newer glibc, the patch uses weak references unless\ngcc is compiled against glibc 2.26+.  strfromf128 unfortunately can't\nhandle %.0Lf and %.*Le, %.*Lf, %.*Lg format strings sprintf/__sprintfieee128\nuse, we need to remove the L from those and replace * with actually\ndirectly printing the precision into the format string (i.e. it can\nhandle %.0f and %.27f (floating point type is implied from the function\nname)).\nUnlike the std::{,b}float16_t support, this one actually exports APIs\nwith std::float128_t aka _Float128 in the mangled name, because no\nstandard format is superset of it.  On the other side, e.g. on i?86/x86_64\nit doesn't have restrictions like for _Float16/__bf16 which ISAs need\nto be enabled in order to use it.\n\nThe denorm_min case in the testcase is temporarily commented out because\nof the ERANGE subnormal issue Patrick posted patch for.\n\n2022-11-07  Jakub Jelinek  <jakub@redhat.com>\n\n\t* include/std/charconv (from_chars, to_chars): Add _Float128\n\toverfloads if _GLIBCXX_HAVE_FLOAT128_MATH is defined.\n\t* config/abi/pre/gnu.ver (GLIBCXX_3.4.31): Export\n\t_ZSt8to_charsPcS_DF128_, _ZSt8to_charsPcS_DF128_St12chars_format,\n\t_ZSt8to_charsPcS_DF128_St12chars_formati and\n\t_ZSt10from_charsPKcS0_RDF128_St12chars_format.\n\t* src/c++17/floating_from_chars.cc (USE_STRTOF128_FOR_FROM_CHARS):\n\tDefine if needed.\n\t(__strtof128): Declare.\n\t(from_chars_impl): Handle _Float128.\n\t(from_chars): New _Float128 overload if USE_STRTOF128_FOR_FROM_CHARS\n\tis define.\n\t* src/c++17/floating_to_chars.cc (__strfromf128): Declare.\n\t(FLOAT128_TO_CHARS): Define even when _Float128 is supported and\n\twider than long double.\n\t(F128_type): Use _Float128 for that case.\n\t(floating_type_traits): Specialize for F128_type rather than\n\t__float128.\n\t(sprintf_ld): Add length argument.  Handle _Float128.\n\t(__floating_to_chars_shortest, __floating_to_chars_precision):\n\tPass length to sprintf_ld.\n\t(to_chars): Add _Float128 overloads for the F128_type being\n\t_Float128 cases.\n\t* testsuite/20_util/to_chars/float128_c++23.cc: New test.", "tree": {"sha": "2da2741e4c7ed8d53223586ba15443e14e1d6cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2da2741e4c7ed8d53223586ba15443e14e1d6cf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d060d8b0477ff4911f41c816281daaa24b41a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d060d8b0477ff4911f41c816281daaa24b41a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d060d8b0477ff4911f41c816281daaa24b41a13"}], "stats": {"total": 268, "additions": 259, "deletions": 9}, "files": [{"sha": "4d97ec371478f5cceaad844b3819ce8c387e3822", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "patch": "@@ -2450,6 +2450,10 @@ GLIBCXX_3.4.31 {\n     _ZSt21__to_chars_bfloat16_tPcS_fSt12chars_format;\n     _ZSt22__from_chars_float16_tPKcS0_RfSt12chars_format;\n     _ZSt23__from_chars_bfloat16_tPKcS0_RfSt12chars_format;\n+    _ZSt8to_charsPcS_DF128_;\n+    _ZSt8to_charsPcS_DF128_St12chars_format;\n+    _ZSt8to_charsPcS_DF128_St12chars_formati;\n+    _ZSt10from_charsPKcS0_RDF128_St12chars_format;\n } GLIBCXX_3.4.30;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "09163af7fc9befdddba35e56420bab2f09c6ee24", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "patch": "@@ -736,6 +736,27 @@ namespace __detail\n       __value = __val;\n     return __res;\n   }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n+  __extension__ from_chars_result\n+  from_chars(const char* __first, const char* __last, __ieee128& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept;\n+\n+  inline from_chars_result\n+  from_chars(const char* __first, const char* __last, _Float128& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept\n+  {\n+    __extension__ __ieee128 __val;\n+    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n+    if (__res.ec == errc{})\n+      __value = __val;\n+    return __res;\n+  }\n+#else\n+  from_chars_result\n+  from_chars(const char* __first, const char* __last, _Float128& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept;\n+#endif\n #endif\n \n #if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32) \\\n@@ -851,6 +872,46 @@ namespace __detail\n     return to_chars(__first, __last, static_cast<long double>(__value), __fmt,\n \t\t    __precision);\n   }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n+  __extension__ to_chars_result\n+  to_chars(char* __first, char* __last, __float128 __value) noexcept;\n+  __extension__ to_chars_result\n+  to_chars(char* __first, char* __last, __float128 __value,\n+\t   chars_format __fmt) noexcept;\n+  __extension__ to_chars_result\n+  to_chars(char* __first, char* __last, __float128 __value,\n+\t   chars_format __fmt, int __precision) noexcept;\n+\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float128 __value) noexcept\n+  {\n+    __extension__\n+    return to_chars(__first, __last, static_cast<__float128>(__value));\n+  }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float128 __value,\n+\t   chars_format __fmt) noexcept\n+  {\n+    __extension__\n+    return to_chars(__first, __last, static_cast<__float128>(__value), __fmt);\n+  }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float128 __value,\n+\t   chars_format __fmt, int __precision) noexcept\n+  {\n+    __extension__\n+    return to_chars(__first, __last, static_cast<__float128>(__value), __fmt,\n+\t\t    __precision);\n+  }\n+#else\n+  to_chars_result to_chars(char* __first, char* __last, _Float128 __value)\n+    noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, _Float128 __value,\n+\t\t\t   chars_format __fmt) noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, _Float128 __value,\n+\t\t\t   chars_format __fmt, int __precision) noexcept;\n+#endif\n #endif\n \n #if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)"}, {"sha": "11a9be68770fcdd535ab92fabdd013449a14f507", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "patch": "@@ -59,6 +59,14 @@\n #endif\n // strtold for __ieee128\n extern \"C\" __ieee128 __strtoieee128(const char*, char**);\n+#elif __FLT128_MANT_DIG__ == 113 && __LDBL_MANT_DIG__ != 113 \\\n+      && defined(__GLIBC_PREREQ)\n+#define USE_STRTOF128_FOR_FROM_CHARS 1\n+extern \"C\" _Float128 __strtof128(const char*, char**)\n+#ifndef _GLIBCXX_HAVE_FLOAT128_MATH\n+  __attribute__((__weak__))\n+#endif\n+  __asm (\"strtof128\");\n #endif\n \n #if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 \\\n@@ -618,6 +626,16 @@ namespace\n # ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n \telse if constexpr (is_same_v<T, __ieee128>)\n \t  tmpval = __strtoieee128(str, &endptr);\n+# elif defined(USE_STRTOF128_FOR_FROM_CHARS)\n+\telse if constexpr (is_same_v<T, _Float128>)\n+\t  {\n+#ifndef _GLIBCXX_HAVE_FLOAT128_MATH\n+\t    if (&__strtof128 == nullptr)\n+\t      tmpval = _Float128(std::strtold(str, &endptr);\n+\t    else\n+#endif\n+\t      tmpval = __strtof128(str, &endptr);\n+\t  }\n # endif\n #else\n \ttmpval = std::strtod(str, &endptr);\n@@ -1239,6 +1257,14 @@ from_chars(const char* first, const char* last, __ieee128& value,\n   // fast_float doesn't support IEEE binary128 format, but we can use strtold.\n   return from_chars_strtod(first, last, value, fmt);\n }\n+#elif defined(USE_STRTOF128_FOR_FROM_CHARS)\n+from_chars_result\n+from_chars(const char* first, const char* last, _Float128& value,\n+\t   chars_format fmt) noexcept\n+{\n+  // fast_float doesn't support IEEE binary128 format, but we can use strtold.\n+  return from_chars_strtod(first, last, value, fmt);\n+}\n #endif\n \n #endif // USE_LIB_FAST_FLOAT || USE_STRTOD_FOR_FROM_CHARS"}, {"sha": "d6be6465b129a91050f887a6f3c5911ddd4f0e16", "filename": "libstdc++-v3/src/c++17/floating_to_chars.cc", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc?ref=e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "patch": "@@ -43,6 +43,13 @@\n #endif\n // sprintf for __ieee128\n extern \"C\" int __sprintfieee128(char*, const char*, ...);\n+#elif __FLT128_MANT_DIG__ == 113 && __LDBL_MANT_DIG__ != 113 \\\n+      && defined(__GLIBC_PREREQ)\n+extern \"C\" int __strfromf128(char*, size_t, const char*, _Float128)\n+#ifndef _GLIBCXX_HAVE_FLOAT128_MATH\n+  __attribute__((__weak__))\n+#endif\n+  __asm (\"strfromf128\");\n #endif\n \n // This implementation crucially assumes float/double have the\n@@ -77,10 +84,11 @@ extern \"C\" int __sprintfieee128(char*, const char*, ...);\n #if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT && __FLT128_MANT_DIG__ == 113\n // Define overloads of std::to_chars for __float128.\n # define FLOAT128_TO_CHARS 1\n-#endif\n-\n-#ifdef FLOAT128_TO_CHARS\n using F128_type = __float128;\n+#elif __FLT128_MANT_DIG__ == 113 && __LDBL_MANT_DIG__ != 113 \\\n+      && defined(__GLIBC_PREREQ)\n+# define FLOAT128_TO_CHARS 1\n+using F128_type = _Float128;\n #else\n using F128_type = void;\n #endif\n@@ -252,7 +260,7 @@ namespace\n \n # ifdef FLOAT128_TO_CHARS\n   template<>\n-    struct floating_type_traits<__float128> : floating_type_traits_binary128\n+    struct floating_type_traits<F128_type> : floating_type_traits_binary128\n     { };\n # endif\n #endif\n@@ -1034,7 +1042,8 @@ namespace\n #pragma GCC diagnostic ignored \"-Wabi\"\n   template<typename T, typename... Extra>\n   inline int\n-  sprintf_ld(char* buffer, const char* format_string, T value, Extra... args)\n+  sprintf_ld(char* buffer, size_t length __attribute__((unused)),\n+\t     const char* format_string, T value, Extra... args)\n   {\n     int len;\n \n@@ -1044,10 +1053,31 @@ namespace\n       fesetround(FE_TONEAREST); // We want round-to-nearest behavior.\n #endif\n \n+#ifdef FLOAT128_TO_CHARS\n #ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n     if constexpr (is_same_v<T, __ieee128>)\n       len = __sprintfieee128(buffer, format_string, args..., value);\n     else\n+#else\n+    if constexpr (is_same_v<T, _Float128>)\n+      {\n+#ifndef _GLIBCXX_HAVE_FLOAT128_MATH\n+\tif (&__strfromf128 == nullptr)\n+\t  len = sprintf(buffer, format_string, args..., (long double)value);\n+\telse\n+#endif\n+\tif constexpr (sizeof...(args) == 0)\n+\t  len = __strfromf128(buffer, length, \"%.0f\", value);\n+\telse\n+\t  {\n+\t    // strfromf128 unfortunately doesn't allow .*\n+\t    char fmt[3 * sizeof(int) + 6];\n+\t    sprintf(fmt, \"%%.%d%c\", args..., int(format_string[4]));\n+\t    len = __strfromf128(buffer, length, fmt, value);\n+\t  }\n+      }\n+    else\n+#endif\n #endif\n     len = sprintf(buffer, format_string, args..., value);\n \n@@ -1205,8 +1235,10 @@ template<typename T>\n \t    // can avoid this if we use sprintf to write all but the last\n \t    // digit, and carefully compute and write the last digit\n \t    // ourselves.\n-\t    char buffer[expected_output_length+1];\n-\t    const int output_length = sprintf_ld(buffer, \"%.0Lf\", value);\n+\t    char buffer[expected_output_length + 1];\n+\t    const int output_length = sprintf_ld(buffer,\n+\t\t\t\t\t\t expected_output_length + 1,\n+\t\t\t\t\t\t \"%.0Lf\", value);\n \t    __glibcxx_assert(output_length == expected_output_length);\n \t    memcpy(first, buffer, output_length);\n \t    return {first + output_length, errc{}};\n@@ -1396,9 +1428,10 @@ template<typename T>\n \t  __builtin_unreachable();\n \n \t// Do the sprintf into the local buffer.\n-\tchar buffer[output_length_upper_bound+1];\n+\tchar buffer[output_length_upper_bound + 1];\n \tint output_length\n-\t  = sprintf_ld(buffer, output_specifier, value, effective_precision);\n+\t  = sprintf_ld(buffer, output_length_upper_bound + 1, output_specifier,\n+\t\t       value, effective_precision);\n \t__glibcxx_assert(output_length <= output_length_upper_bound);\n \n \tif (effective_precision > 0)\n@@ -1798,6 +1831,7 @@ to_chars(char* first, char* last, long double value, chars_format fmt,\n }\n \n #ifdef FLOAT128_TO_CHARS\n+#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n to_chars_result\n to_chars(char* first, char* last, __float128 value) noexcept\n {\n@@ -1816,6 +1850,26 @@ to_chars(char* first, char* last, __float128 value, chars_format fmt,\n {\n   return __floating_to_chars_precision(first, last, value, fmt, precision);\n }\n+#else\n+to_chars_result\n+to_chars(char* first, char* last, _Float128 value) noexcept\n+{\n+  return __floating_to_chars_shortest(first, last, value, chars_format{});\n+}\n+\n+to_chars_result\n+to_chars(char* first, char* last, _Float128 value, chars_format fmt) noexcept\n+{\n+  return __floating_to_chars_shortest(first, last, value, fmt);\n+}\n+\n+to_chars_result\n+to_chars(char* first, char* last, _Float128 value, chars_format fmt,\n+\t int precision) noexcept\n+{\n+  return __floating_to_chars_precision(first, last, value, fmt, precision);\n+}\n+#endif\n #endif\n \n // Entrypoints for 16-bit floats."}, {"sha": "4c01458e6d907637928eeb8882855792cc6687c5", "filename": "libstdc++-v3/testsuite/20_util/to_chars/float128_c++23.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Ffloat128_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Ffloat128_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Ffloat128_c%2B%2B23.cc?ref=e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do run { target c++23 } }\n+// { dg-require-effective-target ieee_floats }\n+// { dg-require-effective-target size32plus }\n+// { dg-add-options ieee }\n+\n+#include <charconv>\n+#include <stdfloat>\n+#include <limits>\n+#include <numbers>\n+#include <testsuite_hooks.h>\n+\n+#if defined(__STDCPP_FLOAT128_T__) \\\n+    && (defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128) \\\n+\t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n+void\n+test(std::chars_format fmt = std::chars_format{})\n+{\n+  std::float128_t tests[] = {\n+//    std::numeric_limits<std::float128_t>::denorm_min(),\n+    std::numeric_limits<std::float128_t>::min(),\n+    0.0f128,\n+    -42.0f128,\n+    1234.5678912345f128,\n+    std::numbers::e_v<std::float128_t>,\n+    std::numbers::log2e_v<std::float128_t>,\n+    std::numbers::log10e_v<std::float128_t>,\n+    std::numbers::pi_v<std::float128_t>,\n+    std::numbers::inv_pi_v<std::float128_t>,\n+    std::numbers::inv_sqrtpi_v<std::float128_t>,\n+    std::numbers::ln2_v<std::float128_t>,\n+    std::numbers::ln10_v<std::float128_t>,\n+    std::numbers::sqrt2_v<std::float128_t>,\n+    std::numbers::sqrt3_v<std::float128_t>,\n+    std::numbers::inv_sqrt3_v<std::float128_t>,\n+    std::numbers::egamma_v<std::float128_t>,\n+    std::numbers::phi_v<std::float128_t>,\n+    std::numeric_limits<std::float128_t>::max()\n+  };\n+  char str1[10000], str2[10000];\n+  for (auto u : tests)\n+    {\n+      auto [ptr1, ec1] = std::to_chars(str1, str1 + sizeof(str1), u, fmt);\n+      VERIFY( ec1 == std::errc() );\n+//    std::cout << i << ' ' << std::string_view (str1, ptr1) << '\\n';\n+      if (fmt == std::chars_format::fixed)\n+\t{\n+\t  auto [ptr2, ec2] = std::to_chars(str2, str2 + (ptr1 - str1), u, fmt);\n+\t  VERIFY( ec2 == std::errc() && ptr2 - str2 == ptr1 - str1 );\n+\t  auto [ptr3, ec3] = std::to_chars(str2, str2 + (ptr1 - str1 - 1), u, fmt);\n+\t  VERIFY( ec3 != std::errc() );\n+\t}\n+      std::float128_t v;\n+      auto [ptr4, ec4] = std::from_chars(str1, ptr1, v,\n+\t\t\t\t\t fmt == std::chars_format{}\n+\t\t\t\t\t ? std::chars_format::general : fmt);\n+      VERIFY( ec4 == std::errc() && ptr4 == ptr1 );\n+      VERIFY( u == v );\n+\n+      auto [ptr5, ec5] = std::to_chars(str1, str1 + sizeof(str1), u, fmt, 90);\n+      VERIFY( ec5 == std::errc() );\n+//    std::cout << i << ' ' << std::string_view (str1, ptr5) << '\\n';\n+      v = 4.0f128;\n+      auto [ptr6, ec6] = std::from_chars(str1, ptr5, v,\n+\t\t\t\t\t fmt == std::chars_format{}\n+\t\t\t\t\t ? std::chars_format::general : fmt);\n+      VERIFY( ec6 == std::errc() && ptr6 == ptr5 );\n+      if (fmt == std::chars_format::fixed && u > 0.0f128 && u < 0.000001f128)\n+\tVERIFY( v == 0.0 );\n+      else\n+\tVERIFY( u == v );\n+    }\n+}\n+#endif\n+\n+int\n+main()\n+{\n+#if defined(__STDCPP_FLOAT128_T__) \\\n+    && (defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128) \\\n+\t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n+  test();\n+  test(std::chars_format::fixed);\n+  test(std::chars_format::scientific);\n+  test(std::chars_format::general);\n+  test(std::chars_format::hex);\n+#endif\n+}"}]}