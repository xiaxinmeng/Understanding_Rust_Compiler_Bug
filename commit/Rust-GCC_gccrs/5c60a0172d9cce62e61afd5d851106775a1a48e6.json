{"sha": "5c60a0172d9cce62e61afd5d851106775a1a48e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM2MGEwMTcyZDljY2U2MmU2MWFmZDVkODUxMTA2Nzc1YTFhNDhlNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-06-01T06:55:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-06-01T06:55:47Z"}, "message": "opts.h (cl_option_state): New structure.\n\n\t* opts.h (cl_option_state): New structure.\n\t(get_option_state): Declare.\n\t* opts.c (get_option_state): New function.\n\t* toplev.c (option_affects_pch_p): New function.\n\t(default_get_pch_validity): Store the state of all options for which\n\toption_affects_pch_p returns true.\n\t(default_pch_valid_p): Check the state of those options here.\n\tOnly check target_flags separately if targetm.check_pch_target_Flags\n\tis nonnull or if TARGET_SWITCHES is defined.\n\nFrom-SVN: r100430", "tree": {"sha": "84536cfc7589dba0e2733eab222c518d135cbf94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84536cfc7589dba0e2733eab222c518d135cbf94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c60a0172d9cce62e61afd5d851106775a1a48e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c60a0172d9cce62e61afd5d851106775a1a48e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c60a0172d9cce62e61afd5d851106775a1a48e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c60a0172d9cce62e61afd5d851106775a1a48e6/comments", "author": null, "committer": null, "parents": [{"sha": "b76f4c1c79e7a5e317d505ac09de3614c8179857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b76f4c1c79e7a5e317d505ac09de3614c8179857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b76f4c1c79e7a5e317d505ac09de3614c8179857"}], "stats": {"total": 106, "additions": 95, "deletions": 11}, "files": [{"sha": "045c42a969fb6d65ae5ffa995541806f7ed60c8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c60a0172d9cce62e61afd5d851106775a1a48e6", "patch": "@@ -1,3 +1,15 @@\n+2005-06-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* opts.h (cl_option_state): New structure.\n+\t(get_option_state): Declare.\n+\t* opts.c (get_option_state): New function.\n+\t* toplev.c (option_affects_pch_p): New function.\n+\t(default_get_pch_validity): Store the state of all options for which\n+\toption_affects_pch_p returns true.\n+\t(default_pch_valid_p): Check the state of those options here.\n+\tOnly check target_flags separately if targetm.check_pch_target_Flags\n+\tis nonnull or if TARGET_SWITCHES is defined.\n+\n 2005-06-01  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips-protos.h (mips_use_ins_ext_p): Remove parameter"}, {"sha": "6e73561496d18de024ffa9557a308fd4ff0368ad", "filename": "gcc/opts.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=5c60a0172d9cce62e61afd5d851106775a1a48e6", "patch": "@@ -1442,3 +1442,37 @@ option_enabled (int opt_idx)\n       }\n   return -1;\n }\n+\n+/* Fill STATE with the current state of option OPTION.  Return true if\n+   there is some state to store.  */\n+\n+bool\n+get_option_state (int option, struct cl_option_state *state)\n+{\n+  if (cl_options[option].flag_var == 0)\n+    return false;\n+\n+  switch (cl_options[option].var_type)\n+    {\n+    case CLVC_BOOLEAN:\n+    case CLVC_EQUAL:\n+      state->data = cl_options[option].flag_var;\n+      state->size = sizeof (int);\n+      break;\n+\n+    case CLVC_BIT_CLEAR:\n+    case CLVC_BIT_SET:\n+      state->ch = option_enabled (option);\n+      state->data = &state->ch;\n+      state->size = 1;\n+      break;\n+\n+    case CLVC_STRING:\n+      state->data = *(const char **) cl_options[option].flag_var;\n+      if (state->data == 0)\n+\tstate->data = \"\";\n+      state->size = strlen (state->data) + 1;\n+      break;\n+    }\n+  return true;\n+}"}, {"sha": "962b1caeb661394904381d1ca6321c6bd673785e", "filename": "gcc/opts.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=5c60a0172d9cce62e61afd5d851106775a1a48e6", "patch": "@@ -52,6 +52,14 @@ struct cl_option\n   int var_value;\n };\n \n+/* Records that the state of an option consists of SIZE bytes starting\n+   at DATA.  DATA might point to CH in some cases.  */\n+struct cl_option_state {\n+  const void *data;\n+  size_t size;\n+  char ch;\n+};\n+\n extern const struct cl_option cl_options[];\n extern const unsigned int cl_options_count;\n extern const char *const lang_names[];\n@@ -77,6 +85,7 @@ extern unsigned num_in_fnames;\n \n extern void decode_options (unsigned int argc, const char **argv);\n extern int option_enabled (int opt_idx);\n+extern bool get_option_state (int, struct cl_option_state *);\n extern void print_filtered_help (unsigned int);\n \n #endif"}, {"sha": "550574fd15408da49a9e9901c2a0bc2f3501d516", "filename": "gcc/toplev.c", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c60a0172d9cce62e61afd5d851106775a1a48e6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5c60a0172d9cce62e61afd5d851106775a1a48e6", "patch": "@@ -1434,16 +1434,30 @@ init_asm_output (const char *name)\n     }\n }\n \n+/* Return true if the state of option OPTION should be stored in PCH files\n+   and checked by default_pch_valid_p.  Store the option's current state\n+   in STATE if so.  */\n+\n+static inline bool\n+option_affects_pch_p (int option, struct cl_option_state *state)\n+{\n+  if ((cl_options[option].flags & CL_TARGET) == 0)\n+    return false;\n+  if (cl_options[option].flag_var == &target_flags)\n+    if (targetm.check_pch_target_flags)\n+      return false;\n+  return get_option_state (option, state);\n+}\n+\n /* Default version of get_pch_validity.\n    By default, every flag difference is fatal; that will be mostly right for\n    most targets, but completely right for very few.  */\n \n void *\n default_get_pch_validity (size_t *len)\n {\n-#ifdef TARGET_OPTIONS\n+  struct cl_option_state state;\n   size_t i;\n-#endif\n   char *result, *r;\n \n   *len = sizeof (target_flags) + 2;\n@@ -1455,6 +1469,9 @@ default_get_pch_validity (size_t *len)\n \t*len += strlen (*target_options[i].variable);\n     }\n #endif\n+  for (i = 0; i < cl_options_count; i++)\n+    if (option_affects_pch_p (i, &state))\n+      *len += state.size;\n \n   result = r = xmalloc (*len);\n   r[0] = flag_pic;\n@@ -1475,6 +1492,12 @@ default_get_pch_validity (size_t *len)\n       r += l;\n     }\n #endif\n+  for (i = 0; i < cl_options_count; i++)\n+    if (option_affects_pch_p (i, &state))\n+      {\n+\tmemcpy (r, state.data, state.size);\n+\tr += state.size;\n+      }\n \n   return result;\n }\n@@ -1484,6 +1507,7 @@ default_get_pch_validity (size_t *len)\n const char *\n default_pch_valid_p (const void *data_p, size_t len)\n {\n+  struct cl_option_state state;\n   const char *data = (const char *)data_p;\n   const char *flag_that_differs = NULL;\n   size_t i;\n@@ -1504,9 +1528,9 @@ default_pch_valid_p (const void *data_p, size_t len)\n       if (r != NULL)\n \treturn r;\n     }\n+#ifdef TARGET_SWITCHES\n   else if (tf != target_flags)\n     {\n-#ifdef TARGET_SWITCHES\n       for (i = 0; i < ARRAY_SIZE (target_switches); i++)\n \t{\n \t  int bits;\n@@ -1520,16 +1544,9 @@ default_pch_valid_p (const void *data_p, size_t len)\n \t      goto make_message;\n \t    }\n \t}\n-#endif\n-      for (i = 0; i < cl_options_count; i++)\n-\tif (cl_options[i].flag_var == &target_flags\n-\t    && (cl_options[i].var_value & (target_flags ^ tf)) != 0)\n-\t  {\n-\t    flag_that_differs = cl_options[i].opt_text + 2;\n-\t    goto make_message;\n-\t  }\n       gcc_unreachable ();\n     }\n+#endif\n   data += sizeof (target_flags);\n   len -= sizeof (target_flags);\n \n@@ -1552,6 +1569,18 @@ default_pch_valid_p (const void *data_p, size_t len)\n     }\n #endif\n \n+  for (i = 0; i < cl_options_count; i++)\n+    if (option_affects_pch_p (i, &state))\n+      {\n+\tif (memcmp (data, state.data, state.size) != 0)\n+\t  {\n+\t    flag_that_differs = cl_options[i].opt_text + 2;\n+\t    goto make_message;\n+\t  }\n+\tdata += state.size;\n+\tlen -= state.size;\n+      }\n+\n   return NULL;\n \n  make_message:"}]}