{"sha": "0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjNDczMzFiOGJiYjYzM2ZjMzc4M2IwZDVkYzljZWMxOWIyYzZiMA==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2016-06-28T01:28:28Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2016-06-28T01:28:28Z"}, "message": "re PR target/71656 (ICE in reload when generating code for -mcpu=power9 -mpower9-dform-vector)\n\ngcc/\n\tPR target/71656\n\t* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Add\n\tOPTION_MASK_P9_DFORM_VECTOR.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Do not\n\tdisable -mpower9-dform-vector when using reload.\n\t(quad_address_p): Remove 'gpr_p' argument and all associated code.\n\tNew 'strict' argument.  Update all callers.  Add strict addressing\n\tsupport.\n\t(rs6000_legitimate_offset_address_p): Remove call to\n\tvirtual_stack_registers_memory_p.\n\t(rs6000_legitimize_reload_address): Add quad address support.\n\t(rs6000_legitimate_address_p): Move call to quad_address_p above\n\tcall to virtual_stack_registers_memory_p.  Adjust quad_address_p args\n\tto account for new strict usage.\n\t(rs6000_output_move_128bit): Adjust quad_address_p args to account\n\tfor new strict usage.\n\t* config/rs6000/predicates.md (quad_memory_operand): Likewise.\n\ngcc/testsuite/\n\tPR target/71656\n\t* gcc.target/powerpc/pr71656-1.c: New test.\n\t* gcc.target/powerpc/pr71656-2.c: New test.\n\nFrom-SVN: r237811", "tree": {"sha": "8b84ddf3424e979b04f60e7c78a033030c2fd33e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b84ddf3424e979b04f60e7c78a033030c2fd33e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0388d837d1e02524f2a807e1679e760da7146a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0388d837d1e02524f2a807e1679e760da7146a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0388d837d1e02524f2a807e1679e760da7146a3"}], "stats": {"total": 181, "additions": 125, "deletions": 56}, "files": [{"sha": "0e0900fdcc571dabe1d4d21c2324dcc9e12e6d21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -1,3 +1,23 @@\n+2016-06-27  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\tPR target/71656\n+\t* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Add\n+\tOPTION_MASK_P9_DFORM_VECTOR.\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Do not\n+\tdisable -mpower9-dform-vector when using reload.\n+\t(quad_address_p): Remove 'gpr_p' argument and all associated code.\n+\tNew 'strict' argument.  Update all callers.  Add strict addressing\n+\tsupport.\n+\t(rs6000_legitimate_offset_address_p): Remove call to\n+\tvirtual_stack_registers_memory_p.\n+\t(rs6000_legitimize_reload_address): Add quad address support.\n+\t(rs6000_legitimate_address_p): Move call to quad_address_p above\n+\tcall to virtual_stack_registers_memory_p.  Adjust quad_address_p args\n+\tto account for new strict usage.\n+\t(rs6000_output_move_128bit): Adjust quad_address_p args to account\n+\tfor new strict usage.\n+\t* config/rs6000/predicates.md (quad_memory_operand): Likewise.\n+\n 2016-06-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/70902"}, {"sha": "0174667b800268a3a408c6a62bf059959ac69e9e", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -740,7 +740,7 @@\n   if (GET_MODE_SIZE (mode) != 16 || !MEM_P (op) || MEM_ALIGN (op) < 128)\n     return false;\n \n-  return quad_address_p (XEXP (op, 0), mode, true);\n+  return quad_address_p (XEXP (op, 0), mode, false);\n })\n \n ;; Return 1 if the operand is suitable for load/store to vector registers with"}, {"sha": "8fbf1b94268e7793b6e929da7a0ccb57a1073756", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -61,14 +61,14 @@\n \t\t\t\t | OPTION_MASK_UPPER_REGS_SF)\n \n /* Add ISEL back into ISA 3.0, since it is supposed to be a win.  Do not add\n-   P9_MINMAX until the hardware that supports it is available. Do not add\n-   P9_DFORM_VECTOR until LRA is the default register allocator.  */\n+   P9_MINMAX until the hardware that supports it is available.  */\n #define ISA_3_0_MASKS_SERVER\t(ISA_2_7_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_FLOAT128_HW\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MODULO\t\t\t\\\n \t\t\t\t | OPTION_MASK_P9_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P9_DFORM_SCALAR\t\t\\\n+\t\t\t\t | OPTION_MASK_P9_DFORM_VECTOR\t\t\\\n \t\t\t\t | OPTION_MASK_P9_VECTOR)\n \n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)"}, {"sha": "f81ce6136375dad1f7f703af23199f3a2e51869f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -4271,13 +4271,10 @@ rs6000_option_override_internal (bool global_init_p)\n     rs6000_isa_flags |= OPTION_MASK_TOC_FUSION;\n \n   /* -mpower9-dform turns on both -mpower9-dform-scalar and\n-      -mpower9-dform-vector. There are currently problems if\n-      -mpower9-dform-vector instructions are enabled when we use the RELOAD\n-      register allocator.  */\n+      -mpower9-dform-vector.  */\n   if (TARGET_P9_DFORM_BOTH > 0)\n     {\n-      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR)\n-\t  && TARGET_LRA)\n+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR))\n \trs6000_isa_flags |= OPTION_MASK_P9_DFORM_VECTOR;\n \n       if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_SCALAR))\n@@ -4323,11 +4320,10 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_P9_VECTOR;\n     }\n \n-  /* There have been bugs with both -mvsx-timode and -mpower9-dform-vector that\n-     don't show up with -mlra, but do show up with -mno-lra.  Given -mlra will\n-     become the default once PR 69847 is fixed, turn off the options with\n-     problems by default if -mno-lra was used, and warn if the user explicitly\n-     asked for the option.\n+  /* There have been bugs with -mvsx-timode that don't show up with -mlra,\n+     but do show up with -mno-lra.  Given -mlra will become the default once\n+     PR 69847 is fixed, turn off the options with problems by default if\n+     -mno-lra was used, and warn if the user explicitly asked for the option.\n \n      Enable -mpower9-dform-vector by default if LRA and other power9 options.\n      Enable -mvsx-timode by default if LRA and VSX.  */\n@@ -4341,27 +4337,13 @@ rs6000_option_override_internal (bool global_init_p)\n \t  else\n \t    rs6000_isa_flags &= ~OPTION_MASK_VSX_TIMODE;\n \t}\n-\n-      if (TARGET_P9_DFORM_VECTOR)\n-\t{\n-\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR) != 0)\n-\t    warning (0, \"-mpower9-dform-vector might need -mlra\");\n-\n-\t  else\n-\t    rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_VECTOR;\n-\t}\n     }\n \n   else\n     {\n       if (TARGET_VSX && !TARGET_VSX_TIMODE\n \t  && (rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE) == 0)\n \trs6000_isa_flags |= OPTION_MASK_VSX_TIMODE;\n-\n-      if (TARGET_VSX && TARGET_P9_VECTOR && !TARGET_P9_DFORM_VECTOR\n-\t  && TARGET_P9_DFORM_SCALAR && TARGET_P9_DFORM_BOTH < 0\n-\t  && (rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR) == 0)\n-\trs6000_isa_flags |= OPTION_MASK_P9_DFORM_VECTOR;\n     }\n \n   /* Set -mallow-movmisalign to explicitly on if we have full ISA 2.07\n@@ -7248,34 +7230,24 @@ quad_address_offset_p (HOST_WIDE_INT offset)\n    3.0 LXV/STXV instruction.  */\n \n bool\n-quad_address_p (rtx addr, machine_mode mode, bool gpr_p)\n+quad_address_p (rtx addr, machine_mode mode, bool strict)\n {\n   rtx op0, op1;\n \n   if (GET_MODE_SIZE (mode) != 16)\n     return false;\n \n-  if (gpr_p)\n-    {\n-      if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)\n-\treturn false;\n-\n-      /* LQ/STQ can handle indirect addresses.  */\n-      if (base_reg_operand (addr, Pmode))\n-\treturn true;\n-    }\n+  if (legitimate_indirect_address_p (addr, strict))\n+    return true;\n \n-  else\n-    {\n-      if (!mode_supports_vsx_dform_quad (mode))\n-\treturn false;\n-    }\n+  if (VECTOR_MODE_P (mode) && !mode_supports_vsx_dform_quad (mode))\n+    return false;\n \n   if (GET_CODE (addr) != PLUS)\n     return false;\n \n   op0 = XEXP (addr, 0);\n-  if (!base_reg_operand (op0, Pmode))\n+  if (!REG_P (op0) || !INT_REG_OK_FOR_BASE_P (op0, strict))\n     return false;\n \n   op1 = XEXP (addr, 1);\n@@ -7644,8 +7616,7 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n   if (mode_supports_vsx_dform_quad (mode))\n-    return (virtual_stack_registers_memory_p (x)\n-\t    || quad_address_p (x, mode, false));\n+    return quad_address_p (x, mode, strict);\n   if (!reg_offset_addressing_ok_p (mode))\n     return virtual_stack_registers_memory_p (x);\n   if (legitimate_constant_pool_address_p (x, mode, strict || lra_in_progress))\n@@ -8548,6 +8519,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \t\t\t\t  int ind_levels ATTRIBUTE_UNUSED, int *win)\n {\n   bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n+  bool quad_offset_p = mode_supports_vsx_dform_quad (mode);\n \n   /* Nasty hack for vsx_splat_v2df/v2di load from mem, which takes a\n      DFmode/DImode MEM.  Ditto for ISA 3.0 vsx_splat_v4sf/v4si.  */\n@@ -8617,6 +8589,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \n   if (TARGET_CMODEL != CMODEL_SMALL\n       && reg_offset_p\n+      && !quad_offset_p\n       && small_toc_ref (x, VOIDmode))\n     {\n       rtx hi = gen_rtx_HIGH (Pmode, copy_rtx (x));\n@@ -8634,22 +8607,24 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n     }\n \n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n+      && REG_P (XEXP (x, 0))\n       && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n       && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && reg_offset_p\n       && !SPE_VECTOR_MODE (mode)\n       && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-      && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))\n+      && (quad_offset_p || !VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n       HOST_WIDE_INT high\n \t= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \n-      /* Check for 32-bit overflow.  */\n-      if (high + low != val)\n+      /* Check for 32-bit overflow or quad addresses with one of the\n+\t four least significant bits set.  */\n+      if (high + low != val\n+\t  || (quad_offset_p && (low & 0xf)))\n \t{\n \t  *win = 0;\n \t  return x;\n@@ -8677,6 +8652,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \n   if (GET_CODE (x) == SYMBOL_REF\n       && reg_offset_p\n+      && !quad_offset_p\n       && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode))\n       && !SPE_VECTOR_MODE (mode)\n #if TARGET_MACHO\n@@ -8761,6 +8737,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \n   if (TARGET_TOC\n       && reg_offset_p\n+      && !quad_offset_p\n       && GET_CODE (x) == SYMBOL_REF\n       && use_toc_relative_ref (x, mode))\n     {\n@@ -8849,15 +8826,14 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n       && mode_supports_pre_incdec_p (mode)\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n-  if (virtual_stack_registers_memory_p (x))\n-    return 1;\n-\n   /* Handle restricted vector d-form offsets in ISA 3.0.  */\n   if (quad_offset_p)\n     {\n-      if (quad_address_p (x, mode, false))\n+      if (quad_address_p (x, mode, reg_ok_strict))\n \treturn 1;\n     }\n+  else if (virtual_stack_registers_memory_p (x))\n+    return 1;\n \n   else if (reg_offset_p)\n     {\n@@ -20463,7 +20439,7 @@ rs6000_output_move_128bit (rtx operands[])\n       else if (TARGET_VSX && dest_vsx_p)\n \t{\n \t  if (mode_supports_vsx_dform_quad (mode)\n-\t      && quad_address_p (XEXP (src, 0), mode, false))\n+\t      && quad_address_p (XEXP (src, 0), mode, true))\n \t    return \"lxv %x0,%1\";\n \n \t  else if (TARGET_P9_VECTOR)\n@@ -20501,7 +20477,7 @@ rs6000_output_move_128bit (rtx operands[])\n       else if (TARGET_VSX && src_vsx_p)\n \t{\n \t  if (mode_supports_vsx_dform_quad (mode)\n-\t      && quad_address_p (XEXP (dest, 0), mode, false))\n+\t      && quad_address_p (XEXP (dest, 0), mode, true))\n \t    return \"stxv %x1,%0\";\n \n \t  else if (TARGET_P9_VECTOR)"}, {"sha": "7e7cf8b7e673921296c063bf489d78cd243757cf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -1,3 +1,9 @@\n+2016-06-27  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\tPR target/71656\n+\t* gcc.target/powerpc/pr71656-1.c: New test.\n+\t* gcc.target/powerpc/pr71656-2.c: New test.\n+\n 2016-06-27  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vget_lane.c: Add ifdef"}, {"sha": "fa6b4ffb81694f16ba89b7f54ce5e7fb771dfb54", "filename": "gcc/testsuite/gcc.target/powerpc/pr71656-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71656-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71656-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71656-1.c?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -0,0 +1,20 @@\n+/* Test for reload ICE arising from POWER9 Vector Dform code generation.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O1 -mcpu=power9 -mpower9-dform-vector -mno-lra\" } */\n+\n+typedef __attribute__((altivec(vector__))) int type_t;\n+type_t\n+func (type_t *src)\n+{\n+  asm volatile (\"# force the base reg on the load below to be spilled\"\n+                   : /* no outputs */\n+                   : /* no inputs */\n+                   : \"r0\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\n+                     \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r14\", \"r15\",\n+                     \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n+                     \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\");\n+  return src[1];\n+}\n+"}, {"sha": "f20c7aa02bf3b31bfd101daee15520cd6e50075e", "filename": "gcc/testsuite/gcc.target/powerpc/pr71656-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71656-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71656-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71656-2.c?ref=0dc47331b8bbb633fc3783b0d5dc9cec19b2c6b0", "patch": "@@ -0,0 +1,47 @@\n+/* Test for reload ICE arising from POWER9 Vector Dform code generation.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O3 -mcpu=power9 -mpower9-dform-vector -mno-lra -funroll-loops -fno-aggressive-loop-optimizations\" } */\n+\n+typedef double vec[3];\n+struct vec_t\n+{\n+  vec x;\n+  vec y;\n+};\n+int a, j, k, l, m, n, o, p, q;\n+double b, i;\n+vec c;\n+double h[6];\n+void func1 (vec);\n+\n+void\n+func2 (double *)\n+{\n+  for (; k; k--)\n+    for (; j <= k;)\n+      for (; m <= q; m++)\n+\tfor (; n <= k; n++)\n+\t  for (; o <= l; o++)\n+\t    {\n+\t      j = p + m + n + o;\n+\t      h[j] = i;\n+\t    }\n+}\n+\n+void\n+func3 (void)\n+{\n+  vec_t d;\n+  func1 (d.y);\n+  func2 (&b);\n+  for (; a;)\n+    {\n+      double *e = d.y, *g;\n+      double f;\n+      c[0] = g[0] + f * e[0];\n+      c[1] = g[1] + f * e[1];\n+      func1 (c);\n+    }\n+}"}]}