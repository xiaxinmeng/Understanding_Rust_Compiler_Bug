{"sha": "869a06d981893b769829975bf27d8a3069cacf47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY5YTA2ZDk4MTg5M2I3Njk4Mjk5NzViZjI3ZDhhMzA2OWNhY2Y0Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2021-01-04T11:43:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-04T09:17:30Z"}, "message": "[Ada] Address some ??? comments in checks.adb\n\ngcc/ada/\n\n\t* checks.adb (Append_Range_Checks, Apply_Selected_Length_Checks,\n\tDetermine_Range, Insert_Range_Checks,\n\tInstall_Null_Excluding_Check, Selected_Length_Checks,\n\tSelected_Range_Checks): Address ??? comments and code cleanups.", "tree": {"sha": "6b5bb999038e40ed666c5bf0d567b3b926c46954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5bb999038e40ed666c5bf0d567b3b926c46954"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/869a06d981893b769829975bf27d8a3069cacf47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869a06d981893b769829975bf27d8a3069cacf47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/869a06d981893b769829975bf27d8a3069cacf47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869a06d981893b769829975bf27d8a3069cacf47/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c356dfdd6fb75553d010852b0a801c9e780290e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c356dfdd6fb75553d010852b0a801c9e780290e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c356dfdd6fb75553d010852b0a801c9e780290e8"}], "stats": {"total": 201, "additions": 80, "deletions": 121}, "files": [{"sha": "a4ad4e6dac26389080359af4e442a0baaa832d2f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 80, "deletions": 121, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869a06d981893b769829975bf27d8a3069cacf47/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869a06d981893b769829975bf27d8a3069cacf47/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=869a06d981893b769829975bf27d8a3069cacf47", "patch": "@@ -500,9 +500,9 @@ package body Checks is\n                     not Range_Checks_Suppressed (Suppress_Typ);\n \n    begin\n-      --  For now we just return if Checks_On is false, however this should be\n+      --  For now we just return if Checks_On is false, however this could be\n       --  enhanced to check for an always True value in the condition and to\n-      --  generate a compilation warning???\n+      --  generate a compilation warning.\n \n       if not Checks_On then\n          return;\n@@ -3459,9 +3459,6 @@ package body Checks is\n             end if;\n          end if;\n \n-         --  If the item is a conditional raise of constraint error, then have\n-         --  a look at what check is being performed and ???\n-\n          if Nkind (R_Cno) = N_Raise_Constraint_Error\n            and then Present (Condition (R_Cno))\n          then\n@@ -5395,8 +5392,7 @@ package body Checks is\n                      OK1 := True;\n                   end;\n \n-               --  No special handling for other attributes\n-               --  Probably more opportunities exist here???\n+               --  No special handling for other attributes for now\n \n                when others =>\n                   OK1 := False;\n@@ -7986,7 +7982,7 @@ package body Checks is\n    begin\n       --  For now we just return if Checks_On is false, however this should be\n       --  enhanced to check for an always True value in the condition and to\n-      --  generate a compilation warning???\n+      --  generate a compilation warning.\n \n       if not Expander_Active or not Checks_On then\n          return;\n@@ -8515,22 +8511,6 @@ package body Checks is\n          return;\n       end if;\n \n-      --  No check needed for the Get_Current_Excep.all.all idiom generated by\n-      --  the expander within exception handlers, since we know that the value\n-      --  can never be null.\n-\n-      --  Is this really the right way to do this? Normally we generate such\n-      --  code in the expander with checks off, and that's how we suppress this\n-      --  kind of junk check ???\n-\n-      if Nkind (N) = N_Function_Call\n-        and then Nkind (Name (N)) = N_Explicit_Dereference\n-        and then Nkind (Prefix (Name (N))) = N_Identifier\n-        and then Is_RTE (Entity (Prefix (Name (N))), RE_Get_Current_Excep)\n-      then\n-         return;\n-      end if;\n-\n       --  In GNATprove mode, we do not apply the check\n \n       if GNATprove_Mode then\n@@ -9821,8 +9801,10 @@ package body Checks is\n       --  Adds the action given to Ret_Result if N is non-Empty\n \n       function Get_E_Length (E : Entity_Id; Indx : Nat) return Node_Id;\n+      --  Return E'Length (Indx)\n+\n       function Get_N_Length (N : Node_Id; Indx : Nat) return Node_Id;\n-      --  Comments required ???\n+      --  Return N'Length (Indx)\n \n       function Same_Bounds (L : Node_Id; R : Node_Id) return Boolean;\n       --  True for equal literals and for nodes that denote the same constant\n@@ -9858,8 +9840,10 @@ package body Checks is\n       begin\n          if Present (N) then\n \n-            --  For now, ignore attempt to place more than two checks ???\n-            --  This is really worrisome, are we really discarding checks ???\n+            --  We do not support inserting more than 2 checks on the same\n+            --  node. If this happens it means we have already added an\n+            --  unconditional raise, so we can skip the other checks safely\n+            --  since N will always raise an exception.\n \n             if Num_Checks = 2 then\n                return;\n@@ -10429,7 +10413,10 @@ package body Checks is\n       begin\n          if Present (N) then\n \n-            --  For now, ignore attempt to place more than 2 checks ???\n+            --  We do not support inserting more than 2 checks on the same\n+            --  node. If this happens it means we have already added an\n+            --  unconditional raise, so we can skip the other checks safely\n+            --  since N will always raise an exception.\n \n             if Num_Checks = 2 then\n                return;\n@@ -10659,6 +10646,13 @@ package body Checks is\n                    Get_E_First_Or_Last (Loc, Typ, Indx, Name_Last)));\n       end Range_N_Cond;\n \n+      function \"<\" (Left, Right : Node_Id) return Boolean\n+      is (if Is_Floating_Point_Type (S_Typ)\n+          then Expr_Value_R (Left) < Expr_Value_R (Right)\n+          else Expr_Value   (Left) < Expr_Value   (Right));\n+      --  Convenience comparison function of integer or floating point\n+      --  values.\n+\n    --  Start of processing for Selected_Range_Checks\n \n    begin\n@@ -10729,14 +10723,14 @@ package body Checks is\n             Known_T_LB : constant Boolean := Compile_Time_Known_Value (T_LB);\n             Known_T_HB : constant Boolean := Compile_Time_Known_Value (T_HB);\n \n-            LB         : Node_Id := Low_Bound (Expr);\n-            HB         : Node_Id := High_Bound (Expr);\n-            Known_LB   : Boolean := False;\n-            Known_HB   : Boolean := False;\n+            LB          : Node_Id := Low_Bound (Expr);\n+            HB          : Node_Id := High_Bound (Expr);\n+            Known_LB    : Boolean := False;\n+            Known_HB    : Boolean := False;\n+            Check_Added : Boolean := False;\n \n-            Null_Range     : Boolean;\n-            Out_Of_Range_L : Boolean;\n-            Out_Of_Range_H : Boolean;\n+            Out_Of_Range_L : Boolean := False;\n+            Out_Of_Range_H : Boolean := False;\n \n          begin\n             --  Compute what is known at compile time\n@@ -10769,79 +10763,76 @@ package body Checks is\n                end if;\n             end if;\n \n-            --  Check for case where everything is static and we can do the\n-            --  check at compile time. This is skipped if we have an access\n-            --  type, since the access value may be null.\n-\n-            --  ??? This code can be improved since you only need to know that\n-            --  the two respective bounds (LB & T_LB or HB & T_HB) are known at\n-            --  compile time to emit pertinent messages.\n-\n-            if Known_T_LB and Known_T_HB and Known_LB and Known_HB\n-              and not Do_Access\n-            then\n-               --  Floating-point case\n-\n-               if Is_Floating_Point_Type (S_Typ) then\n-                  Null_Range := Expr_Value_R (HB) < Expr_Value_R (LB);\n-                  Out_Of_Range_L :=\n-                    (Expr_Value_R (LB) < Expr_Value_R (T_LB))\n-                      or else\n-                    (Expr_Value_R (LB) > Expr_Value_R (T_HB));\n-\n-                  Out_Of_Range_H :=\n-                    (Expr_Value_R (HB) > Expr_Value_R (T_HB))\n-                      or else\n-                    (Expr_Value_R (HB) < Expr_Value_R (T_LB));\n-\n-               --  Fixed or discrete type case\n+            --  Check for the simple cases where we can do the check at\n+            --  compile time. This is skipped if we have an access type, since\n+            --  the access value may be null.\n \n-               else\n-                  Null_Range := Expr_Value (HB) < Expr_Value (LB);\n-                  Out_Of_Range_L :=\n-                    (Expr_Value (LB) < Expr_Value (T_LB))\n-                      or else\n-                    (Expr_Value (LB) > Expr_Value (T_HB));\n+            if not Do_Access and then Not_Null_Range (LB, HB) then\n+               if Known_LB then\n+                  if Known_T_LB then\n+                     Out_Of_Range_L := LB < T_LB;\n+                  end if;\n \n-                  Out_Of_Range_H :=\n-                    (Expr_Value (HB) > Expr_Value (T_HB))\n-                      or else\n-                    (Expr_Value (HB) < Expr_Value (T_LB));\n-               end if;\n+                  if Known_T_HB and not Out_Of_Range_L then\n+                     Out_Of_Range_L := T_HB < LB;\n+                  end if;\n \n-               if not Null_Range then\n                   if Out_Of_Range_L then\n                      if No (Warn_Node) then\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n                              (Low_Bound (Expr),\n                               \"static value out of range of}??\", T_Typ));\n+                        Check_Added := True;\n \n                      else\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n                             (Wnode,\n                              \"static range out of bounds of}??\", T_Typ));\n+                        Check_Added := True;\n                      end if;\n                   end if;\n+               end if;\n+\n+               if Known_HB then\n+                  if Known_T_HB then\n+                     Out_Of_Range_H := T_HB < HB;\n+                  end if;\n+\n+                  if Known_T_LB and not Out_Of_Range_H then\n+                     Out_Of_Range_H := HB < T_LB;\n+                  end if;\n \n                   if Out_Of_Range_H then\n                      if No (Warn_Node) then\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n                              (High_Bound (Expr),\n                               \"static value out of range of}??\", T_Typ));\n+                        Check_Added := True;\n \n                      else\n                         Add_Check\n                           (Compile_Time_Constraint_Error\n                              (Wnode,\n                               \"static range out of bounds of}??\", T_Typ));\n+                        Check_Added := True;\n                      end if;\n                   end if;\n                end if;\n+            end if;\n \n-            else\n+            --  Check for the case where not everything is static\n+\n+            if not Check_Added\n+              and then\n+                (Do_Access\n+                  or else not Known_T_LB\n+                  or else not Known_LB\n+                  or else not Known_T_HB\n+                  or else not Known_HB)\n+            then\n                declare\n                   LB : Node_Id := Low_Bound (Expr);\n                   HB : Node_Id := High_Bound (Expr);\n@@ -10908,8 +10899,8 @@ package body Checks is\n       elsif Is_Scalar_Type (S_Typ) then\n \n          --  This somewhat duplicates what Apply_Scalar_Range_Check does,\n-         --  except the above simply sets a flag in the node and lets\n-         --  gigi generate the check base on the Etype of the expression.\n+         --  except the above simply sets a flag in the node and lets the\n+         --  check be generated based on the Etype of the expression.\n          --  Sometimes, however we want to do a dynamic check against an\n          --  arbitrary target type, so we do that here.\n \n@@ -10923,56 +10914,24 @@ package body Checks is\n          --  expression. As usual, skip this for access types\n \n          elsif Compile_Time_Known_Value (Expr) and then not Do_Access then\n-            declare\n-               LB : constant Node_Id := Type_Low_Bound (T_Typ);\n-               UB : constant Node_Id := Type_High_Bound (T_Typ);\n-\n-               Out_Of_Range  : Boolean;\n-               Static_Bounds : constant Boolean :=\n-                 Compile_Time_Known_Value (LB)\n-                 and Compile_Time_Known_Value (UB);\n-\n-            begin\n-               --  Following range tests should use Sem_Eval routine ???\n-\n-               if Static_Bounds then\n-                  if Is_Floating_Point_Type (S_Typ) then\n-                     Out_Of_Range :=\n-                       (Expr_Value_R (Expr) < Expr_Value_R (LB))\n-                         or else\n-                       (Expr_Value_R (Expr) > Expr_Value_R (UB));\n-\n-                  --  Fixed or discrete type\n-\n-                  else\n-                     Out_Of_Range :=\n-                       Expr_Value (Expr) < Expr_Value (LB)\n-                         or else\n-                       Expr_Value (Expr) > Expr_Value (UB);\n-                  end if;\n-\n-                  --  Bounds of the type are static and the literal is out of\n-                  --  range so output a warning message.\n+            if Is_Out_Of_Range (Expr, T_Typ) then\n \n-                  if Out_Of_Range then\n-                     if No (Warn_Node) then\n-                        Add_Check\n-                          (Compile_Time_Constraint_Error\n-                             (Expr,\n-                              \"static value out of range of}??\", T_Typ));\n+               --  Bounds of the type are static and the literal is out of\n+               --  range so output a warning message.\n \n-                     else\n-                        Add_Check\n-                          (Compile_Time_Constraint_Error\n-                             (Wnode,\n-                              \"static value out of range of}??\", T_Typ));\n-                     end if;\n-                  end if;\n+               if No (Warn_Node) then\n+                  Add_Check\n+                    (Compile_Time_Constraint_Error\n+                       (Expr, \"static value out of range of}??\", T_Typ));\n \n                else\n-                  Cond := Discrete_Expr_Cond (Expr, T_Typ);\n+                  Add_Check\n+                    (Compile_Time_Constraint_Error\n+                       (Wnode, \"static value out of range of}??\", T_Typ));\n                end if;\n-            end;\n+            else\n+               Cond := Discrete_Expr_Cond (Expr, T_Typ);\n+            end if;\n \n          --  Here for the case of a non-static expression, we need a runtime\n          --  check unless the source type range is guaranteed to be in the"}]}