{"sha": "2105f1a796d2fa126313b6568b573af6e330ce80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEwNWYxYTc5NmQyZmExMjYzMTNiNjU2OGI1NzNhZjZlMzMwY2U4MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-02-24T22:17:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-02-24T22:17:43Z"}, "message": "re PR c++/60146 (ICE when compiling this code with -fopenmp)\n\n\tPR c++/60146\n\t* pt.c (tsubst_omp_for_iterator): Don't let substitution of the\n\tDECL_EXPR initialize a non-class iterator.\n\nFrom-SVN: r208094", "tree": {"sha": "27f413ac47c693fc1d6fd0c7415c9ec933552c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27f413ac47c693fc1d6fd0c7415c9ec933552c2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2105f1a796d2fa126313b6568b573af6e330ce80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2105f1a796d2fa126313b6568b573af6e330ce80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2105f1a796d2fa126313b6568b573af6e330ce80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2105f1a796d2fa126313b6568b573af6e330ce80/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "016895178d73bf9e4b0dea6ed253adea4f9af4f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016895178d73bf9e4b0dea6ed253adea4f9af4f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/016895178d73bf9e4b0dea6ed253adea4f9af4f9"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "20589c3f42ae72c4e06e3196fbc82ce1be5c53a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2105f1a796d2fa126313b6568b573af6e330ce80/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2105f1a796d2fa126313b6568b573af6e330ce80/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2105f1a796d2fa126313b6568b573af6e330ce80", "patch": "@@ -1,5 +1,9 @@\n 2014-02-24  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/60146\n+\t* pt.c (tsubst_omp_for_iterator): Don't let substitution of the\n+\tDECL_EXPR initialize a non-class iterator.\n+\n \tPR c++/60312\n \t* parser.c (cp_parser_template_type_arg): Check for invalid 'auto'.\n "}, {"sha": "bd5914295be009889ec39b34c7f7a0d45f374cd0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2105f1a796d2fa126313b6568b573af6e330ce80/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2105f1a796d2fa126313b6568b573af6e330ce80/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2105f1a796d2fa126313b6568b573af6e330ce80", "patch": "@@ -13063,31 +13063,43 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n   tsubst_expr ((NODE), args, complain, in_decl,\t\\\n \t       integral_constant_expression_p)\n   tree decl, init, cond, incr;\n-  bool init_decl;\n \n   init = TREE_VEC_ELT (OMP_FOR_INIT (t), i);\n   gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n   decl = TREE_OPERAND (init, 0);\n   init = TREE_OPERAND (init, 1);\n-  /* Do this before substituting into decl to handle 'auto'.  */\n-  init_decl = (init && TREE_CODE (init) == DECL_EXPR);\n-  init = RECUR (init);\n-  decl = RECUR (decl);\n-\n-  if (decl == error_mark_node || init == error_mark_node)\n-    return;\n-\n-  if (init_decl)\n+  tree decl_expr = NULL_TREE;\n+  if (init && TREE_CODE (init) == DECL_EXPR)\n     {\n-      gcc_assert (!processing_template_decl);\n-      init = DECL_INITIAL (decl);\n-      DECL_INITIAL (decl) = NULL_TREE;\n+      /* We need to jump through some hoops to handle declarations in the\n+\t for-init-statement, since we might need to handle auto deduction,\n+\t but we need to keep control of initialization.  */\n+      decl_expr = init;\n+      init = DECL_INITIAL (DECL_EXPR_DECL (init));\n+      decl = tsubst_decl (decl, args, complain);\n     }\n+  else\n+    decl = RECUR (decl);\n+  init = RECUR (init);\n+\n+  tree auto_node = type_uses_auto (TREE_TYPE (decl));\n+  if (auto_node && init)\n+    TREE_TYPE (decl)\n+      = do_auto_deduction (TREE_TYPE (decl), init, auto_node);\n \n   gcc_assert (!type_dependent_expression_p (decl));\n \n   if (!CLASS_TYPE_P (TREE_TYPE (decl)))\n     {\n+      if (decl_expr)\n+\t{\n+\t  /* Declare the variable, but don't let that initialize it.  */\n+\t  tree init_sav = DECL_INITIAL (DECL_EXPR_DECL (decl_expr));\n+\t  DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = NULL_TREE;\n+\t  RECUR (decl_expr);\n+\t  DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = init_sav;\n+\t}\n+\n       cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));\n       incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n       if (TREE_CODE (incr) == MODIFY_EXPR)\n@@ -13104,7 +13116,13 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n       return;\n     }\n \n-  if (init && !init_decl)\n+  if (decl_expr)\n+    {\n+      /* Declare and initialize the variable.  */\n+      RECUR (decl_expr);\n+      init = NULL_TREE;\n+    }\n+  else if (init)\n     {\n       tree c;\n       for (c = *clauses; c ; c = OMP_CLAUSE_CHAIN (c))"}, {"sha": "7b57b16b85f9f102bd88b89000c655d1878f5291", "filename": "gcc/testsuite/g++.dg/gomp/for-20.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2105f1a796d2fa126313b6568b573af6e330ce80/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2105f1a796d2fa126313b6568b573af6e330ce80/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-20.C?ref=2105f1a796d2fa126313b6568b573af6e330ce80", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/60146\n+// { dg-do compile }\n+// { dg-options -fopenmp }\n+\n+int foo() { return 0; }\n+\n+template<typename T> void bar()\n+{\n+#pragma omp parallel for\n+  for (T i = foo(); i < 8; ++i) {}\n+}\n+\n+void baz()\n+{\n+  bar<int>();\n+}"}]}