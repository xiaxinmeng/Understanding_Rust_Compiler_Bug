{"sha": "0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjZmUwYjQ2ZjkzNWFkNmZkN2I1MzA3ZDYzOWY0MGJkZGU2Y2I0Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-11-17T12:36:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-17T12:36:00Z"}, "message": "pt.c (tsubst): Add diagnostics for invalid array, reference and pointer to member types.\n\n\t* pt.c (tsubst): Add diagnostics for invalid array, reference\n\tand pointer to member types.\n\nFrom-SVN: r23684", "tree": {"sha": "e58c50c1cf6cddfaa415bd915e10f73b626e36e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e58c50c1cf6cddfaa415bd915e10f73b626e36e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47/comments", "author": null, "committer": null, "parents": [{"sha": "a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87ec9e6555785cfc21dfbf8078fa0728f4a0030"}], "stats": {"total": 73, "additions": 57, "deletions": 16}, "files": [{"sha": "6c3895fd26e0f28ae4fa717f8886df6654eb9886", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47", "patch": "@@ -1,3 +1,8 @@\n+1998-11-17  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst): Add diagnostics for invalid array, reference\n+\tand pointer to member types.\n+\n 1998-11-16  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck2.c (my_friendly_abort): Don't fatal twice in a row."}, {"sha": "a416bf97d2b4fa4a451614585c8391017987a2a4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 52, "deletions": 16, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0ecfe0b46f935ad6fd7b5307d639f40bdde6cb47", "patch": "@@ -5577,7 +5577,7 @@ tsubst (t, args, in_decl)\n      tree t, args;\n      tree in_decl;\n {\n-  tree type;\n+  tree type, r;\n \n   if (t == NULL_TREE || t == error_mark_node\n       || t == integer_type_node\n@@ -5641,6 +5641,14 @@ tsubst (t, args, in_decl)\n \t    return itype;\n \t  }\n \n+\tif (pedantic && integer_zerop (max))\n+\t  pedwarn (\"creating array with size zero\");\n+\telse if (INT_CST_LT (max, integer_zero_node))\n+\t  {\n+\t    cp_error (\"creating array with size `%E'\", max);\n+\t    max = integer_one_node;\n+\t  }\n+\n \tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node, 1));\n \treturn build_index_type (max);\n       }\n@@ -5652,7 +5660,8 @@ tsubst (t, args, in_decl)\n \tint idx;\n \tint level;\n \tint levels;\n-\ttree r = NULL_TREE;\n+\n+\tr = NULL_TREE;\n \n \tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n \t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n@@ -5693,7 +5702,6 @@ tsubst (t, args, in_decl)\n \t\t\t   a template template parameter */\n \t\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t),\n \t\t\t\t\t      args, in_decl);\n-\t\t\ttree r;\n \n \t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n \t\t\t   we are resolving nested-types in the signature of \n@@ -5820,14 +5828,14 @@ tsubst (t, args, in_decl)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       {\n-\ttree r;\n \tenum tree_code code;\n \n \tif (type == TREE_TYPE (t))\n \t  return t;\n \n \tcode = TREE_CODE (t);\n-\tif (TREE_CODE (type) == REFERENCE_TYPE) \n+\tif (TREE_CODE (type) == REFERENCE_TYPE\n+\t    || (code == REFERENCE_TYPE && TREE_CODE (type) == VOID_TYPE))\n \t  {\n \t    static int   last_line = 0;\n \t    static char* last_file = 0;\n@@ -5838,9 +5846,12 @@ tsubst (t, args, in_decl)\n \t    if (last_line != lineno ||\n \t\tlast_file != input_filename)\n \t      {\n-\t\tcp_error (\"cannot form type %s to reference type %T during template instantiation\",\n-\t\t\t  (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n-\t\t\t  type);\n+\t\tif (TREE_CODE (type) == VOID_TYPE)\n+\t\t  cp_error (\"forming reference to void\");\n+\t\telse\n+\t\t  cp_error (\"forming %s to reference type `%T'\",\n+\t\t\t    (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n+\t\t\t    type);\n \t\tlast_line = lineno;\n \t\tlast_file = input_filename;\n \t      }\n@@ -5864,8 +5875,12 @@ tsubst (t, args, in_decl)\n \treturn r;\n       }\n     case OFFSET_TYPE:\n-      return build_offset_type\n-\t(tsubst (TYPE_OFFSET_BASETYPE (t), args, in_decl), type);\n+      {\n+\tr = tsubst (TYPE_OFFSET_BASETYPE (t), args, in_decl);\n+\tif (! IS_AGGR_TYPE (r))\n+\t  cp_error (\"creating pointer to member of non-class type `%T'\", r);\n+\treturn build_offset_type (r, type);\n+      }\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n@@ -5882,11 +5897,15 @@ tsubst (t, args, in_decl)\n \t/* Construct a new type node and return it.  */\n \tif (TREE_CODE (t) == FUNCTION_TYPE)\n \t  fntype = build_function_type (type, arg_types);\n-\telse \n-\t  fntype \n-\t    = build_cplus_method_type (TREE_TYPE (TREE_VALUE (arg_types)),\n-\t\t\t\t       type,\n-\t\t\t\t       TREE_CHAIN (arg_types));\n+\telse\n+\t  {\n+\t    r = TREE_TYPE (TREE_VALUE (arg_types));\n+\t    if (! IS_AGGR_TYPE (r))\n+\t      cp_error (\"creating pointer to member function of non-class type `%T'\",\n+\t\t\tr);\n+\t      \n+\t    fntype = build_cplus_method_type (r, type, TREE_CHAIN (arg_types));\n+\t  }\n \tfntype = build_qualified_type (fntype, TYPE_QUALS (t));\n \n \t/* Substitue the exception specification. */\n@@ -5901,9 +5920,26 @@ tsubst (t, args, in_decl)\n     case ARRAY_TYPE:\n       {\n \ttree domain = tsubst (TYPE_DOMAIN (t), args, in_decl);\n-\ttree r;\n \tif (type == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n+\n+\t/* These checks should match the ones in grokdeclarator.  */\n+\tif (TREE_CODE (type) == VOID_TYPE)\n+\t  {\n+\t    cp_error (\"creating array of void\");\n+\t    type = build_pointer_type (type);\n+\t  }\n+\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t  {\n+\t    cp_error (\"creating array of functions `%T'\", type);\n+\t    type = build_pointer_type (type);\n+\t  }\n+\telse if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  {\n+\t    cp_error (\"creating array of references `%T'\", type);\n+\t    type = TREE_TYPE (type);\n+\t  }\n+\n \tr = build_cplus_array_type (type, domain);\n \treturn r;\n       }"}]}