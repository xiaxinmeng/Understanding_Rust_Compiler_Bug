{"sha": "787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg3YzdhNjVmNmVjMjg3NjMzN2U2YzUwYTI2YTFkYTBmYWRjYjViZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-10-27T20:52:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-10-27T20:52:07Z"}, "message": "constraints.md (wH constraint): Add new constraints for allowing 32-bit integers (and eventually 8/16-bit...\n\n[gcc]\n2016-10-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/constraints.md (wH constraint): Add new\n\tconstraints for allowing 32-bit integers (and eventually 8/16-bit\n\tintegers) into the vector registers.\n\t(wI constraint): Likewise.\n\t(wJ constraint): Likewise.\n\t(wK constraint): Likewise.\n\t* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Add\n\t-mvsx-small-integer as a default option for ISA 2.07\n\t(i.e. power8).\n\t(POWERPC_MASKS): Likewise.\n\t* config/rs6000/rs6000.opt (-mvsx-small-integer): Add new debug\n\tswitch to turn off small integer support in vector registers.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Eliminate\n\ttest for -mupper-regs-di, since it is already done with the\n\treg_add[mode].scalar_in_vsx_p.  Add support for the switch\n\t-mvsx-small-integer.\n\t(rs6000_debug_reg_global): Add support for wH, wI, wJ, and wK\n\tconstraints.\n\t(rs6000_setup_reg_addr_masks): Likewise.\n\t(rs6000_init_hard_regno_mode_ok): Likewise.\n\t(rs6000_option_override_internal): Add consistency checks for\n\t-mvsx-small-integer.\n\t(rs6000_secondary_reload_simple_move): SImode is a simple move if\n\t-mvsx-small-integer.\n\t(rs6000_secondary_reload): Use std::swap.\n\t(rs6000_preferred_reload_class): Don't prefer FLOAT_REGS over\n\tVSX_REGS for small integers in vector registers, since there is no\n\tD-FORM address mode for such types.\n\t(rs6000_register_move_cost): Use FIRST_FPR_REGNO instead of 32.\n\t(rs6000_opt_masks): Add -mvsx-small-integer.\n\t* config/rs6000/vsx.md (VSINT_84): Add SImode for small integer\n\tsupport.\n\t(VSX_EXTRACT_I2): Clone VSX_EXTRACT_I, but drop V4SI since SImode\n\textracts can be done on ISA 2.07.\n\t(vsx_extract_<mode>): Add support for small integers in vsx\n\tregisters.\n\t(vsx_extract_<mode>_p9): Use 'v' instead of VSX_EX, since we no\n\tlonger support V4SImode in this pattern.\n\t(vsx_extract_si): New insn to support extraction of SImode in ISA\n\t2.07 using either xxextractuw or vspltw.\n\t(vsx_extract_<mode>_p8): Use 'v' instead of VSX_EX, since we no\n\tlonger support V4SImode in this pattern.\n\t* config/rs6000/rs6000.h (enum rs6000_reg_class_enum): Add wH, wI,\n\twJ, and wK constraints.\n\t* config/rs6000/rs6000.md (f32_sv): Use correct instruction for\n\tstoring SDmode with VSX instructions.\n\t(zero_extendsi<mode>2): Reorder pattern, so RLDICL comes after the\n\tGPR load and before the FPR and VSX loads.  Remove ??, ! from the\n\tconstraints.  Add MFVSRWZ and XXEXTRACTUW instructions to support\n\tsmall integers in vector registers.\n\t(extendsi<mode>2): Reorder pattern, so EXTSW comes after the GPR\n\tload and before the FPR and VSX loads.  Remove ??, ! from the\n\tconstraints.  Add VEXTSW2D support for small integers in vector\n\tregisters.\n\t(lfiwax): Remove ! constraint.  Add VEXTSW2D support for small\n\tintegers in vector registers.\n\t(floatsi<mode>2_lfiwax): If -mvsx-small-integer issue a normal\n\tmove instead of using an UNSPEC.\n\t(lfiwzx): Remove ! constraint.  Add XXEXTRACTUW support for small\n\tintegers in vector registers.\n\t(floatunssi<mode>2_lfiwzx): If -mvsx-small-integer issue a normal\n\tmove instead of using an UNSPEC.\n\t(movsi_internal1): Add support for -mvsx-small-integer.  Align\n\tcolumns so that it is more readable.\n\t(SImode splitter for ISA 3.0 constants): Add splitter for\n\t-128..127 constants that can easily be constructed on ISA 3.0.\n\t* doc/md.texi (PowerPC Constraints): Document wH, wI, wJ, and wK\n\tconstraints.\n\n[gcc/testsuite]\n2016-10-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vsx-simode.c: New test.\n\t* gcc.target/powerpc/vsx-simode2.c: Likewise.\n\t* gcc.target/powerpc/vsx-simode3.c: Likewise.\n\nFrom-SVN: r241631", "tree": {"sha": "6fef9d9f4d0a61bd0a82f599ed70624bc18e9835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fef9d9f4d0a61bd0a82f599ed70624bc18e9835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/comments", "author": null, "committer": null, "parents": [{"sha": "6f21288f8c3579ec7ae47615e76ba1e6ad25551f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f21288f8c3579ec7ae47615e76ba1e6ad25551f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f21288f8c3579ec7ae47615e76ba1e6ad25551f"}], "stats": {"total": 499, "additions": 429, "deletions": 70}, "files": [{"sha": "1e05d4501a56ef1a2d6b699a4f79f350f6fb4bd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -1,3 +1,74 @@\n+2016-10-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/constraints.md (wH constraint): Add new\n+\tconstraints for allowing 32-bit integers (and eventually 8/16-bit\n+\tintegers) into the vector registers.\n+\t(wI constraint): Likewise.\n+\t(wJ constraint): Likewise.\n+\t(wK constraint): Likewise.\n+\t* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Add\n+\t-mvsx-small-integer as a default option for ISA 2.07\n+\t(i.e. power8).\n+\t(POWERPC_MASKS): Likewise.\n+\t* config/rs6000/rs6000.opt (-mvsx-small-integer): Add new debug\n+\tswitch to turn off small integer support in vector registers.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Eliminate\n+\ttest for -mupper-regs-di, since it is already done with the\n+\treg_add[mode].scalar_in_vsx_p.  Add support for the switch\n+\t-mvsx-small-integer.\n+\t(rs6000_debug_reg_global): Add support for wH, wI, wJ, and wK\n+\tconstraints.\n+\t(rs6000_setup_reg_addr_masks): Likewise.\n+\t(rs6000_init_hard_regno_mode_ok): Likewise.\n+\t(rs6000_option_override_internal): Add consistency checks for\n+\t-mvsx-small-integer.\n+\t(rs6000_secondary_reload_simple_move): SImode is a simple move if\n+\t-mvsx-small-integer.\n+\t(rs6000_secondary_reload): Use std::swap.\n+\t(rs6000_preferred_reload_class): Don't prefer FLOAT_REGS over\n+\tVSX_REGS for small integers in vector registers, since there is no\n+\tD-FORM address mode for such types.\n+\t(rs6000_register_move_cost): Use FIRST_FPR_REGNO instead of 32.\n+\t(rs6000_opt_masks): Add -mvsx-small-integer.\n+\t* config/rs6000/vsx.md (VSINT_84): Add SImode for small integer\n+\tsupport.\n+\t(VSX_EXTRACT_I2): Clone VSX_EXTRACT_I, but drop V4SI since SImode\n+\textracts can be done on ISA 2.07.\n+\t(vsx_extract_<mode>): Add support for small integers in vsx\n+\tregisters.\n+\t(vsx_extract_<mode>_p9): Use 'v' instead of VSX_EX, since we no\n+\tlonger support V4SImode in this pattern.\n+\t(vsx_extract_si): New insn to support extraction of SImode in ISA\n+\t2.07 using either xxextractuw or vspltw.\n+\t(vsx_extract_<mode>_p8): Use 'v' instead of VSX_EX, since we no\n+\tlonger support V4SImode in this pattern.\n+\t* config/rs6000/rs6000.h (enum rs6000_reg_class_enum): Add wH, wI,\n+\twJ, and wK constraints.\n+\t* config/rs6000/rs6000.md (f32_sv): Use correct instruction for\n+\tstoring SDmode with VSX instructions.\n+\t(zero_extendsi<mode>2): Reorder pattern, so RLDICL comes after the\n+\tGPR load and before the FPR and VSX loads.  Remove ??, ! from the\n+\tconstraints.  Add MFVSRWZ and XXEXTRACTUW instructions to support\n+\tsmall integers in vector registers.\n+\t(extendsi<mode>2): Reorder pattern, so EXTSW comes after the GPR\n+\tload and before the FPR and VSX loads.  Remove ??, ! from the\n+\tconstraints.  Add VEXTSW2D support for small integers in vector\n+\tregisters.\n+\t(lfiwax): Remove ! constraint.  Add VEXTSW2D support for small\n+\tintegers in vector registers.\n+\t(floatsi<mode>2_lfiwax): If -mvsx-small-integer issue a normal\n+\tmove instead of using an UNSPEC.\n+\t(lfiwzx): Remove ! constraint.  Add XXEXTRACTUW support for small\n+\tintegers in vector registers.\n+\t(floatunssi<mode>2_lfiwzx): If -mvsx-small-integer issue a normal\n+\tmove instead of using an UNSPEC.\n+\t(movsi_internal1): Add support for -mvsx-small-integer.  Align\n+\tcolumns so that it is more readable.\n+\t(SImode splitter for ISA 3.0 constants): Add splitter for\n+\t-128..127 constants that can easily be constructed on ISA 3.0.\n+\t* doc/md.texi (PowerPC Constraints): Document wH, wI, wJ, and wK\n+\tconstraints.\n+\n 2016-10-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/78025"}, {"sha": "0463c0d57a2df94048a702f8bb1ad60cc0cf982a", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -159,6 +159,18 @@\n   \"Memory operand suitable for TOC fusion memory references\"\n   (match_operand 0 \"toc_fusion_mem_wrapped\"))\n \n+(define_register_constraint \"wH\" \"rs6000_constraints[RS6000_CONSTRAINT_wH]\"\n+  \"Altivec register to hold 32-bit integers or NO_REGS.\")\n+\n+(define_register_constraint \"wI\" \"rs6000_constraints[RS6000_CONSTRAINT_wI]\"\n+  \"FPR register to hold 32-bit integers or NO_REGS.\")\n+\n+(define_register_constraint \"wJ\" \"rs6000_constraints[RS6000_CONSTRAINT_wJ]\"\n+  \"FPR register to hold 8/16-bit integers or NO_REGS.\")\n+\n+(define_register_constraint \"wK\" \"rs6000_constraints[RS6000_CONSTRAINT_wK]\"\n+  \"Altivec register to hold 8/16-bit integers or NO_REGS.\")\n+\n (define_constraint \"wL\"\n   \"Int constant that is the element number mfvsrld accesses in a vector.\"\n   (and (match_code \"const_int\")"}, {"sha": "c86da7a49fc6f91d3600020c82adbf4c4f1b7a14", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -58,7 +58,8 @@\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_QUAD_MEMORY\t\t\\\n   \t\t\t\t | OPTION_MASK_QUAD_MEMORY_ATOMIC\t\\\n-\t\t\t\t | OPTION_MASK_UPPER_REGS_SF)\n+\t\t\t\t | OPTION_MASK_UPPER_REGS_SF\t\t\\\n+\t\t\t\t | OPTION_MASK_VSX_SMALL_INTEGER)\n \n /* Add ISEL back into ISA 3.0, since it is supposed to be a win.  Do not add\n    P9_MINMAX until the hardware that supports it is available.  Do not add\n@@ -138,6 +139,7 @@\n \t\t\t\t | OPTION_MASK_UPPER_REGS_DF\t\t\\\n \t\t\t\t | OPTION_MASK_UPPER_REGS_SF\t\t\\\n \t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n+\t\t\t\t | OPTION_MASK_VSX_SMALL_INTEGER\t\\\n \t\t\t\t | OPTION_MASK_VSX_TIMODE)\n \n #endif"}, {"sha": "f9e473932885111ae7ca09482709bc385d45af3c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 93, "deletions": 27, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -1980,8 +1980,7 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n \t  || FLOAT128_VECTOR_P (mode)\n \t  || reg_addr[mode].scalar_in_vmx_p\n \t  || (TARGET_VSX_TIMODE && mode == TImode)\n-\t  || (TARGET_VADDUQM && mode == V1TImode)\n-\t  || (TARGET_UPPER_REGS_DI && mode == DImode)))\n+\t  || (TARGET_VADDUQM && mode == V1TImode)))\n     {\n       if (FP_REGNO_P (regno))\n \treturn FP_REGNO_P (last_regno);\n@@ -2012,9 +2011,14 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n \t  && FP_REGNO_P (last_regno))\n \treturn 1;\n \n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD)\n-\treturn 1;\n+      if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t{\n+\t  if(GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD)\n+\t    return 1;\n+\n+\t  if (TARGET_VSX_SMALL_INTEGER && mode == SImode)\n+\t    return 1;\n+\t}\n \n       if (PAIRED_SIMD_REGNO_P (regno) && TARGET_PAIRED_FLOAT\n \t  && PAIRED_VECTOR_MODE (mode))\n@@ -2447,6 +2451,10 @@ rs6000_debug_reg_global (void)\n \t   \"wx reg_class = %s\\n\"\n \t   \"wy reg_class = %s\\n\"\n \t   \"wz reg_class = %s\\n\"\n+\t   \"wH reg_class = %s\\n\"\n+\t   \"wI reg_class = %s\\n\"\n+\t   \"wJ reg_class = %s\\n\"\n+\t   \"wK reg_class = %s\\n\"\n \t   \"\\n\",\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_d]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_f]],\n@@ -2474,7 +2482,11 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ww]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wx]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wy]],\n-\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wz]]);\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wz]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wH]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wI]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wJ]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wK]]);\n \n   nl = \"\\n\";\n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n@@ -2770,6 +2782,7 @@ rs6000_setup_reg_addr_masks (void)\n     {\n       machine_mode m2 = (machine_mode) m;\n       bool complex_p = false;\n+      bool small_int_p = (m2 == QImode || m2 == HImode || m2 == SImode);\n       size_t msize;\n \n       if (COMPLEX_MODE_P (m2))\n@@ -2794,13 +2807,20 @@ rs6000_setup_reg_addr_masks (void)\n \t  /* Can mode values go in the GPR/FPR/Altivec registers?  */\n \t  if (reg >= 0 && rs6000_hard_regno_mode_ok_p[m][reg])\n \t    {\n+\t      bool small_int_vsx_p = (small_int_p\n+\t\t\t\t      && (rc == RELOAD_REG_FPR\n+\t\t\t\t\t  || rc == RELOAD_REG_VMX));\n+\n \t      nregs = rs6000_hard_regno_nregs[m][reg];\n \t      addr_mask |= RELOAD_REG_VALID;\n \n \t      /* Indicate if the mode takes more than 1 physical register.  If\n \t\t it takes a single register, indicate it can do REG+REG\n-\t\t addressing.  */\n-\t      if (nregs > 1 || m == BLKmode || complex_p)\n+\t\t addressing.  Small integers in VSX registers can only do\n+\t\t REG+REG addressing.  */\n+\t      if (small_int_vsx_p)\n+\t\taddr_mask |= RELOAD_REG_INDEXED;\n+\t      else if (nregs > 1 || m == BLKmode || complex_p)\n \t\taddr_mask |= RELOAD_REG_MULTIPLE;\n \t      else\n \t\taddr_mask |= RELOAD_REG_INDEXED;\n@@ -2817,6 +2837,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\t  && !VECTOR_MODE_P (m2)\n \t\t  && !FLOAT128_VECTOR_P (m2)\n \t\t  && !complex_p\n+\t\t  && !small_int_vsx_p\n \t\t  && (m2 != DFmode || !TARGET_UPPER_REGS_DF)\n \t\t  && (m2 != SFmode || !TARGET_UPPER_REGS_SF)\n \t\t  && !(TARGET_E500_DOUBLE && msize == 8))\n@@ -3115,7 +3136,11 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \tww - Register class to do SF conversions in with VSX operations.\n \twx - Float register if we can do 32-bit int stores.\n \twy - Register class to do ISA 2.07 SF operations.\n-\twz - Float register if we can do 32-bit unsigned int loads.  */\n+\twz - Float register if we can do 32-bit unsigned int loads.\n+\twH - Altivec register if SImode is allowed in VSX registers.\n+\twI - VSX register if SImode is allowed in VSX registers.\n+\twJ - VSX register if QImode/HImode are allowed in VSX registers.\n+\twK - Altivec register if QImode/HImode are allowed in VSX registers.  */\n \n   if (TARGET_HARD_FLOAT && TARGET_FPRS)\n     rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\t/* SFmode  */\n@@ -3209,6 +3234,18 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_DIRECT_MOVE_128)\n     rs6000_constraints[RS6000_CONSTRAINT_we] = VSX_REGS;\n \n+  /* Support small integers in VSX registers.  */\n+  if (TARGET_VSX_SMALL_INTEGER)\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_wH] = ALTIVEC_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wI] = FLOAT_REGS;\n+      if (TARGET_P9_VECTOR)\n+\t{\n+\t  rs6000_constraints[RS6000_CONSTRAINT_wJ] = FLOAT_REGS;\n+\t  rs6000_constraints[RS6000_CONSTRAINT_wK] = ALTIVEC_REGS;\n+\t}\n+    }\n+\n   /* Set up the reload helper and direct move functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n     {\n@@ -3361,6 +3398,9 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n       if (TARGET_UPPER_REGS_SF)\n \treg_addr[SFmode].scalar_in_vmx_p = true;\n+\n+      if (TARGET_VSX_SMALL_INTEGER)\n+\treg_addr[SImode].scalar_in_vmx_p = true;\n     }\n \n   /* Setup the fusion operations.  */\n@@ -4433,6 +4473,20 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n+  /* Check whether we should allow small integers into VSX registers.  We\n+     require direct move to prevent the register allocator from having to move\n+     variables through memory to do moves.  SImode can be used on ISA 2.07,\n+     while HImode and QImode require ISA 3.0.  */\n+  if (TARGET_VSX_SMALL_INTEGER\n+      && (!TARGET_DIRECT_MOVE || !TARGET_P8_VECTOR || !TARGET_UPPER_REGS_DI))\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_VSX_SMALL_INTEGER)\n+\terror (\"-mvsx-small-integer requires -mpower8-vector, \"\n+\t       \"-mupper-regs-di, and -mdirect-move\");\n+\n+      rs6000_isa_flags &= ~OPTION_MASK_VSX_SMALL_INTEGER;\n+    }\n+\n   /* Set long double size before the IEEE 128-bit tests.  */\n   if (!global_options_set.x_rs6000_long_double_type_size)\n     {\n@@ -20485,32 +20539,46 @@ rs6000_secondary_reload_simple_move (enum rs6000_reg_type to_type,\n \t\t\t\t     enum rs6000_reg_type from_type,\n \t\t\t\t     machine_mode mode)\n {\n-  int size;\n+  int size = GET_MODE_SIZE (mode);\n \n   /* Add support for various direct moves available.  In this function, we only\n      look at cases where we don't need any extra registers, and one or more\n-     simple move insns are issued.  At present, 32-bit integers are not allowed\n+     simple move insns are issued.  Originally small integers are not allowed\n      in FPR/VSX registers.  Single precision binary floating is not a simple\n      move because we need to convert to the single precision memory layout.\n      The 4-byte SDmode can be moved.  TDmode values are disallowed since they\n      need special direct move handling, which we do not support yet.  */\n-  size = GET_MODE_SIZE (mode);\n   if (TARGET_DIRECT_MOVE\n-      && ((mode == SDmode) || (TARGET_POWERPC64 && size == 8))\n       && ((to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n \t  || (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)))\n-    return true;\n+    {\n+      if (TARGET_POWERPC64)\n+\t{\n+\t  /* ISA 2.07: MTVSRD or MVFVSRD.  */\n+\t  if (size == 8)\n+\t    return true;\n \n-  else if (TARGET_DIRECT_MOVE_128 && size == 16 && mode != TDmode\n-\t   && ((to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n-\t       || (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)))\n-    return true;\n+\t  /* ISA 3.0: MTVSRDD or MFVSRD + MFVSRLD.  */\n+\t  if (size == 16 && TARGET_P9_VECTOR && mode != TDmode)\n+\t    return true;\n+\t}\n+\n+      /* ISA 2.07: MTVSRWZ or  MFVSRWZ.  */\n+      if (TARGET_VSX_SMALL_INTEGER && mode == SImode)\n+\treturn true;\n+\n+      /* ISA 2.07: MTVSRWZ or  MFVSRWZ.  */\n+      if (mode == SDmode)\n+\treturn true;\n+    }\n \n+  /* Power6+: MFTGPR or MFFGPR.  */\n   else if (TARGET_MFPGPR && TARGET_POWERPC64 && size == 8\n-\t   && ((to_type == GPR_REG_TYPE && from_type == FPR_REG_TYPE)\n-\t       || (to_type == FPR_REG_TYPE && from_type == GPR_REG_TYPE)))\n+      && ((to_type == GPR_REG_TYPE && from_type == FPR_REG_TYPE)\n+\t  || (to_type == FPR_REG_TYPE && from_type == GPR_REG_TYPE)))\n     return true;\n \n+  /* Move to/from SPR.  */\n   else if ((size == 4 || (TARGET_POWERPC64 && size == 8))\n \t   && ((to_type == GPR_REG_TYPE && from_type == SPR_REG_TYPE)\n \t       || (to_type == SPR_REG_TYPE && from_type == GPR_REG_TYPE)))\n@@ -20686,11 +20754,7 @@ rs6000_secondary_reload (bool in_p,\n       enum rs6000_reg_type from_type = register_to_reg_type (x, &altivec_p);\n \n       if (!in_p)\n-\t{\n-\t  enum rs6000_reg_type exchange = to_type;\n-\t  to_type = from_type;\n-\t  from_type = exchange;\n-\t}\n+\tstd::swap (to_type, from_type);\n \n       /* Can we do a direct move of some sort?  */\n       if (rs6000_secondary_reload_move (to_type, from_type, mode, sri,\n@@ -21318,7 +21382,8 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n       /* If this is a scalar floating point value and we don't have D-form\n \t addressing, prefer the traditional floating point registers so that we\n \t can use D-form (register+offset) addressing.  */\n-      if (GET_MODE_SIZE (mode) < 16 && rclass == VSX_REGS)\n+      if (rclass == VSX_REGS\n+\t  && (mode == SFmode || GET_MODE_SIZE (mode) == 8))\n \treturn FLOAT_REGS;\n \n       /* Prefer the Altivec registers if Altivec is handling the vector\n@@ -35898,7 +35963,7 @@ rs6000_register_move_cost (machine_mode mode,\n   else if (VECTOR_MEM_VSX_P (mode)\n \t   && reg_classes_intersect_p (to, VSX_REGS)\n \t   && reg_classes_intersect_p (from, VSX_REGS))\n-    ret = 2 * hard_regno_nregs[32][mode];\n+    ret = 2 * hard_regno_nregs[FIRST_FPR_REGNO][mode];\n \n   /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n@@ -37504,6 +37569,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"upper-regs-df\",\t\tOPTION_MASK_UPPER_REGS_DF,\tfalse, true  },\n   { \"upper-regs-sf\",\t\tOPTION_MASK_UPPER_REGS_SF,\tfalse, true  },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },\n+  { \"vsx-small-integer\",\tOPTION_MASK_VSX_SMALL_INTEGER,\tfalse, true  },\n   { \"vsx-timode\",\t\tOPTION_MASK_VSX_TIMODE,\t\tfalse, true  },\n #ifdef OPTION_MASK_64BIT\n #if TARGET_AIX_OS"}, {"sha": "4b83abdf753c80feeafcd488d73d7ad5deb7a7fa", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -1602,6 +1602,10 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_wx,\t\t/* FPR register for STFIWX */\n   RS6000_CONSTRAINT_wy,\t\t/* VSX register for SF */\n   RS6000_CONSTRAINT_wz,\t\t/* FPR register for LFIWZX */\n+  RS6000_CONSTRAINT_wH,\t\t/* Altivec register for 32-bit integers.  */\n+  RS6000_CONSTRAINT_wI,\t\t/* VSX register for 32-bit integers.  */\n+  RS6000_CONSTRAINT_wJ,\t\t/* VSX register for 8/16-bit integers.  */\n+  RS6000_CONSTRAINT_wK,\t\t/* Altivec register for 16/32-bit integers.  */\n   RS6000_CONSTRAINT_MAX\n };\n "}, {"sha": "bc8e52d6f6aadcdd3f58f9abeb6fe3e0257868bf", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 94, "deletions": 25, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -458,7 +458,7 @@\n (define_mode_attr f32_sm2 [(SF \"wY\")\t\t   (SD \"wn\")])\n (define_mode_attr f32_si  [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n (define_mode_attr f32_si2 [(SF \"stxssp %1,%0\")     (SD \"stfiwx %1,%y0\")])\n-(define_mode_attr f32_sv  [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwzx %x1,%y0\")])\n+(define_mode_attr f32_sv  [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwx %x1,%y0\")])\n \n ; Definitions for 32-bit fpr direct move\n ; At present, the decimal modes are not allowed in the traditional altivec\n@@ -837,16 +837,18 @@\n \n \n (define_insn \"zero_extendsi<mode>2\"\n-  [(set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r,r,??wj,!wz,!wu\")\n-\t(zero_extend:EXTSI (match_operand:SI 1 \"reg_or_mem_operand\" \"m,r,r,Z,Z\")))]\n+  [(set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r,r,wz,wu,wj,r,wJwK\")\n+\t(zero_extend:EXTSI (match_operand:SI 1 \"reg_or_mem_operand\" \"m,r,Z,Z,r,wIwH,wJwK\")))]\n   \"\"\n   \"@\n    lwz%U1%X1 %0,%1\n    rldicl %0,%1,0,32\n-   mtvsrwz %x0,%1\n    lfiwzx %0,%y1\n-   lxsiwzx %x0,%y1\"\n-  [(set_attr \"type\" \"load,shift,mffgpr,fpload,fpload\")])\n+   lxsiwzx %x0,%y1\n+   mtvsrwz %x0,%1\n+   mfvsrwz %0,%x1\n+   xxextractuw %x0,%x1,1\"\n+  [(set_attr \"type\" \"load,shift,fpload,fpload,mffgpr,mftgpr,vecexts\")])\n \n (define_insn_and_split \"*zero_extendsi<mode>2_dot\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n@@ -1005,16 +1007,17 @@\n \n \n (define_insn \"extendsi<mode>2\"\n-  [(set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r,r,??wj,!wl,!wu\")\n-\t(sign_extend:EXTSI (match_operand:SI 1 \"lwa_operand\" \"Y,r,r,Z,Z\")))]\n+  [(set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r,r,wl,wu,wj,wK\")\n+\t(sign_extend:EXTSI (match_operand:SI 1 \"lwa_operand\" \"Y,r,Z,Z,r,wK\")))]\n   \"\"\n   \"@\n    lwa%U1%X1 %0,%1\n    extsw %0,%1\n-   mtvsrwa %x0,%1\n    lfiwax %0,%y1\n-   lxsiwax %x0,%y1\"\n-  [(set_attr \"type\" \"load,exts,mffgpr,fpload,fpload\")\n+   lxsiwax %x0,%y1\n+   mtvsrwa %x0,%1\n+   vextsw2d %0,%1\"\n+  [(set_attr \"type\" \"load,exts,fpload,fpload,mffgpr,vecexts\")\n    (set_attr \"sign_extend\" \"yes\")])\n \n (define_insn_and_split \"*extendsi<mode>2_dot\"\n@@ -4947,15 +4950,16 @@\n ; We don't define lfiwax/lfiwzx with the normal definition, because we\n ; don't want to support putting SImode in FPR registers.\n (define_insn \"lfiwax\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,!wj\")\n-\t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r\")]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,wj,wK\")\n+\t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r,wK\")]\n \t\t   UNSPEC_LFIWAX))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n   \"@\n    lfiwax %0,%y1\n    lxsiwax %x0,%y1\n-   mtvsrwa %x0,%1\"\n-  [(set_attr \"type\" \"fpload,fpload,mffgpr\")])\n+   mtvsrwa %x0,%1\n+   vextsw2d %0,%1\"\n+  [(set_attr \"type\" \"fpload,fpload,mffgpr,vecexts\")])\n \n ; This split must be run before register allocation because it allocates the\n ; memory slot that is needed to move values to/from the FPR.  We don't allocate\n@@ -5019,23 +5023,27 @@\n   operands[1] = rs6000_address_for_fpconvert (operands[1]);\n   if (GET_CODE (operands[2]) == SCRATCH)\n     operands[2] = gen_reg_rtx (DImode);\n-  emit_insn (gen_lfiwax (operands[2], operands[1]));\n+  if (TARGET_VSX_SMALL_INTEGER)\n+    emit_insn (gen_extendsidi2 (operands[2], operands[1]));\n+  else\n+    emit_insn (gen_lfiwax (operands[2], operands[1]));\n   emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n   DONE;\n }\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn \"lfiwzx\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,!wj\")\n-\t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r\")]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,wj,wJwK\")\n+\t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r,wJwK\")]\n \t\t   UNSPEC_LFIWZX))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n   \"@\n    lfiwzx %0,%y1\n    lxsiwzx %x0,%y1\n-   mtvsrwz %x0,%1\"\n-  [(set_attr \"type\" \"fpload,fpload,mftgpr\")])\n+   mtvsrwz %x0,%1\n+   xxextractuw %x0,%x1,1\"\n+  [(set_attr \"type\" \"fpload,fpload,mftgpr,vecexts\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n@@ -5094,7 +5102,10 @@\n   operands[1] = rs6000_address_for_fpconvert (operands[1]);\n   if (GET_CODE (operands[2]) == SCRATCH)\n     operands[2] = gen_reg_rtx (DImode);\n-  emit_insn (gen_lfiwzx (operands[2], operands[1]));\n+  if (TARGET_VSX_SMALL_INTEGER)\n+    emit_insn (gen_zero_extendsidi2 (operands[2], operands[1]));\n+  else\n+    emit_insn (gen_lfiwzx (operands[2], operands[1]));\n   emit_insn (gen_floatdi<mode>2 (operands[0], operands[2]));\n   DONE;\n }\"\n@@ -6518,25 +6529,66 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+;;\t\tMR           LA           LWZ          LFIWZX       LXSIWZX\n+;;\t\tSTW          STFIWX       STXSIWX      LI           LIS\n+;;\t\t#            XXLOR        XXSPLTIB 0   XXSPLTIB -1  VSPLTISW\n+;;\t\tXXLXOR 0     XXLORC -1    P9 const     MTVSRWZ      MFVSRWZ\n+;;\t\tMF%1         MT%0         MT%0         NOP\n (define_insn \"*movsi_internal1\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,*c*l,*h,*h\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,*h,r,r,0\"))]\n+  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\"\n+\t\t\"=r,         r,           r,           ?*wI,        ?*wH,\n+\t\t m,          ?Z,          ?Z,          r,           r,\n+\t\t r,          ?*wIwH,      ?*wJwK,      ?*wK,        ?*wJwK,\n+\t\t ?*wJwK,     ?*wH,        ?*wK,        ?*wIwH,      ?r,\n+\t\t r,          *c*l,        *h,          *h\")\n+\n+\t(match_operand:SI 1 \"input_operand\"\n+\t\t\"r,          U,           m,           Z,           Z,\n+\t\t r,          wI,          wH,          I,           L,\n+\t\t n,          wIwH,        O,           wM,          wB,\n+\t\t O,          wM,          wS,          r,           wIwH,\n+\t\t *h,         r,           r,           0\"))]\n+\n   \"!TARGET_SINGLE_FPU &&\n    (gpc_reg_operand (operands[0], SImode) || gpc_reg_operand (operands[1], SImode))\"\n   \"@\n    mr %0,%1\n    la %0,%a1\n    lwz%U1%X1 %0,%1\n+   lfiwzx %0,%y1\n+   lxsiwzx %x0,%y1\n    stw%U0%X0 %1,%0\n+   stfiwx %1,%y0\n+   stxsiwx %x1,%y0\n    li %0,%1\n    lis %0,%v1\n    #\n+   xxlor %x0,%x1,%x1\n+   xxspltib %x0,0\n+   xxspltib %x0,255\n+   vspltisw %0,%1\n+   xxlxor %x0,%x0,%x0\n+   xxlorc %x0,%x0,%x0\n+   #\n+   mtvsrwz %x0,%1\n+   mfvsrwz %0,%x1\n    mf%1 %0\n    mt%0 %1\n    mt%0 %1\n    nop\"\n-  [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,mtjmpr,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4\")])\n+  [(set_attr \"type\"\n+\t\t\"*,          *,           load,        fpload,      fpload,\n+\t\t store,      fpstore,     fpstore,     *,           *,\n+\t\t *,          veclogical,  vecsimple,   vecsimple,   vecsimple,\n+\t\t veclogical, veclogical,  vecsimple,   mffgpr,      mftgpr,\n+\t\t *,           *,           *,           *\")\n+\n+   (set_attr \"length\"\n+\t\t\"4,          4,           4,           4,           4,\n+\t\t 4,          4,           4,           4,           4,\n+\t\t 8,          4,           4,           4,           4,\n+\t\t 4,          4,           8,           4,           4,\n+\t\t 4,          4,           4,           4\")])\n \n (define_insn \"*movsi_internal1_single\"\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,*c*l,*h,*h,m,*f\")\n@@ -6581,6 +6633,23 @@\n     FAIL;\n }\")\n \n+;; Split loading -128..127 to use XXSPLITB and VEXTSW2D\n+(define_split\n+  [(set (match_operand:DI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:DI 1 \"xxspltib_constant_split\" \"\"))]\n+  \"TARGET_VSX_SMALL_INTEGER && TARGET_P9_VECTOR && reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  int r = REGNO (op0);\n+  rtx op0_v16qi = gen_rtx_REG (V16QImode, r);\n+\n+  emit_insn (gen_xxspltib_v16qi (op0_v16qi, op1));\n+  emit_insn (gen_vsx_sign_extend_qi_si (operands[0], op0_v16qi));\n+  DONE;\n+})\n+\n (define_insn \"*mov<mode>_internal2\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=y,x,?y\")\n \t(compare:CC (match_operand:P 1 \"gpc_reg_operand\" \"0,r,r\")"}, {"sha": "367be2d55918a834f3bf9e96a55c9d0a8fa323b4", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -664,3 +664,7 @@ Enable using IEEE 128-bit floating point instructions.\n mfloat128-convert\n Target Undocumented Mask(FLOAT128_CVT) Var(rs6000_isa_flags)\n Enable default conversions between __float128 & long double.\n+\n+mvsx-small-integer\n+Target Report Mask(VSX_SMALL_INTEGER) Var(rs6000_isa_flags)\n+Enable small integers to be in VSX registers."}, {"sha": "18f3e86e29f237b4d6a92911271208645b0e7e37", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -263,11 +263,14 @@\n \t\t\t    (V2DI\t\"wi\")])\n \n ;; Iterators for loading constants with xxspltib\n-(define_mode_iterator VSINT_84  [V4SI V2DI DI])\n+(define_mode_iterator VSINT_84  [V4SI V2DI DI SI])\n (define_mode_iterator VSINT_842 [V8HI V4SI V2DI])\n \n-;; Iterator for ISA 3.0 vector extract/insert of integer vectors\n-(define_mode_iterator VSX_EXTRACT_I [V16QI V8HI V4SI])\n+;; Iterator for ISA 3.0 vector extract/insert of small integer vectors.\n+;; VSX_EXTRACT_I2 doesn't include V4SImode because SI extracts can be\n+;; done on ISA 2.07 and not just ISA 3.0.\n+(define_mode_iterator VSX_EXTRACT_I  [V16QI V8HI V4SI])\n+(define_mode_iterator VSX_EXTRACT_I2 [V16QI V8HI])\n \n (define_mode_attr VSX_EXTRACT_WIDTH [(V16QI \"b\")\n \t\t  \t\t     (V8HI \"h\")\n@@ -2496,7 +2499,9 @@\n \t      (clobber (match_dup 3))])]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n {\n-  operands[3] = gen_rtx_SCRATCH ((TARGET_VEXTRACTUB) ? DImode : <MODE>mode);\n+  machine_mode smode = ((<MODE>mode != V4SImode && TARGET_VEXTRACTUB)\n+\t\t\t? DImode : <MODE>mode);\n+  operands[3] = gen_rtx_SCRATCH (smode);\n })\n \n ;; Under ISA 3.0, we can use the byte/half-word/word integer stores if we are\n@@ -2505,9 +2510,9 @@\n (define_insn_and_split  \"*vsx_extract_<mode>_p9\"\n   [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r,Z\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,<VSX_EX>\")\n+\t (match_operand:VSX_EXTRACT_I2 1 \"gpc_reg_operand\" \"v,v\")\n \t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n,n\")])))\n-   (clobber (match_scratch:DI 3 \"=<VSX_EX>,<VSX_EX>\"))]\n+   (clobber (match_scratch:DI 3 \"=v,v\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n   \"#\"\n   \"&& (reload_completed || MEM_P (operands[0]))\"\n@@ -2536,8 +2541,6 @@\n \temit_insn (gen_p9_stxsibx (dest, di_tmp));\n       else if (<MODE>mode == V8HImode)\n \temit_insn (gen_p9_stxsihx (dest, di_tmp));\n-      else if (<MODE>mode == V4SImode)\n-\temit_insn (gen_stfiwx (dest, di_tmp));\n       else\n \tgcc_unreachable ();\n     }\n@@ -2570,12 +2573,70 @@\n }\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn_and_split  \"*vsx_extract_si\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,Z,Z,wJwK\")\n+\t(vec_select:SI\n+\t (match_operand:V4SI 1 \"gpc_reg_operand\" \"v,wJwK,v,v\")\n+\t (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n,n,n,n\")])))\n+   (clobber (match_scratch:V4SI 3 \"=v,wJwK,v,v\"))]\n+  \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx element = operands[2];\n+  rtx vec_tmp = operands[3];\n+  int value;\n+\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    element = GEN_INT (GET_MODE_NUNITS (V4SImode) - 1 - INTVAL (element));\n+\n+  /* If the value is in the correct position, we can avoid doing the VSPLT<x>\n+     instruction.  */\n+  value = INTVAL (element);\n+  if (value != 1)\n+    {\n+      if (TARGET_VEXTRACTUB)\n+\t{\n+\t  rtx di_tmp = gen_rtx_REG (DImode, REGNO (vec_tmp));\n+\t  emit_insn (gen_vsx_extract_v4si_di (di_tmp,src, element));\n+\t}\n+      else\n+\temit_insn (gen_altivec_vspltw_direct (vec_tmp, src, element));\n+    }\n+  else\n+    vec_tmp = src;\n+\n+  if (MEM_P (operands[0]))\n+    {\n+      if (can_create_pseudo_p ())\n+\tdest = rs6000_address_for_fpconvert (dest);\n+\n+      if (TARGET_VSX_SMALL_INTEGER)\n+\temit_move_insn (dest, gen_rtx_REG (SImode, REGNO (vec_tmp)));\n+      else\n+\temit_insn (gen_stfiwx (dest, gen_rtx_REG (DImode, REGNO (vec_tmp))));\n+    }\n+\n+  else if (TARGET_VSX_SMALL_INTEGER)\n+    emit_move_insn (dest, gen_rtx_REG (SImode, REGNO (vec_tmp)));\n+  else\n+    emit_move_insn (gen_rtx_REG (DImode, REGNO (dest)),\n+\t\t    gen_rtx_REG (DImode, REGNO (vec_tmp)));\n+\n+  DONE;\n+}\n+  [(set_attr \"type\" \"mftgpr,fpstore,fpstore,vecsimple\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn_and_split  \"*vsx_extract_<mode>_p8\"\n   [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v\")\n+\t (match_operand:VSX_EXTRACT_I2 1 \"gpc_reg_operand\" \"v\")\n \t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))\n-   (clobber (match_scratch:VSX_EXTRACT_I 3 \"=v\"))]\n+   (clobber (match_scratch:VSX_EXTRACT_I2 3 \"=v\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -2607,13 +2668,6 @@\n       else\n \tvec_tmp = src;\n     }\n-  else if (<MODE>mode == V4SImode)\n-    {\n-      if (value != 1)\n-\temit_insn (gen_altivec_vspltw_direct (vec_tmp, src, element));\n-      else\n-\tvec_tmp = src;\n-    }\n   else\n     gcc_unreachable ();\n "}, {"sha": "9f193140bea2e69a4fad9362673b6a6198de8773", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -3125,6 +3125,18 @@ Memory operand suitable for power9 fusion load/stores.\n @item wG\n Memory operand suitable for TOC fusion memory references.\n \n+@item wH\n+Altivec register if @option{-mvsx-small-integer}.\n+\n+@item wI\n+Floating point register if @option{-mvsx-small-integer}.\n+\n+@item wJ\n+FP register if @option{-mvsx-small-integer} and @option{-mpower9-vector}.\n+\n+@item wK\n+Altivec register if @option{-mvsx-small-integer} and @option{-mpower9-vector}.\n+\n @item wL\n Int constant that is the element number that the MFVSRLD instruction.\n targets."}, {"sha": "f2a0a2f7f71e183da5795d332a63fbb708f0b1b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -1,3 +1,9 @@\n+2016-10-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vsx-simode.c: New test.\n+\t* gcc.target/powerpc/vsx-simode2.c: Likewise.\n+\t* gcc.target/powerpc/vsx-simode3.c: Likewise.\n+\n 2016-10-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/78026"}, {"sha": "e4b211397890406527c7fb8badc797125db7a6af", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-simode.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode.c?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2 -mvsx-small-integer\" } */\n+\n+double load_asm_d_constraint (int *p)\n+{\n+  double ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# load d constraint\" : \"=d\" (ret) : \"d\" (*p));\n+  return ret;\n+}\n+\n+void store_asm_d_constraint (int *p, double x)\n+{\n+  int i;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# store d constraint\" : \"=d\" (i) : \"d\" (x));\n+  *p = i;\n+}\n+\n+/* { dg-final { scan-assembler \"lfiwzx\" } } */\n+/* { dg-final { scan-assembler \"stfiwx\" } } */"}, {"sha": "92553b93aa996275f3884126d1958f2792b24a9e", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-simode2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode2.c?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2 -mvsx-small-integer\" } */\n+\n+unsigned int foo (unsigned int u)\n+{\n+  unsigned int ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# v, v constraints\" : \"=v\" (ret) : \"v\" (u));\n+  return ret;\n+}\n+\n+/* { dg-final { scan-assembler \"mtvsrwz\" } } */\n+/* { dg-final { scan-assembler \"mfvsrwz\" } } */"}, {"sha": "fd15931857b5d3939bac5aee8e7b0db667df5fb5", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-simode3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787c7a65f6ec2876337e6c50a26a1da0fadcb5bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-simode3.c?ref=787c7a65f6ec2876337e6c50a26a1da0fadcb5bf", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2 -mvsx-small-integer\" } */\n+\n+double load_asm_v_constraint (int *p)\n+{\n+  double ret;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# load v constraint\" : \"=d\" (ret) : \"v\" (*p));\n+  return ret;\n+}\n+\n+void store_asm_v_constraint (int *p, double x)\n+{\n+  int i;\n+  __asm__ (\"xxlor %x0,%x1,%x1\\t# store v constraint\" : \"=v\" (i) : \"d\" (x));\n+  *p = i;\n+}\n+\n+/* { dg-final { scan-assembler \"lxsiwzx\" } } */\n+/* { dg-final { scan-assembler \"stxsiwx\" } } */"}]}