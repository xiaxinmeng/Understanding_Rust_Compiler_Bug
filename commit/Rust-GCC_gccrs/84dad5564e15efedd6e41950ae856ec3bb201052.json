{"sha": "84dad5564e15efedd6e41950ae856ec3bb201052", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkYWQ1NTY0ZTE1ZWZlZGQ2ZTQxOTUwYWU4NTZlYzNiYjIwMTA1Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:07:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:07:41Z"}, "message": "[multiple changes]\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_unst.adb (Get_Real_Subp): New subprogram.\n\t(Unnest_Subprogram): Use Get_Real_Subp.\n\t(Uplev_Refs_For_One_Subp): Skip if no ARECnU entity.\n\t(Uplev_Refs_For_One_Subp): Use actual subtype in unconstrained case.\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* a-reatim.adb (\"/\"): Add explicit check for Time_Span_First / -1.\n\n2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Extended_Primitive_Ops): New subprogram,\n\tauxiliary to Try_Primitive_Operation to handle properly prefixed\n\tcalls where the operation is not a primitive of the type, but\n\tis declared in the package body that is in the immediate scope\n\tof the type.\n\nFrom-SVN: r223036", "tree": {"sha": "af5dd7a0f9fa835673c73dc8855af294c3d07fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af5dd7a0f9fa835673c73dc8855af294c3d07fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84dad5564e15efedd6e41950ae856ec3bb201052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84dad5564e15efedd6e41950ae856ec3bb201052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84dad5564e15efedd6e41950ae856ec3bb201052", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84dad5564e15efedd6e41950ae856ec3bb201052/comments", "author": null, "committer": null, "parents": [{"sha": "ddbc55d8adbf50089321fc531dc047630958b185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbc55d8adbf50089321fc531dc047630958b185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddbc55d8adbf50089321fc531dc047630958b185"}], "stats": {"total": 217, "additions": 182, "deletions": 35}, "files": [{"sha": "e2666c62709d627a3625e9ba7ed999d7132ba8dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=84dad5564e15efedd6e41950ae856ec3bb201052", "patch": "@@ -1,3 +1,22 @@\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_unst.adb (Get_Real_Subp): New subprogram.\n+\t(Unnest_Subprogram): Use Get_Real_Subp.\n+\t(Uplev_Refs_For_One_Subp): Skip if no ARECnU entity.\n+\t(Uplev_Refs_For_One_Subp): Use actual subtype in unconstrained case.\n+\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-reatim.adb (\"/\"): Add explicit check for Time_Span_First / -1.\n+\n+2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Extended_Primitive_Ops): New subprogram,\n+\tauxiliary to Try_Primitive_Operation to handle properly prefixed\n+\tcalls where the operation is not a primitive of the type, but\n+\tis declared in the package body that is in the immediate scope\n+\tof the type.\n+\n 2015-05-12  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_util.adb (Is_Variable): Allow X'Deref(Y) as a variable."}, {"sha": "52aa9f3a372d2102f04a8dbdf67d7f4cd9602fe3", "filename": "gcc/ada/a-reatim.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2Fa-reatim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2Fa-reatim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.adb?ref=84dad5564e15efedd6e41950ae856ec3bb201052", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2014, AdaCore                     --\n+--                     Copyright (C) 1995-2015, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -123,6 +123,16 @@ package body Ada.Real_Time is\n       pragma Unsuppress (Overflow_Check);\n       pragma Unsuppress (Division_Check);\n    begin\n+      --  Even though checks are unsuppressed, we need an explicit check for\n+      --  the case of largest negative integer divided by minus one, since\n+      --  some library routines we use fail to catch this case. This will be\n+      --  fixed at the compiler level in the future, at which point this test\n+      --  can be removed.\n+\n+      if Left = Time_Span_First and then Right = -1 then\n+         raise Constraint_Error with \"overflow\";\n+      end if;\n+\n       return Time_Span (Duration (Left) / Right);\n    end \"/\";\n "}, {"sha": "446f3fc4e4a25198cdf9345f6e39e137cf4c2609", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=84dad5564e15efedd6e41950ae856ec3bb201052", "patch": "@@ -1116,9 +1116,48 @@ package body Exp_Unst is\n \n                --  Process uplevel references for one subprogram\n \n-               declare\n+               Uplev_Refs_For_One_Subp : declare\n                   Elmt : Elmt_Id;\n \n+                  function Get_Real_Subp (Ent : Entity_Id) return Entity_Id;\n+                  --  The entity recorded as the enclosing subprogram for the\n+                  --  reference sometimes turns out to be a subprogram body.\n+                  --  This function gets the proper subprogram spec if needed.\n+\n+                  -------------------\n+                  -- Get_Real_Subp --\n+                  -------------------\n+\n+                  function Get_Real_Subp (Ent : Entity_Id) return Entity_Id is\n+                     Nod : Node_Id;\n+\n+                  begin\n+                     --  If we have a subprogram, return it\n+\n+                     if Is_Subprogram (Ent) then\n+                        return Ent;\n+\n+                     --  If we have a subprogram body, go to the body\n+\n+                     elsif Ekind (Ent) = E_Subprogram_Body then\n+                        Nod := Parent (Parent (Ent));\n+                        pragma Assert (Nkind (Nod) = N_Subprogram_Body);\n+\n+                        if Acts_As_Spec (Nod) then\n+                           return Ent;\n+                        else\n+                           return Corresponding_Spec (Nod);\n+                        end if;\n+\n+                     --  Should not be any other possibilities\n+\n+                     else\n+                        raise Program_Error;\n+                     end if;\n+                  end Get_Real_Subp;\n+\n+               --  Start of processing for Uplevel_References_For_One_Subp\n+\n                begin\n                   --  Loop through uplevel references\n \n@@ -1127,7 +1166,7 @@ package body Exp_Unst is\n \n                      --  Rewrite one reference\n \n-                     declare\n+                     Rewrite_One_Ref : declare\n                         Ref : constant Node_Id := Actual_Ref (Node (Elmt));\n                         --  The reference to be rewritten\n \n@@ -1140,8 +1179,11 @@ package body Exp_Unst is\n                         Typ : constant Entity_Id := Etype (Ent);\n                         --  The type of the referenced entity\n \n+                        Atyp : constant Entity_Id := Get_Actual_Subtype (Ref);\n+                        --  The actual subtype of the reference\n+\n                         Rsub : constant Entity_Id :=\n-                                 Node (Next_Elmt (Elmt));\n+                                 Get_Real_Subp (Node (Next_Elmt (Elmt)));\n                         --  The enclosing subprogram for the reference\n \n                         RSX : constant SI_Type := Subp_Index (Rsub);\n@@ -1155,6 +1197,17 @@ package body Exp_Unst is\n                         SI   : SI_Type;\n \n                      begin\n+                        --  Ignore if no ARECnF entity for enclosing subprogram\n+                        --  which probably happens as a result of not properly\n+                        --  treating instance bodies. To be examined ???\n+\n+                        --  If this test is omitted, then the compilation of\n+                        --  freeze.adb and inline.adb fail in unnesting mode.\n+\n+                        if No (STJR.ARECnF) then\n+                           goto Continue;\n+                        end if;\n+\n                         --  Push the current scope, so that the pointer type\n                         --  Tnn, and any subsidiary entities resulting from\n                         --  the analysis of the rewritten reference, go in the\n@@ -1215,7 +1268,7 @@ package body Exp_Unst is\n \n                         Rewrite (Ref,\n                           Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Occurrence_Of (Typ, Loc),\n+                            Prefix         => New_Occurrence_Of (Atyp, Loc),\n                             Attribute_Name => Name_Deref,\n                             Expressions    => New_List (\n                               Make_Selected_Component (Loc,\n@@ -1240,12 +1293,13 @@ package body Exp_Unst is\n                         Analyze_And_Resolve (Ref, Typ, Suppress => All_Checks);\n                         Opt.Unnest_Subprogram_Mode := True;\n                         Pop_Scope;\n-                     end;\n+                     end Rewrite_One_Ref;\n \n+                  <<Continue>>\n                      Next_Elmt (Elmt);\n                      Next_Elmt (Elmt);\n                   end loop;\n-               end;\n+               end Uplev_Refs_For_One_Subp;\n             end if;\n          end;\n       end loop Uplev_Refs;"}, {"sha": "6fb250c9461272131f9e9696c4f080f423407408", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 92, "deletions": 28, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dad5564e15efedd6e41950ae856ec3bb201052/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=84dad5564e15efedd6e41950ae856ec3bb201052", "patch": "@@ -210,12 +210,12 @@ package body Sem_Ch4 is\n      (T1, T2 : Entity_Id;\n       Op_Id  : Entity_Id;\n       N      : Node_Id);\n-   --  Subsidiary procedure to Find_Arithmetic_Types. T1 and T2 are valid\n-   --  types for left and right operand. Determine whether they constitute\n-   --  a valid pair for the given operator, and record the corresponding\n-   --  interpretation of the operator node. The node N may be an operator\n-   --  node (the usual case) or a function call whose prefix is an operator\n-   --  designator. In both cases Op_Id is the operator name itself.\n+   --  Subsidiary procedure to Find_Arithmetic_Types. T1 and T2 are valid types\n+   --  for left and right operand. Determine whether they constitute a valid\n+   --  pair for the given operator, and record the corresponding interpretation\n+   --  of the operator node. The node N may be an operator node (the usual\n+   --  case) or a function call whose prefix is an operator designator. In\n+   --  both cases Op_Id is the operator name itself.\n \n    procedure Diagnose_Call (N : Node_Id; Nam : Node_Id);\n    --  Give detailed information on overloaded call where none of the\n@@ -242,6 +242,7 @@ package body Sem_Ch4 is\n    --  object E. The function returns the designated type of the prefix, taking\n    --  into account that the designated type of an anonymous access type may be\n    --  a limited view, when the non-limited view is visible.\n+   --\n    --  If in semantics only mode (-gnatc or generic), the function also records\n    --  that the prefix is a reference to E, if any. Normally, such a reference\n    --  is generated only when the implicit dereference is expanded into an\n@@ -285,7 +286,7 @@ package body Sem_Ch4 is\n    --  Ada 2005 (AI-252): Support the object.operation notation. If node N\n    --  is a call in this notation, it is transformed into a normal subprogram\n    --  call where the prefix is a parameter, and True is returned. If node\n-   --  N is not of this form, it is unchanged, and False is returned. if\n+   --  N is not of this form, it is unchanged, and False is returned. If\n    --  CW_Test_Only is true then N is an N_Selected_Component node which\n    --  is part of a call to an entry or procedure of a tagged concurrent\n    --  type and this routine is invoked to search for class-wide subprograms\n@@ -315,8 +316,10 @@ package body Sem_Ch4 is\n          if Is_Overloaded (Opnd) then\n             if Nkind (Opnd) in N_Op then\n                Nam := Opnd;\n+\n             elsif Nkind (Opnd) = N_Function_Call then\n                Nam := Name (Opnd);\n+\n             elsif Ada_Version >= Ada_2012 then\n                declare\n                   It : Interp;\n@@ -343,7 +346,8 @@ package body Sem_Ch4 is\n          end if;\n \n          if Opnd = Left_Opnd (N) then\n-            Error_Msg_N (\"\\left operand has the following interpretations\", N);\n+            Error_Msg_N\n+              (\"\\left operand has the following interpretations\", N);\n          else\n             Error_Msg_N\n               (\"\\right operand has the following interpretations\", N);\n@@ -606,7 +610,7 @@ package body Sem_Ch4 is\n \n             Type_Id := Process_Subtype (E, N);\n             Acc_Type := Create_Itype (E_Allocator_Type, N);\n-            Set_Etype                    (Acc_Type, Acc_Type);\n+            Set_Etype (Acc_Type, Acc_Type);\n             Set_Directly_Designated_Type (Acc_Type, Type_Id);\n             Check_Fully_Declared (Type_Id, N);\n \n@@ -681,21 +685,21 @@ package body Sem_Ch4 is\n \n                   else\n                      Error_Msg_N\n-                       (\"uninitialized unconstrained allocation not allowed\",\n-                        N);\n+                       (\"uninitialized unconstrained allocation not \"\n+                        & \"allowed\", N);\n \n                      if Is_Array_Type (Type_Id) then\n                         Error_Msg_N\n-                          (\"\\qualified expression or constraint with \" &\n-                           \"array bounds required\", N);\n+                          (\"\\qualified expression or constraint with \"\n+                           & \"array bounds required\", N);\n \n                      elsif Has_Unknown_Discriminants (Type_Id) then\n                         Error_Msg_N (\"\\qualified expression required\", N);\n \n                      else pragma Assert (Has_Discriminants (Type_Id));\n                         Error_Msg_N\n-                          (\"\\qualified expression or constraint with \" &\n-                           \"discriminant values required\", N);\n+                          (\"\\qualified expression or constraint with \"\n+                           & \"discriminant values required\", N);\n                      end if;\n                   end if;\n                end if;\n@@ -804,9 +808,9 @@ package body Sem_Ch4 is\n       --  Entity is not already set, so we do need to collect interpretations\n \n       else\n-         Op_Id := Get_Name_Entity_Id (Chars (N));\n          Set_Etype (N, Any_Type);\n \n+         Op_Id := Get_Name_Entity_Id (Chars (N));\n          while Present (Op_Id) loop\n             if Ekind (Op_Id) = E_Operator\n               and then Present (Next_Entity (First_Entity (Op_Id)))\n@@ -889,6 +893,7 @@ package body Sem_Ch4 is\n                         Actual);\n                      exit;\n                   end if;\n+\n                when others =>\n                   Named_Seen := True;\n             end case;\n@@ -905,10 +910,8 @@ package body Sem_Ch4 is\n       begin\n          if Is_Entity_Name (Nam) then\n             return Ekind (Entity (Nam)) = E_Function;\n-\n          elsif Nkind (Nam) = N_Selected_Component then\n             return Ekind (Entity (Selector_Name (Nam))) = E_Function;\n-\n          else\n             return False;\n          end if;\n@@ -932,8 +935,7 @@ package body Sem_Ch4 is\n                  (\"must instantiate generic procedure& before call\",\n                   Nam, Entity (Nam));\n             else\n-               Error_Msg_N\n-                 (\"procedure or entry name expected\", Nam);\n+               Error_Msg_N (\"procedure or entry name expected\", Nam);\n             end if;\n \n          --  Check for tasking cases where only an entry call will do\n@@ -1101,7 +1103,6 @@ package body Sem_Ch4 is\n          end if;\n \n          Get_First_Interp (Nam, X, It);\n-\n          while Present (It.Nam) loop\n             Nam_Ent := It.Nam;\n             Deref   := False;\n@@ -1359,7 +1360,6 @@ package body Sem_Ch4 is\n \n                if No (Alt) then\n                   Add_One_Interp (N, It.Typ, It.Typ);\n-\n                else\n                   Wrong_Alt := Alt;\n                end if;\n@@ -1685,11 +1685,11 @@ package body Sem_Ch4 is\n          end loop;\n       end if;\n \n-      --  If there was no match, and the operator is inequality, this may\n-      --  be a case where inequality has not been made explicit, as for\n-      --  tagged types. Analyze the node as the negation of an equality\n-      --  operation. This cannot be done earlier, because before analysis\n-      --  we cannot rule out the presence of an explicit inequality.\n+      --  If there was no match, and the operator is inequality, this may be\n+      --  a case where inequality has not been made explicit, as for tagged\n+      --  types. Analyze the node as the negation of an equality operation.\n+      --  This cannot be done earlier, because before analysis we cannot rule\n+      --  out the presence of an explicit inequality.\n \n       if Etype (N) = Any_Type\n         and then Nkind (N) = N_Op_Ne\n@@ -8060,6 +8060,15 @@ package body Sem_Ch4 is\n          --  subprogram because that list starts with the subprogram formals.\n          --  We retrieve the candidate operations from the generic declaration.\n \n+         function Extended_Primitive_Ops (T : Entity_Id) return Elist_Id;\n+         --  Prefix notation can also be used on operations that are not\n+         --  primitives of the type, but are declared in the same immediate\n+         --  declarative part, which can only mean the corresponding package\n+         --  body (See RM 4.1.3 (9.2/3)). If we are in that body we extend the\n+         --  list of primitives with body operations with the same name that\n+         --  may be candidates, so that Try_Primitive_Operations can examine\n+         --  them if no real primitive is found.\n+\n          function Is_Private_Overriding (Op : Entity_Id) return Boolean;\n          --  An operation that overrides an inherited operation in the private\n          --  part of its package may be hidden, but if the inherited operation\n@@ -8166,6 +8175,61 @@ package body Sem_Ch4 is\n             end if;\n          end Collect_Generic_Type_Ops;\n \n+         ----------------------------\n+         -- Extended_Primitive_Ops --\n+         ----------------------------\n+\n+         function Extended_Primitive_Ops (T : Entity_Id) return Elist_Id is\n+            Type_Scope : constant Entity_Id := Scope (T);\n+\n+            Body_Decls : List_Id;\n+            Op_Found   : Boolean;\n+            Op         : Entity_Id;\n+            Op_List    : Elist_Id;\n+\n+         begin\n+            Op_List := Primitive_Operations (T);\n+\n+            if Ekind (Type_Scope) = E_Package\n+              and then In_Package_Body (Type_Scope)\n+              and then In_Open_Scopes (Type_Scope)\n+            then\n+               --  Retrieve list of declarations of package body.\n+\n+               Body_Decls :=\n+                 Declarations\n+                   (Unit_Declaration_Node\n+                     (Corresponding_Body\n+                       (Unit_Declaration_Node (Type_Scope))));\n+\n+               Op       := Current_Entity (Subprog);\n+               Op_Found := False;\n+               while Present (Op) loop\n+                  if Comes_From_Source (Op)\n+                    and then Is_Overloadable (Op)\n+                    and then Is_List_Member (Unit_Declaration_Node (Op))\n+                    and then List_Containing (Unit_Declaration_Node (Op)) =\n+                                                                   Body_Decls\n+                  then\n+                     if not Op_Found then\n+\n+                        --  Copy list of primitives so it is not affected for\n+                        --  other uses.\n+\n+                        Op_List  := New_Copy_Elist (Op_List);\n+                        Op_Found := True;\n+                     end if;\n+\n+                     Append_Elmt (Op, Op_List);\n+                  end if;\n+\n+                  Op := Homonym (Op);\n+               end loop;\n+            end if;\n+\n+            return Op_List;\n+         end Extended_Primitive_Ops;\n+\n          ---------------------------\n          -- Is_Private_Overriding --\n          ---------------------------\n@@ -8237,7 +8301,7 @@ package body Sem_Ch4 is\n \n          elsif not Is_Generic_Type (Obj_Type) then\n             Corr_Type := Obj_Type;\n-            Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n+            Elmt := First_Elmt (Extended_Primitive_Ops (Obj_Type));\n \n          else\n             Corr_Type := Obj_Type;"}]}