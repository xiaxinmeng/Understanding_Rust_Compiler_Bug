{"sha": "8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUwOWE3MjZlNjJjNmFkZTllYTI1ZTFmMWE5MjY5MTQxY2U3M2U4MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2016-12-12T17:00:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2016-12-12T17:00:37Z"}, "message": "re PR other/78252 (C++ demangler crashes with infinite recursion with lambda (auto))\n\n\tlibiberty/\n\tPR c++/78252\n\t* cp-demangle.c (struct d_print_info): Add is_lambda_arg field.\n\t(d_print_init): Initialize it.\n\t(d_print_comp_inner) <DEMANGLE_COMPONENT_TEMPLATE_PARAM>: Check\n\tis_lambda_arg for auto.\n\t<DEMANGLE_COMPONENT_REFERENCE,\n\tDEMANGLE_COMPONENT_RVALUE_REFERENCE>: Skip smashing check when\n\tis_lambda_arg.\n\t<DEMANGLE_COMPONENT_LAMBDA>: Increment is_lambda_arg around arg\n\tprinting.\n\t* testsuite/demangle-expected: Add lambda auto mangling cases.\n\n\tgcc/testsuite/\n\tPR c++/78252\n\t* g++.dg/cpp1y/lambda-mangle-1.C: New.\n\nFrom-SVN: r243566", "tree": {"sha": "5ef5a0b7cfb58687079b847ea9b92a24032c250c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ef5a0b7cfb58687079b847ea9b92a24032c250c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b8cab8a5492e9639fc9f0ff23f5c392ac395e8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8cab8a5492e9639fc9f0ff23f5c392ac395e8a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8cab8a5492e9639fc9f0ff23f5c392ac395e8a2"}], "stats": {"total": 197, "additions": 175, "deletions": 22}, "files": [{"sha": "982a203ec65c144b249d5bc53ff2d56f5676e878", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "patch": "@@ -1,3 +1,8 @@\n+2016-12-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/78252\n+\t* g++.dg/cpp1y/lambda-mangle-1.C: New.\n+\n 2016-12-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78738"}, {"sha": "ca0910be5031ae2b49a7f35962890ec3cc4838ca", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1.C?ref=8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "patch": "@@ -0,0 +1,88 @@\n+// { dg-do compile { target c++14 } }\n+\n+// PRs 78621\n+\n+// We erroneously mangled lambda auto parms as-if template parameters (T<n>_),\n+// rather than auto (Da). Fixed in abi version 11\n+\n+template<typename T> class X;\n+\n+template<typename T>\n+T &&forward (T &v)\n+{\n+  return static_cast<T &&> (v);\n+}\n+\n+template<typename T>\n+void eat (T &v)\n+{\n+}\n+\n+template<typename S, typename T>\n+  void eat (S &, T &v)\n+{\n+}\n+\n+void Foo ()\n+{\n+  auto lam = [](auto &) { };\n+  auto lam_1 = [](int &, auto &) { };\n+  auto lam_2 = [](auto &, X<int> &) { };\n+  auto lam_3 = [](auto (*)[5]) { };\n+\n+  forward (lam);\n+  forward (lam_1);\n+  forward (lam_2);\n+  forward (lam_3);\n+\n+  eat (lam);\n+  eat (lam_1);\n+  eat (lam_2);\n+  eat (lam_3);\n+\n+  // The auto lambda should mangle similarly to the non-auto one\n+  auto lambda_1 = [](float *, float *) { };\n+  auto lambda_2 = [](auto *, auto *) { };\n+  auto lambda_3 = [](auto *, auto *) { };\n+\n+  int *i;\n+  \n+  eat (i, lambda_1);\n+  eat (i, lambda_2);\n+\n+  // The autos should squangle to the first one.\n+  eat (lambda_2, lambda_3);\n+}\n+\n+template<typename X> void Bar ()\n+{\n+  auto lambda_1 = [](X *, float *, float *) { };\n+  auto lambda_2 = [](X *, auto *, auto *) { };\n+  auto lambda_3 = [](X *, auto *...) {};\n+  \n+  int *i;\n+  \n+  eat (i, lambda_1);\n+  eat (i, lambda_2);\n+  eat (i, lambda_3);\n+}\n+\n+void Baz ()\n+{\n+  Bar<short> ();\n+}\n+\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_E_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRiRT_E0_EOS1_S2_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_R1XIiEE1_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlPA5_T_E2_EOS0_RS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_E_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRiRT_E0_EvS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_R1XIiEE1_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPA5_T_E2_EvRS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPfS1_E3_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPT_PT0_E4_EvRS1_RS3_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPT_PT0_E4_Z3FoovEUlS1_S3_E5_EvRS0_RS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPT_zE1_EvRS3_RT0_:\" } }"}, {"sha": "f2e6b373e01a0c997c697e9511b1df3909e11eb7", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "patch": "@@ -1,3 +1,17 @@\n+2016-12-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/78252\n+\t* cp-demangle.c (struct d_print_info): Add is_lambda_arg field.\n+\t(d_print_init): Initialize it.\n+\t(d_print_comp_inner) <DEMANGLE_COMPONENT_TEMPLATE_PARAM>: Check\n+\tis_lambda_arg for auto.\n+\t<DEMANGLE_COMPONENT_REFERENCE,\n+\tDEMANGLE_COMPONENT_RVALUE_REFERENCE>: Skip smashing check when\n+\tis_lambda_arg.\n+\t<DEMANGLE_COMPONENT_LAMBDA>: Increment is_lambda_arg around arg\n+\tprinting.\n+\t* testsuite/demangle-expected: Add lambda auto mangling cases. \n+\n 2016-12-06  DJ Delorie  <dj@redhat.com>\n \n \t* argv.c (expandargv): Check for directories passed as @-files."}, {"sha": "6c2f902955e6a298b98b645d86ad1e1b4e617391", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "patch": "@@ -343,6 +343,9 @@ struct d_print_info\n   struct d_print_mod *modifiers;\n   /* Set to 1 if we saw a demangling error.  */\n   int demangle_failure;\n+  /* Non-zero if we're printing a lambda argument.  A template\n+     parameter reference actually means 'auto'.  */\n+  int is_lambda_arg;\n   /* The current index into any template argument packs we are using\n      for printing, or -1 to print the whole pack.  */\n   int pack_index;\n@@ -4126,6 +4129,7 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n   dpi->opaque = opaque;\n \n   dpi->demangle_failure = 0;\n+  dpi->is_lambda_arg = 0;\n \n   dpi->component_stack = NULL;\n \n@@ -4783,33 +4787,41 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       }\n \n     case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n-      {\n-\tstruct d_print_template *hold_dpt;\n-\tstruct demangle_component *a = d_lookup_template_argument (dpi, dc);\n-\n-\tif (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n-\t  a = d_index_template_argument (a, dpi->pack_index);\n+      if (dpi->is_lambda_arg)\n+\t{\n+\t  /* Show the template parm index, as that's how g++ displays\n+\t     these, and future proofs us against potential\n+\t     '[]<typename T> (T *a, T *b) {...}'.  */\n+\t  d_append_buffer (dpi, \"auto:\", 5);\n+\t  d_append_num (dpi, dc->u.s_number.number + 1);\n+\t}\n+      else\n+\t{\n+\t  struct d_print_template *hold_dpt;\n+\t  struct demangle_component *a = d_lookup_template_argument (dpi, dc);\n \n-\tif (a == NULL)\n-\t  {\n-\t    d_print_error (dpi);\n-\t    return;\n-\t  }\n+\t  if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n+\t    a = d_index_template_argument (a, dpi->pack_index);\n \n-\t/* While processing this parameter, we need to pop the list of\n-\t   templates.  This is because the template parameter may\n-\t   itself be a reference to a parameter of an outer\n-\t   template.  */\n+\t  if (a == NULL)\n+\t    {\n+\t      d_print_error (dpi);\n+\t      return;\n+\t    }\n \n-\thold_dpt = dpi->templates;\n-\tdpi->templates = hold_dpt->next;\n+\t  /* While processing this parameter, we need to pop the list\n+\t     of templates.  This is because the template parameter may\n+\t     itself be a reference to a parameter of an outer\n+\t     template.  */\n \n-\td_print_comp (dpi, options, a);\n+\t  hold_dpt = dpi->templates;\n+\t  dpi->templates = hold_dpt->next;\n \n-\tdpi->templates = hold_dpt;\n+\t  d_print_comp (dpi, options, a);\n \n-\treturn;\n-      }\n+\t  dpi->templates = hold_dpt;\n+\t}\n+      return;\n \n     case DEMANGLE_COMPONENT_CTOR:\n       d_print_comp (dpi, options, dc->u.s_ctor.name);\n@@ -4946,7 +4958,8 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       {\n \t/* Handle reference smashing: & + && = &.  */\n \tconst struct demangle_component *sub = d_left (dc);\n-\tif (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n+\tif (!dpi->is_lambda_arg\n+\t    && sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n \t  {\n \t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n \t    struct demangle_component *a;\n@@ -5616,7 +5629,11 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \n     case DEMANGLE_COMPONENT_LAMBDA:\n       d_append_string (dpi, \"{lambda(\");\n+      /* Generic lambda auto parms are mangled as the template type\n+\t parm they are.  */\n+      dpi->is_lambda_arg++;\n       d_print_comp (dpi, options, dc->u.s_unary_num.sub);\n+      dpi->is_lambda_arg--;\n       d_append_string (dpi, \")#\");\n       d_append_num (dpi, dc->u.s_unary_num.num + 1);\n       d_append_char (dpi, '}');"}, {"sha": "803decdb096babc2e1b3d4e7bdac3dda2f83aff2", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e09a726e62c6ade9ea25e1f1a9269141ce73e81/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=8e09a726e62c6ade9ea25e1f1a9269141ce73e81", "patch": "@@ -4634,3 +4634,32 @@ _Z12binary_rightIJLi1ELi2ELi3EEEv1AIXfRplT_LiEEE\n # ?: expression with missing third component could crash.\n AquT_quT_4mxautouT_4mxxx\n AquT_quT_4mxautouT_4mxxx\n+\n+# pr c++/78252 generic lambda mangling uses template parms, and leads\n+# to unbounded recursion if not dealt with properly\n+_Z7forwardIRZ3FoovEUlRT_E_EOS0_S1_\n+Foo()::{lambda(auto:1&)#1}& forward<Foo()::{lambda(auto:1&)#1}&>(Foo()::{lambda(auto:1&)#1}&)\n+\n+_Z7forwardIZ3FoovEUlRiRT_E_EOS1_S2_\n+Foo()::{lambda(int&, auto:1&)#1}&& forward<Foo()::{lambda(int&, auto:1&)#1}>(Foo()::{lambda(int&, auto:1&)#1}&)\n+\n+_Z7forwardIZ3FoovEUlRT_R1XIiEE0_EOS0_S1_\n+Foo()::{lambda(auto:1&, X<int>&)#2}&& forward<Foo()::{lambda(auto:1&, X<int>&)#2}>(Foo()::{lambda(auto:1&, X<int>&)#2}&)\n+\n+_Z7forwardIZ3FoovEUlPA5_T_E1_EOS0_RS0_\n+Foo()::{lambda(auto:1 (*&&forward<Foo()::{lambda(auto:1 (*) [5])#3}>(auto:1&)) [5])#3}\n+\n+_Z3eatIZ3FoovEUlRiRT_E_EvS2_\n+void eat<Foo()::{lambda(int&, auto:1&)#1}>(Foo()::{lambda(int&, auto:1&)#1}&)\n+\n+_Z3eatIZ3FoovEUlRT_R1XIiEE0_EvS1_\n+void eat<Foo()::{lambda(auto:1&, X<int>&)#2}>(Foo()::{lambda(auto:1&, X<int>&)#2}&)\n+\n+_Z3eatIZ3FoovEUlPA5_T_E1_EvRS0_\n+void eat<Foo()::{lambda(auto:1 (*) [5])#3}>(Foo()::{lambda(auto:1 (*&) [5])#3})\n+\n+_Z3eatIPiZ3FoovEUlPT_PT0_E4_EvRS1_RS3_\n+void eat<int*, Foo()::{lambda(auto:1*, auto:2*)#6}>(int*&, Foo()::{lambda(auto:1*, auto:2*)#6}&)\n+\n+_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_\n+void eat<int*, void Bar<short>()::{lambda(short*, auto:1*, auto:2*)#2}>(int*&, void Bar<short>()::{lambda(short*, auto:1*, auto:2*)#2}&)"}]}