{"sha": "b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNhNjk5OTMwYjdiNjFkMzc3NTNlODcxNDkyOWNkMmQ5YzFmYjZkOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:37:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:37:28Z"}, "message": "[multiple changes]\n\n2014-01-27  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_smem.adb (Expand_Shared_Passive_Variable): For a reference\n\tto a shared variable as an OUT formal in a call to an init proc,\n\tthe 'Read call must be emitted after, not before, the call.\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Remove mention of AUTO mode for SPARK_Mode pragma.\n\nFrom-SVN: r207139", "tree": {"sha": "86a77549b0ac95156b535e113eed4b6b7b55122b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86a77549b0ac95156b535e113eed4b6b7b55122b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/comments", "author": null, "committer": null, "parents": [{"sha": "f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1"}], "stats": {"total": 158, "additions": 95, "deletions": 63}, "files": [{"sha": "3cebcd067c11df57914400c864973b044b5e8106", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "patch": "@@ -1,3 +1,13 @@\n+2014-01-27  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_smem.adb (Expand_Shared_Passive_Variable): For a reference\n+\tto a shared variable as an OUT formal in a call to an init proc,\n+\tthe 'Read call must be emitted after, not before, the call.\n+\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Remove mention of AUTO mode for SPARK_Mode pragma.\n+\n 2014-01-27  Robert Dewar  <dewar@adacore.com>\n \n \t* a-wichha.adb (Character_Set_Version): Change to output proper"}, {"sha": "2b83105ef8fb011349495eff57f8e63cb565cb25", "filename": "gcc/ada/exp_smem.adb", "status": "modified", "additions": 74, "deletions": 48, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,7 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Nmake;    use Nmake;\n with Namet;    use Namet;\n@@ -49,36 +50,38 @@ package body Exp_Smem is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Add_Read_Before (N : Node_Id);\n-   --  Insert a Shared_Var_ROpen call for variable before node N\n+   procedure Add_Read (N : Node_Id; Call : Node_Id := Empty);\n+   --  Insert a Shared_Var_ROpen call for variable before node N, unless\n+   --  Call is a call to an init-proc, in which case the call is inserted\n+   --  after Call.\n \n    procedure Add_Write_After (N : Node_Id);\n-   --  Insert a Shared_Var_WOpen call for variable after the node\n-   --  Insert_Node, as recorded by On_Lhs_Of_Assignment (where it points\n-   --  to the assignment statement) or Is_Out_Actual (where it points to\n-   --  the procedure call statement).\n+   --  Insert a Shared_Var_WOpen call for variable after the node Insert_Node,\n+   --  as recorded by On_Lhs_Of_Assignment (where it points to the assignment\n+   --  statement) or Is_Out_Actual (where it points to the procedure call\n+   --  statement).\n \n    procedure Build_Full_Name (E : Entity_Id; N : out String_Id);\n    --  Build the fully qualified string name of a shared variable\n \n    function On_Lhs_Of_Assignment (N : Node_Id) return Boolean;\n-   --  Determines if N is on the left hand of the assignment. This means\n-   --  that either it is a simple variable, or it is a record or array\n-   --  variable with a corresponding selected or indexed component on\n-   --  the left side of an assignment. If the result is True, then\n-   --  Insert_Node is set to point to the assignment\n+   --  Determines if N is on the left hand of the assignment. This means that\n+   --  either it is a simple variable, or it is a record or array variable with\n+   --  a corresponding selected or indexed component on the left side of an\n+   --  assignment. If the result is True, then Insert_Node is set to point\n+   --  to the assignment\n \n    function Is_Out_Actual (N : Node_Id) return Boolean;\n-   --  In a similar manner, this function determines if N appears as an\n-   --  OUT or IN OUT parameter to a procedure call. If the result is\n-   --  True, then Insert_Node is set to point to the call.\n+   --  In a similar manner, this function determines if N appears as an OUT\n+   --  or IN OUT parameter to a procedure call. If the result is True, then\n+   --  Insert_Node is set to point to the call.\n \n    function Build_Shared_Var_Proc_Call\n      (Loc : Source_Ptr;\n       E   : Node_Id;\n       N   : Name_Id) return Node_Id;\n-   --  Build a call to support procedure N for shared object E (provided by\n-   --  the instance of System.Shared_Storage.Shared_Var_Procs associated to E).\n+   --  Build a call to support procedure N for shared object E (provided by the\n+   --  instance of System.Shared_Storage.Shared_Var_Procs associated to E).\n \n    --------------------------------\n    -- Build_Shared_Var_Proc_Call --\n@@ -87,7 +90,8 @@ package body Exp_Smem is\n    function Build_Shared_Var_Proc_Call\n      (Loc : Source_Ptr;\n       E   : Entity_Id;\n-      N   : Name_Id) return Node_Id is\n+      N   : Name_Id) return Node_Id\n+   is\n    begin\n       return Make_Procedure_Call_Statement (Loc,\n         Name => Make_Selected_Component (Loc,\n@@ -96,18 +100,26 @@ package body Exp_Smem is\n           Selector_Name => Make_Identifier (Loc, N)));\n    end Build_Shared_Var_Proc_Call;\n \n-   ---------------------\n-   -- Add_Read_Before --\n-   ---------------------\n+   --------------\n+   -- Add_Read --\n+   --------------\n \n-   procedure Add_Read_Before (N : Node_Id) is\n+   procedure Add_Read (N : Node_Id; Call : Node_Id := Empty) is\n       Loc : constant Source_Ptr := Sloc (N);\n       Ent : constant Node_Id    := Entity (N);\n+      SVC : Node_Id;\n+\n    begin\n       if Present (Shared_Var_Procs_Instance (Ent)) then\n-         Insert_Action (N, Build_Shared_Var_Proc_Call (Loc, Ent, Name_Read));\n+         SVC := Build_Shared_Var_Proc_Call (Loc, Ent, Name_Read);\n+\n+         if Present (Call) and then Is_Init_Proc (Name (Call)) then\n+            Insert_After_And_Analyze (Call, SVC);\n+         else\n+            Insert_Action (N, SVC);\n+         end if;\n       end if;\n-   end Add_Read_Before;\n+   end Add_Read;\n \n    -------------------------------\n    -- Add_Shared_Var_Lock_Procs --\n@@ -121,10 +133,10 @@ package body Exp_Smem is\n \n    begin\n       --  We have to add Shared_Var_Lock and Shared_Var_Unlock calls around\n-      --  the procedure or function call node. First we locate the right\n-      --  place to do the insertion, which is the call itself in the\n-      --  procedure call case, or else the nearest non subexpression\n-      --  node that contains the function call.\n+      --  the procedure or function call node. First we locate the right place\n+      --  to do the insertion, which is the call itself in the procedure call\n+      --  case, or else the nearest non subexpression node that contains the\n+      --  function call.\n \n       Inode := N;\n       while Nkind (Inode) /= N_Procedure_Call_Statement\n@@ -135,11 +147,11 @@ package body Exp_Smem is\n \n       --  Now insert the Lock and Unlock calls and the read/write calls\n \n-      --  Two concerns here. First we are not dealing with the exception\n-      --  case, really we need some kind of cleanup routine to do the\n-      --  Unlock. Second, these lock calls should be inside the protected\n-      --  object processing, not outside, otherwise they can be done at\n-      --  the wrong priority, resulting in dead lock situations ???\n+      --  Two concerns here. First we are not dealing with the exception case,\n+      --  really we need some kind of cleanup routine to do the Unlock. Second,\n+      --  these lock calls should be inside the protected object processing,\n+      --  not outside, otherwise they can be done at the wrong priority,\n+      --  resulting in dead lock situations ???\n \n       Build_Full_Name (Obj, Vnm);\n \n@@ -171,7 +183,6 @@ package body Exp_Smem is\n          Insert_After_And_Analyze (Inode,\n            Build_Shared_Var_Proc_Call (Loc, Obj, Name_Write));\n       end if;\n-\n    end Add_Shared_Var_Lock_Procs;\n \n    ---------------------\n@@ -235,23 +246,41 @@ package body Exp_Smem is\n       if Is_Limited_Type (Typ) or else Is_Concurrent_Type (Typ) then\n          return;\n \n-      --  If we are on the left hand side of an assignment, then we add\n-      --  the write call after the assignment.\n+      --  If we are on the left hand side of an assignment, then we add the\n+      --  write call after the assignment.\n \n       elsif On_Lhs_Of_Assignment (N) then\n          Add_Write_After (N);\n \n-      --  If we are a parameter for an out or in out formal, then put\n-      --  the read before and the write after.\n+      --  If we are a parameter for an out or in out formal, then in general\n+      --  we do:\n+\n+      --    read\n+      --    call\n+      --    write\n+\n+      --  but in the special case of a call to an init proc, we need to first\n+      --  call the init proc (to set discriminants), then read (to possibly\n+      --  set other components), then write (to record the updated components\n+      --  to the backing store):\n+\n+      --    init-proc-call\n+      --    read\n+      --    write\n \n       elsif Is_Out_Actual (N) then\n-         Add_Read_Before (N);\n+\n+         --  Note: For an init proc call, Add_Read inserts just after the\n+         --  call node, and we want to have first the read, then the write,\n+         --  so we need to first Add_Write_After, then Add_Read.\n+\n          Add_Write_After (N);\n+         Add_Read (N, Call => Insert_Node);\n \n       --  All other cases are simple reads\n \n       else\n-         Add_Read_Before (N);\n+         Add_Read (N);\n       end if;\n    end Expand_Shared_Passive_Variable;\n \n@@ -297,8 +326,7 @@ package body Exp_Smem is\n \n       SVP_Instance : constant Entity_Id := Make_Defining_Identifier (Loc,\n                        Chars => New_External_Name (Chars (Ent), 'G'));\n-      --  Instance of System.Shared_Storage.Shared_Var_Procs associated\n-      --  with Ent.\n+      --  Instance of Shared_Storage.Shared_Var_Procs associated with Ent\n \n       Instantiation : Node_Id;\n       --  Package instantiation node for SVP_Instance\n@@ -308,9 +336,9 @@ package body Exp_Smem is\n    begin\n       Build_Full_Name (Ent, Vnm);\n \n-      --  We turn off Shared_Passive during construction and analysis of\n-      --  the generic package instantiation, to avoid improper attempts to\n-      --  process the variable references within these instantiation.\n+      --  We turn off Shared_Passive during construction and analysis of the\n+      --  generic package instantiation, to avoid improper attempts to process\n+      --  the variable references within these instantiation.\n \n       Set_Is_Shared_Passive (Ent, False);\n \n@@ -376,9 +404,7 @@ package body Exp_Smem is\n             return False;\n          end if;\n \n-      elsif (Nkind (P) = N_Indexed_Component\n-               or else\n-             Nkind (P) = N_Selected_Component)\n+      elsif Nkind_In (P, N_Indexed_Component, N_Selected_Component)\n         and then N = Prefix (P)\n       then\n          return On_Lhs_Of_Assignment (P);"}, {"sha": "6f04498d4f9b1a80730dfcc2707741c98c02b1de", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a699930b7b61d37753e8714929cd2d9c1fb6d8/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "patch": "@@ -6305,7 +6305,7 @@ is needed for error messages issued by all phases of the compiler.\n Syntax:\n \n @smallexample @c ada\n-pragma SPARK_Mode [ (On | Off | Auto) ] ;\n+pragma SPARK_Mode [(On | Off)] ;\n @end smallexample\n \n @noindent\n@@ -6315,16 +6315,14 @@ language. The pragma is intended for use with formal verification tools\n and has no effect on the generated code.\n \n The SPARK_Mode pragma is used to specify the value of the SPARK_Mode aspect\n-(a three-valued aspect having values of On, Off, or Auto) of an entity.\n+(either Off or On) of an entity.\n More precisely, it is used to specify the aspect value of a ``section''\n of an entity (the term ``section'' is defined below).\n If a Spark_Mode pragma's (optional) argument is omitted,\n an implicit argument of On is assumed.\n \n A SPARK_Mode pragma may be used as a configuration pragma and then has the\n-semantics described below. A SPARK_Mode pragma which is not used as a\n-configuration pragma (or an equivalent SPARK_Mode aspect_specification)\n-shall not have an argument of Auto.\n+semantics described below.\n \n A SPARK_Mode pragma can be used as a local pragma only\n in the following contexts:\n@@ -6374,8 +6372,7 @@ completion is defined to have 2 ``sections'': its declaration and its\n completion. Any other construct is defined to have 1 section.\n \n The SPARK_Mode aspect value of an arbitrary section of an arbitrary Ada entity\n-or construct is then defined to be the following value (except if this yields\n-a result of Auto for a non-package; see below):\n+or construct is then defined to be the following value:\n \n @itemize\n \n@@ -6392,7 +6389,7 @@ else for any of the visible part or body declarations of a library unit package\n or either section of a library unit subprogram, if there is an applicable\n SPARK_Mode configuration pragma then the value specified by the\n pragma; if no such configuration pragma applies, then an implicit\n-specification of Auto is assumed;\n+specification of Off is assumed;\n \n @item\n else for any subsequent (i.e., not the first) section of a library unit\n@@ -6404,12 +6401,11 @@ or subprogram;\n \n @end itemize\n \n-If the above computation yields a result of Auto for any construct other than\n-one of the four sections of a package, then a result of On or Off is\n-determined instead based on the legality (with respect to the rules of\n-SPARK 2014) of the construct. The construct's SPARK_Mode is On if and only\n-if the construct is in SPARK 2014. [A SPARK_Mode of\n-Auto is therefore only possible for sections of a package.]\n+If the above computation does not specify a SPARK_Mode setting for any\n+construct other than one of the four sections of a package, then a result of On\n+or Off is determined instead based on the legality (with respect to the rules\n+of SPARK 2014) of the construct. The construct's SPARK_Mode is On if and only\n+if the construct is in SPARK 2014.\n \n If an earlier section of an entity has a Spark_Mode of Off, then the\n Spark_Mode aspect of any later section of that entity shall not be\n@@ -12472,7 +12468,7 @@ See A.3.5(3).\n @end cartouche\n @noindent\n @code{Ada.Wide_Characters.Handling.Character_Set_Version} returns\n-the string \"Unicode 6.2\", referring to version 6.2.x of the\n+the string \"Unicode 4.0\", referring to version 4.0 of the\n Unicode specification.\n \n @sp 1"}]}