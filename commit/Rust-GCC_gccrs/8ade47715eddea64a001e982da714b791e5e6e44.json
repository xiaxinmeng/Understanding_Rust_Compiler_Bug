{"sha": "8ade47715eddea64a001e982da714b791e5e6e44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkZTQ3NzE1ZWRkZWE2NGEwMDFlOTgyZGE3MTRiNzkxZTVlNmU0NA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-18T21:22:06Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-18T21:22:06Z"}, "message": "jvm.h (_Jv_GetJavaVM): Declare.\n\n\t* include/jvm.h (_Jv_GetJavaVM): Declare.\n\t* include/java-interp.h (_Jv_GetFirstMethod): New function.\n\t(_Jv_MethodBase::get_method): New method.\n\t(_Jv_JNIMethod::set_function): New method.\n\t* jni.cc (_Jv_JNI_UnregisterNatives): New function.\n\t(_Jv_JNI_RegisterNatives): New function.\n\t(_Jv_JNIFunctions): Updated for new functions.\n\t(_Jv_GetJavaVM): New function.\n\t(_Jv_JNI_GetJavaVM): Use it.  Now static.\n\t(_Jv_JNI_AttachCurrentThread): Create a new JNIEnv if this thread\n\tis already a Java thread but does not have a JNIEnv yet.\n\n\t* java/lang/natRuntime.cc (_load): Pass the JavaVM to the onload\n\tfunction.\n\nFrom-SVN: r32056", "tree": {"sha": "6637b7627b283f1bc28869d88ab6c8eecc6e22fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6637b7627b283f1bc28869d88ab6c8eecc6e22fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ade47715eddea64a001e982da714b791e5e6e44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ade47715eddea64a001e982da714b791e5e6e44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ade47715eddea64a001e982da714b791e5e6e44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ade47715eddea64a001e982da714b791e5e6e44/comments", "author": null, "committer": null, "parents": [{"sha": "31e890f0f32d3132d0519f640203060a9fc0f0a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e890f0f32d3132d0519f640203060a9fc0f0a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e890f0f32d3132d0519f640203060a9fc0f0a6"}], "stats": {"total": 149, "additions": 135, "deletions": 14}, "files": [{"sha": "fb2e46a48cfb397dc39da7caddb23d5607325a62", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8ade47715eddea64a001e982da714b791e5e6e44", "patch": "@@ -1,3 +1,20 @@\n+2000-02-18  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* include/jvm.h (_Jv_GetJavaVM): Declare.\n+\t* include/java-interp.h (_Jv_GetFirstMethod): New function.\n+\t(_Jv_MethodBase::get_method): New method.\n+\t(_Jv_JNIMethod::set_function): New method.\n+\t* jni.cc (_Jv_JNI_UnregisterNatives): New function.\n+\t(_Jv_JNI_RegisterNatives): New function.\n+\t(_Jv_JNIFunctions): Updated for new functions.\n+\t(_Jv_GetJavaVM): New function.\n+\t(_Jv_JNI_GetJavaVM): Use it.  Now static.\n+\t(_Jv_JNI_AttachCurrentThread): Create a new JNIEnv if this thread\n+\tis already a Java thread but does not have a JNIEnv yet.\n+\n+\t* java/lang/natRuntime.cc (_load): Pass the JavaVM to the onload\n+\tfunction.\n+\n 2000-02-17  Tom Tromey  <tromey@cygnus.com>\n \n \t* gcj/field.h (_Jv_Field::getClass): Don't use JvAssert."}, {"sha": "3f33d54bb555688be1bc0312983dd340edd5f2fe", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=8ade47715eddea64a001e982da714b791e5e6e44", "patch": "@@ -79,6 +79,12 @@ class _Jv_MethodBase\n \n   // Size of raw arguments.\n   _Jv_ushort args_raw_size;\n+\n+public:\n+  _Jv_Method *get_method ()\n+  {\n+    return self;\n+  }\n };\n \n class _Jv_InterpMethod : public _Jv_MethodBase\n@@ -156,8 +162,16 @@ class _Jv_InterpClass : public java::lang::Class\n   friend void  _Jv_PrepareClass(jclass);\n   friend void  _Jv_InitField (jobject, jclass, int);\n   friend void* _Jv_MarkObj (void *, void *, void *, void *);\n+\n+  friend _Jv_MethodBase ** _Jv_GetFirstMethod (_Jv_InterpClass *klass);\n };\n \n+extern inline _Jv_MethodBase **\n+_Jv_GetFirstMethod (_Jv_InterpClass *klass)\n+{\n+  return klass->interpreted_methods;\n+}\n+\n struct _Jv_ResolvedMethod {\n   jint            stack_item_count;\t\n   jint            vtable_index;\t\n@@ -190,6 +204,13 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n \n   friend class _Jv_ClassReader;\n   friend void _Jv_PrepareClass(jclass);\n+\n+public:\n+  // FIXME: this is ugly.\n+  void set_function (void *f)\n+  {\n+    function = f;\n+  }\n };\n \n #endif /* INTERPRETER */"}, {"sha": "40a0c2a983005df6d14113928a5a486402d0ab7d", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=8ade47715eddea64a001e982da714b791e5e6e44", "patch": "@@ -211,4 +211,7 @@ extern void _Jv_JNI_Init (void);\n _Jv_JNIEnv *_Jv_GetCurrentJNIEnv ();\n void _Jv_SetCurrentJNIEnv (_Jv_JNIEnv *);\n \n+struct _Jv_JavaVM;\n+_Jv_JavaVM *_Jv_GetJavaVM ();\n+\n #endif /* __JAVA_JVM_H__ */"}, {"sha": "eb1d477002a0e8bca7b93ff6682c2f1f201bf947", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=8ade47715eddea64a001e982da714b791e5e6e44", "patch": "@@ -135,8 +135,13 @@ java::lang::Runtime::_load (jstring path, jboolean do_search)\n   void *onload = lt_dlsym (h, \"JNI_OnLoad\");\n   if (onload != NULL)\n     {\n-      // FIXME: need invocation API to get JavaVM.\n-      jint vers = ((jint (*) (...)) onload) (NULL, NULL);\n+      JavaVM *vm = _Jv_GetJavaVM ();\n+      if (vm == NULL)\n+\t{\n+\t  // FIXME: what?\n+\t  return;\n+\t}\n+      jint vers = ((jint (*) (JavaVM *, void *)) onload) (vm, NULL);\n       if (vers != JNI_VERSION_1_1 && vers != JNI_VERSION_1_2)\n \t{\n \t  // FIXME: unload the library."}, {"sha": "42c0d07a0995f2a2090eb589461e0936bf698020", "filename": "libjava/jni.cc", "status": "modified", "additions": 87, "deletions": 12, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ade47715eddea64a001e982da714b791e5e6e44/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=8ade47715eddea64a001e982da714b791e5e6e44", "patch": "@@ -1258,6 +1258,63 @@ _Jv_JNI_FromReflectedMethod (JNIEnv *, jobject method)\n     _Jv_FromReflectedConstructor (reinterpret_cast<Constructor *> (method));\n }\n \n+static jint\n+_Jv_JNI_RegisterNatives (JNIEnv *env, jclass k,\n+\t\t\t const JNINativeMethod *methods,\n+\t\t\t jint nMethods)\n+{\n+  // For now, this only matters for interpreted methods.  FIXME.\n+  if (! _Jv_IsInterpretedClass (k))\n+    {\n+      // FIXME: throw exception.\n+      return JNI_ERR;\n+    }\n+  _Jv_InterpClass *klass = reinterpret_cast<_Jv_InterpClass *> (k);\n+\n+  // Look at each descriptor given us, and find the corresponding\n+  // method in the class.\n+  for (int j = 0; j < nMethods; ++j)\n+    {\n+      bool found = false;\n+\n+      _Jv_MethodBase **imeths = _Jv_GetFirstMethod (klass);\n+      for (int i = 0; i < JvNumMethods (klass); ++i)\n+\t{\n+\t  _Jv_MethodBase *meth = imeths[i];\n+\t  _Jv_Method *self = meth->get_method ();\n+\n+\t  if (! strcmp (self->name->data, methods[j].name)\n+\t      && ! strcmp (self->signature->data, methods[j].signature))\n+\t    {\n+\t      if (! (self->accflags\n+\t\t     & java::lang::reflect::Modifier::NATIVE))\n+\t\tbreak;\n+\n+\t      // Found a match that is native.\n+\t      _Jv_JNIMethod *jmeth = reinterpret_cast<_Jv_JNIMethod *> (meth);\n+\t      jmeth->set_function (methods[i].fnPtr);\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (! found)\n+\t{\n+\t  jstring m = JvNewStringUTF (methods[j].name);\n+\t  _Jv_JNI_Throw (env, new java::lang::NoSuchMethodError (m));\n+\t  return JNI_ERR;\n+\t}\n+    }\n+\n+  return JNI_OK;\n+}\n+\n+static jint\n+_Jv_JNI_UnregisterNatives (JNIEnv *, jclass)\n+{\n+  return JNI_ERR;\n+}\n+\n \f\n \n #ifdef INTERPRETER\n@@ -1460,7 +1517,7 @@ _Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv, void *args)\n     }\n \n   // Attaching an already-attached thread is a no-op.\n-  if (_Jv_ThreadCurrent () != NULL)\n+  if (_Jv_GetCurrentJNIEnv () != NULL)\n     return 0;\n \n   JNIEnv *env = (JNIEnv *) _Jv_MallocUnchecked (sizeof (JNIEnv));\n@@ -1480,8 +1537,13 @@ _Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv, void *args)\n     }\n   *penv = reinterpret_cast<void *> (env);\n \n-  java::lang::Thread *t = new gnu::gcj::jni::NativeThread (group, name);\n-  t = t;\t\t\t// Avoid compiler warning.  Eww.\n+  // This thread might already be a Java thread -- this function might\n+  // have been called simply to set the new JNIEnv.\n+  if (_Jv_ThreadCurrent () == NULL)\n+    {\n+      java::lang::Thread *t = new gnu::gcj::jni::NativeThread (group, name);\n+      t = t;\t\t\t// Avoid compiler warning.  Eww.\n+    }\n   _Jv_SetCurrentJNIEnv (env);\n \n   return 0;\n@@ -1655,21 +1717,34 @@ JNI_GetCreatedJavaVMs (JavaVM **vm_buffer, jsize buf_len, jsize *n_vms)\n   return 0;\n }\n \n-jint\n-_Jv_JNI_GetJavaVM (JNIEnv *, JavaVM **vm)\n+JavaVM *\n+_Jv_GetJavaVM ()\n {\n   // FIXME: synchronize\n   if (! the_vm)\n     {\n       JavaVM *nvm = (JavaVM *) _Jv_MallocUnchecked (sizeof (JavaVM));\n-      if (nvm == NULL)\n-\treturn JNI_ERR;\n-      nvm->functions = &_Jv_JNI_InvokeFunctions;\n+      if (nvm != NULL)\n+\tnvm->functions = &_Jv_JNI_InvokeFunctions;\n       the_vm = nvm;\n     }\n \n-  *vm = the_vm;\n-  return 0;\n+  // If this is a Java thread, we want to make sure it has an\n+  // associated JNIEnv.\n+  if (_Jv_ThreadCurrent () != NULL)\n+    {\n+      void *ignore;\n+      _Jv_JNI_AttachCurrentThread (the_vm, &ignore, NULL);\n+    }\n+\n+  return the_vm;\n+}\n+\n+static jint\n+_Jv_JNI_GetJavaVM (JNIEnv *, JavaVM **vm)\n+{\n+  *vm = _Jv_GetJavaVM ();\n+  return *vm == NULL ? JNI_ERR : JNI_OK;\n }\n \n \f\n@@ -1904,8 +1979,8 @@ struct JNINativeInterface _Jv_JNIFunctions =\n   _Jv_JNI_SetPrimitiveArrayRegion,\n   _Jv_JNI_SetPrimitiveArrayRegion,\n   _Jv_JNI_SetPrimitiveArrayRegion,\n-  NOT_IMPL /* RegisterNatives */,\n-  NOT_IMPL /* UnregisterNatives */,\n+  _Jv_JNI_RegisterNatives,\n+  _Jv_JNI_UnregisterNatives,\n   _Jv_JNI_MonitorEnter,\n   _Jv_JNI_MonitorExit,\n   _Jv_JNI_GetJavaVM,"}]}