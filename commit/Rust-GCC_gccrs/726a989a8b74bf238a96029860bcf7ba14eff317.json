{"sha": "726a989a8b74bf238a96029860bcf7ba14eff317", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2YTk4OWE4Yjc0YmYyMzhhOTYwMjk4NjBiY2Y3YmExNGVmZjMxNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-28T14:33:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-28T14:33:56Z"}, "message": "backport: ChangeLog.tuples: ChangeLog from gimple-tuples-branch.\n\n2008-07-28  Richard Guenther  <rguenther@suse.de>\n\n\tMerge from gimple-tuples-branch.\n\n\t* ChangeLog.tuples: ChangeLog from gimple-tuples-branch.\n\t* gimple.def: New file.\n\t* gsstruct.def: Likewise.\n\t* gimple-iterator.c: Likewise.\n\t* gimple-pretty-print.c: Likewise.\n\t* tree-gimple.c: Removed.  Merged into ...\n\t* gimple.c: ... here.  New file.\n\t* tree-gimple.h: Removed.  Merged into ...\n\t* gimple.h: ... here.  New file.\n\n\t* Makefile.in: Add dependencies on GIMPLE_H and tree-iterator.h.\n\t* configure.ac: Added support for ENABLE_GIMPLE_CHECKING and the\n\t--enable-checking=gimple flag.\n\t* config.in: Likewise.\n\t* configure: Regenerated.\n\n\t* tree-ssa-operands.h: Tuplified.\n\t* tree-vrp.c: Likewise.\n\t* tree-loop-linear.c: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-dump.c: Likewise.\n\t* tree-complex.c: Likewise.\n\t* cgraphbuild.c: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-pretty-print.c: Likewise.\n\t* tracer.c: Likewise.\n\t* gengtype.c: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-ssa-loop-unswitch.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* tree-ssa-loop-manip.c: Likewise.\n\t* value-prof.c: Likewise.\n\t* tree-ssa-loop-ch.c: Likewise.\n\t* tree-tailcall.c: Likewise.\n\t* value-prof.h: Likewise.\n\t* tree.c: Likewise.\n\t* tree.h: Likewise.\n\t* tree-pass.h: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* tree-scalar-evolution.c: Likewise.\n\t* tree-scalar-evolution.h: Likewise.\n\t* target.h: Likewise.\n\t* lambda-mat.c: Likewise.\n\t* tree-phinodes.c: Likewise.\n\t* diagnostic.h: Likewise.\n\t* builtins.c: Likewise.\n\t* tree-ssa-alias-warnings.c: Likewise.\n\t* cfghooks.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* cfghooks.h: Likewise.\n\t* omp-low.c: Likewise.\n\t* tree-ssa-dse.c: Likewise.\n\t* ipa-reference.c: Likewise.\n\t* tree-ssa-uncprop.c: Likewise.\n\t* toplev.c: Likewise.\n\t* tree-gimple.c: Likewise.\n\t* tree-gimple.h: Likewise.\n\t* tree-chrec.c: Likewise.\n\t* tree-chrec.h: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-sccvn.h: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* tree-ssa-copyrename.c: Likewise.\n\t* tree-ssa-ccp.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-nomudflap.c: Likewise.\n\t* tree-call-cdce.c: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* c-format.c: Likewise.\n\t* tree-stdarg.c: Likewise.\n\t* tree-ssa-math-opts.c: Likewise.\n\t* tree-ssa-dom.c: Likewise.\n\t* tree-nrv.c: Likewise.\n\t* tree-ssa-propagate.c: Likewise.\n\t* ipa-utils.c: Likewise.\n\t* tree-ssa-propagate.h: Likewise.\n\t* tree-ssa-alias.c: Likewise.\n\t* gimple-low.c: Likewise.\n\t* tree-ssa-sink.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* c-semantics.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* expr.c: Likewise.\n\t* tree-ssa-loop-ivcanon.c: Likewise.\n\t* predict.c: Likewise.\n\t* tree-ssa-loop.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-ssa-address.c: Likewise.\n\t* tree-ssa-ifcombine.c: Likewise.\n\t* matrix-reorg.c: Likewise.\n\t* c-decl.c: Likewise.\n\t* tree-eh.c: Likewise.\n\t* c-pretty-print.c: Likewise.\n\t* lambda-trans.c: Likewise.\n\t* function.c: Likewise.\n\t* langhooks.c: Likewise.\n\t* ebitmap.h: Likewise.\n\t* tree-vectorizer.c: Likewise.\n\t* function.h: Likewise.\n\t* langhooks.h: Likewise.\n\t* tree-vectorizer.h: Likewise.\n\t* ipa-type-escape.c: Likewise.\n\t* ipa-type-escape.h: Likewise.\n\t* domwalk.c: Likewise.\n\t* tree-if-conv.c: Likewise.\n\t* profile.c: Likewise.\n\t* domwalk.h: Likewise.\n\t* tree-data-ref.c: Likewise.\n\t* tree-data-ref.h: Likewise.\n\t* tree-flow-inline.h: Likewise.\n\t* tree-affine.c: Likewise.\n\t* tree-vect-analyze.c: Likewise.\n\t* c-typeck.c: Likewise.\n\t* gimplify.c: Likewise.\n\t* coretypes.h: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* calls.c: Likewise.\n\t* tree-ssa-coalesce.c: Likewise.\n\t* tree.def: Likewise.\n\t* tree-dfa.c: Likewise.\n\t* except.c: Likewise.\n\t* except.h: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* tree-cfgcleanup.c: Likewise.\n\t* tree-ssa-pre.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-sra.c: Likewise.\n\t* tree-ssa-live.h: Likewise.\n\t* tree-predcom.c: Likewise.\n\t* lambda.h: Likewise.\n\t* tree-mudflap.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* print-tree.c: Likewise.\n\t* tree-ssa-copy.c: Likewise.\n\t* ipa-prop.h: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* c-omp.c: Likewise.\n\t* tree-ssa-dce.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-ssa-ter.c: Likewise.\n\t* tree-nested.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* lambda-code.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-inline.h: Likewise.\n\t* tree-iterator.c: Likewise.\n\t* tree-optimize.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-vect-transform.c: Likewise.\n\t* tree-object-size.c: Likewise.\n\t* tree-outof-ssa.c: Likewise.\n\t* cfgloop.c: Likewise.\n\t* system.h: Likewise.\n\t* tree-profile.c: Likewise.\n\t* cfgloop.h: Likewise.\n\t* c-gimplify.c: Likewise.\n\t* c-common.c: Likewise.\n\t* tree-vect-generic.c: Likewise.\n\t* tree-flow.h: Likewise.\n\t* c-common.h: Likewise.\n\t* basic-block.h: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* tree-switch-conversion.c: Likewise.\n\t* tree-ssa-structalias.h: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* passes.c: Likewise.\n\t* ipa-struct-reorg.c: Likewise.\n\t* ipa-struct-reorg.h: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* varpool.c: Likewise.\n\t* stmt.c: Likewise.\n\t* tree-ssanames.c: Likewise.\n\t* tree-ssa-threadedge.c: Likewise.\n\t* langhooks-def.h: Likewise.\n\t* tree-ssa-operands.c: Likewise.\n\t* config/alpha/alpha.c: Likewise.\n\t* config/frv/frv.c: Likewise.\n\t* config/s390/s390.c: Likewise.\n\t* config/m32c/m32c.c: Likewise.\n\t* config/m32c/m32c-protos.h: Likewise.\n\t* config/spu/spu.c: Likewise.\n\t* config/sparc/sparc.c: Likewise.\n\t* config/i386/i386.c: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/xtensa/xtensa.c: Likewise.\n\t* config/stormy16/stormy16.c: Likewise.\n\t* config/ia64/ia64.c: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\nFrom-SVN: r138207", "tree": {"sha": "2926705dd533a8904679724ab1cec40dfee45094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2926705dd533a8904679724ab1cec40dfee45094"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/726a989a8b74bf238a96029860bcf7ba14eff317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726a989a8b74bf238a96029860bcf7ba14eff317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726a989a8b74bf238a96029860bcf7ba14eff317", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726a989a8b74bf238a96029860bcf7ba14eff317/comments", "author": null, "committer": null, "parents": [{"sha": "0d48657d7378a4b1cb25ed181bca8020eae520f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d48657d7378a4b1cb25ed181bca8020eae520f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d48657d7378a4b1cb25ed181bca8020eae520f1"}], "stats": {"total": 67031, "additions": 44323, "deletions": 22708}, "files": [{"sha": "d950a3ae29ea7812e36c0af6cead6096d5652ba9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,3 +1,204 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t* ChangeLog.tuples: ChangeLog from gimple-tuples-branch.\n+\t* gimple.def: New file.\n+\t* gsstruct.def: Likewise.\n+\t* gimple-iterator.c: Likewise.\n+\t* gimple-pretty-print.c: Likewise.\n+\t* tree-gimple.c: Removed.  Merged into ...\n+\t* gimple.c: ... here.  New file.\n+\t* tree-gimple.h: Removed.  Merged into ...\n+\t* gimple.h: ... here.  New file.\n+\n+\t* Makefile.in: Add dependencies on GIMPLE_H and tree-iterator.h.\n+\t* configure.ac: Added support for ENABLE_GIMPLE_CHECKING and the\n+\t--enable-checking=gimple flag.\n+\t* config.in: Likewise.\n+\t* configure: Regenerated.\n+\n+\t* tree-ssa-operands.h: Tuplified.\n+\t* tree-vrp.c: Likewise.\n+\t* tree-loop-linear.c: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-dump.c: Likewise.\n+\t* tree-complex.c: Likewise.\n+\t* cgraphbuild.c: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-pretty-print.c: Likewise.\n+\t* tracer.c: Likewise.\n+\t* gengtype.c: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-ssa-loop-unswitch.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* tree-ssa-loop-manip.c: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* tree-ssa-loop-ch.c: Likewise.\n+\t* tree-tailcall.c: Likewise.\n+\t* value-prof.h: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* tree-pass.h: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* tree-scalar-evolution.c: Likewise.\n+\t* tree-scalar-evolution.h: Likewise.\n+\t* target.h: Likewise.\n+\t* lambda-mat.c: Likewise.\n+\t* tree-phinodes.c: Likewise.\n+\t* diagnostic.h: Likewise.\n+\t* builtins.c: Likewise.\n+\t* tree-ssa-alias-warnings.c: Likewise.\n+\t* cfghooks.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* cfghooks.h: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* tree-ssa-dse.c: Likewise.\n+\t* ipa-reference.c: Likewise.\n+\t* tree-ssa-uncprop.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tree-gimple.c: Likewise.\n+\t* tree-gimple.h: Likewise.\n+\t* tree-chrec.c: Likewise.\n+\t* tree-chrec.h: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-sccvn.h: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* tree-ssa-copyrename.c: Likewise.\n+\t* tree-ssa-ccp.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-nomudflap.c: Likewise.\n+\t* tree-call-cdce.c: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* c-format.c: Likewise.\n+\t* tree-stdarg.c: Likewise.\n+\t* tree-ssa-math-opts.c: Likewise.\n+\t* tree-ssa-dom.c: Likewise.\n+\t* tree-nrv.c: Likewise.\n+\t* tree-ssa-propagate.c: Likewise.\n+\t* ipa-utils.c: Likewise.\n+\t* tree-ssa-propagate.h: Likewise.\n+\t* tree-ssa-alias.c: Likewise.\n+\t* gimple-low.c: Likewise.\n+\t* tree-ssa-sink.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* c-semantics.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* tree-ssa-loop.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-ssa-address.c: Likewise.\n+\t* tree-ssa-ifcombine.c: Likewise.\n+\t* matrix-reorg.c: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* c-pretty-print.c: Likewise.\n+\t* lambda-trans.c: Likewise.\n+\t* function.c: Likewise.\n+\t* langhooks.c: Likewise.\n+\t* ebitmap.h: Likewise.\n+\t* tree-vectorizer.c: Likewise.\n+\t* function.h: Likewise.\n+\t* langhooks.h: Likewise.\n+\t* tree-vectorizer.h: Likewise.\n+\t* ipa-type-escape.c: Likewise.\n+\t* ipa-type-escape.h: Likewise.\n+\t* domwalk.c: Likewise.\n+\t* tree-if-conv.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* domwalk.h: Likewise.\n+\t* tree-data-ref.c: Likewise.\n+\t* tree-data-ref.h: Likewise.\n+\t* tree-flow-inline.h: Likewise.\n+\t* tree-affine.c: Likewise.\n+\t* tree-vect-analyze.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* coretypes.h: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* tree-ssa-coalesce.c: Likewise.\n+\t* tree.def: Likewise.\n+\t* tree-dfa.c: Likewise.\n+\t* except.c: Likewise.\n+\t* except.h: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* tree-cfgcleanup.c: Likewise.\n+\t* tree-ssa-pre.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-sra.c: Likewise.\n+\t* tree-ssa-live.h: Likewise.\n+\t* tree-predcom.c: Likewise.\n+\t* lambda.h: Likewise.\n+\t* tree-mudflap.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* print-tree.c: Likewise.\n+\t* tree-ssa-copy.c: Likewise.\n+\t* ipa-prop.h: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* c-omp.c: Likewise.\n+\t* tree-ssa-dce.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-ssa-ter.c: Likewise.\n+\t* tree-nested.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* lambda-code.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-inline.h: Likewise.\n+\t* tree-iterator.c: Likewise.\n+\t* tree-optimize.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-vect-transform.c: Likewise.\n+\t* tree-object-size.c: Likewise.\n+\t* tree-outof-ssa.c: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* system.h: Likewise.\n+\t* tree-profile.c: Likewise.\n+\t* cfgloop.h: Likewise.\n+\t* c-gimplify.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* tree-vect-generic.c: Likewise.\n+\t* tree-flow.h: Likewise.\n+\t* c-common.h: Likewise.\n+\t* basic-block.h: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* tree-switch-conversion.c: Likewise.\n+\t* tree-ssa-structalias.h: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* passes.c: Likewise.\n+\t* ipa-struct-reorg.c: Likewise.\n+\t* ipa-struct-reorg.h: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* varpool.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* tree-ssanames.c: Likewise.\n+\t* tree-ssa-threadedge.c: Likewise.\n+\t* langhooks-def.h: Likewise.\n+\t* tree-ssa-operands.c: Likewise.\n+\t* config/alpha/alpha.c: Likewise.\n+\t* config/frv/frv.c: Likewise.\n+\t* config/s390/s390.c: Likewise.\n+\t* config/m32c/m32c.c: Likewise.\n+\t* config/m32c/m32c-protos.h: Likewise.\n+\t* config/spu/spu.c: Likewise.\n+\t* config/sparc/sparc.c: Likewise.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/xtensa/xtensa.c: Likewise.\n+\t* config/stormy16/stormy16.c: Likewise.\n+\t* config/ia64/ia64.c: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\n 2008-07-28  Simon Baldwin  <simonb@google.com>\n \n \t* c-pragma.c (handle_pragma_message): New function."}, {"sha": "d5e338368b530e61030879ad7eaab1f9b0fd20a7", "filename": "gcc/ChangeLog.tuples", "status": "added", "additions": 8231, "deletions": 0, "changes": 8231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2FChangeLog.tuples", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2FChangeLog.tuples", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.tuples?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "3dbaa733fe459081e4efd8b09330fce425a62dcd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 96, "deletions": 76, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -798,6 +798,8 @@ TREE_H = tree.h all-tree.def tree.def c-common.def $(lang_tree_files) \\\n BASIC_BLOCK_H = basic-block.h $(BITMAP_H) sbitmap.h varray.h $(PARTITION_H) \\\n           hard-reg-set.h $(PREDICT_H) vec.h $(FUNCTION_H) \\\n           cfghooks.h $(OBSTACK_H)\n+GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h vec.h \\\n+\t$(GGC_H) $(BASIC_BLOCK_H) $(TM_H) $(TARGET_H) tree-ssa-operands.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n COVERAGE_H = coverage.h $(GCOV_IO_H)\n DEMANGLE_H = $(srcdir)/../include/demangle.h\n@@ -844,9 +846,8 @@ SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)\n CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h\n CPP_INTERNAL_H = $(srcdir)/../libcpp/internal.h $(CPP_ID_DATA_H)\n TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H) tree-pass.h\n-TREE_GIMPLE_H = tree-gimple.h tree-iterator.h\n TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n-\t\t$(BITMAP_H) $(BASIC_BLOCK_H) hard-reg-set.h $(TREE_GIMPLE_H) \\\n+\t\t$(BITMAP_H) $(BASIC_BLOCK_H) hard-reg-set.h $(GIMPLE_H) \\\n \t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H)\n TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H) vecprim.h\n PRETTY_PRINT_H = pretty-print.h $(INPUT_H) $(OBSTACK_H)\n@@ -1091,7 +1092,10 @@ OBJS-common = \\\n \tgcse.o \\\n \tgenrtl.o \\\n \tggc-common.o \\\n+\tgimple.o \\\n+\tgimple-iterator.o \\\n \tgimple-low.o \\\n+\tgimple-pretty-print.o \\\n \tgimplify.o \\\n \tglobal.o \\\n \tgraph.o \\\n@@ -1182,7 +1186,6 @@ OBJS-common = \\\n \ttree-dfa.o \\\n \ttree-dump.o \\\n \ttree-eh.o \\\n-\ttree-gimple.o \\\n \ttree-if-conv.o \\\n \ttree-into-ssa.o \\\n \ttree-iterator.o \\\n@@ -1794,12 +1797,12 @@ c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(EXPR_H) debug.h $(TOPLEV_H) intl.h $(TM_P_H) $(TREE_INLINE_H) $(TIMEVAR_H) \\\n     opts.h $(C_PRAGMA_H) gt-c-decl.h $(CGRAPH_H) $(HASHTAB_H) libfuncs.h \\\n     except.h $(LANGHOOKS_DEF_H) $(TREE_DUMP_H) $(C_COMMON_H) $(CPPLIB_H) \\\n-    $(DIAGNOSTIC_H) $(INPUT_H) langhooks.h $(TREE_GIMPLE_H) tree-mudflap.h  \\\n-    pointer-set.h $(BASIC_BLOCK_H)\n+    $(DIAGNOSTIC_H) $(INPUT_H) langhooks.h $(GIMPLE_H) tree-mudflap.h  \\\n+    pointer-set.h $(BASIC_BLOCK_H) $(GIMPLE_H) tree-iterator.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(TREE_H) $(C_TREE_H) $(TARGET_H) $(FLAGS_H) intl.h output.h $(EXPR_H) \\\n     $(RTL_H) $(TOPLEV_H) $(TM_P_H) langhooks.h $(GGC_H) $(TREE_FLOW_H) \\\n-    $(TREE_GIMPLE_H) tree-iterator.h\n+    $(GIMPLE_H) tree-iterator.h\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(DIAGNOSTIC_H) \\\n     $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h \\\n@@ -1860,7 +1863,8 @@ c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(DIAGNOSTIC_H) gt-c-common.h langhooks.h $(VARRAY_H) $(RTL_H) \\\n \t$(TARGET_H) $(C_TREE_H) tree-iterator.h langhooks.h tree-mudflap.h \\\n \tintl.h opts.h $(REAL_H) $(CPPLIB_H) $(TREE_INLINE_H) $(HASHTAB_H) \\\n-\t$(BUILTINS_DEF) $(CGRAPH_H) $(BASIC_BLOCK_H) $(TARGET_DEF_H)\n+\t$(BUILTINS_DEF) $(CGRAPH_H) $(BASIC_BLOCK_H) $(TARGET_DEF_H) \\\n+\t$(GIMPLE_H)\n \n c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n \t$(C_TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(REAL_H) \\\n@@ -1893,8 +1897,8 @@ c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) la\n c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(TREE_H) $(FLAGS_H) $(TOPLEV_H) output.h $(RTL_H) $(GGC_H) \\\n \t$(PREDICT_H) $(TREE_INLINE_H) $(C_COMMON_H) except.h $(FUNCTION_H) \\\n-\tlanghooks.h $(SPLAY_TREE_H) $(TIMEVAR_H) $(TREE_GIMPLE_H) \\\n-\t$(VARRAY_H)\n+\tlanghooks.h $(SPLAY_TREE_H) $(TIMEVAR_H) $(GIMPLE_H) \\\n+\t$(VARRAY_H) tree-iterator.h\n \n c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(C_TREE_H) $(TREE_DUMP_H)\n@@ -1907,7 +1911,7 @@ c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \\\n \t  $< $(OUTPUT_OPTION)\n \n c-omp.o : c-omp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-\t$(FUNCTION_H) $(C_COMMON_H) $(TOPLEV_H) $(TREE_GIMPLE_H) $(BITMAP_H) \\\n+\t$(FUNCTION_H) $(C_COMMON_H) $(TOPLEV.H) $(GIMPLE_H) $(BITMAP_H) \\\n \tlanghooks.h\n \n # Language-independent files.\n@@ -2022,7 +2026,7 @@ double-int.o: double-int.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(TOPLEV_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n    langhooks.h $(TARGET_H) $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n-   intl.h $(TREE_GIMPLE_H)\n+   intl.h $(GIMPLE_H)\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \\\n    $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n@@ -2034,11 +2038,12 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) $(INPUT_H) insn-config.h \\\n    $(VARRAY_H) $(HASHTAB_H) $(TOPLEV_H) langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) \\\n-   intl.h $(FUNCTION_H) $(GGC_H) $(TREE_GIMPLE_H) \\\n+   intl.h $(FUNCTION_H) $(GGC_H) $(GIMPLE_H) \\\n    debug.h $(DIAGNOSTIC_H) except.h $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \\\n    $(IPA_PROP_H) value-prof.h tree-pass.h $(TARGET_H) $(INTEGRATE_H)\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(GGC_H) langhooks.h $(REAL_H) tree-iterator.h fixed-value.h $(TREE_FLOW_H)\n+   $(GGC_H) langhooks.h $(REAL_H) tree-iterator.h fixed-value.h \\\n+   $(DIAGNOSTIC_H) $(TREE_FLOW_H)\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) output.h $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \\\n@@ -2047,21 +2052,21 @@ tree-ssa-structalias.o: tree-ssa-structalias.c tree-ssa-structalias.h \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h errors.h \\\n    $(DIAGNOSTIC_H) $(TREE_H) $(C_COMMON_H) $(TREE_FLOW_H) $(TREE_INLINE_H) varray.h \\\n-   $(C_TREE_H) $(TREE_GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) tree-pass.h \\\n+   $(C_TREE_H) $(GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) tree-pass.h \\\n    $(TIMEVAR_H) alloc-pool.h $(SPLAY_TREE_H) $(PARAMS_H) gt-tree-ssa-structalias.h \\\n    $(CGRAPH_H) $(ALIAS_H) pointer-set.h\n tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    $(TOPLEV_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) langhooks.h tree-pass.h $(BASIC_BLOCK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) pointer-set.h \\\n-   $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H)\n+   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H)\n tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    langhooks.h domwalk.h tree-pass.h $(GGC_H) $(PARAMS_H) $(BASIC_BLOCK_H) \\\n    $(BITMAP_H) $(CFGLOOP_H) $(FLAGS_H) hard-reg-set.h $(HASHTAB_H) \\\n-   $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) vecprim.h\n+   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) vecprim.h\n tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(TREE_SSA_LIVE_H) $(BITMAP_H)\n@@ -2078,7 +2083,7 @@ tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n-   langhooks.h $(FLAGS_H)\n+   langhooks.h $(FLAGS_H) $(GIMPLE_H)\n tree-ssa-phiprop.o : tree-ssa-phiprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n@@ -2103,7 +2108,7 @@ tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n    tree-ssa-propagate.h vec.h value-prof.h gt-tree-ssa-propagate.h $(FLAGS_H) \\\n-   $(VARRAY_H)\n+   $(VARRAY_H) $(GIMPLE_H)\n tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n@@ -2127,7 +2132,7 @@ tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) $(TREE_FLOW_H)\n tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n-   gt-tree-phinodes.h $(RTL_H) $(TOPLEV_H)\n+   gt-tree-phinodes.h $(RTL_H) $(TOPLEV.H)  $(GIMPLE_H)\n domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) domwalk.h $(GGC_H)\n tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2136,18 +2141,18 @@ tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) tree-pass.h \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \\\n-   $(BITMAP_H) $(FLAGS_H) $(HASHTAB_H) langhooks.h $(TREE_GIMPLE_H) \\\n-   $(TREE_INLINE_H)\n+   $(BITMAP_H) $(FLAGS_H) $(HASHTAB_H) langhooks.h $(GIMPLE_H) \\\n+   $(TREE_INLINE_H) $(GIMPLE_H)\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) langhooks.h $(CFGLOOP_H) \\\n-   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n+   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) $(GIMPLE_H) \\\n    $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \\\n    $(DBGCNT_H)\n tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n-   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) langhooks.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n+   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) langhooks.h $(HASHTAB_H) $(GIMPLE_H) \\\n    $(TREE_INLINE_H) tree-iterator.h tree-ssa-propagate.h tree-ssa-sccvn.h \\\n    $(PARAMS_H)\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -2178,24 +2183,24 @@ tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) alloc-pool.h \\\n    $(BASIC_BLOCK_H) $(BITMAP_H) $(CFGLOOP_H) $(FIBHEAP_H) $(HASHTAB_H) \\\n-   langhooks.h $(REAL_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h\n+   langhooks.h $(REAL_H) $(GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h\n tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(TREE_DUMP_H) $(TREE_INLINE_H) \\\n-   tree-iterator.h $(TREE_GIMPLE_H) $(CGRAPH_H) $(EXPR_H) langhooks.h \\\n+   tree-iterator.h $(GIMPLE_H) $(CGRAPH_H) $(EXPR_H) langhooks.h \\\n    $(GGC_H) gt-tree-nested.h coretypes.h $(TREE_FLOW_H) pointer-set.h\n tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(TIMEVAR_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n    $(CFGLOOP_H) $(RTL_H) $(C_COMMON_H) tree-chrec.h $(TREE_DATA_REF_H) \\\n    $(SCEV_H) tree-pass.h $(DIAGNOSTIC_H) $(TARGET_H) $(TREE_DUMP_H) \\\n    $(VARRAY_H)\n tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-   coretypes.h $(GGC_H) tree-iterator.h $(TREE_GIMPLE_H) gt-tree-iterator.h\n+   coretypes.h $(GGC_H) tree-iterator.h $(GIMPLE_H) gt-tree-iterator.h\n tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(TREE_INLINE_H) $(HASHTAB_H) pointer-set.h $(FLAGS_H) $(FUNCTION_H) \\\n    $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h $(TREE_DUMP_H) \\\n    tree-pass.h $(PARAMS_H) $(CGRAPH_H) $(BASIC_BLOCK_H) hard-reg-set.h \\\n-   $(TREE_GIMPLE_H)\n+   $(GIMPLE_H)\n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(TM_H) $(TIMEVAR_H) tree-pass.h $(TOPLEV_H) \\\n@@ -2250,7 +2255,7 @@ tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n    tree-chrec.h $(VARRAY_H) tree-affine.h pointer-set.h $(TARGET_H)\n tree-affine.o : tree-affine.c tree-affine.h $(CONFIG_H) pointer-set.h \\\n-   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) hard-reg-set.h $(TREE_GIMPLE_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) hard-reg-set.h $(GIMPLE_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H)\n tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h \\\n@@ -2274,12 +2279,12 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(TREE_INLINE_H) $(FLAGS_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n-   hard-reg-set.h $(TREE_GIMPLE_H) vec.h tree-ssa-structalias.h \\\n+   hard-reg-set.h $(GIMPLE_H) vec.h tree-ssa-structalias.h \\\n    $(IPA_TYPE_ESCAPE_H) vecprim.h pointer-set.h alloc-pool.h\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\\n-   $(BASIC_BLOCK_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) vec.h langhooks.h \\\n+   $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_INLINE_H) vec.h langhooks.h \\\n    alloc-pool.h pointer-set.h $(CFGLOOP_H)\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) hard-reg-set.h $(EXPR_H) $(GGC_H) output.h \\\n@@ -2289,25 +2294,28 @@ tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(CFGLOOP_H) except.h\n \n c-gimplify.o : c-gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-   $(C_TREE_H) $(C_COMMON_H) $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(VARRAY_H) \\\n+   $(C_TREE_H) $(C_COMMON_H) $(DIAGNOSTIC_H) $(GIMPLE_H) $(VARRAY_H) \\\n    $(FLAGS_H) langhooks.h $(TOPLEV_H) $(RTL_H) $(TREE_FLOW_H) $(LANGHOOKS_DEF_H) \\\n    $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(TREE_DUMP_H) $(TREE_INLINE_H)\n-gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n+gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(GIMPLE_H) \\\n+   $(DIAGNOSTIC_H) $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) output.h \\\n    $(GGC_H) gt-gimplify.h $(HASHTAB_H) $(TARGET_H) $(TOPLEV_H) $(OPTABS_H) \\\n-   $(REAL_H) $(SPLAY_TREE_H)\n+   $(REAL_H) $(SPLAY_TREE_H) vec.h tree-iterator.h\n+gimple-iterator.o : gimple-iterator.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) value-prof.h\n gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n+   $(DIAGNOSTIC_H) $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) tree-pass.h \\\n-   $(HASHTAB_H) $(TOPLEV_H)\n+   $(HASHTAB_H) $(TOPLEV.H) tree-iterator.h\n omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(RTL_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \\\n+   $(RTL_H) $(GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) $(TOPLEV_H) tree-pass.h \\\n-   $(GGC_H) except.h $(SPLAY_TREE_H) $(OPTABS_H) $(CFGLOOP_H)\n+   $(GGC_H) except.h $(SPLAY_TREE_H) $(OPTABS_H) $(CFGLOOP_H) \\\n+   tree-iterator.h\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    $(TM_H) coretypes.h\n@@ -2365,16 +2373,19 @@ tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(TOPLEV_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \\\n    tree-ssa-propagate.h\n-tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n-   $(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h $(BITMAP_H) $(GGC_H) \\\n-   output.h $(TREE_FLOW_H)\n+gimple.o : gimple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n+   $(GGC_H) $(GIMPLE_H) $(GIMPLE_H) $(DIAGNOSTIC_H) gt-gimple.h \\\n+   $(TREE_FLOW_H) value-prof.h $(FLAGS_H)\n+gimple-pretty-print.o : gimple-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n+   $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \\\n+   $(TM_H) coretypes.h tree-pass.h $(GIMPLE_H) value-prof.h\n tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n-   $(TREE_GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \\\n+   $(GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(CGRAPH_H) $(GGC_H) \\\n    gt-tree-mudflap.h $(BASIC_BLOCK_H) $(FLAGS_H) $(FUNCTION_H) hard-reg-set.h \\\n-   $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(TOPLEV_H)\n+   $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(TOPLEV.H) $(GIMPLE_H) tree-iterator.h\n tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n-   $(C_TREE_H) $(C_COMMON_H) $(TREE_GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n+   $(C_TREE_H) $(C_COMMON_H) $(GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    output.h $(VARRAY_H) langhooks.h tree-mudflap.h $(TM_H) coretypes.h \\\n    $(GGC_H) gt-tree-mudflap.h tree-pass.h $(TOPLEV_H)\n tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2383,7 +2394,8 @@ tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    value-prof.h fixed-value.h output.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(REAL_H) $(TOPLEV_H) $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n-   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h fixed-value.h $(TARGET_H)\n+   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h fixed-value.h $(TARGET_H) \\\n+   $(GIMPLE_H)\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) $(INPUT_H) $(TOPLEV_H) intl.h \\\n    $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h\n@@ -2406,7 +2418,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    value-prof.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \\\n    $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \\\n-   opts.h params.def tree-mudflap.h $(REAL_H) tree-pass.h\n+   opts.h params.def tree-mudflap.h $(REAL_H) tree-pass.h $(GIMPLE_H)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \\\n \t  -DTARGET_NAME=\\\"$(target_noncanonical)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)\n@@ -2448,7 +2460,7 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h $(BASIC_BLOCK_H) \\\n    $(CFGLAYOUT_H) $(CGRAPH_H) targhooks.h tree-mudflap.h $(REAL_H) tree-iterator.h\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(CFGLAYOUT_H) $(TREE_GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n+   $(TREE_H) $(CFGLAYOUT_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n    $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h $(TOPLEV_H) except.h $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n    gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \\\n@@ -2477,15 +2489,15 @@ dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n    langhooks.h $(GGC_H) gt-dojump.h vecprim.h\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(TREE_GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \\\n+   $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \\\n    $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \\\n    hard-reg-set.h $(TOPLEV_H) hard-reg-set.h except.h $(TM_P_H) $(PREDICT_H) \\\n    libfuncs.h $(REAL_H) langhooks.h $(BASIC_BLOCK_H) tree-mudflap.h \\\n    $(BUILTINS_DEF) $(MACHMODE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) value-prof.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \\\n    libfuncs.h $(REGS_H) $(TOPLEV_H) output.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_P_H) \\\n-   $(CGRAPH_H) except.h sbitmap.h $(DBGCNT_H)\n+   $(CGRAPH_H) except.h sbitmap.h $(DBGCNT_H) $(TREE_FLOW_H)\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(REAL_H) \\\n    $(TOPLEV_H) $(TM_P_H) langhooks.h $(DF_H) $(TARGET_H)\n@@ -2551,16 +2563,16 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_INLINE_H) $(VARRAY_H) $(TREE_DUMP_H) $(TREE_FLOW_H)\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(TOPLEV_H) $(FLAGS_H) $(GGC_H) \\\n-   $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\\n+   $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) $(IPA_PROP_H) \\\n-   gt-cgraphunit.h \n+   gt-cgraphunit.h tree-iterator.h\n cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(TREE_GIMPLE_H) \\\n+   $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) tree-pass.h\n varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(CGRAPH_H) langhooks.h $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n-   $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(TREE_GIMPLE_H) \\\n+   $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) gt-varpool.h\n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    tree-pass.h $(TIMEVAR_H)\n@@ -2584,30 +2596,31 @@ ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H)\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n-   pointer-set.h $(GGC_H) $(C_COMMON_H) $(TREE_GIMPLE_H) \\\n+   pointer-set.h $(GGC_H) $(C_COMMON_H) $(GIMPLE_H) \\\n    $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(TIMEVAR_H) $(DIAGNOSTIC_H)\n ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(C_COMMON_H) \\\n-   $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h \\\n+   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h \\\n    $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H)\n \n ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(C_COMMON_H) $(TARGET_H) \\\n-   $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(TIMEVAR_H) \\\n+   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(TIMEVAR_H) \\\n    $(DIAGNOSTIC_H)\n ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(C_COMMON_H) \\\n-   $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h \\\n+   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h \\\n    $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H)\n ipa-struct-reorg.o: ipa-struct-reorg.c ipa-struct-reorg.h $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TREE_GIMPLE_H) tree-inline.h \\\n+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(GIMPLE_H) tree-inline.h \\\n    $(TREE_FLOW_H) langhooks.h pointer-set.h $(HASHTAB_H) $(C_TREE_H) $(TOPLEV_H) \\\n    $(FLAGS_H) debug.h $(TARGET_H) $(CGRAPH_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(PARAMS_H) $(FIBHEAP_H) intl.h $(FUNCTION_H) $(BASIC_BLOCK_H) tree-iterator.h \\\n-   tree-pass.h opts.h $(IPA_TYPE_ESCAPE_H) $(TREE_DUMP_H) $(C_COMMON_H)\n+   tree-pass.h opts.h $(IPA_TYPE_ESCAPE_H) $(TREE_DUMP_H) $(C_COMMON_H) \\\n+   $(GIMPLE_H)\n \n coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n@@ -2658,32 +2671,32 @@ mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n     coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \\\n-    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(TREE_GIMPLE_H) $(CFGLOOP_H) \\\n+    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(GIMPLE_H) $(CFGLOOP_H) \\\n     tree-scalar-evolution.h\n tree-call-cdce.o : tree-call-cdce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n     coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \\\n-    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(TREE_GIMPLE_H)\n+    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(GIMPLE_H)\n tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n    tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(TOPLEV_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n     $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n-    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \\\n     langhooks.h tree-pass.h $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n     $(BITMAP_H) $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(PARAMS_H) $(TARGET_H)\n tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n     $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n-    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \\\n     tree-pass.h $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h \\\n     $(GGC_H) $(OBSTACK_H) $(PARAMS_H) $(CPPLIB_H) $(PARAMS_H)\n tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n-    $(TM_H) $(RTL_H) $(REAL_H) $(FLAGS_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) \\\n+    $(TM_H) $(RTL_H) $(REAL_H) $(FLAGS_H) $(TREE_FLOW_H) $(GIMPLE_H) \\\n     tree-iterator.h tree-pass.h tree-ssa-propagate.h $(DIAGNOSTIC_H)\n tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-    $(TM_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) tree-iterator.h tree-pass.h \\\n+    $(TM_H) $(TREE_FLOW_H) $(GIMPLE_H) tree-iterator.h tree-pass.h \\\n     $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \\\n     langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \\\n     coretypes.h insn-codes.h\n@@ -2953,9 +2966,9 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REAL_H) $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h $(TIMEVAR_H) tree-pass.h \\\n    $(DF_H) $(DBGCNT_H)\n lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n-   $(TM_H) coretypes.h $(TREE_H)\n+   $(TM_H) coretypes.h $(TREE_H) $(TREE_FLOW_H)\n lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n-   $(TM_H) coretypes.h $(TARGET_H) $(TREE_H)\n+   $(TM_H) coretypes.h $(TARGET_H) $(TREE_H) $(TREE_FLOW_H)\n lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n    $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n@@ -2978,7 +2991,7 @@ $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\\n    output.h $(INSN_ATTR_H) $(SYSTEM_H) $(TOPLEV_H) $(TARGET_H) libfuncs.h \\\n    $(TARGET_DEF_H) $(FUNCTION_H) $(SCHED_INT_H) $(TM_P_H) $(EXPR_H) \\\n-   langhooks.h $(GGC_H) $(OPTABS_H) $(REAL_H) tm-constrs.h\n+   langhooks.h $(GGC_H) $(OPTABS_H) $(REAL_H) tm-constrs.h $(GIMPLE_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \\\n \t\t$(out_file) $(OUTPUT_OPTION)\n \n@@ -3203,6 +3216,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c $(srcdir)/matrix-reorg.c \\\n   $(srcdir)/dbxout.c $(srcdir)/ipa-struct-reorg.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n+  $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/dojump.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/function.c $(srcdir)/except.h \\\n@@ -3211,18 +3225,24 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n-  $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h $(srcdir)/tree-scalar-evolution.c \\\n+  $(srcdir)/gimple.h $(srcdir)/gimple.c \\\n+  $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h \\\n   $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \\\n-  $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \\\n-  $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-propagate.c \\\n+  $(srcdir)/tree-cfg.c \\\n+  $(srcdir)/tree-dfa.c \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n-  $(srcdir)/tree-chrec.h $(srcdir)/tree-vect-generic.c \\\n+  $(srcdir)/tree-chrec.h \\\n+  $(srcdir)/tree-scalar-evolution.c \\\n   $(srcdir)/tree-ssa-operands.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n-  $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n-  $(srcdir)/tree-ssa-structalias.c $(srcdir)/tree-parloops.c \\\n-  $(srcdir)/omp-low.c $(srcdir)/varpool.c \\\n+  $(srcdir)/varpool.c \\\n+  $(srcdir)/tree-parloops.c \\\n+  $(srcdir)/omp-low.c \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n+  $(srcdir)/tree-ssa-propagate.c \\\n+  $(srcdir)/tree-phinodes.c \\\n+  $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n+  $(srcdir)/tree-ssa-structalias.c \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,\n@@ -3301,7 +3321,7 @@ build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h vec.h\t\t\\\n   $(HASHTAB_H) gensupport.h\n build/gencheck.o : gencheck.c tree.def $(BCONFIG_H) $(GTM_H)\t\t\\\n-\t$(SYSTEM_H) coretypes.h $(lang_tree_files)\n+\t$(SYSTEM_H) coretypes.h $(lang_tree_files) gimple.def\n build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)\n build/gencodes.o : gencodes.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h"}, {"sha": "a4859fd744ebd82ae815039e468542311d2e7420", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,3 +1,40 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t2008-07-22  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gigi.h (end_subprog_body): New ELAB_P argument, saying if\n+\tthis is called for an elab proc to be discarded if empty.\n+\t* utils.c (end_subprog_body): Honor ELAB_P.\n+\t(build_function_stub): Adjust call to end_subprog_body.\n+\t* trans.c (Subprogram_Body_to_gnu): Likewise.\n+\t(gigi): Reorganize processing of elab procs to prevent\n+\tgimplifying twice, using the new end_subprog_body argument.\n+\n+\t2008-07-19  Richard Guenther  <rguenther@suse.de>\n+\n+\t* Make-lang.in (trans.o): Add tree-iterator.h dependency.\n+\t(utils.o): Likewise.\n+\t* trans.c: Include tree-iterator.h.\n+\t(gnat_gimplify_expr): Adjust prototype.  Fix typo.\n+\t(gnat_gimplify_stmt): Use SET_EXPR_LOCATION.\n+\t(set_expr_location_from_node): Likewise.\n+\t(gigi): Tuplify.\n+\t* ada-tree.h (union lang_tree_node): Use TREE_CHAIN instead\n+\tof GENERIC_NEXT.\n+\t* utils.c: Include tree-iterator.h.\n+\t* gigi.h (gnat_gimplify_expr): Adjust prototype.\n+\n+\t2008-07-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans.c: Include gimple.h instead of tree-gimple.h.\n+\t* utils.c: Same.\n+\n+\t2008-07-14  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans.c (gnat_gimplify_expr): Use gimplify_assign.\n+\n 2008-07-25  Jan Hubicka  <jh@suse.cz>\n \n \t* utils.c (end_subprog_body): Remove inline trees check."}, {"sha": "268fa7031fcebebbdae22549b78abdc5b62a52df", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1106,13 +1106,13 @@ ada/trans.o : ada/trans.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(FUNCTION_H) ada/ada.h except.h \\\n    ada/types.h ada/atree.h ada/nlists.h ada/elists.h ada/uintp.h ada/sinfo.h \\\n    ada/einfo.h ada/namet.h ada/snames.h ada/stringt.h ada/urealp.h ada/fe.h \\\n-   $(ADA_TREE_H) ada/gigi.h gt-ada-trans.h\n+   $(ADA_TREE_H) ada/gigi.h gt-ada-trans.h tree-iterator.h\n \n ada/utils.o : ada/utils.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXPR_H) convert.h defaults.h langhooks.h \\\n    ada/ada.h ada/types.h ada/atree.h ada/nlists.h ada/elists.h ada/sinfo.h \\\n    ada/einfo.h ada/namet.h ada/stringt.h ada/uintp.h ada/fe.h $(ADA_TREE_H) \\\n-   ada/gigi.h gt-ada-utils.h gtype-ada.h $(TARGET_H)\n+   ada/gigi.h gt-ada-utils.h gtype-ada.h $(TARGET_H) tree-iterator.h\n \n ada/utils2.o : ada/utils2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) ada/ada.h ada/types.h ada/atree.h ada/nlists.h \\"}, {"sha": "9c31e46f2672a7e36baba2e99269f57f5a5488c4", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -26,7 +26,7 @@\n /* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n union lang_tree_node\n   GTY((desc (\"0\"),\n-       chain_next (\"(union lang_tree_node *)GENERIC_NEXT (&%h.t)\")))\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.t)\")))\n {\n   union tree_node GTY((tag (\"0\"))) t;\n };"}, {"sha": "aaf5e7f8d8f433207d869e4cffdb5ea2a4ff5c4d", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -233,8 +233,8 @@ extern tree gnat_to_gnu (Node_Id gnat_node);\n extern void gnat_expand_stmt (tree gnu_stmt);\n \n /* ??? missing documentation */\n-extern int gnat_gimplify_expr (tree *expr_p, tree *pre_p,\n-                               tree *post_p ATTRIBUTE_UNUSED);\n+extern int gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n+                               gimple_seq *post_p ATTRIBUTE_UNUSED);\n \n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n@@ -668,10 +668,10 @@ extern tree create_label_decl (tree label_name);\n    appearing in the subprogram.  */\n extern void begin_subprog_body (tree subprog_decl);\n \n-/* Finish the definition of the current subprogram and compile it all the way\n-   to assembler language output.  BODY is the tree corresponding to\n-   the subprogram.  */\n-extern void end_subprog_body (tree body);\n+/* Finish the definition of the current subprogram BODY and compile it all the\n+   way to assembler language output.  ELAB_P tells if this is called for an\n+   elaboration routine, to be entirely discarded if empty.  */\n+extern void end_subprog_body (tree body, bool elab_p);\n \n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n    EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs."}, {"sha": "abc71f5e53ef45326e6463e9c1c21d04c097d4de", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -40,7 +40,8 @@\n #include \"except.h\"\n #include \"debug.h\"\n #include \"output.h\"\n-#include \"tree-gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple.h\"\n #include \"ada.h\"\n #include \"types.h\"\n #include \"atree.h\"\n@@ -356,7 +357,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   for (info = elab_info_list; info; info = info->next)\n     {\n       tree gnu_body = DECL_SAVED_TREE (info->elab_proc);\n-      tree gnu_stmts;\n \n       /* Unshare SAVE_EXPRs between subprograms.  These are not unshared by\n \t the gimplifier for obvious reasons, but it turns out that we need to\n@@ -368,30 +368,14 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \t an upstream bug for which we would not change the outcome.  */\n       walk_tree_without_duplicates (&gnu_body, unshare_save_expr, NULL);\n \n-      /* Set the current function to be the elaboration procedure and gimplify\n-\t what we have.  */\n-      current_function_decl = info->elab_proc;\n-      gimplify_body (&gnu_body, info->elab_proc, true);\n+      /* Process the function as others, but for indicating this is an\n+\t elab proc, to be discarded if empty, then propagate the status\n+\t up to the GNAT tree node.  */\n+      begin_subprog_body (info->elab_proc);\n+      end_subprog_body (gnu_body, true);\n \n-      /* We should have a BIND_EXPR, but it may or may not have any statements\n-\t in it.  If it doesn't have any, we have nothing to do.  */\n-      gnu_stmts = gnu_body;\n-      if (TREE_CODE (gnu_stmts) == BIND_EXPR)\n-\tgnu_stmts = BIND_EXPR_BODY (gnu_stmts);\n-\n-      /* If there are no statements, there is no elaboration code.  */\n-      if (!gnu_stmts || !STATEMENT_LIST_HEAD (gnu_stmts))\n-\t{\n-\t  Set_Has_No_Elaboration_Code (info->gnat_node, 1);\n-\t  cgraph_remove_node (cgraph_node (info->elab_proc));\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, compile the function.  Note that we'll be gimplifying\n-\t     it twice, but that's fine for the nodes we use.  */\n-\t  begin_subprog_body (info->elab_proc);\n-\t  end_subprog_body (gnu_body);\n-\t}\n+      if (empty_body_p (gimple_body (info->elab_proc)))\n+\tSet_Has_No_Elaboration_Code (info->gnat_node, 1);\n     }\n \n   /* We cannot track the location of errors past this point.  */\n@@ -2003,7 +1987,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       : Sloc (gnat_node)),\n      &DECL_STRUCT_FUNCTION (gnu_subprog_decl)->function_end_locus);\n \n-  end_subprog_body (gnu_result);\n+  end_subprog_body (gnu_result, false);\n \n   /* Disconnect the trees for parameters that we made variables for from the\n      GNAT entities since these are unusable after we end the function.  */\n@@ -5334,7 +5318,8 @@ pop_stack (tree *gnu_stack_ptr)\n /* Generate GIMPLE in place for the expression at *EXPR_P.  */\n \n int\n-gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n+gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n+\t\t    gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree expr = *expr_p;\n   tree op;\n@@ -5419,14 +5404,14 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t       && TREE_CODE_CLASS (TREE_CODE (op)) != tcc_constant)\n \t{\n \t  tree new_var = create_tmp_var (TREE_TYPE (op), \"A\");\n-\t  tree mod = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (op), new_var, op);\n+\t  gimple stmt;\n \n \t  TREE_ADDRESSABLE (new_var) = 1;\n \n+\t  stmt = gimplify_assign (new_var, op, pre_p);\n \t  if (EXPR_HAS_LOCATION (op))\n-\t    SET_EXPR_LOCUS (mod, EXPR_LOCUS (op));\n+\t    gimple_set_location (stmt, *EXPR_LOCUS (op));\n \n-\t  gimplify_and_add (mod, pre_p);\n \t  TREE_OPERAND (expr, 0) = new_var;\n \t  recompute_tree_invariant_for_addr_expr (expr);\n \t  return GS_ALL_DONE;\n@@ -5494,7 +5479,7 @@ gnat_gimplify_stmt (tree *stmt_p)\n \t  append_to_statement_list (LOOP_STMT_UPDATE (stmt), stmt_p);\n \n \tt = build1 (GOTO_EXPR, void_type_node, gnu_start_label);\n-\tset_expr_location (t, DECL_SOURCE_LOCATION (gnu_end_label));\n+\tSET_EXPR_LOCATION (t, DECL_SOURCE_LOCATION (gnu_end_label));\n \tappend_to_statement_list (t, stmt_p);\n \n \tappend_to_statement_list (build1 (LABEL_EXPR, void_type_node,\n@@ -6913,7 +6898,7 @@ set_expr_location_from_node (tree node, Node_Id gnat_node)\n   if (!Sloc_to_locus (Sloc (gnat_node), &locus))\n     return;\n \n-  set_expr_location (node, locus);\n+  SET_EXPR_LOCATION (node, locus);\n }\n \f\n /* Return a colon-separated list of encodings contained in encoded Ada"}, {"sha": "cde8d4dd2f3c4fcf779a541c3b5715be309edf51", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -43,7 +43,8 @@\n #include \"function.h\"\n #include \"cgraph.h\"\n #include \"tree-inline.h\"\n-#include \"tree-gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple.h\"\n #include \"tree-dump.h\"\n #include \"pointer-set.h\"\n #include \"langhooks.h\"\n@@ -2199,12 +2200,12 @@ gnat_genericize (tree fndecl)\n   pointer_set_destroy (p_set);\n }\n \n-/* Finish the definition of the current subprogram and compile it all the way\n-   to assembler language output.  BODY is the tree corresponding to\n-   the subprogram.  */\n+/* Finish the definition of the current subprogram BODY and compile it all the\n+   way to assembler language output.  ELAB_P tells if this is called for an\n+   elaboration routine, to be entirely discarded if empty.  */\n \n void\n-end_subprog_body (tree body)\n+end_subprog_body (tree body, bool elab_p)\n {\n   tree fndecl = current_function_decl;\n \n@@ -2246,7 +2247,13 @@ end_subprog_body (tree body)\n   if (!DECL_CONTEXT (fndecl))\n     {\n       gnat_gimplify_function (fndecl);\n-      cgraph_finalize_function (fndecl, false);\n+\n+      /* If this is an empty elaboration proc, just discard the node.\n+\t Otherwise, compile further.  */\n+      if (elab_p && empty_body_p (gimple_body (fndecl)))\n+\tcgraph_remove_node (cgraph_node (fndecl));\n+      else\n+\tcgraph_finalize_function (fndecl, false);\n     }\n   else\n     /* Register this function with cgraph just far enough to get it\n@@ -3117,7 +3124,7 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n   gnat_poplevel ();\n \n   allocate_struct_function (gnu_stub_decl, false);\n-  end_subprog_body (gnu_body);\n+  end_subprog_body (gnu_body, false);\n }\n \f\n /* Build a type to be used to represent an aliased object whose nominal"}, {"sha": "ff6d025819110155ac6afa70c8c5d23184bf6f61", "filename": "gcc/basic-block.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -122,7 +122,7 @@ struct edge_def GTY(())\n \n   /* Instructions queued on the edge.  */\n   union edge_def_insns {\n-    tree GTY ((tag (\"true\"))) t;\n+    gimple_seq GTY ((tag (\"true\"))) g;\n     rtx GTY ((tag (\"false\"))) r;\n   } GTY ((desc (\"current_ir_type () == IR_GIMPLE\"))) insns;\n \n@@ -231,7 +231,7 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   struct basic_block_def *next_bb;\n \n   union basic_block_il_dependent {\n-      struct tree_bb_info * GTY ((tag (\"0\"))) tree;\n+      struct gimple_bb_info * GTY ((tag (\"0\"))) gimple;\n       struct rtl_bb_info * GTY ((tag (\"1\"))) rtl;\n     } GTY ((desc (\"((%1.flags & BB_RTL) != 0)\"))) il;\n \n@@ -266,13 +266,13 @@ struct rtl_bb_info GTY(())\n   int visited;\n };\n \n-struct tree_bb_info GTY(())\n+struct gimple_bb_info GTY(())\n {\n-  /* Pointers to the first and last trees of the block.  */\n-  tree stmt_list;\n+  /* Sequence of statements in this block.  */\n+  gimple_seq seq;\n \n-  /* Chain of PHI nodes for this block.  */\n-  tree phi_nodes;\n+  /* PHI nodes for this block.  */\n+  gimple_seq phi_nodes;\n };\n \n typedef struct basic_block_def *basic_block;\n@@ -383,7 +383,7 @@ struct control_flow_graph GTY(())\n   int x_last_basic_block;\n \n   /* Mapping of labels to their associated blocks.  At present\n-     only used for the tree CFG.  */\n+     only used for the gimple CFG.  */\n   VEC(basic_block,gc) *x_label_to_block_map;\n \n   enum profile_status {\n@@ -831,9 +831,9 @@ extern bool maybe_hot_bb_p (const_basic_block);\n extern bool maybe_hot_edge_p (edge);\n extern bool probably_cold_bb_p (const_basic_block);\n extern bool probably_never_executed_bb_p (const_basic_block);\n-extern bool tree_predicted_by_p (const_basic_block, enum br_predictor);\n+extern bool gimple_predicted_by_p (const_basic_block, enum br_predictor);\n extern bool rtl_predicted_by_p (const_basic_block, enum br_predictor);\n-extern void tree_predict_edge (edge, enum br_predictor, int);\n+extern void gimple_predict_edge (edge, enum br_predictor, int);\n extern void rtl_predict_edge (edge, enum br_predictor, int);\n extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n extern void guess_outgoing_edge_probabilities (basic_block);"}, {"sha": "288ad59717edc59f2a9fbdef72d8acb7d6f4dd03", "filename": "gcc/builtins.c", "status": "modified", "additions": 375, "deletions": 9, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"real.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -3287,6 +3287,7 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \t\t\t\t\t    false, /*endp=*/0);\n       HOST_WIDE_INT expected_size = -1;\n       unsigned int expected_align = 0;\n+      tree_ann_common_t ann;\n \n       if (result)\n \t{\n@@ -3308,7 +3309,10 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n       if (src_align == 0)\n \treturn NULL_RTX;\n  \n-      stringop_block_profile (exp, &expected_align, &expected_size);\n+      ann = tree_common_ann (exp);\n+      if (ann)\n+        stringop_block_profile (ann->stmt, &expected_align, &expected_size);\n+\n       if (expected_align < dest_align)\n \texpected_align = dest_align;\n       dest_mem = get_memory_rtx (dest, len);\n@@ -3883,14 +3887,18 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   rtx dest_mem, dest_addr, len_rtx;\n   HOST_WIDE_INT expected_size = -1;\n   unsigned int expected_align = 0;\n+  tree_ann_common_t ann;\n \n   dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \n   /* If DEST is not a pointer type, don't do this operation in-line.  */\n   if (dest_align == 0)\n     return NULL_RTX;\n \n-  stringop_block_profile (orig_exp, &expected_align, &expected_size);\n+  ann = tree_common_ann (orig_exp);\n+  if (ann)\n+    stringop_block_profile (ann->stmt, &expected_align, &expected_size);\n+\n   if (expected_align < dest_align)\n     expected_align = dest_align;\n \n@@ -4755,7 +4763,8 @@ expand_builtin_va_start (tree exp)\n    current (padded) address and increment by the (padded) size.  */\n \n tree\n-std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n+std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t  gimple_seq *post_p)\n {\n   tree addr, t, type_size, rounded_size, valist_tmp;\n   unsigned HOST_WIDE_INT align, boundary;\n@@ -4875,7 +4884,7 @@ dummy_object (tree type)\n    builtin function, but a very special sort of operator.  */\n \n enum gimplify_status\n-gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   tree promoted_type, have_va_type;\n   tree valist = TREE_OPERAND (*expr_p, 0);\n@@ -4917,7 +4926,7 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t Call abort to encourage the user to fix the program.  */\n       inform (\"if this code is reached, the program will abort\");\n       t = build_call_expr (implicit_built_in_decls[BUILT_IN_TRAP], 0);\n-      append_to_statement_list (t, pre_p);\n+      gimplify_and_add (t, pre_p);\n \n       /* This is dead code, but go ahead and finish so that the\n \t mode of the result comes out right.  */\n@@ -4939,13 +4948,14 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t      tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n \t      valist = build_fold_addr_expr_with_type (valist, p1);\n \t    }\n+\n \t  gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n \t}\n       else\n \tgimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n \n       if (!targetm.gimplify_va_arg_expr)\n-\t/* FIXME:Once most targets are converted we should merely\n+\t/* FIXME: Once most targets are converted we should merely\n \t   assert this is non-null.  */\n \treturn GS_ALL_DONE;\n \n@@ -7292,7 +7302,7 @@ integer_valued_real_p (tree t)\n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n     case BIND_EXPR:\n-      return integer_valued_real_p (GENERIC_TREE_OPERAND (t, 1));\n+      return integer_valued_real_p (TREE_OPERAND (t, 1));\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -10572,7 +10582,7 @@ fold_builtin_n (tree fndecl, tree *args, int nargs, bool ignore)\n     }\n   if (ret)\n     {\n-      ret = build1 (NOP_EXPR, GENERIC_TREE_TYPE (ret), ret);\n+      ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n       TREE_NO_WARNING (ret) = 1;\n       return ret;\n     }\n@@ -10830,6 +10840,61 @@ validate_arg (const_tree arg, enum tree_code code)\n   return code == TREE_CODE (TREE_TYPE (arg));\n }\n \n+/* This function validates the types of a function call argument list\n+   against a specified list of tree_codes.  If the last specifier is a 0,\n+   that represents an ellipses, otherwise the last specifier must be a\n+   VOID_TYPE.\n+\n+   This is the GIMPLE version of validate_arglist.  Eventually we want to\n+   completely convert builtins.c to work from GIMPLEs and the tree based\n+   validate_arglist will then be removed.  */\n+\n+bool\n+validate_gimple_arglist (const_gimple call, ...)\n+{\n+  enum tree_code code;\n+  bool res = 0;\n+  va_list ap;\n+  const_tree arg;\n+  size_t i;\n+\n+  va_start (ap, call);\n+  i = 0;\n+\n+  do\n+    {\n+      code = va_arg (ap, enum tree_code);\n+      switch (code)\n+\t{\n+\tcase 0:\n+\t  /* This signifies an ellipses, any further arguments are all ok.  */\n+\t  res = true;\n+\t  goto end;\n+\tcase VOID_TYPE:\n+\t  /* This signifies an endlink, if no arguments remain, return\n+\t     true, otherwise return false.  */\n+\t  res = (i == gimple_call_num_args (call));\n+\t  goto end;\n+\tdefault:\n+\t  /* If no parameters remain or the parameter's code does not\n+\t     match the specified code, return false.  Otherwise continue\n+\t     checking any remaining arguments.  */\n+\t  arg = gimple_call_arg (call, i++);\n+\t  if (!validate_arg (arg, code))\n+\t    goto end;\n+\t  break;\n+\t}\n+    }\n+  while (1);\n+\n+  /* We need gotos here since we can only have one VA_CLOSE in a\n+     function.  */\n+ end: ;\n+  va_end (ap);\n+\n+  return res;\n+}\n+\n /* This function validates the types of a function call argument list\n    against a specified list of tree_codes.  If the last specifier is a 0,\n    that represents an ellipses, otherwise the last specifier must be a\n@@ -11439,6 +11504,7 @@ fold_builtin_fputs (tree arg0, tree arg1, bool ignore, bool unlocked, tree len)\n /* Fold the next_arg or va_start call EXP. Returns true if there was an error\n    produced.  False otherwise.  This is done so that we don't output the error\n    or warning twice or three times.  */\n+\n bool\n fold_builtin_next_arg (tree exp, bool va_start_p)\n {\n@@ -13113,3 +13179,303 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n   return result;\n }\n #endif\n+\n+/* FIXME tuples.\n+   The functions below provide an alternate interface for folding\n+   builtin function calls presented as GIMPLE_CALL statements rather\n+   than as CALL_EXPRs.  The folded result is still expressed as a\n+   tree.  There is too much code duplication in the handling of\n+   varargs functions, and a more intrusive re-factoring would permit\n+   better sharing of code between the tree and statement-based\n+   versions of these functions.  */\n+\n+/* Construct a new CALL_EXPR using the tail of the argument list of STMT\n+   along with N new arguments specified as the \"...\" parameters.  SKIP\n+   is the number of arguments in STMT to be omitted.  This function is used\n+   to do varargs-to-varargs transformations.  */\n+\n+static tree\n+gimple_rewrite_call_expr (gimple stmt, int skip, tree fndecl, int n, ...)\n+{\n+  int oldnargs = gimple_call_num_args (stmt);\n+  int nargs = oldnargs - skip + n;\n+  tree fntype = TREE_TYPE (fndecl);\n+  tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n+  tree *buffer;\n+  int i, j;\n+  va_list ap;\n+\n+  buffer = XALLOCAVEC (tree, nargs);\n+  va_start (ap, n);\n+  for (i = 0; i < n; i++)\n+    buffer[i] = va_arg (ap, tree);\n+  va_end (ap);\n+  for (j = skip; j < oldnargs; j++, i++)\n+    buffer[i] = gimple_call_arg (stmt, j);\n+\n+  return fold (build_call_array (TREE_TYPE (fntype), fn, nargs, buffer));\n+}\n+\n+/* Fold a call STMT to __{,v}sprintf_chk.  Return NULL_TREE if\n+   a normal call should be emitted rather than expanding the function\n+   inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n+\n+static tree\n+gimple_fold_builtin_sprintf_chk (gimple stmt, enum built_in_function fcode)\n+{\n+  tree dest, size, len, fn, fmt, flag;\n+  const char *fmt_str;\n+  int nargs = gimple_call_num_args (stmt);\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (nargs < 4)\n+    return NULL_TREE;\n+  dest = gimple_call_arg (stmt, 0);\n+  if (!validate_arg (dest, POINTER_TYPE))\n+    return NULL_TREE;\n+  flag = gimple_call_arg (stmt, 1);\n+  if (!validate_arg (flag, INTEGER_TYPE))\n+    return NULL_TREE;\n+  size = gimple_call_arg (stmt, 2);\n+  if (!validate_arg (size, INTEGER_TYPE))\n+    return NULL_TREE;\n+  fmt = gimple_call_arg (stmt, 3);\n+  if (!validate_arg (fmt, POINTER_TYPE))\n+    return NULL_TREE;\n+\n+  if (! host_integerp (size, 1))\n+    return NULL_TREE;\n+\n+  len = NULL_TREE;\n+\n+  if (!init_target_chars ())\n+    return NULL_TREE;\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str != NULL)\n+    {\n+      /* If the format doesn't contain % args or %%, we know the size.  */\n+      if (strchr (fmt_str, target_percent) == 0)\n+\t{\n+\t  if (fcode != BUILT_IN_SPRINTF_CHK || nargs == 4)\n+\t    len = build_int_cstu (size_type_node, strlen (fmt_str));\n+\t}\n+      /* If the format is \"%s\" and first ... argument is a string literal,\n+\t we know the size too.  */\n+      else if (fcode == BUILT_IN_SPRINTF_CHK\n+\t       && strcmp (fmt_str, target_percent_s) == 0)\n+\t{\n+\t  tree arg;\n+\n+\t  if (nargs == 5)\n+\t    {\n+\t      arg = gimple_call_arg (stmt, 4);\n+\t      if (validate_arg (arg, POINTER_TYPE))\n+\t\t{\n+\t\t  len = c_strlen (arg, 1);\n+\t\t  if (! len || ! host_integerp (len, 1))\n+\t\t    len = NULL_TREE;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! len || ! tree_int_cst_lt (len, size))\n+\treturn NULL_TREE;\n+    }\n+\n+  /* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0\n+     or if format doesn't contain % chars or is \"%s\".  */\n+  if (! integer_zerop (flag))\n+    {\n+      if (fmt_str == NULL)\n+\treturn NULL_TREE;\n+      if (strchr (fmt_str, target_percent) != NULL\n+\t  && strcmp (fmt_str, target_percent_s))\n+\treturn NULL_TREE;\n+    }\n+\n+  /* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */\n+  fn = built_in_decls[fcode == BUILT_IN_VSPRINTF_CHK\n+\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF];\n+  if (!fn)\n+    return NULL_TREE;\n+\n+  return gimple_rewrite_call_expr (stmt, 4, fn, 2, dest, fmt);\n+}\n+\n+/* Fold a call STMT to {,v}snprintf.  Return NULL_TREE if\n+   a normal call should be emitted rather than expanding the function\n+   inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n+   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n+   passed as second argument.  */\n+\n+tree\n+gimple_fold_builtin_snprintf_chk (gimple stmt, tree maxlen,\n+                                  enum built_in_function fcode)\n+{\n+  tree dest, size, len, fn, fmt, flag;\n+  const char *fmt_str;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (gimple_call_num_args (stmt) < 5)\n+    return NULL_TREE;\n+  dest = gimple_call_arg (stmt, 0);\n+  if (!validate_arg (dest, POINTER_TYPE))\n+    return NULL_TREE;\n+  len = gimple_call_arg (stmt, 1);\n+  if (!validate_arg (len, INTEGER_TYPE))\n+    return NULL_TREE;\n+  flag = gimple_call_arg (stmt, 2);\n+  if (!validate_arg (flag, INTEGER_TYPE))\n+    return NULL_TREE;\n+  size = gimple_call_arg (stmt, 3);\n+  if (!validate_arg (size, INTEGER_TYPE))\n+    return NULL_TREE;\n+  fmt = gimple_call_arg (stmt, 4);\n+  if (!validate_arg (fmt, POINTER_TYPE))\n+    return NULL_TREE;\n+\n+  if (! host_integerp (size, 1))\n+    return NULL_TREE;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! host_integerp (len, 1))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! host_integerp (maxlen, 1))\n+\t    return NULL_TREE;\n+\t}\n+      else\n+\tmaxlen = len;\n+\n+      if (tree_int_cst_lt (size, maxlen))\n+\treturn NULL_TREE;\n+    }\n+\n+  if (!init_target_chars ())\n+    return NULL_TREE;\n+\n+  /* Only convert __{,v}snprintf_chk to {,v}snprintf if flag is 0\n+     or if format doesn't contain % chars or is \"%s\".  */\n+  if (! integer_zerop (flag))\n+    {\n+      fmt_str = c_getstr (fmt);\n+      if (fmt_str == NULL)\n+\treturn NULL_TREE;\n+      if (strchr (fmt_str, target_percent) != NULL\n+\t  && strcmp (fmt_str, target_percent_s))\n+\treturn NULL_TREE;\n+    }\n+\n+  /* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is\n+     available.  */\n+  fn = built_in_decls[fcode == BUILT_IN_VSNPRINTF_CHK\n+\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF];\n+  if (!fn)\n+    return NULL_TREE;\n+\n+  return gimple_rewrite_call_expr (stmt, 5, fn, 3, dest, len, fmt);\n+}\n+\n+/* Builtins with folding operations that operate on \"...\" arguments\n+   need special handling; we need to store the arguments in a convenient\n+   data structure before attempting any folding.  Fortunately there are\n+   only a few builtins that fall into this category.  FNDECL is the\n+   function, EXP is the CALL_EXPR for the call, and IGNORE is true if the\n+   result of the function call is ignored.  */\n+\n+static tree\n+gimple_fold_builtin_varargs (tree fndecl, gimple stmt, bool ignore ATTRIBUTE_UNUSED)\n+{\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree ret = NULL_TREE;\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_SPRINTF_CHK:\n+    case BUILT_IN_VSPRINTF_CHK:\n+      ret = gimple_fold_builtin_sprintf_chk (stmt, fcode);\n+      break;\n+\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      ret = gimple_fold_builtin_snprintf_chk (stmt, NULL_TREE, fcode);\n+\n+    default:\n+      break;\n+    }\n+  if (ret)\n+    {\n+      ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n+      TREE_NO_WARNING (ret) = 1;\n+      return ret;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* A wrapper function for builtin folding that prevents warnings for\n+   \"statement without effect\" and the like, caused by removing the\n+   call node earlier than the warning is generated.  */\n+\n+tree\n+fold_call_stmt (gimple stmt, bool ignore)\n+{\n+  tree ret = NULL_TREE;\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  if (fndecl\n+      && TREE_CODE (fndecl) == FUNCTION_DECL\n+      && DECL_BUILT_IN (fndecl)\n+      && !gimple_call_va_arg_pack_p (stmt))\n+    {\n+      int nargs = gimple_call_num_args (stmt);\n+\n+      /* FIXME: Don't use a list in this interface.  */\n+      if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n+        {\n+          tree arglist = NULL_TREE;\n+          int i;\n+          for (i = nargs - 1; i >= 0; i--)\n+            arglist = tree_cons (NULL_TREE, gimple_call_arg (stmt, i), arglist);\n+\t  return targetm.fold_builtin (fndecl, arglist, ignore);\n+        }\n+      else\n+\t{\n+\t  if (nargs <= MAX_ARGS_TO_FOLD_BUILTIN)\n+\t    {\n+              tree args[MAX_ARGS_TO_FOLD_BUILTIN];\n+              int i;\n+              for (i = 0; i < nargs; i++)\n+                args[i] = gimple_call_arg (stmt, i);\n+\t      ret = fold_builtin_n (fndecl, args, nargs, ignore);\n+\t    }\n+\t  if (!ret)\n+\t    ret = gimple_fold_builtin_varargs (fndecl, stmt, ignore);\n+\t  if (ret)\n+\t    {\n+\t      /* Propagate location information from original call to\n+\t\t expansion of builtin.  Otherwise things like\n+\t\t maybe_emit_chk_warning, that operate on the expansion\n+\t\t of a builtin, will use the wrong location information.  */\n+\t      if (gimple_has_location (stmt))\n+                {\n+\t\t  tree realret = ret;\n+\t\t  if (TREE_CODE (ret) == NOP_EXPR)\n+\t\t    realret = TREE_OPERAND (ret, 0);\n+\t\t  if (CAN_HAVE_LOCATION_P (realret)\n+\t\t      && !EXPR_HAS_LOCATION (realret))\n+\t\t    SET_EXPR_LOCATION (realret, gimple_location (stmt));\n+                  return realret;\n+                }\n+\t      return ret;\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}"}, {"sha": "caac53e7cdd8b20536c17b94db8126404556d391", "filename": "gcc/c-common.c", "status": "modified", "additions": 53, "deletions": 56, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"real.h\"\n #include \"cgraph.h\"\n #include \"target-def.h\"\n+#include \"gimple.h\"\n #include \"fixed-value.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n@@ -7376,71 +7377,67 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)\n    inlining, so we don't have to worry about that.  */\n \n void\n-c_warn_unused_result (tree *top_p)\n+c_warn_unused_result (gimple_seq seq)\n {\n-  tree t = *top_p;\n-  tree_stmt_iterator i;\n   tree fdecl, ftype;\n+  gimple_stmt_iterator i;\n \n-  switch (TREE_CODE (t))\n+  for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n     {\n-    case STATEMENT_LIST:\n-      for (i = tsi_start (*top_p); !tsi_end_p (i); tsi_next (&i))\n-\tc_warn_unused_result (tsi_stmt_ptr (i));\n-      break;\n-\n-    case COND_EXPR:\n-      c_warn_unused_result (&COND_EXPR_THEN (t));\n-      c_warn_unused_result (&COND_EXPR_ELSE (t));\n-      break;\n-    case BIND_EXPR:\n-      c_warn_unused_result (&BIND_EXPR_BODY (t));\n-      break;\n-    case TRY_FINALLY_EXPR:\n-    case TRY_CATCH_EXPR:\n-      c_warn_unused_result (&TREE_OPERAND (t, 0));\n-      c_warn_unused_result (&TREE_OPERAND (t, 1));\n-      break;\n-    case CATCH_EXPR:\n-      c_warn_unused_result (&CATCH_BODY (t));\n-      break;\n-    case EH_FILTER_EXPR:\n-      c_warn_unused_result (&EH_FILTER_FAILURE (t));\n-      break;\n+      gimple g = gsi_stmt (i);\n \n-    case CALL_EXPR:\n-      if (TREE_USED (t))\n-\tbreak;\n-\n-      /* This is a naked call, as opposed to a CALL_EXPR nested inside\n-\t a MODIFY_EXPR.  All calls whose value is ignored should be\n-\t represented like this.  Look for the attribute.  */\n-      fdecl = get_callee_fndecl (t);\n-      if (fdecl)\n-\tftype = TREE_TYPE (fdecl);\n-      else\n+      switch (gimple_code (g))\n \t{\n-\t  ftype = TREE_TYPE (CALL_EXPR_FN (t));\n-\t  /* Look past pointer-to-function to the function type itself.  */\n-\t  ftype = TREE_TYPE (ftype);\n-\t}\n+\tcase GIMPLE_BIND:\n+\t  c_warn_unused_result (gimple_bind_body (g));\n+\t  break;\n+\tcase GIMPLE_TRY:\n+\t  c_warn_unused_result (gimple_try_eval (g));\n+\t  c_warn_unused_result (gimple_try_cleanup (g));\n+\t  break;\n+\tcase GIMPLE_CATCH:\n+\t  c_warn_unused_result (gimple_catch_handler (g));\n+\t  break;\n+\tcase GIMPLE_EH_FILTER:\n+\t  c_warn_unused_result (gimple_eh_filter_failure (g));\n+\t  break;\n \n-      if (lookup_attribute (\"warn_unused_result\", TYPE_ATTRIBUTES (ftype)))\n-\t{\n-\t  if (fdecl)\n-\t    warning (0, \"%Hignoring return value of %qD, \"\n-\t\t     \"declared with attribute warn_unused_result\",\n-\t\t     EXPR_LOCUS (t), fdecl);\n+\tcase GIMPLE_CALL:\n+\t  if (gimple_call_lhs (g))\n+\t    break;\n+\n+\t  /* This is a naked call, as opposed to a GIMPLE_CALL with an\n+\t     LHS.  All calls whose value is ignored should be\n+\t     represented like this.  Look for the attribute.  */\n+\t  fdecl = gimple_call_fn (g);\n+\t  if (TREE_CODE (fdecl) == FUNCTION_DECL)\n+\t    ftype = TREE_TYPE (fdecl);\n \t  else\n-\t    warning (0, \"%Hignoring return value of function \"\n-\t\t     \"declared with attribute warn_unused_result\",\n-\t\t     EXPR_LOCUS (t));\n-\t}\n-      break;\n+\t    {\n+\t      ftype = TREE_TYPE (fdecl);\n+\t      /* Look past pointer-to-function to the function type itself.  */\n+\t      ftype = TREE_TYPE (ftype);\n+\t    }\n \n-    default:\n-      /* Not a container, not a call, or a call whose value is used.  */\n-      break;\n+\t  if (lookup_attribute (\"warn_unused_result\", TYPE_ATTRIBUTES (ftype)))\n+\t    {\n+\t      location_t loc = gimple_location (g);\n+\n+\t      if (fdecl)\n+\t\twarning (0, \"%Hignoring return value of %qD, \"\n+\t\t\t \"declared with attribute warn_unused_result\",\n+\t\t\t &loc, fdecl);\n+\t      else\n+\t\twarning (0, \"%Hignoring return value of function \"\n+\t\t\t \"declared with attribute warn_unused_result\",\n+\t\t\t &loc);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  /* Not a container, not a call, or a call whose value is used.  */\n+\t  break;\n+\t}\n     }\n }\n "}, {"sha": "1ff5d665532728dd09d2f0c720ead6fb538b58ba", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -897,7 +897,7 @@ extern void dump_time_statistics (void);\n \n extern bool c_dump_tree (void *, tree);\n \n-extern void c_warn_unused_result (tree *);\n+extern void c_warn_unused_result (gimple_seq);\n \n extern void verify_sequence_points (tree);\n \n@@ -928,7 +928,7 @@ extern void warn_for_div_by_zero (tree divisor);\n \n /* In c-gimplify.c  */\n extern void c_genericize (tree);\n-extern int c_gimplify_expr (tree *, tree *, tree *);\n+extern int c_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n extern tree c_build_bind_expr (tree, tree);\n \n /* In c-pch.c  */"}, {"sha": "bdb6819935167b14cfec047dfbb603c8e9683fd7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -52,7 +52,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-pragma.h\"\n #include \"langhooks.h\"\n #include \"tree-mudflap.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n #include \"diagnostic.h\"\n #include \"tree-dump.h\"\n #include \"cgraph.h\"\n@@ -61,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"langhooks-def.h\"\n #include \"pointer-set.h\"\n+#include \"gimple.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -248,7 +250,7 @@ extern char C_SIZEOF_STRUCT_LANG_IDENTIFIER_isnt_accurate\n \n union lang_tree_node\n   GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *) TYPE_NEXT_VARIANT (&%h.generic) : ((union lang_tree_node *) GENERIC_NEXT (&%h.generic))\")))\n+       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *) TYPE_NEXT_VARIANT (&%h.generic) : ((union lang_tree_node *) TREE_CHAIN (&%h.generic))\")))\n {\n   union tree_node GTY ((tag (\"0\"),\n \t\t\tdesc (\"tree_node_structure (&%h)\")))\n@@ -1836,6 +1838,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \t  DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n \t  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n+\t  gimple_set_body (newdecl, gimple_body (olddecl));\n \t  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n \n \t  /* Set DECL_INLINE on the declaration if we've got a body\n@@ -1870,14 +1873,17 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t    sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n     switch (TREE_CODE (olddecl))\n       {\n+      case FUNCTION_DECL:\n+\tgimple_set_body (olddecl, gimple_body (newdecl));\n+\t/* fall through */\n+\n       case FIELD_DECL:\n       case VAR_DECL:\n       case PARM_DECL:\n       case LABEL_DECL:\n       case RESULT_DECL:\n       case CONST_DECL:\n       case TYPE_DECL:\n-      case FUNCTION_DECL:\n \tmemcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n \t\t(char *) newdecl + sizeof (struct tree_decl_common),\n \t\ttree_code_size (TREE_CODE (olddecl)) - sizeof (struct tree_decl_common));\n@@ -4050,7 +4056,7 @@ grokdeclarator (const struct c_declarator *declarator,\n      \"signed\".  */\n   if (bitfield && !flag_signed_bitfields && !declspecs->explicit_signed_p\n       && TREE_CODE (type) == INTEGER_TYPE)\n-    type = c_common_unsigned_type (type);\n+    type = unsigned_type_for (type);\n \n   /* Figure out the type qualifiers for the declaration.  There are\n      two ways a declaration can become qualified.  One is something\n@@ -6634,9 +6640,10 @@ static void\n c_gimple_diagnostics_recursively (tree fndecl)\n {\n   struct cgraph_node *cgn;\n+  gimple_seq body = gimple_body (fndecl);\n \n   /* Handle attribute((warn_unused_result)).  Relies on gimple input.  */\n-  c_warn_unused_result (&DECL_SAVED_TREE (fndecl));\n+  c_warn_unused_result (body);\n \n   /* Notice when OpenMP structured block constraints are violated.  */\n   if (flag_openmp)"}, {"sha": "9d20d12b97bd66574523f935b08260b7881d8541", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -2262,7 +2262,7 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t  && TREE_CODE (cur_type) == INTEGER_TYPE\n \t  && (!pedantic || i == 0 || (i == 1 && char_type_flag))\n \t  && (TYPE_UNSIGNED (wanted_type)\n-\t      ? wanted_type == c_common_unsigned_type (cur_type)\n+\t      ? wanted_type == unsigned_type_for (cur_type)\n \t      : wanted_type == c_common_signed_type (cur_type)))\n \tcontinue;\n       /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are"}, {"sha": "342848acd294f3e72f8005cd9d130ba60c947d8b", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -31,7 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varray.h\"\n #include \"c-tree.h\"\n #include \"c-common.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"tree-flow.h\"\n@@ -104,7 +104,6 @@ c_genericize (tree fndecl)\n   /* Go ahead and gimplify for now.  */\n   gimplify_function_tree (fndecl);\n \n-  /* Dump the genericized tree IR.  */\n   dump_function (TDI_generic, fndecl);\n \n   /* Genericize all nested functions now.  We do things in this order so\n@@ -118,14 +117,16 @@ c_genericize (tree fndecl)\n static void\n add_block_to_enclosing (tree block)\n {\n+  unsigned i;\n   tree enclosing;\n+  gimple bind;\n+  VEC(gimple, heap) *stack = gimple_bind_expr_stack ();\n \n-  for (enclosing = gimple_current_bind_expr ();\n-       enclosing; enclosing = TREE_CHAIN (enclosing))\n-    if (BIND_EXPR_BLOCK (enclosing))\n+  for (i = 0; VEC_iterate (gimple, stack, i, bind); i++)\n+    if (gimple_bind_block (bind))\n       break;\n \n-  enclosing = BIND_EXPR_BLOCK (enclosing);\n+  enclosing = gimple_bind_block (bind);\n   BLOCK_SUBBLOCKS (enclosing) = chainon (BLOCK_SUBBLOCKS (enclosing), block);\n }\n \n@@ -178,7 +179,7 @@ c_build_bind_expr (tree block, tree body)\n    decl instead.  */\n \n static enum gimplify_status\n-gimplify_compound_literal_expr (tree *expr_p, tree *pre_p)\n+gimplify_compound_literal_expr (tree *expr_p, gimple_seq *pre_p)\n {\n   tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (*expr_p);\n   tree decl = DECL_EXPR_DECL (decl_s);\n@@ -249,10 +250,12 @@ optimize_compound_literals_in_ctor (tree orig_ctor)\n   return ctor;\n }\n \n-/* Do C-specific gimplification.  Args are as for gimplify_expr.  */\n+/* Do C-specific gimplification on *EXPR_P.  PRE_P and POST_P are as in\n+   gimplify_expr.  */\n \n int\n-c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n+c_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n+\t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*expr_p);\n "}, {"sha": "7da659cc9fbc2058e9ec1e6c0307ea84b41d7fd8", "filename": "gcc/c-omp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"c-common.h\"\n #include \"toplev.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"bitmap.h\"\n #include \"langhooks.h\"\n "}, {"sha": "67a466ba74934d5027d8b36651d108708484241e", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1852,14 +1852,13 @@ static void\n pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == MODIFY_EXPR \n-      || TREE_CODE (e) == GIMPLE_MODIFY_STMT\n       || TREE_CODE (e) == INIT_EXPR)\n     {\n-      pp_c_unary_expression (pp, GENERIC_TREE_OPERAND (e, 0));\n+      pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n       pp_c_whitespace (pp);\n       pp_equal (pp);\n       pp_space (pp);\n-      pp_c_expression (pp, GENERIC_TREE_OPERAND (e, 1));\n+      pp_c_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n     pp_c_conditional_expression (pp, e);\n@@ -2007,7 +2006,6 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case MODIFY_EXPR:\n-    case GIMPLE_MODIFY_STMT:\n     case INIT_EXPR:\n       pp_assignment_expression (pp, e);\n       break;"}, {"sha": "62faee54ea83f26f9d6c24b6ca5d4ea3a808d466", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -43,7 +43,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"predict.h\"\n #include \"tree-inline.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n #include \"langhooks.h\"\n \n /* Create an empty statement tree rooted at T.  */"}, {"sha": "160229ad8b8b9400965b1f9a0a14be2e1b1d4095", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"tree-iterator.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-flow.h\"\n \n /* Possible cases of implicit bad conversions.  Used to select"}, {"sha": "71bdf8c003bfa7d3050a533cffb43f900c2c1e23", "filename": "gcc/calls.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"gimple.h\"\n #include \"flags.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n@@ -41,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"except.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-flow.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -380,7 +382,7 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n     add_reg_note (call_insn, REG_EH_REGION, const0_rtx);\n   else\n     {\n-      int rn = lookup_stmt_eh_region (fntree);\n+      int rn = lookup_expr_eh_region (fntree);\n \n       /* If rn < 0, then either (1) tree-ssa not used or (2) doesn't\n \t throw, which we already took care of.  */\n@@ -542,7 +544,26 @@ setjmp_call_p (const_tree fndecl)\n   return special_function_p (fndecl, 0) & ECF_RETURNS_TWICE;\n }\n \n+\n+/* Return true if STMT is an alloca call.  */\n+\n+bool\n+gimple_alloca_call_p (const_gimple stmt)\n+{\n+  tree fndecl;\n+\n+  if (!is_gimple_call (stmt))\n+    return false;\n+\n+  fndecl = gimple_call_fndecl (stmt);\n+  if (fndecl && (special_function_p (fndecl, 0) & ECF_MAY_BE_ALLOCA))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return true when exp contains alloca call.  */\n+\n bool\n alloca_call_p (const_tree exp)\n {\n@@ -2251,7 +2272,7 @@ expand_call (tree exp, rtx target, int ignore)\n   if (currently_expanding_call++ != 0\n       || !flag_optimize_sibling_calls\n       || args_size.var\n-      || lookup_stmt_eh_region (exp) >= 0\n+      || lookup_expr_eh_region (exp) >= 0\n       || dbg_cnt (tail_call) == false)\n     try_tail_call = 0;\n \n@@ -3229,7 +3250,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n #ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n-  int low_to_save, high_to_save;\n+  int low_to_save = 0, high_to_save = 0;\n   rtx save_area = 0;            /* Place that it is saved.  */\n #endif\n "}, {"sha": "b4c33ab81939cafc9c96a528363194a7f154440e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 423, "deletions": 79, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -42,6 +42,352 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"target.h\"\n \n+\n+/* Return an expression tree corresponding to the RHS of GIMPLE\n+   statement STMT.  */\n+\n+tree\n+gimple_assign_rhs_to_tree (gimple stmt)\n+{\n+  tree t;\n+  enum gimple_rhs_class class;\n+    \n+  class = get_gimple_rhs_class (gimple_expr_code (stmt));\n+\n+  if (class == GIMPLE_BINARY_RHS)\n+    t = build2 (gimple_assign_rhs_code (stmt),\n+\t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\tgimple_assign_rhs1 (stmt),\n+\t\tgimple_assign_rhs2 (stmt));\n+  else if (class == GIMPLE_UNARY_RHS)\n+    t = build1 (gimple_assign_rhs_code (stmt),\n+\t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\tgimple_assign_rhs1 (stmt));\n+  else if (class == GIMPLE_SINGLE_RHS)\n+    t = gimple_assign_rhs1 (stmt);\n+  else\n+    gcc_unreachable ();\n+\n+  return t;\n+}\n+\n+/* Return an expression tree corresponding to the PREDICATE of GIMPLE_COND\n+   statement STMT.  */\n+\n+static tree\n+gimple_cond_pred_to_tree (gimple stmt)\n+{\n+  return build2 (gimple_cond_code (stmt), boolean_type_node,\n+\t\t gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n+}\n+\n+/* Helper for gimple_to_tree.  Set EXPR_LOCATION for every expression\n+   inside *TP.  DATA is the location to set.  */\n+\n+static tree\n+set_expr_location_r (tree *tp, int *ws ATTRIBUTE_UNUSED, void *data)\n+{\n+  location_t *loc = (location_t *) data;\n+  if (EXPR_P (*tp))\n+    SET_EXPR_LOCATION (*tp, *loc);\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* RTL expansion has traditionally been done on trees, so the\n+   transition to doing it on GIMPLE tuples is very invasive to the RTL\n+   expander.  To facilitate the transition, this function takes a\n+   GIMPLE tuple STMT and returns the same statement in the form of a\n+   tree.  */\n+\n+static tree\n+gimple_to_tree (gimple stmt)\n+{\n+  tree t;\n+  int rn;\n+  tree_ann_common_t ann;\n+  location_t loc;\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+      {\n+\ttree lhs = gimple_assign_lhs (stmt);\n+\n+\tt = gimple_assign_rhs_to_tree (stmt);\n+\tt = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, t);\n+\tif (gimple_assign_nontemporal_move_p (stmt))\n+\t  MOVE_NONTEMPORAL (t) = true;\n+      }\n+      break;\n+\t                                 \n+    case GIMPLE_COND:\n+      t = gimple_cond_pred_to_tree (stmt);\n+      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n+      break;\n+\n+    case GIMPLE_GOTO:\n+      t = build1 (GOTO_EXPR, void_type_node, gimple_goto_dest (stmt));\n+      break;\n+\n+    case GIMPLE_LABEL:\n+      t = build1 (LABEL_EXPR, void_type_node, gimple_label_label (stmt));\n+      break;\n+\n+    case GIMPLE_RETURN:\n+      {\n+\ttree retval = gimple_return_retval (stmt);\n+\n+\tif (retval && retval != error_mark_node)\n+\t  {\n+\t    tree result = DECL_RESULT (current_function_decl);\n+\n+\t    /* If we are not returning the current function's RESULT_DECL,\n+\t       build an assignment to it.  */\n+\t    if (retval != result)\n+\t      {\n+\t\t/* I believe that a function's RESULT_DECL is unique.  */\n+\t\tgcc_assert (TREE_CODE (retval) != RESULT_DECL);\n+\n+\t\tretval = build2 (MODIFY_EXPR, TREE_TYPE (result),\n+\t\t\t\t result, retval);\n+\t      }\n+\t  }\n+\tt = build1 (RETURN_EXPR, void_type_node, retval);\n+      }\n+      break;\n+\n+    case GIMPLE_ASM:\n+      {\n+\tsize_t i, n;\n+\ttree out, in, cl;\n+\tconst char *s;\n+\n+\tout = NULL_TREE;\n+\tn = gimple_asm_noutputs (stmt);\n+\tif (n > 0)\n+\t  {\n+\t    t = out = gimple_asm_output_op (stmt, 0);\n+\t    for (i = 1; i < n; i++)\n+\t      {\n+\t\tTREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n+\t\tt = gimple_asm_output_op (stmt, i);\n+\t      }\n+\t  }\n+\n+\tin = NULL_TREE;\n+\tn = gimple_asm_ninputs (stmt);\n+\tif (n > 0)\n+\t  {\n+\t    t = in = gimple_asm_input_op (stmt, 0);\n+\t    for (i = 1; i < n; i++)\n+\t      {\n+\t\tTREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n+\t\tt = gimple_asm_input_op (stmt, i);\n+\t      }\n+\t  }\n+\n+\tcl = NULL_TREE;\n+\tn = gimple_asm_nclobbers (stmt);\n+\tif (n > 0)\n+\t  {\n+\t    t = cl = gimple_asm_clobber_op (stmt, 0);\n+\t    for (i = 1; i < n; i++)\n+\t      {\n+\t\tTREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n+\t\tt = gimple_asm_clobber_op (stmt, i);\n+\t      }\n+\t  }\n+\n+\ts = gimple_asm_string (stmt);\n+\tt = build4 (ASM_EXPR, void_type_node, build_string (strlen (s), s),\n+\t            out, in, cl);\n+        ASM_VOLATILE_P (t) = gimple_asm_volatile_p (stmt);\n+        ASM_INPUT_P (t) = gimple_asm_input_p (stmt);\n+      }\n+    break;\n+\n+    case GIMPLE_CALL:\n+      {\n+\tsize_t i;\n+        tree fn;\n+\ttree_ann_common_t ann;\n+        \n+\tt = build_vl_exp (CALL_EXPR, gimple_call_num_args (stmt) + 3);\n+\n+        fn = gimple_call_fn (stmt);\n+        if (TREE_CODE (fn) == FUNCTION_DECL)\n+          CALL_EXPR_FN (t) = build1 (ADDR_EXPR,\n+                                     build_pointer_type (TREE_TYPE (fn)),\n+                                     fn);\n+        else\n+          CALL_EXPR_FN (t) = fn;\n+        \n+        TREE_TYPE (t) = gimple_call_return_type (stmt);\n+\n+\tCALL_EXPR_STATIC_CHAIN (t) = gimple_call_chain (stmt);\n+\n+\tfor (i = 0; i < gimple_call_num_args (stmt); i++)\n+\t  CALL_EXPR_ARG (t, i) = gimple_call_arg (stmt, i);\n+\n+\tif (!(gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE)))\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\n+\tif (gimple_call_flags (stmt) & ECF_NOTHROW)\n+\t  TREE_NOTHROW (t) = 1;\n+\n+        CALL_EXPR_TAILCALL (t) = gimple_call_tail_p (stmt);\n+        CALL_EXPR_RETURN_SLOT_OPT (t) = gimple_call_return_slot_opt_p (stmt);\n+        CALL_FROM_THUNK_P (t) = gimple_call_from_thunk_p (stmt);\n+        CALL_CANNOT_INLINE_P (t) = gimple_call_cannot_inline_p (stmt);\n+        CALL_EXPR_VA_ARG_PACK (t) = gimple_call_va_arg_pack_p (stmt);\n+\n+        /* If the call has a LHS then create a MODIFY_EXPR to hold it.  */\n+\t{\n+\t  tree lhs = gimple_call_lhs (stmt);\n+\n+\t  if (lhs)\n+\t    t = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, t);\n+\t}\n+\n+        /* Record the original call statement, as it may be used\n+           to retrieve profile information during expansion.  */\n+\tif (TREE_CODE (fn) == FUNCTION_DECL && DECL_BUILT_IN (fn))\n+\t  {\n+\t    ann = get_tree_common_ann (t);\n+\t    ann->stmt = stmt;\n+\t  }\n+      }\n+    break;\n+\n+    case GIMPLE_SWITCH:\n+      {\n+\ttree label_vec;\n+\tsize_t i;\n+\ttree elt = gimple_switch_label (stmt, 0);\n+\n+\tlabel_vec = make_tree_vec (gimple_switch_num_labels (stmt));\n+\n+\tif (!CASE_LOW (elt) && !CASE_HIGH (elt))\n+\t  {\n+\t    for (i = 1; i < gimple_switch_num_labels (stmt); i++)\n+\t      TREE_VEC_ELT (label_vec, i - 1) = gimple_switch_label (stmt, i);\n+\n+\t    /* The default case in a SWITCH_EXPR must be at the end of\n+\t       the label vector.  */\n+\t    TREE_VEC_ELT (label_vec, i - 1) = gimple_switch_label (stmt, 0);\n+\t  }\n+\telse\n+\t  {\n+\t    for (i = 0; i < gimple_switch_num_labels (stmt); i++)\n+\t      TREE_VEC_ELT (label_vec, i) = gimple_switch_label (stmt, i);\n+\t  }\n+\n+\tt = build3 (SWITCH_EXPR, void_type_node, gimple_switch_index (stmt),\n+\t\t    NULL, label_vec);\n+      }\n+    break;\n+\n+    case GIMPLE_NOP:\n+    case GIMPLE_PREDICT:\n+      t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n+      break;\n+\n+    case GIMPLE_RESX:\n+      t = build_resx (gimple_resx_region (stmt));\n+      break;\n+\t\n+    default:\n+      if (errorcount == 0)\n+\t{\n+\t  error (\"Unrecognized GIMPLE statement during RTL expansion\");\n+\t  print_gimple_stmt (stderr, stmt, 4, 0);\n+\t  gcc_unreachable ();\n+\t}\n+      else\n+\t{\n+\t  /* Ignore any bad gimple codes if we're going to die anyhow,\n+\t     so we can at least set TREE_ASM_WRITTEN and have the rest\n+\t     of compilation advance without sudden ICE death.  */\n+\t  t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n+\t  break;\n+\t}\n+    }\n+\n+  /* If STMT is inside an exception region, record it in the generated\n+     expression.  */\n+  rn = lookup_stmt_eh_region (stmt);\n+  if (rn >= 0)\n+    {\n+      tree call = get_call_expr_in (t);\n+\n+      ann = get_tree_common_ann (t);\n+      ann->rn = rn;\n+      \n+      /* For a CALL_EXPR on the RHS of an assignment, calls.c looks up\n+ \t the CALL_EXPR not the assignment statment for EH region number. */\n+      if (call && call != t)\n+\t{\n+\t  ann = get_tree_common_ann (call);\n+\t  ann->rn = rn;\n+\t}\n+    }\n+\n+  /* Set EXPR_LOCATION in all the embedded expressions.  */\n+  loc = gimple_location (stmt);\n+  walk_tree (&t, set_expr_location_r, (void *) &loc, NULL);\n+\n+  TREE_BLOCK (t) = gimple_block (stmt);\n+\n+  return t;\n+}\n+\n+\n+/* Release back to GC memory allocated by gimple_to_tree.  */\n+\n+static void\n+release_stmt_tree (gimple stmt, tree stmt_tree)\n+{\n+  tree_ann_common_t ann;\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+      if (get_gimple_rhs_class (gimple_expr_code (stmt)) != GIMPLE_SINGLE_RHS)\n+\tggc_free (TREE_OPERAND (stmt_tree, 1));\n+      break;\n+    case GIMPLE_COND:\n+      ggc_free (COND_EXPR_COND (stmt_tree));\n+      break;\n+    case GIMPLE_RETURN:\n+      if (TREE_OPERAND (stmt_tree, 0)\n+\t  && TREE_CODE (TREE_OPERAND (stmt_tree, 0)) == MODIFY_EXPR)\n+\tggc_free (TREE_OPERAND (stmt_tree, 0));\n+      break;\n+    case GIMPLE_CALL:\n+      if (gimple_call_lhs (stmt))\n+\t{\n+\t  if (TREE_CODE (gimple_call_fn (stmt)) == FUNCTION_DECL)\n+\t    ggc_free (CALL_EXPR_FN (TREE_OPERAND (stmt_tree, 1)));\n+\t  ann = tree_common_ann (TREE_OPERAND (stmt_tree, 1));\n+\t  if (ann)\n+\t    ggc_free (ann);\n+\t  ggc_free (TREE_OPERAND (stmt_tree, 1));\n+\t}\n+      else if (TREE_CODE (gimple_call_fn (stmt)) == FUNCTION_DECL)\n+\tggc_free (CALL_EXPR_FN (stmt_tree));\n+      break;\n+    default:\n+      break;\n+    }\n+  ann = tree_common_ann (stmt_tree);\n+  if (ann)\n+    ggc_free (ann);\n+  ggc_free (stmt_tree);\n+}\n+\n+\n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n    ??? We really ought to pass the probability down to RTL expanders and let it\n@@ -1181,12 +1527,12 @@ expand_used_vars (void)\n    generated for STMT should have been appended.  */\n \n static void\n-maybe_dump_rtl_for_tree_stmt (tree stmt, rtx since)\n+maybe_dump_rtl_for_gimple_stmt (gimple stmt, rtx since)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\n;; \");\n-      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n       fprintf (dump_file, \"\\n\");\n \n       print_rtl (dump_file, since ? NEXT_INSN (since) : since);\n@@ -1200,10 +1546,11 @@ static struct pointer_map_t *lab_rtx_for_bb;\n /* Returns the label_rtx expression for a label starting basic block BB.  */\n \n static rtx\n-label_rtx_for_bb (basic_block bb)\n+label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n {\n-  tree_stmt_iterator tsi;\n-  tree lab, lab_stmt;\n+  gimple_stmt_iterator gsi;\n+  tree lab;\n+  gimple lab_stmt;\n   void **elt;\n \n   if (bb->flags & BB_RTL)\n@@ -1215,13 +1562,13 @@ label_rtx_for_bb (basic_block bb)\n \n   /* Find the tree label if it is present.  */\n      \n-  for (tsi = tsi_start (bb_stmt_list (bb)); !tsi_end_p (tsi); tsi_next (&tsi))\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      lab_stmt = tsi_stmt (tsi);\n-      if (TREE_CODE (lab_stmt) != LABEL_EXPR)\n+      lab_stmt = gsi_stmt (gsi);\n+      if (gimple_code (lab_stmt) != GIMPLE_LABEL)\n \tbreak;\n \n-      lab = LABEL_EXPR_LABEL (lab_stmt);\n+      lab = gimple_label_label (lab_stmt);\n       if (DECL_NONLOCAL (lab))\n \tbreak;\n \n@@ -1233,29 +1580,28 @@ label_rtx_for_bb (basic_block bb)\n   return (rtx) *elt;\n }\n \n-/* A subroutine of expand_gimple_basic_block.  Expand one COND_EXPR.\n+\n+/* A subroutine of expand_gimple_basic_block.  Expand one GIMPLE_COND.\n    Returns a new basic block if we've terminated the current basic\n    block and created a new one.  */\n \n static basic_block\n-expand_gimple_cond_expr (basic_block bb, tree stmt)\n+expand_gimple_cond (basic_block bb, gimple stmt)\n {\n   basic_block new_bb, dest;\n   edge new_edge;\n   edge true_edge;\n   edge false_edge;\n-  tree pred = COND_EXPR_COND (stmt);\n+  tree pred = gimple_cond_pred_to_tree (stmt);\n   rtx last2, last;\n \n-  gcc_assert (COND_EXPR_THEN (stmt) == NULL_TREE);\n-  gcc_assert (COND_EXPR_ELSE (stmt) == NULL_TREE);\n   last2 = last = get_last_insn ();\n \n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-  if (EXPR_LOCUS (stmt))\n+  if (gimple_has_location (stmt))\n     {\n-      set_curr_insn_source_location (*(EXPR_LOCUS (stmt)));\n-      set_curr_insn_block (TREE_BLOCK (stmt));\n+      set_curr_insn_source_location (gimple_location (stmt));\n+      set_curr_insn_block (gimple_block (stmt));\n     }\n \n   /* These flags have no purpose in RTL land.  */\n@@ -1268,20 +1614,22 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n     {\n       jumpif (pred, label_rtx_for_bb (true_edge->dest));\n       add_reg_br_prob_note (last, true_edge->probability);\n-      maybe_dump_rtl_for_tree_stmt (stmt, last);\n+      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (true_edge->goto_locus)\n   \tset_curr_insn_source_location (true_edge->goto_locus);\n       false_edge->flags |= EDGE_FALLTHRU;\n+      ggc_free (pred);\n       return NULL;\n     }\n   if (true_edge->dest == bb->next_bb)\n     {\n       jumpifnot (pred, label_rtx_for_bb (false_edge->dest));\n       add_reg_br_prob_note (last, false_edge->probability);\n-      maybe_dump_rtl_for_tree_stmt (stmt, last);\n+      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n       if (false_edge->goto_locus)\n   \tset_curr_insn_source_location (false_edge->goto_locus);\n       true_edge->flags |= EDGE_FALLTHRU;\n+      ggc_free (pred);\n       return NULL;\n     }\n \n@@ -1308,15 +1656,16 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n     BB_END (new_bb) = PREV_INSN (BB_END (new_bb));\n   update_bb_for_insn (new_bb);\n \n-  maybe_dump_rtl_for_tree_stmt (stmt, last2);\n+  maybe_dump_rtl_for_gimple_stmt (stmt, last2);\n \n   if (false_edge->goto_locus)\n     set_curr_insn_source_location (false_edge->goto_locus);\n \n+  ggc_free (pred);\n   return new_bb;\n }\n \n-/* A subroutine of expand_gimple_basic_block.  Expand one CALL_EXPR\n+/* A subroutine of expand_gimple_basic_block.  Expand one GIMPLE_CALL\n    that has CALL_EXPR_TAILCALL set.  Returns non-null if we actually\n    generated a tail call (something that might be denied by the ABI\n    rules governing the call; see calls.c).\n@@ -1327,23 +1676,26 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n    tailcall) and the normal result happens via a sqrt instruction.  */\n \n static basic_block\n-expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n+expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n {\n   rtx last2, last;\n   edge e;\n   edge_iterator ei;\n   int probability;\n   gcov_type count;\n+  tree stmt_tree = gimple_to_tree (stmt);\n \n   last2 = last = get_last_insn ();\n \n-  expand_expr_stmt (stmt);\n+  expand_expr_stmt (stmt_tree);\n+\n+  release_stmt_tree (stmt, stmt_tree);\n \n   for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n     if (CALL_P (last) && SIBLING_CALL_P (last))\n       goto found;\n \n-  maybe_dump_rtl_for_tree_stmt (stmt, last2);\n+  maybe_dump_rtl_for_gimple_stmt (stmt, last2);\n \n   *can_fallthru = true;\n   return NULL;\n@@ -1418,7 +1770,7 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n \tBB_END (bb) = PREV_INSN (last);\n     }\n \n-  maybe_dump_rtl_for_tree_stmt (stmt, last2);\n+  maybe_dump_rtl_for_gimple_stmt (stmt, last2);\n \n   return bb;\n }\n@@ -1428,50 +1780,52 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n static basic_block\n expand_gimple_basic_block (basic_block bb)\n {\n-  tree_stmt_iterator tsi;\n-  tree stmts = bb_stmt_list (bb);\n-  tree stmt = NULL;\n+  gimple_stmt_iterator gsi;\n+  gimple_seq stmts;\n+  gimple stmt = NULL;\n   rtx note, last;\n   edge e;\n   edge_iterator ei;\n   void **elt;\n \n   if (dump_file)\n-    {\n-      fprintf (dump_file,\n-\t       \"\\n;; Generating RTL for tree basic block %d\\n\",\n-\t       bb->index);\n-    }\n-\n-  bb->il.tree = NULL;\n+    fprintf (dump_file, \"\\n;; Generating RTL for gimple basic block %d\\n\",\n+\t     bb->index);\n+\n+  /* Note that since we are now transitioning from GIMPLE to RTL, we\n+     cannot use the gsi_*_bb() routines because they expect the basic\n+     block to be in GIMPLE, instead of RTL.  Therefore, we need to\n+     access the BB sequence directly.  */\n+  stmts = bb_seq (bb);\n+  bb->il.gimple = NULL;\n   init_rtl_bb_info (bb);\n   bb->flags |= BB_RTL;\n \n   /* Remove the RETURN_EXPR if we may fall though to the exit\n      instead.  */\n-  tsi = tsi_last (stmts);\n-  if (!tsi_end_p (tsi)\n-      && TREE_CODE (tsi_stmt (tsi)) == RETURN_EXPR)\n+  gsi = gsi_last (stmts);\n+  if (!gsi_end_p (gsi)\n+      && gimple_code (gsi_stmt (gsi)) == GIMPLE_RETURN)\n     {\n-      tree ret_stmt = tsi_stmt (tsi);\n+      gimple ret_stmt = gsi_stmt (gsi);\n \n       gcc_assert (single_succ_p (bb));\n       gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR);\n \n       if (bb->next_bb == EXIT_BLOCK_PTR\n-\t  && !TREE_OPERAND (ret_stmt, 0))\n+\t  && !gimple_return_retval (ret_stmt))\n \t{\n-\t  tsi_delink (&tsi);\n+\t  gsi_remove (&gsi, false);\n \t  single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n \t}\n     }\n \n-  tsi = tsi_start (stmts);\n-  if (!tsi_end_p (tsi))\n+  gsi = gsi_start (stmts);\n+  if (!gsi_end_p (gsi))\n     {\n-      stmt = tsi_stmt (tsi);\n-      if (TREE_CODE (stmt) != LABEL_EXPR)\n-\tstmt = NULL_TREE;\n+      stmt = gsi_stmt (gsi);\n+      if (gimple_code (stmt) != GIMPLE_LABEL)\n+\tstmt = NULL;\n     }\n \n   elt = pointer_map_contains (lab_rtx_for_bb, bb);\n@@ -1482,8 +1836,10 @@ expand_gimple_basic_block (basic_block bb)\n \n       if (stmt)\n \t{\n-\t  expand_expr_stmt (stmt);\n-\t  tsi_next (&tsi);\n+\t  tree stmt_tree = gimple_to_tree (stmt);\n+\t  expand_expr_stmt (stmt_tree);\n+\t  release_stmt_tree (stmt, stmt_tree);\n+\t  gsi_next (&gsi);\n \t}\n \n       if (elt)\n@@ -1496,7 +1852,7 @@ expand_gimple_basic_block (basic_block bb)\n \tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n       note = emit_note_after (NOTE_INSN_BASIC_BLOCK, BB_HEAD (bb));\n \n-      maybe_dump_rtl_for_tree_stmt (stmt, last);\n+      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n     }\n   else\n     note = BB_HEAD (bb) = emit_note (NOTE_INSN_BASIC_BLOCK);\n@@ -1517,36 +1873,22 @@ expand_gimple_basic_block (basic_block bb)\n \tei_next (&ei);\n     }\n \n-  for (; !tsi_end_p (tsi); tsi_next (&tsi))\n+  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      tree stmt = tsi_stmt (tsi);\n+      gimple stmt = gsi_stmt (gsi);\n       basic_block new_bb;\n \n-      if (!stmt)\n-\tcontinue;\n-\n       /* Expand this statement, then evaluate the resulting RTL and\n \t fixup the CFG accordingly.  */\n-      if (TREE_CODE (stmt) == COND_EXPR)\n+      if (gimple_code (stmt) == GIMPLE_COND)\n \t{\n-\t  new_bb = expand_gimple_cond_expr (bb, stmt);\n+\t  new_bb = expand_gimple_cond (bb, stmt);\n \t  if (new_bb)\n \t    return new_bb;\n \t}\n       else\n \t{\n-\t  tree call = get_call_expr_in (stmt);\n-\t  int region;\n-\t  /* For the benefit of calls.c, converting all this to rtl,\n-\t     we need to record the call expression, not just the outer\n-\t     modify statement.  */\n-\t  if (call && call != stmt)\n-\t    {\n-\t      if ((region = lookup_stmt_eh_region (stmt)) > 0)\n-\t        add_stmt_to_eh_region (call, region);\n-\t      gimple_duplicate_stmt_histograms (cfun, call, cfun, stmt);\n-\t    }\n-\t  if (call && CALL_EXPR_TAILCALL (call))\n+\t  if (is_gimple_call (stmt) && gimple_call_tail_p (stmt))\n \t    {\n \t      bool can_fallthru;\n \t      new_bb = expand_gimple_tailcall (bb, stmt, &can_fallthru);\n@@ -1560,9 +1902,11 @@ expand_gimple_basic_block (basic_block bb)\n \t    }\n \t  else\n \t    {\n+\t      tree stmt_tree = gimple_to_tree (stmt);\n \t      last = get_last_insn ();\n-\t      expand_expr_stmt (stmt);\n-\t      maybe_dump_rtl_for_tree_stmt (stmt, last);\n+\t      expand_expr_stmt (stmt_tree);\n+\t      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n+\t      release_stmt_tree (stmt, stmt_tree);\n \t    }\n \t}\n     }\n@@ -1621,7 +1965,7 @@ construct_init_block (void)\n      otherwise we have to jump into proper target.  */\n   if (e && e->dest != ENTRY_BLOCK_PTR->next_bb)\n     {\n-      tree label = tree_block_label (e->dest);\n+      tree label = gimple_block_label (e->dest);\n \n       emit_jump (label_rtx (label));\n       flags = 0;\n@@ -1779,14 +2123,14 @@ static void\n discover_nonconstant_array_refs (void)\n {\n   basic_block bb;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n \n   FOR_EACH_BB (bb)\n-    {\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\twalk_tree (bsi_stmt_ptr (bsi), discover_nonconstant_array_refs_r,\n-\t\t   NULL , NULL);\n-    }\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple stmt = gsi_stmt (gsi);\n+\twalk_gimple_op (stmt, discover_nonconstant_array_refs_r, NULL);\n+      }\n }\n \n /* Translate the intermediate representation contained in the CFG\n@@ -1799,7 +2143,7 @@ discover_nonconstant_array_refs (void)\n    the expansion.  */\n \n static unsigned int\n-tree_expand_cfg (void)\n+gimple_expand_cfg (void)\n {\n   basic_block bb, init_block;\n   sbitmap blocks;\n@@ -1949,7 +2293,7 @@ struct rtl_opt_pass pass_expand =\n   RTL_PASS,\n   \"expand\",\t\t\t\t/* name */\n   NULL,                                 /* gate */\n-  tree_expand_cfg,\t\t\t/* execute */\n+  gimple_expand_cfg,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}, {"sha": "00d7151f6b8afa6d36a6158f816cea16b30f94d5", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -51,17 +51,17 @@ cfg_layout_rtl_register_cfg_hooks (void)\n /* Initialization of functions specific to the tree IR.  */\n \n void\n-tree_register_cfg_hooks (void)\n+gimple_register_cfg_hooks (void)\n {\n-  cfg_hooks = &tree_cfg_hooks;\n+  cfg_hooks = &gimple_cfg_hooks;\n }\n \n /* Returns current ir type.  */\n \n enum ir_type\n current_ir_type (void)\n {\n-  if (cfg_hooks == &tree_cfg_hooks)\n+  if (cfg_hooks == &gimple_cfg_hooks)\n     return IR_GIMPLE;\n   else if (cfg_hooks == &rtl_cfg_hooks)\n     return IR_RTL_CFGRTL;\n@@ -291,7 +291,7 @@ dump_bb (basic_block bb, FILE *outf, int indent)\n   putc ('\\n', outf);\n \n   if (cfg_hooks->dump_bb)\n-    cfg_hooks->dump_bb (bb, outf, indent);\n+    cfg_hooks->dump_bb (bb, outf, indent, 0);\n }\n \n /* Redirect edge E to the given basic block DEST and update underlying program"}, {"sha": "537c05f07baea4bcf34598d9e283fbbeb0791635", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -28,7 +28,7 @@ struct cfg_hooks\n \n   /* Debugging.  */\n   int (*verify_flow_info) (void);\n-  void (*dump_bb) (basic_block, FILE *, int);\n+  void (*dump_bb) (basic_block, FILE *, int, int);\n \n   /* Basic CFG manipulation.  */\n \n@@ -181,14 +181,14 @@ extern void lv_add_condition_to_bb (basic_block, basic_block, basic_block,\n \t\t\t\t    void *);\n \n /* Hooks containers.  */\n-extern struct cfg_hooks tree_cfg_hooks;\n+extern struct cfg_hooks gimple_cfg_hooks;\n extern struct cfg_hooks rtl_cfg_hooks;\n extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;\n \n /* Declarations.  */\n extern enum ir_type current_ir_type (void);\n extern void rtl_register_cfg_hooks (void);\n extern void cfg_layout_rtl_register_cfg_hooks (void);\n-extern void tree_register_cfg_hooks (void);\n+extern void gimple_register_cfg_hooks (void);\n \n #endif  /* GCC_CFGHOOKS_H */"}, {"sha": "4c9bbf0ab19da258d69f9d751a24c1d47debcc82", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -563,11 +563,13 @@ find_subloop_latch_edge_by_profile (VEC (edge, heap) *latches)\n    another edge.  */\n \n static edge\n-find_subloop_latch_edge_by_ivs (struct loop *loop, VEC (edge, heap) *latches)\n+find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, VEC (edge, heap) *latches)\n {\n   edge e, latch = VEC_index (edge, latches, 0);\n   unsigned i;\n-  tree phi, lop;\n+  gimple phi;\n+  gimple_stmt_iterator psi;\n+  tree lop;\n   basic_block bb;\n \n   /* Find the candidate for the latch edge.  */\n@@ -582,15 +584,16 @@ find_subloop_latch_edge_by_ivs (struct loop *loop, VEC (edge, heap) *latches)\n \n   /* Check for a phi node that would deny that this is a latch edge of\n      a subloop.  */\n-  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+  for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n+      phi = gsi_stmt (psi);\n       lop = PHI_ARG_DEF_FROM_EDGE (phi, latch);\n \n       /* Ignore the values that are not changed inside the subloop.  */\n       if (TREE_CODE (lop) != SSA_NAME\n \t  || SSA_NAME_DEF_STMT (lop) == phi)\n \tcontinue;\n-      bb = bb_for_stmt (SSA_NAME_DEF_STMT (lop));\n+      bb = gimple_bb (SSA_NAME_DEF_STMT (lop));\n       if (!bb || !flow_bb_inside_loop_p (loop, bb))\n \tcontinue;\n "}, {"sha": "d21d50bebdd0eb22129fdc02fe65d29bdd4327db", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -49,7 +49,7 @@ struct lpt_decision GTY (())\n struct nb_iter_bound GTY ((chain_next (\"%h.next\")))\n {\n   /* The statement STMT is executed at most ...  */\n-  tree stmt;\n+  gimple stmt;\n \n   /* ... BOUND + 1 times (BOUND must be an unsigned constant).\n      The + 1 is added for the following reasons:"}, {"sha": "f9e3e17e1a79b02c61e6c520b50296408e0805e3", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -76,7 +76,7 @@ static void rtl_delete_block (basic_block);\n static basic_block rtl_redirect_edge_and_branch_force (edge, basic_block);\n static edge rtl_redirect_edge_and_branch (edge, basic_block);\n static basic_block rtl_split_block (basic_block, void *);\n-static void rtl_dump_bb (basic_block, FILE *, int);\n+static void rtl_dump_bb (basic_block, FILE *, int, int);\n static int rtl_verify_flow_info_1 (void);\n static void rtl_make_forwarder_block (edge);\n \f\n@@ -1510,7 +1510,7 @@ commit_edge_insertions (void)\n    at start and end).  */\n \n static void\n-rtl_dump_bb (basic_block bb, FILE *outf, int indent)\n+rtl_dump_bb (basic_block bb, FILE *outf, int indent, int flags ATTRIBUTE_UNUSED)\n {\n   rtx insn;\n   rtx last;"}, {"sha": "51181cbe6a2055272d96a60962114dd55ccac329", "filename": "gcc/cgraph.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -81,7 +81,7 @@ The callgraph:\n #include \"varray.h\"\n #include \"output.h\"\n #include \"intl.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-dump.h\"\n #include \"tree-flow.h\"\n \n@@ -503,9 +503,12 @@ edge_eq (const void *x, const void *y)\n   return ((const struct cgraph_edge *) x)->call_stmt == y;\n }\n \n-/* Return callgraph edge representing CALL_EXPR statement.  */\n+\n+/* Return the callgraph edge representing the GIMPLE_CALL statement\n+   CALL_STMT.  */\n+\n struct cgraph_edge *\n-cgraph_edge (struct cgraph_node *node, tree call_stmt)\n+cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n {\n   struct cgraph_edge *e, *e2;\n   int n = 0;\n@@ -526,6 +529,7 @@ cgraph_edge (struct cgraph_node *node, tree call_stmt)\n \tbreak;\n       n++;\n     }\n+\n   if (n > 100)\n     {\n       node->call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);\n@@ -540,13 +544,15 @@ cgraph_edge (struct cgraph_node *node, tree call_stmt)\n \t  *slot = e2;\n \t}\n     }\n+\n   return e;\n }\n \n-/* Change call_stmt of edge E to NEW_STMT.  */\n+\n+/* Change field call_smt of edge E to NEW_STMT.  */\n \n void\n-cgraph_set_call_stmt (struct cgraph_edge *e, tree new_stmt)\n+cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n {\n   if (e->caller->call_site_hash)\n     {\n@@ -571,7 +577,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, tree new_stmt)\n \n struct cgraph_edge *\n cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    tree call_stmt, gcov_type count, int freq, int nest)\n+\t\t    gimple call_stmt, gcov_type count, int freq, int nest)\n {\n   struct cgraph_edge *edge = GGC_NEW (struct cgraph_edge);\n #ifdef ENABLE_CHECKING\n@@ -581,9 +587,9 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n     gcc_assert (e->call_stmt != call_stmt);\n #endif\n \n-  gcc_assert (get_call_expr_in (call_stmt));\n+  gcc_assert (is_gimple_call (call_stmt));\n \n-  if (!DECL_SAVED_TREE (callee->decl))\n+  if (!gimple_body (callee->decl))\n     edge->inline_failed = N_(\"function body not available\");\n   else if (callee->local.redefined_extern_inline)\n     edge->inline_failed = N_(\"redefined extern inline functions are not \"\n@@ -691,14 +697,15 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n   e->callee = n;\n }\n \n-/* Update or remove corresponding cgraph edge if a call OLD_CALL\n-   in OLD_STMT changed into NEW_STMT.  */\n+\n+/* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n+   OLD_STMT changed into NEW_STMT.  */\n \n void\n-cgraph_update_edges_for_call_stmt (tree old_stmt, tree old_call,\n-\t\t\t\t   tree new_stmt)\n+cgraph_update_edges_for_call_stmt (gimple old_stmt, gimple new_stmt)\n {\n-  tree new_call = get_call_expr_in (new_stmt);\n+  tree new_call = (is_gimple_call (new_stmt)) ? gimple_call_fn (new_stmt) : 0;\n+  tree old_call = (is_gimple_call (old_stmt)) ? gimple_call_fn (old_stmt) : 0;\n   struct cgraph_node *node = cgraph_node (cfun->decl);\n \n   if (old_call != new_call)\n@@ -716,7 +723,7 @@ cgraph_update_edges_for_call_stmt (tree old_stmt, tree old_call,\n \t  cgraph_remove_edge (e);\n \t  if (new_call)\n \t    {\n-\t      new_decl = get_callee_fndecl (new_call);\n+\t      new_decl = gimple_call_fndecl (new_stmt);\n \t      if (new_decl)\n \t\t{\n \t\t  ne = cgraph_create_edge (node, cgraph_node (new_decl),\n@@ -736,6 +743,7 @@ cgraph_update_edges_for_call_stmt (tree old_stmt, tree old_call,\n     }\n }\n \n+\n /* Remove all callees from the node.  */\n \n void\n@@ -791,6 +799,7 @@ cgraph_release_function_body (struct cgraph_node *node)\n       delete_tree_ssa ();\n       delete_tree_cfg_annotations ();\n       cfun->eh = NULL;\n+      gimple_set_body (node->decl, NULL);\n       current_function_decl = old_decl;\n       pop_cfun();\n     }\n@@ -1006,8 +1015,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" needed\");\n   else if (node->reachable)\n     fprintf (f, \" reachable\");\n-  if (DECL_SAVED_TREE (node->decl))\n-    fprintf (f, \" tree\");\n+  if (gimple_body (node->decl))\n+    fprintf (f, \" body\");\n   if (node->output)\n     fprintf (f, \" output\");\n   if (node->local.local)\n@@ -1147,7 +1156,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   tree call_stmt, gcov_type count_scale, int freq_scale,\n+\t\t   gimple call_stmt, gcov_type count_scale, int freq_scale,\n \t\t   int loop_nest, bool update_original)\n {\n   struct cgraph_edge *new;\n@@ -1178,8 +1187,8 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n    function's profile to reflect the fact that part of execution is handled\n    by node.  */\n struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq, int loop_nest,\n-\t\t   bool update_original)\n+cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n+\t\t   int loop_nest, bool update_original)\n {\n   struct cgraph_node *new = cgraph_create_node ();\n   struct cgraph_edge *e;\n@@ -1335,8 +1344,8 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t  {\n \t    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t    current_function_decl = fndecl;\n-\t    tree_register_cfg_hooks ();\n-            tree_lowering_passes (fndecl);\n+\t    gimple_register_cfg_hooks ();\n+\t    tree_lowering_passes (fndecl);\n \t    bitmap_obstack_initialize (NULL);\n \t    if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t      execute_pass_list (pass_early_local_passes.pass.sub);\n@@ -1357,7 +1366,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t   to expansion.  */\n \tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \tcurrent_function_decl = fndecl;\n-\ttree_register_cfg_hooks ();\n+\tgimple_register_cfg_hooks ();\n \tif (!lowered)\n           tree_lowering_passes (fndecl);\n \tbitmap_obstack_initialize (NULL);"}, {"sha": "7a19dd6e05971637b6332b56ecf45ff206a17ced", "filename": "gcc/cgraph.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -91,7 +91,7 @@ struct cgraph_local_info GTY(())\n };\n \n /* Information about the function that needs to be computed globally\n-   once compilation is finished.  Available only with -funit-at-time.  */\n+   once compilation is finished.  Available only with -funit-at-a-time.  */\n \n struct cgraph_global_info GTY(())\n {\n@@ -100,7 +100,8 @@ struct cgraph_global_info GTY(())\n   /* Expected offset of the stack frame of inlined function.  */\n   HOST_WIDE_INT stack_frame_offset;\n \n-  /* For inline clones this points to the function they will be inlined into.  */\n+  /* For inline clones this points to the function they will be\n+     inlined into.  */\n   struct cgraph_node *inlined_to;\n \n   /* Estimated size of the function after inlining.  */\n@@ -196,7 +197,7 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n   struct cgraph_edge *next_caller;\n   struct cgraph_edge *prev_callee;\n   struct cgraph_edge *next_callee;\n-  tree call_stmt;\n+  gimple call_stmt;\n   PTR GTY ((skip (\"\"))) aux;\n   /* When NULL, inline this call.  When non-NULL, points to the explanation\n      why function was not inlined.  */\n@@ -306,19 +307,19 @@ void cgraph_release_function_body (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\ttree, gcov_type, int, int);\n+\t\t\t\t\tgimple, gcov_type, int, int);\n struct cgraph_node *cgraph_node (tree);\n struct cgraph_node *cgraph_node_for_asm (tree asmname);\n-struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);\n-void cgraph_set_call_stmt (struct cgraph_edge *, tree);\n-void cgraph_update_edges_for_call_stmt (tree, tree, tree);\n+struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n+void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n+void cgraph_update_edges_for_call_stmt (gimple, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\ttree, gcov_type, int, int, bool);\n+\t\t\t\t\tgimple, gcov_type, int, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int,\n \t\t\t\t\tint, bool);\n "}, {"sha": "958fed7b0ccb68e82c70826fdc7c5be25317bf54", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,5 +1,6 @@\n /* Callgraph construction.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -28,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"cgraph.h\"\n #include \"intl.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-pass.h\"\n \n /* Walk tree and record all calls and references to functions/variables.\n@@ -60,18 +61,6 @@ record_reference (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \tcgraph_mark_needed_node (cgraph_node (decl));\n       break;\n \n-    case OMP_PARALLEL:\n-      if (OMP_PARALLEL_FN (*tp))\n-\tcgraph_mark_needed_node (cgraph_node (OMP_PARALLEL_FN (*tp)));\n-      break;\n-\n-    case OMP_TASK:\n-      if (OMP_TASK_FN (*tp))\n-\tcgraph_mark_needed_node (cgraph_node (OMP_TASK_FN (*tp)));\n-      if (OMP_TASK_COPYFN (*tp))\n-\tcgraph_mark_needed_node (cgraph_node (OMP_TASK_COPYFN (*tp)));\n-      break;\n-\n     default:\n       /* Save some cycles by not walking types and declaration as we\n \t won't find anything useful there anyway.  */\n@@ -107,7 +96,7 @@ initialize_inline_failed (struct cgraph_node *node)\n \t\t\t   \"considered for inlining\");\n       else if (!node->local.inlinable)\n \te->inline_failed = N_(\"function not inlinable\");\n-      else if (CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n+      else if (gimple_call_cannot_inline_p (e->call_stmt))\n \te->inline_failed = N_(\"mismatched arguments\");\n       else\n \te->inline_failed = N_(\"function not considered for inlining\");\n@@ -142,34 +131,54 @@ build_cgraph_edges (void)\n   basic_block bb;\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   tree step;\n \n   /* Create the callgraph edges and record the nodes referenced by the function.\n      body.  */\n   FOR_EACH_BB (bb)\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\ttree stmt = bsi_stmt (bsi);\n-\ttree call = get_call_expr_in (stmt);\n+\tgimple stmt = gsi_stmt (gsi);\n \ttree decl;\n \n-\tif (call && (decl = get_callee_fndecl (call)))\n+\tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n \t  {\n-\t    int i;\n-\t    int n = call_expr_nargs (call);\n+\t    size_t i;\n+\t    size_t n = gimple_call_num_args (stmt);\n \t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n \t\t\t\tbb->count, compute_call_stmt_bb_frequency (bb),\n \t\t\t\tbb->loop_depth);\n \t    for (i = 0; i < n; i++)\n-\t      walk_tree (&CALL_EXPR_ARG (call, i),\n-\t\t\t record_reference, node, visited_nodes);\n-\t    if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-\t      walk_tree (&GIMPLE_STMT_OPERAND (stmt, 0),\n-\t\t\t record_reference, node, visited_nodes);\n+\t      walk_tree (gimple_call_arg_ptr (stmt, i), record_reference,\n+\t\t\t node, visited_nodes);\n+\t    if (gimple_call_lhs (stmt))\n+\t      walk_tree (gimple_call_lhs_ptr (stmt), record_reference, node,\n+\t\t         visited_nodes);\n \t  }\n \telse\n-\t  walk_tree (bsi_stmt_ptr (bsi), record_reference, node, visited_nodes);\n+\t  {\n+\t    struct walk_stmt_info wi;\n+\t    memset (&wi, 0, sizeof (wi));\n+\t    wi.info = node;\n+\t    wi.pset = visited_nodes;\n+\t    walk_gimple_op (stmt, record_reference, &wi);\n+\t    if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n+\t\t&& gimple_omp_parallel_child_fn (stmt))\n+\t      {\n+\t\ttree fn = gimple_omp_parallel_child_fn (stmt);\n+\t\tcgraph_mark_needed_node (cgraph_node (fn));\n+\t      }\n+\t    if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n+\t      {\n+\t\ttree fn = gimple_omp_task_child_fn (stmt);\n+\t\tif (fn)\n+\t\t  cgraph_mark_needed_node (cgraph_node (fn));\n+\t\tfn = gimple_omp_task_copy_fn (stmt);\n+\t\tif (fn)\n+\t\t  cgraph_mark_needed_node (cgraph_node (fn));\n+\t      }\n+\t  }\n       }\n \n   /* Look for initializers of constant variables and private statics.  */\n@@ -228,23 +237,23 @@ rebuild_cgraph_edges (void)\n {\n   basic_block bb;\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n \n   cgraph_node_remove_callees (node);\n \n   node->count = ENTRY_BLOCK_PTR->count;\n \n   FOR_EACH_BB (bb)\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\ttree stmt = bsi_stmt (bsi);\n-\ttree call = get_call_expr_in (stmt);\n+\tgimple stmt = gsi_stmt (gsi);\n \ttree decl;\n \n-\tif (call && (decl = get_callee_fndecl (call)))\n+\tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n \t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n \t\t\t      bb->count, compute_call_stmt_bb_frequency (bb),\n \t\t\t      bb->loop_depth);\n+\n       }\n   initialize_inline_failed (node);\n   gcc_assert (!node->global.inlined_to);"}, {"sha": "48dd70bcac797448f990ef0ba722a548254543d2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -130,7 +130,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"function.h\"\n #include \"ipa-prop.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n #include \"tree-pass.h\"\n #include \"output.h\"\n \n@@ -404,7 +405,7 @@ cgraph_process_new_functions (void)\n \t     transformations that has been already performed on the whole\n \t     cgraph but not on this function.  */\n \n-\t  tree_register_cfg_hooks ();\n+\t  gimple_register_cfg_hooks ();\n \t  if (!node->analyzed)\n \t    cgraph_analyze_function (node);\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n@@ -555,7 +556,7 @@ verify_cgraph_node (struct cgraph_node *node)\n   struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n   struct function *saved_cfun = cfun;\n   basic_block this_block;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   bool error_found = false;\n \n   if (errorcount || sorrycount)\n@@ -637,7 +638,8 @@ verify_cgraph_node (struct cgraph_node *node)\n     }\n \n   if (node->analyzed\n-      && DECL_SAVED_TREE (node->decl) && !TREE_ASM_WRITTEN (node->decl)\n+      && gimple_body (node->decl)\n+      && !TREE_ASM_WRITTEN (node->decl)\n       && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n     {\n       if (this_cfun->cfg)\n@@ -648,20 +650,21 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  /* Reach the trees by walking over the CFG, and note the\n \t     enclosing basic-blocks in the call edges.  */\n \t  FOR_EACH_BB_FN (this_block, this_cfun)\n-\t    for (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t    for (gsi = gsi_start_bb (this_block);\n+                 !gsi_end_p (gsi);\n+                 gsi_next (&gsi))\n \t      {\n-\t\ttree stmt = bsi_stmt (bsi);\n-\t\ttree call = get_call_expr_in (stmt);\n+\t\tgimple stmt = gsi_stmt (gsi);\n \t\ttree decl;\n-\t\tif (call && (decl = get_callee_fndecl (call)))\n+\t\tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n \t\t  {\n \t\t    struct cgraph_edge *e = cgraph_edge (node, stmt);\n \t\t    if (e)\n \t\t      {\n \t\t\tif (e->aux)\n \t\t\t  {\n \t\t\t    error (\"shared call_stmt:\");\n-\t\t\t    debug_generic_stmt (stmt);\n+\t\t\t    debug_gimple_stmt (stmt);\n \t\t\t    error_found = true;\n \t\t\t  }\n \t\t\tif (e->callee->decl != cgraph_node (decl)->decl\n@@ -677,7 +680,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t    else\n \t\t      {\n \t\t\terror (\"missing callgraph edge for call stmt:\");\n-\t\t\tdebug_generic_stmt (stmt);\n+\t\t\tdebug_gimple_stmt (stmt);\n \t\t\terror_found = true;\n \t\t      }\n \t\t  }\n@@ -695,7 +698,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t      error (\"edge %s->%s has no corresponding call_stmt\",\n \t\t     cgraph_node_name (e->caller),\n \t\t     cgraph_node_name (e->callee));\n-\t      debug_generic_stmt (e->call_stmt);\n+\t      debug_gimple_stmt (e->call_stmt);\n \t      error_found = true;\n \t    }\n \t  e->aux = 0;\n@@ -856,7 +859,7 @@ cgraph_analyze_functions (void)\n     {\n       fprintf (cgraph_dump_file, \"Initial entry points:\");\n       for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n-\tif (node->needed && DECL_SAVED_TREE (node->decl))\n+\tif (node->needed && gimple_body (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\");\n     }\n@@ -878,14 +881,14 @@ cgraph_analyze_functions (void)\n       /* ??? It is possible to create extern inline function and later using\n \t weak alias attribute to kill its body. See\n \t gcc.c-torture/compile/20011119-1.c  */\n-      if (!DECL_SAVED_TREE (decl))\n+      if (!DECL_STRUCT_FUNCTION (decl))\n \t{\n \t  cgraph_reset_node (node);\n \t  continue;\n \t}\n \n       gcc_assert (!node->analyzed && node->reachable);\n-      gcc_assert (DECL_SAVED_TREE (decl));\n+      gcc_assert (gimple_body (decl));\n \n       cgraph_analyze_function (node);\n \n@@ -908,7 +911,7 @@ cgraph_analyze_functions (void)\n     {\n       fprintf (cgraph_dump_file, \"Unit entry points:\");\n       for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n-\tif (node->needed && DECL_SAVED_TREE (node->decl))\n+\tif (node->needed && gimple_body (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n       dump_cgraph (cgraph_dump_file);\n@@ -922,10 +925,10 @@ cgraph_analyze_functions (void)\n       tree decl = node->decl;\n       next = node->next;\n \n-      if (node->local.finalized && !DECL_SAVED_TREE (decl))\n+      if (node->local.finalized && !gimple_body (decl))\n \tcgraph_reset_node (node);\n \n-      if (!node->reachable && DECL_SAVED_TREE (decl))\n+      if (!node->reachable && gimple_body (decl))\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n@@ -934,7 +937,7 @@ cgraph_analyze_functions (void)\n \t}\n       else\n \tnode->next_needed = NULL;\n-      gcc_assert (!node->local.finalized || DECL_SAVED_TREE (decl));\n+      gcc_assert (!node->local.finalized || gimple_body (decl));\n       gcc_assert (node->analyzed == node->local.finalized);\n     }\n   if (cgraph_dump_file)\n@@ -987,7 +990,7 @@ cgraph_mark_functions_to_output (void)\n       /* We need to output all local functions that are used and not\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n-      if (DECL_SAVED_TREE (decl)\n+      if (gimple_body (decl)\n \t  && !node->global.inlined_to\n \t  && (node->needed\n \t      || (e && node->reachable))\n@@ -998,14 +1001,16 @@ cgraph_mark_functions_to_output (void)\n \t{\n \t  /* We should've reclaimed all functions that are not needed.  */\n #ifdef ENABLE_CHECKING\n-\t  if (!node->global.inlined_to && DECL_SAVED_TREE (decl)\n+\t  if (!node->global.inlined_to\n+\t      && gimple_body (decl)\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n \t      internal_error (\"failed to reclaim unneeded function\");\n \t    }\n #endif\n-\t  gcc_assert (node->global.inlined_to || !DECL_SAVED_TREE (decl)\n+\t  gcc_assert (node->global.inlined_to\n+\t\t      || !gimple_body (decl)\n \t\t      || DECL_EXTERNAL (decl));\n \n \t}\n@@ -1035,7 +1040,6 @@ cgraph_expand_function (struct cgraph_node *node)\n   /* Make sure that BE didn't give up on compiling.  */\n   /* ??? Can happen with nested function of extern inline.  */\n   gcc_assert (TREE_ASM_WRITTEN (decl));\n-\n   current_function_decl = NULL;\n   if (!cgraph_preserve_function_body_p (decl))\n     {\n@@ -1224,7 +1228,7 @@ ipa_passes (void)\n {\n   set_cfun (NULL);\n   current_function_decl = NULL;\n-  tree_register_cfg_hooks ();\n+  gimple_register_cfg_hooks ();\n   bitmap_obstack_initialize (NULL);\n   execute_ipa_pass_list (all_ipa_passes);\n   bitmap_obstack_release (NULL);\n@@ -1324,7 +1328,7 @@ cgraph_optimize (void)\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->analyzed\n \t    && (node->global.inlined_to\n-\t\t|| DECL_SAVED_TREE (node->decl)))\n+\t\t|| gimple_body (node->decl)))\n \t  {\n \t    error_found = true;\n \t    dump_cgraph_node (stderr, node);\n@@ -1413,10 +1417,10 @@ update_call_expr (struct cgraph_node *new_version)\n   struct cgraph_edge *e;\n \n   gcc_assert (new_version);\n+\n+  /* Update the call expr on the edges to call the new version.  */\n   for (e = new_version->callers; e; e = e->next_caller)\n-    /* Update the call expr on the edges\n-       to call the new version.  */\n-    TREE_OPERAND (CALL_EXPR_FN (get_call_expr_in (e->call_stmt)), 0) = new_version->decl;\n+    gimple_call_set_fn (e->call_stmt, new_version->decl);\n }\n \n "}, {"sha": "ca66efe6c8b5508bda160900e4c0fdc433c88071", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -126,6 +126,12 @@\n #undef ENABLE_TREE_CHECKING\n #endif\n \n+/* Define if you want operations on GIMPLE (the basic data structure of\n+   the high-level optimizers) to be checked for dynamic type safety at\n+   runtime.  This is moderately expensive.  */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_GIMPLE_CHECKING\n+#endif\n \n /* Define if you want all gimple types to be verified after gimplifiation.\n    This is cheap. */"}, {"sha": "e2835acd3b756fe34f0f28dcd4d3ff155bd342f2", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on the DEC Alpha.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GCC.\n@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include <splay-tree.h>\n #include \"cfglayout.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-flow.h\"\n #include \"tree-stdarg.h\"\n #include \"tm-constrs.h\"\n@@ -5817,11 +5817,11 @@ va_list_skip_additions (tree lhs)\n       if (TREE_CODE (stmt) == PHI_NODE)\n \treturn stmt;\n \n-      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT\n-\t  || GIMPLE_STMT_OPERAND (stmt, 0) != lhs)\n+      if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t  || TREE_OPERAND (stmt, 0) != lhs)\n \treturn lhs;\n \n-      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+      rhs = TREE_OPERAND (stmt, 1);\n       if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n \trhs = TREE_OPERAND (rhs, 0);\n \n@@ -5856,11 +5856,17 @@ va_list_skip_additions (tree lhs)\n    current statement.  */\n \n static bool\n-alpha_stdarg_optimize_hook (struct stdarg_info *si, const_tree lhs, const_tree rhs)\n+alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n {\n   tree base, offset, arg1, arg2;\n   int offset_arg = 1;\n \n+#if 1\n+  /* FIXME tuples.  */\n+  (void) si;\n+  (void) stmt;\n+  return false;\n+#else\n   while (handled_component_p (rhs))\n     rhs = TREE_OPERAND (rhs, 0);\n   if (TREE_CODE (rhs) != INDIRECT_REF\n@@ -5953,6 +5959,7 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const_tree lhs, const_tree r\n escapes:\n   si->va_list_escapes = true;\n   return false;\n+#endif\n }\n #endif\n \n@@ -6087,7 +6094,7 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     {\n       nextarg = plus_constant (nextarg, offset);\n       nextarg = plus_constant (nextarg, NUM_ARGS * UNITS_PER_WORD);\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist,\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n \t\t  make_tree (ptr_type_node, nextarg));\n       TREE_SIDE_EFFECTS (t) = 1;\n \n@@ -6106,20 +6113,20 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n       t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t,\n \t\t  size_int (offset));\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (base_field), base_field, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (base_field), base_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       t = build_int_cst (NULL_TREE, NUM_ARGS * UNITS_PER_WORD);\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (offset_field),\n-\t  \t  offset_field, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n }\n \n static tree\n-alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n+alpha_gimplify_va_arg_1 (tree type, tree base, gimple_seq offset,\n+\t\t\t gimple_seq *pre_p)\n {\n   tree type_size, ptr_type, addend, t, addr, internal_post;\n \n@@ -6128,9 +6135,9 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n   if (targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n     {\n       t = build_int_cst (TREE_TYPE (offset), 6*8);\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (offset), offset,\n-\t\t  build2 (MAX_EXPR, TREE_TYPE (offset), offset, t));\n-      gimplify_and_add (t, pre_p);\n+      gimplify_assign (offset,\n+\t\t       build2 (MAX_EXPR, TREE_TYPE (offset), offset, t),\n+\t\t       pre_p);\n     }\n \n   addend = offset;\n@@ -6182,15 +6189,15 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n       t = size_binop (MULT_EXPR, t, size_int (8));\n     }\n   t = fold_convert (TREE_TYPE (offset), t);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, offset,\n-\t      build2 (PLUS_EXPR, TREE_TYPE (offset), offset, t));\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (offset, build2 (PLUS_EXPR, TREE_TYPE (offset), offset, t),\n+      \t\t   pre_p);\n \n   return build_va_arg_indirect_ref (addr);\n }\n \n static tree\n-alpha_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n+alpha_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n+\t\t       gimple_seq *post_p)\n {\n   tree offset_field, base_field, offset, base, t, r;\n   bool indirect;\n@@ -6222,9 +6229,8 @@ alpha_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   r = alpha_gimplify_va_arg_1 (type, base, offset, pre_p);\n \n   /* Stuff the offset temporary back into its field.  */\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, offset_field,\n-\t      fold_convert (TREE_TYPE (offset_field), offset));\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (offset_field,\n+\t\t   fold_convert (TREE_TYPE (offset_field), offset), pre_p);\n \n   if (indirect)\n     r = build_va_arg_indirect_ref (r);"}, {"sha": "07e8eaae9282365295a68a93de612bef59393fe2", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -2207,7 +2207,7 @@ frv_expand_builtin_va_start (tree valist, rtx nextarg)\n       debug_rtx (nextarg);\n     }\n \n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist,\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n \t      fold_convert (TREE_TYPE (valist),\n \t\t\t    make_tree (sizetype, nextarg)));\n   TREE_SIDE_EFFECTS (t) = 1;"}, {"sha": "62d1b8d9bce6815a02a195e0de1d8f42b288c53d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target-def.h\"\n #include \"langhooks.h\"\n #include \"cgraph.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"dwarf2.h\"\n #include \"df.h\"\n #include \"tm-constrs.h\"\n@@ -6327,16 +6327,16 @@ ix86_va_start (tree valist, rtx nextarg)\n   if (cfun->va_list_gpr_size)\n     {\n       type = TREE_TYPE (gpr);\n-      t = build2 (GIMPLE_MODIFY_STMT, type, gpr,\n-\t\t  build_int_cst (type, n_gpr * 8));\n+      t = build2 (MODIFY_EXPR, type,\n+\t\t  gpr, build_int_cst (type, n_gpr * 8));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n       type = TREE_TYPE (fpr);\n-      t = build2 (GIMPLE_MODIFY_STMT, type, fpr,\n+      t = build2 (MODIFY_EXPR, type, fpr,\n \t\t  build_int_cst (type, n_fpr * 16 + 8*X86_64_REGPARM_MAX));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6348,7 +6348,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   if (words != 0)\n     t = build2 (POINTER_PLUS_EXPR, type, t,\n \t        size_int (words * UNITS_PER_WORD));\n-  t = build2 (GIMPLE_MODIFY_STMT, type, ovf, t);\n+  t = build2 (MODIFY_EXPR, type, ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -6358,7 +6358,7 @@ ix86_va_start (tree valist, rtx nextarg)\n \t Prologue of the function save it right above stack frame.  */\n       type = TREE_TYPE (sav);\n       t = make_tree (type, frame_pointer_rtx);\n-      t = build2 (GIMPLE_MODIFY_STMT, type, sav, t);\n+      t = build2 (MODIFY_EXPR, type, sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -6367,7 +6367,8 @@ ix86_va_start (tree valist, rtx nextarg)\n /* Implement va_arg.  */\n \n static tree\n-ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n+ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n+\t\t      gimple_seq *post_p)\n {\n   static const int intreg[6] = { 0, 1, 2, 3, 4, 5 };\n   tree f_gpr, f_fpr, f_ovf, f_sav;\n@@ -6497,16 +6498,14 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  /* int_addr = gpr + sav; */\n \t  t = fold_convert (sizetype, gpr);\n \t  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, t);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, int_addr, t);\n-\t  gimplify_and_add (t, pre_p);\n+\t  gimplify_assign (int_addr, t, pre_p);\n \t}\n       if (needed_sseregs)\n \t{\n \t  /* sse_addr = fpr + sav; */\n \t  t = fold_convert (sizetype, fpr);\n \t  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, t);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, sse_addr, t);\n-\t  gimplify_and_add (t, pre_p);\n+\t  gimplify_assign (sse_addr, t, pre_p);\n \t}\n       if (need_temp)\n \t{\n@@ -6515,8 +6514,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n \t  /* addr = &temp; */\n \t  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-\t  gimplify_and_add (t, pre_p);\n+\t  gimplify_assign (addr, t, pre_p);\n \n \t  for (i = 0; i < XVECLEN (container, 0); i++)\n \t    {\n@@ -6549,31 +6547,27 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t\t\t       size_int (INTVAL (XEXP (slot, 1))));\n \t      dest = build_va_arg_indirect_ref (dest_addr);\n \n-\t      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dest, src);\n-\t      gimplify_and_add (t, pre_p);\n+\t      gimplify_assign (dest, src, pre_p);\n \t    }\n \t}\n \n       if (needed_intregs)\n \t{\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n \t\t      build_int_cst (TREE_TYPE (gpr), needed_intregs * 8));\n-\t  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gpr), gpr, t);\n-\t  gimplify_and_add (t, pre_p);\n+\t  gimplify_assign (gpr, t, pre_p);\n \t}\n+\n       if (needed_sseregs)\n \t{\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n \t\t      build_int_cst (TREE_TYPE (fpr), needed_sseregs * 16));\n-\t  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (fpr), fpr, t);\n-\t  gimplify_and_add (t, pre_p);\n+\t  gimplify_assign (fpr, t, pre_p);\n \t}\n \n-      t = build1 (GOTO_EXPR, void_type_node, lab_over);\n-      gimplify_and_add (t, pre_p);\n+      gimple_seq_add_stmt (pre_p, gimple_build_goto (lab_over));\n \n-      t = build1 (LABEL_EXPR, void_type_node, lab_false);\n-      append_to_statement_list (t, pre_p);\n+      gimple_seq_add_stmt (pre_p, gimple_build_label (lab_false));\n     }\n \n   /* ... otherwise out of the overflow area.  */\n@@ -6601,20 +6595,14 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = fold_convert (TREE_TYPE (ovf), t);\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n-\n-  t2 = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-  gimplify_and_add (t2, pre_p);\n+  gimplify_assign (addr, t, pre_p);\n \n   t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t,\n \t      size_int (rsize * UNITS_PER_WORD));\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (unshare_expr (ovf), t, pre_p);\n \n   if (container)\n-    {\n-      t = build1 (LABEL_EXPR, void_type_node, lab_over);\n-      append_to_statement_list (t, pre_p);\n-    }\n+    gimple_seq_add_stmt (pre_p, gimple_build_label (lab_over));\n \n   ptrtype = build_pointer_type (type);\n   addr = fold_convert (ptrtype, addr);"}, {"sha": "c07b21d9d53dcefa58647c84a5f5b43dedef2938", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -50,7 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"intl.h\"\n #include \"df.h\"\n #include \"debug.h\"\n@@ -275,7 +275,7 @@ static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);\n static tree ia64_handle_version_id_attribute (tree *, tree, tree, int, bool *);\n static void ia64_encode_section_info (tree, rtx, int);\n static rtx ia64_struct_value_rtx (tree, int);\n-static tree ia64_gimplify_va_arg (tree, tree, tree *, tree *);\n+static tree ia64_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n static bool ia64_cannot_force_const_mem (rtx);\n@@ -4342,7 +4342,8 @@ ia64_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n /* Implement va_arg.  */\n \n static tree\n-ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n+ia64_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n+\t\t      gimple_seq *post_p)\n {\n   /* Variable sized types are passed by reference.  */\n   if (pass_by_reference (NULL, TYPE_MODE (type), type, false))\n@@ -4365,8 +4366,7 @@ ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n \t\t  size_int (-2 * UNITS_PER_WORD));\n       t = fold_convert (TREE_TYPE (valist), t);\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist, t);\n-      gimplify_and_add (t, pre_p);\n+      gimplify_assign (unshare_expr (valist), t, pre_p);\n     }\n \n   return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);"}, {"sha": "ec98d81f93c422fa66d5e9699e53663c3e7eb0dd", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,5 +1,5 @@\n /* Target Prototypes for R8C/M16C/M32C\n-   Copyright (C) 2005, 2007\n+   Copyright (C) 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Red Hat.\n \n@@ -108,7 +108,7 @@ int  m32c_split_psi_p (rtx *);\n #ifdef TREE_CODE\n \n void m32c_function_arg_advance (CUMULATIVE_ARGS *, MM, tree, int);\n-tree m32c_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+tree m32c_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n void m32c_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n bool m32c_promote_function_return (const_tree);\n int  m32c_special_page_vector_p (tree);"}, {"sha": "0e03c9e6bf264420f278bc1c315f30a8bd653a82", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -47,7 +47,7 @@\n #include \"target-def.h\"\n #include \"tm_p.h\"\n #include \"langhooks.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"df.h\"\n \n /* Prototypes */"}, {"sha": "913acc71cf132f37776af2aab41d8ef795bdb54b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"bitmap.h\"\n #include \"diagnostic.h\"\n \n@@ -4959,12 +4959,12 @@ mips_va_start (tree valist, rtx nextarg)\n       if (cum->stack_words > 0)\n \tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovfl), t,\n \t\t    size_int (cum->stack_words * UNITS_PER_WORD));\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovfl), ovfl, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize GTOP, the top of the GPR save area.  */\n       t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gtop), gtop, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize FTOP, the top of the FPR save area.\n@@ -4976,18 +4976,18 @@ mips_va_start (tree valist, rtx nextarg)\n       if (fpr_offset)\n \tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ftop), t,\n \t\t    size_int (-fpr_offset));\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ftop), ftop, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Emit code to initialize GOFF, the offset from GTOP of the\n \t next GPR argument.  */\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (goff), goff,\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (goff), goff,\n \t\t  build_int_cst (TREE_TYPE (goff), gpr_save_area_size));\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       /* Likewise emit code to initialize FOFF, the offset from FTOP\n \t of the next FPR argument.  */\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (foff), foff,\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (foff), foff,\n \t\t  build_int_cst (TREE_TYPE (foff), fpr_save_area_size));\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -5001,7 +5001,8 @@ mips_va_start (tree valist, rtx nextarg)\n /* Implement TARGET_GIMPLIFY_VA_ARG_EXPR.  */\n \n static tree\n-mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n+mips_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t   gimple_seq *post_p)\n {\n   tree addr;\n   bool indirect_p;\n@@ -5100,8 +5101,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t      /* [1] Emit code for: off &= -rsize.\t*/\n \t      t = build2 (BIT_AND_EXPR, TREE_TYPE (off), off,\n \t\t\t  build_int_cst (NULL_TREE, -rsize));\n-\t      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (off), off, t);\n-\t      gimplify_and_add (t, pre_p);\n+\t      gimplify_assign (off, t, pre_p);\n \t    }\n \t  osize = rsize;\n \t}\n@@ -5137,7 +5137,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  u = size_int (-osize);\n \t  t = build2 (BIT_AND_EXPR, sizetype, t, u);\n \t  t = fold_convert (TREE_TYPE (ovfl), t);\n-\t  align = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovfl), ovfl, t);\n+\t  align = build2 (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n \t}\n       else\n \talign = NULL;"}, {"sha": "76d84bad092bb0e9a38cf84d39d9cf14c086d129", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for HPPA.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c\n \n This file is part of GCC.\n@@ -125,7 +125,7 @@ static void pa_asm_out_destructor (rtx, int);\n static void pa_init_builtins (void);\n static rtx hppa_builtin_saveregs (void);\n static void hppa_va_start (tree, rtx);\n-static tree hppa_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+static tree hppa_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n static bool pa_scalar_mode_supported_p (enum machine_mode);\n static bool pa_commutative_p (const_rtx x, int outer_code);\n static void copy_fp_args (rtx) ATTRIBUTE_UNUSED;\n@@ -5998,7 +5998,8 @@ hppa_va_start (tree valist, rtx nextarg)\n }\n \n static tree\n-hppa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n+hppa_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t   gimple_seq *post_p)\n {\n   if (TARGET_64BIT)\n     {"}, {"sha": "0e03be0fe2a77f8d8846205d3d25aa212e7b9c46", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -52,7 +52,7 @@\n #include \"reload.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-flow.h\"\n #include \"intl.h\"\n #include \"params.h\"\n@@ -958,7 +958,7 @@ static void rs6000_darwin_file_start (void);\n \n static tree rs6000_build_builtin_va_list (void);\n static void rs6000_va_start (tree, rtx);\n-static tree rs6000_gimplify_va_arg (tree, tree, tree *, tree *);\n+static tree rs6000_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool rs6000_must_pass_in_stack (enum machine_mode, const_tree);\n static bool rs6000_scalar_mode_supported_p (enum machine_mode);\n static bool rs6000_vector_mode_supported_p (enum machine_mode);\n@@ -6713,9 +6713,12 @@ rs6000_va_start (tree valist, rtx nextarg)\n \n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), unshare_expr (valist),\n+\t\tf_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), unshare_expr (valist),\n+\t\tf_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), unshare_expr (valist),\n+\t\tf_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n   words = crtl->args.info.words;\n@@ -6731,15 +6734,15 @@ rs6000_va_start (tree valist, rtx nextarg)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gpr), gpr,\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n \t\t  build_int_cst (NULL_TREE, n_gpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (fpr), fpr,\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n \t\t  build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6750,7 +6753,7 @@ rs6000_va_start (tree valist, rtx nextarg)\n   if (words != 0)\n     t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovf), t,\n \t        size_int (words * UNITS_PER_WORD));\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -6767,15 +6770,16 @@ rs6000_va_start (tree valist, rtx nextarg)\n   if (cfun->machine->varargs_save_offset)\n     t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (sav), t,\n \t        size_int (cfun->machine->varargs_save_offset));\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (sav), sav, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n /* Implement va_arg.  */\n \n tree\n-rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n+rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\tgimple_seq *post_p)\n {\n   tree f_gpr, f_fpr, f_res, f_ovf, f_sav;\n   tree gpr, fpr, ovf, sav, reg, t, u;\n@@ -6784,6 +6788,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   int align;\n   tree ptrtype = build_pointer_type (type);\n   int regalign = 0;\n+  gimple stmt;\n \n   if (pass_by_reference (NULL, TYPE_MODE (type), type, false))\n     {\n@@ -6802,14 +6807,14 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  if (elem_size < UNITS_PER_WORD)\n \t    {\n \t      tree real_part, imag_part;\n-\t      tree post = NULL_TREE;\n+\t      gimple_seq post = NULL;\n \n \t      real_part = rs6000_gimplify_va_arg (valist, elem_type, pre_p,\n \t\t\t\t\t\t  &post);\n \t      /* Copy the value into a temporary, lest the formal temporary\n \t\t be reused out from under us.  */\n \t      real_part = get_initialized_tmp_var (real_part, pre_p, &post);\n-\t      append_to_statement_list (post, pre_p);\n+\t      gimple_seq_add_seq (pre_p, post);\n \n \t      imag_part = rs6000_gimplify_va_arg (valist, elem_type, pre_p,\n \t\t\t\t\t\t  post_p);\n@@ -6829,9 +6834,12 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), unshare_expr (valist),\n+\t\tf_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), unshare_expr (valist),\n+\t\tf_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), unshare_expr (valist),\n+\t\tf_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n   rsize = (size + 3) / 4;\n@@ -6885,18 +6893,19 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (n_reg == 2 && reg == gpr)\n \t{\n \t  regalign = 1;\n-\t  u = build2 (BIT_AND_EXPR, TREE_TYPE (reg), reg,\n+\t  u = build2 (BIT_AND_EXPR, TREE_TYPE (reg), unshare_expr (reg),\n \t\t     build_int_cst (TREE_TYPE (reg), n_reg - 1));\n-\t  u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, u);\n+\t  u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg),\n+\t\t      unshare_expr (reg), u);\n \t}\n       /* _Decimal128 is passed in even/odd fpr pairs; the stored\n \t reg number is 0 for f1, so we want to make it odd.  */\n       else if (reg == fpr && TYPE_MODE (type) == TDmode)\n \t{\n \t  regalign = 1;\n-\t  t = build2 (BIT_IOR_EXPR, TREE_TYPE (reg), reg,\n+\t  t = build2 (BIT_IOR_EXPR, TREE_TYPE (reg), unshare_expr (reg),\n \t\t      build_int_cst (TREE_TYPE (reg), 1));\n-\t  u = build2 (MODIFY_EXPR, void_type_node, reg, t);\n+\t  u = build2 (MODIFY_EXPR, void_type_node, unshare_expr (reg), t);\n \t}\n \n       t = fold_convert (TREE_TYPE (reg), size_int (8 - n_reg + 1));\n@@ -6909,7 +6918,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (sav_ofs)\n \tt = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, size_int (sav_ofs));\n \n-      u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg,\n+      u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), unshare_expr (reg),\n \t\t  build_int_cst (TREE_TYPE (reg), n_reg));\n       u = fold_convert (sizetype, u);\n       u = build2 (MULT_EXPR, sizetype, u, size_int (sav_scale));\n@@ -6922,22 +6931,18 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t  && TYPE_MODE (type) == SDmode)\n \tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n \n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-      gimplify_and_add (t, pre_p);\n+      gimplify_assign (addr, t, pre_p);\n \n-      t = build1 (GOTO_EXPR, void_type_node, lab_over);\n-      gimplify_and_add (t, pre_p);\n+      gimple_seq_add_stmt (pre_p, gimple_build_goto (lab_over));\n \n-      t = build1 (LABEL_EXPR, void_type_node, lab_false);\n-      append_to_statement_list (t, pre_p);\n+      stmt = gimple_build_label (lab_false);\n+      gimple_seq_add_stmt (pre_p, stmt);\n \n       if ((n_reg == 2 && !regalign) || n_reg > 2)\n \t{\n \t  /* Ensure that we don't find any more args in regs.\n \t     Alignment has taken care of for special cases.  */\n-\t  t = build_gimple_modify_stmt (reg,\n-\t\t\t\t\tbuild_int_cst (TREE_TYPE (reg), 8));\n-\t  gimplify_and_add (t, pre_p);\n+\t  gimplify_assign (reg, build_int_cst (TREE_TYPE (reg), 8), pre_p);\n \t}\n     }\n \n@@ -6955,17 +6960,15 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n-  u = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-  gimplify_and_add (u, pre_p);\n+  gimplify_assign (unshare_expr (addr), t, pre_p);\n \n   t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (unshare_expr (ovf), t, pre_p);\n \n   if (lab_over)\n     {\n-      t = build1 (LABEL_EXPR, void_type_node, lab_over);\n-      append_to_statement_list (t, pre_p);\n+      stmt = gimple_build_label (lab_over);\n+      gimple_seq_add_stmt (pre_p, stmt);\n     }\n \n   if (STRICT_ALIGNMENT\n@@ -11321,15 +11324,14 @@ rs6000_alloc_sdmode_stack_slot (void)\n {\n   tree t;\n   basic_block bb;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n \n   gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n \n   FOR_EACH_BB (bb)\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\ttree ret = walk_tree_without_duplicates (bsi_stmt_ptr (bsi),\n-\t\t\t\t\t\t rs6000_check_sdmode, NULL);\n+\ttree ret = walk_gimple_op (gsi_stmt (gsi), rs6000_check_sdmode, NULL);\n \tif (ret)\n \t  {\n \t    rtx stack = assign_stack_local (DDmode, GET_MODE_SIZE (DDmode), 0);"}, {"sha": "3c7d92b3c8d9eff232a87590cbc44b7e2763f69b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -50,7 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"langhooks.h\"\n #include \"optabs.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"df.h\"\n \n \n@@ -8424,15 +8424,15 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   if (cfun->va_list_gpr_size)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (gpr), gpr,\n-\t          build_int_cst (NULL_TREE, n_gpr));\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t  build_int_cst (NULL_TREE, n_gpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (cfun->va_list_fpr_size)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (fpr), fpr,\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n \t          build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -8452,7 +8452,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n       t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovf), t, size_int (off));\n \n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -8465,7 +8465,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (sav), t,\n \t          size_int (-RETURN_REGNUM * UNITS_PER_WORD));\n   \n-      t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (sav), sav, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -8496,8 +8496,8 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n    } */\n \n static tree\n-s390_gimplify_va_arg (tree valist, tree type, tree *pre_p, \n-\t\t      tree *post_p ATTRIBUTE_UNUSED)\n+s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p, \n+\t\t      gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav;\n   tree gpr, fpr, ovf, sav, reg, t, u;\n@@ -8512,9 +8512,13 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n   fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n   sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n+  /* The tree for args* cannot be shared between gpr/fpr and ovf since\n+     both appear on a lhs.  */\n+  valist = unshare_expr (valist);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+\n   size = int_size_in_bytes (type);\n \n   if (pass_by_reference (NULL, TYPE_MODE (type), type, false))\n@@ -8598,14 +8602,11 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n \t      fold_convert (TREE_TYPE (reg), size_int (sav_scale)));\n   t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, fold_convert (sizetype, u));\n \n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (addr, t, pre_p);\n \n-  t = build1 (GOTO_EXPR, void_type_node, lab_over);\n-  gimplify_and_add (t, pre_p);\n+  gimple_seq_add_stmt (pre_p, gimple_build_goto (lab_over));\n \n-  t = build1 (LABEL_EXPR, void_type_node, lab_false);\n-  append_to_statement_list (t, pre_p);\n+  gimple_seq_add_stmt (pre_p, gimple_build_label (lab_false));\n \n \n   /* ... Otherwise out of the overflow area.  */\n@@ -8617,16 +8618,13 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n \n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n-  u = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-  gimplify_and_add (u, pre_p);\n+  gimplify_assign (addr, t, pre_p);\n \n   t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, \n \t      size_int (size));\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, ovf, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (ovf, t, pre_p);\n \n-  t = build1 (LABEL_EXPR, void_type_node, lab_over);\n-  append_to_statement_list (t, pre_p);\n+  gimple_seq_add_stmt (pre_p, gimple_build_label (lab_over));\n \n \n   /* Increment register save count.  */"}, {"sha": "c7b8f5820625d66a48a1a6bc32be85325ab65eb6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"sched-int.h\"\n #include \"ggc.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"cfgloop.h\"\n #include \"alloc-pool.h\"\n #include \"tm-constrs.h\"\n@@ -262,7 +262,7 @@ static bool sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n static tree sh_build_builtin_va_list (void);\n static tree sh_canonical_va_list_type (tree);\n static void sh_va_start (tree, rtx);\n-static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+static tree sh_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  const_tree, bool);\n static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -7200,7 +7200,7 @@ sh_va_start (tree valist, rtx nextarg)\n   /* Call __builtin_saveregs.  */\n   u = make_tree (sizetype, expand_builtin_saveregs ());\n   u = fold_convert (ptr_type_node, u);\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_fp, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -7211,11 +7211,11 @@ sh_va_start (tree valist, rtx nextarg)\n     nfp = 0;\n   u = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, u,\n \t\t   size_int (UNITS_PER_WORD * nfp));\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_limit, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_fp_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_o, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_o, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -7226,12 +7226,12 @@ sh_va_start (tree valist, rtx nextarg)\n     nint = 0;\n   u = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, u,\n \t\t   size_int (UNITS_PER_WORD * nint));\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_o_limit, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_o_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   u = make_tree (ptr_type_node, nextarg);\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_stack, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, next_stack, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -7260,8 +7260,8 @@ find_sole_member (tree type)\n /* Implement `va_arg'.  */\n \n static tree\n-sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n-\t\t\t tree *post_p ATTRIBUTE_UNUSED)\n+sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT size, rsize;\n   tree tmp, pptr_type_node;\n@@ -7351,11 +7351,9 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  bool is_double = size == 8 && TREE_CODE (eff_type) == REAL_TYPE;\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_fp);\n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n-\t  gimplify_and_add (tmp, pre_p);\n+\t  gimplify_assign (addr, tmp, pre_p);\n \n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_tmp, valist);\n-\t  gimplify_and_add (tmp, pre_p);\n+\t  gimplify_assign (next_fp_tmp, valist, pre_p);\n \t  tmp = next_fp_limit;\n \t  if (size > 4 && !is_double)\n \t    tmp = build2 (POINTER_PLUS_EXPR, TREE_TYPE (tmp), tmp,\n@@ -7375,9 +7373,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t\t    size_int (UNITS_PER_WORD));\n \t      tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n \t\t\t    next_fp_tmp, tmp);\n-\t      tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node,\n-\t\t  \t    next_fp_tmp, tmp);\n-\t      gimplify_and_add (tmp, pre_p);\n+\t      gimplify_assign (next_fp_tmp, tmp, pre_p);\n \t    }\n \t  if (is_double)\n \t    gimplify_and_add (cmp, pre_p);\n@@ -7409,13 +7405,10 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n-\t  gimplify_and_add (tmp, pre_p);\n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_tmp, valist);\n-\t  gimplify_and_add (tmp, pre_p);\n+\t  gimplify_assign (addr, tmp, pre_p);\n+\t  gimplify_assign (next_fp_tmp, valist, pre_p);\n \n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, valist, next_fp_tmp);\n-\t  gimplify_and_add (tmp, post_p);\n+\t  gimplify_assign (valist, next_fp_tmp, post_p);\n \t  valist = next_fp_tmp;\n \t}\n       else\n@@ -7429,8 +7422,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_o);\n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n-\t  gimplify_and_add (tmp, pre_p);\n+\t  gimplify_assign (addr, tmp, pre_p);\n \n \t  tmp = build1 (GOTO_EXPR, void_type_node, lab_over);\n \t  gimplify_and_add (tmp, pre_p);\n@@ -7439,15 +7431,10 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  gimplify_and_add (tmp, pre_p);\n \n \t  if (size > 4 && ! (TARGET_SH4 || TARGET_SH2A))\n-\t    {\n-\t      tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node,\n-\t\t  \t    next_o, next_o_limit);\n-\t      gimplify_and_add (tmp, pre_p);\n-\t    }\n+\t    gimplify_assign (next_o, next_o_limit, pre_p);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, tmp);\n-\t  gimplify_and_add (tmp, pre_p);\n+\t  gimplify_assign (addr, tmp, pre_p);\n \t}\n \n       if (!result)\n@@ -7463,8 +7450,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   tmp = std_gimplify_va_arg_expr (valist, type, pre_p, NULL);\n   if (result)\n     {\n-      tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node, result, tmp);\n-      gimplify_and_add (tmp, pre_p);\n+      gimplify_assign (result, tmp, pre_p);\n \n       tmp = build1 (LABEL_EXPR, void_type_node, lab_over);\n       gimplify_and_add (tmp, pre_p);"}, {"sha": "adf28c027b1352a6c9d909e94984384a46d9b3fa", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"cfglayout.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"langhooks.h\"\n #include \"params.h\"\n #include \"df.h\"\n@@ -410,7 +410,7 @@ static rtx sparc_struct_value_rtx (tree, int);\n static bool sparc_return_in_memory (const_tree, const_tree);\n static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n static void sparc_va_start (tree, rtx);\n-static tree sparc_gimplify_va_arg (tree, tree, tree *, tree *);\n+static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool sparc_vector_mode_supported_p (enum machine_mode);\n static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, const_tree, bool);\n@@ -5709,7 +5709,8 @@ sparc_va_start (tree valist, rtx nextarg)\n /* Implement `va_arg' for stdarg.  */\n \n static tree\n-sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n+sparc_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n+\t\t       gimple_seq *post_p)\n {\n   HOST_WIDE_INT size, rsize, align;\n   tree addr, incr;\n@@ -5792,8 +5793,7 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n     addr = fold_convert (ptrtype, addr);\n \n   incr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, incr, size_int (rsize));\n-  incr = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, valist, incr);\n-  gimplify_and_add (incr, post_p);\n+  gimplify_assign (valist, incr, post_p);\n \n   return build_va_arg_indirect_ref (addr);\n }"}, {"sha": "83bd9f51315ccd411bb3924bd5f8736b6026b2da", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n \n    This file is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License as published by the Free\n@@ -50,7 +50,7 @@\n #include \"assert.h\"\n #include \"c-common.h\"\n #include \"machmode.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tm-constrs.h\"\n #include \"spu-builtins.h\"\n #include \"ddg.h\"\n@@ -118,8 +118,8 @@ static unsigned char spu_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_m\n \t\t\t\t\t    const_tree type, unsigned char named);\n static tree spu_build_builtin_va_list (void);\n static void spu_va_start (tree, rtx);\n-static tree spu_gimplify_va_arg_expr (tree valist, tree type, tree * pre_p,\n-\t\t\t\t      tree * post_p);\n+static tree spu_gimplify_va_arg_expr (tree valist, tree type,\n+\t\t\t\t      gimple_seq * pre_p, gimple_seq * post_p);\n static int regno_aligned_for_load (int regno);\n static int store_with_one_insn_p (rtx mem);\n static int mem_is_padded_component_ref (rtx x);\n@@ -3238,7 +3238,7 @@ spu_va_start (tree valist, rtx nextarg)\n   if (crtl->args.pretend_args_size > 0)\n     t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (args), t,\n \t\tsize_int (-STACK_POINTER_OFFSET));\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (args), args, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -3247,7 +3247,7 @@ spu_va_start (tree valist, rtx nextarg)\n   t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (skip), t,\n \t      size_int (crtl->args.pretend_args_size\n \t\t\t - STACK_POINTER_OFFSET));\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (skip), skip, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (skip), skip, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -3270,8 +3270,8 @@ spu_va_start (tree valist, rtx nextarg)\n     ret = *(TYPE *)addr;\n  */\n static tree\n-spu_gimplify_va_arg_expr (tree valist, tree type, tree * pre_p,\n-\t\t\t  tree * post_p ATTRIBUTE_UNUSED)\n+spu_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n+\t\t\t  gimple_seq * post_p ATTRIBUTE_UNUSED)\n {\n   tree f_args, f_skip;\n   tree args, skip;\n@@ -3303,22 +3303,21 @@ spu_gimplify_va_arg_expr (tree valist, tree type, tree * pre_p,\n   /* build conditional expression to calculate addr. The expression\n      will be gimplified later. */\n   paddedsize = size_int (rsize);\n-  tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node, args, paddedsize);\n+  tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node, unshare_expr (args), paddedsize);\n   tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\tbuild2 (GT_EXPR, boolean_type_node, tmp, skip),\n-\t\tbuild2 (LE_EXPR, boolean_type_node, args, skip));\n+\t\tbuild2 (GT_EXPR, boolean_type_node, tmp, unshare_expr (skip)),\n+\t\tbuild2 (LE_EXPR, boolean_type_node, unshare_expr (args),\n+\t\tunshare_expr (skip)));\n \n   tmp = build3 (COND_EXPR, ptr_type_node, tmp,\n-\t\tbuild2 (POINTER_PLUS_EXPR, ptr_type_node, skip,\n-\t\t\tsize_int (32)), args);\n+\t\tbuild2 (POINTER_PLUS_EXPR, ptr_type_node, unshare_expr (skip),\n+\t\t\tsize_int (32)), unshare_expr (args));\n \n-  tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, addr, tmp);\n-  gimplify_and_add (tmp, pre_p);\n+  gimplify_assign (addr, tmp, pre_p);\n \n   /* update VALIST.__args */\n   tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node, addr, paddedsize);\n-  tmp = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, tmp);\n-  gimplify_and_add (tmp, pre_p);\n+  gimplify_assign (unshare_expr (args), tmp, pre_p);\n \n   addr = fold_convert (build_pointer_type (type), addr);\n "}, {"sha": "64ecec8f5e592789762d7e3a84523f0c494f78cf", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -45,7 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target-def.h\"\n #include \"tm_p.h\"\n #include \"langhooks.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"df.h\"\n #include \"ggc.h\"\n \n@@ -1350,11 +1350,11 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   u = build_int_cst (NULL_TREE, INCOMING_FRAME_SP_OFFSET);\n   u = fold_convert (TREE_TYPE (count), u);\n   t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (base), t, u);\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (base), base, t);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (base), base, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (count), count, \n+  t = build2 (MODIFY_EXPR, TREE_TYPE (count), count, \n \t      build_int_cst (NULL_TREE,\n \t\t\t     crtl->args.info * UNITS_PER_WORD));\n   TREE_SIDE_EFFECTS (t) = 1;\n@@ -1366,8 +1366,8 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n    Note:  This algorithm is documented in stormy-abi.  */\n    \n static tree\n-xstormy16_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n-\t\t\t\ttree *post_p ATTRIBUTE_UNUSED)\n+xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t\tgimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree f_base, f_count;\n   tree base, count;\n@@ -1408,8 +1408,7 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       gimplify_and_add (t, pre_p);\n \n       t = build2 (POINTER_PLUS_EXPR, ptr_type_node, base, count_tmp);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-      gimplify_and_add (t, pre_p);\n+      gimplify_assign (addr, t, pre_p);\n \n       t = build1 (GOTO_EXPR, void_type_node, lab_gotaddr);\n       gimplify_and_add (t, pre_p);\n@@ -1427,7 +1426,7 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       tree r, u;\n \n       r = size_int (NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD);\n-      u = build2 (GIMPLE_MODIFY_STMT, void_type_node, count_tmp, r);\n+      u = build2 (MODIFY_EXPR, TREE_TYPE (count_tmp), count_tmp, r);\n \n       t = fold_convert (TREE_TYPE (count), r);\n       t = build2 (GE_EXPR, boolean_type_node, count_tmp, t);\n@@ -1444,16 +1443,14 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n   t = fold_convert (TREE_TYPE (t), fold (t));\n   t = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n   t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (base), base, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (addr, t, pre_p);\n \n   t = build1 (LABEL_EXPR, void_type_node, lab_gotaddr);\n   gimplify_and_add (t, pre_p);\n \n   t = fold_convert (TREE_TYPE (count), size_tree);\n   t = build2 (PLUS_EXPR, TREE_TYPE (count), count_tmp, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (count), count, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (count, t, pre_p);\n   \n   addr = fold_convert (build_pointer_type (type), addr);\n   return build_va_arg_indirect_ref (addr);"}, {"sha": "000df14854cb7cee252f2405acbb01cb32a21b6b", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"langhooks.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"df.h\"\n \n \n@@ -142,8 +142,9 @@ static section *xtensa_select_rtx_section (enum machine_mode, rtx,\n static bool xtensa_rtx_costs (rtx, int, int, int *);\n static tree xtensa_build_builtin_va_list (void);\n static bool xtensa_return_in_memory (const_tree, const_tree);\n+static tree xtensa_gimplify_va_arg_expr (tree, tree, gimple_seq *,\n+\t\t\t\t\t gimple_seq *);\n static rtx xtensa_function_value (const_tree, const_tree, bool);\n-static tree xtensa_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n static void xtensa_init_builtins (void);\n static tree xtensa_fold_builtin (tree, tree, bool);\n static rtx xtensa_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n@@ -2538,14 +2539,14 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   /* Call __builtin_saveregs; save the result in __va_reg */\n   u = make_tree (sizetype, expand_builtin_saveregs ());\n   u = fold_convert (ptr_type_node, u);\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, reg, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, reg, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Set the __va_stk member to ($arg_ptr - 32).  */\n   u = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n   u = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, u, size_int (-32));\n-  t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, stk, u);\n+  t = build2 (MODIFY_EXPR, ptr_type_node, stk, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -2554,7 +2555,7 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n      alignment offset for __va_stk.  */\n   if (arg_words >= MAX_ARGS_IN_REGISTERS)\n     arg_words += 2;\n-  t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, ndx,\n+  t = build2 (MODIFY_EXPR, integer_type_node, ndx,\n \t      build_int_cst (integer_type_node, arg_words * UNITS_PER_WORD));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2564,8 +2565,8 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n /* Implement `va_arg'.  */\n \n static tree\n-xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n-\t\t\t     tree *post_p ATTRIBUTE_UNUSED)\n+xtensa_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t     gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree f_stk, stk;\n   tree f_reg, reg;\n@@ -2624,8 +2625,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t  build_int_cst (integer_type_node, align - 1));\n       t = build2 (BIT_AND_EXPR, integer_type_node, t,\n \t\t  build_int_cst (integer_type_node, -align));\n-      t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, orig_ndx, t);\n-      gimplify_and_add (t, pre_p);\n+      gimplify_assign (orig_ndx, t, pre_p);\n     }\n \n \n@@ -2635,8 +2635,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \n   t = fold_convert (integer_type_node, va_size);\n   t = build2 (PLUS_EXPR, integer_type_node, orig_ndx, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, ndx, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (ndx, t, pre_p);\n \n \n   /* Check if the argument is in registers:\n@@ -2661,8 +2660,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t\t  NULL_TREE);\n       gimplify_and_add (t, pre_p);\n \n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, array, reg);\n-      gimplify_and_add (t, pre_p);\n+      gimplify_assign (array, reg, pre_p);\n \n       t = build1 (GOTO_EXPR, void_type_node, lab_over);\n       gimplify_and_add (t, pre_p);\n@@ -2694,14 +2692,12 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \n   t = size_binop (PLUS_EXPR, va_size, size_int (32));\n   t = fold_convert (integer_type_node, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, integer_type_node, ndx, t);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (ndx, t, pre_p);\n \n   t = build1 (LABEL_EXPR, void_type_node, lab_false2);\n   gimplify_and_add (t, pre_p);\n \n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, array, stk);\n-  gimplify_and_add (t, pre_p);\n+  gimplify_assign (array, stk, pre_p);\n \n   if (lab_over)\n     {"}, {"sha": "3293be1713e2651cab6fd1bb0d20fe0ad7824e9d", "filename": "gcc/configure", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1017,7 +1017,7 @@ Optional Features:\n \t\t\t  enable expensive run-time checks.  With LIST,\n \t\t\t  enable only specific categories of checks.\n \t\t\t  Categories are: yes,no,all,none,release.\n-\t\t\t  Flags are: assert,df,fold,gc,gcac,misc,\n+\t\t\t  Flags are: assert,df,fold,gc,gcac,gimple,misc,\n \t\t\t  rtlflag,rtl,runtime,tree,valgrind,types.\n   --enable-coverage=LEVEL\n \t\t\t  enable compiler's code coverage collection.\n@@ -7266,25 +7266,25 @@ do\n \t# these set all the flags to specific states\n \tyes)\t\tac_assert_checking=1 ; ac_checking=1 ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking=1 ;\n-\t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n+\t\t\tac_gc_always_collect= ; ac_gimple_checking=1 ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n \t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n \t\t\tac_types_checking=1 ;;\n \tno|none)\tac_assert_checking= ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n-\t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n+\t\t\tac_gc_always_collect= ; ac_gimple_checking= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking= ;\n \t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n \t\t\tac_types_checking= ;;\n \tall)\t\tac_assert_checking=1 ; ac_checking=1 ; ac_df_checking=1 ;\n \t\t\tac_fold_checking=1 ; ac_gc_checking=1 ;\n-\t\t\tac_gc_always_collect=1 ; ac_rtl_checking=1 ;\n+\t\t\tac_gc_always_collect=1 ; ac_gimple_checking=1 ; ac_rtl_checking=1 ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n \t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n \t\t\tac_types_checking=1 ;;\n \trelease)\tac_assert_checking=1 ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n-\t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n+\t\t\tac_gc_always_collect= ; ac_gimple_checking= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking=1 ;\n \t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n \t\t\tac_types_checking= ;;\n@@ -7294,6 +7294,7 @@ do\n \tfold)\t\tac_fold_checking=1 ;;\n \tgc)\t\tac_gc_checking=1 ;;\n \tgcac)\t\tac_gc_always_collect=1 ;;\n+\tgimple)\t\tac_gimple_checking=1 ;;\n \tmisc)\t\tac_checking=1 ;;\n \trtl)\t\tac_rtl_checking=1 ;;\n \trtlflag)\tac_rtlflag_checking=1 ;;\n@@ -7331,6 +7332,13 @@ cat >>confdefs.h <<\\_ACEOF\n #define ENABLE_ASSERT_CHECKING 1\n _ACEOF\n \n+fi\n+if test x$ac_gimple_checking != x ; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define ENABLE_GIMPLE_CHECKING 1\n+_ACEOF\n+\n fi\n \n if test x$ac_runtime_checking != x ; then\n@@ -14723,13 +14731,13 @@ if test \"${lt_cv_nm_interface+set}\" = set; then\n else\n   lt_cv_nm_interface=\"BSD nm\"\n   echo \"int some_variable = 0;\" > conftest.$ac_ext\n-  (eval echo \"\\\"\\$as_me:14726: $ac_compile\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14734: $ac_compile\\\"\" >&5)\n   (eval \"$ac_compile\" 2>conftest.err)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:14729: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14737: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n   (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:14732: output\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14740: output\\\"\" >&5)\n   cat conftest.out >&5\n   if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n     lt_cv_nm_interface=\"MS dumpbin\"\n@@ -15784,7 +15792,7 @@ ia64-*-hpux*)\n   ;;\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 15787 \"configure\"' > conftest.$ac_ext\n+  echo '#line 15795 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -16404,11 +16412,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16407: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16415: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:16411: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16419: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -16726,11 +16734,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16729: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16737: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:16733: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16741: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -16831,11 +16839,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16834: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16842: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:16838: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16846: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -16886,11 +16894,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16889: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16897: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:16893: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16901: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -19683,7 +19691,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19686 \"configure\"\n+#line 19694 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19783,7 +19791,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19786 \"configure\"\n+#line 19794 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "6d266f285d9f8db9df879b08a03bf6878918dff6", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -350,7 +350,7 @@ AC_ARG_ENABLE(checking,\n \t\t\t  enable expensive run-time checks.  With LIST,\n \t\t\t  enable only specific categories of checks.\n \t\t\t  Categories are: yes,no,all,none,release.\n-\t\t\t  Flags are: assert,df,fold,gc,gcac,misc,\n+\t\t\t  Flags are: assert,df,fold,gc,gcac,gimple,misc,\n \t\t\t  rtlflag,rtl,runtime,tree,valgrind,types.],\n [ac_checking_flags=\"${enableval}\"],[\n # Determine the default checks.\n@@ -366,25 +366,25 @@ do\n \t# these set all the flags to specific states\n \tyes)\t\tac_assert_checking=1 ; ac_checking=1 ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking=1 ;\n-\t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n+\t\t\tac_gc_always_collect= ; ac_gimple_checking=1 ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n \t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n \t\t\tac_types_checking=1 ;;\n \tno|none)\tac_assert_checking= ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n-\t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n+\t\t\tac_gc_always_collect= ; ac_gimple_checking= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking= ;\n \t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n \t\t\tac_types_checking= ;;\n \tall)\t\tac_assert_checking=1 ; ac_checking=1 ; ac_df_checking=1 ;\n \t\t\tac_fold_checking=1 ; ac_gc_checking=1 ;\n-\t\t\tac_gc_always_collect=1 ; ac_rtl_checking=1 ;\n+\t\t\tac_gc_always_collect=1 ; ac_gimple_checking=1 ; ac_rtl_checking=1 ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n \t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n \t\t\tac_types_checking=1 ;;\n \trelease)\tac_assert_checking=1 ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n-\t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n+\t\t\tac_gc_always_collect= ; ac_gimple_checking= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking=1 ;\n \t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n \t\t\tac_types_checking= ;;\n@@ -394,6 +394,7 @@ do\n \tfold)\t\tac_fold_checking=1 ;;\n \tgc)\t\tac_gc_checking=1 ;;\n \tgcac)\t\tac_gc_always_collect=1 ;;\n+\tgimple)\t\tac_gimple_checking=1 ;;\n \tmisc)\t\tac_checking=1 ;;\n \trtl)\t\tac_rtl_checking=1 ;;\n \trtlflag)\tac_rtlflag_checking=1 ;;\n@@ -422,6 +423,12 @@ if test x$ac_assert_checking != x ; then\n   AC_DEFINE(ENABLE_ASSERT_CHECKING, 1,\n [Define if you want assertions enabled.  This is a cheap check.])\n fi\n+if test x$ac_gimple_checking != x ; then\n+  AC_DEFINE(ENABLE_GIMPLE_CHECKING, 1,\n+[Define if you want operations on GIMPLE (the basic data structure of\n+the high-level optimizers) to be checked for dynamic type safety at\n+runtime.  This is moderately expensive.])\n+fi\n GCC_TARGET_TEMPLATE(ENABLE_RUNTIME_CHECKING)\n if test x$ac_runtime_checking != x ; then\n   AC_DEFINE(ENABLE_RUNTIME_CHECKING, 1,"}, {"sha": "e1d66a52608e4767e91cbed738062fdd9c2e6fa7", "filename": "gcc/coretypes.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -47,11 +47,20 @@ typedef struct rtvec_def *rtvec;\n typedef const struct rtvec_def *const_rtvec;\n union tree_node;\n typedef union tree_node *tree;\n+union gimple_statement_d;\n+typedef union gimple_statement_d *gimple;\n typedef const union tree_node *const_tree;\n+typedef const union gimple_statement_d *const_gimple;\n union section;\n typedef union section section;\n struct cl_target_option;\n struct cl_optimization;\n+struct gimple_seq_d;\n+typedef struct gimple_seq_d *gimple_seq;\n+typedef const struct gimple_seq_d *const_gimple_seq;\n+struct gimple_seq_node_d;\n+typedef struct gimple_seq_node_d *gimple_seq_node;\n+typedef const struct gimple_seq_node_d *const_gimple_seq_node;\n \n /* The major intermediate representations of GCC.  */\n enum ir_type {"}, {"sha": "ad2964cf4035dda21383ba4a113fde1123026036", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,3 +1,143 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t2008-07-22  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-gimplify.c (gimplify_if_stmt): Set location on newly created\n+\tCOND_EXPR.\n+\n+\t2008-07-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* decl.c (finish_function): Call gimple_body after cp_genericize.\n+\n+\t2008-07-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* optimize.c: Include gimple.h instead of tree-gimple.h.\n+\t* Make-lang.in (cp-gimplify.o): Depend on tree-iterator.h.\n+\t* cp-gimplify.c: Rename tree-gimple.h to gimple.h.  Include\n+\ttree-iterator.h.\n+\n+\t2008-07-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* optimize.c (maybe_clone_body): Clear DECL_SAVED_TREE for the clone.\n+\n+\t2008-07-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cp_gimplify_expr): Update comment.\n+\n+\t2008-07-14  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-tree.h (union lang_tree_node): Rename GENERIC_NEXT to\n+\tTREE_CHAIN.\n+\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Rename\n+\tGIMPLE_MODIFY_STMT to MODIFY_EXPR.\n+\t(cxx_omp_clause_copy_ctor): Same.\n+\t(cxx_omp_clause_assign_op): Same.\n+\n+\t2008-05-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cp_gimplify_omp_for): Add pre_p argument.  Tuplify.\n+\t(cp_gimplify_expr): Adjust caller.\n+\n+\t2008-05-11 Doug Kwan  <dougkwan@google.com>\n+\n+\t* init.c (build_vec_delete): Add type conversion for argument\n+\t0 of POINTER_PLUS_EXPR.\n+\n+\t2008-04-29  Doug Kwan  <dougkwan@google.com>\n+\n+       * decl2 (File): Include \"gimple.h\"\n+       (cp_write_global_declarations): Use gimple_body instead of\n+       DECL_SAVED_TREE.\n+       * Make-lang.in (cp/decl2.o): Add $(GIMPLE_H)\n+\n+\t2008-04-10  Diego Novillo  <dnovillo@google.com>\n+\n+\thttp://gcc.gnu.org/ml/gcc-patches/2008-04/msg00913.html\n+\n+\t* optimize.c (maybe_clone_body): Re-enable call to\n+\tclone_body.\n+\t* cp-gimplify.c (cp_gimplify_omp_for): Mark disabled\n+\tcode with call to gimple_unreachable.\n+\t(cp_genericize): Fix handling of clone bodies.\n+\n+\t2008-04-04  Diego Novillo  <dnovillo@google.com>\n+\n+\thttp://gcc.gnu.org/ml/gcc-patches/2008-04/msg00413.html\n+\n+\t* optimize.c (maybe_clone_body): Re-enable.\n+\n+\t2008-02-19  Diego Novillo  <dnovillo@google.com>\n+\t\t    Oleg Ryjkov  <olegr@google.com>\n+\n+\thttp://gcc.gnu.org/ml/gcc-patches/2008-02/msg00804.html\n+\n+\t* cp-gimplify.c (gimplify_for_stmt): Change gimple_seq\n+\targument to gimple_seq *.  Update all users.\n+\t(gimplify_must_not_throw_expr): Likewise.\n+\n+\t2008-02-04  Oleg Ryjkov <olegr@google.com>\n+\n+\t* except.c: Include gimple.h\n+\t(cp_protect_cleanup_actions): Convert to tuples.\n+\t* Make-lang.in (cp/except.o): Add dependency on gimple.h\n+\n+\t2007-11-10  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-gimplify.c (gimplify_cp_loop): Call tree_annotate_all_with_locus\n+\tinstead of annotating each block manually.\n+\n+\t2007-10-30  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-gimplify.c (gimplify_cp_loop): Tuplify.\n+\t(gimplify_for_stmt): Same.\n+\t(gimplify_switch_stmt): Same.\n+\t(cp_gimplify_expr): [FOR_STMT]: Do not call gimplify_for_stmt.  Return\n+\tGS_OK.\n+\t[WHILE_STMT]: Return GS_OK.\n+\t[SWITCH_STMT]: Same.\n+\t[CONTINUE_STMT]: Same.\n+\t[BREAK_STMT]: Same.\n+\t(cp_genericize): Set gimple_body() of cloned functions when needed.\n+\n+\t2007-10-29  Aldy Hernandez  <aldy@quesejoda.com>\n+\n+\t* cp-gimplify.c: Move build_gimple_eh_filter_tree here.\n+\t(cp_gimplify_init_expr): Convert to tuples.\n+\t(gimplify_must_not_throw_expr): Make function return a\n+\tgimplify_status and convert to tuples.\n+\n+\t2007-10-18  Aldy Hernandez  <aldy@quesejoda.com>\n+\n+\t* cp-gimplify.c (genericize_try_block): Enable and do not call\n+\tgimplify_stmt.\n+\t(genericize_catch_block): Same.\n+\t(genericize_eh_spec_block): Same.\n+\tRename gimple_build_eh_filter_tree to build_gimple_eh_filter_tree.\n+\t(cp_gimplify_expr): Enable TRY_BLOCK, HANDLER, and EH_SPEC_BLOCK.\n+\n+\t2007-10-16  Aldy Hernandez  <aldy@quesejoda.com>\n+\n+\t* optimize.c (maybe_clone_body): Comment out call to clone_body.\n+\t* decl.c (finish_function): Use gimple_body instead of\n+\tDECL_SAVED_TREE.\n+\t* cp-tree.h (cp_gimplify_expr): Last 2 arguments are sequences.\n+\t* cp-gimplify.c (genericize_try_block): Comment out.\n+\t(genericize_catch_block): Same.\n+\t(genericize_eh_spec_block): Same.\n+\t(gimplify_cp_loop): Comment out calls to gimplify_stmt.\n+\t(gimplify_for_stmt): Comment out.\n+\t(gimplify_switch_stmt): Comment out call to gimplify_stmt.\n+\t(cp_gimplify_omp_for): Same.\n+\t(gimplify_must_not_throw_expr): Argument pre_p is a sequence.\n+\tComment out call to gimplify_stmt and append_to_statement_list.\n+\tRename gimple_build_eh_filter_tree to build_gimple_eh_filter_tree.\n+\t(cp_gimplify_init_expr): Arguments pre_p and post_p are sequences.\n+\t(cp_gimplify_expr): Same.\n+\tComment out calls to genericize_*_block.  Comment out call to\n+\tgimplify_for_stmt.\n+\n 2008-07-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/36944"}, {"sha": "03963446251624833ff5c3d8da8cf6b334bcee6a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -239,7 +239,7 @@ cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \\\n   debug.h gt-cp-decl.h $(TIMEVAR_H) $(TREE_FLOW_H) $(TARGET_H)\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) $(C_COMMON_H) gt-cp-decl2.h $(CGRAPH_H) \\\n-  $(C_PRAGMA_H) $(TREE_DUMP_H) intl.h $(TARGET_H)\n+  $(C_PRAGMA_H) $(TREE_DUMP_H) intl.h $(TARGET_H) $(GIMPLE_H)\n cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) $(C_COMMON_H) toplev.h \\\n   langhooks.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h \\\n@@ -280,17 +280,17 @@ cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h $(DIAGNOSTIC_H) \\\n   gt-cp-repo.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) except.h toplev.h \\\n   $(FLAGS_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n-  $(TREE_INLINE_H) $(CGRAPH_H) $(TARGET_H) $(C_COMMON_H)\n+  $(TREE_INLINE_H) $(CGRAPH_H) $(TARGET_H) $(C_COMMON_H) $(GIMPLE_H)\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) $(TREE_DUMP_H)\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h $(INTEGRATE_H) \\\n-  insn-config.h input.h $(PARAMS_H) debug.h $(TREE_INLINE_H) $(TREE_GIMPLE_H) \\\n+  insn-config.h input.h $(PARAMS_H) debug.h $(TREE_INLINE_H) $(GIMPLE_H) \\\n   $(TARGET_H)\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) gt-cp-parser.h \\\n   output.h $(TARGET_H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) toplev.h $(C_COMMON_H) \\\n-\t$(TM_H) coretypes.h pointer-set.h\n+\t$(TM_H) coretypes.h pointer-set.h tree-iterator.h\n \n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(CXX_TREE_H) $(TIMEVAR_H) gt-cp-name-lookup.h toplev.h \\"}, {"sha": "8dda74d3cbe22bd0e40c787a46b08f08c214715f", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 141, "deletions": 102, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -28,7 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-tree.h\"\n #include \"c-common.h\"\n #include \"toplev.h\"\n-#include \"tree-gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple.h\"\n #include \"hashtab.h\"\n #include \"pointer-set.h\"\n #include \"flags.h\"\n@@ -62,32 +63,26 @@ begin_bc_block (enum bc_t bc)\n    If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n    body.  Otherwise, just forget the label.  */\n \n-static tree\n-finish_bc_block (enum bc_t bc, tree label, tree body)\n+static gimple_seq\n+finish_bc_block (enum bc_t bc, tree label, gimple_seq body)\n {\n   gcc_assert (label == bc_label[bc]);\n \n   if (TREE_USED (label))\n     {\n-      tree t, sl = NULL;\n-\n-      t = build1 (LABEL_EXPR, void_type_node, label);\n-\n-      append_to_statement_list (body, &sl);\n-      append_to_statement_list (t, &sl);\n-      body = sl;\n+      gimple_seq_add_stmt (&body, gimple_build_label (label));\n     }\n \n   bc_label[bc] = TREE_CHAIN (label);\n   TREE_CHAIN (label) = NULL_TREE;\n   return body;\n }\n \n-/* Build a GOTO_EXPR to represent a break or continue statement.  BC\n-   indicates which.  */\n+/* Get the LABEL_EXPR to represent a break or continue statement\n+   in the current block scope.  BC indicates which.  */\n \n static tree\n-build_bc_goto (enum bc_t bc)\n+get_bc_label (enum bc_t bc)\n {\n   tree label = bc_label[bc];\n \n@@ -103,7 +98,7 @@ build_bc_goto (enum bc_t bc)\n \n   /* Mark the label used for finish_bc_block.  */\n   TREE_USED (label) = 1;\n-  return build1 (GOTO_EXPR, void_type_node, label);\n+  return label;\n }\n \n /* Genericize a TRY_BLOCK.  */\n@@ -114,13 +109,6 @@ genericize_try_block (tree *stmt_p)\n   tree body = TRY_STMTS (*stmt_p);\n   tree cleanup = TRY_HANDLERS (*stmt_p);\n \n-  gimplify_stmt (&body);\n-\n-  if (CLEANUP_P (*stmt_p))\n-    /* A cleanup is an expression, so it doesn't need to be genericized.  */;\n-  else\n-    gimplify_stmt (&cleanup);\n-\n   *stmt_p = build2 (TRY_CATCH_EXPR, void_type_node, body, cleanup);\n }\n \n@@ -132,12 +120,28 @@ genericize_catch_block (tree *stmt_p)\n   tree type = HANDLER_TYPE (*stmt_p);\n   tree body = HANDLER_BODY (*stmt_p);\n \n-  gimplify_stmt (&body);\n-\n   /* FIXME should the caught type go in TREE_TYPE?  */\n   *stmt_p = build2 (CATCH_EXPR, void_type_node, type, body);\n }\n \n+/* A terser interface for building a representation of an exception\n+   specification.  */\n+\n+static tree\n+build_gimple_eh_filter_tree (tree body, tree allowed, tree failure)\n+{\n+  tree t;\n+\n+  /* FIXME should the allowed types go in TREE_TYPE?  */\n+  t = build2 (EH_FILTER_EXPR, void_type_node, allowed, NULL_TREE);\n+  append_to_statement_list (failure, &EH_FILTER_FAILURE (t));\n+\n+  t = build2 (TRY_CATCH_EXPR, void_type_node, NULL_TREE, t);\n+  append_to_statement_list (body, &TREE_OPERAND (t, 0));\n+\n+  return t;\n+}\n+\n /* Genericize an EH_SPEC_BLOCK by converting it to a\n    TRY_CATCH_EXPR/EH_FILTER_EXPR pair.  */\n \n@@ -147,9 +151,8 @@ genericize_eh_spec_block (tree *stmt_p)\n   tree body = EH_SPEC_STMTS (*stmt_p);\n   tree allowed = EH_SPEC_RAISES (*stmt_p);\n   tree failure = build_call_n (call_unexpected_node, 1, build_exc_ptr ());\n-  gimplify_stmt (&body);\n \n-  *stmt_p = gimple_build_eh_filter (body, allowed, failure);\n+  *stmt_p = build_gimple_eh_filter_tree (body, allowed, failure);\n }\n \n /* Genericize an IF_STMT by turning it into a COND_EXPR.  */\n@@ -158,6 +161,7 @@ static void\n gimplify_if_stmt (tree *stmt_p)\n {\n   tree stmt, cond, then_, else_;\n+  location_t locus = EXPR_LOCATION (*stmt_p);\n \n   stmt = *stmt_p;\n   cond = IF_COND (stmt);\n@@ -175,6 +179,8 @@ gimplify_if_stmt (tree *stmt_p)\n     stmt = else_;\n   else\n     stmt = build3 (COND_EXPR, void_type_node, cond, then_, else_);\n+  if (CAN_HAVE_LOCATION_P (stmt) && !EXPR_HAS_LOCATION (stmt))\n+    SET_EXPR_LOCATION (stmt, locus);\n   *stmt_p = stmt;\n }\n \n@@ -185,28 +191,33 @@ gimplify_if_stmt (tree *stmt_p)\n    evaluated before the loop body as in while and for loops, or after the\n    loop body as in do-while loops.  */\n \n-static tree\n+static gimple_seq\n gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n {\n-  tree top, entry, exit, cont_block, break_block, stmt_list, t;\n+  gimple top, entry, stmt;\n+  gimple_seq stmt_list, body_seq, incr_seq, exit_seq;\n+  tree cont_block, break_block;\n   location_t stmt_locus;\n \n   stmt_locus = input_location;\n-  stmt_list = NULL_TREE;\n-  entry = NULL_TREE;\n+  stmt_list = NULL;\n+  body_seq = NULL;\n+  incr_seq = NULL;\n+  exit_seq = NULL;\n+  entry = NULL;\n \n   break_block = begin_bc_block (bc_break);\n   cont_block = begin_bc_block (bc_continue);\n \n   /* If condition is zero don't generate a loop construct.  */\n   if (cond && integer_zerop (cond))\n     {\n-      top = NULL_TREE;\n-      exit = NULL_TREE;\n+      top = NULL;\n       if (cond_is_first)\n \t{\n-\t  t = build_bc_goto (bc_break);\n-\t  append_to_statement_list (t, &stmt_list);\n+\t  stmt = gimple_build_goto (get_bc_label (bc_break));\n+\t  gimple_set_location (stmt, stmt_locus);\n+\t  gimple_seq_add_stmt (&stmt_list, stmt);\n \t}\n     }\n   else\n@@ -215,44 +226,55 @@ gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n \t back through the main gimplifier to lower it.  Given that we\n \t have to gimplify the loop body NOW so that we can resolve\n \t break/continue stmts, seems easier to just expand to gotos.  */\n-      top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+      top = gimple_build_label (create_artificial_label ());\n \n       /* If we have an exit condition, then we build an IF with gotos either\n \t out of the loop, or to the top of it.  If there's no exit condition,\n \t then we just build a jump back to the top.  */\n-      exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n       if (cond && !integer_nonzerop (cond))\n \t{\n-\t  t = build_bc_goto (bc_break);\n-\t  exit = fold_build3 (COND_EXPR, void_type_node, cond, exit, t);\n-\t  gimplify_stmt (&exit);\n+\t  if (cond != error_mark_node)\n+\t    { \n+\t      gimplify_expr (&cond, &exit_seq, NULL, is_gimple_val, fb_rvalue);\n+\t      stmt = gimple_build_cond (NE_EXPR, cond,\n+\t\t\t\t\tbuild_int_cst (TREE_TYPE (cond), 0),\n+\t\t\t\t\tgimple_label_label (top),\n+\t\t\t\t\tget_bc_label (bc_break));\n+\t      gimple_seq_add_stmt (&exit_seq, stmt);\n+\t    }\n \n \t  if (cond_is_first)\n \t    {\n \t      if (incr)\n \t\t{\n-\t\t  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\t\t  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n+\t\t  entry = gimple_build_label (create_artificial_label ());\n+\t\t  stmt = gimple_build_goto (gimple_label_label (entry));\n \t\t}\n \t      else\n-\t\tt = build_bc_goto (bc_continue);\n-\t      append_to_statement_list (t, &stmt_list);\n+\t\tstmt = gimple_build_goto (get_bc_label (bc_continue));\n+\t      gimple_set_location (stmt, stmt_locus);\n+\t      gimple_seq_add_stmt (&stmt_list, stmt);\n \t    }\n \t}\n+      else\n+\t{\n+\t  stmt = gimple_build_goto (gimple_label_label (top));\n+\t  gimple_seq_add_stmt (&exit_seq, stmt);\n+\t}\n     }\n \n-  gimplify_stmt (&body);\n-  gimplify_stmt (&incr);\n+  gimplify_stmt (&body, &body_seq);\n+  gimplify_stmt (&incr, &incr_seq);\n \n-  body = finish_bc_block (bc_continue, cont_block, body);\n+  body_seq = finish_bc_block (bc_continue, cont_block, body_seq);\n \n-  append_to_statement_list (top, &stmt_list);\n-  append_to_statement_list (body, &stmt_list);\n-  append_to_statement_list (incr, &stmt_list);\n-  append_to_statement_list (entry, &stmt_list);\n-  append_to_statement_list (exit, &stmt_list);\n+  gimple_seq_add_stmt (&stmt_list, top);\n+  gimple_seq_add_seq (&stmt_list, body_seq);\n+  gimple_seq_add_seq (&stmt_list, incr_seq);\n+  gimple_seq_add_stmt (&stmt_list, entry);\n+  gimple_seq_add_seq (&stmt_list, exit_seq);\n \n-  annotate_all_with_locus (&stmt_list, stmt_locus);\n+  annotate_all_with_location (stmt_list, stmt_locus);\n \n   return finish_bc_block (bc_break, break_block, stmt_list);\n }\n@@ -261,58 +283,67 @@ gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n    prequeue and hand off to gimplify_cp_loop.  */\n \n static void\n-gimplify_for_stmt (tree *stmt_p, tree *pre_p)\n+gimplify_for_stmt (tree *stmt_p, gimple_seq *pre_p)\n {\n   tree stmt = *stmt_p;\n \n   if (FOR_INIT_STMT (stmt))\n     gimplify_and_add (FOR_INIT_STMT (stmt), pre_p);\n \n-  *stmt_p = gimplify_cp_loop (FOR_COND (stmt), FOR_BODY (stmt),\n-\t\t\t      FOR_EXPR (stmt), 1);\n+  gimple_seq_add_seq (pre_p,\n+\t\t      gimplify_cp_loop (FOR_COND (stmt), FOR_BODY (stmt),\n+\t\t\t\t\tFOR_EXPR (stmt), 1));\n+  *stmt_p = NULL_TREE;\n }\n \n /* Gimplify a WHILE_STMT node.  */\n \n static void\n-gimplify_while_stmt (tree *stmt_p)\n+gimplify_while_stmt (tree *stmt_p, gimple_seq *pre_p)\n {\n   tree stmt = *stmt_p;\n-  *stmt_p = gimplify_cp_loop (WHILE_COND (stmt), WHILE_BODY (stmt),\n-\t\t\t      NULL_TREE, 1);\n+  gimple_seq_add_seq (pre_p,\n+\t\t      gimplify_cp_loop (WHILE_COND (stmt), WHILE_BODY (stmt),\n+\t\t\t\t\tNULL_TREE, 1));\n+  *stmt_p = NULL_TREE;\n }\n \n /* Gimplify a DO_STMT node.  */\n \n static void\n-gimplify_do_stmt (tree *stmt_p)\n+gimplify_do_stmt (tree *stmt_p, gimple_seq *pre_p)\n {\n   tree stmt = *stmt_p;\n-  *stmt_p = gimplify_cp_loop (DO_COND (stmt), DO_BODY (stmt),\n-\t\t\t      NULL_TREE, 0);\n+  gimple_seq_add_seq (pre_p,\n+\t\t      gimplify_cp_loop (DO_COND (stmt), DO_BODY (stmt),\n+\t\t\t\t\tNULL_TREE, 0));\n+  *stmt_p = NULL_TREE;\n }\n \n /* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */\n \n static void\n-gimplify_switch_stmt (tree *stmt_p)\n+gimplify_switch_stmt (tree *stmt_p, gimple_seq *pre_p)\n {\n   tree stmt = *stmt_p;\n-  tree break_block, body;\n+  tree break_block, body, t;\n   location_t stmt_locus = input_location;\n+  gimple_seq seq = NULL;\n \n   break_block = begin_bc_block (bc_break);\n \n   body = SWITCH_STMT_BODY (stmt);\n   if (!body)\n     body = build_empty_stmt ();\n \n-  *stmt_p = build3 (SWITCH_EXPR, SWITCH_STMT_TYPE (stmt),\n-\t\t    SWITCH_STMT_COND (stmt), body, NULL_TREE);\n-  SET_EXPR_LOCATION (*stmt_p, stmt_locus);\n-  gimplify_stmt (stmt_p);\n+  t = build3 (SWITCH_EXPR, SWITCH_STMT_TYPE (stmt),\n+\t      SWITCH_STMT_COND (stmt), body, NULL_TREE);\n+  SET_EXPR_LOCATION (t, stmt_locus);\n+  gimplify_and_add (t, &seq);\n \n-  *stmt_p = finish_bc_block (bc_break, break_block, *stmt_p);\n+  seq = finish_bc_block (bc_break, break_block, seq);\n+  gimple_seq_add_seq (pre_p, seq);\n+  *stmt_p = NULL_TREE;\n }\n \n /* Hook into the middle of gimplifying an OMP_FOR node.  This is required\n@@ -321,10 +352,12 @@ gimplify_switch_stmt (tree *stmt_p)\n    regular gimplifier.  */\n \n static enum gimplify_status\n-cp_gimplify_omp_for (tree *expr_p)\n+cp_gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n {\n   tree for_stmt = *expr_p;\n   tree cont_block;\n+  gimple stmt;\n+  gimple_seq seq = NULL;\n \n   /* Protect ourselves from recursion.  */\n   if (OMP_FOR_GIMPLIFYING_P (for_stmt))\n@@ -336,10 +369,15 @@ cp_gimplify_omp_for (tree *expr_p)\n      statement expressions within the INIT, COND, or INCR expressions.  */\n   cont_block = begin_bc_block (bc_continue);\n \n-  gimplify_stmt (expr_p);\n+  gimplify_and_add (for_stmt, &seq);\n+  stmt = gimple_seq_last_stmt (seq);\n+  if (gimple_code (stmt) == GIMPLE_OMP_FOR)\n+    gimple_omp_set_body (stmt, finish_bc_block (bc_continue, cont_block,\n+\t\t\t\t\t\tgimple_omp_body (stmt)));\n+  else\n+    seq = finish_bc_block (bc_continue, cont_block, seq);\n+  gimple_seq_add_seq (pre_p, seq);\n \n-  OMP_FOR_BODY (for_stmt)\n-    = finish_bc_block (bc_continue, cont_block, OMP_FOR_BODY (for_stmt));\n   OMP_FOR_GIMPLIFYING_P (for_stmt) = 0;\n \n   return GS_ALL_DONE;\n@@ -383,7 +421,7 @@ gimplify_expr_stmt (tree *stmt_p)\n /* Gimplify initialization from an AGGR_INIT_EXPR.  */\n \n static void\n-cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+cp_gimplify_init_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   tree from = TREE_OPERAND (*expr_p, 1);\n   tree to = TREE_OPERAND (*expr_p, 0);\n@@ -441,31 +479,31 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n /* Gimplify a MUST_NOT_THROW_EXPR.  */\n \n-static void\n-gimplify_must_not_throw_expr (tree *expr_p, tree *pre_p)\n+static enum gimplify_status\n+gimplify_must_not_throw_expr (tree *expr_p, gimple_seq *pre_p)\n {\n   tree stmt = *expr_p;\n   tree temp = voidify_wrapper_expr (stmt, NULL);\n   tree body = TREE_OPERAND (stmt, 0);\n \n-  gimplify_stmt (&body);\n-\n-  stmt = gimple_build_eh_filter (body, NULL_TREE,\n-\t\t\t\t build_call_n (terminate_node, 0));\n+  stmt = build_gimple_eh_filter_tree (body, NULL_TREE,\n+\t\t\t\t      build_call_n (terminate_node, 0));\n \n+  gimplify_and_add (stmt, pre_p);\n   if (temp)\n     {\n-      append_to_statement_list (stmt, pre_p);\n       *expr_p = temp;\n+      return GS_OK;\n     }\n-  else\n-    *expr_p = stmt;\n+\n+  *expr_p = NULL;\n+  return GS_ALL_DONE;\n }\n \n /* Do C++-specific gimplification.  Args are as for gimplify_expr.  */\n \n int\n-cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   int saved_stmts_are_full_exprs_p = 0;\n   enum tree_code code = TREE_CODE (*expr_p);\n@@ -498,11 +536,10 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       break;\n \n     case MUST_NOT_THROW_EXPR:\n-      gimplify_must_not_throw_expr (expr_p, pre_p);\n-      ret = GS_OK;\n+      ret = gimplify_must_not_throw_expr (expr_p, pre_p);\n       break;\n \n-      /* We used to do this for GIMPLE_MODIFY_STMT as well, but that's unsafe; the\n+      /* We used to do this for MODIFY_EXPR as well, but that's unsafe; the\n \t LHS of an assignment might also be involved in the RHS, as in bug\n \t 25979.  */\n     case INIT_EXPR:\n@@ -539,7 +576,7 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n     case USING_STMT:\n       /* Just ignore for now.  Eventually we will want to pass this on to\n \t the debugger.  */\n-      *expr_p = build_empty_stmt ();\n+      *expr_p = NULL;\n       ret = GS_ALL_DONE;\n       break;\n \n@@ -550,35 +587,37 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n     case FOR_STMT:\n       gimplify_for_stmt (expr_p, pre_p);\n-      ret = GS_ALL_DONE;\n+      ret = GS_OK;\n       break;\n \n     case WHILE_STMT:\n-      gimplify_while_stmt (expr_p);\n-      ret = GS_ALL_DONE;\n+      gimplify_while_stmt (expr_p, pre_p);\n+      ret = GS_OK;\n       break;\n \n     case DO_STMT:\n-      gimplify_do_stmt (expr_p);\n-      ret = GS_ALL_DONE;\n+      gimplify_do_stmt (expr_p, pre_p);\n+      ret = GS_OK;\n       break;\n \n     case SWITCH_STMT:\n-      gimplify_switch_stmt (expr_p);\n-      ret = GS_ALL_DONE;\n+      gimplify_switch_stmt (expr_p, pre_p);\n+      ret = GS_OK;\n       break;\n \n     case OMP_FOR:\n-      ret = cp_gimplify_omp_for (expr_p);\n+      ret = cp_gimplify_omp_for (expr_p, pre_p);\n       break;\n \n     case CONTINUE_STMT:\n-      *expr_p = build_bc_goto (bc_continue);\n+      gimple_seq_add_stmt (pre_p, gimple_build_goto (get_bc_label (bc_continue)));\n+      *expr_p = NULL_TREE;\n       ret = GS_ALL_DONE;\n       break;\n \n     case BREAK_STMT:\n-      *expr_p = build_bc_goto (bc_break);\n+      gimple_seq_add_stmt (pre_p, gimple_build_goto (get_bc_label (bc_break)));\n+      *expr_p = NULL_TREE;\n       ret = GS_ALL_DONE;\n       break;\n \n@@ -835,13 +874,13 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n       end1 = build2 (POINTER_PLUS_EXPR, TREE_TYPE (start1), start1, end1);\n \n       p1 = create_tmp_var (TREE_TYPE (start1), NULL);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p1, start1);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (p1), p1, start1);\n       append_to_statement_list (t, &ret);\n \n       if (arg2)\n \t{\n \t  p2 = create_tmp_var (TREE_TYPE (start2), NULL);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p2, start2);\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (p2), p2, start2);\n \t  append_to_statement_list (t, &ret);\n \t}\n \n@@ -864,14 +903,14 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n \n       t = TYPE_SIZE_UNIT (inner_type);\n       t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (p1), p1, t);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p1, t);\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (p1), p1, t);\n       append_to_statement_list (t, &ret);\n \n       if (arg2)\n \t{\n \t  t = TYPE_SIZE_UNIT (inner_type);\n \t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (p2), p2, t);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p2, t);\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (p2), p2, t);\n \t  append_to_statement_list (t, &ret);\n \t}\n \n@@ -925,7 +964,7 @@ cxx_omp_clause_copy_ctor (tree clause, tree dst, tree src)\n   if (info)\n     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 0), dst, src);\n   if (ret == NULL)\n-    ret = build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n+    ret = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \n   return ret;\n }\n@@ -941,7 +980,7 @@ cxx_omp_clause_assign_op (tree clause, tree dst, tree src)\n   if (info)\n     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 2), dst, src);\n   if (ret == NULL)\n-    ret = build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n+    ret = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \n   return ret;\n }"}, {"sha": "f9a2af8bb01d089d9948e46c9aa0bd5088e58566", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -534,7 +534,7 @@ enum cp_tree_node_structure_enum {\n \n /* The resulting tree type.  */\n union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n-       chain_next (\"(union lang_tree_node *)GENERIC_NEXT (&%h.generic)\")))\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n {\n   union tree_node GTY ((tag (\"TS_CP_GENERIC\"),\n \t\t\tdesc (\"tree_node_structure (&%h)\"))) generic;\n@@ -4938,7 +4938,8 @@ extern void init_shadowed_var_for_decl\t\t(void);\n extern tree cxx_staticp                         (tree);\n \n /* in cp-gimplify.c */\n-extern int cp_gimplify_expr\t\t\t(tree *, tree *, tree *);\n+extern int cp_gimplify_expr\t\t\t(tree *, gimple_seq *,\n+\t\t\t\t\t\t gimple_seq *);\n extern void cp_genericize\t\t\t(tree);\n \n /* -- end of C++ */"}, {"sha": "630faacb354e2bbf4c0bb44e40dde7afb3eb066d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -12038,7 +12038,7 @@ finish_function (int flags)\n       f->extern_decl_map = NULL;\n \n       /* Handle attribute((warn_unused_result)).  Relies on gimple input.  */\n-      c_warn_unused_result (&DECL_SAVED_TREE (fndecl));\n+      c_warn_unused_result (gimple_body (fndecl));\n     }\n   /* Clear out the bits we don't need.  */\n   local_names = NULL;"}, {"sha": "20b0826faf26394f63260426de156464180243f5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-pragma.h\"\n #include \"tree-dump.h\"\n #include \"intl.h\"\n+#include \"gimple.h\"\n \n extern cpp_reader *parse_in;\n \n@@ -3439,7 +3440,7 @@ cp_write_global_declarations (void)\n \t      reconsider = true;\n \t    }\n \n-\t  if (!DECL_SAVED_TREE (decl))\n+\t  if (!gimple_body (decl))\n \t    continue;\n \n \t  /* We lie to the back end, pretending that some functions"}, {"sha": "56a551212fe42dd52a6789747d42300e1bb854df", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-iterator.h\"\n #include \"target.h\"\n+#include \"gimple.h\"\n \n static void push_eh_cleanup (tree);\n static tree prepare_eh_type (tree);\n@@ -53,7 +54,7 @@ static tree wrap_cleanups_r (tree *, int *, void *);\n static int complete_ptr_ref_or_void_ptr_p (tree, tree);\n static bool is_admissible_throw_operand (tree);\n static int can_convert_eh (tree, tree);\n-static tree cp_protect_cleanup_actions (void);\n+static gimple cp_protect_cleanup_actions (void);\n \n /* Sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.  */\n@@ -92,14 +93,14 @@ init_exception_processing (void)\n /* Returns an expression to be executed if an unhandled exception is\n    propagated out of a cleanup region.  */\n \n-static tree\n+static gimple\n cp_protect_cleanup_actions (void)\n {\n   /* [except.terminate]\n \n      When the destruction of an object during stack unwinding exits\n      using an exception ... void terminate(); is called.  */\n-  return build_call_n (terminate_node, 0);\n+  return gimple_build_call (terminate_node, 0);\n }\n \n static tree"}, {"sha": "3deb85d432bcbe6da372afead2aaf6f63aec6d0d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -3275,6 +3275,7 @@ build_vec_delete (tree base, tree maxindex,\n     {\n       /* Step back one from start of vector, and read dimension.  */\n       tree cookie_addr;\n+      tree size_ptr_type = build_pointer_type (sizetype);\n \n       if (TREE_SIDE_EFFECTS (base))\n \t{\n@@ -3284,8 +3285,8 @@ build_vec_delete (tree base, tree maxindex,\n       type = strip_array_types (TREE_TYPE (type));\n       cookie_addr = fold_build1 (NEGATE_EXPR, sizetype, TYPE_SIZE_UNIT (sizetype));\n       cookie_addr = build2 (POINTER_PLUS_EXPR,\n-\t\t\t    build_pointer_type (sizetype),\n-\t\t\t    base,\n+\t\t\t    size_ptr_type,\n+\t\t\t    fold_convert (size_ptr_type, base),\n \t\t\t    cookie_addr);\n       maxindex = cp_build_indirect_ref (cookie_addr, NULL, tf_warning_or_error);\n     }"}, {"sha": "ed43b435831b98dcaa47b2b45d281160c5827c57", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,5 +1,5 @@\n /* Perform optimizations on tree structure.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Written by Mark Michell (mark@codesourcery.com).\n \n@@ -40,7 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"diagnostic.h\"\n #include \"tree-dump.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n \n /* Prototypes.  */\n \n@@ -72,35 +72,40 @@ update_cloned_parm (tree parm, tree cloned_parm, bool first)\n   DECL_GIMPLE_REG_P (cloned_parm) = DECL_GIMPLE_REG_P (parm);\n }\n \n-/* FN is a function that has a complete body, and CLONE is a function whose\n-   body is to be set to a copy of FN, mapping argument declarations according\n-   to the ARG_MAP splay_tree.  */\n+\n+/* FN is a function in High GIMPLE form that has a complete body and no\n+   CFG.  CLONE is a function whose body is to be set to a copy of FN,\n+   mapping argument declarations according to the ARG_MAP splay_tree.  */\n \n static void\n clone_body (tree clone, tree fn, void *arg_map)\n {\n   copy_body_data id;\n+  gimple_seq new_body;\n+\n+  /* FN must already be in GIMPLE form.  */\n+  gcc_assert (gimple_body (fn));\n \n-  /* Clone the body, as if we were making an inline call.  But, remap the\n-     parameters in the callee to the parameters of caller.  */\n+  /* Clone the body, as if we were making an inline call.  But, remap\n+     the parameters in the callee to the parameters of caller.  */\n   memset (&id, 0, sizeof (id));\n   id.src_fn = fn;\n   id.dst_fn = clone;\n   id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n-  id.decl_map = (struct pointer_map_t *)arg_map;\n+  id.decl_map = (struct pointer_map_t *) arg_map;\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n   id.transform_new_cfg = true;\n   id.transform_return_to_modify = false;\n-  id.transform_lang_insert_block = insert_block;\n+  id.transform_lang_insert_block = NULL;\n \n   /* We're not inside any EH region.  */\n   id.eh_region = -1;\n \n   /* Actually copy the body.  */\n-  append_to_statement_list_force (copy_generic_body (&id),\n-\t\t\t\t  &DECL_SAVED_TREE (clone));\n+  new_body = remap_gimple_seq (gimple_body (fn), &id);\n+  gimple_set_body (clone, new_body);\n }\n \n /* FN is a function that has a complete body.  Clone the body as\n@@ -228,6 +233,7 @@ maybe_clone_body (tree fn)\n       /* Now, expand this function into RTL, if appropriate.  */\n       finish_function (0);\n       BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);\n+      DECL_SAVED_TREE (clone) = NULL;\n       expand_or_defer_fn (clone);\n       first = false;\n     }"}, {"sha": "5ada42241fbd44598c41ed49dffa766b6b03b4a4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"vec.h\"\n #include \"target.h\"\n+#include \"gimple.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -3201,6 +3202,8 @@ expand_or_defer_fn (tree fn)\n       return;\n     }\n \n+  gcc_assert (gimple_body (fn));\n+\n   /* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */\n   cp_walk_tree_without_duplicates (&DECL_SAVED_TREE (fn),\n \t\t\t\t   simplify_aggr_init_exprs_r,"}, {"sha": "8906cc48ca057dc4eb7ec56eb4420447ef8afe3a", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -215,14 +215,24 @@ extern char *diagnostic_build_prefix (diagnostic_info *);\n extern char *file_name_as_prefix (const char *);\n \n /* In tree-pretty-print.c  */\n+extern void print_declaration (pretty_printer *, tree, int, int);\n extern int dump_generic_node (pretty_printer *, tree, int, int, bool);\n extern void print_generic_stmt (FILE *, tree, int);\n extern void print_generic_stmt_indented (FILE *, tree, int, int);\n extern void print_generic_expr (FILE *, tree, int);\n extern void print_generic_decl (FILE *, tree, int);\n+extern void debug_c_tree (tree);\n+extern void dump_omp_clauses (pretty_printer *, tree, int, int);\n \n+/* In gimple-pretty-print.c  */\n extern void debug_generic_expr (tree);\n extern void debug_generic_stmt (tree);\n extern void debug_tree_chain (tree);\n-extern void debug_c_tree (tree);\n+extern void debug_gimple_stmt (gimple);\n+extern void debug_gimple_seq (gimple_seq);\n+extern void print_gimple_seq (FILE *, gimple_seq, int, int);\n+extern void print_gimple_stmt (FILE *, gimple, int, int);\n+extern void print_gimple_expr (FILE *, gimple, int, int);\n+extern void dump_gimple_stmt (pretty_printer *, gimple, int, int);\n+\n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "8f779225432c7f89b9385583b02c7c69a96bd179", "filename": "gcc/domwalk.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -144,7 +144,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n {\n   void *bd = NULL;\n   basic_block dest;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   bool is_interesting;\n   basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n   int sp = 0;\n@@ -168,8 +168,8 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t    {\n \t      bool recycled;\n \n-\t      /* First get some local data, reusing any local data pointer we may\n-\t         have saved.  */\n+\t      /* First get some local data, reusing any local data\n+\t\t pointer we may have saved.  */\n \t      if (VEC_length (void_p, walk_data->free_block_data) > 0)\n \t\t{\n \t\t  bd = VEC_pop (void_p, walk_data->free_block_data);\n@@ -199,13 +199,14 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  if (is_interesting && walk_data->before_dom_children_walk_stmts)\n \t    {\n \t      if (walk_data->walk_stmts_backward)\n-\t\tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+\t\tfor (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi);\n+\t\t     gsi_prev (&gsi))\n \t\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t\tbsi);\n+\t\t\t\t\t\t\t\tgsi);\n \t      else\n-\t\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t\tbsi);\n+\t\t\t\t\t\t\t\tgsi);\n \t    }\n \n \t  /* Callback for operations to execute before we have walked the\n@@ -239,13 +240,14 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  if (is_interesting && walk_data->after_dom_children_walk_stmts)\n \t    {\n \t      if (walk_data->walk_stmts_backward)\n-\t\tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+\t\tfor (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi);\n+\t\t     gsi_prev (&gsi))\n \t\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t       bsi);\n+\t\t\t\t\t\t\t       gsi);\n \t      else\n-\t\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t       bsi);\n+\t\t\t\t\t\t\t       gsi);\n \t    }\n \n \t  /* Callback for operations to execute after we have walked the"}, {"sha": "61117ef7d45be2e5c6a6d86e8617543929a8bcf9", "filename": "gcc/domwalk.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -66,7 +66,7 @@ struct dom_walk_data\n   /* Function to call to walk statements before the recursive walk\n      of the dominator children.  */\n   void (*before_dom_children_walk_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t  basic_block, block_stmt_iterator);\n+\t\t\t\t\t  basic_block, gimple_stmt_iterator);\n \n   /* Function to call after the statement walk occurring before the\n      recursive walk of the dominator children.  */\n@@ -81,7 +81,7 @@ struct dom_walk_data\n   /* Function to call to walk statements after the recursive walk\n      of the dominator children.  */\n   void (*after_dom_children_walk_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t basic_block, block_stmt_iterator);\n+\t\t\t\t\t basic_block, gimple_stmt_iterator);\n \n   /* Function to call after the statement walk occurring after the\n      recursive walk of the dominator children. "}, {"sha": "a8e06efb22d77886fc0d0c303fd08630305233bf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -9636,9 +9636,8 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n-    case GIMPLE_MODIFY_STMT:\n-      return loc_descriptor_from_tree_1 (GENERIC_TREE_OPERAND (loc, 0),\n-\t\t\t\t\t want_address);\n+    case MODIFY_EXPR:\n+      return loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), want_address);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -10442,7 +10441,7 @@ static tree\n reference_to_unused (tree * tp, int * walk_subtrees,\n \t\t     void * data ATTRIBUTE_UNUSED)\n {\n-  if (! EXPR_P (*tp) && ! GIMPLE_STMT_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n+  if (! EXPR_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n     *walk_subtrees = 0;\n \n   if (DECL_P (*tp) && ! TREE_PUBLIC (*tp) && ! TREE_USED (*tp)"}, {"sha": "2916e44b223b979592dda5c74195964ffdd82894", "filename": "gcc/ebitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Febitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Febitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -121,7 +121,7 @@ ebitmap_iter_init (ebitmap_iterator *i, ebitmap bmp, unsigned int min)\n static inline bool\n ebitmap_iter_cond (ebitmap_iterator *i, unsigned int *n)\n {\n-  unsigned int ourn;\n+  unsigned int ourn = 0;\n \n   if (i->size == 0)\n     return false;"}, {"sha": "962dd0b8b6429a498efdf7e3167beaa00e238100", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -86,7 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Protect cleanup actions with must-not-throw regions, with a call\n    to the given failure handler.  */\n-tree (*lang_protect_cleanup_actions) (void);\n+gimple (*lang_protect_cleanup_actions) (void);\n \n /* Return true if type A catches type B.  */\n int (*lang_eh_type_covers) (tree a, tree b);"}, {"sha": "8f9efb263829058bcbf953b14554ba06171c35f0", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -108,20 +108,13 @@ extern void dump_eh_tree (FILE *, struct function *);\n extern bool eh_region_outer_p (struct function *, int, int);\n extern int eh_region_outermost (struct function *, int, int);\n \n-/* tree-eh.c */\n-extern void add_stmt_to_eh_region_fn (struct function *, tree, int);\n-extern bool remove_stmt_from_eh_region_fn (struct function *, tree);\n-extern int lookup_stmt_eh_region_fn (struct function *, const_tree);\n-extern int lookup_stmt_eh_region (const_tree);\n-extern bool verify_eh_edges (tree);\n-\n /* If non-NULL, this is a function that returns an expression to be\n    executed if an unhandled exception is propagated out of a cleanup\n    region.  For example, in C++, an exception thrown by a destructor\n    during stack unwinding is required to result in a call to\n    `std::terminate', so the C++ version of this function returns a\n    CALL_EXPR for `std::terminate'.  */\n-extern tree (*lang_protect_cleanup_actions) (void);\n+extern gimple (*lang_protect_cleanup_actions) (void);\n \n /* Return true if type A catches type B.  */\n extern int (*lang_eh_type_covers) (tree a, tree b);\n@@ -175,7 +168,7 @@ extern tree (*lang_eh_runtime_type) (tree);\n \n struct throw_stmt_node GTY(())\n {\n-  tree stmt;\n+  gimple stmt;\n   int region_nr;\n };\n "}, {"sha": "4984780fe325d9f3bafcf78120c69eb3ff11316b", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 39, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -6539,9 +6539,6 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n     case tcc_type:\n       /* Should never get a type here.  */\n       gcc_unreachable ();\n-\n-    case tcc_gimple_stmt:\n-      gcc_unreachable ();\n     }\n \n   /* If we have an rtl, find any enclosed object.  Then see if we conflict\n@@ -7048,16 +7045,16 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \n   /* Handle ERROR_MARK before anybody tries to access its type.  */\n   if (TREE_CODE (exp) == ERROR_MARK\n-      || TREE_CODE (exp) == PREDICT_EXPR\n-      || (!GIMPLE_TUPLE_P (exp) && TREE_CODE (TREE_TYPE (exp)) == ERROR_MARK))\n+      || (TREE_CODE (TREE_TYPE (exp)) == ERROR_MARK))\n     {\n       ret = CONST0_RTX (tmode);\n       return ret ? ret : const0_rtx;\n     }\n \n   if (flag_non_call_exceptions)\n     {\n-      rn = lookup_stmt_eh_region (exp);\n+      rn = lookup_expr_eh_region (exp);\n+\n       /* If rn < 0, then either (1) tree-ssa not used or (2) doesn't throw.  */\n       if (rn >= 0)\n \tlast = get_last_insn ();\n@@ -7131,18 +7128,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t\t\t  type)\t  \\\n \t\t\t\t : (expr))\n \n-  if (GIMPLE_STMT_P (exp))\n-    {\n-      type = void_type_node;\n-      mode = VOIDmode;\n-      unsignedp = 0;\n-    }\n-  else\n-    {\n-      type = TREE_TYPE (exp);\n-      mode = TYPE_MODE (type);\n-      unsignedp = TYPE_UNSIGNED (type);\n-    }\n+  type = TREE_TYPE (exp);\n+  mode = TYPE_MODE (type);\n+  unsignedp = TYPE_UNSIGNED (type);\n \n   ignore = (target == const0_rtx\n \t    || ((code == NOP_EXPR || code == CONVERT_EXPR \n@@ -9089,16 +9077,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \ttree lhs = TREE_OPERAND (exp, 0);\n \ttree rhs = TREE_OPERAND (exp, 1);\n-\tgcc_assert (ignore);\n-\texpand_assignment (lhs, rhs, false);\n-\treturn const0_rtx;\n-      }\n-\n-    case GIMPLE_MODIFY_STMT:\n-      {\n-\ttree lhs = GIMPLE_STMT_OPERAND (exp, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (exp, 1);\n-\n \tgcc_assert (ignore);\n \n \t/* Check for |= or &= of a bitfield of size one into another bitfield\n@@ -9358,17 +9336,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n-      {\n-\tmode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\tgoto binop;\n-      }\n-\n-    case OMP_ATOMIC_LOAD:\n-    case OMP_ATOMIC_STORE:\n-      /* OMP expansion is not run when there were errors, so these codes\n-\t\t  can get here.  */\n-      gcc_assert (errorcount != 0);\n-      return NULL_RTX;\n+      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+      goto binop;\n \n     default:\n       return lang_hooks.expand_expr (exp, original_target, tmode,"}, {"sha": "f8085dc37092ded72968b7d09daff1ec81ca086b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n #include \"md5.h\"\n+#include \"gimple.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n@@ -949,7 +950,7 @@ fold_defer_overflow_warnings (void)\n    deferred code.  */\n \n void\n-fold_undefer_overflow_warnings (bool issue, const_tree stmt, int code)\n+fold_undefer_overflow_warnings (bool issue, const_gimple stmt, int code)\n {\n   const char *warnmsg;\n   location_t locus;\n@@ -971,7 +972,7 @@ fold_undefer_overflow_warnings (bool issue, const_tree stmt, int code)\n   if (!issue || warnmsg == NULL)\n     return;\n \n-  if (stmt != NULL_TREE && TREE_NO_WARNING (stmt))\n+  if (gimple_no_warning_p (stmt))\n     return;\n \n   /* Use the smallest code level when deciding to issue the\n@@ -982,10 +983,10 @@ fold_undefer_overflow_warnings (bool issue, const_tree stmt, int code)\n   if (!issue_strict_overflow_warning (code))\n     return;\n \n-  if (stmt == NULL_TREE || !expr_has_location (stmt))\n+  if (stmt == NULL)\n     locus = input_location;\n   else\n-    locus = expr_location (stmt);\n+    locus = gimple_location (stmt);\n   warning (OPT_Wstrict_overflow, \"%H%s\", &locus, warnmsg);\n }\n \n@@ -995,7 +996,7 @@ fold_undefer_overflow_warnings (bool issue, const_tree stmt, int code)\n void\n fold_undefer_and_ignore_overflow_warnings (void)\n {\n-  fold_undefer_overflow_warnings (false, NULL_TREE, 0);\n+  fold_undefer_overflow_warnings (false, NULL, 0);\n }\n \n /* Whether we are deferring overflow warnings.  */\n@@ -2639,7 +2640,7 @@ fold_convert (tree type, tree arg)\n \n     case VOID_TYPE:\n       tem = fold_ignored_result (arg);\n-      if (TREE_CODE (tem) == GIMPLE_MODIFY_STMT)\n+      if (TREE_CODE (tem) == MODIFY_EXPR)\n \treturn tem;\n       return fold_build1 (NOP_EXPR, type, tem);\n \n@@ -2682,7 +2683,6 @@ maybe_lvalue_p (const_tree x)\n   case WITH_CLEANUP_EXPR:\n   case COMPOUND_EXPR:\n   case MODIFY_EXPR:\n-  case GIMPLE_MODIFY_STMT:\n   case TARGET_EXPR:\n   case COND_EXPR:\n   case BIND_EXPR:\n@@ -7847,17 +7847,16 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t    return fold_convert (type, fold_addr_expr (base));\n         }\n \n-      if ((TREE_CODE (op0) == MODIFY_EXPR\n-\t   || TREE_CODE (op0) == GIMPLE_MODIFY_STMT)\n-\t  && TREE_CONSTANT (GENERIC_TREE_OPERAND (op0, 1))\n+      if (TREE_CODE (op0) == MODIFY_EXPR\n+\t  && TREE_CONSTANT (TREE_OPERAND (op0, 1))\n \t  /* Detect assigning a bitfield.  */\n-\t  && !(TREE_CODE (GENERIC_TREE_OPERAND (op0, 0)) == COMPONENT_REF\n+\t  && !(TREE_CODE (TREE_OPERAND (op0, 0)) == COMPONENT_REF\n \t       && DECL_BIT_FIELD\n-\t       (TREE_OPERAND (GENERIC_TREE_OPERAND (op0, 0), 1))))\n+\t       (TREE_OPERAND (TREE_OPERAND (op0, 0), 1))))\n \t{\n \t  /* Don't leave an assignment inside a conversion\n \t     unless assigning a bitfield.  */\n-\t  tem = fold_build1 (code, type, GENERIC_TREE_OPERAND (op0, 1));\n+\t  tem = fold_build1 (code, type, TREE_OPERAND (op0, 1));\n \t  /* First do the assignment, then return converted constant.  */\n \t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), op0, tem);\n \t  TREE_NO_WARNING (tem) = 1;\n@@ -9249,8 +9248,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n   tree t1 = NULL_TREE;\n   bool strict_overflow_p;\n \n-  gcc_assert ((IS_EXPR_CODE_CLASS (kind)\n-\t       || IS_GIMPLE_STMT_CODE_CLASS (kind))\n+  gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 2\n \t      && op0 != NULL_TREE\n \t      && op1 != NULL_TREE);\n@@ -13169,8 +13167,7 @@ fold (tree expr)\n       return expr;\n     }\n \n-  if (IS_EXPR_CODE_CLASS (kind)\n-      || IS_GIMPLE_STMT_CODE_CLASS (kind))\n+  if (IS_EXPR_CODE_CLASS (kind))\n     {\n       tree type = TREE_TYPE (t);\n       tree op0, op1, op2;\n@@ -14110,7 +14107,7 @@ tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n    *STRICT_OVERFLOW_P.  */\n \n bool\n-tree_call_nonnegative_warnv_p (enum tree_code code,  tree type, tree fndecl,\n+tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n \t\t\t       tree arg0, tree arg1, bool *strict_overflow_p)\n {\n   if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n@@ -14231,7 +14228,7 @@ tree_call_nonnegative_warnv_p (enum tree_code code,  tree type, tree fndecl,\n       default:\n \tbreak;\n       }\n-  return tree_simple_nonnegative_warnv_p (code,\n+  return tree_simple_nonnegative_warnv_p (CALL_EXPR,\n \t\t\t\t\t  type);\n }\n \n@@ -14273,10 +14270,9 @@ tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t    else\n \t      break;\n \t  }\n-\tif ((TREE_CODE (t) == MODIFY_EXPR\n-\t     || TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n-\t    && GENERIC_TREE_OPERAND (t, 0) == temp)\n-\t  return tree_expr_nonnegative_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+\tif (TREE_CODE (t) == MODIFY_EXPR\n+\t    && TREE_OPERAND (t, 0) == temp)\n+\t  return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n \t\t\t\t\t\tstrict_overflow_p);\n \n \treturn false;\n@@ -14287,17 +14283,15 @@ tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \ttree arg0 = call_expr_nargs (t) > 0 ?  CALL_EXPR_ARG (t, 0) : NULL_TREE;\n \ttree arg1 = call_expr_nargs (t) > 1 ?  CALL_EXPR_ARG (t, 1) : NULL_TREE;\n \n-\treturn tree_call_nonnegative_warnv_p (TREE_CODE (t),\n-\t\t\t\t\t      TREE_TYPE (t),\n+\treturn tree_call_nonnegative_warnv_p (TREE_TYPE (t),\n \t\t\t\t\t      get_callee_fndecl (t),\n \t\t\t\t\t      arg0,\n \t\t\t\t\t      arg1,\n \t\t\t\t\t      strict_overflow_p);\n       }\n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n-    case GIMPLE_MODIFY_STMT:\n-      return tree_expr_nonnegative_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n \t\t\t\t\t    strict_overflow_p);\n     case BIND_EXPR:\n       return tree_expr_nonnegative_warnv_p (expr_last (TREE_OPERAND (t, 1)),\n@@ -14672,9 +14666,8 @@ tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n-    case GIMPLE_MODIFY_STMT:\n     case BIND_EXPR:\n-      return tree_expr_nonzero_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n \t\t\t\t\tstrict_overflow_p);\n \n     case SAVE_EXPR:"}, {"sha": "cfcfa12530a2f205a0feef1a8857886b793fb552", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,3 +1,92 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t2008-07-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans-expr.c: Include gimple.h instead of tree-gimple.h.\n+\t* trans-array.c: Same.\n+\t* trans-openmp.c: Same.\n+\t* trans-stmt.c: Same.\n+\t* f95-lang.c: Same.\n+\t* trans-io.c: Same.\n+\t* trans-decl.c: Same.\n+\t* trans-intrinsic.c: Same.\n+\t* trans.c: Same.  Include tree-iterator.h.\n+\t* Make-lang.in (trans.o): Depend on tree-iterator.h\n+\n+\t2008-07-14  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans-array.h (gfc_conv_descriptor_data_set_internal):\n+\tRename to gfc_conv_descriptor_data_set.\n+\t(gfc_conv_descriptor_data_set_tuples): Remove.\n+\t* trans-array.c (gfc_conv_descriptor_data_get): Rename\n+\tfrom gfc_conv_descriptor_data_set_internal.\n+\tRemove last argument to gfc_add_modify.\n+\t(gfc_trans_allocate_array_storage): Rename gfc_add_modify_expr to\n+\tgfc_add_modify.\n+\t(gfc_trans_create_temp_array): Same.\n+\t(gfc_conv_array_transpose): Same.\n+\t(gfc_grow_array): Same.\n+\t(gfc_put_offset_into_var): Same.\n+\t(gfc_trans_array_ctor_element): Same.\n+\t(gfc_trans_array_constructor_subarray): Same.\n+\t(gfc_trans_array_constructor_value): Same.\n+\t(gfc_trans_scalarized_loop_end): Same.\n+\t(gfc_array_init_size): Same.\n+\t(gfc_array_allocate): Same.\n+\t(gfc_trans_array_bounds): Same.\n+\t(gfc_trans_auto_array_allocation): Same.\n+\t(gfc_trans_g77_array): Same.\n+\t(gfc_trans_dummy_array_bias): Same.\n+\t(gfc_conv_expr_descriptor): Same.\n+\t(structure_alloc_comps): Same.\n+\t* trans-expr.c: Same.\n+\t* trans-openmp.c (gfc_omp_clause_default_ctor): Same.\n+\tRename gfc_conv_descriptor_data_set_tuples to\n+\tgfc_conv_descriptor_data_set.\n+\t(gfc_omp_clause_copy_ctor): Change build_gimple_modify_stmt to\n+\tbuild2_v.\n+\t(gfc_omp_clause_assign_op): Same.\n+\t(gfc_trans_omp_array_reduction): Rename gfc_add_modify_expr to\n+\tgfc_add_modify.\n+\t(gfc_trans_omp_atomic): Same.\n+\t(gfc_trans_omp_do): Same.  Change GIMPLE_MODIFY_STMT to MODIFY_EXPR.\n+\tRename gfc_add_modify_stmt to gfc_add_modify.\n+\t* trans-stmt.c: Rename gfc_add_modify_expr to\n+\tgfc_add_modify.\n+\t* trans.c: Rename gfc_add_modify_expr to\n+\tgfc_add_modify.\n+\t(gfc_add_modify): Remove last argument.\n+\tRename GIMPLE_MODIFY_STMT to MODIFY_EXPR.\n+\t* trans.h: Remove gfc_add_modify_expr, gfc_add_modify_stmt.\n+\tAdd prototype for gfc_add_modify.\n+\t* f95-lang.c (union lang_tree_node): Rename GENERIC_NEXT to TREE_CHAIN.\n+\t* trans-decl.c: Rename gfc_add_modify_stmt to gfc_add_modify.\n+\t* trans-io.c: Same.\n+\t* trans-intrinsic.c: Same.\n+\n+\t2008-02-25  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Make-lang.in (fortran-warn): Add -Wno-format.\n+\n+\t2008-02-19  Diego Novillo  <dnovillo@google.com>\n+\n+\thttp://gcc.gnu.org/ml/gcc-patches/2008-02/msg00804.html\n+\n+\t* fortran/Make-lang.in (fortran-warn): Remove.\n+\n+\t2007-11-22  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans-expr.c (gfc_trans_string_copy): Use \"void *\" when building a\n+\tmemset.\n+\n+\t2007-11-10  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Make-lang.in (fortran-warn): Set to -Wno-format.\n+\t* trans.c (gfc_trans_code): Update comment to say GENERIC.\n+\tCall tree_annotate_all_with_locus instead of annotate_all_with_locus.\n+\n 2008-07-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36132"}, {"sha": "77ddb6ae5e0aa633e8c62873c02e46b62dcca071", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -47,6 +47,7 @@ GFORTRAN_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gfortran|sed\n \n # Use strict warnings for this front end.\n fortran-warn = $(STRICT_WARN)\n+fortran-warn += -Wno-format -Wno-missing-format-attribute -Wno-uninitialized # FIXME tuples: Do not merge.\n \n # These are the groups of object files we have.  The F95_PARSER_OBJS are\n # all the front end files, the F95_OBJS are the files for the translation\n@@ -311,9 +312,9 @@ fortran/f95-lang.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n   $(BUILTINS_DEF) fortran/types.def\n fortran/scanner.o: toplev.h fortran/cpp.h\n fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n-fortran/trans.o: $(GFORTRAN_TRANS_DEPS)\n+fortran/trans.o: $(GFORTRAN_TRANS_DEPS) tree-iterator.h\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n-  $(CGRAPH_H) $(TARGET_H) $(FUNCTION_H) $(FLAGS_H) $(RTL_H) $(TREE_GIMPLE_H) \\\n+  $(CGRAPH_H) $(TARGET_H) $(FUNCTION_H) $(FLAGS_H) $(RTL_H) $(GIMPLE_H) \\\n   $(TREE_DUMP_H)\n fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n   $(REAL_H) toplev.h $(TARGET_H) $(FLAGS_H) dwarf2out.h"}, {"sha": "d2768b112dde0266ddedc7629d58a57d47fc75c6", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"flags.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n@@ -62,7 +62,7 @@ GTY(())\n \n union lang_tree_node\n GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-     chain_next (\"(union lang_tree_node *)GENERIC_NEXT (&%h.generic)\")))\n+     chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n \n {\n   union tree_node GTY((tag (\"0\"),"}, {"sha": "fe6b63de90ba0ca66f11c98e76213ae65eb6e8f2", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -80,7 +80,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n@@ -161,12 +161,10 @@ gfc_conv_descriptor_data_get (tree desc)\n    \n    This function gets called through the following macros:\n      gfc_conv_descriptor_data_set\n-     gfc_conv_descriptor_data_set_tuples.  */\n+     gfc_conv_descriptor_data_set.  */\n \n void\n-gfc_conv_descriptor_data_set_internal (stmtblock_t *block,\n-\t\t\t\t       tree desc, tree value,\n-\t\t\t\t       bool tuples_p)\n+gfc_conv_descriptor_data_set (stmtblock_t *block, tree desc, tree value)\n {\n   tree field, type, t;\n \n@@ -177,7 +175,7 @@ gfc_conv_descriptor_data_set_internal (stmtblock_t *block,\n   gcc_assert (DATA_FIELD == 0);\n \n   t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n-  gfc_add_modify (block, t, fold_convert (TREE_TYPE (field), value), tuples_p);\n+  gfc_add_modify (block, t, fold_convert (TREE_TYPE (field), value));\n }\n \n \n@@ -547,7 +545,7 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n   /* The offset is zero because we create temporaries with a zero\n      lower bound.  */\n   tmp = gfc_conv_descriptor_offset (desc);\n-  gfc_add_modify_expr (pre, tmp, gfc_index_zero_node);\n+  gfc_add_modify (pre, tmp, gfc_index_zero_node);\n \n   if (dealloc && !onstack)\n     {\n@@ -627,7 +625,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   /* Fill in the array dtype.  */\n   tmp = gfc_conv_descriptor_dtype (desc);\n-  gfc_add_modify_expr (pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+  gfc_add_modify (pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n \n   /*\n      Fill in the bounds and stride.  This is a packed array, so:\n@@ -661,13 +659,13 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n         \n       /* Store the stride and bound components in the descriptor.  */\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (pre, tmp, size);\n+      gfc_add_modify (pre, tmp, size);\n \n       tmp = gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (pre, tmp, gfc_index_zero_node);\n+      gfc_add_modify (pre, tmp, gfc_index_zero_node);\n \n       tmp = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (pre, tmp, loop->to[n]);\n+      gfc_add_modify (pre, tmp, loop->to[n]);\n \n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t loop->to[n], gfc_index_one_node);\n@@ -752,7 +750,7 @@ gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n   se->expr = dest;\n \n   /* Copy across the dtype field.  */\n-  gfc_add_modify_expr (&se->pre,\n+  gfc_add_modify (&se->pre,\n \t\t       gfc_conv_descriptor_dtype (dest),\n \t\t       gfc_conv_descriptor_dtype (src));\n \n@@ -769,15 +767,15 @@ gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n       dest_index = gfc_rank_cst[n];\n       src_index = gfc_rank_cst[1 - n];\n \n-      gfc_add_modify_expr (&se->pre,\n+      gfc_add_modify (&se->pre,\n \t\t\t   gfc_conv_descriptor_stride (dest, dest_index),\n \t\t\t   gfc_conv_descriptor_stride (src, src_index));\n \n-      gfc_add_modify_expr (&se->pre,\n+      gfc_add_modify (&se->pre,\n \t\t\t   gfc_conv_descriptor_lbound (dest, dest_index),\n \t\t\t   gfc_conv_descriptor_lbound (src, src_index));\n \n-      gfc_add_modify_expr (&se->pre,\n+      gfc_add_modify (&se->pre,\n \t\t\t   gfc_conv_descriptor_ubound (dest, dest_index),\n \t\t\t   gfc_conv_descriptor_ubound (src, src_index));\n \n@@ -803,7 +801,7 @@ gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n   else\n     dest_info->offset = gfc_index_zero_node;\n \n-  gfc_add_modify_expr (&se->pre,\n+  gfc_add_modify (&se->pre,\n \t\t       gfc_conv_descriptor_offset (dest),\n \t\t       dest_info->offset);\n \t  \n@@ -847,7 +845,7 @@ gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n \n   /* Add EXTRA to the upper bound.  */\n   tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, extra);\n-  gfc_add_modify_expr (pblock, ubound, tmp);\n+  gfc_add_modify (pblock, ubound, tmp);\n \n   /* Get the value of the current data pointer.  */\n   arg0 = gfc_conv_descriptor_data_get (desc);\n@@ -957,7 +955,7 @@ gfc_put_offset_into_var (stmtblock_t * pblock, tree * poffset,\n   /* We should have already created the offset variable.  We cannot\n      create it here because we may be in an inner scope.  */\n   gcc_assert (*offsetvar != NULL_TREE);\n-  gfc_add_modify_expr (pblock, *offsetvar, *poffset);\n+  gfc_add_modify (pblock, *offsetvar, *poffset);\n   *poffset = *offsetvar;\n   TREE_USED (*offsetvar) = 1;\n }\n@@ -996,7 +994,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t{\n \t  /* The temporary is an array of pointers.  */\n \t  se->expr = fold_convert (TREE_TYPE (tmp), se->expr);\n-\t  gfc_add_modify_expr (&se->pre, tmp, se->expr);\n+\t  gfc_add_modify (&se->pre, tmp, se->expr);\n \t}\n       else\n \t{\n@@ -1011,7 +1009,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t{\n \t  if (first_len)\n \t    {\n-\t      gfc_add_modify_expr (&se->pre, first_len_val,\n+\t      gfc_add_modify (&se->pre, first_len_val,\n \t\t\t\t   se->string_length);\n \t      first_len = false;\n \t    }\n@@ -1033,7 +1031,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n     {\n       /* TODO: Should the frontend already have done this conversion?  */\n       se->expr = fold_convert (TREE_TYPE (tmp), se->expr);\n-      gfc_add_modify_expr (&se->pre, tmp, se->expr);\n+      gfc_add_modify (&se->pre, tmp, se->expr);\n     }\n \n   gfc_add_block_to_block (pblock, &se->pre);\n@@ -1104,7 +1102,7 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   /* Increment the offset.  */\n   tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t     *poffset, gfc_index_one_node);\n-  gfc_add_modify_expr (&body, *poffset, tmp);\n+  gfc_add_modify (&body, *poffset, tmp);\n \n   /* Finish the loop.  */\n   gfc_trans_scalarizing_loops (&loop, &body);\n@@ -1243,7 +1241,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t    }\n \t  if (!INTEGER_CST_P (*poffset))\n             {\n-              gfc_add_modify_expr (&body, *offsetvar, *poffset);\n+              gfc_add_modify (&body, *offsetvar, *poffset);\n               *poffset = *offsetvar;\n             }\n \t}\n@@ -1289,13 +1287,13 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  /* Make a temporary, store the current value in that\n \t     and return it, once the loop is done.  */\n \t  tmp_loopvar = gfc_create_var (TREE_TYPE (loopvar), \"loopvar\");\n-\t  gfc_add_modify_expr (pblock, tmp_loopvar, loopvar);\n+\t  gfc_add_modify (pblock, tmp_loopvar, loopvar);\n \n \t  /* Initialize the loop.  */\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_val (&se, c->iterator->start);\n \t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  gfc_add_modify_expr (pblock, loopvar, se.expr);\n+\t  gfc_add_modify (pblock, loopvar, se.expr);\n \n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_val (&se, c->iterator->end);\n@@ -1348,7 +1346,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \n \t  /* Increase loop variable by step.  */\n \t  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (loopvar), loopvar, step);\n-\t  gfc_add_modify_expr (&body, loopvar, tmp);\n+\t  gfc_add_modify (&body, loopvar, tmp);\n \n \t  /* Finish the loop.  */\n \t  tmp = gfc_finish_block (&body);\n@@ -1360,7 +1358,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_add_expr_to_block (pblock, tmp);\n \n \t  /* Restore the original value of the loop counter.  */\n-\t  gfc_add_modify_expr (pblock, loopvar, tmp_loopvar);\n+\t  gfc_add_modify (pblock, loopvar, tmp_loopvar);\n \t}\n     }\n   mpz_clear (size);\n@@ -2640,7 +2638,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n   loopbody = gfc_finish_block (pbody);\n \n   /* Initialize the loopvar.  */\n-  gfc_add_modify_expr (&loop->code[n], loop->loopvar[n], loop->from[n]);\n+  gfc_add_modify (&loop->code[n], loop->loopvar[n], loop->from[n]);\n \n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n@@ -2661,7 +2659,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n   /* Increment the loopvar.  */\n   tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t     loop->loopvar[n], gfc_index_one_node);\n-  gfc_add_modify_expr (&block, loop->loopvar[n], tmp);\n+  gfc_add_modify (&block, loop->loopvar[n], tmp);\n \n   /* Build the loop.  */\n   tmp = gfc_finish_block (&block);\n@@ -3621,7 +3619,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n \n   /* Set the dtype.  */\n   tmp = gfc_conv_descriptor_dtype (descriptor);\n-  gfc_add_modify_expr (pblock, tmp, gfc_get_dtype (TREE_TYPE (descriptor)));\n+  gfc_add_modify (pblock, tmp, gfc_get_dtype (TREE_TYPE (descriptor)));\n \n   or_expr = NULL_TREE;\n \n@@ -3652,7 +3650,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n             }\n \t}\n       tmp = gfc_conv_descriptor_lbound (descriptor, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (pblock, tmp, se.expr);\n+      gfc_add_modify (pblock, tmp, se.expr);\n \n       /* Work out the offset for this component.  */\n       tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, se.expr, stride);\n@@ -3669,11 +3667,11 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       gfc_add_block_to_block (pblock, &se.pre);\n \n       tmp = gfc_conv_descriptor_ubound (descriptor, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (pblock, tmp, se.expr);\n+      gfc_add_modify (pblock, tmp, se.expr);\n \n       /* Store the stride.  */\n       tmp = gfc_conv_descriptor_stride (descriptor, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (pblock, tmp, stride);\n+      gfc_add_modify (pblock, tmp, stride);\n \n       /* Calculate the size of this dimension.  */\n       size = fold_build2 (PLUS_EXPR, gfc_array_index_type, se.expr, size);\n@@ -3713,11 +3711,11 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n \n   var = gfc_create_var (TREE_TYPE (size), \"size\");\n   gfc_start_block (&thenblock);\n-  gfc_add_modify_expr (&thenblock, var, gfc_index_zero_node);\n+  gfc_add_modify (&thenblock, var, gfc_index_zero_node);\n   thencase = gfc_finish_block (&thenblock);\n \n   gfc_start_block (&elseblock);\n-  gfc_add_modify_expr (&elseblock, var, size);\n+  gfc_add_modify (&elseblock, var, size);\n   elsecase = gfc_finish_block (&elseblock);\n \n   tmp = gfc_evaluate_now (or_expr, pblock);\n@@ -3803,7 +3801,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   tmp = gfc_conv_descriptor_offset (se->expr);\n-  gfc_add_modify_expr (&se->pre, tmp, offset);\n+  gfc_add_modify (&se->pre, tmp, offset);\n \n   if (expr->ts.type == BT_DERIVED\n \t&& expr->ts.derived->attr.alloc_comp)\n@@ -4001,15 +3999,15 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n           gfc_init_se (&se, NULL);\n           gfc_conv_expr_type (&se, as->lower[dim], gfc_array_index_type);\n           gfc_add_block_to_block (pblock, &se.pre);\n-          gfc_add_modify_expr (pblock, lbound, se.expr);\n+          gfc_add_modify (pblock, lbound, se.expr);\n         }\n       ubound = GFC_TYPE_ARRAY_UBOUND (type, dim);\n       if (as->upper[dim] && !INTEGER_CST_P (ubound))\n         {\n           gfc_init_se (&se, NULL);\n           gfc_conv_expr_type (&se, as->upper[dim], gfc_array_index_type);\n           gfc_add_block_to_block (pblock, &se.pre);\n-          gfc_add_modify_expr (pblock, ubound, se.expr);\n+          gfc_add_modify (pblock, ubound, se.expr);\n         }\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n       tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, size);\n@@ -4029,7 +4027,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n           tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, tmp);\n           tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n           if (stride)\n-            gfc_add_modify_expr (pblock, stride, tmp);\n+            gfc_add_modify (pblock, stride, tmp);\n           else\n             stride = gfc_evaluate_now (tmp, pblock);\n \n@@ -4039,7 +4037,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \t\t\t     stride, gfc_index_zero_node);\n \t  tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n \t\t\t     stride, gfc_index_zero_node);\n-\t  gfc_add_modify_expr (pblock, stride, tmp);\n+\t  gfc_add_modify (pblock, stride, tmp);\n         }\n \n       size = stride;\n@@ -4112,7 +4110,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   if (sym->attr.cray_pointee)\n     {\n       if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-\tgfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+\tgfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n       gfc_add_expr_to_block (&block, fnbody);\n       return gfc_finish_block (&block);\n     }\n@@ -4125,11 +4123,11 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   /* Allocate memory to hold the data.  */\n   tmp = gfc_call_malloc (&block, TREE_TYPE (decl), size);\n-  gfc_add_modify_expr (&block, decl, tmp);\n+  gfc_add_modify (&block, decl, tmp);\n \n   /* Set offset of the array.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-    gfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+    gfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n \n   /* Automatic arrays should not have initializers.  */\n@@ -4177,13 +4175,13 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n \n   /* Set the offset.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-    gfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+    gfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   /* Set the pointer itself if we aren't using the parameter directly.  */\n   if (TREE_CODE (parm) != PARM_DECL)\n     {\n       tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));\n-      gfc_add_modify_expr (&block, parm, tmp);\n+      gfc_add_modify (&block, parm, tmp);\n     }\n   stmt = gfc_finish_block (&block);\n \n@@ -4278,7 +4276,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       TREE_USED (partial) = 1;\n       tmp = gfc_conv_descriptor_stride (dumdesc, gfc_rank_cst[0]);\n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, tmp, gfc_index_one_node);\n-      gfc_add_modify_expr (&block, partial, tmp);\n+      gfc_add_modify (&block, partial, tmp);\n     }\n   else\n     {\n@@ -4298,7 +4296,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n \t\t\t gfc_index_one_node, stride);\n       stride = GFC_TYPE_ARRAY_STRIDE (type, 0);\n-      gfc_add_modify_expr (&block, stride, tmp);\n+      gfc_add_modify (&block, stride, tmp);\n \n       /* Allow the user to disable array repacking.  */\n       stmt_unpacked = NULL_TREE;\n@@ -4332,7 +4330,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n     }\n   else\n     tmp = stmt_packed != NULL_TREE ? stmt_packed : stmt_unpacked;\n-  gfc_add_modify_expr (&block, tmpdesc, fold_convert (type, tmp));\n+  gfc_add_modify (&block, tmpdesc, fold_convert (type, tmp));\n \n   offset = gfc_index_zero_node;\n   size = gfc_index_one_node;\n@@ -4359,7 +4357,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n           gfc_conv_expr_type (&se, sym->as->lower[n],\n                               gfc_array_index_type);\n           gfc_add_block_to_block (&block, &se.pre);\n-          gfc_add_modify_expr (&block, lbound, se.expr);\n+          gfc_add_modify (&block, lbound, se.expr);\n         }\n \n       ubound = GFC_TYPE_ARRAY_UBOUND (type, n);\n@@ -4373,7 +4371,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t      gfc_conv_expr_type (&se, sym->as->upper[n],\n                                   gfc_array_index_type);\n \t      gfc_add_block_to_block (&block, &se.pre);\n-              gfc_add_modify_expr (&block, ubound, se.expr);\n+              gfc_add_modify (&block, ubound, se.expr);\n             }\n \n \t  /* Check the sizes match.  */\n@@ -4400,7 +4398,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n           tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t     dubound, dlbound);\n           tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound);\n-          gfc_add_modify_expr (&block, ubound, tmp);\n+          gfc_add_modify (&block, ubound, tmp);\n \t}\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n       tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, stride);\n@@ -4440,7 +4438,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t\t\t\t   stmt_unpacked, stmt_packed);\n               else\n                 tmp = (stmt_packed != NULL_TREE) ? stmt_packed : stmt_unpacked;\n-              gfc_add_modify_expr (&block, stride, tmp);\n+              gfc_add_modify (&block, stride, tmp);\n             }\n         }\n       else\n@@ -4456,14 +4454,14 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t\t\t\t ubound, tmp);\n \t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t GFC_TYPE_ARRAY_STRIDE (type, n), tmp);\n-\t      gfc_add_modify_expr (&block, stride, tmp);\n+\t      gfc_add_modify (&block, stride, tmp);\n \t    }\n \t}\n     }\n \n   /* Set the offset.  */\n   if (TREE_CODE (GFC_TYPE_ARRAY_OFFSET (type)) == VAR_DECL)\n-    gfc_add_modify_expr (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n+    gfc_add_modify (&block, GFC_TYPE_ARRAY_OFFSET (type), offset);\n \n   gfc_trans_vla_type_sizes (sym, &block);\n \n@@ -4758,7 +4756,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  if (se->direct_byref)\n \t    {\n \t      /* Copy the descriptor for pointer assignments.  */\n-\t      gfc_add_modify_expr (&se->pre, se->expr, desc);\n+\t      gfc_add_modify (&se->pre, se->expr, desc);\n \n \t      /* Add any offsets from subreferences.  */\n \t      gfc_get_dataptr_offset (&se->pre, se->expr, desc, NULL_TREE,\n@@ -4991,7 +4989,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       /* Set the dtype.  */\n       tmp = gfc_conv_descriptor_dtype (parm);\n-      gfc_add_modify_expr (&loop.pre, tmp, gfc_get_dtype (parmtype));\n+      gfc_add_modify (&loop.pre, tmp, gfc_get_dtype (parmtype));\n \n       /* Set offset for assignments to pointer only to zero if it is not\n          the full array.  */\n@@ -5060,11 +5058,11 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t      from = gfc_index_one_node;\n \t    }\n \t  tmp = gfc_conv_descriptor_lbound (parm, gfc_rank_cst[dim]);\n-\t  gfc_add_modify_expr (&loop.pre, tmp, from);\n+\t  gfc_add_modify (&loop.pre, tmp, from);\n \n \t  /* Set the new upper bound.  */\n \t  tmp = gfc_conv_descriptor_ubound (parm, gfc_rank_cst[dim]);\n-\t  gfc_add_modify_expr (&loop.pre, tmp, to);\n+\t  gfc_add_modify (&loop.pre, tmp, to);\n \n \t  /* Multiply the stride by the section stride to get the\n \t     total stride.  */\n@@ -5089,7 +5087,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n \t  /* Store the new stride.  */\n \t  tmp = gfc_conv_descriptor_stride (parm, gfc_rank_cst[dim]);\n-\t  gfc_add_modify_expr (&loop.pre, tmp, stride);\n+\t  gfc_add_modify (&loop.pre, tmp, stride);\n \n \t  dim++;\n \t}\n@@ -5106,14 +5104,14 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t{\n \t  /* Set the offset.  */\n \t  tmp = gfc_conv_descriptor_offset (parm);\n-\t  gfc_add_modify_expr (&loop.pre, tmp, base);\n+\t  gfc_add_modify (&loop.pre, tmp, base);\n \t}\n       else\n \t{\n \t  /* Only the callee knows what the correct offset it, so just set\n \t     it to zero here.  */\n \t  tmp = gfc_conv_descriptor_offset (parm);\n-\t  gfc_add_modify_expr (&loop.pre, tmp, gfc_index_zero_node);\n+\t  gfc_add_modify (&loop.pre, tmp, gfc_index_zero_node);\n \t}\n       desc = parm;\n     }\n@@ -5588,7 +5586,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n-\t      gfc_add_modify_expr (&fnblock, dcmp, tmp);\n+\t      gfc_add_modify (&fnblock, dcmp, tmp);\n \t      tmp = structure_alloc_comps (c->ts.derived, comp, dcmp,\n \t\t\t\t\t   rank, purpose);\n \t      gfc_add_expr_to_block (&fnblock, tmp);"}, {"sha": "18de51c8437f7c6904d236ca967911bc381d4b45", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -120,11 +120,7 @@ tree gfc_conv_array_ubound (tree, int);\n \n /* Build expressions for accessing components of an array descriptor.  */\n tree gfc_conv_descriptor_data_get (tree);\n-void gfc_conv_descriptor_data_set_internal (stmtblock_t *, tree, tree, bool);\n-#define gfc_conv_descriptor_data_set(BLOCK, T1, T2)\t\t\t\\\n-  gfc_conv_descriptor_data_set_internal ((BLOCK), (T1), (T2), false)\n-#define gfc_conv_descriptor_data_set_tuples(BLOCK, T1, T2)\t\t\\\n-  gfc_conv_descriptor_data_set_internal ((BLOCK), (T1), (T2), true)\n+void gfc_conv_descriptor_data_set (stmtblock_t *, tree, tree);\n tree gfc_conv_descriptor_data_addr (tree);\n tree gfc_conv_descriptor_offset (tree);\n tree gfc_conv_descriptor_dtype (tree);"}, {"sha": "1dfa05cc46f3e97062e6359427ba83e1fc6b6c5a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"tree-dump.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"tm.h\"\n@@ -2576,7 +2576,7 @@ gfc_trans_assign_aux_var (gfc_symbol * sym, tree fnbody)\n \n   /* Set the initial value to length. See the comments in\n      function gfc_add_assign_aux_vars in this file.  */\n-  gfc_add_modify_expr (&body, GFC_DECL_STRING_LEN (sym->backend_decl),\n+  gfc_add_modify (&body, GFC_DECL_STRING_LEN (sym->backend_decl),\n \t\t       build_int_cst (NULL_TREE, -2));\n \n   gfc_add_expr_to_block (&body, fnbody);\n@@ -2607,7 +2607,7 @@ gfc_trans_vla_one_sizepos (tree *tp, stmtblock_t *body)\n \n   var = gfc_create_var_np (TREE_TYPE (t), NULL);\n   gfc_add_decl_to_function (var);\n-  gfc_add_modify_expr (body, var, val);\n+  gfc_add_modify (body, var, val);\n   if (TREE_CODE (t) == SAVE_EXPR)\n     TREE_OPERAND (t, 0) = var;\n   *tp = var;\n@@ -3412,7 +3412,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n     {\n       tree alternate_return;\n       alternate_return = gfc_get_fake_result_decl (sym, 0);\n-      gfc_add_modify_expr (&body, alternate_return, integer_zero_node);\n+      gfc_add_modify (&body, alternate_return, integer_zero_node);\n     }\n \n   if (ns->entries)"}, {"sha": "05ee3902e34d1fa9fca48d21fc1ede5329a567b3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"langhooks.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n@@ -115,7 +115,7 @@ gfc_make_safe_expr (gfc_se * se)\n \n   /* We need a temporary for this result.  */\n   var = gfc_create_var (TREE_TYPE (se->expr), NULL);\n-  gfc_add_modify_expr (&se->pre, var, se->expr);\n+  gfc_add_modify (&se->pre, var, se->expr);\n   se->expr = var;\n }\n \n@@ -257,7 +257,7 @@ gfc_conv_string_length (gfc_charlen * cl, stmtblock_t * pblock)\n   gfc_add_block_to_block (pblock, &se.pre);\n \n   if (cl->backend_decl)\n-    gfc_add_modify_expr (pblock, cl->backend_decl, se.expr);\n+    gfc_add_modify (pblock, cl->backend_decl, se.expr);\n   else\n     cl->backend_decl = gfc_evaluate_now (se.expr, pblock);\n }\n@@ -993,7 +993,7 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n \t\t\t     fold_build2 (MULT_EXPR, TREE_TYPE (len), len,\n \t\t\t\t\t  fold_convert (TREE_TYPE (len),\n \t\t\t\t\t\t\tTYPE_SIZE (type))));\n-      gfc_add_modify_expr (&se->pre, var, tmp);\n+      gfc_add_modify (&se->pre, var, tmp);\n \n       /* Free the temporary afterwards.  */\n       tmp = gfc_call_free (convert (pvoid_type_node, var));\n@@ -1509,7 +1509,7 @@ gfc_get_interface_mapping_array (stmtblock_t * block, gfc_symbol * sym,\n   type = gfc_get_nodesc_array_type (type, sym->as, packed);\n \n   var = gfc_create_var (type, \"ifm\");\n-  gfc_add_modify_expr (block, var, fold_convert (type, data));\n+  gfc_add_modify (block, var, fold_convert (type, data));\n \n   return var;\n }\n@@ -2165,7 +2165,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n \n   tmp_index = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n   \t\t\t   tmp_index, rse.loop->from[0]);\n-  gfc_add_modify_expr (&rse.loop->code[0], offset, tmp_index);\n+  gfc_add_modify (&rse.loop->code[0], offset, tmp_index);\n \n   tmp_index = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t   rse.loop->loopvar[0], offset);\n@@ -2895,9 +2895,9 @@ fill_with_spaces (tree start, tree type, tree size)\n   /* Initialize variables.  */\n   gfc_init_block (&block);\n   i = gfc_create_var (sizetype, \"i\");\n-  gfc_add_modify_expr (&block, i, fold_convert (sizetype, size));\n+  gfc_add_modify (&block, i, fold_convert (sizetype, size));\n   el = gfc_create_var (build_pointer_type (type), \"el\");\n-  gfc_add_modify_expr (&block, el, fold_convert (TREE_TYPE (el), start));\n+  gfc_add_modify (&block, el, fold_convert (TREE_TYPE (el), start));\n   exit_label = gfc_build_label_decl (NULL_TREE);\n   TREE_USED (exit_label) = 1;\n \n@@ -2913,14 +2913,14 @@ fill_with_spaces (tree start, tree type, tree size)\n   gfc_add_expr_to_block (&loop, tmp);\n \n   /* Assignment.  */\n-  gfc_add_modify_expr (&loop, fold_build1 (INDIRECT_REF, type, el),\n+  gfc_add_modify (&loop, fold_build1 (INDIRECT_REF, type, el),\n \t\t       build_int_cst (type,\n \t\t\t\t      lang_hooks.to_target_charset (' ')));\n \n   /* Increment loop variables.  */\n-  gfc_add_modify_expr (&loop, i, fold_build2 (MINUS_EXPR, sizetype, i,\n+  gfc_add_modify (&loop, i, fold_build2 (MINUS_EXPR, sizetype, i,\n \t\t\t\t\t      TYPE_SIZE_UNIT (type)));\n-  gfc_add_modify_expr (&loop, el, fold_build2 (POINTER_PLUS_EXPR,\n+  gfc_add_modify (&loop, el, fold_build2 (POINTER_PLUS_EXPR,\n \t\t\t\t\t       TREE_TYPE (el), el,\n \t\t\t\t\t       TYPE_SIZE_UNIT (type)));\n \n@@ -2989,7 +2989,7 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   if (dsc != NULL_TREE && ssc != NULL_TREE\n       && TREE_TYPE (dsc) == TREE_TYPE (ssc))\n     {\n-      gfc_add_modify_expr (block, dsc, ssc);\n+      gfc_add_modify (block, dsc, ssc);\n       return;\n     }\n \n@@ -3135,7 +3135,7 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n           gfc_conv_expr (&lse, args->expr);\n \n           gfc_add_block_to_block (&se->pre, &lse.pre);\n-          gfc_add_modify_expr (&se->pre, temp_vars[n], lse.expr);\n+          gfc_add_modify (&se->pre, temp_vars[n], lse.expr);\n           gfc_add_block_to_block (&se->pre, &lse.post);\n         }\n \n@@ -3420,7 +3420,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  se.want_pointer = 1;\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&block, &se.pre);\n-\t  gfc_add_modify_expr (&block, dest,\n+\t  gfc_add_modify (&block, dest,\n \t\t\t       fold_convert (TREE_TYPE (dest), se.expr));\n \t  gfc_add_block_to_block (&block, &se.post);\n \t}\n@@ -3441,7 +3441,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  gfc_add_block_to_block (&block, &se.pre);\n \n \t  tmp = fold_convert (TREE_TYPE (dest), se.expr);\n-\t  gfc_add_modify_expr (&block, dest, tmp);\n+\t  gfc_add_modify (&block, dest, tmp);\n \n \t  if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)\n \t    tmp = gfc_copy_alloc_comp (cm->ts.derived, se.expr, dest,\n@@ -3459,7 +3459,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  /* Shift the lbound and ubound of temporaries to being unity, rather\n \t     than zero, based.  Calculate the offset for all cases.  */\n \t  offset = gfc_conv_descriptor_offset (dest);\n-\t  gfc_add_modify_expr (&block, offset, gfc_index_zero_node);\n+\t  gfc_add_modify (&block, offset, gfc_index_zero_node);\n \t  tmp2 =gfc_create_var (gfc_array_index_type, NULL);\n \t  for (n = 0; n < expr->rank; n++)\n \t    {\n@@ -3470,21 +3470,21 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t\t  tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);\n \t\t  span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,\n \t\t\t    gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]));\n-\t\t  gfc_add_modify_expr (&block, tmp,\n+\t\t  gfc_add_modify (&block, tmp,\n \t\t\t\t       fold_build2 (PLUS_EXPR,\n \t\t\t\t\t\t    gfc_array_index_type,\n \t\t\t\t\t\t    span, gfc_index_one_node));\n \t\t  tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);\n-\t\t  gfc_add_modify_expr (&block, tmp, gfc_index_one_node);\n+\t\t  gfc_add_modify (&block, tmp, gfc_index_one_node);\n \t\t}\n \t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t gfc_conv_descriptor_lbound (dest,\n \t\t\t\t\t\t\t     gfc_rank_cst[n]),\n \t\t\t\t gfc_conv_descriptor_stride (dest,\n \t\t\t\t\t\t\t     gfc_rank_cst[n]));\n-\t      gfc_add_modify_expr (&block, tmp2, tmp);\n+\t      gfc_add_modify (&block, tmp2, tmp);\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n-\t      gfc_add_modify_expr (&block, offset, tmp);\n+\t      gfc_add_modify (&block, offset, tmp);\n \t    }\n \t}\n       else\n@@ -3499,7 +3499,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t{\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr (&se, expr);\n-\t  gfc_add_modify_expr (&block, dest,\n+\t  gfc_add_modify (&block, dest,\n \t\t\t       fold_convert (TREE_TYPE (dest), se.expr));\n \t}\n       else\n@@ -3745,7 +3745,7 @@ gfc_conv_expr_val (gfc_se * se, gfc_expr * expr)\n   if (se->post.head)\n     {\n       val = gfc_create_var (TREE_TYPE (se->expr), NULL);\n-      gfc_add_modify_expr (&se->pre, val, se->expr);\n+      gfc_add_modify (&se->pre, val, se->expr);\n       se->expr = val;\n       gfc_add_block_to_block (&se->pre, &se->post);\n     }\n@@ -3791,7 +3791,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n       if (se->post.head)\n \t{\n \t  var = gfc_create_var (TREE_TYPE (se->expr), NULL);\n-\t  gfc_add_modify_expr (&se->pre, var, se->expr);\n+\t  gfc_add_modify (&se->pre, var, se->expr);\n \t  gfc_add_block_to_block (&se->pre, &se->post);\n \t  se->expr = var;\n \t}\n@@ -3805,7 +3805,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n       se->want_pointer = 1;\n       gfc_conv_expr (se, expr);\n       var = gfc_create_var (TREE_TYPE (se->expr), NULL);\n-      gfc_add_modify_expr (&se->pre, var, se->expr);\n+      gfc_add_modify (&se->pre, var, se->expr);\n       se->expr = var;\n       return;\n     }\n@@ -3826,7 +3826,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n   else\n     {\n       var = gfc_create_var (TREE_TYPE (se->expr), NULL);\n-      gfc_add_modify_expr (&se->pre, var, se->expr);\n+      gfc_add_modify (&se->pre, var, se->expr);\n     }\n   gfc_add_block_to_block (&se->pre, &se->post);\n \n@@ -3879,7 +3879,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n-      gfc_add_modify_expr (&block, lse.expr,\n+      gfc_add_modify (&block, lse.expr,\n \t\t\t   fold_convert (TREE_TYPE (lse.expr), rse.expr));\n       gfc_add_block_to_block (&block, &rse.post);\n       gfc_add_block_to_block (&block, &lse.post);\n@@ -3912,7 +3912,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t      tmp = fold_convert (gfc_array_index_type, size_in_bytes (tmp));\n \t      if (!INTEGER_CST_P (tmp))\n \t        gfc_add_block_to_block (&lse.post, &rse.pre);\n-\t      gfc_add_modify_expr (&lse.post, GFC_DECL_SPAN(decl), tmp);\n+\t      gfc_add_modify (&lse.post, GFC_DECL_SPAN(decl), tmp);\n \t    }\n \n \t  break;\n@@ -3926,7 +3926,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  lse.expr = tmp;\n \t  lse.direct_byref = 1;\n \t  gfc_conv_expr_descriptor (&lse, expr2, rss);\n-\t  gfc_add_modify_expr (&lse.pre, desc, tmp);\n+\t  gfc_add_modify (&lse.pre, desc, tmp);\n \t  break;\n         }\n       gfc_add_block_to_block (&block, &lse.pre);\n@@ -4038,7 +4038,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_add_block_to_block (&block, &rse->pre);\n       gfc_add_block_to_block (&block, &lse->pre);\n \n-      gfc_add_modify_expr (&block, lse->expr,\n+      gfc_add_modify (&block, lse->expr,\n \t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n \n       /* Do a deep copy if the rhs is a variable, if it is not the\n@@ -4055,7 +4055,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n \n-      gfc_add_modify_expr (&block, lse->expr,\n+      gfc_add_modify (&block, lse->expr,\n \t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n     }\n "}, {"sha": "a56f4c1fabbca12de38cb06a996a5bbc7b66dabd", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"\n@@ -1316,7 +1316,7 @@ gfc_conv_intrinsic_char (gfc_se * se, gfc_expr * expr)\n   var = gfc_create_var (type, \"char\");\n \n   arg[0] = fold_build1 (NOP_EXPR, type, arg[0]);\n-  gfc_add_modify_expr (&se->pre, var, arg[0]);\n+  gfc_add_modify (&se->pre, var, arg[0]);\n   se->expr = gfc_build_addr_expr (build_pointer_type (type), var);\n   se->string_length = integer_one_node;\n }\n@@ -1479,7 +1479,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n     args[0] = gfc_evaluate_now (args[0], &se->pre);\n \n   mvar = gfc_create_var (type, \"M\");\n-  gfc_add_modify_expr (&se->pre, mvar, args[0]);\n+  gfc_add_modify (&se->pre, mvar, args[0]);\n   for (i = 1, argexpr = argexpr->next; i < nargs; i++)\n     {\n       tree cond, isnan;\n@@ -1718,7 +1718,7 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, int op)\n     tmp = convert (type, boolean_true_node);\n   else\n     tmp = convert (type, boolean_false_node);\n-  gfc_add_modify_expr (&se->pre, resvar, tmp);\n+  gfc_add_modify (&se->pre, resvar, tmp);\n \n   /* Walk the arguments.  */\n   arrayss = gfc_walk_expr (actual->expr);\n@@ -1744,7 +1744,7 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, int op)\n     tmp = convert (type, boolean_false_node);\n   else\n     tmp = convert (type, boolean_true_node);\n-  gfc_add_modify_expr (&block, resvar, tmp);\n+  gfc_add_modify (&block, resvar, tmp);\n \n   /* And break out of the loop.  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n@@ -1802,7 +1802,7 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   type = gfc_typenode_for_spec (&expr->ts);\n   /* Initialize the result.  */\n   resvar = gfc_create_var (type, \"count\");\n-  gfc_add_modify_expr (&se->pre, resvar, build_int_cst (type, 0));\n+  gfc_add_modify (&se->pre, resvar, build_int_cst (type, 0));\n \n   /* Walk the arguments.  */\n   arrayss = gfc_walk_expr (actual->expr);\n@@ -1875,7 +1875,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   else\n     tmp = gfc_build_const (type, integer_one_node);\n \n-  gfc_add_modify_expr (&se->pre, resvar, tmp);\n+  gfc_add_modify (&se->pre, resvar, tmp);\n \n   /* Walk the arguments.  */\n   actual = expr->value.function.actual;\n@@ -1932,7 +1932,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n   tmp = fold_build2 (op, type, resvar, arrayse.expr);\n-  gfc_add_modify_expr (&block, resvar, tmp);\n+  gfc_add_modify (&block, resvar, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n \n   if (maskss)\n@@ -1999,7 +1999,7 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n   else\n     tmp = gfc_build_const (type, integer_zero_node);\n \n-  gfc_add_modify_expr (&se->pre, resvar, tmp);\n+  gfc_add_modify (&se->pre, resvar, tmp);\n \n   /* Walk argument #1.  */\n   actual = expr->value.function.actual;\n@@ -2056,7 +2056,7 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n       tmp = fold_build2 (MULT_EXPR, type, arrayse1.expr, arrayse2.expr);\n       tmp = fold_build2 (PLUS_EXPR, type, resvar, tmp);\n     }\n-  gfc_add_modify_expr (&block, resvar, tmp);\n+  gfc_add_modify (&block, resvar, tmp);\n \n   /* Finish up the loop block and the loop.  */\n   tmp = gfc_finish_block (&block);\n@@ -2146,7 +2146,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n      possible value is HUGE in both cases.  */\n   if (op == GT_EXPR)\n     tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n-  gfc_add_modify_expr (&se->pre, limit, tmp);\n+  gfc_add_modify (&se->pre, limit, tmp);\n \n   if (op == GT_EXPR && expr->ts.type == BT_INTEGER)\n     tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp,\n@@ -2167,7 +2167,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   /* Initialize the position to zero, following Fortran 2003.  We are free\n      to do this because Fortran 95 allows the result of an entirely false\n      mask to be processor dependent.  */\n-  gfc_add_modify_expr (&loop.pre, pos, gfc_index_zero_node);\n+  gfc_add_modify (&loop.pre, pos, gfc_index_zero_node);\n \n   gfc_mark_ss_chain_used (arrayss, 1);\n   if (maskss)\n@@ -2200,7 +2200,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   gfc_start_block (&ifblock);\n \n   /* Assign the value to the limit...  */\n-  gfc_add_modify_expr (&ifblock, limit, arrayse.expr);\n+  gfc_add_modify (&ifblock, limit, arrayse.expr);\n \n   /* Remember where we are.  An offset must be added to the loop\n      counter to obtain the required position.  */\n@@ -2210,11 +2210,11 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   else\n     tmp = build_int_cst (gfc_array_index_type, 1);\n   \n-  gfc_add_modify_expr (&block, offset, tmp);\n+  gfc_add_modify (&block, offset, tmp);\n \n   tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n \t\t     loop.loopvar[0], offset);\n-  gfc_add_modify_expr (&ifblock, pos, tmp);\n+  gfc_add_modify (&ifblock, pos, tmp);\n \n   ifbody = gfc_finish_block (&ifblock);\n \n@@ -2258,7 +2258,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n \t the pos variable the same way as above.  */\n \n       gfc_init_block (&elseblock);\n-      gfc_add_modify_expr (&elseblock, pos, gfc_index_zero_node);\n+      gfc_add_modify (&elseblock, pos, gfc_index_zero_node);\n       elsetmp = gfc_finish_block (&elseblock);\n \n       tmp = build3_v (COND_EXPR, maskse.expr, tmp, elsetmp);\n@@ -2329,7 +2329,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n     tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp),\n \t\t       tmp, build_int_cst (type, 1));\n \n-  gfc_add_modify_expr (&se->pre, limit, tmp);\n+  gfc_add_modify (&se->pre, limit, tmp);\n \n   /* Walk the arguments.  */\n   actual = expr->value.function.actual;\n@@ -3003,12 +3003,12 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node, e, prec);\n-  gfc_add_modify_expr (&block, e, fold_build2 (MAX_EXPR, integer_type_node,\n+  gfc_add_modify (&block, e, fold_build2 (MAX_EXPR, integer_type_node,\n \t\t\t\t\t       tmp, emin));\n \n   tmp = build_call_expr (built_in_decls[scalbn], 2,\n \t\t\t build_real_from_int_cst (type, integer_one_node), e);\n-  gfc_add_modify_expr (&block, res, tmp);\n+  gfc_add_modify (&block, res, tmp);\n \n   /* Finish by building the IF statement.  */\n   cond = fold_build2 (EQ_EXPR, boolean_type_node, arg,\n@@ -3071,7 +3071,7 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n \n   e = gfc_create_var (integer_type_node, NULL);\n   x = gfc_create_var (type, NULL);\n-  gfc_add_modify_expr (&se->pre, x,\n+  gfc_add_modify (&se->pre, x,\n \t\t       build_call_expr (built_in_decls[fabs], 1, arg));\n \n \n@@ -3083,7 +3083,7 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n   tmp = fold_build2 (MINUS_EXPR, integer_type_node,\n \t\t     build_int_cst (NULL_TREE, prec), e);\n   tmp = build_call_expr (built_in_decls[scalbn], 2, x, tmp);\n-  gfc_add_modify_expr (&block, x, tmp);\n+  gfc_add_modify (&block, x, tmp);\n   stmt = gfc_finish_block (&block);\n \n   cond = fold_build2 (NE_EXPR, boolean_type_node, x,\n@@ -3300,7 +3300,7 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n       else\n \ttmp = fold_convert (gfc_array_index_type,\n \t\t\t    size_in_bytes (type)); \n-      gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+      gfc_add_modify (&argse.pre, source_bytes, tmp);\n \n       /* Obtain the size of the array in bytes.  */\n       for (n = 0; n < arg->rank; n++)\n@@ -3315,7 +3315,7 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n \t\t\t     tmp, gfc_index_one_node);\n \t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t     tmp, source_bytes);\n-\t  gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+\t  gfc_add_modify (&argse.pre, source_bytes, tmp);\n \t}\n       se->expr = source_bytes;\n     }\n@@ -3473,21 +3473,21 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t{\n \t  tree idx;\n \t  idx = gfc_rank_cst[n];\n-\t  gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+\t  gfc_add_modify (&argse.pre, source_bytes, tmp);\n \t  stride = gfc_conv_descriptor_stride (argse.expr, idx);\n \t  lower = gfc_conv_descriptor_lbound (argse.expr, idx);\n \t  upper = gfc_conv_descriptor_ubound (argse.expr, idx);\n \t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t     upper, lower);\n-\t  gfc_add_modify_expr (&argse.pre, extent, tmp);\n+\t  gfc_add_modify (&argse.pre, extent, tmp);\n \t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     extent, gfc_index_one_node);\n \t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t     tmp, source_bytes);\n \t}\n     }\n \n-  gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+  gfc_add_modify (&argse.pre, source_bytes, tmp);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n \n@@ -3522,7 +3522,7 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\tsize_in_bytes (mold_type)); \n  \n   dest_word_len = gfc_create_var (gfc_array_index_type, NULL);\n-  gfc_add_modify_expr (&se->pre, dest_word_len, tmp);\n+  gfc_add_modify (&se->pre, dest_word_len, tmp);\n \n   /* Finally convert SIZE, if it is present.  */\n   arg = arg->next;\n@@ -3551,8 +3551,8 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   else\n     tmp = source_bytes;\n \n-  gfc_add_modify_expr (&se->pre, size_bytes, tmp);\n-  gfc_add_modify_expr (&se->pre, size_words,\n+  gfc_add_modify (&se->pre, size_bytes, tmp);\n+  gfc_add_modify (&se->pre, size_words,\n \t\t       fold_build2 (CEIL_DIV_EXPR, gfc_array_index_type,\n \t\t\t\t    size_bytes, dest_word_len));\n \n@@ -3569,8 +3569,8 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\t tmp, gfc_index_one_node);\n       tmp = fold_build2 (MIN_EXPR, gfc_array_index_type,\n \t\t\t tmp, size_words);\n-      gfc_add_modify_expr (&se->pre, size_words, tmp);\n-      gfc_add_modify_expr (&se->pre, size_bytes,\n+      gfc_add_modify (&se->pre, size_words, tmp);\n+      gfc_add_modify (&se->pre, size_bytes,\n \t\t\t   fold_build2 (MULT_EXPR, gfc_array_index_type,\n \t\t\t\t\tsize_words, dest_word_len));\n       upper = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n@@ -3971,7 +3971,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \t\t      build_int_cst (size_type_node, 0));\n   tmp = fold_build3 (COND_EXPR, ncopies_type, cond,\n \t\t     build_int_cst (ncopies_type, 0), ncopies);\n-  gfc_add_modify_expr (&se->pre, n, tmp);\n+  gfc_add_modify (&se->pre, n, tmp);\n   ncopies = n;\n \n   /* Check that ncopies is not too large: ncopies should be less than\n@@ -4006,7 +4006,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n          memmove (dest + (i * slen * size), src, slen*size);  */\n   gfc_start_block (&block);\n   count = gfc_create_var (ncopies_type, \"count\");\n-  gfc_add_modify_expr (&block, count, build_int_cst (ncopies_type, 0));\n+  gfc_add_modify (&block, count, build_int_cst (ncopies_type, 0));\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Start the loop body.  */\n@@ -4037,7 +4037,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   /* Increment count.  */\n   tmp = fold_build2 (PLUS_EXPR, ncopies_type,\n \t\t     count, build_int_cst (TREE_TYPE (count), 1));\n-  gfc_add_modify_expr (&body, count, tmp);\n+  gfc_add_modify (&body, count, tmp);\n \n   /* Build the loop.  */\n   tmp = build1_v (LOOP_EXPR, gfc_finish_block (&body));\n@@ -4101,7 +4101,7 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n   /* Create a temporary variable for loc return value.  Without this, \n      we get an error an ICE in gcc/expr.c(expand_expr_addr_expr_1).  */\n   temp_var = gfc_create_var (gfc_get_int_type (gfc_index_integer_kind), NULL);\n-  gfc_add_modify_expr (&se->pre, temp_var, se->expr);\n+  gfc_add_modify (&se->pre, temp_var, se->expr);\n   se->expr = temp_var;\n }\n "}, {"sha": "e304d1687bfc9674c4f820c9e4e5a66b28a5bf17", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n@@ -450,7 +450,7 @@ set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n \t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n   tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n \t\t     NULL_TREE);\n-  gfc_add_modify_expr (block, tmp, build_int_cst (TREE_TYPE (p->field), val));\n+  gfc_add_modify (block, tmp, build_int_cst (TREE_TYPE (p->field), val));\n   return p->mask;\n }\n \n@@ -505,7 +505,7 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n \t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n \n   tmp = fold_build3 (COMPONENT_REF, dest_type, var, p->field, NULL_TREE);\n-  gfc_add_modify_expr (block, tmp, se.expr);\n+  gfc_add_modify (block, tmp, se.expr);\n   return p->mask;\n }\n \n@@ -535,7 +535,7 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n       /* If this is for the iostat variable initialize the\n \t user variable to LIBERROR_OK which is zero.  */\n       if (type == IOPARM_common_iostat)\n-\tgfc_add_modify_expr (block, se.expr,\n+\tgfc_add_modify (block, se.expr,\n \t\t\t     build_int_cst (TREE_TYPE (se.expr), LIBERROR_OK));\n     }\n   else\n@@ -549,21 +549,21 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n       /* If this is for the iostat variable, initialize the\n \t user variable to LIBERROR_OK which is zero.  */\n       if (type == IOPARM_common_iostat)\n-\tgfc_add_modify_expr (block, tmpvar,\n+\tgfc_add_modify (block, tmpvar,\n \t\t\t     build_int_cst (TREE_TYPE (tmpvar), LIBERROR_OK));\n \n       addr = build_fold_addr_expr (tmpvar);\n \t/* After the I/O operation, we set the variable from the temporary.  */\n       tmp = convert (TREE_TYPE (se.expr), tmpvar);\n-      gfc_add_modify_expr (postblock, se.expr, tmp);\n+      gfc_add_modify (postblock, se.expr, tmp);\n      }\n \n   if (p->param_type == IOPARM_ptype_common)\n     var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n \t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n   tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n \t\t     var, p->field, NULL_TREE);\n-  gfc_add_modify_expr (block, tmp, addr);\n+  gfc_add_modify (block, tmp, addr);\n   return p->mask;\n }\n \n@@ -672,9 +672,9 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \t\t\t       fold_convert (long_integer_type_node, tmp));\n       gfc_free (msg);\n \n-      gfc_add_modify_expr (&se.pre, io,\n+      gfc_add_modify (&se.pre, io,\n \t\t fold_convert (TREE_TYPE (io), GFC_DECL_ASSIGN_ADDR (se.expr)));\n-      gfc_add_modify_expr (&se.pre, len, GFC_DECL_STRING_LEN (se.expr));\n+      gfc_add_modify (&se.pre, len, GFC_DECL_STRING_LEN (se.expr));\n     }\n   else\n     {\n@@ -688,8 +688,8 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \tgcc_unreachable ();\n \n       gfc_conv_string_parameter (&se);\n-      gfc_add_modify_expr (&se.pre, io, fold_convert (TREE_TYPE (io), se.expr));\n-      gfc_add_modify_expr (&se.pre, len, se.string_length);\n+      gfc_add_modify (&se.pre, io, fold_convert (TREE_TYPE (io), se.expr));\n+      gfc_add_modify (&se.pre, len, se.string_length);\n     }\n \n   gfc_add_block_to_block (block, &se.pre);\n@@ -764,10 +764,10 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n \n   /* The cast is needed for character substrings and the descriptor\n      data.  */\n-  gfc_add_modify_expr (&se.pre, io, fold_convert (TREE_TYPE (io), tmp));\n-  gfc_add_modify_expr (&se.pre, len,\n+  gfc_add_modify (&se.pre, io, fold_convert (TREE_TYPE (io), tmp));\n+  gfc_add_modify (&se.pre, len,\n \t\t       fold_convert (TREE_TYPE (len), se.string_length));\n-  gfc_add_modify_expr (&se.pre, desc, se.expr);\n+  gfc_add_modify (&se.pre, desc, se.expr);\n \n   gfc_add_block_to_block (block, &se.pre);\n   gfc_add_block_to_block (post_block, &se.post);\n@@ -865,7 +865,7 @@ set_error_locus (stmtblock_t * block, tree var, locus * where)\n   str = gfc_build_cstring_const (f->filename);\n \n   str = gfc_build_addr_expr (pchar_type_node, str);\n-  gfc_add_modify_expr (block, locus_file, str);\n+  gfc_add_modify (block, locus_file, str);\n \n   line = LOCATION_LINE (where->lb->location);\n   set_parameter_const (block, var, IOPARM_common_line, line);"}, {"sha": "49fd1f6152f224a7b605f16fa313c84b2c034c22", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n@@ -147,7 +147,7 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n \n   gfc_init_block (&cond_block);\n \n-  gfc_add_modify_expr (&cond_block, decl, outer);\n+  gfc_add_modify (&cond_block, decl, outer);\n   rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n   size = gfc_conv_descriptor_ubound (decl, rank);\n   size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n@@ -164,11 +164,11 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n   ptr = gfc_allocate_array_with_status (&cond_block,\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n \t\t\t\t\tsize, NULL);\n-  gfc_conv_descriptor_data_set_tuples (&cond_block, decl, ptr);\n+  gfc_conv_descriptor_data_set (&cond_block, decl, ptr);\n   then_b = gfc_finish_block (&cond_block);\n \n   gfc_init_block (&cond_block);\n-  gfc_conv_descriptor_data_set_tuples (&cond_block, decl, null_pointer_node);\n+  gfc_conv_descriptor_data_set (&cond_block, decl, null_pointer_node);\n   else_b = gfc_finish_block (&cond_block);\n \n   cond = fold_build2 (NE_EXPR, boolean_type_node,\n@@ -191,15 +191,15 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n \n   if (! GFC_DESCRIPTOR_TYPE_P (type)\n       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n-    return build_gimple_modify_stmt (dest, src);\n+    return build2_v (MODIFY_EXPR, dest, src);\n \n   gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_FIRSTPRIVATE);\n \n   /* Allocatable arrays in FIRSTPRIVATE clauses need to be allocated\n      and copied from SRC.  */\n   gfc_start_block (&block);\n \n-  gfc_add_modify_expr (&block, dest, src);\n+  gfc_add_modify (&block, dest, src);\n   rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n   size = gfc_conv_descriptor_ubound (dest, rank);\n   size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n@@ -216,7 +216,7 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   ptr = gfc_allocate_array_with_status (&block,\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n \t\t\t\t\tsize, NULL);\n-  gfc_conv_descriptor_data_set_tuples (&block, dest, ptr);\n+  gfc_conv_descriptor_data_set (&block, dest, ptr);\n   call = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n@@ -236,7 +236,7 @@ gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n \n   if (! GFC_DESCRIPTOR_TYPE_P (type)\n       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n-    return build_gimple_modify_stmt (dest, src);\n+    return build2_v (MODIFY_EXPR, dest, src);\n \n   /* Handle copying allocatable arrays.  */\n   gfc_start_block (&block);\n@@ -602,7 +602,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n \n       gfc_start_block (&block);\n \n-      gfc_add_modify_expr (&block, decl, outer_sym.backend_decl);\n+      gfc_add_modify (&block, decl, outer_sym.backend_decl);\n       rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n       size = gfc_conv_descriptor_ubound (decl, rank);\n       size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n@@ -619,7 +619,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       ptr = gfc_allocate_array_with_status (&block,\n \t\t\t\t\t    build_int_cst (pvoid_type_node, 0),\n \t\t\t\t\t    size, NULL);\n-      gfc_conv_descriptor_data_set_tuples (&block, decl, ptr);\n+      gfc_conv_descriptor_data_set (&block, decl, ptr);\n       gfc_add_expr_to_block (&block, gfc_trans_assignment (e1, e2, false));\n       stmt = gfc_finish_block (&block);\n     }\n@@ -1062,15 +1062,15 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t  tree accum = gfc_create_var (TREE_TYPE (rse.expr), NULL);\n \t  gfc_actual_arglist *arg;\n \n-\t  gfc_add_modify_stmt (&block, accum, rse.expr);\n+\t  gfc_add_modify (&block, accum, rse.expr);\n \t  for (arg = expr2->value.function.actual->next->next; arg;\n \t       arg = arg->next)\n \t    {\n \t      gfc_init_block (&rse.pre);\n \t      gfc_conv_expr (&rse, arg->expr);\n \t      gfc_add_block_to_block (&block, &rse.pre);\n \t      x = fold_build2 (op, TREE_TYPE (accum), accum, rse.expr);\n-\t      gfc_add_modify_stmt (&block, accum, x);\n+\t      gfc_add_modify (&block, accum, x);\n \t    }\n \n \t  rse.expr = accum;\n@@ -1204,11 +1204,11 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n       /* Loop body.  */\n       if (simple)\n \t{\n-\t  TREE_VEC_ELT (init, i) = build2_v (GIMPLE_MODIFY_STMT, dovar, from);\n+\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, dovar, from);\n \t  TREE_VEC_ELT (cond, i) = fold_build2 (simple > 0 ? LE_EXPR : GE_EXPR,\n \t\t\t\t\t\tboolean_type_node, dovar, to);\n \t  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, dovar, step);\n-\t  TREE_VEC_ELT (incr, i) = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar,\n+\t  TREE_VEC_ELT (incr, i) = fold_build2 (MODIFY_EXPR, type, dovar,\n \t\t\t\t\t\tTREE_VEC_ELT (incr, i));\n \t}\n       else\n@@ -1225,13 +1225,13 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t  tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n \t  tmp = gfc_evaluate_now (tmp, pblock);\n \t  count = gfc_create_var (type, \"count\");\n-\t  TREE_VEC_ELT (init, i) = build2_v (GIMPLE_MODIFY_STMT, count,\n+\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, count,\n \t\t\t\t\t     build_int_cst (type, 0));\n \t  TREE_VEC_ELT (cond, i) = fold_build2 (LT_EXPR, boolean_type_node,\n \t\t\t\t\t\tcount, tmp);\n \t  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, count,\n \t\t\t\t\t\tbuild_int_cst (type, 1));\n-\t  TREE_VEC_ELT (incr, i) = fold_build2 (GIMPLE_MODIFY_STMT, type,\n+\t  TREE_VEC_ELT (incr, i) = fold_build2 (MODIFY_EXPR, type,\n \t\t\t\t\t\tcount, TREE_VEC_ELT (incr, i));\n \n \t  /* Initialize DOVAR.  */\n@@ -1260,7 +1260,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t\t than value after iterator increment.  */\n \t      tmp = gfc_evaluate_now (step, pblock);\n \t      tmp = fold_build2 (PLUS_EXPR, type, dovar, tmp);\n-\t      tmp = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar, tmp);\n+\t      tmp = fold_build2 (MODIFY_EXPR, type, dovar, tmp);\n \t      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n \t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t\t    && OMP_CLAUSE_DECL (c) == dovar)\n@@ -1308,7 +1308,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n   dovar_init = nreverse (dovar_init);\n   while (dovar_init)\n     {\n-      gfc_add_modify_stmt (&body, TREE_PURPOSE (dovar_init),\n+      gfc_add_modify (&body, TREE_PURPOSE (dovar_init),\n \t\t\t   TREE_VALUE (dovar_init));\n       dovar_init = TREE_CHAIN (dovar_init);\n     }\n@@ -1381,7 +1381,7 @@ gfc_trans_omp_parallel (gfc_code *code)\n   omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n \t\t\t\t       code->loc);\n   stmt = gfc_trans_omp_code (code->block->next, true);\n-  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }\n@@ -1421,7 +1421,7 @@ gfc_trans_omp_parallel_do (gfc_code *code)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n     poplevel (0, 0, 0);\n-  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n@@ -1446,7 +1446,7 @@ gfc_trans_omp_parallel_sections (gfc_code *code)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n     poplevel (0, 0, 0);\n-  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n@@ -1471,7 +1471,7 @@ gfc_trans_omp_parallel_workshare (gfc_code *code)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n     poplevel (0, 0, 0);\n-  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  stmt = build2 (OMP_PARALLEL, void_type_node, stmt, omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n@@ -1503,7 +1503,7 @@ gfc_trans_omp_sections (gfc_code *code, gfc_omp_clauses *clauses)\n     }\n   stmt = gfc_finish_block (&body);\n \n-  stmt = build3_v (OMP_SECTIONS, stmt, omp_clauses, NULL_TREE);\n+  stmt = build2 (OMP_SECTIONS, void_type_node, stmt, omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n \n   return gfc_finish_block (&block);\n@@ -1522,16 +1522,13 @@ static tree\n gfc_trans_omp_task (gfc_code *code)\n {\n   stmtblock_t block;\n-  tree stmt, body_stmt, omp_clauses;\n+  tree stmt, omp_clauses;\n \n   gfc_start_block (&block);\n   omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n \t\t\t\t       code->loc);\n-  body_stmt = gfc_trans_omp_code (code->block->next, true);\n-  stmt = make_node (OMP_TASK);\n-  TREE_TYPE (stmt) = void_type_node;\n-  OMP_TASK_CLAUSES (stmt) = omp_clauses;\n-  OMP_TASK_BODY (stmt) = body_stmt;\n+  stmt = gfc_trans_omp_code (code->block->next, true);\n+  stmt = build2 (OMP_TASK, void_type_node, stmt, omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }"}, {"sha": "bf4305ba9c356776fb4f1f0b66c8e28e21239008", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n@@ -127,8 +127,8 @@ gfc_trans_label_assign (gfc_code * code)\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n     }\n \n-  gfc_add_modify_expr (&se.pre, len, len_tree);\n-  gfc_add_modify_expr (&se.pre, addr, label_tree);\n+  gfc_add_modify (&se.pre, len, len_tree);\n+  gfc_add_modify (&se.pre, addr, label_tree);\n \n   return gfc_finish_block (&se.pre);\n }\n@@ -271,9 +271,9 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t\t\t\t\t      &tmp_loop, info, tmp,\n \t\t\t\t\t      false, true, false,\n \t\t\t\t\t     & arg->expr->where);\n-\t  gfc_add_modify_expr (&se->pre, size, tmp);\n+\t  gfc_add_modify (&se->pre, size, tmp);\n \t  tmp = fold_convert (pvoid_type_node, info->data);\n-\t  gfc_add_modify_expr (&se->pre, data, tmp);\n+\t  gfc_add_modify (&se->pre, data, tmp);\n \t  gfc_merge_block_scope (&block);\n \n \t  /* Obtain the argument descriptor for unpacking.  */\n@@ -294,7 +294,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t\t\t\t\t  offset, tmp);\n \t    }\n \t  info->offset = gfc_create_var (gfc_array_index_type, NULL);\t  \n-\t  gfc_add_modify_expr (&se->pre, info->offset, offset);\n+\t  gfc_add_modify (&se->pre, info->offset, offset);\n \n \t  /* Copy the result back using unpack.  */\n \t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, parmse.expr, data);\n@@ -349,7 +349,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n \t  se.expr = convert (gfc_typenode_for_spec (&sym->ts), se.expr);\n \t  if (sym->backend_decl == NULL)\n \t    sym->backend_decl = gfc_get_symbol_decl (sym);\n-\t  gfc_add_modify_expr (&se.pre, sym->backend_decl, se.expr);\n+\t  gfc_add_modify (&se.pre, sym->backend_decl, se.expr);\n \t}\n       else\n \tgfc_add_expr_to_block (&se.pre, se.expr);\n@@ -734,7 +734,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   type = TREE_TYPE (dovar);\n \n   /* Initialize the DO variable: dovar = from.  */\n-  gfc_add_modify_expr (pblock, dovar, from);\n+  gfc_add_modify (pblock, dovar, from);\n \n   /* Cycle and exit statements are implemented with gotos.  */\n   cycle_label = gfc_build_label_decl (NULL_TREE);\n@@ -763,7 +763,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \n   /* Increment the loop variable.  */\n   tmp = fold_build2 (PLUS_EXPR, type, dovar, step);\n-  gfc_add_modify_expr (&body, dovar, tmp);\n+  gfc_add_modify (&body, dovar, tmp);\n \n   /* The loop exit.  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n@@ -911,15 +911,15 @@ gfc_trans_do (gfc_code * code)\n       tmp = fold_build1 (FIX_TRUNC_EXPR, utype, tmp);\n     }\n   countm1 = gfc_create_var (utype, \"countm1\");\n-  gfc_add_modify_expr (&block, countm1, tmp);\n+  gfc_add_modify (&block, countm1, tmp);\n \n   /* Cycle and exit statements are implemented with gotos.  */\n   cycle_label = gfc_build_label_decl (NULL_TREE);\n   exit_label = gfc_build_label_decl (NULL_TREE);\n   TREE_USED (exit_label) = 1;\n \n   /* Initialize the DO variable: dovar = from.  */\n-  gfc_add_modify_expr (&block, dovar, from);\n+  gfc_add_modify (&block, dovar, from);\n \n   /* If the loop is empty, go directly to the exit label.  */\n   tmp = fold_build3 (COND_EXPR, void_type_node, empty,\n@@ -949,7 +949,7 @@ gfc_trans_do (gfc_code * code)\n \n   /* Increment the loop variable.  */\n   tmp = fold_build2 (PLUS_EXPR, type, dovar, step);\n-  gfc_add_modify_expr (&body, dovar, tmp);\n+  gfc_add_modify (&body, dovar, tmp);\n \n   /* End with the loop condition.  Loop until countm1 == 0.  */\n   cond = fold_build2 (EQ_EXPR, boolean_type_node, countm1,\n@@ -961,7 +961,7 @@ gfc_trans_do (gfc_code * code)\n \n   /* Decrement the loop count.  */\n   tmp = fold_build2 (MINUS_EXPR, utype, countm1, build_int_cst (utype, 1));\n-  gfc_add_modify_expr (&body, countm1, tmp);\n+  gfc_add_modify (&body, countm1, tmp);\n \n   /* End of loop body.  */\n   tmp = gfc_finish_block (&body);\n@@ -1479,7 +1479,7 @@ gfc_trans_character_select (gfc_code *code)\n   tmp = build_call_expr (fndecl, 4, init, build_int_cst (NULL_TREE, n),\n \t\t\t se.expr, se.string_length);\n   case_num = gfc_create_var (integer_type_node, \"case_num\");\n-  gfc_add_modify_expr (&block, case_num, tmp);\n+  gfc_add_modify (&block, case_num, tmp);\n \n   gfc_add_block_to_block (&block, &se.post);\n \n@@ -1609,7 +1609,7 @@ forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n \t{\n \t  /* Use the variable offset for the temporary.  */\n \t  tmp = gfc_conv_descriptor_offset (tse.expr);\n-\t  gfc_add_modify_expr (pre, tmp,\n+\t  gfc_add_modify (pre, tmp,\n \t\tgfc_conv_array_offset (old_sym->backend_decl));\n \t}\n     }\n@@ -1765,7 +1765,7 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n \n   /* Initialize the mask index outside the FORALL nest.  */\n   if (mask_flag && forall_tmp->mask)\n-    gfc_add_modify_expr (outer, forall_tmp->maskindex, gfc_index_zero_node);\n+    gfc_add_modify (outer, forall_tmp->maskindex, gfc_index_zero_node);\n \n   iter = forall_tmp->this_loop;\n   nvar = forall_tmp->nvar;\n@@ -1798,7 +1798,7 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n \n       /* Increment the loop variable.  */\n       tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), var, step);\n-      gfc_add_modify_expr (&block, var, tmp);\n+      gfc_add_modify (&block, var, tmp);\n \n       /* Advance to the next mask element.  Only do this for the\n \t innermost loop.  */\n@@ -1807,26 +1807,26 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n \t  tree maskindex = forall_tmp->maskindex;\n \t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     maskindex, gfc_index_one_node);\n-\t  gfc_add_modify_expr (&block, maskindex, tmp);\n+\t  gfc_add_modify (&block, maskindex, tmp);\n \t}\n \n       /* Decrement the loop counter.  */\n       tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), count,\n \t\t\t build_int_cst (TREE_TYPE (var), 1));\n-      gfc_add_modify_expr (&block, count, tmp);\n+      gfc_add_modify (&block, count, tmp);\n \n       body = gfc_finish_block (&block);\n \n       /* Loop var initialization.  */\n       gfc_init_block (&block);\n-      gfc_add_modify_expr (&block, var, start);\n+      gfc_add_modify (&block, var, start);\n \n \n       /* Initialize the loop counter.  */\n       tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), step, start);\n       tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), end, tmp);\n       tmp = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (var), tmp, step);\n-      gfc_add_modify_expr (&block, count, tmp);\n+      gfc_add_modify (&block, count, tmp);\n \n       /* The loop expression.  */\n       tmp = build1_v (LOOP_EXPR, body);\n@@ -1918,7 +1918,7 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n       *pdata = convert (pvoid_type_node, tmpvar);\n \n       tmp = gfc_call_malloc (pblock, TREE_TYPE (tmpvar), bytesize);\n-      gfc_add_modify_expr (pblock, tmpvar, tmp);\n+      gfc_add_modify (pblock, tmpvar, tmp);\n     }\n   return tmpvar;\n }\n@@ -1954,13 +1954,13 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n \n       /* Use the scalar assignment as is.  */\n       gfc_add_block_to_block (&block, &lse.pre);\n-      gfc_add_modify_expr (&block, lse.expr, tmp);\n+      gfc_add_modify (&block, lse.expr, tmp);\n       gfc_add_block_to_block (&block, &lse.post);\n \n       /* Increment the count1.  */\n       tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1,\n \t\t\t gfc_index_one_node);\n-      gfc_add_modify_expr (&block, count1, tmp);\n+      gfc_add_modify (&block, count1, tmp);\n \n       tmp = gfc_finish_block (&block);\n     }\n@@ -2016,14 +2016,14 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n       /* Increment count1.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count1, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count1, tmp);\n+      gfc_add_modify (&body, count1, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n \t{\n \t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count3, gfc_index_one_node);\n-\t  gfc_add_modify_expr (&body, count3, tmp);\n+\t  gfc_add_modify (&body, count3, tmp);\n \t}\n \n       /* Generate the copying loops.  */\n@@ -2117,21 +2117,21 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n       /* Increment count1.  */\n       tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1,\n \t\t\t gfc_index_one_node);\n-      gfc_add_modify_expr (&block, count1, tmp);\n+      gfc_add_modify (&block, count1, tmp);\n     }\n   else\n     {\n       /* Increment count1.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count1, gfc_index_one_node);\n-      gfc_add_modify_expr (&body1, count1, tmp);\n+      gfc_add_modify (&body1, count1, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n \t{\n \t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count3, gfc_index_one_node);\n-\t  gfc_add_modify_expr (&body1, count3, tmp);\n+\t  gfc_add_modify (&body1, count3, tmp);\n \t}\n \n       /* Generate the copying loops.  */\n@@ -2257,7 +2257,7 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \n   /* Otherwise, create a temporary variable to compute the result.  */\n   number = gfc_create_var (gfc_array_index_type, \"num\");\n-  gfc_add_modify_expr (block, number, gfc_index_zero_node);\n+  gfc_add_modify (block, number, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n   if (inner_size_body)\n@@ -2267,7 +2267,7 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \t\t       number, inner_size);\n   else\n     tmp = inner_size;\n-  gfc_add_modify_expr (&body, number, tmp);\n+  gfc_add_modify (&body, number, tmp);\n   tmp = gfc_finish_block (&body);\n \n   /* Generate loops.  */\n@@ -2378,13 +2378,13 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   if (wheremask)\n     {\n       count = gfc_create_var (gfc_array_index_type, \"count\");\n-      gfc_add_modify_expr (block, count, gfc_index_zero_node);\n+      gfc_add_modify (block, count, gfc_index_zero_node);\n     }\n   else\n     count = NULL;\n \n   /* Initialize count1.  */\n-  gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n+  gfc_add_modify (block, count1, gfc_index_zero_node);\n \n   /* Calculate the size of temporary needed in the assignment. Return loop, lss\n      and rss which are used in function generate_loop_for_rhs_to_temp().  */\n@@ -2423,11 +2423,11 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Reset count1.  */\n-  gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n+  gfc_add_modify (block, count1, gfc_index_zero_node);\n \n   /* Reset count.  */\n   if (wheremask)\n-    gfc_add_modify_expr (block, count, gfc_index_zero_node);\n+    gfc_add_modify (block, count, gfc_index_zero_node);\n \n   /* Generate codes to copy the temporary to lhs.  */\n   tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, count, count1,\n@@ -2469,7 +2469,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   tree tmp, tmp1, ptemp1;\n \n   count = gfc_create_var (gfc_array_index_type, \"count\");\n-  gfc_add_modify_expr (block, count, gfc_index_zero_node);\n+  gfc_add_modify (block, count, gfc_index_zero_node);\n \n   inner_size = integer_one_node;\n   lss = gfc_walk_expr (expr1);\n@@ -2490,14 +2490,14 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       rse.want_pointer = 1;\n       gfc_conv_expr (&rse, expr2);\n       gfc_add_block_to_block (&body, &rse.pre);\n-      gfc_add_modify_expr (&body, lse.expr,\n+      gfc_add_modify (&body, lse.expr,\n \t\t\t   fold_convert (TREE_TYPE (lse.expr), rse.expr));\n       gfc_add_block_to_block (&body, &rse.post);\n \n       /* Increment count.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count, tmp);\n+      gfc_add_modify (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n \n@@ -2507,7 +2507,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_expr_to_block (block, tmp);\n \n       /* Reset count.  */\n-      gfc_add_modify_expr (block, count, gfc_index_zero_node);\n+      gfc_add_modify (block, count, gfc_index_zero_node);\n \n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n@@ -2516,12 +2516,12 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       lse.want_pointer = 1;\n       gfc_conv_expr (&lse, expr1);\n       gfc_add_block_to_block (&body, &lse.pre);\n-      gfc_add_modify_expr (&body, lse.expr, rse.expr);\n+      gfc_add_modify (&body, lse.expr, rse.expr);\n       gfc_add_block_to_block (&body, &lse.post);\n       /* Increment count.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count, tmp);\n+      gfc_add_modify (&body, count, tmp);\n       tmp = gfc_finish_block (&body);\n \n       /* Generate body and loops according to the information in\n@@ -2566,7 +2566,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       /* Increment count.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count, tmp);\n+      gfc_add_modify (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n \n@@ -2576,21 +2576,21 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_expr_to_block (block, tmp);\n \n       /* Reset count.  */\n-      gfc_add_modify_expr (block, count, gfc_index_zero_node);\n+      gfc_add_modify (block, count, gfc_index_zero_node);\n \n       parm = gfc_build_array_ref (tmp1, count, NULL);\n       lss = gfc_walk_expr (expr1);\n       gfc_init_se (&lse, NULL);\n       gfc_conv_expr_descriptor (&lse, expr1, lss);\n-      gfc_add_modify_expr (&lse.pre, lse.expr, parm);\n+      gfc_add_modify (&lse.pre, lse.expr, parm);\n       gfc_start_block (&body);\n       gfc_add_block_to_block (&body, &lse.pre);\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count, tmp);\n+      gfc_add_modify (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n \n@@ -2822,7 +2822,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       /* As the mask array can be very big, prefer compact boolean types.  */\n       tree mask_type = gfc_get_logical_type (gfc_logical_kinds[0].kind);\n \n-      gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n+      gfc_add_modify (&block, maskindex, gfc_index_zero_node);\n \n       /* Start of mask assignment loop body.  */\n       gfc_start_block (&body);\n@@ -2836,12 +2836,12 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       se.expr = convert (mask_type, se.expr);\n \n       tmp = gfc_build_array_ref (mask, maskindex, NULL);\n-      gfc_add_modify_expr (&body, tmp, se.expr);\n+      gfc_add_modify (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t maskindex, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, maskindex, tmp);\n+      gfc_add_modify (&body, maskindex, tmp);\n \n       /* Generate the loops.  */\n       tmp = gfc_finish_block (&body);\n@@ -2999,7 +2999,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   /* Variable to index the temporary.  */\n   count = gfc_create_var (gfc_array_index_type, \"count\");\n   /* Initialize count.  */\n-  gfc_add_modify_expr (block, count, gfc_index_zero_node);\n+  gfc_add_modify (block, count, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n \n@@ -3041,14 +3041,14 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   gfc_add_block_to_block (&body1, &lse.pre);\n   gfc_add_block_to_block (&body1, &rse.pre);\n \n-  gfc_add_modify_expr (&body1, cond, fold_convert (mask_type, rse.expr));\n+  gfc_add_modify (&body1, cond, fold_convert (mask_type, rse.expr));\n \n   if (mask && (cmask || pmask))\n     {\n       tmp = gfc_build_array_ref (mask, count, NULL);\n       if (invert)\n \ttmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, tmp);\n-      gfc_add_modify_expr (&body1, mtmp, tmp);\n+      gfc_add_modify (&body1, mtmp, tmp);\n     }\n \n   if (cmask)\n@@ -3057,7 +3057,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       tmp = cond;\n       if (mask)\n \ttmp = fold_build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n-      gfc_add_modify_expr (&body1, tmp1, tmp);\n+      gfc_add_modify (&body1, tmp1, tmp);\n     }\n \n   if (pmask)\n@@ -3066,7 +3066,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       tmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, cond);\n       if (mask)\n \ttmp = fold_build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n-      gfc_add_modify_expr (&body1, tmp1, tmp);\n+      gfc_add_modify (&body1, tmp1, tmp);\n     }\n \n   gfc_add_block_to_block (&body1, &lse.post);\n@@ -3081,7 +3081,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       /* Increment count.  */\n       tmp1 = fold_build2 (PLUS_EXPR, gfc_array_index_type, count,\n                           gfc_index_one_node);\n-      gfc_add_modify_expr (&body1, count, tmp1);\n+      gfc_add_modify (&body1, count, tmp1);\n \n       /* Generate the copying loops.  */\n       gfc_trans_scalarizing_loops (&loop, &body1);\n@@ -3242,7 +3242,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n       /* Increment count1.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t count1, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count1, tmp);\n+      gfc_add_modify (&body, count1, tmp);\n \n       /* Use the scalar assignment as is.  */\n       gfc_add_block_to_block (&block, &body);\n@@ -3258,7 +3258,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n              expression.  */\n           tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count1, gfc_index_one_node);\n-          gfc_add_modify_expr (&body, count1, tmp);\n+          gfc_add_modify (&body, count1, tmp);\n           gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n           /* We need to copy the temporary to the actual lhs.  */\n@@ -3292,14 +3292,14 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n           /* Increment count2.  */\n           tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count2, gfc_index_one_node);\n-          gfc_add_modify_expr (&body, count2, tmp);\n+          gfc_add_modify (&body, count2, tmp);\n         }\n       else\n         {\n           /* Increment count1.  */\n           tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count1, gfc_index_one_node);\n-          gfc_add_modify_expr (&body, count1, tmp);\n+          gfc_add_modify (&body, count1, tmp);\n         }\n \n       /* Generate the copying loops.  */\n@@ -3492,8 +3492,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n                       /* Variables to control maskexpr.  */\n                       count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n                       count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n-                      gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n-                      gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n+                      gfc_add_modify (block, count1, gfc_index_zero_node);\n+                      gfc_add_modify (block, count2, gfc_index_zero_node);\n \n                       tmp = gfc_trans_where_assign (expr1, expr2,\n \t\t\t\t\t\t    cmask, invert,\n@@ -3510,8 +3510,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n                   /* Variables to control maskexpr.  */\n                   count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n                   count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n-                  gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n-                  gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n+                  gfc_add_modify (block, count1, gfc_index_zero_node);\n+                  gfc_add_modify (block, count2, gfc_index_zero_node);\n \n                   tmp = gfc_trans_where_assign (expr1, expr2,\n \t\t\t\t\t\tcmask, invert,\n@@ -3893,7 +3893,7 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_lhs (&se, code->expr);\n       tmp = convert (TREE_TYPE (se.expr), stat);\n-      gfc_add_modify_expr (&block, se.expr, tmp);\n+      gfc_add_modify (&block, se.expr, tmp);\n     }\n \n   return gfc_finish_block (&block);\n@@ -3942,7 +3942,7 @@ gfc_trans_deallocate (gfc_code * code)\n       apstat = build_fold_addr_expr (astat);\n \n       /* Initialize astat to 0.  */\n-      gfc_add_modify_expr (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n+      gfc_add_modify (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n     }\n   else\n     pstat = apstat = stat = astat = NULL_TREE;\n@@ -3997,7 +3997,7 @@ gfc_trans_deallocate (gfc_code * code)\n       if (code->expr)\n \t{\n \t  apstat = fold_build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n-\t  gfc_add_modify_expr (&se.pre, astat, apstat);\n+\t  gfc_add_modify (&se.pre, astat, apstat);\n \t}\n \n       tmp = gfc_finish_block (&se.pre);\n@@ -4011,7 +4011,7 @@ gfc_trans_deallocate (gfc_code * code)\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_lhs (&se, code->expr);\n       tmp = convert (TREE_TYPE (se.expr), astat);\n-      gfc_add_modify_expr (&block, se.expr, tmp);\n+      gfc_add_modify (&block, se.expr, tmp);\n     }\n \n   return gfc_finish_block (&block);"}, {"sha": "911e379001a27cf1ecddb3086966fd3b453bbd0b", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -23,7 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"defaults.h\"\n@@ -142,19 +143,18 @@ gfc_evaluate_now (tree expr, stmtblock_t * pblock)\n     return expr;\n \n   var = gfc_create_var (TREE_TYPE (expr), NULL);\n-  gfc_add_modify_expr (pblock, var, expr);\n+  gfc_add_modify (pblock, var, expr);\n \n   return var;\n }\n \n \n-/* Build a MODIFY_EXPR (or GIMPLE_MODIFY_STMT) node and add it to a\n-   given statement block PBLOCK.  A MODIFY_EXPR is an assignment:\n+/* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.  \n+   A MODIFY_EXPR is an assignment:\n    LHS <- RHS.  */\n \n void\n-gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs,\n-\t\tbool tuples_p)\n+gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs)\n {\n   tree tmp;\n \n@@ -167,8 +167,7 @@ gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs,\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n-  tmp = fold_build2 (tuples_p ? GIMPLE_MODIFY_STMT : MODIFY_EXPR,\n-\t\t     void_type_node, lhs, rhs);\n+  tmp = fold_build2 (MODIFY_EXPR, void_type_node, lhs, rhs);\n   gfc_add_expr_to_block (pblock, tmp);\n }\n \n@@ -434,7 +433,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n   gfc_add_expr_to_block (&block, tmp);\n \n   if (once)\n-    gfc_add_modify_expr (&block, tmpvar, boolean_false_node);\n+    gfc_add_modify (&block, tmpvar, boolean_false_node);\n \n   body = gfc_finish_block (&block);\n \n@@ -495,7 +494,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   size = fold_build2 (MAX_EXPR, size_type_node, size,\n \t\t      build_int_cst (size_type_node, 1));\n \n-  gfc_add_modify_expr (&block2, res,\n+  gfc_add_modify (&block2, res,\n \t\t       build_call_expr (built_in_decls[BUILT_IN_MALLOC], 1,\n \t\t       size));\n   null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n@@ -593,10 +592,10 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n       stmtblock_t set_status_block;\n \n       gfc_start_block (&set_status_block);\n-      gfc_add_modify_expr (&set_status_block,\n+      gfc_add_modify (&set_status_block,\n \t\t\t   fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n-      gfc_add_modify_expr (&set_status_block, res,\n+      gfc_add_modify (&set_status_block, res,\n \t\t\t   build_int_cst (pvoid_type_node, 0));\n \n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n@@ -607,7 +606,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \n   /* The allocation itself.  */\n   gfc_start_block (&alloc_block);\n-  gfc_add_modify_expr (&alloc_block, res,\n+  gfc_add_modify (&alloc_block, res,\n \t\t       build_call_expr (built_in_decls[BUILT_IN_MALLOC], 1,\n \t\t\t\t\tfold_build2 (MAX_EXPR, size_type_node,\n \t\t\t\t\t\t     size,\n@@ -689,7 +688,7 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n   /* If mem is NULL, we call gfc_allocate_with_status.  */\n   gfc_start_block (&alloc_block);\n   tmp = gfc_allocate_with_status (&alloc_block, size, status);\n-  gfc_add_modify_expr (&alloc_block, res, fold_convert (type, tmp));\n+  gfc_add_modify (&alloc_block, res, fold_convert (type, tmp));\n   alloc = gfc_finish_block (&alloc_block);\n \n   /* Otherwise, we issue a runtime error or set the status variable.  */\n@@ -708,9 +707,9 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n       gfc_add_expr_to_block (&set_status_block, tmp);\n \n       tmp = gfc_allocate_with_status (&set_status_block, size, status);\n-      gfc_add_modify_expr (&set_status_block, res, fold_convert (type, tmp));\n+      gfc_add_modify (&set_status_block, res, fold_convert (type, tmp));\n \n-      gfc_add_modify_expr (&set_status_block,\n+      gfc_add_modify (&set_status_block,\n \t\t\t   fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n \n@@ -885,7 +884,7 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n   /* Call realloc and check the result.  */\n   tmp = build_call_expr (built_in_decls[BUILT_IN_REALLOC], 2,\n \t\t\t fold_convert (pvoid_type_node, mem), size);\n-  gfc_add_modify_expr (block, res, fold_convert (type, tmp));\n+  gfc_add_modify (block, res, fold_convert (type, tmp));\n   null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n \t\t\t     build_int_cst (pvoid_type_node, 0));\n   nonzero = fold_build2 (NE_EXPR, boolean_type_node, size,\n@@ -985,7 +984,7 @@ gfc_trans_code (gfc_code * code)\n \n   gfc_start_block (&block);\n \n-  /* Translate statements one by one to GIMPLE trees until we reach\n+  /* Translate statements one by one into GENERIC trees until we reach\n      the end of this gfc_code branch.  */\n   for (; code; code = code->next)\n     {\n@@ -1173,7 +1172,7 @@ gfc_trans_code (gfc_code * code)\n       if (res != NULL_TREE && ! IS_EMPTY_STMT (res))\n \t{\n \t  if (TREE_CODE (res) == STATEMENT_LIST)\n-\t    annotate_all_with_locus (&res, input_location);\n+\t    tree_annotate_all_with_location (&res, input_location);\n \t  else\n \t    SET_EXPR_LOCATION (res, input_location);\n \t    "}, {"sha": "6e09f24ac95164ead3ce6abdd2393327ce97bcd2", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -348,12 +348,8 @@ void gfc_trans_vla_type_sizes (gfc_symbol *, stmtblock_t *);\n void gfc_add_expr_to_block (stmtblock_t *, tree);\n /* Add a block to the end of a block.  */\n void gfc_add_block_to_block (stmtblock_t *, stmtblock_t *);\n-/* Add a MODIFY_EXPR or a GIMPLE_MODIFY_STMT to a block.  */\n-void gfc_add_modify (stmtblock_t *, tree, tree, bool);\n-#define gfc_add_modify_expr(BLOCK, LHS, RHS) \\\n-       gfc_add_modify ((BLOCK), (LHS), (RHS), false)\n-#define gfc_add_modify_stmt(BLOCK, LHS, RHS) \\\n-       gfc_add_modify ((BLOCK), (LHS), (RHS), true)\n+/* Add a MODIFY_EXPR to a block.  */\n+void gfc_add_modify (stmtblock_t *, tree, tree);\n \n /* Initialize a statement block.  */\n void gfc_init_block (stmtblock_t *);"}, {"sha": "532a94f34c484be86e49a8450979486e7bc1fa7d", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -59,7 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"cfglayout.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-pass.h\"\n #include \"predict.h\"\n #include \"df.h\"\n@@ -1547,7 +1547,7 @@ static tree\n instantiate_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   tree t = *tp;\n-  if (! EXPR_P (t) && ! GIMPLE_STMT_P (t))\n+  if (! EXPR_P (t))\n     {\n       *walk_subtrees = 0;\n       if (DECL_P (t) && DECL_RTL_SET_P (t))\n@@ -3092,7 +3092,7 @@ gimplify_parm_type (tree *tp, int *walk_subtrees, void *data)\n       else if (TYPE_SIZE (t) && !TREE_CONSTANT (TYPE_SIZE (t))\n \t       && !TYPE_SIZES_GIMPLIFIED (t))\n \t{\n-\t  gimplify_type_sizes (t, (tree *) data);\n+\t  gimplify_type_sizes (t, (gimple_seq *) data);\n \t  *walk_subtrees = 1;\n \t}\n     }\n@@ -3102,15 +3102,15 @@ gimplify_parm_type (tree *tp, int *walk_subtrees, void *data)\n \n /* Gimplify the parameter list for current_function_decl.  This involves\n    evaluating SAVE_EXPRs of variable sized parameters and generating code\n-   to implement callee-copies reference parameters.  Returns a list of\n-   statements to add to the beginning of the function, or NULL if nothing\n-   to do.  */\n+   to implement callee-copies reference parameters.  Returns a sequence of\n+   statements to add to the beginning of the function.  */\n \n-tree\n+gimple_seq\n gimplify_parameters (void)\n {\n   struct assign_parm_data_all all;\n-  tree fnargs, parm, stmts = NULL;\n+  tree fnargs, parm;\n+  gimple_seq stmts = NULL;\n \n   assign_parms_initialize_all (&all);\n   fnargs = assign_parms_augmented_arg_list (&all);\n@@ -3170,12 +3170,11 @@ gimplify_parameters (void)\n \t\t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (parm));\n \t\t  t = fold_convert (ptr_type, t);\n-\t\t  t = build_gimple_modify_stmt (addr, t);\n+\t\t  t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n \t\t  gimplify_and_add (t, &stmts);\n \t\t}\n \n-\t      t = build_gimple_modify_stmt (local, parm);\n-\t      gimplify_and_add (t, &stmts);\n+\t      gimplify_assign (local, parm, &stmts);\n \n \t      SET_DECL_VALUE_EXPR (parm, local);\n \t      DECL_HAS_VALUE_EXPR_P (parm) = 1;"}, {"sha": "9de018100d98684b5b8c02fe40cae6b193be9ece", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -428,6 +428,10 @@ struct function GTY(())\n \n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n+\n+  /* GIMPLE body for this function.  */\n+  struct gimple_seq_d *gimple_body;\n+\n   /* SSA and dataflow information.  */\n   struct gimple_df *gimple_df;\n "}, {"sha": "adc355a3881840fb2601e2a917fba5edd14c190c", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1537,7 +1537,7 @@ open_base_files (void)\n       \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n-      \"cfglayout.h\", \"except.h\", \"output.h\", \"cfgloop.h\", NULL\n+      \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "0afe0d815dd233757f340a249a3c5a77846297d6", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -172,7 +172,6 @@ along with GCC; see the file COPYING3.  If not see\n    thing you need to do to add a new special allocation size.  */\n \n static const size_t extra_order_size_table[] = {\n-  sizeof (struct stmt_ann_d),\n   sizeof (struct var_ann_d),\n   sizeof (struct tree_decl_non_common),\n   sizeof (struct tree_field_decl),\n@@ -184,9 +183,6 @@ static const size_t extra_order_size_table[] = {\n   sizeof (struct basic_block_def),\n   sizeof (bitmap_element),\n   sizeof (bitmap_head),\n-  /* PHI nodes with one to three arguments are already covered by the\n-     above sizes.  */\n-  sizeof (struct tree_phi_node) + sizeof (struct phi_arg_d) * 3,\n   TREE_EXP_SIZE (2),\n   RTL_SIZE (2),\t\t\t/* MEM, PLUS, etc.  */\n   RTL_SIZE (9),\t\t\t/* INSN */"}, {"sha": "a52c83072b44c950eadb5c3ea570702a70cbe1b0", "filename": "gcc/gimple-iterator.c", "status": "added", "additions": 771, "deletions": 0, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -0,0 +1,771 @@\n+/* Iterator routines for GIMPLE statements.\n+   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez  <aldy@quesejoda.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-flow.h\"\n+#include \"value-prof.h\"\n+\n+\n+/* Mark the statement STMT as modified, and update it.  */\n+\n+static inline void\n+update_modified_stmt (gimple stmt)\n+{\n+  if (!ssa_operands_active ())\n+    return;\n+  update_stmt_if_modified (stmt);\n+}\n+\n+\n+/* Mark the statements in SEQ as modified, and update them.  */\n+\n+static void\n+update_modified_stmts (gimple_seq seq)\n+{\n+  gimple_stmt_iterator gsi;\n+ \n+  if (!ssa_operands_active ())\n+    return;  \n+  for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n+    update_stmt_if_modified (gsi_stmt (gsi));\n+}\n+\n+\n+/* Set BB to be the basic block for all the statements in the list\n+   starting at FIRST and LAST.  */\n+\n+static void\n+update_bb_for_stmts (gimple_seq_node first, basic_block bb)\n+{\n+  gimple_seq_node n;\n+  \n+  for (n = first; n; n = n->next)\n+    gimple_set_bb (n->stmt, bb);\n+}\n+\n+\n+/* Insert the sequence delimited by nodes FIRST and LAST before\n+   iterator I.  M specifies how to update iterator I after insertion\n+   (see enum gsi_iterator_update).\n+\n+   This routine assumes that there is a forward and backward path\n+   between FIRST and LAST (i.e., they are linked in a doubly-linked\n+   list).  Additionally, if FIRST == LAST, this routine will properly\n+   insert a single node.  */\n+\n+static void\n+gsi_insert_seq_nodes_before (gimple_stmt_iterator *i,\n+\t\t\t     gimple_seq_node first,\n+\t\t\t     gimple_seq_node last,\n+\t\t\t     enum gsi_iterator_update mode)\n+{\n+  basic_block bb;\n+  gimple_seq_node cur = i->ptr;\n+\n+  if ((bb = gsi_bb (*i)) != NULL)\n+    update_bb_for_stmts (first, bb);\n+\n+  /* Link SEQ before CUR in the sequence.  */\n+  if (cur)\n+    {\n+      first->prev = cur->prev;\n+      if (first->prev)\n+\tfirst->prev->next = first;\n+      else\n+\tgimple_seq_set_first (i->seq, first);\n+      last->next = cur;\n+      cur->prev = last;\n+    }\n+  else\n+    {\n+      gimple_seq_node itlast = gimple_seq_last (i->seq);\n+\n+      /* If CUR is NULL, we link at the end of the sequence (this case happens\n+\t when gsi_after_labels is called for a basic block that contains only\n+\t labels, so it returns an iterator after the end of the block, and\n+\t we need to insert before it; it might be cleaner to add a flag to the\n+\t iterator saying whether we are at the start or end of the list).  */\n+      first->prev = itlast;\n+      if (itlast)\n+\titlast->next = first;\n+      else\n+\tgimple_seq_set_first (i->seq, first);\n+      gimple_seq_set_last (i->seq, last);\n+    }\n+\n+  /* Update the iterator, if requested.  */\n+  switch (mode)\n+    {\n+    case GSI_NEW_STMT:\n+    case GSI_CONTINUE_LINKING:\n+      i->ptr = first;\n+      break;\n+    case GSI_SAME_STMT:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Inserts the sequence of statements SEQ before the statement pointed\n+   by iterator I.  MODE indicates what to do with the iterator after\n+   insertion (see enum gsi_iterator_update).\n+\n+   This function does not scan for new operands.  It is provided for\n+   the use of the gimplifier, which manipulates statements for which\n+   def/use information has not yet been constructed.  Most callers\n+   should use gsi_insert_seq_before.  */\n+\n+void\n+gsi_insert_seq_before_without_update (gimple_stmt_iterator *i, gimple_seq seq,\n+                                      enum gsi_iterator_update mode)\n+{\n+  gimple_seq_node first, last;\n+\n+  if (seq == NULL)\n+    return;\n+\n+  /* Don't allow inserting a sequence into itself.  */\n+  gcc_assert (seq != i->seq);\n+\n+  first = gimple_seq_first (seq);\n+  last = gimple_seq_last (seq);\n+\n+  gimple_seq_set_first (seq, NULL);\n+  gimple_seq_set_last (seq, NULL);\n+  gimple_seq_free (seq);\n+\n+  /* Empty sequences need no work.  */\n+  if (!first || !last)\n+    {\n+      gcc_assert (first == last);\n+      return;\n+    }\n+\n+  gsi_insert_seq_nodes_before (i, first, last, mode);\n+}\n+\n+\n+/* Inserts the sequence of statements SEQ before the statement pointed\n+   by iterator I.  MODE indicates what to do with the iterator after\n+   insertion (see enum gsi_iterator_update). Scan the statements in SEQ\n+   for new operands.  */\n+\n+void\n+gsi_insert_seq_before (gimple_stmt_iterator *i, gimple_seq seq,\n+\t\t       enum gsi_iterator_update mode)\n+{\n+  update_modified_stmts (seq);\n+  gsi_insert_seq_before_without_update (i, seq, mode);\n+}\n+\n+\n+/* Insert the sequence delimited by nodes FIRST and LAST after\n+   iterator I.  M specifies how to update iterator I after insertion\n+   (see enum gsi_iterator_update).\n+\n+   This routine assumes that there is a forward and backward path\n+   between FIRST and LAST (i.e., they are linked in a doubly-linked\n+   list).  Additionally, if FIRST == LAST, this routine will properly\n+   insert a single node.  */\n+\n+static void\n+gsi_insert_seq_nodes_after (gimple_stmt_iterator *i,\n+\t\t\t    gimple_seq_node first,\n+\t\t\t    gimple_seq_node last,\n+\t\t\t    enum gsi_iterator_update m)\n+{\n+  basic_block bb;\n+  gimple_seq_node cur = i->ptr;\n+\n+  /* If the iterator is inside a basic block, we need to update the\n+     basic block information for all the nodes between FIRST and LAST.  */\n+  if ((bb = gsi_bb (*i)) != NULL)\n+    update_bb_for_stmts (first, bb);\n+\n+  /* Link SEQ after CUR.  */\n+  if (cur)\n+    {\n+      last->next = cur->next;\n+      if (last->next)\n+\tlast->next->prev = last;\n+      else\n+\tgimple_seq_set_last (i->seq, last);\n+      first->prev = cur;\n+      cur->next = first;\n+    }\n+  else\n+    {\n+      gcc_assert (!gimple_seq_last (i->seq));\n+      gimple_seq_set_first (i->seq, first);\n+      gimple_seq_set_last (i->seq, last);\n+    }\n+\n+  /* Update the iterator, if requested.  */\n+  switch (m)\n+    {\n+    case GSI_NEW_STMT:\n+      i->ptr = first;\n+      break;\n+    case GSI_CONTINUE_LINKING:\n+      i->ptr = last;\n+      break;\n+    case GSI_SAME_STMT:\n+      gcc_assert (cur);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Links sequence SEQ after the statement pointed-to by iterator I.\n+   MODE is as in gsi_insert_after.\n+\n+   This function does not scan for new operands.  It is provided for\n+   the use of the gimplifier, which manipulates statements for which\n+   def/use information has not yet been constructed.  Most callers\n+   should use gsi_insert_seq_after.  */\n+\n+void\n+gsi_insert_seq_after_without_update (gimple_stmt_iterator *i, gimple_seq seq,\n+                                     enum gsi_iterator_update mode)\n+{\n+  gimple_seq_node first, last;\n+\n+  if (seq == NULL)\n+    return;\n+\n+  /* Don't allow inserting a sequence into itself.  */\n+  gcc_assert (seq != i->seq);\n+\n+  first = gimple_seq_first (seq);\n+  last = gimple_seq_last (seq);\n+\n+  gimple_seq_set_first (seq, NULL);\n+  gimple_seq_set_last (seq, NULL);\n+  gimple_seq_free (seq);\n+\n+  /* Empty sequences need no work.  */\n+  if (!first || !last)\n+    {\n+      gcc_assert (first == last);\n+      return;\n+    }\n+\n+  gsi_insert_seq_nodes_after (i, first, last, mode);\n+}\n+\n+\n+/* Links sequence SEQ after the statement pointed-to by iterator I.\n+   MODE is as in gsi_insert_after.  Scan the statements in SEQ\n+   for new operands.  */\n+\n+void\n+gsi_insert_seq_after (gimple_stmt_iterator *i, gimple_seq seq,\n+\t\t      enum gsi_iterator_update mode)\n+{\n+  update_modified_stmts (seq);\n+  gsi_insert_seq_after_without_update (i, seq, mode);\n+}\n+\n+\n+/* Move all statements in the sequence after I to a new sequence.\n+   Return this new sequence.  */\n+\n+gimple_seq\n+gsi_split_seq_after (gimple_stmt_iterator i)\n+{\n+  gimple_seq_node cur, next;\n+  gimple_seq old_seq, new_seq;\n+\n+  cur = i.ptr;\n+\n+  /* How can we possibly split after the end, or before the beginning?  */\n+  gcc_assert (cur && cur->next);\n+  next = cur->next;\n+\n+  old_seq = i.seq;\n+  new_seq = gimple_seq_alloc ();\n+\n+  gimple_seq_set_first (new_seq, next);\n+  gimple_seq_set_last (new_seq, gimple_seq_last (old_seq));\n+  gimple_seq_set_last (old_seq, cur);\n+  cur->next = NULL;\n+  next->prev = NULL;\n+\n+  return new_seq;\n+}\n+\n+\n+/* Move all statements in the sequence before I to a new sequence.\n+   Return this new sequence.  I is set to the head of the new list.  */\n+\n+gimple_seq\n+gsi_split_seq_before (gimple_stmt_iterator *i)\n+{\n+  gimple_seq_node cur, prev;\n+  gimple_seq old_seq, new_seq;\n+\n+  cur = i->ptr;\n+\n+  /* How can we possibly split after the end?  */\n+  gcc_assert (cur);\n+  prev = cur->prev;\n+\n+  old_seq = i->seq;\n+  new_seq = gimple_seq_alloc ();\n+  i->seq = new_seq;\n+\n+  /* Set the limits on NEW_SEQ.  */\n+  gimple_seq_set_first (new_seq, cur);\n+  gimple_seq_set_last (new_seq, gimple_seq_last (old_seq));\n+\n+  /* Cut OLD_SEQ before I.  */\n+  gimple_seq_set_last (old_seq, prev);\n+  cur->prev = NULL;\n+  if (prev)\n+    prev->next = NULL;\n+  else\n+    gimple_seq_set_first (old_seq, NULL);\n+\n+  return new_seq;\n+}\n+\n+\n+/* Replace the statement pointed-to by GSI to STMT.  If UPDATE_EH_INFO\n+   is true, the exception handling information of the original\n+   statement is moved to the new statement.  */\n+\n+void\n+gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n+{\n+  int eh_region;\n+  gimple orig_stmt = gsi_stmt (*gsi);\n+\n+  if (stmt == orig_stmt)\n+    return;\n+\n+  gimple_set_location (stmt, gimple_location (orig_stmt));\n+  gimple_set_bb (stmt, gsi_bb (*gsi));\n+\n+  /* Preserve EH region information from the original statement, if\n+     requested by the caller.  */\n+  if (update_eh_info)\n+    {\n+      eh_region = lookup_stmt_eh_region (orig_stmt);\n+      if (eh_region >= 0)\n+\t{\n+\t  remove_stmt_from_eh_region (orig_stmt);\n+\t  add_stmt_to_eh_region (stmt, eh_region);\n+\t}\n+    }\n+\n+  gimple_duplicate_stmt_histograms (cfun, stmt, cfun, orig_stmt);\n+  gimple_remove_stmt_histograms (cfun, orig_stmt);\n+  delink_stmt_imm_use (orig_stmt);\n+  *gsi_stmt_ptr (gsi) = stmt;\n+  gimple_set_modified (stmt, true);\n+  update_modified_stmt (stmt);\n+}\n+\n+\n+/* Insert statement STMT before the statement pointed-to by iterator I.\n+   M specifies how to update iterator I after insertion (see enum\n+   gsi_iterator_update).\n+\n+   This function does not scan for new operands.  It is provided for\n+   the use of the gimplifier, which manipulates statements for which\n+   def/use information has not yet been constructed.  Most callers\n+   should use gsi_insert_before.  */\n+\n+void\n+gsi_insert_before_without_update (gimple_stmt_iterator *i, gimple stmt,\n+                                  enum gsi_iterator_update m)\n+{\n+  gimple_seq_node n;\n+\n+  n = GGC_NEW (struct gimple_seq_node_d);\n+  n->prev = n->next = NULL;\n+  n->stmt = stmt;\n+  gsi_insert_seq_nodes_before (i, n, n, m);\n+}\n+\n+/* Insert statement STMT before the statement pointed-to by iterator I.\n+   Update STMT's basic block and scan it for new operands.  M\n+   specifies how to update iterator I after insertion (see enum\n+   gsi_iterator_update).  */\n+\n+void\n+gsi_insert_before (gimple_stmt_iterator *i, gimple stmt,\n+                   enum gsi_iterator_update m)\n+{\n+  update_modified_stmt (stmt);\n+  gsi_insert_before_without_update (i, stmt, m);\n+}\n+\n+\n+/* Insert statement STMT after the statement pointed-to by iterator I.\n+   M specifies how to update iterator I after insertion (see enum\n+   gsi_iterator_update).\n+\n+   This function does not scan for new operands.  It is provided for\n+   the use of the gimplifier, which manipulates statements for which\n+   def/use information has not yet been constructed.  Most callers\n+   should use gsi_insert_after.  */\n+\n+void\n+gsi_insert_after_without_update (gimple_stmt_iterator *i, gimple stmt,\n+                                 enum gsi_iterator_update m)\n+{\n+  gimple_seq_node n;\n+\n+  n = GGC_NEW (struct gimple_seq_node_d);\n+  n->prev = n->next = NULL;\n+  n->stmt = stmt;\n+  gsi_insert_seq_nodes_after (i, n, n, m);\n+}\n+\n+\n+/* Insert statement STMT after the statement pointed-to by iterator I.\n+   Update STMT's basic block and scan it for new operands.  M\n+   specifies how to update iterator I after insertion (see enum\n+   gsi_iterator_update).  */\n+\n+void\n+gsi_insert_after (gimple_stmt_iterator *i, gimple stmt,\n+\t\t  enum gsi_iterator_update m)\n+{\n+  update_modified_stmt (stmt);\n+  gsi_insert_after_without_update (i, stmt, m);\n+}\n+\n+\n+/* Remove the current stmt from the sequence.  The iterator is updated\n+   to point to the next statement.\n+\n+   REMOVE_PERMANENTLY is true when the statement is going to be removed\n+   from the IL and not reinserted elsewhere.  In that case we remove the\n+   statement pointed to by iterator I from the EH tables, and free its\n+   operand caches.  Otherwise we do not modify this information.  */\n+\n+void\n+gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n+{\n+  gimple_seq_node cur, next, prev;\n+  gimple stmt = gsi_stmt (*i);\n+\n+  /* Free all the data flow information for STMT.  */\n+  gimple_set_bb (stmt, NULL);\n+  delink_stmt_imm_use (stmt);\n+  gimple_set_modified (stmt, true);\n+\n+  if (remove_permanently)\n+    {\n+      remove_stmt_from_eh_region (stmt);\n+      gimple_remove_stmt_histograms (cfun, stmt);\n+    }\n+\n+  /* Update the iterator and re-wire the links in I->SEQ.  */\n+  cur = i->ptr;\n+  next = cur->next;\n+  prev = cur->prev;\n+\n+  if (prev)\n+    prev->next = next;\n+  else\n+    gimple_seq_set_first (i->seq, next);\n+\n+  if (next)\n+    next->prev = prev;\n+  else\n+    gimple_seq_set_last (i->seq, prev);\n+\n+  i->ptr = next;\n+}\n+\n+\n+/* Finds iterator for STMT.  */\n+\n+gimple_stmt_iterator\n+gsi_for_stmt (gimple stmt)\n+{\n+  gimple_stmt_iterator i;\n+  basic_block bb = gimple_bb (stmt);\n+\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    i = gsi_start_phis (bb);\n+  else\n+    i = gsi_start_bb (bb);\n+\n+  for (; !gsi_end_p (i); gsi_next (&i))\n+    if (gsi_stmt (i) == stmt)\n+      return i;\n+\n+  gcc_unreachable ();\n+}\n+\n+\n+/* Move the statement at FROM so it comes right after the statement at TO.  */\n+\n+void\n+gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n+{\n+  gimple stmt = gsi_stmt (*from);\n+  gsi_remove (from, false);\n+\n+  /* We must have GSI_NEW_STMT here, as gsi_move_after is sometimes used to\n+     move statements to an empty block.  */\n+  gsi_insert_after (to, stmt, GSI_NEW_STMT);\n+}\n+\n+\n+/* Move the statement at FROM so it comes right before the statement\n+   at TO.  */\n+\n+void\n+gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n+{\n+  gimple stmt = gsi_stmt (*from);\n+  gsi_remove (from, false);\n+\n+  /* For consistency with gsi_move_after, it might be better to have\n+     GSI_NEW_STMT here; however, that breaks several places that expect\n+     that TO does not change.  */\n+  gsi_insert_before (to, stmt, GSI_SAME_STMT);\n+}\n+\n+\n+/* Move the statement at FROM to the end of basic block BB.  */\n+\n+void\n+gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)\n+{\n+  gimple_stmt_iterator last = gsi_last_bb (bb);\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (gsi_bb (last) == bb);\n+#endif\n+\n+  /* Have to check gsi_end_p because it could be an empty block.  */\n+  if (!gsi_end_p (last) && is_ctrl_stmt (gsi_stmt (last)))\n+    gsi_move_before (from, &last);\n+  else\n+    gsi_move_after (from, &last);\n+}\n+\n+\n+/* Add STMT to the pending list of edge E.  No actual insertion is\n+   made until a call to gsi_commit_edge_inserts () is made.  */\n+\n+void\n+gsi_insert_on_edge (edge e, gimple stmt)\n+{\n+  gimple_seq_add_stmt (&PENDING_STMT (e), stmt);\n+}\n+\n+/* Add the sequence of statements SEQ to the pending list of edge E.\n+   No actual insertion is made until a call to gsi_commit_edge_inserts\n+   is made.  */\n+\n+void\n+gsi_insert_seq_on_edge (edge e, gimple_seq seq)\n+{\n+  gimple_seq_add_seq (&PENDING_STMT (e), seq);\n+}\n+\n+\n+/* Insert the statement pointed-to by GSI into edge E.  Every attempt\n+   is made to place the statement in an existing basic block, but\n+   sometimes that isn't possible.  When it isn't possible, the edge is\n+   split and the statement is added to the new block.\n+\n+   In all cases, the returned *GSI points to the correct location.  The\n+   return value is true if insertion should be done after the location,\n+   or false if it should be done before the location.  If new basic block\n+   has to be created, it is stored in *NEW_BB.  */\n+\n+static bool\n+gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n+\t\t\t     basic_block *new_bb)\n+{\n+  basic_block dest, src;\n+  gimple tmp;\n+\n+  dest = e->dest;\n+\n+  /* If the destination has one predecessor which has no PHI nodes,\n+     insert there.  Except for the exit block.\n+\n+     The requirement for no PHI nodes could be relaxed.  Basically we\n+     would have to examine the PHIs to prove that none of them used\n+     the value set by the statement we want to insert on E.  That\n+     hardly seems worth the effort.  */\n+restart:\n+  if (single_pred_p (dest)\n+      && ! phi_nodes (dest)\n+      && dest != EXIT_BLOCK_PTR)\n+    {\n+      *gsi = gsi_start_bb (dest);\n+      if (gsi_end_p (*gsi))\n+\treturn true;\n+\n+      /* Make sure we insert after any leading labels.  */\n+      tmp = gsi_stmt (*gsi);\n+      while (gimple_code (tmp) == GIMPLE_LABEL)\n+\t{\n+\t  gsi_next (gsi);\n+\t  if (gsi_end_p (*gsi))\n+\t    break;\n+\t  tmp = gsi_stmt (*gsi);\n+\t}\n+\n+      if (gsi_end_p (*gsi))\n+\t{\n+\t  *gsi = gsi_last_bb (dest);\n+\t  return true;\n+\t}\n+      else\n+\treturn false;\n+    }\n+\n+  /* If the source has one successor, the edge is not abnormal and\n+     the last statement does not end a basic block, insert there.\n+     Except for the entry block.  */\n+  src = e->src;\n+  if ((e->flags & EDGE_ABNORMAL) == 0\n+      && single_succ_p (src)\n+      && src != ENTRY_BLOCK_PTR)\n+    {\n+      *gsi = gsi_last_bb (src);\n+      if (gsi_end_p (*gsi))\n+\treturn true;\n+\n+      tmp = gsi_stmt (*gsi);\n+      if (!stmt_ends_bb_p (tmp))\n+\treturn true;\n+\n+      if (gimple_code (tmp) == GIMPLE_RETURN)\n+        {\n+\t  gsi_prev (gsi);\n+\t  return true;\n+        }\n+    }\n+\n+  /* Otherwise, create a new basic block, and split this edge.  */\n+  dest = split_edge (e);\n+  if (new_bb)\n+    *new_bb = dest;\n+  e = single_pred_edge (dest);\n+  goto restart;\n+}\n+\n+\n+/* Similar to gsi_insert_on_edge+gsi_commit_edge_inserts.  If a new\n+   block has to be created, it is returned.  */\n+\n+basic_block\n+gsi_insert_on_edge_immediate (edge e, gimple stmt)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block new_bb = NULL;\n+\n+  gcc_assert (!PENDING_STMT (e));\n+\n+  if (gimple_find_edge_insert_loc (e, &gsi, &new_bb))\n+    gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  else\n+    gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n+\n+  return new_bb;\n+}\n+\n+/* Insert STMTS on edge E.  If a new block has to be created, it\n+   is returned.  */\n+\n+basic_block\n+gsi_insert_seq_on_edge_immediate (edge e, gimple_seq stmts)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block new_bb = NULL;\n+\n+  gcc_assert (!PENDING_STMT (e));\n+\n+  if (gimple_find_edge_insert_loc (e, &gsi, &new_bb))\n+    gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n+  else\n+    gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n+\n+  return new_bb;\n+}\n+\n+/* This routine will commit all pending edge insertions, creating any new\n+   basic blocks which are necessary.  */\n+\n+void\n+gsi_commit_edge_inserts (void)\n+{\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+\n+  gsi_commit_one_edge_insert (single_succ_edge (ENTRY_BLOCK_PTR), NULL);\n+\n+  FOR_EACH_BB (bb)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+      gsi_commit_one_edge_insert (e, NULL);\n+}\n+\n+\n+/* Commit insertions pending at edge E. If a new block is created, set NEW_BB\n+   to this block, otherwise set it to NULL.  */\n+\n+void\n+gsi_commit_one_edge_insert (edge e, basic_block *new_bb)\n+{\n+  if (new_bb)\n+    *new_bb = NULL;\n+\n+  if (PENDING_STMT (e))\n+    {\n+      gimple_stmt_iterator gsi;\n+      gimple_seq seq = PENDING_STMT (e);\n+\n+      PENDING_STMT (e) = NULL;\n+\n+      if (gimple_find_edge_insert_loc (e, &gsi, new_bb))\n+\tgsi_insert_seq_after (&gsi, seq, GSI_NEW_STMT);\n+      else\n+\tgsi_insert_seq_before (&gsi, seq, GSI_NEW_STMT);\n+    }\n+}\n+\n+/* Returns iterator at the start of the list of phi nodes of BB.  */\n+\n+gimple_stmt_iterator\n+gsi_start_phis (basic_block bb)\n+{\n+  return gsi_start (phi_nodes (bb));\n+}"}, {"sha": "cc77874b84970c14b39e4697770f9084402a1051", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 320, "deletions": 255, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,4 +1,4 @@\n-/* Tree lowering pass.  Lowers GIMPLE into unstructured form.\n+/* GIMPLE lowering pass.  Converts High GIMPLE into Low GIMPLE.\n \n    Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n@@ -25,7 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"varray.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n #include \"tree-inline.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n@@ -40,76 +41,123 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"tree-pass.h\"\n \n+/* The differences between High GIMPLE and Low GIMPLE are the\n+   following:\n+\n+   1- Lexical scopes are removed (i.e., GIMPLE_BIND disappears).\n+\n+   2- GIMPLE_TRY and GIMPLE_CATCH are converted to abnormal control\n+      flow and exception regions are built as an on-the-side region\n+      hierarchy (See tree-eh.c:lower_eh_constructs).\n+\n+   3- Multiple identical return statements are grouped into a single\n+      return and gotos to the unique return site.  */\n+\n+/* Match a return statement with a label.  During lowering, we identify\n+   identical return statements and replace duplicates with a jump to\n+   the corresponding label.  */\n+struct return_statements_t\n+{\n+  tree label;\n+  gimple stmt;\n+};\n+typedef struct return_statements_t return_statements_t;\n+\n+DEF_VEC_O(return_statements_t);\n+DEF_VEC_ALLOC_O(return_statements_t,heap);\n+\n struct lower_data\n {\n   /* Block the current statement belongs to.  */\n   tree block;\n \n-  /* A TREE_LIST of label and return statements to be moved to the end\n+  /* A vector of label and return statements to be moved to the end\n      of the function.  */\n-  tree return_statements;\n+  VEC(return_statements_t,heap) *return_statements;\n \n   /* True if the function calls __builtin_setjmp.  */\n   bool calls_builtin_setjmp;\n };\n \n-static void lower_stmt (tree_stmt_iterator *, struct lower_data *);\n-static void lower_bind_expr (tree_stmt_iterator *, struct lower_data *);\n-static void lower_cond_expr (tree_stmt_iterator *, struct lower_data *);\n-static void lower_return_expr (tree_stmt_iterator *, struct lower_data *);\n-static void lower_builtin_setjmp (tree_stmt_iterator *);\n+static void lower_stmt (gimple_stmt_iterator *, struct lower_data *);\n+static void lower_gimple_bind (gimple_stmt_iterator *, struct lower_data *);\n+static void lower_gimple_return (gimple_stmt_iterator *, struct lower_data *);\n+static void lower_builtin_setjmp (gimple_stmt_iterator *);\n \n-/* Lower the body of current_function_decl.  */\n+\n+/* Lower the body of current_function_decl from High GIMPLE into Low\n+   GIMPLE.  */\n \n static unsigned int\n lower_function_body (void)\n {\n   struct lower_data data;\n-  tree *body_p = &DECL_SAVED_TREE (current_function_decl);\n-  tree bind = *body_p;\n-  tree_stmt_iterator i;\n-  tree t, x;\n-\n-  gcc_assert (TREE_CODE (bind) == BIND_EXPR);\n+  gimple_seq body = gimple_body (current_function_decl);\n+  gimple_seq lowered_body;\n+  gimple_stmt_iterator i;\n+  gimple bind;\n+  tree t;\n+  gimple x;\n+\n+  /* The gimplifier should've left a body of exactly one statement,\n+     namely a GIMPLE_BIND.  */\n+  gcc_assert (gimple_seq_first (body) == gimple_seq_last (body)\n+\t      && gimple_code (gimple_seq_first_stmt (body)) == GIMPLE_BIND);\n \n   memset (&data, 0, sizeof (data));\n   data.block = DECL_INITIAL (current_function_decl);\n   BLOCK_SUBBLOCKS (data.block) = NULL_TREE;\n   BLOCK_CHAIN (data.block) = NULL_TREE;\n   TREE_ASM_WRITTEN (data.block) = 1;\n+  data.return_statements = VEC_alloc (return_statements_t, heap, 8);\n+\n+  bind = gimple_seq_first_stmt (body);\n+  lowered_body = NULL;\n+  gimple_seq_add_stmt (&lowered_body, bind);\n+  i = gsi_start (lowered_body);\n+  lower_gimple_bind (&i, &data);\n \n-  *body_p = alloc_stmt_list ();\n-  i = tsi_start (*body_p);\n-  tsi_link_after (&i, bind, TSI_NEW_STMT);\n-  lower_bind_expr (&i, &data);\n+  /* Once the old body has been lowered, replace it with the new\n+     lowered sequence.  */\n+  gimple_set_body (current_function_decl, lowered_body);\n \n-  i = tsi_last (*body_p);\n+  i = gsi_last (lowered_body);\n \n   /* If the function falls off the end, we need a null return statement.\n-     If we've already got one in the return_statements list, we don't\n+     If we've already got one in the return_statements vector, we don't\n      need to do anything special.  Otherwise build one by hand.  */\n-  if (block_may_fallthru (*body_p)\n-      && (data.return_statements == NULL\n-          || TREE_OPERAND (TREE_VALUE (data.return_statements), 0) != NULL))\n+  if (gimple_seq_may_fallthru (lowered_body)\n+      && (VEC_empty (return_statements_t, data.return_statements)\n+\t  || gimple_return_retval (VEC_last (return_statements_t,\n+\t\t\t           data.return_statements)->stmt) != NULL))\n     {\n-      x = build1 (RETURN_EXPR, void_type_node, NULL);\n-      SET_EXPR_LOCATION (x, cfun->function_end_locus);\n-      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+      x = gimple_build_return (NULL);\n+      gimple_set_location (x, cfun->function_end_locus);\n+      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n     }\n \n   /* If we lowered any return statements, emit the representative\n      at the end of the function.  */\n-  for (t = data.return_statements ; t ; t = TREE_CHAIN (t))\n+  while (!VEC_empty (return_statements_t, data.return_statements))\n     {\n-      x = build1 (LABEL_EXPR, void_type_node, TREE_PURPOSE (t));\n-      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+      return_statements_t t;\n+\n+      /* Unfortunately, we can't use VEC_pop because it returns void for\n+\t objects.  */\n+      t = *VEC_last (return_statements_t, data.return_statements);\n+      VEC_truncate (return_statements_t,\n+\t  \t    data.return_statements,\n+\t  \t    VEC_length (return_statements_t,\n+\t\t      \t\tdata.return_statements) - 1);\n+\n+      x = gimple_build_label (t.label);\n+      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n \n       /* Remove the line number from the representative return statement.\n \t It now fills in for many such returns.  Failure to remove this\n \t will result in incorrect results for coverage analysis.  */\n-      x = TREE_VALUE (t);\n-      SET_EXPR_LOCATION (x, UNKNOWN_LOCATION);\n-      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+      gimple_set_location (t.stmt, UNKNOWN_LOCATION);\n+      gsi_insert_after (&i, t.stmt, GSI_CONTINUE_LINKING);\n     }\n \n   /* If the function calls __builtin_setjmp, we need to emit the computed\n@@ -123,28 +171,29 @@ lower_function_body (void)\n       /* This mark will create forward edges from every call site.  */\n       DECL_NONLOCAL (disp_label) = 1;\n       cfun->has_nonlocal_label = 1;\n-      x = build1 (LABEL_EXPR, void_type_node, disp_label);\n-      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+      x = gimple_build_label (disp_label);\n+      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n \n       /* Build 'DISP_VAR = __builtin_setjmp_dispatcher (DISP_LABEL);'\n \t and insert.  */\n       disp_var = create_tmp_var (ptr_type_node, \"setjmpvar\");\n       arg = build_addr (disp_label, current_function_decl);\n       t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];\n-      t = build_call_expr (t, 1, arg);\n-      x = build_gimple_modify_stmt (disp_var, t);\n+      x = gimple_build_call (t, 1, arg);\n+      gimple_call_set_lhs (x, disp_var);\n \n       /* Build 'goto DISP_VAR;' and insert.  */\n-      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n-      x = build1 (GOTO_EXPR, void_type_node, disp_var);\n-      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n+      x = gimple_build_goto (disp_var);\n+      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n     }\n \n   gcc_assert (data.block == DECL_INITIAL (current_function_decl));\n   BLOCK_SUBBLOCKS (data.block)\n     = blocks_nreverse (BLOCK_SUBBLOCKS (data.block));\n \n   clear_block_marks (data.block);\n+  VEC_free(return_statements_t, heap, data.return_statements);\n   return 0;\n }\n \n@@ -168,134 +217,131 @@ struct gimple_opt_pass pass_lower_cf =\n };\n \n \n-/* Lower the EXPR.  Unlike gimplification the statements are not relowered\n+/* Lower sequence SEQ.  Unlike gimplification the statements are not relowered\n    when they are changed -- if this has to be done, the lowering routine must\n    do it explicitly.  DATA is passed through the recursion.  */\n \n static void\n-lower_stmt_body (tree expr, struct lower_data *data)\n+lower_sequence (gimple_seq seq, struct lower_data *data)\n {\n-  tree_stmt_iterator tsi;\n+  gimple_stmt_iterator gsi;\n \n-  for (tsi = tsi_start (expr); !tsi_end_p (tsi); )\n-    lower_stmt (&tsi, data);\n+  for (gsi = gsi_start (seq); !gsi_end_p (gsi); )\n+    lower_stmt (&gsi, data);\n }\n \n \n-/* Lower the OpenMP directive statement pointed by TSI.  DATA is\n+/* Lower the OpenMP directive statement pointed by GSI.  DATA is\n    passed through the recursion.  */\n \n static void\n-lower_omp_directive (tree_stmt_iterator *tsi, struct lower_data *data)\n+lower_omp_directive (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n-  tree stmt;\n+  gimple stmt;\n   \n-  stmt = tsi_stmt (*tsi);\n+  stmt = gsi_stmt (*gsi);\n \n-  lower_stmt_body (OMP_BODY (stmt), data);\n-  tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n-  tsi_link_before (tsi, OMP_BODY (stmt), TSI_SAME_STMT);\n-  OMP_BODY (stmt) = NULL_TREE;\n-  tsi_delink (tsi);\n+  lower_sequence (gimple_omp_body (stmt), data);\n+  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+  gsi_insert_seq_before (gsi, gimple_omp_body (stmt), GSI_SAME_STMT);\n+  gimple_omp_set_body (stmt, NULL);\n+  gsi_remove (gsi, false);\n }\n \n \n-/* Lower statement TSI.  DATA is passed through the recursion.  */\n+/* Lower statement GSI.  DATA is passed through the recursion.  */\n \n static void\n-lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n+lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n-  tree stmt = tsi_stmt (*tsi);\n+  gimple stmt = gsi_stmt (*gsi);\n \n-  if (EXPR_HAS_LOCATION (stmt) && data)\n-    TREE_BLOCK (stmt) = data->block;\n+  gimple_set_block (stmt, data->block);\n \n-  switch (TREE_CODE (stmt))\n+  switch (gimple_code (stmt))\n     {\n-    case BIND_EXPR:\n-      lower_bind_expr (tsi, data);\n-      return;\n-    case COND_EXPR:\n-      lower_cond_expr (tsi, data);\n-      return;\n-    case RETURN_EXPR:\n-      lower_return_expr (tsi, data);\n+    case GIMPLE_BIND:\n+      lower_gimple_bind (gsi, data);\n       return;\n \n-    case TRY_FINALLY_EXPR:\n-    case TRY_CATCH_EXPR:\n-      lower_stmt_body (TREE_OPERAND (stmt, 0), data);\n-      lower_stmt_body (TREE_OPERAND (stmt, 1), data);\n+    case GIMPLE_COND:\n+      /* The gimplifier has already lowered this into gotos.  */\n       break;\n-    case CATCH_EXPR:\n-      lower_stmt_body (CATCH_BODY (stmt), data);\n+\n+    case GIMPLE_RETURN:\n+      lower_gimple_return (gsi, data);\n+      return;\n+\n+    case GIMPLE_TRY:\n+      lower_sequence (gimple_try_eval (stmt), data);\n+      lower_sequence (gimple_try_cleanup (stmt), data);\n       break;\n-    case EH_FILTER_EXPR:\n-      lower_stmt_body (EH_FILTER_FAILURE (stmt), data);\n+\n+    case GIMPLE_CATCH:\n+      lower_sequence (gimple_catch_handler (stmt), data);\n       break;\n-      \n-    case NOP_EXPR:\n-    case ASM_EXPR:\n-    case GOTO_EXPR:\n-    case PREDICT_EXPR:\n-    case LABEL_EXPR:\n-    case SWITCH_EXPR:\n-    case CHANGE_DYNAMIC_TYPE_EXPR:\n-    case OMP_FOR:\n-    case OMP_SECTIONS:\n-    case OMP_SECTIONS_SWITCH:\n-    case OMP_SECTION:\n-    case OMP_SINGLE:\n-    case OMP_MASTER:\n-    case OMP_ORDERED:\n-    case OMP_CRITICAL:\n-    case OMP_RETURN:\n-    case OMP_ATOMIC_LOAD:\n-    case OMP_ATOMIC_STORE:\n-    case OMP_CONTINUE:\n+\n+    case GIMPLE_EH_FILTER:\n+      lower_sequence (gimple_eh_filter_failure (stmt), data);\n       break;\n \n-    case GIMPLE_MODIFY_STMT:\n-      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR)\n-\tstmt = GIMPLE_STMT_OPERAND (stmt, 1);\n-      else\n-\tbreak;\n-      /* FALLTHRU */\n+    case GIMPLE_NOP:\n+    case GIMPLE_ASM:\n+    case GIMPLE_ASSIGN:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_PREDICT:\n+    case GIMPLE_LABEL:\n+    case GIMPLE_SWITCH:\n+    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n+    case GIMPLE_OMP_FOR:\n+    case GIMPLE_OMP_SECTIONS:\n+    case GIMPLE_OMP_SECTIONS_SWITCH:\n+    case GIMPLE_OMP_SECTION:\n+    case GIMPLE_OMP_SINGLE:\n+    case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_ORDERED:\n+    case GIMPLE_OMP_CRITICAL:\n+    case GIMPLE_OMP_RETURN:\n+    case GIMPLE_OMP_ATOMIC_LOAD:\n+    case GIMPLE_OMP_ATOMIC_STORE:\n+    case GIMPLE_OMP_CONTINUE:\n+      break;\n \n-    case CALL_EXPR:\n+    case GIMPLE_CALL:\n       {\n-\ttree decl = get_callee_fndecl (stmt);\n+\ttree decl = gimple_call_fndecl (stmt);\n+\n \tif (decl\n \t    && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n \t    && DECL_FUNCTION_CODE (decl) == BUILT_IN_SETJMP)\n \t  {\n \t    data->calls_builtin_setjmp = true;\n-\t    lower_builtin_setjmp (tsi);\n+\t    lower_builtin_setjmp (gsi);\n \t    return;\n \t  }\n       }\n       break;\n \n-    case OMP_PARALLEL:\n-    case OMP_TASK:\n-      lower_omp_directive (tsi, data);\n+    case GIMPLE_OMP_PARALLEL:\n+    case GIMPLE_OMP_TASK:\n+      lower_omp_directive (gsi, data);\n       return;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  tsi_next (tsi);\n+  gsi_next (gsi);\n }\n \n /* Lower a bind_expr TSI.  DATA is passed through the recursion.  */\n \n static void\n-lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n+lower_gimple_bind (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n   tree old_block = data->block;\n-  tree stmt = tsi_stmt (*tsi);\n-  tree new_block = BIND_EXPR_BLOCK (stmt);\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree new_block = gimple_bind_block (stmt);\n \n   if (new_block)\n     {\n@@ -325,8 +371,8 @@ lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n \t}\n     }\n \n-  record_vars (BIND_EXPR_VARS (stmt));\n-  lower_stmt_body (BIND_EXPR_BODY (stmt), data);\n+  record_vars (gimple_bind_vars (stmt));\n+  lower_sequence (gimple_bind_body (stmt), data);\n \n   if (new_block)\n     {\n@@ -337,9 +383,9 @@ lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n       data->block = old_block;\n     }\n \n-  /* The BIND_EXPR no longer carries any useful information -- kill it.  */\n-  tsi_link_before (tsi, BIND_EXPR_BODY (stmt), TSI_SAME_STMT);\n-  tsi_delink (tsi);\n+  /* The GIMPLE_BIND no longer carries any useful information -- kill it.  */\n+  gsi_insert_seq_before (gsi, gimple_bind_body (stmt), GSI_SAME_STMT);\n+  gsi_remove (gsi, false);\n }\n \n /* Try to determine whether a TRY_CATCH expression can fall through.\n@@ -390,6 +436,58 @@ try_catch_may_fallthru (const_tree stmt)\n     }\n }\n \n+\n+/* Same as above, but for a GIMPLE_TRY_CATCH.  */\n+\n+static bool\n+gimple_try_catch_may_fallthru (gimple stmt)\n+{\n+  gimple_stmt_iterator i;\n+\n+  /* We don't handle GIMPLE_TRY_FINALLY.  */\n+  gcc_assert (gimple_try_kind (stmt) == GIMPLE_TRY_CATCH);\n+\n+  /* If the TRY block can fall through, the whole TRY_CATCH can\n+     fall through.  */\n+  if (gimple_seq_may_fallthru (gimple_try_eval (stmt)))\n+    return true;\n+\n+  i = gsi_start (gimple_try_cleanup (stmt));\n+  switch (gimple_code (gsi_stmt (i)))\n+    {\n+    case GIMPLE_CATCH:\n+      /* We expect to see a sequence of GIMPLE_CATCH stmts, each with a\n+\t catch expression and a body.  The whole try/catch may fall\n+\t through iff any of the catch bodies falls through.  */\n+      for (; !gsi_end_p (i); gsi_next (&i))\n+\t{\n+\t  if (gimple_seq_may_fallthru (gimple_catch_handler (gsi_stmt (i))))\n+\t    return true;\n+\t}\n+      return false;\n+\n+    case GIMPLE_EH_FILTER:\n+      /* The exception filter expression only matters if there is an\n+\t exception.  If the exception does not match EH_FILTER_TYPES,\n+\t we will execute EH_FILTER_FAILURE, and we will fall through\n+\t if that falls through.  If the exception does match\n+\t EH_FILTER_TYPES, the stack unwinder will continue up the\n+\t stack, so we will not fall through.  We don't know whether we\n+\t will throw an exception which matches EH_FILTER_TYPES or not,\n+\t so we just ignore EH_FILTER_TYPES and assume that we might\n+\t throw an exception which doesn't match.  */\n+      return gimple_seq_may_fallthru (gimple_eh_filter_failure (gsi_stmt (i)));\n+\n+    default:\n+      /* This case represents statements to be executed when an\n+\t exception occurs.  Those statements are implicitly followed\n+\t by a GIMPLE_RESX to resume execution after the exception.  So\n+\t in this case the try/catch never falls through.  */\n+      return false;\n+    }\n+}\n+\n+\n /* Try to determine if we can fall out of the bottom of BLOCK.  This guess\n    need not be 100% accurate; simply be conservative and return true if we\n    don't know.  This is used only to avoid stupidly generating extra code.\n@@ -440,9 +538,9 @@ block_may_fallthru (const_tree block)\n       return (block_may_fallthru (TREE_OPERAND (stmt, 0))\n \t      && block_may_fallthru (TREE_OPERAND (stmt, 1)));\n \n-    case GIMPLE_MODIFY_STMT:\n-      if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR)\n-\tstmt = GIMPLE_STMT_OPERAND (stmt, 1);\n+    case MODIFY_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n+\tstmt = TREE_OPERAND (stmt, 1);\n       else\n \treturn true;\n       /* FALLTHRU */\n@@ -459,138 +557,110 @@ block_may_fallthru (const_tree block)\n     }\n }\n \n-/* Lower a cond_expr TSI.  DATA is passed through the recursion.  */\n \n-static void\n-lower_cond_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n+/* Try to determine if we can continue executing the statement\n+   immediately following STMT.  This guess need not be 100% accurate;\n+   simply be conservative and return true if we don't know.  This is\n+   used only to avoid stupidly generating extra code. If we're wrong,\n+   we'll just delete the extra code later.  */\n+\n+bool\n+gimple_stmt_may_fallthru (gimple stmt)\n {\n-  tree stmt = tsi_stmt (*tsi);\n-  bool then_is_goto, else_is_goto;\n-  tree then_branch, else_branch;\n-  tree then_goto, else_goto;\n-  \n-  then_branch = COND_EXPR_THEN (stmt);\n-  else_branch = COND_EXPR_ELSE (stmt);\n+  if (!stmt)\n+    return true;\n \n-  lower_stmt_body (then_branch, data);\n-  lower_stmt_body (else_branch, data);\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_GOTO:\n+    case GIMPLE_RETURN:\n+    case GIMPLE_RESX:\n+      /* Easy cases.  If the last statement of the seq implies \n+\t control transfer, then we can't fall through.  */\n+      return false;\n \n-  then_goto = expr_only (then_branch);\n-  then_is_goto = then_goto && simple_goto_p (then_goto);\n+    case GIMPLE_SWITCH:\n+      /* Switch has already been lowered and represents a\n+\t branch to a selected label and hence can not fall through.  */\n+      return true;\n \n-  else_goto = expr_only (else_branch);\n-  else_is_goto = else_goto && simple_goto_p (else_goto);\n+    case GIMPLE_COND:\n+      /* GIMPLE_COND's are already lowered into a two-way branch.  They\n+\t can't fall through.  */\n+      return false;\n \n-  if (!then_is_goto || !else_is_goto)\n-    {\n-      tree then_label, else_label, end_label, t;\n-\n-      then_label = NULL_TREE;\n-      else_label = NULL_TREE;\n-      end_label = NULL_TREE;\n- \n-      /* Replace the cond_expr with explicit gotos.  */\n-      if (!then_is_goto)\n-\t{\n-\t  t = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\t  if (TREE_SIDE_EFFECTS (then_branch))\n-\t    then_label = t;\n-\t  else\n-\t    end_label = t;\n-\t  then_goto = build_and_jump (&LABEL_EXPR_LABEL (t));\n-\t}\n+    case GIMPLE_BIND:\n+      return gimple_seq_may_fallthru (gimple_bind_body (stmt));\n \n-      if (!else_is_goto)\n-\t{\n-\t  t = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\t  if (TREE_SIDE_EFFECTS (else_branch))\n-\t    else_label = t;\n-\t  else\n-\t    {\n-\t      /* Both THEN and ELSE can be no-ops if one or both contained an\n-\t         empty BIND_EXPR that was associated with the toplevel block\n-\t         of an inlined function.  In that case remove_useless_stmts\n-\t         can't have cleaned things up for us; kill the whole \n-\t         conditional now.  */\n-\t      if (end_label)\n-\t\t{\n-\t\t  tsi_delink (tsi);\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\tend_label = t;\n-\t    }\n-\t  else_goto = build_and_jump (&LABEL_EXPR_LABEL (t));\n-\t}\n+    case GIMPLE_TRY:\n+      if (gimple_try_kind (stmt) == GIMPLE_TRY_CATCH)\n+        return gimple_try_catch_may_fallthru (stmt);\n \n-      if (then_label)\n-\t{\n-\t  bool may_fallthru = block_may_fallthru (then_branch);\n+      /* It must be a GIMPLE_TRY_FINALLY.  */\n \n-\t  tsi_link_after (tsi, then_label, TSI_CONTINUE_LINKING);\n-\t  tsi_link_after (tsi, then_branch, TSI_CONTINUE_LINKING);\n-  \n-\t  if (else_label && may_fallthru)\n-\t    {\n-\t      end_label = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\t      t = build_and_jump (&LABEL_EXPR_LABEL (end_label));\n-\t      tsi_link_after (tsi, t, TSI_CONTINUE_LINKING);\n-\t    }\n-\t}\n-  \n-      if (else_label)\n-\t{\n-\t  tsi_link_after (tsi, else_label, TSI_CONTINUE_LINKING);\n-\t  tsi_link_after (tsi, else_branch, TSI_CONTINUE_LINKING);\n-\t}\n+      /* The finally clause is always executed after the try clause,\n+\t so if it does not fall through, then the try-finally will not\n+\t fall through.  Otherwise, if the try clause does not fall\n+\t through, then when the finally clause falls through it will\n+\t resume execution wherever the try clause was going.  So the\n+\t whole try-finally will only fall through if both the try\n+\t clause and the finally clause fall through.  */\n+      return (gimple_seq_may_fallthru (gimple_try_eval (stmt))\n+\t      && gimple_seq_may_fallthru (gimple_try_cleanup (stmt)));\n+\n+    case GIMPLE_ASSIGN:\n+      return true;\n \n-      if (end_label)\n-\ttsi_link_after (tsi, end_label, TSI_CONTINUE_LINKING);\n+    case GIMPLE_CALL:\n+      /* Functions that do not return do not fall through.  */\n+      return (gimple_call_flags (stmt) & ECF_NORETURN) == 0;\n+    \n+    default:\n+      return true;\n     }\n+}\n+\n \n-  COND_EXPR_THEN (stmt) = then_goto;\n-  COND_EXPR_ELSE (stmt) = else_goto;\n+/* Same as gimple_stmt_may_fallthru, but for the gimple sequence SEQ.  */\n \n-  tsi_next (tsi);\n+bool\n+gimple_seq_may_fallthru (gimple_seq seq)\n+{\n+  return gimple_stmt_may_fallthru (gimple_seq_last_stmt (seq));\n }\n \n-/* Lower a return_expr TSI.  DATA is passed through the recursion.  */\n+\n+/* Lower a GIMPLE_RETURN GSI.  DATA is passed through the recursion.  */\n \n static void\n-lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n+lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n-  tree stmt = tsi_stmt (*tsi);\n-  tree value, t, label;\n-\n-  /* Extract the value being returned.  */\n-  value = TREE_OPERAND (stmt, 0);\n-  if (value && TREE_CODE (value) == GIMPLE_MODIFY_STMT)\n-    value = GIMPLE_STMT_OPERAND (value, 1);\n+  gimple stmt = gsi_stmt (*gsi);\n+  gimple t;\n+  int i;\n+  return_statements_t tmp_rs;\n \n   /* Match this up with an existing return statement that's been created.  */\n-  for (t = data->return_statements; t ; t = TREE_CHAIN (t))\n+  for (i = VEC_length (return_statements_t, data->return_statements) - 1;\n+       i >= 0; i--)\n     {\n-      tree tvalue = TREE_OPERAND (TREE_VALUE (t), 0);\n-      if (tvalue && TREE_CODE (tvalue) == GIMPLE_MODIFY_STMT)\n-\ttvalue = GIMPLE_STMT_OPERAND (tvalue, 1);\n+      tmp_rs = *VEC_index (return_statements_t, data->return_statements, i);\n \n-      if (value == tvalue)\n-\t{\n-\t  label = TREE_PURPOSE (t);\n-\t  goto found;\n-\t}\n+      if (gimple_return_retval (stmt) == gimple_return_retval (tmp_rs.stmt))\n+\tgoto found;\n     }\n \n   /* Not found.  Create a new label and record the return statement.  */\n-  label = create_artificial_label ();\n-  data->return_statements = tree_cons (label, stmt, data->return_statements);\n+  tmp_rs.label = create_artificial_label ();\n+  tmp_rs.stmt = stmt;\n+  VEC_safe_push (return_statements_t, heap, data->return_statements, &tmp_rs);\n \n   /* Generate a goto statement and remove the return statement.  */\n  found:\n-  t = build1 (GOTO_EXPR, void_type_node, label);\n-  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n-  tsi_link_before (tsi, t, TSI_SAME_STMT);\n-  tsi_delink (tsi);\n+  t = gimple_build_goto (tmp_rs.label);\n+  gimple_set_location (t, gimple_location (stmt));\n+  gsi_insert_before (gsi, t, GSI_SAME_STMT);\n+  gsi_remove (gsi, false);\n }\n \n /* Lower a __builtin_setjmp TSI.\n@@ -647,71 +717,66 @@ lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n    to the receivers, thus keeping the complexity explosion localized.  */\n \n static void\n-lower_builtin_setjmp (tree_stmt_iterator *tsi)\n+lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n {\n-  tree stmt = tsi_stmt (*tsi);\n+  gimple stmt = gsi_stmt (*gsi);\n   tree cont_label = create_artificial_label ();\n   tree next_label = create_artificial_label ();\n   tree dest, t, arg;\n+  gimple g;\n \n   /* NEXT_LABEL is the label __builtin_longjmp will jump to.  Its address is\n      passed to both __builtin_setjmp_setup and __builtin_setjmp_receiver.  */\n   FORCED_LABEL (next_label) = 1;\n \n-  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-    {\n-      dest = GIMPLE_STMT_OPERAND (stmt, 0);\n-      stmt = GIMPLE_STMT_OPERAND (stmt, 1);\n-    }\n-  else\n-    dest = NULL_TREE;\n+  dest = gimple_call_lhs (stmt);\n \n   /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */\n   arg = build_addr (next_label, current_function_decl);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];\n-  t = build_call_expr (t, 2, CALL_EXPR_ARG (stmt, 0), arg);\n-  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n-  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+  g = gimple_build_call (t, 2, gimple_call_arg (stmt, 0), arg);\n+  gimple_set_location (g, gimple_location (stmt));\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Build 'DEST = 0' and insert.  */\n   if (dest)\n     {\n-      t = build_gimple_modify_stmt (dest, fold_convert (TREE_TYPE (dest),\n-\t\t\t\t\t\t\tinteger_zero_node));\n-      SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n-      tsi_link_before (tsi, t, TSI_SAME_STMT);\n+      g = gimple_build_assign (dest, fold_convert (TREE_TYPE (dest),\n+\t\t\t\t\t\t   integer_zero_node));\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n     }\n \n   /* Build 'goto CONT_LABEL' and insert.  */\n-  t = build1 (GOTO_EXPR, void_type_node, cont_label);\n-  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+  g = gimple_build_goto (cont_label);\n+  gsi_insert_before (gsi, g, TSI_SAME_STMT);\n \n   /* Build 'NEXT_LABEL:' and insert.  */\n-  t = build1 (LABEL_EXPR, void_type_node, next_label);\n-  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+  g = gimple_build_label (next_label);\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Build '__builtin_setjmp_receiver (NEXT_LABEL)' and insert.  */\n   arg = build_addr (next_label, current_function_decl);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];\n-  t = build_call_expr (t, 1, arg);\n-  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n-  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+  g = gimple_build_call (t, 1, arg);\n+  gimple_set_location (g, gimple_location (stmt));\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Build 'DEST = 1' and insert.  */\n   if (dest)\n     {\n-      t = build_gimple_modify_stmt (dest, fold_convert (TREE_TYPE (dest),\n-\t\t\t\t\t\t\tinteger_one_node));\n-      SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n-      tsi_link_before (tsi, t, TSI_SAME_STMT);\n+      g = gimple_build_assign (dest, fold_convert (TREE_TYPE (dest),\n+\t\t\t\t\t\t   integer_one_node));\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n     }\n \n   /* Build 'CONT_LABEL:' and insert.  */\n-  t = build1 (LABEL_EXPR, void_type_node, cont_label);\n-  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+  g = gimple_build_label (cont_label);\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Remove the call to __builtin_setjmp.  */\n-  tsi_delink (tsi);\n+  gsi_remove (gsi, false);\n }\n \f\n "}, {"sha": "d334d856982eb44caadfe4ed712f9241f567ab32", "filename": "gcc/gimple-pretty-print.c", "status": "added", "additions": 1857, "deletions": 0, "changes": 1857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -0,0 +1,1857 @@\n+/* Pretty formatting of GIMPLE statements and expressions.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com> and\n+   Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"real.h\"\n+#include \"hashtab.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple.h\"\n+#include \"value-prof.h\"\n+\n+#define INDENT(SPACE)\t\t\t\t\t\t\t\\\n+  do { int i; for (i = 0; i < SPACE; i++) pp_space (buffer); } while (0)\n+\n+static pretty_printer buffer;\n+static bool initialized = false;\n+\n+#define GIMPLE_NIY do_niy (buffer,gs)\n+\n+/* Try to print on BUFFER a default message for the unrecognized\n+   gimple statement GS.  */\n+\n+static void\n+do_niy (pretty_printer *buffer, gimple gs)\n+{\n+  pp_printf (buffer, \"<<< Unknown GIMPLE statement: %s >>>\\n\",\n+\t     gimple_code_name[(int) gimple_code (gs)]);\n+}\n+\n+\n+/* Initialize the pretty printer on FILE if needed.  */\n+\n+static void\n+maybe_init_pretty_print (FILE *file)\n+{\n+  if (!initialized)\n+    {\n+      pp_construct (&buffer, NULL, 0);\n+      pp_needs_newline (&buffer) = true;\n+      initialized = true;\n+    }\n+\n+  buffer.buffer->stream = file;\n+}\n+\n+\n+/* Emit a newline and SPC indentantion spaces to BUFFER.  */\n+\n+static void\n+newline_and_indent (pretty_printer *buffer, int spc)\n+{\n+  pp_newline (buffer);\n+  INDENT (spc);\n+}\n+\n+\n+/* Print the GIMPLE statement GS on stderr.  */\n+\n+void\n+debug_gimple_stmt (gimple gs)\n+{\n+  print_gimple_stmt (stderr, gs, 0, TDF_VOPS|TDF_MEMSYMS);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+\n+/* Dump GIMPLE statement G to FILE using SPC indentantion spaces and\n+   FLAGS as in dump_gimple_stmt.  */\n+\n+void\n+print_gimple_stmt (FILE *file, gimple g, int spc, int flags)\n+{\n+  maybe_init_pretty_print (file);\n+  dump_gimple_stmt (&buffer, g, spc, flags);\n+  pp_flush (&buffer);\n+}\n+\n+\n+/* Dump GIMPLE statement G to FILE using SPC indentantion spaces and\n+   FLAGS as in dump_gimple_stmt.  Print only the right-hand side\n+   of the statement.  */\n+\n+void\n+print_gimple_expr (FILE *file, gimple g, int spc, int flags)\n+{\n+  flags |= TDF_RHS_ONLY;\n+  maybe_init_pretty_print (file);\n+  dump_gimple_stmt (&buffer, g, spc, flags);\n+}\n+\n+\n+/* Print the GIMPLE sequence SEQ on BUFFER using SPC indentantion\n+   spaces and FLAGS as in dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_seq (pretty_printer *buffer, gimple_seq seq, int spc, int flags)\n+{\n+  gimple_stmt_iterator i;\n+\n+  for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n+    {\n+      gimple gs = gsi_stmt (i);\n+      INDENT (spc);\n+      dump_gimple_stmt (buffer, gs, spc, flags);\n+      if (!gsi_one_before_end_p (i))\n+\tpp_newline (buffer);\n+    }\n+}\n+\n+\n+/* Dump GIMPLE sequence SEQ to FILE using SPC indentantion spaces and\n+   FLAGS as in dump_gimple_stmt.  */\n+\n+void\n+print_gimple_seq (FILE *file, gimple_seq seq, int spc, int flags)\n+{\n+  maybe_init_pretty_print (file);\n+  dump_gimple_seq (&buffer, seq, spc, flags);\n+  pp_flush (&buffer);\n+}\n+\n+\n+/* Print the GIMPLE sequence SEQ on stderr.  */\n+\n+void\n+debug_gimple_seq (gimple_seq seq)\n+{\n+  print_gimple_seq (stderr, seq, 0, TDF_VOPS|TDF_MEMSYMS);\n+}\n+\n+\n+/* A simple helper to pretty-print some of the gimple tuples in the printf\n+   style. The format modifiers are preceeded by '%' and are:\n+     'G' - outputs a string corresponding to the code of the given gimple,\n+     'S' - outputs a gimple_seq with indent of spc + 2,\n+     'T' - outputs the tree t,\n+     'd' - outputs an int as a decimal,\n+     's' - outputs a string,\n+     'n' - outputs a newline,\n+     '+' - increases indent by 2 then outputs a newline,\n+     '-' - decreases indent by 2 then outputs a newline.   */\n+\n+static void\n+dump_gimple_fmt (pretty_printer *buffer, int spc, int flags,\n+                 const char *fmt, ...)\n+{\n+  va_list args;\n+  const char *c;\n+  const char *tmp;\n+\n+  va_start (args, fmt);\n+  for (c = fmt; *c; c++)\n+    {\n+      if (*c == '%')\n+        {\n+          gimple_seq seq;\n+          tree t;\n+          gimple g;\n+          switch (*++c)\n+            {\n+              case 'G':\n+                g = va_arg (args, gimple);\n+                tmp = gimple_code_name[gimple_code (g)];\n+                pp_string (buffer, tmp);\n+                break;\n+\n+              case 'S':\n+                seq = va_arg (args, gimple_seq);\n+                pp_newline (buffer);\n+                dump_gimple_seq (buffer, seq, spc + 2, flags);\n+                newline_and_indent (buffer, spc);\n+                break;\n+\n+              case 'T':\n+                t = va_arg (args, tree);\n+                if (t == NULL_TREE)\n+                  pp_string (buffer, \"NULL\");\n+                else\n+                  dump_generic_node (buffer, t, spc, flags, false);\n+                break;\n+\n+              case 'd':\n+                pp_decimal_int (buffer, va_arg (args, int));\n+                break;\n+\n+              case 's':\n+                pp_string (buffer, va_arg (args, char *));\n+                break;\n+\n+              case 'n':\n+                newline_and_indent (buffer, spc);\n+                break;\n+\n+              case '+':\n+                spc += 2;\n+                newline_and_indent (buffer, spc);\n+                break;\n+\n+              case '-':\n+                spc -= 2;\n+                newline_and_indent (buffer, spc);\n+                break;\n+\n+              default:\n+                gcc_unreachable ();\n+            }\n+        } \n+      else\n+        pp_character (buffer, *c);\n+    }\n+  va_end (args);\n+}\n+\n+\n+/* Helper for dump_gimple_assign.  Print the unary RHS of the\n+   assignment GS.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.  */\n+\n+static void\n+dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  enum tree_code rhs_code = gimple_assign_rhs_code (gs);\n+  tree lhs = gimple_assign_lhs (gs);\n+  tree rhs = gimple_assign_rhs1 (gs);\n+\n+  switch (rhs_code)\n+    {\n+    case VIEW_CONVERT_EXPR:\n+    case ASSERT_EXPR:\n+      dump_generic_node (buffer, rhs, spc, flags, false);\n+      break;\n+\n+    case FIXED_CONVERT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    CASE_CONVERT:\n+      pp_string (buffer, \"(\");\n+      dump_generic_node (buffer, TREE_TYPE (lhs), spc, flags, false);\n+      pp_string (buffer, \") \");\n+      dump_generic_node (buffer, rhs, spc, flags, false);\n+      break;\n+      \n+    case PAREN_EXPR:\n+      pp_string (buffer, \"((\");\n+      dump_generic_node (buffer, rhs, spc, flags, false);\n+      pp_string (buffer, \"))\");\n+      break;\n+      \n+    case ABS_EXPR:\n+      pp_string (buffer, \"ABS_EXPR <\");\n+      dump_generic_node (buffer, rhs, spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+\n+    default:\n+      if (TREE_CODE_CLASS (rhs_code) == tcc_declaration\n+\t  || TREE_CODE_CLASS (rhs_code) == tcc_constant\n+\t  || TREE_CODE_CLASS (rhs_code) == tcc_reference\n+\t  || rhs_code == SSA_NAME\n+\t  || rhs_code == ADDR_EXPR\n+\t  || rhs_code == CONSTRUCTOR)\n+\t; /* do nothing.  */\n+      else if (rhs_code == BIT_NOT_EXPR)\n+\tpp_string (buffer, \"~\");\n+      else if (rhs_code == TRUTH_NOT_EXPR)\n+\tpp_string (buffer, \"!\");\n+      else if (rhs_code == NEGATE_EXPR)\n+\tpp_string (buffer, \"-\");\n+      else\n+\t{\n+\t  pp_string (buffer, \"[\");\n+\t  pp_string (buffer, tree_code_name [rhs_code]);\n+\t  pp_string (buffer, \"] \");\n+\t}\n+\n+      dump_generic_node (buffer, rhs, spc, flags, false);\n+      break;\n+    }\n+}\n+\n+\n+/* Helper for dump_gimple_assign.  Print the binary RHS of the\n+   assignment GS.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.  */\n+\n+static void\n+dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  switch (gimple_assign_rhs_code (gs))\n+    {\n+    case COMPLEX_EXPR:\n+      pp_string (buffer, \"COMPLEX_EXPR <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+      \n+    case MIN_EXPR:\n+      pp_string (buffer, \"MIN_EXPR <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+      \n+    case MAX_EXPR:\n+      pp_string (buffer, \"MAX_EXPR <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+\n+    default:\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_space (buffer);\n+      pp_string (buffer, op_symbol_code (gimple_assign_rhs_code (gs)));\n+      pp_space (buffer);\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+    }\n+}\n+\n+\n+/* Dump the gimple assignment GS.  BUFFER, SPC and FLAGS are as in\n+   dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      tree last;\n+      if (gimple_num_ops (gs) == 2)\n+        last = NULL_TREE;\n+      else if (gimple_num_ops (gs) == 3)\n+        last = gimple_assign_rhs2 (gs);\n+      else\n+        gcc_unreachable ();\n+\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%s, %T, %T, %T>\", gs,\n+                       tree_code_name[gimple_assign_rhs_code (gs)],\n+                       gimple_assign_lhs (gs), gimple_assign_rhs1 (gs), last);\n+    }\n+  else\n+    {\n+      if (!(flags & TDF_RHS_ONLY))\n+\t{\n+\t  dump_generic_node (buffer, gimple_assign_lhs (gs), spc, flags, false);\n+\t  pp_space (buffer);\n+\t  pp_character (buffer, '=');\n+\n+\t  if (gimple_assign_nontemporal_move_p (gs))\n+\t    pp_string (buffer, \"{nt}\");\n+\n+\t  if (gimple_has_volatile_ops (gs))\n+\t    pp_string (buffer, \"{v}\");\n+\n+\t  pp_space (buffer);\n+\t}\n+\n+      if (gimple_num_ops (gs) == 2)\n+        dump_unary_rhs (buffer, gs, spc, flags);\n+      else if (gimple_num_ops (gs) == 3)\n+        dump_binary_rhs (buffer, gs, spc, flags);\n+      else\n+        gcc_unreachable ();\n+      if (!(flags & TDF_RHS_ONLY))\n+\tpp_semicolon(buffer);\n+    }\n+}\n+\n+\n+/* Dump the return statement GS.  BUFFER, SPC and FLAGS are as in\n+   dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  tree t;\n+\n+  t = gimple_return_retval (gs);\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, t);\n+  else\n+    {\n+      pp_string (buffer, \"return\");\n+      if (t)\n+\t{\n+\t  pp_space (buffer);\n+\t  dump_generic_node (buffer, t, spc, flags, false);\n+\t}\n+      pp_semicolon (buffer);\n+    }\n+}\n+\n+\n+/* Dump the call arguments for a gimple call. BUFFER, FLAGS are as in\n+   dump_gimple_call.  */\n+\n+static void\n+dump_gimple_call_args (pretty_printer *buffer, gimple gs, int flags)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < gimple_call_num_args (gs); i++)\n+    {\n+      dump_generic_node (buffer, gimple_call_arg (gs, i), 0, flags, false);\n+      if (i < gimple_call_num_args (gs) - 1)\n+\tpp_string (buffer, \", \");\n+    }\n+\n+  if (gimple_call_va_arg_pack_p (gs))\n+    {\n+      if (gimple_call_num_args (gs) > 0)\n+        {\n+          pp_character (buffer, ',');\n+          pp_space (buffer);\n+        }\n+\n+      pp_string (buffer, \"__builtin_va_arg_pack ()\");\n+    }\n+}\n+\n+\n+/* Dump the call statement GS.  BUFFER, SPC and FLAGS are as in\n+   dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  tree lhs = gimple_call_lhs (gs);\n+\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T\",\n+                     gs, gimple_call_fn (gs), lhs);\n+      if (gimple_call_num_args (gs) > 0)\n+        {\n+          pp_string (buffer, \", \");\n+          dump_gimple_call_args (buffer, gs, flags);\n+        }\n+      pp_string (buffer, \">\");\n+    }\n+  else\n+    {\n+      if (lhs && !(flags & TDF_RHS_ONLY))\n+        {\n+          dump_generic_node (buffer, lhs, spc, flags, false);\n+          pp_string (buffer, \" =\");\n+\n+\t  if (gimple_has_volatile_ops (gs))\n+\t    pp_string (buffer, \"{v}\");\n+\n+\t  pp_space (buffer);\n+        }\n+      dump_generic_node (buffer, gimple_call_fn (gs), spc, flags, false);\n+      pp_string (buffer, \" (\");\n+      dump_gimple_call_args (buffer, gs, flags);\n+      pp_string (buffer, \")\");\n+      if (!(flags & TDF_RHS_ONLY))\n+\tpp_semicolon (buffer);\n+    }\n+\n+  if (gimple_call_chain (gs))\n+    {\n+      pp_string (buffer, \" [static-chain: \");\n+      dump_generic_node (buffer, gimple_call_chain (gs), spc, flags, false);\n+      pp_character (buffer, ']');\n+    }\n+\n+  if (gimple_call_return_slot_opt_p (gs))\n+    pp_string (buffer, \" [return slot optimization]\");\n+\n+  if (gimple_call_tail_p (gs))\n+    pp_string (buffer, \" [tail call]\");\n+}\n+\n+\n+/* Dump the switch statement GS.  BUFFER, SPC and FLAGS are as in\n+   dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_switch (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  unsigned int i;\n+\n+  GIMPLE_CHECK (gs, GIMPLE_SWITCH);\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T, \", gs,\n+                   gimple_switch_index (gs));\n+  else\n+    {\n+      pp_string (buffer, \"switch (\");\n+      dump_generic_node (buffer, gimple_switch_index (gs), spc, flags, true);\n+      pp_string (buffer, \") <\");\n+    }\n+\n+  for (i = 0; i < gimple_switch_num_labels (gs); i++)\n+    {\n+      tree case_label = gimple_switch_label (gs, i);\n+      if (case_label == NULL_TREE)\n+\tcontinue;\n+\n+      dump_generic_node (buffer, case_label, spc, flags, false);\n+      pp_string (buffer, \" \");\n+      dump_generic_node (buffer, CASE_LABEL (case_label), spc, flags, false);\n+      if (i < gimple_switch_num_labels (gs) - 1)\n+        pp_string (buffer, \", \");\n+    }\n+  pp_string (buffer, \">\");\n+}\n+\n+\n+/* Dump the gimple conditional GS.  BUFFER, SPC and FLAGS are as in\n+   dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_cond (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%s, %T, %T, %T, %T>\", gs,\n+                   tree_code_name [gimple_cond_code (gs)],\n+                   gimple_cond_lhs (gs), gimple_cond_rhs (gs),\n+                   gimple_cond_true_label (gs), gimple_cond_false_label (gs));\n+  else\n+    {\n+      if (!(flags & TDF_RHS_ONLY))\n+\tpp_string (buffer, \"if (\");\n+      dump_generic_node (buffer, gimple_cond_lhs (gs), spc, flags, false);\n+      pp_space (buffer);\n+      pp_string (buffer, op_symbol_code (gimple_cond_code (gs)));\n+      pp_space (buffer);\n+      dump_generic_node (buffer, gimple_cond_rhs (gs), spc, flags, false);\n+      if (!(flags & TDF_RHS_ONLY))\n+\t{\n+\t  pp_string (buffer, \")\");\n+\n+\t  if (gimple_cond_true_label (gs))\n+\t    {\n+\t      pp_string (buffer, \" goto \");\n+\t      dump_generic_node (buffer, gimple_cond_true_label (gs),\n+\t\t\t\t spc, flags, false);\n+\t      pp_semicolon (buffer);\n+\t    }\n+\t  if (gimple_cond_false_label (gs))\n+\t    {\n+\t      pp_string (buffer, \" else goto \");\n+\t      dump_generic_node (buffer, gimple_cond_false_label (gs),\n+\t\t\t\t spc, flags, false);\n+\t      pp_semicolon (buffer);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Dump a GIMPLE_LABEL tuple on the pretty_printer BUFFER, SPC\n+   spaces of indent.  FLAGS specifies details to show in the dump (see\n+   TDF_* in tree-pass.h).  */\n+\n+static void\n+dump_gimple_label (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  tree label = gimple_label_label (gs);\n+  if (flags & TDF_RAW)\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, label);\n+  else\n+    {\n+      dump_generic_node (buffer, label, spc, flags, false);\n+      pp_string (buffer, \":\");\n+    }\n+  if (DECL_NONLOCAL (label))\n+    pp_string (buffer, \" [non-local]\");\n+}\n+\n+/* Dump a GIMPLE_GOTO tuple on the pretty_printer BUFFER, SPC\n+   spaces of indent.  FLAGS specifies details to show in the dump (see\n+   TDF_* in tree-pass.h).  */\n+\n+static void\n+dump_gimple_goto (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  tree label = gimple_goto_dest (gs);\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, label);\n+  else\n+    dump_gimple_fmt (buffer, spc, flags, \"goto %T;\", label);\n+}\n+\n+\n+/* Dump a GIMPLE_BIND tuple on the pretty_printer BUFFER, SPC\n+   spaces of indent.  FLAGS specifies details to show in the dump (see\n+   TDF_* in tree-pass.h).  */\n+\n+static void\n+dump_gimple_bind (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <\", gs);\n+  else\n+    pp_character (buffer, '{');\n+  if (!(flags & TDF_SLIM))\n+    {\n+      tree var;\n+\n+      for (var = gimple_bind_vars (gs); var; var = TREE_CHAIN (var))\n+\t{\n+          newline_and_indent (buffer, 2);\n+\t  print_declaration (buffer, var, spc, flags);\n+\t}\n+      if (gimple_bind_vars (gs))\n+\tpp_newline (buffer);\n+    }\n+  pp_newline (buffer);\n+  dump_gimple_seq (buffer, gimple_bind_body (gs), spc + 2, flags);\n+  newline_and_indent (buffer, spc);\n+  if (flags & TDF_RAW)\n+    pp_character (buffer, '>');\n+  else\n+    pp_character (buffer, '}');\n+}\n+\n+\n+/* Dump a GIMPLE_TRY tuple on the pretty_printer BUFFER, SPC spaces of\n+   indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_try (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      const char *type;\n+      if (gimple_try_kind (gs) == GIMPLE_TRY_CATCH)\n+        type = \"GIMPLE_TRY_CATCH\";\n+      else if (gimple_try_kind (gs) == GIMPLE_TRY_FINALLY)\n+        type = \"GIMPLE_TRY_FINALLY\";\n+      else\n+        type = \"UNKNOWN GIMPLE_TRY\";\n+      dump_gimple_fmt (buffer, spc, flags,\n+                       \"%G <%s,%+EVAL <%S>%nCLEANUP <%S>%->\", gs, type,\n+                       gimple_try_eval (gs), gimple_try_cleanup (gs));\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"try\");\n+      newline_and_indent (buffer, spc + 2);\n+      pp_string (buffer, \"{\");\n+      pp_newline (buffer);\n+\n+      dump_gimple_seq (buffer, gimple_try_eval (gs), spc + 4, flags);\n+      newline_and_indent (buffer, spc + 2);\n+      pp_string (buffer, \"}\");\n+\n+      if (gimple_try_kind (gs) == GIMPLE_TRY_CATCH)\n+\t{\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_string (buffer, \"catch\");\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_string (buffer, \"{\");\n+\t}\n+      else if (gimple_try_kind (gs) == GIMPLE_TRY_FINALLY)\n+\t{\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_string (buffer, \"finally\");\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_string (buffer, \"{\");\n+\t}\n+      else\n+\tpp_string (buffer, \" <UNKNOWN GIMPLE_TRY> {\");\n+\n+      pp_newline (buffer);\n+      dump_gimple_seq (buffer, gimple_try_cleanup (gs), spc + 4, flags);\n+      newline_and_indent (buffer, spc + 2);\n+      pp_character (buffer, '}');\n+    }\n+}\n+\n+\n+/* Dump a GIMPLE_CATCH tuple on the pretty_printer BUFFER, SPC spaces of\n+   indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_catch (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %+CATCH <%S>%->\", gs,\n+                       gimple_catch_types (gs), gimple_catch_handler (gs));\n+  else\n+      dump_gimple_fmt (buffer, spc, flags, \"catch (%T)%+{%S}\",\n+                       gimple_catch_types (gs), gimple_catch_handler (gs));\n+}\n+\n+\n+/* Dump a GIMPLE_EH_FILTER tuple on the pretty_printer BUFFER, SPC spaces of\n+   indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_eh_filter (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %+FAILURE <%S>%->\", gs,\n+                     gimple_eh_filter_types (gs),\n+                     gimple_eh_filter_failure (gs));\n+  else\n+    dump_gimple_fmt (buffer, spc, flags, \"<<<eh_filter (%T)>>>%+{%+%S%-}\",\n+                     gimple_eh_filter_types (gs),\n+                     gimple_eh_filter_failure (gs));\n+}\n+\n+\n+/* Dump a GIMPLE_RESX tuple on the pretty_printer BUFFER, SPC spaces of\n+   indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_resx (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%d>\", gs,\n+                     gimple_resx_region (gs));\n+  else\n+    dump_gimple_fmt (buffer, spc, flags, \"resx %d\", gimple_resx_region (gs));\n+}\n+\n+/* Dump a GIMPLE_OMP_FOR tuple on the pretty_printer BUFFER.  */\n+static void\n+dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  size_t i;\n+\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+                       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >,\");\n+      for (i = 0; i < gimple_omp_for_collapse (gs); i++)\n+\tdump_gimple_fmt (buffer, spc, flags,\n+\t\t\t \"%+%T, %T, %T, %s, %T,%n\",\n+\t\t\t gimple_omp_for_index (gs, i),\n+\t\t\t gimple_omp_for_initial (gs, i),\n+\t\t\t gimple_omp_for_final (gs, i),\n+\t\t\t tree_code_name[gimple_omp_for_cond (gs, i)],\n+\t\t\t gimple_omp_for_incr (gs, i));\n+      dump_gimple_fmt (buffer, spc, flags, \"PRE_BODY <%S>%->\",\n+\t\t       gimple_omp_for_pre_body (gs));\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp for\");\n+      dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n+      for (i = 0; i < gimple_omp_for_collapse (gs); i++)\n+\t{\n+\t  if (i)\n+\t    spc += 2;\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_string (buffer, \"for (\");\n+\t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n+\t\t\t     flags, false);\n+\t  pp_string (buffer, \" = \");\n+\t  dump_generic_node (buffer, gimple_omp_for_initial (gs, i), spc,\n+\t\t\t     flags, false);\n+\t  pp_string (buffer, \"; \");\n+\n+\t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n+\t\t\t     flags, false);\n+\t  pp_space (buffer);\n+\t  switch (gimple_omp_for_cond (gs, i))\n+\t    {\n+\t    case LT_EXPR:\n+\t      pp_character (buffer, '<');\n+\t      break;\n+\t    case GT_EXPR:\n+\t      pp_character (buffer, '>');\n+\t      break;\n+\t    case LE_EXPR:\n+\t      pp_string (buffer, \"<=\");\n+\t      break;\n+\t    case GE_EXPR:\n+\t      pp_string (buffer, \">=\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  pp_space (buffer);\n+\t  dump_generic_node (buffer, gimple_omp_for_final (gs, i), spc,\n+\t\t\t     flags, false);\n+\t  pp_string (buffer, \"; \");\n+\n+\t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n+\t\t\t     flags, false);\n+\t  pp_string (buffer, \" = \");\n+\t  dump_generic_node (buffer, gimple_omp_for_incr (gs, i), spc,\n+\t\t\t     flags, false);\n+\t  pp_character (buffer, ')');\n+\t}\n+\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_CONTINUE tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_continue (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T>\", gs,\n+                       gimple_omp_continue_control_def (gs),\n+                       gimple_omp_continue_control_use (gs));\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp continue (\");\n+      dump_generic_node (buffer, gimple_omp_continue_control_def (gs),\n+\t  \t\t spc, flags, false);\n+      pp_character (buffer, ',');\n+      pp_space (buffer);\n+      dump_generic_node (buffer, gimple_omp_continue_control_use (gs),\n+\t  \t\t spc, flags, false);\n+      pp_character (buffer, ')');\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_SINGLE tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_single (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_single_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp single\");\n+      dump_omp_clauses (buffer, gimple_omp_single_clauses (gs), spc, flags);\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_SECTIONS tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_sections (pretty_printer *buffer, gimple gs, int spc,\n+\t\t\t  int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_sections_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp sections\");\n+      if (gimple_omp_sections_control (gs))\n+\t{\n+\t  pp_string (buffer, \" <\");\n+\t  dump_generic_node (buffer, gimple_omp_sections_control (gs), spc,\n+\t\t\t     flags, false);\n+\t  pp_character (buffer, '>');\n+\t}\n+      dump_omp_clauses (buffer, gimple_omp_sections_clauses (gs), spc, flags);\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_{MASTER,ORDERED,SECTION} tuple on the pretty_printer\n+   BUFFER.  */\n+\n+static void\n+dump_gimple_omp_block (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S> >\", gs,\n+\t\t     gimple_omp_body (gs));\n+  else\n+    {\n+      switch (gimple_code (gs))\n+\t{\n+\tcase GIMPLE_OMP_MASTER:\n+\t  pp_string (buffer, \"#pragma omp master\");\n+\t  break;\n+\tcase GIMPLE_OMP_ORDERED:\n+\t  pp_string (buffer, \"#pragma omp ordered\");\n+\t  break;\n+\tcase GIMPLE_OMP_SECTION:\n+\t  pp_string (buffer, \"#pragma omp section\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_CRITICAL tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_critical (pretty_printer *buffer, gimple gs, int spc,\n+\t\t\t  int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S> >\", gs,\n+\t\t     gimple_omp_body (gs));\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp critical\");\n+      if (gimple_omp_critical_name (gs))\n+\t{\n+\t  pp_string (buffer, \" (\");\n+\t  dump_generic_node (buffer, gimple_omp_critical_name (gs), spc,\n+\t\t\t     flags, false);\n+\t  pp_character (buffer, ')');\n+\t}\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_RETURN tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <nowait=%d>\", gs,\n+                       (int) gimple_omp_return_nowait_p (gs));\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp return\");\n+      if (gimple_omp_return_nowait_p (gs))\n+\tpp_string (buffer, \"(nowait)\");\n+    }\n+}\n+\n+/* Dump a GIMPLE_ASM tuple on the pretty_printer BUFFER, SPC spaces of\n+   indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_asm (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  unsigned int i;\n+\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%+STRING <%n%s%n>\", gs,\n+                     gimple_asm_string (gs));\n+  else\n+    {\n+      pp_string (buffer, \"__asm__\");\n+      if (gimple_asm_volatile_p (gs))\n+\tpp_string (buffer, \" __volatile__\");\n+      pp_string (buffer, \"(\\\"\");\n+      pp_string (buffer, gimple_asm_string (gs));\n+      pp_string (buffer, \"\\\"\");\n+    }\n+\n+  if (gimple_asm_ninputs (gs)\n+     || gimple_asm_noutputs (gs) \n+     || gimple_asm_nclobbers (gs))\n+    {\n+      if (gimple_asm_noutputs (gs))\n+        {\n+          if (flags & TDF_RAW)\n+            {\n+              newline_and_indent (buffer, spc + 2);\n+              pp_string (buffer, \"OUTPUT: \");\n+            }\n+          else\n+            pp_string (buffer, \" : \");\n+        }\n+\n+      for (i = 0; i < gimple_asm_noutputs (gs); i++)\n+        {\n+          dump_generic_node (buffer, gimple_asm_output_op (gs, i), spc, flags,\n+                             false);\n+          if ( i < gimple_asm_noutputs (gs) -1)\n+            pp_string (buffer, \", \");\n+        }\n+\n+      if (gimple_asm_ninputs (gs))\n+        {\n+          if (flags & TDF_RAW)\n+            {\n+              newline_and_indent (buffer, spc + 2);\n+              pp_string (buffer, \"INPUT: \");\n+            }\n+          else\n+            pp_string (buffer, \" : \");\n+        }\n+\n+      for (i = 0; i < gimple_asm_ninputs (gs); i++)\n+        {\n+          dump_generic_node (buffer, gimple_asm_input_op (gs, i), spc, flags,\n+                             false);\n+          if (i < gimple_asm_ninputs (gs) -1)\n+            pp_string (buffer, \" : \");\n+        }\n+\n+      if (gimple_asm_nclobbers (gs))\n+        {\n+          if (flags & TDF_RAW)\n+            {\n+              newline_and_indent (buffer, spc + 2);\n+              pp_string (buffer, \"CLOBBER: \");\n+            }\n+          else\n+            pp_string (buffer, \" : \");\n+        }\n+\n+      for (i = 0; i < gimple_asm_nclobbers (gs); i++)\n+        {\n+          dump_generic_node (buffer, gimple_asm_clobber_op (gs, i), spc, flags,\n+                             false);\n+          if ( i < gimple_asm_nclobbers (gs) -1)\n+            pp_string (buffer, \", \");\n+        }\n+    }\n+  if (flags & TDF_RAW)\n+    {\n+      newline_and_indent (buffer, spc);\n+      pp_character (buffer, '>');\n+    }\n+  else\n+    pp_string (buffer, \");\");\n+}\n+\n+\n+/* Dump the set of decls SYMS.  BUFFER, SPC and FLAGS are as in\n+   dump_generic_node.  */\n+\n+static void\n+dump_symbols (pretty_printer *buffer, bitmap syms, int flags)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  if (syms == NULL)\n+    pp_string (buffer, \"NIL\");\n+  else\n+    {\n+      pp_string (buffer, \" { \");\n+\n+      EXECUTE_IF_SET_IN_BITMAP (syms, 0, i, bi)\n+\t{\n+\t  tree sym = referenced_var_lookup (i);\n+\t  dump_generic_node (buffer, sym, 0, flags, false);\n+\t  pp_string (buffer, \" \");\n+\t}\n+\n+      pp_string (buffer, \"}\");\n+    }\n+}\n+\n+\n+/* Dump a PHI node PHI.  BUFFER, SPC and FLAGS are as in\n+   dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_phi (pretty_printer *buffer, gimple phi, int spc, int flags)\n+{\n+  size_t i;\n+\n+  if (flags & TDF_RAW)\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T, \", phi,\n+                       gimple_phi_result (phi));\n+  else\n+    {\n+      dump_generic_node (buffer, gimple_phi_result (phi), spc, flags, false);\n+      pp_string (buffer, \" = PHI <\");\n+    }\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      dump_generic_node (buffer, gimple_phi_arg_def (phi, i), spc, flags,\n+\t\t\t false);\n+      pp_string (buffer, \"(\");\n+      pp_decimal_int (buffer, gimple_phi_arg_edge (phi, i)->src->index);\n+      pp_string (buffer, \")\");\n+      if (i < gimple_phi_num_args (phi) - 1)\n+\tpp_string (buffer, \", \");\n+    }\n+  pp_string (buffer, \">\");\n+}\n+\n+\n+/* Dump a GIMPLE_OMP_PARALLEL tuple on the pretty_printer BUFFER, SPC spaces\n+   of indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_omp_parallel (pretty_printer *buffer, gimple gs, int spc,\n+                          int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+                       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_parallel_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >, %T, %T%n>\",\n+                       gimple_omp_parallel_child_fn (gs),\n+                       gimple_omp_parallel_data_arg (gs));\n+    }\n+  else\n+    {\n+      gimple_seq body;\n+      pp_string (buffer, \"#pragma omp parallel\");\n+      dump_omp_clauses (buffer, gimple_omp_parallel_clauses (gs), spc, flags);\n+      if (gimple_omp_parallel_child_fn (gs))\n+\t{\n+\t  pp_string (buffer, \" [child fn: \");\n+\t  dump_generic_node (buffer, gimple_omp_parallel_child_fn (gs),\n+\t\t\t     spc, flags, false);\n+\t  pp_string (buffer, \" (\");\n+\t  if (gimple_omp_parallel_data_arg (gs))\n+\t    dump_generic_node (buffer, gimple_omp_parallel_data_arg (gs),\n+\t\t\t       spc, flags, false);\n+\t  else\n+\t    pp_string (buffer, \"???\");\n+\t  pp_string (buffer, \")]\");\n+\t}\n+      body = gimple_omp_body (gs);\n+      if (body && gimple_code (gimple_seq_first_stmt (body)) != GIMPLE_BIND)\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, body, spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+      else if (body)\n+\t{\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, body, spc + 2, flags);\n+\t}\n+    }\n+}\n+\n+\n+/* Dump a GIMPLE_OMP_TASK tuple on the pretty_printer BUFFER, SPC spaces\n+   of indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_omp_task (pretty_printer *buffer, gimple gs, int spc,\n+\t\t      int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+                       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_task_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >, %T, %T, %T, %T, %T%n>\",\n+                       gimple_omp_task_child_fn (gs),\n+                       gimple_omp_task_data_arg (gs),\n+\t\t       gimple_omp_task_copy_fn (gs),\n+\t\t       gimple_omp_task_arg_size (gs),\n+\t\t       gimple_omp_task_arg_size (gs));\n+    }\n+  else\n+    {\n+      gimple_seq body;\n+      pp_string (buffer, \"#pragma omp task\");\n+      dump_omp_clauses (buffer, gimple_omp_task_clauses (gs), spc, flags);\n+      if (gimple_omp_task_child_fn (gs))\n+\t{\n+\t  pp_string (buffer, \" [child fn: \");\n+\t  dump_generic_node (buffer, gimple_omp_task_child_fn (gs),\n+\t\t\t     spc, flags, false);\n+\t  pp_string (buffer, \" (\");\n+\t  if (gimple_omp_task_data_arg (gs))\n+\t    dump_generic_node (buffer, gimple_omp_task_data_arg (gs),\n+\t\t\t       spc, flags, false);\n+\t  else\n+\t    pp_string (buffer, \"???\");\n+\t  pp_string (buffer, \")]\");\n+\t}\n+      body = gimple_omp_body (gs);\n+      if (body && gimple_code (gimple_seq_first_stmt (body)) != GIMPLE_BIND)\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, body, spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+      else if (body)\n+\t{\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, body, spc + 2, flags);\n+\t}\n+    }\n+}\n+\n+\n+/* Dump a GIMPLE_OMP_ATOMIC_LOAD tuple on the pretty_printer BUFFER, SPC\n+   spaces of indent.  FLAGS specifies details to show in the dump (see TDF_*\n+   in tree-pass.h).  */\n+\n+static void\n+dump_gimple_omp_atomic_load (pretty_printer *buffer, gimple gs, int spc,\n+                             int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T>\", gs,\n+                       gimple_omp_atomic_load_lhs (gs),\n+                       gimple_omp_atomic_load_rhs (gs));\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp atomic_load\");\n+      newline_and_indent (buffer, spc + 2);\n+      dump_generic_node (buffer, gimple_omp_atomic_load_lhs (gs),\n+\t  \t\t spc, flags, false);\n+      pp_space (buffer);\n+      pp_character (buffer, '=');\n+      pp_space (buffer);\n+      pp_character (buffer, '*');\n+      dump_generic_node (buffer, gimple_omp_atomic_load_rhs (gs),\n+\t  \t\t spc, flags, false);\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_ATOMIC_STORE tuple on the pretty_printer BUFFER, SPC\n+   spaces of indent.  FLAGS specifies details to show in the dump (see TDF_*\n+   in tree-pass.h).  */\n+\n+static void\n+dump_gimple_omp_atomic_store (pretty_printer *buffer, gimple gs, int spc,\n+                             int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs,\n+                       gimple_omp_atomic_store_val (gs));\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp atomic_store (\");\n+      dump_generic_node (buffer, gimple_omp_atomic_store_val (gs),\n+\t  \t\t spc, flags, false);\n+      pp_character (buffer, ')');\n+    }\n+}\n+\n+/* Dump a GIMPLE_CHANGE_DYNAMIC_TYPE statement GS.  BUFFER, SPC and\n+   FLAGS are as in dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_cdt (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T>\", gs,\n+                     gimple_cdt_new_type (gs), gimple_cdt_location (gs));\n+  else\n+    {\n+      pp_string (buffer, \"<<<change_dynamic_type (\");\n+      dump_generic_node (buffer, gimple_cdt_new_type (gs), spc + 2, flags,\n+                         false);\n+      pp_string (buffer, \") \");\n+      dump_generic_node (buffer, gimple_cdt_location (gs), spc + 2, flags,\n+                         false);\n+      pp_string (buffer, \")>>>\");\n+    }\n+}\n+\n+\n+/* Dump all the memory operands for statement GS.  BUFFER, SPC and\n+   FLAGS are as in dump_gimple_stmt.  */\n+\n+static void\n+dump_gimple_mem_ops (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  struct voptype_d *vdefs;\n+  struct voptype_d *vuses;\n+  int i, n;\n+\n+  if (!ssa_operands_active () || !gimple_references_memory_p (gs))\n+    return;\n+\n+  /* Even if the statement doesn't have virtual operators yet, it may\n+     contain symbol information (this happens before aliases have been\n+     computed).  */\n+  if ((flags & TDF_MEMSYMS)\n+      && gimple_vuse_ops (gs) == NULL\n+      && gimple_vdef_ops (gs) == NULL)\n+    {\n+      if (gimple_loaded_syms (gs))\n+\t{\n+\t  pp_string (buffer, \"# LOADS: \");\n+\t  dump_symbols (buffer, gimple_loaded_syms (gs), flags);\n+\t  newline_and_indent (buffer, spc);\n+\t}\n+\n+      if (gimple_stored_syms (gs))\n+\t{\n+\t  pp_string (buffer, \"# STORES: \");\n+\t  dump_symbols (buffer, gimple_stored_syms (gs), flags);\n+\t  newline_and_indent (buffer, spc);\n+\t}\n+\n+      return;\n+    }\n+\n+  vuses = gimple_vuse_ops (gs);\n+  while (vuses)\n+    {\n+      pp_string (buffer, \"# VUSE <\");\n+\n+      n = VUSE_NUM (vuses);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  dump_generic_node (buffer, VUSE_OP (vuses, i), spc + 2, flags, false);\n+\t  if (i < n - 1)\n+\t    pp_string (buffer, \", \");\n+\t}\n+\n+      pp_string (buffer, \">\");\n+\n+      if (flags & TDF_MEMSYMS)\n+\tdump_symbols (buffer, gimple_loaded_syms (gs), flags);\n+\n+      newline_and_indent (buffer, spc);\n+      vuses = vuses->next;\n+    }\n+\n+  vdefs = gimple_vdef_ops (gs);\n+  while (vdefs)\n+    {\n+      pp_string (buffer, \"# \");\n+      dump_generic_node (buffer, VDEF_RESULT (vdefs), spc + 2, flags, false);\n+      pp_string (buffer, \" = VDEF <\");\n+\n+      n = VDEF_NUM (vdefs);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  dump_generic_node (buffer, VDEF_OP (vdefs, i), spc + 2, flags, 0);\n+\t  if (i < n - 1)\n+\t    pp_string (buffer, \", \");\n+\t}\n+\n+      pp_string (buffer, \">\");\n+\n+      if ((flags & TDF_MEMSYMS) && vdefs->next == NULL)\n+\tdump_symbols (buffer, gimple_stored_syms (gs), flags);\n+\n+      newline_and_indent (buffer, spc);\n+      vdefs = vdefs->next;\n+    }\n+}\n+\n+\n+/* Dump the gimple statement GS on the pretty printer BUFFER, SPC\n+   spaces of indent.  FLAGS specifies details to show in the dump (see\n+   TDF_* in tree-pass.h).  */\n+\n+void\n+dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (!gs)\n+    return;\n+\n+  if (flags & TDF_STMTADDR)\n+    pp_printf (buffer, \"<&%p> \", (void *) gs);\n+\n+  if ((flags & TDF_LINENO) && gimple_has_location (gs))\n+    {\n+      expanded_location xloc = expand_location (gimple_location (gs));\n+      pp_character (buffer, '[');\n+      if (xloc.file)\n+\t{\n+\t  pp_string (buffer, xloc.file);\n+\t  pp_string (buffer, \" : \");\n+\t}\n+      pp_decimal_int (buffer, xloc.line);\n+      pp_string (buffer, \"] \");\n+    }\n+\n+  if ((flags & (TDF_VOPS|TDF_MEMSYMS))\n+      && gimple_has_mem_ops (gs))\n+    dump_gimple_mem_ops (buffer, gs, spc, flags);\n+\n+  switch (gimple_code (gs))\n+    {\n+    case GIMPLE_ASM:\n+      dump_gimple_asm (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_ASSIGN:\n+      dump_gimple_assign (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_BIND:\n+      dump_gimple_bind (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_CALL:\n+      dump_gimple_call (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_COND:\n+      dump_gimple_cond (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_LABEL:\n+      dump_gimple_label (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_GOTO:\n+      dump_gimple_goto (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_NOP:\n+      pp_string (buffer, \"GIMPLE_NOP\");\n+      break;\n+\n+    case GIMPLE_RETURN:\n+      dump_gimple_return (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_SWITCH:\n+      dump_gimple_switch (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_TRY:\n+      dump_gimple_try (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_PHI:\n+      dump_gimple_phi (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_PARALLEL:\n+      dump_gimple_omp_parallel (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_TASK:\n+      dump_gimple_omp_task (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_ATOMIC_LOAD:\n+      dump_gimple_omp_atomic_load (buffer, gs, spc, flags);\n+\n+      break;\n+\n+    case GIMPLE_OMP_ATOMIC_STORE:\n+      dump_gimple_omp_atomic_store (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_FOR:\n+      dump_gimple_omp_for (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_CONTINUE:\n+      dump_gimple_omp_continue (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_SINGLE:\n+      dump_gimple_omp_single (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_RETURN:\n+      dump_gimple_omp_return (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_SECTIONS:\n+      dump_gimple_omp_sections (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_SECTIONS_SWITCH:\n+      pp_string (buffer, \"GIMPLE_SECTIONS_SWITCH\");\n+      break;\n+\n+    case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_ORDERED:\n+    case GIMPLE_OMP_SECTION:\n+      dump_gimple_omp_block (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_CRITICAL:\n+      dump_gimple_omp_critical (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_CHANGE_DYNAMIC_TYPE:\n+      dump_gimple_cdt (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_CATCH:\n+      dump_gimple_catch (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_EH_FILTER:\n+      dump_gimple_eh_filter (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_RESX:\n+      dump_gimple_resx (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_PREDICT:\n+      pp_string (buffer, \"// predicted \");\n+      if (gimple_predict_outcome (gs))\n+\tpp_string (buffer, \"likely by \");\n+      else\n+\tpp_string (buffer, \"unlikely by \");\n+      pp_string (buffer, predictor_name (gimple_predict_predictor (gs)));\n+      pp_string (buffer, \" predictor.\");\n+      break;\n+\n+    default:\n+      GIMPLE_NIY;\n+    }\n+\n+  /* If we're building a diagnostic, the formatted text will be\n+     written into BUFFER's stream by the caller; otherwise, write it\n+     now.  */\n+  if (!(flags & TDF_DIAGNOSTIC))\n+    pp_write_text_to_stream (buffer);\n+}\n+\n+\n+/* Dumps header of basic block BB to buffer BUFFER indented by INDENT\n+   spaces and details described by flags.  */\n+\n+static void\n+dump_bb_header (pretty_printer *buffer, basic_block bb, int indent, int flags)\n+{\n+  edge e;\n+  gimple stmt;\n+  edge_iterator ei;\n+\n+  if (flags & TDF_BLOCKS)\n+    {\n+      INDENT (indent);\n+      pp_string (buffer, \"# BLOCK \");\n+      pp_decimal_int (buffer, bb->index);\n+      if (bb->frequency)\n+\t{\n+          pp_string (buffer, \" freq:\");\n+          pp_decimal_int (buffer, bb->frequency);\n+\t}\n+      if (bb->count)\n+\t{\n+          pp_string (buffer, \" count:\");\n+          pp_widest_integer (buffer, bb->count);\n+\t}\n+\n+      if (flags & TDF_LINENO)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    if (get_lineno (gsi_stmt (gsi)) != -1)\n+\t      {\n+\t\tpp_string (buffer, \", starting at line \");\n+\t\tpp_decimal_int (buffer, get_lineno (gsi_stmt (gsi)));\n+\t\tbreak;\n+\t      }\n+\t}\n+      newline_and_indent (buffer, indent);\n+\n+      pp_string (buffer, \"# PRED:\");\n+      pp_write_text_to_stream (buffer);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (flags & TDF_SLIM)\n+\t  {\n+\t    pp_string (buffer, \" \");\n+\t    if (e->src == ENTRY_BLOCK_PTR)\n+\t      pp_string (buffer, \"ENTRY\");\n+\t    else\n+\t      pp_decimal_int (buffer, e->src->index);\n+\t  }\n+\telse\n+\t  dump_edge_info (buffer->buffer->stream, e, 0);\n+      pp_newline (buffer);\n+    }\n+  else\n+    {\n+      stmt = first_stmt (bb);\n+      if (!stmt || gimple_code (stmt) != GIMPLE_LABEL)\n+\t{\n+\t  INDENT (indent - 2);\n+\t  pp_string (buffer, \"<bb \");\n+\t  pp_decimal_int (buffer, bb->index);\n+\t  pp_string (buffer, \">:\");\n+\t  pp_newline (buffer);\n+\t}\n+    }\n+  pp_write_text_to_stream (buffer);\n+  check_bb_profile (bb, buffer->buffer->stream);\n+}\n+\n+\n+/* Dumps end of basic block BB to buffer BUFFER indented by INDENT\n+   spaces.  */\n+\n+static void\n+dump_bb_end (pretty_printer *buffer, basic_block bb, int indent, int flags)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  INDENT (indent);\n+  pp_string (buffer, \"# SUCC:\");\n+  pp_write_text_to_stream (buffer);\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (flags & TDF_SLIM)\n+      {\n+\tpp_string (buffer, \" \");\n+\tif (e->dest == EXIT_BLOCK_PTR)\n+\t  pp_string (buffer, \"EXIT\");\n+\telse\n+\t  pp_decimal_int (buffer, e->dest->index);\n+      }\n+    else\n+      dump_edge_info (buffer->buffer->stream, e, 1);\n+  pp_newline (buffer);\n+}\n+\n+\n+/* Dump PHI nodes of basic block BB to BUFFER with details described\n+   by FLAGS and indented by INDENT spaces.  */\n+\n+static void\n+dump_phi_nodes (pretty_printer *buffer, basic_block bb, int indent, int flags)\n+{\n+  gimple_stmt_iterator i;\n+\n+  for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n+    {\n+      gimple phi = gsi_stmt (i);\n+      if (is_gimple_reg (gimple_phi_result (phi)) || (flags & TDF_VOPS))\n+        {\n+          INDENT (indent);\n+          pp_string (buffer, \"# \");\n+          dump_gimple_phi (buffer, phi, indent, flags);\n+          pp_newline (buffer);\n+        }\n+    }\n+}\n+\n+\n+/* Dump jump to basic block BB that is represented implicitly in the cfg\n+   to BUFFER.  */\n+\n+static void\n+pp_cfg_jump (pretty_printer *buffer, basic_block bb)\n+{\n+  gimple stmt;\n+\n+  stmt = first_stmt (bb);\n+\n+  pp_string (buffer, \"goto <bb \");\n+  pp_decimal_int (buffer, bb->index);\n+  pp_string (buffer, \">\");\n+  if (stmt && gimple_code (stmt) == GIMPLE_LABEL)\n+    {\n+      pp_string (buffer, \" (\");\n+      dump_generic_node (buffer, gimple_label_label (stmt), 0, 0, false);\n+      pp_string (buffer, \")\");\n+      pp_semicolon (buffer);\n+    }\n+  else\n+    pp_semicolon (buffer);\n+}\n+\n+\n+/* Dump edges represented implicitly in basic block BB to BUFFER, indented\n+   by INDENT spaces, with details given by FLAGS.  */\n+\n+static void\n+dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n+\t\t     int flags)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple stmt;\n+\n+  stmt = last_stmt (bb);\n+\n+  if (stmt && gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      edge true_edge, false_edge;\n+\n+      /* When we are emitting the code or changing CFG, it is possible that\n+\t the edges are not yet created.  When we are using debug_bb in such\n+\t a situation, we do not want it to crash.  */\n+      if (EDGE_COUNT (bb->succs) != 2)\n+\treturn;\n+      extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\n+      INDENT (indent + 2);\n+      pp_cfg_jump (buffer, true_edge->dest);\n+      newline_and_indent (buffer, indent);\n+      pp_string (buffer, \"else\");\n+      newline_and_indent (buffer, indent + 2);\n+      pp_cfg_jump (buffer, false_edge->dest);\n+      pp_newline (buffer);\n+      return;\n+    }\n+\n+  /* If there is a fallthru edge, we may need to add an artificial\n+     goto to the dump.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_FALLTHRU)\n+      break;\n+\n+  if (e && e->dest != bb->next_bb)\n+    {\n+      INDENT (indent);\n+\n+      if ((flags & TDF_LINENO)\n+\t  && e->goto_locus != UNKNOWN_LOCATION\n+\t  )\n+\t{\n+\t  expanded_location goto_xloc;\n+\t  goto_xloc = expand_location (e->goto_locus);\n+\t  pp_character (buffer, '[');\n+\t  if (goto_xloc.file)\n+\t    {\n+\t      pp_string (buffer, goto_xloc.file);\n+\t      pp_string (buffer, \" : \");\n+\t    }\n+\t  pp_decimal_int (buffer, goto_xloc.line);\n+\t  pp_string (buffer, \"] \");\n+\t}\n+\n+      pp_cfg_jump (buffer, e->dest);\n+      pp_newline (buffer);\n+    }\n+}\n+\n+\n+/* Dumps basic block BB to buffer BUFFER with details described by FLAGS and\n+   indented by INDENT spaces.  */\n+\n+static void\n+gimple_dump_bb_buff (pretty_printer *buffer, basic_block bb, int indent,\n+\t\t     int flags)\n+{\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  int label_indent = indent - 2;\n+\n+  if (label_indent < 0)\n+    label_indent = 0;\n+\n+  dump_bb_header (buffer, bb, indent, flags);\n+  dump_phi_nodes (buffer, bb, indent, flags);\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      int curr_indent;\n+\n+      stmt = gsi_stmt (gsi);\n+\n+      curr_indent = gimple_code (stmt) == GIMPLE_LABEL ? label_indent : indent;\n+\n+      INDENT (curr_indent);\n+      dump_gimple_stmt (buffer, stmt, curr_indent, flags);\n+      pp_newline (buffer);\n+      dump_histograms_for_stmt (cfun, buffer->buffer->stream, stmt);\n+    }\n+\n+  dump_implicit_edges (buffer, bb, indent, flags);\n+\n+  if (flags & TDF_BLOCKS)\n+    dump_bb_end (buffer, bb, indent, flags);\n+}\n+\n+\n+/* Dumps basic block BB to FILE with details described by FLAGS and\n+   indented by INDENT spaces.  */\n+\n+void\n+gimple_dump_bb (basic_block bb, FILE *file, int indent, int flags)\n+{\n+  maybe_init_pretty_print (file);\n+  gimple_dump_bb_buff (&buffer, bb, indent, flags);\n+  pp_flush (&buffer);\n+}"}, {"sha": "69cfd4e1db803b4b360e21f07cd80ebfa2ce51c3", "filename": "gcc/gimple.c", "status": "added", "additions": 3144, "deletions": 0, "changes": 3144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "23eaae2e86ee2d3a18cd8eacd5bb6d5a54e86e9a", "filename": "gcc/gimple.def", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -0,0 +1,357 @@\n+/* This file contains the definitions of the GIMPLE IR tuples used in GCC.\n+\n+   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* The format of this file is\n+   DEFGSCODE(GIMPLE_symbol, printable name, structure).\n+\n+   Where symbol is the enumeration name without the ``GIMPLE_''.\n+   The argument STRUCTURE is used to compute offsets into each of the\n+   tuple structures that contain operands.  Since vector operands\n+   are at different offsets depending on the particular structure\n+   used, these offsets are computed at compile time for efficient\n+   lookup at runtime.  See gimple_ops().\n+\n+   If a code does not use operand vectors, STRUCTURE should be NULL.  */\n+\n+/* Error marker.  This is used in similar ways as ERROR_MARK in tree.def.  */\n+DEFGSCODE(GIMPLE_ERROR_MARK, \"gimple_error_mark\", NULL)\n+\n+/* IMPORTANT.  Do not rearrange the codes between GIMPLE_COND and\n+   GIMPLE_RETURN.  The ordering is exposed by gimple_has_ops calls.\n+   These are all the GIMPLE statements with register operands.  */\n+\n+/* GIMPLE_COND <COND_CODE, OP1, OP2, TRUE_LABEL, FALSE_LABEL>\n+   represents the conditional jump:\n+   \n+   if (OP1 COND_CODE OP2) goto TRUE_LABEL else goto FALSE_LABEL\n+\n+   COND_CODE is the tree code used as the comparison predicate.  It\n+   must be of class tcc_comparison.\n+\n+   OP1 and OP2 are the operands used in the comparison.  They must be\n+   accepted by is_gimple_operand.\n+\n+   TRUE_LABEL and FALSE_LABEL are the LABEL_DECL nodes used as the\n+   jump target for the comparison.  */\n+DEFGSCODE(GIMPLE_COND, \"gimple_cond\", struct gimple_statement_with_ops)\n+\n+/* GIMPLE_GOTO <TARGET> represents unconditional jumps.\n+   TARGET is a LABEL_DECL or an expression node for computed GOTOs.  */\n+DEFGSCODE(GIMPLE_GOTO, \"gimple_goto\", struct gimple_statement_with_ops)\n+\n+/* GIMPLE_LABEL <LABEL> represents label statements.  LABEL is a\n+   LABEL_DECL representing a jump target.  */\n+DEFGSCODE(GIMPLE_LABEL, \"gimple_label\", struct gimple_statement_with_ops)\n+\n+/* GIMPLE_SWITCH <INDEX, DEFAULT_LAB, LAB1, ..., LABN> represents the\n+   multiway branch:\n+\n+   switch (INDEX)\n+   {\n+     case LAB1: ...; break;\n+     ...\n+     case LABN: ...; break;\n+     default: ...\n+   }\n+\n+   INDEX is the variable evaluated to decide which label to jump to.\n+\n+   DEFAULT_LAB, LAB1 ... LABN are the tree nodes representing case labels.\n+   They must be CASE_LABEL_EXPR nodes.  */\n+DEFGSCODE(GIMPLE_SWITCH, \"gimple_switch\", struct gimple_statement_with_ops)\n+\n+/* GIMPLE_CHANGE_DYNAMIC_TYPE indicates a change in the dynamic type\n+   of a memory location.  This has no value and generates no\n+   executable code.  It is only used for type based alias analysis.\n+   This is generated by C++ placement new and it's a direct\n+   translation from CHANGE_DYNAMIC_TYPE_EXPR.  The first operand\n+   (gimple_cdt_new_type) is the new type.  The second operand\n+   (gimple_cdt_location) is the location (pointer) whose type is being\n+   changed.  */\n+DEFGSCODE(GIMPLE_CHANGE_DYNAMIC_TYPE, \"gimple_change_dynamic_type\",\n+\t  struct gimple_statement_with_ops)\n+\n+/* IMPORTANT.\n+   \n+   Do not rearrange the codes between GIMPLE_ASSIGN and GIMPLE_RETURN.\n+   It's exposed by GIMPLE_RANGE_CHECK calls. These are all the GIMPLE\n+   statements with memory and register operands.  */\n+\n+/* GIMPLE_ASSIGN <SUBCODE, LHS, RHS1[, RHS2]> represents the assignment\n+   statement\n+\n+   LHS = RHS1 SUBCODE RHS2.\n+\n+   SUBCODE is the tree code for the expression computed by the RHS of the\n+   assignment.  It must be one of the tree codes accepted by\n+   get_gimple_rhs_class.\n+\n+   LHS is the operand on the LHS of the assignment.  It must be a tree node\n+   accepted by is_gimple_operand.\n+\n+   RHS1 is the first operand on the RHS of the assignment. It must be a tree\n+   node accepted by is_gimple_operand.\n+\n+   RHS2 is the second operand on the RHS of the assignemnt. It must be a tree\n+   node accepted by is_gimple_operand.  This argument exists only if SUBCODE is\n+   of class GIMPLE_BINARY_RHS.  */\n+DEFGSCODE(GIMPLE_ASSIGN, \"gimple_assign\",\n+\t  struct gimple_statement_with_memory_ops)\n+\n+/* GIMPLE_ASM <STRING, I1, ..., IN, O1, ... OM, C1, ..., CP>\n+   represents inline assembly statements.\n+\n+   STRING is the string containing the assembly statements.\n+   I1 ... IN are the N input operands.\n+   O1 ... OM are the M output operands.\n+   C1 ... CP are the P clobber operands.  */\n+DEFGSCODE(GIMPLE_ASM, \"gimple_asm\", struct gimple_statement_asm)\n+\n+/* GIMPLE_CALL <FN, LHS, ARG1, ..., ARGN[, CHAIN]> represents function\n+   calls.\n+\n+   FN is the callee.  It must be accepted by is_gimple_call_addr.\n+\n+   LHS is the operand where the return value from FN is stored.  It may\n+   be NULL.\n+\n+   ARG1 ... ARGN are the arguments.  They must all be accepted by\n+   is_gimple_operand.\n+\n+    CHAIN is the optional static chain link for nested functions.  */\n+DEFGSCODE(GIMPLE_CALL, \"gimple_call\",\n+\t  struct gimple_statement_with_memory_ops)\n+\n+/* GIMPLE_RETURN <RETVAL> represents return statements.\n+\n+   RETVAL is the value to return or NULL.  If a value is returned it\n+   must be accepted by is_gimple_operand.  */\n+DEFGSCODE(GIMPLE_RETURN, \"gimple_return\",\n+\t  struct gimple_statement_with_memory_ops)\n+\n+/* GIMPLE_BIND <VARS, BLOCK, BODY> represents a lexical scope.\n+   VARS is the set of variables declared in that scope.\n+   BLOCK is the symbol binding block used for debug information.  \n+   BODY is the sequence of statements in the scope.  */\n+DEFGSCODE(GIMPLE_BIND, \"gimple_bind\", NULL)\n+\n+/* GIMPLE_CATCH <TYPES, HANDLER> represents a typed exception handler.\n+   TYPES is the type (or list of types) handled.  HANDLER is the\n+   sequence of statements that handle these types.  */\n+DEFGSCODE(GIMPLE_CATCH, \"gimple_catch\", NULL)\n+\n+/* GIMPLE_EH_FILTER <TYPES, FAILURE> represents an exception\n+   specification.  TYPES is a list of allowed types and FAILURE is the\n+   sequence of statements to execute on failure.  */\n+DEFGSCODE(GIMPLE_EH_FILTER, \"gimple_eh_filter\", NULL)\n+\n+/* GIMPLE_PHI <RESULT, ARG1, ..., ARGN> represents the PHI node\n+\n+   RESULT = PHI <ARG1, ..., ARGN>\n+\n+   RESULT is the SSA name created by this PHI node.\n+\n+   ARG1 ... ARGN are the arguments to the PHI node.  N must be\n+   exactly the same as the number of incoming edges to the basic block\n+   holding the PHI node.  Every argument is either an SSA name or a\n+   tree node of class tcc_constant.  */\n+DEFGSCODE(GIMPLE_PHI, \"gimple_phi\", NULL)\n+\n+/* GIMPLE_RESX <REGION> resumes execution after an exception.\n+   REGION is the region number being left.  */\n+DEFGSCODE(GIMPLE_RESX, \"gimple_resx\", NULL)\n+\n+/* GIMPLE_TRY <TRY_KIND, EVAL, CLEANUP>\n+   represents a try/catch or a try/finally statement.\n+\n+   TRY_KIND is either GIMPLE_TRY_CATCH or GIMPLE_TRY_FINALLY.\n+\n+   EVAL is the sequence of statements to execute on entry to GIMPLE_TRY.\n+\n+   CLEANUP is the sequence of statements to execute according to\n+   TRY_KIND.  If TRY_KIND is GIMPLE_TRY_CATCH, CLEANUP is only exected\n+   if an exception is thrown during execution of EVAL.  If TRY_KIND is\n+   GIMPLE_TRY_FINALLY, CLEANUP is always executed after executing EVAL\n+   (regardless of whether EVAL finished normally, or jumped out or an\n+   exception was thrown).  */\n+DEFGSCODE(GIMPLE_TRY, \"gimple_try\", NULL)\n+\n+/* GIMPLE_NOP represents the \"do nothing\" statement.  */\n+DEFGSCODE(GIMPLE_NOP, \"gimple_nop\", NULL)\n+\n+\n+/* IMPORTANT.\n+   \n+   Do not rearrange any of the GIMPLE_OMP_* codes.  This ordering is\n+   exposed by the range check in gimple_omp_subcode().  */\n+\n+\n+/* Tuples used for lowering of OMP_ATOMIC.  Although the form of the OMP_ATOMIC\n+   expression is very simple (just in form mem op= expr), various implicit\n+   conversions may cause the expression to become more complex, so that it does\n+   not fit the gimple grammar very well.  To overcome this problem, OMP_ATOMIC\n+   is rewritten as a sequence of two codes in gimplification:\n+\n+   GIMPLE_OMP_LOAD (tmp, mem)\n+   val = some computations involving tmp;\n+   GIMPLE_OMP_STORE (val).  */\n+DEFGSCODE(GIMPLE_OMP_ATOMIC_LOAD, \"gimple_omp_atomic_load\", NULL)\n+DEFGSCODE(GIMPLE_OMP_ATOMIC_STORE, \"gimple_omp_atomic_store\", NULL)\n+\n+/* GIMPLE_OMP_CONTINUE marks the location of the loop or sections\n+   iteration in partially lowered OpenMP code.  */\n+DEFGSCODE(GIMPLE_OMP_CONTINUE, \"gimple_omp_continue\", NULL)\n+\n+/* GIMPLE_OMP_CRITICAL <NAME, BODY> represents\n+\n+   #pragma omp critical [name]\n+\n+   NAME is the name given to the critical section.\n+   BODY is the sequence of statements that are inside the critical section.  */\n+DEFGSCODE(GIMPLE_OMP_CRITICAL, \"gimple_omp_critical\", NULL)\n+\n+/* GIMPLE_OMP_FOR <BODY, CLAUSES, INDEX, INITIAL, FINAL, COND, INCR, PRE_BODY>\n+   represents\n+\n+   PRE_BODY\n+   #pragma omp for [clause1 ... clauseN]\n+   for (INDEX = INITIAL; INDEX COND FINAL; INDEX {+=,-=} INCR)\n+   BODY\n+\n+   BODY is the loop body.\n+\n+   CLAUSES is the list of clauses.\n+\n+   INDEX must be an integer or pointer variable, which is implicitly thread\n+   private.  It must be accepted by is_gimple_operand.\n+\n+   INITIAL is the initial value given to INDEX. It must be\n+   accepted by is_gimple_operand.\n+\n+   FINAL is the final value that INDEX should take. It must\n+   be accepted by is_gimple_operand.\n+\n+   COND is the condition code for the controlling predicate.  It must\n+   be one of { <, >, <=, >= }\n+\n+   INCR is the loop index increment.  It must be tree node of type\n+   tcc_constant.\n+\n+   PRE_BODY is a landing pad filled by the gimplifier with things from\n+   INIT, COND, and INCR that are technically part of the OMP_FOR\n+   structured block, but are evaluated before the loop body begins.\n+\n+   INITIAL, FINAL and INCR are required to be loop invariant integer\n+   expressions that are evaluated without any synchronization.\n+   The evaluation order, frequency of evaluation and side-effects are\n+   unspecified by the standard.  */\n+DEFGSCODE(GIMPLE_OMP_FOR, \"gimple_omp_for\", NULL)\n+\n+/* GIMPLE_OMP_MASTER <BODY> represents #pragma omp master.\n+   BODY is the sequence of statements to execute in the master section.  */\n+DEFGSCODE(GIMPLE_OMP_MASTER, \"gimple_omp_master\", NULL)\n+\n+/* GIMPLE_OMP_ORDERED <BODY> represents #pragma omp ordered.\n+   BODY is the sequence of statements to execute in the ordered section.  */\n+DEFGSCODE(GIMPLE_OMP_ORDERED, \"gimple_omp_ordered\", NULL)\n+\n+/* GIMPLE_OMP_PARALLEL <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents\n+\n+   #pragma omp parallel [CLAUSES]\n+   BODY\n+\n+   BODY is a the sequence of statements to be executed by all threads.\n+\n+   CLAUSES is a TREE_LIST node with all the clauses.\n+\n+   CHILD_FN is set when outlining the body of the parallel region.\n+   All the statements in BODY are moved into this newly created\n+   function when converting OMP constructs into low-GIMPLE.\n+\n+   DATA_ARG is a local variable in the parent function containing data\n+   to be shared with CHILD_FN.  This is used to implement all the data\n+   sharing clauses.  */\n+DEFGSCODE(GIMPLE_OMP_PARALLEL, \"gimple_omp_parallel\", NULL)\n+\n+/* GIMPLE_OMP_TASK <BODY, CLAUSES, CHILD_FN, DATA_ARG, COPY_FN,\n+\t\t    ARG_SIZE, ARG_ALIGN> represents\n+\n+   #pragma omp task [CLAUSES]\n+   BODY\n+\n+   BODY is a the sequence of statements to be executed by all threads.\n+\n+   CLAUSES is a TREE_LIST node with all the clauses.\n+\n+   CHILD_FN is set when outlining the body of the explicit task region.\n+   All the statements in BODY are moved into this newly created\n+   function when converting OMP constructs into low-GIMPLE.\n+\n+   DATA_ARG is a local variable in the parent function containing data\n+   to be shared with CHILD_FN.  This is used to implement all the data\n+   sharing clauses.\n+\n+   COPY_FN is set when outlining the firstprivate var initialization.\n+   All the needed statements are emitted into the newly created\n+   function, or when only memcpy is needed, it is NULL.\n+\n+   ARG_SIZE and ARG_ALIGN are the size and alignment of the incoming\n+   data area allocated by GOMP_task and passed to CHILD_FN.  */\n+DEFGSCODE(GIMPLE_OMP_TASK, \"gimple_omp_task\", NULL)\n+\n+/* OMP_RETURN marks the end of an OpenMP directive.  */\n+DEFGSCODE(GIMPLE_OMP_RETURN, \"gimple_omp_return\", NULL)\n+\n+/* OMP_SECTION <BODY> represents #pragma omp section.\n+   BODY is the sequence of statements in the section body.  */\n+DEFGSCODE(GIMPLE_OMP_SECTION, \"gimple_omp_section\", NULL)\n+\n+/* OMP_SECTIONS <BODY, CLAUSES, CONTROL> represents #pragma omp sections.\n+\n+   BODY is the sequence of statements in the sections body.\n+   CLAUSES is a TREE_LIST node holding the list of associated clauses.\n+   CONTROL is a VAR_DECL used for deciding which of the sections\n+   to execute.  */\n+DEFGSCODE(GIMPLE_OMP_SECTIONS, \"gimple_omp_sections\", NULL)\n+\n+/* GIMPLE_OMP_SECTIONS_SWITCH is a marker placed immediately after\n+   OMP_SECTIONS.  It represents the GIMPLE_SWITCH used to decide which\n+   branch is taken.  */\n+DEFGSCODE(GIMPLE_OMP_SECTIONS_SWITCH, \"gimple_omp_sections_switch\", NULL)\n+\n+/* GIMPLE_OMP_SINGLE <BODY, CLAUSES> represents #pragma omp single\n+   BODY is the sequence of statements inside the single section.\n+   CLAUSES is a TREE_LIST node holding the associated clauses.  */\n+DEFGSCODE(GIMPLE_OMP_SINGLE, \"gimple_omp_single\", NULL)\n+\n+/* GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction.\n+\n+   PREDICT is one of the predictors from predict.def.\n+\n+   OUTCOME is NOT_TAKEN or TAKEN.  */\n+DEFGSCODE(GIMPLE_PREDICT, \"gimple_predict\", NULL)\n+\n+/*  This node represents a cleanup expression.  It is ONLY USED INTERNALLY\n+    by the gimplifier as a placeholder for cleanups, and its uses will be\n+    cleaned up by the time gimplification is done.\n+    \n+    This tuple should not exist outside of the gimplifier proper.  */\n+DEFGSCODE(GIMPLE_WITH_CLEANUP_EXPR, \"gimple_with_cleanup_expr\", NULL)"}, {"sha": "744461d7310db08a019cf179e774da0ce7a055a7", "filename": "gcc/gimple.h", "status": "added", "additions": 4539, "deletions": 0, "changes": 4539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "0f08f3b7393a32ae6a7043c735f58eef21dd553e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1719, "deletions": 951, "changes": 2670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "b524a37bcf4bfcc99dd8aedd1e844cb069d67950", "filename": "gcc/gsstruct.def", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -0,0 +1,48 @@\n+/* This file contains the definitions for the gimple IR structure\n+   enumeration used in GCC.\n+\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* The format of this file is\n+   DEFGSSTRUCT(GSS_enumeration value, printable name).\n+   Each enum value should correspond with a single member of the union\n+   gimple_statement_d.  */\n+\n+DEFGSSTRUCT(GSS_BASE, \"base\")\n+DEFGSSTRUCT(GSS_WITH_OPS, \"with_ops\")\n+DEFGSSTRUCT(GSS_WITH_MEM_OPS, \"with_mem_ops\")\n+DEFGSSTRUCT(GSS_OMP, \"omp\")\n+DEFGSSTRUCT(GSS_BIND, \"bind\")\n+DEFGSSTRUCT(GSS_CATCH, \"catch\")\n+DEFGSSTRUCT(GSS_EH_FILTER, \"eh_filter\")\n+DEFGSSTRUCT(GSS_PHI, \"phi\")\n+DEFGSSTRUCT(GSS_RESX, \"resx\")\n+DEFGSSTRUCT(GSS_TRY, \"try\")\n+DEFGSSTRUCT(GSS_WCE, \"with_cleanup_expression\")\n+DEFGSSTRUCT(GSS_ASM, \"asm\")\n+DEFGSSTRUCT(GSS_OMP_CRITICAL, \"omp_critical\")\n+DEFGSSTRUCT(GSS_OMP_FOR, \"omp_for\")\n+DEFGSSTRUCT(GSS_OMP_PARALLEL, \"omp_parallel\")\n+DEFGSSTRUCT(GSS_OMP_TASK, \"omp_task\")\n+DEFGSSTRUCT(GSS_OMP_SECTIONS, \"sections\")\n+DEFGSSTRUCT(GSS_OMP_SINGLE, \"single\")\n+DEFGSSTRUCT(GSS_OMP_CONTINUE, \"omp_continue\")\n+DEFGSSTRUCT(GSS_OMP_ATOMIC_LOAD, \"omp_atomic_load\")\n+DEFGSSTRUCT(GSS_OMP_ATOMIC_STORE, \"omp_atomic_store\")"}, {"sha": "af1cc0fd787296d4e0518b2f5b4cf9e19365c152", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -359,18 +359,15 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n /* Create a new assignment statement and make it the first statement in the\n    function.  PARM1 is the lhs of the assignment and VAL is the rhs. */\n static void\n-constant_val_insert (tree parm1, tree val)\n+constant_val_insert (tree parm1 ATTRIBUTE_UNUSED, tree val ATTRIBUTE_UNUSED)\n {\n-  tree init_stmt = NULL;\n+  gimple init_stmt = NULL;\n   edge e_step;\n \n-  init_stmt = build_gimple_modify_stmt (parm1, val);\n-\n-  if (init_stmt)\n-    {\n-      e_step = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun));\n-      bsi_insert_on_edge_immediate (e_step, init_stmt);\n-    }\n+  init_stmt = gimple_build_assign (parm1, val);\n+  gcc_assert (init_stmt);\n+  e_step = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun));\n+  gsi_insert_on_edge_immediate (e_step, init_stmt);\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n@@ -810,9 +807,7 @@ ipcp_update_callgraph (void)\n \t    if (ipcp_need_redirect_p (cs))\n \t      {\n \t\tcgraph_redirect_edge_callee (cs, orig_callee);\n-\t\tTREE_OPERAND (CALL_EXPR_FN (get_call_expr_in (cs->call_stmt)),\n-\t\t\t      0) =\n-\t\t  orig_callee->decl;\n+\t\tgimple_call_set_fn (cs->call_stmt, orig_callee->decl);\n \t      }\n \t  }\n     }\n@@ -944,7 +939,7 @@ ipcp_insert_stage (void)\n       if (const_param > 0)\n \t{\n \t  push_cfun (DECL_STRUCT_FUNCTION (node1->decl));\n-\t  tree_register_cfg_hooks ();\n+\t  gimple_register_cfg_hooks ();\n \t  current_function_decl = node1->decl;\n \n \t  for (i = 0; i < count; i++)"}, {"sha": "0ccaa6bb24f3c988a70e15edc122113d49d959e3", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -195,9 +195,11 @@ cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n    clones or re-using node originally representing out-of-line function call.\n    */\n void\n-cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_original)\n+cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n+\t\t\t    bool update_original)\n {\n   HOST_WIDE_INT peak;\n+\n   if (duplicate)\n     {\n       /* We may eliminate the need for out-of-line copy to be output.\n@@ -207,7 +209,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_o\n \t  && !cgraph_new_nodes)\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n-\t  if (DECL_SAVED_TREE (e->callee->decl))\n+\t  if (gimple_body (e->callee->decl))\n \t    overall_insns -= e->callee->global.insns, nfunctions_inlined++;\n \t  duplicate = false;\n \t}\n@@ -289,7 +291,7 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n   struct cgraph_node *what = edge->callee;\n   struct cgraph_edge *e, *next;\n \n-  gcc_assert (!CALL_STMT_CANNOT_INLINE_P (edge->call_stmt));\n+  gcc_assert (!gimple_call_cannot_inline_p (edge->call_stmt));\n   /* Look for all calls, mark them inline and clone recursively\n      all inlined functions.  */\n   for (e = what->callers; e; e = next)\n@@ -971,7 +973,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t}\n       if (!tree_can_inline_p (edge->caller->decl, edge->callee->decl))\n \t{\n-\t  CALL_STMT_CANNOT_INLINE_P (edge->call_stmt) = true;\n+\t  gimple_call_set_cannot_inline (edge->call_stmt, true);\n \t  edge->inline_failed = N_(\"target specific option mismatch\");\n \t  if (dump_file)\n \t    fprintf (dump_file, \" inline_failed:%s.\\n\", edge->inline_failed);\n@@ -992,7 +994,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       else\n \t{\n \t  struct cgraph_node *callee;\n-\t  if (CALL_STMT_CANNOT_INLINE_P (edge->call_stmt)\n+\t  if (gimple_call_cannot_inline_p (edge->call_stmt)\n \t      || !cgraph_check_inline_limits (edge->caller, edge->callee,\n \t\t\t\t\t      &edge->inline_failed, true))\n \t    {\n@@ -1126,14 +1128,14 @@ cgraph_decide_inlining (void)\n       for (e = node->callers; e; e = next)\n \t{\n \t  next = e->next_caller;\n-\t  if (!e->inline_failed || CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n+\t  if (!e->inline_failed || gimple_call_cannot_inline_p (e->call_stmt))\n \t    continue;\n \t  if (cgraph_recursive_inlining_p (e->caller, e->callee,\n \t\t\t\t  \t   &e->inline_failed))\n \t    continue;\n \t  if (!tree_can_inline_p (e->caller->decl, e->callee->decl))\n \t    {\n-\t      CALL_STMT_CANNOT_INLINE_P (e->call_stmt) = true;\n+\t      gimple_call_set_cannot_inline (e->call_stmt, true);\n \t      continue;\n \t    }\n \t  cgraph_mark_inline_edge (e, true);\n@@ -1172,15 +1174,18 @@ cgraph_decide_inlining (void)\n \tfprintf (dump_file, \"\\nDeciding on functions called once:\\n\");\n \n       /* And finally decide what functions are called once.  */\n-\n       for (i = nnodes - 1; i >= 0; i--)\n \t{\n \t  node = order[i];\n \n-\t  if (node->callers && !node->callers->next_caller && !node->needed\n-\t      && node->local.inlinable && node->callers->inline_failed\n-\t      && !CALL_STMT_CANNOT_INLINE_P (node->callers->call_stmt)\n-\t      && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n+\t  if (node->callers\n+\t      && !node->callers->next_caller\n+\t      && !node->needed\n+\t      && node->local.inlinable\n+\t      && node->callers->inline_failed\n+\t      && !gimple_call_cannot_inline_p (node->callers->call_stmt)\n+\t      && !DECL_EXTERNAL (node->decl)\n+\t      && !DECL_COMDAT (node->decl))\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -1342,7 +1347,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n       if (!e->callee->local.disregard_inline_limits\n \t  && (mode != INLINE_ALL || !e->callee->local.inlinable))\n \tcontinue;\n-      if (CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n+      if (gimple_call_cannot_inline_p (e->call_stmt))\n \tcontinue;\n       /* When the edge is already inlined, we just need to recurse into\n \t it in order to fully flatten the leaves.  */\n@@ -1369,7 +1374,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t}\n       if (!tree_can_inline_p (node->decl, e->callee->decl))\n \t{\n-\t  CALL_STMT_CANNOT_INLINE_P (e->call_stmt) = true;\n+\t  gimple_call_set_cannot_inline (e->call_stmt, true);\n \t  if (dump_file)\n \t    {\n \t      indent_to (dump_file, depth);\n@@ -1388,7 +1393,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t    }\n \t  continue;\n \t}\n-      if (!DECL_SAVED_TREE (e->callee->decl) && !e->callee->inline_decl)\n+      if (!gimple_body (e->callee->decl) && !e->callee->inline_decl)\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1402,7 +1407,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n     }\n \n   /* Now do the automatic inlining.  */\n-  if (!flag_really_no_inline && mode != INLINE_ALL\n+  if (!flag_really_no_inline\n+      && mode != INLINE_ALL\n       && mode != INLINE_ALWAYS_INLINE)\n     for (e = node->callees; e; e = e->next_callee)\n       {\n@@ -1455,7 +1461,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  }\n \tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n \t\t\t\t        false)\n-\t    || CALL_STMT_CANNOT_INLINE_P (e->call_stmt))\n+\t    || gimple_call_cannot_inline_p (e->call_stmt))\n \t  {\n \t    if (dump_file)\n \t      {\n@@ -1464,7 +1470,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t      }\n \t    continue;\n \t  }\n-\tif (!DECL_SAVED_TREE (e->callee->decl) && !e->callee->inline_decl)\n+\tif (!gimple_body (e->callee->decl) && !e->callee->inline_decl)\n \t  {\n \t    if (dump_file)\n \t      {\n@@ -1476,7 +1482,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  }\n \tif (!tree_can_inline_p (node->decl, e->callee->decl))\n \t  {\n-\t    CALL_STMT_CANNOT_INLINE_P (e->call_stmt) = true;\n+\t    gimple_call_set_cannot_inline (e->call_stmt, true);\n \t    if (dump_file)\n \t      {\n \t\tindent_to (dump_file, depth);\n@@ -1585,8 +1591,8 @@ compute_inline_parameters (struct cgraph_node *node)\n     = inline_summary (node)->estimated_self_stack_size;\n   node->global.stack_frame_offset = 0;\n   node->local.inlinable = tree_inlinable_function_p (current_function_decl);\n-  inline_summary (node)->self_insns = estimate_num_insns (current_function_decl,\n-\t\t\t\t\t                  &eni_inlining_weights);\n+  inline_summary (node)->self_insns\n+      = estimate_num_insns_fn (current_function_decl, &eni_inlining_weights);\n   if (node->local.inlinable && !node->local.disregard_inline_limits)\n     node->local.disregard_inline_limits\n       = DECL_DISREGARD_INLINE_LIMITS (current_function_decl);\n@@ -1706,6 +1712,7 @@ inline_transform (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     if (!e->inline_failed || warn_inline)\n       break;\n+\n   if (e)\n     {\n       timevar_push (TV_INTEGRATION);"}, {"sha": "efa195916cd2c8865dae665653fa0159624e6b2a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 107, "deletions": 123, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -156,16 +156,16 @@ ipa_count_formal_params (struct cgraph_node *mt)\n    pointers or escaping addresses because all TREE_ADDRESSABLE parameters are\n    considered modified anyway.  */\n static void\n-ipa_check_stmt_modifications (struct ipa_node_params *info, tree stmt)\n+ipa_check_stmt_modifications (struct ipa_node_params *info, gimple stmt)\n {\n   int j;\n   int index;\n   tree lhs;\n \n-  switch (TREE_CODE (stmt))\n+  switch (gimple_code (stmt))\n     {\n-    case GIMPLE_MODIFY_STMT:\n-      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+    case GIMPLE_ASSIGN:\n+      lhs = gimple_assign_lhs (stmt);\n \n       while (handled_component_p (lhs))\n \tlhs = TREE_OPERAND (lhs, 0);\n@@ -176,7 +176,7 @@ ipa_check_stmt_modifications (struct ipa_node_params *info, tree stmt)\n \tinfo->param_flags[index].modified = true;\n       break;\n \n-    case ASM_EXPR:\n+    case GIMPLE_ASM:\n       /* Asm code could modify any of the parameters.  */\n       for (j = 0; j < ipa_get_param_count (info); j++)\n \tinfo->param_flags[j].modified = true;\n@@ -197,8 +197,8 @@ ipa_detect_param_modifications (struct cgraph_node *node)\n   tree decl = node->decl;\n   basic_block bb;\n   struct function *func;\n-  block_stmt_iterator bsi;\n-  tree stmt;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count;\n \n@@ -212,9 +212,9 @@ ipa_detect_param_modifications (struct cgraph_node *node)\n   func = DECL_STRUCT_FUNCTION (decl);\n   FOR_EACH_BB_FN (bb, func)\n     {\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  stmt = bsi_stmt (bsi);\n+\t  stmt = gsi_stmt (gsi);\n \t  ipa_check_stmt_modifications (info, stmt);\n \t}\n     }\n@@ -227,17 +227,17 @@ ipa_detect_param_modifications (struct cgraph_node *node)\n   info->modification_analysis_done = 1;\n }\n \n-/* Count number of arguments callsite CS has and store it in\n+/* Count number of arguments callsite CS has and store it in \n    ipa_edge_args structure corresponding to this callsite.  */\n void\n ipa_count_arguments (struct cgraph_edge *cs)\n {\n-  tree call_tree;\n+  gimple stmt;\n   int arg_num;\n \n-  call_tree = get_call_expr_in (cs->call_stmt);\n-  gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n-  arg_num = call_expr_nargs (call_tree);\n+  stmt = cs->call_stmt;\n+  gcc_assert (is_gimple_call (stmt));\n+  arg_num = gimple_call_num_args (stmt);\n   ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n \n@@ -314,14 +314,15 @@ ipa_print_all_jump_functions (FILE *f)\n static void\n compute_scalar_jump_functions (struct ipa_node_params *info,\n \t\t\t       struct ipa_jump_func *functions,\n-\t\t\t       tree call)\n+\t\t\t       gimple call)\n {\n-  call_expr_arg_iterator iter;\n   tree arg;\n-  int num = 0;\n+  unsigned num = 0;\n \n-  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+  for (num = 0; num < gimple_call_num_args (call); num++)\n     {\n+      arg = gimple_call_arg (call, num);\n+\n       if (TREE_CODE (arg) == INTEGER_CST\n \t  || TREE_CODE (arg) == REAL_CST\n \t  || TREE_CODE (arg) == FIXED_CST)\n@@ -359,8 +360,6 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t      functions[num].value.formal_id = index;\n \t    }\n \t}\n-\n-      num++;\n     }\n }\n \n@@ -404,15 +403,16 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n static bool\n compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *functions,\n-\t\t\t\t  tree call)\n+\t\t\t\t  gimple call)\n {\n-  call_expr_arg_iterator iter;\n   bool undecided_members = false;\n-  int num = 0;\n+  unsigned num;\n   tree arg;\n \n-  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+  for (num = 0; num < gimple_call_num_args (call); num++)\n     {\n+      arg = gimple_call_arg (call, num);\n+\n       if (type_like_member_ptr_p (TREE_TYPE (arg), NULL, NULL))\n \t{\n \t  if (TREE_CODE (arg) == PARM_DECL)\n@@ -431,8 +431,6 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t  else\n \t    undecided_members = true;\n \t}\n-\n-      num++;\n     }\n \n   return undecided_members;\n@@ -449,39 +447,36 @@ fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n   jfunc->value.member_cst.delta = delta;\n }\n \n-/* Traverse statements from CALL_STMT backwards, scanning whether the argument\n-   ARG which is a member pointer is filled in with constant values.  If it is,\n-   fill the jump function JFUNC in appropriately.  METHOD_FIELD and DELTA_FIELD\n-   are fields of the record type of the member pointer.  To give an example, we\n-   look for a pattern looking like the following:  \n+/* Traverse statements from CALL backwards, scanning whether the argument ARG\n+   which is a member pointer is filled in with constant values.  If it is, fill\n+   the jump function JFUNC in appropriately.  METHOD_FIELD and DELTA_FIELD are\n+   fields of the record type of the member pointer.  To give an example, we\n+   look for a pattern looking like the following:\n \n      D.2515.__pfn ={v} printStuff;\n      D.2515.__delta ={v} 0;\n      i_1 = doprinting (D.2515);  */\n static void\n-determine_cst_member_ptr (tree call_stmt, tree arg, tree method_field,\n+determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n \t\t\t  tree delta_field, struct ipa_jump_func *jfunc)\n {\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   tree method = NULL_TREE;\n   tree delta = NULL_TREE;\n \n-  bsi = bsi_for_stmt (call_stmt);\n+  gsi = gsi_for_stmt (call);\n \n-  bsi_prev (&bsi);\n-  for (; !bsi_end_p (bsi); bsi_prev (&bsi))\n+  gsi_prev (&gsi);\n+  for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      tree stmt = bsi_stmt (bsi);\n+      gimple stmt = gsi_stmt (gsi);\n       tree lhs, rhs, fld;\n \n-      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+      if (!is_gimple_assign (stmt) || gimple_num_ops (stmt) != 2)\n \treturn;\n \n-      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-      if (TREE_CODE (rhs) == CALL_EXPR)\n-\treturn;\n-\n-      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      lhs = gimple_assign_lhs (stmt);\n+      rhs = gimple_assign_rhs1 (stmt);\n \n       if (TREE_CODE (lhs) != COMPONENT_REF\n \t  || TREE_OPERAND (lhs, 0) != arg)\n@@ -524,28 +519,26 @@ determine_cst_member_ptr (tree call_stmt, tree arg, tree method_field,\n   return;\n }\n \n-/* Go through the arguments of the call in CALL_STMT and for every member\n-   pointer within tries determine whether it is a constant.  If it is, create a\n-   corresponding constant jump function in FUNCTIONS which is an array of jump\n-   functions associated with the call.  */\n+/* Go through the arguments of the CALL and for every member pointer within\n+   tries determine whether it is a constant.  If it is, create a corresponding\n+   constant jump function in FUNCTIONS which is an array of jump functions\n+   associated with the call.  */\n static void\n compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n-\t\t\t\t  tree call_stmt)\n+\t\t\t\t  gimple call)\n {\n-  call_expr_arg_iterator iter;\n-  int num = 0;\n-  tree call = get_call_expr_in (call_stmt);\n+  unsigned num;\n   tree arg, method_field, delta_field;\n \n-  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+  for (num = 0; num < gimple_call_num_args (call); num++)\n     {\n+      arg = gimple_call_arg (call, num);\n+\n       if (functions[num].type == IPA_UNKNOWN\n \t  && type_like_member_ptr_p (TREE_TYPE (arg), &method_field,\n \t\t\t\t     &delta_field))\n-\tdetermine_cst_member_ptr (call_stmt, arg, method_field,\n-\t\t\t\t  delta_field, &functions[num]);\n-\n-      num++;\n+\tdetermine_cst_member_ptr (call, arg, method_field, delta_field,\n+\t\t\t\t  &functions[num]);\n     }\n }\n \n@@ -557,13 +550,15 @@ ipa_compute_jump_functions (struct cgraph_edge *cs)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n   struct ipa_edge_args *arguments = IPA_EDGE_REF (cs);\n-  tree call;\n+  gimple call;\n \n   if (ipa_get_cs_argument_count (arguments) == 0 || arguments->jump_functions)\n     return;\n   arguments->jump_functions = XCNEWVEC (struct ipa_jump_func,\n \t\t\t\t\tipa_get_cs_argument_count (arguments));\n-  call = get_call_expr_in (cs->call_stmt);\n+\n+  call = cs->call_stmt;\n+  gcc_assert (is_gimple_call (call));\n \n   /* We will deal with constants and SSA scalars first:  */\n   compute_scalar_jump_functions (info, arguments->jump_functions, call);\n@@ -575,7 +570,7 @@ ipa_compute_jump_functions (struct cgraph_edge *cs)\n \n   /* Finally, let's check whether we actually pass a new constant membeer\n      pointer here...  */\n-  compute_cst_member_ptr_arguments (arguments->jump_functions, cs->call_stmt);\n+  compute_cst_member_ptr_arguments (arguments->jump_functions, call);\n }\n \n /* If RHS looks like a rhs of a statement loading pfn from a member pointer\n@@ -604,14 +599,14 @@ ipa_get_member_ptr_load_param (tree rhs)\n /* If STMT looks like a statement loading a value from a member pointer formal\n    parameter, this function retuns that parameter.  */\n static tree\n-ipa_get_stmt_member_ptr_load_param (tree stmt)\n+ipa_get_stmt_member_ptr_load_param (gimple stmt)\n {\n   tree rhs;\n \n-  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+  if (!is_gimple_assign (stmt) || gimple_num_ops (stmt) != 2)\n     return NULL_TREE;\n \n-  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+  rhs = gimple_assign_rhs1 (stmt);\n   return ipa_get_member_ptr_load_param (rhs);\n }\n \n@@ -631,10 +626,10 @@ ipa_is_ssa_with_stmt_def (tree t)\n    parameter.  STMT is the corresponding call statement.  */\n static void\n ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n-\t\t     tree stmt)\n+\t\t     gimple stmt)\n {\n   struct ipa_param_call_note *note;\n-  basic_block bb = bb_for_stmt (stmt);\n+  basic_block bb = gimple_bb (stmt);\n \n   info->param_flags[formal_id].called = 1;\n \n@@ -650,15 +645,14 @@ ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n   return;\n }\n \n-/* Analyze the CALL (which itself must be a part of statement STMT) and examine\n-   uses of formal parameters of the caller (described by INFO).  Currently it\n-   checks whether the call calls a pointer that is a formal parameter and if\n-   so, the parameter is marked with the called flag and a note describing the\n-   call is created.  This is very simple for ordinary pointers represented in\n-   SSA but not-so-nice when it comes to member pointers.  The ugly part of this\n-   function does nothing more than tries to match the pattern of such a call.\n-   An example of such a pattern is the gimple dump below, the call is on the\n-   last line:\n+/* Analyze the CALL and examine uses of formal parameters of the caller\n+   (described by INFO).  Currently it checks whether the call calls a pointer\n+   that is a formal parameter and if so, the parameter is marked with the\n+   called flag and a note describing the call is created.  This is very simple\n+   for ordinary pointers represented in SSA but not-so-nice when it comes to\n+   member pointers.  The ugly part of this function does nothing more than\n+   tries to match the pattern of such a call.  An example of such a pattern is\n+   the gimple dump below, the call is on the last line:\n \n      <bb 2>:\n        f$__delta_5 = f.__delta;\n@@ -698,16 +692,16 @@ ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n */\n \n static void\n-ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n+ipa_analyze_call_uses (struct ipa_node_params *info, gimple call)\n {\n-  tree target = CALL_EXPR_FN (call);\n-  tree var, def;\n+  tree target = gimple_call_fn (call);\n+  gimple def;\n+  tree var;\n   tree n1, n2;\n-  tree d1, d2;\n-  tree rec, rec2;\n-  tree branch, cond;\n+  gimple d1, d2;\n+  tree rec, rec2, cond;\n+  gimple branch;\n   int index;\n-\n   basic_block bb, virt_bb, join;\n \n   if (TREE_CODE (target) != SSA_NAME)\n@@ -719,7 +713,7 @@ ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n       /* assuming TREE_CODE (var) == PARM_DECL */\n       index = ipa_get_param_decl_index (info, var);\n       if (index >= 0)\n-\tipa_note_param_call (info, index, stmt);\n+\tipa_note_param_call (info, index, call);\n       return;\n     }\n \n@@ -731,10 +725,10 @@ ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n     return;\n \n   def = SSA_NAME_DEF_STMT (target);\n-  if (TREE_CODE (def) != PHI_NODE)\n+  if (gimple_code (def) != GIMPLE_PHI)\n     return;\n \n-  if (PHI_NUM_ARGS (def) != 2)\n+  if (gimple_phi_num_args (def) != 2)\n     return;\n \n   /* First, we need to check whether one of these is a load from a member\n@@ -751,21 +745,21 @@ ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n       if (ipa_get_stmt_member_ptr_load_param (d2))\n \treturn;\n \n-      bb = bb_for_stmt (d1);\n-      virt_bb = bb_for_stmt (d2);\n+      bb = gimple_bb (d1);\n+      virt_bb = gimple_bb (d2);\n     }\n   else if ((rec = ipa_get_stmt_member_ptr_load_param (d2)))\n     {\n-      bb = bb_for_stmt (d2);\n-      virt_bb = bb_for_stmt (d1);\n+      bb = gimple_bb (d2);\n+      virt_bb = gimple_bb (d1);\n     }\n   else\n     return;\n \n   /* Second, we need to check that the basic blocks are laid out in the way\n      corresponding to the pattern. */\n \n-  join = bb_for_stmt (def);\n+  join = gimple_bb (def);\n   if (!single_pred_p (virt_bb) || !single_succ_p (virt_bb)\n       || single_pred (virt_bb) != bb\n       || single_succ (virt_bb) != join)\n@@ -775,52 +769,45 @@ ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n      significant bit of the pfn. */\n \n   branch = last_stmt (bb);\n-  if (TREE_CODE (branch) != COND_EXPR)\n+  if (gimple_code (branch) != GIMPLE_COND)\n     return;\n \n-  cond = TREE_OPERAND (branch, 0);\n-  if (TREE_CODE (cond) != NE_EXPR\n-      || !integer_zerop (TREE_OPERAND (cond, 1)))\n+  if (gimple_cond_code (branch) != NE_EXPR\n+      || !integer_zerop (gimple_cond_rhs (branch)))\n     return;\n-  cond = TREE_OPERAND (cond, 0);\n \n+  cond = gimple_cond_lhs (branch);\n   if (!ipa_is_ssa_with_stmt_def (cond))\n     return;\n \n-  cond = SSA_NAME_DEF_STMT (cond);\n-  if (TREE_CODE (cond) != GIMPLE_MODIFY_STMT)\n+  def = SSA_NAME_DEF_STMT (cond);\n+  if (!is_gimple_assign (def) || gimple_num_ops (def) != 3\n+      || gimple_assign_rhs_code (def) != BIT_AND_EXPR\n+      || !integer_onep (gimple_assign_rhs2 (def)))\n     return;\n-  cond = GIMPLE_STMT_OPERAND (cond, 1);\n-  if (TREE_CODE (cond) != BIT_AND_EXPR\n-      || !integer_onep (TREE_OPERAND (cond, 1)))\n-    return;\n-  cond = TREE_OPERAND (cond, 0);\n+\n+  cond = gimple_assign_rhs1 (def);\n   if (!ipa_is_ssa_with_stmt_def (cond))\n     return;\n \n-  cond = SSA_NAME_DEF_STMT (cond);\n-  if (TREE_CODE (cond) != GIMPLE_MODIFY_STMT)\n-    return;\n-  cond = GIMPLE_STMT_OPERAND (cond, 1);\n+  def = SSA_NAME_DEF_STMT (cond);\n \n-  if (TREE_CODE (cond) == NOP_EXPR)\n+  if (is_gimple_assign (def) && gimple_num_ops (def) == 2\n+      && gimple_assign_rhs_code (def) == NOP_EXPR)\n     {\n-      cond = TREE_OPERAND (cond, 0);\n+      cond = gimple_assign_rhs1 (def);\n       if (!ipa_is_ssa_with_stmt_def (cond))\n \treturn;\n-      cond = SSA_NAME_DEF_STMT (cond);\n-      if (TREE_CODE (cond) != GIMPLE_MODIFY_STMT)\n-\treturn;\n-      cond = GIMPLE_STMT_OPERAND (cond, 1);\n+      def = SSA_NAME_DEF_STMT (cond);\n     }\n \n-  rec2 = ipa_get_member_ptr_load_param (cond);\n+  rec2 = ipa_get_stmt_member_ptr_load_param (def);\n   if (rec != rec2)\n     return;\n \n   index = ipa_get_param_decl_index (info, rec);\n   if (index >= 0 && !ipa_is_ith_param_modified (info, index))\n-    ipa_note_param_call (info, index, stmt);\n+    ipa_note_param_call (info, index, call);\n \n   return;\n }\n@@ -829,12 +816,10 @@ ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n    INFO) and their uses.  Currently it only checks whether formal parameters\n    are called.  */\n static void\n-ipa_analyze_stmt_uses (struct ipa_node_params *info, tree stmt)\n+ipa_analyze_stmt_uses (struct ipa_node_params *info, gimple stmt)\n {\n-  tree call = get_call_expr_in (stmt);\n-\n-  if (call)\n-    ipa_analyze_call_uses (info, call, stmt);\n+  if (is_gimple_call (stmt))\n+    ipa_analyze_call_uses (info, stmt);\n }\n \n /* Scan the function body of NODE and inspect the uses of formal parameters.\n@@ -846,11 +831,10 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n   tree decl = node->decl;\n   basic_block bb;\n   struct function *func;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-  if (ipa_get_param_count (info) == 0 || info->uses_analysis_done\n-      || !DECL_SAVED_TREE (decl))\n+  if (ipa_get_param_count (info) == 0 || info->uses_analysis_done)\n     return;\n   if (!info->param_flags)\n     info->param_flags = XCNEWVEC (struct ipa_param_flags,\n@@ -859,9 +843,9 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n   func = DECL_STRUCT_FUNCTION (decl);\n   FOR_EACH_BB_FN (bb, func)\n     {\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  tree stmt = bsi_stmt (bsi);\n+\t  gimple stmt = gsi_stmt (gsi);\n \t  ipa_analyze_stmt_uses (info, stmt);\n \t}\n     }\n@@ -918,7 +902,7 @@ print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n     print_node_brief(f, \"\", jfunc->value.constant, 0);\n \n   fprintf (f, \") in %s: \", cgraph_node_name (node));\n-  print_generic_stmt (f, nt->stmt, 2);\n+  print_gimple_stmt (f, nt->stmt, 2, TDF_SLIM);\n }\n \n /* Update the param called notes associated with NODE when CS is being inlined,"}, {"sha": "908a97e7797899753ee064e3acb24b6ef63716da", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -132,7 +132,7 @@ struct ipa_param_call_note\n   /* Linked list's next */\n   struct ipa_param_call_note *next;\n   /* Statement that contains the call to the parameter above.  */\n-  tree stmt;\n+  gimple stmt;\n   /* Index of the parameter that is called.  */\n   unsigned int formal_id;\n   /* Expected number of executions: calculated in profile.c.  */"}, {"sha": "7720d304a2d40f01f3589d23375d9e89ac0c5096", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 93, "deletions": 72, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"ipa-utils.h\"\n #include \"c-common.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"cgraph.h\"\n #include \"output.h\"\n #include \"flags.h\"\n@@ -276,42 +276,47 @@ check_lhs_var (funct_state local, tree t)\n    actual asm statement.  */\n \n static void\n-get_asm_expr_operands (funct_state local, tree stmt)\n+get_asm_expr_operands (funct_state local, gimple stmt)\n {\n-  int noutputs = list_length (ASM_OUTPUTS (stmt));\n+  size_t noutputs = gimple_asm_noutputs (stmt);\n   const char **oconstraints\n     = (const char **) alloca ((noutputs) * sizeof (const char *));\n-  int i;\n-  tree link;\n+  size_t i;\n+  tree op;\n   const char *constraint;\n   bool allows_mem, allows_reg, is_inout;\n   \n-  for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n+  for (i = 0; i < noutputs; i++)\n     {\n+      op = gimple_asm_output_op (stmt, i);\n       oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n       parse_output_constraint (&constraint, i, 0, 0,\n \t\t\t       &allows_mem, &allows_reg, &is_inout);\n       \n-      check_lhs_var (local, TREE_VALUE (link));\n+      check_lhs_var (local, TREE_VALUE (op));\n     }\n \n-  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n+  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n     {\n+      op = gimple_asm_input_op (stmt, i);\n       constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n       parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n \t\t\t      oconstraints, &allows_mem, &allows_reg);\n       \n-      check_rhs_var (local, TREE_VALUE (link));\n+      check_rhs_var (local, TREE_VALUE (op));\n     }\n   \n-  for (link = ASM_CLOBBERS (stmt); link; link = TREE_CHAIN (link))\n-    if (simple_cst_equal(TREE_VALUE (link), memory_identifier_string) == 1) \n-      /* Abandon all hope, ye who enter here. */\n-      local->pure_const_state = IPA_NEITHER;\n+  for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n+    {\n+      op = gimple_asm_clobber_op (stmt, i);\n+      if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1) \n+\t/* Abandon all hope, ye who enter here. */\n+\tlocal->pure_const_state = IPA_NEITHER;\n+    }\n \n-  if (ASM_VOLATILE_P (stmt))\n+  if (gimple_asm_volatile_p (stmt))\n     local->pure_const_state = IPA_NEITHER;\n }\n \n@@ -323,17 +328,20 @@ get_asm_expr_operands (funct_state local, tree stmt)\n    the entire call expression.  */\n \n static void\n-check_call (funct_state local, tree call_expr) \n+check_call (funct_state local, gimple call) \n {\n-  int flags = call_expr_flags (call_expr);\n-  tree operand;\n-  call_expr_arg_iterator iter;\n-  tree callee_t = get_callee_fndecl (call_expr);\n+  int flags = gimple_call_flags (call);\n+  tree lhs, callee_t = gimple_call_fndecl (call);\n   struct cgraph_node* callee;\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n+  size_t i;\n+\n+  lhs = gimple_call_lhs (call);\n+  if (lhs)\n+    check_lhs_var (local, lhs);\n \n-  FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n-    check_rhs_var (local, operand);\n+  for (i = 0; i < gimple_call_num_args (call); i++)\n+    check_rhs_var (local, gimple_call_arg (call, i));\n   \n   /* The const and pure flags are set by a variety of places in the\n      compiler (including here).  If someone has already set the flags\n@@ -405,70 +413,83 @@ check_call (funct_state local, tree call_expr)\n    should be converted to use the operand scanner.  */\n \n static tree\n-scan_function (tree *tp, \n-\t\t      int *walk_subtrees, \n-\t\t      void *data)\n+scan_function_op (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct cgraph_node *fn = (struct cgraph_node *) data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  struct cgraph_node *fn = (struct cgraph_node *) wi->info;\n   tree t = *tp;\n   funct_state local = get_function_state (fn);\n \n   switch (TREE_CODE (t))  \n     {\n     case VAR_DECL:\n       if (DECL_INITIAL (t))\n-\twalk_tree (&DECL_INITIAL (t), scan_function, fn, visited_nodes);\n+\twalk_tree (&DECL_INITIAL (t), scan_function_op, data, visited_nodes);\n       *walk_subtrees = 0;\n       break;\n \n-    case GIMPLE_MODIFY_STMT:\n+    case ADDR_EXPR:\n+      /* This case is here to find addresses on rhs of constructors in\n+\t decl_initial of static variables. */\n+      check_rhs_var (local, t);\n+      *walk_subtrees = 0;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return NULL;\n+}\n+\n+static tree\n+scan_function_stmt (gimple_stmt_iterator *gsi_p,\n+\t\t    bool *handled_ops_p,\n+\t\t    struct walk_stmt_info *wi)\n+{\n+  struct cgraph_node *fn = (struct cgraph_node *) wi->info;\n+  gimple stmt = gsi_stmt (*gsi_p);\n+  funct_state local = get_function_state (fn);\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n       {\n \t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n+\ttree lhs = gimple_assign_lhs (stmt);\n+\ttree rhs1 = gimple_assign_rhs1 (stmt);\n+\ttree rhs2 = gimple_assign_rhs2 (stmt);\n+\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\n \tcheck_lhs_var (local, lhs);\n \n \t/* For the purposes of figuring out what the cast affects */\n \n \t/* Next check the operands on the rhs to see if they are ok. */\n-\tswitch (TREE_CODE_CLASS (TREE_CODE (rhs))) \n+\tswitch (TREE_CODE_CLASS (code))\n \t  {\n \t  case tcc_binary:\t    \n  \t    {\n- \t      tree op0 = TREE_OPERAND (rhs, 0);\n- \t      tree op1 = TREE_OPERAND (rhs, 1);\n- \t      check_rhs_var (local, op0);\n- \t      check_rhs_var (local, op1);\n+ \t      check_rhs_var (local, rhs1);\n+ \t      check_rhs_var (local, rhs2);\n \t    }\n \t    break;\n \t  case tcc_unary:\n  \t    {\n- \t      tree op0 = TREE_OPERAND (rhs, 0);\n- \t      check_rhs_var (local, op0);\n+ \t      check_rhs_var (local, rhs1);\n  \t    }\n \n \t    break;\n \t  case tcc_reference:\n-\t    check_rhs_var (local, rhs);\n+\t    check_rhs_var (local, rhs1);\n \t    break;\n \t  case tcc_declaration:\n-\t    check_rhs_var (local, rhs);\n+\t    check_rhs_var (local, rhs1);\n \t    break;\n \t  case tcc_expression:\n-\t    switch (TREE_CODE (rhs)) \n+\t    switch (code)\n \t      {\n \t      case ADDR_EXPR:\n-\t\tcheck_rhs_var (local, rhs);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t    break;\n-\t  case tcc_vl_exp:\n-\t    switch (TREE_CODE (rhs)) \n-\t      {\n-\t      case CALL_EXPR:\n-\t\tcheck_call (local, rhs);\n+\t\tcheck_rhs_var (local, rhs1);\n \t\tbreak;\n \t      default:\n \t\tbreak;\n@@ -477,34 +498,27 @@ scan_function (tree *tp,\n \t  default:\n \t    break;\n \t  }\n-\t*walk_subtrees = 0;\n+\t*handled_ops_p = true;\n       }\n       break;\n \n-    case ADDR_EXPR:\n-      /* This case is here to find addresses on rhs of constructors in\n-\t decl_initial of static variables. */\n-      check_rhs_var (local, t);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case LABEL_EXPR:\n-      if (DECL_NONLOCAL (TREE_OPERAND (t, 0)))\n+    case GIMPLE_LABEL:\n+      if (DECL_NONLOCAL (gimple_label_label (stmt)))\n \t/* Target of long jump. */\n \t{\n \t  local->pure_const_state = IPA_NEITHER;\n \t  local->looping = false;\n \t}\n       break;\n \n-    case CALL_EXPR: \n-      check_call (local, t);\n-      *walk_subtrees = 0;\n+    case GIMPLE_CALL:\n+      check_call (local, stmt);\n+      *handled_ops_p = true;\n       break;\n       \n-    case ASM_EXPR:\n-      get_asm_expr_operands (local, t);\n-      *walk_subtrees = 0;\n+    case GIMPLE_ASM:\n+      get_asm_expr_operands (local, stmt);\n+      *handled_ops_p = true;\n       break;\n       \n     default:\n@@ -567,11 +581,18 @@ analyze_function (struct cgraph_node *fn)\n       \n       FOR_EACH_BB_FN (this_block, this_cfun)\n \t{\n-\t  block_stmt_iterator bsi;\n-\t  for (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  gimple_stmt_iterator gsi;\n+\t  struct walk_stmt_info wi;\n+\n+\t  memset (&wi, 0, sizeof(wi));\n+\t  for (gsi = gsi_start_bb (this_block);\n+\t       !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n \t    {\n-\t      walk_tree (bsi_stmt_ptr (bsi), scan_function, \n-\t\t\t fn, visited_nodes);\n+\t      wi.info = fn;\n+\t      wi.pset = visited_nodes;\n+\t      walk_gimple_stmt (&gsi, scan_function_stmt, scan_function_op, \n+\t\t\t\t&wi);\n \t      if (l->pure_const_state == IPA_NEITHER) \n \t\tgoto end;\n \t    }"}, {"sha": "c28c7327f2c61c2aa2346d67a1265ae02fcd260e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 124, "deletions": 96, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -45,8 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n    Currently must be run after inlining decisions have been made since\n    otherwise, the local sets will not contain information that is\n    consistent with post inlined state.  The global sets are not prone\n-   to this problem since they are by definition transitive.  \n-*/\n+   to this problem since they are by definition transitive.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -62,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"ipa-reference.h\"\n #include \"c-common.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"cgraph.h\"\n #include \"output.h\"\n #include \"flags.h\"\n@@ -388,43 +387,48 @@ check_lhs_var (ipa_reference_local_vars_info_t local, tree t)\n    function being analyzed and STMT is the actual asm statement.  */\n \n static void\n-get_asm_expr_operands (ipa_reference_local_vars_info_t local, tree stmt)\n+get_asm_stmt_operands (ipa_reference_local_vars_info_t local, gimple stmt)\n {\n-  int noutputs = list_length (ASM_OUTPUTS (stmt));\n+  size_t noutputs = gimple_asm_noutputs (stmt);\n   const char **oconstraints\n     = (const char **) alloca ((noutputs) * sizeof (const char *));\n-  int i;\n-  tree link;\n+  size_t i;\n+  tree op;\n   const char *constraint;\n   bool allows_mem, allows_reg, is_inout;\n   \n-  for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n+  for (i = 0; i < noutputs; i++)\n     {\n+      op = gimple_asm_output_op (stmt, i);\n       oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n       parse_output_constraint (&constraint, i, 0, 0,\n \t\t\t       &allows_mem, &allows_reg, &is_inout);\n       \n-      check_lhs_var (local, TREE_VALUE (link));\n+      check_lhs_var (local, TREE_VALUE (op));\n     }\n \n-  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n+  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n     {\n+      op = gimple_asm_input_op (stmt, i);\n       constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n       parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n \t\t\t      oconstraints, &allows_mem, &allows_reg);\n       \n-      check_rhs_var (local, TREE_VALUE (link));\n+      check_rhs_var (local, TREE_VALUE (op));\n     }\n   \n-  for (link = ASM_CLOBBERS (stmt); link; link = TREE_CHAIN (link))\n-    if (simple_cst_equal(TREE_VALUE (link), memory_identifier_string) == 1) \n-      {\n-\t/* Abandon all hope, ye who enter here. */\n-\tlocal->calls_read_all = true;\n-\tlocal->calls_write_all = true;\n-      }      \n+  for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n+    {\n+      op = gimple_asm_clobber_op (stmt, i);\n+      if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1) \n+\t{\n+\t  /* Abandon all hope, ye who enter here. */\n+\t  local->calls_read_all = true;\n+\t  local->calls_write_all = true;\n+\t}      \n+    }\n }\n \n /* Check the parameters of a function call from CALLER to CALL_EXPR to\n@@ -435,16 +439,19 @@ get_asm_expr_operands (ipa_reference_local_vars_info_t local, tree stmt)\n    the tree node for the entire call expression.  */\n \n static void\n-check_call (ipa_reference_local_vars_info_t local, tree call_expr) \n+check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n {\n-  int flags = call_expr_flags (call_expr);\n+  int flags = gimple_call_flags (stmt);\n   tree operand;\n-  tree callee_t = get_callee_fndecl (call_expr);\n+  tree callee_t = gimple_call_fndecl (stmt);\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n-  call_expr_arg_iterator iter;\n+  size_t i;\n \n-  FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n-    check_rhs_var (local, operand);\n+  if ((operand = gimple_call_lhs (stmt)) != NULL)\n+    check_lhs_var (local, operand);\n+\n+  for (i = 0; i < gimple_call_num_args (stmt); i++)\n+    check_rhs_var (local, gimple_call_arg (stmt, i));\n \n   if (callee_t)\n     {\n@@ -473,73 +480,49 @@ check_call (ipa_reference_local_vars_info_t local, tree call_expr)\n    should be converted to use the operand scanner.  */\n \n static tree\n-scan_for_static_refs (tree *tp, \n-\t\t      int *walk_subtrees, \n-\t\t      void *data)\n+scan_stmt_for_static_refs (gimple_stmt_iterator *gsip, bool *handled_ops_p,\n+\t\t\t   struct walk_stmt_info *data)\n {\n-  struct cgraph_node *fn = (struct cgraph_node *) data;\n-  tree t = *tp;\n+  struct cgraph_node *fn = (struct cgraph_node *) data->info;\n+  gimple stmt = gsi_stmt (*gsip);\n   ipa_reference_local_vars_info_t local = NULL;\n   if (fn)\n     local = get_reference_vars_info_from_cgraph (fn)->local;\n \n-  switch (TREE_CODE (t))  \n+  switch (gimple_code (stmt))\n     {\n-    case VAR_DECL:\n-      if (DECL_INITIAL (t))\n-\twalk_tree (&DECL_INITIAL (t), scan_for_static_refs, fn, visited_nodes);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case GIMPLE_MODIFY_STMT:\n+    case GIMPLE_ASSIGN:\n       {\n \t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n+\ttree lhs = gimple_assign_lhs (stmt);\n+\ttree rhs1 = gimple_assign_rhs1 (stmt);\n+\ttree rhs2 = gimple_assign_rhs2 (stmt);\n+\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\n \tcheck_lhs_var (local, lhs);\n \n \t/* For the purposes of figuring out what the cast affects */\n \n \t/* Next check the operands on the rhs to see if they are ok. */\n-\tswitch (TREE_CODE_CLASS (TREE_CODE (rhs))) \n+\tswitch (TREE_CODE_CLASS (code))\n \t  {\n \t  case tcc_binary:\t    \n \t  case tcc_comparison:\t    \n- \t    {\n- \t      tree op0 = TREE_OPERAND (rhs, 0);\n- \t      tree op1 = TREE_OPERAND (rhs, 1);\n- \t      check_rhs_var (local, op0);\n- \t      check_rhs_var (local, op1);\n-\t    }\n+ \t    check_rhs_var (local, rhs1);\n+ \t    check_rhs_var (local, rhs2);\n \t    break;\n-\t  case tcc_unary:\n- \t    {\n- \t      tree op0 = TREE_OPERAND (rhs, 0);\n- \t      check_rhs_var (local, op0);\n- \t    }\n \n-\t    break;\n+\t  case tcc_unary:\n \t  case tcc_reference:\n-\t    check_rhs_var (local, rhs);\n-\t    break;\n \t  case tcc_declaration:\n-\t    check_rhs_var (local, rhs);\n+\t    check_rhs_var (local, rhs1);\n \t    break;\n+\n \t  case tcc_expression:\n-\t    switch (TREE_CODE (rhs)) \n+\t    switch (code)\n \t      {\n \t      case ADDR_EXPR:\n-\t\tcheck_rhs_var (local, rhs);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t    break;\n-\t  case tcc_vl_exp:\n-\t    switch (TREE_CODE (rhs))\n-\t      {\n-\t      case CALL_EXPR:\n-\t\tcheck_call (local, rhs);\n+\t\tcheck_rhs_var (local, rhs1);\n \t\tbreak;\n \t      default:\n \t\tbreak;\n@@ -548,34 +531,27 @@ scan_for_static_refs (tree *tp,\n \t  default:\n \t    break;\n \t  }\n-\t*walk_subtrees = 0;\n+\t*handled_ops_p = true;\n       }\n       break;\n \n-    case ADDR_EXPR:\n-      /* This case is here to find addresses on rhs of constructors in\n-\t decl_initial of static variables. */\n-      check_rhs_var (local, t);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case LABEL_EXPR:\n-      if (DECL_NONLOCAL (TREE_OPERAND (t, 0)))\n+    case GIMPLE_LABEL:\n+      if (DECL_NONLOCAL (gimple_label_label (stmt)))\n \t{\n \t  /* Target of long jump. */\n \t  local->calls_read_all = true;\n \t  local->calls_write_all = true;\n \t}\n       break;\n \n-    case CALL_EXPR: \n-      check_call (local, t);\n-      *walk_subtrees = 0;\n+    case GIMPLE_CALL:\n+      check_call (local, stmt);\n+      *handled_ops_p = true;\n       break;\n       \n-    case ASM_EXPR:\n-      get_asm_expr_operands (local, t);\n-      *walk_subtrees = 0;\n+    case GIMPLE_ASM:\n+      get_asm_stmt_operands (local, stmt);\n+      *handled_ops_p = true;\n       break;\n       \n     default:\n@@ -584,6 +560,42 @@ scan_for_static_refs (tree *tp,\n   return NULL;\n }\n \n+/* Call-back to scan GIMPLE operands for static references.  This is supposed\n+   to work with scan_stmt_for_static_refs so the real call-back data is stored\n+   inside a walk_stmt_info struct.  Callers using the walk_tree interface must\n+   also wrap the call-back data in a walk_stmt_info struct.  */\n+\n+static tree\n+scan_op_for_static_refs (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info*) data;\n+  struct cgraph_node *fn = (struct cgraph_node *) wi->info;\n+  tree t = *tp;\n+  ipa_reference_local_vars_info_t local = NULL;\n+  if (fn)\n+    local = get_reference_vars_info_from_cgraph (fn)->local;\n+\n+  switch (TREE_CODE (t))  \n+    {\n+    case VAR_DECL:\n+      if (DECL_INITIAL (t))\n+\twalk_tree (&DECL_INITIAL (t), scan_op_for_static_refs, data,\n+\t\t   wi->pset);\n+      *walk_subtrees = 0;\n+      break;\n+\n+    case ADDR_EXPR:\n+      /* This case is here to find addresses on rhs of constructors in\n+\t decl_initial of static variables. */\n+      check_rhs_var (local, t);\n+      *walk_subtrees = 0;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return NULL;\n+}\n \n /* Lookup the tree node for the static variable that has UID.  */\n static tree\n@@ -777,9 +789,13 @@ ipa_init (void)\n static void \n analyze_variable (struct varpool_node *vnode)\n {\n+  struct walk_stmt_info wi;\n   tree global = vnode->decl;\n-  walk_tree (&DECL_INITIAL (global), scan_for_static_refs, \n-             NULL, visited_nodes);\n+\n+  memset (&wi, 0, sizeof (wi));\n+  wi.pset = visited_nodes;\n+  walk_tree (&DECL_INITIAL (global), scan_op_for_static_refs,\n+             &wi, wi.pset);\n }\n \n /* This is the main routine for finding the reference patterns for\n@@ -793,6 +809,7 @@ analyze_function (struct cgraph_node *fn)\n   ipa_reference_local_vars_info_t l\n     = XCNEW (struct ipa_reference_local_vars_info_d);\n   tree decl = fn->decl;\n+  struct walk_stmt_info wi;\n \n   /* Add the info to the tree's annotation.  */\n   get_function_ann (fn->decl)->reference_vars_info = info;\n@@ -810,14 +827,18 @@ analyze_function (struct cgraph_node *fn)\n \n     FOR_EACH_BB_FN (this_block, this_cfun)\n       {\n-\tblock_stmt_iterator bsi;\n-\ttree phi, op;\n+\tgimple_stmt_iterator gsi;\n+\tgimple phi;\n+\ttree op;\n \tuse_operand_p use;\n \tssa_op_iter iter;\n \n \t/* Find the addresses taken in phi node arguments.  */\n-\tfor (phi = phi_nodes (this_block); phi; phi = PHI_CHAIN (phi))\n+\tfor (gsi = gsi_start_phis (this_block);\n+\t     !gsi_end_p (gsi);\n+\t     gsi_next (&gsi))\n \t  {\n+\t    phi = gsi_stmt (gsi);\n \t    FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n \t      {\n \t\top = USE_FROM_PTR (use);\n@@ -826,9 +847,12 @@ analyze_function (struct cgraph_node *fn)\n \t      }\n \t  }\n \n-\tfor (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  walk_tree (bsi_stmt_ptr (bsi), scan_for_static_refs, \n-\t\t     fn, visited_nodes);\n+\tmemset (&wi, 0, sizeof (wi));\n+\twi.info = fn;\n+\twi.pset = visited_nodes;\n+\tfor (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  walk_gimple_stmt (&gsi, scan_stmt_for_static_refs,\n+\t\t\t    scan_op_for_static_refs, &wi);\n       }\n   }\n \n@@ -844,8 +868,13 @@ analyze_function (struct cgraph_node *fn)\n \t  if (TREE_CODE (var) == VAR_DECL \n \t      && DECL_INITIAL (var)\n \t      && !TREE_STATIC (var))\n-\t    walk_tree (&DECL_INITIAL (var), scan_for_static_refs, \n-\t\t       fn, visited_nodes);\n+\t    {\n+\t      memset (&wi, 0, sizeof (wi));\n+\t      wi.info = fn;\n+\t      wi.pset = visited_nodes;\n+\t      walk_tree (&DECL_INITIAL (var), scan_op_for_static_refs,\n+\t\t         &wi, wi.pset);\n+\t    }\n \t}\n     }\n }\n@@ -1339,4 +1368,3 @@ struct simple_ipa_opt_pass pass_ipa_reference =\n };\n \n #include \"gt-ipa-reference.h\"\n-"}, {"sha": "d6bca8ab7224ef8fe2c2a7e327784d5ac12ead3e", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 226, "deletions": 306, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -28,7 +28,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"tree-inline.h\"\n #include \"tree-flow.h\"\n #include \"tree-flow-inline.h\"\n@@ -55,6 +55,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ipa-type-escape.h\"\n #include \"tree-dump.h\"\n #include \"c-common.h\"\n+#include \"gimple.h\"\n \n /* This optimization implements structure peeling.\n \n@@ -168,7 +169,7 @@ typedef const struct new_var_data *const_new_var;\n /* This structure represents allocation site of the structure.  */\n typedef struct alloc_site\n {\n-  tree stmt;\n+  gimple stmt;\n   d_str str;\n } alloc_site_t;\n \n@@ -235,7 +236,7 @@ get_type_of_var (tree var)\n /* Set of actions we do for each newly generated STMT.  */ \n \n static inline void\n-finalize_stmt (tree stmt)\n+finalize_stmt (gimple stmt)\n {\n   update_stmt (stmt);\n   mark_symbols_for_renaming (stmt);\n@@ -244,9 +245,9 @@ finalize_stmt (tree stmt)\n /* This function finalizes STMT and appends it to the list STMTS.  */\n \n static inline void\n-finalize_stmt_and_append (tree *stmts, tree stmt)\n+finalize_stmt_and_append (gimple_seq *stmts, gimple stmt)\n {\n-  append_to_statement_list (stmt, stmts);\n+  gimple_seq_add_stmt (stmts, stmt);\n   finalize_stmt (stmt);\n }\n \n@@ -307,25 +308,24 @@ find_field_in_struct (d_str str, tree field_decl)\n static bool\n is_result_of_mult (tree arg, tree *num, tree struct_size)\n {\n-  tree size_def_stmt = SSA_NAME_DEF_STMT (arg);\n+  gimple size_def_stmt = SSA_NAME_DEF_STMT (arg);\n \n   /* If the allocation statement was of the form\n      D.2229_10 = <alloc_func> (D.2228_9);\n      then size_def_stmt can be D.2228_9 = num.3_8 * 8;  */\n \n-  if (size_def_stmt && TREE_CODE (size_def_stmt) == GIMPLE_MODIFY_STMT)\n+  if (size_def_stmt && is_gimple_assign (size_def_stmt))\n     {\n-      tree lhs = GIMPLE_STMT_OPERAND (size_def_stmt, 0);\n-      tree rhs = GIMPLE_STMT_OPERAND (size_def_stmt, 1);\n+      tree lhs = gimple_assign_lhs (size_def_stmt);\n \n       /* We expect temporary here.  */\n       if (!is_gimple_reg (lhs))\t\n \treturn false;\n \n-      if (TREE_CODE (rhs) == MULT_EXPR)\n+      if (gimple_assign_rhs_code (size_def_stmt) == MULT_EXPR)\n \t{\n-\t  tree arg0 = TREE_OPERAND (rhs, 0);\n-\t  tree arg1 = TREE_OPERAND (rhs, 1);\n+\t  tree arg0 = gimple_assign_rhs1 (size_def_stmt);\n+\t  tree arg1 = gimple_assign_rhs2 (size_def_stmt);\n \n \t  if (operand_equal_p (arg0, struct_size, OEP_ONLY_CONST))\n \t    {\n@@ -356,8 +356,9 @@ static bool\n decompose_indirect_ref_acc (tree str_decl, struct field_access_site *acc)\n {\n   tree ref_var;\n-  tree rhs, struct_size, op0, op1;\n+  tree struct_size, op0, op1;\n   tree before_cast;\n+  enum tree_code rhs_code;\n  \n   ref_var = TREE_OPERAND (acc->ref, 0);\n \n@@ -366,20 +367,20 @@ decompose_indirect_ref_acc (tree str_decl, struct field_access_site *acc)\n \n   acc->ref_def_stmt = SSA_NAME_DEF_STMT (ref_var);\n   if (!(acc->ref_def_stmt)\n-      || (TREE_CODE (acc->ref_def_stmt) != GIMPLE_MODIFY_STMT))\n+      || (gimple_code (acc->ref_def_stmt) != GIMPLE_ASSIGN))\n     return false;\n \n-  rhs = GIMPLE_STMT_OPERAND (acc->ref_def_stmt, 1);\n+  rhs_code = gimple_assign_rhs_code (acc->ref_def_stmt);\n \n-  if (TREE_CODE (rhs) != PLUS_EXPR\n-      && TREE_CODE (rhs)!= MINUS_EXPR\n-      && TREE_CODE (rhs) != POINTER_PLUS_EXPR)\n+  if (rhs_code != PLUS_EXPR\n+      && rhs_code != MINUS_EXPR\n+      && rhs_code != POINTER_PLUS_EXPR)\n     return false;\n \n-  op0 = TREE_OPERAND (rhs, 0);\n-  op1 = TREE_OPERAND (rhs, 1);\n+  op0 = gimple_assign_rhs1 (acc->ref_def_stmt);\n+  op1 = gimple_assign_rhs2 (acc->ref_def_stmt);\n \n-  if (!is_array_access_through_pointer_and_index (TREE_CODE (rhs), op0, op1, \n+  if (!is_array_access_through_pointer_and_index (rhs_code, op0, op1, \n \t\t\t\t\t\t &acc->base, &acc->offset, \n \t\t\t\t\t\t &acc->cast_stmt))\n     return false;\n@@ -438,7 +439,7 @@ make_field_acc_node (void)\n    if it is already in hashtable of function accesses F_ACCS.  */\n \n static struct field_access_site *\n-is_in_field_accs (tree stmt, htab_t f_accs)\n+is_in_field_accs (gimple stmt, htab_t f_accs)\n {\n   return (struct field_access_site *) \n     htab_find_with_hash (f_accs, stmt, htab_hash_pointer (stmt));\n@@ -466,7 +467,7 @@ add_field_acc_to_acc_sites (struct field_access_site *acc,\n    accesses ACCS, this function creates it.  */ \n \n static void\n-add_access_to_acc_sites (tree stmt, tree var, htab_t accs)\n+add_access_to_acc_sites (gimple stmt, tree var, htab_t accs)\n {\n    struct access_site *acc;\n \n@@ -538,23 +539,6 @@ finalize_new_vars_creation (void **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-/* This function updates statements in STMT_LIST with BB info.  */\n-\n-static void\n-add_bb_info (basic_block bb, tree stmt_list)\n-{\n-  if (TREE_CODE (stmt_list) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator tsi;\n-      for (tsi = tsi_start (stmt_list); !tsi_end_p (tsi); tsi_next (&tsi))\n-\t{\n-\t  tree stmt = tsi_stmt (tsi);\n-\n-\t  set_bb_for_stmt (stmt, bb);\n-\t}\n-    }\n-}\n-\n /* This function looks for the variable of NEW_TYPE type, stored in VAR.\n    It returns it, if found, and NULL_TREE otherwise.  */\n \n@@ -610,12 +594,12 @@ find_new_var_of_type (tree orig_var, tree new_type)\n    res = NUM * sizeof(TYPE) and returns it.\n    res is filled into RES.  */\n \n-static tree\n+static gimple\n gen_size (tree num, tree type, tree *res)\n {\n   tree struct_size = TYPE_SIZE_UNIT (type);\n   HOST_WIDE_INT struct_size_int = TREE_INT_CST_LOW (struct_size);\n-  tree new_stmt;\n+  gimple new_stmt;\n \n   *res = create_tmp_var (TREE_TYPE (num), NULL);\n \n@@ -625,17 +609,13 @@ gen_size (tree num, tree type, tree *res)\n   if (exact_log2 (struct_size_int) == -1)\n     {\n       tree size = build_int_cst (TREE_TYPE (num), struct_size_int);\n-      new_stmt = build_gimple_modify_stmt (*res, build2 (MULT_EXPR,\n-\t\t\t\t\t\t\t TREE_TYPE (num),\n-\t\t\t\t\t\t\t num, size));\n+      new_stmt = gimple_build_assign_with_ops (MULT_EXPR, *res, num, size);\n     }\n   else\n     {\n       tree C = build_int_cst (TREE_TYPE (num), exact_log2 (struct_size_int));\n  \n-      new_stmt = build_gimple_modify_stmt (*res, build2 (LSHIFT_EXPR, \n-\t\t\t\t\t\t\t TREE_TYPE (num),\n-\t\t\t\t\t\t\t num, C));\n+      new_stmt = gimple_build_assign_with_ops (LSHIFT_EXPR, *res, num, C);\n     }\n \n   finalize_stmt (new_stmt);\n@@ -646,21 +626,18 @@ gen_size (tree num, tree type, tree *res)\n    BEFORE_CAST to NEW_TYPE. The cast result variable is stored \n    into RES_P. ORIG_CAST_STMT is the original cast statement.  */\n \n-static tree\n-gen_cast_stmt (tree before_cast, tree new_type, tree orig_cast_stmt,\n+static gimple\n+gen_cast_stmt (tree before_cast, tree new_type, gimple orig_cast_stmt,\n \t       tree *res_p)\n {\n-  tree lhs, new_lhs, new_stmt;\n-  gcc_assert (TREE_CODE (orig_cast_stmt) == GIMPLE_MODIFY_STMT);\n-    \n-  lhs = GIMPLE_STMT_OPERAND (orig_cast_stmt, 0);\n+  tree lhs, new_lhs;\n+  gimple new_stmt;\n+\n+  lhs = gimple_assign_lhs (orig_cast_stmt);\n   new_lhs = find_new_var_of_type (lhs, new_type);\n   gcc_assert (new_lhs);\n \n-  new_stmt = build_gimple_modify_stmt (new_lhs, \n-\t\t\t\t       build1 (NOP_EXPR, \n-\t\t\t\t\t       TREE_TYPE (new_lhs),\n-\t\t\t\t\t       before_cast));\n+  new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_lhs, before_cast, 0);\n   finalize_stmt (new_stmt);\n   *res_p = new_lhs;\n   return new_stmt;\n@@ -673,45 +650,61 @@ static edge\n make_edge_and_fix_phis_of_dest (basic_block bb, edge e)\n {\n   edge new_e;\n-  tree phi, arg;\n+  tree arg;\n+  gimple_stmt_iterator si;\n \t\t      \n   new_e = make_edge (bb, e->dest, e->flags);\n \n-  for (phi = phi_nodes (new_e->dest); phi; phi = PHI_CHAIN (phi))\n+  for (si = gsi_start_phis (new_e->dest); !gsi_end_p (si); gsi_next (&si))\n     {\n+      gimple phi = gsi_stmt (si);\n       arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       add_phi_arg (phi, arg, new_e); \n     }\n \n   return new_e;\n }\n \n-/* This function inserts NEW_STMTS before STMT.  */\n+/* This function inserts NEW_STMT before STMT.  */\n \n static void\n-insert_before_stmt (tree stmt, tree new_stmts)\n+insert_before_stmt (gimple stmt, gimple new_stmt)\n {\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator bsi;\n \n-  if (!stmt || !new_stmts)\n+  if (!stmt || !new_stmt)\n     return;\n \n-  bsi = bsi_for_stmt (stmt); \n-  bsi_insert_before (&bsi, new_stmts, BSI_SAME_STMT);   \n+  bsi = gsi_for_stmt (stmt); \n+  gsi_insert_before (&bsi, new_stmt, GSI_SAME_STMT);   \n }\n \n /* Insert NEW_STMTS after STMT.  */\n \n static void\n-insert_after_stmt (tree stmt, tree new_stmts)\n+insert_seq_after_stmt (gimple stmt, gimple_seq new_stmts)\n {\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator bsi;\n \n   if (!stmt || !new_stmts)\n     return;\n \n-  bsi = bsi_for_stmt (stmt); \n-  bsi_insert_after (&bsi, new_stmts, BSI_SAME_STMT);   \n+  bsi = gsi_for_stmt (stmt); \n+  gsi_insert_seq_after (&bsi, new_stmts, GSI_SAME_STMT);   \n+}\n+\n+/* Insert NEW_STMT after STMT.  */\n+\n+static void\n+insert_after_stmt (gimple stmt, gimple new_stmt)\n+{\n+  gimple_stmt_iterator bsi;\n+\n+  if (!stmt || !new_stmt)\n+    return;\n+\n+  bsi = gsi_for_stmt (stmt); \n+  gsi_insert_after (&bsi, new_stmt, GSI_SAME_STMT);   \n }\n \n /* This function returns vector of allocation sites\n@@ -730,20 +723,20 @@ get_fallocs (tree fn_decl)\n    p_8 = (struct str_t *) D.2225_7;\n    which is returned by this function.  */\n \n-static tree\n-get_final_alloc_stmt (tree alloc_stmt)\n+static gimple\n+get_final_alloc_stmt (gimple alloc_stmt)\n {\n-  tree final_stmt;\n+  gimple final_stmt;\n   use_operand_p use_p;\n   tree alloc_res;\n \n   if (!alloc_stmt)\n     return NULL;\n   \n-  if (TREE_CODE (alloc_stmt) != GIMPLE_MODIFY_STMT)\n+  if (!is_gimple_call (alloc_stmt))\n     return NULL;\n \n-  alloc_res = GIMPLE_STMT_OPERAND (alloc_stmt, 0);\n+  alloc_res = gimple_get_lhs (alloc_stmt);\n \n   if (TREE_CODE (alloc_res) != SSA_NAME)\n     return NULL;\n@@ -758,7 +751,7 @@ get_final_alloc_stmt (tree alloc_stmt)\n    sites of function FN_DECL. It returns false otherwise.  */\n \n static bool\n-is_part_of_malloc (tree stmt, tree fn_decl)\n+is_part_of_malloc (gimple stmt, tree fn_decl)\n {\n   fallocs_t fallocs = get_fallocs (fn_decl);\n   \n@@ -767,8 +760,7 @@ is_part_of_malloc (tree stmt, tree fn_decl)\n       alloc_site_t *call;\n       unsigned i;\n \n-      for (i = 0;\n-\t   VEC_iterate (alloc_site_t, fallocs->allocs, i, call); i++)\n+      for (i = 0; VEC_iterate (alloc_site_t, fallocs->allocs, i, call); i++)\n \tif (call->stmt == stmt\n \t    || get_final_alloc_stmt (call->stmt) == stmt)\n \t  return true;\n@@ -780,7 +772,7 @@ is_part_of_malloc (tree stmt, tree fn_decl)\n struct find_stmt_data\n {\n   bool found;\n-  tree stmt;\n+  gimple stmt;\n };\n \n /* This function looks for DATA->stmt among \n@@ -790,9 +782,8 @@ struct find_stmt_data\n static int\n find_in_field_accs (void **slot, void *data)\n {\n-  struct field_access_site *f_acc = \n-    *(struct field_access_site **) slot;\n-  tree stmt = ((struct find_stmt_data *)data)->stmt;\n+  struct field_access_site *f_acc = *(struct field_access_site **) slot;\n+  gimple stmt = ((struct find_stmt_data *)data)->stmt;\n \n   if (f_acc->stmt == stmt\n       || f_acc->ref_def_stmt == stmt\n@@ -810,7 +801,7 @@ find_in_field_accs (void **slot, void *data)\n    and false otherwise.  */\n \n static bool\n-is_part_of_field_access (tree stmt, d_str str)\n+is_part_of_field_access (gimple stmt, d_str str)\n {\n   int i;\n \n@@ -883,7 +874,8 @@ struct ref_pos\n static tree\n find_pos_in_stmt_1 (tree *tp, int *walk_subtrees, void * data)\n {\n-  struct ref_pos * r_pos = (struct ref_pos *) data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  struct ref_pos *r_pos = (struct ref_pos *) wi->info;\n   tree ref = r_pos->ref;\n   tree t = *tp;\n \n@@ -893,37 +885,25 @@ find_pos_in_stmt_1 (tree *tp, int *walk_subtrees, void * data)\n       return t;\n     }\n \n-  switch (TREE_CODE (t))\n-    {\n-    case GIMPLE_MODIFY_STMT:\n-      {\n-\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n-\t*walk_subtrees = 1;\n-\twalk_tree (&lhs, find_pos_in_stmt_1, data, NULL);\n-\twalk_tree (&rhs, find_pos_in_stmt_1, data, NULL);\n-\t*walk_subtrees = 0;\t    \n-      }\n-      break;\n-\n-    default:\n-      *walk_subtrees = 1;      \n-    }\n-    return NULL_TREE;\n+  *walk_subtrees = 1;      \n+  return NULL_TREE;\n }\n \n \n /* This function looks for the pointer of REF in STMT,\n    It returns it, if found, and NULL otherwise.  */\n \n static tree *\n-find_pos_in_stmt (tree stmt, tree ref)\n+find_pos_in_stmt (gimple stmt, tree ref)\n {\n   struct ref_pos r_pos;\n+  struct walk_stmt_info wi;\n \n   r_pos.ref = ref;\n   r_pos.pos = NULL;\n-  walk_tree (&stmt, find_pos_in_stmt_1, &r_pos, NULL);\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = &r_pos;\n+  walk_gimple_op (stmt, find_pos_in_stmt_1, &wi);\n \n   return r_pos.pos;\n }\n@@ -1003,16 +983,15 @@ replace_field_acc (struct field_access_site *acc, tree new_type)\n   new_acc = build_comp_ref (new_ref, field_id, new_type);\n   VEC_free (type_wrapper_t, heap, wrapper);  \n \n-  if (TREE_CODE (acc->stmt) == GIMPLE_MODIFY_STMT)\n+  if (is_gimple_assign (acc->stmt))\n     {      \n-      lhs = GIMPLE_STMT_OPERAND (acc->stmt, 0);\n-      rhs = GIMPLE_STMT_OPERAND (acc->stmt, 1);\n-      \n-\t\n+      lhs = gimple_assign_lhs (acc->stmt);\n+      rhs = gimple_assign_rhs1 (acc->stmt);\n+\n       if (lhs == acc->comp_ref)\n-\tGIMPLE_STMT_OPERAND (acc->stmt, 0) = new_acc;\n+\tgimple_assign_set_lhs (acc->stmt, new_acc);\n       else if (rhs == acc->comp_ref)\n-\tGIMPLE_STMT_OPERAND (acc->stmt, 1) = new_acc;\n+\tgimple_assign_set_rhs1 (acc->stmt, new_acc);\n       else\n \t{\n \t  pos = find_pos_in_stmt (acc->stmt, acc->comp_ref);\n@@ -1070,18 +1049,15 @@ find_structure (tree type)\n    like assignments:  p.8_7 = p; or statements with rhs of \n    tree codes PLUS_EXPR and MINUS_EXPR.  */\n \n-static tree\n-create_base_plus_offset (tree orig_stmt, tree new_type, \n-\t\t\t tree offset)\n+static gimple\n+create_base_plus_offset (gimple orig_stmt, tree new_type, tree offset)\n {\n-  tree lhs, rhs;\n-  tree new_lhs, new_rhs;\n-  tree new_stmt;\n-\n-  gcc_assert (TREE_CODE (orig_stmt) == GIMPLE_MODIFY_STMT);\n+  tree lhs;\n+  tree new_lhs;\n+  gimple new_stmt;\n+  tree new_op0 = NULL_TREE, new_op1 = NULL_TREE;\n \n-  lhs = GIMPLE_STMT_OPERAND (orig_stmt, 0);\n-  rhs = GIMPLE_STMT_OPERAND (orig_stmt, 1);\n+  lhs = gimple_assign_lhs (orig_stmt);\n \n   gcc_assert (TREE_CODE (lhs) == VAR_DECL\n \t      || TREE_CODE (lhs) == SSA_NAME);\n@@ -1090,15 +1066,14 @@ create_base_plus_offset (tree orig_stmt, tree new_type,\n   gcc_assert (new_lhs);\n   finalize_var_creation (new_lhs);\n \n-  switch (TREE_CODE (rhs))\n+  switch (gimple_assign_rhs_code (orig_stmt))\n     {\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case POINTER_PLUS_EXPR:\n       {\n-\ttree op0 = TREE_OPERAND (rhs, 0);\n-\ttree op1 = TREE_OPERAND (rhs, 1);\n-\ttree new_op0 = NULL_TREE, new_op1 = NULL_TREE;\n+\ttree op0 = gimple_assign_rhs1 (orig_stmt);\n+\ttree op1 = gimple_assign_rhs2 (orig_stmt);\n \tunsigned str0, str1;\n \tunsigned length = VEC_length (structure, structures);\n \t\n@@ -1116,18 +1091,16 @@ create_base_plus_offset (tree orig_stmt, tree new_type,\n \t  new_op0 = offset;\n \tif (!new_op1)\n \t  new_op1 = offset;\n-\n-\tnew_rhs = build2 (TREE_CODE (rhs), TREE_TYPE (new_op0), \n-\t\t\t  new_op0, new_op1);\n       }\n       break;\n \n     default:\n       gcc_unreachable();\n     }\n   \n-  new_stmt = build_gimple_modify_stmt (new_lhs, new_rhs);\n-  finalize_stmt (new_stmt);\t\n+  new_stmt = gimple_build_assign_with_ops (gimple_assign_rhs_code (orig_stmt),\n+                                           new_lhs, new_op0, new_op1);\n+  finalize_stmt (new_stmt);\n \n   return new_stmt;\n }\n@@ -1140,9 +1113,10 @@ create_new_field_access (struct field_access_site *f_acc,\n \t\t\t struct field_entry field)\n {\n   tree new_type = field.field_mapping;\n-  tree new_stmt;\n+  gimple new_stmt;\n   tree size_res;\n-  tree mult_stmt, cast_stmt;\n+  gimple mult_stmt;\n+  gimple cast_stmt;\n   tree cast_res = NULL;\n   \n   if (f_acc->num)\n@@ -1182,41 +1156,37 @@ create_new_field_access (struct field_access_site *f_acc,\n    variable located in the condition statement at the position POS.  */\n \n static void\n-create_new_stmts_for_cond_expr_1 (tree new_var, tree cond_stmt, bool pos)\n+create_new_stmts_for_cond_expr_1 (tree new_var, gimple cond_stmt, unsigned pos)\n {\n-  tree new_cond;\n-  tree new_stmt;\n+  gimple new_stmt;\n   edge true_e = NULL, false_e = NULL;\n   basic_block new_bb;\n-  tree stmt_list;\n+  gimple_stmt_iterator si;\n \n-  extract_true_false_edges_from_block (bb_for_stmt (cond_stmt),\n+  extract_true_false_edges_from_block (gimple_bb (cond_stmt),\n \t\t\t\t       &true_e, &false_e);\n \n-  new_cond = unshare_expr (COND_EXPR_COND (cond_stmt));\n-\n-  TREE_OPERAND (new_cond, pos) = new_var;\n-\t\t\t\t      \n-  new_stmt = build3 (COND_EXPR, TREE_TYPE (cond_stmt),\n-\t\t     new_cond, NULL_TREE, NULL_TREE);\n+  new_stmt = gimple_build_cond (gimple_cond_code (cond_stmt),\n+\t\t\t       pos == 0 ? new_var : gimple_cond_lhs (cond_stmt),\n+\t\t\t       pos == 1 ? new_var : gimple_cond_rhs (cond_stmt),\n+\t\t\t       NULL_TREE,\n+\t\t\t       NULL_TREE);\n \n   finalize_stmt (new_stmt);\n \n   /* Create new basic block after bb.  */\n-  new_bb = create_empty_bb (bb_for_stmt (cond_stmt));\n+  new_bb = create_empty_bb (gimple_bb (cond_stmt));\n \n   /* Add new condition stmt to the new_bb.  */\n-  stmt_list = bb_stmt_list (new_bb);\n-  append_to_statement_list (new_stmt, &stmt_list);\n-  add_bb_info (new_bb, stmt_list);\n+  si = gsi_start_bb (new_bb);\n+  gsi_insert_after (&si, new_stmt, GSI_NEW_STMT);\n \n-\t\t  \n   /* Create false and true edges from new_bb.  */\n   make_edge_and_fix_phis_of_dest (new_bb, true_e);\n   make_edge_and_fix_phis_of_dest (new_bb, false_e);\n \t\t  \n   /* Redirect one of original edges to point to new_bb.  */\n-  if (TREE_CODE (cond_stmt) == NE_EXPR)\n+  if (gimple_cond_code (cond_stmt) == NE_EXPR)\n     redirect_edge_succ (true_e, new_bb);\n   else\n     redirect_edge_succ (false_e, new_bb);\n@@ -1227,23 +1197,22 @@ create_new_stmts_for_cond_expr_1 (tree new_var, tree cond_stmt, bool pos)\n    recursively redirect edges to newly generated basic blocks.  */\n \n static void\n-create_new_stmts_for_cond_expr (tree stmt)\n+create_new_stmts_for_cond_expr (gimple stmt)\n {\n-  tree cond = COND_EXPR_COND (stmt);\n   tree arg0, arg1, arg;\n   unsigned str0, str1;\n   bool s0, s1;\n   d_str str;\n   tree type;\n-  bool pos;\n+  unsigned pos;\n   int i;\n   unsigned length = VEC_length (structure, structures);\n \n-  gcc_assert (TREE_CODE (cond) == EQ_EXPR\n-\t      || TREE_CODE (cond) == NE_EXPR);\n+  gcc_assert (gimple_cond_code (stmt) == EQ_EXPR\n+\t      || gimple_cond_code (stmt) == NE_EXPR);\n \n-  arg0 = TREE_OPERAND (cond, 0);\n-  arg1 = TREE_OPERAND (cond, 1);\n+  arg0 = gimple_cond_lhs (stmt);\n+  arg1 = gimple_cond_rhs (stmt);\n \n   str0 = find_structure (strip_type (get_type_of_var (arg0)));\n   str1 = find_structure (strip_type (get_type_of_var (arg1)));\n@@ -1273,15 +1242,14 @@ create_new_stmts_for_cond_expr (tree stmt)\n /* Create a new general access to replace original access ACC\n    for structure type NEW_TYPE.  */\n \n-static tree\n+static gimple\n create_general_new_stmt (struct access_site *acc, tree new_type)\n {\n-  tree old_stmt = acc->stmt;\n+  gimple old_stmt = acc->stmt;\n   tree var;\n-  tree new_stmt = unshare_expr (old_stmt);\n+  gimple new_stmt = gimple_copy (old_stmt);\n   unsigned i;\n \n-  \n   for (i = 0; VEC_iterate (tree, acc->vars, i, var); i++)\n     {\n       tree *pos;\n@@ -1291,32 +1259,30 @@ create_general_new_stmt (struct access_site *acc, tree new_type)\n       gcc_assert (new_var);\n       finalize_var_creation (new_var);\n \n-      if (TREE_CODE (new_stmt) == GIMPLE_MODIFY_STMT)\n+      if (is_gimple_assign (new_stmt))\n \t{\n-      \n-\t  lhs = GIMPLE_STMT_OPERAND (new_stmt, 0);\n-\t  rhs = GIMPLE_STMT_OPERAND (new_stmt, 1);\n+\t  lhs = gimple_assign_lhs (new_stmt);\n \t  \n \t  if (TREE_CODE (lhs) == SSA_NAME)\n \t    lhs = SSA_NAME_VAR (lhs);\n-\t  if (TREE_CODE (rhs) == SSA_NAME)\n-\t    rhs = SSA_NAME_VAR (rhs); \n+\t  if (gimple_assign_rhs_code (new_stmt) == SSA_NAME)\n+\t    rhs = SSA_NAME_VAR (gimple_assign_rhs1 (new_stmt));\n \n \t  /* It can happen that rhs is a constructor.\n \t   Then we have to replace it to be of new_type.  */\n-\t  if (TREE_CODE (rhs) == CONSTRUCTOR)\n+\t  if (gimple_assign_rhs_code (new_stmt) == CONSTRUCTOR)\n \t    {\n \t      /* Dealing only with empty constructors right now.  */\n \t      gcc_assert (VEC_empty (constructor_elt, \n \t\t\t\t     CONSTRUCTOR_ELTS (rhs)));\n \t      rhs = build_constructor (new_type, 0);\n-\t      GIMPLE_STMT_OPERAND (new_stmt, 1) = rhs;\n+\t      gimple_assign_set_rhs1 (new_stmt, rhs);\n \t    }\n \t  \n \t  if (lhs == var)\n-\t    GIMPLE_STMT_OPERAND (new_stmt, 0) = new_var;\n+\t    gimple_assign_set_lhs (new_stmt, new_var);\n \t  else if (rhs == var)\n-\t    GIMPLE_STMT_OPERAND (new_stmt, 1) = new_var;\n+\t    gimple_assign_set_rhs1 (new_stmt, new_var);\n \t  else\n \t    {\n \t      pos = find_pos_in_stmt (new_stmt, var);\n@@ -1343,12 +1309,12 @@ static void\n create_new_stmts_for_general_acc (struct access_site *acc, d_str str)\n {\n   tree type;\n-  tree stmt = acc->stmt;\n+  gimple stmt = acc->stmt;\n   unsigned i;\n \n   for (i = 0; VEC_iterate (tree, str->new_types, i, type); i++)\n     {\n-      tree new_stmt;\n+      gimple new_stmt;\n \n       new_stmt = create_general_new_stmt (acc, type);\n       insert_after_stmt (stmt, new_stmt);\n@@ -1361,10 +1327,10 @@ create_new_stmts_for_general_acc (struct access_site *acc, d_str str)\n static void\n create_new_general_access (struct access_site *acc, d_str str)\n {\n-  tree stmt = acc->stmt;\n-  switch (TREE_CODE (stmt))\n+  gimple stmt = acc->stmt;\n+  switch (gimple_code (stmt))\n     {\n-    case COND_EXPR:\n+    case GIMPLE_COND:\n       create_new_stmts_for_cond_expr (stmt);\n       break;\n \n@@ -1391,7 +1357,7 @@ create_new_acc (void **slot, void *data)\n   basic_block bb = ((struct create_acc_data *)data)->bb;\n   d_str str = ((struct create_acc_data *)data)->str;\n \n-  if (bb_for_stmt (acc->stmt) == bb)\n+  if (gimple_bb (acc->stmt) == bb)\n     create_new_general_access (acc, str);\n   return 1;\n }\n@@ -1407,7 +1373,7 @@ create_new_field_acc (void **slot, void *data)\n   d_str str = ((struct create_acc_data *)data)->str;\n   int i = ((struct create_acc_data *)data)->field_index;\n \n-  if (bb_for_stmt (f_acc->stmt) == bb)\n+  if (gimple_bb (f_acc->stmt) == bb)\n     create_new_field_access (f_acc, str->fields[i]);\n   return 1;\n }\n@@ -1462,11 +1428,11 @@ dump_field_acc (void **slot, void *data ATTRIBUTE_UNUSED)\n \n   fprintf(dump_file, \"\\n\");\n   if (f_acc->stmt)\n-    print_generic_stmt (dump_file, f_acc->stmt, 0);\n+    print_gimple_stmt (dump_file, f_acc->stmt, 0, 0);\n   if (f_acc->ref_def_stmt)\n-    print_generic_stmt (dump_file, f_acc->ref_def_stmt, 0);\n+    print_gimple_stmt (dump_file, f_acc->ref_def_stmt, 0, 0);\n   if (f_acc->cast_stmt)\n-    print_generic_stmt (dump_file, f_acc->cast_stmt, 0);\n+    print_gimple_stmt (dump_file, f_acc->cast_stmt, 0, 0);\n   return 1;\n }\n \n@@ -1697,63 +1663,60 @@ free_field_accesses (htab_t f_accs)\n    The edge origin is CONTEXT function.  */\n \n static void\n-update_cgraph_with_malloc_call (tree malloc_stmt, tree context)\n+update_cgraph_with_malloc_call (gimple malloc_stmt, tree context)\n {\n-  tree call_expr;\n   struct cgraph_node *src, *dest;\n   tree malloc_fn_decl;\n \n   if (!malloc_stmt)\n     return;\n \n-  call_expr = get_call_expr_in (malloc_stmt);\n-  malloc_fn_decl = get_callee_fndecl (call_expr);\n+  malloc_fn_decl = gimple_call_fndecl (malloc_stmt);\n     \n   src = cgraph_node (context);\n   dest = cgraph_node (malloc_fn_decl);\n   cgraph_create_edge (src, dest, malloc_stmt, \n-\t\t      0, 0, bb_for_stmt (malloc_stmt)->loop_depth);\n+\t\t      0, 0, gimple_bb (malloc_stmt)->loop_depth);\n }\n \n /* This function generates set of statements required \n    to allocate number NUM of structures of type NEW_TYPE.\n    The statements are stored in NEW_STMTS. The statement that contain\n    call to malloc is returned. MALLOC_STMT is an original call to malloc.  */\n \n-static tree\n-create_new_malloc (tree malloc_stmt, tree new_type, tree *new_stmts, tree num)\n+static gimple\n+create_new_malloc (gimple malloc_stmt, tree new_type, gimple_seq *new_stmts,\n+\t\t   tree num)\n {\n   tree new_malloc_size;\n-  tree call_expr, malloc_fn_decl;\n-  tree new_stmt, malloc_res;\n-  tree call_stmt, final_stmt;\n+  tree malloc_fn_decl;\n+  gimple new_stmt;\n+  tree malloc_res;\n+  gimple call_stmt, final_stmt;\n   tree cast_res;\n \n   gcc_assert (num && malloc_stmt && new_type);\n-  *new_stmts = alloc_stmt_list ();\n+  *new_stmts = gimple_seq_alloc ();\n \n   /* Generate argument to malloc as multiplication of num \n      and size of new_type.  */\n   new_stmt = gen_size (num, new_type, &new_malloc_size);\n-  append_to_statement_list (new_stmt, new_stmts);\n+  gimple_seq_add_stmt (new_stmts, new_stmt);\n \n   /* Generate new call for malloc.  */\n   malloc_res = create_tmp_var (ptr_type_node, NULL);\n+  add_referenced_var (malloc_res);\n \n-  if (malloc_res)\n-    add_referenced_var (malloc_res);\n-\n-  call_expr = get_call_expr_in (malloc_stmt);\n-  malloc_fn_decl = get_callee_fndecl (call_expr);\n-  call_expr = build_call_expr (malloc_fn_decl, 1, new_malloc_size); \n-  call_stmt = build_gimple_modify_stmt (malloc_res, call_expr);\n+  malloc_fn_decl = gimple_call_fndecl (malloc_stmt);\n+  call_stmt = gimple_build_call (malloc_fn_decl, 1, new_malloc_size); \n+  gimple_call_set_lhs (call_stmt, malloc_res);\n   finalize_stmt_and_append (new_stmts, call_stmt);\n \n   /* Create new cast statement. */\n   final_stmt = get_final_alloc_stmt (malloc_stmt);\n   gcc_assert (final_stmt);\n   new_stmt = gen_cast_stmt (malloc_res, new_type, final_stmt, &cast_res);\n-  append_to_statement_list (new_stmt, new_stmts);\n+  gimple_seq_add_stmt (new_stmts, new_stmt);\n  \n   return call_stmt;      \n }\n@@ -1764,23 +1727,21 @@ create_new_malloc (tree malloc_stmt, tree new_type, tree *new_stmts, tree num)\n    they are filled into NEW_STMTS_P.  */\n \n static tree \n-gen_num_of_structs_in_malloc (tree stmt, tree str_decl, tree *new_stmts_p)\n+gen_num_of_structs_in_malloc (gimple stmt, tree str_decl,\n+\t\t\t      gimple_seq *new_stmts_p)\n {\n-  call_expr_arg_iterator iter;\n   tree arg;\n-  tree call_expr;\n   tree struct_size;\n   HOST_WIDE_INT struct_size_int;\n \n   if (!stmt)\n     return NULL_TREE;\n \n   /* Get malloc argument.  */\n-  call_expr = get_call_expr_in (stmt);\n-  if (!call_expr)\n+  if (!is_gimple_call (stmt))\n     return NULL_TREE;\n \n-  arg = first_call_expr_arg (call_expr, &iter);\n+  arg = gimple_call_arg (stmt, 0);\n \n   if (TREE_CODE (arg) != SSA_NAME\n       && !TREE_CONSTANT (arg))\n@@ -1793,7 +1754,8 @@ gen_num_of_structs_in_malloc (tree stmt, tree str_decl, tree *new_stmts_p)\n \n   if (TREE_CODE (arg) == SSA_NAME)\n     {\n-      tree num, div_stmt;\n+      tree num;\n+      gimple div_stmt;\n \n       if (is_result_of_mult (arg, &num, struct_size))\n \t  return num;      \n@@ -1804,23 +1766,16 @@ gen_num_of_structs_in_malloc (tree stmt, tree str_decl, tree *new_stmts_p)\n \tadd_referenced_var (num);\n \n       if (exact_log2 (struct_size_int) == -1)\n-\tdiv_stmt = build_gimple_modify_stmt (num, \n-\t\t\t\t\t     build2 (TRUNC_DIV_EXPR, \n-\t\t\t\t\t\t     integer_type_node,\n-\t\t\t\t\t\t     arg, struct_size));\n+\tdiv_stmt = gimple_build_assign_with_ops (TRUNC_DIV_EXPR, num, arg,\n+\t\t\t\t\t\t struct_size);\n       else\n \t{\n \t  tree C =  build_int_cst (integer_type_node,\n \t\t\t\t   exact_log2 (struct_size_int)); \n \n-\t  div_stmt = \n-\t    build_gimple_modify_stmt (num, build2 (RSHIFT_EXPR, \n-\t\t\t\t\t\t   integer_type_node,\n-\t\t\t\t\t\t   arg, C)); \n+\t  div_stmt = gimple_build_assign_with_ops (RSHIFT_EXPR, num, arg, C); \n \t}\n-      *new_stmts_p = alloc_stmt_list ();\n-      append_to_statement_list (div_stmt, \n-\t\t\t\tnew_stmts_p);\n+      gimple_seq_add_stmt (new_stmts_p, div_stmt);\n       finalize_stmt (div_stmt);\n       return num;\n     }\n@@ -2049,7 +2004,7 @@ field_acc_hash (const void *x)\n static int\n field_acc_eq (const void *x, const void *y)\n {\n-  return ((const struct field_access_site *)x)->stmt == (const_tree)y;\n+  return ((const struct field_access_site *)x)->stmt == (const_gimple)y;\n }\n \n /* This function prints an access site, defined by SLOT.  */ \n@@ -2063,7 +2018,7 @@ dump_acc (void **slot, void *data ATTRIBUTE_UNUSED)\n \n   fprintf(dump_file, \"\\n\");\n   if (acc->stmt)\n-    print_generic_stmt (dump_file, acc->stmt, 0);\n+    print_gimple_stmt (dump_file, acc->stmt, 0, 0);\n   fprintf(dump_file, \" : \");\n \n   for (i = 0; VEC_iterate (tree, acc->vars, i, var); i++)\n@@ -2146,35 +2101,33 @@ create_new_alloc_sites (fallocs_t m_data, tree context)\n   alloc_site_t *call;\n   unsigned j;\n   \n-  for (j = 0;\n-       VEC_iterate (alloc_site_t, m_data->allocs, j, call); j++)\n+  for (j = 0; VEC_iterate (alloc_site_t, m_data->allocs, j, call); j++)\n     {\n-      tree stmt = call->stmt;\n+      gimple stmt = call->stmt;\n       d_str str = call->str;\n       tree num;\n-      tree new_stmts = NULL_TREE;\n-      tree last_stmt = get_final_alloc_stmt (stmt);\n+      gimple_seq new_stmts = NULL;\n+      gimple last_stmt = get_final_alloc_stmt (stmt);\n       unsigned i;\n       tree type;\n \n       num = gen_num_of_structs_in_malloc (stmt, str->decl, &new_stmts);\n       if (new_stmts)\n \t{\n-\t  last_stmt = tsi_stmt (tsi_last (new_stmts));\n-\t  insert_after_stmt (last_stmt, new_stmts);\n+\t  last_stmt = gimple_seq_last_stmt (new_stmts);\n+\t  insert_seq_after_stmt (last_stmt, new_stmts);\n \t}\n       \n       /* Generate an allocation sites for each new structure type.  */      \n-      for (i = 0; \n-\t   VEC_iterate (tree, str->new_types, i, type); i++)\t\n+      for (i = 0; VEC_iterate (tree, str->new_types, i, type); i++)\t\n \t{\n-\t  tree new_malloc_stmt = NULL_TREE;\n-\t  tree last_stmt_tmp = NULL_TREE;\n+\t  gimple new_malloc_stmt = NULL;\n+\t  gimple last_stmt_tmp = NULL;\n \n-\t  new_stmts = NULL_TREE;\n+\t  new_stmts = NULL;\n \t  new_malloc_stmt = create_new_malloc (stmt, type, &new_stmts, num);\n-\t  last_stmt_tmp = tsi_stmt (tsi_last (new_stmts));\n-\t  insert_after_stmt (last_stmt, new_stmts);\n+\t  last_stmt_tmp = gimple_seq_last_stmt (new_stmts);\n+\t  insert_seq_after_stmt (last_stmt, new_stmts);\n \t  update_cgraph_with_malloc_call (new_malloc_stmt, context);\n \t  last_stmt = last_stmt_tmp;\n \t}\n@@ -2304,7 +2257,7 @@ acc_hash (const void *x)\n static int\n acc_eq (const void *x, const void *y)\n {\n-  return ((const struct access_site *)x)->stmt == (const_tree)y;\n+  return ((const struct access_site *)x)->stmt == (const_gimple)y;\n }\n \n /* Given a structure declaration STRUCT_DECL, and number of fields \n@@ -2405,25 +2358,19 @@ remove_structure (unsigned i)\n    COND_STMT is a condition statement to check.  */\n \n static bool\n-is_safe_cond_expr (tree cond_stmt)\n+is_safe_cond_expr (gimple cond_stmt)\n {\n-\n   tree arg0, arg1;\n   unsigned str0, str1;\n   bool s0, s1;\n   unsigned length = VEC_length (structure, structures);\n \n-  tree cond = COND_EXPR_COND (cond_stmt);\n-\n-  if (TREE_CODE (cond) != EQ_EXPR\n-      && TREE_CODE (cond) != NE_EXPR)\n+  if (gimple_cond_code (cond_stmt) != EQ_EXPR\n+      && gimple_cond_code (cond_stmt) != NE_EXPR)\n     return false;\n   \n-  if (TREE_CODE_LENGTH (TREE_CODE (cond)) != 2)\n-    return false;\n-\n-  arg0 = TREE_OPERAND (cond, 0);\n-  arg1 = TREE_OPERAND (cond, 1);\n+  arg0 = gimple_cond_lhs (cond_stmt);\n+  arg1 = gimple_cond_rhs (cond_stmt);\n \n   str0 = find_structure (strip_type (get_type_of_var (arg0)));\n   str1 = find_structure (strip_type (get_type_of_var (arg1)));\n@@ -2470,25 +2417,15 @@ exclude_from_accs (void **slot, void *data)\n static tree\n get_stmt_accesses (tree *tp, int *walk_subtrees, void *data)\n {\n-  tree stmt = (tree) data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  gimple stmt = (gimple) wi->info;\n   tree t = *tp;\n \n   if (!t)\n     return NULL;\n \n   switch (TREE_CODE (t))\n     {\n-    case GIMPLE_MODIFY_STMT:\n-      {\n-\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n-\t*walk_subtrees = 1;\n-\twalk_tree (&lhs, get_stmt_accesses, data, NULL);\n-\twalk_tree (&rhs, get_stmt_accesses, data, NULL);\n-\t*walk_subtrees = 0;\t    \n-      }\n-      break;\n-\n     case BIT_FIELD_REF:\n       {\n \ttree var = TREE_OPERAND(t, 0);\n@@ -2549,7 +2486,7 @@ get_stmt_accesses (tree *tp, int *walk_subtrees, void *data)\n \t\t\t    print_generic_expr (dump_file, type, 0);\n \t\t\t    fprintf (dump_file, \n \t\t\t\t     \" has complicate access in statement \");\n-\t\t\t    print_generic_stmt (dump_file, stmt, 0);\n+\t\t\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t\t  }\n \t\t\t\n \t\t\tremove_structure (i);\n@@ -2558,7 +2495,7 @@ get_stmt_accesses (tree *tp, int *walk_subtrees, void *data)\n \t\t    else\n \t\t      {\n \t\t\t/* Increase count of field.  */\n-\t\t\tbasic_block bb = bb_for_stmt (stmt);\n+\t\t\tbasic_block bb = gimple_bb (stmt);\n \t\t\tfield->count += bb->count;\n \n \t\t\t/* Add stmt to the acc_sites of field.  */\n@@ -2571,18 +2508,6 @@ get_stmt_accesses (tree *tp, int *walk_subtrees, void *data)\n       }\n       break;\n \n-    case MINUS_EXPR:\n-    case PLUS_EXPR:\n-      {\n-\ttree op0 = TREE_OPERAND (t, 0);\n-\ttree op1 = TREE_OPERAND (t, 1);\n-\t*walk_subtrees = 1;\t    \n-\twalk_tree (&op0, get_stmt_accesses, data, NULL);\n-\twalk_tree (&op1, get_stmt_accesses, data, NULL);\t\n-\t*walk_subtrees = 0;\t    \n-      }\n-      break;\n-\n     case COND_EXPR:\n       {\n \ttree cond = COND_EXPR_COND (t);\n@@ -2618,14 +2543,6 @@ get_stmt_accesses (tree *tp, int *walk_subtrees, void *data)\n       }\n       break;\n \n-    case CALL_EXPR:\n-      {\n-\t/* It was checked as part of stage1 that structures \n-\t   to be transformed cannot be passed as parameters of functions.  */\n-\t*walk_subtrees = 0;\t    \n-      }\n-      break;\n-\n     default:\n       return NULL;\n     }\n@@ -3019,7 +2936,7 @@ add_structure (tree type)\n    allocates the structure represented by STR.  */\n \n static void\n-add_alloc_site (tree fn_decl, tree stmt, d_str str)\n+add_alloc_site (tree fn_decl, gimple stmt, d_str str)\n {\n   fallocs_t fallocs = NULL;\n   alloc_site_t m_call;\n@@ -3049,7 +2966,7 @@ add_alloc_site (tree fn_decl, tree stmt, d_str str)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nAdding stmt \");\n-      print_generic_stmt (dump_file, stmt, 0);\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n       fprintf (dump_file, \" to list of mallocs.\");\n     }\n }\n@@ -3061,11 +2978,11 @@ add_alloc_site (tree fn_decl, tree stmt, d_str str)\n    Otherwise I_P contains the length of the vector of structures.  */\n \n static bool\n-is_alloc_of_struct (tree stmt, unsigned *i_p)\n+is_alloc_of_struct (gimple stmt, unsigned *i_p)\n {\n   tree lhs;\n   tree type;\n-  tree final_stmt;\n+  gimple final_stmt;\n \n   final_stmt = get_final_alloc_stmt (stmt);\n \n@@ -3075,10 +2992,10 @@ is_alloc_of_struct (tree stmt, unsigned *i_p)\n   /* final_stmt should be of the form:\n      T.3 = (struct_type *) T.2; */\n \n-  if (TREE_CODE (final_stmt) != GIMPLE_MODIFY_STMT)\n+  if (gimple_code (final_stmt) != GIMPLE_ASSIGN)\n     return false;\n \n-  lhs = GIMPLE_STMT_OPERAND (final_stmt, 0);      \n+  lhs = gimple_assign_lhs (final_stmt);\n \n   type = get_type_of_var (lhs);\n       \n@@ -3128,13 +3045,13 @@ safe_cond_expr_check (void **slot, void *data)\n {\n   struct access_site *acc = *(struct access_site **) slot;\n \n-  if (TREE_CODE (acc->stmt) == COND_EXPR\n+  if (gimple_code (acc->stmt) == GIMPLE_COND\n       && !is_safe_cond_expr (acc->stmt))\n     {\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"\\nUnsafe conditional statement \");\n-\t  print_generic_stmt (dump_file, acc->stmt, 0);\n+\t  print_gimple_stmt (dump_file, acc->stmt, 0, 0);\n \t}\n       *(bool *) data = false;\n       return 0;\n@@ -3163,21 +3080,25 @@ exclude_alloc_and_field_accs_1 (d_str str, struct cgraph_node *node)\n static void\n collect_accesses_in_bb (basic_block bb)\n {\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator bsi;\n+  struct walk_stmt_info wi;\n+\n+  memset (&wi, 0, sizeof (wi));\n \n-  for (bsi = bsi_start (bb); ! bsi_end_p (bsi); bsi_next (&bsi))\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n-      tree stmt = bsi_stmt (bsi);\n+      gimple stmt = gsi_stmt (bsi);\n \n       /* In asm stmt we cannot always track the arguments,\n \t so we just give up.  */\n-      if (TREE_CODE (stmt) == ASM_EXPR)\n+      if (gimple_code (stmt) == GIMPLE_ASM)\n \t{\n \t  free_structures ();\n \t  break;\n \t}\n \n-      walk_tree (&stmt, get_stmt_accesses, stmt, NULL);\n+      wi.info = (void *) stmt;\n+      walk_gimple_op (stmt, get_stmt_accesses, &wi);\n     }\n }\n \n@@ -3467,25 +3388,23 @@ program_redefines_malloc_p (void)\n   struct cgraph_edge *c_edge;\n   tree fndecl;\n   tree fndecl2;\n-  tree call_expr;\n   \n   for (c_node = cgraph_nodes; c_node; c_node = c_node->next)\n     {\n       fndecl = c_node->decl;\n \n       for (c_edge = c_node->callees; c_edge; c_edge = c_edge->next_callee)\n \t{\n-\t  call_expr = get_call_expr_in (c_edge->call_stmt);\n \t  c_node2 = c_edge->callee;\n \t  fndecl2 = c_node2->decl;\n-\t  if (call_expr)\n+\t  if (is_gimple_call (c_edge->call_stmt))\n \t    {\n \t      const char * fname = get_name (fndecl2);\n \n-\t      if ((call_expr_flags (call_expr) & ECF_MALLOC) &&\n-\t\t  (DECL_FUNCTION_CODE (fndecl2) != BUILT_IN_MALLOC) &&\n-\t\t  (DECL_FUNCTION_CODE (fndecl2) != BUILT_IN_CALLOC) &&\n-\t\t  (DECL_FUNCTION_CODE (fndecl2) != BUILT_IN_ALLOCA))\n+\t      if ((gimple_call_flags (c_edge->call_stmt) & ECF_MALLOC)\n+\t\t  && (DECL_FUNCTION_CODE (fndecl2) != BUILT_IN_MALLOC)\n+\t\t  && (DECL_FUNCTION_CODE (fndecl2) != BUILT_IN_CALLOC)\n+\t\t  && (DECL_FUNCTION_CODE (fndecl2) != BUILT_IN_ALLOCA))\n \t\treturn true;\n \n \t      /* Check that there is no __builtin_object_size,\n@@ -3527,15 +3446,15 @@ collect_alloc_sites (void)\n       {\n \tfor (cs = node->callees; cs; cs = cs->next_callee)\n \t  {\n-\t    tree stmt = cs->call_stmt;\n+\t    gimple stmt = cs->call_stmt;\n \n \t    if (stmt)\n \t      {\n-\t\ttree call = get_call_expr_in (stmt);\n \t\ttree decl;\n \n-\t\tif (call && (decl = get_callee_fndecl (call)) \n-\t\t    && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t\tif (is_gimple_call (stmt)\n+\t\t    && (decl = gimple_call_fndecl (stmt)) \n+\t\t    && gimple_call_lhs (stmt))\n \t\t  {\n \t\t    unsigned i;\n \n@@ -3555,7 +3474,7 @@ collect_alloc_sites (void)\n \t\t\t      {\n \t\t\t\tfprintf (dump_file, \n \t\t\t\t\t \"\\nUnsupported allocation function \");\n-\t\t\t\tprint_generic_stmt (dump_file, stmt, 0);\n+\t\t\t\tprint_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t\t      }\n \t\t\t    remove_structure (i);\t\t\n \t\t\t  }\n@@ -4035,8 +3954,9 @@ reorg_structs_drive (void)\n static bool\n struct_reorg_gate (void)\n {\n-  return flag_ipa_struct_reorg && flag_whole_program \n-    && (optimize > 0);\n+  return flag_ipa_struct_reorg\n+\t && flag_whole_program \n+\t && (optimize > 0);\n }\n \n struct simple_ipa_opt_pass pass_ipa_struct_reorg = "}, {"sha": "a92d345ec926b24c9393def6863068b3d816617b", "filename": "gcc/ipa-struct-reorg.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-struct-reorg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-struct-reorg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -37,23 +37,23 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n struct field_access_site\n {\n   /* Statement in which the access site occurs.  */\n-  tree stmt;             /* D.2169_25 = D.2168_24->b;  */\n+  gimple stmt;           /* D.2169_25 = D.2168_24->b;  */\n   tree comp_ref;         /* D.2168_24->b  */\n   tree field_decl;       /* b */\n   tree ref;              /* D.2168_24  */\n   tree num;              /* i.6_20  */\n   tree offset;           /* D2167_22  */\n   tree base;             /* p.5_23  */\n-  tree ref_def_stmt;     /* D.2168_24 = D.2167_22 + p.5_23;  */\n-  tree cast_stmt;        /* D.2167_22 = (struct str_t *) D.2166_21;\n+  gimple ref_def_stmt;   /* D.2168_24 = D.2167_22 + p.5_23;  */\n+  gimple cast_stmt;      /* D.2167_22 = (struct str_t *) D.2166_21;\n                             This statement is not always present.  */\n };\n \n /* A non-field structure access site.  */\n struct access_site\n {\n   /* A statement in which the access site occurs.  */\n-  tree stmt;\n+  gimple stmt;\n   /* A list of structure variables in the access site.  */\n   VEC (tree, heap) *vars;\n };"}, {"sha": "48d95049b4f3c355c852c49d9dc1d3a6ca18f058", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 220, "deletions": 297, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"ipa-type-escape.h\"\n #include \"c-common.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"cgraph.h\"\n #include \"output.h\"\n #include \"flags.h\"\n@@ -136,8 +136,8 @@ static bitmap_obstack ipa_obstack;\n \n /* Static functions from this file that are used \n    before being defined.  */\n-static unsigned int look_for_casts (tree lhs ATTRIBUTE_UNUSED, tree);\n-static bool is_cast_from_non_pointer (tree, tree, void *);\n+static unsigned int look_for_casts (tree);\n+static bool is_cast_from_non_pointer (tree, gimple, void *);\n \n /* Get the name of TYPE or return the string \"<UNNAMED>\".  */\n static const char*\n@@ -308,7 +308,7 @@ get_canon_type (tree type, bool see_thru_ptrs, bool see_thru_arrays)\n     while (POINTER_TYPE_P (type))\n \ttype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \n-  result = splay_tree_lookup(type_to_canon_type, (splay_tree_key) type);\n+  result = splay_tree_lookup (type_to_canon_type, (splay_tree_key) type);\n   \n   if (result == NULL)\n     return discover_unique_type (type);\n@@ -663,9 +663,7 @@ check_cast_type (tree to_type, tree from_type)\n static bool\n is_malloc_result (tree var)\n {\n-  tree def_stmt;\n-  tree rhs;\n-  int flags;\n+  gimple def_stmt;\n \n   if (!var)\n     return false;\n@@ -675,20 +673,13 @@ is_malloc_result (tree var)\n \n   def_stmt = SSA_NAME_DEF_STMT (var);\n   \n-  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n+  if (!is_gimple_call (def_stmt))\n     return false;\n \n-  if (var != GIMPLE_STMT_OPERAND (def_stmt, 0))\n+  if (var != gimple_call_lhs (def_stmt))\n     return false;\n \n-  rhs = get_call_expr_in (def_stmt);\n-\n-  if (!rhs)\n-    return false;\n-\n-  flags = call_expr_flags (rhs);\n-    \n-  return ((flags & ECF_MALLOC) != 0);\n+  return ((gimple_call_flags (def_stmt) & ECF_MALLOC) != 0);\n \n }\n \n@@ -769,115 +760,98 @@ check_cast (tree to_type, tree from)\n   return cast;\n }\n \n-typedef struct cast \n-{\n-  int type;\n-  tree stmt;\n-}cast_t;\n-\n-/* This function is a callback for walk_tree called from \n-   is_cast_from_non_pointer. The data->type is set to be:\n \n-   0      - if there is no cast\n-   number - the number of casts from non-pointer type\n-   -1     - if there is a cast that makes the type to escape\n+/* Scan assignment statement S to see if there are any casts within it.  */\n \n-   If data->type = number, then data->stmt will contain the \n-   last casting stmt met in traversing.  */\n-\n-static tree\n-is_cast_from_non_pointer_1 (tree *tp, int *walk_subtrees, void *data)\n+static unsigned int\n+look_for_casts_stmt (gimple s)\n {\n-  tree def_stmt = *tp;\n+  unsigned int cast = 0;\n \n+  gcc_assert (is_gimple_assign (s));\n \n-  if (pointer_set_insert (visited_stmts, def_stmt))\n+  if (gimple_assign_cast_p (s))\n     {\n-      *walk_subtrees = 0;\n-      return NULL;\n+      tree castfromvar = gimple_assign_rhs1 (s);\n+      cast |= check_cast (TREE_TYPE (gimple_assign_lhs (s)), castfromvar);\n     }\n-  \n-  switch (TREE_CODE (def_stmt))\n+  else\n     {\n-    case GIMPLE_MODIFY_STMT:\n-      {\n-\tuse_operand_p use_p; \n-\tssa_op_iter iter;\n-\ttree lhs = GIMPLE_STMT_OPERAND (def_stmt, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n-\n-        unsigned int cast = look_for_casts (lhs, rhs);\n-\t/* Check that only one cast happened, and it's of \n-\t   non-pointer type.  */\n-\tif ((cast & CT_FROM_NON_P) == (CT_FROM_NON_P) \n-\t    && (cast & ~(CT_FROM_NON_P)) == 0)\n-\t  {\n-\t    ((cast_t *)data)->stmt = def_stmt;\n-\t    ((cast_t *)data)->type++;\n-\n-\t    FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n-\t      {\n-\t\twalk_use_def_chains (USE_FROM_PTR (use_p), is_cast_from_non_pointer, \n-\t\t\t\t     data, false);\n-\t\tif (((cast_t*)data)->type == -1)\n-\t\t  return def_stmt;\n-\t      }\n-\t  }\n-\n-\t/* Check that there is no cast, or cast is not harmful. */\n-\telse if ((cast & CT_NO_CAST) == (CT_NO_CAST)\n-\t\t || (cast & CT_DOWN) == (CT_DOWN)\n-\t\t || (cast & CT_UP) == (CT_UP)\n-\t\t || (cast & CT_USELESS) == (CT_USELESS)\n-\t\t || (cast & CT_FROM_MALLOC) == (CT_FROM_MALLOC))\n-\t  {\n-\t    FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n-\t      {\n-\t\twalk_use_def_chains (USE_FROM_PTR (use_p), is_cast_from_non_pointer, \n-\t\t\t\t     data, false);\n-\t\tif (((cast_t*)data)->type == -1)\n-\t\t  return def_stmt;\n-\t      }\t    \n-\t  }\n+      size_t i;\n+      for (i = 0; i < gimple_num_ops (s); i++)\n+\tcast |= look_for_casts (gimple_op (s, i));\n+    }\n \n-\t/* The cast is harmful.  */\n-\telse\n-\t  {\n-\t    ((cast_t *)data)->type = -1;\n-\t    return def_stmt;\n-\t  }\n+  if (!cast)\n+    cast = CT_NO_CAST;\n \n-\t*walk_subtrees = 0;\n-      }     \n-      break;\n+  return cast;\n+} \n \n-    default:\n-      {\n-\t*walk_subtrees = 0;\n-\tbreak;\n-      }\n-    }\n \n-  return NULL;\n-}\n+typedef struct cast \n+{\n+  int type;\n+  gimple stmt;\n+} cast_t;\n \n /* This function is a callback for walk_use_def_chains function called \n    from is_array_access_through_pointer_and_index.  */\n \n static bool\n-is_cast_from_non_pointer (tree var, tree def_stmt, void *data)\n+is_cast_from_non_pointer (tree var, gimple def_stmt, void *data)\n {\n-\n   if (!def_stmt || !var)\n     return false;\n   \n-  if (TREE_CODE (def_stmt) == PHI_NODE)\n+  if (gimple_code (def_stmt) == GIMPLE_PHI)\n     return false;\n \n   if (SSA_NAME_IS_DEFAULT_DEF (var))\n       return false;\n \n-  walk_tree (&def_stmt, is_cast_from_non_pointer_1, data, NULL);\n+  if (is_gimple_assign (def_stmt))\n+    {\n+      use_operand_p use_p; \n+      ssa_op_iter iter;\n+      unsigned int cast = look_for_casts_stmt (def_stmt);\n+\n+      /* Check that only one cast happened, and it's of non-pointer\n+\t type.  */\n+      if ((cast & CT_FROM_NON_P) == (CT_FROM_NON_P) \n+\t  && (cast & ~(CT_FROM_NON_P)) == 0)\n+\t{\n+\t  ((cast_t *)data)->stmt = def_stmt;\n+\t  ((cast_t *)data)->type++;\n+\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n+\t    {\n+\t      walk_use_def_chains (USE_FROM_PTR (use_p),\n+\t\t\t\t   is_cast_from_non_pointer, data, false);\n+\t      if (((cast_t*)data)->type == -1)\n+\t\tbreak;\n+\t    }\n+\t}\n+      /* Check that there is no cast, or cast is not harmful. */\n+      else if ((cast & CT_NO_CAST) == (CT_NO_CAST)\n+\t  || (cast & CT_DOWN) == (CT_DOWN)\n+\t  || (cast & CT_UP) == (CT_UP)\n+\t  || (cast & CT_USELESS) == (CT_USELESS)\n+\t  || (cast & CT_FROM_MALLOC) == (CT_FROM_MALLOC))\n+\t{\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n+\t    {\n+\t      walk_use_def_chains (USE_FROM_PTR (use_p),\n+\t\t\t\t   is_cast_from_non_pointer, data, false);\n+\t      if (((cast_t*)data)->type == -1)\n+\t\tbreak;\n+\t    }\t    \n+\t}\n+\t/* The cast is harmful.  */\n+\telse\n+\t  ((cast_t *)data)->type = -1;\n+    }     \n+\n   if (((cast_t*)data)->type == -1)\n     return true;\n   \n@@ -930,9 +904,10 @@ is_cast_from_non_pointer (tree var, tree def_stmt, void *data)\n bool\n is_array_access_through_pointer_and_index (enum tree_code code, tree op0, \n \t\t\t\t\t   tree op1, tree *base, tree *offset,\n-\t\t\t\t\t   tree *offset_cast_stmt)\n+\t\t\t\t\t   gimple *offset_cast_stmt)\n {\n-  tree before_cast, before_cast_def_stmt;\n+  tree before_cast;\n+  gimple before_cast_def_stmt;\n   cast_t op0_cast, op1_cast;\n \n   *base = NULL;\n@@ -1014,26 +989,23 @@ is_array_access_through_pointer_and_index (enum tree_code code, tree op0,\n   /* before_cast_def_stmt should be of the form:\n      D.1605_6 = i.1_5 * 16; */\n   \n-  if (TREE_CODE (before_cast_def_stmt) == GIMPLE_MODIFY_STMT)\n+  if (is_gimple_assign (before_cast_def_stmt))\n     {\n-      tree lhs = GIMPLE_STMT_OPERAND (before_cast_def_stmt,0);\n-      tree rhs = GIMPLE_STMT_OPERAND (before_cast_def_stmt,1);\n-\n       /* We expect temporary here.  */\n-      if (!is_gimple_reg (lhs))\t\n+      if (!is_gimple_reg (gimple_assign_lhs (before_cast_def_stmt)))\n \treturn false;\n \n-      if (TREE_CODE (rhs) == MULT_EXPR)\n+      if (gimple_assign_rhs_code (before_cast_def_stmt) == MULT_EXPR)\n \t{\n-\t  tree arg0 = TREE_OPERAND (rhs, 0);\n-\t  tree arg1 = TREE_OPERAND (rhs, 1);\n+\t  tree arg0 = gimple_assign_rhs1 (before_cast_def_stmt);\n+\t  tree arg1 = gimple_assign_rhs2 (before_cast_def_stmt);\n \t  tree unit_size = \n \t    TYPE_SIZE_UNIT (TREE_TYPE (TYPE_MAIN_VARIANT (TREE_TYPE (op0))));\n \n \t  if (!(CONSTANT_CLASS_P (arg0) \n-\t      && simple_cst_equal (arg0,unit_size))\n+\t      && simple_cst_equal (arg0, unit_size))\n \t      && !(CONSTANT_CLASS_P (arg1) \n-\t      && simple_cst_equal (arg1,unit_size)))\n+\t      && simple_cst_equal (arg1, unit_size)))\n \t    return false;\t      \t\t   \n \t}\n       else\n@@ -1173,7 +1145,11 @@ check_tree (tree t)\n     check_tree (TREE_OPERAND (t, 0));\n \n   if (SSA_VAR_P (t) || (TREE_CODE (t) == FUNCTION_DECL))\n-    check_operand (t);\n+    {\n+      check_operand (t);\n+      if (DECL_P (t) && DECL_INITIAL (t))\n+\tcheck_tree (DECL_INITIAL (t));\n+    }\n }\n \n /* Create an address_of edge FROM_TYPE.TO_TYPE.  */\n@@ -1260,15 +1236,13 @@ look_for_address_of (tree t)\n }\n \n \n-/* Scan tree T to see if there are any casts within it.\n-   LHS Is the LHS of the expression involving the cast.  */\n+/* Scan tree T to see if there are any casts within it.  */\n \n static unsigned int \n-look_for_casts (tree lhs ATTRIBUTE_UNUSED, tree t)\n+look_for_casts (tree t)\n {\n   unsigned int cast = 0;\n \n-\n   if (is_gimple_cast (t) || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n     {\n       tree castfromvar = TREE_OPERAND (t, 0);\n@@ -1302,7 +1276,7 @@ static void\n check_rhs_var (tree t)\n {\n   look_for_address_of (t);\n-  check_tree(t);\n+  check_tree (t);\n }\n \n /* Check to see if T is an assignment to a static var we are\n@@ -1311,7 +1285,7 @@ check_rhs_var (tree t)\n static void\n check_lhs_var (tree t)\n {\n-  check_tree(t);\n+  check_tree (t);\n }\n \n /* This is a scaled down version of get_asm_expr_operands from\n@@ -1322,35 +1296,15 @@ check_lhs_var (tree t)\n    analyzed and STMT is the actual asm statement.  */\n \n static void\n-get_asm_expr_operands (tree stmt)\n+check_asm (gimple stmt)\n {\n-  int noutputs = list_length (ASM_OUTPUTS (stmt));\n-  const char **oconstraints\n-    = (const char **) alloca ((noutputs) * sizeof (const char *));\n-  int i;\n-  tree link;\n-  const char *constraint;\n-  bool allows_mem, allows_reg, is_inout;\n-  \n-  for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n-    {\n-      oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-      parse_output_constraint (&constraint, i, 0, 0,\n-\t\t\t       &allows_mem, &allows_reg, &is_inout);\n-      \n-      check_lhs_var (TREE_VALUE (link));\n-    }\n+  size_t i;\n \n-  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n-    {\n-      constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-      parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n-\t\t\t      oconstraints, &allows_mem, &allows_reg);\n-      \n-      check_rhs_var (TREE_VALUE (link));\n-    }\n+  for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+    check_lhs_var (gimple_asm_output_op (stmt, i));\n+\n+  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n+    check_rhs_var (gimple_asm_input_op (stmt, i));\n   \n   /* There is no code here to check for asm memory clobbers.  The\n      casual maintainer might think that such code would be necessary,\n@@ -1360,22 +1314,22 @@ get_asm_expr_operands (tree stmt)\n      assumed to already escape.  So, we are protected here.  */\n }\n \n-/* Check the parameters of a function call to CALL_EXPR to mark the\n+\n+/* Check the parameters of function call to CALL to mark the\n    types that pass across the function boundary.  Also check to see if\n    this is either an indirect call, a call outside the compilation\n    unit.  */\n \n static void\n-check_call (tree call_expr) \n+check_call (gimple call)\n {\n-  tree operand;\n-  tree callee_t = get_callee_fndecl (call_expr);\n+  tree callee_t = gimple_call_fndecl (call);\n   struct cgraph_node* callee;\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n-  call_expr_arg_iterator iter;\n+  size_t i;\n \n-  FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n-    check_rhs_var (operand);\n+  for (i = 0; i < gimple_call_num_args (call); i++)\n+    check_rhs_var (gimple_call_arg (call, i));\n   \n   if (callee_t)\n     {\n@@ -1388,12 +1342,11 @@ check_call (tree call_expr)\n \t parameters.  */\n       if (TYPE_ARG_TYPES (TREE_TYPE (callee_t)))\n \t{\n-\t  for (arg_type = TYPE_ARG_TYPES (TREE_TYPE (callee_t)),\n-\t\t operand = first_call_expr_arg (call_expr, &iter);\n+\t  for (arg_type = TYPE_ARG_TYPES (TREE_TYPE (callee_t)), i = 0;\n \t       arg_type && TREE_VALUE (arg_type) != void_type_node;\n-\t       arg_type = TREE_CHAIN (arg_type),\n-\t\t operand = next_call_expr_arg (&iter))\n+\t       arg_type = TREE_CHAIN (arg_type), i++)\n \t    {\n+\t      tree operand = gimple_call_arg (call, i);\n \t      if (operand)\n \t\t{\n \t\t  last_arg_type = TREE_VALUE(arg_type);\n@@ -1411,15 +1364,14 @@ check_call (tree call_expr)\n \t  /* FIXME - According to Geoff Keating, we should never\n \t     have to do this; the front ends should always process\n \t     the arg list from the TYPE_ARG_LIST. */\n-\t  for (arg_type = DECL_ARGUMENTS (callee_t),\n-\t\t operand = first_call_expr_arg (call_expr, &iter);\n+\t  for (arg_type = DECL_ARGUMENTS (callee_t), i = 0;\n \t       arg_type;\n-\t       arg_type = TREE_CHAIN (arg_type),\n-\t\t operand = next_call_expr_arg (&iter))\n+\t       arg_type = TREE_CHAIN (arg_type), i++)\n \t    {\n+\t      tree operand = gimple_call_arg (call, i);\n \t      if (operand)\n \t\t{\n-\t\t  last_arg_type = TREE_TYPE(arg_type);\n+\t\t  last_arg_type = TREE_TYPE (arg_type);\n \t\t  check_cast (last_arg_type, operand);\n \t\t} \n \t      else \n@@ -1433,10 +1385,9 @@ check_call (tree call_expr)\n       /* In the case where we have a var_args function, we need to\n \t check the remaining parameters against the last argument.  */\n       arg_type = last_arg_type;\n-      for (;\n-\t   operand != NULL_TREE;\n-\t   operand = next_call_expr_arg (&iter))\n+      for ( ; i < gimple_call_num_args (call); i++)\n \t{\n+\t  tree operand = gimple_call_arg (call, i);\n \t  if (arg_type)\n \t    check_cast (arg_type, operand);\n \t  else \n@@ -1457,16 +1408,16 @@ check_call (tree call_expr)\n      are any bits available for the callee (such as by declaration or\n      because it is builtin) and process solely on the basis of those\n      bits. */\n-\n   if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n     {\n       /* If this is a direct call to an external function, mark all of\n \t the parameter and return types.  */\n-      FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n+      for (i = 0; i < gimple_call_num_args (call); i++)\n \t{\n+\t  tree operand = gimple_call_arg (call, i);\n \t  tree type = get_canon_type (TREE_TYPE (operand), false, false);\n \t  mark_interesting_type (type, EXPOSED_PARAMETER);\n-    }\n+\t}\n \t  \n       if (callee_t) \n \t{\n@@ -1494,7 +1445,8 @@ okay_pointer_operation (enum tree_code code, tree op0, tree op1)\n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n       {\n-\ttree base, offset, offset_cast_stmt;\n+\ttree base, offset;\n+\tgimple offset_cast_stmt;\n \n \tif (POINTER_TYPE_P (op0type)\n \t    && TREE_CODE (op0) == SSA_NAME \n@@ -1528,150 +1480,124 @@ okay_pointer_operation (enum tree_code code, tree op0, tree op1)\n   return false;\n }\n \n-/* TP is the part of the tree currently under the microscope.\n-   WALK_SUBTREES is part of the walk_tree api but is unused here.\n-   DATA is cgraph_node of the function being walked.  */\n \n-/* FIXME: When this is converted to run over SSA form, this code\n-   should be converted to use the operand scanner.  */\n \n-static tree\n-scan_for_refs (tree *tp, int *walk_subtrees, void *data)\n+/* Helper for scan_for_refs.  Check the operands of an assignment to\n+   mark types that may escape.  */\n+\n+static void\n+check_assign (gimple t)\n {\n-  struct cgraph_node *fn = (struct cgraph_node *) data;\n-  tree t = *tp;\n+  /* First look on the lhs and see what variable is stored to */\n+  check_lhs_var (gimple_assign_lhs (t));\n+\n+  /* For the purposes of figuring out what the cast affects */\n \n-  switch (TREE_CODE (t))  \n+  /* Next check the operands on the rhs to see if they are ok. */\n+  switch (TREE_CODE_CLASS (gimple_assign_rhs_code (t)))\n     {\n-    case VAR_DECL:\n-      if (DECL_INITIAL (t))\n-\twalk_tree (&DECL_INITIAL (t), scan_for_refs, fn, visited_nodes);\n-      *walk_subtrees = 0;\n+    case tcc_binary:\t    \n+      {\n+\ttree op0 = gimple_assign_rhs1 (t);\n+\ttree type0 = get_canon_type (TREE_TYPE (op0), false, false);\n+\ttree op1 = gimple_assign_rhs2 (t);\n+\ttree type1 = get_canon_type (TREE_TYPE (op1), false, false);\n+\n+\t/* If this is pointer arithmetic of any bad sort, then\n+\t    we need to mark the types as bad.  For binary\n+\t    operations, no binary operator we currently support\n+\t    is always \"safe\" in regard to what it would do to\n+\t    pointers for purposes of determining which types\n+\t    escape, except operations of the size of the type.\n+\t    It is possible that min and max under the right set\n+\t    of circumstances and if the moon is in the correct\n+\t    place could be safe, but it is hard to see how this\n+\t    is worth the effort.  */\n+\tif (type0 && POINTER_TYPE_P (type0)\n+\t    && !okay_pointer_operation (gimple_assign_rhs_code (t), op0, op1))\n+\t  mark_interesting_type (type0, FULL_ESCAPE);\n+\n+\tif (type1 && POINTER_TYPE_P (type1)\n+\t    && !okay_pointer_operation (gimple_assign_rhs_code (t), op1, op0))\n+\t  mark_interesting_type (type1, FULL_ESCAPE);\n+\n+\tlook_for_casts (op0);\n+\tlook_for_casts (op1);\n+\tcheck_rhs_var (op0);\n+\tcheck_rhs_var (op1);\n+      }\n       break;\n \n-    case GIMPLE_MODIFY_STMT:\n+    case tcc_unary:\n       {\n-\t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = GIMPLE_STMT_OPERAND (t, 0);\n-\ttree rhs = GIMPLE_STMT_OPERAND (t, 1);\n+\ttree op0 = gimple_assign_rhs1 (t);\n+\ttree type0 = get_canon_type (TREE_TYPE (op0), false, false);\n+\n+\t/* For unary operations, if the operation is NEGATE or ABS on\n+\t   a pointer, this is also considered pointer arithmetic and\n+\t   thus, bad for business.  */\n+\tif (type0\n+\t    && POINTER_TYPE_P (type0)\n+\t    && (TREE_CODE (op0) == NEGATE_EXPR\n+\t      || TREE_CODE (op0) == ABS_EXPR))\n+\t  mark_interesting_type (type0, FULL_ESCAPE);\n+\n+\tcheck_rhs_var (op0);\n+\tlook_for_casts (op0);\n+      }\n+      break;\n \n-\tcheck_lhs_var (lhs);\n- \tcheck_cast (TREE_TYPE (lhs), rhs);\n+    case tcc_reference:\n+      look_for_casts (gimple_assign_rhs1 (t));\n+      check_rhs_var (gimple_assign_rhs1 (t));\n+      break;\n \n-\t/* For the purposes of figuring out what the cast affects */\n+    case tcc_declaration:\n+      check_rhs_var (gimple_assign_rhs1 (t));\n+      break;\n \n-\t/* Next check the operands on the rhs to see if they are ok. */\n-\tswitch (TREE_CODE_CLASS (TREE_CODE (rhs))) \n-\t  {\n-\t  case tcc_binary:\t    \n- \t    {\n- \t      tree op0 = TREE_OPERAND (rhs, 0);\n-\t      tree type0 = get_canon_type (TREE_TYPE (op0), false, false);\n- \t      tree op1 = TREE_OPERAND (rhs, 1);\n-\t      tree type1 = get_canon_type (TREE_TYPE (op1), false, false);\n- \n- \t      /* If this is pointer arithmetic of any bad sort, then\n- \t\t we need to mark the types as bad.  For binary\n- \t\t operations, no binary operator we currently support\n- \t\t is always \"safe\" in regard to what it would do to\n- \t\t pointers for purposes of determining which types\n- \t\t escape, except operations of the size of the type.\n- \t\t It is possible that min and max under the right set\n- \t\t of circumstances and if the moon is in the correct\n- \t\t place could be safe, but it is hard to see how this\n- \t\t is worth the effort.  */\n- \n- \t      if (type0 && POINTER_TYPE_P (type0)\n-\t\t  && !okay_pointer_operation (TREE_CODE (rhs), op0, op1))\n- \t\tmark_interesting_type (type0, FULL_ESCAPE);\n- \t      if (type1 && POINTER_TYPE_P (type1)\n-\t\t  && !okay_pointer_operation (TREE_CODE (rhs), op1, op0))\n- \t\tmark_interesting_type (type1, FULL_ESCAPE);\n- \t      \n-\t      look_for_casts (lhs, op0);\n-\t      look_for_casts (lhs, op1);\n- \t      check_rhs_var (op0);\n- \t      check_rhs_var (op1);\n-\t    }\n-\t    break;\n-\t  case tcc_unary:\n- \t    {\n- \t      tree op0 = TREE_OPERAND (rhs, 0);\n-\t      tree type0 = get_canon_type (TREE_TYPE (op0), false, false);\n-\t      /* For unary operations, if the operation is NEGATE or\n-\t\t ABS on a pointer, this is also considered pointer\n-\t\t arithmetic and thus, bad for business.  */\n- \t      if (type0 && (TREE_CODE (op0) == NEGATE_EXPR\n- \t\t   || TREE_CODE (op0) == ABS_EXPR)\n- \t\t  && POINTER_TYPE_P (type0))\n- \t\t{\n- \t\t  mark_interesting_type (type0, FULL_ESCAPE);\n- \t\t}\n- \t      check_rhs_var (op0);\n-\t      look_for_casts (lhs, op0);\n-\t      look_for_casts (lhs, rhs);\n- \t    }\n+    case tcc_expression:\n+      if (gimple_assign_rhs_code (t) == ADDR_EXPR)\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (t);\n+\t  look_for_casts (TREE_OPERAND (rhs, 0));\n+\t  check_rhs_var (rhs);\n+\t}\n+      break;\n \n-\t    break;\n-\t  case tcc_reference:\n-\t    look_for_casts (lhs, rhs);\n-\t    check_rhs_var (rhs);\n-\t    break;\n-\t  case tcc_declaration:\n-\t    check_rhs_var (rhs);\n-\t    break;\n-\t  case tcc_expression:\n-\t    switch (TREE_CODE (rhs)) \n-\t      {\n-\t      case ADDR_EXPR:\n-\t\tlook_for_casts (lhs, TREE_OPERAND (rhs, 0));\n-\t\tcheck_rhs_var (rhs);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t    break;\n-\t  case tcc_vl_exp:\n-\t    switch (TREE_CODE (rhs))\n-\t      {\n-\t      case CALL_EXPR:\n-\t\t/* If this is a call to malloc, squirrel away the\n-\t\t   result so we do mark the resulting cast as being\n-\t\t   bad.  */\n-\t\tcheck_call (rhs);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-\t*walk_subtrees = 0;\n-      }\n+    default:\n       break;\n+    }\n+}\n+\n \n-    case ADDR_EXPR:\n-      /* This case is here to find addresses on rhs of constructors in\n-\t decl_initial of static variables. */\n-      check_rhs_var (t);\n-      *walk_subtrees = 0;\n+/* Scan statement T for references to types and mark anything\n+   interesting.  */\n+\n+static void\n+scan_for_refs (gimple t)\n+{\n+  switch (gimple_code (t))  \n+    {\n+    case GIMPLE_ASSIGN:\n+      check_assign (t);\n       break;\n \n-    case CALL_EXPR: \n+    case GIMPLE_CALL: \n+      /* If this is a call to malloc, squirrel away the result so we\n+\t do mark the resulting cast as being bad.  */\n       check_call (t);\n-      *walk_subtrees = 0;\n       break;\n       \n-    case ASM_EXPR:\n-      get_asm_expr_operands (t);\n-      *walk_subtrees = 0;\n+    case GIMPLE_ASM:\n+      check_asm (t);\n       break;\n       \n     default:\n       break;\n     }\n-  return NULL;\n+\n+  return;\n }\n \n \n@@ -1721,7 +1647,7 @@ analyze_variable (struct varpool_node *vnode)\n   gcc_assert (TREE_CODE (global) == VAR_DECL);\n \n   if (DECL_INITIAL (global))\n-    walk_tree (&DECL_INITIAL (global), scan_for_refs, NULL, visited_nodes);\n+    check_tree (DECL_INITIAL (global));\n }\n \n /* This is the main routine for finding the reference patterns for\n@@ -1742,10 +1668,9 @@ analyze_function (struct cgraph_node *fn)\n \n     FOR_EACH_BB_FN (this_block, this_cfun)\n       {\n-\tblock_stmt_iterator bsi;\n-\tfor (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  walk_tree (bsi_stmt_ptr (bsi), scan_for_refs, \n-\t\t     fn, visited_nodes);\n+\tgimple_stmt_iterator gsi;\n+\tfor (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  scan_for_refs (gsi_stmt (gsi));\n       }\n   }\n \n@@ -1761,8 +1686,7 @@ analyze_function (struct cgraph_node *fn)\n \t  if (TREE_CODE (var) == VAR_DECL \n \t      && DECL_INITIAL (var)\n \t      && !TREE_STATIC (var))\n-\t    walk_tree (&DECL_INITIAL (var), scan_for_refs, \n-\t\t       fn, visited_nodes);\n+\t    check_tree (DECL_INITIAL (var));\n \t  get_canon_type (TREE_TYPE (var), false, false);\n \t}\n     }\n@@ -2215,4 +2139,3 @@ struct simple_ipa_opt_pass pass_ipa_type_escape =\n   0                                     /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "13c3b725c898f1722829400b9a3d11e374d04355", "filename": "gcc/ipa-type-escape.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-type-escape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-type-escape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -23,11 +23,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n \n bool   ipa_type_escape_type_contained_p (tree type);\n-bool   ipa_type_escape_field_does_not_clobber_p (tree record_type, tree field_type);\n+bool   ipa_type_escape_field_does_not_clobber_p (tree, tree);\n int    ipa_type_escape_star_count_of_interesting_type (tree type); \n int    ipa_type_escape_star_count_of_interesting_or_array_type (tree type);\n bool   is_array_access_through_pointer_and_index (enum tree_code, tree, tree,\n-\t\t\t\t\t\t  tree *, tree *, tree *);\n+\t\t\t\t\t\t  tree *, tree *, gimple *);\n \n \n #endif  /* GCC_IPA_TYPE_ESCAPE_H  */"}, {"sha": "729a84d87102a1a14e6cb95e3d875ee8e44d9e23", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -32,7 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"ipa-reference.h\"\n #include \"c-common.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"cgraph.h\"\n #include \"output.h\"\n #include \"flags.h\""}, {"sha": "a2c3cca3e1238ac526d779e90298714ad8c9d074", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,3 +1,48 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t2008-07-18  Richard Guenther  <rguenther@suse.de>\n+\n+\t* expr.c: Include tree-iterator.h.\n+\t* Make-lang.in (expr.o): Add tree-iterator.h dependency.\n+\n+\t2008-07-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* java-gimplify.c: Include gimple.h instead of tree-gimple.h.\n+\t* expr.c: Same.\n+\n+\t2008-07-14  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* java-gimplify.c (java_gimplify_expr): Same.\n+\t(java_gimplify_modify_expr): Same.\n+\t* java-tree.h: Rename GENERIC_NEXT to TREE_CHAIN.\n+\n+\t2008-05-02  Diego Novillo  <dnovillo@google.com>\n+\n+\t* expr.c (build_java_throw_out_of_bounds_exception): Fix\n+\tmixed declarations and code.\n+\n+\t2008-05-02  Doug Kwan  <dougkwan@google.com>\n+\t\n+\t* expr.c (build_java_throw_out_of_bounds_exception ): Wrap call to\n+\t_Jv_ThrowBadArrayIndex with a COMPOUND_EXPR to return 0.\n+\n+\t2008-02-19  Diego Novillo  <dnovillo@google.com>\n+\n+\thttp://gcc.gnu.org/ml/gcc-patches/2008-02/msg00804.html\n+\n+\t* java-gimplify.c (java_gimplify_self_mod_expr): Change\n+\tgimple_seq arguments to gimple_seq *.  Update all users.\n+\n+\t2007-11-26  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* java-gimplify.c (java_gimplify_expr): Make pre_p and post_p\n+\tsequences.\n+\t(java_gimplify_self_mod_expr): Same.                                    \n+\t* java-tree.h (java_gimplify_expr): Make pre_p and post_p               \n+\tsequences.\n+\n 2008-07-24  Jan Hubicka  <jh@suse.cz>\n \n \t* java/decl.c: Include cgraph.h"}, {"sha": "f188c7d788dd1863f3f057933a8f2a2328dfe181", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -269,7 +269,8 @@ java/except.o: java/except.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h $(REAL_H) \\\n java/expr.o: java/expr.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h $(REAL_H) \\\n   $(RTL_H) $(EXPR_H) java/javaop.h java/java-opcodes.h except.h \\\n   java/java-except.h java/java-except.h java/parse.h toplev.h \\\n-  $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) gt-java-expr.h $(TARGET_H)\n+  $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) gt-java-expr.h $(TARGET_H) \\\n+  tree-iterator.h\n java/jcf-depend.o: java/jcf-depend.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   $(TM_H) java/jcf.h\n java/jcf-parse.o: java/jcf-parse.c $(CONFIG_H) $(JAVA_TREE_H) $(FLAGS_H) \\\n@@ -298,7 +299,7 @@ java/verify-impl.o: java/verify-impl.c $(CONFIG_H) java/verify.h $(SYSTEM_H) \\\n java/zextract.o: java/zextract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   java/zipfile.h\n java/java-gimplify.o: java/java-gimplify.c $(CONFIG_H) $(SYSTEM_H) \\\n-  coretypes.h $(TM_H) $(JAVA_TREE_H) $(TREE_GIMPLE_H) toplev.h\n+  coretypes.h $(TM_H) $(JAVA_TREE_H) $(GIMPLE_H) toplev.h\n \n # jcf-io.o needs $(ZLIBINC) added to cflags.\n java/jcf-io.o: java/jcf-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "ff28bbb0b40984490eed52826a6bab87b4ddfd12", "filename": "gcc/java/expr.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -42,7 +42,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"ggc.h\"\n-#include \"tree-gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple.h\"\n #include \"target.h\"\n \n static void flush_quick_stack (void);\n@@ -814,10 +815,20 @@ encode_newarray_type (tree type)\n static tree\n build_java_throw_out_of_bounds_exception (tree index)\n {\n-  tree node = build_call_nary (int_type_node,\n+  tree node;\n+\n+  /* We need to build a COMPOUND_EXPR because _Jv_ThrowBadArrayIndex()\n+     has void return type.  We cannot just set the type of the CALL_EXPR below\n+     to int_type_node because we would lose it during gimplification.  */\n+  gcc_assert (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (soft_badarrayindex_node))));\n+  node = build_call_nary (void_type_node,\n \t\t\t       build_address_of (soft_badarrayindex_node),\n \t\t\t       1, index);\n+  TREE_SIDE_EFFECTS (node) = 1;\n+\n+  node = build2 (COMPOUND_EXPR, int_type_node, node, integer_zero_node);\n   TREE_SIDE_EFFECTS (node) = 1;\t/* Allows expansion within ANDIF */\n+\n   return (node);\n }\n "}, {"sha": "790cb13c03945d255f1a5035288868512fb79fda", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -28,12 +28,13 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"tree.h\"\n #include \"java-tree.h\"\n #include \"tree-dump.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"toplev.h\"\n \n static tree java_gimplify_block (tree);\n static enum gimplify_status java_gimplify_modify_expr (tree *);\n-static enum gimplify_status java_gimplify_self_mod_expr (tree*, tree*, tree *);\n+static enum gimplify_status java_gimplify_self_mod_expr (tree *, gimple_seq *,\n+\t\t\t\t\t\t\t gimple_seq *);\n \n static void dump_java_tree (enum tree_dump_index, tree);\n \n@@ -53,8 +54,7 @@ java_genericize (tree fndecl)\n /* Gimplify a Java tree.  */\n \n int\n-java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n-\t\t    tree *post_p ATTRIBUTE_UNUSED)\n+java_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   enum tree_code code = TREE_CODE (*expr_p);\n \n@@ -68,9 +68,6 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n       *expr_p = java_replace_reference (*expr_p, /* want_lvalue */ false);\n       return GS_UNHANDLED;\n \n-      /* We don't handle GIMPLE_MODIFY_STMT, as MODIFY_EXPRs with java\n-         semantics should only be generated by the front-end, and never\n-         by anything after gimplification.  */\n     case MODIFY_EXPR:\n       return java_gimplify_modify_expr (expr_p);\n \n@@ -142,7 +139,7 @@ java_gimplify_modify_expr (tree *modify_expr_p)\n     {\n       tree new_lhs = java_replace_reference (lhs, /* want_lvalue */ true);\n       tree new_rhs = build1 (NOP_EXPR, TREE_TYPE (new_lhs), rhs);\n-      modify_expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (new_lhs),\n+      modify_expr = build2 (MODIFY_EXPR, TREE_TYPE (new_lhs),\n \t\t\t    new_lhs, new_rhs);\n       modify_expr = build1 (NOP_EXPR, lhs_type, modify_expr);\n     }\n@@ -160,8 +157,8 @@ java_gimplify_modify_expr (tree *modify_expr_p)\n     between the reading and the writing.  */\n \n static enum gimplify_status\n-java_gimplify_self_mod_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED, \n-\t\t\t     tree *post_p ATTRIBUTE_UNUSED)\n+java_gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED, \n+\t\t\t     gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree lhs = TREE_OPERAND (*expr_p, 0);\n \n@@ -180,7 +177,7 @@ java_gimplify_block (tree java_block)\n {\n   tree decls = BLOCK_VARS (java_block);\n   tree body = BLOCK_EXPR_BODY (java_block);\n-  tree outer = gimple_current_bind_expr ();\n+  gimple outer = gimple_current_bind_expr ();\n   tree block;\n \n   /* Don't bother with empty blocks.  */\n@@ -199,10 +196,10 @@ java_gimplify_block (tree java_block)\n      routines generate info for the variables in that block.  */\n   TREE_USED (block) = 1;\n \n-  if (outer != NULL_TREE)\n+  if (outer != NULL)\n     {\n-      outer = BIND_EXPR_BLOCK (outer);\n-      BLOCK_SUBBLOCKS (outer) = chainon (BLOCK_SUBBLOCKS (outer), block);\n+      tree b = gimple_bind_block (outer);\n+      BLOCK_SUBBLOCKS (b) = chainon (BLOCK_SUBBLOCKS (b), block);\n     }\n   BLOCK_EXPR_BODY (java_block) = NULL_TREE;\n "}, {"sha": "7ae71d9e41ba32491fa94d4114837aaec9cb6d56", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -649,7 +649,7 @@ struct lang_identifier GTY(())\n /* The resulting tree type.  */\n union lang_tree_node \n   GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-       chain_next (\"(union lang_tree_node *)GENERIC_NEXT (&%h.generic)\")))\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n \n {\n   union tree_node GTY ((tag (\"0\"), \n@@ -1555,7 +1555,7 @@ enum\n #undef DEBUG_JAVA_BINDING_LEVELS\n \n extern void java_genericize (tree);\n-extern int java_gimplify_expr (tree *, tree *, tree *);\n+extern int java_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n \n extern FILE *finput;\n "}, {"sha": "21bc1846a73e2594a1787405395b9e60a0093873", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 189, "deletions": 191, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1231,16 +1231,16 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t\t\t VEC(tree,heap) * outerinductionvars,\n \t\t\t VEC(tree,heap) ** lboundvars,\n \t\t\t VEC(tree,heap) ** uboundvars,\n-                         VEC(int,heap) ** steps,\n+\t\t\t VEC(int,heap) ** steps,\n                          struct obstack * lambda_obstack)\n {\n-  tree phi;\n-  tree exit_cond;\n+  gimple phi;\n+  gimple exit_cond;\n   tree access_fn, inductionvar;\n   tree step;\n   lambda_loop lloop = NULL;\n   lambda_linear_expression lbound, ubound;\n-  tree test;\n+  tree test_lhs, test_rhs;\n   int stepint;\n   int extra = 0;\n   tree lboundvar, uboundvar, uboundresult;\n@@ -1257,9 +1257,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n       return NULL;\n     }\n \n-  test = TREE_OPERAND (exit_cond, 0);\n-\n-  if (SSA_NAME_DEF_STMT (inductionvar) == NULL_TREE)\n+  if (SSA_NAME_DEF_STMT (inductionvar) == NULL)\n     {\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1270,10 +1268,10 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n     }\n \n   phi = SSA_NAME_DEF_STMT (inductionvar);\n-  if (TREE_CODE (phi) != PHI_NODE)\n+  if (gimple_code (phi) != GIMPLE_PHI)\n     {\n-      phi = SINGLE_SSA_TREE_OPERAND (phi, SSA_OP_USE);\n-      if (!phi)\n+      tree op = SINGLE_SSA_TREE_OPERAND (phi, SSA_OP_USE);\n+      if (!op)\n \t{\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1283,16 +1281,14 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t  return NULL;\n \t}\n \n-      phi = SSA_NAME_DEF_STMT (phi);\n-      if (TREE_CODE (phi) != PHI_NODE)\n+      phi = SSA_NAME_DEF_STMT (op);\n+      if (gimple_code (phi) != GIMPLE_PHI)\n \t{\n-\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n \t\t     \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n \t  return NULL;\n \t}\n-\n     }\n \n   /* The induction variable name/version we want to put in the array is the\n@@ -1331,7 +1327,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \n   /* Only want phis for induction vars, which will have two\n      arguments.  */\n-  if (PHI_NUM_ARGS (phi) != 2)\n+  if (gimple_phi_num_args (phi) != 2)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -1341,8 +1337,8 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \n   /* Another induction variable check. One argument's source should be\n      in the loop, one outside the loop.  */\n-  if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 0)->src)\n-      && flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 1)->src))\n+  if (flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, 0)->src)\n+      && flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, 1)->src))\n     {\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1352,7 +1348,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n       return NULL;\n     }\n \n-  if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 0)->src))\n+  if (flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, 0)->src))\n     {\n       lboundvar = PHI_ARG_DEF (phi, 1);\n       lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n@@ -1378,21 +1374,23 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n     }\n   /* One part of the test may be a loop invariant tree.  */\n   VEC_reserve (tree, heap, *invariants, 1);\n-  if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME\n-      && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 1)))\n-    VEC_quick_push (tree, *invariants, TREE_OPERAND (test, 1));\n-  else if (TREE_CODE (TREE_OPERAND (test, 0)) == SSA_NAME\n-\t   && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 0)))\n-    VEC_quick_push (tree, *invariants, TREE_OPERAND (test, 0));\n+  test_lhs = gimple_cond_lhs (exit_cond);\n+  test_rhs = gimple_cond_rhs (exit_cond);\n+\n+  if (TREE_CODE (test_rhs) == SSA_NAME\n+      && invariant_in_loop_and_outer_loops (loop, test_rhs))\n+    VEC_quick_push (tree, *invariants, test_rhs);\n+  else if (TREE_CODE (test_lhs) == SSA_NAME\n+\t   && invariant_in_loop_and_outer_loops (loop, test_lhs))\n+    VEC_quick_push (tree, *invariants, test_lhs);\n   \n   /* The non-induction variable part of the test is the upper bound variable.\n    */\n-  if (TREE_OPERAND (test, 0) == inductionvar)\n-    uboundvar = TREE_OPERAND (test, 1);\n+  if (test_lhs == inductionvar)\n+    uboundvar = test_rhs;\n   else\n-    uboundvar = TREE_OPERAND (test, 0);\n+    uboundvar = test_lhs;\n     \n-\n   /* We only size the vectors assuming we have, at max, 2 times as many\n      invariants as we do loops (one for each bound).\n      This is just an arbitrary number, but it has to be matched against the\n@@ -1401,13 +1399,13 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   \n \n   /* We might have some leftover.  */\n-  if (TREE_CODE (test) == LT_EXPR)\n+  if (gimple_cond_code (exit_cond) == LT_EXPR)\n     extra = -1 * stepint;\n-  else if (TREE_CODE (test) == NE_EXPR)\n+  else if (gimple_cond_code (exit_cond) == NE_EXPR)\n     extra = -1 * stepint;\n-  else if (TREE_CODE (test) == GT_EXPR)\n+  else if (gimple_cond_code (exit_cond) == GT_EXPR)\n     extra = -1 * stepint;\n-  else if (TREE_CODE (test) == EQ_EXPR)\n+  else if (gimple_cond_code (exit_cond) == EQ_EXPR)\n     extra = 1 * stepint;\n   \n   ubound = gcc_tree_to_linear_expression (depth, uboundvar,\n@@ -1439,24 +1437,23 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n static tree\n find_induction_var_from_exit_cond (struct loop *loop)\n {\n-  tree expr = get_loop_exit_condition (loop);\n+  gimple expr = get_loop_exit_condition (loop);\n   tree ivarop;\n-  tree test;\n-  if (expr == NULL_TREE)\n-    return NULL_TREE;\n-  if (TREE_CODE (expr) != COND_EXPR)\n+  tree test_lhs, test_rhs;\n+  if (expr == NULL)\n     return NULL_TREE;\n-  test = TREE_OPERAND (expr, 0);\n-  if (!COMPARISON_CLASS_P (test))\n+  if (gimple_code (expr) != GIMPLE_COND)\n     return NULL_TREE;\n+  test_lhs = gimple_cond_lhs (expr);\n+  test_rhs = gimple_cond_rhs (expr);\n \n   /* Find the side that is invariant in this loop. The ivar must be the other\n      side.  */\n   \n-  if (expr_invariant_in_loop_p (loop, TREE_OPERAND (test, 0)))\n-      ivarop = TREE_OPERAND (test, 1);\n-  else if (expr_invariant_in_loop_p (loop, TREE_OPERAND (test, 1)))\n-      ivarop = TREE_OPERAND (test, 0);\n+  if (expr_invariant_in_loop_p (loop, test_lhs))\n+      ivarop = test_rhs;\n+  else if (expr_invariant_in_loop_p (loop, test_rhs))\n+      ivarop = test_lhs;\n   else\n     return NULL_TREE;\n \n@@ -1548,7 +1545,7 @@ gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n static tree\n lbv_to_gcc_expression (lambda_body_vector lbv, \n \t\t       tree type, VEC(tree,heap) *induction_vars, \n-\t\t       tree *stmts_to_insert)\n+\t\t       gimple_seq *stmts_to_insert)\n {\n   int k;\n   tree resvar;\n@@ -1583,7 +1580,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t       tree type,\n \t\t       VEC(tree,heap) *induction_vars,\n \t\t       VEC(tree,heap) *invariants,\n-\t\t       enum tree_code wrap, tree *stmts_to_insert)\n+\t\t       enum tree_code wrap, gimple_seq *stmts_to_insert)\n {\n   int k;\n   tree resvar;\n@@ -1641,17 +1638,19 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n /* Remove the induction variable defined at IV_STMT.  */\n \n void\n-remove_iv (tree iv_stmt)\n+remove_iv (gimple iv_stmt)\n {\n-  if (TREE_CODE (iv_stmt) == PHI_NODE)\n+  gimple_stmt_iterator si = gsi_for_stmt (iv_stmt);\n+\n+  if (gimple_code (iv_stmt) == GIMPLE_PHI)\n     {\n-      int i;\n+      unsigned i;\n \n-      for (i = 0; i < PHI_NUM_ARGS (iv_stmt); i++)\n+      for (i = 0; i < gimple_phi_num_args (iv_stmt); i++)\n \t{\n-\t  tree stmt;\n+\t  gimple stmt;\n \t  imm_use_iterator imm_iter;\n-\t  tree arg = PHI_ARG_DEF (iv_stmt, i);\n+\t  tree arg = gimple_phi_arg_def (iv_stmt, i);\n \t  bool used = false;\n \n \t  if (TREE_CODE (arg) != SSA_NAME)\n@@ -1665,13 +1664,11 @@ remove_iv (tree iv_stmt)\n \t    remove_iv (SSA_NAME_DEF_STMT (arg));\n \t}\n \n-      remove_phi_node (iv_stmt, NULL_TREE, true);\n+      remove_phi_node (&si, true);\n     }\n   else\n     {\n-      block_stmt_iterator bsi = bsi_for_stmt (iv_stmt);\n-\n-      bsi_remove (&bsi, true);\n+      gsi_remove (&si, true);\n       release_defs (iv_stmt); \n     }\n }\n@@ -1692,18 +1689,18 @@ void\n lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t\t\t VEC(tree,heap) *old_ivs,\n \t\t\t\t VEC(tree,heap) *invariants,\n-\t\t\t\t VEC(tree,heap) **remove_ivs,\n+\t\t\t\t VEC(gimple,heap) **remove_ivs,\n \t\t\t\t lambda_loopnest new_loopnest,\n                                  lambda_trans_matrix transform,\n                                  struct obstack * lambda_obstack)\n {\n   struct loop *temp;\n   size_t i = 0;\n-  int j;\n+  unsigned j;\n   size_t depth = 0;\n   VEC(tree,heap) *new_ivs = NULL;\n   tree oldiv;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator bsi;\n \n   transform = lambda_trans_matrix_inverse (transform);\n \n@@ -1720,13 +1717,15 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       lambda_loop newloop;\n       basic_block bb;\n       edge exit;\n-      tree ivvar, ivvarinced, exitcond, stmts;\n+      tree ivvar, ivvarinced;\n+      gimple exitcond;\n+      gimple_seq stmts;\n       enum tree_code testtype;\n       tree newupperbound, newlowerbound;\n       lambda_linear_expression offset;\n       tree type;\n       bool insert_after;\n-      tree inc_stmt;\n+      gimple inc_stmt;\n \n       oldiv = VEC_index (tree, old_ivs, i);\n       type = TREE_TYPE (oldiv);\n@@ -1749,6 +1748,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t    \n       /* Now build the  new lower bounds, and insert the statements\n          necessary to generate it on the loop preheader.  */\n+      stmts = NULL;\n       newlowerbound = lle_to_gcc_expression (LL_LOWER_BOUND (newloop),\n \t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n \t\t\t\t\t     type,\n@@ -1757,22 +1757,23 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \n       if (stmts)\n \t{\n-\t  bsi_insert_on_edge (loop_preheader_edge (temp), stmts);\n-\t  bsi_commit_edge_inserts ();\n+\t  gsi_insert_seq_on_edge (loop_preheader_edge (temp), stmts);\n+\t  gsi_commit_edge_inserts ();\n \t}\n       /* Build the new upper bound and insert its statements in the\n          basic block of the exit condition */\n+      stmts = NULL;\n       newupperbound = lle_to_gcc_expression (LL_UPPER_BOUND (newloop),\n \t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n \t\t\t\t\t     type,\n \t\t\t\t\t     new_ivs,\n \t\t\t\t\t     invariants, MIN_EXPR, &stmts);\n       exit = single_exit (temp);\n       exitcond = get_loop_exit_condition (temp);\n-      bb = bb_for_stmt (exitcond);\n-      bsi = bsi_after_labels (bb);\n+      bb = gimple_bb (exitcond);\n+      bsi = gsi_after_labels (bb);\n       if (stmts)\n-\tbsi_insert_before (&bsi, stmts, BSI_NEW_STMT);\n+\tgsi_insert_seq_before (&bsi, stmts, GSI_NEW_STMT);\n \n       /* Create the new iv.  */\n \n@@ -1786,13 +1787,14 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t dominate the block containing the exit condition.\n \t So we simply create our own incremented iv to use in the new exit\n \t test,  and let redundancy elimination sort it out.  */\n-      inc_stmt = build2 (PLUS_EXPR, type, \n-\t\t\t ivvar, build_int_cst (type, LL_STEP (newloop)));\n-      inc_stmt = build_gimple_modify_stmt (SSA_NAME_VAR (ivvar), inc_stmt);\n+      inc_stmt = gimple_build_assign_with_ops (PLUS_EXPR, SSA_NAME_VAR (ivvar),\n+\t\t\t\t\t       ivvar,\n+\t\t\t\t\t       build_int_cst (type, LL_STEP (newloop)));\n+\n       ivvarinced = make_ssa_name (SSA_NAME_VAR (ivvar), inc_stmt);\n-      GIMPLE_STMT_OPERAND (inc_stmt, 0) = ivvarinced;\n-      bsi = bsi_for_stmt (exitcond);\n-      bsi_insert_before (&bsi, inc_stmt, BSI_SAME_STMT);\n+      gimple_assign_set_lhs (inc_stmt, ivvarinced);\n+      bsi = gsi_for_stmt (exitcond);\n+      gsi_insert_before (&bsi, inc_stmt, GSI_SAME_STMT);\n \n       /* Replace the exit condition with the new upper bound\n          comparison.  */\n@@ -1806,9 +1808,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       if (exit->flags & EDGE_FALSE_VALUE)\n \ttesttype = swap_tree_comparison (testtype);\n \n-      COND_EXPR_COND (exitcond) = build2 (testtype,\n-\t\t\t\t\t  boolean_type_node,\n-\t\t\t\t\t  newupperbound, ivvarinced);\n+      gimple_cond_set_condition (exitcond, testtype, newupperbound, ivvarinced);\n       update_stmt (exitcond);\n       VEC_replace (tree, new_ivs, i, ivvar);\n \n@@ -1824,18 +1824,19 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n       tree oldiv_def;\n-      tree oldiv_stmt = SSA_NAME_DEF_STMT (oldiv);\n-      tree stmt;\n+      gimple oldiv_stmt = SSA_NAME_DEF_STMT (oldiv);\n+      gimple stmt;\n \n-      if (TREE_CODE (oldiv_stmt) == PHI_NODE)\n+      if (gimple_code (oldiv_stmt) == GIMPLE_PHI)\n         oldiv_def = PHI_RESULT (oldiv_stmt);\n       else\n \toldiv_def = SINGLE_SSA_TREE_OPERAND (oldiv_stmt, SSA_OP_DEF);\n       gcc_assert (oldiv_def != NULL_TREE);\n \n       FOR_EACH_IMM_USE_STMT (stmt, imm_iter, oldiv_def)\n         {\n-\t  tree newiv, stmts;\n+\t  tree newiv;\n+\t  gimple_seq stmts;\n \t  lambda_body_vector lbv, newlbv;\n \n \t  /* Compute the new expression for the induction\n@@ -1847,28 +1848,29 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n           newlbv = lambda_body_vector_compute_new (transform, lbv,\n                                                    lambda_obstack);\n \n+\t  stmts = NULL;\n \t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n \t\t\t\t\t new_ivs, &stmts);\n \n-\t  if (stmts && TREE_CODE (stmt) != PHI_NODE)\n+\t  if (stmts && gimple_code (stmt) != GIMPLE_PHI)\n \t    {\n-\t      bsi = bsi_for_stmt (stmt);\n-\t      bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t      bsi = gsi_for_stmt (stmt);\n+\t      gsi_insert_seq_before (&bsi, stmts, GSI_SAME_STMT);\n \t    }\n \n \t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t    propagate_value (use_p, newiv);\n \n-\t  if (stmts && TREE_CODE (stmt) == PHI_NODE)\n-\t    for (j = 0; j < PHI_NUM_ARGS (stmt); j++)\n-\t      if (PHI_ARG_DEF (stmt, j) == newiv)\n-\t\tbsi_insert_on_edge (PHI_ARG_EDGE (stmt, j), stmts);\n+\t  if (stmts && gimple_code (stmt) == GIMPLE_PHI)\n+\t    for (j = 0; j < gimple_phi_num_args (stmt); j++)\n+\t      if (gimple_phi_arg_def (stmt, j) == newiv)\n+\t\tgsi_insert_seq_on_edge (gimple_phi_arg_edge (stmt, j), stmts);\n \n \t  update_stmt (stmt);\n \t}\n \n       /* Remove the now unused induction variable.  */\n-      VEC_safe_push (tree, heap, *remove_ivs, oldiv_stmt);\n+      VEC_safe_push (gimple, heap, *remove_ivs, oldiv_stmt);\n     }\n   VEC_free (tree, heap, new_ivs);\n }\n@@ -1877,25 +1879,25 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n    determining if we have a perfect loop nest.  */\n \n static bool\n-not_interesting_stmt (tree stmt)\n+not_interesting_stmt (gimple stmt)\n {\n   /* Note that COND_EXPR's aren't interesting because if they were exiting the\n      loop, we would have already failed the number of exits tests.  */\n-  if (TREE_CODE (stmt) == LABEL_EXPR\n-      || TREE_CODE (stmt) == GOTO_EXPR\n-      || TREE_CODE (stmt) == COND_EXPR)\n+  if (gimple_code (stmt) == GIMPLE_LABEL\n+      || gimple_code (stmt) == GIMPLE_GOTO\n+      || gimple_code (stmt) == GIMPLE_COND)\n     return true;\n   return false;\n }\n \n /* Return TRUE if PHI uses DEF for it's in-the-loop edge for LOOP.  */\n \n static bool\n-phi_loop_edge_uses_def (struct loop *loop, tree phi, tree def)\n+phi_loop_edge_uses_def (struct loop *loop, gimple phi, tree def)\n {\n-  int i;\n-  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-    if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, i)->src))\n+  unsigned i;\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    if (flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, i)->src))\n       if (PHI_ARG_DEF (phi, i) == def)\n \treturn true;\n   return false;\n@@ -1904,7 +1906,7 @@ phi_loop_edge_uses_def (struct loop *loop, tree phi, tree def)\n /* Return TRUE if STMT is a use of PHI_RESULT.  */\n \n static bool\n-stmt_uses_phi_result (tree stmt, tree phi_result)\n+stmt_uses_phi_result (gimple stmt, tree phi_result)\n {\n   tree use = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_USE);\n   \n@@ -1920,9 +1922,9 @@ stmt_uses_phi_result (tree stmt, tree phi_result)\n         i_3 = PHI (0, i_29);  */\n \n static bool\n-stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n+stmt_is_bumper_for_loop (struct loop *loop, gimple stmt)\n {\n-  tree use;\n+  gimple use;\n   tree def;\n   imm_use_iterator iter;\n   use_operand_p use_p;\n@@ -1934,7 +1936,7 @@ stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n   FOR_EACH_IMM_USE_FAST (use_p, iter, def)\n     {\n       use = USE_STMT (use_p);\n-      if (TREE_CODE (use) == PHI_NODE)\n+      if (gimple_code (use) == GIMPLE_PHI)\n \t{\n \t  if (phi_loop_edge_uses_def (loop, use, def))\n \t    if (stmt_uses_phi_result (stmt, PHI_RESULT (use)))\n@@ -1976,7 +1978,7 @@ perfect_nest_p (struct loop *loop)\n {\n   basic_block *bbs;\n   size_t i;\n-  tree exit_cond;\n+  gimple exit_cond;\n \n   /* Loops at depth 0 are perfect nests.  */\n   if (!loop->inner)\n@@ -1989,13 +1991,13 @@ perfect_nest_p (struct loop *loop)\n     {\n       if (bbs[i]->loop_father == loop)\n \t{\n-\t  block_stmt_iterator bsi;\n+\t  gimple_stmt_iterator bsi;\n \n-\t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  for (bsi = gsi_start_bb (bbs[i]); !gsi_end_p (bsi); gsi_next (&bsi))\n \t    {\n-\t      tree stmt = bsi_stmt (bsi);\n+\t      gimple stmt = gsi_stmt (bsi);\n \n-\t      if (TREE_CODE (stmt) == COND_EXPR\n+\t      if (gimple_code (stmt) == GIMPLE_COND\n \t\t  && exit_cond != stmt)\n \t\tgoto non_perfectly_nested;\n \n@@ -2023,10 +2025,10 @@ perfect_nest_p (struct loop *loop)\n    of body basic block.  */\n \n static void\n-replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x, \n+replace_uses_equiv_to_x_with_y (struct loop *loop, gimple stmt, tree x, \n \t\t\t\tint xstep, tree y, tree yinit,\n \t\t\t\thtab_t replacements,\n-\t\t\t\tblock_stmt_iterator *firstbsi)\n+\t\t\t\tgimple_stmt_iterator *firstbsi)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n@@ -2035,7 +2037,8 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n     {\n       tree use = USE_FROM_PTR (use_p);\n       tree step = NULL_TREE;\n-      tree scev, init, val, var, setstmt;\n+      tree scev, init, val, var;\n+      gimple setstmt;\n       struct tree_map *h, in;\n       void **loc;\n \n@@ -2098,12 +2101,12 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n \t which sets Y.  */\n       var = create_tmp_var (TREE_TYPE (use), \"perfecttmp\");\n       add_referenced_var (var);\n-      val = force_gimple_operand_bsi (firstbsi, val, false, NULL,\n-\t\t\t\t      true, BSI_SAME_STMT);\n-      setstmt = build_gimple_modify_stmt (var, val);\n+      val = force_gimple_operand_gsi (firstbsi, val, false, NULL,\n+\t\t\t\t      true, GSI_SAME_STMT);\n+      setstmt = gimple_build_assign (var, val);\n       var = make_ssa_name (var, setstmt);\n-      GIMPLE_STMT_OPERAND (setstmt, 0) = var;\n-      bsi_insert_before (firstbsi, setstmt, BSI_SAME_STMT);\n+      gimple_assign_set_lhs (setstmt, var);\n+      gsi_insert_before (firstbsi, setstmt, GSI_SAME_STMT);\n       update_stmt (setstmt);\n       SET_USE (use_p, var);\n       h = GGC_NEW (struct tree_map);\n@@ -2119,12 +2122,11 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n /* Return true if STMT is an exit PHI for LOOP */\n \n static bool\n-exit_phi_for_loop_p (struct loop *loop, tree stmt)\n+exit_phi_for_loop_p (struct loop *loop, gimple stmt)\n {\n-  \n-  if (TREE_CODE (stmt) != PHI_NODE\n-      || PHI_NUM_ARGS (stmt) != 1\n-      || bb_for_stmt (stmt) != single_exit (loop)->dest)\n+  if (gimple_code (stmt) != GIMPLE_PHI\n+      || gimple_phi_num_args (stmt) != 1\n+      || gimple_bb (stmt) != single_exit (loop)->dest)\n     return false;\n   \n   return true;\n@@ -2134,21 +2136,21 @@ exit_phi_for_loop_p (struct loop *loop, tree stmt)\n    copying it to the beginning of that loop and changing the uses.  */\n \n static bool\n-can_put_in_inner_loop (struct loop *inner, tree stmt)\n+can_put_in_inner_loop (struct loop *inner, gimple stmt)\n {\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   \n-  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n+  gcc_assert (is_gimple_assign (stmt));\n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS)\n-      || !expr_invariant_in_loop_p (inner, GIMPLE_STMT_OPERAND (stmt, 1)))\n+      || !stmt_invariant_in_loop_p (inner, stmt))\n     return false;\n   \n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, GIMPLE_STMT_OPERAND (stmt, 0))\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_assign_lhs (stmt))\n     {\n       if (!exit_phi_for_loop_p (inner, USE_STMT (use_p)))\n \t{\n-\t  basic_block immbb = bb_for_stmt (USE_STMT (use_p));\n+\t  basic_block immbb = gimple_bb (USE_STMT (use_p));\n \n \t  if (!flow_bb_inside_loop_p (inner, immbb))\n \t    return false;\n@@ -2158,20 +2160,21 @@ can_put_in_inner_loop (struct loop *inner, tree stmt)\n }\n \n /* Return true if STMT can be put *after* the inner loop of LOOP.  */\n+\n static bool\n-can_put_after_inner_loop (struct loop *loop, tree stmt)\n+can_put_after_inner_loop (struct loop *loop, gimple stmt)\n {\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n \n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return false;\n   \n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, GIMPLE_STMT_OPERAND (stmt, 0))\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_assign_lhs (stmt))\n     {\n       if (!exit_phi_for_loop_p (loop, USE_STMT (use_p)))\n \t{\n-\t  basic_block immbb = bb_for_stmt (USE_STMT (use_p));\n+\t  basic_block immbb = gimple_bb (USE_STMT (use_p));\n \t  \n \t  if (!dominated_by_p (CDI_DOMINATORS,\n \t\t\t       immbb,\n@@ -2211,81 +2214,77 @@ can_duplicate_iv (tree iv, struct loop *loop)\n    it has better cache behavior.  */\n \n static bool\n-cannot_convert_modify_to_perfect_nest (tree stmt, struct loop *loop)\n+cannot_convert_modify_to_perfect_nest (gimple stmt, struct loop *loop)\n {\n-  \n   use_operand_p use_a, use_b;\n   imm_use_iterator imm_iter;\n   ssa_op_iter op_iter, op_iter1;\n-  tree op0 = GIMPLE_STMT_OPERAND (stmt, 0);\n+  tree op0 = gimple_assign_lhs (stmt);\n \n   /* The statement should not define a variable used in the inner\n      loop.  */\n   if (TREE_CODE (op0) == SSA_NAME\n       && !can_duplicate_iv (op0, loop))\n     FOR_EACH_IMM_USE_FAST (use_a, imm_iter, op0)\n-      if (bb_for_stmt (USE_STMT (use_a))->loop_father\n-\t  == loop->inner)\n+      if (gimple_bb (USE_STMT (use_a))->loop_father == loop->inner)\n \treturn true;\n \n   FOR_EACH_SSA_USE_OPERAND (use_a, stmt, op_iter, SSA_OP_USE)\n     {\n-      tree node, op = USE_FROM_PTR (use_a);\n+      gimple node;\n+      tree op = USE_FROM_PTR (use_a);\n \n       /* The variables should not be used in both loops.  */\n       if (!can_duplicate_iv (op, loop))\n \tFOR_EACH_IMM_USE_FAST (use_b, imm_iter, op)\n-\t  if (bb_for_stmt (USE_STMT (use_b))->loop_father\n-\t      == loop->inner)\n+\t  if (gimple_bb (USE_STMT (use_b))->loop_father == loop->inner)\n \t    return true;\n \n       /* The statement should not use the value of a scalar that was\n \t modified in the loop.  */\n       node = SSA_NAME_DEF_STMT (op);\n-      if (TREE_CODE (node) == PHI_NODE)\n+      if (gimple_code (node) == GIMPLE_PHI)\n \tFOR_EACH_PHI_ARG (use_b, node, op_iter1, SSA_OP_USE)\n-\t{\n-\t  tree arg = USE_FROM_PTR (use_b);\n+\t  {\n+\t    tree arg = USE_FROM_PTR (use_b);\n \n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      tree arg_stmt = SSA_NAME_DEF_STMT (arg);\n+\t    if (TREE_CODE (arg) == SSA_NAME)\n+\t      {\n+\t\tgimple arg_stmt = SSA_NAME_DEF_STMT (arg);\n \n-\t      if (bb_for_stmt (arg_stmt)\n-\t\t  && (bb_for_stmt (arg_stmt)->loop_father\n-\t\t      == loop->inner))\n-\t\treturn true;\n-\t    }\n-\t}\n+\t\tif (gimple_bb (arg_stmt)\n+\t\t    && (gimple_bb (arg_stmt)->loop_father == loop->inner))\n+\t\t  return true;\n+\t      }\n+\t  }\n     }\n \n   return false;\n }\n-\n /* Return true when BB contains statements that can harm the transform\n    to a perfect loop nest.  */\n \n static bool\n cannot_convert_bb_to_perfect_nest (basic_block bb, struct loop *loop)\n {\n-  block_stmt_iterator bsi;\n-  tree exit_condition = get_loop_exit_condition (loop);\n+  gimple_stmt_iterator bsi;\n+  gimple exit_condition = get_loop_exit_condition (loop);\n \n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     { \n-      tree stmt = bsi_stmt (bsi);\n+      gimple stmt = gsi_stmt (bsi);\n \n       if (stmt == exit_condition\n \t  || not_interesting_stmt (stmt)\n \t  || stmt_is_bumper_for_loop (loop, stmt))\n \tcontinue;\n \n-      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+      if (is_gimple_assign (stmt))\n \t{\n \t  if (cannot_convert_modify_to_perfect_nest (stmt, loop))\n \t    return true;\n \n-\t  if (can_duplicate_iv (GIMPLE_STMT_OPERAND (stmt, 0), loop))\n+\t  if (can_duplicate_iv (gimple_assign_lhs (stmt), loop))\n \t    continue;\n \n \t  if (can_put_in_inner_loop (loop->inner, stmt)\n@@ -2298,14 +2297,15 @@ cannot_convert_bb_to_perfect_nest (basic_block bb, struct loop *loop)\n \t right now.  This test ensures that the statement comes\n \t completely *after* the inner loop.  */\n       if (!dominated_by_p (CDI_DOMINATORS,\n-\t\t\t   bb_for_stmt (stmt), \n+\t\t\t   gimple_bb (stmt), \n \t\t\t   loop->inner->header))\n \treturn true;\n     }\n \n   return false;\n }\n \n+\n /* Return TRUE if LOOP is an imperfect nest that we can convert to a\n    perfect one.  At the moment, we only handle imperfect nests of\n    depth 2, where all of the statements occur after the inner loop.  */\n@@ -2314,8 +2314,8 @@ static bool\n can_convert_to_perfect_nest (struct loop *loop)\n {\n   basic_block *bbs;\n-  tree phi;\n   size_t i;\n+  gimple_stmt_iterator si;\n \n   /* Can't handle triply nested+ loops yet.  */\n   if (!loop->inner || loop->inner->inner)\n@@ -2329,8 +2329,10 @@ can_convert_to_perfect_nest (struct loop *loop)\n \n   /* We also need to make sure the loop exit only has simple copy phis in it,\n      otherwise we don't know how to transform it into a perfect nest.  */\n-  for (phi = phi_nodes (single_exit (loop)->dest); phi; phi = PHI_CHAIN (phi))\n-    if (PHI_NUM_ARGS (phi) != 1)\n+  for (si = gsi_start_phis (single_exit (loop)->dest);\n+       !gsi_end_p (si);\n+       gsi_next (&si))\n+    if (gimple_phi_num_args (gsi_stmt (si)) != 1)\n       goto fail;\n   \n   free (bbs);\n@@ -2385,17 +2387,17 @@ perfect_nestify (struct loop *loop,\n \t\t VEC(tree,heap) *loopivs)\n {\n   basic_block *bbs;\n-  tree exit_condition;\n-  tree cond_stmt;\n+  gimple exit_condition;\n+  gimple cond_stmt;\n   basic_block preheaderbb, headerbb, bodybb, latchbb, olddest;\n   int i;\n-  block_stmt_iterator bsi, firstbsi;\n+  gimple_stmt_iterator bsi, firstbsi;\n   bool insert_after;\n   edge e;\n   struct loop *newloop;\n-  tree phi;\n+  gimple phi;\n   tree uboundvar;\n-  tree stmt;\n+  gimple stmt;\n   tree oldivvar, ivvar, ivvarinced;\n   VEC(tree,heap) *phis = NULL;\n   htab_t replacements = NULL;\n@@ -2406,17 +2408,18 @@ perfect_nestify (struct loop *loop,\n   headerbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   \n   /* Push the exit phi nodes that we are moving.  */\n-  for (phi = phi_nodes (olddest); phi; phi = PHI_CHAIN (phi))\n+  for (bsi = gsi_start_phis (olddest); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n+      phi = gsi_stmt (bsi);\n       VEC_reserve (tree, heap, phis, 2);\n       VEC_quick_push (tree, phis, PHI_RESULT (phi));\n       VEC_quick_push (tree, phis, PHI_ARG_DEF (phi, 0));\n     }\n   e = redirect_edge_and_branch (single_succ_edge (preheaderbb), headerbb);\n \n   /* Remove the exit phis from the old basic block.  */\n-  while (phi_nodes (olddest) != NULL)\n-    remove_phi_node (phi_nodes (olddest), NULL, false);\n+  for (bsi = gsi_start_phis (olddest); !gsi_end_p (bsi); )\n+    remove_phi_node (&bsi, false);\n \n   /* and add them back to the new basic block.  */\n   while (VEC_length (tree, phis) != 0)\n@@ -2434,13 +2437,10 @@ perfect_nestify (struct loop *loop,\n   bodybb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   latchbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   make_edge (headerbb, bodybb, EDGE_FALLTHRU); \n-  cond_stmt = build3 (COND_EXPR, void_type_node,\n-\t\t      build2 (NE_EXPR, boolean_type_node, \n-\t\t\t      integer_one_node, \n-\t\t\t      integer_zero_node), \n-\t\t      NULL_TREE, NULL_TREE);\n-  bsi = bsi_start (bodybb);\n-  bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n+  cond_stmt = gimple_build_cond (NE_EXPR, integer_one_node, integer_zero_node,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+  bsi = gsi_start_bb (bodybb);\n+  gsi_insert_after (&bsi, cond_stmt, GSI_NEW_STMT);\n   e = make_edge (bodybb, olddest, EDGE_FALSE_VALUE);\n   make_edge (bodybb, latchbb, EDGE_TRUE_VALUE);\n   make_edge (latchbb, headerbb, EDGE_FALLTHRU);\n@@ -2474,30 +2474,27 @@ perfect_nestify (struct loop *loop,\n   exit_condition = get_loop_exit_condition (newloop);\n   uboundvar = create_tmp_var (integer_type_node, \"uboundvar\");\n   add_referenced_var (uboundvar);\n-  stmt = build_gimple_modify_stmt (uboundvar, VEC_index (tree, ubounds, 0));\n+  stmt = gimple_build_assign (uboundvar, VEC_index (tree, ubounds, 0));\n   uboundvar = make_ssa_name (uboundvar, stmt);\n-  GIMPLE_STMT_OPERAND (stmt, 0) = uboundvar;\n+  gimple_assign_set_lhs (stmt, uboundvar);\n \n   if (insert_after)\n-    bsi_insert_after (&bsi, stmt, BSI_SAME_STMT);\n+    gsi_insert_after (&bsi, stmt, GSI_SAME_STMT);\n   else\n-    bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n+    gsi_insert_before (&bsi, stmt, GSI_SAME_STMT);\n   update_stmt (stmt);\n-  COND_EXPR_COND (exit_condition) = build2 (GE_EXPR, \n-\t\t\t\t\t    boolean_type_node,\n-\t\t\t\t\t    uboundvar,\n-\t\t\t\t\t    ivvarinced);\n+  gimple_cond_set_condition (exit_condition, GE_EXPR, uboundvar, ivvarinced);\n   update_stmt (exit_condition);\n   replacements = htab_create_ggc (20, tree_map_hash,\n \t\t\t\t  tree_map_eq, NULL);\n   bbs = get_loop_body_in_dom_order (loop); \n   /* Now move the statements, and replace the induction variable in the moved\n      statements with the correct loop induction variable.  */\n   oldivvar = VEC_index (tree, loopivs, 0);\n-  firstbsi = bsi_start (bodybb);\n+  firstbsi = gsi_start_bb (bodybb);\n   for (i = loop->num_nodes - 1; i >= 0 ; i--)\n     {\n-      block_stmt_iterator tobsi = bsi_last (bodybb);\n+      gimple_stmt_iterator tobsi = gsi_last_bb (bodybb);\n       if (bbs[i]->loop_father == loop)\n \t{\n \t  /* If this is true, we are *before* the inner loop.\n@@ -2513,47 +2510,48 @@ perfect_nestify (struct loop *loop,\n \n \t  if (dominated_by_p (CDI_DOMINATORS, loop->inner->header, bbs[i]))\n \t    {\n-\t      block_stmt_iterator header_bsi \n-\t\t= bsi_after_labels (loop->inner->header);\n+\t      gimple_stmt_iterator header_bsi \n+\t\t= gsi_after_labels (loop->inner->header);\n \n-\t      for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi);)\n+\t      for (bsi = gsi_start_bb (bbs[i]); !gsi_end_p (bsi);)\n \t\t{ \n-\t\t  tree stmt = bsi_stmt (bsi);\n+\t\t  gimple stmt = gsi_stmt (bsi);\n \n \t\t  if (stmt == exit_condition\n \t\t      || not_interesting_stmt (stmt)\n \t\t      || stmt_is_bumper_for_loop (loop, stmt))\n \t\t    {\n-\t\t      bsi_next (&bsi);\n+\t\t      gsi_next (&bsi);\n \t\t      continue;\n \t\t    }\n \n-\t\t  bsi_move_before (&bsi, &header_bsi);\n+\t\t  gsi_move_before (&bsi, &header_bsi);\n \t\t}\n \t    }\n \t  else\n \t    { \n \t      /* Note that the bsi only needs to be explicitly incremented\n \t\t when we don't move something, since it is automatically\n \t\t incremented when we do.  */\n-\t      for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi);)\n+\t      for (bsi = gsi_start_bb (bbs[i]); !gsi_end_p (bsi);)\n \t\t{ \n \t\t  ssa_op_iter i;\n-\t\t  tree n, stmt = bsi_stmt (bsi);\n+\t\t  tree n;\n+\t\t  gimple stmt = gsi_stmt (bsi);\n \t\t  \n \t\t  if (stmt == exit_condition\n \t\t      || not_interesting_stmt (stmt)\n \t\t      || stmt_is_bumper_for_loop (loop, stmt))\n \t\t    {\n-\t\t      bsi_next (&bsi);\n+\t\t      gsi_next (&bsi);\n \t\t      continue;\n \t\t    }\n \t\t  \n \t\t  replace_uses_equiv_to_x_with_y \n \t\t    (loop, stmt, oldivvar, VEC_index (int, steps, 0), ivvar,\n \t\t     VEC_index (tree, lbounds, 0), replacements, &firstbsi);\n \n-\t\t  bsi_move_before (&bsi, &tobsi);\n+\t\t  gsi_move_before (&bsi, &tobsi);\n \t\t  \n \t\t  /* If the statement has any virtual operands, they may\n \t\t     need to be rewired because the original loop may\n@@ -2793,7 +2791,7 @@ build_access_matrix (data_reference_p data_reference,\n {\n   struct access_matrix *am = GGC_NEW (struct access_matrix);\n   unsigned i, ndim = DR_NUM_DIMENSIONS (data_reference);\n-  struct loop *loop = bb_for_stmt (DR_STMT (data_reference))->loop_father;\n+  struct loop *loop = gimple_bb (DR_STMT (data_reference))->loop_father;\n   struct loop *loop_nest = get_loop (loop_nest_num);\n   unsigned nivs = loop_depth (loop) - loop_depth (loop_nest) + 1;\n   unsigned lambda_nb_columns;"}, {"sha": "36110a721039e8027d884513090da664fe97518b", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n+#include \"tree-flow.h\"\n #include \"lambda.h\"\n \n static void lambda_matrix_get_column (lambda_matrix, int, int, "}, {"sha": "e81a71cd53e7e5aca46e980b8ba126174697b8e0", "filename": "gcc/lambda-trans.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"tree.h\"\n #include \"target.h\"\n+#include \"tree-flow.h\"\n #include \"lambda.h\"\n \n /* Allocate a new transformation matrix.  */"}, {"sha": "66fbac74bd53deb764bed1f6a5ac8cc03efd9124", "filename": "gcc/lambda.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -209,10 +209,10 @@ lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loop *,\n                                                  struct obstack *);\n void lambda_loopnest_to_gcc_loopnest (struct loop *,\n \t\t\t\t      VEC(tree,heap) *, VEC(tree,heap) *,\n-\t\t\t\t      VEC(tree,heap) **,\n+\t\t\t\t      VEC(gimple,heap) **,\n                                       lambda_loopnest, lambda_trans_matrix,\n                                       struct obstack *);\n-void remove_iv (tree);\n+void remove_iv (gimple);\n \n static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);\n static inline void lambda_vector_mult_const (lambda_vector, lambda_vector, int, int);"}, {"sha": "4cab70b614918a0beaccf458da4a1e8b33d58ba3", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -73,7 +73,7 @@ extern tree lhd_callgraph_analyze_expr (tree *, int *);\n \n \n /* Declarations for tree gimplification hooks.  */\n-extern int lhd_gimplify_expr (tree *, tree *, tree *);\n+extern int lhd_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n extern enum omp_clause_default_kind lhd_omp_predetermined_sharing (tree);\n extern tree lhd_omp_assignment (tree, tree, tree);\n struct gimplify_omp_ctx;"}, {"sha": "2285ac17f54a4eec1e995f59b4f06d5da2a68445", "filename": "gcc/langhooks.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"tree.h\"\n #include \"tree-inline.h\"\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n #include \"rtl.h\"\n #include \"insn-config.h\"\n #include \"integrate.h\"\n@@ -303,8 +303,9 @@ lhd_expr_size (const_tree exp)\n /* lang_hooks.gimplify_expr re-writes *EXPR_P into GIMPLE form.  */\n \n int\n-lhd_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED, tree *pre_p ATTRIBUTE_UNUSED,\n-\t\t   tree *post_p ATTRIBUTE_UNUSED)\n+lhd_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED,\n+\t\t   gimple_seq *pre_p ATTRIBUTE_UNUSED,\n+\t\t   gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   return GS_UNHANDLED;\n }\n@@ -527,7 +528,7 @@ lhd_omp_predetermined_sharing (tree decl ATTRIBUTE_UNUSED)\n tree\n lhd_omp_assignment (tree clause ATTRIBUTE_UNUSED, tree dst, tree src)\n {\n-  return build_gimple_modify_stmt (dst, src);\n+  return build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n }\n \n /* Register language specific type size variables as potentially OpenMP"}, {"sha": "6a23a313f350bc404119c9bf74cb9070ed99d202", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -401,7 +401,7 @@ struct lang_hooks\n \n   /* Perform language-specific gimplification on the argument.  Returns an\n      enum gimplify_status, though we can't see that type here.  */\n-  int (*gimplify_expr) (tree *, tree *, tree *);\n+  int (*gimplify_expr) (tree *, gimple_seq *, gimple_seq *);\n \n   /* Fold an OBJ_TYPE_REF expression to the address of a function.\n      KNOWN_TYPE carries the true type of the OBJ_TYPE_REF_OBJECT.  */"}, {"sha": "9ebbcde560859d267e18cc861a301f13c6c84f23", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -107,9 +107,7 @@ along with GCC; see the file COPYING3.  If not see\n \n   Both optimizations are described in the paper \"Matrix flattening and \n   transposing in GCC\" which was presented in GCC summit 2006. \n-  http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf\n-\n- */\n+  http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -145,8 +143,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n \n-/*\n-   We need to collect a lot of data from the original malloc,\n+  /* FIXME tuples.  */\n+#if 0\n+/* We need to collect a lot of data from the original malloc,\n    particularly as the gimplifier has converted:\n \n    orig_var = (struct_type *) malloc (x * sizeof (struct_type *));\n@@ -430,7 +429,7 @@ may_flatten_matrices_1 (tree stmt)\n   switch (TREE_CODE (stmt))\n     {\n     case GIMPLE_MODIFY_STMT:\n-      t = GIMPLE_STMT_OPERAND (stmt, 1);\n+      t = TREE_OPERAND (stmt, 1);\n       while (CONVERT_EXPR_P (t))\n \t{\n \t  if (TREE_TYPE (t) && POINTER_TYPE_P (TREE_TYPE (t)))\n@@ -775,7 +774,7 @@ analyze_matrix_allocation_site (struct matrix_info *mi, tree stmt,\n {\n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n-      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+      tree rhs = TREE_OPERAND (stmt, 1);\n \n       rhs = get_inner_of_cast_expr (rhs);\n       if (TREE_CODE (rhs) == SSA_NAME)\n@@ -910,7 +909,7 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n        i++)\n     {\n-      if (TREE_CODE (GIMPLE_STMT_OPERAND (acc_info->stmt, 1)) == POINTER_PLUS_EXPR\n+      if (TREE_CODE (TREE_OPERAND (acc_info->stmt, 1)) == POINTER_PLUS_EXPR\n \t  && acc_info->level < min_escape_l)\n \t{\n \t  loop = loop_containing_stmt (acc_info->stmt);\n@@ -930,7 +929,7 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t    {\n \t\t      acc_info->iterated_by_inner_most_loop_p = 1;\n \t\t      mi->dim_hot_level[acc_info->level] +=\n-\t\t\tbb_for_stmt (acc_info->stmt)->count;\n+\t\t\tgimple_bb (acc_info->stmt)->count;\n \t\t    }\n \n \t\t}\n@@ -952,7 +951,7 @@ get_index_from_offset (tree offset, tree def_stmt)\n \n   if (TREE_CODE (def_stmt) == PHI_NODE)\n     return NULL;\n-  expr = get_inner_of_cast_expr (GIMPLE_STMT_OPERAND (def_stmt, 1));\n+  expr = get_inner_of_cast_expr (TREE_OPERAND (def_stmt, 1));\n   if (TREE_CODE (expr) == SSA_NAME)\n     return get_index_from_offset (offset, SSA_NAME_DEF_STMT (expr));\n   else if (TREE_CODE (expr) == MULT_EXPR)\n@@ -980,9 +979,9 @@ update_type_size (struct matrix_info *mi, tree stmt, tree ssa_var,\n \n   /* Update type according to the type of the INDIRECT_REF expr.   */\n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == INDIRECT_REF)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == INDIRECT_REF)\n     {\n-      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      lhs = TREE_OPERAND (stmt, 0);\n       gcc_assert (POINTER_TYPE_P\n \t\t  (TREE_TYPE (SSA_NAME_VAR (TREE_OPERAND (lhs, 0)))));\n       type_size =\n@@ -1139,8 +1138,8 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n \t\t\t\t  bool record_accesses)\n {\n \n-  tree lhs = GIMPLE_STMT_OPERAND (use_stmt, 0);\n-  tree rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n+  tree lhs = TREE_OPERAND (use_stmt, 0);\n+  tree rhs = TREE_OPERAND (use_stmt, 1);\n   struct ssa_acc_in_tree lhs_acc, rhs_acc;\n \n   memset (&lhs_acc, 0, sizeof (lhs_acc));\n@@ -1376,7 +1375,7 @@ check_var_notmodified_p (tree * tp, int *walk_subtrees, void *data)\n \tstmt = bsi_stmt (bsi);\n \tif (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n \t  continue;\n-\tif (GIMPLE_STMT_OPERAND (stmt, 0) == t)\n+\tif (TREE_OPERAND (stmt, 0) == t)\n \t  return stmt;\n       }\n   }\n@@ -1425,7 +1424,7 @@ can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n \treturn fold_build2 (TREE_CODE (expr), TREE_TYPE (expr), op1, op2);\n       return NULL_TREE;\n     case GIMPLE_MODIFY_STMT:\n-      return can_calculate_expr_before_stmt (GIMPLE_STMT_OPERAND (expr, 1),\n+      return can_calculate_expr_before_stmt (TREE_OPERAND (expr, 1),\n \t\t\t\t\t     visited);\n     case PHI_NODE:\n       {\n@@ -1588,9 +1587,9 @@ find_sites_in_func (bool record)\n       {\n \tstmt = bsi_stmt (bsi);\n \tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == VAR_DECL)\n+\t    && TREE_CODE (TREE_OPERAND (stmt, 0)) == VAR_DECL)\n \t  {\n-\t    tmpmi.decl = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t    tmpmi.decl = TREE_OPERAND (stmt, 0);\n \t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n \t\t\t\t\t\t\t&tmpmi)))\n \t      {\n@@ -1599,16 +1598,16 @@ find_sites_in_func (bool record)\n \t      }\n \t  }\n \tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n-\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == VAR_DECL)\n+\t    && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n+\t    && TREE_CODE (TREE_OPERAND (stmt, 1)) == VAR_DECL)\n \t  {\n-\t    tmpmi.decl = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t    tmpmi.decl = TREE_OPERAND (stmt, 1);\n \t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n \t\t\t\t\t\t\t&tmpmi)))\n \t      {\n \t\tsbitmap_zero (visited_stmts_1);\n \t\tanalyze_matrix_accesses (mi,\n-\t\t\t\t\t GIMPLE_STMT_OPERAND (stmt, 0), 0,\n+\t\t\t\t\t TREE_OPERAND (stmt, 0), 0,\n \t\t\t\t\t false, visited_stmts_1, record);\n \t      }\n \t  }\n@@ -1642,8 +1641,8 @@ record_all_accesses_in_func (void)\n       if (!ssa_var\n \t  || TREE_CODE (SSA_NAME_DEF_STMT (ssa_var)) != GIMPLE_MODIFY_STMT)\n \tcontinue;\n-      rhs = GIMPLE_STMT_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 1);\n-      lhs = GIMPLE_STMT_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 0);\n+      rhs = TREE_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 1);\n+      lhs = TREE_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 0);\n       if (TREE_CODE (rhs) != VAR_DECL && TREE_CODE (lhs) != VAR_DECL)\n \tcontinue;\n \n@@ -1741,7 +1740,7 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t}\n       if (acc_info->is_alloc)\n \t{\n-\t  if (acc_info->level >= 0 && bb_for_stmt (acc_info->stmt))\n+\t  if (acc_info->level >= 0 && gimple_bb (acc_info->stmt))\n \t    {\n \t      ssa_op_iter iter;\n \t      tree def;\n@@ -1751,15 +1750,15 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\tmark_sym_for_renaming (SSA_NAME_VAR (def));\n \t      bsi = bsi_for_stmt (stmt);\n \t      gcc_assert (TREE_CODE (acc_info->stmt) == GIMPLE_MODIFY_STMT);\n-\t      if (TREE_CODE (GIMPLE_STMT_OPERAND (acc_info->stmt, 0)) ==\n+\t      if (TREE_CODE (TREE_OPERAND (acc_info->stmt, 0)) ==\n \t\t  SSA_NAME && acc_info->level < min_escape_l - 1)\n \t\t{\n \t\t  imm_use_iterator imm_iter;\n \t\t  use_operand_p use_p;\n \t\t  tree use_stmt;\n \n \t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t\t\t GIMPLE_STMT_OPERAND (acc_info->stmt,\n+\t\t\t\t\t TREE_OPERAND (acc_info->stmt,\n \t\t\t\t\t\t\t      0))\n \t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t\t  {\n@@ -1768,22 +1767,22 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t    /* Emit convert statement to convert to type of use.  */\n \t\t    conv =\n \t\t      fold_build1 (CONVERT_EXPR,\n-\t\t\t\t   TREE_TYPE (GIMPLE_STMT_OPERAND\n+\t\t\t\t   TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t      (acc_info->stmt, 0)),\n-\t\t\t\t   TREE_OPERAND (GIMPLE_STMT_OPERAND\n+\t\t\t\t   TREE_OPERAND (TREE_OPERAND\n \t\t\t\t\t\t (acc_info->stmt, 1), 0));\n \t\t    tmp =\n \t\t      create_tmp_var (TREE_TYPE\n-\t\t\t\t      (GIMPLE_STMT_OPERAND\n+\t\t\t\t      (TREE_OPERAND\n \t\t\t\t       (acc_info->stmt, 0)), \"new\");\n \t\t    add_referenced_var (tmp);\n \t\t    stmts =\n \t\t      fold_build2 (GIMPLE_MODIFY_STMT,\n-\t\t\t\t   TREE_TYPE (GIMPLE_STMT_OPERAND\n+\t\t\t\t   TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t      (acc_info->stmt, 0)), tmp,\n \t\t\t\t   conv);\n \t\t    tmp = make_ssa_name (tmp, stmts);\n-\t\t    GIMPLE_STMT_OPERAND (stmts, 0) = tmp;\n+\t\t    TREE_OPERAND (stmts, 0) = tmp;\n \t\t    bsi = bsi_for_stmt (acc_info->stmt);\n \t\t    bsi_insert_after (&bsi, stmts, BSI_SAME_STMT);\n \t\t    SET_USE (use_p, tmp);\n@@ -1795,7 +1794,7 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t  free (acc_info);\n \t  continue;\n \t}\n-      orig = GIMPLE_STMT_OPERAND (acc_info->stmt, 1);\n+      orig = TREE_OPERAND (acc_info->stmt, 1);\n       type = TREE_TYPE (orig);\n       if (TREE_CODE (orig) == INDIRECT_REF\n \t  && acc_info->level < min_escape_l - 1)\n@@ -1804,8 +1803,8 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t     from \"pointer to type\" to \"type\".  */\n \t  orig =\n \t    build1 (NOP_EXPR, TREE_TYPE (orig),\n-\t\t    GIMPLE_STMT_OPERAND (orig, 0));\n-\t  GIMPLE_STMT_OPERAND (acc_info->stmt, 1) = orig;\n+\t\t    TREE_OPERAND (orig, 0));\n+\t  TREE_OPERAND (acc_info->stmt, 1) = orig;\n \t}\n       else if (TREE_CODE (orig) == POINTER_PLUS_EXPR\n \t       && acc_info->level < (min_escape_l))\n@@ -2095,7 +2094,7 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t\t\t\t   true, BSI_SAME_STMT);\n       /* GLOBAL_HOLDING_THE_SIZE = DIM_SIZE.  */\n       tmp = fold_build2 (GIMPLE_MODIFY_STMT, type, dim_var, dim_size);\n-      GIMPLE_STMT_OPERAND (tmp, 0) = dim_var;\n+      TREE_OPERAND (tmp, 0) = dim_var;\n       mark_symbols_for_renaming (tmp);\n       bsi_insert_before (&bsi, tmp, BSI_SAME_STMT);\n \n@@ -2104,7 +2103,7 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n   update_ssa (TODO_update_ssa);\n   /* Replace the malloc size argument in the malloc of level 0 to be\n      the size of all the dimensions.  */\n-  malloc_stmt = GIMPLE_STMT_OPERAND (call_stmt_0, 1);\n+  malloc_stmt = TREE_OPERAND (call_stmt_0, 1);\n   c_node = cgraph_node (mi->allocation_function_decl);\n   old_size_0 = CALL_EXPR_ARG (malloc_stmt, 0);\n   tmp = force_gimple_operand_bsi (&bsi, mi->dimension_size[0], true,\n@@ -2128,7 +2127,7 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n       tree call;\n \n       tree call_stmt = mi->malloc_for_level[i];\n-      call = GIMPLE_STMT_OPERAND (call_stmt, 1);\n+      call = TREE_OPERAND (call_stmt, 1);\n       gcc_assert (TREE_CODE (call) == CALL_EXPR);\n       e = cgraph_edge (c_node, call_stmt);\n       gcc_assert (e);\n@@ -2138,15 +2137,15 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n       bsi_remove (&bsi, true);\n       /* remove the type cast stmt.  */\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     GIMPLE_STMT_OPERAND (call_stmt, 0))\n+\t\t\t     TREE_OPERAND (call_stmt, 0))\n       {\n \tuse_stmt1 = use_stmt;\n \tbsi = bsi_for_stmt (use_stmt);\n \tbsi_remove (&bsi, true);\n       }\n       /* Remove the assignment of the allocated area.  */\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     GIMPLE_STMT_OPERAND (use_stmt1, 0))\n+\t\t\t     TREE_OPERAND (use_stmt1, 0))\n       {\n \tbsi = bsi_for_stmt (use_stmt);\n \tbsi_remove (&bsi, true);\n@@ -2204,12 +2203,13 @@ dump_matrix_reorg_analysis (void **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-\n+#endif\n /* Perform matrix flattening.  */\n \n static unsigned int\n matrix_reorg (void)\n {\n+#if 0 /* FIXME tuples */\n   struct cgraph_node *node;\n \n   if (profile_info)\n@@ -2233,7 +2233,7 @@ matrix_reorg (void)\n \tcurrent_function_decl = node->decl;\n \tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \tbitmap_obstack_initialize (NULL);\n-\ttree_register_cfg_hooks ();\n+\tgimple_register_cfg_hooks ();\n \n \tif (!gimple_in_ssa_p (cfun))\n \t  {\n@@ -2301,7 +2301,7 @@ matrix_reorg (void)\n \tcurrent_function_decl = node->decl;\n \tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \tbitmap_obstack_initialize (NULL);\n-\ttree_register_cfg_hooks ();\n+\tgimple_register_cfg_hooks ();\n \trecord_all_accesses_in_func ();\n \thtab_traverse (matrices_to_reorg, transform_access_sites, NULL);\n \tfree_dominance_info (CDI_DOMINATORS);\n@@ -2316,14 +2316,22 @@ matrix_reorg (void)\n   set_cfun (NULL);\n   matrices_to_reorg = NULL;\n   return 0;\n+#else\n+  gcc_unreachable ();\n+#endif\n }\n \n \n /* The condition for matrix flattening to be performed.  */\n static bool\n gate_matrix_reorg (void)\n {\n+  /* FIXME tuples */\n+#if 0\n   return flag_ipa_matrix_reorg && flag_whole_program;\n+#else\n+  return false;\n+#endif\n }\n \n struct simple_ipa_opt_pass pass_ipa_matrix_reorg = \n@@ -2344,3 +2352,4 @@ struct simple_ipa_opt_pass pass_ipa_matrix_reorg =\n   TODO_dump_cgraph | TODO_dump_func\t/* todo_flags_finish */\n  }\n };\n+"}, {"sha": "8fa3d3d4df18104434d803a80bd7001afb9a964c", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -1,3 +1,19 @@\n+2008-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tMerge from gimple-tuples-branch.\n+\n+\t2008-07-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Make-lang.in (objc-lang.o): Depend on GIMPLE_H.\n+\t(objc-act.o): Rename TREE_GIMPLE_H to GIMPLE_H.\n+\t* objc-act.h: Include gimple.h instead of tree-gimple.h.\n+\t* ipa-reference.c: Same.\n+\n+\t2007-11-10  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* objc-act.c (objc_gimplify_expr): Change pre and post to sequences.\n+\t* objc-act.h (objc_gimplify_expr): Change prototype accordingly.\n+\n 2008-07-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* objc-act.c: Fix comment typos."}, {"sha": "c5de9d83c733893083fd022936471116c8548920", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -72,14 +72,14 @@ objc/objc-lang.o : objc/objc-lang.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(C_TREE_H) $(DIAGNOSTIC_H) \\\n    $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objc.h \\\n-   c-objc-common.h objc/objc-act.h $(TREE_GIMPLE_H)\n+   c-objc-common.h objc/objc-act.h $(GIMPLE_H)\n \n objc/objc-act.o : objc/objc-act.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) \\\n    $(EXPR_H) $(TARGET_H) $(C_TREE_H) $(DIAGNOSTIC_H) toplev.h $(FLAGS_H) \\\n    objc/objc-act.h input.h $(FUNCTION_H) output.h debug.h langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(HASHTAB_H) $(C_PRAGMA_H) gt-objc-objc-act.h \\\n-   $(TREE_GIMPLE_H)\n+   $(GIMPLE_H)\n \n objc.srcextra:\n "}, {"sha": "5941fb6938908d8db5a2a0471fb65f9cde735dc1", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -9476,7 +9476,7 @@ objc_rewrite_function_call (tree function, tree params)\n    of its cousins).  */\n \n enum gimplify_status\n-objc_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+objc_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   enum gimplify_status r0, r1;\n   if (TREE_CODE (*expr_p) == OBJ_TYPE_REF"}, {"sha": "741401d8356e5e10f89067e9dc8282034a360926", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_OBJC_ACT_H\n \n /* For enum gimplify_status */\n-#include \"tree-gimple.h\"\n+#include \"gimple.h\"\n \n /*** Language hooks ***/\n \n@@ -32,7 +32,7 @@ const char *objc_printable_name (tree, int);\n tree objc_get_callee_fndecl (const_tree);\n void objc_finish_file (void);\n tree objc_fold_obj_type_ref (tree, tree);\n-enum gimplify_status objc_gimplify_expr (tree *, tree *, tree *);\n+enum gimplify_status objc_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n \n /* NB: The remaining public functions are prototyped in c-common.h, for the\n    benefit of stub-objc.c and objc-act.c.  */"}, {"sha": "fb7cffee234a0d6e30bdf2b4457857c550eb5450", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=726a989a8b74bf238a96029860bcf7ba14eff317", "patch": "@@ -72,12 +72,12 @@ cc1objplus$(exeext): $(OBJCXX_OBJS) cc1objplus-checksum.o $(BACKEND) $(LIBDEPS)\n objcp/objcp-lang.o : objcp/objcp-lang.c \\\n   $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h objc/objc-act.h \\\n   $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objcp.h \\\n-  $(DIAGNOSTIC_H) cp/cp-objcp-common.h $(TREE_GIMPLE_H)\n+  $(DIAGNOSTIC_H) cp/cp-objcp-common.h $(GIMPLE_H)\n \n objcp/objcp-decl.o : objcp/objcp-decl.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n    toplev.h $(GGC_H) $(C_PRAGMA_H) input.h $(FLAGS_H) output.h \\\n-   objc/objc-act.h objcp/objcp-decl.h $(TREE_GIMPLE_H) $(EXPR_H) $(TARGET_H)\n+   objc/objc-act.h objcp/objcp-decl.h $(GIMPLE_H) $(EXPR_H) $(TARGET_H)\n \n # The following must be an explicit rule; please keep in sync with the implicit\n # one in Makefile.in.\n@@ -86,7 +86,7 @@ objcp/objcp-act.o : objc/objc-act.c \\\n    $(EXPR_H) $(TARGET_H) $(CXX_TREE_H) $(DIAGNOSTIC_H) toplev.h $(FLAGS_H) \\\n    objc/objc-act.h input.h $(FUNCTION_H) output.h debug.h langhooks.h \\\n    objcp/objcp-decl.h $(LANGHOOKS_DEF_H) $(HASHTAB_H) gt-objc-objc-act.h \\\n-   $(TREE_GIMPLE_H)\n+   $(GIMPLE_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n po-generated:"}, {"sha": "cda05a449caa8744bf4f1bf57bf1815bf0a7b207", "filename": "gcc/omp-low.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d07a5ca9f3d41cd3eace49ae1e5524bb2a2ff0a2", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "6a887be8e561890b8d686f732ac06b4172567926", "filename": "gcc/predict.c", "status": "modified", "additions": 163, "deletions": 143, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "a310ec436e24d78d94126a79d682ac8c3443ecfe", "filename": "gcc/print-tree.c", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "b6cddc2295f81146ad40ae43fc297f2c48df3c24", "filename": "gcc/profile.c", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "664c91049b460d8fc53f0ecbe425fcc618243861", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "80bfe619c3d11ebb377fe8f60a1d02c8c8a692c8", "filename": "gcc/system.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "331cc53d8f4db71ca859b46567aee14fc1971152", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "dc2bb162abffa1a90b6fb4052c8a6c51c985317f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "436220ba8a7917c08eaa40287ca274e7e534e171", "filename": "gcc/testsuite/g++.dg/torture/pr36826.C", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr36826.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr36826.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr36826.C?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "35ef352bc6dac8ace3840f907c678aeeadf94e6b", "filename": "gcc/testsuite/gcc.c-torture/compile/20080721-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080721-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080721-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080721-1.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "bce9476cddb7a36361f54c37694726303e8956b6", "filename": "gcc/testsuite/gcc.dg/20080615-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2F20080615-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2F20080615-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20080615-1.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "c464536470159da4558066f8b31d872aa009002d", "filename": "gcc/testsuite/gcc.dg/fold-alloca-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-alloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-alloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-alloca-1.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "dd7fe7783a99a9f036dc134a960200e397987adf", "filename": "gcc/testsuite/gcc.dg/gomp/block-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "4c56add570c4d8dc1563da57255ba55d6e0dce58", "filename": "gcc/testsuite/gcc.dg/gomp/block-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "c72b04c35d09de6f35d1532dc51af7eab4ba5284", "filename": "gcc/testsuite/gcc.dg/gomp/block-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "61f490c003317d09a21b1ef83ffffcd6fb697c3d", "filename": "gcc/testsuite/gcc.dg/gomp/block-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "741049fddeaad163b1814b3937daed633b96d828", "filename": "gcc/testsuite/gcc.dg/gomp/block-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "87e6392e5b34995385c42f8e84eb513c8ac23801", "filename": "gcc/testsuite/gcc.dg/gomp/block-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "2bc1cdb5723d79a6cfcd245697d6e87fbbb6e5b3", "filename": "gcc/testsuite/gcc.dg/gomp/block-7.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "3c717d927bee72dcf7cb9e6a419fbfa07434a70d", "filename": "gcc/testsuite/gcc.dg/gomp/block-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "91fcd2b00d317ebaa84a940a4dfcd3d7bf939123", "filename": "gcc/testsuite/gcc.dg/torture/20080716-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20080716-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20080716-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20080716-1.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "1ad2c63653c972865bcbd9933cb79227c92ffab4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030728-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "6da7cb8a03ab9fd23023fbc19e83eabe06c68cca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20080530.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20080530.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20080530.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20080530.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d7b72f9f75416b68e705cdf197cde96aab6a9c18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21658.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21658.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21658.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21658.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "50b3bfd565af068e51b75b69a0e9b0aff5eb7c2c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr30375.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30375.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30375.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30375.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "4055bc3f52d092018486b65bfc996033e2320ae0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/tailcall-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-3.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "04c39a40a02cc1bdca245819315f240553326fdf", "filename": "gcc/testsuite/gfortran.dg/gomp/block-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fblock-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fblock-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fblock-1.f90?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d021eeea32cf801e2c117ba55a3b01d1d217ba9e", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "fab2f49fa9f56a52f7ccb18b8972884942969916", "filename": "gcc/tracer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "0d329d06efda7e4b1336f502b09803d62723c2d6", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "ce9572ca142870cca0f0da0f514059ceaf43132f", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 97, "deletions": 108, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "00979bd82ab10929ea522a1c595b2caa83a79029", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1561, "deletions": 1963, "changes": 3524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "433900c3a1496beaf7bd796c8e5d76c513820c06", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 86, "deletions": 93, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "89e96fd53b68aa17b6c9a1fce050997e95ea3f9b", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "9000fb7dab4778587ce73cb1fa57547286128640", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "bbf4c494218e466927cbc1a03b1e026d2033d7a0", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 440, "deletions": 371, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "1b5e92b5af344283b80f9590544b2c7164f1be84", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 140, "deletions": 124, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "639a32bf82bbba4a37ed24b5751c2b06e7724c82", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "df0be2df134a54b11af9672de482a5be1f485ca8", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 74, "deletions": 135, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "66ea1e75840852d145d94d2d8dc9e0faca6a0804", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "140cbc54953982a0af682501404f4903f59998bb", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1060, "deletions": 737, "changes": 1797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "eefc983190ebedc6ad75b62324487aec27d5dc3a", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 92, "deletions": 314, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "96c4795fef0af96de7cc4f230fe6ba9c2d5a4065", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 141, "deletions": 178, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "8b05f93d5052535d99bfbc3f6e01b5008e698c46", "filename": "gcc/tree-gimple.c", "status": "removed", "additions": 0, "deletions": 653, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d48657d7378a4b1cb25ed181bca8020eae520f1/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d48657d7378a4b1cb25ed181bca8020eae520f1/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=0d48657d7378a4b1cb25ed181bca8020eae520f1"}, {"sha": "3691cbc56314b73487dee354cd8a6eacb232609a", "filename": "gcc/tree-gimple.h", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d48657d7378a4b1cb25ed181bca8020eae520f1/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d48657d7378a4b1cb25ed181bca8020eae520f1/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=0d48657d7378a4b1cb25ed181bca8020eae520f1"}, {"sha": "d21bb9d49d1c267750e7275d32b3c0d2e66cb3bd", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 138, "deletions": 146, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "511270bffb366ca6e25a39d35db38ca49d6d399f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1343, "deletions": 719, "changes": 2062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e590e1465a7a2b1a3b4e6426ed82915db7d0de0c", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "fb61731893ac95c3bb62121c5c15cc930677f397", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 164, "deletions": 120, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d8c151a9f5427bd2a32a6ad644c0488047f6803c", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d86391e2af3cf480d8a5d9252d3565094b57fbc1", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 62, "deletions": 72, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "66d25ec1bebc115a28b86aa6879e60c2d76a4252", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "7d15077073b0e140407ab7fdb2074370a0d7f0a6", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 161, "deletions": 155, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "8f4ab047ae9d9b7aa10f2d9c5e210494a921ba52", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 530, "deletions": 473, "changes": 1003, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "8e618a100f417cd4d7781dcc61b785dbe400323f", "filename": "gcc/tree-nomudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-nomudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-nomudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nomudflap.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "40e7508f613385553d8f70ba29884627da32fccc", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "22c495154d41b3d01ca667b151d4f9bc1b9ed1da", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 215, "deletions": 176, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "ba3d0fcc9e0f8b08c779cc898922374d88e6752b", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "58aed883007db977d626e6c2c930f81903401383", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 132, "deletions": 140, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "f2b8d042ef5b2f0a49dc6f0a0845d34420a47e10", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 257, "deletions": 259, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "1e1463fc5fabb5c61d585cc13ab6540549f8f062", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "511e84bf9b977f50f2d95bc704db6e8c79e2690c", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 97, "deletions": 119, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "63911b3dbe51871cb7db49ac8ed9df9648fcb1a1", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 240, "deletions": 191, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "df055f84fe71a739fbe81e9f4db0139f8741bbcb", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 9, "deletions": 504, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "20ded1b9f75be56e623c2728aa1395546b3e8549", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 94, "deletions": 87, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "67fcd08dda0de984413c7d0272af2d80b3d0cc9c", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 323, "deletions": 274, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "5d6d711afa953c28cb60e6292f2c8b5e6a6a0d24", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "5ae1c51350c86b2a3cd3c6a2629744f5da333e61", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 363, "deletions": 387, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "198adb409e64f5032d576e493cc1d0b23bc7c1c6", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "67d7f94ea3d4a8a94fa8f373e054d31d579d4044", "filename": "gcc/tree-ssa-alias-warnings.c", "status": "modified", "additions": 93, "deletions": 62, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-alias-warnings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-alias-warnings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-warnings.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e1540f3b8f8225fd39885160df931ec7e3847b68", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 81, "deletions": 113, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "44b5523263daef8d67ffda8fed4083780afeaa29", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 849, "deletions": 571, "changes": 1420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d5e5f8702ff69fa5359ffe64632447e2987ed00f", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "c228725e59e12f360f75385a2c60df3a2ecab9a9", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 163, "deletions": 72, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "d30e2372e7e5e5d92633d793c0ac0682808a267c", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "3c7504696826f9411e0426469cb790a0b01e2882", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 122, "deletions": 120, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "4e7a390d91e23dcba456b30d02e3a98b4b4d4998", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1056, "deletions": 606, "changes": 1662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "b4be5142e016214c0db8df2bc3e837c404b8c5d1", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 94, "deletions": 91, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "6c5c6cabc468c298577e9d103635b134c695b4c4", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 362, "deletions": 233, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "143608e28eb75b2c05f424b0bfcde64e82881bd1", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 135, "deletions": 123, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "fa3834d21c55aa8cbb46465de09ca62774162203", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "de4726245f801ffa31c601667a764a32a3982684", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "9a0dca7265e172de2d7b83840c9f368b1afa0f20", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "4c85c878e6cb1338440f276bd48f3bb009528ac1", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 284, "deletions": 289, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "dc863f8b8a55a97078de74f574ee5977a91e8170", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "c314da49f94860bdee03ee6d73d73ae74d5602d7", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 201, "deletions": 176, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "05e87d241cd8fa22e92d4567da557b08fac75253", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 83, "deletions": 70, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "83baae7828aafd4ec54b51901a69645c97823c55", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 229, "deletions": 153, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "02b4d7347dfa4197dcbd980239a51d7231f2c736", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "8ece4aca4ab3f8f3b614ce549ca65ad79e62a013", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "ec3782a54500026a0b08cdf0d09df9b0fedff099", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "dfc00bcdd12aa2f46fec4a34f0679334646ad899", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 108, "deletions": 109, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "304df53863e345fa78655f39f52ff55c34658f68", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 258, "deletions": 465, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "cdbc050b579cb36fe927ed6a1f2fbd6a38695b93", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "72ba04a09b87ce7350923fd8f9af3f2c075f6a10", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 152, "deletions": 244, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "ff3ee4a439f5cadf447976b07bd4c66af14927e6", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "a8a39073d13604af74d33b7e06660db7c9ff53f3", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 414, "deletions": 356, "changes": 770, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "611f2b2847d181a9253fe1b3cdcf9e7c1c0ba150", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 358, "deletions": 326, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e472baca7c72c3fad1a7e30a1d110b3412418882", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "a3facd8baa1071e31f395136203a2d47e6f056de", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 216, "deletions": 193, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "42d394f554009eef6ef83733dbcee156c28c353b", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 496, "deletions": 220, "changes": 716, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "923be1931630deb2d7a7a6c94279163d379f0882", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e56cce0edb1e223f5d01f2fc645586cbcbc64987", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "3b9ce02a5b7ad97c6720fe10dc4a13618b34976a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 157, "deletions": 200, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e684f5def7f353445e738e10f5be2925123cf554", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "099c19742e413acbaf4b0091cd6814b1172401c3", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 43, "deletions": 58, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "6a8216118003aaa42efd4317be5fc8278f1ca108", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 149, "deletions": 109, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "dedd00ecb9a57dc735a8cca8f8dbe641a83fc5d1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "335d7aed14b3e567f67c911f27f8820ae38d63e4", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "fbfcbf213d3b53b7b9fd41eddaf4cf05038e5e84", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 136, "deletions": 108, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "f3101d2827102fe4b956595403e682d71c48e7f8", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "96a72fad08e848a56625dc799f1114efb47140f5", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 110, "deletions": 117, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "8bcfcfde5ca031046e3f4c7a799a17a085d061da", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 123, "deletions": 136, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "78bf1550d2b4dc245518b0e329f633051fac231e", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 219, "deletions": 258, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "c9753a0598d95425967db744785ecbfbd98c5620", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 212, "deletions": 201, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "9919389dfc3f45a3bfed7d21d792a4f8078cd024", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 94, "deletions": 97, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e53780f1ef6e1ccd120e56f139f75c68cd2f27f8", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 153, "deletions": 135, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "362d37cf861f52e6a894ffabfd965d5d2d23065b", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 742, "deletions": 655, "changes": 1397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "3526de45bb3389288920cee5b01af5688be6d6f8", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 253, "deletions": 233, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "ea80a8d3d30f4ab22e0cc905899fbe2998a581fe", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 68, "deletions": 44, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "40bec2e1d4da5aa26ccb98f95bb60e641b48b446", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 557, "deletions": 424, "changes": 981, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "cdecd707f0067cbc65f830fcb500e9ad33481abe", "filename": "gcc/tree.c", "status": "modified", "additions": 80, "deletions": 201, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e9c891754bbc73f06175b9b56934e4a3ee50b80a", "filename": "gcc/tree.def", "status": "modified", "additions": 8, "deletions": 64, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "5f5b37d4ef8d6fb1e19aeff6029003499bdfe267", "filename": "gcc/tree.h", "status": "modified", "additions": 58, "deletions": 214, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "b94a3f96b47be00066a93b1e49de4287f1367375", "filename": "gcc/value-prof.c", "status": "modified", "additions": 364, "deletions": 375, "changes": 739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "e66f4e2046a2fb0995ba7e36ca8a9d150ef06ec2", "filename": "gcc/value-prof.h", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}, {"sha": "1d1cc9ed630b40420b524de3e67e0f1ca442c54d", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726a989a8b74bf238a96029860bcf7ba14eff317/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=726a989a8b74bf238a96029860bcf7ba14eff317"}]}