{"sha": "aaa26bf496a646778ac861aed124d960b5bf549f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFhMjZiZjQ5NmE2NDY3NzhhYzg2MWFlZDEyNGQ5NjBiNWJmNTQ5Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-27T03:58:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-02-08T16:14:58Z"}, "message": "c++: Use constexpr to avoid wrong -Wsign-compare (PR90691).\n\nWe would like to do constexpr evaluation to avoid false positives on\nwarnings, but constexpr evaluation can involve function body copying that\nchanges DECL_UID, which breaks -fcompare-debug.  So let's remember\nthat we need to avoid that.\n\n\tPR c++/90691\n\t* expr.c (fold_for_warn): Call maybe_constant_value.\n\t* constexpr.c (struct constexpr_ctx): Add uid_sensitive field.\n\t(maybe_constant_value): Add uid_sensitive parm.\n\t(get_fundef_copy): Don't copy if it's true.\n\t(cxx_eval_call_expression): Don't instantiate if it's true.\n\t(cxx_eval_outermost_constant_expr): Likewise.", "tree": {"sha": "1167d885bee00dad0a0f9437ebe7fcfc8d1c19cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1167d885bee00dad0a0f9437ebe7fcfc8d1c19cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaa26bf496a646778ac861aed124d960b5bf549f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa26bf496a646778ac861aed124d960b5bf549f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa26bf496a646778ac861aed124d960b5bf549f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa26bf496a646778ac861aed124d960b5bf549f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "173c8defa6e82f1bc003173b6ee1e4eb2830d1c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173c8defa6e82f1bc003173b6ee1e4eb2830d1c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173c8defa6e82f1bc003173b6ee1e4eb2830d1c2"}], "stats": {"total": 80, "additions": 66, "deletions": 14}, "files": [{"sha": "dff6a170580d30dfb50b2d734e4064c8485bdfa0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aaa26bf496a646778ac861aed124d960b5bf549f", "patch": "@@ -1,5 +1,13 @@\n 2020-02-08  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/90691\n+\t* expr.c (fold_for_warn): Call maybe_constant_value.\n+\t* constexpr.c (struct constexpr_ctx): Add uid_sensitive bit-field.\n+\t(maybe_constant_value): Add uid_sensitive parm.\n+\t(get_fundef_copy): Don't copy if it's true.\n+\t(cxx_eval_call_expression): Don't instantiate if it's true.\n+\t(cxx_eval_outermost_constant_expr): Likewise.\n+\n \tPR c++/92852\n \t* constexpr.c (maybe_constant_value): Don't unshare if the cached\n \tvalue is the same as the argument."}, {"sha": "192ba566427df22dababf95b4616b40b61d701f8", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=aaa26bf496a646778ac861aed124d960b5bf549f", "patch": "@@ -1074,13 +1074,18 @@ struct constexpr_ctx {\n   /* If inside SWITCH_EXPR.  */\n   constexpr_switch_state *css_state;\n \n-  /* Whether we should error on a non-constant expression or fail quietly.  */\n+  /* Whether we should error on a non-constant expression or fail quietly.\n+     This flag needs to be here, but some of the others could move to global\n+     if they get larger than a word.  */\n   bool quiet;\n   /* Whether we are strictly conforming to constant expression rules or\n      trying harder to get a constant value.  */\n   bool strict;\n   /* Whether __builtin_is_constant_evaluated () should be true.  */\n   bool manifestly_const_eval;\n+  /* Whether we want to avoid doing anything that will cause extra DECL_UID\n+     generation.  */\n+  bool uid_sensitive;\n };\n \n /* A table of all constexpr calls that have been evaluated by the\n@@ -1145,7 +1150,7 @@ static GTY(()) hash_map<tree, tree> *fundef_copies_table;\n    is parms, TYPE is result.  */\n \n static tree\n-get_fundef_copy (constexpr_fundef *fundef)\n+get_fundef_copy (const constexpr_ctx *ctx, constexpr_fundef *fundef)\n {\n   tree copy;\n   bool existed;\n@@ -1162,6 +1167,9 @@ get_fundef_copy (constexpr_fundef *fundef)\n     }\n   else if (*slot == NULL_TREE)\n     {\n+      if (ctx->uid_sensitive)\n+\treturn NULL_TREE;\n+\n       /* We've already used the function itself, so make a copy.  */\n       copy = build_tree_list (NULL, NULL);\n       tree saved_body = DECL_SAVED_TREE (fundef->decl);\n@@ -2232,6 +2240,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \n   /* We can't defer instantiating the function any longer.  */\n   if (!DECL_INITIAL (fun)\n+      && !ctx->uid_sensitive\n       && DECL_TEMPLOID_INSTANTIATION (fun))\n     {\n       location_t save_loc = input_location;\n@@ -2378,13 +2387,12 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (at_eof >= 2 && ctx->quiet);\n \t  *non_constant_p = true;\n \t}\n-      else\n+      else if (tree copy = get_fundef_copy (ctx, new_call.fundef))\n \t{\n \t  tree body, parms, res;\n \t  releasing_vec ctors;\n \n \t  /* Reuse or create a new unshared copy of this function's body.  */\n-\t  tree copy = get_fundef_copy (new_call.fundef);\n \t  body = TREE_PURPOSE (copy);\n \t  parms = TREE_VALUE (copy);\n \t  res = TREE_TYPE (copy);\n@@ -2522,6 +2530,9 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t    }\n \t    }\n \t}\n+      else\n+\t/* Couldn't get a function copy to evaluate.  */\n+\t*non_constant_p = true;\n \n       if (result == error_mark_node)\n \t*non_constant_p = true;\n@@ -6275,7 +6286,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t\t\t\t  bool strict = true,\n \t\t\t\t  bool manifestly_const_eval = false,\n \t\t\t\t  bool constexpr_dtor = false,\n-\t\t\t\t  tree object = NULL_TREE)\n+\t\t\t\t  tree object = NULL_TREE,\n+\t\t\t\t  bool uid_sensitive = false)\n {\n   auto_timevar time (TV_CONSTEXPR);\n \n@@ -6285,7 +6297,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   constexpr_global_ctx global_ctx;\n   constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict,\n-\t\t\tmanifestly_const_eval || !allow_non_constant };\n+\t\t\tmanifestly_const_eval || !allow_non_constant,\n+\t\t\tuid_sensitive };\n \n   tree type = initialized_type (t);\n   tree r = t;\n@@ -6375,7 +6388,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   auto_vec<tree, 16> cleanups;\n   global_ctx.cleanups = &cleanups;\n \n-  instantiate_constexpr_fns (r);\n+  if (!uid_sensitive)\n+    instantiate_constexpr_fns (r);\n   r = cxx_eval_constant_expression (&ctx, r,\n \t\t\t\t    false, &non_constant_p, &overflow_p);\n \n@@ -6623,12 +6637,14 @@ fold_simple (tree t)\n    Otherwise, if T does not have TREE_CONSTANT set, returns T.\n    Otherwise, returns a version of T without TREE_CONSTANT.\n    MANIFESTLY_CONST_EVAL is true if T is manifestly const-evaluated\n-   as per P0595.  */\n+   as per P0595.  UID_SENSITIVE is true if we can't do anything that\n+   would affect DECL_UID ordering.  */\n \n static GTY((deletable)) hash_map<tree, tree> *cv_cache;\n \n tree\n-maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n+maybe_constant_value (tree t, tree decl, bool manifestly_const_eval,\n+\t\t      bool uid_sensitive)\n {\n   tree r;\n \n@@ -6646,7 +6662,8 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n     return t;\n \n   if (manifestly_const_eval)\n-    return cxx_eval_outermost_constant_expr (t, true, true, true, false, decl);\n+    return cxx_eval_outermost_constant_expr (t, true, true, true, false,\n+\t\t\t\t\t     decl, uid_sensitive);\n \n   if (cv_cache == NULL)\n     cv_cache = hash_map<tree, tree>::create_ggc (101);\n@@ -6658,7 +6675,10 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n \t  r = unshare_expr_without_location (r);\n \t  protected_set_expr_location (r, EXPR_LOCATION (t));\n \t}\n-      return r;\n+      if (r != t || TREE_CONSTANT (t) || !manifestly_const_eval)\n+\treturn r;\n+      /* If we cached this as non-constant and we need a constant value, try\n+\t again; we might have failed before due to UID_SENSITIVE.  */\n     }\n \n   r = cxx_eval_outermost_constant_expr (t, true, true, false, false, decl);"}, {"sha": "037d3b6453825508f226cb57aff6ddc00e173874", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aaa26bf496a646778ac861aed124d960b5bf549f", "patch": "@@ -7930,7 +7930,7 @@ extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n-extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n+extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false, bool = false);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,"}, {"sha": "04e4418c671bfa389cafdce9e596c5d333f6afaf", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=aaa26bf496a646778ac861aed124d960b5bf549f", "patch": "@@ -397,6 +397,8 @@ fold_for_warn (tree x)\n       else\n \treturn f;\n     }\n+  else if (cxx_dialect >= cxx11)\n+    x = maybe_constant_value (x, NULL_TREE, false, true);\n \n   return c_fully_fold (x, /*for_init*/false, /*maybe_constp*/NULL);\n }"}, {"sha": "dd02843857b824d645bf07723a41674ff111dc1d", "filename": "gcc/testsuite/g++.dg/warn/Walways-true-3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-3.C?ref=aaa26bf496a646778ac861aed124d960b5bf549f", "patch": "@@ -17,7 +17,7 @@ bar (int &a)\n   if (&b) // { dg-warning \"7:the compiler can assume that the address of\" }\n     foo ();\n \n-  if (!&c) // { dg-warning \"8:the compiler can assume that the address of\" }\n+  if (!&c) // { dg-warning \"8:the address of\" }\n     foo ();\n \n   if (!&(int &)(int &)a) // { dg-warning \"8:the compiler can assume that the address of\" }\n@@ -29,7 +29,7 @@ bar (int &a)\n   if (&b != 0) // { dg-warning \"10:the compiler can assume that the address of\" }\n     foo ();\n \n-  if (0 == &(int &)(int &)c) // { dg-warning \"9:the compiler can assume that the address of\" }\n+  if (0 == &(int &)(int &)c) // { dg-warning \"9:the address of\" }\n     foo ();\n \n   if (&a != (int *)0) // { dg-warning \"10:the compiler can assume that the address of\" }"}, {"sha": "bf3514c40acf9ab05efb8fca6ef13d2d4cbd55e8", "filename": "gcc/testsuite/g++.dg/warn/Wsign-compare-9.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-compare-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa26bf496a646778ac861aed124d960b5bf549f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-compare-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-compare-9.C?ref=aaa26bf496a646778ac861aed124d960b5bf549f", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/90691\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options -Wsign-compare }\n+\n+struct S {\n+  int a;\n+\n+  constexpr S();\n+  explicit constexpr S(int a_) : a(a_) {}\n+};\n+\n+constexpr S b = S(12);\n+\n+template <const S& e>\n+bool c(unsigned int d) {\n+  return d >= e.a;\n+}\n+\n+bool test(unsigned int d);\n+bool test(unsigned int d) {\n+    return c<b>(d);\n+}"}]}