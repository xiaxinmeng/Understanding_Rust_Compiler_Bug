{"sha": "0dd973dd9710115f96420505591f65c5ab2445b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRkOTczZGQ5NzEwMTE1Zjk2NDIwNTA1NTkxZjY1YzVhYjI0NDViNA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2005-01-22T15:24:09Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-01-22T15:24:09Z"}, "message": "primary.c (gfc_match_rvalue): Only apply implicit type if variable does not have an explicit type.\n\n2005-01-22  Paul Brook  <paul@codesourcery.com>\n\n\t* primary.c (gfc_match_rvalue): Only apply implicit type if variable\n\tdoes not have an explicit type.\n\t(gfc_match_variable): Resolve implicit derived types in all cases.\n\tResolve contained function types from their own namespace, not the\n\tparent.\n\t* resolve.c (resolve_contained_fntype): Remove duplicate sym->result\n\tchecking.  Resolve from the contained namespace, not the parent.\ntestsuite/\n\t* gfortran.dg/implicit_2.f90: New test.\n\nFrom-SVN: r94066", "tree": {"sha": "2a3848c0ca3a85aeeedecdf1905a38e016a7dc5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a3848c0ca3a85aeeedecdf1905a38e016a7dc5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dd973dd9710115f96420505591f65c5ab2445b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd973dd9710115f96420505591f65c5ab2445b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dd973dd9710115f96420505591f65c5ab2445b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd973dd9710115f96420505591f65c5ab2445b4/comments", "author": null, "committer": null, "parents": [{"sha": "b8d5e92646dd8d2a4ea41770e734a29cfcbc1ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d5e92646dd8d2a4ea41770e734a29cfcbc1ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d5e92646dd8d2a4ea41770e734a29cfcbc1ea3"}], "stats": {"total": 110, "additions": 83, "deletions": 27}, "files": [{"sha": "fb4af7de454f3d1c831b4dd9e7ed88421a3ba1a8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0dd973dd9710115f96420505591f65c5ab2445b4", "patch": "@@ -1,3 +1,13 @@\n+2005-01-22  Paul Brook  <paul@codesourcery.com>\n+\n+\t* primary.c (gfc_match_rvalue): Only apply implicit type if variable\n+\tdoes not have an explicit type.\n+\t(gfc_match_variable): Resolve implicit derived types in all cases.\n+\tResolve contained function types from their own namespace, not the\n+\tparent.\n+\t* resolve.c (resolve_contained_fntype): Remove duplicate sym->result\n+\tchecking.  Resolve from the contained namespace, not the parent.\n+\n 2005-01-22  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/19543"}, {"sha": "6496bcd34782fbb305ef16b7bcbacf6ecde15e92", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=0dd973dd9710115f96420505591f65c5ab2445b4", "patch": "@@ -2011,6 +2011,7 @@ gfc_match_rvalue (gfc_expr ** result)\n          resolution phase.  */\n \n       if (gfc_peek_char () == '%'\n+\t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, sym->ns);\n \n@@ -2188,29 +2189,18 @@ gfc_match_variable (gfc_expr ** result, int equiv_flag)\n     case FL_UNKNOWN:\n       if (gfc_add_flavor (&sym->attr, FL_VARIABLE, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n-\n-      /* Special case for derived type variables that get their types\n-         via an IMPLICIT statement.  This can't wait for the\n-         resolution phase.  */\n-\n-      if (gfc_peek_char () == '%'\n-\t  && gfc_get_default_type (sym, sym->ns)->type == BT_DERIVED)\n-\tgfc_set_default_type (sym, 0, sym->ns);\n-\n       break;\n \n     case FL_PROCEDURE:\n       /* Check for a nonrecursive function result */\n       if (sym->attr.function && (sym->result == sym || sym->attr.entry))\n \t{\n-\n \t  /* If a function result is a derived type, then the derived\n \t     type may still have to be resolved.  */\n \n \t  if (sym->ts.type == BT_DERIVED\n \t      && gfc_use_derived (sym->ts.derived) == NULL)\n \t    return MATCH_ERROR;\n-\n \t  break;\n \t}\n \n@@ -2221,6 +2211,24 @@ gfc_match_variable (gfc_expr ** result, int equiv_flag)\n       return MATCH_ERROR;\n     }\n \n+  /* Special case for derived type variables that get their types\n+     via an IMPLICIT statement.  This can't wait for the\n+     resolution phase.  */\n+\n+    {\n+      gfc_namespace * implicit_ns;\n+\n+      if (gfc_current_ns->proc_name == sym)\n+\timplicit_ns = gfc_current_ns;\n+      else\n+\timplicit_ns = sym->ns;\n+\t\n+      if (gfc_peek_char () == '%'\n+\t  && sym->ts.type == BT_UNKNOWN\n+\t  && gfc_get_default_type (sym, implicit_ns)->type == BT_DERIVED)\n+\tgfc_set_default_type (sym, 0, implicit_ns);\n+    }\n+\n   expr = gfc_get_expr ();\n \n   expr->expr_type = EXPR_VARIABLE;"}, {"sha": "c3bf35057df9d5f354b98189f74de8cfce03981a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0dd973dd9710115f96420505591f65c5ab2445b4", "patch": "@@ -259,27 +259,13 @@ resolve_contained_fntype (gfc_symbol * sym, gfc_namespace * ns)\n \t   || sym->attr.flavor == FL_VARIABLE))\n     return;\n \n-  /* Try to find out of what type the function is.  If there was an\n-     explicit RESULT clause, try to get the type from it.  If the\n-     function is never defined, set it to the implicit type.  If\n-     even that fails, give up.  */\n+  /* Try to find out of what the return type is.  */\n   if (sym->result != NULL)\n     sym = sym->result;\n \n   if (sym->ts.type == BT_UNKNOWN)\n     {\n-      /* Assume we can find an implicit type.  */\n-      t = SUCCESS;\n-\n-      if (sym->result == NULL)\n-\tt = gfc_set_default_type (sym, 0, ns);\n-      else\n-\t{\n-\t  if (sym->result->ts.type == BT_UNKNOWN)\n-\t    t = gfc_set_default_type (sym->result, 0, NULL);\n-\n-\t  sym->ts = sym->result->ts;\n-\t}\n+      t = gfc_set_default_type (sym, 0, ns);\n \n       if (t == FAILURE)\n \tgfc_error (\"Contained function '%s' at %L has no IMPLICIT type\","}, {"sha": "6b16fc8542e2fc0029d76283cdc428c3a3651cfe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0dd973dd9710115f96420505591f65c5ab2445b4", "patch": "@@ -1,3 +1,7 @@\n+2005-01-22  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gfortran.dg/implicit_2.f90: New test.\n+\n 2005-01-22  Bud Davis  <bdavis9659@comcast.net>\n \n \tPR fortran/19314"}, {"sha": "c0582d703b6014e174e51986a8a33ac9a88dd901", "filename": "gcc/testsuite/gfortran.dg/implicit_2.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd973dd9710115f96420505591f65c5ab2445b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_2.f90?ref=0dd973dd9710115f96420505591f65c5ab2445b4", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile }\n+\n+module implicit_2\n+  ! This should cause an error if function types are resolved from the\n+  ! module namespace.\n+  implicit none\n+  type t\n+    integer i\n+  end type\n+contains\n+! This caused an ICE because we were trying to apply the implicit type\n+! after we had applied the explicit type.\n+subroutine test()\n+  implicit type (t) (v)\n+  type (t) v1, v2\n+  v1%i = 1\n+  call foo (v2%i)\n+end subroutine\n+\n+! A similar error because we failed to apply the implicit type to a function.\n+! This is a contained function to check we lookup the type in the function\n+! namespace, not it's parent.\n+function f() result (val)\n+  implicit type (t) (v)\n+\n+  val%i = 1\n+end function\n+\n+! And again for a result variable.\n+function fun()\n+  implicit type (t) (f)\n+\n+  fun%i = 1\n+end function\n+\n+! intrinsic types are resolved later than derived type, so check those as well.\n+function test2()\n+  implicit integer (t)\n+  test2 = 42\n+end function\n+subroutine bar()\n+  ! Check that implicit types are applied to names already known to be\n+  ! variables.\n+  implicit type(t) (v)\n+  save v\n+  v%i = 42\n+end subroutine\n+end module"}]}