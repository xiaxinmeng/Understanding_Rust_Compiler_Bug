{"sha": "cc570be69335a3d3c36c14eabc99bf0049e7f9be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M1NzBiZTY5MzM1YTNkM2MzNmMxNGVhYmM5OWJmMDA0OWU3ZjliZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-07T16:20:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-07T16:20:14Z"}, "message": "[multiple changes]\n\n2011-11-07  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_alfa.adb: Remove with and use clause for\n\tExp_Ch8. Add with and use clause for Exp_Util.\n\tRemove local constant Disable_Processing_Of_Renamings.\n\t(Expand_Alfa_N_Object_Renaming_Declaration): The expansion of\n\tobject renamings has been reenabled.\n\t(Expand_Possible_Renaming):\n\tThe expansion of identifier and expanded names has been\n\treenabled. Perform the substitutions only for entities that\n\tdenote an object.\n\t* exp_ch8.ads, exp_ch8.adb (Evaluate_Name): Moved to Exp_Util.\n\t* exp_util.adb (Evaluate_Name): Moved from Exp_Ch8.\n\t(Remove_Side_Effects): Alphabetize local variables. Add a guard\n\tto avoid the infinite expansion of an expression in Alfa mode. Add\n\tprocessing for function calls in Alfa mode.\n\t* exp_util.ads (Evaliate_Name): Moved from Exp_Ch8.\n\n2011-11-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): If the entity is an access to\n\tsubprogram whose designated type is itself a subprogram type,\n\tits own return type must be decorated with size information.\n\nFrom-SVN: r181091", "tree": {"sha": "6788b159094d3e15bb388510e484debf113ebeb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6788b159094d3e15bb388510e484debf113ebeb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc570be69335a3d3c36c14eabc99bf0049e7f9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc570be69335a3d3c36c14eabc99bf0049e7f9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc570be69335a3d3c36c14eabc99bf0049e7f9be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc570be69335a3d3c36c14eabc99bf0049e7f9be/comments", "author": null, "committer": null, "parents": [{"sha": "da80a6464e2f41f4e139fcd182fdaa00a024851e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da80a6464e2f41f4e139fcd182fdaa00a024851e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da80a6464e2f41f4e139fcd182fdaa00a024851e"}], "stats": {"total": 326, "additions": 193, "deletions": 133}, "files": [{"sha": "dce07972ed64090229cad7c9522451fa5124d827", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -1,3 +1,27 @@\n+2011-11-07  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_alfa.adb: Remove with and use clause for\n+\tExp_Ch8. Add with and use clause for Exp_Util.\n+\tRemove local constant Disable_Processing_Of_Renamings.\n+\t(Expand_Alfa_N_Object_Renaming_Declaration): The expansion of\n+\tobject renamings has been reenabled.\n+\t(Expand_Possible_Renaming):\n+\tThe expansion of identifier and expanded names has been\n+\treenabled. Perform the substitutions only for entities that\n+\tdenote an object.\n+\t* exp_ch8.ads, exp_ch8.adb (Evaluate_Name): Moved to Exp_Util.\n+\t* exp_util.adb (Evaluate_Name): Moved from Exp_Ch8.\n+\t(Remove_Side_Effects): Alphabetize local variables. Add a guard\n+\tto avoid the infinite expansion of an expression in Alfa mode. Add\n+\tprocessing for function calls in Alfa mode.\n+\t* exp_util.ads (Evaliate_Name): Moved from Exp_Ch8.\n+\n+2011-11-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): If the entity is an access to\n+\tsubprogram whose designated type is itself a subprogram type,\n+\tits own return type must be decorated with size information.\n+\n 2011-11-04  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "e2424da99280e94103efee5f6747dc358a686826", "filename": "gcc/ada/exp_alfa.adb", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.adb?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -28,8 +28,8 @@ with Einfo;    use Einfo;\n with Exp_Attr; use Exp_Attr;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n-with Exp_Ch8;  use Exp_Ch8;\n with Exp_Dbug; use Exp_Dbug;\n+with Exp_Util; use Exp_Util;\n with Nlists;   use Nlists;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n@@ -42,8 +42,6 @@ with Tbuild;   use Tbuild;\n \n package body Exp_Alfa is\n \n-   Disable_Processing_Of_Renamings : constant Boolean := True;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -211,10 +209,6 @@ package body Exp_Alfa is\n \n    procedure Expand_Alfa_N_Object_Renaming_Declaration (N : Node_Id) is\n    begin\n-      if Disable_Processing_Of_Renamings then\n-         return;\n-      end if;\n-\n       --  Unconditionally remove all side effects from the name\n \n       Evaluate_Name (Name (N));\n@@ -303,13 +297,11 @@ package body Exp_Alfa is\n       T : constant Entity_Id := Etype (N);\n \n    begin\n-      if Disable_Processing_Of_Renamings then\n-         return;\n-      end if;\n-\n       --  Substitute a reference to a renaming with the actual renamed object\n \n-      if Present (Renamed_Object (E)) then\n+      if Ekind (E) in Object_Kind\n+        and then Present (Renamed_Object (E))\n+      then\n          Rewrite (N, New_Copy_Tree (Renamed_Object (E)));\n \n          Reset_Analyzed_Flags (N);"}, {"sha": "f6f62d7f19116f55ff0d73fd816bf5702e63782b", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -44,100 +44,6 @@ with Tbuild;   use Tbuild;\n \n package body Exp_Ch8 is\n \n-   -------------------\n-   -- Evaluate_Name --\n-   -------------------\n-\n-   procedure Evaluate_Name (Nam : Node_Id) is\n-      K : constant Node_Kind := Nkind (Nam);\n-\n-   begin\n-      --  For an explicit dereference, we simply force the evaluation of the\n-      --  name expression. The dereference provides a value that is the address\n-      --  for the renamed object, and it is precisely this value that we want\n-      --  to preserve.\n-\n-      if K = N_Explicit_Dereference then\n-         Force_Evaluation (Prefix (Nam));\n-\n-      --  For a selected component, we simply evaluate the prefix\n-\n-      elsif K = N_Selected_Component then\n-         Evaluate_Name (Prefix (Nam));\n-\n-      --  For an indexed component, or an attribute reference, we evaluate the\n-      --  prefix, which is itself a name, recursively, and then force the\n-      --  evaluation of all the subscripts (or attribute expressions).\n-\n-      elsif Nkind_In (K, N_Indexed_Component, N_Attribute_Reference) then\n-         Evaluate_Name (Prefix (Nam));\n-\n-         declare\n-            E : Node_Id;\n-\n-         begin\n-            E := First (Expressions (Nam));\n-            while Present (E) loop\n-               Force_Evaluation (E);\n-\n-               if Original_Node (E) /= E then\n-                  Set_Do_Range_Check (E, Do_Range_Check (Original_Node (E)));\n-               end if;\n-\n-               Next (E);\n-            end loop;\n-         end;\n-\n-      --  For a slice, we evaluate the prefix, as for the indexed component\n-      --  case and then, if there is a range present, either directly or as the\n-      --  constraint of a discrete subtype indication, we evaluate the two\n-      --  bounds of this range.\n-\n-      elsif K = N_Slice then\n-         Evaluate_Name (Prefix (Nam));\n-\n-         declare\n-            DR     : constant Node_Id := Discrete_Range (Nam);\n-            Constr : Node_Id;\n-            Rexpr  : Node_Id;\n-\n-         begin\n-            if Nkind (DR) = N_Range then\n-               Force_Evaluation (Low_Bound (DR));\n-               Force_Evaluation (High_Bound (DR));\n-\n-            elsif Nkind (DR) = N_Subtype_Indication then\n-               Constr := Constraint (DR);\n-\n-               if Nkind (Constr) = N_Range_Constraint then\n-                  Rexpr := Range_Expression (Constr);\n-\n-                  Force_Evaluation (Low_Bound (Rexpr));\n-                  Force_Evaluation (High_Bound (Rexpr));\n-               end if;\n-            end if;\n-         end;\n-\n-      --  For a type conversion, the expression of the conversion must be the\n-      --  name of an object, and we simply need to evaluate this name.\n-\n-      elsif K = N_Type_Conversion then\n-         Evaluate_Name (Expression (Nam));\n-\n-      --  For a function call, we evaluate the call\n-\n-      elsif K = N_Function_Call then\n-         Force_Evaluation (Nam);\n-\n-      --  The remaining cases are direct name, operator symbol and character\n-      --  literal. In all these cases, we do nothing, since we want to\n-      --  reevaluate each time the renamed object is used.\n-\n-      else\n-         return;\n-      end if;\n-   end Evaluate_Name;\n-\n    ---------------------------------------------\n    -- Expand_N_Exception_Renaming_Declaration --\n    ---------------------------------------------"}, {"sha": "d5dd37c6fcd46d2e97292acf82f92d609cbc1d5a", "filename": "gcc/ada/exp_ch8.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.ads?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -33,8 +33,4 @@ package Exp_Ch8 is\n    procedure Expand_N_Package_Renaming_Declaration    (N : Node_Id);\n    procedure Expand_N_Subprogram_Renaming_Declaration (N : Node_Id);\n \n-   procedure Evaluate_Name (Nam : Node_Id);\n-   --  Remove the all side effects from a name except for the outermost\n-   --  construct.\n-\n end Exp_Ch8;"}, {"sha": "e675da828890a2b59924ac4103c04e342dfa58ab", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 151, "deletions": 23, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -1759,6 +1759,100 @@ package body Exp_Util is\n           and then not Restriction_Active (No_Local_Allocators);\n    end Entry_Names_OK;\n \n+   -------------------\n+   -- Evaluate_Name --\n+   -------------------\n+\n+   procedure Evaluate_Name (Nam : Node_Id) is\n+      K : constant Node_Kind := Nkind (Nam);\n+\n+   begin\n+      --  For an explicit dereference, we simply force the evaluation of the\n+      --  name expression. The dereference provides a value that is the address\n+      --  for the renamed object, and it is precisely this value that we want\n+      --  to preserve.\n+\n+      if K = N_Explicit_Dereference then\n+         Force_Evaluation (Prefix (Nam));\n+\n+      --  For a selected component, we simply evaluate the prefix\n+\n+      elsif K = N_Selected_Component then\n+         Evaluate_Name (Prefix (Nam));\n+\n+      --  For an indexed component, or an attribute reference, we evaluate the\n+      --  prefix, which is itself a name, recursively, and then force the\n+      --  evaluation of all the subscripts (or attribute expressions).\n+\n+      elsif Nkind_In (K, N_Indexed_Component, N_Attribute_Reference) then\n+         Evaluate_Name (Prefix (Nam));\n+\n+         declare\n+            E : Node_Id;\n+\n+         begin\n+            E := First (Expressions (Nam));\n+            while Present (E) loop\n+               Force_Evaluation (E);\n+\n+               if Original_Node (E) /= E then\n+                  Set_Do_Range_Check (E, Do_Range_Check (Original_Node (E)));\n+               end if;\n+\n+               Next (E);\n+            end loop;\n+         end;\n+\n+      --  For a slice, we evaluate the prefix, as for the indexed component\n+      --  case and then, if there is a range present, either directly or as the\n+      --  constraint of a discrete subtype indication, we evaluate the two\n+      --  bounds of this range.\n+\n+      elsif K = N_Slice then\n+         Evaluate_Name (Prefix (Nam));\n+\n+         declare\n+            DR     : constant Node_Id := Discrete_Range (Nam);\n+            Constr : Node_Id;\n+            Rexpr  : Node_Id;\n+\n+         begin\n+            if Nkind (DR) = N_Range then\n+               Force_Evaluation (Low_Bound (DR));\n+               Force_Evaluation (High_Bound (DR));\n+\n+            elsif Nkind (DR) = N_Subtype_Indication then\n+               Constr := Constraint (DR);\n+\n+               if Nkind (Constr) = N_Range_Constraint then\n+                  Rexpr := Range_Expression (Constr);\n+\n+                  Force_Evaluation (Low_Bound (Rexpr));\n+                  Force_Evaluation (High_Bound (Rexpr));\n+               end if;\n+            end if;\n+         end;\n+\n+      --  For a type conversion, the expression of the conversion must be the\n+      --  name of an object, and we simply need to evaluate this name.\n+\n+      elsif K = N_Type_Conversion then\n+         Evaluate_Name (Expression (Nam));\n+\n+      --  For a function call, we evaluate the call\n+\n+      elsif K = N_Function_Call then\n+         Force_Evaluation (Nam);\n+\n+      --  The remaining cases are direct name, operator symbol and character\n+      --  literal. In all these cases, we do nothing, since we want to\n+      --  reevaluate each time the renamed object is used.\n+\n+      else\n+         return;\n+      end if;\n+   end Evaluate_Name;\n+\n    ---------------------\n    -- Evolve_And_Then --\n    ---------------------\n@@ -5921,11 +6015,11 @@ package body Exp_Util is\n       Exp_Type     : constant Entity_Id      := Etype (Exp);\n       Svg_Suppress : constant Suppress_Array := Scope_Suppress;\n       Def_Id       : Entity_Id;\n+      E            : Node_Id;\n+      New_Exp      : Node_Id;\n+      Ptr_Typ_Decl : Node_Id;\n       Ref_Type     : Entity_Id;\n       Res          : Node_Id;\n-      Ptr_Typ_Decl : Node_Id;\n-      New_Exp      : Node_Id;\n-      E            : Node_Id;\n \n       function Side_Effect_Free (N : Node_Id) return Boolean;\n       --  Determines if the tree N represents an expression that is known not\n@@ -6160,7 +6254,7 @@ package body Exp_Util is\n \n             --  A binary operator is side effect free if and both operands are\n             --  side effect free. For this purpose binary operators include\n-            --  membership tests and short circuit forms\n+            --  membership tests and short circuit forms.\n \n             when N_Binary_Op | N_Membership_Test | N_Short_Circuit =>\n                return Side_Effect_Free (Left_Opnd  (N))\n@@ -6528,6 +6622,15 @@ package body Exp_Util is\n       --  Otherwise we generate a reference to the value\n \n       else\n+         --  An expression which is in Alfa mode is considered side effect free\n+         --  if the resulting value is captured by a variable or a constant.\n+\n+         if Alfa_Mode\n+           and then Nkind (Parent (Exp)) = N_Object_Declaration\n+         then\n+            return;\n+         end if;\n+\n          --  Special processing for function calls that return a limited type.\n          --  We need to build a declaration that will enable build-in-place\n          --  expansion of the call. This is not done if the context is already\n@@ -6536,10 +6639,10 @@ package body Exp_Util is\n          --  This is relevant only in Ada 2005 mode. In Ada 95 programs we have\n          --  to accommodate functions returning limited objects by reference.\n \n-         if Nkind (Exp) = N_Function_Call\n+         if Ada_Version >= Ada_2005\n+           and then Nkind (Exp) = N_Function_Call\n            and then Is_Immutably_Limited_Type (Etype (Exp))\n            and then Nkind (Parent (Exp)) /= N_Object_Declaration\n-           and then Ada_Version >= Ada_2005\n          then\n             declare\n                Obj  : constant Entity_Id := Make_Temporary (Loc, 'F', Exp);\n@@ -6559,32 +6662,57 @@ package body Exp_Util is\n             end;\n          end if;\n \n-         Ref_Type := Make_Temporary (Loc, 'A');\n+         Def_Id := Make_Temporary (Loc, 'R', Exp);\n+         Set_Etype (Def_Id, Exp_Type);\n+\n+         --  The regular expansion of functions with side effects involves the\n+         --  generation of an access type to capture the return value found on\n+         --  the secondary stack. Since Alfa (and why) cannot process access\n+         --  types, use a different approach which ignores the secondary stack\n+         --  and \"copies\" the returned object.\n \n-         Ptr_Typ_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Ref_Type,\n-             Type_Definition =>\n-               Make_Access_To_Object_Definition (Loc,\n-                 All_Present => True,\n-                 Subtype_Indication =>\n-                   New_Reference_To (Exp_Type, Loc)));\n+         if Alfa_Mode then\n+            Res := New_Reference_To (Def_Id, Loc);\n+            Ref_Type := Exp_Type;\n \n-         E := Exp;\n-         Insert_Action (Exp, Ptr_Typ_Decl);\n+         --  Regular expansion utilizing an access type and 'reference\n \n-         Def_Id := Make_Temporary (Loc, 'R', Exp);\n-         Set_Etype (Def_Id, Exp_Type);\n+         else\n+            Res :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Reference_To (Def_Id, Loc));\n \n-         Res :=\n-           Make_Explicit_Dereference (Loc,\n-             Prefix => New_Reference_To (Def_Id, Loc));\n+            --  Generate:\n+            --    type Ann is access all <Exp_Type>;\n \n+            Ref_Type := Make_Temporary (Loc, 'A');\n+\n+            Ptr_Typ_Decl :=\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Ref_Type,\n+                Type_Definition     =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present        => True,\n+                    Subtype_Indication =>\n+                      New_Reference_To (Exp_Type, Loc)));\n+\n+            Insert_Action (Exp, Ptr_Typ_Decl);\n+         end if;\n+\n+         E := Exp;\n          if Nkind (E) = N_Explicit_Dereference then\n             New_Exp := Relocate_Node (Prefix (E));\n          else\n             E := Relocate_Node (E);\n-            New_Exp := Make_Reference (Loc, E);\n+\n+            --  Do not generate a 'reference in Alfa mode since the access type\n+            --  is not created in the first place.\n+\n+            if Alfa_Mode then\n+               New_Exp := E;\n+            else\n+               New_Exp := Make_Reference (Loc, E);\n+            end if;\n          end if;\n \n          if Is_Delayed_Aggregate (E) then"}, {"sha": "f293b8f0a6f520930ff022c45b057c1626f2c8f9", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -351,6 +351,10 @@ package Exp_Util is\n    --  which represent entry [family member] names. These strings are created\n    --  by the compiler and used by GDB.\n \n+   procedure Evaluate_Name (Nam : Node_Id);\n+   --  Remove the all side effects from a name which appears as part of an\n+   --  object renaming declaration.\n+\n    procedure Evolve_And_Then (Cond : in out Node_Id; Cond1 : Node_Id);\n    --  Rewrites Cond with the expression: Cond and then Cond1. If Cond is\n    --  Empty, then simply returns Cond1 (this allows the use of Empty to"}, {"sha": "b1a33d58da18c08e5fb917a9adb5ccceaf0cab94", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc570be69335a3d3c36c14eabc99bf0049e7f9be/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=cc570be69335a3d3c36c14eabc99bf0049e7f9be", "patch": "@@ -4063,6 +4063,16 @@ package body Freeze is\n             Layout_Type (E);\n          end if;\n \n+         --  If this is an access to subprogram whose designated type is itself\n+         --  a subprogram type, the return type of this anonymous subprogram\n+         --  type must be decorated as well.\n+\n+         if Ekind (E) = E_Anonymous_Access_Subprogram_Type\n+           and then Ekind (Designated_Type (E)) = E_Subprogram_Type\n+         then\n+            Layout_Type (Etype (Designated_Type (E)));\n+         end if;\n+\n          --  If the type has a Defaut_Value/Default_Component_Value aspect,\n          --  this is where we analye the expression (after the type is frozen,\n          --  since in the case of Default_Value, we are analyzing with the"}]}