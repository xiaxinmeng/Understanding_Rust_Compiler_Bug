{"sha": "13c2c08bad28dbf30454a90f56ad6da9ee171ae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNjMmMwOGJhZDI4ZGJmMzA0NTRhOTBmNTZhZDZkYTllZTE3MWFlMQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-07-13T02:25:48Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-07-13T02:25:48Z"}, "message": "re PR tree-optimization/22422 (ICE in first_vi_for_offset, at tree-ssa-structalias.c:2843)\n\n2005-07-12  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/22422\n\t* tree-ssa-structalias.c (struct variable_info): Add flag for\n\tspecial vars.\n\t(get_varinfo): Now a static function.\n\t(new_varinfo): init has_union and is_special_var to false.\n\t(solution_set_add): Check has_union.\n\t(do_da_constraint): Move temporary variable so it gets reset\n\tproperly.\n\tAlso check for special variable.\n\t(do_ds_constraint): Ditto.\n\t(do_sd_constraint): Ditto.\n\t(do_structure_copy): Check for special variable.\n\t(find_func_aliases): Ditto.\n\t(init_base_vars): Set special vars properly.\n\nFrom-SVN: r101959", "tree": {"sha": "9f8919f03624db185815a820337be45e32bc1ccd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f8919f03624db185815a820337be45e32bc1ccd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13c2c08bad28dbf30454a90f56ad6da9ee171ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c2c08bad28dbf30454a90f56ad6da9ee171ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c2c08bad28dbf30454a90f56ad6da9ee171ae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c2c08bad28dbf30454a90f56ad6da9ee171ae1/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58deefdeb8f4f7b1a477b999b363c94a5197696e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58deefdeb8f4f7b1a477b999b363c94a5197696e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58deefdeb8f4f7b1a477b999b363c94a5197696e"}], "stats": {"total": 64, "additions": 51, "deletions": 13}, "files": [{"sha": "bb00a8fc7bcfe5b47c34d91979c37bd8a232e7d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c2c08bad28dbf30454a90f56ad6da9ee171ae1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c2c08bad28dbf30454a90f56ad6da9ee171ae1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13c2c08bad28dbf30454a90f56ad6da9ee171ae1", "patch": "@@ -1,3 +1,20 @@\n+2005-07-12  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\tFix PR tree-optimization/22422 \n+\t* tree-ssa-structalias.c (struct variable_info): Add flag for\n+\tspecial vars.\n+\t(get_varinfo): Now a static function.\n+\t(new_varinfo): init has_union and is_special_var to false.\n+\t(solution_set_add): Check has_union.\n+\t(do_da_constraint): Move temporary variable so it gets reset\n+\tproperly.\n+\tAlso check for special variable.\n+\t(do_ds_constraint): Ditto.\n+\t(do_sd_constraint): Ditto.\n+\t(do_structure_copy): Check for special variable.\n+\t(find_func_aliases): Ditto.\n+\t(init_base_vars): Set special vars properly.\t\n+\n 2005-07-13  Jan Hubicka  <jh@suse.cz>\n \n \t* cfgexpand.c (expand_one_stack_var): Do not expand variables when we"}, {"sha": "8bd1f3ef532e781d36e1b5f8b55571813b9521b0", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c2c08bad28dbf30454a90f56ad6da9ee171ae1/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c2c08bad28dbf30454a90f56ad6da9ee171ae1/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=13c2c08bad28dbf30454a90f56ad6da9ee171ae1", "patch": "@@ -216,6 +216,10 @@ struct variable_info\n   /* True if this is a variable created by the constraint analysis, such as\n      heap variables and constraints we had to break up.  */\n   unsigned int is_artificial_var:1;\n+  \n+  /* True if this is a special variable whose solution set should not be\n+     changed.  */\n+  unsigned int is_special_var:1;\n \n   /* True for variables whose size is not known or variable.  */\n   unsigned int is_unknown_size_var:1;  \n@@ -250,7 +254,14 @@ DEF_VEC_ALLOC_P(varinfo_t, heap);\n /* Table of variable info structures for constraint variables.  Indexed directly\n    by variable info id.  */\n static VEC(varinfo_t,heap) *varmap;\n-#define get_varinfo(n) VEC_index(varinfo_t, varmap, n)\n+\n+/* Return the varmap element N */\n+\n+static inline varinfo_t\n+get_varinfo(unsigned int n)\n+{\n+  return VEC_index(varinfo_t, varmap, n);\n+}\n \n /* Variable that represents the unknown pointer.  */\n static varinfo_t var_anything;\n@@ -296,7 +307,9 @@ new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n   ret->indirect_target = false;\n   ret->is_artificial_var = false;\n   ret->is_heap_var = false;\n+  ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n+  ret->has_union = false;\n   ret->solution = BITMAP_ALLOC (&ptabitmap_obstack);\n   bitmap_clear (ret->solution);\n   ret->variables = BITMAP_ALLOC (&ptabitmap_obstack);\n@@ -602,6 +615,7 @@ solution_set_add (bitmap set, unsigned HOST_WIDE_INT offset)\n \t  bitmap_set_bit (result, v->id);\n \t}\n       else if (get_varinfo (i)->is_artificial_var \n+\t       || get_varinfo (i)->has_union\n \t       || get_varinfo (i)->is_unknown_size_var)\n \t{\n \t  bitmap_set_bit (result, i);\n@@ -1298,20 +1312,21 @@ do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n \t\t  constraint_t c, bitmap delta)\n {\n   unsigned int rhs = c->rhs.var;\n-  unsigned HOST_WIDE_INT offset = c->lhs.offset;\n   unsigned int j;\n   bitmap_iterator bi;\n \n   /* For each member j of Delta (Sol(x)), add x to Sol(j)  */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n     {\n-      if (type_safe (j, &offset))\n+      unsigned HOST_WIDE_INT offset = c->lhs.offset;\n+      if (type_safe (j, &offset) && !(get_varinfo (j)->is_special_var))\n \t{\n \t/* *x != NULL && *x != ANYTHING*/\n \t  varinfo_t v;\n \t  unsigned int t;\n \t  bitmap sol;\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + offset;\n+\n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  t = v->node;\n \t  sol = get_varinfo (t)->solution;\n@@ -1325,7 +1340,7 @@ do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n \t\t}\n \t    }\n \t}\n-      else if (dump_file)\n+      else if (dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_da_constraint.\\n\");\n       \n     }\n@@ -1339,7 +1354,6 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t\t  bitmap delta)\n {\n   unsigned int lhs = get_varinfo (c->lhs.var)->node;\n-  unsigned HOST_WIDE_INT roffset = c->rhs.offset;\n   bool flag = false;\n   bitmap sol = get_varinfo (lhs)->solution;\n   unsigned int j;\n@@ -1349,6 +1363,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n      an edge in the graph from j to x, and union Sol(j) into Sol(x).  */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n     {\n+      unsigned HOST_WIDE_INT roffset = c->rhs.offset;\n       if (type_safe (j, &roffset))\n \t{\n \t  varinfo_t v;\n@@ -1360,7 +1375,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  if (int_add_graph_edge (graph, lhs, t, 0))\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\t  \n \t}\n-      else if (dump_file)\n+      else if (dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_sd_constraint\\n\");\n       \n     }\n@@ -1383,7 +1398,6 @@ static void\n do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n {\n   unsigned int rhs = get_varinfo (c->rhs.var)->node;\n-  unsigned HOST_WIDE_INT loff = c->lhs.offset;\n   unsigned HOST_WIDE_INT roff = c->rhs.offset;\n   bitmap sol = get_varinfo (rhs)->solution;\n   unsigned int j;\n@@ -1393,7 +1407,8 @@ do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n      union Sol(y) into Sol(j) */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n     {\n-      if (type_safe (j, &loff))\n+      unsigned HOST_WIDE_INT loff = c->lhs.offset;\n+      if (type_safe (j, &loff) && !(get_varinfo(j)->is_special_var))\n \t{\n \t  varinfo_t v;\n \t  unsigned int t;\n@@ -1419,7 +1434,7 @@ do_ds_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n \t\t}\n \t    }\n \t}    \n-      else if (dump_file)\n+      else if (dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_ds_constraint\\n\");\n     }\n }\n@@ -1446,7 +1461,8 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n   else\n     {\n       /* x = *y */\n-      do_sd_constraint (graph, c, delta);\n+      if (!(get_varinfo (c->lhs.var)->is_special_var))\n+\tdo_sd_constraint (graph, c, delta);\n     }\n }\n \n@@ -2389,7 +2405,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n   rhs = get_constraint_for (rhsop);\n   \n   /* If we have special var = x, swap it around.  */\n-  if (lhs.var <= integer_id && rhs.var > integer_id)\n+  if (lhs.var <= integer_id && !(get_varinfo (rhs.var)->is_special_var))\n     {\n       tmp = lhs;\n       lhs = rhs;\n@@ -2400,7 +2416,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n       possible it's something we could handle.  However, most cases falling\n       into this are dealing with transparent unions, which are slightly\n       weird. */\n-  if (rhs.type == ADDRESSOF && rhs.var > integer_id)\n+  if (rhs.type == ADDRESSOF && !(get_varinfo (rhs.var)->is_special_var))\n     {\n       rhs.type = ADDRESSOF;\n       rhs.var = anything_id;\n@@ -2773,7 +2789,7 @@ find_func_aliases (tree t, struct alias_info *ai)\n \t\t\t   type, from the LHS we can access any field\n \t\t\t   of the RHS.  */\n \t\t\tif (rhs.type == ADDRESSOF\n-\t\t\t    && rhs.var > anything_id\n+\t\t\t    && !(get_varinfo (rhs.var)->is_special_var)\n \t\t\t    && AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (rhsop))))\n \t\t\t  {\n \t\t\t    rhs.var = anyoffset_id;\n@@ -3364,6 +3380,7 @@ init_base_vars (void)\n   var_nothing->offset = 0;\n   var_nothing->size = ~0;\n   var_nothing->fullsize = ~0;\n+  var_nothing->is_special_var = 1;\n   nothing_id = 0;\n   VEC_safe_push (varinfo_t, heap, varmap, var_nothing);\n \n@@ -3377,6 +3394,7 @@ init_base_vars (void)\n   var_anything->offset = 0;\n   var_anything->next = NULL;\n   var_anything->fullsize = ~0;\n+  var_anything->is_special_var = 1;\n   anything_id = 1;\n \n   /* Anything points to anything.  This makes deref constraints just\n@@ -3405,6 +3423,7 @@ init_base_vars (void)\n   var_readonly->size = ~0;\n   var_readonly->fullsize = ~0;\n   var_readonly->next = NULL;\n+  var_readonly->is_special_var = 1;\n   insert_id_for_tree (readonly_tree, 2);\n   readonly_id = 2;\n   VEC_safe_push (varinfo_t, heap, varmap, var_readonly);\n@@ -3432,6 +3451,7 @@ init_base_vars (void)\n   var_integer->fullsize = ~0;\n   var_integer->offset = 0;\n   var_integer->next = NULL;\n+  var_integer->is_special_var = 1;\n   integer_id = 3;\n   VEC_safe_push (varinfo_t, heap, varmap, var_integer);\n \n@@ -3459,6 +3479,7 @@ init_base_vars (void)\n   var_anyoffset->offset = 0;\n   var_anyoffset->next = NULL;\n   var_anyoffset->fullsize = ~0;\n+  var_anyoffset->is_special_var = 1;\n   VEC_safe_push (varinfo_t, heap, varmap, var_anyoffset);\n \n   /* ANYOFFSET points to ANYOFFSET.  */"}]}