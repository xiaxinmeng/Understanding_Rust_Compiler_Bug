{"sha": "d63c70024d2ecd3016851acedf8655ef586e8beb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYzYzcwMDI0ZDJlY2QzMDE2ODUxYWNlZGY4NjU1ZWY1ODZlOGJlYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@act-europe.fr", "date": "2004-10-27T12:29:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-27T12:29:59Z"}, "message": "decl.c (gnat_to_gnu_field): Use the type of the inner object for a JM type only if...\n\n2004-10-26  Eric Botcazou  <ebotcazou@act-europe.fr>\n\n\t* decl.c (gnat_to_gnu_field): Use the type of the inner object for a\n\tJM type only if its size matches that of the wrapper.  When a size is\n\tprescribed and the field is not aliased, remove the wrapper of a JM\n\ttype only if the size is not greater than that of the packed array.\n\t(gnat_to_gnu_entity): Change the extension of packed array wrappers\n\tfrom LJM to JM.\n\nFrom-SVN: r89647", "tree": {"sha": "ce1480ad72468fb81b69e69e0a00112d786be812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce1480ad72468fb81b69e69e0a00112d786be812"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d63c70024d2ecd3016851acedf8655ef586e8beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63c70024d2ecd3016851acedf8655ef586e8beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d63c70024d2ecd3016851acedf8655ef586e8beb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63c70024d2ecd3016851acedf8655ef586e8beb/comments", "author": null, "committer": null, "parents": [{"sha": "9f1621753772745306133818df81270a1d758a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1621753772745306133818df81270a1d758a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f1621753772745306133818df81270a1d758a88"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "f76ad645ea02b8cfd373204c0a4ad47e496b1d90", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63c70024d2ecd3016851acedf8655ef586e8beb/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63c70024d2ecd3016851acedf8655ef586e8beb/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=d63c70024d2ecd3016851acedf8655ef586e8beb", "patch": "@@ -521,7 +521,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* If an alignment is specified, use it if valid.   Note that\n \t   exceptions are objects but don't have alignments.  We must do this\n-\t   before we validate the size, since the alignment can affect the \n+\t   before we validate the size, since the alignment can affect the\n \t   size.  */\n \tif (kind != E_Exception && Known_Alignment (gnat_entity))\n \t  {\n@@ -1342,7 +1342,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_RM_SIZE_NUM (gnu_field_type)\n \t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n \t  gnu_type = make_node (RECORD_TYPE);\n-\t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"LJM\");\n+\t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"JM\");\n \t  TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_field_type);\n \t  TYPE_PACKED (gnu_type) = 1;\n \n@@ -5019,15 +5019,15 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n \n-  /* If the field's type is justified modular, the wrapper can prevent\n-     packing so we make the field the type of the inner object unless the\n-     situation forbids it. We may not do that when the field is addressable_p,\n-     typically because in that case this field may later be passed by-ref for\n-     a formal argument expecting the justification.  The condition below\n-     is then matching the addressable_p code for COMPONENT_REF.  */\n-  if (!Is_Aliased (gnat_field) && flag_strict_aliasing\n-      && TREE_CODE (gnu_field_type) == RECORD_TYPE\n-      && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type))\n+  /* If the field's type is justified modular and the size of the packed\n+     array it wraps is the same as that of the field, we can make the field\n+     the type of the inner object.  Note that we may need to do so if the\n+     record is packed or the field has a component clause, but these cases\n+     are handled later.  */\n+  if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n+      && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n+      && tree_int_cst_equal (TYPE_SIZE (gnu_field_type),\n+\t\t\t     TYPE_ADA_SIZE (gnu_field_type)))\n     gnu_field_type = TREE_TYPE (TYPE_FIELDS (gnu_field_type));\n \n   /* If we are packing this record, have a specified size that's smaller than\n@@ -5173,12 +5173,16 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     gnu_pos = NULL_TREE;\n   else\n     {\n-      /* Unless this field is aliased, we can remove any justified\n-\t modular type since it's only needed in the unchecked conversion\n-\t case, which doesn't apply here.  */\n+      /* If the field's type is justified modular, we would need to remove\n+\t the wrapper to (better) meet the layout requirements.  However we\n+\t can do so only if the field is not aliased to preserve the unique\n+\t layout and if the prescribed size is not greater than that of the\n+\t packed array to preserve the justification.  */\n       if (!needs_strict_alignment\n \t  && TREE_CODE (gnu_field_type) == RECORD_TYPE\n-\t  && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type))\n+\t  && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n+\t  && tree_int_cst_compare (gnu_size, TYPE_ADA_SIZE (gnu_field_type))\n+\t       <= 0)\n \tgnu_field_type = TREE_TYPE (TYPE_FIELDS (gnu_field_type));\n \n       gnu_field_type"}]}