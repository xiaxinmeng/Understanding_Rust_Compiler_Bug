{"sha": "70388d9433b275054b72014b54f387933f1d8d02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzODhkOTQzM2IyNzUwNTRiNzIwMTRiNTRmMzg3OTMzZjFkOGQwMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-03-01T13:44:46Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-03-01T13:44:46Z"}, "message": "cfgloop.c (flow_loop_entry_edges_find, [...]): Removed.\n\n\t* cfgloop.c (flow_loop_entry_edges_find, flow_loop_exit_edges_find,\n\tflow_loop_pre_header_scan, flow_loop_pre_header_find,\n\tflow_loop_scan): Removed.\n\t(flow_loop_dump): Do not dump removed fields.\n\t(flow_loop_free): Do not free removed fields.\n\t(flow_loops_find): Flags argument removed.  Do not call flow_loop_scan.\n\t(loop_exit_edge_p): New function.\n\t* cfgloop.h (struct loop): Removed fields pre_header, pre_header_edges,\n\tnum_pre_header_edges, entry_edges, num_entries, exit_edges,\n\tnum_exits, exits_doms.\n\t(LOOP_TREE, LOOP_PRE_HEADER, LOOP_ENTRY_EDGES, LOOP_EXIT_EDGES,\n\tLOOP_EDGES, LOOP_ALL): Removed.\n\t(flow_loop_scan): Declaration removed.\n\t(loop_exit_edge_p, mark_loop_exit_edges): Declare.\n\t* cfgloopmanip.c (create_loop_notes): Do not pass flags to\n\tflow_loops_find.\n\t* ifcvt.c (mark_loop_exit_edges): Moved to cfgloopanal.c.\n\t(if_convert): Call flow_loops_find and flow_loops_free\n\twhen calling mark_loop_exit_edges.\n\t* cfgloopanal.c (mark_loop_exit_edges): Moved from\n\tifcvt.c.  Removed the flow_loops_find, flow_loops_free and\n\tfree_dominance_info calls.\n\t* loop-init.c (flow_loops_find): Ditto.\n\t* passes.c (rest_of_handle_branch_prob): Ditto.\n\t* lambda-code.c (perfect_nestify): Do not call flow_loops_find.\n\t* loop-unroll.c (analyze_insns_in_loop): Do not use\n\tEDGE_LOOP_EXIT.\n\t* predict.c (predict_loops): Do not call flow_loop_scan.\n\tUse get_loop_exit_edges.\n\t(tree_estimate_probability): Do not pass flags to flow_loops_find.\n\t* tree-if-conv.c (bb_with_exit_edge_p): Take loop as argument.\n\tDo not use EDGE_LOOP_EXIT.\n\t(tree_if_convert_cond_expr, if_convertible_modify_expr_p): Pass loop\n\tto bb_with_exit_edge_p.\n\t(if_convertible_loop_p): Do not call flow_loop_scan.  Use\n\tloop->single_exit.  Do not use EDGE_LOOP_EXIT.  Pass loop\n\tto bb_with_exit_edge_p.\n\t(combine_blocks): Pass loop to bb_with_exit_edge_p.  Do not use\n\tEDGE_LOOP_EXIT.\n\t* tree-loop-linear.c (linear_transform_loops): Do not call\n\tflow_loop_scan.  Use loop->single_exit.\n\t* tree-vect-analyze.c (vect_analyze_operations): Use loop->single_exit.\n\t(vect_analyze_loop_form): Do not call flow_loop_scan.\n\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer): Use\n\tloop->single_exit.\n\t(vect_do_peeling_for_loop_bound): Use loop_preheader_edge and\n\tloop->single_exit.\n\t* tree-vectorizer.c (slpeel_update_phis_for_duplicate_loop,\n\tslpeel_make_loop_iterate_ntimes, slpeel_can_duplicate_loop_p,\n\tslpeel_tree_duplicate_loop_to_edge_cfg,\n\tslpeel_verify_cfg_after_peeling, slpeel_tree_peel_loop_to_edge):\n\tUse loop_preheader_edge and loop->single_exit.  Do not call\n\tflow_loop_scan.\n\nFrom-SVN: r95738", "tree": {"sha": "5b1c8a12d24075ced5f333d3ddacf873da6903a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b1c8a12d24075ced5f333d3ddacf873da6903a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70388d9433b275054b72014b54f387933f1d8d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70388d9433b275054b72014b54f387933f1d8d02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70388d9433b275054b72014b54f387933f1d8d02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70388d9433b275054b72014b54f387933f1d8d02/comments", "author": null, "committer": null, "parents": [{"sha": "b279b20ab3eacc439ecb98f26374f428d43eee77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b279b20ab3eacc439ecb98f26374f428d43eee77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b279b20ab3eacc439ecb98f26374f428d43eee77"}], "stats": {"total": 563, "additions": 171, "deletions": 392}, "files": [{"sha": "c5f2f228323331b215dc6449f72f69c1673c84e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -1,3 +1,59 @@\n+2005-03-01  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* cfgloop.c (flow_loop_entry_edges_find, flow_loop_exit_edges_find,\n+\tflow_loop_pre_header_scan, flow_loop_pre_header_find,\n+\tflow_loop_scan): Removed.\n+\t(flow_loop_dump): Do not dump removed fields.\n+\t(flow_loop_free): Do not free removed fields.\n+\t(flow_loops_find): Flags argument removed.  Do not call flow_loop_scan.\n+\t(loop_exit_edge_p): New function.\n+\t* cfgloop.h (struct loop): Removed fields pre_header, pre_header_edges,\n+\tnum_pre_header_edges, entry_edges, num_entries, exit_edges,\n+\tnum_exits, exits_doms.\n+\t(LOOP_TREE, LOOP_PRE_HEADER, LOOP_ENTRY_EDGES, LOOP_EXIT_EDGES,\n+\tLOOP_EDGES, LOOP_ALL): Removed.\n+\t(flow_loop_scan): Declaration removed.\n+\t(loop_exit_edge_p, mark_loop_exit_edges): Declare.\n+\t* cfgloopmanip.c (create_loop_notes): Do not pass flags to\n+\tflow_loops_find.\n+\t* ifcvt.c (mark_loop_exit_edges): Moved to cfgloopanal.c.\n+\t(if_convert): Call flow_loops_find and flow_loops_free\n+\twhen calling mark_loop_exit_edges.\n+\t* cfgloopanal.c (mark_loop_exit_edges): Moved from\n+\tifcvt.c.  Removed the flow_loops_find, flow_loops_free and\n+\tfree_dominance_info calls.\n+\t* loop-init.c (flow_loops_find): Ditto.\n+\t* passes.c (rest_of_handle_branch_prob): Ditto.\n+\t* lambda-code.c (perfect_nestify): Do not call flow_loops_find.\n+\t* loop-unroll.c (analyze_insns_in_loop): Do not use\n+\tEDGE_LOOP_EXIT.\n+\t* predict.c (predict_loops): Do not call flow_loop_scan.\n+\tUse get_loop_exit_edges.\n+\t(tree_estimate_probability): Do not pass flags to flow_loops_find.\n+\t* tree-if-conv.c (bb_with_exit_edge_p): Take loop as argument.\n+\tDo not use EDGE_LOOP_EXIT.\n+\t(tree_if_convert_cond_expr, if_convertible_modify_expr_p): Pass loop\n+\tto bb_with_exit_edge_p.\n+\t(if_convertible_loop_p): Do not call flow_loop_scan.  Use\n+\tloop->single_exit.  Do not use EDGE_LOOP_EXIT.  Pass loop\n+\tto bb_with_exit_edge_p.\n+\t(combine_blocks): Pass loop to bb_with_exit_edge_p.  Do not use\n+\tEDGE_LOOP_EXIT.\n+\t* tree-loop-linear.c (linear_transform_loops): Do not call\n+\tflow_loop_scan.  Use loop->single_exit.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Use loop->single_exit.\n+\t(vect_analyze_loop_form): Do not call flow_loop_scan.\n+\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer): Use\n+\tloop->single_exit.\n+\t(vect_do_peeling_for_loop_bound): Use loop_preheader_edge and\n+\tloop->single_exit.\n+\t* tree-vectorizer.c (slpeel_update_phis_for_duplicate_loop,\n+\tslpeel_make_loop_iterate_ntimes, slpeel_can_duplicate_loop_p,\n+\tslpeel_tree_duplicate_loop_to_edge_cfg,\n+\tslpeel_verify_cfg_after_peeling, slpeel_tree_peel_loop_to_edge):\n+\tUse loop_preheader_edge and loop->single_exit.  Do not call\n+\tflow_loop_scan.\n+\n 2005-03-01  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/arm.c (thumb_find_work_register): Check all of the"}, {"sha": "96175a8dbe1b601ef6d1c4c107c7fde94d66c5e6", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 14, "deletions": 228, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -41,11 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define LATCH_EDGE(E) (*(int *) (E)->aux)\n \n static void flow_loops_cfg_dump (const struct loops *, FILE *);\n-static void flow_loop_entry_edges_find (struct loop *);\n-static void flow_loop_exit_edges_find (struct loop *);\n static int flow_loop_nodes_find (basic_block, struct loop *);\n-static void flow_loop_pre_header_scan (struct loop *);\n-static basic_block flow_loop_pre_header_find (basic_block);\n static int flow_loop_level_compute (struct loop *);\n static void flow_loops_level_compute (struct loops *);\n static void establish_preds (struct loop *);\n@@ -135,27 +131,18 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n   fprintf (file, \";;\\n;; Loop %d:%s\\n\", loop->num,\n \t     loop->invalid ? \" invalid\" : \"\");\n \n-  fprintf (file, \";;  header %d, latch %d, pre-header %d\\n\",\n-\t   loop->header->index, loop->latch->index,\n-\t   loop->pre_header ? loop->pre_header->index : -1);\n+  fprintf (file, \";;  header %d, latch %d\\n\",\n+\t   loop->header->index, loop->latch->index);\n   fprintf (file, \";;  depth %d, level %d, outer %ld\\n\",\n \t   loop->depth, loop->level,\n \t   (long) (loop->outer ? loop->outer->num : -1));\n \n-  if (loop->pre_header_edges)\n-    flow_edge_list_print (\";;  pre-header edges\", loop->pre_header_edges,\n-\t\t\t  loop->num_pre_header_edges, file);\n-\n-  flow_edge_list_print (\";;  entry edges\", loop->entry_edges,\n-\t\t\tloop->num_entries, file);\n   fprintf (file, \";;  nodes:\");\n   bbs = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n     fprintf (file, \" %d\", bbs[i]->index);\n   free (bbs);\n   fprintf (file, \"\\n\");\n-  flow_edge_list_print (\";;  exit edges\", loop->exit_edges,\n-\t\t\tloop->num_exits, file);\n \n   if (loop_dump_aux)\n     loop_dump_aux (loop, file, verbose);\n@@ -194,12 +181,6 @@ flow_loops_dump (const struct loops *loops, FILE *file, void (*loop_dump_aux) (c\n void\n flow_loop_free (struct loop *loop)\n {\n-  if (loop->pre_header_edges)\n-    free (loop->pre_header_edges);\n-  if (loop->entry_edges)\n-    free (loop->entry_edges);\n-  if (loop->exit_edges)\n-    free (loop->exit_edges);\n   if (loop->pred)\n     free (loop->pred);\n   free (loop);\n@@ -238,95 +219,6 @@ flow_loops_free (struct loops *loops)\n     }\n }\n \n-/* Find the entry edges into the LOOP.  */\n-\n-static void\n-flow_loop_entry_edges_find (struct loop *loop)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  int num_entries;\n-\n-  num_entries = 0;\n-  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-    {\n-      if (flow_loop_outside_edge_p (loop, e))\n-\tnum_entries++;\n-    }\n-\n-  gcc_assert (num_entries);\n-\n-  loop->entry_edges = xmalloc (num_entries * sizeof (edge *));\n-\n-  num_entries = 0;\n-  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-    {\n-      if (flow_loop_outside_edge_p (loop, e))\n-\tloop->entry_edges[num_entries++] = e;\n-    }\n-\n-  loop->num_entries = num_entries;\n-}\n-\n-/* Find the exit edges from the LOOP.  */\n-\n-static void\n-flow_loop_exit_edges_find (struct loop *loop)\n-{\n-  edge e;\n-  basic_block node, *bbs;\n-  unsigned num_exits, i;\n-\n-  loop->exit_edges = NULL;\n-  loop->num_exits = 0;\n-\n-  /* Check all nodes within the loop to see if there are any\n-     successors not in the loop.  Note that a node may have multiple\n-     exiting edges.  */\n-  num_exits = 0;\n-  bbs = get_loop_body (loop);\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      edge_iterator ei;\n-      node = bbs[i];\n-      FOR_EACH_EDGE (e, ei, node->succs)\n-\t{\n-\t  basic_block dest = e->dest;\n-\n-\t  if (!flow_bb_inside_loop_p (loop, dest))\n-\t    num_exits++;\n-\t}\n-    }\n-\n-  if (! num_exits)\n-    {\n-      free (bbs);\n-      return;\n-    }\n-\n-  loop->exit_edges = xmalloc (num_exits * sizeof (edge *));\n-\n-  /* Store all exiting edges into an array.  */\n-  num_exits = 0;\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      edge_iterator ei;\n-      node = bbs[i];\n-      FOR_EACH_EDGE (e, ei, node->succs)\n-\t{\n-\t  basic_block dest = e->dest;\n-\n-\t  if (!flow_bb_inside_loop_p (loop, dest))\n-\t    {\n-\t      e->flags |= EDGE_LOOP_EXIT;\n-\t      loop->exit_edges[num_exits++] = e;\n-\t    }\n-      }\n-    }\n-  free (bbs);\n-  loop->num_exits = num_exits;\n-}\n-\n /* Find the nodes contained within the LOOP with header HEADER.\n    Return the number of nodes within the loop.  */\n \n@@ -434,77 +326,6 @@ mark_single_exit_loops (struct loops *loops)\n   loops->state |= LOOPS_HAVE_MARKED_SINGLE_EXITS;\n }\n \n-/* Find the root node of the loop pre-header extended basic block and\n-   the edges along the trace from the root node to the loop header.  */\n-\n-static void\n-flow_loop_pre_header_scan (struct loop *loop)\n-{\n-  int num;\n-  basic_block ebb;\n-  edge e;\n-\n-  loop->num_pre_header_edges = 0;\n-  if (loop->num_entries != 1)\n-    return;\n-\n-  ebb = loop->entry_edges[0]->src;\n-  if (ebb == ENTRY_BLOCK_PTR)\n-    return;\n-\n-  /* Count number of edges along trace from loop header to\n-     root of pre-header extended basic block.  Usually this is\n-     only one or two edges.  */\n-  for (num = 1;\n-       EDGE_PRED (ebb, 0)->src != ENTRY_BLOCK_PTR && EDGE_COUNT (ebb->preds) == 1;\n-       num++)\n-    ebb = EDGE_PRED (ebb, 0)->src;\n-\n-  loop->pre_header_edges = xmalloc (num * sizeof (edge));\n-  loop->num_pre_header_edges = num;\n-\n-  /* Store edges in order that they are followed.  The source of the first edge\n-     is the root node of the pre-header extended basic block and the\n-     destination of the last last edge is the loop header.  */\n-  for (e = loop->entry_edges[0]; num; e = EDGE_PRED (e->src, 0))\n-    loop->pre_header_edges[--num] = e;\n-}\n-\n-/* Return the block for the pre-header of the loop with header\n-   HEADER.  Return NULL if there is no pre-header.  */\n-\n-static basic_block\n-flow_loop_pre_header_find (basic_block header)\n-{\n-  basic_block pre_header;\n-  edge e;\n-  edge_iterator ei;\n-\n-  /* If block p is a predecessor of the header and is the only block\n-     that the header does not dominate, then it is the pre-header.  */\n-  pre_header = NULL;\n-  FOR_EACH_EDGE (e, ei, header->preds)\n-    {\n-      basic_block node = e->src;\n-\n-      if (node != ENTRY_BLOCK_PTR\n-\t  && ! dominated_by_p (CDI_DOMINATORS, node, header))\n-\t{\n-\t  if (pre_header == NULL)\n-\t    pre_header = node;\n-\t  else\n-\t    {\n-\t      /* There are multiple edges into the header from outside\n-\t\t the loop so there is no pre-header block.  */\n-\t      pre_header = NULL;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  return pre_header;\n-}\n-\n static void\n establish_preds (struct loop *loop)\n {\n@@ -602,39 +423,6 @@ flow_loops_level_compute (struct loops *loops)\n   flow_loop_level_compute (loops->tree_root);\n }\n \n-/* Scan a single natural loop specified by LOOP collecting information\n-   about it specified by FLAGS.  */\n-\n-int\n-flow_loop_scan (struct loop *loop, int flags)\n-{\n-  if (flags & LOOP_ENTRY_EDGES)\n-    {\n-      /* Find edges which enter the loop header.\n-\t Note that the entry edges should only\n-\t enter the header of a natural loop.  */\n-      flow_loop_entry_edges_find (loop);\n-    }\n-\n-  if (flags & LOOP_EXIT_EDGES)\n-    {\n-      /* Find edges which exit the loop.  */\n-      flow_loop_exit_edges_find (loop);\n-    }\n-\n-  if (flags & LOOP_PRE_HEADER)\n-    {\n-      /* Look to see if the loop has a pre-header node.  */\n-      loop->pre_header = flow_loop_pre_header_find (loop->header);\n-\n-      /* Find the blocks within the extended basic block of\n-\t the loop pre-header.  */\n-      flow_loop_pre_header_scan (loop);\n-    }\n-\n-  return 1;\n-}\n-\n /* A callback to update latch and header info for basic block JUMP created\n    by redirecting an edge.  */\n \n@@ -800,14 +588,12 @@ initialize_loops_parallel_p (struct loops *loops)\n }\n \n /* Find all the natural loops in the function and save in LOOPS structure and\n-   recalculate loop_depth information in basic block structures.  FLAGS\n-   controls which loop information is collected.  Return the number of natural\n-   loops found.  */\n+   recalculate loop_depth information in basic block structures.\n+   Return the number of natural loops found.  */\n \n int\n-flow_loops_find (struct loops *loops, int flags)\n+flow_loops_find (struct loops *loops)\n {\n-  int i;\n   int b;\n   int num_loops;\n   edge e;\n@@ -817,11 +603,6 @@ flow_loops_find (struct loops *loops, int flags)\n   basic_block header;\n   basic_block bb;\n \n-  /* This function cannot be repeatedly called with different\n-     flags to build up the loop information.  The loop tree\n-     must always be built if this function is called.  */\n-  gcc_assert (flags & LOOP_TREE);\n-\n   memset (loops, 0, sizeof *loops);\n \n   /* We are going to recount the maximum loop depth,\n@@ -963,10 +744,6 @@ flow_loops_find (struct loops *loops, int flags)\n \t loop.  */\n       flow_loops_level_compute (loops);\n \n-      /* Scan the loops.  */\n-      for (i = 1; i < num_loops; i++)\n-\tflow_loop_scan (loops->parray[i], flags);\n-\n       loops->num = num_loops;\n       initialize_loops_parallel_p (loops);\n     }\n@@ -1523,3 +1300,12 @@ loop_preheader_edge (const struct loop *loop)\n \n   return e;\n }\n+\n+/* Returns true if E is an exit of LOOP.  */\n+\n+bool\n+loop_exit_edge_p (const struct loop *loop, edge e)\n+{\n+  return (flow_bb_inside_loop_p (loop, e->src)\n+\t  && !flow_bb_inside_loop_p (loop, e->dest));\n+}"}, {"sha": "224d6cf18fb5cd103c1eeb62a352d63e958daaa2", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -69,9 +69,6 @@ struct loop\n   /* Basic block of loop latch.  */\n   basic_block latch;\n \n-  /* Basic block of loop preheader or NULL if it does not exist.  */\n-  basic_block pre_header;\n-\n   /* For loop unrolling/peeling decision.  */\n   struct lpt_decision lpt_decision;\n \n@@ -81,14 +78,6 @@ struct loop\n   /* Average number of executed insns per iteration.  */\n   unsigned av_ninsns;\n \n-  /* Array of edges along the preheader extended basic block trace.\n-     The source of the first edge is the root node of preheader\n-     extended basic block, if it exists.  */\n-  edge *pre_header_edges;\n-\n-  /* Number of edges along the pre_header extended basic block trace.  */\n-  int num_pre_header_edges;\n-\n   /* The first block in the loop.  This is not necessarily the same as\n      the loop header.  */\n   basic_block first;\n@@ -100,21 +89,6 @@ struct loop\n   /* Number of blocks contained within the loop.  */\n   unsigned num_nodes;\n \n-  /* Array of edges that enter the loop.  */\n-  edge *entry_edges;\n-\n-  /* Number of edges that enter the loop.  */\n-  int num_entries;\n-\n-  /* Array of edges that exit the loop.  */\n-  edge *exit_edges;\n-\n-  /* Number of edges that exit the loop.  */\n-  int num_exits;\n-\n-  /* Bitmap of blocks that dominate all exits of the loop.  */\n-  sbitmap exits_doms;\n-\n   /* The loop nesting depth.  */\n   int depth;\n \n@@ -254,23 +228,13 @@ struct loops\n \n extern struct loops *current_loops;\n \n-/* Flags for loop discovery.  */\n-\n-#define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */\n-#define LOOP_PRE_HEADER\t\t2\t/* Analyze loop preheader.  */\n-#define LOOP_ENTRY_EDGES\t4\t/* Find entry edges.  */\n-#define LOOP_EXIT_EDGES\t\t8\t/* Find exit edges.  */\n-#define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n-#define LOOP_ALL\t       15\t/* All of the above  */\n-\n /* Loop recognition.  */\n-extern int flow_loops_find (struct loops *, int flags);\n+extern int flow_loops_find (struct loops *);\n extern void flow_loops_free (struct loops *);\n extern void flow_loops_dump (const struct loops *, FILE *,\n \t\t\t     void (*)(const struct loop *, FILE *, int), int);\n extern void flow_loop_dump (const struct loop *, FILE *,\n \t\t\t    void (*)(const struct loop *, FILE *, int), int);\n-extern int flow_loop_scan (struct loop *, int);\n extern void flow_loop_free (struct loop *);\n void mark_irreducible_loops (struct loops *);\n void mark_single_exit_loops (struct loops *);\n@@ -288,6 +252,8 @@ extern unsigned tree_num_loop_insns (struct loop *);\n extern int num_loop_insns (struct loop *);\n extern int average_num_loop_insns (struct loop *);\n extern unsigned get_loop_level (const struct loop *);\n+extern bool loop_exit_edge_p (const struct loop *, edge);\n+extern void mark_loop_exit_edges (struct loops *);\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);"}, {"sha": "f40a48f8202b02df220f381b1aab2ead418b0748", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -565,3 +565,32 @@ global_cost_for_size (unsigned size, unsigned regs_used, unsigned n_uses)\n   return cost;\n }\n \n+/* Sets EDGE_LOOP_EXIT flag for all exits of LOOPS.  */\n+\n+void\n+mark_loop_exit_edges (struct loops *loops)\n+{\n+  basic_block bb;\n+  edge e;\n+ \n+  if (loops->num <= 1)\n+    return;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      edge_iterator ei;\n+\n+      /* Do not mark exits from the fake outermost loop.  */\n+      if (!bb->loop_father->outer)\n+\tcontinue;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (loop_exit_edge_p (bb->loop_father, e))\n+\t    e->flags |= EDGE_LOOP_EXIT;\n+\t  else\n+\t    e->flags &= ~EDGE_LOOP_EXIT;\n+\t}\n+    }\n+}\n+"}, {"sha": "022624f574f2a2e4bd2a9cee292090c4a4b8a84d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -1296,7 +1296,7 @@ create_loop_notes (void)\n \t\tNOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n #endif\n \n-  flow_loops_find (&loops, LOOP_TREE);\n+  flow_loops_find (&loops);\n   free_dominance_info (CDI_DOMINATORS);\n   if (loops.num > 1)\n     {"}, {"sha": "eb597d13f1fc4963c813c9c3ad7fedfa97a073ae", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -110,38 +110,7 @@ static int dead_or_predicable (basic_block, basic_block, basic_block,\n \t\t\t       basic_block, int);\n static void noce_emit_move_insn (rtx, rtx);\n static rtx block_has_only_trap (basic_block);\n-static void mark_loop_exit_edges (void);\n \f\n-/* Sets EDGE_LOOP_EXIT flag for all loop exits.  */\n-static void\n-mark_loop_exit_edges (void)\n-{\n-  struct loops loops;\n-  basic_block bb;\n-  edge e;\n-  \n-  flow_loops_find (&loops, LOOP_TREE);\n-  free_dominance_info (CDI_DOMINATORS);\n-  \n-  if (loops.num > 1)\n-    {\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      if (find_common_loop (bb->loop_father, e->dest->loop_father)\n-\t\t  != bb->loop_father)\n-\t\te->flags |= EDGE_LOOP_EXIT;\n-\t      else\n-\t\te->flags &= ~EDGE_LOOP_EXIT;\n-\t    }\n-\t}\n-    }\n-\n-  flow_loops_free (&loops);\n-}\n-\n /* Count the number of non-jump active insns in BB.  */\n \n static int\n@@ -3356,7 +3325,14 @@ if_convert (int x_life_data_ok)\n   if ((! targetm.cannot_modify_jumps_p ())\n       && (!flag_reorder_blocks_and_partition || !no_new_pseudos\n \t  || !targetm.have_named_sections))\n-    mark_loop_exit_edges ();\n+    {\n+      struct loops loops;\n+\n+      flow_loops_find (&loops);\n+      mark_loop_exit_edges (&loops);\n+      flow_loops_free (&loops);\n+      free_dominance_info (CDI_DOMINATORS);\n+    }\n \n   /* Compute postdominators if we think we'll use them.  */\n   if (HAVE_conditional_execution || life_data_ok)"}, {"sha": "909c28dd371c6e5389806edf954e79603410c1bd", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -2430,7 +2430,6 @@ perfect_nestify (struct loops *loops,\n \t}\n     }\n   free (bbs);\n-  flow_loops_find (loops, LOOP_ALL);\n   return perfect_nest_p (loop);\n }\n "}, {"sha": "b6a827ca2c68ab61b3038a91239b6d553f7ac5d1", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -56,7 +56,7 @@ loop_optimizer_init (FILE *dumpfile)\n \n   /* Find the loops.  */\n \n-  if (flow_loops_find (loops, LOOP_TREE) <= 1)\n+  if (flow_loops_find (loops) <= 1)\n     {\n       /* No loops.  */\n       flow_loops_free (loops);"}, {"sha": "c4f49d5629fafe3970ddcecbfb5c61580474c78a", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -1669,8 +1669,7 @@ analyze_insns_in_loop (struct loop *loop)\n     opt_info->loop_preheader = loop_preheader_edge (loop)->src;\n   \n   if (n_edges == 1\n-      && !(edges[0]->flags & EDGE_COMPLEX)\n-      && (edges[0]->flags & EDGE_LOOP_EXIT))\n+      && !(edges[0]->flags & EDGE_COMPLEX))\n     {\n       opt_info->loop_exit = loop_split_edge_with (edges[0], NULL_RTX);\n       can_apply = true;"}, {"sha": "65c183df383402358a2d8e2c5ba22dff5f7965ae", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -781,7 +781,7 @@ rest_of_handle_branch_prob (void)\n \n   /* Discover and record the loop depth at the head of each basic\n      block.  The loop infrastructure does the real job for us.  */\n-  flow_loops_find (&loops, LOOP_TREE);\n+  flow_loops_find (&loops);\n \n   if (dump_file)\n     flow_loops_dump (&loops, dump_file, NULL, 0);"}, {"sha": "bf594acfc92a392d0d71145c0b20d53f16698e62", "filename": "gcc/predict.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -583,13 +583,13 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n     {\n       basic_block bb, *bbs;\n       unsigned j;\n-      int exits;\n+      unsigned n_exits;\n       struct loop *loop = loops_info->parray[i];\n       struct niter_desc desc;\n       unsigned HOST_WIDE_INT niter;\n+      edge *exits;\n \n-      flow_loop_scan (loop, LOOP_EXIT_EDGES);\n-      exits = loop->num_exits;\n+      exits = get_loop_exit_edges (loop, &n_exits);\n \n       if (rtlsimpleloops)\n \t{\n@@ -615,11 +615,8 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t}\n       else\n \t{\n-\t  edge *exits;\n-\t  unsigned j, n_exits;\n \t  struct tree_niter_desc niter_desc;\n \n-\t  exits = get_loop_exit_edges (loop, &n_exits);\n \t  for (j = 0; j < n_exits; j++)\n \t    {\n \t      tree niter = NULL;\n@@ -647,8 +644,8 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t\t}\n \t    }\n \n-\t  free (exits);\n \t}\n+      free (exits);\n \n       bbs = get_loop_body (loop);\n \n@@ -690,7 +687,7 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t\t  (e, PRED_LOOP_EXIT,\n \t\t   (REG_BR_PROB_BASE\n \t\t    - predictor_info [(int) PRED_LOOP_EXIT].hitrate)\n-\t\t   / exits);\n+\t\t   / n_exits);\n \t}\n       \n       /* Free basic blocks from get_loop_body.  */\n@@ -1293,7 +1290,7 @@ tree_estimate_probability (void)\n   basic_block bb;\n   struct loops loops_info;\n \n-  flow_loops_find (&loops_info, LOOP_TREE);\n+  flow_loops_find (&loops_info);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     flow_loops_dump (&loops_info, dump_file, NULL, 0);\n "}, {"sha": "bb832d2461668d2d61b50e3b64b698918bd0e9d1", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -126,7 +126,7 @@ static void combine_blocks (struct loop *);\n static tree ifc_temp_var (tree, tree);\n static bool pred_blocks_visited_p (basic_block, bitmap *);\n static basic_block * get_loop_body_in_if_conv_order (const struct loop *loop);\n-static bool bb_with_exit_edge_p (basic_block);\n+static bool bb_with_exit_edge_p (struct loop *, basic_block);\n \n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n@@ -312,7 +312,7 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,\n   /* Now this conditional statement is redundant. Remove it.\n      But, do not remove exit condition! Update exit condition\n      using new condition.  */\n-  if (!bb_with_exit_edge_p (bb_for_stmt (stmt)))\n+  if (!bb_with_exit_edge_p (loop, bb_for_stmt (stmt)))\n     {\n       bsi_remove (bsi);\n       cond = NULL_TREE;\n@@ -405,7 +405,7 @@ if_convertible_modify_expr_p (struct loop *loop, basic_block bb, tree m_expr)\n \n   if (TREE_CODE (TREE_OPERAND (m_expr, 0)) != SSA_NAME\n       && bb != loop->header\n-      && !bb_with_exit_edge_p (bb))\n+      && !bb_with_exit_edge_p (loop, bb))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -534,8 +534,6 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n       return false;\n     }\n \n-  flow_loop_scan (loop, LOOP_ALL);\n-\n   /* If only one block, no need for if-conversion.  */\n   if (loop->num_nodes <= 2)\n     {\n@@ -545,7 +543,7 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n     }\n \n   /* More than one loop exit is too much to handle.  */\n-  if (loop->num_exits > 1)\n+  if (!loop->single_exit)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"multiple exits\\n\");\n@@ -557,8 +555,10 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n   /* If one of the loop header's edge is exit edge then do not apply\n      if-conversion.  */\n   FOR_EACH_EDGE (e, ei, loop->header->succs)\n-    if ( e->flags & EDGE_LOOP_EXIT)\n-      return false;\n+    {\n+      if (loop_exit_edge_p (loop, e))\n+\treturn false;\n+    }\n \n   compute_immediate_uses (TDFA_USE_OPS|TDFA_USE_VOPS, NULL);\n \n@@ -593,7 +593,7 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n \tif (!if_convertible_phi_p (loop, bb, phi))\n \t  return false;\n \n-      if (bb_with_exit_edge_p (bb))\n+      if (bb_with_exit_edge_p (loop, bb))\n \texit_bb_seen = true;\n     }\n \n@@ -874,7 +874,7 @@ combine_blocks (struct loop *loop)\n \n       bb = ifc_bbs[i];\n \n-      if (!exit_bb && bb_with_exit_edge_p (bb))\n+      if (!exit_bb && bb_with_exit_edge_p (loop, bb))\n \t  exit_bb = bb;\n \n       if (bb == exit_bb)\n@@ -890,11 +890,13 @@ combine_blocks (struct loop *loop)\n \t    {\n \t      /* Redirect non-exit edge to loop->latch.  */\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tif (!(e->flags & EDGE_LOOP_EXIT))\n-\t\t  {\n-\t\t    redirect_edge_and_branch (e, loop->latch);\n-\t\t    set_immediate_dominator (CDI_DOMINATORS, loop->latch, bb);\n-\t\t  }\n+\t\t{\n+\t\t  if (!loop_exit_edge_p (loop, e))\n+\t\t    {\n+\t\t      redirect_edge_and_branch (e, loop->latch);\n+\t\t      set_immediate_dominator (CDI_DOMINATORS, loop->latch, bb);\n+\t\t    }\n+\t\t}\n \t    }\n \t  continue;\n \t}\n@@ -1056,17 +1058,17 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   return blocks;\n }\n \n-/* Return true if one of the basic block BB edge is loop exit.  */\n+/* Return true if one of the basic block BB edge is exit of LOOP.  */\n \n static bool\n-bb_with_exit_edge_p (basic_block bb)\n+bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n   bool exit_edge_found = false;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_LOOP_EXIT)\n+    if (loop_exit_edge_p (loop, e))\n       {\n \texit_edge_found = true;\n \tbreak;"}, {"sha": "0333304612928aec7cb64f79d95e3a4138f63892", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -277,9 +277,8 @@ linear_transform_loops (struct loops *loops)\n       depth = 1;\n       for (temp = loop_nest->inner; temp; temp = temp->inner)\n \t{\n-\t  flow_loop_scan (temp, LOOP_ALL);\n \t  /* If we have a sibling loop or multiple exit edges, jump ship.  */\n-\t  if (temp->next || temp->num_exits != 1)\n+\t  if (temp->next || !temp->single_exit)\n \t    {\n \t      problem = true;\n \t      break;"}, {"sha": "4736f1b4cfa03a1b866f804683ec523f589b636f", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -462,7 +462,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n                      \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n-      if (!slpeel_can_duplicate_loop_p (loop, loop->exit_edges[0]))\n+      if (!slpeel_can_duplicate_loop_p (loop, loop->single_exit))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n                                      LOOP_LOC (loop_vinfo)))\n@@ -2265,7 +2265,6 @@ vect_analyze_loop_form (struct loop *loop)\n   loop_vec_info loop_vinfo;\n   tree loop_cond;\n   tree number_of_iterations = NULL;\n-  bool rescan = false;\n   LOC loop_loc;\n \n   loop_loc = find_loop_location (loop);\n@@ -2282,8 +2281,7 @@ vect_analyze_loop_form (struct loop *loop)\n   \n   if (!loop->single_exit \n       || loop->num_nodes != 2\n-      || EDGE_COUNT (loop->header->preds) != 2\n-      || loop->num_entries != 1)\n+      || EDGE_COUNT (loop->header->preds) != 2)\n     {\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n         {\n@@ -2293,8 +2291,6 @@ vect_analyze_loop_form (struct loop *loop)\n             fprintf (vect_dump, \"not vectorized: too many BBs in loop.\");\n           else if (EDGE_COUNT (loop->header->preds) != 2)\n             fprintf (vect_dump, \"not vectorized: too many incoming edges.\");\n-          else if (loop->num_entries != 1)\n-            fprintf (vect_dump, \"not vectorized: too many entries.\");\n         }\n \n       return NULL;\n@@ -2311,16 +2307,6 @@ vect_analyze_loop_form (struct loop *loop)\n       return NULL;\n     }\n \n-  /* Make sure we have a preheader basic block.  */\n-  if (!loop->pre_header || EDGE_COUNT (loop->pre_header->succs) != 1)\n-    {\n-      edge e = loop_preheader_edge (loop);\n-      loop_split_edge_with (e, NULL);\n-      if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n-\tfprintf (vect_dump, \"split preheader edge.\");\n-      rescan = true;\n-    }\n-    \n   /* Make sure there exists a single-predecessor exit bb:  */\n   if (EDGE_COUNT (loop->single_exit->dest->preds) != 1)\n     {\n@@ -2330,7 +2316,6 @@ vect_analyze_loop_form (struct loop *loop)\n \t  loop_split_edge_with (e, NULL);\n \t  if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n \t    fprintf (vect_dump, \"split exit edge.\");\n-\t  rescan = true;\n \t}\n       else\n \t{\n@@ -2339,13 +2324,6 @@ vect_analyze_loop_form (struct loop *loop)\n \t  return NULL;\n \t}\n     }\n-    \n-  if (rescan)\n-    {\n-      flow_loop_scan (loop, LOOP_ALL);\n-      /* Flow loop scan does not update loop->single_exit field.  */\n-      loop->single_exit = loop->exit_edges[0];\n-    }\n \n   if (empty_block_p (loop->header))\n     {"}, {"sha": "1935a738f71d3465dfe807398c996ddd79609d63", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -1315,7 +1315,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \t\t\t\t  edge update_e)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block exit_bb = loop->exit_edges[0]->dest;\n+  basic_block exit_bb = loop->single_exit->dest;\n   tree phi, phi1;\n   basic_block update_bb = update_e->dest;\n \n@@ -1398,6 +1398,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *new_loop;\n   edge update_e;\n+  basic_block preheader;\n #ifdef ENABLE_CHECKING\n   int loop_num;\n #endif\n@@ -1413,14 +1414,10 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   vect_generate_tmps_on_preheader (loop_vinfo, &ni_name,\n \t\t\t\t   &ratio_mult_vf_name, ratio);\n \n-  /* Update loop info.  */\n-  loop->pre_header = loop_preheader_edge (loop)->src;\n-  loop->pre_header_edges[0] = loop_preheader_edge (loop);\n-\n #ifdef ENABLE_CHECKING\n   loop_num  = loop->num; \n #endif\n-  new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, loop->exit_edges[0],\n+  new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, loop->single_exit,\n \t\t\t\t\t    ratio_mult_vf_name, ni_name, false);\n #ifdef ENABLE_CHECKING\n   gcc_assert (new_loop);\n@@ -1434,10 +1431,11 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n      is a bb after NEW_LOOP, where these IVs are not used.  Find the edge that\n      is on the path where the LOOP IVs are used and need to be updated.  */\n \n-  if (EDGE_PRED (new_loop->pre_header, 0)->src == loop->exit_edges[0]->dest)\n-    update_e = EDGE_PRED (new_loop->pre_header, 0);\n+  preheader = loop_preheader_edge (new_loop)->src;\n+  if (EDGE_PRED (preheader, 0)->src == loop->single_exit->dest)\n+    update_e = EDGE_PRED (preheader, 0);\n   else\n-    update_e = EDGE_PRED (new_loop->pre_header, 1);\n+    update_e = EDGE_PRED (preheader, 1);\n \n   /* Update IVs of original loop as if they were advanced \n      by ratio_mult_vf_name steps.  */"}, {"sha": "7f8d84ae21fbbfd4fb3cec08158be79c385b4784", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70388d9433b275054b72014b54f387933f1d8d02/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=70388d9433b275054b72014b54f387933f1d8d02", "patch": "@@ -373,7 +373,7 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n   tree def;\n   edge orig_loop_latch = loop_latch_edge (orig_loop);\n   edge orig_entry_e = loop_preheader_edge (orig_loop);\n-  edge new_loop_exit_e = new_loop->exit_edges[0];\n+  edge new_loop_exit_e = new_loop->single_exit;\n   edge new_loop_entry_e = loop_preheader_edge (new_loop);\n   edge entry_arg_e = (after ? orig_loop_latch : orig_entry_e);\n \n@@ -518,8 +518,9 @@ slpeel_update_phi_nodes_for_guard (edge guard_edge,\n       if (entry_phis)\n         {\n           loop_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi,\n-                                            EDGE_SUCC (loop->latch, 0));\n-          guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, loop->entry_edges[0]);\n+                                            loop_latch_edge (loop));\n+          guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi,\n+\t\t\t\t\t     loop_preheader_edge (loop));\n         }\n       else /* exit phis */\n         {\n@@ -544,7 +545,7 @@ slpeel_update_phi_nodes_for_guard (edge guard_edge,\n               loop_arg = orig_def;\n             }\n         }\n-      add_phi_arg (new_phi, loop_arg, loop->exit_edges[0]);\n+      add_phi_arg (new_phi, loop_arg, loop->single_exit);\n       add_phi_arg (new_phi, guard_arg, guard_edge);\n \n       /* 3. Update phi in successor block.  */\n@@ -567,7 +568,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n {\n   tree indx_before_incr, indx_after_incr, cond_stmt, cond;\n   tree orig_cond;\n-  edge exit_edge = loop->exit_edges[0];\n+  edge exit_edge = loop->single_exit;\n   block_stmt_iterator loop_cond_bsi;\n   block_stmt_iterator incr_bsi;\n   bool insert_after;\n@@ -636,7 +637,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   basic_block exit_dest; \n   tree phi, phi_arg;\n \n-  at_exit = (e == loop->exit_edges[0]); \n+  at_exit = (e == loop->single_exit); \n   if (!at_exit && e != loop_preheader_edge (loop))\n     return NULL;\n \n@@ -657,20 +658,21 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n       return NULL;\n     }\n \n-  exit_dest = loop->exit_edges[0]->dest;\n+  exit_dest = loop->single_exit->dest;\n   was_imm_dom = (get_immediate_dominator (CDI_DOMINATORS, \n \t\t\t\t\t  exit_dest) == loop->header ? \n \t\t true : false);\n \n   new_bbs = xmalloc (sizeof (basic_block) * loop->num_nodes);\n \n-  copy_bbs (bbs, loop->num_nodes, new_bbs, NULL, 0, NULL, NULL);\n+  copy_bbs (bbs, loop->num_nodes, new_bbs,\n+\t    &loop->single_exit, 1, &new_loop->single_exit, NULL);\n \n   /* Duplicating phi args at exit bbs as coming \n      also from exit of duplicated loop.  */\n   for (phi = phi_nodes (exit_dest); phi; phi = PHI_CHAIN (phi))\n     {\n-      phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->exit_edges[0]);\n+      phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->single_exit);\n       if (phi_arg)\n \t{\n \t  edge new_loop_exit_edge;\n@@ -720,8 +722,6 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n       set_immediate_dominator (CDI_DOMINATORS, new_loop->header, preheader);\n     }\n \n-  flow_loop_scan (new_loop, LOOP_ALL);\n-  flow_loop_scan (loop, LOOP_ALL);  \n   free (new_bbs);\n   free (bbs);\n \n@@ -772,7 +772,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n bool\n slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n {\n-  edge exit_e = loop->exit_edges [0];\n+  edge exit_e = loop->single_exit;\n   edge entry_e = loop_preheader_edge (loop);\n   tree orig_cond = get_loop_exit_condition (loop);\n   block_stmt_iterator loop_exit_bsi = bsi_last (exit_e->src);\n@@ -786,8 +786,7 @@ slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n       || !loop->outer\n       || loop->num_nodes != 2\n       || !empty_block_p (loop->latch)\n-      || loop->num_exits != 1\n-      || loop->num_entries != 1\n+      || !loop->single_exit\n       /* Verify that new loop exit condition can be trivially modified.  */\n       || (!orig_cond || orig_cond != bsi_stmt (loop_exit_bsi))\n       || (e != exit_e && e != entry_e))\n@@ -801,8 +800,8 @@ void\n slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n                                  struct loop *second_loop)\n {\n-  basic_block loop1_exit_bb = first_loop->exit_edges[0]->dest;\n-  basic_block loop2_entry_bb = second_loop->pre_header;\n+  basic_block loop1_exit_bb = first_loop->single_exit->dest;\n+  basic_block loop2_entry_bb = loop_preheader_edge (second_loop)->src;\n   basic_block loop1_entry_bb = loop_preheader_edge (first_loop)->src;\n \n   /* A guard that controls whether the second_loop is to be executed or skipped\n@@ -812,7 +811,6 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n    */\n   gcc_assert (EDGE_COUNT (loop1_exit_bb->succs) == 2);\n    \n-   \n   /* 1. Verify that one of the successors of first_loopt->exit is the preheader\n         of second_loop.  */\n    \n@@ -880,7 +878,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   basic_block bb_before_second_loop, bb_after_second_loop;\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n-  edge exit_e = loop->exit_edges [0];\n+  edge exit_e = loop->single_exit;\n   LOC loop_loc;\n   \n   if (!slpeel_can_duplicate_loop_p (loop, e))\n@@ -961,10 +959,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n \n   bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n   add_bb_to_loop (bb_before_first_loop, first_loop->outer);\n-  bb_before_second_loop = split_edge (first_loop->exit_edges[0]);\n+  bb_before_second_loop = split_edge (first_loop->single_exit);\n   add_bb_to_loop (bb_before_second_loop, first_loop->outer);\n-  flow_loop_scan (first_loop, LOOP_ALL);\n-  flow_loop_scan (second_loop, LOOP_ALL);\n \n   pre_condition =\n         build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node);\n@@ -1000,12 +996,10 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n         orig_exit_bb:\n    */\n \n-  bb_between_loops = split_edge (first_loop->exit_edges[0]);\n+  bb_between_loops = split_edge (first_loop->single_exit);\n   add_bb_to_loop (bb_between_loops, first_loop->outer);\n-  bb_after_second_loop = split_edge (second_loop->exit_edges[0]);\n+  bb_after_second_loop = split_edge (second_loop->single_exit);\n   add_bb_to_loop (bb_after_second_loop, second_loop->outer);\n-  flow_loop_scan (first_loop, LOOP_ALL);\n-  flow_loop_scan (second_loop, LOOP_ALL);\n \n   pre_condition = build2 (EQ_EXPR, boolean_type_node, first_niters, niters);\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n@@ -1014,8 +1008,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n                                      second_loop == new_loop);\n \n   /* Flow loop scan does not update loop->single_exit field.  */\n-  first_loop->single_exit = first_loop->exit_edges[0];\n-  second_loop->single_exit = second_loop->exit_edges[0];\n+  first_loop->single_exit = first_loop->single_exit;\n+  second_loop->single_exit = second_loop->single_exit;\n \n   /* 4. Make first-loop iterate FIRST_NITERS times, if requested.\n    */"}]}