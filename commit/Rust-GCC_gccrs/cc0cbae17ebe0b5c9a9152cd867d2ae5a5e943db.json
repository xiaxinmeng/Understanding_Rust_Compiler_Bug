{"sha": "cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwY2JhZTE3ZWJlMGI1YzlhOTE1MmNkODY3ZDJhZTVhNWU5NDNkYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "2000-10-05T23:24:18Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-10-05T23:24:18Z"}, "message": "Fix IA-64 REG_LIBCALL dangling reference.\n\n\t* function.c (fixup_var_refs_1, case SET): When gen_move_insn returns a\n\tSEQUENCE, call emit_insn_before, copy PATTERN and REG_NOTES of last\n\tsequence insn to INSN, and delete last sequence insn.\n\nFrom-SVN: r36735", "tree": {"sha": "c4fb33b2bcd24213c4329edef7116967bd34aa25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4fb33b2bcd24213c4329edef7116967bd34aa25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db/comments", "author": null, "committer": null, "parents": [{"sha": "f5fa9a5bd08d383e14f920c38f69d15f456e1aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5fa9a5bd08d383e14f920c38f69d15f456e1aeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5fa9a5bd08d383e14f920c38f69d15f456e1aeb"}], "stats": {"total": 50, "additions": 40, "deletions": 10}, "files": [{"sha": "bf8dae3e7f3c63b492c6ce2684edfa0067b6bf58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db", "patch": "@@ -1,3 +1,9 @@\n+2000-10-05  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* function.c (fixup_var_refs_1, case SET): When gen_move_insn returns a\n+\tSEQUENCE, call emit_insn_before, copy PATTERN and REG_NOTES of last\n+\tsequence insn to INSN, and delete last sequence insn.\n+\n 2000-10-05  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* gcc.c (main): Include generated configargs.h header"}, {"sha": "f58141092110b3ba32a873835ba1758d38255827", "filename": "gcc/function.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cc0cbae17ebe0b5c9a9152cd867d2ae5a5e943db", "patch": "@@ -2324,7 +2324,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    && GET_MODE (var) == promoted_mode\n \t    && x == single_set (insn))\n \t  {\n-\t    rtx pat;\n+\t    rtx pat, last;\n \n \t    replacement = find_fixup_replacement (replacements, SET_SRC (x));\n \t    if (replacement->new)\n@@ -2350,10 +2350,22 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n \t    if (GET_CODE (pat) == SEQUENCE)\n \t      {\n-\t\temit_insn_after (pat, insn);\n-\t\tPUT_CODE (insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t\tlast = emit_insn_before (pat, insn);\n+\n+\t\t/* INSN might have REG_RETVAL or other important notes, so\n+\t\t   we need to store the pattern of the last insn in the\n+\t\t   sequence into INSN similarly to the normal case.  LAST\n+\t\t   should not have REG_NOTES, but we allow them if INSN has\n+\t\t   no REG_NOTES.  */\n+\t\tif (REG_NOTES (last) && REG_NOTES (insn))\n+\t\t  abort ();\n+\t\tif (REG_NOTES (last))\n+\t\t  REG_NOTES (insn) = REG_NOTES (last);\n+\t\tPATTERN (insn) = PATTERN (last);\n+\n+\t\tPUT_CODE (last, NOTE);\n+\t\tNOTE_LINE_NUMBER (last) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (last) = 0;\n \t      }\n \t    else\n \t      PATTERN (insn) = pat;\n@@ -2370,7 +2382,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    && GET_MODE (var) == promoted_mode\n \t    && x == single_set (insn))\n \t  {\n-\t    rtx pat;\n+\t    rtx pat, last;\n \n \t    if (GET_CODE (SET_DEST (x)) == SUBREG)\n \t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn, 0);\n@@ -2383,10 +2395,22 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n \t    if (GET_CODE (pat) == SEQUENCE)\n \t      {\n-\t\temit_insn_after (pat, insn);\n-\t\tPUT_CODE (insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t\tlast = emit_insn_before (pat, insn);\n+\n+\t\t/* INSN might have REG_RETVAL or other important notes, so\n+\t\t   we need to store the pattern of the last insn in the\n+\t\t   sequence into INSN similarly to the normal case.  LAST\n+\t\t   should not have REG_NOTES, but we allow them if INSN has\n+\t\t   no REG_NOTES.  */\n+\t\tif (REG_NOTES (last) && REG_NOTES (insn))\n+\t\t  abort ();\n+\t\tif (REG_NOTES (last))\n+\t\t  REG_NOTES (insn) = REG_NOTES (last);\n+\t\tPATTERN (insn) = PATTERN (last);\n+\n+\t\tPUT_CODE (last, NOTE);\n+\t\tNOTE_LINE_NUMBER (last) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (last) = 0;\n \t      }\n \t    else\n \t      PATTERN (insn) = pat;"}]}