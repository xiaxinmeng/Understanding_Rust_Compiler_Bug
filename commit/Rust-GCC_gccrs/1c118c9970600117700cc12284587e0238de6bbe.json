{"sha": "1c118c9970600117700cc12284587e0238de6bbe", "node_id": "C_kwDOANBUbNoAKDFjMTE4Yzk5NzA2MDAxMTc3MDBjYzEyMjg0NTg3ZTAyMzhkZTZiYmU", "commit": {"author": {"name": "Thomas Neumann", "email": "tneumann@users.sourceforge.net", "date": "2022-11-22T07:41:54Z"}, "committer": {"name": "Thomas Neumann", "email": "tneumann@users.sourceforge.net", "date": "2022-12-16T23:48:16Z"}, "message": "speed up end_fde_sort using radix sort\n\nWhen registering a dynamic unwinding frame the fde list is sorted.\nPreviously, we split the list into a sorted and an unsorted part,\nsorted the later using heap sort, and merged both. That can be\nquite slow due to the large number of (expensive) comparisons.\n\nThis patch replaces that logic with a radix sort instead. The\nradix sort uses the same amount of memory as the old logic,\nusing the second list as auxiliary space, and it includes two\ntechniques to speed up sorting: First, it computes the pointer\naddresses for blocks of values, reducing the decoding overhead.\nAnd it recognizes when the data has reached a sorted state,\nallowing for early termination. When running out of memory\nwe fall back to pure heap sort, as before.\n\nFor this test program\n\n\\#include <cstdio>\nint main(int argc, char** argv) {\n     return 0;\n}\n\ncompiled with g++ -O -o hello -static hello.c we get with\nperf stat -r 200 on a 5950X the following performance numbers:\n\nold logic:\n\n              0,20 msec task-clock\n           930.834      cycles\n         3.079.765      instructions\n        0,00030478 +- 0,00000237 seconds time elapsed\n\nnew logic:\n\n              0,10 msec task-clock\n           473.269      cycles\n         1.239.077      instructions\n        0,00021119 +- 0,00000168 seconds time elapsed\n\nlibgcc/ChangeLog:\n\t* unwind-dw2-fde.c: Use radix sort instead of split+sort+merge.", "tree": {"sha": "801ed7b0969d0169e0e0c0db5d9a0b848874add2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/801ed7b0969d0169e0e0c0db5d9a0b848874add2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c118c9970600117700cc12284587e0238de6bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c118c9970600117700cc12284587e0238de6bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c118c9970600117700cc12284587e0238de6bbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c118c9970600117700cc12284587e0238de6bbe/comments", "author": {"login": "neumannt", "id": 25097991, "node_id": "MDQ6VXNlcjI1MDk3OTkx", "avatar_url": "https://avatars.githubusercontent.com/u/25097991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumannt", "html_url": "https://github.com/neumannt", "followers_url": "https://api.github.com/users/neumannt/followers", "following_url": "https://api.github.com/users/neumannt/following{/other_user}", "gists_url": "https://api.github.com/users/neumannt/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumannt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumannt/subscriptions", "organizations_url": "https://api.github.com/users/neumannt/orgs", "repos_url": "https://api.github.com/users/neumannt/repos", "events_url": "https://api.github.com/users/neumannt/events{/privacy}", "received_events_url": "https://api.github.com/users/neumannt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "neumannt", "id": 25097991, "node_id": "MDQ6VXNlcjI1MDk3OTkx", "avatar_url": "https://avatars.githubusercontent.com/u/25097991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumannt", "html_url": "https://github.com/neumannt", "followers_url": "https://api.github.com/users/neumannt/followers", "following_url": "https://api.github.com/users/neumannt/following{/other_user}", "gists_url": "https://api.github.com/users/neumannt/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumannt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumannt/subscriptions", "organizations_url": "https://api.github.com/users/neumannt/orgs", "repos_url": "https://api.github.com/users/neumannt/repos", "events_url": "https://api.github.com/users/neumannt/events{/privacy}", "received_events_url": "https://api.github.com/users/neumannt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e51c5d5aa27d613750cadbdc1bf5b45da62dca25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51c5d5aa27d613750cadbdc1bf5b45da62dca25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51c5d5aa27d613750cadbdc1bf5b45da62dca25"}], "stats": {"total": 234, "additions": 134, "deletions": 100}, "files": [{"sha": "8d2eaaa6bc4cb6d221636c6fb90586ab48d95782", "filename": "libgcc/unwind-dw2-fde.c", "status": "modified", "additions": 134, "deletions": 100, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c118c9970600117700cc12284587e0238de6bbe/libgcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c118c9970600117700cc12284587e0238de6bbe/libgcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2-fde.c?ref=1c118c9970600117700cc12284587e0238de6bbe", "patch": "@@ -456,22 +456,52 @@ fde_mixed_encoding_compare (struct object *ob, const fde *x, const fde *y)\n \n typedef int (*fde_compare_t) (struct object *, const fde *, const fde *);\n \n+// The extractor functions compute the pointer values for a block of\n+// fdes. The block processing hides the call overhead.\n \n-/* This is a special mix of insertion sort and heap sort, optimized for\n-   the data sets that actually occur. They look like\n-   101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.\n-   I.e. a linearly increasing sequence (coming from functions in the text\n-   section), with additionally a few unordered elements (coming from functions\n-   in gnu_linkonce sections) whose values are higher than the values in the\n-   surrounding linear sequence (but not necessarily higher than the values\n-   at the end of the linear sequence!).\n-   The worst-case total run time is O(N) + O(n log (n)), where N is the\n-   total number of FDEs and n is the number of erratic ones.  */\n+static void\n+fde_unencoded_extract (struct object *ob __attribute__ ((unused)),\n+\t\t       _Unwind_Ptr *target, const fde **x, int count)\n+{\n+  for (int index = 0; index < count; ++index)\n+    memcpy (target + index, x[index]->pc_begin, sizeof (_Unwind_Ptr));\n+}\n+\n+static void\n+fde_single_encoding_extract (struct object *ob, _Unwind_Ptr *target,\n+\t\t\t     const fde **x, int count)\n+{\n+  _Unwind_Ptr base;\n+\n+  base = base_from_object (ob->s.b.encoding, ob);\n+  for (int index = 0; index < count; ++index)\n+    read_encoded_value_with_base (ob->s.b.encoding, base, x[index]->pc_begin,\n+\t\t\t\t  target + index);\n+}\n+\n+static void\n+fde_mixed_encoding_extract (struct object *ob, _Unwind_Ptr *target,\n+\t\t\t    const fde **x, int count)\n+{\n+  for (int index = 0; index < count; ++index)\n+    {\n+      int encoding = get_fde_encoding (x[index]);\n+      read_encoded_value_with_base (encoding, base_from_object (encoding, ob),\n+\t\t\t\t    x[index]->pc_begin, target + index);\n+    }\n+}\n+\n+typedef void (*fde_extractor_t) (struct object *, _Unwind_Ptr *, const fde **,\n+\t\t\t\t int);\n+\n+// Data is is sorted using radix sort if possible, using an temporary\n+// auxiliary data structure of the same size as the input. When running\n+// out of memory do in-place heap sort.\n \n struct fde_accumulator\n {\n   struct fde_vector *linear;\n-  struct fde_vector *erratic;\n+  struct fde_vector *aux;\n };\n \n static inline int\n@@ -485,8 +515,8 @@ start_fde_sort (struct fde_accumulator *accu, size_t count)\n   if ((accu->linear = malloc (size)))\n     {\n       accu->linear->count = 0;\n-      if ((accu->erratic = malloc (size)))\n-\taccu->erratic->count = 0;\n+      if ((accu->aux = malloc (size)))\n+\taccu->aux->count = 0;\n       return 1;\n     }\n   else\n@@ -500,59 +530,6 @@ fde_insert (struct fde_accumulator *accu, const fde *this_fde)\n     accu->linear->array[accu->linear->count++] = this_fde;\n }\n \n-/* Split LINEAR into a linear sequence with low values and an erratic\n-   sequence with high values, put the linear one (of longest possible\n-   length) into LINEAR and the erratic one into ERRATIC. This is O(N).\n-\n-   Because the longest linear sequence we are trying to locate within the\n-   incoming LINEAR array can be interspersed with (high valued) erratic\n-   entries.  We construct a chain indicating the sequenced entries.\n-   To avoid having to allocate this chain, we overlay it onto the space of\n-   the ERRATIC array during construction.  A final pass iterates over the\n-   chain to determine what should be placed in the ERRATIC array, and\n-   what is the linear sequence.  This overlay is safe from aliasing.  */\n-\n-static inline void\n-fde_split (struct object *ob, fde_compare_t fde_compare,\n-\t   struct fde_vector *linear, struct fde_vector *erratic)\n-{\n-  static const fde *marker;\n-  size_t count = linear->count;\n-  const fde *const *chain_end = &marker;\n-  size_t i, j, k;\n-\n-  /* This should optimize out, but it is wise to make sure this assumption\n-     is correct. Should these have different sizes, we cannot cast between\n-     them and the overlaying onto ERRATIC will not work.  */\n-  gcc_assert (sizeof (const fde *) == sizeof (const fde **));\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      const fde *const *probe;\n-\n-      for (probe = chain_end;\n-\t   probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;\n-\t   probe = chain_end)\n-\t{\n-\t  chain_end = (const fde *const*) erratic->array[probe - linear->array];\n-\t  erratic->array[probe - linear->array] = NULL;\n-\t}\n-      erratic->array[i] = (const fde *) chain_end;\n-      chain_end = &linear->array[i];\n-    }\n-\n-  /* Each entry in LINEAR which is part of the linear sequence we have\n-     discovered will correspond to a non-NULL entry in the chain we built in\n-     the ERRATIC array.  */\n-  for (i = j = k = 0; i < count; i++)\n-    if (erratic->array[i])\n-      linear->array[j++] = linear->array[i];\n-    else\n-      erratic->array[k++] = linear->array[i];\n-  linear->count = j;\n-  erratic->count = k;\n-}\n-\n #define SWAP(x,y) do { const fde * tmp = x; x = y; y = tmp; } while (0)\n \n /* Convert a semi-heap to a heap.  A semi-heap is a heap except possibly\n@@ -615,59 +592,116 @@ frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n #undef SWAP\n }\n \n-/* Merge V1 and V2, both sorted, and put the result into V1.  */\n+// Radix sort data in V1 using V2 as aux memory. Runtime O(n).\n static inline void\n-fde_merge (struct object *ob, fde_compare_t fde_compare,\n-\t   struct fde_vector *v1, struct fde_vector *v2)\n+fde_radixsort (struct object *ob, fde_extractor_t fde_extractor,\n+\t       struct fde_vector *v1, struct fde_vector *v2)\n {\n-  size_t i1, i2;\n-  const fde * fde2;\n-\n-  i2 = v2->count;\n-  if (i2 > 0)\n+#define FANOUTBITS 8\n+#define FANOUT (1 << FANOUTBITS)\n+#define BLOCKSIZE 128\n+  const unsigned rounds\n+    = (__CHAR_BIT__ * sizeof (_Unwind_Ptr) + FANOUTBITS - 1) / FANOUTBITS;\n+  const fde **a1 = v1->array, **a2 = v2->array;\n+  _Unwind_Ptr ptrs[BLOCKSIZE + 1];\n+  unsigned n = v1->count;\n+  for (unsigned round = 0; round != rounds; ++round)\n     {\n-      i1 = v1->count;\n-      do\n+      unsigned counts[FANOUT] = {0};\n+      unsigned violations = 0;\n+\n+      // Count the number of elements per bucket and check if we are already\n+      // sorted.\n+      _Unwind_Ptr last = 0;\n+      for (unsigned i = 0; i < n;)\n+\t{\n+\t  unsigned chunk = ((n - i) <= BLOCKSIZE) ? (n - i) : BLOCKSIZE;\n+\t  fde_extractor (ob, ptrs + 1, a1 + i, chunk);\n+\t  ptrs[0] = last;\n+\t  for (unsigned j = 0; j < chunk; ++j)\n+\t    {\n+\t      unsigned b = (ptrs[j + 1] >> (round * FANOUTBITS)) & (FANOUT - 1);\n+\t      counts[b]++;\n+\t      // Use summation instead of an if to eliminate branches.\n+\t      violations += ptrs[j + 1] < ptrs[j];\n+\t    }\n+\t  i += chunk;\n+\t  last = ptrs[chunk];\n+\t}\n+\n+      // Stop if we are already sorted.\n+      if (!violations)\n+\t{\n+\t  // The sorted data is in a1 now.\n+\t  a2 = a1;\n+\t  break;\n+\t}\n+\n+      // Compute the prefix sum.\n+      unsigned sum = 0;\n+      for (unsigned i = 0; i != FANOUT; ++i)\n+\t{\n+\t  unsigned s = sum;\n+\t  sum += counts[i];\n+\t  counts[i] = s;\n+\t}\n+\n+      // Place all elements.\n+      for (unsigned i = 0; i < n;)\n \t{\n-\t  i2--;\n-\t  fde2 = v2->array[i2];\n-\t  while (i1 > 0 && fde_compare (ob, v1->array[i1-1], fde2) > 0)\n+\t  unsigned chunk = ((n - i) <= BLOCKSIZE) ? (n - i) : BLOCKSIZE;\n+\t  fde_extractor (ob, ptrs, a1 + i, chunk);\n+\t  for (unsigned j = 0; j < chunk; ++j)\n \t    {\n-\t      v1->array[i1+i2] = v1->array[i1-1];\n-\t      i1--;\n+\t      unsigned b = (ptrs[j] >> (round * FANOUTBITS)) & (FANOUT - 1);\n+\t      a2[counts[b]++] = a1[i + j];\n \t    }\n-\t  v1->array[i1+i2] = fde2;\n+\t  i += chunk;\n \t}\n-      while (i2 > 0);\n-      v1->count += v2->count;\n+\n+      // Swap a1 and a2.\n+      const fde **tmp = a1;\n+      a1 = a2;\n+      a2 = tmp;\n     }\n+#undef BLOCKSIZE\n+#undef FANOUT\n+#undef FANOUTBITS\n+\n+  // The data is in a2 now, move in place if needed.\n+  if (a2 != v1->array)\n+    memcpy (v1->array, a2, sizeof (const fde *) * n);\n }\n \n static inline void\n end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)\n {\n-  fde_compare_t fde_compare;\n-\n   gcc_assert (!accu->linear || accu->linear->count == count);\n \n-  if (ob->s.b.mixed_encoding)\n-    fde_compare = fde_mixed_encoding_compare;\n-  else if (ob->s.b.encoding == DW_EH_PE_absptr)\n-    fde_compare = fde_unencoded_compare;\n-  else\n-    fde_compare = fde_single_encoding_compare;\n-\n-  if (accu->erratic)\n+  if (accu->aux)\n     {\n-      fde_split (ob, fde_compare, accu->linear, accu->erratic);\n-      gcc_assert (accu->linear->count + accu->erratic->count == count);\n-      frame_heapsort (ob, fde_compare, accu->erratic);\n-      fde_merge (ob, fde_compare, accu->linear, accu->erratic);\n-      free (accu->erratic);\n+      fde_extractor_t fde_extractor;\n+      if (ob->s.b.mixed_encoding)\n+\tfde_extractor = fde_mixed_encoding_extract;\n+      else if (ob->s.b.encoding == DW_EH_PE_absptr)\n+\tfde_extractor = fde_unencoded_extract;\n+      else\n+\tfde_extractor = fde_single_encoding_extract;\n+\n+      fde_radixsort (ob, fde_extractor, accu->linear, accu->aux);\n+      free (accu->aux);\n     }\n   else\n     {\n-      /* We've not managed to malloc an erratic array,\n+      fde_compare_t fde_compare;\n+      if (ob->s.b.mixed_encoding)\n+\tfde_compare = fde_mixed_encoding_compare;\n+      else if (ob->s.b.encoding == DW_EH_PE_absptr)\n+\tfde_compare = fde_unencoded_compare;\n+      else\n+\tfde_compare = fde_single_encoding_compare;\n+\n+      /* We've not managed to malloc an aux array,\n \t so heap sort in the linear one.  */\n       frame_heapsort (ob, fde_compare, accu->linear);\n     }"}]}