{"sha": "c2749e2df1fc0b9975377b80d1d817d1475f0d15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3NDllMmRmMWZjMGI5OTc1Mzc3YjgwZDFkODE3ZDE0NzVmMGQxNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-27T05:53:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-27T05:53:14Z"}, "message": "i960.c (i960_setup_incoming_varargs): Use get_varargs_alias_set for the register spill block.\n\n        * i960.c (i960_setup_incoming_varargs): Use get_varargs_alias_set\n        for the register spill block.\n        (i960_build_va_list): New.\n        (i960_va_start): New.\n        (i960_va_arg): New.\n        * i960.h (BUILD_VA_LIST_TYPE): New.\n        (EXPAND_BUILTIN_VA_START): New.\n        (EXPAND_BUILTIN_VA_ARG): New.\n        * i960.md (store_multiple): Use change_address on individul mems.\n\nFrom-SVN: r28284", "tree": {"sha": "e0af55339205104c41e580c52eb1f5e8a823fc11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0af55339205104c41e580c52eb1f5e8a823fc11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2749e2df1fc0b9975377b80d1d817d1475f0d15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2749e2df1fc0b9975377b80d1d817d1475f0d15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2749e2df1fc0b9975377b80d1d817d1475f0d15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2749e2df1fc0b9975377b80d1d817d1475f0d15/comments", "author": null, "committer": null, "parents": [{"sha": "daf68dd71ff9dc5c3f97743d702204be6fe253ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf68dd71ff9dc5c3f97743d702204be6fe253ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf68dd71ff9dc5c3f97743d702204be6fe253ae"}], "stats": {"total": 140, "additions": 127, "deletions": 13}, "files": [{"sha": "16dfcbe9e7e0c8b495d765eb550a393f2891d225", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2749e2df1fc0b9975377b80d1d817d1475f0d15", "patch": "@@ -1,3 +1,15 @@\n+Mon Jul 26 22:52:47 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i960.c (i960_setup_incoming_varargs): Use get_varargs_alias_set\n+\tfor the register spill block.\n+\t(i960_build_va_list): New.\n+\t(i960_va_start): New.\n+\t(i960_va_arg): New.\n+\t* i960.h (BUILD_VA_LIST_TYPE): New.\n+\t(EXPAND_BUILTIN_VA_START): New.\n+\t(EXPAND_BUILTIN_VA_ARG): New.\n+\t* i960.md (store_multiple): Use change_address on individul mems.\n+\n Mon Jul 26 22:43:12 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* builtins.c (stabilize_va_list): Don't INDIRECT_REF through"}, {"sha": "7a661e60e0199ceaf5b20c5818e72067695aa79d", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 95, "deletions": 2, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=c2749e2df1fc0b9975377b80d1d817d1475f0d15", "patch": "@@ -1,5 +1,6 @@\n /* Subroutines used for code generation on intel 80960.\n-   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999\n+   Free Software Foundation, Inc.\n    Contributed by Steven McGeady, Intel Corp.\n    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n    Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n@@ -2623,16 +2624,108 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       emit_label (label);\n \n       /* ??? Note that we unnecessarily store one extra register for stdarg\n-\t fns.  We could optimize this, but it's kept as for now.  */\n+\t fns.  We could optimize this, but it's kept as-is for now.  */\n       regblock = gen_rtx (MEM, BLKmode,\n \t\t\t  plus_constant (arg_pointer_rtx,\n \t\t\t\t\t first_reg * 4));\n+      MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();\n       move_block_from_reg (first_reg, regblock,\n \t\t\t   NPARM_REGS - first_reg,\n \t\t\t   (NPARM_REGS - first_reg) * UNITS_PER_WORD);\n     }\n }\n \n+/* Define the `__builtin_va_list' type for the ABI.  */\n+\n+tree\n+i960_build_va_list ()\n+{\n+  return build_array_type (unsigned_type_node,\n+\t\t\t   build_index_type (size_one_node));\n+}\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+\n+void\n+i960_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p ATTRIBUTE_UNUSED;\n+     tree valist;\n+     rtx nextarg ATTRIBUTE_UNUSED;\n+{\n+  tree d, s, t;\n+\n+  s = make_tree (unsigned_type_node, arg_pointer_rtx);\n+  d = build (ARRAY_REF, unsigned_type_node, valist, size_zero_node);\n+  t = build (MODIFY_EXPR, unsigned_type_node, d, s);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  s = build_int_2 ((current_function_args_info.ca_nregparms\n+\t\t    + current_function_args_info.ca_nstackparms) * 4, 0);\n+  d = build (ARRAY_REF, unsigned_type_node, valist, size_one_node);\n+  t = build (MODIFY_EXPR, unsigned_type_node, d, s);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+/* Implement `va_arg'.  */\n+\n+rtx\n+i960_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  HOST_WIDE_INT siz, ali;\n+  tree base, num, pad, next, this, t1, t2, int48;\n+  rtx addr_rtx;\n+\n+  base = build (ARRAY_REF, unsigned_type_node, valist, size_zero_node);\n+  num = build (ARRAY_REF, unsigned_type_node, valist, size_one_node);\n+\n+  /* Round up sizeof(type) to a word.  */\n+  siz = (int_size_in_bytes (type) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+\n+  /* Round up alignment to a word.  */\n+  ali = TYPE_ALIGN (type);\n+  if (ali < BITS_PER_WORD)\n+    ali = BITS_PER_WORD;\n+  ali /= BITS_PER_UNIT;\n+\n+  /* Align NUM appropriate for the argument.  */\n+  pad = fold (build (PLUS_EXPR, unsigned_type_node, num, \n+\t\t      build_int_2 (ali - 1, 0)));\n+  pad = fold (build (BIT_AND_EXPR, unsigned_type_node, pad,\n+\t\t      build_int_2 (-ali, -1)));\n+  pad = save_expr (pad);\n+\n+  /* Increment VPAD past this argument.  */\n+  next = fold (build (PLUS_EXPR, unsigned_type_node, pad,\n+\t\t      build_int_2 (siz, 0)));\n+  next = save_expr (next);\n+\n+  /* Find the offset for the current argument.  Mind peculiar overflow\n+     from registers to stack.  */\n+  int48 = build_int_2 (48, 0);\n+  if (siz > 16)\n+    t2 = integer_one_node;\n+  else\n+    t2 = fold (build (GT_EXPR, integer_type_node, next, int48));\n+  t1 = fold (build (LE_EXPR, integer_type_node, num, int48));\n+  t1 = fold (build (TRUTH_AND_EXPR, integer_type_node, t1, t2));\n+  this = fold (build (COND_EXPR, unsigned_type_node, t1, int48, pad));\n+\n+  /* Find the address for the current argument.  */\n+  t1 = fold (build (PLUS_EXPR, unsigned_type_node, base, this));\n+  t1 = build1 (NOP_EXPR, ptr_type_node, t1);\n+  addr_rtx = expand_expr (t1, NULL_RTX, Pmode, EXPAND_NORMAL);\n+\n+  /* Increment NUM.  */\n+  t1 = build (MODIFY_EXPR, unsigned_type_node, num, next);\n+  TREE_SIDE_EFFECTS (t1) = 1;\n+  expand_expr (t1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  \n+  return addr_rtx;\n+}\n+\n /* Calculate the final size of the reg parm stack space for the current\n    function, based on how many bytes would be allocated on the stack.  */\n "}, {"sha": "357ccdc80a750a1c1c8f5a1bfaeadbf0cd2d336e", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=c2749e2df1fc0b9975377b80d1d817d1475f0d15", "patch": "@@ -1,5 +1,6 @@\n /* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 1992, 1993, 1995, 1996, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999\n+   Free Software Foundation, Inc.\n    Contributed by Steven McGeady, Intel Corp.\n    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n    Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n@@ -859,6 +860,18 @@ enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n \n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n   i960_setup_incoming_varargs(&CUM,MODE,TYPE,&PRETEND_SIZE,NO_RTL)\n+\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = i960_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  i960_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  i960_va_arg (valist, type)\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should"}, {"sha": "945b514c9de24d5f7ac2d904b140bb6cf1083934", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2749e2df1fc0b9975377b80d1d817d1475f0d15/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=c2749e2df1fc0b9975377b80d1d817d1475f0d15", "patch": "@@ -972,7 +972,6 @@\n   int regno;\n   int count;\n   rtx from;\n-  int i;\n \n   if (GET_CODE (operands[0]) != MEM\n       || GET_CODE (operands[1]) != REG\n@@ -987,27 +986,24 @@\n   from = memory_address (SImode, XEXP (operands[0], 0));\n   while (count >= 4 && ((regno & 3) == 0))\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (MEM, TImode, from),\n-\t\t\t  gen_rtx (REG, TImode, regno)));\n+      emit_move_insn (change_address (operands[0], TImode, from),\n+\t\t      gen_rtx_REG (TImode, regno));\n       count -= 4;\n       regno += 4;\n       from = memory_address (TImode, plus_constant (from, 16));\n     }\n   while (count >= 2 && ((regno & 1) == 0))\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (MEM, DImode, from),\n-\t\t\t  gen_rtx (REG, DImode, regno)));\n+      emit_move_insn (change_address (operands[0], DImode, from),\n+\t\t      gen_rtx_REG (DImode, regno));\n       count -= 2;\n       regno += 2;\n       from = memory_address (DImode, plus_constant (from, 8));\n     }\n   while (count > 0)\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (MEM, SImode, from),\n-\t\t\t  gen_rtx (REG, SImode, regno)));\n+      emit_move_insn (change_address (operands[0], SImode, from),\n+\t\t      gen_rtx_REG (SImode, regno));\n       count -= 1;\n       regno += 1;\n       from = memory_address (SImode, plus_constant (from, 4));"}]}