{"sha": "a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxMmJhNzMyNzNjYTdjYjhiNGFiNWRjNjFhMTRiZWZiMmQ2NzAwNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@redhat.com", "date": "2002-03-09T20:20:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2002-03-09T20:20:18Z"}, "message": "Add memcpy/memset/strlen/strcmp/strncmp tests\n\nFrom-SVN: r50507", "tree": {"sha": "5fafa9bbb78da996e68e68874d645121b301bee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fafa9bbb78da996e68e68874d645121b301bee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/comments", "author": null, "committer": null, "parents": [{"sha": "2877e0aedebffa77a55167700f643d30ea499b3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2877e0aedebffa77a55167700f643d30ea499b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2877e0aedebffa77a55167700f643d30ea499b3f"}], "stats": {"total": 496, "additions": 496, "deletions": 0}, "files": [{"sha": "0ea067c668281ad0a9764cb345086f517afb86d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "patch": "@@ -1,3 +1,11 @@\n+2002-03-09  Michael Meissner  <meissner@redhat.com>\n+\n+\t* gcc.c-torture/execute/memcpy-2.c: New test.\n+\t* gcc.c-torture/execute/memset-1.c: New test.\n+\t* gcc.c-torture/execute/strlen-1.c: New test.\n+\t* gcc.c-torture/execute/strcmp-1.c: New test.\n+\t* gcc.c-torture/execute/strncmp-1.c: New test.\n+\n 2002-03-09  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* gcc.dg/ppc-ldstruct.c: New test."}, {"sha": "7832bf81ad7e14059bbaa188d3e30d979c531862", "filename": "gcc/testsuite/gcc.c-torture/execute/memcpy-2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcpy-2.c?ref=a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "patch": "@@ -0,0 +1,64 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test memcpy with various combinations of pointer alignments and lengths to\n+   make sure any optimizations in the library are correct.\n+\n+   Written by Michael Meissner, March 9, 2002.  */\n+\n+#include <string.h>\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (8 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+main ()\n+{\n+  int off1, off2, len, i;\n+  char *p, *q;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 1; len < MAX_COPY; len++)\n+\t{\n+\t  for (i = 0; i < MAX_LENGTH; i++)\n+\t    {\n+\t      u1.buf[i] = 'a';\n+\t      u2.buf[i] = 'A';\n+\t    }\n+\n+\t  p = memcpy (u1.buf + off1, u2.buf + off2, len);\n+\t  if (p != u1.buf + off1)\n+\t    abort ();\n+\n+\t  q = u1.buf;\n+\t  for (i = 0; i < off1; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\n+\t  for (i = 0; i < len; i++, q++)\n+\t    if (*q != 'A')\n+\t      abort ();\n+\n+\t  for (i = 0; i < MAX_EXTRA; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\t}\n+\n+  exit (0);\n+}"}, {"sha": "dd5df10d5abbd76a7f5d2cbed96fb8a56aa45203", "filename": "gcc/testsuite/gcc.c-torture/execute/memset-1.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-1.c?ref=a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "patch": "@@ -0,0 +1,96 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test memset with various combinations of pointer alignments and lengths to\n+   make sure any optimizations in the library are correct.\n+\n+   Written by Michael Meissner, March 9, 2002.  */\n+\n+#include <string.h>\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (8 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u;\n+\n+char A = 'A';\n+\n+main ()\n+{\n+  int off, len, i;\n+  char *p, *q;\n+\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    for (len = 1; len < MAX_COPY; len++)\n+      {\n+\tfor (i = 0; i < MAX_LENGTH; i++)\n+\t  u.buf[i] = 'a';\n+\n+\tp = memset (u.buf + off, '\\0', len);\n+\tif (p != u.buf + off)\n+\t  abort ();\n+\n+\tq = u.buf;\n+\tfor (i = 0; i < off; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tfor (i = 0; i < len; i++, q++)\n+\t  if (*q != '\\0')\n+\t    abort ();\n+\n+\tfor (i = 0; i < MAX_EXTRA; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tp = memset (u.buf + off, A, len);\n+\tif (p != u.buf + off)\n+\t  abort ();\n+\n+\tq = u.buf;\n+\tfor (i = 0; i < off; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tfor (i = 0; i < len; i++, q++)\n+\t  if (*q != 'A')\n+\t    abort ();\n+\n+\tfor (i = 0; i < MAX_EXTRA; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tp = memset (u.buf + off, 'B', len);\n+\tif (p != u.buf + off)\n+\t  abort ();\n+\n+\tq = u.buf;\n+\tfor (i = 0; i < off; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tfor (i = 0; i < len; i++, q++)\n+\t  if (*q != 'B')\n+\t    abort ();\n+\n+\tfor (i = 0; i < MAX_EXTRA; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+      }\n+\n+  exit (0);\n+}"}, {"sha": "79999af3cbe8866f85b0efba48ae4227cdf89594", "filename": "gcc/testsuite/gcc.c-torture/execute/strcmp-1.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrcmp-1.c?ref=a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "patch": "@@ -0,0 +1,131 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test strcmp with various combinations of pointer alignments and lengths to\n+   make sure any optimizations in the library are correct.\n+\n+   Written by Michael Meissner, March 9, 2002.  */\n+\n+#include <string.h>\n+#include <stddef.h>\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_TEST\n+#define MAX_TEST (8 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_TEST + MAX_EXTRA + 2)\n+\n+static union {\n+  unsigned char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+void\n+test (const unsigned char *s1, const unsigned char *s2, int expected)\n+{\n+  int value = strcmp ((char *) s1, (char *) s2);\n+\n+  if (expected < 0 && value >= 0)\n+    abort ();\n+  else if (expected == 0 && value != 0)\n+    abort ();\n+  else if (expected > 0 && value <= 0)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  size_t off1, off2, len, i;\n+  unsigned char *buf1, *buf2;\n+  unsigned char *mod1, *mod2;\n+  unsigned char *p1, *p2;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 0; len < MAX_TEST; len++)\n+\t{\n+\t  p1 = u1.buf;\n+\t  for (i = 0; i < off1; i++)\n+\t    *p1++ = '\\0';\n+\n+\t  buf1 = p1;\n+\t  for (i = 0; i < len; i++)\n+\t    *p1++ = 'a';\n+\n+\t  mod1 = p1;\n+\t  for (i = 0; i < MAX_EXTRA+2; i++)\n+\t    *p1++ = 'x';\n+\n+\t  p2 = u2.buf;\n+\t  for (i = 0; i < off2; i++)\n+\t    *p2++ = '\\0';\n+\n+\t  buf2 = p2;\n+\t  for (i = 0; i < len; i++)\n+\t    *p2++ = 'a';\n+\n+\t  mod2 = p2;\n+\t  for (i = 0; i < MAX_EXTRA+2; i++)\n+\t    *p2++ = 'x';\n+\n+\t  mod1[0] = '\\0';\n+\t  mod2[0] = '\\0';\n+\t  test (buf1, buf2, 0);\n+\n+\t  mod1[0] = 'a';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = '\\0';\n+\t  test (buf1, buf2, +1);\n+\n+\t  mod1[0] = '\\0';\n+\t  mod2[0] = 'a';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, -1);\n+\n+\t  mod1[0] = 'b';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = 'c';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, -1);\n+\n+\t  mod1[0] = 'c';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = 'b';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, +1);\n+\n+\t  mod1[0] = 'b';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = (unsigned char)'\\251';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, -1);\n+\n+\t  mod1[0] = (unsigned char)'\\251';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = 'b';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, +1);\n+\n+\t  mod1[0] = (unsigned char)'\\251';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = (unsigned char)'\\252';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, -1);\n+\n+\t  mod1[0] = (unsigned char)'\\252';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = (unsigned char)'\\251';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, +1);\n+\t}\n+\n+  exit (0);\n+}"}, {"sha": "c29592b8b88791d9f7a380edfc81f268b62f891d", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-1.c?ref=a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test strlen with various combinations of pointer alignments and lengths to\n+   make sure any optimizations in the library are correct.\n+\n+   Written by Michael Meissner, March 9, 2002.  */\n+\n+#include <string.h>\n+#include <stddef.h>\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_TEST\n+#define MAX_TEST (8 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_TEST + MAX_EXTRA + 1)\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u;\n+\n+main ()\n+{\n+  size_t off, len, len2, i;\n+  char *p;\n+\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    for (len = 0; len < MAX_TEST; len++)\n+      {\n+\tp = u.buf;\n+\tfor (i = 0; i < off; i++)\n+\t  *p++ = '\\0';\n+\n+\tfor (i = 0; i < len; i++)\n+\t  *p++ = 'a';\n+\n+\t*p++ = '\\0';\n+\tfor (i = 0; i < MAX_EXTRA; i++)\n+\t  *p++ = 'b';\n+\n+\tp = u.buf + off;\n+\tlen2 = strlen (p);\n+\tif (len != len2)\n+\t  abort ();\n+      }\n+\n+  exit (0);\n+}"}, {"sha": "dee904ff1e690106db4a5860bac14bc8d698d49b", "filename": "gcc/testsuite/gcc.c-torture/execute/strncmp-1.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrncmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012ba73273ca7cb8b4ab5dc61a14befb2d67004/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrncmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrncmp-1.c?ref=a012ba73273ca7cb8b4ab5dc61a14befb2d67004", "patch": "@@ -0,0 +1,140 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test strncmp with various combinations of pointer alignments and lengths to\n+   make sure any optimizations in the library are correct.\n+\n+   Written by Michael Meissner, March 9, 2002.  */\n+\n+#include <string.h>\n+#include <stddef.h>\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_TEST\n+#define MAX_TEST (8 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_TEST + MAX_EXTRA)\n+\n+static union {\n+  unsigned char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+void\n+test (const unsigned char *s1, const unsigned char *s2, size_t len, int expected)\n+{\n+  int value = strncmp ((char *) s1, (char *) s2, len);\n+\n+  if (expected < 0 && value >= 0)\n+    abort ();\n+  else if (expected == 0 && value != 0)\n+    abort ();\n+  else if (expected > 0 && value <= 0)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  size_t off1, off2, len, i;\n+  unsigned char *buf1, *buf2;\n+  unsigned char *mod1, *mod2;\n+  unsigned char *p1, *p2;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 0; len < MAX_TEST; len++)\n+\t{\n+\t  p1 = u1.buf;\n+\t  for (i = 0; i < off1; i++)\n+\t    *p1++ = '\\0';\n+\n+\t  buf1 = p1;\n+\t  for (i = 0; i < len; i++)\n+\t    *p1++ = 'a';\n+\n+\t  mod1 = p1;\n+\t  for (i = 0; i < MAX_EXTRA; i++)\n+\t    *p1++ = 'x';\n+\n+\t  p2 = u2.buf;\n+\t  for (i = 0; i < off2; i++)\n+\t    *p2++ = '\\0';\n+\n+\t  buf2 = p2;\n+\t  for (i = 0; i < len; i++)\n+\t    *p2++ = 'a';\n+\n+\t  mod2 = p2;\n+\t  for (i = 0; i < MAX_EXTRA; i++)\n+\t    *p2++ = 'x';\n+\n+\t  mod1[0] = '\\0';\n+\t  mod2[0] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, 0);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = 'a';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, +1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = '\\0';\n+\t  mod2[0] = 'a';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, -1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = 'b';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = 'c';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, -1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = 'c';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = 'b';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, +1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = 'b';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = (unsigned char)'\\251';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, -1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = (unsigned char)'\\251';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = 'b';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, +1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = (unsigned char)'\\251';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = (unsigned char)'\\252';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, -1);\n+\t  test (buf1, buf2, len, 0);\n+\n+\t  mod1[0] = (unsigned char)'\\252';\n+\t  mod1[1] = '\\0';\n+\t  mod2[0] = (unsigned char)'\\251';\n+\t  mod2[1] = '\\0';\n+\t  test (buf1, buf2, MAX_LENGTH, +1);\n+\t  test (buf1, buf2, len, 0);\n+\t}\n+\n+  exit (0);\n+}"}]}