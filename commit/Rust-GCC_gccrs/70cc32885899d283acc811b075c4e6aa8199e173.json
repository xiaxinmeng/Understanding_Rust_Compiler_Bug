{"sha": "70cc32885899d283acc811b075c4e6aa8199e173", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBjYzMyODg1ODk5ZDI4M2FjYzgxMWIwNzVjNGU2YWE4MTk5ZTE3Mw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-02-13T17:40:22Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-02-13T17:40:22Z"}, "message": "re PR target/56184 (Internal compiler error in push_reload during bootstrap stage 2)\n\n2013-02-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/56184\n\t* ira.c (max_regno_before_ira): Move from ...\n\t(ira): ... here.\n\t(fix_reg_equiv_init): Use max_regno_before_ira instead of\n\tvec_safe_length.\n\n2013-02-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/56184\n\t* gcc.target/arm/pr56184.C: New test.\n\nFrom-SVN: r196019", "tree": {"sha": "4675ffd74979fa6ab1548e79ea49719d1e657cd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4675ffd74979fa6ab1548e79ea49719d1e657cd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70cc32885899d283acc811b075c4e6aa8199e173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70cc32885899d283acc811b075c4e6aa8199e173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70cc32885899d283acc811b075c4e6aa8199e173", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70cc32885899d283acc811b075c4e6aa8199e173/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6760071f307c18d0aef50f9c848d15cb7c1a687d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6760071f307c18d0aef50f9c848d15cb7c1a687d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6760071f307c18d0aef50f9c848d15cb7c1a687d"}], "stats": {"total": 283, "additions": 279, "deletions": 4}, "files": [{"sha": "d4125050a494331b38a7ff43bf8efda3c7a67c03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70cc32885899d283acc811b075c4e6aa8199e173", "patch": "@@ -1,3 +1,11 @@\n+2013-02-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/56184\n+\t* ira.c (max_regno_before_ira): Move from ...\n+\t(ira): ... here.\n+\t(fix_reg_equiv_init): Use max_regno_before_ira instead of\n+\tvec_safe_length.\n+\n 2013-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_asan_shadow_offset): Revert last change.\n@@ -63,7 +71,7 @@\n \n \tPR inline-asm/56148\n \t* lra-constraints.c (process_alt_operands): Match early clobber\n-\toperand with itself.  Check conflicts with earlyclobner only if\n+\toperand with itself.  Check conflicts with earlyclobber only if\n \tthe operand is not reloaded.  Prefer to reload conflicting operand\n \tif earlyclobber and matching operands are the same.\n "}, {"sha": "03b336831fad5ac8f9fd157ba5f07a51f270b9bc", "filename": "gcc/ira.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=70cc32885899d283acc811b075c4e6aa8199e173", "patch": "@@ -419,6 +419,11 @@ int ira_move_loops_num, ira_additional_jumps_num;\n \n HARD_REG_SET eliminable_regset;\n \n+/* Value of max_reg_num () before IRA work start.  This value helps\n+   us to recognize a situation when new pseudos were created during\n+   IRA work.  */\n+static int max_regno_before_ira;\n+\n /* Temporary hard reg set used for a different calculation.  */\n static HARD_REG_SET temp_hard_regset;\n \n@@ -2264,11 +2269,11 @@ ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx insns)\n static void\n fix_reg_equiv_init (void)\n {\n-  unsigned int max_regno = max_reg_num ();\n+  int max_regno = max_reg_num ();\n   int i, new_regno, max;\n   rtx x, prev, next, insn, set;\n \n-  if (vec_safe_length (reg_equivs) < max_regno)\n+  if (max_regno_before_ira < max_regno)\n     {\n       max = vec_safe_length (reg_equivs);\n       grow_reg_equivs ();\n@@ -4350,7 +4355,7 @@ static void\n ira (FILE *f)\n {\n   bool loops_p;\n-  int max_regno_before_ira, ira_max_point_before_emit;\n+  int ira_max_point_before_emit;\n   int rebuild_p;\n   bool saved_flag_caller_saves = flag_caller_saves;\n   enum ira_region saved_flag_ira_region = flag_ira_region;"}, {"sha": "7fec9fc703cb13a80f0238056a219db594461f00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70cc32885899d283acc811b075c4e6aa8199e173", "patch": "@@ -1,3 +1,8 @@\n+2013-02-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/56184\n+\t* gcc.target/arm/pr56184.C: New test.\n+\n 2013-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/56302"}, {"sha": "db92db13f9ebe057e6ce2efac217ace1cea1cd3d", "filename": "gcc/testsuite/gcc.target/arm/pr56184.C", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr56184.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70cc32885899d283acc811b075c4e6aa8199e173/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr56184.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr56184.C?ref=70cc32885899d283acc811b075c4e6aa8199e173", "patch": "@@ -0,0 +1,257 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mthumb -march=armv7-a -mfpu=neon -mfloat-abi=softfp -mtune=cortex-a9 -fno-section-anchors\" } */\n+\n+typedef unsigned int size_t;\n+__extension__ typedef int __intptr_t;\n+typedef __intptr_t intptr_t;\n+typedef union tree_node *tree;\n+typedef const union tree_node *const_tree;\n+extern void *ggc_internal_cleared_alloc_stat (size_t )\n+  __attribute__ ((__malloc__));\n+enum tree_code {\n+TREE_LIST=2,\n+FUNCTION_DECL,\n+MAX_TREE_CODES=254\n+};\n+extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n+struct tree_base {\n+  enum tree_code code : 16;\n+};\n+struct tree_common {\n+  tree chain;\n+};\n+enum tree_node_structure_enum {\n+TS_COMMON,\n+TS_DECL_COMMON,\n+};\n+extern void tree_contains_struct_check_failed (const_tree,\n+            const enum tree_node_structure_enum,\n+            const char *, int, const char *)\n+  __attribute__ ((__noreturn__));\n+extern void tree_check_failed (const_tree, const char *, int, const char *,\n+          ...) __attribute__ ((__noreturn__));\n+struct tree_list {\n+  tree value;\n+};\n+struct tree_decl_common {\n+  tree initial;\n+};\n+struct tree_function_decl {\n+  struct function *f;\n+};\n+union\n+                                                         tree_node {\n+  struct tree_base base;\n+  struct tree_common common;\n+  struct tree_decl_common decl_common;\n+  struct tree_function_decl function_decl;\n+  struct tree_list list;\n+};\n+inline tree\n+tree_check (tree __t, const char *__f, int __l, const char *__g, enum tree_code __c)\n+{\n+  if (((enum tree_code) (__t)->base.code) != __c)\n+    tree_check_failed (__t, __f, __l, __g, __c, 0);\n+}\n+inline tree\n+contains_struct_check (tree __t, const enum tree_node_structure_enum __s,\n+                       const char *__f, int __l, const char *__g)\n+{\n+  if (tree_contains_struct[((enum tree_code) (__t)->base.code)][__s] != 1)\n+      tree_contains_struct_check_failed (__t, __s, __f, __l, __g);\n+}\n+struct function {\n+  tree static_chain_decl;\n+};\n+enum gimple_code {\n+    LAST_AND_UNUSED_GIMPLE_CODE\n+};\n+struct eh_catch_d\n+{\n+  struct eh_catch_d *next_catch;\n+  struct eh_catch_d *prev_catch;\n+  tree type_list;\n+  tree filter_list;\n+  tree label;\n+};\n+struct eh_region_d\n+{\n+  struct eh_region_d *outer;\n+  struct eh_region_d *inner;\n+  int index;\n+  union eh_region_u {\n+    struct eh_region_u_try {\n+      struct eh_catch_d *first_catch;\n+    } eh_try;\n+  } u;\n+};\n+typedef struct eh_catch_d *eh_catch;\n+typedef struct eh_region_d *eh_region;\n+extern void add_type_for_runtime (tree);\n+enum LTO_tags\n+{\n+  LTO_null = 0,\n+  LTO_bb0 = 1 + MAX_TREE_CODES + LAST_AND_UNUSED_GIMPLE_CODE,\n+  LTO_ert_cleanup,\n+  LTO_NUM_TAGS\n+};\n+enum lto_section_type\n+{\n+  LTO_section_function_body,\n+};\n+struct lto_input_block\n+{\n+  const char *data;\n+  unsigned int p;\n+  unsigned int len;\n+};\n+extern void lto_section_overrun (struct lto_input_block *) __attribute__ ((__noreturn__));\n+extern void lto_value_range_error (const char *,\n+       long long, long long,\n+       long long) __attribute__ ((__noreturn__));\n+long long streamer_read_hwi (struct lto_input_block *);\n+static inline unsigned char\n+streamer_read_uchar (struct lto_input_block *ib)\n+{\n+  if (ib->p >= ib->len)\n+    lto_section_overrun (ib);\n+  return (ib->data[ib->p++]);\n+}\n+static inline long long\n+streamer_read_hwi_in_range (struct lto_input_block *ib,\n+     const char *purpose,\n+     long long min,\n+     long long max)\n+{\n+  long long range = max - min;\n+  long long val = streamer_read_uchar (ib);\n+  if (range >= 0xff)\n+    val |= ((long long)streamer_read_uchar (ib)) << 8;\n+  if (val < min || val > max)\n+    lto_value_range_error (purpose, val, min, max);\n+  return val;\n+}\n+static inline enum LTO_tags\n+streamer_read_record_start (struct lto_input_block *ib)\n+{\n+  return (enum LTO_tags)streamer_read_hwi_in_range ((ib), \"LTO_tags\", 0, (int)(LTO_NUM_TAGS) - 1);\n+}\n+struct streamer_hooks {\n+  tree (*read_tree) (struct lto_input_block *, struct data_in *);\n+};\n+extern struct streamer_hooks streamer_hooks;\n+static struct eh_catch_d *\n+lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n+    eh_catch *last_p)\n+{\n+  eh_catch first;\n+  enum LTO_tags tag;\n+  *last_p = first = __null;\n+  tag = streamer_read_record_start (ib);\n+  while (tag)\n+    {\n+      tree list;\n+      eh_catch n;\n+      n = ((struct eh_catch_d *)(ggc_internal_cleared_alloc_stat (sizeof (struct eh_catch_d) )));\n+      n->type_list = streamer_hooks.read_tree(ib, data_in);\n+      n->filter_list = streamer_hooks.read_tree(ib, data_in);\n+      n->label = streamer_hooks.read_tree(ib, data_in);\n+      for (list = n->filter_list; list; list = ((contains_struct_check ((list), (TS_COMMON), \"../../../gcc-4.8~svn195526/gcc/lto-streamer-in.c\", 275, __FUNCTION__))->common.chain))\n+ add_type_for_runtime (((tree_check ((list), \"../../../gcc-4.8~svn195526/gcc/lto-streamer-in.c\", 276, __FUNCTION__, (TREE_LIST)))->list.value));\n+      if (*last_p)\n+ (*last_p)->next_catch = n;\n+      n->prev_catch = *last_p;\n+      *last_p = n;\n+      if (first == __null)\n+ first = n;\n+      tag = streamer_read_record_start (ib);\n+    }\n+  return first;\n+}\n+static eh_region\n+input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n+{\n+  enum LTO_tags tag;\n+  eh_region r;\n+  tag = streamer_read_record_start (ib);\n+  if (tag == LTO_null)\n+    return __null;\n+  r = ((struct eh_region_d *)(ggc_internal_cleared_alloc_stat (sizeof (struct eh_region_d) )));\n+  r->index = streamer_read_hwi (ib);\n+  r->outer = (eh_region) (intptr_t) streamer_read_hwi (ib);\n+  r->inner = (eh_region) (intptr_t) streamer_read_hwi (ib);\n+  switch (tag)\n+    {\n+      case LTO_ert_cleanup:\n+ {\n+   struct eh_catch_d *last_catch;\n+   r->u.eh_try.first_catch = lto_input_eh_catch_list (ib, data_in,\n+            &last_catch);\n+ }\n+ {\n+   tree l;\n+     add_type_for_runtime (((tree_check ((l), \"../../../gcc-4.8~svn195526/gcc/lto-streamer-in.c\", 346, __FUNCTION__, (TREE_LIST)))->list.value));\n+ }\n+    }\n+}\n+static void\n+input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n+    struct function *fn)\n+{\n+  long long i, root_region, len;\n+  enum LTO_tags tag;\n+  tag = streamer_read_record_start (ib);\n+  if (tag == LTO_null)\n+    return;\n+  len = streamer_read_hwi (ib);\n+  if (len > 0)\n+    {\n+      for (i = 0; i < len; i++)\n+ {\n+   eh_region r = input_eh_region (ib, data_in, i);\n+ }\n+    }\n+}\n+static void\n+input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n+   struct function *fn)\n+{\n+  unsigned int i, size;\n+  while (i)\n+    {\n+    }\n+}\n+static void\n+input_struct_function_base (struct function *fn, struct data_in *data_in,\n+                            struct lto_input_block *ib)\n+{\n+  fn->static_chain_decl = streamer_hooks.read_tree(ib, data_in);\n+}\n+static void\n+input_function (tree fn_decl, struct data_in *data_in,\n+  struct lto_input_block *ib)\n+{\n+  struct function *fn;\n+  enum LTO_tags tag;\n+  fn = ((tree_check ((fn_decl), \"../../../gcc-4.8~svn195526/gcc/lto-streamer-in.c\", 807, __FUNCTION__, (FUNCTION_DECL)))->function_decl.f);\n+  tag = streamer_read_record_start (ib);\n+  input_struct_function_base (fn, data_in, ib);\n+  input_ssa_names (ib, data_in, fn);\n+  input_eh_regions (ib, data_in, fn);\n+  ((contains_struct_check ((fn_decl), (TS_DECL_COMMON), \"../../../gcc-4.8~svn195526/gcc/lto-streamer-in.c\", 823, __FUNCTION__))->decl_common.initial) = streamer_hooks.read_tree(ib, data_in);\n+}\n+static void\n+lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n+        const char *data, enum lto_section_type section_type)\n+{\n+  struct data_in *data_in;\n+  struct lto_input_block ib_main;\n+  input_function (fn_decl, data_in, &ib_main);\n+}\n+void\n+lto_input_function_body (struct lto_file_decl_data *file_data,\n+    tree fn_decl, const char *data)\n+{\n+  lto_read_body (file_data, fn_decl, data, LTO_section_function_body);\n+}\n+"}]}