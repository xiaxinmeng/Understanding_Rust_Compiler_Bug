{"sha": "b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "node_id": "C_kwDOANBUbNoAKGI4ZWYwMTlhYjkzODQ3MWY3Zjg3N2ExZWVlM2E2Mzc0ZmQ4YTZhZTk", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-10-29T14:01:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-10-29T14:01:51Z"}, "message": "handle retslot in modref\n\nExtend modref and tree-ssa-structalias to handle retslot flags.\nSince retslot it essentially a hidden argument that is known to be write-only\nwe can do pretty much the same stuff as we do for regular parameters.\nI plan to add static chain handling similar way.\n\nWe do not handle IPA propagation of retslot flags (where return slot is\ninitialized via return slot of other function). For this ipa-prop needs\nto be extended to understand retslot as well.\n\nBootstrapped/regtested x86_64-linux, OK for the gimple bits?\n\nHonza\n\ngcc/ChangeLog:\n\n\t* gimple.c (gimple_call_retslot_flags): New function.\n\t* gimple.h (gimple_call_retslot_flags): Declare.\n\t* ipa-modref.c: Include tree-cfg.h.\n\t(struct escape_entry): Turn parm_index to signed.\n\t(modref_summary_lto::modref_summary_lto): Add retslot_flags.\n\t(modref_summary::modref_summary): Initialize retslot_flags.\n\t(struct modref_summary_lto): Likewise.\n\t(modref_summary::useful_p): Check retslot_flags.\n\t(modref_summary_lto::useful_p): Likewise.\n\t(modref_summary::dump): Dump retslot_flags.\n\t(modref_summary_lto::dump): Likewise.\n\t(struct escape_point): Add hidden_args enum.\n\t(analyze_ssa_name_flags): Ignore return slot return;\n\tuse gimple_call_retslot_flags.\n\t(record_escape_points): Break out from ...\n\t(analyze_parms): ... here; handle retslot_flags.\n\t(modref_summaries::duplicate): Duplicate retslot_flags.\n\t(modref_summaries_lto::duplicate): Likewise.\n\t(modref_write_escape_summary): Stream parm_index as signed.\n\t(modref_read_escape_summary): Likewise.\n\t(modref_write): Stream retslot_flags.\n\t(read_section): Likewise.\n\t(struct escape_map): Fix typo in comment.\n\t(update_escape_summary_1): Fix whitespace.\n\t(ipa_merge_modref_summary_after_inlining): Drop retslot_flags.\n\t(modref_merge_call_site_flags): Merge retslot_flags.\n\t* ipa-modref.h (struct modref_summary): Add retslot_flags.\n\t* tree-ssa-structalias.c (handle_rhs_call): Handle retslot_flags.", "tree": {"sha": "d7bf60ed504c5a2116becd99e9c9f88d7a4ba63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7bf60ed504c5a2116becd99e9c9f88d7a4ba63c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/comments", "author": null, "committer": null, "parents": [{"sha": "4045d5fa42f2ee7b284977c8f2f0edc300a63e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4045d5fa42f2ee7b284977c8f2f0edc300a63e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4045d5fa42f2ee7b284977c8f2f0edc300a63e43"}], "stats": {"total": 217, "additions": 170, "deletions": 47}, "files": [{"sha": "22dd6417d19d5f00f302e78ca2430543b1724df6", "filename": "gcc/gimple.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "patch": "@@ -1597,7 +1597,12 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n \t  if (!node->binds_to_current_def_p ())\n \t    {\n \t      if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n-\t\tmodref_flags &= ~EAF_UNUSED;\n+\t\t{\n+\t\t  modref_flags &= ~EAF_UNUSED;\n+\t\t  modref_flags |= EAF_NOESCAPE;\n+\t\t}\n+\t      if ((modref_flags & EAF_NOREAD) && !(flags & EAF_NOREAD))\n+\t\tmodref_flags &= ~EAF_NOREAD;\n \t      if ((modref_flags & EAF_DIRECT) && !(flags & EAF_DIRECT))\n \t\tmodref_flags &= ~EAF_DIRECT;\n \t    }\n@@ -1608,6 +1613,40 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n   return flags;\n }\n \n+/* Detects argument flags for return slot on call STMT.  */\n+\n+int\n+gimple_call_retslot_flags (const gcall *stmt)\n+{\n+  int flags = EAF_DIRECT | EAF_NOREAD;\n+\n+  tree callee = gimple_call_fndecl (stmt);\n+  if (callee)\n+    {\n+      cgraph_node *node = cgraph_node::get (callee);\n+      modref_summary *summary = node ? get_modref_function_summary (node)\n+\t\t\t\t: NULL;\n+\n+      if (summary)\n+\t{\n+\t  int modref_flags = summary->retslot_flags;\n+\n+\t  /* We have possibly optimized out load.  Be conservative here.  */\n+\t  if (!node->binds_to_current_def_p ())\n+\t    {\n+\t      if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n+\t\t{\n+\t\t  modref_flags &= ~EAF_UNUSED;\n+\t\t  modref_flags |= EAF_NOESCAPE;\n+\t\t}\n+\t    }\n+\t  if (dbg_cnt (ipa_mod_ref_pta))\n+\t    flags |= modref_flags;\n+\t}\n+    }\n+  return flags;\n+}\n+\n /* Detects return flags for the call STMT.  */\n \n int"}, {"sha": "23a124ec76936cf72832260fa29b7fd26248ab59", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "patch": "@@ -1589,6 +1589,7 @@ gimple_seq gimple_seq_copy (gimple_seq);\n bool gimple_call_same_target_p (const gimple *, const gimple *);\n int gimple_call_flags (const gimple *);\n int gimple_call_arg_flags (const gcall *, unsigned);\n+int gimple_call_retslot_flags (const gcall *);\n int gimple_call_return_flags (const gcall *);\n bool gimple_call_nonnull_result_p (gcall *);\n tree gimple_call_nonnull_arg (gcall *);"}, {"sha": "3539cb43d11a21798b72bc265326876fc4d444b3", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 108, "deletions": 37, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n #include \"attribs.h\"\n+#include \"tree-cfg.h\"\n \n \n namespace {\n@@ -133,7 +134,7 @@ static fnspec_summaries_t *fnspec_summaries = NULL;\n struct escape_entry\n {\n   /* Parameter that escapes at a given call.  */\n-  unsigned int parm_index;\n+  int parm_index;\n   /* Argument it escapes to.  */\n   unsigned int arg;\n   /* Minimal flags known about the argument.  */\n@@ -269,7 +270,7 @@ static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n /* Summary for a single function which this pass produces.  */\n \n modref_summary::modref_summary ()\n-  : loads (NULL), stores (NULL), writes_errno (NULL)\n+  : loads (NULL), stores (NULL), retslot_flags (0), writes_errno (false)\n {\n }\n \n@@ -322,6 +323,8 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n   if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n     return true;\n   arg_flags.release ();\n+  if (check_flags && remove_useless_eaf_flags (retslot_flags, ecf_flags, false))\n+    return true;\n   if (ecf_flags & ECF_CONST)\n     return false;\n   if (loads && !loads->every_base)\n@@ -363,6 +366,7 @@ struct GTY(()) modref_summary_lto\n   modref_records_lto *loads;\n   modref_records_lto *stores;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n+  eaf_flags_t retslot_flags;\n   bool writes_errno;\n \n   modref_summary_lto ();\n@@ -374,7 +378,7 @@ struct GTY(()) modref_summary_lto\n /* Summary for a single function which this pass produces.  */\n \n modref_summary_lto::modref_summary_lto ()\n-  : loads (NULL), stores (NULL), writes_errno (NULL)\n+  : loads (NULL), stores (NULL), retslot_flags (0), writes_errno (false)\n {\n }\n \n@@ -400,6 +404,8 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n   if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n     return true;\n   arg_flags.release ();\n+  if (check_flags && remove_useless_eaf_flags (retslot_flags, ecf_flags, false))\n+    return true;\n   if (ecf_flags & ECF_CONST)\n     return false;\n   if (loads && !loads->every_base)\n@@ -608,6 +614,11 @@ modref_summary::dump (FILE *out)\n \t    dump_eaf_flags (out, arg_flags[i]);\n \t  }\n     }\n+  if (retslot_flags)\n+    {\n+      fprintf (out, \"  Retslot flags:\");\n+      dump_eaf_flags (out, retslot_flags);\n+    }\n }\n \n /* Dump summary.  */\n@@ -630,6 +641,11 @@ modref_summary_lto::dump (FILE *out)\n \t    dump_eaf_flags (out, arg_flags[i]);\n \t  }\n     }\n+  if (retslot_flags)\n+    {\n+      fprintf (out, \"  Retslot flags:\");\n+      dump_eaf_flags (out, retslot_flags);\n+    }\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n@@ -1396,6 +1412,11 @@ namespace {\n \n struct escape_point\n {\n+  /* Extra hidden args we keep track of.  */\n+  enum hidden_args\n+  {\n+    retslot_arg = -1\n+  };\n   /* Value escapes to this call.  */\n   gcall *call;\n   /* Argument it escapes to.  */\n@@ -1705,7 +1726,11 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t Returning name counts as an use by tree-ssa-structalias.c  */\n       if (greturn *ret = dyn_cast <greturn *> (use_stmt))\n \t{\n-\t  if (gimple_return_retval (ret) == name)\n+\t  /* Returning through return slot is seen as memory write earlier.  */\n+\t  if (DECL_RESULT (current_function_decl)\n+\t      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+\t    ;\n+\t  else if (gimple_return_retval (ret) == name)\n \t    lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED));\n \t  else if (memory_access_to (gimple_return_retval (ret), name))\n \t    {\n@@ -1748,7 +1773,7 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t     may make LHS to escape.  See PR 98499.  */\n \t\t  if (gimple_call_return_slot_opt_p (call)\n \t\t      && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (call))))\n-\t\t    lattice[index].merge (EAF_NOREAD | EAF_DIRECT);\n+\t\t    lattice[index].merge (gimple_call_retslot_flags (call));\n \t\t}\n \n \t      /* We do not track accesses to the static chain (we could)\n@@ -1777,7 +1802,7 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t\t  lattice[index].merge (call_flags);\n \t\t\telse\n \t\t\t  lattice[index].add_escape_point (call, i,\n-\t\t\t     \t\t\t\t   call_flags, true);\n+\t\t\t\t\t\t\t   call_flags, true);\n \t\t      }\n \t\t    if (!ignore_retval)\n \t\t      merge_call_lhs_flags (call, i, index, false,\n@@ -1912,6 +1937,29 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n   lattice[index].known = true;\n }\n \n+/* Record escape points of PARM_INDEX according to LATTICE.  */\n+\n+static void\n+record_escape_points (modref_lattice &lattice, int parm_index, int flags)\n+{\n+  if (lattice.escape_points.length ())\n+    {\n+      escape_point *ep;\n+      unsigned int ip;\n+      cgraph_node *node = cgraph_node::get (current_function_decl);\n+\n+      FOR_EACH_VEC_ELT (lattice.escape_points, ip, ep)\n+\tif ((ep->min_flags & flags) != flags)\n+\t  {\n+\t    cgraph_edge *e = node->get_edge (ep->call);\n+\t    struct escape_entry ee = {parm_index, ep->arg,\n+\t\t\t\t      ep->min_flags, ep->direct};\n+\n+\t    escape_summaries->get_create (e)->esc.safe_push (ee);\n+\t  }\n+    }\n+}\n+\n /* Determine EAF flags for function parameters.  */\n \n static void\n@@ -1921,16 +1969,22 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n   unsigned int parm_index = 0;\n   unsigned int count = 0;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n+  tree retslot = NULL;\n \n   /* For novops functions we have nothing to gain by EAF flags.  */\n   if (ecf_flags & ECF_NOVOPS)\n     return;\n \n+  /* If there is return slot, look up its SSA name.  */\n+  if (DECL_RESULT (current_function_decl)\n+      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+    retslot = ssa_default_def (cfun, DECL_RESULT (current_function_decl));\n+\n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n        parm = TREE_CHAIN (parm))\n     count++;\n \n-  if (!count)\n+  if (!count && !retslot)\n     return;\n \n   auto_vec<modref_lattice> lattice;\n@@ -1984,24 +2038,24 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t\tsummary_lto->arg_flags.safe_grow_cleared (count, true);\n \t      summary_lto->arg_flags[parm_index] = flags;\n \t    }\n-\t  if (lattice[SSA_NAME_VERSION (name)].escape_points.length ())\n-\t    {\n-\t      escape_point *ep;\n-\t      unsigned int ip;\n-\t      cgraph_node *node = cgraph_node::get (current_function_decl);\n-\n-\t      gcc_checking_assert (ipa);\n-\t      FOR_EACH_VEC_ELT\n-\t\t  (lattice[SSA_NAME_VERSION (name)].escape_points, ip, ep)\n-\t\tif ((ep->min_flags & flags) != flags)\n-\t\t  {\n-\t\t    cgraph_edge *e = node->get_edge (ep->call);\n-\t\t    struct escape_entry ee = {parm_index, ep->arg,\n-\t\t     \t\t\t      ep->min_flags, ep->direct};\n+\t  record_escape_points (lattice[SSA_NAME_VERSION (name)],\n+\t\t\t\tparm_index, flags);\n+\t}\n+    }\n+  if (retslot)\n+    {\n+      analyze_ssa_name_flags (retslot, lattice, 0, ipa);\n+      int flags = lattice[SSA_NAME_VERSION (retslot)].flags;\n \n-\t\t    escape_summaries->get_create (e)->esc.safe_push (ee);\n-\t\t  }\n-\t    }\n+      flags = remove_useless_eaf_flags (flags, ecf_flags, false);\n+      if (flags)\n+\t{\n+\t  if (summary)\n+\t    summary->retslot_flags = flags;\n+\t  if (summary_lto)\n+\t    summary_lto->retslot_flags = flags;\n+\t  record_escape_points (lattice[SSA_NAME_VERSION (retslot)],\n+\t\t\t\tescape_point::retslot_arg, flags);\n \t}\n     }\n   if (ipa)\n@@ -2287,6 +2341,7 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n   dst_data->writes_errno = src_data->writes_errno;\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n+  dst_data->retslot_flags = src_data->retslot_flags;\n }\n \n /* Called when new clone is inserted to callgraph late.  */\n@@ -2312,6 +2367,7 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n   dst_data->writes_errno = src_data->writes_errno;\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n+  dst_data->retslot_flags = src_data->retslot_flags;\n }\n \n namespace\n@@ -2551,7 +2607,7 @@ modref_write_escape_summary (struct bitpack_d *bp, escape_summary *esum)\n   escape_entry *ee;\n   FOR_EACH_VEC_ELT (esum->esc, i, ee)\n     {\n-      bp_pack_var_len_unsigned (bp, ee->parm_index);\n+      bp_pack_var_len_int (bp, ee->parm_index);\n       bp_pack_var_len_unsigned (bp, ee->arg);\n       bp_pack_var_len_unsigned (bp, ee->min_flags);\n       bp_pack_value (bp, ee->direct, 1);\n@@ -2571,7 +2627,7 @@ modref_read_escape_summary (struct bitpack_d *bp, cgraph_edge *e)\n   for (unsigned int i = 0; i < n; i++)\n     {\n       escape_entry ee;\n-      ee.parm_index = bp_unpack_var_len_unsigned (bp);\n+      ee.parm_index = bp_unpack_var_len_int (bp);\n       ee.arg = bp_unpack_var_len_unsigned (bp);\n       ee.min_flags = bp_unpack_var_len_unsigned (bp);\n       ee.direct = bp_unpack_value (bp, 1);\n@@ -2628,6 +2684,7 @@ modref_write ()\n \t  streamer_write_uhwi (ob, r->arg_flags.length ());\n \t  for (unsigned int i = 0; i < r->arg_flags.length (); i++)\n \t    streamer_write_uhwi (ob, r->arg_flags[i]);\n+\t  streamer_write_uhwi (ob, r->retslot_flags);\n \n \t  write_modref_records (r->loads, ob);\n \t  write_modref_records (r->stores, ob);\n@@ -2724,6 +2781,11 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  if (modref_sum_lto)\n \t    modref_sum_lto->arg_flags.quick_push (flags);\n \t}\n+      eaf_flags_t flags = streamer_read_uhwi (&ib);\n+      if (modref_sum)\n+\tmodref_sum->retslot_flags = flags;\n+      if (modref_sum_lto)\n+\tmodref_sum_lto->retslot_flags = flags;\n       read_modref_records (&ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->loads : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->loads : NULL);\n@@ -3098,7 +3160,7 @@ struct escape_map\n   bool direct;\n };\n \n-/* Update escape map fo E.  */\n+/* Update escape map for E.  */\n \n static void\n update_escape_summary_1 (cgraph_edge *e,\n@@ -3117,15 +3179,18 @@ update_escape_summary_1 (cgraph_edge *e,\n     {\n       unsigned int j;\n       struct escape_map *em;\n-      if (ee->parm_index >= map.length ())\n+      /* TODO: We do not have jump functions for return slots, so we\n+\t never propagate them to outer function.  */\n+      if (ee->parm_index >= (int)map.length ()\n+\t  || ee->parm_index < 0)\n \tcontinue;\n       FOR_EACH_VEC_ELT (map[ee->parm_index], j, em)\n \t{\n \t  int min_flags = ee->min_flags;\n \t  if (ee->direct && !em->direct)\n \t    min_flags = deref_flags (min_flags, ignore_stores);\n \t  struct escape_entry entry = {em->parm_index, ee->arg,\n-\t    \t\t\t       ee->min_flags,\n+\t\t\t\t       ee->min_flags,\n \t\t\t\t       ee->direct & em->direct};\n \t  sum->esc.safe_push (entry);\n \t}\n@@ -3245,7 +3310,11 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n     FOR_EACH_VEC_ELT (sum->esc, i, ee)\n       {\n \tbool needed = false;\n-\tif (to_info && to_info->arg_flags.length () > ee->parm_index)\n+\t/* TODO: We do not have jump functions for return slots, so we\n+\t   never propagate them to outer function.  */\n+\tif (ee->parm_index < 0)\n+\t  continue;\n+\tif (to_info && (int)to_info->arg_flags.length () > ee->parm_index)\n \t  {\n \t    int flags = callee_info\n \t\t\t&& callee_info->arg_flags.length () > ee->arg\n@@ -3259,7 +3328,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t    if (to_info->arg_flags[ee->parm_index])\n \t      needed = true;\n \t  }\n-\tif (to_info_lto && to_info_lto->arg_flags.length () > ee->parm_index)\n+\tif (to_info_lto && (int)to_info_lto->arg_flags.length () > ee->parm_index)\n \t  {\n \t    int flags = callee_info_lto\n \t\t\t&& callee_info_lto->arg_flags.length () > ee->arg\n@@ -3798,29 +3867,31 @@ modref_merge_call_site_flags (escape_summary *sum,\n       if (flags_lto & EAF_NOESCAPE)\n \tflags_lto |= EAF_NODIRECTESCAPE;\n       if (!(flags & EAF_UNUSED)\n-\t  && cur_summary && ee->parm_index < cur_summary->arg_flags.length ())\n+\t  && cur_summary && ee->parm_index < (int)cur_summary->arg_flags.length ())\n \t{\n-\t  int f = cur_summary->arg_flags[ee->parm_index];\n+\t  eaf_flags_t &f = ee->parm_index == escape_point::retslot_arg\n+\t\t\t   ? cur_summary->retslot_flags\n+\t\t\t   : cur_summary->arg_flags[ee->parm_index];\n \t  if ((f & flags) != f)\n \t    {\n \t      f = remove_useless_eaf_flags\n \t\t\t (f & flags, ecf_flags,\n \t\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (caller))));\n-\t      cur_summary->arg_flags[ee->parm_index] = f;\n \t      changed = true;\n \t    }\n \t}\n       if (!(flags_lto & EAF_UNUSED)\n \t  && cur_summary_lto\n-\t  && ee->parm_index < cur_summary_lto->arg_flags.length ())\n+\t  && ee->parm_index < (int)cur_summary_lto->arg_flags.length ())\n \t{\n-\t  int f = cur_summary_lto->arg_flags[ee->parm_index];\n+\t  eaf_flags_t &f = ee->parm_index == escape_point::retslot_arg\n+\t\t\t   ? cur_summary_lto->retslot_flags\n+\t\t\t   : cur_summary_lto->arg_flags[ee->parm_index];\n \t  if ((f & flags_lto) != f)\n \t    {\n \t      f = remove_useless_eaf_flags\n \t\t\t (f & flags_lto, ecf_flags,\n \t\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (caller))));\n-\t      cur_summary_lto->arg_flags[ee->parm_index] = f;\n \t      changed = true;\n \t    }\n \t}"}, {"sha": "a4db27471ebc945c2c35665ad6311096f56dd7c3", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "patch": "@@ -31,6 +31,7 @@ struct GTY(()) modref_summary\n   modref_records *loads;\n   modref_records *stores;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n+  eaf_flags_t retslot_flags;\n   bool writes_errno;\n \n   modref_summary ();"}, {"sha": "99072df0768b5ecee0eb47b38f0ff128c4093209", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ef019ab938471f7f877a1eee3a6374fd8a6ae9/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=b8ef019ab938471f7f877a1eee3a6374fd8a6ae9", "patch": "@@ -4254,17 +4254,28 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results,\n       && gimple_call_lhs (stmt) != NULL_TREE\n       && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n     {\n-      auto_vec<ce_s> tmpc;\n-      struct constraint_expr *c;\n-      unsigned i;\n+      int flags = gimple_call_retslot_flags (stmt);\n+      if ((flags & (EAF_NOESCAPE | EAF_NOT_RETURNED))\n+\t  != (EAF_NOESCAPE | EAF_NOT_RETURNED))\n+\t{\n+\t  auto_vec<ce_s> tmpc;\n \n-      get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n+\t  get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n \n-      make_constraints_to (callescape->id, tmpc);\n-      if (writes_global_memory)\n-\tmake_constraints_to (escaped_id, tmpc);\n-      FOR_EACH_VEC_ELT (tmpc, i, c)\n-\tresults->safe_push (*c);\n+\t  if (!(flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE)))\n+\t    {\n+\t      make_constraints_to (callescape->id, tmpc);\n+\t      if (writes_global_memory)\n+\t\tmake_constraints_to (escaped_id, tmpc);\n+\t    }\n+\t  if (!(flags & EAF_NOT_RETURNED))\n+\t    {\n+\t      struct constraint_expr *c;\n+\t      unsigned i;\n+\t      FOR_EACH_VEC_ELT (tmpc, i, c)\n+\t\tresults->safe_push (*c);\n+\t    }\n+\t}\n     }\n }\n "}]}