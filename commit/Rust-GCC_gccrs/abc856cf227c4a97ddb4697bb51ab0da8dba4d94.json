{"sha": "abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJjODU2Y2YyMjdjNGE5N2RkYjQ2OTdiYjUxYWIwZGE4ZGJhNGQ5NA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-03T08:15:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-03T08:15:54Z"}, "message": "[Ada] Spurious visibility error in inlined function\n\nThis patch corrects the use of tree replication when inlining a function\nthat returns an unconstrained result, and its sole statement is an\nextended return statement. The use of New_Copy_Tree ensires that global\nreferences saved in a generic template are properly carried over when\nthe function is instantiated and inlined.\n\n2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* inline.adb (Build_Return_Object_Formal): New routine.\n\t(Can_Split_Unconstrained_Function): Code clean up.\n\t(Copy_Formals,Copy_Return_Object): New routines.\n\t(Split_Unconstrained_Function): Code clean up and refactoring.\n\ngcc/testsuite/\n\n\t* gnat.dg/inline15.adb, gnat.dg/inline15_gen.adb,\n\tgnat.dg/inline15_gen.ads, gnat.dg/inline15_types.ads: New\n\ttestcase.\n\nFrom-SVN: r272980", "tree": {"sha": "6e6c2f1efc4a5602bf9a67beab58af8616112ac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e6c2f1efc4a5602bf9a67beab58af8616112ac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "866000e7fb53a137db4e876dcd3f6b46195a6683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866000e7fb53a137db4e876dcd3f6b46195a6683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866000e7fb53a137db4e876dcd3f6b46195a6683"}], "stats": {"total": 346, "additions": 255, "deletions": 91}, "files": [{"sha": "d25fcbe47ca71b060e921652fa65b59fae709d3f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -1,3 +1,10 @@\n+2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* inline.adb (Build_Return_Object_Formal): New routine.\n+\t(Can_Split_Unconstrained_Function): Code clean up.\n+\t(Copy_Formals,Copy_Return_Object): New routines.\n+\t(Split_Unconstrained_Function): Code clean up and refactoring.\n+\n 2019-07-03  Gary Dismukes  <dismukes@adacore.com>\n \n \t* bindo-augmentors.adb, bindo-augmentors.ads,"}, {"sha": "653908a71448be47553524bd59172eac139de21b", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 176, "deletions": 91, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -1706,11 +1706,29 @@ package body Inline is\n       --  Use generic machinery to build an unexpanded body for the subprogram.\n       --  This body is subsequently used for inline expansions at call sites.\n \n+      procedure Build_Return_Object_Formal\n+        (Loc      : Source_Ptr;\n+         Obj_Decl : Node_Id;\n+         Formals  : List_Id);\n+      --  Create a formal parameter for return object declaration Obj_Decl of\n+      --  an extended return statement and add it to list Formals.\n+\n       function Can_Split_Unconstrained_Function (N : Node_Id) return Boolean;\n       --  Return true if we generate code for the function body N, the function\n       --  body N has no local declarations and its unique statement is a single\n       --  extended return statement with a handled statements sequence.\n \n+      procedure Copy_Formals\n+        (Loc     : Source_Ptr;\n+         Subp_Id : Entity_Id;\n+         Formals : List_Id);\n+      --  Create new formal parameters from the formal parameters of subprogram\n+      --  Subp_Id and add them to list Formals.\n+\n+      function Copy_Return_Object (Obj_Decl : Node_Id) return Node_Id;\n+      --  Create a copy of return object declaration Obj_Decl of an extended\n+      --  return statement.\n+\n       procedure Split_Unconstrained_Function\n         (N       : Node_Id;\n          Spec_Id : Entity_Id);\n@@ -1757,6 +1775,9 @@ package body Inline is\n                Body_To_Inline :=\n                  Copy_Generic_Node (N, Empty, Instantiating => True);\n             else\n+               --  ??? Shouldn't this use New_Copy_Tree? What about global\n+               --  references captured in the body to inline?\n+\n                Body_To_Inline := Copy_Separate_Tree (N);\n             end if;\n \n@@ -1845,43 +1866,142 @@ package body Inline is\n          Set_Ekind (Defining_Entity (Original_Body), Ekind (Spec_Id));\n       end Build_Body_To_Inline;\n \n+      --------------------------------\n+      -- Build_Return_Object_Formal --\n+      --------------------------------\n+\n+      procedure Build_Return_Object_Formal\n+        (Loc      : Source_Ptr;\n+         Obj_Decl : Node_Id;\n+         Formals  : List_Id)\n+      is\n+         Obj_Def : constant Node_Id   := Object_Definition (Obj_Decl);\n+         Obj_Id  : constant Entity_Id := Defining_Entity   (Obj_Decl);\n+         Typ_Def : Node_Id;\n+\n+      begin\n+         --  Build the type definition of the formal parameter. The use of\n+         --  New_Copy_Tree ensures that global references preserved in the\n+         --  case of generics.\n+\n+         if Is_Entity_Name (Obj_Def) then\n+            Typ_Def := New_Copy_Tree (Obj_Def);\n+         else\n+            Typ_Def := New_Copy_Tree (Subtype_Mark (Obj_Def));\n+         end if;\n+\n+         --  Generate:\n+         --\n+         --    Obj_Id : [out] Typ_Def\n+\n+         --  Mode OUT should not be used when the return object is declared as\n+         --  a constant. Check the definition of the object declaration because\n+         --  the object has not been analyzed yet.\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier    =>\n+               Make_Defining_Identifier (Loc, Chars (Obj_Id)),\n+             In_Present             => False,\n+             Out_Present            => not Constant_Present (Obj_Decl),\n+             Null_Exclusion_Present => False,\n+             Parameter_Type         => Typ_Def));\n+      end Build_Return_Object_Formal;\n+\n       --------------------------------------\n       -- Can_Split_Unconstrained_Function --\n       --------------------------------------\n \n       function Can_Split_Unconstrained_Function (N : Node_Id) return Boolean is\n-         Ret_Node : constant Node_Id :=\n-                      First (Statements (Handled_Statement_Sequence (N)));\n-         D : Node_Id;\n+         Stmt : constant Node_Id :=\n+                  First (Statements (Handled_Statement_Sequence (N)));\n+         Decl : Node_Id;\n \n       begin\n          --  No user defined declarations allowed in the function except inside\n          --  the unique return statement; implicit labels are the only allowed\n          --  declarations.\n \n-         if not Is_Empty_List (Declarations (N)) then\n-            D := First (Declarations (N));\n-            while Present (D) loop\n-               if Nkind (D) /= N_Implicit_Label_Declaration then\n-                  return False;\n-               end if;\n+         Decl := First (Declarations (N));\n+         while Present (Decl) loop\n+            if Nkind (Decl) /= N_Implicit_Label_Declaration then\n+               return False;\n+            end if;\n \n-               Next (D);\n-            end loop;\n-         end if;\n+            Next (Decl);\n+         end loop;\n \n          --  We only split the inlined function when we are generating the code\n          --  of its body; otherwise we leave duplicated split subprograms in\n          --  the tree which (if referenced) generate wrong references at link\n          --  time.\n \n          return In_Extended_Main_Code_Unit (N)\n-           and then Present (Ret_Node)\n-           and then Nkind (Ret_Node) = N_Extended_Return_Statement\n-           and then No (Next (Ret_Node))\n-           and then Present (Handled_Statement_Sequence (Ret_Node));\n+           and then Present (Stmt)\n+           and then Nkind (Stmt) = N_Extended_Return_Statement\n+           and then No (Next (Stmt))\n+           and then Present (Handled_Statement_Sequence (Stmt));\n       end Can_Split_Unconstrained_Function;\n \n+      ------------------\n+      -- Copy_Formals --\n+      ------------------\n+\n+      procedure Copy_Formals\n+        (Loc     : Source_Ptr;\n+         Subp_Id : Entity_Id;\n+         Formals : List_Id)\n+      is\n+         Formal : Entity_Id;\n+         Spec   : Node_Id;\n+\n+      begin\n+         Formal := First_Formal (Subp_Id);\n+         while Present (Formal) loop\n+            Spec := Parent (Formal);\n+\n+            --  Create an exact copy of the formal parameter. The use of\n+            --  New_Copy_Tree ensures that global references are preserved\n+            --  in case of generics.\n+\n+            Append_To (Formals,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier    =>\n+                  Make_Defining_Identifier (Sloc (Formal), Chars (Formal)),\n+                In_Present             => In_Present  (Spec),\n+                Out_Present            => Out_Present (Spec),\n+                Null_Exclusion_Present => Null_Exclusion_Present (Spec),\n+                Parameter_Type         =>\n+                  New_Copy_Tree (Parameter_Type (Spec)),\n+                Expression             => New_Copy_Tree (Expression (Spec))));\n+\n+            Next_Formal (Formal);\n+         end loop;\n+      end Copy_Formals;\n+\n+      ------------------------\n+      -- Copy_Return_Object --\n+      ------------------------\n+\n+      function Copy_Return_Object (Obj_Decl : Node_Id) return Node_Id is\n+         Obj_Id  : constant Entity_Id := Defining_Entity (Obj_Decl);\n+\n+      begin\n+         --  The use of New_Copy_Tree ensures that global references are\n+         --  preserved in case of generics.\n+\n+         return\n+           Make_Object_Declaration (Sloc (Obj_Decl),\n+             Defining_Identifier    =>\n+               Make_Defining_Identifier (Sloc (Obj_Id), Chars (Obj_Id)),\n+             Aliased_Present        => Aliased_Present  (Obj_Decl),\n+             Constant_Present       => Constant_Present (Obj_Decl),\n+             Null_Exclusion_Present => Null_Exclusion_Present (Obj_Decl),\n+             Object_Definition      =>\n+               New_Copy_Tree (Object_Definition (Obj_Decl)),\n+             Expression             => New_Copy_Tree (Expression (Obj_Decl)));\n+      end Copy_Return_Object;\n+\n       ----------------------------------\n       -- Split_Unconstrained_Function --\n       ----------------------------------\n@@ -1891,10 +2011,10 @@ package body Inline is\n          Spec_Id  : Entity_Id)\n       is\n          Loc      : constant Source_Ptr := Sloc (N);\n-         Ret_Node : constant Node_Id :=\n+         Ret_Stmt : constant Node_Id :=\n                       First (Statements (Handled_Statement_Sequence (N)));\n          Ret_Obj  : constant Node_Id :=\n-                      First (Return_Object_Declarations (Ret_Node));\n+                      First (Return_Object_Declarations (Ret_Stmt));\n \n          procedure Build_Procedure\n            (Proc_Id   : out Entity_Id;\n@@ -1910,63 +2030,35 @@ package body Inline is\n            (Proc_Id   : out Entity_Id;\n             Decl_List : out List_Id)\n          is\n-            Formal         : Entity_Id;\n-            Formal_List    : constant List_Id := New_List;\n-            Proc_Spec      : Node_Id;\n-            Proc_Body      : Node_Id;\n-            Subp_Name      : constant Name_Id := New_Internal_Name ('F');\n-            Body_Decl_List : List_Id := No_List;\n-            Param_Type     : Node_Id;\n+            Formals   : constant List_Id   := New_List;\n+            Subp_Name : constant Name_Id   := New_Internal_Name ('F');\n \n-         begin\n-            if Nkind (Object_Definition (Ret_Obj)) = N_Identifier then\n-               Param_Type :=\n-                 New_Copy (Object_Definition (Ret_Obj));\n-            else\n-               Param_Type :=\n-                 New_Copy (Subtype_Mark (Object_Definition (Ret_Obj)));\n-            end if;\n+            Body_Decls : List_Id := No_List;\n+            Decl       : Node_Id;\n+            Proc_Body  : Node_Id;\n+            Proc_Spec  : Node_Id;\n \n-            Append_To (Formal_List,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier    =>\n-                  Make_Defining_Identifier (Loc,\n-                    Chars => Chars (Defining_Identifier (Ret_Obj))),\n-                In_Present             => False,\n-                Out_Present            => True,\n-                Null_Exclusion_Present => False,\n-                Parameter_Type         => Param_Type));\n-\n-            Formal := First_Formal (Spec_Id);\n-\n-            --  Note that we copy the parameter type rather than creating\n-            --  a reference to it, because it may be a class-wide entity\n-            --  that will not be retrieved by name.\n+         begin\n+            --  Create formal parameters for the return object and all formals\n+            --  of the unconstrained function in order to pass their values to\n+            --  the procedure.\n \n-            while Present (Formal) loop\n-               Append_To (Formal_List,\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier    =>\n-                     Make_Defining_Identifier (Sloc (Formal),\n-                       Chars => Chars (Formal)),\n-                   In_Present             => In_Present (Parent (Formal)),\n-                   Out_Present            => Out_Present (Parent (Formal)),\n-                   Null_Exclusion_Present =>\n-                     Null_Exclusion_Present (Parent (Formal)),\n-                   Parameter_Type         =>\n-                     New_Copy_Tree (Parameter_Type (Parent (Formal))),\n-                   Expression             =>\n-                     Copy_Separate_Tree (Expression (Parent (Formal)))));\n+            Build_Return_Object_Formal\n+              (Loc      => Loc,\n+               Obj_Decl => Ret_Obj,\n+               Formals  => Formals);\n \n-               Next_Formal (Formal);\n-            end loop;\n+            Copy_Formals\n+              (Loc     => Loc,\n+               Subp_Id => Spec_Id,\n+               Formals => Formals);\n \n             Proc_Id := Make_Defining_Identifier (Loc, Chars => Subp_Name);\n \n             Proc_Spec :=\n               Make_Procedure_Specification (Loc,\n                 Defining_Unit_Name       => Proc_Id,\n-                Parameter_Specifications => Formal_List);\n+                Parameter_Specifications => Formals);\n \n             Decl_List := New_List;\n \n@@ -1978,37 +2070,30 @@ package body Inline is\n             --  Copy these declarations to the built procedure.\n \n             if Present (Declarations (N)) then\n-               Body_Decl_List := New_List;\n+               Body_Decls := New_List;\n \n-               declare\n-                  D     : Node_Id;\n-                  New_D : Node_Id;\n+               Decl := First (Declarations (N));\n+               while Present (Decl) loop\n+                  pragma Assert (Nkind (Decl) = N_Implicit_Label_Declaration);\n \n-               begin\n-                  D := First (Declarations (N));\n-                  while Present (D) loop\n-                     pragma Assert (Nkind (D) = N_Implicit_Label_Declaration);\n-\n-                     New_D :=\n-                       Make_Implicit_Label_Declaration (Loc,\n-                         Make_Defining_Identifier (Loc,\n-                           Chars => Chars (Defining_Identifier (D))),\n-                         Label_Construct => Empty);\n-                     Append_To (Body_Decl_List, New_D);\n-\n-                     Next (D);\n-                  end loop;\n-               end;\n+                  Append_To (Body_Decls,\n+                    Make_Implicit_Label_Declaration (Loc,\n+                      Make_Defining_Identifier (Loc,\n+                        Chars => Chars (Defining_Identifier (Decl))),\n+                      Label_Construct => Empty));\n+\n+                  Next (Decl);\n+               end loop;\n             end if;\n \n-            pragma Assert (Present (Handled_Statement_Sequence (Ret_Node)));\n+            pragma Assert (Present (Handled_Statement_Sequence (Ret_Stmt)));\n \n             Proc_Body :=\n               Make_Subprogram_Body (Loc,\n-                Specification => Copy_Separate_Tree (Proc_Spec),\n-                Declarations  => Body_Decl_List,\n+                Specification              => Copy_Subprogram_Spec (Proc_Spec),\n+                Declarations               => Body_Decls,\n                 Handled_Statement_Sequence =>\n-                  Copy_Separate_Tree (Handled_Statement_Sequence (Ret_Node)));\n+                  New_Copy_Tree (Handled_Statement_Sequence (Ret_Stmt)));\n \n             Set_Defining_Unit_Name (Specification (Proc_Body),\n                Make_Defining_Identifier (Loc, Subp_Name));\n@@ -2018,10 +2103,10 @@ package body Inline is\n \n          --  Local variables\n \n-         New_Obj   : constant Node_Id := Copy_Separate_Tree (Ret_Obj);\n+         New_Obj   : constant Node_Id := Copy_Return_Object (Ret_Obj);\n          Blk_Stmt  : Node_Id;\n-         Proc_Id   : Entity_Id;\n          Proc_Call : Node_Id;\n+         Proc_Id   : Entity_Id;\n \n       --  Start of processing for Split_Unconstrained_Function\n \n@@ -2089,7 +2174,7 @@ package body Inline is\n                        New_Occurrence_Of\n                          (Defining_Identifier (New_Obj), Loc)))));\n \n-         Rewrite (Ret_Node, Blk_Stmt);\n+         Rewrite (Ret_Stmt, Blk_Stmt);\n       end Split_Unconstrained_Function;\n \n       --  Local variables"}, {"sha": "91168935178e51e9a98b79b2ea76278c017ec31d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -1,3 +1,9 @@\n+2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/inline15.adb, gnat.dg/inline15_gen.adb,\n+\tgnat.dg/inline15_gen.ads, gnat.dg/inline15_types.ads: New\n+\ttestcase.\n+\n 2019-07-03  Bob Duff  <duff@adacore.com>\n \n \t* gnat.dg/warn20.adb, gnat.dg/warn20_pkg.adb,"}, {"sha": "953e72e44c0227bebc635772bb4778688aee30dc", "filename": "gcc/testsuite/gnat.dg/inline15.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Finline15.adb?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -0,0 +1,11 @@\n+--  { dg-do compile }\n+--  { dg-options \"-O2\" }\n+\n+with Inline15_Gen;\n+\n+procedure Inline15 is\n+   package Inst is new Inline15_Gen;\n+\n+begin\n+   Inst.Call_Func;\n+end Inline15;"}, {"sha": "f2b17f8af3029a1b4322fb347df682624814b3ad", "filename": "gcc/testsuite/gnat.dg/inline15_gen.adb", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_gen.adb?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -0,0 +1,27 @@\n+package body Inline15_Gen is\n+   function Initialize (Val : Inline15_Types.Enum) return Inline15_Types.Rec;\n+   procedure Print (Val : Inline15_Types.Rec);\n+\n+   procedure Call_Func is\n+      Result : constant Inline15_Types.Rec := Func (Inline15_Types.Two);\n+   begin\n+      null;\n+   end Call_Func;\n+\n+   function Func (Val : Inline15_Types.Enum) return Inline15_Types.Rec is\n+   begin\n+      return Result : constant Inline15_Types.Rec := Initialize (Val) do\n+         Print (Result);\n+      end return;\n+   end Func;\n+\n+   function Initialize (Val : Inline15_Types.Enum) return Inline15_Types.Rec is\n+      pragma Warnings (Off);\n+      Result : Inline15_Types.Rec (Val);\n+      pragma Warnings (On);\n+   begin\n+      return Result;\n+   end Initialize;\n+\n+   procedure Print (Val : Inline15_Types.Rec) is begin null; end Print;\n+end Inline15_Gen;"}, {"sha": "42856e8cd0fa651141acd298c9884f19739b4b70", "filename": "gcc/testsuite/gnat.dg/inline15_gen.ads", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_gen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_gen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_gen.ads?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -0,0 +1,11 @@\n+\n+--  gen.ads\n+\n+with Inline15_Types;\n+\n+generic\n+package Inline15_Gen is\n+   function Func (Val : Inline15_Types.Enum) return Inline15_Types.Rec with Inline;\n+\n+   procedure Call_Func with Inline;\n+end Inline15_Gen;"}, {"sha": "5aaa2d64bf1f9ea16ea0a72e487558024ed08352", "filename": "gcc/testsuite/gnat.dg/inline15_types.ads", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_types.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc856cf227c4a97ddb4697bb51ab0da8dba4d94/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_types.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Finline15_types.ads?ref=abc856cf227c4a97ddb4697bb51ab0da8dba4d94", "patch": "@@ -0,0 +1,17 @@\n+package Inline15_Types is\n+   type Enum is (One, Two, Three, Four);\n+\n+   type Rec (Discr : Enum) is record\n+      Comp_1 : Integer;\n+\n+      case Discr is\n+         when One =>\n+            Comp_2 : Float;\n+         when Two =>\n+            Comp_3 : Boolean;\n+            Comp_4 : Long_Float;\n+         when others =>\n+            null;\n+      end case;\n+   end record;\n+end Inline15_Types;"}]}