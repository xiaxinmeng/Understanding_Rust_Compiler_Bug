{"sha": "acda0629ffd1ce4fa1189f9b36e724267cc63795", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNkYTA2MjlmZmQxY2U0ZmExMTg5ZjliMzZlNzI0MjY3Y2M2Mzc5NQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-10-11T19:19:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-10-11T19:19:05Z"}, "message": "Split print_rtx into subroutines\n\ngcc/ChangeLog:\n\t* print-rtl.c (print_rtx): Rename \"i\" to \"idx\".  Split out the\n\toperand-printing \"switch\" statement into...\n\t(print_rtx_operand_code_0): ...this new function, ...\n\t(print_rtx_operand_code_e): ...this new function, ...\n\t(print_rtx_operand_codes_E_and_V): ...this new function, ...\n\t(print_rtx_operand_code_i): ...this new function, ...\n\t(print_rtx_operand_code_r): ...this new function, ...\n\t(print_rtx_operand_code_u): ...this new function, ...\n\t(print_rtx_operand): ...and this new function.\n\nFrom-SVN: r241002", "tree": {"sha": "e323afc12d203f1f66112715594b6393aded75ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e323afc12d203f1f66112715594b6393aded75ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acda0629ffd1ce4fa1189f9b36e724267cc63795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acda0629ffd1ce4fa1189f9b36e724267cc63795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acda0629ffd1ce4fa1189f9b36e724267cc63795", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acda0629ffd1ce4fa1189f9b36e724267cc63795/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec08df86cb5af4ab34f8251b38f52be7b99bfa20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec08df86cb5af4ab34f8251b38f52be7b99bfa20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec08df86cb5af4ab34f8251b38f52be7b99bfa20"}], "stats": {"total": 863, "additions": 467, "deletions": 396}, "files": [{"sha": "d555c2e768b103e3a0922d210a96c83f58e08ee1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acda0629ffd1ce4fa1189f9b36e724267cc63795/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acda0629ffd1ce4fa1189f9b36e724267cc63795/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acda0629ffd1ce4fa1189f9b36e724267cc63795", "patch": "@@ -1,3 +1,15 @@\n+2016-10-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* print-rtl.c (print_rtx): Rename \"i\" to \"idx\".  Split out the\n+\toperand-printing \"switch\" statement into...\n+\t(print_rtx_operand_code_0): ...this new function, ...\n+\t(print_rtx_operand_code_e): ...this new function, ...\n+\t(print_rtx_operand_codes_E_and_V): ...this new function, ...\n+\t(print_rtx_operand_code_i): ...this new function, ...\n+\t(print_rtx_operand_code_r): ...this new function, ...\n+\t(print_rtx_operand_code_u): ...this new function, ...\n+\t(print_rtx_operand): ...and this new function.\n+\n 2016-10-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha-passes.def: New file."}, {"sha": "29e8ee2e180d8ca8f30acb0add0f44da7647b235", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 455, "deletions": 396, "changes": 851, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acda0629ffd1ce4fa1189f9b36e724267cc63795/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acda0629ffd1ce4fa1189f9b36e724267cc63795/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=acda0629ffd1ce4fa1189f9b36e724267cc63795", "patch": "@@ -94,15 +94,462 @@ print_mem_expr (FILE *outfile, const_tree expr)\n }\n #endif\n \n+/* Subroutine of print_rtx_operand for handling code '0'.\n+   0 indicates a field for internal use that should not be printed.\n+   However there are various special cases, such as the third field\n+   of a NOTE, where it indicates that the field has several different\n+   valid contents.  */\n+\n+static void\n+print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n+\t\t\t  int idx ATTRIBUTE_UNUSED)\n+{\n+#ifndef GENERATOR_FILE\n+  if (idx == 1 && GET_CODE (in_rtx) == SYMBOL_REF)\n+    {\n+      int flags = SYMBOL_REF_FLAGS (in_rtx);\n+      if (flags)\n+\tfprintf (outfile, \" [flags %#x]\", flags);\n+      tree decl = SYMBOL_REF_DECL (in_rtx);\n+      if (decl)\n+\tprint_node_brief (outfile, \"\", decl, dump_flags);\n+    }\n+  else if (idx == 3 && NOTE_P (in_rtx))\n+    {\n+      switch (NOTE_KIND (in_rtx))\n+\t{\n+\tcase NOTE_INSN_EH_REGION_BEG:\n+\tcase NOTE_INSN_EH_REGION_END:\n+\t  if (flag_dump_unnumbered)\n+\t    fprintf (outfile, \" #\");\n+\t  else\n+\t    fprintf (outfile, \" %d\", NOTE_EH_HANDLER (in_rtx));\n+\t  sawclose = 1;\n+\t  break;\n+\n+\tcase NOTE_INSN_BLOCK_BEG:\n+\tcase NOTE_INSN_BLOCK_END:\n+\t  dump_addr (outfile, \" \", NOTE_BLOCK (in_rtx));\n+\t  sawclose = 1;\n+\t  break;\n+\n+\tcase NOTE_INSN_BASIC_BLOCK:\n+\t  {\n+\t    basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t    if (bb != 0)\n+\t      fprintf (outfile, \" [bb %d]\", bb->index);\n+\t    break;\n+\t  }\n+\n+\tcase NOTE_INSN_DELETED_LABEL:\n+\tcase NOTE_INSN_DELETED_DEBUG_LABEL:\n+\t  {\n+\t    const char *label = NOTE_DELETED_LABEL_NAME (in_rtx);\n+\t    if (label)\n+\t      fprintf (outfile, \" (\\\"%s\\\")\", label);\n+\t    else\n+\t      fprintf (outfile, \" \\\"\\\"\");\n+\t  }\n+\t  break;\n+\n+\tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n+\t  {\n+\t    basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t    if (bb != 0)\n+\t      fprintf (outfile, \" [bb %d]\", bb->index);\n+\t    break;\n+\t  }\n+\n+\tcase NOTE_INSN_VAR_LOCATION:\n+\tcase NOTE_INSN_CALL_ARG_LOCATION:\n+\t  fputc (' ', outfile);\n+\t  print_rtx (NOTE_VAR_LOCATION (in_rtx));\n+\t  break;\n+\n+\tcase NOTE_INSN_CFI:\n+\t  fputc ('\\n', outfile);\n+\t  output_cfi_directive (outfile, NOTE_CFI (in_rtx));\n+\t  fputc ('\\t', outfile);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  else if (idx == 7 && JUMP_P (in_rtx) && JUMP_LABEL (in_rtx) != NULL)\n+    {\n+      /* Output the JUMP_LABEL reference.  */\n+      fprintf (outfile, \"\\n%s%*s -> \", print_rtx_head, indent * 2, \"\");\n+      if (GET_CODE (JUMP_LABEL (in_rtx)) == RETURN)\n+\tfprintf (outfile, \"return\");\n+      else if (GET_CODE (JUMP_LABEL (in_rtx)) == SIMPLE_RETURN)\n+\tfprintf (outfile, \"simple_return\");\n+      else\n+\tfprintf (outfile, \"%d\", INSN_UID (JUMP_LABEL (in_rtx)));\n+    }\n+  else if (idx == 0 && GET_CODE (in_rtx) == VALUE)\n+    {\n+      cselib_val *val = CSELIB_VAL_PTR (in_rtx);\n+\n+      fprintf (outfile, \" %u:%u\", val->uid, val->hash);\n+      dump_addr (outfile, \" @\", in_rtx);\n+      dump_addr (outfile, \"/\", (void*)val);\n+    }\n+  else if (idx == 0 && GET_CODE (in_rtx) == DEBUG_EXPR)\n+    {\n+      fprintf (outfile, \" D#%i\",\n+\t       DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (in_rtx)));\n+    }\n+  else if (idx == 0 && GET_CODE (in_rtx) == ENTRY_VALUE)\n+    {\n+      indent += 2;\n+      if (!sawclose)\n+\tfprintf (outfile, \" \");\n+      print_rtx (ENTRY_VALUE_EXP (in_rtx));\n+      indent -= 2;\n+    }\n+#endif\n+}\n+\n+/* Subroutine of print_rtx_operand for handling code 'e'.\n+   Also called by print_rtx_operand_code_u for handling code 'u'\n+   for LABEL_REFs when they don't reference a CODE_LABEL.  */\n+\n+static void\n+print_rtx_operand_code_e (const_rtx in_rtx, int idx)\n+{\n+  indent += 2;\n+  if (idx == 6 && INSN_P (in_rtx))\n+    /* Put REG_NOTES on their own line.  */\n+    fprintf (outfile, \"\\n%s%*s\",\n+\t     print_rtx_head, indent * 2, \"\");\n+  if (!sawclose)\n+    fprintf (outfile, \" \");\n+  if (idx == 7 && CALL_P (in_rtx))\n+    {\n+      in_call_function_usage = true;\n+      print_rtx (XEXP (in_rtx, idx));\n+      in_call_function_usage = false;\n+    }\n+  else\n+    print_rtx (XEXP (in_rtx, idx));\n+  indent -= 2;\n+}\n+\n+/* Subroutine of print_rtx_operand for handling codes 'E' and 'V'.  */\n+\n+static void\n+print_rtx_operand_codes_E_and_V (const_rtx in_rtx, int idx)\n+{\n+  indent += 2;\n+  if (sawclose)\n+    {\n+      fprintf (outfile, \"\\n%s%*s\",\n+      print_rtx_head, indent * 2, \"\");\n+      sawclose = 0;\n+    }\n+  fputs (\" [\", outfile);\n+  if (NULL != XVEC (in_rtx, idx))\n+    {\n+      indent += 2;\n+      if (XVECLEN (in_rtx, idx))\n+\tsawclose = 1;\n+\n+      for (int j = 0; j < XVECLEN (in_rtx, idx); j++)\n+\tprint_rtx (XVECEXP (in_rtx, idx, j));\n+\n+      indent -= 2;\n+    }\n+  if (sawclose)\n+    fprintf (outfile, \"\\n%s%*s\", print_rtx_head, indent * 2, \"\");\n+\n+  fputs (\"]\", outfile);\n+  sawclose = 1;\n+  indent -= 2;\n+}\n+\n+/* Subroutine of print_rtx_operand for handling code 'i'.  */\n+\n+static void\n+print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n+{\n+  if (idx == 4 && INSN_P (in_rtx))\n+    {\n+#ifndef GENERATOR_FILE\n+      const rtx_insn *in_insn = as_a <const rtx_insn *> (in_rtx);\n+\n+      /*  Pretty-print insn locations.  Ignore scoping as it is mostly\n+\t  redundant with line number information and do not print anything\n+\t  when there is no location information available.  */\n+      if (INSN_HAS_LOCATION (in_insn))\n+\t{\n+\t  expanded_location xloc = insn_location (in_insn);\n+\t  fprintf (outfile, \" %s:%i\", xloc.file, xloc.line);\n+\t}\n+#endif\n+    }\n+  else if (idx == 6 && GET_CODE (in_rtx) == ASM_OPERANDS)\n+    {\n+#ifndef GENERATOR_FILE\n+      if (ASM_OPERANDS_SOURCE_LOCATION (in_rtx) != UNKNOWN_LOCATION)\n+\tfprintf (outfile, \" %s:%i\",\n+\t\t LOCATION_FILE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)),\n+\t\t LOCATION_LINE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)));\n+#endif\n+    }\n+  else if (idx == 1 && GET_CODE (in_rtx) == ASM_INPUT)\n+    {\n+#ifndef GENERATOR_FILE\n+      if (ASM_INPUT_SOURCE_LOCATION (in_rtx) != UNKNOWN_LOCATION)\n+\tfprintf (outfile, \" %s:%i\",\n+\t\t LOCATION_FILE (ASM_INPUT_SOURCE_LOCATION (in_rtx)),\n+\t\t LOCATION_LINE (ASM_INPUT_SOURCE_LOCATION (in_rtx)));\n+#endif\n+    }\n+  else if (idx == 5 && NOTE_P (in_rtx))\n+    {\n+      /* This field is only used for NOTE_INSN_DELETED_LABEL, and\n+\t other times often contains garbage from INSN->NOTE death.  */\n+      if (NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_LABEL\n+\t  || NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_DEBUG_LABEL)\n+\tfprintf (outfile, \" %d\",  XINT (in_rtx, idx));\n+    }\n+#if !defined(GENERATOR_FILE) && NUM_UNSPECV_VALUES > 0\n+  else if (idx == 1\n+\t   && GET_CODE (in_rtx) == UNSPEC_VOLATILE\n+\t   && XINT (in_rtx, 1) >= 0\n+\t   && XINT (in_rtx, 1) < NUM_UNSPECV_VALUES)\n+    fprintf (outfile, \" %s\", unspecv_strings[XINT (in_rtx, 1)]);\n+#endif\n+#if !defined(GENERATOR_FILE) && NUM_UNSPEC_VALUES > 0\n+  else if (idx == 1\n+\t   && (GET_CODE (in_rtx) == UNSPEC\n+\t       || GET_CODE (in_rtx) == UNSPEC_VOLATILE)\n+\t   && XINT (in_rtx, 1) >= 0\n+\t   && XINT (in_rtx, 1) < NUM_UNSPEC_VALUES)\n+    fprintf (outfile, \" %s\", unspec_strings[XINT (in_rtx, 1)]);\n+#endif\n+  else\n+    {\n+      int value = XINT (in_rtx, idx);\n+      const char *name;\n+      int is_insn = INSN_P (in_rtx);\n+\n+      if (flag_dump_unnumbered\n+\t  && (is_insn || NOTE_P (in_rtx)))\n+\tfputc ('#', outfile);\n+      else\n+\tfprintf (outfile, \" %d\", value);\n+\n+      if (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, idx)\n+\t  && XINT (in_rtx, idx) >= 0\n+\t  && (name = get_insn_name (XINT (in_rtx, idx))) != NULL)\n+\tfprintf (outfile, \" {%s}\", name);\n+      sawclose = 0;\n+    }\n+}\n+\n+/* Subroutine of print_rtx_operand for handling code 'r'.  */\n+\n+static void\n+print_rtx_operand_code_r (const_rtx in_rtx)\n+{\n+  int is_insn = INSN_P (in_rtx);\n+  unsigned int regno = REGNO (in_rtx);\n+\n+#ifndef GENERATOR_FILE\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    fprintf (outfile, \" %d %s\", regno, reg_names[regno]);\n+  else if (regno <= LAST_VIRTUAL_REGISTER)\n+    {\n+      if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n+\tfprintf (outfile, \" %d virtual-incoming-args\", regno);\n+      else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n+\tfprintf (outfile, \" %d virtual-stack-vars\", regno);\n+      else if (regno == VIRTUAL_STACK_DYNAMIC_REGNUM)\n+\tfprintf (outfile, \" %d virtual-stack-dynamic\", regno);\n+      else if (regno == VIRTUAL_OUTGOING_ARGS_REGNUM)\n+\tfprintf (outfile, \" %d virtual-outgoing-args\", regno);\n+      else if (regno == VIRTUAL_CFA_REGNUM)\n+\tfprintf (outfile, \" %d virtual-cfa\", regno);\n+      else if (regno == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n+\tfprintf (outfile, \" %d virtual-preferred-stack-boundary\",\n+\t\t regno);\n+      else\n+\tfprintf (outfile, \" %d virtual-reg-%d\", regno,\n+\t\t regno-FIRST_VIRTUAL_REGISTER);\n+    }\n+  else\n+#endif\n+    if (flag_dump_unnumbered && is_insn)\n+      fputc ('#', outfile);\n+    else\n+      fprintf (outfile, \" %d\", regno);\n+\n+#ifndef GENERATOR_FILE\n+  if (REG_ATTRS (in_rtx))\n+    {\n+      fputs (\" [\", outfile);\n+      if (regno != ORIGINAL_REGNO (in_rtx))\n+\tfprintf (outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n+      if (REG_EXPR (in_rtx))\n+\tprint_mem_expr (outfile, REG_EXPR (in_rtx));\n+\n+      if (REG_OFFSET (in_rtx))\n+\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n+\t\t REG_OFFSET (in_rtx));\n+      fputs (\" ]\", outfile);\n+    }\n+  if (regno != ORIGINAL_REGNO (in_rtx))\n+    fprintf (outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n+#endif\n+}\n+\n+/* Subroutine of print_rtx_operand for handling code 'u'.  */\n+\n+static void\n+print_rtx_operand_code_u (const_rtx in_rtx, int idx)\n+{\n+  if (XEXP (in_rtx, idx) != NULL)\n+    {\n+      rtx sub = XEXP (in_rtx, idx);\n+      enum rtx_code subc = GET_CODE (sub);\n+\n+      if (GET_CODE (in_rtx) == LABEL_REF)\n+\t{\n+\t  if (subc == NOTE\n+\t      && NOTE_KIND (sub) == NOTE_INSN_DELETED_LABEL)\n+\t    {\n+\t      if (flag_dump_unnumbered)\n+\t\tfprintf (outfile, \" [# deleted]\");\n+\t      else\n+\t\tfprintf (outfile, \" [%d deleted]\", INSN_UID (sub));\n+\t      sawclose = 0;\n+\t      return;\n+\t    }\n+\n+\t  if (subc != CODE_LABEL)\n+\t    {\n+\t      print_rtx_operand_code_e (in_rtx, idx);\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (flag_dump_unnumbered\n+\t  || (flag_dump_unnumbered_links && idx <= 1\n+\t      && (INSN_P (in_rtx) || NOTE_P (in_rtx)\n+\t\t  || LABEL_P (in_rtx) || BARRIER_P (in_rtx))))\n+\tfputs (\" #\", outfile);\n+      else\n+\tfprintf (outfile, \" %d\", INSN_UID (sub));\n+    }\n+  else\n+    fputs (\" 0\", outfile);\n+  sawclose = 0;\n+}\n+\n+/* Subroutine of print_rtx.   Print operand IDX of IN_RTX.  */\n+\n+static void\n+print_rtx_operand (const_rtx in_rtx, int idx)\n+{\n+  const char *format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx));\n+\n+  switch (format_ptr[idx])\n+    {\n+      const char *str;\n+\n+    case 'T':\n+      str = XTMPL (in_rtx, idx);\n+      goto string;\n+\n+    case 'S':\n+    case 's':\n+      str = XSTR (in_rtx, idx);\n+    string:\n+\n+      if (str == 0)\n+\tfputs (\" \\\"\\\"\", outfile);\n+      else\n+\tfprintf (outfile, \" (\\\"%s\\\")\", str);\n+      sawclose = 1;\n+      break;\n+\n+    case '0':\n+      print_rtx_operand_code_0 (in_rtx, idx);\n+      break;\n+\n+    case 'e':\n+      print_rtx_operand_code_e (in_rtx, idx);\n+      break;\n+\n+    case 'E':\n+    case 'V':\n+      print_rtx_operand_codes_E_and_V (in_rtx, idx);\n+      break;\n+\n+    case 'w':\n+      if (! flag_simple)\n+\tfprintf (outfile, \" \");\n+      fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, XWINT (in_rtx, idx));\n+      if (! flag_simple)\n+\tfprintf (outfile, \" [\" HOST_WIDE_INT_PRINT_HEX \"]\",\n+\t\t (unsigned HOST_WIDE_INT) XWINT (in_rtx, idx));\n+      break;\n+\n+    case 'i':\n+      print_rtx_operand_code_i (in_rtx, idx);\n+      break;\n+\n+    case 'r':\n+      print_rtx_operand_code_r (in_rtx);\n+      break;\n+\n+    /* Print NOTE_INSN names rather than integer codes.  */\n+\n+    case 'n':\n+      fprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, idx)));\n+      sawclose = 0;\n+      break;\n+\n+    case 'u':\n+      print_rtx_operand_code_u (in_rtx, idx);\n+      break;\n+\n+    case 't':\n+#ifndef GENERATOR_FILE\n+      if (idx == 0 && GET_CODE (in_rtx) == DEBUG_IMPLICIT_PTR)\n+\tprint_mem_expr (outfile, DEBUG_IMPLICIT_PTR_DECL (in_rtx));\n+      else if (idx == 0 && GET_CODE (in_rtx) == DEBUG_PARAMETER_REF)\n+\tprint_mem_expr (outfile, DEBUG_PARAMETER_REF_DECL (in_rtx));\n+      else\n+\tdump_addr (outfile, \" \", XTREE (in_rtx, idx));\n+#endif\n+      break;\n+\n+    case '*':\n+      fputs (\" Unknown\", outfile);\n+      sawclose = 0;\n+      break;\n+\n+    case 'B':\n+#ifndef GENERATOR_FILE\n+      if (XBBDEF (in_rtx, idx))\n+\tfprintf (outfile, \" %i\", XBBDEF (in_rtx, idx)->index);\n+#endif\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n \n static void\n print_rtx (const_rtx in_rtx)\n {\n-  int i = 0;\n-  int j;\n-  const char *format_ptr;\n-  int is_insn;\n+  int idx = 0;\n \n   if (sawclose)\n     {\n@@ -127,8 +574,6 @@ print_rtx (const_rtx in_rtx)\n        return;\n     }\n \n-  is_insn = INSN_P (in_rtx);\n-\n   /* Print name of expression code.  */\n   if (flag_simple && CONST_INT_P (in_rtx))\n     fputc ('(', outfile);\n@@ -184,14 +629,14 @@ print_rtx (const_rtx in_rtx)\n \t      == VAR_INIT_STATUS_UNINITIALIZED)\n \t    fprintf (outfile, \" [uninit]\");\n \t  sawclose = 1;\n-\t  i = GET_RTX_LENGTH (VAR_LOCATION);\n+\t  idx = GET_RTX_LENGTH (VAR_LOCATION);\n \t}\n #endif\n     }\n \n #ifndef GENERATOR_FILE\n   if (CONST_DOUBLE_AS_FLOAT_P (in_rtx))\n-    i = 5;\n+    idx = 5;\n #endif\n \n   if (INSN_CHAIN_CODE_P (GET_CODE (in_rtx)))\n@@ -204,394 +649,8 @@ print_rtx (const_rtx in_rtx)\n \n   /* Get the format string and skip the first elements if we have handled\n      them already.  */\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx)) + i;\n-  for (; i < GET_RTX_LENGTH (GET_CODE (in_rtx)); i++)\n-    switch (*format_ptr++)\n-      {\n-\tconst char *str;\n-\n-      case 'T':\n-\tstr = XTMPL (in_rtx, i);\n-\tgoto string;\n-\n-      case 'S':\n-      case 's':\n-\tstr = XSTR (in_rtx, i);\n-      string:\n-\n-\tif (str == 0)\n-\t  fputs (\" \\\"\\\"\", outfile);\n-\telse\n-\t  fprintf (outfile, \" (\\\"%s\\\")\", str);\n-\tsawclose = 1;\n-\tbreak;\n-\n-\t/* 0 indicates a field for internal use that should not be printed.\n-\t   An exception is the third field of a NOTE, where it indicates\n-\t   that the field has several different valid contents.  */\n-      case '0':\n-#ifndef GENERATOR_FILE\n-\tif (i == 1 && GET_CODE (in_rtx) == SYMBOL_REF)\n-\t  {\n-\t    int flags = SYMBOL_REF_FLAGS (in_rtx);\n-\t    if (flags)\n-\t      fprintf (outfile, \" [flags %#x]\", flags);\n-\t    tree decl = SYMBOL_REF_DECL (in_rtx);\n-\t    if (decl)\n-\t      print_node_brief (outfile, \"\", decl, dump_flags);\n-\t  }\n-\telse if (i == 3 && NOTE_P (in_rtx))\n-\t  {\n-\t    switch (NOTE_KIND (in_rtx))\n-\t      {\n-\t      case NOTE_INSN_EH_REGION_BEG:\n-\t      case NOTE_INSN_EH_REGION_END:\n-\t\tif (flag_dump_unnumbered)\n-\t\t  fprintf (outfile, \" #\");\n-\t\telse\n-\t\t  fprintf (outfile, \" %d\", NOTE_EH_HANDLER (in_rtx));\n-\t\tsawclose = 1;\n-\t\tbreak;\n-\n-\t      case NOTE_INSN_BLOCK_BEG:\n-\t      case NOTE_INSN_BLOCK_END:\n-\t\tdump_addr (outfile, \" \", NOTE_BLOCK (in_rtx));\n-\t\tsawclose = 1;\n-\t\tbreak;\n-\n-\t      case NOTE_INSN_BASIC_BLOCK:\n-\t\t{\n-\t\t  basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n-\t\t  if (bb != 0)\n-\t\t    fprintf (outfile, \" [bb %d]\", bb->index);\n-\t\t  break;\n-\t        }\n-\n-\t      case NOTE_INSN_DELETED_LABEL:\n-\t      case NOTE_INSN_DELETED_DEBUG_LABEL:\n-\t\t{\n-\t\t  const char *label = NOTE_DELETED_LABEL_NAME (in_rtx);\n-\t\t  if (label)\n-\t\t    fprintf (outfile, \" (\\\"%s\\\")\", label);\n-\t\t  else\n-\t\t    fprintf (outfile, \" \\\"\\\"\");\n-\t\t}\n-\t\tbreak;\n-\n-\t      case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n-\t\t{\n-\t\t  basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n-\t\t  if (bb != 0)\n-\t\t    fprintf (outfile, \" [bb %d]\", bb->index);\n-\t\t  break;\n-\t\t}\n-\n-\t      case NOTE_INSN_VAR_LOCATION:\n-\t      case NOTE_INSN_CALL_ARG_LOCATION:\n-\t\tfputc (' ', outfile);\n-\t\tprint_rtx (NOTE_VAR_LOCATION (in_rtx));\n-\t\tbreak;\n-\n-\t      case NOTE_INSN_CFI:\n-\t\tfputc ('\\n', outfile);\n-\t\toutput_cfi_directive (outfile, NOTE_CFI (in_rtx));\n-\t\tfputc ('\\t', outfile);\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t  }\n-\telse if (i == 7 && JUMP_P (in_rtx) && JUMP_LABEL (in_rtx) != NULL)\n-\t  {\n-\t    /* Output the JUMP_LABEL reference.  */\n-\t    fprintf (outfile, \"\\n%s%*s -> \", print_rtx_head, indent * 2, \"\");\n-\t    if (GET_CODE (JUMP_LABEL (in_rtx)) == RETURN)\n-\t      fprintf (outfile, \"return\");\n-\t    else if (GET_CODE (JUMP_LABEL (in_rtx)) == SIMPLE_RETURN)\n-\t      fprintf (outfile, \"simple_return\");\n-\t    else\n-\t      fprintf (outfile, \"%d\", INSN_UID (JUMP_LABEL (in_rtx)));\n-\t  }\n-\telse if (i == 0 && GET_CODE (in_rtx) == VALUE)\n-\t  {\n-\t    cselib_val *val = CSELIB_VAL_PTR (in_rtx);\n-\n-\t    fprintf (outfile, \" %u:%u\", val->uid, val->hash);\n-\t    dump_addr (outfile, \" @\", in_rtx);\n-\t    dump_addr (outfile, \"/\", (void*)val);\n-\t  }\n-\telse if (i == 0 && GET_CODE (in_rtx) == DEBUG_EXPR)\n-\t  {\n-\t    fprintf (outfile, \" D#%i\",\n-\t\t     DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (in_rtx)));\n-\t  }\n-\telse if (i == 0 && GET_CODE (in_rtx) == ENTRY_VALUE)\n-\t  {\n-\t    indent += 2;\n-\t    if (!sawclose)\n-\t      fprintf (outfile, \" \");\n-\t    print_rtx (ENTRY_VALUE_EXP (in_rtx));\n-\t    indent -= 2;\n-\t  }\n-#endif\n-\tbreak;\n-\n-      case 'e':\n-      do_e:\n-\tindent += 2;\n-\tif (i == 6 && INSN_P (in_rtx))\n-\t  /* Put REG_NOTES on their own line.  */\n-\t  fprintf (outfile, \"\\n%s%*s\",\n-\t\t   print_rtx_head, indent * 2, \"\");\n-\tif (!sawclose)\n-\t  fprintf (outfile, \" \");\n-\tif (i == 7 && CALL_P (in_rtx))\n-\t  {\n-\t    in_call_function_usage = true;\n-\t    print_rtx (XEXP (in_rtx, i));\n-\t    in_call_function_usage = false;\n-\t  }\n-\telse\n-\t  print_rtx (XEXP (in_rtx, i));\n-\tindent -= 2;\n-\tbreak;\n-\n-      case 'E':\n-      case 'V':\n-\tindent += 2;\n-\tif (sawclose)\n-\t  {\n-\t    fprintf (outfile, \"\\n%s%*s\",\n-\t\t     print_rtx_head, indent * 2, \"\");\n-\t    sawclose = 0;\n-\t  }\n-\tfputs (\" [\", outfile);\n-\tif (NULL != XVEC (in_rtx, i))\n-\t  {\n-\t    indent += 2;\n-\t    if (XVECLEN (in_rtx, i))\n-\t      sawclose = 1;\n-\n-\t    for (j = 0; j < XVECLEN (in_rtx, i); j++)\n-\t      print_rtx (XVECEXP (in_rtx, i, j));\n-\n-\t    indent -= 2;\n-\t  }\n-\tif (sawclose)\n-\t  fprintf (outfile, \"\\n%s%*s\", print_rtx_head, indent * 2, \"\");\n-\n-\tfputs (\"]\", outfile);\n-\tsawclose = 1;\n-\tindent -= 2;\n-\tbreak;\n-\n-      case 'w':\n-\tif (! flag_simple)\n-\t  fprintf (outfile, \" \");\n-\tfprintf (outfile, HOST_WIDE_INT_PRINT_DEC, XWINT (in_rtx, i));\n-\tif (! flag_simple)\n-\t  fprintf (outfile, \" [\" HOST_WIDE_INT_PRINT_HEX \"]\",\n-\t\t   (unsigned HOST_WIDE_INT) XWINT (in_rtx, i));\n-\tbreak;\n-\n-      case 'i':\n-\tif (i == 4 && INSN_P (in_rtx))\n-\t  {\n-#ifndef GENERATOR_FILE\n-\t    const rtx_insn *in_insn = as_a <const rtx_insn *> (in_rtx);\n-\n-\t    /*  Pretty-print insn locations.  Ignore scoping as it is mostly\n-\t\tredundant with line number information and do not print anything\n-\t\twhen there is no location information available.  */\n-\t    if (INSN_HAS_LOCATION (in_insn))\n-\t      {\n-\t\texpanded_location xloc = insn_location (in_insn);\n-\t\tfprintf (outfile, \" %s:%i\", xloc.file, xloc.line);\n-\t      }\n-#endif\n-\t  }\n-\telse if (i == 6 && GET_CODE (in_rtx) == ASM_OPERANDS)\n-\t  {\n-#ifndef GENERATOR_FILE\n-\t    if (ASM_OPERANDS_SOURCE_LOCATION (in_rtx) != UNKNOWN_LOCATION)\n-\t      fprintf (outfile, \" %s:%i\",\n-\t\t       LOCATION_FILE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)),\n-\t\t       LOCATION_LINE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)));\n-#endif\n-\t  }\n-\telse if (i == 1 && GET_CODE (in_rtx) == ASM_INPUT)\n-\t  {\n-#ifndef GENERATOR_FILE\n-\t    if (ASM_INPUT_SOURCE_LOCATION (in_rtx) != UNKNOWN_LOCATION)\n-\t      fprintf (outfile, \" %s:%i\",\n-\t\t       LOCATION_FILE (ASM_INPUT_SOURCE_LOCATION (in_rtx)),\n-\t\t       LOCATION_LINE (ASM_INPUT_SOURCE_LOCATION (in_rtx)));\n-#endif\n-\t  }\n-\telse if (i == 5 && NOTE_P (in_rtx))\n-\t  {\n-\t    /* This field is only used for NOTE_INSN_DELETED_LABEL, and\n-\t       other times often contains garbage from INSN->NOTE death.  */\n-\t    if (NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_LABEL\n-\t\t|| NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_DEBUG_LABEL)\n-\t      fprintf (outfile, \" %d\",  XINT (in_rtx, i));\n-\t  }\n-#if !defined(GENERATOR_FILE) && NUM_UNSPECV_VALUES > 0\n-\telse if (i == 1\n-\t\t && GET_CODE (in_rtx) == UNSPEC_VOLATILE\n-\t\t && XINT (in_rtx, 1) >= 0\n-\t\t && XINT (in_rtx, 1) < NUM_UNSPECV_VALUES)\n-\t  fprintf (outfile, \" %s\", unspecv_strings[XINT (in_rtx, 1)]);\n-#endif\n-#if !defined(GENERATOR_FILE) && NUM_UNSPEC_VALUES > 0\n-\telse if (i == 1\n-\t\t && (GET_CODE (in_rtx) == UNSPEC\n-\t\t     || GET_CODE (in_rtx) == UNSPEC_VOLATILE)\n-\t\t && XINT (in_rtx, 1) >= 0\n-\t\t && XINT (in_rtx, 1) < NUM_UNSPEC_VALUES)\n-\t  fprintf (outfile, \" %s\", unspec_strings[XINT (in_rtx, 1)]);\n-#endif\n-\telse\n-\t  {\n-\t    int value = XINT (in_rtx, i);\n-\t    const char *name;\n-\n-\t    if (flag_dump_unnumbered\n-\t\t&& (is_insn || NOTE_P (in_rtx)))\n-\t      fputc ('#', outfile);\n-\t    else\n-\t      fprintf (outfile, \" %d\", value);\n-\n-\t    if (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, i)\n-\t\t&& XINT (in_rtx, i) >= 0\n-\t\t&& (name = get_insn_name (XINT (in_rtx, i))) != NULL)\n-\t      fprintf (outfile, \" {%s}\", name);\n-\t    sawclose = 0;\n-\t  }\n-\tbreak;\n-\n-      case 'r':\n-\t{\n-\t  unsigned int regno = REGNO (in_rtx);\n-#ifndef GENERATOR_FILE\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    fprintf (outfile, \" %d %s\", regno, reg_names[regno]);\n-\t  else if (regno <= LAST_VIRTUAL_REGISTER)\n-\t    {\n-\t      if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n-\t\tfprintf (outfile, \" %d virtual-incoming-args\", regno);\n-\t      else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n-\t\tfprintf (outfile, \" %d virtual-stack-vars\", regno);\n-\t      else if (regno == VIRTUAL_STACK_DYNAMIC_REGNUM)\n-\t\tfprintf (outfile, \" %d virtual-stack-dynamic\", regno);\n-\t      else if (regno == VIRTUAL_OUTGOING_ARGS_REGNUM)\n-\t\tfprintf (outfile, \" %d virtual-outgoing-args\", regno);\n-\t      else if (regno == VIRTUAL_CFA_REGNUM)\n-\t\tfprintf (outfile, \" %d virtual-cfa\", regno);\n-\t      else if (regno == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n-\t\tfprintf (outfile, \" %d virtual-preferred-stack-boundary\",\n-\t\t\t regno);\n-\t      else\n-\t\tfprintf (outfile, \" %d virtual-reg-%d\", regno,\n-\t\t\t regno-FIRST_VIRTUAL_REGISTER);\n-\t    }\n-\t  else\n-#endif\n-\t    if (flag_dump_unnumbered && is_insn)\n-\t      fputc ('#', outfile);\n-\t    else\n-\t      fprintf (outfile, \" %d\", regno);\n-\n-#ifndef GENERATOR_FILE\n-\t  if (REG_ATTRS (in_rtx))\n-\t    {\n-\t      fputs (\" [\", outfile);\n-\t      if (regno != ORIGINAL_REGNO (in_rtx))\n-\t\tfprintf (outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n-\t      if (REG_EXPR (in_rtx))\n-\t\tprint_mem_expr (outfile, REG_EXPR (in_rtx));\n-\n-\t      if (REG_OFFSET (in_rtx))\n-\t\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t REG_OFFSET (in_rtx));\n-\t      fputs (\" ]\", outfile);\n-\t    }\n-\t  if (regno != ORIGINAL_REGNO (in_rtx))\n-\t    fprintf (outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n-#endif\n-\t  break;\n-\t}\n-\n-      /* Print NOTE_INSN names rather than integer codes.  */\n-\n-      case 'n':\n-\tfprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, i)));\n-\tsawclose = 0;\n-\tbreak;\n-\n-      case 'u':\n-\tif (XEXP (in_rtx, i) != NULL)\n-\t  {\n-\t    rtx sub = XEXP (in_rtx, i);\n-\t    enum rtx_code subc = GET_CODE (sub);\n-\n-\t    if (GET_CODE (in_rtx) == LABEL_REF)\n-\t      {\n-\t\tif (subc == NOTE\n-\t\t    && NOTE_KIND (sub) == NOTE_INSN_DELETED_LABEL)\n-\t\t  {\n-\t\t    if (flag_dump_unnumbered)\n-\t\t      fprintf (outfile, \" [# deleted]\");\n-\t\t    else\n-\t\t      fprintf (outfile, \" [%d deleted]\", INSN_UID (sub));\n-\t\t    sawclose = 0;\n-\t\t    break;\n-\t\t  }\n-\n-\t\tif (subc != CODE_LABEL)\n-\t\t  goto do_e;\n-\t      }\n-\n-\t    if (flag_dump_unnumbered\n-\t\t|| (flag_dump_unnumbered_links && i <= 1\n-\t\t    && (INSN_P (in_rtx) || NOTE_P (in_rtx)\n-\t\t\t|| LABEL_P (in_rtx) || BARRIER_P (in_rtx))))\n-\t      fputs (\" #\", outfile);\n-\t    else\n-\t      fprintf (outfile, \" %d\", INSN_UID (sub));\n-\t  }\n-\telse\n-\t  fputs (\" 0\", outfile);\n-\tsawclose = 0;\n-\tbreak;\n-\n-      case 't':\n-#ifndef GENERATOR_FILE\n-\tif (i == 0 && GET_CODE (in_rtx) == DEBUG_IMPLICIT_PTR)\n-\t  print_mem_expr (outfile, DEBUG_IMPLICIT_PTR_DECL (in_rtx));\n-\telse if (i == 0 && GET_CODE (in_rtx) == DEBUG_PARAMETER_REF)\n-\t  print_mem_expr (outfile, DEBUG_PARAMETER_REF_DECL (in_rtx));\n-\telse\n-\t  dump_addr (outfile, \" \", XTREE (in_rtx, i));\n-#endif\n-\tbreak;\n-\n-      case '*':\n-\tfputs (\" Unknown\", outfile);\n-\tsawclose = 0;\n-\tbreak;\n-\n-      case 'B':\n-#ifndef GENERATOR_FILE\n-\tif (XBBDEF (in_rtx, i))\n-\t  fprintf (outfile, \" %i\", XBBDEF (in_rtx, i)->index);\n-#endif\n-\tbreak;\n-\n-      default:\n-\tgcc_unreachable ();\n-      }\n+  for (; idx < GET_RTX_LENGTH (GET_CODE (in_rtx)); idx++)\n+    print_rtx_operand (in_rtx, idx);\n \n   switch (GET_CODE (in_rtx))\n     {"}]}