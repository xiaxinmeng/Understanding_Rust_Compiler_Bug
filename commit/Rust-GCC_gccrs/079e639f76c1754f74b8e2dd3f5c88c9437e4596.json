{"sha": "079e639f76c1754f74b8e2dd3f5c88c9437e4596", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5ZTYzOWY3NmMxNzU0Zjc0YjhlMmRkM2Y1Yzg4Yzk0MzdlNDU5Ng==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-04-21T17:56:17Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-04-21T17:56:17Z"}, "message": "(movqi+2): Add address registers.\n\n(movxf+1): Disable for TARGET_5200.\n(movxf+2): New pattern for TARGET_5200.\n(addsi3): Add define_expand.  Move code to output_addsi3.\n(addsi3_internal): Renamed from addsi3.  Disable for TARGET_5200.\n(addsi3_5200): New pattern for TARGET_5200.\n\nFrom-SVN: r13951", "tree": {"sha": "df680a2de51b6b91e4e4afd549d3d63db8bf506d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df680a2de51b6b91e4e4afd549d3d63db8bf506d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/079e639f76c1754f74b8e2dd3f5c88c9437e4596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079e639f76c1754f74b8e2dd3f5c88c9437e4596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079e639f76c1754f74b8e2dd3f5c88c9437e4596", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079e639f76c1754f74b8e2dd3f5c88c9437e4596/comments", "author": null, "committer": null, "parents": [{"sha": "dfcce277a065f4bd19786982368512f1d0836e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfcce277a065f4bd19786982368512f1d0836e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfcce277a065f4bd19786982368512f1d0836e93"}], "stats": {"total": 115, "additions": 25, "deletions": 90}, "files": [{"sha": "d2e18e78da030c129b7466d356aa7a49b9f25357", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 25, "deletions": 90, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e639f76c1754f74b8e2dd3f5c88c9437e4596/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e639f76c1754f74b8e2dd3f5c88c9437e4596/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=079e639f76c1754f74b8e2dd3f5c88c9437e4596", "patch": "@@ -986,8 +986,8 @@\n   \"* return output_move_qimode (operands);\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d<>,dm\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi,d<>\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d*a<>,d*am\")\n+\t(match_operand:QI 1 \"general_operand\" \"d*ami,d*a<>\"))]\n   \"TARGET_5200\"\n   \"* return output_move_qimode (operands);\")\n \n@@ -1186,7 +1186,7 @@\n (define_insn \"\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=rm,rf,&rof<>\")\n \t(match_operand:XF 1 \"nonimmediate_operand\" \"rf,m,rof<>\"))]\n-  \"! TARGET_68881\"\n+  \"! TARGET_68881 && ! TARGET_5200\"\n   \"*\n {\n   if (FP_REG_P (operands[0]))\n@@ -1224,6 +1224,12 @@\n }\n \")\n \n+(define_insn \"\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=r,g\")\n+\t(match_operand:XF 1 \"nonimmediate_operand\" \"g,r\"))]\n+  \"! TARGET_68881 && TARGET_5200\"\n+  \"* return output_move_double (operands);\")\n+\n (define_expand \"movdi\"\n   ;; Let's see if it really still needs to handle fp regs, and, if so, why.\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -2110,101 +2116,30 @@\n   return \\\"\\\";\n }\")\n \n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n ;; Note that the middle two alternatives are near-duplicates\n ;; in order to handle insns generated by reload.\n ;; This is needed since they are not themselves reloaded,\n ;; so commutativity won't apply to them.\n-(define_insn \"addsi3\"\n+(define_insn \"*addsi3_internal\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=m,?a,?a,r\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"dIKLs,rJK,a,mrIKLs\")))]\n-  \"\"\n-  \"*\n-{\n-  if (! operands_match_p (operands[0], operands[1]))\n-    {\n-      if (!ADDRESS_REG_P (operands[1]))\n-\t{\n-\t  rtx tmp = operands[1];\n-\n-\t  operands[1] = operands[2];\n-\t  operands[2] = tmp;\n-\t}\n+  \"! TARGET_5200\"\n+  \"* return output_addsi3 (operands);\")\n \n-      /* These insns can result from reloads to access\n-\t stack slots over 64k from the frame pointer.  */\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && INTVAL (operands[2]) + 0x8000 >= (unsigned) 0x10000)\n-        return \\\"move%.l %2,%0\\;add%.l %1,%0\\\";\n-#ifdef SGS\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn \\\"lea 0(%1,%2.l),%0\\\";\n-      else\n-\treturn \\\"lea %c2(%1),%0\\\";\n-#else /* not SGS */\n-#ifdef MOTOROLA\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn \\\"lea (%1,%2.l),%0\\\";\n-      else\n-\treturn \\\"lea (%c2,%1),%0\\\";\n-#else /* not MOTOROLA (MIT syntax) */\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn \\\"lea %1@(0,%2:l),%0\\\";\n-      else\n-\treturn \\\"lea %1@(%c2),%0\\\";\n-#endif /* not MOTOROLA */\n-#endif /* not SGS */\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-#ifndef NO_ADDSUB_Q\n-      if (INTVAL (operands[2]) > 0\n-\t  && INTVAL (operands[2]) <= 8)\n-\treturn \\\"addq%.l %2,%0\\\";\n-      if (INTVAL (operands[2]) < 0\n-\t  && INTVAL (operands[2]) >= -8)\n-        {\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t         - INTVAL (operands[2]));\n-\t  return \\\"subq%.l %2,%0\\\";\n-\t}\n-      /* On the CPU32 it is faster to use two addql instructions to\n-\t add a small integer (8 < N <= 16) to a register.\n-\t Likewise for subql. */\n-      if (TARGET_CPU32 && REG_P (operands[0]))\n-\t{\n-\t  if (INTVAL (operands[2]) > 8\n-\t      && INTVAL (operands[2]) <= 16)\n-\t    {\n-\t      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n-\t\t\t\t      INTVAL (operands[2]) - 8);\n-\t      return \\\"addq%.l %#8,%0\\;addq%.l %2,%0\\\";\n-\t    }\n-\t  if (INTVAL (operands[2]) < -8\n-\t      && INTVAL (operands[2]) >= -16)\n-\t    {\n-\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t      - INTVAL (operands[2]) - 8);\n-\t      return \\\"subq%.l %#8,%0\\;subq%.l %2,%0\\\";\n-\t    }\n-\t}\n-#endif\n-      if (ADDRESS_REG_P (operands[0])\n-\t  && INTVAL (operands[2]) >= -0x8000\n-\t  && INTVAL (operands[2]) < 0x8000)\n-\t{\n-\t  if (TARGET_68040)\n-\t    return \\\"add%.w %2,%0\\\";\n-\t  else\n-#ifdef MOTOROLA  \n-\t    return \\\"lea (%c2,%0),%0\\\";\n-#else\n-\t    return \\\"lea %0@(%c2),%0\\\";\n-#endif\n-\t}\n-    }\n-  return \\\"add%.l %2,%0\\\";\n-}\")\n+(define_insn \"*addsi3_5200\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,?a,?a,r\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"d,rJK,a,mrIKLs\")))]\n+  \"TARGET_5200\"\n+  \"* return output_addsi3 (operands);\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=a\")"}]}