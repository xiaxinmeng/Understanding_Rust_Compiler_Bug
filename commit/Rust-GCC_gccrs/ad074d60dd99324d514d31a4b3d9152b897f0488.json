{"sha": "ad074d60dd99324d514d31a4b3d9152b897f0488", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQwNzRkNjBkZDk5MzI0ZDUxNGQzMWE0YjNkOTE1MmI4OTdmMDQ4OA==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-12-29T14:56:36Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-12-29T14:56:36Z"}, "message": "* objc/objc-act.c: Apply various cosmetic and formatting changes.\n\nFrom-SVN: r48365", "tree": {"sha": "147edf4c596beea70b6fd52d59cacae04330a271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/147edf4c596beea70b6fd52d59cacae04330a271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad074d60dd99324d514d31a4b3d9152b897f0488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad074d60dd99324d514d31a4b3d9152b897f0488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad074d60dd99324d514d31a4b3d9152b897f0488", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad074d60dd99324d514d31a4b3d9152b897f0488/comments", "author": null, "committer": null, "parents": [{"sha": "7f3ad6b697267778f8c34e1f8384bc031a025047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3ad6b697267778f8c34e1f8384bc031a025047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3ad6b697267778f8c34e1f8384bc031a025047"}], "stats": {"total": 134, "additions": 67, "deletions": 67}, "files": [{"sha": "11a8ad61b9c81721a2304012ade8a9b64bd5c0ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad074d60dd99324d514d31a4b3d9152b897f0488/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad074d60dd99324d514d31a4b3d9152b897f0488/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad074d60dd99324d514d31a4b3d9152b897f0488", "patch": "@@ -1,3 +1,7 @@\n+2001-12-29  Stan Shebs  <shebs@apple.com>\n+\n+\t* objc/objc-act.c: Apply various cosmetic and formatting changes.\n+\n 2001-12-29  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/rs6000/darwin-tramp.asm: Fix comment formatting."}, {"sha": "d6cc5eaba9262dfa8f7d02d67f722b3a3636b8c3", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad074d60dd99324d514d31a4b3d9152b897f0488/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad074d60dd99324d514d31a4b3d9152b897f0488/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=ad074d60dd99324d514d31a4b3d9152b897f0488", "patch": "@@ -382,7 +382,7 @@ static const char *TAG_MSGSEND;\n static const char *TAG_MSGSENDSUPER;\n static const char *TAG_EXECCLASS;\n \n-/* The OCTI_... enumeration itself in in objc/objc-act.h.  */\n+/* The OCTI_... enumeration itself is in objc/objc-act.h.  */\n tree objc_global_trees[OCTI_MAX];\n \n int objc_receiver_context;\n@@ -437,20 +437,19 @@ int flag_warn_protocol = 1;\n /* Tells \"encode_pointer/encode_aggregate\" whether we are generating\n    type descriptors for instance variables (as opposed to methods).\n    Type descriptors for instance variables contain more information\n-   than methods (for static typing and embedded structures). This\n-   was added to support features being planned for dbkit2.  */\n+   than methods (for static typing and embedded structures).  */\n \n static int generating_instance_variables = 0;\n \n-/* Tells the compiler that this is a special run.  Do not perform\n-   any compiling, instead we are to test some platform dependent\n-   features and output a C header file with appropriate definitions. */\n+/* Tells the compiler that this is a special run.  Do not perform any\n+   compiling, instead we are to test some platform dependent features\n+   and output a C header file with appropriate definitions.  */\n \n static int print_struct_values = 0;\n \n-/* Some platforms pass small structures through registers versus through\n-   an invisible pointer.  Determine at what size structure is the \n-   transition point between the two possibilities. */\n+/* Some platforms pass small structures through registers versus\n+   through an invisible pointer.  Determine at what size structure is\n+   the transition point between the two possibilities.  */\n \n static void\n generate_struct_by_value_array ()\n@@ -461,7 +460,7 @@ generate_struct_by_value_array ()\n   int aggregate_in_mem[32];\n   int found = 0;\n \n-  /* Presumably no platform passes 32 byte structures in a register. */\n+  /* Presumably no platform passes 32 byte structures in a register.  */\n   for (i = 1; i < 32; i++)\n     {\n       char buffer[5];\n@@ -491,7 +490,7 @@ generate_struct_by_value_array ()\n     }\n  \n   /* We found some structures that are returned in registers instead of memory\n-     so output the necessary data. */\n+     so output the necessary data.  */\n   if (found)\n     {\n       for (i = 31; i >= 0;  i--)\n@@ -684,38 +683,38 @@ lookup_method_in_protocol_list (rproto_list, sel_name, class_meth)\n \n static tree\n lookup_protocol_in_reflist (rproto_list, lproto)\n-   tree rproto_list;\n-   tree lproto;\n+     tree rproto_list;\n+     tree lproto;\n {\n-   tree rproto, p;\n+  tree rproto, p;\n \n-   /* Make sure the protocol is supported by the object on the rhs.  */\n-   if (TREE_CODE (lproto) == PROTOCOL_INTERFACE_TYPE)\n-     {\n-       tree fnd = 0;\n-       for (rproto = rproto_list; rproto; rproto = TREE_CHAIN (rproto))\n-\t {\n-\t   p = TREE_VALUE (rproto);\n+  /* Make sure the protocol is supported by the object on the rhs.  */\n+  if (TREE_CODE (lproto) == PROTOCOL_INTERFACE_TYPE)\n+    {\n+      tree fnd = 0;\n+      for (rproto = rproto_list; rproto; rproto = TREE_CHAIN (rproto))\n+\t{\n+\t  p = TREE_VALUE (rproto);\n \n-\t   if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n-\t     {\n-\t       if (lproto == p)\n-\t\t fnd = lproto;\n+\t  if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n+\t    {\n+\t      if (lproto == p)\n+\t\tfnd = lproto;\n \n-\t       else if (PROTOCOL_LIST (p))\n-\t\t fnd = lookup_protocol_in_reflist (PROTOCOL_LIST (p), lproto);\n-\t     }\n+\t      else if (PROTOCOL_LIST (p))\n+\t\tfnd = lookup_protocol_in_reflist (PROTOCOL_LIST (p), lproto);\n+\t    }\n \n-\t   if (fnd)\n-\t     return fnd;\n-\t }\n-     }\n-   else\n-     {\n-       ; /* An identifier...if we could not find a protocol.  */\n-     }\n+\t  if (fnd)\n+\t    return fnd;\n+\t}\n+    }\n+  else\n+    {\n+      ; /* An identifier...if we could not find a protocol.  */\n+    }\n \n-   return 0;\n+  return 0;\n }\n \n /* Return 1 if LHS and RHS are compatible types for assignment\n@@ -1563,8 +1562,8 @@ init_objc_symtab (type)\n   return build_constructor (type, nreverse (initlist));\n }\n \n-/* Push forward-declarations of all the categories\n-   so that init_def_list can use them in a CONSTRUCTOR.  */\n+/* Push forward-declarations of all the categories so that\n+   init_def_list can use them in a CONSTRUCTOR.  */\n \n static void\n forward_declare_categories ()\n@@ -2204,7 +2203,7 @@ add_class_reference (ident)\n \n tree\n get_class_reference (ident)\n-    tree ident;\n+     tree ident;\n {\n   if (flag_next_runtime)\n     {\n@@ -2829,17 +2828,15 @@ generate_descriptor_table (type, name, size, list, proto)\n }\n \n static void\n-generate_method_descriptors (protocol)\t/* generate_dispatch_tables */\n-  tree protocol;\n+generate_method_descriptors (protocol)\n+     tree protocol;\n {\n   tree initlist, chain, method_list_template;\n   tree cast, variable_length_type;\n   int size;\n \n   if (!objc_method_prototype_template)\n-    {\n-      objc_method_prototype_template = build_method_prototype_template ();\n-    }\n+    objc_method_prototype_template = build_method_prototype_template ();\n \n   cast = build_tree_list (build_tree_list (NULL_TREE, xref_tag (RECORD_TYPE,\n \t\t\t\tget_identifier (UTAG_METHOD_PROTOTYPE_LIST))),\n@@ -3750,7 +3747,7 @@ build_ivar_list_initializer (type, field_decl)\n \t   ivar);\n       obstack_free (&util_obstack, util_firstobj);\n \n-      /* Set offset. */\n+      /* Set offset.  */\n       ivar = tree_cons (NULL_TREE, byte_position (field_decl), ivar);\n       initlist = tree_cons (NULL_TREE, \n \t\t\t    build_constructor (type, nreverse (ivar)),\n@@ -4855,7 +4852,7 @@ finish_message_expr (receiver, sel_name, method_params)\n   tree selector, self_object, retval;\n   int statically_typed = 0, statically_allocated = 0;\n   \n-  /* Determine receiver type. */\n+  /* Determine receiver type.  */\n   tree rtype = TREE_TYPE (receiver);\n   int super = IS_SUPER (rtype);\n \n@@ -4880,7 +4877,7 @@ finish_message_expr (receiver, sel_name, method_params)\n       if (statically_allocated)\n \treceiver = build_unary_op (ADDR_EXPR, receiver, 0);\n \n-      /* Don't evaluate the receiver twice. */\n+      /* Don't evaluate the receiver twice.  */\n       receiver = save_expr (receiver);\n       self_object = receiver;\n     }\n@@ -5923,7 +5920,7 @@ check_methods_accessible (chain, context, mtype)\n \n       chain = TREE_CHAIN (chain); /* next method...  */\n     }\n-    return first;\n+  return first;\n }\n \n /* Check whether the current interface (accessible via\n@@ -5971,6 +5968,7 @@ check_protocol (p, type, name)\n       tree subs = PROTOCOL_LIST (p);\n       tree super_class =\n \tlookup_interface (CLASS_SUPER_NAME (implementation_template));\n+\n       while (subs) \n \t{\n \t  tree sub = TREE_VALUE (subs);\n@@ -6315,10 +6313,8 @@ lookup_protocol (ident)\n   tree chain;\n \n   for (chain = protocol_chain; chain; chain = TREE_CHAIN (chain))\n-    {\n-      if (ident == PROTOCOL_NAME (chain))\n-\treturn chain;\n-    }\n+    if (ident == PROTOCOL_NAME (chain))\n+      return chain;\n \n   return NULL_TREE;\n }\n@@ -6395,7 +6391,7 @@ start_protocol (code, name, list)\n \n void\n finish_protocol (protocol)\n-\ttree protocol ATTRIBUTE_UNUSED;\n+     tree protocol ATTRIBUTE_UNUSED;\n {\n }\n \n@@ -6537,12 +6533,12 @@ encode_aggregate_within (type, curtype, format, left, right)\n     {\n       tree name = TYPE_NAME (type);\n \n-      /* we have a reference; this is a NeXT extension. */\n+      /* we have a reference; this is a NeXT extension.  */\n \n       if (obstack_object_size (&util_obstack) - curtype == 1\n \t  && format == OBJC_ENCODE_INLINE_DEFS)\n \t{\n-\t  /* Output format of struct for first level only. */\n+\t  /* Output format of struct for first level only.  */\n \t  tree fields = TYPE_FIELDS (type);\n \n \t  if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n@@ -6576,7 +6572,7 @@ encode_aggregate_within (type, curtype, format, left, right)\n \n       else\n \t{\n-\t  /* We have an untagged structure or a typedef. */\n+\t  /* We have an untagged structure or a typedef.  */\n \t  obstack_1grow (&util_obstack, left);\n \t  obstack_1grow (&util_obstack, '?');\n \t  obstack_1grow (&util_obstack, right);\n@@ -6632,7 +6628,7 @@ encode_aggregate_within (type, curtype, format, left, right)\n \t\t\t    IDENTIFIER_POINTER (name),\n \t\t\t    strlen (IDENTIFIER_POINTER (name)));\n \t  else\n-\t      /* We have an untagged structure or a typedef. */\n+\t      /* We have an untagged structure or a typedef.  */\n \t      obstack_1grow (&util_obstack, '?');\n \n \t  obstack_1grow (&util_obstack, right);\n@@ -7193,7 +7189,7 @@ get_super_receiver ()\n \t  tree super_name = CLASS_SUPER_NAME (implementation_template);\n \t  tree super_class;\n \n-\t  /* Barf if super used in a category of Object. */\n+\t  /* Barf if super used in a category of Object.  */\n \t  if (!super_name)\n \t    {\n \t      error (\"no super class declared in interface for `%s'\",\n@@ -7970,7 +7966,7 @@ dump_interface (fp, chain)\n      FILE *fp;\n      tree chain;\n {\n-  char *buf = (char *)xmalloc (256);\n+  char *buf = (char *) xmalloc (256);\n   const char *my_name = IDENTIFIER_POINTER (CLASS_NAME (chain));\n   tree ivar_decls = CLASS_RAW_IVARS (chain);\n   tree nst_methods = CLASS_NST_METHODS (chain);\n@@ -8099,7 +8095,7 @@ init_objc ()\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n \n-  errbuf = (char *)xmalloc (BUFSIZE);\n+  errbuf = (char *) xmalloc (BUFSIZE);\n   hash_init ();\n   synth_module_prologue ();\n }\n@@ -8130,7 +8126,7 @@ finish_objc ()\n #endif\n \n   /* Process the static instances here because initialization of objc_symtab\n-     depends on them. */\n+     depends on them.  */\n   if (objc_static_instances)\n     generate_static_references ();\n \n@@ -8171,7 +8167,7 @@ finish_objc ()\n   if (objc_implementation_context || class_names_chain || objc_static_instances\n       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)\n     {\n-      /* Arrange for Objc data structures to be initialized at run time.  */\n+      /* Arrange for ObjC data structures to be initialized at run time.  */\n       rtx init_sym = build_module_descriptor ();\n       if (init_sym && targetm.have_ctors_dtors)\n \t(* targetm.asm_out.constructor) (init_sym, DEFAULT_INIT_PRIORITY);\n@@ -8250,7 +8246,7 @@ finish_objc ()\n \n static void\n generate_classref_translation_entry (chain)\n-    tree chain;\n+     tree chain;\n {\n   tree expr, name, decl_specs, decl, sc_spec;\n   tree type;\n@@ -8346,7 +8342,7 @@ handle_impent (impent)\n \n       /* Do the same for categories.  Even though no references to\n          these symbols are generated automatically by the compiler, it\n-         gives you a handle to pull them into an archive by hand. */\n+         gives you a handle to pull them into an archive by hand.  */\n       sprintf (string, \"*%sobjc_category_name_%s_%s\",\n                (flag_next_runtime ? \".\" : \"__\"), class_name, class_super_name);\n     }\n@@ -8371,7 +8367,7 @@ handle_impent (impent)\n \f\n static void\n ggc_mark_imp_list (arg)\n-    void *arg;\n+     void *arg;\n {\n   struct imp_entry *impent;\n \n@@ -8386,7 +8382,7 @@ ggc_mark_imp_list (arg)\n \n static void\n ggc_mark_hash_table (arg)\n-    void *arg;\n+     void *arg;\n {\n   hash *hash_table = *(hash **)arg;\n   hash hst;"}]}