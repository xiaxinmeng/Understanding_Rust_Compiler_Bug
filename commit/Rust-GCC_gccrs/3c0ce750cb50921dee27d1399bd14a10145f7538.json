{"sha": "3c0ce750cb50921dee27d1399bd14a10145f7538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MwY2U3NTBjYjUwOTIxZGVlMjdkMTM5OWJkMTRhMTAxNDVmNzUzOA==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-04-21T00:01:12Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-04-21T00:01:12Z"}, "message": "Fixes to compile multiple .class files at once.\n\nFrom-SVN: r41472", "tree": {"sha": "3e403b7d575e2f47a8246846495c78ecb309ed18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e403b7d575e2f47a8246846495c78ecb309ed18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c0ce750cb50921dee27d1399bd14a10145f7538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c0ce750cb50921dee27d1399bd14a10145f7538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c0ce750cb50921dee27d1399bd14a10145f7538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c0ce750cb50921dee27d1399bd14a10145f7538/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1800ec88e53d47792c9b01672d4feabba209a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1800ec88e53d47792c9b01672d4feabba209a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1800ec88e53d47792c9b01672d4feabba209a3c"}], "stats": {"total": 163, "additions": 85, "deletions": 78}, "files": [{"sha": "d6af9b30ba01db2e39989fe6b28c8d51d2308134", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3c0ce750cb50921dee27d1399bd14a10145f7538", "patch": "@@ -1,3 +1,17 @@\n+2001-04-20  Per Bothner  <per@bothner.com>\n+\n+\tFixes to compile multiple .class files at once.\n+\t* decl.c (init_decl_processing):  Don't set CLASS_LOADED_P.\n+\t* java-tree.h (CLASS_PARSED_P):  New macro.\n+\t(CLASS_LOADED_P):  Re-define to use TYPE_SIZE and CLASS_PARSED_P.\n+\t* jcf-parse.c (jcf_parse_source):  Inline into read_class.\n+\t(read_class):  Avoid some code duplication.\n+\tDon't call JCF_FINISH for a .class file - might be needed later.\n+\t(jcf_parse):  Don't call layout_class here.  Check/set CLASS_PARSED_P\n+\trather than CLASS_LOADED_P, since latter implies class laid out.\n+\t(yyparse):  Do layout_class and JCF_FINISh here instead, in pass 2.\n+\t* parse.y:  Don't need to set CLASS_LOADED_P for array types.\n+\n 2001-04-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in (java/boehm.o): Depend on toplev.h."}, {"sha": "31e40b3fd36eeb8fc75f446eb10d956fb557038c", "filename": "gcc/java/decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=3c0ce750cb50921dee27d1399bd14a10145f7538", "patch": "@@ -667,7 +667,6 @@ init_decl_processing ()\n   PUSH_FIELD (field_type_node, field, \"bsize\", unsigned_short_type_node);\n   PUSH_FIELD (field_type_node, field, \"info\", field_info_union_node);\n   FINISH_RECORD (field_type_node);\n-  CLASS_LOADED_P (field_type_node) = 1;\n   build_decl (TYPE_DECL, get_identifier (\"Field\"), field_type_node);\n \n   one_elt_array_domain_type = build_index_type (integer_one_node);\n@@ -709,7 +708,6 @@ init_decl_processing ()\n   PUSH_FIELD (method_type_node, field, \"accflags\", access_flags_type_node);\n   PUSH_FIELD (method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n   FINISH_RECORD (method_type_node);\n-  CLASS_LOADED_P (method_type_node) = 1;\n   build_decl (TYPE_DECL, get_identifier (\"Method\"), method_type_node);\n \n   endlink = end_params_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);"}, {"sha": "65e7956ee7a8805f3d7886d02f671aa2d879ef17", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=3c0ce750cb50921dee27d1399bd14a10145f7538", "patch": "@@ -73,7 +73,7 @@ struct JCF;\n    Usage of TYPE_LANG_FLAG_?:\n    0: CLASS_ACCESS0_GENERATED_P (in RECORD_TYPE)\n    1: TYPE_ARRAY_P (in RECORD_TYPE).\n-   2: CLASS_LOADED_P (in RECORD_TYPE).\n+   2: CLASS_PARSED_P (in RECORD_TYPE).\n    3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n    4: CLASS_P (in RECORD_TYPE).\n    5: CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P (in RECORD_TYPE)\n@@ -1306,8 +1306,13 @@ extern tree *type_map;\n /* FIXME this use of TREE_TYPE conflicts with something or other. */\n #define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE(ATYPE)\n \n-/* True if class TYPE has been loaded. */\n-#define CLASS_LOADED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n+/* True if class TYPE has been loaded (i.e. parsed plus laid out).\n+   (The check for CLASS_PARSED_P is needed because of Object and Class.) */\n+#define CLASS_LOADED_P(TYPE) (TYPE_SIZE (TYPE) != NULL_TREE \\\n+\t\t\t      && (CLASS_PARSED_P(TYPE) || TYPE_ARRAY_P(TYPE)))\n+\n+/* True if class TYPE has been parsed (first pass). */\n+#define CLASS_PARSED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n \n /* True if class TYPE was defined in Java source code. */\n #define CLASS_FROM_SOURCE_P(TYPE) TYPE_LANG_FLAG_3 (TYPE)"}, {"sha": "4be3453cc41c99e3563ea0b1302440aaf1054db5", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 60, "deletions": 53, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=3c0ce750cb50921dee27d1399bd14a10145f7538", "patch": "@@ -93,7 +93,6 @@ static void parse_zip_file_entries PARAMS ((void));\n static void process_zip_dir PARAMS ((FILE *));\n static void parse_source_file_1 PARAMS ((tree, FILE *));\n static void parse_source_file_2 PARAMS ((void));\n-static void jcf_parse_source PARAMS ((void));\n static void parse_class_file PARAMS ((void));\n static void set_source_filename PARAMS ((JCF *, int));\n static int predefined_filename_p PARAMS ((tree));\n@@ -559,6 +558,7 @@ read_class (name)\n   tree save_current_class = current_class;\n   const char *save_input_filename = input_filename;\n   JCF *save_current_jcf = current_jcf;\n+  int generate;\n \n   if ((icv = IDENTIFIER_CLASS_VALUE (name)) != NULL_TREE)\n     {\n@@ -579,23 +579,50 @@ read_class (name)\n \n   current_jcf = jcf;\n \n+  java_parser_context_save_global ();\n+  java_push_parser_context ();\n   if (current_jcf->java_source)\n-    jcf_parse_source ();\n-  else {\n-    java_parser_context_save_global ();\n-    java_push_parser_context ();\n-    input_filename = current_jcf->filename;\n-    current_class = class;\n-    if (JCF_SEEN_IN_ZIP (current_jcf))\n-      read_zip_member(current_jcf, current_jcf->zipd, current_jcf->zipd->zipf);\n-    jcf_parse (current_jcf);\n-    load_inner_classes (current_class);\n-    java_pop_parser_context (0);\n-    java_parser_context_restore_global ();\n-  }\n-\n-  if (! JCF_SEEN_IN_ZIP (current_jcf))\n-    JCF_FINISH (current_jcf);\n+    {\n+      const char *filename = current_jcf->filename;\n+      tree file;\n+      FILE *finput;\n+\n+      BUILD_FILENAME_IDENTIFIER_NODE (file, filename);\n+      generate = IS_A_COMMAND_LINE_FILENAME_P (file);\n+      if (wfl_operator == NULL_TREE)\n+\twfl_operator = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n+      EXPR_WFL_FILENAME_NODE (wfl_operator) = file;\n+      input_filename = ggc_strdup (filename);\n+      current_class = NULL_TREE;\n+      current_function_decl = NULL_TREE;\n+      if (!HAS_BEEN_ALREADY_PARSED_P (file))\n+\t{\n+\t  if (!(finput = fopen (input_filename, \"r\")))\n+\t    fatal_io_error (\"can't reopen %s\", input_filename);\n+\t  parse_source_file_1 (file, finput);\n+\t  parse_source_file_2 ();\n+\t  if (fclose (finput))\n+\t    fatal_io_error (\"can't close %s\", input_filename);\n+\t}\n+      JCF_FINISH (current_jcf);\n+    }\n+  else\n+    {\n+      input_filename = current_jcf->filename;\n+      current_class = class;\n+      if (class == NULL_TREE || ! CLASS_PARSED_P (class))\n+\t{\n+\t  if (JCF_SEEN_IN_ZIP (current_jcf))\n+\t    read_zip_member(current_jcf,\n+\t\t\t    current_jcf->zipd, current_jcf->zipd->zipf);\n+\t  jcf_parse (current_jcf);\n+\t}\n+      layout_class (current_class);\n+      load_inner_classes (current_class);\n+      generate = 0;\n+    }\n+  java_pop_parser_context (generate);\n+  java_parser_context_restore_global ();\n \n   current_class = save_current_class;\n   input_filename = save_input_filename;\n@@ -632,36 +659,6 @@ load_class (class_or_name, verbose)\n     error (\"Cannot find file for class %s.\", IDENTIFIER_POINTER (name));\n }\n \n-/* Parse a source file when JCF refers to a source file.  */\n-\n-static void\n-jcf_parse_source ()\n-{\n-  tree file;\n-  FILE *finput;\n-\n-  java_parser_context_save_global ();\n-  java_push_parser_context ();\n-  BUILD_FILENAME_IDENTIFIER_NODE (file, current_jcf->filename);\n-  if (wfl_operator == NULL_TREE)\n-    wfl_operator = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n-  EXPR_WFL_FILENAME_NODE (wfl_operator) = file;\n-  input_filename = ggc_strdup (current_jcf->filename);\n-  current_class = NULL_TREE;\n-  current_function_decl = NULL_TREE;\n-  if (!HAS_BEEN_ALREADY_PARSED_P (file))\n-    {\n-      if (!(finput = fopen (input_filename, \"r\")))\n-\tfatal_io_error (\"can't reopen %s\", input_filename);\n-      parse_source_file_1 (file, finput);\n-      parse_source_file_2 ();\n-      if (fclose (finput))\n-\tfatal_io_error (\"can't close %s\", input_filename);\n-    }\n-  java_pop_parser_context (IS_A_COMMAND_LINE_FILENAME_P (file));\n-  java_parser_context_restore_global ();\n-}\n-\n /* Parse the .class file JCF. */\n \n void\n@@ -686,9 +683,14 @@ jcf_parse (jcf)\n     fprintf (stderr, \" %s %s\",\n \t     (jcf->access_flags & ACC_INTERFACE) ? \"interface\" : \"class\", \n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n-  if (CLASS_LOADED_P (current_class))\n-    return;\n-  CLASS_LOADED_P (current_class) = 1;\n+  if (CLASS_PARSED_P (current_class))\n+    {\n+      /* FIXME - where was first time */\n+      fatal_error (\"reading class %s for the second time from %s\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))),\n+\t\t   jcf->filename);\n+    }\n+  CLASS_PARSED_P (current_class) = 1;\n \n   for (i = 1; i < JPOOL_SIZE(jcf); i++)\n     {\n@@ -714,7 +716,6 @@ jcf_parse (jcf)\n   if (current_class != class_type_node && current_class != object_type_node)\n     TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n \n-  layout_class (current_class);\n   if (current_class == object_type_node)\n     {\n       layout_class_methods (object_type_node);\n@@ -1123,8 +1124,10 @@ yyparse ()\n \t{\n \t  current_class = TREE_PURPOSE (node);\n \t  current_jcf = TYPE_JCF (current_class);\n+\t  layout_class (current_class);\n \t  load_inner_classes (current_class);\n \t  parse_class_file ();\n+\t  JCF_FINISH (current_jcf);\n \t}\n     }\n   input_filename = main_input_filename;\n@@ -1157,8 +1160,12 @@ parse_zip_file_entries (void)\n \n       if ( !CLASS_LOADED_P (class))\n \t{\n-\t  read_zip_member(current_jcf, zdir, localToFile);\n-\t  jcf_parse (current_jcf);\n+\t  if (! CLASS_PARSED_P (class))\n+\t    {\n+\t      read_zip_member(current_jcf, zdir, localToFile);\n+\t      jcf_parse (current_jcf);\n+\t    }\n+\t  layout_class (current_class);\n \t  load_inner_classes (current_class);\n \t}\n "}, {"sha": "fb22d81705530a110b025a34fb87b71176f82aa9", "filename": "gcc/java/parse.y", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0ce750cb50921dee27d1399bd14a10145f7538/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=3c0ce750cb50921dee27d1399bd14a10145f7538", "patch": "@@ -666,7 +666,6 @@ array_type:\n \t\t{ \n \t\t  int osb = pop_current_osb (ctxp);\n \t\t  tree t = build_java_array_type (($1), -1);\n-\t\t  CLASS_LOADED_P (t) = 1;\n \t\t  while (--osb)\n \t\t    t = build_unresolved_array_type (t);\n \t\t  $$ = t;\n@@ -3268,7 +3267,6 @@ build_array_from_name (type, type_wfl, name, ret_name)\n       if (JPRIMITIVE_TYPE_P (type))\n \t{\n \t  type = build_java_array_type (type, -1);\n-\t  CLASS_LOADED_P (type) = 1;\n \t  more_dims--;\n \t}\n       /* Otherwise, if we have a WFL for this type, use it (the type\n@@ -3311,11 +3309,7 @@ build_unresolved_array_type (type_or_wfl)\n   /* TYPE_OR_WFL might be an array on a resolved type. In this case,\n      just create a array type */\n   if (TREE_CODE (type_or_wfl) == RECORD_TYPE)\n-    {\n-      tree type = build_java_array_type (type_or_wfl, -1);\n-      CLASS_LOADED_P (type) = CLASS_LOADED_P (type_or_wfl);\n-      return type;\n-    }\n+    return build_java_array_type (type_or_wfl, -1);\n \n   obstack_1grow (&temporary_obstack, '[');\n   obstack_grow0 (&temporary_obstack,\n@@ -3659,6 +3653,7 @@ maybe_create_class_interface_decl (decl, raw_name, qualified_name, cl)\n   else\n     DECL_SOURCE_LINE (decl) = EXPR_WFL_LINENO (cl);\n   CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) = 1;\n+  CLASS_PARSED_P (TREE_TYPE (decl)) = 1;\n   CLASS_FROM_CURRENTLY_COMPILED_P (TREE_TYPE (decl)) =\n     IS_A_COMMAND_LINE_FILENAME_P (EXPR_WFL_FILENAME_NODE (cl));\n \n@@ -5285,7 +5280,6 @@ safe_layout_class (class)\n   current_class = save_current_class;\n   input_filename = save_input_filename;\n   lineno = save_lineno;\n-  CLASS_LOADED_P (class) = 1;\n }\n \n static tree\n@@ -5506,7 +5500,6 @@ resolve_class (enclosing, class_type, decl, cl)\n       while (base != name)\n \t{\n \t  resolved_type = build_java_array_type (resolved_type, -1);\n-\t  CLASS_LOADED_P (resolved_type) = 1;\n \t  name--;\n \t}\n       /* A TYPE_NAME that is a TYPE_DECL was set in\n@@ -7314,9 +7307,6 @@ java_layout_classes ()\n       current_class = TREE_TYPE (TREE_VALUE (current));\n       layout_class (current_class);\n \n-      /* From now on, the class is considered completely loaded */\n-      CLASS_LOADED_P (current_class) = 1;\n-\n       /* Error reported by the caller */\n       if (java_error_count)\n \treturn;\n@@ -9152,7 +9142,6 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  if (decl == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (decl);\n-\t  CLASS_LOADED_P (type) = 1;\n \t  continue;\n \n \tcase CONVERT_EXPR:\n@@ -9465,8 +9454,6 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t  && !CLASS_LOADED_P (field_decl_type)\n \t\t  && !TYPE_ARRAY_P (field_decl_type))\n \t\tresolve_and_layout (field_decl_type, NULL_TREE);\n-\t      if (TYPE_ARRAY_P (field_decl_type))\n-\t\tCLASS_LOADED_P (field_decl_type) = 1;\n \t      \n \t      /* Check on accessibility here */\n \t      if (not_accessible_p (current_class, field_decl,\n@@ -13989,11 +13976,7 @@ resolve_type_during_patch (type)\n \t\t\t       IDENTIFIER_POINTER (EXPR_WFL_NODE (type)));\n \t  return NULL_TREE;\n \t}\n-      else\n-\t{\n-\t  CLASS_LOADED_P (TREE_TYPE (type_decl)) = 1;\n-\t  return TREE_TYPE (type_decl);\n-\t}\n+      return TREE_TYPE (type_decl);\n     }\n   return type;\n }"}]}