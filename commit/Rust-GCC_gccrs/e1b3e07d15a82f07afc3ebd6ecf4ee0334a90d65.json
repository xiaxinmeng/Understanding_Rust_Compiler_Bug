{"sha": "e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiM2UwN2QxNWE4MmYwN2FmYzNlYmQ2ZWNmNGVlMDMzNGE5MGQ2NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-09T06:17:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-09T06:17:13Z"}, "message": "cp-tree.h (scratch_tree_cons): Remove.\n\n\t* cp-tree.h (scratch_tree_cons): Remove.\n\t* call.c: Replace all uses of expr_tree_cons, saveable_tree_cons,\n\tand perm_tree_cons with plain tree_cons.\n\t* class.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* except.c: Likewise.\n\t* expr.c: Likewise.\n\t* init.c: Likewise.\n\t* lex.c: Likewise.\n\t* method.c: Likewise.\n\t* parse.y: Likewise.\n\t* pt.c: Likewise.\n\t* repo.c: Likewise.\n\t* rtti.c: Likewise.\n\t* search.c: Likewise.\n\t* typeck.c: Likewise.\n\t* parse.c: Regenerated.\n\t* tree.c (build_srcloc): Simplify.\n\nFrom-SVN: r29225", "tree": {"sha": "5953ca2b981b4fba376c0372f43a13e5ce7fa27d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5953ca2b981b4fba376c0372f43a13e5ce7fa27d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/comments", "author": null, "committer": null, "parents": [{"sha": "fc009f966c98317401b51127f59de4ad37bb7d19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc009f966c98317401b51127f59de4ad37bb7d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc009f966c98317401b51127f59de4ad37bb7d19"}], "stats": {"total": 361, "additions": 170, "deletions": 191}, "files": [{"sha": "ac0ad6bf40dbd91bec6aac3d4a62c0d91f9cb46d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -162,7 +162,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \t  else if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance)))\n \t\t   == METHOD_TYPE)\n \t    return build_function_call\n-\t      (instance, expr_tree_cons (NULL_TREE, instance_ptr, parms));\n+\t      (instance, tree_cons (NULL_TREE, instance_ptr, parms));\n \t}\n     }\n \n@@ -1992,10 +1992,10 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t  if (code == COND_EXPR)\n \t    {\n \t      if (real_lvalue_p (args[i]))\n-\t\ttypes[i] = scratch_tree_cons\n+\t\ttypes[i] = tree_cons\n \t\t  (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n \n-\t      types[i] = scratch_tree_cons\n+\t      types[i] = tree_cons\n \t\t(NULL_TREE, TYPE_MAIN_VARIANT (argtypes[i]), types[i]);\n \t    }\n \n@@ -2012,37 +2012,37 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t\tcontinue;\n \n \t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n-\t\ttypes[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n \n \t      type = non_reference (type);\n \t      if (i != 0 || ! ref1)\n \t\t{\n \t\t  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \t\t  if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t    types[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n+\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n \t\t  if (INTEGRAL_TYPE_P (type))\n \t\t    type = type_promotes_to (type);\n \t\t}\n \n \t      if (! value_member (type, types[i]))\n-\t\ttypes[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n \t    }\n \t}\n       else\n \t{\n \t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n-\t    types[i] = scratch_tree_cons\n+\t    types[i] = tree_cons\n \t      (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n \t  type = non_reference (argtypes[i]);\n \t  if (i != 0 || ! ref1)\n \t    {\n \t      type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \t      if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\ttypes[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n \t      if (INTEGRAL_TYPE_P (type))\n \t\ttype = type_promotes_to (type);\n \t    }\n-\t  types[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n+\t  types[i] = tree_cons (NULL_TREE, type, types[i]);\n \t}\n     }\n \n@@ -2256,8 +2256,8 @@ build_user_type_conversion_1 (totype, expr, flags)\n       TREE_TYPE (t) = build_pointer_type (totype);\n       args = build_scratch_list (NULL_TREE, expr);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (totype))\n-\targs = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n-      args = scratch_tree_cons (NULL_TREE, t, args);\n+\targs = tree_cons (NULL_TREE, integer_one_node, args);\n+      args = tree_cons (NULL_TREE, t, args);\n \n       ctors = TREE_VALUE (ctors);\n     }\n@@ -2269,7 +2269,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n       if (TREE_CODE (ctor) == TEMPLATE_DECL) \n \t{\n-\t  templates = scratch_tree_cons (NULL_TREE, ctor, templates);\n+\t  templates = tree_cons (NULL_TREE, ctor, templates);\n \t  candidates = \n \t    add_template_candidate (candidates, ctor,\n \t\t\t\t    NULL_TREE, args, NULL_TREE, flags,\n@@ -2319,7 +2319,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n \t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t      {\n-\t\ttemplates = scratch_tree_cons (NULL_TREE, fn, templates);\n+\t\ttemplates = tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = \n \t\t  add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  args, totype, flags,\n@@ -2476,7 +2476,7 @@ build_new_function_call (fn, args)\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n-\t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n+\t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n \t\t(candidates, t, explicit_targs, args, NULL_TREE,\n \t\t LOOKUP_NORMAL, DEDUCE_CALL);  \n@@ -2555,7 +2555,7 @@ build_object_call (obj, args)\n   if (fns)\n     {\n       tree base = TREE_PURPOSE (fns);\n-      mem_args = scratch_tree_cons (NULL_TREE, build_this (obj), args);\n+      mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n \n       for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n \t{\n@@ -3139,10 +3139,10 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     arg2 = integer_zero_node;\n \n   if (arg2 && arg3)\n-    arglist = scratch_tree_cons (NULL_TREE, arg1, scratch_tree_cons\n+    arglist = tree_cons (NULL_TREE, arg1, tree_cons\n \t\t      (NULL_TREE, arg2, build_scratch_list (NULL_TREE, arg3)));\n   else if (arg2)\n-    arglist = scratch_tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n+    arglist = tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n   else\n     arglist = build_scratch_list (NULL_TREE, arg1);\n \n@@ -3155,7 +3155,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       tree fn = OVL_CURRENT (fns);\n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t{\n-\t  templates = scratch_tree_cons (NULL_TREE, fn, templates);\n+\t  templates = tree_cons (NULL_TREE, fn, templates);\n \t  candidates \n \t    = add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t      arglist, TREE_TYPE (fnname),\n@@ -3177,7 +3177,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   if (fns)\n     {\n       tree basetype = TREE_PURPOSE (fns);\n-      mem_arglist = scratch_tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n+      mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n       for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n@@ -3191,7 +3191,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n \t      /* A member template. */\n-\t      templates = scratch_tree_cons (NULL_TREE, fn, templates);\n+\t      templates = tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  this_arglist,  TREE_TYPE (fnname),\n@@ -3521,7 +3521,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n       if (TREE_CODE (fns) == TREE_LIST)\n \t/* Member functions.  */\n \tenforce_access (TREE_PURPOSE (fns), fn);\n-      return build_function_call (fn, expr_tree_cons (NULL_TREE, addr, args));\n+      return build_function_call (fn, tree_cons (NULL_TREE, addr, args));\n     }\n \n   /* If we are doing placement delete we do nothing if we don't find a\n@@ -3542,8 +3542,8 @@ build_op_delete_call (code, addr, size, flags, placement)\n \t/* Member functions.  */\n \tenforce_access (TREE_PURPOSE (fns), fn);\n       return build_function_call\n-\t(fn, expr_tree_cons (NULL_TREE, addr,\n-\t\t\t     build_expr_list (NULL_TREE, size)));\n+\t(fn, tree_cons (NULL_TREE, addr,\n+\t\t\tbuild_expr_list (NULL_TREE, size)));\n     }\n \n   /* finish_function passes LOOKUP_SPECULATIVELY if we're in a\n@@ -3628,8 +3628,8 @@ convert_like (convs, expr)\n \n \t    args = build_scratch_list (NULL_TREE, expr);\n \t    if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n-\t      args = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n-\t    args = scratch_tree_cons (NULL_TREE, t, args);\n+\t      args = tree_cons (NULL_TREE, integer_one_node, args);\n+\t    args = tree_cons (NULL_TREE, t, args);\n \t  }\n \telse\n \t  args = build_this (expr);\n@@ -3856,12 +3856,12 @@ build_over_call (cand, args, flags)\n      resolution, and must be of the proper type.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n-      converted_args = expr_tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n+      converted_args = tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n       arg = TREE_CHAIN (arg);\n       parm = TREE_CHAIN (parm);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n \t{\n-\t  converted_args = expr_tree_cons\n+\t  converted_args = tree_cons\n \t    (NULL_TREE, TREE_VALUE (arg), converted_args);\n \t  arg = TREE_CHAIN (arg);\n \t  parm = TREE_CHAIN (parm);\n@@ -3885,7 +3885,7 @@ build_over_call (cand, args, flags)\n \t optimize accordingly.  */\n       my_friendly_assert (TREE_CODE (parmtype) == POINTER_TYPE, 19990811);\n       t = convert_pointer_to_real (TREE_TYPE (parmtype), TREE_VALUE (arg));\n-      converted_args = expr_tree_cons (NULL_TREE, t, converted_args);\n+      converted_args = tree_cons (NULL_TREE, t, converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n       ++i;\n@@ -3933,24 +3933,24 @@ build_over_call (cand, args, flags)\n \t      || TREE_CODE (type) == ENUMERAL_TYPE)\n \t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \tval = default_conversion (val);\n-      converted_args = expr_tree_cons (NULL_TREE, val, converted_args);\n+      converted_args = tree_cons (NULL_TREE, val, converted_args);\n     }\n \n   /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n     converted_args \n-      = expr_tree_cons (NULL_TREE, \n-\t\t\tconvert_default_arg (TREE_VALUE (parm), \n-\t\t\t\t\t     TREE_PURPOSE (parm),\n-\t\t\t\t\t     fn),\n-\t\t\tconverted_args);\n+      = tree_cons (NULL_TREE, \n+\t\t   convert_default_arg (TREE_VALUE (parm), \n+\t\t\t\t\tTREE_PURPOSE (parm),\n+\t\t\t\t\tfn),\n+\t\t   converted_args);\n \n   /* Ellipsis */\n   for (; arg; arg = TREE_CHAIN (arg))\n     converted_args \n-      = expr_tree_cons (NULL_TREE,\n-\t\t\tconvert_arg_to_ellipsis (TREE_VALUE (arg)),\n-\t\t\tconverted_args);\n+      = tree_cons (NULL_TREE,\n+\t\t   convert_arg_to_ellipsis (TREE_VALUE (arg)),\n+\t\t   converted_args);\n \n   converted_args = nreverse (converted_args);\n \n@@ -4206,9 +4206,9 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  && ! (flags & LOOKUP_HAS_IN_CHARGE))\n \t{\n \t  flags |= LOOKUP_HAS_IN_CHARGE;\n-\t  args = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n+\t  args = tree_cons (NULL_TREE, integer_one_node, args);\n \t}\n-      mem_args = scratch_tree_cons (NULL_TREE, instance_ptr, args);\n+      mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n       for (; fn; fn = OVL_NEXT (fn))\n \t{\n \t  tree t = OVL_CURRENT (fn);\n@@ -4227,7 +4227,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      /* A member template. */\n-\t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n+\t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = \n \t\tadd_template_candidate (candidates, t, explicit_targs,\n \t\t\t\t\tthis_arglist,\n@@ -4774,9 +4774,9 @@ static void\n add_warning (winner, loser)\n      struct z_candidate *winner, *loser;\n {\n-  winner->warnings = expr_tree_cons (NULL_PTR,\n-\t\t\t\t     build_expr_ptr_wrapper (loser),\n-\t\t\t\t     winner->warnings);\n+  winner->warnings = tree_cons (NULL_PTR,\n+\t\t\t\tbuild_expr_ptr_wrapper (loser),\n+\t\t\t\twinner->warnings);\n }\n \n /* Returns true iff functions are equivalent. Equivalent functions are"}, {"sha": "2c6a03f71562085e43f48ed60509e5eb4d3945d9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -399,8 +399,8 @@ build_vtable_entry (delta, pfn)\n   else\n     {\n       extern int flag_huge_objects;\n-      tree elems = expr_tree_cons (NULL_TREE, delta,\n-\t\t\t      expr_tree_cons (NULL_TREE, integer_zero_node,\n+      tree elems = tree_cons (NULL_TREE, delta,\n+\t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n \t\t\t\t\t build_expr_list (NULL_TREE, pfn)));\n       tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n@@ -3358,7 +3358,7 @@ finish_struct_1 (t)\n \t  else\n \t    fields = TREE_CHAIN (x);\n \t  \n-\t  access_decls = scratch_tree_cons (NULL_TREE, x, access_decls);\n+\t  access_decls = tree_cons (NULL_TREE, x, access_decls);\n \t  continue;\n \t}\n \n@@ -4820,7 +4820,7 @@ resolve_address_of_overloaded_function (target_type,\n \t    fntype = build_pointer_type (fntype);\n \n \t  if (can_convert_arg (target_type, fntype, fn))\n-\t    matches = scratch_tree_cons (fn, NULL_TREE, matches);\n+\t    matches = tree_cons (fn, NULL_TREE, matches);\n \t}\n     }\n \n@@ -4879,7 +4879,7 @@ resolve_address_of_overloaded_function (target_type,\n \t  else if (!is_reference)\n \t    instantiation_type = build_pointer_type (instantiation_type);\n \t  if (can_convert_arg (target_type, instantiation_type, instantiation))\n-\t    matches = scratch_tree_cons (instantiation, fn, matches);\n+\t    matches = tree_cons (instantiation, fn, matches);\n \t}\n \n       /* Now, remove all but the most specialized of the matches.  */\n@@ -4889,7 +4889,7 @@ resolve_address_of_overloaded_function (target_type,\n \t\t\t\t\t\t       explicit_targs);\n \n \t  if (match != error_mark_node)\n-\t    matches = scratch_tree_cons (match, NULL_TREE, NULL_TREE);\n+\t    matches = tree_cons (match, NULL_TREE, NULL_TREE);\n \t}\n     }\n \n@@ -4907,8 +4907,8 @@ resolve_address_of_overloaded_function (target_type,\n              TREE_VALUE slots, so we cons one up here (we're losing anyway,\n              so why be clever?).  */\n           for (; overload; overload = OVL_NEXT (overload))\n-            matches = scratch_tree_cons (NULL_TREE, OVL_CURRENT (overload),\n-                                         matches);\n+            matches = tree_cons (NULL_TREE, OVL_CURRENT (overload),\n+\t\t\t\t matches);\n           \n \t  print_candidates (matches);\n \t}"}, {"sha": "4a37cdb2a330016ea79e99145bbfca24845826c4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -3709,7 +3709,6 @@ extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n \n #define scratchalloc expralloc\n-#define scratch_tree_cons expr_tree_cons\n #define build_scratch_list build_expr_list\n #define make_scratch_vec make_temp_vec\n #define push_scratch_obstack push_expression_obstack"}, {"sha": "6305a623a936bc5531e803599931a6712b604afb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -2687,7 +2687,7 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t\t that won't happen below because B is not the class\n \t\t binding level, but is instead the pseudo-global level.  */\n \t      b->level_chain->tags = \n-\t\tsaveable_tree_cons (name, type, b->level_chain->tags);\n+\t\ttree_cons (name, type, b->level_chain->tags);\n \t      if (TYPE_SIZE (current_class_type) == NULL_TREE)\n \t\tCLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n \t    }\n@@ -2737,10 +2737,7 @@ pushtag (name, type, globalize)\n \t || (globalize && b->parm_flag == 2))\n     b = b->level_chain;\n \n-  if (toplevel_bindings_p ())\n-    b->tags = perm_tree_cons (name, type, b->tags);\n-  else\n-    b->tags = saveable_tree_cons (name, type, b->tags);\n+  b->tags = tree_cons (name, type, b->tags);\n \n   if (name)\n     {\n@@ -4401,7 +4398,7 @@ push_using_directive (used)\n \n   ancestor = namespace_ancestor (current_decl_namespace (), used);\n   ud = current_binding_level->using_directives;\n-  ud = perm_tree_cons (used, ancestor, ud);\n+  ud = tree_cons (used, ancestor, ud);\n   current_binding_level->using_directives = ud;\n   return ud;\n }\n@@ -5483,7 +5480,7 @@ unqualified_namespace_lookup (name, flags, spacesp)\n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n       if (spacesp)\n-\t*spacesp = scratch_tree_cons (scope, NULL_TREE, *spacesp);\n+\t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n       val = binding_for_name (name, scope);\n \n       /* Initialize binding for this context. */\n@@ -8185,9 +8182,9 @@ expand_static_init (decl, init)\n \t  mark_addressable (cleanup);\n \t  cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n \t  fcall = build_function_call (Atexit, \n-\t\t\t\t       expr_tree_cons (NULL_TREE, \n-\t\t\t\t\t\t       cleanup, \n-\t\t\t\t\t\t       NULL_TREE));\n+\t\t\t\t       tree_cons (NULL_TREE, \n+\t\t\t\t\t\t  cleanup, \n+\t\t\t\t\t\t  NULL_TREE));\n \t  finish_expr_stmt (fcall);\n \t}\n \n@@ -8205,7 +8202,7 @@ expand_static_init (decl, init)\n \t currently in the temporary obstack.  */\n       if (!TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n \tpreserve_initializer ();\n-      static_aggregates = perm_tree_cons (init, decl, static_aggregates);\n+      static_aggregates = tree_cons (init, decl, static_aggregates);\n     }\n }\n \n@@ -8535,9 +8532,9 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t     the information in the TEMPLATE_ID_EXPR.  */\n \t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n \t  DECL_TEMPLATE_INFO (decl)\n-\t    = perm_tree_cons (TREE_OPERAND (orig_declarator, 0),\n-\t\t\t      TREE_OPERAND (orig_declarator, 1),\n-\t\t\t      NULL_TREE);\n+\t    = tree_cons (TREE_OPERAND (orig_declarator, 0),\n+\t\t\t TREE_OPERAND (orig_declarator, 1),\n+\t\t\t NULL_TREE);\n \n \t  if (has_default_arg)\n \t    {\n@@ -11614,7 +11611,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t  TREE_CHAIN (list_node) = NULL_TREE;\n \t\t}\n \t      else\n-\t\tlist_node = saveable_tree_cons (init, type, NULL_TREE);\n+\t\tlist_node = tree_cons (init, type, NULL_TREE);\n \t      if (result == NULL_TREE)\n \t\t{\n \t\t  result = list_node;\n@@ -12796,7 +12793,7 @@ build_enumerator (name, value, type)\n      enum_overflow = tree_int_cst_lt (enum_next_value, value);\n    }\n \n-  result = saveable_tree_cons (name, decl, NULL_TREE);\n+  result = tree_cons (name, decl, NULL_TREE);\n   return result;\n }\n \n@@ -14034,9 +14031,9 @@ finish_function (lineno, flags)\n     }\n \n   if (DECL_STATIC_CONSTRUCTOR (fndecl))\n-    static_ctors = perm_tree_cons (NULL_TREE, fndecl, static_ctors);\n+    static_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n   if (DECL_STATIC_DESTRUCTOR (fndecl))\n-    static_dtors = perm_tree_cons (NULL_TREE, fndecl, static_dtors);\n+    static_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n \n   if (! nested)\n     {\n@@ -14296,7 +14293,7 @@ maybe_build_cleanup_1 (decl, auto_delete)\n \n       if (TYPE_USES_VIRTUAL_BASECLASSES (type)\n \t  && ! TYPE_HAS_DESTRUCTOR (type))\n-\trval = build_compound_expr (expr_tree_cons (NULL_TREE, rval,\n+\trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n \t\t\t\t\t       build_expr_list (NULL_TREE, build_vbase_delete (type, decl))));\n \n       if (TREE_CODE (decl) != PARM_DECL)"}, {"sha": "332fca525748d168769c4b32fbb6e412dddcd085", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -2151,7 +2151,7 @@ build_anon_union_vars (anon_decl, elems, static_p, external_p)\n \n       /* If there's a cleanup to do, it belongs in the\n \t TREE_PURPOSE of the following TREE_LIST.  */\n-      *elems = scratch_tree_cons (NULL_TREE, decl, *elems);\n+      *elems = tree_cons (NULL_TREE, decl, *elems);\n       TREE_TYPE (*elems) = type;\n     }\n   \n@@ -2952,8 +2952,8 @@ start_static_storage_duration_function ()\n \n   /* Create the parameters.  */\n   parm_types = void_list_node;\n-  parm_types = perm_tree_cons (NULL_TREE, integer_type_node, parm_types);\n-  parm_types = perm_tree_cons (NULL_TREE, integer_type_node, parm_types);\n+  parm_types = tree_cons (NULL_TREE, integer_type_node, parm_types);\n+  parm_types = tree_cons (NULL_TREE, integer_type_node, parm_types);\n   type = build_function_type (void_type_node, parm_types);\n \n   /* Create the FUNCTION_DECL itself.  */\n@@ -3986,7 +3986,7 @@ build_expr_from_tree (t)\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n \t  chain = build_expr_from_tree (chain);\n-\treturn expr_tree_cons (purpose, value, chain);\n+\treturn tree_cons (purpose, value, chain);\n       }\n \n     case COMPONENT_REF:\n@@ -4185,14 +4185,14 @@ add_using_namespace (user, used, indirect)\n \n   /* Add used to the user's using list. */\n   DECL_NAMESPACE_USING (user) \n-    = perm_tree_cons (used, namespace_ancestor (user, used), \n-\t\t      DECL_NAMESPACE_USING (user));\n+    = tree_cons (used, namespace_ancestor (user, used), \n+\t\t DECL_NAMESPACE_USING (user));\n \n   TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n \n   /* Add user to the used's users list. */\n   DECL_NAMESPACE_USERS (used)\n-    = perm_tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n+    = tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n \n   /* Recursively add all namespaces used. */\n   for (t = DECL_NAMESPACE_USING (used); t; t = TREE_CHAIN (t))\n@@ -4335,8 +4335,8 @@ lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n     if (TREE_VALUE (iter) == scope)\n       {\n \tif (spacesp)\n-\t  *spacesp = scratch_tree_cons (TREE_PURPOSE (iter), NULL_TREE,\n-\t\t\t\t\t*spacesp);\n+\t  *spacesp = tree_cons (TREE_PURPOSE (iter), NULL_TREE,\n+\t\t\t\t*spacesp);\n \tval1 = binding_for_name (name, TREE_PURPOSE (iter));\n \t/* Resolve ambiguities. */\n \tval = ambiguous_decl (name, val, val1, flags);"}, {"sha": "18bd798a25b661080112ac6a9ee49ed8c474ed96", "filename": "gcc/cp/except.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -470,7 +470,7 @@ do_pop_exception ()\n   mark_used (fn);\n   /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n   cleanup = lookup_name (get_identifier (\"__exception_info\"), 0);\n-  cleanup = build_function_call (fn, expr_tree_cons\n+  cleanup = build_function_call (fn, tree_cons\n \t\t\t\t (NULL_TREE, cleanup, NULL_TREE));\n   return cleanup;\n }\n@@ -691,7 +691,7 @@ expand_end_eh_spec (raises)\n   /* Build up an array of type_infos.  */\n   for (; raises && TREE_VALUE (raises); raises = TREE_CHAIN (raises))\n     {\n-      types = expr_tree_cons\n+      types = tree_cons\n \t(NULL_TREE, build_eh_type_type (TREE_VALUE (raises)), types);\n       ++count;\n     }\n@@ -731,8 +731,8 @@ expand_end_eh_spec (raises)\n     }\n \n   mark_used (fn);\n-  tmp = expr_tree_cons (NULL_TREE, build_int_2 (count, 0), expr_tree_cons\n-\t\t\t(NULL_TREE, decl, NULL_TREE));\n+  tmp = tree_cons (NULL_TREE, build_int_2 (count, 0), \n+\t\t   tree_cons (NULL_TREE, decl, NULL_TREE));\n   tmp = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), tmp);\n   expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -872,7 +872,7 @@ alloc_eh_object (type)\n     }\n \n   mark_used (fn);\n-  exp = build_function_call (fn, expr_tree_cons\n+  exp = build_function_call (fn, tree_cons\n \t\t\t     (NULL_TREE, size_in_bytes (type), NULL_TREE));\n   exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n   return exp;\n@@ -1025,9 +1025,9 @@ expand_throw (exp)\n \t}\n \n       mark_used (fn);\n-      e = expr_tree_cons (NULL_TREE, exp, expr_tree_cons\n-\t\t\t  (NULL_TREE, throw_type, expr_tree_cons\n-\t\t\t   (NULL_TREE, cleanup, NULL_TREE)));\n+      e = tree_cons (NULL_TREE, exp, tree_cons\n+\t\t     (NULL_TREE, throw_type, tree_cons\n+\t\t      (NULL_TREE, cleanup, NULL_TREE)));\n       e = build_function_call (fn, e);\n       expand_expr (e, const0_rtx, VOIDmode, 0);\n     }"}, {"sha": "c1f72636c980f9722384d8d38ba80ca5a5bf2d8e", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -161,7 +161,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t       parameter value.  */\n \t    mark_addressable (slot);\n \t    if (TREE_PERMANENT (args))\n-\t      args = expr_tree_cons (0, build1 (ADDR_EXPR, type, slot),\n+\t      args = tree_cons (0, build1 (ADDR_EXPR, type, slot),\n \t\t\t\tTREE_CHAIN (args));\n \t    else\n \t      TREE_VALUE (args) = build1 (ADDR_EXPR, type, slot);"}, {"sha": "fd48f198cab385aa6ad451d1644529527c028d0e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -1196,9 +1196,9 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       if (true_exp == exp)\n-\tparms = expr_tree_cons (NULL_TREE, integer_one_node, parms);\n+\tparms = tree_cons (NULL_TREE, integer_one_node, parms);\n       else\n-\tparms = expr_tree_cons (NULL_TREE, integer_zero_node, parms);\n+\tparms = tree_cons (NULL_TREE, integer_zero_node, parms);\n       flags |= LOOKUP_HAS_IN_CHARGE;\n     }\n \n@@ -2266,7 +2266,7 @@ build_new_1 (exp)\n \tsusp = suspend_momentary ();\n \n       rval = build_op_new_call\n-\t(code, true_type, expr_tree_cons (NULL_TREE, size, placement),\n+\t(code, true_type, tree_cons (NULL_TREE, size, placement),\n \t LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL));\n       rval = cp_convert (build_pointer_type (true_type), rval);\n \n@@ -2324,7 +2324,7 @@ build_new_1 (exp)\n       TREE_SIDE_EFFECTS (exp1) = 1;\n       rval = cp_convert (build_pointer_type (true_type), rval);\n       rval = build_compound_expr\n-\t(expr_tree_cons (NULL_TREE, exp1,\n+\t(tree_cons (NULL_TREE, exp1,\n \t\t\t build_expr_list (NULL_TREE, rval)));\n     }\n \n@@ -2389,7 +2389,7 @@ build_new_1 (exp)\n \n \t  if (rval && TYPE_USES_VIRTUAL_BASECLASSES (true_type))\n \t    {\n-\t      init = expr_tree_cons (NULL_TREE, integer_one_node, init);\n+\t      init = tree_cons (NULL_TREE, integer_one_node, init);\n \t      flags |= LOOKUP_HAS_IN_CHARGE;\n \t    }\n \n@@ -2580,24 +2580,24 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n   else\n     body = NULL_TREE;\n \n-  body = expr_tree_cons (NULL_TREE,\n+  body = tree_cons (NULL_TREE,\n \t\t    build_delete (ptype, tbase, auto_delete,\n \t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n \t\t    body);\n \n-  body = expr_tree_cons (NULL_TREE,\n+  body = tree_cons (NULL_TREE,\n \t\t    build_modify_expr (tbase, NOP_EXPR, build (MINUS_EXPR, ptype, tbase, size_exp)),\n \t\t    body);\n \n-  body = expr_tree_cons (NULL_TREE,\n+  body = tree_cons (NULL_TREE,\n \t\t    build (EXIT_EXPR, void_type_node,\n \t\t\t   build (EQ_EXPR, boolean_type_node, base, tbase)),\n \t\t    body);\n \n   loop = build (LOOP_EXPR, void_type_node, build_compound_expr (body));\n \n-  loop = expr_tree_cons (NULL_TREE, tbase_init,\n-\t\t    expr_tree_cons (NULL_TREE, loop, NULL_TREE));\n+  loop = tree_cons (NULL_TREE, tbase_init,\n+\t\t    tree_cons (NULL_TREE, loop, NULL_TREE));\n   loop = build_compound_expr (loop);\n \n  no_destructor:\n@@ -2636,8 +2636,8 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \n   if (loop && deallocate_expr != integer_zero_node)\n     {\n-      body = expr_tree_cons (NULL_TREE, loop,\n-\t\t\texpr_tree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n+      body = tree_cons (NULL_TREE, loop,\n+\t\t\ttree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n       body = build_compound_expr (body);\n     }\n   else\n@@ -3240,7 +3240,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  expr = build_scoped_method_call\n \t    (ref, base_binfo, dtor_identifier,\n \t     build_expr_list (NULL_TREE, this_auto_delete));\n-\t  exprstmt = expr_tree_cons (NULL_TREE, expr, exprstmt);\n+\t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n \n       /* Take care of the remaining baseclasses.  */\n@@ -3255,7 +3255,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t    (ref, base_binfo, dtor_identifier,\n \t     build_expr_list (NULL_TREE, integer_zero_node));\n \n-\t  exprstmt = expr_tree_cons (NULL_TREE, expr, exprstmt);\n+\t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n \n       for (member = TYPE_FIELDS (type); member; member = TREE_CHAIN (member))\n@@ -3267,7 +3267,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t      tree this_member = build_component_ref (ref, DECL_NAME (member), NULL_TREE, 0);\n \t      tree this_type = TREE_TYPE (member);\n \t      expr = build_delete (this_type, this_member, integer_two_node, flags, 0);\n-\t      exprstmt = expr_tree_cons (NULL_TREE, expr, exprstmt);\n+\t      exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t    }\n \t}\n \n@@ -3294,7 +3294,7 @@ build_vbase_delete (type, decl)\n     {\n       tree this_addr = convert_force (build_pointer_type (BINFO_TYPE (vbases)),\n \t\t\t\t      addr, 0);\n-      result = expr_tree_cons (NULL_TREE,\n+      result = tree_cons (NULL_TREE,\n \t\t\t  build_delete (TREE_TYPE (this_addr), this_addr,\n \t\t\t\t\tinteger_zero_node,\n \t\t\t\t\tLOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0),"}, {"sha": "21b09d47eb807237e2eb31406b6f5a71aef1aa71", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -2751,9 +2751,9 @@ handle_cp_pragma (pname)\n \t}\n \n       pending_vtables\n-\t= perm_tree_cons (NULL_TREE,\n-\t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n-\t\t\t  pending_vtables);\n+\t= tree_cons (NULL_TREE,\n+\t\t     get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n+\t\t     pending_vtables);\n       token = real_yylex ();\n       if (token != END_OF_LINE)\n \twarning (\"trailing characters ignored\");"}, {"sha": "f71b03e507e4788637b67c4b3f19580ae9394392", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -2140,9 +2140,9 @@ emit_thunk (thunk_fndecl)\n     t = build_int_2 (delta, -1 * (delta < 0));\n     TREE_TYPE (t) = signed_type (sizetype);\n     t = fold (build (PLUS_EXPR, TREE_TYPE (a), a, t));\n-    t = expr_tree_cons (NULL_TREE, t, NULL_TREE);\n+    t = tree_cons (NULL_TREE, t, NULL_TREE);\n     for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n-      t = expr_tree_cons (NULL_TREE, a, t);\n+      t = tree_cons (NULL_TREE, a, t);\n     t = nreverse (t);\n     t = build_call (function, TREE_TYPE (TREE_TYPE (function)), t);\n     c_expand_return (t);"}, {"sha": "beca740de3068491761c8cd44bcbacceec3b8fda", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -5246,12 +5246,12 @@ case 207:\n     break;}\n case 209:\n #line 1075 \"parse.y\"\n-{ yyval.ttype = expr_tree_cons (NULL_TREE, yyval.ttype, \n+{ yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, \n \t\t                  build_expr_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 210:\n #line 1078 \"parse.y\"\n-{ yyval.ttype = expr_tree_cons (NULL_TREE, yyval.ttype, \n+{ yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, \n \t\t                  build_expr_list (NULL_TREE, error_mark_node)); ;\n     break;}\n case 211:\n@@ -6310,7 +6310,7 @@ case 454:\n     break;}\n case 455:\n #line 2055 \"parse.y\"\n-{ yyval.ttype = expr_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n+{ yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 456:\n #line 2058 \"parse.y\"\n@@ -6322,7 +6322,7 @@ case 457:\n     break;}\n case 458:\n #line 2062 \"parse.y\"\n-{ yyval.ttype = expr_tree_cons (yyvsp[-2].ttype, yyvsp[0].ttype, yyval.ttype); ;\n+{ yyval.ttype = tree_cons (yyvsp[-2].ttype, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 459:\n #line 2067 \"parse.y\""}, {"sha": "dcee4ecf8aad4a95fda7b2abd2cfa675f4649653", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -1072,10 +1072,10 @@ already_scoped_stmt:\n \n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n-\t\t{ $$ = expr_tree_cons (NULL_TREE, $$, \n+\t\t{ $$ = tree_cons (NULL_TREE, $$, \n \t\t                  build_expr_list (NULL_TREE, $3)); }\n \t| expr_no_commas ',' error\n-\t\t{ $$ = expr_tree_cons (NULL_TREE, $$, \n+\t\t{ $$ = tree_cons (NULL_TREE, $$, \n \t\t                  build_expr_list (NULL_TREE, error_mark_node)); }\n \t| nontrivial_exprlist ',' expr_no_commas\n \t\t{ chainon ($$, build_expr_list (NULL_TREE, $3)); }\n@@ -2052,14 +2052,14 @@ initlist:\n \t  init\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| initlist ',' init\n-\t\t{ $$ = expr_tree_cons (NULL_TREE, $3, $$); }\n+\t\t{ $$ = tree_cons (NULL_TREE, $3, $$); }\n \t/* These are for labeled elements.  */\n \t| '[' expr_no_commas ']' init\n \t\t{ $$ = build_expr_list ($2, $4); }\n \t| identifier ':' init\n \t\t{ $$ = build_expr_list ($$, $3); }\n \t| initlist ',' identifier ':' init\n-\t\t{ $$ = expr_tree_cons ($3, $5, $$); }\n+\t\t{ $$ = tree_cons ($3, $5, $$); }\n \t;\n \n fn.defpen:"}, {"sha": "a452241bdf894171a866a6adb589dcbb24609beb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -912,7 +912,7 @@ register_specialization (spec, tmpl, args)\n       }\n \n   DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n-     = perm_tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+     = tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n \n   return spec;\n }\n@@ -951,7 +951,7 @@ register_local_specialization (spec, tmpl, fn)\n      tree fn;\n {\n   DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n-     = perm_tree_cons (fn, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+     = tree_cons (fn, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n \n   return spec;\n }\n@@ -1090,7 +1090,7 @@ determine_specialization (template_id, decl, targs_out,\n \tcontinue;\n \n       /* Save this template, and the arguments deduced.  */\n-      templates = scratch_tree_cons (targs, tmpl, templates);\n+      templates = tree_cons (targs, tmpl, templates);\n     }\n \n   if (templates && TREE_CHAIN (templates))\n@@ -1130,7 +1130,7 @@ determine_specialization (template_id, decl, targs_out,\n      if (tmpl && tmpl != error_mark_node)\n        {\n \t targs = get_bindings (tmpl, decl, explicit_targs);\n-\t templates = scratch_tree_cons (targs, tmpl, NULL_TREE);\n+\t templates = tree_cons (targs, tmpl, NULL_TREE);\n        }\n     }\n \n@@ -1546,8 +1546,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t    }\n \n \t  /* Set up the DECL_TEMPLATE_INFO for DECL.  */\n-\t  DECL_TEMPLATE_INFO (decl) \n-\t    = perm_tree_cons (tmpl, targs, NULL_TREE);\n+\t  DECL_TEMPLATE_INFO (decl) = tree_cons (tmpl, targs, NULL_TREE);\n \n \t  /* Mangle the function name appropriately.  Note that we do\n \t     not mangle specializations of non-template member\n@@ -2232,8 +2231,8 @@ process_partial_specialization (decl)\n     return decl;\n \n   DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = CLASSTYPE_TI_SPEC_INFO (type)\n-    = perm_tree_cons (inner_args, inner_parms,\n-\t\t      DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n+    = tree_cons (inner_args, inner_parms,\n+\t\t DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n   TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n   return decl;\n }\n@@ -2547,8 +2546,8 @@ push_template_decl_real (decl, is_friend)\n \t  TREE_TYPE (new_tmpl) = TREE_TYPE (decl);\n \t  DECL_TI_TEMPLATE (decl) = new_tmpl;\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (new_tmpl);\n-\t  DECL_TEMPLATE_INFO (new_tmpl) = \n-\t    perm_tree_cons (tmpl, args, NULL_TREE);\n+\t  DECL_TEMPLATE_INFO (new_tmpl) \n+\t    = tree_cons (tmpl, args, NULL_TREE);\n \n \t  register_specialization (new_tmpl, tmpl, args);\n \t  return decl;\n@@ -2604,7 +2603,7 @@ push_template_decl_real (decl, is_friend)\n   if (primary)\n     DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n \n-  info = perm_tree_cons (tmpl, args, NULL_TREE);\n+  info = tree_cons (tmpl, args, NULL_TREE);\n \n   if (DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n@@ -3633,8 +3632,7 @@ add_pending_template (d)\n   if (TI_PENDING_TEMPLATE_FLAG (ti))\n     return;\n \n-  *template_tail = perm_tree_cons\n-    (build_srcloc_here (), d, NULL_TREE);\n+  *template_tail = tree_cons (build_srcloc_here (), d, NULL_TREE);\n   template_tail = &TREE_CHAIN (*template_tail);\n   TI_PENDING_TEMPLATE_FLAG (ti) = 1;\n }\n@@ -3802,7 +3800,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \treturn error_mark_node;\n \n       TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm)\n-\t= perm_tree_cons (template2, arglist2, NULL_TREE);\n+\t= tree_cons (template2, arglist2, NULL_TREE);\n       TYPE_SIZE (parm) = 0;\n       return parm;\n     }\n@@ -5889,7 +5887,7 @@ tsubst_decl (t, args, type, in_decl)\n \tif (gen_tmpl)\n \t  {\n \t    DECL_TEMPLATE_INFO (r) \n-\t      = perm_tree_cons (gen_tmpl, argvec, NULL_TREE);\n+\t      = tree_cons (gen_tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t    register_specialization (r, gen_tmpl, argvec);\n \n@@ -6100,7 +6098,7 @@ tsubst_decl (t, args, type, in_decl)\n \tif (ctx)\n \t  DECL_EXTERNAL (r) = 1;\n \n-\tDECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n+\tDECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n \tSET_DECL_IMPLICIT_INSTANTIATION (r);\n \tif (ctx)\n \t  register_specialization (r, gen_tmpl, argvec);\n@@ -6511,7 +6509,7 @@ tsubst (t, args, complain, in_decl)\n \t\t  return error_mark_node;\n \n \t\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n-\t\t  = perm_tree_cons (TYPE_NAME (t), argvec, NULL_TREE);\n+\t\t  = tree_cons (TYPE_NAME (t), argvec, NULL_TREE);\n \t      }\n \t    break;\n \n@@ -7674,9 +7672,9 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n       /* This is a template conversion operator.  Use the return types\n          as well as the argument types.  We use it instead of 'this', since\n          we could be comparing conversions from different classes.  */\n-      parms = scratch_tree_cons (NULL_TREE, TREE_TYPE (fntype),\n-\t\t\t\t TREE_CHAIN (parms));\n-      args = scratch_tree_cons (NULL_TREE, return_type, TREE_CHAIN (args));\n+      parms = tree_cons (NULL_TREE, TREE_TYPE (fntype),\n+\t\t\t TREE_CHAIN (parms));\n+      args = tree_cons (NULL_TREE, return_type, TREE_CHAIN (args));\n     }\n \n   /* We allow incomplete unification without an error message here\n@@ -9044,8 +9042,7 @@ most_specialized (fns, decl, explicit_args)\n \n       args = get_bindings (candidate, decl, explicit_args);\n       if (args)\n-\tcandidates = scratch_tree_cons (NULL_TREE, candidate, \n-\t\t\t\t\tcandidates);\n+\tcandidates = tree_cons (NULL_TREE, candidate, candidates);\n     }\n \n   return most_specialized_instantiation (candidates, explicit_args);\n@@ -9909,7 +9906,7 @@ add_maybe_template (d, fns)\n       return;\n     }\n \n-  *maybe_template_tail = perm_tree_cons (t, d, NULL_TREE);\n+  *maybe_template_tail = tree_cons (t, d, NULL_TREE);\n   maybe_template_tail = &TREE_CHAIN (*maybe_template_tail);\n   DECL_MAYBE_TEMPLATE (d) = 1;\n }"}, {"sha": "fdeefb18f4decdb27c8b514ed514d2c07d5c24d1", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -142,7 +142,7 @@ repo_template_used (t)\n   if (! IDENTIFIER_REPO_USED (id))\n     {\n       IDENTIFIER_REPO_USED (id) = 1;\n-      pending_repo = perm_tree_cons (NULL_TREE, id, pending_repo);\n+      pending_repo = tree_cons (NULL_TREE, id, pending_repo);\n     }\n }\n \n@@ -156,7 +156,7 @@ repo_vtable_used (t)\n   if (! flag_use_repository)\n     return;\n \n-  pending_repo = perm_tree_cons (NULL_TREE, t, pending_repo);\n+  pending_repo = tree_cons (NULL_TREE, t, pending_repo);\n }\n \n /* Note that an inline with external linkage has been used, and offer to\n@@ -176,7 +176,7 @@ repo_inline_used (fn)\n       return;\n     }\n \n-  pending_repo = perm_tree_cons (NULL_TREE, fn, pending_repo);\n+  pending_repo = tree_cons (NULL_TREE, fn, pending_repo);\n }\n \n /* Note that a particular typeinfo node has been used, and offer to\n@@ -347,7 +347,7 @@ init_repo (filename)\n \t    else\n \t      orig = NULL_TREE;\n \n-\t    original_repo = perm_tree_cons (orig, id, original_repo);\n+\t    original_repo = tree_cons (orig, id, original_repo);\n \t  }\n \t  break;\n \tdefault:"}, {"sha": "2b4eeaf7af2296804953118359e569d4602d0898", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -298,7 +298,7 @@ build_x_typeid (exp)\n       tree bad = throw_bad_typeid ();\n \n       bad = build_compound_expr\n-\t(expr_tree_cons (NULL_TREE, bad, build_expr_list\n+\t(tree_cons (NULL_TREE, bad, build_expr_list\n \t\t    (NULL_TREE, cp_convert (type, integer_zero_node))));\n       exp = build (COND_EXPR, type, cond, exp, bad);\n     }\n@@ -676,7 +676,7 @@ build_dynamic_cast_1 (type, expr)\n \t    {\n \t      expr1 = throw_bad_cast ();\n \t      expr1 = build_compound_expr\n-\t\t(expr_tree_cons (NULL_TREE, expr1,\n+\t\t(tree_cons (NULL_TREE, expr1,\n \t\t\t    build_expr_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n \t      TREE_TYPE (expr1) = type;\n \t      result = save_expr (result);\n@@ -868,7 +868,7 @@ expand_class_desc (tdecl, type)\n \t   (NULL_TREE, isvir, tree_cons\n \t    (NULL_TREE, access, NULL_TREE)))));\n       TREE_HAS_CONSTRUCTOR (elt) = TREE_CONSTANT (elt) = TREE_STATIC (elt) = 1;\n-      elts = expr_tree_cons (NULL_TREE, elt, elts);\n+      elts = tree_cons (NULL_TREE, elt, elts);\n       base_cnt++;\n     }\n #if 0\n@@ -895,10 +895,10 @@ expand_class_desc (tdecl, type)\n       offset = BINFO_OFFSET (vb);\n       isvir = build_int_2 (1, 0);\n \n-      base_list = expr_tree_cons (NULL_TREE, base, base_list);\n-      isvir_list = expr_tree_cons (NULL_TREE, isvir, isvir_list);\n-      acc_list = expr_tree_cons (NULL_TREE, access, acc_list);\n-      off_list = expr_tree_cons (NULL_TREE, offset, off_list);\n+      base_list = tree_cons (NULL_TREE, base, base_list);\n+      isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);\n+      acc_list = tree_cons (NULL_TREE, access, acc_list);\n+      off_list = tree_cons (NULL_TREE, offset, off_list);\n \n       base_cnt++;\n       vb = TREE_CHAIN (vb);\n@@ -1014,7 +1014,7 @@ expand_attr_desc (tdecl, type)\n   elems = tree_cons\n     (NULL_TREE, decay_conversion (tdecl), tree_cons\n      (NULL_TREE, decay_conversion (name_string), tree_cons\n-      (NULL_TREE, attrval, expr_tree_cons (NULL_TREE, t, NULL_TREE))));\n+      (NULL_TREE, attrval, tree_cons (NULL_TREE, t, NULL_TREE))));\n \n   fn = get_identifier (\"__rtti_attr\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))"}, {"sha": "818ab144f45fd20ae67b3bb9afc354c931a4a252", "filename": "gcc/cp/search.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -1333,14 +1333,12 @@ lookup_field_r (binfo, data)\n \t      /* This is the first time we noticed an ambiguity.  Add\n \t\t what we previously thought was a reasonable candidate\n \t\t to the list.  */\n-\t      lfi->ambiguous = scratch_tree_cons (NULL_TREE, lfi->rval,\n-\t\t\t\t\t\t  NULL_TREE);\n+\t      lfi->ambiguous = tree_cons (NULL_TREE, lfi->rval, NULL_TREE);\n \t      TREE_TYPE (lfi->ambiguous) = error_mark_node;\n \t    }\n \n \t  /* Add the new value.  */\n-\t  lfi->ambiguous = scratch_tree_cons (NULL_TREE, nval, \n-\t\t\t\t\t      lfi->ambiguous);\n+\t  lfi->ambiguous = tree_cons (NULL_TREE, nval, lfi->ambiguous);\n \t  TREE_TYPE (lfi->ambiguous) = error_mark_node;\n \t  lfi->errstr = \"request for member `%D' is ambiguous\";\n \t}\n@@ -1484,7 +1482,7 @@ lookup_member (xbasetype, name, protect, want_type)\n \n   if (rval && is_overloaded_fn (rval)) \n     {\n-      rval = scratch_tree_cons (basetype_path, rval, NULL_TREE);\n+      rval = tree_cons (basetype_path, rval, NULL_TREE);\n       SET_BASELINK_P (rval);\n     }\n \n@@ -1774,10 +1772,9 @@ get_virtuals_named_this_r (binfo, data)\n   idx = lookup_fnfields_here (BINFO_TYPE (binfo), gvnti->name);\n   if (idx >= 0)\n     gvnti->fields\n-      = scratch_tree_cons (binfo, \n-\t\t\t   TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type),\n-\t\t\t\t\t idx),\n-\t\t\t   gvnti->fields);\n+      = tree_cons (binfo, \n+\t\t   TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx),\n+\t\t   gvnti->fields);\n \n   return NULL_TREE;\n }\n@@ -3150,8 +3147,6 @@ reinit_search_statistics ()\n #endif /* GATHER_STATISTICS */\n }\n \n-#define scratch_tree_cons expr_tree_cons\n-\n static tree\n add_conversions (binfo, data)\n      tree binfo;\n@@ -3178,7 +3173,7 @@ add_conversions (binfo, data)\n       /* Make sure we don't already have this conversion.  */\n       if (! IDENTIFIER_MARKED (name))\n \t{\n-\t  *conversions = scratch_tree_cons (binfo, tmp, *conversions);\n+\t  *conversions = tree_cons (binfo, tmp, *conversions);\n \t  IDENTIFIER_MARKED (name) = 1;\n \t}\n     }"}, {"sha": "2cb6721bb76c18504fb441c945714ab0cb3c91f4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -2522,19 +2522,10 @@ build_srcloc (file, line)\n {\n   tree t;\n \n-  /* Make sure that we put these on the permanent obstack; up in\n-     add_pending_template, we pass this return value into perm_tree_cons,\n-     which also puts it on the permanent_obstack.  However, this wasn't\n-     explicitly doing the same.  */\n-  register struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = &permanent_obstack;\n-\n   t = make_node (SRCLOC);\n   SRCLOC_FILE (t) = file;\n   SRCLOC_LINE (t) = line;\n \n-  current_obstack = ambient_obstack;\n-\n   return t;\n }\n "}, {"sha": "b035fbe93b2fb31b355d2bbb69e062d26f32b163", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e1b3e07d15a82f07afc3ebd6ecf4ee0334a90d65", "patch": "@@ -2833,7 +2833,7 @@ build_x_function_call (function, params, decl)\n \tfunction = TREE_OPERAND (function, 1);\n \n       function = get_member_function_from_ptrfunc (&decl_addr, function);\n-      params = expr_tree_cons (NULL_TREE, decl_addr, params);\n+      params = tree_cons (NULL_TREE, decl_addr, params);\n       return build_function_call (function, params);\n     }\n \n@@ -2884,7 +2884,7 @@ build_x_function_call (function, params, decl)\n \t}\n       else\n \tdecl = build_c_cast (ctypeptr, decl);\n-      params = expr_tree_cons (NULL_TREE, decl, params);\n+      params = tree_cons (NULL_TREE, decl, params);\n     }\n \n   return build_function_call (function, params);\n@@ -3260,14 +3260,14 @@ convert_arguments (typelist, values, fndecl, flags)\n \t  if (parmval == error_mark_node)\n \t    return error_mark_node;\n \n-\t  result = expr_tree_cons (NULL_TREE, parmval, result);\n+\t  result = tree_cons (NULL_TREE, parmval, result);\n \t}\n       else\n \t{\n \t  if (TREE_CODE (TREE_TYPE (val)) == REFERENCE_TYPE)\n \t    val = convert_from_reference (val);\n \n-\t  result = expr_tree_cons (NULL_TREE,\n+\t  result = tree_cons (NULL_TREE,\n \t\t\t\t   convert_arg_to_ellipsis (val),\n \t\t\t\t   result);\n \t}\n@@ -3291,7 +3291,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t      if (parmval == error_mark_node)\n \t\treturn error_mark_node;\n \n-\t      result = expr_tree_cons (0, parmval, result);\n+\t      result = tree_cons (0, parmval, result);\n \t      typetail = TREE_CHAIN (typetail);\n \t      /* ends with `...'.  */\n \t      if (typetail == NULL_TREE)\n@@ -5155,7 +5155,7 @@ build_x_compound_expr (list)\n   result = build_opfncall (COMPOUND_EXPR, LOOKUP_NORMAL,\n \t\t\t   TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n   if (result)\n-    return build_x_compound_expr (expr_tree_cons (NULL_TREE, result,\n+    return build_x_compound_expr (tree_cons (NULL_TREE, result,\n \t\t\t\t\t\t  TREE_CHAIN (rest)));\n \n   if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n@@ -5174,7 +5174,7 @@ build_x_compound_expr (list)\n #endif\n \n   return build_compound_expr\n-    (expr_tree_cons (NULL_TREE, TREE_VALUE (list),\n+    (tree_cons (NULL_TREE, TREE_VALUE (list),\n \t\t     build_expr_list (NULL_TREE,\n \t\t\t\t      build_x_compound_expr (rest))));\n }\n@@ -6182,18 +6182,18 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n   if (pfn)\n     {\n       u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t    expr_tree_cons (pfn_identifier, pfn, NULL_TREE));\n+\t\t    tree_cons (pfn_identifier, pfn, NULL_TREE));\n     }\n   else\n     {\n       u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t    expr_tree_cons (delta2_identifier, delta2, NULL_TREE));\n+\t\t    tree_cons (delta2_identifier, delta2, NULL_TREE));\n     }\n \n   u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\texpr_tree_cons (NULL_TREE, delta,\n-\t\t\t   expr_tree_cons (NULL_TREE, idx,\n-\t\t\t\t      expr_tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t\ttree_cons (NULL_TREE, delta,\n+\t\t\t   tree_cons (NULL_TREE, idx,\n+\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n \n   return digest_init (type, u, (tree*)0);\n #else\n@@ -6212,14 +6212,14 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n     {\n       allconstant = TREE_CONSTANT (pfn);\n       allsimple = !! initializer_constant_valid_p (pfn, TREE_TYPE (pfn));\n-      u = expr_tree_cons (pfn_field, pfn, NULL_TREE);\n+      u = tree_cons (pfn_field, pfn, NULL_TREE);\n     }\n   else\n     {\n       delta2 = convert_and_check (delta_type_node, delta2);\n       allconstant = TREE_CONSTANT (delta2);\n       allsimple = !! initializer_constant_valid_p (delta2, TREE_TYPE (delta2));\n-      u = expr_tree_cons (delta2_field, delta2, NULL_TREE);\n+      u = tree_cons (delta2_field, delta2, NULL_TREE);\n     }\n \n   delta = convert_and_check (delta_type_node, delta);\n@@ -6231,9 +6231,9 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n       && initializer_constant_valid_p (idx, TREE_TYPE (idx));\n \n   u = build (CONSTRUCTOR, subtype, NULL_TREE, u);\n-  u = expr_tree_cons (delta_field, delta,\n-\t\t expr_tree_cons (idx_field, idx,\n-\t\t\t    expr_tree_cons (pfn_or_delta2_field, u, NULL_TREE)));\n+  u = tree_cons (delta_field, delta,\n+\t\t tree_cons (idx_field, idx,\n+\t\t\t    tree_cons (pfn_or_delta2_field, u, NULL_TREE)));\n   u = build (CONSTRUCTOR, type, NULL_TREE, u);\n   TREE_CONSTANT (u) = allconstant;\n   TREE_STATIC (u) = allconstant && allsimple;"}]}