{"sha": "ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "node_id": "C_kwDOANBUbNoAKGVjZGY0MTRiZDg5ZTZiYTI1MWY2YjNmNDk0NDA3MTM5YjRkYmFlMGU", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T11:13:42Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T11:13:42Z"}, "message": "Enable ipa-sra with fnspec attributes\n\nEnable some ipa-sra on fortran by allowing signature changes on functions\nwith \"fn spec\" attribute when ipa-modref is enabled.  This is possible since ipa-modref\nknows how to preserve things we trace in fnspec and fnspec generated by fortran forntend\nare quite simple and can be analysed automatically now.  To be sure I will also add\ncode that merge fnspec to parameters.\n\nThis unfortunately hits bug in ipa-param-manipulation when we remove parameter\nthat specifies size of variable length parameter. For this reason I added a hack\nthat prevent signature changes on such functions and will handle it incrementally.\n\nI tried creating C testcase but it is blocked by another problem that we punt ipa-sra\non access attribute.  This is optimization regression we ought to fix so I filled\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=103223.\n\nAs a followup I will add code classifying the type attributes (we have just few) and\nget stats on access attribute.\n\ngcc/ChangeLog:\n\n\t* ipa-fnsummary.c (compute_fn_summary): Do not give up on signature\n\tchanges on \"fn spec\" attribute; give up on varadic types.\n\t* ipa-param-manipulation.c: Include attribs.h.\n\t(build_adjusted_function_type): New parameter ARG_MODIFIED; if it is\n\ttrue remove \"fn spec\" attribute.\n\t(ipa_param_adjustments::build_new_function_type): Update.\n\t(ipa_param_body_adjustments::modify_formal_parameters): update.\n\t* ipa-sra.c: Include attribs.h.\n\t(ipa_sra_preliminary_function_checks): Do not check for TYPE_ATTRIBUTES.", "tree": {"sha": "24cbfb095f17562f3f29ad32a65c512e3dda473a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24cbfb095f17562f3f29ad32a65c512e3dda473a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/comments", "author": null, "committer": null, "parents": [{"sha": "dc777f6b0646fed2f18a580ce249cb6404f89205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc777f6b0646fed2f18a580ce249cb6404f89205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc777f6b0646fed2f18a580ce249cb6404f89205"}], "stats": {"total": 91, "additions": 76, "deletions": 15}, "files": [{"sha": "94a80d3ec90d0bc6e0fa8700081b69f13f56e808", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "patch": "@@ -3135,10 +3135,38 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n        else\n \t info->inlinable = tree_inlinable_function_p (node->decl);\n \n-       /* Type attributes can use parameter indices to describe them.  */\n-       if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl))\n-\t   /* Likewise for #pragma omp declare simd functions or functions\n-\t      with simd attribute.  */\n+       bool no_signature = false;\n+       /* Type attributes can use parameter indices to describe them.\n+\t  Special case fn spec since we can safely preserve them in\n+\t  modref summaries.  */\n+       for (tree list = TYPE_ATTRIBUTES (TREE_TYPE (node->decl));\n+\t    list && !no_signature; list = TREE_CHAIN (list))\n+\t if (!flag_ipa_modref\n+\t     || !is_attribute_p (\"fn spec\", get_attribute_name (list)))\n+\t   {\n+\t     if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"No signature change:\"\n+\t\t\t   \" function type has unhandled attribute %s.\\n\",\n+\t\t\t   IDENTIFIER_POINTER (get_attribute_name (list)));\n+\t\t}\n+\t     no_signature = true;\n+\t   }\n+       for (tree parm = DECL_ARGUMENTS (node->decl);\n+\t    parm && !no_signature; parm = DECL_CHAIN (parm))\n+\t if (variably_modified_type_p (TREE_TYPE (parm), node->decl))\n+\t   {\n+\t     if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"No signature change:\"\n+\t\t\t   \" has parameter with variably modified type.\\n\");\n+\t\t}\n+\t     no_signature = true;\n+\t   }\n+\n+       /* Likewise for #pragma omp declare simd functions or functions\n+\t  with simd attribute.  */\n+       if (no_signature\n \t   || lookup_attribute (\"omp declare simd\",\n \t\t\t\tDECL_ATTRIBUTES (node->decl)))\n \t node->can_change_signature = false;"}, {"sha": "991db0d9b1bf176f64b73f1cfd4a84249c1ad3fa", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"symtab-clones.h\"\n #include \"tree-phinodes.h\"\n #include \"cfgexpand.h\"\n+#include \"attribs.h\"\n \n \n /* Actual prefixes of different newly synthetized parameters.  Keep in sync\n@@ -281,11 +282,13 @@ fill_vector_of_new_param_types (vec<tree> *new_types, vec<tree> *otypes,\n /* Build and return a function type just like ORIG_TYPE but with parameter\n    types given in NEW_PARAM_TYPES - which can be NULL if, but only if,\n    ORIG_TYPE itself has NULL TREE_ARG_TYPEs.  If METHOD2FUNC is true, also make\n-   it a FUNCTION_TYPE instead of FUNCTION_TYPE.  */\n+   it a FUNCTION_TYPE instead of FUNCTION_TYPE.\n+   If ARG_MODIFIED is true drop attributes that are no longer up to date.  */\n \n static tree\n build_adjusted_function_type (tree orig_type, vec<tree> *new_param_types,\n-\t\t\t      bool method2func, bool skip_return)\n+\t\t\t      bool method2func, bool skip_return,\n+\t\t\t      bool args_modified)\n {\n   tree new_arg_types = NULL;\n   if (TYPE_ARG_TYPES (orig_type))\n@@ -334,6 +337,17 @@ build_adjusted_function_type (tree orig_type, vec<tree> *new_param_types,\n       if (skip_return)\n \tTREE_TYPE (new_type) = void_type_node;\n     }\n+  /* We only support one fn spec attribute on type.  Be sure to remove it.\n+     Once we support multiple attributes we will need to be able to unshare\n+     the list.  */\n+  if (args_modified && TYPE_ATTRIBUTES (new_type))\n+    {\n+      gcc_checking_assert\n+\t      (!TREE_CHAIN (TYPE_ATTRIBUTES (new_type))\n+\t       && (is_attribute_p (\"fn spec\",\n+\t\t\t  get_attribute_name (TYPE_ATTRIBUTES (new_type)))));\n+      TYPE_ATTRIBUTES (new_type) = NULL;\n+    }\n \n   return new_type;\n }\n@@ -460,8 +474,22 @@ ipa_param_adjustments::build_new_function_type (tree old_type,\n   else\n     new_param_types_p = NULL;\n \n+  /* Check if any params type cares about are modified.  In this case will\n+     need to drop some type attributes.  */\n+  bool modified = false;\n+  size_t index = 0;\n+  if (m_adj_params)\n+    for (tree t = TYPE_ARG_TYPES (old_type);\n+\t t && (int)index < m_always_copy_start && !modified;\n+\t t = TREE_CHAIN (t), index++)\n+      if (index >= m_adj_params->length ()\n+\t  || get_original_index (index) != (int)index)\n+\tmodified = true;\n+\n+\n   return build_adjusted_function_type (old_type, new_param_types_p,\n-\t\t\t\t       method2func_p (old_type), m_skip_return);\n+\t\t\t\t       method2func_p (old_type), m_skip_return,\n+\t\t\t\t       modified);\n }\n \n /* Build variant of function decl ORIG_DECL which has no return value if\n@@ -1467,12 +1495,23 @@ ipa_param_body_adjustments::modify_formal_parameters ()\n   if (fndecl_built_in_p (m_fndecl))\n     set_decl_built_in_function (m_fndecl, NOT_BUILT_IN, 0);\n \n+  bool modified = false;\n+  size_t index = 0;\n+  if (m_adj_params)\n+    for (tree t = TYPE_ARG_TYPES (orig_type);\n+\t t && !modified;\n+\t t = TREE_CHAIN (t), index++)\n+      if (index >= m_adj_params->length ()\n+\t  || (*m_adj_params)[index].op != IPA_PARAM_OP_COPY\n+\t  || (*m_adj_params)[index].base_index != index)\n+\tmodified = true;\n+\n   /* At this point, removing return value is only implemented when going\n      through tree_function_versioning, not when modifying function body\n      directly.  */\n   gcc_assert (!m_adjustments || !m_adjustments->m_skip_return);\n   tree new_type = build_adjusted_function_type (orig_type, &m_new_types,\n-\t\t\t\t\t\tm_method2func, false);\n+\t\t\t\t\t\tm_method2func, false, modified);\n \n   TREE_TYPE (m_fndecl) = new_type;\n   DECL_VIRTUAL_P (m_fndecl) = 0;"}, {"sha": "cb0e30507a1d318845e1fa357277e47e3b3ae0f8", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecdf414bd89e6ba251f6b3f494407139b4dbae0e/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=ecdf414bd89e6ba251f6b3f494407139b4dbae0e", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"internal-fn.h\"\n #include \"symtab-clones.h\"\n+#include \"attribs.h\"\n \n static void ipa_sra_summarize_function (cgraph_node *);\n \n@@ -616,13 +617,6 @@ ipa_sra_preliminary_function_checks (cgraph_node *node)\n       return false;\n     }\n \n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function type has attributes. \\n\");\n-      return false;\n-    }\n-\n   if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n     {\n       if (dump_file)"}]}