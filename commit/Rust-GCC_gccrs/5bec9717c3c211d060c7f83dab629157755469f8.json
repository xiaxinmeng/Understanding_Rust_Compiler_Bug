{"sha": "5bec9717c3c211d060c7f83dab629157755469f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJlYzk3MTdjM2MyMTFkMDYwYzdmODNkYWI2MjkxNTc3NTU0NjlmOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T16:35:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T16:35:15Z"}, "message": "[multiple changes]\n\n2010-06-22  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.adb, a-coinve.adb: Removed 64-bit types Int and UInt.\n\n2010-06-22  Paul Hilfinger  <hilfinger@adacore.com>\n\n\t* s-rannum.adb (Random_Float_Template): Replace with unbiased version\n\tthat is able to produce all representable floating-point numbers in the\n\tunit interval. Remove template parameter Shift_Right, no longer used.\n\t* gnat_rm.texi: Document the period of the pseudo-random number\n\tgenerator under the description of its algorithm.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\nFrom-SVN: r161202", "tree": {"sha": "cd63993cb9680d415dbcc471971970fba6370f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd63993cb9680d415dbcc471971970fba6370f18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bec9717c3c211d060c7f83dab629157755469f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bec9717c3c211d060c7f83dab629157755469f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bec9717c3c211d060c7f83dab629157755469f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bec9717c3c211d060c7f83dab629157755469f8/comments", "author": null, "committer": null, "parents": [{"sha": "5087048c12395ee380b8040e9ecf399b64e1cf66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5087048c12395ee380b8040e9ecf399b64e1cf66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5087048c12395ee380b8040e9ecf399b64e1cf66"}], "stats": {"total": 4121, "additions": 2866, "deletions": 1255}, "files": [{"sha": "b3834978de071c72f11c323f2d02dff36d86c202", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5bec9717c3c211d060c7f83dab629157755469f8", "patch": "@@ -1,3 +1,16 @@\n+2010-06-22  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-convec.adb, a-coinve.adb: Removed 64-bit types Int and UInt.\n+\n+2010-06-22  Paul Hilfinger  <hilfinger@adacore.com>\n+\n+\t* s-rannum.adb (Random_Float_Template): Replace with unbiased version\n+\tthat is able to produce all representable floating-point numbers in the\n+\tunit interval. Remove template parameter Shift_Right, no longer used.\n+\t* gnat_rm.texi: Document the period of the pseudo-random number\n+\tgenerator under the description of its algorithm.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n 2010-06-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_aggr.adb (Rewrite_Discriminant): Fix predicate used to identify"}, {"sha": "6443644b4f650aa6947da42ecd0c50eab4b939bc", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 1353, "deletions": 538, "changes": 1891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=5bec9717c3c211d060c7f83dab629157755469f8"}, {"sha": "501128b9d89afebdf8443c78365be3cbd1e93ab5", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 1179, "deletions": 415, "changes": 1594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=5bec9717c3c211d060c7f83dab629157755469f8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,9 +34,6 @@ with System; use type System.Address;\n \n package body Ada.Containers.Vectors is\n \n-   type Int is range System.Min_Int .. System.Max_Int;\n-   type UInt is mod System.Max_Binary_Modulus;\n-\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n \n@@ -45,10 +42,22 @@ package body Ada.Containers.Vectors is\n    ---------\n \n    function \"&\" (Left, Right : Vector) return Vector is\n-      LN : constant Count_Type := Length (Left);\n-      RN : constant Count_Type := Length (Right);\n+      LN   : constant Count_Type := Length (Left);\n+      RN   : constant Count_Type := Length (Right);\n+      N    : Count_Type'Base;  -- length of result\n+      J    : Count_Type'Base;  -- for computing intermediate index values\n+      Last : Index_Type'Base;  -- Last index of result\n \n    begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the vector parameters. We could decide to make it larger, but we\n+      --  have no basis for knowing how much larger, so we just allocate the\n+      --  minimum amount of storage.\n+\n+      --  Here we handle the easy cases first, when one of the vector\n+      --  parameters is empty. (We say \"easy\" because there's nothing to\n+      --  compute, that can potentially overflow.)\n+\n       if LN = 0 then\n          if RN = 0 then\n             return Empty_Vector;\n@@ -80,82 +89,116 @@ package body Ada.Containers.Vectors is\n \n       end if;\n \n-      declare\n-         N : constant Int'Base := Int (LN) + Int (RN);\n-         J : Int'Base;\n+      --  Neither of the vector parameters is empty, so must compute the length\n+      --  of the result vector and its last index. (This is the harder case,\n+      --  because our computations must avoid overflow.)\n \n-      begin\n-         --  There are two constraints we need to satisfy. The first constraint\n-         --  is that a container cannot have more than Count_Type'Last\n-         --  elements, so we must check the sum of the combined lengths. (It\n-         --  would be rare for vectors to have such a large number of elements,\n-         --  so we would normally expect this first check to succeed.) The\n-         --  second constraint is that the new Last index value cannot exceed\n-         --  Index_Type'Last.\n-\n-         if N > Count_Type'Pos (Count_Type'Last) then\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the combined lengths. Note that we cannot\n+      --  simply add the lengths, because of the possibilty of overflow.\n+\n+      if LN > Count_Type'Last - RN then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n+\n+      N := LN + RN;\n+\n+      --  The second constraint is that the new Last index value cannot\n+      --  exceed Index_Type'Last. We use the wider of Index_Type'Base and\n+      --  Count_Type'Base as the type for intermediate values.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (N) < No_Index then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n-         --  We now check whether the new length would create a Last index\n-         --  value greater than Index_Type'Last. This calculation requires\n-         --  care, because overflow can occur when Index_Type'First is near the\n-         --  end of the range of Int.\n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n \n-         if Index_Type'First <= 0 then\n+         Last := No_Index + Index_Type'Base (N);\n \n-            --  Compute the potential Last index value in the normal way, using\n-            --  Int as the type in which to perform intermediate\n-            --  calculations. Int is a 64-bit type, and Count_Type is a 32-bit\n-            --  type, so no overflow can occur.\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n \n-            J := Int (Index_Type'First - 1) + N;\n+         if Last > Index_Type'Last then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n \n-            if J > Int (Index_Type'Last) then\n-               raise Constraint_Error with \"new length is out of range\";\n-            end if;\n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of length.\n \n-         else\n-            --  If Index_Type'First is within N of Int'Last, then overflow\n-            --  would occur if we simply computed Last directly. So instead of\n-            --  computing Last, and then determining whether its value is\n-            --  greater than Index_Type'Last (as we do above), we work\n-            --  backwards by computing the potential First index value, and\n-            --  then checking whether that value is less than Index_Type'First.\n+         J := Count_Type'Base (No_Index) + N;  -- Last\n+\n+         if J > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n \n-            J := Int (Index_Type'Last) - N + 1;\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n \n-            if J < Int (Index_Type'First) then\n-               raise Constraint_Error with \"new length is out of range\";\n-            end if;\n+         Last := Index_Type'Base (J);\n+\n+      else\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n \n-            --  We have determined that Length would not create a Last index\n-            --  value outside of the range of Index_Type, so we can now safely\n-            --  compute its value.\n+         J := Count_Type'Base (Index_Type'Last) - N;  -- No_Index\n \n-            J := Int (Index_Type'First - 1) + N;\n+         if J < Count_Type'Base (No_Index) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n-         declare\n-            Last : constant Index_Type := Index_Type (J);\n+         --  We have determined that the result length would not create a Last\n+         --  index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n \n-            LE : Elements_Array renames\n-                   Left.Elements.EA (Index_Type'First .. Left.Last);\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + N);\n+      end if;\n \n-            RE : Elements_Array renames\n-                   Right.Elements.EA (Index_Type'First .. Right.Last);\n+      declare\n+         LE : Elements_Array renames\n+                Left.Elements.EA (Index_Type'First .. Left.Last);\n \n-            Elements : constant Elements_Access :=\n-                         new Elements_Type'(Last, LE & RE);\n+         RE : Elements_Array renames\n+                Right.Elements.EA (Index_Type'First .. Right.Last);\n \n-         begin\n-            return (Controlled with Elements, Last, 0, 0);\n-         end;\n+         Elements : constant Elements_Access :=\n+                      new Elements_Type'(Last, LE & RE);\n+\n+      begin\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n    function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n    begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the parameters. We could decide to make it larger, but we have no\n+      --  basis for knowing how much larger, so we just allocate the minimum\n+      --  amount of storage.\n+\n+      --  Here we handle the easy case first, when the vector parameter (Left)\n+      --  is empty.\n+\n       if Left.Is_Empty then\n          declare\n             Elements : constant Elements_Access :=\n@@ -168,8 +211,10 @@ package body Ada.Containers.Vectors is\n          end;\n       end if;\n \n-      --  We must satisfy two constraints: the new length cannot exceed\n-      --  Count_Type'Last, and the new Last index cannot exceed\n+      --  The vector parameter is not empty, so we must compute the length of\n+      --  the result vector and its last index, but in such a way that overflow\n+      --  is avoided. We must satisfy two constraints: the new length cannot\n+      --  exceed Count_Type'Last, and the new Last index cannot exceed\n       --  Index_Type'Last.\n \n       if Left.Length = Count_Type'Last then\n@@ -198,6 +243,14 @@ package body Ada.Containers.Vectors is\n \n    function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n    begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the parameters. We could decide to make it larger, but we have no\n+      --  basis for knowing how much larger, so we just allocate the minimum\n+      --  amount of storage.\n+\n+      --  Here we handle the easy case first, when the vector parameter (Right)\n+      --  is empty.\n+\n       if Right.Is_Empty then\n          declare\n             Elements : constant Elements_Access :=\n@@ -210,8 +263,10 @@ package body Ada.Containers.Vectors is\n          end;\n       end if;\n \n-      --  We must satisfy two constraints: the new length cannot exceed\n-      --  Count_Type'Last, and the new Last index cannot exceed\n+      --  The vector parameter is not empty, so we must compute the length of\n+      --  the result vector and its last index, but in such a way that overflow\n+      --  is avoided. We must satisfy two constraints: the new length cannot\n+      --  exceed Count_Type'Last, and the new Last index cannot exceed\n       --  Index_Type'Last.\n \n       if Right.Length = Count_Type'Last then\n@@ -240,6 +295,17 @@ package body Ada.Containers.Vectors is\n \n    function \"&\" (Left, Right : Element_Type) return Vector is\n    begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the parameters. We could decide to make it larger, but we have no\n+      --  basis for knowing how much larger, so we just allocate the minimum\n+      --  amount of storage.\n+\n+      --  We must compute the length of the result vector and its last index,\n+      --  but in such a way that overflow is avoided. We must satisfy two\n+      --  constraints: the new length cannot exceed Count_Type'Last (here, we\n+      --  know that that condition is satisfied), and the new Last index cannot\n+      --  exceed Index_Type'Last.\n+\n       if Index_Type'First >= Index_Type'Last then\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n@@ -401,56 +467,117 @@ package body Ada.Containers.Vectors is\n       Index     : Extended_Index;\n       Count     : Count_Type := 1)\n    is\n-   begin\n+      Old_Last : constant Index_Type'Base := Container.Last;\n+      New_Last : Index_Type'Base;\n+      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last\n+      J        : Index_Type'Base;  -- first index of items that slide down\n+\n+   begin\n+      --  Delete removes items from the vector, the number of which is the\n+      --  minimum of the specified Count and the items (if any) that exist from\n+      --  Index to Container.Last. There are no constraints on the specified\n+      --  value of Count (it can be larger than what's available at this\n+      --  position in the vector, for example), but there are constraints on\n+      --  the allowed values of the Index.\n+\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying which items\n+      --  should be deleted, so we must manually check. (That the user is\n+      --  allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n       if Index < Index_Type'First then\n          raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n-      if Index > Container.Last then\n-         if Index > Container.Last + 1 then\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows the\n+      --  corner case of deleting no items from the back end of the vector to\n+      --  be treated as a no-op. (It is assumed that specifying an index value\n+      --  greater than Last + 1 indicates some deeper flaw in the caller's\n+      --  algorithm, so that case is treated as a proper error.)\n+\n+      if Index > Old_Last then\n+         if Index > Old_Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n          end if;\n \n          return;\n       end if;\n \n+      --  Here and elsewhere we treat deleting 0 items from the container as a\n+      --  no-op, even when the container is busy, so we simply return.\n+\n       if Count = 0 then\n          return;\n       end if;\n \n+      --  The tampering bits exist to prevent an item from being deleted (or\n+      --  otherwise harmfully manipulated) while it is being visited. Query,\n+      --  Update, and Iterate increment the busy count on entry, and decrement\n+      --  the count on exit. Delete checks the count to determine whether it is\n+      --  being called while the associated callback procedure is executing.\n+\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n-      declare\n-         I_As_Int        : constant Int := Int (Index);\n-         Old_Last_As_Int : constant Int := Index_Type'Pos (Container.Last);\n+      --  We first calculate what's available for deletion starting at\n+      --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n+      --  Count_Type'Base as the type for intermediate values. (See function\n+      --  Length for more information.)\n \n-         Count1 : constant Int'Base := Count_Type'Pos (Count);\n-         Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n-         N      : constant Int'Base := Int'Min (Count1, Count2);\n+      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n+         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n \n-         J_As_Int : constant Int'Base := I_As_Int + N;\n+      else\n+         Count2 := Count_Type'Base (Old_Last - Index + 1);\n+      end if;\n \n-      begin\n-         if J_As_Int > Old_Last_As_Int then\n-            Container.Last := Index - 1;\n+      --  If more elements are requested (Count) for deletion than are\n+      --  available (Count2) for deletion beginning at Index, then everything\n+      --  from Index is deleted. There are no elements to slide down, and so\n+      --  all we need to do is set the value of Container.Last.\n \n-         else\n-            declare\n-               J  : constant Index_Type := Index_Type (J_As_Int);\n-               EA : Elements_Array renames Container.Elements.EA;\n+      if Count >= Count2 then\n+         Container.Last := Index - 1;\n+         return;\n+      end if;\n \n-               New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n-               New_Last        : constant Index_Type :=\n-                                   Index_Type (New_Last_As_Int);\n+      --  There are some elements aren't being deleted (the requested count was\n+      --  less than the available count), so we must slide them down to\n+      --  Index. We first calculate the index values of the respective array\n+      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n+      --  type for intermediate calculations. For the elements that slide down,\n+      --  index value New_Last is the last index value of their new home, and\n+      --  index value J is the first index of their old home.\n \n-            begin\n-               EA (Index .. New_Last) := EA (J .. Container.Last);\n-               Container.Last := New_Last;\n-            end;\n-         end if;\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         New_Last := Old_Last - Index_Type'Base (Count);\n+         J := Index + Index_Type'Base (Count);\n+\n+      else\n+         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n+         J := Index_Type'Base (Count_Type'Base (Index) + Count);\n+      end if;\n+\n+      --  The internal elements array isn't guaranteed to exist unless we have\n+      --  elements, but we have that guarantee here because we know we have\n+      --  elements to slide.  The array index values for each slice have\n+      --  already been determined, so we just slide down to Index the elements\n+      --  that weren't deleted.\n+\n+      declare\n+         EA : Elements_Array renames Container.Elements.EA;\n+\n+      begin\n+         EA (Index .. New_Last) := EA (J .. Old_Last);\n+         Container.Last := New_Last;\n       end;\n    end Delete;\n \n@@ -507,24 +634,47 @@ package body Ada.Containers.Vectors is\n      (Container : in out Vector;\n       Count     : Count_Type := 1)\n    is\n-      Index : Int'Base;\n-\n    begin\n+      --  It is not permitted to delete items while the container is busy (for\n+      --  example, we're in the middle of a passive iteration). However, we\n+      --  always treat deleting 0 items as a no-op, even when we're busy, so we\n+      --  simply return without checking.\n+\n       if Count = 0 then\n          return;\n       end if;\n \n+      --  The tampering bits exist to prevent an item from being deleted (or\n+      --  otherwise harmfully manipulated) while it is being visited. Query,\n+      --  Update, and Iterate increment the busy count on entry, and decrement\n+      --  the count on exit. Delete_Last checks the count to determine whether\n+      --  it is being called while the associated callback procedure is\n+      --  executing.\n+\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n+      --  There is no restriction on how large Count can be when deleting\n+      --  items. If it is equal or greater than the current length, then this\n+      --  is equivalent to clearing the vector. (In particular, there's no need\n+      --  for us to actually calculate the new value for Last.)\n+\n+      --  If the requested count is less than the current length, then we must\n+      --  calculate the new value for Last. For the type we use the widest of\n+      --  Index_Type'Base and Count_Type'Base for the intermediate values of\n+      --  our calculation.  (See the comments in Length for more information.)\n+\n       if Count >= Container.Length then\n          Container.Last := No_Index;\n \n+      elsif Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := Container.Last - Index_Type'Base (Count);\n+\n       else\n-         Index := Int (Container.Last) - Int (Count);\n-         Container.Last := Index_Type (Index);\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (Container.Last) - Count);\n       end if;\n    end Delete_Last;\n \n@@ -804,170 +954,339 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    is\n-      N : constant Int := Count_Type'Pos (Count);\n+      Old_Length : constant Count_Type := Container.Length;\n \n-      First           : constant Int := Int (Index_Type'First);\n-      New_Last_As_Int : Int'Base;\n-      New_Last        : Index_Type;\n-      New_Length      : UInt;\n-      Max_Length      : constant UInt := UInt (Count_Type'Last);\n+      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n+      New_Length : Count_Type'Base;  -- sum of current length and Count\n+      New_Last   : Index_Type'Base;  -- last index of vector after insertion\n \n-      Dst : Elements_Access;\n+      Index : Index_Type'Base;  -- scratch for intermediate values\n+      J     : Count_Type'Base;  -- scratch\n+\n+      New_Capacity : Count_Type'Base;  -- length of new, expanded array\n+      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array\n+      Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying where the new\n+      --  items should be inserted, so we must manually check. (That the user\n+      --  is allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n \n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows for the\n+      --  case of appending items to the back end of the vector. (It is assumed\n+      --  that specifying an index value greater than Last + 1 indicates some\n+      --  deeper flaw in the caller's algorithm, so that case is treated as a\n+      --  proper error.)\n+\n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n \n+      --  We treat inserting 0 items into the container as a no-op, even when\n+      --  the container is busy, so we simply return.\n+\n       if Count = 0 then\n          return;\n       end if;\n \n-      declare\n-         Old_Last_As_Int : constant Int := Int (Container.Last);\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the current length and the insertion\n+      --  count. Note that we cannot simply add these values, because of the\n+      --  possibilty of overflow.\n \n-      begin\n-         if Old_Last_As_Int > Int'Last - N then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      if Old_Length > Count_Type'Last - Count then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n \n-         New_Last_As_Int := Old_Last_As_Int + N;\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n \n-         if New_Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n+      New_Length := Old_Length + Count;\n+\n+      --  The second constraint is that the new Last index value cannot exceed\n+      --  Index_Type'Last. In each branch below, we calculate the maximum\n+      --  length (computed from the range of values in Index_Type), and then\n+      --  compare the new length to the maximum length. If the new length is\n+      --  acceptable, then we compute the new last index from that.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We have to handle the case when there might be more values in the\n+         --  range of Index_Type than in the range of Count_Type.\n+\n+         if Index_Type'First <= 0 then\n+            --  We know that No_Index (the same as Index_Type'First - 1) is\n+            --  less than 0, so it is safe to compute the following sum without\n+            --  fear of overflow.\n+\n+            Index := No_Index + Index_Type'Base (Count_Type'Last);\n+\n+            if Index <= Index_Type'Last then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+\n+         else\n+            --  No_Index is equal or greater than 0, so we can safely compute\n+            --  the difference without fear of overflow (which we would have to\n+            --  worry about if No_Index were less than 0, but that case is\n+            --  handled above).\n+\n+            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n          end if;\n \n-         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n+      elsif Index_Type'First <= 0 then\n+         --  We know that No_Index (the same as Index_Type'First - 1) is less\n+         --  than 0, so it is safe to compute the following sum without fear of\n+         --  overflow.\n \n-         if New_Length > Max_Length then\n-            raise Constraint_Error with \"new length is out of range\";\n+         J := Count_Type'Base (No_Index) + Count_Type'Last;\n+\n+         if J <= Count_Type'Base (Index_Type'Last) then\n+            --  We have determined that range of Index_Type has at least as\n+            --  many values as in Count_Type, so Count_Type'Last is the maximum\n+            --  number of items that are allowed.\n+\n+            Max_Length := Count_Type'Last;\n+\n+         else\n+            --  The range of Index_Type has fewer values than Count_Type does,\n+            --  so the maximum number of items is computed from the range of\n+            --  the Index_Type.\n+\n+            Max_Length :=\n+              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n          end if;\n \n-         New_Last := Index_Type (New_Last_As_Int);\n-      end;\n+      else\n+         --  No_Index is equal or greater than 0, so we can safely compute the\n+         --  difference without fear of overflow (which we would have to worry\n+         --  about if No_Index were less than 0, but that case is handled\n+         --  above).\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n+         Max_Length :=\n+           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+      end if;\n+\n+      --  We have just computed the maximum length (number of items). We must\n+      --  now compare the requested length to the maximum length, as we do not\n+      --  allow a vector expand beyond the maximum (because that would create\n+      --  an internal array with a last index value greater than\n+      --  Index_Type'Last, with no way to index those elements).\n+\n+      if New_Length > Max_Length then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  New_Last is the last index value of the items in the container after\n+      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n+      --  compute its value from the New_Length.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         New_Last := No_Index + Index_Type'Base (New_Length);\n+\n+      else\n+         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n       end if;\n \n       if Container.Elements = null then\n+         pragma Assert (Container.Last = No_Index);\n+\n+         --  This is the simplest case, with which we must always begin: we're\n+         --  inserting items into an empty vector that hasn't allocated an\n+         --  internal array yet. Note that we don't need to check the busy bit\n+         --  here, because an empty container cannot be busy.\n+\n+         --  In order to preserve container invariants, we allocate the new\n+         --  internal array first, before setting the Last index value, in case\n+         --  the allocation fails (which can happen either because there is no\n+         --  storage available, or because element initialization fails).\n+\n          Container.Elements := new Elements_Type'\n                                      (Last => New_Last,\n                                       EA   => (others => New_Item));\n+\n+         --  The allocation of the new, internal array succeeded, so it is now\n+         --  safe to update the Last index, restoring container invariants.\n+\n          Container.Last := New_Last;\n+\n          return;\n       end if;\n \n-      if New_Last <= Container.Elements.Last then\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      --  An internal array has already been allocated, so we must determine\n+      --  whether there is enough unused storage for the new items.\n+\n+      if New_Length <= Container.Elements.EA'Length then\n+         --  In this case, we're inserting elements into a vector that has\n+         --  already allocated an internal array, and the existing array has\n+         --  enough unused storage for the new items.\n+\n          declare\n             EA : Elements_Array renames Container.Elements.EA;\n \n          begin\n-            if Before <= Container.Last then\n-               declare\n-                  Index_As_Int : constant Int'Base :=\n-                                   Index_Type'Pos (Before) + N;\n+            if Before > Container.Last then\n+               --  The new items are being appended to the vector, so no\n+               --  sliding of existing elements is required.\n \n-                  Index : constant Index_Type := Index_Type (Index_As_Int);\n+               EA (Before .. New_Last) := (others => New_Item);\n \n-               begin\n-                  EA (Index .. New_Last) := EA (Before .. Container.Last);\n+            else\n+               --  The new items are being inserted before some existing\n+               --  elements, so we must slide the existing elements up to their\n+               --  new home. We use the wider of Index_Type'Base and\n+               --  Count_Type'Base as the type for intermediate index values.\n \n-                  EA (Before .. Index_Type'Pred (Index)) :=\n-                      (others => New_Item);\n-               end;\n+               if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+                  Index := Before + Index_Type'Base (Count);\n \n-            else\n-               EA (Before .. New_Last) := (others => New_Item);\n+               else\n+                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n+               end if;\n+\n+               EA (Index .. New_Last) := EA (Before .. Container.Last);\n+               EA (Before .. Index - 1) := (others => New_Item);\n             end if;\n          end;\n \n          Container.Last := New_Last;\n          return;\n       end if;\n \n-      declare\n-         C, CC : UInt;\n+      --  In this case, we're inserting elements into a vector that has already\n+      --  allocated an internal array, but the existing array does not have\n+      --  enough storage, so we must allocate a new, longer array. In order to\n+      --  guarantee that the amortized insertion cost is O(1), we always\n+      --  allocate an array whose length is some power-of-two factor of the\n+      --  current array length. (The new array cannot have a length less than\n+      --  the New_Length of the container, but its last index value cannot be\n+      --  greater than Index_Type'Last.)\n+\n+      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);\n+      while New_Capacity < New_Length loop\n+         if New_Capacity > Count_Type'Last / 2 then\n+            New_Capacity := Count_Type'Last;\n+            exit;\n+         end if;\n \n-      begin\n-         C := UInt'Max (1, Container.Elements.EA'Length);  -- ???\n-         while C < New_Length loop\n-            if C > UInt'Last / 2 then\n-               C := UInt'Last;\n-               exit;\n-            end if;\n+         New_Capacity := 2 * New_Capacity;\n+      end loop;\n \n-            C := 2 * C;\n-         end loop;\n+      if New_Capacity > Max_Length then\n+         --  We have reached the limit of capacity, so no further expansion\n+         --  will occur. (This is not a problem, as there is never a need to\n+         --  have more capacity than the maximum container length.)\n \n-         if C > Max_Length then\n-            C := Max_Length;\n-         end if;\n+         New_Capacity := Max_Length;\n+      end if;\n \n-         if Index_Type'First <= 0\n-           and then Index_Type'Last >= 0\n-         then\n-            CC := UInt (Index_Type'Last) + UInt (-Index_Type'First) + 1;\n-         else\n-            CC := UInt (Int (Index_Type'Last) - First + 1);\n-         end if;\n+      --  We have computed the length of the new internal array (and this is\n+      --  what \"vector capacity\" means), so use that to compute its last index.\n \n-         if C > CC then\n-            C := CC;\n-         end if;\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n \n-         declare\n-            Dst_Last : constant Index_Type :=\n-                         Index_Type (First + UInt'Pos (C) - 1);\n+      else\n+         Dst_Last :=\n+           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);\n+      end if;\n \n-         begin\n-            Dst := new Elements_Type (Dst_Last);\n-         end;\n-      end;\n+      --  Now we allocate the new, longer internal array. If the allocation\n+      --  fails, we have not changed any container state, so no side-effect\n+      --  will occur as a result of propagating the exception.\n+\n+      Dst := new Elements_Type (Dst_Last);\n+\n+      --  We have our new internal array. All that needs to be done now is to\n+      --  copy the existing items (if any) from the old array (the \"source\"\n+      --  array, object SA below) to the new array (the \"destination\" array,\n+      --  object DA below), and then deallocate the old array.\n \n       declare\n-         SA : Elements_Array renames Container.Elements.EA;\n-         DA : Elements_Array renames Dst.EA;\n+         SA : Elements_Array renames Container.Elements.EA; -- source\n+         DA : Elements_Array renames Dst.EA;                -- destination\n \n       begin\n-         DA (Index_Type'First .. Index_Type'Pred (Before)) :=\n-           SA (Index_Type'First .. Index_Type'Pred (Before));\n+         DA (Index_Type'First .. Before - 1) :=\n+           SA (Index_Type'First .. Before - 1);\n \n-         if Before <= Container.Last then\n-            declare\n-               Index_As_Int : constant Int'Base :=\n-                                Index_Type'Pos (Before) + N;\n+         if Before > Container.Last then\n+            DA (Before .. New_Last) := (others => New_Item);\n \n-               Index : constant Index_Type := Index_Type (Index_As_Int);\n+         else\n+            --  The new items are being inserted before some existing elements,\n+            --  so we must slide the existing elements up to their new home.\n \n-            begin\n-               DA (Before .. Index_Type'Pred (Index)) := (others => New_Item);\n-               DA (Index .. New_Last) := SA (Before .. Container.Last);\n-            end;\n+            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               Index := Before + Index_Type'Base (Count);\n \n-         else\n-            DA (Before .. New_Last) := (others => New_Item);\n+            else\n+               Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n+            end if;\n+\n+            DA (Before .. Index - 1) := (others => New_Item);\n+            DA (Index .. New_Last) := SA (Before .. Container.Last);\n          end if;\n       exception\n          when others =>\n             Free (Dst);\n             raise;\n       end;\n \n+      --  We have successfully copied the items onto the new array, so the\n+      --  final thing to do is deallocate the old array.\n+\n       declare\n          X : Elements_Access := Container.Elements;\n       begin\n+         --  We first isolate the old internal array, removing it from the\n+         --  container and replacing it with the new internal array, before we\n+         --  deallocate the old array (which can fail if finalization of\n+         --  elements propagates an exception).\n+\n          Container.Elements := Dst;\n          Container.Last := New_Last;\n+\n+         --  The container invariants have been restored, so it is now safe to\n+         --  attempt to deallocate the old array.\n+\n          Free (X);\n       end;\n    end Insert;\n@@ -978,83 +1297,118 @@ package body Ada.Containers.Vectors is\n       New_Item  : Vector)\n    is\n       N : constant Count_Type := Length (New_Item);\n+      J : Index_Type'Base;\n \n    begin\n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n+      --  Use Insert_Space to create the \"hole\" (the destination slice) into\n+      --  which we copy the source items.\n+\n+      Insert_Space (Container, Before, Count => N);\n+\n+      if N = 0 then\n+         --  There's nothing else to do here (vetting of parameters was\n+         --  performed already in Insert_Space), so we simply return.\n+\n+         return;\n       end if;\n \n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n+      --  We calculate the last index value of the destination slice using the\n+      --  wider of Index_Type'Base and count_Type'Base.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         J := (Before - 1) + Index_Type'Base (N);\n+\n+      else\n+         J := Index_Type'Base (Count_Type'Base (Before - 1) + N);\n       end if;\n \n-      if N = 0 then\n+      if Container'Address /= New_Item'Address then\n+         --  This is the simple case.  New_Item denotes an object different\n+         --  from Container, so there's nothing special we need to do to copy\n+         --  the source items to their destination, because all of the source\n+         --  items are contiguous.\n+\n+         Container.Elements.EA (Before .. J) :=\n+           New_Item.Elements.EA (Index_Type'First .. New_Item.Last);\n+\n          return;\n       end if;\n \n-      Insert_Space (Container, Before, Count => N);\n+      --  New_Item denotes the same object as Container, so an insertion has\n+      --  potentially split the source items. The destination is always the\n+      --  range [Before, J], but the source is [Index_Type'First, Before) and\n+      --  (J, Container.Last]. We perform the copy in two steps, using each of\n+      --  the two slices of the source items.\n \n       declare\n-         Dst_Last_As_Int : constant Int'Base :=\n-                             Int'Base (Before) + Int'Base (N) - 1;\n+         L : constant Index_Type'Base := Before - 1;\n \n-         Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n+         subtype Src_Index_Subtype is Index_Type'Base range\n+           Index_Type'First .. L;\n \n-      begin\n-         if Container'Address /= New_Item'Address then\n-            Container.Elements.EA (Before .. Dst_Last) :=\n-              New_Item.Elements.EA (Index_Type'First .. New_Item.Last);\n+         Src : Elements_Array renames\n+           Container.Elements.EA (Src_Index_Subtype);\n \n-            return;\n-         end if;\n-\n-         declare\n-            subtype Src_Index_Subtype is Index_Type'Base range\n-              Index_Type'First .. Before - 1;\n+         K : Index_Type'Base;\n \n-            Src : Elements_Array renames\n-                    Container.Elements.EA (Src_Index_Subtype);\n+      begin\n+         --  We first copy the source items that precede the space we\n+         --  inserted. Index value K is the last index of that portion\n+         --  destination that receives this slice of the source. (If Before\n+         --  equals Index_Type'First, then this first source slice will be\n+         --  empty, which is harmless.)\n \n-            Index_As_Int : constant Int'Base :=\n-                             Int (Before) + Src'Length - 1;\n+         if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+            K := L + Index_Type'Base (Src'Length);\n \n-            Index : constant Index_Type'Base :=\n-                      Index_Type'Base (Index_As_Int);\n+         else\n+            K := Index_Type'Base (Count_Type'Base (L) + Src'Length);\n+         end if;\n \n-            Dst : Elements_Array renames\n-                    Container.Elements.EA (Before .. Index);\n+         Container.Elements.EA (Before .. K) := Src;\n \n-         begin\n-            Dst := Src;\n-         end;\n+         if Src'Length = N then\n+            --  The new items were effectively appended to the container, so we\n+            --  have already copied all of the items that need to be copied.\n+            --  We return early here, even though the source slice below is\n+            --  empty (so the assignment would be harmless), because we want to\n+            --  avoid computing J + 1, which will overflow if J equals\n+            --  Index_Type'Base'Last.\n \n-         if Dst_Last = Container.Last then\n             return;\n          end if;\n+      end;\n \n-         declare\n-            subtype Src_Index_Subtype is Index_Type'Base range\n-              Dst_Last + 1 .. Container.Last;\n+      declare\n+         --  Note that we want to avoid computing J + 1 here, in case J equals\n+         --  Index_Type'Base'Last. We prevent that by returning early above,\n+         --  immediately after copying the first slice of the source, and\n+         --  determining that this second slice of the source is empty.\n \n-            Src : Elements_Array renames\n-                    Container.Elements.EA (Src_Index_Subtype);\n+         F : constant Index_Type'Base := J + 1;\n \n-            Index_As_Int : constant Int'Base :=\n-                             Dst_Last_As_Int - Src'Length + 1;\n+         subtype Src_Index_Subtype is Index_Type'Base range\n+           F .. Container.Last;\n \n-            Index : constant Index_Type :=\n-                      Index_Type (Index_As_Int);\n+         Src : Elements_Array renames\n+           Container.Elements.EA (Src_Index_Subtype);\n \n-            Dst : Elements_Array renames\n-                    Container.Elements.EA (Index .. Dst_Last);\n+         K : Index_Type'Base;\n \n-         begin\n-            Dst := Src;\n-         end;\n+      begin\n+         --  We next copy the source items that follow the space we\n+         --  inserted. Index value K is the first index of that portion of the\n+         --  destination that receives this slice of the source. (For the\n+         --  reasons given above, this slice is guaranteed to be non-empty.)\n+\n+         if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+            K := F - Index_Type'Base (Src'Length);\n+\n+         else\n+            K := Index_Type'Base (Count_Type'Base (F) - Src'Length);\n+         end if;\n+\n+         Container.Elements.EA (K .. J) := Src;\n       end;\n    end Insert;\n \n@@ -1256,157 +1610,328 @@ package body Ada.Containers.Vectors is\n       Before    : Extended_Index;\n       Count     : Count_Type := 1)\n    is\n-      N : constant Int := Count_Type'Pos (Count);\n+      Old_Length : constant Count_Type := Container.Length;\n+\n+      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n+      New_Length : Count_Type'Base;  -- sum of current length and Count\n+      New_Last   : Index_Type'Base;  -- last index of vector after insertion\n \n-      First           : constant Int := Int (Index_Type'First);\n-      New_Last_As_Int : Int'Base;\n-      New_Last        : Index_Type;\n-      New_Length      : UInt;\n-      Max_Length      : constant UInt := UInt (Count_Type'Last);\n+      Index : Index_Type'Base;  -- scratch for intermediate values\n+      J     : Count_Type'Base;  -- scratch\n \n-      Dst : Elements_Access;\n+      New_Capacity : Count_Type'Base;  -- length of new, expanded array\n+      Dst_Last     : Index_Type'Base;  -- last index of new, expanded array\n+      Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying where the new\n+      --  items should be inserted, so we must manually check. (That the user\n+      --  is allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n \n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows for the\n+      --  case of appending items to the back end of the vector. (It is assumed\n+      --  that specifying an index value greater than Last + 1 indicates some\n+      --  deeper flaw in the caller's algorithm, so that case is treated as a\n+      --  proper error.)\n+\n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n \n+      --  We treat inserting 0 items into the container as a no-op, even when\n+      --  the container is busy, so we simply return.\n+\n       if Count = 0 then\n          return;\n       end if;\n \n-      declare\n-         Old_Last_As_Int : constant Int := Int (Container.Last);\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the current length and the insertion\n+      --  count. Note that we cannot simply add these values, because of the\n+      --  possibilty of overflow.\n \n-      begin\n-         if Old_Last_As_Int > Int'Last - N then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      if Old_Length > Count_Type'Last - Count then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n \n-         New_Last_As_Int := Old_Last_As_Int + N;\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n \n-         if New_Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n+      New_Length := Old_Length + Count;\n+\n+      --  The second constraint is that the new Last index value cannot exceed\n+      --  Index_Type'Last. In each branch below, we calculate the maximum\n+      --  length (computed from the range of values in Index_Type), and then\n+      --  compare the new length to the maximum length. If the new length is\n+      --  acceptable, then we compute the new last index from that.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We have to handle the case when there might be more values in the\n+         --  range of Index_Type than in the range of Count_Type.\n+\n+         if Index_Type'First <= 0 then\n+            --  We know that No_Index (the same as Index_Type'First - 1) is\n+            --  less than 0, so it is safe to compute the following sum without\n+            --  fear of overflow.\n+\n+            Index := No_Index + Index_Type'Base (Count_Type'Last);\n+\n+            if Index <= Index_Type'Last then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+\n+         else\n+            --  No_Index is equal or greater than 0, so we can safely compute\n+            --  the difference without fear of overflow (which we would have to\n+            --  worry about if No_Index were less than 0, but that case is\n+            --  handled above).\n+\n+            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n          end if;\n \n-         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n+      elsif Index_Type'First <= 0 then\n+         --  We know that No_Index (the same as Index_Type'First - 1) is less\n+         --  than 0, so it is safe to compute the following sum without fear of\n+         --  overflow.\n \n-         if New_Length > Max_Length then\n-            raise Constraint_Error with \"new length is out of range\";\n+         J := Count_Type'Base (No_Index) + Count_Type'Last;\n+\n+         if J <= Count_Type'Base (Index_Type'Last) then\n+            --  We have determined that range of Index_Type has at least as\n+            --  many values as in Count_Type, so Count_Type'Last is the maximum\n+            --  number of items that are allowed.\n+\n+            Max_Length := Count_Type'Last;\n+\n+         else\n+            --  The range of Index_Type has fewer values than Count_Type does,\n+            --  so the maximum number of items is computed from the range of\n+            --  the Index_Type.\n+\n+            Max_Length :=\n+              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n          end if;\n \n-         New_Last := Index_Type (New_Last_As_Int);\n-      end;\n+      else\n+         --  No_Index is equal or greater than 0, so we can safely compute the\n+         --  difference without fear of overflow (which we would have to worry\n+         --  about if No_Index were less than 0, but that case is handled\n+         --  above).\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n+         Max_Length :=\n+           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+      end if;\n+\n+      --  We have just computed the maximum length (number of items). We must\n+      --  now compare the requested length to the maximum length, as we do not\n+      --  allow a vector expand beyond the maximum (because that would create\n+      --  an internal array with a last index value greater than\n+      --  Index_Type'Last, with no way to index those elements).\n+\n+      if New_Length > Max_Length then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  New_Last is the last index value of the items in the container after\n+      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n+      --  compute its value from the New_Length.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         New_Last := No_Index + Index_Type'Base (New_Length);\n+\n+      else\n+         New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n       end if;\n \n       if Container.Elements = null then\n+         pragma Assert (Container.Last = No_Index);\n+\n+         --  This is the simplest case, with which we must always begin: we're\n+         --  inserting items into an empty vector that hasn't allocated an\n+         --  internal array yet. Note that we don't need to check the busy bit\n+         --  here, because an empty container cannot be busy.\n+\n+         --  In order to preserve container invariants, we allocate the new\n+         --  internal array first, before setting the Last index value, in case\n+         --  the allocation fails (which can happen either because there is no\n+         --  storage available, or because default-valued element\n+         --  initialization fails).\n+\n          Container.Elements := new Elements_Type (New_Last);\n+\n+         --  The allocation of the new, internal array succeeded, so it is now\n+         --  safe to update the Last index, restoring container invariants.\n+\n          Container.Last := New_Last;\n+\n          return;\n       end if;\n \n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n+      end if;\n+\n+      --  An internal array has already been allocated, so we must determine\n+      --  whether there is enough unused storage for the new items.\n+\n       if New_Last <= Container.Elements.Last then\n+         --  In this case, we're inserting space into a vector that has already\n+         --  allocated an internal array, and the existing array has enough\n+         --  unused storage for the new items.\n+\n          declare\n             EA : Elements_Array renames Container.Elements.EA;\n+\n          begin\n             if Before <= Container.Last then\n-               declare\n-                  Index_As_Int : constant Int'Base :=\n-                                   Index_Type'Pos (Before) + N;\n+               --  The space is being inserted before some existing elements,\n+               --  so we must slide the existing elements up to their new\n+               --  home. We use the wider of Index_Type'Base and\n+               --  Count_Type'Base as the type for intermediate index values.\n \n-                  Index : constant Index_Type := Index_Type (Index_As_Int);\n+               if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+                  Index := Before + Index_Type'Base (Count);\n \n-               begin\n-                  EA (Index .. New_Last) := EA (Before .. Container.Last);\n-               end;\n+               else\n+                  Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n+               end if;\n+\n+               EA (Index .. New_Last) := EA (Before .. Container.Last);\n             end if;\n          end;\n \n          Container.Last := New_Last;\n          return;\n       end if;\n \n-      declare\n-         C, CC : UInt;\n+      --  In this case, we're inserting space into a vector that has already\n+      --  allocated an internal array, but the existing array does not have\n+      --  enough storage, so we must allocate a new, longer array. In order to\n+      --  guarantee that the amortized insertion cost is O(1), we always\n+      --  allocate an array whose length is some power-of-two factor of the\n+      --  current array length. (The new array cannot have a length less than\n+      --  the New_Length of the container, but its last index value cannot be\n+      --  greater than Index_Type'Last.)\n+\n+      New_Capacity := Count_Type'Max (1, Container.Elements.EA'Length);\n+      while New_Capacity < New_Length loop\n+         if New_Capacity > Count_Type'Last / 2 then\n+            New_Capacity := Count_Type'Last;\n+            exit;\n+         end if;\n \n-      begin\n-         C := UInt'Max (1, Container.Elements.EA'Length);  -- ???\n-         while C < New_Length loop\n-            if C > UInt'Last / 2 then\n-               C := UInt'Last;\n-               exit;\n-            end if;\n+         New_Capacity := 2 * New_Capacity;\n+      end loop;\n \n-            C := 2 * C;\n-         end loop;\n+      if New_Capacity > Max_Length then\n+         --  We have reached the limit of capacity, so no further expansion\n+         --  will occur. (This is not a problem, as there is never a need to\n+         --  have more capacity than the maximum container length.)\n \n-         if C > Max_Length then\n-            C := Max_Length;\n-         end if;\n+         New_Capacity := Max_Length;\n+      end if;\n \n-         if Index_Type'First <= 0\n-           and then Index_Type'Last >= 0\n-         then\n-            CC := UInt (Index_Type'Last) + UInt (-Index_Type'First) + 1;\n-         else\n-            CC := UInt (Int (Index_Type'Last) - First + 1);\n-         end if;\n+      --  We have computed the length of the new internal array (and this is\n+      --  what \"vector capacity\" means), so use that to compute its last index.\n \n-         if C > CC then\n-            C := CC;\n-         end if;\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n \n-         declare\n-            Dst_Last : constant Index_Type :=\n-                         Index_Type (First + UInt'Pos (C) - 1);\n+      else\n+         Dst_Last :=\n+           Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);\n+      end if;\n \n-         begin\n-            Dst := new Elements_Type (Dst_Last);\n-         end;\n-      end;\n+      --  Now we allocate the new, longer internal array. If the allocation\n+      --  fails, we have not changed any container state, so no side-effect\n+      --  will occur as a result of propagating the exception.\n+\n+      Dst := new Elements_Type (Dst_Last);\n+\n+      --  We have our new internal array. All that needs to be done now is to\n+      --  copy the existing items (if any) from the old array (the \"source\"\n+      --  array, object SA below) to the new array (the \"destination\" array,\n+      --  object DA below), and then deallocate the old array.\n \n       declare\n-         SA : Elements_Array renames Container.Elements.EA;\n-         DA : Elements_Array renames Dst.EA;\n+         SA : Elements_Array renames Container.Elements.EA;  -- source\n+         DA : Elements_Array renames Dst.EA;                 -- destination\n \n       begin\n-         DA (Index_Type'First .. Index_Type'Pred (Before)) :=\n-           SA (Index_Type'First .. Index_Type'Pred (Before));\n+         DA (Index_Type'First .. Before - 1) :=\n+           SA (Index_Type'First .. Before - 1);\n \n          if Before <= Container.Last then\n-            declare\n-               Index_As_Int : constant Int'Base :=\n-                                Index_Type'Pos (Before) + N;\n+            --  The space is being inserted before some existing elements, so\n+            --  we must slide the existing elements up to their new home.\n \n-               Index : constant Index_Type := Index_Type (Index_As_Int);\n+            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               Index := Before + Index_Type'Base (Count);\n \n-            begin\n-               DA (Index .. New_Last) := SA (Before .. Container.Last);\n-            end;\n+            else\n+               Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n+            end if;\n+\n+            DA (Index .. New_Last) := SA (Before .. Container.Last);\n          end if;\n       exception\n          when others =>\n             Free (Dst);\n             raise;\n       end;\n \n+      --  We have successfully copied the items onto the new array, so the\n+      --  final thing to do is restore invariants, and deallocate the old\n+      --  array.\n+\n       declare\n          X : Elements_Access := Container.Elements;\n       begin\n+         --  We first isolate the old internal array, removing it from the\n+         --  container and replacing it with the new internal array, before we\n+         --  deallocate the old array (which can fail if finalization of\n+         --  elements propagates an exception).\n+\n          Container.Elements := Dst;\n          Container.Last := New_Last;\n+\n+         --  The container invariants have been restored, so it is now safe to\n+         --  attempt to deallocate the old array.\n+\n          Free (X);\n       end;\n    end Insert_Space;\n@@ -1533,12 +2058,33 @@ package body Ada.Containers.Vectors is\n    ------------\n \n    function Length (Container : Vector) return Count_Type is\n-      L : constant Int := Int (Container.Last);\n-      F : constant Int := Int (Index_Type'First);\n-      N : constant Int'Base := L - F + 1;\n-\n-   begin\n-      return Count_Type (N);\n+      L : constant Index_Type'Base := Container.Last;\n+      F : constant Index_Type := Index_Type'First;\n+\n+   begin\n+      --  The base range of the index type (Index_Type'Base) might not include\n+      --  all values for length (Count_Type). Contrariwise, the index type\n+      --  might include values outside the range of length.  Hence we use\n+      --  whatever type is wider for intermediate values when calculating\n+      --  length. Note that no matter what the index type is, the maximum\n+      --  length to which a vector is allowed to grow is always the minimum\n+      --  of Count_Type'Last and (IT'Last - IT'First + 1).\n+\n+      --  For example, an Index_Type with range -127 .. 127 is only guaranteed\n+      --  to have a base range of -128 .. 127, but the corresponding vector\n+      --  would have lengths in the range 0 .. 255. In this case we would need\n+      --  to use Count_Type'Base for intermediate values.\n+\n+      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The\n+      --  vector would have a maximum length of 10, but the index values lie\n+      --  outside the range of Count_Type (which is only 32 bits). In this\n+      --  case we would need to use Index_Type'Base for intermediate values.\n+\n+      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n+         return Count_Type'Base (L) - Count_Type'Base (F) + 1;\n+      else\n+         return Count_Type (L - F + 1);\n+      end if;\n    end Length;\n \n    ----------\n@@ -1799,17 +2345,51 @@ package body Ada.Containers.Vectors is\n    is\n       N : constant Count_Type := Length (Container);\n \n+      Index : Count_Type'Base;\n+      Last  : Index_Type'Base;\n+\n    begin\n+      --  Reserve_Capacity can be used to either expand the storage available\n+      --  for elements (this would be its typical use, in anticipation of\n+      --  future insertion), or to trim back storage. In the latter case,\n+      --  storage can only be trimmed back to the limit of the container\n+      --  length. Note that Reserve_Capacity neither deletes (active) elements\n+      --  nor inserts elements; it only affects container capacity, never\n+      --  container length.\n+\n       if Capacity = 0 then\n+         --  This is a request to trim back storage, to the minimum amount\n+         --  possible given the current state of the container.\n+\n          if N = 0 then\n+            --  The container is empty, so in this unique case we can\n+            --  deallocate the entire internal array. Note that an empty\n+            --  container can never be busy, so there's no need to check the\n+            --  tampering bits.\n+\n             declare\n                X : Elements_Access := Container.Elements;\n             begin\n+               --  First we remove the internal array from the container, to\n+               --  handle the case when the deallocation raises an exception.\n+\n                Container.Elements := null;\n+\n+               --  Container invariants have been restored, so it is now safe\n+               --  to attempt to deallocate the internal array.\n+\n                Free (X);\n             end;\n \n          elsif N < Container.Elements.EA'Length then\n+            --  The container is not empty, and the current length is less than\n+            --  the current capacity, so there's storage available to trim. In\n+            --  this case, we allocate a new internal array having a length\n+            --  that exactly matches the number of items in the\n+            --  container. (Reserve_Capacity does not delete active elements,\n+            --  so this is the best we can do with respect to minimizing\n+            --  storage).\n+\n             if Container.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n@@ -1825,37 +2405,126 @@ package body Ada.Containers.Vectors is\n                X : Elements_Access := Container.Elements;\n \n             begin\n+               --  Although we have isolated the old internal array that we're\n+               --  going to deallocate, we don't deallocate it until we have\n+               --  successfully allocated a new one. If there is an exception\n+               --  during allocation (either because there is not enough\n+               --  storage, or because initialization of the elements fails),\n+               --  we let it propagate without causing any side-effect.\n+\n                Container.Elements := new Elements_Type'(Container.Last, Src);\n+\n+               --  We have succesfully allocated a new internal array (with a\n+               --  smaller length than the old one, and containing a copy of\n+               --  just the active elements in the container), so it is now\n+               --  safe to attempt to deallocate the old array. The old array\n+               --  has been isolated, and container invariants have been\n+               --  restored, so if the deallocation fails (because finalization\n+               --  of the elements fails), we simply let it propagate.\n+\n                Free (X);\n             end;\n          end if;\n \n          return;\n       end if;\n \n-      if Container.Elements = null then\n-         declare\n-            Last_As_Int : constant Int'Base :=\n-                            Int (Index_Type'First) + Int (Capacity) - 1;\n+      --  Reserve_Capacity can be used to expand the storage available for\n+      --  elements, but we do not let the capacity grow beyond the number of\n+      --  values in Index_Type'Range. (Were it otherwise, there would be no way\n+      --  to refer to the elements with an index value greater than\n+      --  Index_Type'Last, so that storage would be wasted.) Here we compute\n+      --  the Last index value of the new internal array, in a way that avoids\n+      --  any possibility of overflow.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index then\n+            raise Constraint_Error with \"Capacity is out of range\";\n+         end if;\n \n-         begin\n-            if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-               raise Constraint_Error with \"new length is out of range\";\n-            end if;\n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n \n-            declare\n-               Last : constant Index_Type := Index_Type (Last_As_Int);\n+         Last := No_Index + Index_Type'Base (Capacity);\n \n-            begin\n-               Container.Elements := new Elements_Type (Last);\n-            end;\n-         end;\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n+\n+         if Last > Index_Type'Last then\n+            raise Constraint_Error with \"Capacity is out of range\";\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of Capacity.\n+\n+         Index := Count_Type'Base (No_Index) + Capacity;  -- Last\n+\n+         if Index > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"Capacity is out of range\";\n+         end if;\n+\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n+\n+         Last := Index_Type'Base (Index);\n+\n+      else\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n+\n+         Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index\n+\n+         if Index < Count_Type'Base (No_Index) then\n+            raise Constraint_Error with \"Capacity is out of range\";\n+         end if;\n+\n+         --  We have determined that the value of Capacity would not create a\n+         --  Last index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n+\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + Capacity);\n+      end if;\n+\n+      --  The requested capacity is non-zero, but we don't know yet whether\n+      --  this is a request for expansion or contraction of storage.\n+\n+      if Container.Elements = null then\n+         --  The container is empty (it doesn't even have an internal array),\n+         --  so this represents a request to allocate (expand) storage having\n+         --  the given capacity.\n \n+         Container.Elements := new Elements_Type (Last);\n          return;\n       end if;\n \n       if Capacity <= N then\n+         --  This is a request to trim back storage, but only to the limit of\n+         --  what's already in the container. (Reserve_Capacity never deletes\n+         --  active elements, it only reclaims excess storage.)\n+\n          if N < Container.Elements.EA'Length then\n+            --  The container is not empty (because the requested capacity is\n+            --  positive, and less than or equal to the container length), and\n+            --  the current length is less than the current capacity, so\n+            --  there's storage available to trim. In this case, we allocate a\n+            --  new internal array having a length that exactly matches the\n+            --  number of items in the container.\n+\n             if Container.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n@@ -1871,63 +2540,99 @@ package body Ada.Containers.Vectors is\n                X : Elements_Access := Container.Elements;\n \n             begin\n+               --  Although we have isolated the old internal array that we're\n+               --  going to deallocate, we don't deallocate it until we have\n+               --  successfully allocated a new one. If there is an exception\n+               --  during allocation (either because there is not enough\n+               --  storage, or because initialization of the elements fails),\n+               --  we let it propagate without causing any side-effect.\n+\n                Container.Elements := new Elements_Type'(Container.Last, Src);\n+\n+               --  We have succesfully allocated a new internal array (with a\n+               --  smaller length than the old one, and containing a copy of\n+               --  just the active elements in the container), so it is now\n+               --  safe to attempt to deallocate the old array. The old array\n+               --  has been isolated, and container invariants have been\n+               --  restored, so if the deallocation fails (because finalization\n+               --  of the elements fails), we simply let it propagate.\n+\n                Free (X);\n             end;\n-\n          end if;\n \n          return;\n       end if;\n \n+      --  The requested capacity is larger than the container length (the\n+      --  number of active elements). Whether this represents a request for\n+      --  expansion or contraction of the current capacity depends on what the\n+      --  current capacity is.\n+\n       if Capacity = Container.Elements.EA'Length then\n+         --  The requested capacity matches the existing capacity, so there's\n+         --  nothing to do here. We treat this case as a no-op, and simply\n+         --  return without checking the busy bit.\n+\n          return;\n       end if;\n \n+      --  There is a change in the capacity of a non-empty container, so a new\n+      --  internal array will be allocated. (The length of the new internal\n+      --  array could be less or greater than the old internal array. We know\n+      --  only that the length of the new internal array is greater than the\n+      --  number of active elements in the container.) We must check whether\n+      --  the container is busy before doing anything else.\n+\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n+      --  We now allocate a new internal array, having a length different from\n+      --  its current value.\n+\n       declare\n-         Last_As_Int : constant Int'Base :=\n-                         Int (Index_Type'First) + Int (Capacity) - 1;\n+         E : Elements_Access := new Elements_Type (Last);\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+         --  We have successfully allocated the new internal array. We first\n+         --  attempt to copy the existing elements from the old internal array\n+         --  (\"src\" elements) onto the new internal array (\"tgt\" elements).\n \n          declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+            subtype Index_Subtype is Index_Type'Base range\n+              Index_Type'First .. Container.Last;\n+\n+            Src : Elements_Array renames\n+                    Container.Elements.EA (Index_Subtype);\n \n-            E : Elements_Access := new Elements_Type (Last);\n+            Tgt : Elements_Array renames E.EA (Index_Subtype);\n \n          begin\n-            declare\n-               subtype Index_Subtype is Index_Type'Base range\n-                 Index_Type'First .. Container.Last;\n+            Tgt := Src;\n \n-               Src : Elements_Array renames\n-                       Container.Elements.EA (Index_Subtype);\n+         exception\n+            when others =>\n+               Free (E);\n+               raise;\n+         end;\n \n-               Tgt : Elements_Array renames E.EA (Index_Subtype);\n+         --  We have successfully copied the existing elements onto the new\n+         --  internal array, so now we can attempt to deallocate the old one.\n \n-            begin\n-               Tgt := Src;\n+         declare\n+            X : Elements_Access := Container.Elements;\n+         begin\n+            --  First we isolate the old internal array, and replace it in the\n+            --  container with the new internal array.\n \n-            exception\n-               when others =>\n-                  Free (E);\n-                  raise;\n-            end;\n+            Container.Elements := E;\n \n-            declare\n-               X : Elements_Access := Container.Elements;\n-            begin\n-               Container.Elements := E;\n-               Free (X);\n-            end;\n+            --  Container invariants have been restored, so it is now safe to\n+            --  attempt to deallocate the old internal array.\n+\n+            Free (X);\n          end;\n       end;\n    end Reserve_Capacity;\n@@ -2055,26 +2760,25 @@ package body Ada.Containers.Vectors is\n    ----------------\n \n    procedure Set_Length (Container : in out Vector; Length : Count_Type) is\n+      Count : constant Count_Type'Base := Container.Length - Length;\n+\n    begin\n-      if Length = Vectors.Length (Container) then\n-         return;\n-      end if;\n+      --  Set_Length allows the user to set the length explicitly, instead of\n+      --  implicitly as a side-effect of deletion or insertion. If the\n+      --  requested length is less then the current length, this is equivalent\n+      --  to deleting items from the back end of the vector. If the requested\n+      --  length is greater than the current length, then this is equivalent to\n+      --  inserting \"space\" (nonce items) at the end.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is busy)\";\n-      end if;\n+      if Count >= 0 then\n+         Container.Delete_Last (Count);\n \n-      if Length > Capacity (Container) then\n-         Reserve_Capacity (Container, Capacity => Length);\n-      end if;\n+      elsif Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n \n-      declare\n-         Last_As_Int : constant Int'Base :=\n-                         Int (Index_Type'First) + Int (Length) - 1;\n-      begin\n-         Container.Last := Index_Type'Base (Last_As_Int);\n-      end;\n+      else\n+         Container.Insert_Space (Container.Last + 1, -Count);\n+      end if;\n    end Set_Length;\n \n    ----------\n@@ -2167,8 +2871,8 @@ package body Ada.Containers.Vectors is\n    ---------------\n \n    function To_Vector (Length : Count_Type) return Vector is\n-      Index    : Int'Base;\n-      Last     : Index_Type;\n+      Index    : Count_Type'Base;\n+      Last     : Index_Type'Base;\n       Elements : Elements_Access;\n \n    begin\n@@ -2181,41 +2885,71 @@ package body Ada.Containers.Vectors is\n       --  internal array) to exceed the number of values in Index_Type'Range\n       --  (otherwise, there would be no way to refer to those components via an\n       --  index).  We must therefore check whether the specified Length would\n-      --  create a Last index value greater than Index_Type'Last. This\n-      --  calculation requires care, because overflow can occur when\n-      --  Index_Type'First is near the end of the range of Int.\n-\n-      if Index_Type'First <= 0 then\n-         --  Compute the potential Last index value in the normal way, using\n-         --  Int as the type in which to perform intermediate calculations. Int\n-         --  is a 64-bit type, and Count_Type is a 32-bit type, so no overflow\n-         --  can occur.\n-         Index := Int (Index_Type'First - 1) + Int (Length);\n-\n-         if Index > Int (Index_Type'Last) then\n+      --  create a Last index value greater than Index_Type'Last.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n+\n+         Last := No_Index + Index_Type'Base (Length);\n+\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n+\n+         if Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of Length.\n+\n+         Index := Count_Type'Base (No_Index) + Length;  -- Last\n+\n+         if Index > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n+\n+         Last := Index_Type'Base (Index);\n+\n       else\n-         --  If Index_Type'First is within Length of Int'Last, then overflow\n-         --  would occur if we simply computed Last directly. So instead of\n-         --  computing Last, and then determining whether its value is greater\n-         --  than Index_Type'Last, we work backwards by computing the potential\n-         --  First index value, and then checking whether that value is less\n-         --  than Index_Type'First.\n-         Index := Int (Index_Type'Last) - Int (Length) + 1;\n-\n-         if Index < Int (Index_Type'First) then\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n+\n+         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n+\n+         if Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n-         --  We have determined that Length would not create a Last index value\n-         --  outside of the range of Index_Type, so we can now safely compute\n-         --  its value.\n-         Index := Int (Index_Type'First - 1) + Int (Length);\n+         --  We have determined that the value of Length would not create a\n+         --  Last index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n+\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);\n       end if;\n \n-      Last := Index_Type (Index);\n       Elements := new Elements_Type (Last);\n \n       return Vector'(Controlled with Elements, Last, 0, 0);\n@@ -2225,8 +2959,8 @@ package body Ada.Containers.Vectors is\n      (New_Item : Element_Type;\n       Length   : Count_Type) return Vector\n    is\n-      Index    : Int'Base;\n-      Last     : Index_Type;\n+      Index    : Count_Type'Base;\n+      Last     : Index_Type'Base;\n       Elements : Elements_Access;\n \n    begin\n@@ -2239,41 +2973,71 @@ package body Ada.Containers.Vectors is\n       --  internal array) to exceed the number of values in Index_Type'Range\n       --  (otherwise, there would be no way to refer to those components via an\n       --  index). We must therefore check whether the specified Length would\n-      --  create a Last index value greater than Index_Type'Last. This\n-      --  calculation requires care, because overflow can occur when\n-      --  Index_Type'First is near the end of the range of Int.\n-\n-      if Index_Type'First <= 0 then\n-         --  Compute the potential Last index value in the normal way, using\n-         --  Int as the type in which to perform intermediate calculations. Int\n-         --  is a 64-bit type, and Count_Type is a 32-bit type, so no overflow\n-         --  can occur.\n-         Index := Int (Index_Type'First - 1) + Int (Length);\n-\n-         if Index > Int (Index_Type'Last) then\n+      --  create a Last index value greater than Index_Type'Last.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n+\n+         Last := No_Index + Index_Type'Base (Length);\n+\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n+\n+         if Last > Index_Type'Last then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of Length.\n+\n+         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last\n+\n+         if Index > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n+\n+         Last := Index_Type'Base (Index);\n+\n       else\n-         --  If Index_Type'First is within Length of Int'Last, then overflow\n-         --  would occur if we simply computed Last directly. So instead of\n-         --  computing Last, and then determining whether its value is greater\n-         --  than Index_Type'Last, we work backwards by computing the potential\n-         --  First index value, and then checking whether that value is less\n-         --  than Index_Type'First.\n-         Index := Int (Index_Type'Last) - Int (Length) + 1;\n-\n-         if Index < Int (Index_Type'First) then\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n+\n+         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n+\n+         if Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n-         --  We have determined that Length would not create a Last index value\n-         --  outside of the range of Index_Type, so we can now safely compute\n-         --  its value.\n-         Index := Int (Index_Type'First - 1) + Int (Length);\n+         --  We have determined that the value of Length would not create a\n+         --  Last index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n+\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);\n       end if;\n \n-      Last := Index_Type (Index);\n       Elements := new Elements_Type'(Last, EA => (others => New_Item));\n \n       return Vector'(Controlled with Elements, Last, 0, 0);"}, {"sha": "11b3a9f910234f0e32bc13c1473521c7297df827", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 207, "deletions": 242, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=5bec9717c3c211d060c7f83dab629157755469f8", "patch": "@@ -1574,7 +1574,8 @@ ada/einfo.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads \\\n    ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n    ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n+   ada/uintp.adb ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \\\n+   ada/urealp.adb \n \n ada/elists.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/elists.ads \\\n@@ -1735,29 +1736,20 @@ ada/exp_attr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/exp_cg.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n-   ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/elists.ads ada/elists.adb ada/err_vars.ads \\\n-   ada/errout.ads ada/erroutc.ads ada/exp_cg.ads ada/exp_cg.adb \\\n-   ada/exp_ch11.ads ada/exp_dbug.ads ada/exp_disp.ads ada/exp_tss.ads \\\n-   ada/exp_util.ads ada/fname.ads ada/freeze.ads ada/get_targ.ads \\\n-   ada/gnat.ads ada/g-htable.ads ada/hostparm.ads ada/interfac.ads \\\n-   ada/lib.ads ada/lib-xref.ads ada/namet.ads ada/namet.adb ada/nlists.ads \\\n-   ada/nlists.adb ada/nmake.ads ada/opt.ads ada/output.ads ada/rident.ads \\\n-   ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_eval.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n-   ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/casing.ads ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n+   ada/elists.adb ada/exp_cg.ads ada/exp_cg.adb ada/exp_dbug.ads \\\n+   ada/exp_disp.ads ada/exp_tss.ads ada/gnat.ads ada/g-htable.ads \\\n+   ada/hostparm.ads ada/lib.ads ada/namet.ads ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/opt.ads ada/output.ads ada/sem_aux.ads \\\n+   ada/sem_aux.adb ada/sem_disp.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n+   ada/types.ads ada/uintp.ads ada/uintp.adb ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads \n \n ada/exp_ch11.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -1833,36 +1825,33 @@ ada/exp_ch2.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/exp_ch3.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n-   ada/casing.ads ada/checks.ads ada/checks.adb ada/csets.ads \\\n-   ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads ada/elists.adb \\\n+   ada/casing.ads ada/checks.ads ada/checks.adb ada/debug.ads \\\n+   ada/einfo.ads ada/einfo.adb ada/elists.ads ada/elists.adb \\\n    ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/eval_fat.ads \\\n    ada/exp_aggr.ads ada/exp_atag.ads ada/exp_ch11.ads ada/exp_ch2.ads \\\n    ada/exp_ch3.ads ada/exp_ch3.adb ada/exp_ch4.ads ada/exp_ch6.ads \\\n    ada/exp_ch7.ads ada/exp_ch9.ads ada/exp_disp.ads ada/exp_dist.ads \\\n    ada/exp_pakd.ads ada/exp_smem.ads ada/exp_strm.ads ada/exp_tss.ads \\\n    ada/exp_tss.adb ada/exp_util.ads ada/exp_util.adb ada/fname.ads \\\n    ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads ada/gnat.ads \\\n-   ada/g-htable.ads ada/hostparm.ads ada/inline.ads ada/interfac.ads \\\n-   ada/itypes.ads ada/lib.ads ada/lib-xref.ads ada/namet.ads ada/namet.adb \\\n-   ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n-   ada/output.ads ada/restrict.ads ada/restrict.adb ada/rident.ads \\\n-   ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads \\\n+   ada/g-htable.ads ada/hostparm.ads ada/inline.ads ada/itypes.ads \\\n+   ada/lib.ads ada/namet.ads ada/nlists.ads ada/nlists.adb ada/nmake.ads \\\n+   ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n+   ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/sem.ads \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_cat.ads \\\n    ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n    ada/sem_eval.ads ada/sem_mech.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads \\\n-   ada/sprint.ads ada/stand.ads ada/stringt.ads ada/style.ads \\\n-   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/sem_type.ads ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n+   ada/stand.ads ada/stringt.ads ada/system.ads ada/s-exctab.ads \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n    ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n    ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n    ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/validsw.ads ada/widechar.ads \n+   ada/urealp.ads ada/validsw.ads \n \n ada/exp_ch4.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -1949,21 +1938,21 @@ ada/exp_ch6.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n    ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb \\\n    ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads \\\n-   ada/sem_attr.ads ada/sem_aux.ads ada/sem_ch12.ads ada/sem_ch13.ads \\\n-   ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_dist.ads ada/sem_eval.ads ada/sem_mech.ads \\\n-   ada/sem_res.ads ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads \\\n-   ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n-   ada/sinput.ads ada/snames.ads ada/sprint.ads ada/stand.ads \\\n-   ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_ch12.ads \\\n+   ada/sem_ch13.ads ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads ada/sem_eval.ads \\\n+   ada/sem_mech.ads ada/sem_res.ads ada/sem_scil.ads ada/sem_type.ads \\\n+   ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n+   ada/stand.ads ada/stringt.ads ada/style.ads ada/styleg.ads \\\n+   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-crc32.ads \\\n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \\\n    ada/widechar.ads \n \n@@ -2030,21 +2019,21 @@ ada/exp_ch9.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n    ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n    ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads ada/sem_attr.ads \\\n-   ada/sem_aux.ads ada/sem_ch11.ads ada/sem_ch6.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_elab.ads ada/sem_eval.ads ada/sem_res.ads \\\n-   ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n-   ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \\\n-   ada/widechar.ads \n+   ada/sem_aux.ads ada/sem_aux.adb ada/sem_ch11.ads ada/sem_ch6.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_elab.ads ada/sem_eval.ads \\\n+   ada/sem_res.ads ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n+   ada/snames.ads ada/stand.ads ada/stringt.ads ada/style.ads \\\n+   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n+   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/validsw.ads ada/widechar.ads \n \n ada/exp_code.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2108,10 +2097,10 @@ ada/exp_disp.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n    ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n    ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads ada/sem_attr.ads \\\n-   ada/sem_aux.ads ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_eval.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/sem_aux.ads ada/sem_aux.adb ada/sem_ch6.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_eval.ads ada/sem_res.ads \\\n+   ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n    ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n    ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-carun8.ads \\\n    ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n@@ -2126,33 +2115,26 @@ ada/exp_disp.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/exp_dist.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n-   ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/elists.ads ada/elists.adb ada/err_vars.ads \\\n-   ada/errout.ads ada/erroutc.ads ada/exp_atag.ads ada/exp_ch11.ads \\\n-   ada/exp_disp.ads ada/exp_dist.ads ada/exp_dist.adb ada/exp_strm.ads \\\n-   ada/exp_tss.ads ada/exp_util.ads ada/fname.ads ada/freeze.ads \\\n-   ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads \\\n-   ada/hostparm.ads ada/interfac.ads ada/lib.ads ada/lib.adb \\\n-   ada/lib-list.adb ada/lib-sort.adb ada/lib-xref.ads ada/namet.ads \\\n-   ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n-   ada/opt.ads ada/output.ads ada/restrict.ads ada/rident.ads \\\n-   ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads \\\n-   ada/sem_ch3.ads ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads \\\n-   ada/sem_eval.ads ada/sem_res.ads ada/sem_scil.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_util.adb ada/sinfo.ads ada/sinfo.adb \\\n-   ada/sinput.ads ada/snames.ads ada/stand.ads ada/stringt.ads \\\n-   ada/stringt.adb ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n+   ada/casing.ads ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n+   ada/elists.adb ada/exp_atag.ads ada/exp_disp.ads ada/exp_dist.ads \\\n+   ada/exp_dist.adb ada/exp_strm.ads ada/exp_tss.ads ada/exp_util.ads \\\n+   ada/fname.ads ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads \\\n+   ada/g-htable.ads ada/hostparm.ads ada/lib.ads ada/lib.adb \\\n+   ada/lib-list.adb ada/lib-sort.adb ada/namet.ads ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/sem.ads \\\n+   ada/sem_aux.ads ada/sem_aux.adb ada/sem_cat.ads ada/sem_ch3.ads \\\n+   ada/sem_ch8.ads ada/sem_dist.ads ada/sem_eval.ads ada/sem_util.ads \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/stringt.ads ada/stringt.adb ada/system.ads ada/s-exctab.ads \\\n    ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads ada/s-memory.ads \\\n    ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n    ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n    ada/s-stoele.adb ada/s-strhas.ads ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/widechar.ads \n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/exp_fixd.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2203,7 +2185,7 @@ ada/exp_imgv.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n    ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n    ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \n \n ada/exp_intr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2767,31 +2749,23 @@ ada/lib-writ.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/lib-xref.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n-   ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/elists.ads ada/elists.adb ada/err_vars.ads \\\n-   ada/errout.ads ada/erroutc.ads ada/exp_ch11.ads ada/exp_disp.ads \\\n-   ada/exp_tss.ads ada/exp_util.ads ada/fname.ads ada/freeze.ads \\\n-   ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads ada/g-hesorg.adb \\\n-   ada/g-htable.ads ada/hostparm.ads ada/interfac.ads ada/lib.ads \\\n-   ada/lib-util.ads ada/lib-util.adb ada/lib-xref.ads ada/lib-xref.adb \\\n-   ada/namet.ads ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads \\\n-   ada/opt.ads ada/osint.ads ada/osint-c.ads ada/output.ads \\\n-   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n-   ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads ada/sem_attr.ads \\\n-   ada/sem_aux.ads ada/sem_ch8.ads ada/sem_disp.ads ada/sem_eval.ads \\\n-   ada/sem_prag.ads ada/sem_res.ads ada/sem_scil.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinput.ads ada/sinput.adb ada/snames.ads \\\n-   ada/stand.ads ada/stringt.ads ada/style.ads ada/styleg.ads \\\n-   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-crc32.ads \\\n-   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/targparm.ads ada/tbuild.ads ada/tree_io.ads ada/ttypes.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/casing.ads ada/csets.ads ada/debug.ads ada/einfo.ads ada/einfo.adb \\\n+   ada/elists.ads ada/elists.adb ada/err_vars.ads ada/errout.ads \\\n+   ada/erroutc.ads ada/gnat.ads ada/g-hesorg.ads ada/g-hesorg.adb \\\n+   ada/g-htable.ads ada/hostparm.ads ada/lib.ads ada/lib-util.ads \\\n+   ada/lib-util.adb ada/lib-xref.ads ada/lib-xref.adb ada/namet.ads \\\n+   ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/opt.ads ada/osint.ads \\\n+   ada/osint-c.ads ada/output.ads ada/restrict.ads ada/rident.ads \\\n+   ada/sem.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_prag.ads \\\n+   ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n+   ada/sinput.ads ada/sinput.adb ada/snames.ads ada/stand.ads \\\n+   ada/stringt.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \\\n+   ada/widechar.ads \n \n ada/lib.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads ada/a-uncdea.ads \\\n    ada/alloc.ads ada/atree.ads ada/atree.adb ada/casing.ads ada/debug.ads \\\n@@ -3328,26 +3302,26 @@ ada/sem_attr.o : ada/ada.ads ada/a-charac.ads ada/a-chlat1.ads \\\n    ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n    ada/rident.ads ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads \\\n    ada/scng.adb ada/sdefault.ads ada/sem.ads ada/sem_aggr.ads \\\n-   ada/sem_attr.ads ada/sem_attr.adb ada/sem_aux.ads ada/sem_cat.ads \\\n-   ada/sem_ch10.ads ada/sem_ch13.ads ada/sem_ch3.ads ada/sem_ch4.ads \\\n-   ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads \\\n-   ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads ada/sem_eval.adb \\\n-   ada/sem_intr.ads ada/sem_res.ads ada/sem_res.adb ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/sinput.adb \\\n-   ada/snames.ads ada/snames.adb ada/sprint.ads ada/stand.ads \\\n-   ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n-   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-carun8.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypef.ads ada/ttypes.ads \\\n-   ada/types.ads ada/types.adb ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n-   ada/validsw.ads ada/widechar.ads \n+   ada/sem_attr.ads ada/sem_attr.adb ada/sem_aux.ads ada/sem_aux.adb \\\n+   ada/sem_cat.ads ada/sem_ch10.ads ada/sem_ch13.ads ada/sem_ch3.ads \\\n+   ada/sem_ch4.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n+   ada/sem_dist.ads ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads \\\n+   ada/sem_eval.adb ada/sem_intr.ads ada/sem_res.ads ada/sem_res.adb \\\n+   ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n+   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n+   ada/sinput.adb ada/snames.ads ada/snames.adb ada/sprint.ads \\\n+   ada/stand.ads ada/stringt.ads ada/stringt.adb ada/style.ads \\\n+   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-carun8.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-exctab.adb \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypef.ads \\\n+   ada/ttypes.ads ada/types.ads ada/types.adb ada/uintp.ads ada/uintp.adb \\\n+   ada/uname.ads ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \\\n+   ada/urealp.adb ada/validsw.ads ada/widechar.ads \n \n ada/sem_aux.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -3546,23 +3520,23 @@ ada/sem_ch3.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n    ada/output.ads ada/restrict.ads ada/rident.ads ada/rtsfind.ads \\\n    ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads \\\n-   ada/sem_attr.ads ada/sem_aux.ads ada/sem_case.ads ada/sem_case.adb \\\n-   ada/sem_cat.ads ada/sem_cat.adb ada/sem_ch13.ads ada/sem_ch3.ads \\\n-   ada/sem_ch3.adb ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_dist.ads ada/sem_elim.ads ada/sem_eval.ads \\\n-   ada/sem_eval.adb ada/sem_mech.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_smem.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n-   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n-   ada/snames.ads ada/sprint.ads ada/stand.ads ada/stringt.ads \\\n-   ada/stringt.adb ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_case.ads \\\n+   ada/sem_case.adb ada/sem_cat.ads ada/sem_cat.adb ada/sem_ch13.ads \\\n+   ada/sem_ch3.ads ada/sem_ch3.adb ada/sem_ch6.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads ada/sem_elim.ads \\\n+   ada/sem_eval.ads ada/sem_eval.adb ada/sem_mech.ads ada/sem_res.ads \\\n+   ada/sem_scil.ads ada/sem_smem.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n+   ada/sinput.ads ada/snames.ads ada/sprint.ads ada/stand.ads \\\n+   ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n+   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-crc32.ads \\\n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n    ada/validsw.ads ada/widechar.ads \n \n@@ -3647,25 +3621,25 @@ ada/sem_ch6.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n    ada/output.ads ada/restrict.ads ada/restrict.adb ada/rident.ads \\\n    ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads \\\n-   ada/sem_ch10.ads ada/sem_ch12.ads ada/sem_ch3.ads ada/sem_ch4.ads \\\n-   ada/sem_ch5.ads ada/sem_ch6.ads ada/sem_ch6.adb ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_dist.ads ada/sem_elim.ads ada/sem_eval.ads \\\n-   ada/sem_mech.ads ada/sem_prag.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinfo-cn.ads ada/sinput.ads \\\n-   ada/sinput.adb ada/snames.ads ada/snames.adb ada/stand.ads \\\n-   ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n-   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-carun8.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/validsw.ads ada/widechar.ads \n+   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb \\\n+   ada/sem_cat.ads ada/sem_ch10.ads ada/sem_ch12.ads ada/sem_ch3.ads \\\n+   ada/sem_ch4.ads ada/sem_ch5.ads ada/sem_ch6.ads ada/sem_ch6.adb \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads ada/sem_elim.ads \\\n+   ada/sem_eval.ads ada/sem_mech.ads ada/sem_prag.ads ada/sem_res.ads \\\n+   ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n+   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinfo-cn.ads \\\n+   ada/sinput.ads ada/sinput.adb ada/snames.ads ada/snames.adb \\\n+   ada/stand.ads ada/stringt.ads ada/stringt.adb ada/style.ads \\\n+   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-carun8.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/validsw.ads ada/widechar.ads \n \n ada/sem_ch7.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -3778,11 +3752,11 @@ ada/sem_disp.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n    ada/output.ads ada/restrict.ads ada/restrict.adb ada/rident.ads \\\n    ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_ch3.ads \\\n-   ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n-   ada/sem_disp.adb ada/sem_eval.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb \\\n+   ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n+   ada/sem_disp.ads ada/sem_disp.adb ada/sem_eval.ads ada/sem_res.ads \\\n+   ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n    ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n    ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n    ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n@@ -3843,29 +3817,19 @@ ada/sem_elab.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/sem_elim.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n-   ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/elists.ads ada/err_vars.ads ada/errout.ads \\\n-   ada/erroutc.ads ada/exp_ch11.ads ada/exp_disp.ads ada/exp_tss.ads \\\n-   ada/exp_util.ads ada/fname.ads ada/freeze.ads ada/get_targ.ads \\\n+   ada/casing.ads ada/debug.ads ada/einfo.ads ada/einfo.adb \\\n+   ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/fname.ads \\\n    ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads ada/hostparm.ads \\\n-   ada/interfac.ads ada/lib.ads ada/lib.adb ada/lib-list.adb \\\n-   ada/lib-sort.adb ada/lib-xref.ads ada/namet.ads ada/namet.adb \\\n+   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-sort.adb ada/namet.ads \\\n    ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/opt.ads ada/output.ads \\\n-   ada/rident.ads ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads \\\n-   ada/scng.adb ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads \\\n-   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_elim.ads ada/sem_elim.adb \\\n-   ada/sem_eval.ads ada/sem_prag.ads ada/sem_res.ads ada/sem_scil.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sinfo.ads \\\n+   ada/sem.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_elim.ads \\\n+   ada/sem_elim.adb ada/sem_prag.ads ada/sem_util.ads ada/sinfo.ads \\\n    ada/sinfo.adb ada/sinput.ads ada/sinput.adb ada/snames.ads \\\n-   ada/stand.ads ada/stringt.ads ada/style.ads ada/styleg.ads \\\n-   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-crc32.ads \\\n-   ada/s-exctab.ads ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-strhas.ads ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/stand.ads ada/stringt.ads ada/system.ads ada/s-exctab.ads \\\n+   ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads ada/s-strhas.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n    ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n    ada/urealp.ads ada/widechar.ads \n \n@@ -3882,23 +3846,24 @@ ada/sem_eval.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n    ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n    ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads ada/sem_aggr.ads \\\n-   ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch13.ads \\\n-   ada/sem_ch4.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n-   ada/sem_dist.ads ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads \\\n-   ada/sem_eval.adb ada/sem_intr.ads ada/sem_res.ads ada/sem_res.adb \\\n-   ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n-   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n-   ada/snames.ads ada/stand.ads ada/stringt.ads ada/stringt.adb \\\n-   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n-   ada/system.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/urealp.adb ada/widechar.ads \n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_cat.ads \\\n+   ada/sem_ch13.ads ada/sem_ch4.ads ada/sem_ch6.ads ada/sem_ch8.ads \\\n+   ada/sem_disp.ads ada/sem_dist.ads ada/sem_elab.ads ada/sem_elim.ads \\\n+   ada/sem_eval.ads ada/sem_eval.adb ada/sem_intr.ads ada/sem_res.ads \\\n+   ada/sem_res.adb ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n+   ada/sinput.ads ada/snames.ads ada/stand.ads ada/stringt.ads \\\n+   ada/stringt.adb ada/style.ads ada/styleg.ads ada/styleg.adb \\\n+   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n+   ada/widechar.ads \n \n ada/sem_intr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -3949,25 +3914,25 @@ ada/sem_prag.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nmake.adb ada/opt.ads ada/output.ads ada/par_sco.ads \\\n    ada/restrict.ads ada/restrict.adb ada/rident.ads ada/rtsfind.ads \\\n    ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads \\\n-   ada/sem_aggr.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads \\\n-   ada/sem_ch12.ads ada/sem_ch13.ads ada/sem_ch3.ads ada/sem_ch4.ads \\\n-   ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads \\\n-   ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads ada/sem_eval.adb \\\n-   ada/sem_intr.ads ada/sem_mech.ads ada/sem_prag.ads ada/sem_prag.adb \\\n-   ada/sem_res.ads ada/sem_res.adb ada/sem_scil.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_util.adb ada/sem_vfpt.ads ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinfo-cn.ads ada/sinput.ads \\\n-   ada/sinput.adb ada/snames.ads ada/snames.adb ada/stand.ads \\\n-   ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n-   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-carun8.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/types.adb ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/sem_aggr.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb \\\n+   ada/sem_cat.ads ada/sem_ch12.ads ada/sem_ch13.ads ada/sem_ch3.ads \\\n+   ada/sem_ch4.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n+   ada/sem_dist.ads ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads \\\n+   ada/sem_eval.adb ada/sem_intr.ads ada/sem_mech.ads ada/sem_prag.ads \\\n+   ada/sem_prag.adb ada/sem_res.ads ada/sem_res.adb ada/sem_scil.ads \\\n+   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_vfpt.ads \\\n+   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinfo-cn.ads \\\n+   ada/sinput.ads ada/sinput.adb ada/snames.ads ada/snames.adb \\\n+   ada/stand.ads ada/stringt.ads ada/stringt.adb ada/style.ads \\\n+   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-carun8.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-exctab.adb \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/types.adb ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n    ada/validsw.ads ada/widechar.ads \n "}, {"sha": "31d97c74711798ab4e15bc6b59166803cf3f86f6", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5bec9717c3c211d060c7f83dab629157755469f8", "patch": "@@ -8869,7 +8869,8 @@ A.5.2(32).\n @end cartouche\n @noindent\n The algorithm is the Mersenne Twister, as documented in the source file\n-@file{s-rannum.adb}.\n+@file{s-rannum.adb}. This version of the algorithm has a period of\n+2**19937-1.\n \n @sp 1\n @cartouche"}, {"sha": "aa6191344df7712269e71b71637d034427f074ea", "filename": "gcc/ada/s-rannum.adb", "status": "modified", "additions": 112, "deletions": 59, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fs-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bec9717c3c211d060c7f83dab629157755469f8/gcc%2Fada%2Fs-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.adb?ref=5bec9717c3c211d060c7f83dab629157755469f8", "patch": "@@ -191,17 +191,21 @@ package body System.Random_Numbers is\n    generic\n       type Unsigned is mod <>;\n       type Real is digits <>;\n-      with function Shift_Right (Value : Unsigned; Amount : Natural)\n-        return Unsigned is <>;\n       with function Random (G : Generator) return Unsigned is <>;\n    function Random_Float_Template (Gen : Generator) return Real;\n    pragma Inline (Random_Float_Template);\n    --  Template for a random-number generator implementation that delivers\n-   --  values of type Real in the half-open range [0 .. 1), using values from\n-   --  Gen, assuming that Unsigned is large enough to hold the bits of\n-   --  a mantissa for type Real.\n+   --  values of type Real in the range [0 .. 1], using values from Gen,\n+   --  assuming that Unsigned is large enough to hold the bits of a mantissa\n+   --  for type Real.\n \n    function Random_Float_Template (Gen : Generator) return Real is\n+\n+      pragma Compile_Time_Error\n+        (Unsigned'Last <= 2**(Real'Machine_Mantissa - 1),\n+         \"insufficiently large modular type used to hold mantissa\");\n+\n+   begin\n       --  This code generates random floating-point numbers from unsigned\n       --  integers. Assuming that Real'Machine_Radix = 2, it can deliver all\n       --  machine values of type Real (as implied by Real'Machine_Mantissa and\n@@ -210,69 +214,118 @@ package body System.Random_Numbers is\n       --  integer>) / (<max random integer>+1). To do so, we first extract an\n       --  (M-1)-bit significand (where M is Real'Machine_Mantissa), and then\n       --  decide on a normalized exponent by repeated coin flips, decrementing\n-      --  from 0 as long as we flip heads (1 bits). This yields the proper\n-      --  geometric distribution for the exponent: in a uniformly distributed\n-      --  set of floating-point numbers, 1/2 of them will be in [0.5, 1), 1/4\n-      --  will be in [0.25, 0.5), and so forth. If the process reaches\n-      --  Machine_Emin (an extremely rare event), it uses the selected mantissa\n-      --  bits as an unnormalized fraction with Machine_Emin as exponent.\n-      --  Otherwise, it adds a leading bit to the selected mantissa bits (thus\n-      --  giving a normalized fraction) and adjusts by the chosen exponent. The\n-      --  algorithm attempts to be stingy with random integers. In the worst\n-      --  case, it can consume roughly -Real'Machine_Emin/32 32-bit integers,\n-      --  but this case occurs with probability 2**Machine_Emin, and the\n-      --  expected number of calls to integer-valued Random is 1.\n+      --  from 0 as long as we flip heads (1 bits). This process yields the\n+      --  proper geometric distribution for the exponent: in a uniformly\n+      --  distributed set of floating-point numbers, 1/2 of them will be in\n+      --  (0.5, 1], 1/4 will be in (0.25, 0.5], and so forth. It makes a\n+      --  further adjustment at binade boundaries (see comments below) to give\n+      --  the effect of selecting a uniformly distributed real deviate in\n+      --  [0..1] and then rounding to the nearest representable floating-point\n+      --  number.  The algorithm attempts to be stingy with random integers. In\n+      --  the worst case, it can consume roughly -Real'Machine_Emin/32 32-bit\n+      --  integers, but this case occurs with probability around\n+      --  2**Machine_Emin, and the expected number of calls to integer-valued\n+      --  Random is 1.  For another discussion of the issues addressed by this\n+      --  process, see Allen Downey's unpublished paper at\n+      --  http://allendowney.com/research/rand/downey07randfloat.pdf.\n \n-   begin\n       if Real'Machine_Radix /= 2 then\n+         return Real'Machine\n+           (Real (Unsigned'(Random (Gen))) * 2.0**(-Unsigned'Size));\n+      else\n          declare\n-            Val : constant Real :=\n-                    Real'Machine\n-                      (Real (Unsigned'(Random (Gen))) * 2.0**(-Unsigned'Size));\n+            type Bit_Count is range 0 .. 4;\n+\n+            subtype T is Real'Base;\n+\n+            Trailing_Ones : constant array (Unsigned_32 range 0 .. 15)\n+              of Bit_Count\n+              :=  (2#00000# => 0, 2#00001# => 1, 2#00010# => 0, 2#00011# => 2,\n+                   2#00100# => 0, 2#00101# => 1, 2#00110# => 0, 2#00111# => 3,\n+                   2#01000# => 0, 2#01001# => 1, 2#01010# => 0, 2#01011# => 2,\n+                   2#01100# => 0, 2#01101# => 1, 2#01110# => 0, 2#01111# => 4);\n+\n+            Pow_Tab : constant array (Bit_Count range 0 .. 3) of Real\n+              := (0 => 2.0**(0 - T'Machine_Mantissa),\n+                  1 => 2.0**(-1 - T'Machine_Mantissa),\n+                  2 => 2.0**(-2 - T'Machine_Mantissa),\n+                  3 => 2.0**(-3 - T'Machine_Mantissa));\n+\n+            Extra_Bits : constant Natural :=\n+                         (Unsigned'Size - T'Machine_Mantissa + 1);\n+            --  Random bits left over after selecting mantissa\n+\n+            Mantissa   : Unsigned;\n+            X          : Real;            -- Scaled mantissa\n+            R          : Unsigned_32;     -- Supply of random bits\n+            R_Bits     : Natural;         -- Number of bits left in R\n+\n+            K          : Bit_Count;       -- Next decrement to exponent\n          begin\n-            if Val < 1.0 then\n-               return Real'Base (Val);\n+\n+            Mantissa := Random (Gen) / 2**Extra_Bits;\n+            R := Unsigned_32 (Mantissa mod 2**Extra_Bits);\n+            R_Bits := Extra_Bits;\n+            X := Real (2**(T'Machine_Mantissa - 1) + Mantissa); -- Exact\n+\n+            if Extra_Bits < 4 and then R < 2**Extra_Bits - 1 then\n+               --  We got lucky and got a zero in our few extra bits\n+               K := Trailing_Ones (R);\n+\n             else\n-               return Real'Pred (1.0);\n+               Find_Zero : loop\n+\n+                  --  R has R_Bits unprocessed random bits, a multiple of 4.\n+                  --  X needs to be halved for each trailing one bit. The\n+                  --  process stops as soon as a 0 bit is found. If R_Bits\n+                  --  becomes zero, reload R.\n+\n+                  --  Process 4 bits at a time for speed: the two iterations\n+                  --  on average with three tests each was still too slow,\n+                  --  probably because the branches are not predictable.\n+                  --  This loop now will only execute once 94% of the cases,\n+                  --  doing more bits at a time will not help.\n+\n+                  while R_Bits >= 4 loop\n+                     K := Trailing_Ones (R mod 16);\n+\n+                     exit Find_Zero when K < 4; -- Exits 94% of the time\n+\n+                     R_Bits := R_Bits - 4;\n+                     X := X / 16.0;\n+                     R := R / 16;\n+                  end loop;\n+\n+                  --  Do not allow us to loop endlessly even in the (very\n+                  --  unlikely) case that Random (Gen) keeps yielding all ones.\n+\n+                  exit Find_Zero when X = 0.0;\n+                  R := Random (Gen);\n+                  R_Bits := 32;\n+               end loop Find_Zero;\n             end if;\n-         end;\n \n-      else\n-         declare\n-            Mant_Bits : constant Integer := Real'Machine_Mantissa - 1;\n-            Mant_Mask : constant Unsigned := 2**Mant_Bits - 1;\n-            Adjust32  : constant Integer := Real'Size - Unsigned_32'Size;\n-            Leftover  : constant Integer :=\n-                          Unsigned'Size - Real'Machine_Mantissa + 1;\n-            V         : constant Unsigned := Random (Gen);\n-            Mant      : constant Unsigned := V and Mant_Mask;\n-            Rand_Bits : Unsigned_32;\n-            Exp       : Integer;\n-            Bits_Left : Integer;\n-            Result    : Real;\n+            --  K has the count of trailing ones not reflected yet in X.\n+            --  The following multiplication takes care of that, as well\n+            --  as the correction to move the radix point to the left of\n+            --  the mantissa. Doing it at the end avoids repeated rounding\n+            --  errors in the exceedingly unlikely case of ever having\n+            --  a subnormal result.\n \n-         begin\n-            Rand_Bits := Unsigned_32 (Shift_Right (V, Adjust32));\n-            Exp := 0;\n-            Bits_Left := Leftover;\n-            Result := Real (Mant + 2**Mant_Bits) * 2.0**(-Mant_Bits - 1);\n-            while Rand_Bits >= 2**31 loop\n-               if Exp = Real'Machine_Emin then\n-                  return Real (Mant) * 2.0**Real'Machine_Emin;\n-               end if;\n-\n-               Result := Result * 0.5;\n-               Exp := Exp - 1;\n-               Rand_Bits := 2 * Rand_Bits;\n-               Bits_Left := Bits_Left - 1;\n-\n-               if Bits_Left = 0 then\n-                  Bits_Left := 32;\n-                  Rand_Bits := Random (Gen);\n-               end if;\n-            end loop;\n+            X := X * Pow_Tab (K);\n+\n+            --  The smallest value in each binade is rounded to by 0.75 of\n+            --  the span of real numbers as its next larger neighbor, and\n+            --  1.0 is rounded to by half of the span of real numbers as its\n+            --  next smaller neighbor. To account for this, when we encounter\n+            --  the smallest number in a binade, we substitute the smallest\n+            --  value in the next larger binade with probability 1/2.\n+\n+            if Mantissa = 0 and then Unsigned_32'(Random (Gen)) mod 2 = 0 then\n+               X := 2.0 * X;\n+            end if;\n \n-            return Result;\n+            return X;\n          end;\n       end if;\n    end Random_Float_Template;"}]}