{"sha": "a753df11b8bc86cf0e991fe2843ebb30b7992a16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc1M2RmMTFiOGJjODZjZjBlOTkxZmUyODQzZWJiMzBiNzk5MmExNg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-04-24T15:13:39Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-04-24T15:13:39Z"}, "message": "[PR 80293] Dont totally-scalarize char arrays\n\n2017-04-24  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/80293\n\t* tree-sra.c (scalarizable_type_p): New parameter const_decl, make\n\tchar arrays not totally scalarizable if it is false.\n\t(analyze_all_variable_accesses): Pass correct value in the new\n\tparameter.  Add a statistics counter.\n\ntestsuite/\n\t* g++.dg/tree-ssa/pr80293.C: New test.\n\nFrom-SVN: r247104", "tree": {"sha": "6d3ec20ad48bcca2e3018827c134c624e86f5c74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d3ec20ad48bcca2e3018827c134c624e86f5c74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a753df11b8bc86cf0e991fe2843ebb30b7992a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a753df11b8bc86cf0e991fe2843ebb30b7992a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a753df11b8bc86cf0e991fe2843ebb30b7992a16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a753df11b8bc86cf0e991fe2843ebb30b7992a16/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "957221f5511cf97447f52ba274eb0e0be7eff151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957221f5511cf97447f52ba274eb0e0be7eff151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/957221f5511cf97447f52ba274eb0e0be7eff151"}], "stats": {"total": 81, "additions": 75, "deletions": 6}, "files": [{"sha": "0dd86c12e6c8950eec900fb219f1763632565eaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a753df11b8bc86cf0e991fe2843ebb30b7992a16", "patch": "@@ -1,3 +1,11 @@\n+2017-04-24  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/80293\n+\t* tree-sra.c (scalarizable_type_p): New parameter const_decl, make\n+\tchar arrays not totally scalarizable if it is false.\n+\t(analyze_all_variable_accesses): Pass correct value in the new\n+\tparameter.  Add a statistics counter.\n+\n 2017-04-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR middle-end/79931"}, {"sha": "d8306420fc4100ab13f13207b08044d39112e26d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a753df11b8bc86cf0e991fe2843ebb30b7992a16", "patch": "@@ -1,3 +1,8 @@\n+2017-04-24  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/80293\n+\t* g++.dg/tree-ssa/pr80293.C: New test.\n+\n 2017-04-24  Martin Liska  <mliska@suse.cz>\n \n \tPR middle-end/79931"}, {"sha": "7faf35ae98319127432be046034970b94b4503f3", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr80293.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr80293.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr80293.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr80293.C?ref=a753df11b8bc86cf0e991fe2843ebb30b7992a16", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -std=gnu++11 -fdump-tree-optimized\" } */\n+\n+#include <array>\n+\n+// Return a copy of the underlying memory of an arbitrary value.\n+template <\n+    typename T,\n+    typename = typename std::enable_if<std::is_trivially_copyable<T>::value>::type\n+>\n+auto getMem(\n+    T const & value\n+) -> std::array<char, sizeof(T)> {\n+    auto ret = std::array<char, sizeof(T)>{};\n+    __builtin_memcpy(ret.data(), &value, sizeof(T));\n+    return ret;\n+}\n+\n+template <\n+    typename T,\n+    typename = typename std::enable_if<std::is_trivially_copyable<T>::value>::type\n+>\n+auto fromMem(\n+    std::array<char, sizeof(T)> const & buf\n+) -> T {\n+    auto ret = T{};\n+    __builtin_memcpy(&ret, buf.data(), sizeof(T));\n+    return ret;\n+}\n+\n+double foo1(std::uint64_t arg) {\n+    return fromMem<double>(getMem(arg));\n+}\n+\n+double foo2(std::uint64_t arg) {\n+    return *reinterpret_cast<double*>(&arg);\n+}\n+\n+double foo3(std::uint64_t arg) {\n+    double ret;\n+    __builtin_memcpy(&ret, &arg, sizeof(arg));\n+    return ret;\n+}\n+\n+// { dg-final { scan-tree-dump-not \"BIT_FIELD_REF\" \"optimized\" } }"}, {"sha": "0334d0615075117389358539cf9292d45535ae4a", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a753df11b8bc86cf0e991fe2843ebb30b7992a16/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=a753df11b8bc86cf0e991fe2843ebb30b7992a16", "patch": "@@ -949,10 +949,12 @@ create_access (tree expr, gimple *stmt, bool write)\n \n /* Return true iff TYPE is scalarizable - i.e. a RECORD_TYPE or fixed-length\n    ARRAY_TYPE with fields that are either of gimple register types (excluding\n-   bit-fields) or (recursively) scalarizable types.  */\n+   bit-fields) or (recursively) scalarizable types.  CONST_DECL must be true if\n+   we are considering a decl from constant pool.  If it is false, char arrays\n+   will be refused.  */\n \n static bool\n-scalarizable_type_p (tree type)\n+scalarizable_type_p (tree type, bool const_decl)\n {\n   gcc_assert (!is_gimple_reg_type (type));\n   if (type_contains_placeholder_p (type))\n@@ -970,18 +972,24 @@ scalarizable_type_p (tree type)\n \t    return false;\n \n \t  if (!is_gimple_reg_type (ft)\n-\t      && !scalarizable_type_p (ft))\n+\t      && !scalarizable_type_p (ft, const_decl))\n \t    return false;\n \t}\n \n     return true;\n \n   case ARRAY_TYPE:\n     {\n+      HOST_WIDE_INT min_elem_size;\n+      if (const_decl)\n+\tmin_elem_size = 0;\n+      else\n+\tmin_elem_size = BITS_PER_UNIT;\n+\n       if (TYPE_DOMAIN (type) == NULL_TREE\n \t  || !tree_fits_shwi_p (TYPE_SIZE (type))\n \t  || !tree_fits_shwi_p (TYPE_SIZE (TREE_TYPE (type)))\n-\t  || (tree_to_shwi (TYPE_SIZE (TREE_TYPE (type))) <= 0)\n+\t  || (tree_to_shwi (TYPE_SIZE (TREE_TYPE (type))) <= min_elem_size)\n \t  || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))\n \treturn false;\n       if (tree_to_shwi (TYPE_SIZE (type)) == 0\n@@ -995,7 +1003,7 @@ scalarizable_type_p (tree type)\n \n       tree elem = TREE_TYPE (type);\n       if (!is_gimple_reg_type (elem)\n-\t && !scalarizable_type_p (elem))\n+\t  && !scalarizable_type_p (elem, const_decl))\n \treturn false;\n       return true;\n     }\n@@ -2660,13 +2668,16 @@ analyze_all_variable_accesses (void)\n       {\n \ttree var = candidate (i);\n \n-\tif (VAR_P (var) && scalarizable_type_p (TREE_TYPE (var)))\n+\tif (VAR_P (var) && scalarizable_type_p (TREE_TYPE (var),\n+\t\t\t\t\t\tconstant_decl_p (var)))\n \t  {\n \t    if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var)))\n \t\t<= max_scalarization_size)\n \t      {\n \t\tcreate_total_scalarization_access (var);\n \t\tcompletely_scalarize (var, TREE_TYPE (var), 0, var);\n+\t\tstatistics_counter_event (cfun,\n+\t\t\t\t\t  \"Totally-scalarized aggregates\", 1);\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  {\n \t\t    fprintf (dump_file, \"Will attempt to totally scalarize \");"}]}