{"sha": "341e0bb6c54e541637031f30492d584a8e5e98f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQxZTBiYjZjNTRlNTQxNjM3MDMxZjMwNDkyZDU4NGE4ZTVlOThmNQ==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2018-05-28T08:53:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-28T08:53:36Z"}, "message": "[Ada] Spurious constraint error on array of null-excluding components\n\nThis patch fixes an issue whereby the compiler would raise spurious runtime\nerrors when an array of null-excluding components was initialized with an\nexpression which required the secondary stack (such as with an concatination\noperation) due to certain generated checks which were incorrected performed\non internal object declarations.\n\n2018-05-28  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch3.adb\n\t(Build_Initialization_Call): Add logic to pass the appropriate actual to match\n\t new formal.\n\t(Init_Formals): Add new formal *_skip_null_excluding_check\n\t* exp_util.adb, exp_util.ads\n\t(Enclosing_Init_Proc): Added to fetch the enclosing Init_Proc from the current\n\t scope.\n\t(Inside_Init_Proc): Refactored to use Enclosing_Init_Proc\n\t(Needs_Conditional_Null_Excluding_Check): Added to factorize the predicate\n\t used to determine how to generate an Init_Proc for a given type.\n\t(Needs_Constant_Address): Minor reformatting\n\t* sem_res.adb\n\t(Resolve_Null): Add logic to generate a conditional check in certain cases\n\ngcc/testsuite/\n\n\t* gnat.dg/array31.adb: New testcase.\n\nFrom-SVN: r260822", "tree": {"sha": "ec2d3805900f0491479ada4b18d10c221045936b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec2d3805900f0491479ada4b18d10c221045936b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/341e0bb6c54e541637031f30492d584a8e5e98f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341e0bb6c54e541637031f30492d584a8e5e98f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341e0bb6c54e541637031f30492d584a8e5e98f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341e0bb6c54e541637031f30492d584a8e5e98f5/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b19c244561c5d8c312af9e44eb62e77d42e1e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b19c244561c5d8c312af9e44eb62e77d42e1e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b19c244561c5d8c312af9e44eb62e77d42e1e65"}], "stats": {"total": 280, "additions": 209, "deletions": 71}, "files": [{"sha": "a6edf80758d3ad526047a2844043ade4a6a98341", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -1,3 +1,19 @@\n+2018-05-28  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_ch3.adb\n+\t(Build_Initialization_Call): Add logic to pass the appropriate actual to match\n+\t new formal.\n+\t(Init_Formals): Add new formal *_skip_null_excluding_check\n+\t* exp_util.adb, exp_util.ads\n+\t(Enclosing_Init_Proc): Added to fetch the enclosing Init_Proc from the current\n+\t scope.\n+\t(Inside_Init_Proc): Refactored to use Enclosing_Init_Proc\n+\t(Needs_Conditional_Null_Excluding_Check): Added to factorize the predicate\n+\t used to determine how to generate an Init_Proc for a given type.\n+\t(Needs_Constant_Address): Minor reformatting\n+\t* sem_res.adb\n+\t(Resolve_Null): Add logic to generate a conditional check in certain cases\n+\n 2018-05-28  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_aggr.adb, gnatlink.adb, sem_ch6.adb, sem_res.adb, sem_util.adb:"}, {"sha": "689c67c2e7b0218fb2492fc81811cfa214ec64c5", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -1550,6 +1550,29 @@ package body Exp_Ch3 is\n          Decl  := Empty;\n       end if;\n \n+      --  Handle the optionally generated formal *_skip_null_excluding_checks\n+\n+      if Needs_Conditional_Null_Excluding_Check (Full_Init_Type) then\n+\n+         --  Look at the associated node for the object we are referencing and\n+         --  verify that we are expanding a call to an Init_Proc for an\n+         --  internally generated object declaration before passing True and\n+         --  skipping the relevant checks.\n+\n+         if Nkind (Id_Ref) in N_Has_Entity\n+           and then Comes_From_Source (Associated_Node (Id_Ref))\n+         then\n+            Append_To (Args,\n+              New_Occurrence_Of (Standard_True, Loc));\n+\n+         --  Otherwise, we pass False to perform null excluding checks\n+\n+         else\n+            Append_To (Args,\n+              New_Occurrence_Of (Standard_False, Loc));\n+         end if;\n+      end if;\n+\n       --  Add discriminant values if discriminants are present\n \n       if Has_Discriminants (Full_Init_Type) then\n@@ -8643,6 +8666,24 @@ package body Exp_Ch3 is\n              Parameter_Type      => New_Occurrence_Of (Standard_String, Loc)));\n       end if;\n \n+      --  Due to certain edge cases such as arrays with null excluding\n+      --  components being built with the secondary stack it becomes necessary\n+      --  to add a formal to the Init_Proc which controls whether we raise\n+      --  constraint errors on generated calls for internal object\n+      --  declarations.\n+\n+      if Needs_Conditional_Null_Excluding_Check (Typ) then\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc,\n+                 New_External_Name (Chars\n+                   (Component_Type (Typ)), \"_skip_null_excluding_check\")),\n+             In_Present          => True,\n+             Parameter_Type      =>\n+               New_Occurrence_Of (Standard_Boolean, Loc)));\n+      end if;\n+\n       return Formals;\n \n    exception"}, {"sha": "e1b92f322e607708caffcfe0e5e53ba011c83383", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 88, "deletions": 65, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -4751,6 +4751,26 @@ package body Exp_Util is\n       return New_Exp;\n    end Duplicate_Subexpr_Move_Checks;\n \n+   -------------------------\n+   -- Enclosing_Init_Proc --\n+   -------------------------\n+\n+   function Enclosing_Init_Proc return Entity_Id is\n+      S : Entity_Id;\n+\n+   begin\n+      S := Current_Scope;\n+      while Present (S) and then S /= Standard_Standard loop\n+         if Is_Init_Proc (S) then\n+            return S;\n+         else\n+            S := Scope (S);\n+         end if;\n+      end loop;\n+\n+      return Empty;\n+   end Enclosing_Init_Proc;\n+\n    --------------------\n    -- Ensure_Defined --\n    --------------------\n@@ -7534,19 +7554,10 @@ package body Exp_Util is\n    ----------------------\n \n    function Inside_Init_Proc return Boolean is\n-      S : Entity_Id;\n+      Proc : constant Entity_Id := Enclosing_Init_Proc;\n \n    begin\n-      S := Current_Scope;\n-      while Present (S) and then S /= Standard_Standard loop\n-         if Is_Init_Proc (S) then\n-            return True;\n-         else\n-            S := Scope (S);\n-         end if;\n-      end loop;\n-\n-      return False;\n+      return Proc /= Empty;\n    end Inside_Init_Proc;\n \n    ----------------------------\n@@ -10430,6 +10441,72 @@ package body Exp_Util is\n       end if;\n    end May_Generate_Large_Temp;\n \n+   --------------------------------------------\n+   -- Needs_Conditional_Null_Excluding_Check --\n+   --------------------------------------------\n+\n+   function Needs_Conditional_Null_Excluding_Check\n+     (Typ : Entity_Id) return Boolean\n+   is\n+   begin\n+      return Is_Array_Type (Typ)\n+               and then Can_Never_Be_Null (Component_Type (Typ));\n+   end Needs_Conditional_Null_Excluding_Check;\n+\n+   ----------------------------\n+   -- Needs_Constant_Address --\n+   ----------------------------\n+\n+   function Needs_Constant_Address\n+     (Decl : Node_Id;\n+      Typ  : Entity_Id) return Boolean\n+   is\n+   begin\n+      --  If we have no initialization of any kind, then we don't need to place\n+      --  any restrictions on the address clause, because the object will be\n+      --  elaborated after the address clause is evaluated. This happens if the\n+      --  declaration has no initial expression, or the type has no implicit\n+      --  initialization, or the object is imported.\n+\n+      --  The same holds for all initialized scalar types and all access types.\n+      --  Packed bit arrays of size up to 64 are represented using a modular\n+      --  type with an initialization (to zero) and can be processed like other\n+      --  initialized scalar types.\n+\n+      --  If the type is controlled, code to attach the object to a\n+      --  finalization chain is generated at the point of declaration, and\n+      --  therefore the elaboration of the object cannot be delayed: the\n+      --  address expression must be a constant.\n+\n+      if No (Expression (Decl))\n+        and then not Needs_Finalization (Typ)\n+        and then\n+          (not Has_Non_Null_Base_Init_Proc (Typ)\n+            or else Is_Imported (Defining_Identifier (Decl)))\n+      then\n+         return False;\n+\n+      elsif (Present (Expression (Decl)) and then Is_Scalar_Type (Typ))\n+        or else Is_Access_Type (Typ)\n+        or else\n+          (Is_Bit_Packed_Array (Typ)\n+            and then Is_Modular_Integer_Type (Packed_Array_Impl_Type (Typ)))\n+      then\n+         return False;\n+\n+      else\n+\n+         --  Otherwise, we require the address clause to be constant because\n+         --  the call to the initialization procedure (or the attach code) has\n+         --  to happen at the point of the declaration.\n+\n+         --  Actually the IP call has been moved to the freeze actions anyway,\n+         --  so maybe we can relax this restriction???\n+\n+         return True;\n+      end if;\n+   end Needs_Constant_Address;\n+\n    ------------------------\n    -- Needs_Finalization --\n    ------------------------\n@@ -10518,60 +10595,6 @@ package body Exp_Util is\n       end if;\n    end Needs_Finalization;\n \n-   ----------------------------\n-   -- Needs_Constant_Address --\n-   ----------------------------\n-\n-   function Needs_Constant_Address\n-     (Decl : Node_Id;\n-      Typ  : Entity_Id) return Boolean\n-   is\n-   begin\n-      --  If we have no initialization of any kind, then we don't need to place\n-      --  any restrictions on the address clause, because the object will be\n-      --  elaborated after the address clause is evaluated. This happens if the\n-      --  declaration has no initial expression, or the type has no implicit\n-      --  initialization, or the object is imported.\n-\n-      --  The same holds for all initialized scalar types and all access types.\n-      --  Packed bit arrays of size up to 64 are represented using a modular\n-      --  type with an initialization (to zero) and can be processed like other\n-      --  initialized scalar types.\n-\n-      --  If the type is controlled, code to attach the object to a\n-      --  finalization chain is generated at the point of declaration, and\n-      --  therefore the elaboration of the object cannot be delayed: the\n-      --  address expression must be a constant.\n-\n-      if No (Expression (Decl))\n-        and then not Needs_Finalization (Typ)\n-        and then\n-          (not Has_Non_Null_Base_Init_Proc (Typ)\n-            or else Is_Imported (Defining_Identifier (Decl)))\n-      then\n-         return False;\n-\n-      elsif (Present (Expression (Decl)) and then Is_Scalar_Type (Typ))\n-        or else Is_Access_Type (Typ)\n-        or else\n-          (Is_Bit_Packed_Array (Typ)\n-            and then Is_Modular_Integer_Type (Packed_Array_Impl_Type (Typ)))\n-      then\n-         return False;\n-\n-      else\n-\n-         --  Otherwise, we require the address clause to be constant because\n-         --  the call to the initialization procedure (or the attach code) has\n-         --  to happen at the point of the declaration.\n-\n-         --  Actually the IP call has been moved to the freeze actions anyway,\n-         --  so maybe we can relax this restriction???\n-\n-         return True;\n-      end if;\n-   end Needs_Constant_Address;\n-\n    ----------------------------\n    -- New_Class_Wide_Subtype --\n    ----------------------------"}, {"sha": "0f78442596abf1628cf6f173cf92c10670b17b66", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -505,6 +505,11 @@ package Exp_Util is\n    --  elaborated before the original expression Exp, so that there is no need\n    --  to repeat the checks.\n \n+   function Enclosing_Init_Proc return Entity_Id;\n+   --  Obtain the entity associated with the enclosing type Init_Proc by\n+   --  examining the current scope. If not inside an Init_Proc at the point of\n+   --  call Empty will be returned.\n+\n    procedure Ensure_Defined (Typ : Entity_Id; N : Node_Id);\n    --  This procedure ensures that type referenced by Typ is defined. For the\n    --  case of a type other than an Itype, nothing needs to be done, since\n@@ -916,6 +921,11 @@ package Exp_Util is\n    --  caller has to check whether stack checking is actually enabled in order\n    --  to guide the expansion (typically of a function call).\n \n+   function Needs_Conditional_Null_Excluding_Check\n+     (Typ : Entity_Id) return Boolean;\n+   --  Check if a type meets certain properties that require it to have a\n+   --  conditional null-excluding check within its Init_Proc.\n+\n    function Needs_Constant_Address\n      (Decl : Node_Id;\n       Typ  : Entity_Id) return Boolean;"}, {"sha": "327bf3148f92819b7732c8cea5375e8ddc154c57", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -9116,22 +9116,51 @@ package body Sem_Res is\n       end if;\n \n       --  Ada 2005 (AI-231): Generate the null-excluding check in case of\n-      --  assignment to a null-excluding object\n+      --  assignment to a null-excluding object.\n \n       if Ada_Version >= Ada_2005\n         and then Can_Never_Be_Null (Typ)\n         and then Nkind (Parent (N)) = N_Assignment_Statement\n       then\n-         if not Inside_Init_Proc then\n+         if Inside_Init_Proc then\n+\n+            --  Decide whether to generate an if_statement around our\n+            --  null-excluding check to avoid them on certain internal object\n+            --  declarations by looking at the type the current Init_Proc\n+            --  belongs to.\n+\n+            --  Generate:\n+            --    if T1b_skip_null_excluding_check then\n+            --       [constraint_error \"access check failed\"]\n+            --    end if;\n+\n+            if Needs_Conditional_Null_Excluding_Check\n+                (Etype (First_Formal (Enclosing_Init_Proc)))\n+            then\n+               Insert_Action (N,\n+                 Make_If_Statement (Loc,\n+                   Condition       =>\n+                     Make_Identifier (Loc,\n+                       New_External_Name\n+                         (Chars (Typ), \"_skip_null_excluding_check\")),\n+                   Then_Statements =>\n+                     New_List (\n+                       Make_Raise_Constraint_Error (Loc,\n+                         Reason => CE_Access_Check_Failed))));\n+\n+            --  Otherwise, simply create the check\n+\n+            else\n+               Insert_Action (N,\n+                 Make_Raise_Constraint_Error (Loc,\n+                   Reason => CE_Access_Check_Failed));\n+            end if;\n+         else\n             Insert_Action\n               (Compile_Time_Constraint_Error (N,\n                  \"(Ada 2005) null not allowed in null-excluding objects??\"),\n                Make_Raise_Constraint_Error (Loc,\n                  Reason => CE_Access_Check_Failed));\n-         else\n-            Insert_Action (N,\n-              Make_Raise_Constraint_Error (Loc,\n-                Reason => CE_Access_Check_Failed));\n          end if;\n       end if;\n "}, {"sha": "3717830a1b215803926f1d6474e3eaf4acc7bb31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -1,3 +1,7 @@\n+2018-05-28  Justin Squirek  <squirek@adacore.com>\n+\n+\t* gnat.dg/array31.adb: New testcase.\n+\n 2018-05-28  Justin Squirek  <squirek@adacore.com>\n \n \t* gnat.dg/warn15-core-main.adb, gnat.dg/warn15-core.ads,"}, {"sha": "b60474828efec82088740ec12cf2c38e0c9a3aa1", "filename": "gcc/testsuite/gnat.dg/array31.adb", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Ftestsuite%2Fgnat.dg%2Farray31.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341e0bb6c54e541637031f30492d584a8e5e98f5/gcc%2Ftestsuite%2Fgnat.dg%2Farray31.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray31.adb?ref=341e0bb6c54e541637031f30492d584a8e5e98f5", "patch": "@@ -0,0 +1,15 @@\n+--  { dg-do run }\n+\n+procedure Array31 is\n+\n+   type Boolean_Access is access Boolean;\n+\n+   type Boolean_Access_Array is\n+     array (Positive range <>) of not null Boolean_Access;\n+\n+   X : constant Boolean_Access_Array := (1 => new Boolean'(False));\n+   Y : constant Boolean_Access_Array := X & X;\n+\n+begin\n+   null;\n+end;"}]}