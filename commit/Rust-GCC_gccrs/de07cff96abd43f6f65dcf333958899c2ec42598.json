{"sha": "de07cff96abd43f6f65dcf333958899c2ec42598", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUwN2NmZjk2YWJkNDNmNmY2NWRjZjMzMzk1ODg5OWMyZWM0MjU5OA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-09-14T15:22:12Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-09-14T15:22:12Z"}, "message": "c++: empty union member activation during constexpr [PR102163]\n\nHere, the union's constructor is defined to activate its empty data\nmember _M_rest, but during constexpr evaluation of this constructor the\nsubobject constructor call O::O(&_M_rest, 42) doesn't produce a side\neffect that actually activates the member, so the union still appears\nuninitialized after its constructor has run.  This patch fixes this by\nusing a dummy MODIFY_EXPR in this situation, whose evaluation ensures\nthe member gets activated.\n\n\tPR c++/102163\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (cxx_eval_call_expression): After evaluating a\n\tsubobject constructor call for an empty union member, produce a\n\tside effect that makes sure the member gets activated.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/constexpr-empty17.C: New test.", "tree": {"sha": "05fbbb6484dff791c6a2a5fd8f82ad60ba12fe00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05fbbb6484dff791c6a2a5fd8f82ad60ba12fe00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de07cff96abd43f6f65dcf333958899c2ec42598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de07cff96abd43f6f65dcf333958899c2ec42598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de07cff96abd43f6f65dcf333958899c2ec42598", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de07cff96abd43f6f65dcf333958899c2ec42598/comments", "author": null, "committer": null, "parents": [{"sha": "818c505188ff5cd8eb048eb0e614c4ef732225bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818c505188ff5cd8eb048eb0e614c4ef732225bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/818c505188ff5cd8eb048eb0e614c4ef732225bd"}], "stats": {"total": 55, "additions": 49, "deletions": 6}, "files": [{"sha": "d3c075c5ab84fb1613d2d61a5bca2d46fbdf0ce3", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de07cff96abd43f6f65dcf333958899c2ec42598/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de07cff96abd43f6f65dcf333958899c2ec42598/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=de07cff96abd43f6f65dcf333958899c2ec42598", "patch": "@@ -2787,12 +2787,34 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t&jump_target);\n \n \t  if (DECL_CONSTRUCTOR_P (fun))\n-\t    /* This can be null for a subobject constructor call, in\n-\t       which case what we care about is the initialization\n-\t       side-effects rather than the value.  We could get at the\n-\t       value by evaluating *this, but we don't bother; there's\n-\t       no need to put such a call in the hash table.  */\n-\t    result = lval ? ctx->object : ctx->ctor;\n+\t    {\n+\t      /* This can be null for a subobject constructor call, in\n+\t\t which case what we care about is the initialization\n+\t\t side-effects rather than the value.  We could get at the\n+\t\t value by evaluating *this, but we don't bother; there's\n+\t\t no need to put such a call in the hash table.  */\n+\t      result = lval ? ctx->object : ctx->ctor;\n+\n+\t      /* If we've just evaluated a subobject constructor call for an\n+\t\t empty union member, it might not have produced a side effect\n+\t\t that actually activated the union member.  So produce such a\n+\t\t side effect now to ensure the union appears initialized.  */\n+\t      if (!result && new_obj\n+\t\t  && TREE_CODE (new_obj) == COMPONENT_REF\n+\t\t  && TREE_CODE (TREE_TYPE\n+\t\t\t\t(TREE_OPERAND (new_obj, 0))) == UNION_TYPE\n+\t\t  && is_really_empty_class (TREE_TYPE (new_obj),\n+\t\t\t\t\t    /*ignore_vptr*/false))\n+\t\t{\n+\t\t  tree activate = build2 (MODIFY_EXPR, TREE_TYPE (new_obj),\n+\t\t\t\t\t  new_obj,\n+\t\t\t\t\t  build_constructor (TREE_TYPE (new_obj),\n+\t\t\t\t\t\t\t     NULL));\n+\t\t  cxx_eval_constant_expression (ctx, activate, lval,\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t  ggc_free (activate);\n+\t\t}\n+\t    }\n \t  else if (VOID_TYPE_P (TREE_TYPE (res)))\n \t    result = void_node;\n \t  else"}, {"sha": "86126dabdbb0094ca19da8ffa61762f1fcebd96e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty17.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de07cff96abd43f6f65dcf333958899c2ec42598/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de07cff96abd43f6f65dcf333958899c2ec42598/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty17.C?ref=de07cff96abd43f6f65dcf333958899c2ec42598", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/102163\n+// { dg-do compile { target c++11 } }\n+\n+struct O {\n+  constexpr O(int) { }\n+};\n+\n+union _Variadic_union {\n+  constexpr _Variadic_union(int __arg) : _M_rest(__arg) { }\n+  int _M_first;\n+  O _M_rest;\n+};\n+\n+constexpr _Variadic_union u(42);\n+\n+struct _Variant_storage {\n+  constexpr _Variant_storage() : _M_u(42) {}\n+  _Variadic_union _M_u;\n+};\n+\n+constexpr _Variant_storage w;"}]}