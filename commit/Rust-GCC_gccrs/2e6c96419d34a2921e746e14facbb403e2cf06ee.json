{"sha": "2e6c96419d34a2921e746e14facbb403e2cf06ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU2Yzk2NDE5ZDM0YTI5MjFlNzQ2ZTE0ZmFjYmI0MDNlMmNmMDZlZQ==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2004-08-26T17:20:20Z"}, "committer": {"name": "Fariborz Jahanian", "email": "fjahanian@gcc.gnu.org", "date": "2004-08-26T17:20:20Z"}, "message": "Fixed several -mcpu=G5 and 'long double' issues for apple-ppc-darwin.\n\nOK'ed by David Edehlson.\n\nFrom-SVN: r86629", "tree": {"sha": "52f3cb74c78d74eff5e2c22863a530e2d244afde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52f3cb74c78d74eff5e2c22863a530e2d244afde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e6c96419d34a2921e746e14facbb403e2cf06ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6c96419d34a2921e746e14facbb403e2cf06ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6c96419d34a2921e746e14facbb403e2cf06ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6c96419d34a2921e746e14facbb403e2cf06ee/comments", "author": null, "committer": null, "parents": [{"sha": "a1bab9ea96f0a1a2e0b6030237fa4434eab78972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bab9ea96f0a1a2e0b6030237fa4434eab78972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1bab9ea96f0a1a2e0b6030237fa4434eab78972"}], "stats": {"total": 76, "additions": 64, "deletions": 12}, "files": [{"sha": "96bfe42a4f073cca965c58221f3864728527050a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e6c96419d34a2921e746e14facbb403e2cf06ee", "patch": "@@ -1,3 +1,27 @@\n+2004-08-26  Fariborz Jahanian  <fjahanian@apple.com>\n+\n+\t* config/rs6000/rs6000.h (HARD_REGNO_CALL_PART_CLOBBERED): Added \n+\tTFmode as additional register mode cloberred by call.\n+\n+2004-08-26  Fariborz Jahanian  <fjahanian@apple.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_libcall_value): Generate\n+\tparallel pattern for library call returning DImode in\n+\tmixed mode.\n+\n+2004-08-26  Fariborz Jahanian  <fjahanian@apple.com>\n+\n+\t* config/rs6000/rs6000.c (function_arg): Generate parallel\n+\tpattern for more split args.\n+\n+2004-08-26  Fariborz Jahanian  <fjahanian@apple.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_split_multireg_move): Call\n+\teither gen_movdi_di_update or gen_movdi_si_update depending on\n+\ttarget mode.\n+\t* config/rs6000/rs6000.md (movdi_update): Changed to movdi_<mode>_update,\n+\tto generate two versions.\n+ \n 2004-08-26  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* Makefile.in (lambda-code.o): New."}, {"sha": "49fe3bac77fe17c1114823f353a2c8e704caaad1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2e6c96419d34a2921e746e14facbb403e2cf06ee", "patch": "@@ -5120,11 +5120,19 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t include the portion actually in registers here.  */\n \t\t      enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n \t\t      rtx off;\n+\t\t      int i=0;\n+                      if (align_words + n_words > GP_ARG_NUM_REG \n+                          && (TARGET_32BIT && TARGET_POWERPC64))\n+                      /* Not all of the arg fits in gprs.  Say that it goes in memory too,\n+                         using a magic NULL_RTX component. Also see comment in \n+\t\t\t rs6000_mixed_function_arg for why the normal \n+\t\t\t function_arg_partial_nregs scheme doesn't work in this case. */\n+                        rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n \t\t      do\n \t\t\t{\n \t\t\t  r = gen_rtx_REG (rmode,\n \t\t\t\t\t   GP_ARG_MIN_REG + align_words);\n-\t\t\t  off = GEN_INT (k * GET_MODE_SIZE (rmode));\n+\t\t\t  off = GEN_INT (i++ * GET_MODE_SIZE (rmode));\n \t\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n \t\t\t}\n \t\t      while (++align_words < GP_ARG_NUM_REG && --n_words != 0);\n@@ -11383,9 +11391,11 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t      if (TARGET_UPDATE)\n \t\t{\n \t\t  rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n-\t\t  emit_insn (TARGET_32BIT\n-\t\t\t     ? gen_movsi_update (breg, breg, delta_rtx, nsrc)\n-\t\t\t     : gen_movdi_update (breg, breg, delta_rtx, nsrc));\n+                  emit_insn (TARGET_32BIT\n+                             ? (TARGET_POWERPC64\n+                                ? gen_movdi_si_update (breg, breg, delta_rtx, nsrc)\n+                                : gen_movsi_update (breg, breg, delta_rtx, nsrc))\n+                             : gen_movdi_di_update (breg, breg, delta_rtx, nsrc));\n \t\t  used_update = true;\n \t\t}\n \t      else\n@@ -12583,7 +12593,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n       insn = emit_insn (TARGET_32BIT\n \t\t\t? gen_movsi_update (stack_reg, stack_reg,\n \t\t\t\t\t    todec, stack_reg)\n-\t\t\t: gen_movdi_update (stack_reg, stack_reg,\n+\t\t\t: gen_movdi_di_update (stack_reg, stack_reg, \n \t\t\t\t\t    todec, stack_reg));\n     }\n   else\n@@ -17520,6 +17530,20 @@ rs6000_libcall_value (enum machine_mode mode)\n {\n   unsigned int regno;\n \n+  if (TARGET_32BIT && TARGET_POWERPC64 && mode == DImode)\n+    {\n+      /* Long long return value need be split in -mpowerpc64, 32bit ABI.  */\n+      return gen_rtx_PARALLEL (DImode,\n+\tgen_rtvec (2,\n+\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (SImode, GP_ARG_RETURN),\n+\t\t\t\t      const0_rtx),\n+\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (SImode,\n+\t\t\t\t\t\t   GP_ARG_RETURN + 1),\n+\t\t\t\t      GEN_INT (4))));\n+    }\n+\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;"}, {"sha": "801d54fd93f7ef0b512f717a63148fb1d75859e3", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2e6c96419d34a2921e746e14facbb403e2cf06ee", "patch": "@@ -1016,7 +1016,7 @@ extern const char *rs6000_warn_altivec_long_switch;\n \n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\\\n   ((TARGET_32BIT && TARGET_POWERPC64\t\t\t\\\n-    && (MODE == DImode || MODE == DFmode)\t\t\\\n+    && (GET_MODE_SIZE (MODE) > 4)  \\\n     && INT_REGNO_P (REGNO)) ? 1 : 0)\n \n #define ALTIVEC_VECTOR_MODE(MODE)\t\\"}, {"sha": "819e8a3d8e644e317e104975600658c312947bf4", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6c96419d34a2921e746e14facbb403e2cf06ee/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2e6c96419d34a2921e746e14facbb403e2cf06ee", "patch": "@@ -104,6 +104,10 @@\n (include \"darwin.md\")\n \n \f\n+;; This mode macro allows :P to be used for patterns that operate on\n+;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n+(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n \n@@ -9483,12 +9487,12 @@\n    ldu %3,%2(%0)\"\n   [(set_attr \"type\" \"load_ux,load_u\")])\n \n-(define_insn \"movdi_update\"\n-  [(set (mem:DI (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"0,0\")\n-\t\t\t (match_operand:DI 2 \"reg_or_aligned_short_operand\" \"r,I\")))\n+(define_insn \"movdi_<mode>_update\"\n+  [(set (mem:DI (plus:P (match_operand:P 1 \"gpc_reg_operand\" \"0,0\")\n+\t\t\t (match_operand:P 2 \"reg_or_aligned_short_operand\" \"r,I\")))\n \t(match_operand:DI 3 \"gpc_reg_operand\" \"r,r\"))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=b,b\")\n-\t(plus:DI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"=b,b\")\n+\t(plus:P (match_dup 1) (match_dup 2)))]\n   \"TARGET_POWERPC64 && TARGET_UPDATE\"\n   \"@\n    stdux %3,%0,%2\n@@ -9956,7 +9960,7 @@\n     neg_op0 = GEN_INT (- INTVAL (operands[1]));\n \n   if (TARGET_UPDATE)\n-    emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update : gen_movdi_update))\n+    emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update : gen_movdi_di_update))\n \t\t(stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n \n   else"}]}