{"sha": "bb51e27026e8f068ad191b7200f51439aaa292af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI1MWUyNzAyNmU4ZjA2OGFkMTkxYjcyMDBmNTE0MzlhYWEyOTJhZg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-01-22T12:44:54Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-01-22T12:44:54Z"}, "message": "rtlanal.c (subreg_lsb_1): New function split out from subreg_lsb.\n\n\n\t* rtlanal.c (subreg_lsb_1): New function split out from subreg_lsb.\n\t(subreg_lsb): Change to call new subreg_lsb_1 helper function.\n\t* rtl.h (subreg_lsb_1): Prototype here.\n\t* simplify-rtx.c (simplify_subreg): Optimize subregs of zero and\n\tsign extensions.\n\nCo-Authored-By: Paolo Bonzini <bonzini@gnu.org>\n\nFrom-SVN: r76352", "tree": {"sha": "3c307eaa8d9217b307aed75ea2e9ba109fafafb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c307eaa8d9217b307aed75ea2e9ba109fafafb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb51e27026e8f068ad191b7200f51439aaa292af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb51e27026e8f068ad191b7200f51439aaa292af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb51e27026e8f068ad191b7200f51439aaa292af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb51e27026e8f068ad191b7200f51439aaa292af/comments", "author": null, "committer": null, "parents": [{"sha": "9c49953c15b1071a2a44135143b463a15b40687a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c49953c15b1071a2a44135143b463a15b40687a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c49953c15b1071a2a44135143b463a15b40687a"}], "stats": {"total": 87, "additions": 72, "deletions": 15}, "files": [{"sha": "22c095a625479ec3db81f3d36cc987453eb8adfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb51e27026e8f068ad191b7200f51439aaa292af", "patch": "@@ -1,3 +1,12 @@\n+2004-01-22  Roger Sayle  <roger@eyesopen.com>\n+\t    Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* rtlanal.c (subreg_lsb_1): New function split out from subreg_lsb.\n+\t(subreg_lsb): Change to call new subreg_lsb_1 helper function.\n+\t* rtl.h (subreg_lsb_1): Prototype here.\n+\t* simplify-rtx.c (simplify_subreg): Optimize subregs of zero and\n+\tsign extensions.\n+\n 2004-01-22  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/tm.texi (CASE_VECTOR_PC_RELATIVE): Mention that the"}, {"sha": "7fde7eac820fbcab1010a2c181a4d368ac08905a", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bb51e27026e8f068ad191b7200f51439aaa292af", "patch": "@@ -1065,6 +1065,8 @@ enum label_kind\n \n /* in rtlanal.c */\n extern unsigned int subreg_lsb (rtx);\n+extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,\n+\t\t\t\t  unsigned int);\n extern unsigned int subreg_regno_offset\t(unsigned int, enum machine_mode,\n \t\t\t\t\t unsigned int, enum machine_mode);\n extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,"}, {"sha": "4dda17869968a53d25ed824e272a6d5814232534", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=bb51e27026e8f068ad191b7200f51439aaa292af", "patch": "@@ -3187,48 +3187,59 @@ loc_mentioned_in_p (rtx *loc, rtx in)\n   return 0;\n }\n \n-/* Given a subreg X, return the bit offset where the subreg begins\n-   (counting from the least significant bit of the reg).  */\n+/* Helper function for subreg_lsb.  Given a subreg's OUTER_MODE, INNER_MODE,\n+   and SUBREG_BYTE, return the bit offset where the subreg begins\n+   (counting from the least significant bit of the operand).  */\n \n unsigned int\n-subreg_lsb (rtx x)\n+subreg_lsb_1 (enum machine_mode outer_mode,\n+\t      enum machine_mode inner_mode,\n+\t      unsigned int subreg_byte)\n {\n-  enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n-  enum machine_mode mode = GET_MODE (x);\n   unsigned int bitpos;\n   unsigned int byte;\n   unsigned int word;\n \n   /* A paradoxical subreg begins at bit position 0.  */\n-  if (GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (inner_mode))\n+  if (GET_MODE_BITSIZE (outer_mode) > GET_MODE_BITSIZE (inner_mode))\n     return 0;\n \n   if (WORDS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n     /* If the subreg crosses a word boundary ensure that\n        it also begins and ends on a word boundary.  */\n-    if ((SUBREG_BYTE (x) % UNITS_PER_WORD\n-\t + GET_MODE_SIZE (mode)) > UNITS_PER_WORD\n-\t&& (SUBREG_BYTE (x) % UNITS_PER_WORD\n-\t    || GET_MODE_SIZE (mode) % UNITS_PER_WORD))\n+    if ((subreg_byte % UNITS_PER_WORD\n+\t + GET_MODE_SIZE (outer_mode)) > UNITS_PER_WORD\n+\t&& (subreg_byte % UNITS_PER_WORD\n+\t    || GET_MODE_SIZE (outer_mode) % UNITS_PER_WORD))\n \tabort ();\n \n   if (WORDS_BIG_ENDIAN)\n     word = (GET_MODE_SIZE (inner_mode)\n-\t    - (SUBREG_BYTE (x) + GET_MODE_SIZE (mode))) / UNITS_PER_WORD;\n+\t    - (subreg_byte + GET_MODE_SIZE (outer_mode))) / UNITS_PER_WORD;\n   else\n-    word = SUBREG_BYTE (x) / UNITS_PER_WORD;\n+    word = subreg_byte / UNITS_PER_WORD;\n   bitpos = word * BITS_PER_WORD;\n \n   if (BYTES_BIG_ENDIAN)\n     byte = (GET_MODE_SIZE (inner_mode)\n-\t    - (SUBREG_BYTE (x) + GET_MODE_SIZE (mode))) % UNITS_PER_WORD;\n+\t    - (subreg_byte + GET_MODE_SIZE (outer_mode))) % UNITS_PER_WORD;\n   else\n-    byte = SUBREG_BYTE (x) % UNITS_PER_WORD;\n+    byte = subreg_byte % UNITS_PER_WORD;\n   bitpos += byte * BITS_PER_UNIT;\n \n   return bitpos;\n }\n \n+/* Given a subreg X, return the bit offset where the subreg begins\n+   (counting from the least significant bit of the reg).  */\n+\n+unsigned int\n+subreg_lsb (rtx x)\n+{\n+  return subreg_lsb_1 (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n+\t\t       SUBREG_BYTE (x));\n+}\n+\n /* This function returns the regno offset of a subreg expression.\n    xregno - A regno of an inner hard subreg_reg (or what will become one).\n    xmode  - The mode of xregno."}, {"sha": "5ba6882e680386996d63915a57bac01697f6a0eb", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb51e27026e8f068ad191b7200f51439aaa292af/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=bb51e27026e8f068ad191b7200f51439aaa292af", "patch": "@@ -3379,10 +3379,45 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n       res = simplify_subreg (outermode, part, GET_MODE (part), final_offset);\n       if (res)\n \treturn res;\n-      /* We can at least simplify it by referring directly to the relevant part.  */\n+      /* We can at least simplify it by referring directly to the\n+\t relevant part.  */\n       return gen_rtx_SUBREG (outermode, part, final_offset);\n     }\n \n+  /* Optimize SUBREG truncations of zero and sign extended values.  */\n+  if ((GET_CODE (op) == ZERO_EXTEND\n+       || GET_CODE (op) == SIGN_EXTEND)\n+      && GET_MODE_BITSIZE (outermode) < GET_MODE_BITSIZE (innermode))\n+    {\n+      unsigned int bitpos = subreg_lsb_1 (outermode, innermode, byte);\n+\n+      /* If we're requesting the lowpart of a zero or sign extension,\n+\t there are three possibilities.  If the outermode is the same\n+\t as the origmode, we can omit both the extension and the subreg.\n+\t If the outermode is not larger than the origmode, we can apply\n+\t the truncation without the extension.  Finally, if the outermode\n+\t is larger than the origmode, but both are integer modes, we\n+\t can just extend to the appropriate mode.  */\n+      if (bitpos == 0)\n+\t{\n+\t  enum machine_mode origmode = GET_MODE (XEXP (op, 0));\n+\t  if (outermode == origmode)\n+\t    return XEXP (op, 0);\n+\t  if (GET_MODE_BITSIZE (outermode) <= GET_MODE_BITSIZE (origmode))\n+\t    return simplify_gen_subreg (outermode, XEXP (op, 0),\n+\t\t\t\t\torigmode, byte);\n+\t  if (SCALAR_INT_MODE_P (outermode))\n+\t    return simplify_gen_unary (GET_CODE (op), outermode,\n+\t\t\t\t       XEXP (op, 0), origmode);\n+\t}\n+\n+      /* A SUBREG resulting from a zero extension may fold to zero if\n+\t it extracts higher bits that the ZERO_EXTEND's source bits.  */\n+      if (GET_CODE (op) == ZERO_EXTEND\n+\t  && bitpos >= GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))))\n+\treturn CONST0_RTX (outermode);\n+    }\n+\n   return NULL_RTX;\n }\n "}]}