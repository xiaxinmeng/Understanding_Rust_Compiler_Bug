{"sha": "33b30201b365982cf276cfa64e20985f0c81bc78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNiMzAyMDFiMzY1OTgyY2YyNzZjZmE2NGUyMDk4NWYwYzgxYmM3OA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2007-12-21T16:28:48Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-12-21T16:28:48Z"}, "message": "tree-data-ref.c (signed_type_for_types): New.\n\n2007-12-21  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-data-ref.c (signed_type_for_types): New.\n\t(affine_fn_op): Use signed_type_for_types and signed_type_for instead\n\tof long_integer_type_node.\n\t(analyze_ziv_subscript): Same.\n\t(analyze_siv_subscript_cst_affine): Same.\n\t(analyze_miv_subscript): Same.\n\t(omega_setup_subscript): Same.\n\nFrom-SVN: r131121", "tree": {"sha": "d819e55c908ee83fb71b5441e22ace65c42d018b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d819e55c908ee83fb71b5441e22ace65c42d018b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33b30201b365982cf276cfa64e20985f0c81bc78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b30201b365982cf276cfa64e20985f0c81bc78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33b30201b365982cf276cfa64e20985f0c81bc78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b30201b365982cf276cfa64e20985f0c81bc78/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f90dd02db58085d6b750cc002f5ba1b971657d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90dd02db58085d6b750cc002f5ba1b971657d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90dd02db58085d6b750cc002f5ba1b971657d9b"}], "stats": {"total": 90, "additions": 59, "deletions": 31}, "files": [{"sha": "fa163e35f6d6fc86c14756efb067730b123095d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b30201b365982cf276cfa64e20985f0c81bc78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b30201b365982cf276cfa64e20985f0c81bc78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33b30201b365982cf276cfa64e20985f0c81bc78", "patch": "@@ -1,3 +1,13 @@\n+2007-12-21  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-data-ref.c (signed_type_for_types): New.\n+\t(affine_fn_op): Use signed_type_for_types and signed_type_for instead\n+\tof long_integer_type_node.\n+\t(analyze_ziv_subscript): Same.\n+\t(analyze_siv_subscript_cst_affine): Same.\n+\t(analyze_miv_subscript): Same.\n+\t(omega_setup_subscript): Same.\n+\n 2007-12-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (mips_emit_loadgp): Replace gen_* calls with"}, {"sha": "07b311a93fd6fb9cd71d8beecd85b942486a2d43", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b30201b365982cf276cfa64e20985f0c81bc78/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b30201b365982cf276cfa64e20985f0c81bc78/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=33b30201b365982cf276cfa64e20985f0c81bc78", "patch": "@@ -935,6 +935,18 @@ affine_function_zero_p (affine_fn fn)\n \t  && affine_function_constant_p (fn));\n }\n \n+/* Returns a signed integer type with the largest precision from TA\n+   and TB.  */\n+\n+static tree\n+signed_type_for_types (tree ta, tree tb)\n+{\n+  if (TYPE_PRECISION (ta) > TYPE_PRECISION (tb))\n+    return signed_type_for (ta);\n+  else\n+    return signed_type_for (tb);\n+}\n+\n /* Applies operation OP on affine functions FNA and FNB, and returns the\n    result.  */\n \n@@ -958,18 +970,23 @@ affine_fn_op (enum tree_code op, affine_fn fna, affine_fn fnb)\n \n   ret = VEC_alloc (tree, heap, m);\n   for (i = 0; i < n; i++)\n-    VEC_quick_push (tree, ret,\n-\t\t    fold_build2 (op, long_integer_type_node,\n-\t\t\t\t VEC_index (tree, fna, i), \n-\t\t\t\t VEC_index (tree, fnb, i)));\n+    {\n+      tree type = signed_type_for_types (TREE_TYPE (VEC_index (tree, fna, i)),\n+\t\t\t\t\t TREE_TYPE (VEC_index (tree, fnb, i)));\n+\n+      VEC_quick_push (tree, ret,\n+\t\t      fold_build2 (op, type,\n+\t\t\t\t   VEC_index (tree, fna, i), \n+\t\t\t\t   VEC_index (tree, fnb, i)));\n+    }\n \n   for (; VEC_iterate (tree, fna, i, coef); i++)\n     VEC_quick_push (tree, ret,\n-\t\t    fold_build2 (op, long_integer_type_node,\n+\t\t    fold_build2 (op, signed_type_for (TREE_TYPE (coef)),\n \t\t\t\t coef, integer_zero_node));\n   for (; VEC_iterate (tree, fnb, i, coef); i++)\n     VEC_quick_push (tree, ret,\n-\t\t    fold_build2 (op, long_integer_type_node,\n+\t\t    fold_build2 (op, signed_type_for (TREE_TYPE (coef)),\n \t\t\t\t integer_zero_node, coef));\n \n   return ret;\n@@ -1484,15 +1501,16 @@ analyze_ziv_subscript (tree chrec_a,\n \t\t       conflict_function **overlaps_b, \n \t\t       tree *last_conflicts)\n {\n-  tree difference;\n+  tree type, difference;\n   dependence_stats.num_ziv++;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_ziv_subscript \\n\");\n-  \n-  chrec_a = chrec_convert (long_integer_type_node, chrec_a, NULL_TREE);\n-  chrec_b = chrec_convert (long_integer_type_node, chrec_b, NULL_TREE);\n-  difference = chrec_fold_minus (long_integer_type_node, chrec_a, chrec_b);\n+\n+  type = signed_type_for_types (TREE_TYPE (chrec_a), TREE_TYPE (chrec_b));\n+  chrec_a = chrec_convert (type, chrec_a, NULL_TREE);\n+  chrec_b = chrec_convert (type, chrec_b, NULL_TREE);\n+  difference = chrec_fold_minus (type, chrec_a, chrec_b);\n   \n   switch (TREE_CODE (difference))\n     {\n@@ -1618,12 +1636,12 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t\t\t  tree *last_conflicts)\n {\n   bool value0, value1, value2;\n-  tree difference, tmp;\n+  tree type, difference, tmp;\n \n-  chrec_a = chrec_convert (long_integer_type_node, chrec_a, NULL_TREE);\n-  chrec_b = chrec_convert (long_integer_type_node, chrec_b, NULL_TREE);\n-  difference = chrec_fold_minus \n-    (long_integer_type_node, initial_condition (chrec_b), chrec_a);\n+  type = signed_type_for_types (TREE_TYPE (chrec_a), TREE_TYPE (chrec_b));\n+  chrec_a = chrec_convert (type, chrec_a, NULL_TREE);\n+  chrec_b = chrec_convert (type, chrec_b, NULL_TREE);\n+  difference = chrec_fold_minus (type, initial_condition (chrec_b), chrec_a);\n   \n   if (!chrec_is_positive (initial_condition (difference), &value0))\n     {\n@@ -1666,10 +1684,8 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      struct loop *loop = get_chrec_loop (chrec_b);\n \n \t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n-\t\t      tmp = fold_build2 (EXACT_DIV_EXPR, long_integer_type_node,\n-\t\t\t\t\t fold_build1 (ABS_EXPR,\n-\t\t\t\t\t\t      long_integer_type_node,\n-\t\t\t\t\t\t      difference),\n+\t\t      tmp = fold_build2 (EXACT_DIV_EXPR, type,\n+\t\t\t\t\t fold_build1 (ABS_EXPR, type, difference),\n \t\t\t\t\t CHREC_RIGHT (chrec_b));\n \t\t      *overlaps_b = conflict_fn (1, affine_fn_cst (tmp));\n \t\t      *last_conflicts = integer_one_node;\n@@ -1748,8 +1764,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      struct loop *loop = get_chrec_loop (chrec_b);\n \n \t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n-\t\t      tmp = fold_build2 (EXACT_DIV_EXPR,\n-\t\t\t\t\t long_integer_type_node, difference, \n+\t\t      tmp = fold_build2 (EXACT_DIV_EXPR, type, difference,\n \t\t\t\t\t CHREC_RIGHT (chrec_b));\n \t\t      *overlaps_b = conflict_fn (1, affine_fn_cst (tmp));\n \t\t      *last_conflicts = integer_one_node;\n@@ -2445,14 +2460,16 @@ analyze_miv_subscript (tree chrec_a,\n      variables.  In the MIV case we have to solve a Diophantine\n      equation with 2*n variables (if the subscript uses n IVs).\n   */\n-  tree difference;\n+  tree type, difference;\n+\n   dependence_stats.num_miv++;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_miv_subscript \\n\");\n \n-  chrec_a = chrec_convert (long_integer_type_node, chrec_a, NULL_TREE);\n-  chrec_b = chrec_convert (long_integer_type_node, chrec_b, NULL_TREE);\n-  difference = chrec_fold_minus (long_integer_type_node, chrec_a, chrec_b);\n+  type = signed_type_for_types (TREE_TYPE (chrec_a), TREE_TYPE (chrec_b));\n+  chrec_a = chrec_convert (type, chrec_a, NULL_TREE);\n+  chrec_b = chrec_convert (type, chrec_b, NULL_TREE);\n+  difference = chrec_fold_minus (type, chrec_a, chrec_b);\n   \n   if (eq_evolutions_p (chrec_a, chrec_b))\n     {\n@@ -3400,9 +3417,11 @@ omega_setup_subscript (tree access_fun_a, tree access_fun_b,\n \t\t       omega_pb pb, bool *maybe_dependent)\n {\n   int eq;\n-  tree fun_a = chrec_convert (long_integer_type_node, access_fun_a, NULL_TREE);\n-  tree fun_b = chrec_convert (long_integer_type_node, access_fun_b, NULL_TREE);\n-  tree difference = chrec_fold_minus (long_integer_type_node, fun_a, fun_b);\n+  tree type = signed_type_for_types (TREE_TYPE (access_fun_a),\n+\t\t\t\t     TREE_TYPE (access_fun_b));\n+  tree fun_a = chrec_convert (type, access_fun_a, NULL_TREE);\n+  tree fun_b = chrec_convert (type, access_fun_b, NULL_TREE);\n+  tree difference = chrec_fold_minus (type, fun_a, fun_b);\n \n   /* When the fun_a - fun_b is not constant, the dependence is not\n      captured by the classic distance vector representation.  */\n@@ -3417,8 +3436,7 @@ omega_setup_subscript (tree access_fun_a, tree access_fun_b,\n       return true;\n     }\n \n-  fun_b = chrec_fold_multiply (long_integer_type_node, fun_b, \n-\t\t\t       integer_minus_one_node);\n+  fun_b = chrec_fold_multiply (type, fun_b, integer_minus_one_node);\n \n   eq = omega_add_zero_eq (pb, omega_black);\n   if (!init_omega_eq_with_af (pb, eq, DDR_NB_LOOPS (ddr), fun_a, ddr)"}]}