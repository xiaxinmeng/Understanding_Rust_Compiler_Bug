{"sha": "29b747611f60e5aa30b43734ac3bdd5745b09ea4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjliNzQ3NjExZjYwZTVhYTMwYjQzNzM0YWMzYmRkNTc0NWIwOWVhNA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2007-10-11T17:51:01Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-10-11T17:51:01Z"}, "message": "i386.md (AX_REG, [...]): New constants.\n\n        * config/i386/i386.md (AX_REG, BX_REG, CX_REG): New constants.\n        * config/i386/i386.c (ix86_function_arg_regno_p, function_arg_32,\n        function_value_32, function_value_64, function_value_ms_64,\n        setup_incoming_varargs_64, ix86_expand_prologue, ix86_expand_call,\n        legitimize_tls_address, x86_this_parameter, x86_output_mi_thunk):\n        Use new constants.\n\nFrom-SVN: r129236", "tree": {"sha": "fcb106ac414a3b7a203a6b0ce0bf16a60d9c8671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcb106ac414a3b7a203a6b0ce0bf16a60d9c8671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29b747611f60e5aa30b43734ac3bdd5745b09ea4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b747611f60e5aa30b43734ac3bdd5745b09ea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29b747611f60e5aa30b43734ac3bdd5745b09ea4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b747611f60e5aa30b43734ac3bdd5745b09ea4/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cd7218dee0033f29c3f447ba9851358d523093b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cd7218dee0033f29c3f447ba9851358d523093b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cd7218dee0033f29c3f447ba9851358d523093b"}], "stats": {"total": 69, "additions": 40, "deletions": 29}, "files": [{"sha": "589d957e0fb19f6c0d9140770d6e186f98626e63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b747611f60e5aa30b43734ac3bdd5745b09ea4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b747611f60e5aa30b43734ac3bdd5745b09ea4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29b747611f60e5aa30b43734ac3bdd5745b09ea4", "patch": "@@ -1,3 +1,12 @@\n+2007-10-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (AX_REG, BX_REG, CX_REG): New constants.\n+\t* config/i386/i386.c (ix86_function_arg_regno_p, function_arg_32,\n+\tfunction_value_32, function_value_64, function_value_ms_64,\n+\tsetup_incoming_varargs_64, ix86_expand_prologue, ix86_expand_call,\n+\tlegitimize_tls_address, x86_this_parameter, x86_output_mi_thunk):\n+\tUse new constants.\n+\n 2007-10-11  Richard Guenther  <rguenther@suse.de>\n \n \t* gcse.c (hash_scan_set): If the next nonnote insn is in"}, {"sha": "ce699addb8bbaa09c1a6de36ced2c4e8f6307d64", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b747611f60e5aa30b43734ac3bdd5745b09ea4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b747611f60e5aa30b43734ac3bdd5745b09ea4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=29b747611f60e5aa30b43734ac3bdd5745b09ea4", "patch": "@@ -3361,7 +3361,7 @@ ix86_function_arg_regno_p (int regno)\n     }\n \n   /* RAX is used as hidden argument to va_arg functions.  */\n-  if (!TARGET_64BIT_MS_ABI && regno == 0)\n+  if (!TARGET_64BIT_MS_ABI && regno == AX_REG)\n     return true;\n \n   if (TARGET_64BIT_MS_ABI)\n@@ -4236,8 +4236,8 @@ function_arg_32 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t        break;\n \n \t      /* ECX not EAX is the first allocated register.  */\n-\t      if (regno == 0)\n-\t\tregno = 2;\n+\t      if (regno == AX_REG)\n+\t\tregno = CX_REG;\n \t    }\n \t  return gen_rtx_REG (mode, regno);\n \t}\n@@ -4558,7 +4558,7 @@ function_value_32 (enum machine_mode orig_mode, enum machine_mode mode,\n     regno = FIRST_FLOAT_REG;\n   else\n     /* Most things go in %eax.  */\n-    regno = 0;\n+    regno = AX_REG;\n \n   /* Override FP return register with %xmm0 for local functions when\n      SSE math is enabled or for functions with sseregparm attribute.  */\n@@ -4599,7 +4599,7 @@ function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n \tcase TCmode:\n \t  return NULL;\n \tdefault:\n-\t  return gen_rtx_REG (mode, 0);\n+\t  return gen_rtx_REG (mode, AX_REG);\n \t}\n     }\n \n@@ -4610,15 +4610,15 @@ function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n   /* For zero sized structures, construct_container returns NULL, but we\n      need to keep rest of compiler happy by returning meaningful value.  */\n   if (!ret)\n-    ret = gen_rtx_REG (orig_mode, 0);\n+    ret = gen_rtx_REG (orig_mode, AX_REG);\n \n   return ret;\n }\n \n static rtx\n function_value_ms_64 (enum machine_mode orig_mode, enum machine_mode mode)\n {\n-  unsigned int regno = 0;\n+  unsigned int regno = AX_REG;\n \n   if (TARGET_SSE)\n     {\n@@ -4928,7 +4928,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n          label - 5*eax + nnamed_sse_arguments*5  */\n       tmp_reg = gen_reg_rtx (Pmode);\n       nsse_reg = gen_reg_rtx (Pmode);\n-      emit_insn (gen_zero_extendqidi2 (nsse_reg, gen_rtx_REG (QImode, 0)));\n+      emit_insn (gen_zero_extendqidi2 (nsse_reg, gen_rtx_REG (QImode, AX_REG)));\n       emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n \t\t\t      gen_rtx_MULT (Pmode, nsse_reg,\n \t\t\t\t\t    GEN_INT (4))));\n@@ -6174,7 +6174,7 @@ ix86_internal_arg_pointer (void)\n \t\t   ix86_force_align_arg_pointer_string);\n \t  return virtual_incoming_args_rtx;\n \t}\n-      cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, 2);\n+      cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, CX_REG);\n       return copy_to_reg (cfun->machine->force_align_arg_pointer);\n     }\n   else\n@@ -6297,7 +6297,7 @@ ix86_expand_prologue (void)\n   else\n     {\n       /* Only valid for Win32.  */\n-      rtx eax = gen_rtx_REG (Pmode, 0);\n+      rtx eax = gen_rtx_REG (Pmode, AX_REG);\n       bool eax_live;\n       rtx t;\n \n@@ -6368,8 +6368,7 @@ ix86_expand_prologue (void)\n \t{\n \t  if (ix86_cmodel == CM_LARGE_PIC)\n \t    {\n-              rtx tmp_reg = gen_rtx_REG (DImode,\n-\t\t\t\t\t FIRST_REX_INT_REG + 3 /* R11 */);\n+              rtx tmp_reg = gen_rtx_REG (DImode, R11_REG);\n \t      rtx label = gen_label_rtx ();\n \t      emit_label (label);\n \t      LABEL_PRESERVE_P (label) = 1;\n@@ -6582,7 +6581,7 @@ ix86_expand_epilogue (int style)\n \n       if (current_function_pops_args >= 65536)\n \t{\n-\t  rtx ecx = gen_rtx_REG (SImode, 2);\n+\t  rtx ecx = gen_rtx_REG (SImode, CX_REG);\n \n \t  /* There is no \"pascal\" calling convention in any 64bit ABI.  */\n \t  gcc_assert (!TARGET_64BIT);\n@@ -7645,7 +7644,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \n       if (TARGET_64BIT && ! TARGET_GNU2_TLS)\n \t{\n-\t  rtx rax = gen_rtx_REG (Pmode, 0), insns;\n+\t  rtx rax = gen_rtx_REG (Pmode, AX_REG), insns;\n \n \t  start_sequence ();\n \t  emit_call_insn (gen_tls_global_dynamic_64 (rax, x));\n@@ -7674,7 +7673,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \n       if (TARGET_64BIT && ! TARGET_GNU2_TLS)\n \t{\n-\t  rtx rax = gen_rtx_REG (Pmode, 0), insns, note;\n+\t  rtx rax = gen_rtx_REG (Pmode, AX_REG), insns, note;\n \n \t  start_sequence ();\n \t  emit_call_insn (gen_tls_local_dynamic_base_64 (rax));\n@@ -16057,7 +16056,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \n   if (TARGET_64BIT && INTVAL (callarg2) >= 0)\n     {\n-      rtx al = gen_rtx_REG (QImode, 0);\n+      rtx al = gen_rtx_REG (QImode, AX_REG);\n       emit_move_insn (al, callarg2);\n       use_reg (&use, al);\n     }\n@@ -22545,9 +22544,9 @@ x86_this_parameter (tree function)\n \n   if (ix86_function_regparm (type, function) > 0 && !stdarg_p (type))\n     {\n-      int regno = 0;\n+      int regno = AX_REG;\n       if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n-\tregno = 2;\n+\tregno = CX_REG;\n       return gen_rtx_REG (SImode, regno);\n     }\n \n@@ -22604,7 +22603,7 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n     {\n       /* Put the this parameter into %eax.  */\n       xops[0] = this_param;\n-      xops[1] = this_reg = gen_rtx_REG (Pmode, 0);\n+      xops[1] = this_reg = gen_rtx_REG (Pmode, AX_REG);\n       output_asm_insn (\"mov{l}\\t{%0, %1|%1, %0}\", xops);\n     }\n   else\n@@ -22638,10 +22637,10 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \ttmp = gen_rtx_REG (DImode, R10_REG);\n       else\n \t{\n-\t  int tmp_regno = 2 /* ECX */;\n+\t  int tmp_regno = CX_REG;\n \t  if (lookup_attribute (\"fastcall\",\n \t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (function))))\n-\t    tmp_regno = 0 /* EAX */;\n+\t    tmp_regno = AX_REG;\n \t  tmp = gen_rtx_REG (SImode, tmp_regno);\n \t}\n \n@@ -22714,7 +22713,7 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \telse\n #endif /* TARGET_MACHO */\n \t{\n-\t  tmp = gen_rtx_REG (SImode, 2 /* ECX */);\n+\t  tmp = gen_rtx_REG (SImode, CX_REG);\n \t  output_set_got (tmp, NULL_RTX);\n \n \t  xops[1] = tmp;"}, {"sha": "cf79389a981f95f83ba0348dfcc646aa595bd57f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b747611f60e5aa30b43734ac3bdd5745b09ea4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b747611f60e5aa30b43734ac3bdd5745b09ea4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=29b747611f60e5aa30b43734ac3bdd5745b09ea4", "patch": "@@ -219,7 +219,10 @@\n \n ;; Registers by name.\n (define_constants\n-  [(BP_REG\t\t\t 6)\n+  [(AX_REG\t\t\t 0)\n+   (DX_REG\t\t\t 1)\n+   (CX_REG\t\t\t 2)\n+   (BP_REG\t\t\t 6)\n    (SP_REG\t\t\t 7)\n    (FLAGS_REG\t\t\t17)\n    (FPSR_REG\t\t\t18)\n@@ -3714,8 +3717,8 @@\n \n   /* Generate a cltd if possible and doing so it profitable.  */\n   if ((optimize_size || TARGET_USE_CLTD)\n-      && true_regnum (operands[1]) == 0\n-      && true_regnum (operands[2]) == 1)\n+      && true_regnum (operands[1]) == AX_REG\n+      && true_regnum (operands[2]) == DX_REG)\n     {\n       emit_insn (gen_ashrsi3_31 (operands[2], operands[1], GEN_INT (31)));\n     }\n@@ -3745,7 +3748,7 @@\n \n   /* Generate a cltd if possible and doing so it profitable.  */\n   if ((optimize_size || TARGET_USE_CLTD)\n-      && true_regnum (operands[3]) == 0)\n+      && true_regnum (operands[3]) == AX_REG)\n     {\n       emit_insn (gen_ashrsi3_31 (operands[4], operands[3], GEN_INT (31)));\n       DONE;\n@@ -20422,7 +20425,7 @@\n \t\t   (match_operand:SI 3 \"immediate_operand\" \"\"))\n \t   (const_int 0)]))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && (true_regnum (operands[2]) != 0\n+   && (true_regnum (operands[2]) != AX_REG\n        || satisfies_constraint_K (operands[3]))\n    && peep2_reg_dead_p (1, operands[2])\"\n   [(parallel\n@@ -20444,7 +20447,7 @@\n \t   (const_int 0)]))]\n   \"! TARGET_PARTIAL_REG_STALL\n    && ix86_match_ccmode (insn, CCNOmode)\n-   && true_regnum (operands[2]) != 0\n+   && true_regnum (operands[2]) != AX_REG\n    && peep2_reg_dead_p (1, operands[2])\"\n   [(parallel\n      [(set (match_dup 0)\n@@ -20466,7 +20469,7 @@\n \t   (const_int 0)]))]\n   \"! TARGET_PARTIAL_REG_STALL\n    && ix86_match_ccmode (insn, CCNOmode)\n-   && true_regnum (operands[2]) != 0\n+   && true_regnum (operands[2]) != AX_REG\n    && peep2_reg_dead_p (1, operands[2])\"\n   [(parallel [(set (match_dup 0)\n \t\t   (match_op_dup 1"}]}