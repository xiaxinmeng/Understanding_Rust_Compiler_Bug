{"sha": "9b0986f8589f13684a6899875f8c73f42aab775a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIwOTg2Zjg1ODlmMTM2ODRhNjg5OTg3NWY4YzczZjQyYWFiNzc1YQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:10:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:10:11Z"}, "message": "sem_util.ads, [...] (Enter_Name): Exclude -gnatwh warning messages for entities in packages which are not used.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n        \n        * sem_util.ads, sem_util.adb (Enter_Name): Exclude -gnatwh warning\n\tmessages for entities in packages which are not used.\n\t(Collect_Synchronized_Interfaces): New procedure.\n\t(Overrides_Synchronized_Primitive): New function.\n\t(Denotes_Discriminant): Extend predicate to apply to task types.\n\tAdd missing continuation marks in error msgs\n\t(Unqualify): New function for removing zero or more levels of\n\tqualification from an expression. There are numerous places where this\n\tought to be used, but we currently only deal properly with zero or one\n\tlevel.\n\t(In_Instance); The analysis of the actuals in the instantiation of a\n\tchild unit is not within an instantiation, even though the parent\n\tinstance is on the scope stack.\n\t(Safe_To_Capture_Value): Exclude the case of variables that are\n\trenamings.\n\t(Check_Obsolescent): Removed\n\t(Is_Aliased_View): A reference to an enclosing instance in an aggregate\n\tis an aliased view, even when rewritten as a reference to the target\n\tobject in an assignment.\n\t(Get_Subprogram_Entity): New function\n\t(Known_To_Be_Assigned): New function\n\t(Type_Access_Level): Compute properly the access level of a return\n\tsubtype that is an anonymous access type.\n\t(Explain_Limited_Type): Correct use of \"\\\" for continuation messages.\n\t(Is_Transfer): The new extended_return_statement causes a transfer of\n\tcontrol.\n\t(Has_Preelaborable_Initialization): New function\n\t(Has_Null_Exclusion): New function. Given a node N, determine whether it\n\thas a null exclusion depending on its Nkind.\n\tChange Is_Lvalue to May_Be_Lvalue\n\t(May_Be_Lvalue): Extensive additional code to deal with subprogram\n\targuments (IN parameters are not Lvalues, IN OUT parameters are).\n\t(Safe_To_Capture_Value): Extend functionality so it can be used for\n\tthe current value condition case.\n\t(Has_Compatible_Alignment): New function\n\t(Is_Dependent_Component_Of_Mutable_Object): Revise the tests for mutable\n\tobjects to handle the Ada 2005 case, where aliasedness no longer implies\n\tthat the object is constrained. In particular, for dereferenced names,\n\tthe designated object must be assumed to be unconstrained.\n\t(Kill_Current_Values): Properly deal with the case where we encounter\n\ta loop in the scope chain.\n\t(Safe_To_Capture_Value): Do not let a loop stop us from capturing\n\ta value.\n\t(Compile_Time_Constraint_Error): Improve error message in error case\n\n\t* exp_ch13.adb (Expand_N_Freeze_Entity): Remove the freezing node\n\tassociated with entities of abstract interface primitives.\n\tCall Apply_Address_Clause_Check instead of Apply_Alignment_Check\n\nFrom-SVN: r118312", "tree": {"sha": "1ab2574211b34dd8c350e9a371fcdd68bd7f7965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ab2574211b34dd8c350e9a371fcdd68bd7f7965"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b0986f8589f13684a6899875f8c73f42aab775a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0986f8589f13684a6899875f8c73f42aab775a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b0986f8589f13684a6899875f8c73f42aab775a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0986f8589f13684a6899875f8c73f42aab775a/comments", "author": null, "committer": null, "parents": [{"sha": "60573ca25ab315e4825a035ef67d59a23e645b52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60573ca25ab315e4825a035ef67d59a23e645b52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60573ca25ab315e4825a035ef67d59a23e645b52"}], "stats": {"total": 2276, "additions": 1868, "deletions": 408}, "files": [{"sha": "258a60cd036438300442619a088cb3e3b6478ff6", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0986f8589f13684a6899875f8c73f42aab775a/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0986f8589f13684a6899875f8c73f42aab775a/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=9b0986f8589f13684a6899875f8c73f42aab775a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,15 +81,14 @@ package body Exp_Ch13 is\n \n          when Attribute_Address =>\n \n-            --  If there is an initialization which did not come from\n-            --  the source program, then it is an artifact of our\n-            --  expansion, and we suppress it. The case we are most\n-            --  concerned about here is the initialization of a packed\n-            --  array to all false, which seems inappropriate for a\n-            --  variable to which an address clause is applied. The\n-            --  expression may itself have been rewritten if the type is a\n-            --  packed array, so we need to examine whether the original\n-            --  node is in the source.\n+            --  If there is an initialization which did not come from the\n+            --  source program, then it is an artifact of our expansion, and we\n+            --  suppress it. The case we are most concerned about here is the\n+            --  initialization of a packed array to all false, which seems\n+            --  inappropriate for variable to which an address clause is\n+            --  applied. The expression may itself have been rewritten if the\n+            --  type is packed array, so we need to examine whether the\n+            --  original node is in the source.\n \n             declare\n                Decl : constant Node_Id := Declaration_Node (Ent);\n@@ -139,7 +138,6 @@ package body Exp_Ch13 is\n             --  assignment statement to initialze this value.\n \n             elsif Is_Access_Type (Ent) then\n-\n                V := Make_Defining_Identifier (Loc,\n                       New_External_Name (Chars (Ent), 'V'));\n \n@@ -246,13 +244,14 @@ package body Exp_Ch13 is\n       Delete         : Boolean := False;\n \n    begin\n-      --  For object, with address clause, check alignment is OK\n+      --  Processing for objects with address clauses\n \n-      if Is_Object (E) then\n-         Apply_Alignment_Check (E, N);\n+      if Is_Object (E) and then Present (Address_Clause (E)) then\n+         Apply_Address_Clause_Check (E, N);\n+         return;\n \n-      --  Only other items requiring any front end action are\n-      --  types and subprograms.\n+      --  Only other items requiring any front end action are types and\n+      --  subprograms.\n \n       elsif not Is_Type (E) and then not Is_Subprogram (E) then\n          return;\n@@ -268,12 +267,12 @@ package body Exp_Ch13 is\n          return;\n       end if;\n \n-      --  If we are freezing entities defined in protected types, they\n-      --  belong in the enclosing scope, given that the original type\n-      --  has been expanded away. The same is true for entities in task types,\n-      --  in particular the parameter records of entries (Entities in bodies\n-      --  are all frozen within the body). If we are in the task body, this\n-      --  is a proper scope.\n+      --  If we are freezing entities defined in protected types, they belong\n+      --  in the enclosing scope, given that the original type has been\n+      --  expanded away. The same is true for entities in task types, in\n+      --  particular the parameter records of entries (Entities in bodies are\n+      --  all frozen within the body). If we are in the task body, this is a\n+      --  proper scope.\n \n       if Ekind (E_Scope) = E_Protected_Type\n         or else (Ekind (E_Scope) = E_Task_Type\n@@ -349,19 +348,26 @@ package body Exp_Ch13 is\n \n       elsif Is_Subprogram (E) then\n          Freeze_Subprogram (N);\n+\n+         --  Ada 2005 (AI-251): Remove the freezing node associated with the\n+         --  entities internally used by the frontend to register primitives\n+         --  covering abstract interfaces. The call to Freeze_Subprogram has\n+         --  already expanded the code that fills the corresponding entry in\n+         --  its secondary dispatch table and therefore the code generator\n+         --  has nothing else to do with this freezing node.\n+\n+         Delete := Present (Abstract_Interface_Alias (E));\n       end if;\n \n-      --  Analyze actions generated by freezing. The init_proc contains\n-      --  source expressions that may raise constraint_error, and the\n-      --  assignment procedure for complex types needs checks on individual\n-      --  component assignments, but all other freezing actions should be\n-      --  compiled with all checks off.\n+      --  Analyze actions generated by freezing. The init_proc contains source\n+      --  expressions that may raise Constraint_Error, and the assignment\n+      --  procedure for complex types needs checks on individual component\n+      --  assignments, but all other freezing actions should be compiled with\n+      --  all checks off.\n \n       if Present (Actions (N)) then\n          Decl := First (Actions (N));\n-\n          while Present (Decl) loop\n-\n             if Nkind (Decl) = N_Subprogram_Body\n               and then (Is_Init_Proc (Defining_Entity (Decl))\n                           or else"}, {"sha": "96378f66961f8dd45b5803a9f58130d451c15736", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1710, "deletions": 349, "changes": 2059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0986f8589f13684a6899875f8c73f42aab775a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0986f8589f13684a6899875f8c73f42aab775a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9b0986f8589f13684a6899875f8c73f42aab775a", "patch": "@@ -41,8 +41,6 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Output;   use Output;\n with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Scans;    use Scans;\n with Scn;      use Scn;\n@@ -172,8 +170,6 @@ package body Sem_Util is\n      (T : Entity_Id;\n       N : Node_Or_Entity_Id) return Node_Id\n    is\n-      Obj : Node_Id;\n-\n       Loc         : constant Source_Ptr := Sloc (N);\n       Constraints : List_Id;\n       Decl        : Node_Id;\n@@ -182,6 +178,7 @@ package body Sem_Util is\n       Lo          : Node_Id;\n       Subt        : Entity_Id;\n       Disc_Type   : Entity_Id;\n+      Obj         : Node_Id;\n \n    begin\n       if Nkind (N) = N_Defining_Identifier then\n@@ -192,13 +189,12 @@ package body Sem_Util is\n \n       if Is_Array_Type (T) then\n          Constraints := New_List;\n-\n          for J in 1 .. Number_Dimensions (T) loop\n \n-            --  Build an array subtype declaration with the nominal\n-            --  subtype and the bounds of the actual. Add the declaration\n-            --  in front of the local declarations for the subprogram, for\n-            --  analysis before any reference to the formal in the body.\n+            --  Build an array subtype declaration with the nominal subtype and\n+            --  the bounds of the actual. Add the declaration in front of the\n+            --  local declarations for the subprogram, for analysis before any\n+            --  reference to the formal in the body.\n \n             Lo :=\n               Make_Attribute_Reference (Loc,\n@@ -240,7 +236,6 @@ package body Sem_Util is\n          end if;\n \n          Discr := First_Discriminant (Disc_Type);\n-\n          while Present (Discr) loop\n             Append_To (Constraints,\n               Make_Selected_Component (Loc,\n@@ -363,7 +358,6 @@ package body Sem_Util is\n       begin\n          D := First_Elmt (Discriminant_Constraint (Deaccessed_T));\n          while Present (D) loop\n-\n             if Denotes_Discriminant (Node (D)) then\n                D_Val :=  Make_Selected_Component (Loc,\n                  Prefix => New_Copy_Tree (P),\n@@ -417,7 +411,6 @@ package body Sem_Util is\n \n       if Ekind (Deaccessed_T) = E_Array_Subtype then\n          Id := First_Index (Deaccessed_T);\n-\n          while Present (Id) loop\n             Indx_Type := Underlying_Type (Etype (Id));\n \n@@ -439,7 +432,6 @@ package body Sem_Util is\n       then\n          D := First_Elmt (Discriminant_Constraint (Deaccessed_T));\n          while Present (D) loop\n-\n             if Denotes_Discriminant (Node (D)) then\n                Remove_Side_Effects (P);\n                return\n@@ -494,6 +486,59 @@ package body Sem_Util is\n       return Decl;\n    end Build_Component_Subtype;\n \n+   ---------------------------\n+   -- Build_Default_Subtype --\n+   ---------------------------\n+\n+   function Build_Default_Subtype\n+     (T : Entity_Id;\n+      N : Node_Id) return Entity_Id\n+   is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Disc : Entity_Id;\n+\n+   begin\n+      if not Has_Discriminants (T) or else Is_Constrained (T) then\n+         return T;\n+      end if;\n+\n+      Disc := First_Discriminant (T);\n+\n+      if No (Discriminant_Default_Value (Disc)) then\n+         return T;\n+      end if;\n+\n+      declare\n+         Act : constant Entity_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('S'));\n+\n+         Constraints : constant List_Id := New_List;\n+         Decl        : Node_Id;\n+\n+      begin\n+         while Present (Disc) loop\n+            Append_To (Constraints,\n+              New_Copy_Tree (Discriminant_Default_Value (Disc)));\n+            Next_Discriminant (Disc);\n+         end loop;\n+\n+         Decl :=\n+           Make_Subtype_Declaration (Loc,\n+             Defining_Identifier => Act,\n+             Subtype_Indication =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark => New_Occurrence_Of (T, Loc),\n+                 Constraint =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     Constraints => Constraints)));\n+\n+         Insert_Action (N, Decl);\n+         Analyze (Decl);\n+         return Act;\n+      end;\n+   end Build_Default_Subtype;\n+\n    --------------------------------------------\n    -- Build_Discriminal_Subtype_Of_Component --\n    --------------------------------------------\n@@ -585,7 +630,6 @@ package body Sem_Util is\n    begin\n       if Ekind (T) = E_Array_Subtype then\n          Id := First_Index (T);\n-\n          while Present (Id) loop\n             if Denotes_Discriminant (Type_Low_Bound  (Etype (Id))) or else\n                Denotes_Discriminant (Type_High_Bound (Etype (Id)))\n@@ -684,11 +728,13 @@ package body Sem_Util is\n       Append_To (Declarations (Aux_Decls_Node (N)), Decl);\n       Analyze (Decl);\n \n-      --  Reset True_Constant indication, since we will indeed\n-      --  assign a value to the variable in the binder main.\n+      --  Reset True_Constant indication, since we will indeed assign a value\n+      --  to the variable in the binder main. We also kill the Current_Value\n+      --  and Last_Assignment fields for the same reason.\n \n       Set_Is_True_Constant (Elab_Ent, False);\n       Set_Current_Value    (Elab_Ent, Empty);\n+      Set_Last_Assignment  (Elab_Ent, Empty);\n \n       --  We do not want any further qualification of the name (if we did\n       --  not do this, we would pick up the name of the generic package\n@@ -733,9 +779,10 @@ package body Sem_Util is\n \n                else\n                   declare\n-                     N : Node_Id := First (Expressions (Expr));\n+                     N : Node_Id;\n \n                   begin\n+                     N := First (Expressions (Expr));\n                      while Present (N) loop\n                         if Cannot_Raise_Constraint_Error (N) then\n                            Next (N);\n@@ -865,52 +912,6 @@ package body Sem_Util is\n       end if;\n    end Check_Fully_Declared;\n \n-   -----------------------\n-   -- Check_Obsolescent --\n-   -----------------------\n-\n-   procedure Check_Obsolescent (Nam : Entity_Id; N : Node_Id) is\n-      W : Node_Id;\n-\n-   begin\n-      --  Note that we always allow obsolescent references in the compiler\n-      --  itself and the run time, since we assume that we know what we are\n-      --  doing in such cases. For example the calls in Ada.Characters.Handling\n-      --  to its own obsolescent subprograms are just fine.\n-\n-      if Is_Obsolescent (Nam) and then not GNAT_Mode then\n-         Check_Restriction (No_Obsolescent_Features, N);\n-\n-         if Warn_On_Obsolescent_Feature then\n-            if Is_Package_Or_Generic_Package (Nam) then\n-               Error_Msg_NE (\"with of obsolescent package&?\", N, Nam);\n-            else\n-               Error_Msg_NE (\"call to obsolescent subprogram&?\", N, Nam);\n-            end if;\n-\n-            --  Output additional warning if present\n-\n-            W := Obsolescent_Warning (Nam);\n-\n-            if Present (W) then\n-               Name_Buffer (1) := '|';\n-               Name_Buffer (2) := '?';\n-               Name_Len := 2;\n-\n-               --  Add characters to message, and output message\n-\n-               for J in 1 .. String_Length (Strval (W)) loop\n-                  Add_Char_To_Name_Buffer (''');\n-                  Add_Char_To_Name_Buffer\n-                    (Get_Character (Get_String_Char (Strval (W), J)));\n-               end loop;\n-\n-               Error_Msg_N (Name_Buffer (1 .. Name_Len), N);\n-            end if;\n-         end if;\n-      end if;\n-   end Check_Obsolescent;\n-\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------\n@@ -954,6 +955,153 @@ package body Sem_Util is\n       end if;\n    end Check_VMS;\n \n+   ---------------------------------\n+   -- Collect_Abstract_Interfaces --\n+   ---------------------------------\n+\n+   procedure Collect_Abstract_Interfaces\n+     (T                         : Entity_Id;\n+      Ifaces_List               : out Elist_Id;\n+      Exclude_Parent_Interfaces : Boolean := False)\n+   is\n+      procedure Add_Interface (Iface : Entity_Id);\n+      --  Add the interface it if is not already in the list\n+\n+      procedure Collect (Typ : Entity_Id);\n+      --  Subsidiary subprogram used to traverse the whole list\n+      --  of directly and indirectly implemented interfaces\n+\n+      -------------------\n+      -- Add_Interface --\n+      -------------------\n+\n+      procedure Add_Interface (Iface : Entity_Id) is\n+         Elmt : Elmt_Id;\n+\n+      begin\n+         Elmt := First_Elmt (Ifaces_List);\n+         while Present (Elmt) and then Node (Elmt) /= Iface loop\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         if No (Elmt) then\n+            Append_Elmt (Iface, Ifaces_List);\n+         end if;\n+      end Add_Interface;\n+\n+      -------------\n+      -- Collect --\n+      -------------\n+\n+      procedure Collect (Typ : Entity_Id) is\n+         Ancestor : Entity_Id;\n+         Id       : Node_Id;\n+         Iface    : Entity_Id;\n+         Nod      : Node_Id;\n+\n+      begin\n+         if Ekind (Typ) = E_Record_Type_With_Private then\n+            if Nkind (Parent (Typ)) = N_Full_Type_Declaration then\n+               Nod := Type_Definition (Parent (Typ));\n+\n+            elsif Nkind (Parent (Typ)) = N_Private_Type_Declaration then\n+               if Present (Full_View (Typ)) then\n+                  Nod := Type_Definition (Parent (Full_View (Typ)));\n+\n+               --  If the full-view is not available we cannot do anything\n+               --  else here (the source has errors)\n+\n+               else\n+                  return;\n+               end if;\n+\n+            --  The support for generic formals with interfaces is still\n+            --  missing???\n+\n+            elsif Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n+               return;\n+\n+            else\n+               pragma Assert\n+                 (Nkind (Parent (Typ)) = N_Private_Extension_Declaration);\n+               Nod := Parent (Typ);\n+            end if;\n+\n+         elsif Ekind (Typ) = E_Record_Subtype then\n+            Nod := Type_Definition (Parent (Etype (Typ)));\n+\n+         else pragma Assert ((Ekind (Typ)) = E_Record_Type);\n+            if Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n+               Nod := Formal_Type_Definition (Parent (Typ));\n+            else\n+               Nod := Type_Definition (Parent (Typ));\n+            end if;\n+         end if;\n+\n+         --  Include the ancestor if we are generating the whole list of\n+         --  abstract interfaces.\n+\n+         if Etype (Typ) /= Typ\n+\n+            --  Protect the frontend against wrong sources. For example:\n+\n+            --    package P is\n+            --      type A is tagged null record;\n+            --      type B is new A with private;\n+            --      type C is new A with private;\n+            --    private\n+            --      type B is new C with null record;\n+            --      type C is new B with null record;\n+            --    end P;\n+\n+           and then Etype (Typ) /= T\n+         then\n+            Ancestor := Etype (Typ);\n+            Collect (Ancestor);\n+\n+            if Is_Interface (Ancestor)\n+              and then not Exclude_Parent_Interfaces\n+            then\n+               Add_Interface (Ancestor);\n+            end if;\n+         end if;\n+\n+         --  Traverse the graph of ancestor interfaces\n+\n+         if Is_Non_Empty_List (Interface_List (Nod)) then\n+            Id := First (Interface_List (Nod));\n+            while Present (Id) loop\n+               Iface := Etype (Id);\n+\n+               --  Protect against wrong uses. For example:\n+               --    type I is interface;\n+               --    type O is tagged null record;\n+               --    type Wrong is new I and O with null record; -- ERROR\n+\n+               if Is_Interface (Iface) then\n+                  if Exclude_Parent_Interfaces\n+                    and then Interface_Present_In_Ancestor (T, Iface)\n+                  then\n+                     null;\n+                  else\n+                     Collect       (Iface);\n+                     Add_Interface (Iface);\n+                  end if;\n+               end if;\n+\n+               Next (Id);\n+            end loop;\n+         end if;\n+      end Collect;\n+\n+   --  Start of processing for Collect_Abstract_Interfaces\n+\n+   begin\n+      pragma Assert (Is_Tagged_Type (T));\n+      Ifaces_List := New_Elmt_List;\n+      Collect (T);\n+   end Collect_Abstract_Interfaces;\n+\n    ----------------------------------\n    -- Collect_Primitive_Operations --\n    ----------------------------------\n@@ -1088,6 +1236,92 @@ package body Sem_Util is\n       return Op_List;\n    end Collect_Primitive_Operations;\n \n+   -------------------------------------\n+   -- Collect_Synchronized_Interfaces --\n+   -------------------------------------\n+\n+   procedure Collect_Synchronized_Interfaces\n+     (Typ         : Entity_Id;\n+      Ifaces_List : out Elist_Id)\n+   is\n+      Iface : Entity_Id;\n+\n+      procedure Collect (Typ : Entity_Id);\n+      --  Gather any parent or progenitor interfaces of type Typ\n+\n+      -------------\n+      -- Collect --\n+      -------------\n+\n+      procedure Collect (Typ : Entity_Id) is\n+         Iface_Elmt : Elmt_Id;\n+\n+         procedure Add (Iface : Entity_Id);\n+         --  Add a single interface to list Ifaces if the interface is\n+         --  not already in the list.\n+\n+         ---------\n+         -- Add --\n+         ---------\n+\n+         procedure Add (Iface : Entity_Id) is\n+            Iface_Elmt : Elmt_Id;\n+\n+         begin\n+            Iface_Elmt := First_Elmt (Ifaces_List);\n+            while Present (Iface_Elmt)\n+              and then Node (Iface_Elmt) /= Iface\n+            loop\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+\n+            if No (Iface_Elmt) then\n+               Append_Elmt (Iface, Ifaces_List);\n+            end if;\n+         end Add;\n+\n+      --  Start of processing for Collect\n+\n+      begin\n+         if Is_Interface (Typ) then\n+\n+            --  Potential parent interface\n+\n+            if Etype (Typ) /= Typ then\n+               Collect (Etype (Typ));\n+            end if;\n+\n+            --  Progenitors\n+\n+            if Present (Abstract_Interfaces (Typ)) then\n+               Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+               while Present (Iface_Elmt) loop\n+                  Collect (Node (Iface_Elmt));\n+                  Next_Elmt (Iface_Elmt);\n+               end loop;\n+            end if;\n+\n+            Add (Typ);\n+         end if;\n+      end Collect;\n+\n+   --  Start of processing for Collect_Synchronized_Interfaces\n+\n+   begin\n+      pragma Assert (Is_Concurrent_Type (Typ));\n+\n+      Ifaces_List := New_Elmt_List;\n+\n+      if Present (Interface_List (Parent (Typ))) then\n+         Iface := First (Interface_List (Parent (Typ)));\n+         while Present (Iface) loop\n+            Collect (Etype (Iface));\n+\n+            Next (Iface);\n+         end loop;\n+      end if;\n+   end Collect_Synchronized_Interfaces;\n+\n    -----------------------------------\n    -- Compile_Time_Constraint_Error --\n    -----------------------------------\n@@ -1097,7 +1331,7 @@ package body Sem_Util is\n       Msg  : String;\n       Ent  : Entity_Id  := Empty;\n       Loc  : Source_Ptr := No_Location;\n-      Warn : Boolean  := False) return Node_Id\n+      Warn : Boolean    := False) return Node_Id\n    is\n       Msgc : String (1 .. Msg'Length + 2);\n       Msgl : Natural;\n@@ -1130,7 +1364,7 @@ package body Sem_Util is\n \n          --  Message is a warning, even in Ada 95 case\n \n-         if Msg (Msg'Length) = '?' then\n+         if Msg (Msg'Last) = '?' then\n             Wmsg := True;\n \n          --  In Ada 83, all messages are warnings. In the private part and\n@@ -1247,10 +1481,11 @@ package body Sem_Util is\n                     (\"\\?& will be raised at run time\",\n                      N, Standard_Constraint_Error, Eloc);\n                end if;\n+\n             else\n-               Error_Msg_NEL\n-                 (\"\\static expression raises&!\",\n-                  N, Standard_Constraint_Error, Eloc);\n+               Error_Msg\n+                 (\"\\static expression fails Constraint_Check\", Eloc);\n+               Set_Error_Posted (N);\n             end if;\n          end if;\n       end if;\n@@ -1295,7 +1530,6 @@ package body Sem_Util is\n \n    begin\n       E := Get_Name_Entity_Id (Chars (N));\n-\n       while Present (E)\n         and then Scope (E) /= CS\n         and then (not Transient_Case or else Scope (E) /= Scope (CS))\n@@ -1455,8 +1689,8 @@ package body Sem_Util is\n    --------------------------\n \n    function Denotes_Discriminant\n-     (N               : Node_Id;\n-      Check_Protected : Boolean := False) return Boolean\n+     (N                : Node_Id;\n+      Check_Concurrent : Boolean := False) return Boolean\n    is\n       E : Entity_Id;\n    begin\n@@ -1475,11 +1709,11 @@ package body Sem_Util is\n \n       return Ekind (E) = E_Discriminant\n         or else\n-          (Check_Protected\n+          (Check_Concurrent\n             and then Ekind (E) = E_In_Parameter\n             and then Present (Discriminal_Link (E))\n             and then\n-              (Is_Protected_Type (Scope (Discriminal_Link (E)))\n+              (Is_Concurrent_Type (Scope (Discriminal_Link (E)))\n                 or else\n                   Is_Concurrent_Record_Type (Scope (Discriminal_Link (E)))));\n \n@@ -1658,12 +1892,13 @@ package body Sem_Util is\n    -------------------------------\n \n    function Enclosing_Lib_Unit_Entity return Entity_Id is\n-      Unit_Entity : Entity_Id := Current_Scope;\n+      Unit_Entity : Entity_Id;\n \n    begin\n       --  Look for enclosing library unit entity by following scope links.\n       --  Equivalent to, but faster than indexing through the scope stack.\n \n+      Unit_Entity := Current_Scope;\n       while (Present (Scope (Unit_Entity))\n         and then Scope (Unit_Entity) /= Standard_Standard)\n         and not Is_Child_Unit (Unit_Entity)\n@@ -1679,9 +1914,10 @@ package body Sem_Util is\n    -----------------------------\n \n    function Enclosing_Lib_Unit_Node (N : Node_Id) return Node_Id is\n-      Current_Node : Node_Id := N;\n+      Current_Node : Node_Id;\n \n    begin\n+      Current_Node := N;\n       while Present (Current_Node)\n         and then Nkind (Current_Node) /= N_Compilation_Unit\n       loop\n@@ -1837,7 +2073,6 @@ package body Sem_Util is\n                --  entity in the scope.\n \n                Prev := First_Entity (Current_Scope);\n-\n                while Present (Prev)\n                  and then Next_Entity (Prev) /= E\n                loop\n@@ -2049,12 +2284,29 @@ package body Sem_Util is\n \n       --  Warn if new entity hides an old one\n \n-      if Warn_On_Hiding\n-        and then Present (C)\n-        and then Length_Of_Name (Chars (C)) /= 1\n-        and then Comes_From_Source (C)\n-        and then Comes_From_Source (Def_Id)\n-        and then In_Extended_Main_Source_Unit (Def_Id)\n+      if Warn_On_Hiding and then Present (C)\n+\n+         --  Don't warn for one character variables. It is too common to use\n+         --  such variables as locals and will just cause too many false hits.\n+\n+         and then Length_Of_Name (Chars (C)) /= 1\n+\n+         --  Don't warn for non-source eneities\n+\n+         and then Comes_From_Source (C)\n+         and then Comes_From_Source (Def_Id)\n+\n+         --  Don't warn unless entity in question is in extended main source\n+\n+         and then In_Extended_Main_Source_Unit (Def_Id)\n+\n+         --  Finally, the hidden entity must be either immediately visible\n+         --  or use visible (from a used package)\n+\n+         and then\n+           (Is_Immediately_Visible (C)\n+              or else\n+            Is_Potentially_Use_Visible (C))\n       then\n          Error_Msg_Sloc := Sloc (C);\n          Error_Msg_N (\"declaration hides &#?\", Def_Id);\n@@ -2074,7 +2326,7 @@ package body Sem_Util is\n       if Is_Array_Type (T) then\n          Error_Msg_Node_2 := T;\n          Error_Msg_NE\n-           (\"component type& of type& is limited\", N, Component_Type (T));\n+           (\"\\component type& of type& is limited\", N, Component_Type (T));\n          Explain_Limited_Type (Component_Type (T), N);\n \n       elsif Is_Record_Type (T) then\n@@ -2177,7 +2429,6 @@ package body Sem_Util is\n       Search : loop\n          if Nkind (Alt) /= N_Pragma then\n             Choice := First (Discrete_Choices (Alt));\n-\n             while Present (Choice) loop\n \n                --  Others choice, always matches\n@@ -2406,7 +2657,6 @@ package body Sem_Util is\n               and then Is_Derived_Type (Typ)\n               and then Present (Stored_Constraint (Typ))\n             then\n-\n                --  If the type is a tagged type with inherited discriminants,\n                --  use the stored constraint on the parent in order to find\n                --  the values of discriminants that are otherwise hidden by an\n@@ -2426,16 +2676,13 @@ package body Sem_Util is\n                begin\n                   D := First_Discriminant (Etype (Typ));\n                   C := First_Elmt (Stored_Constraint (Typ));\n-\n-                  while Present (D)\n-                    and then Present (C)\n-                  loop\n+                  while Present (D) and then Present (C) loop\n                      if Chars (Discrim_Name) = Chars (D) then\n                         if Is_Entity_Name (Node (C))\n                           and then Entity (Node (C)) = Entity (Discrim)\n                         then\n-                           --  D is renamed by Discrim, whose value is\n-                           --  given in Assoc.\n+                           --  D is renamed by Discrim, whose value is given in\n+                           --  Assoc.\n \n                            null;\n \n@@ -2449,7 +2696,7 @@ package body Sem_Util is\n                         exit Find_Constraint;\n                      end if;\n \n-                     D := Next_Discriminant (D);\n+                     Next_Discriminant (D);\n                      Next_Elmt (C);\n                   end loop;\n                end;\n@@ -2804,14 +3051,55 @@ package body Sem_Util is\n       return Entity_Id (Get_Name_Table_Info (Id));\n    end Get_Name_Entity_Id;\n \n+   ---------------------------\n+   -- Get_Subprogram_Entity --\n+   ---------------------------\n+\n+   function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id is\n+      Nam  : Node_Id;\n+      Proc : Entity_Id;\n+\n+   begin\n+      if Nkind (Nod) = N_Accept_Statement then\n+         Nam := Entry_Direct_Name (Nod);\n+      else\n+         Nam := Name (Nod);\n+      end if;\n+\n+      if Nkind (Nam) = N_Explicit_Dereference then\n+         Proc := Etype (Prefix (Nam));\n+      elsif Is_Entity_Name (Nam) then\n+         Proc := Entity (Nam);\n+      else\n+         return Empty;\n+      end if;\n+\n+      if Is_Object (Proc) then\n+         Proc := Etype (Proc);\n+      end if;\n+\n+      if Ekind (Proc) = E_Access_Subprogram_Type then\n+         Proc := Directly_Designated_Type (Proc);\n+      end if;\n+\n+      if not Is_Subprogram (Proc)\n+        and then Ekind (Proc) /= E_Subprogram_Type\n+      then\n+         return Empty;\n+      else\n+         return Proc;\n+      end if;\n+   end Get_Subprogram_Entity;\n+\n    ---------------------------\n    -- Get_Referenced_Object --\n    ---------------------------\n \n    function Get_Referenced_Object (N : Node_Id) return Node_Id is\n-      R   : Node_Id := N;\n+      R : Node_Id;\n \n    begin\n+      R := N;\n       while Is_Entity_Name (R)\n         and then Present (Renamed_Object (Entity (R)))\n       loop\n@@ -2862,9 +3150,64 @@ package body Sem_Util is\n       --  and the procedure that holds the body of the task is held in its\n       --  underlying type.\n \n+      --  This is an odd function, why not have Task_Body_Procedure do\n+      --  the following digging???\n+\n       return Task_Body_Procedure (Underlying_Type (Root_Type (E)));\n    end Get_Task_Body_Procedure;\n \n+   -----------------------------\n+   -- Has_Abstract_Interfaces --\n+   -----------------------------\n+\n+   function Has_Abstract_Interfaces (Tagged_Type : Entity_Id) return Boolean is\n+      Typ : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Record_Type (Tagged_Type)\n+         and then Is_Tagged_Type (Tagged_Type));\n+\n+      --  Handle private types\n+\n+      if Present (Full_View (Tagged_Type)) then\n+         Typ := Full_View (Tagged_Type);\n+      else\n+         Typ := Tagged_Type;\n+      end if;\n+\n+      loop\n+         if Is_Interface (Typ)\n+           or else (Present (Abstract_Interfaces (Typ))\n+                      and then\n+                        not Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n+         then\n+            return True;\n+         end if;\n+\n+         exit when Etype (Typ) = Typ\n+\n+            --  Handle private types\n+\n+            or else (Present (Full_View (Etype (Typ)))\n+                       and then Full_View (Etype (Typ)) = Typ)\n+\n+            --  Protect the frontend against wrong source with cyclic\n+            --  derivations\n+\n+            or else Etype (Typ) = Tagged_Type;\n+\n+         --  Climb to the ancestor type handling private types\n+\n+         if Present (Full_View (Etype (Typ))) then\n+            Typ := Full_View (Etype (Typ));\n+         else\n+            Typ := Etype (Typ);\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Has_Abstract_Interfaces;\n+\n    -----------------------\n    -- Has_Access_Values --\n    -----------------------\n@@ -2914,48 +3257,372 @@ package body Sem_Util is\n       end if;\n    end Has_Access_Values;\n \n-   ----------------------\n-   -- Has_Declarations --\n-   ----------------------\n+   ------------------------------\n+   -- Has_Compatible_Alignment --\n+   ------------------------------\n \n-   function Has_Declarations (N : Node_Id) return Boolean is\n-      K : constant Node_Kind := Nkind (N);\n-   begin\n-      return    K = N_Accept_Statement\n-        or else K = N_Block_Statement\n-        or else K = N_Compilation_Unit_Aux\n-        or else K = N_Entry_Body\n-        or else K = N_Package_Body\n-        or else K = N_Protected_Body\n-        or else K = N_Subprogram_Body\n-        or else K = N_Task_Body\n-        or else K = N_Package_Specification;\n-   end Has_Declarations;\n+   function Has_Compatible_Alignment\n+     (Obj  : Entity_Id;\n+      Expr : Node_Id) return Alignment_Result\n+   is\n+      function Has_Compatible_Alignment_Internal\n+        (Obj     : Entity_Id;\n+         Expr    : Node_Id;\n+         Default : Alignment_Result) return Alignment_Result;\n+      --  This is the internal recursive function that actually does the work.\n+      --  There is one additional parameter, which says what the result should\n+      --  be if no alignment information is found, and there is no definite\n+      --  indication of compatible alignments. At the outer level, this is set\n+      --  to Unknown, but for internal recursive calls in the case where types\n+      --  are known to be correct, it is set to Known_Compatible.\n+\n+      ---------------------------------------\n+      -- Has_Compatible_Alignment_Internal --\n+      ---------------------------------------\n+\n+      function Has_Compatible_Alignment_Internal\n+        (Obj     : Entity_Id;\n+         Expr    : Node_Id;\n+         Default : Alignment_Result) return Alignment_Result\n+      is\n+         Result : Alignment_Result := Known_Compatible;\n+         --  Set to result if Problem_Prefix or Problem_Offset returns True.\n+         --  Note that once a value of Known_Incompatible is set, it is sticky\n+         --  and does not get changed to Unknown (the value in Result only gets\n+         --  worse as we go along, never better).\n+\n+         procedure Check_Offset (Offs : Uint);\n+         --  Called when Expr is a selected or indexed component with Offs set\n+         --  to resp Component_First_Bit or Component_Size. Checks that if the\n+         --  offset is specified it is compatible with the object alignment\n+         --  requirements. The value in Result is modified accordingly.\n+\n+         procedure Check_Prefix;\n+         --  Checks the prefix recursively in the case where the expression\n+         --  is an indexed or selected component.\n+\n+         procedure Set_Result (R : Alignment_Result);\n+         --  If R represents a worse outcome (unknown instead of known\n+         --  compatible, or known incompatible), then set Result to R.\n+\n+         ------------------\n+         -- Check_Offset --\n+         ------------------\n+\n+         procedure Check_Offset (Offs : Uint) is\n+         begin\n+            --  Unspecified or zero offset is always OK\n \n-   -------------------------------------------\n-   -- Has_Discriminant_Dependent_Constraint --\n-   -------------------------------------------\n+            if Offs = No_Uint or else Offs = Uint_0 then\n+               null;\n \n-   function Has_Discriminant_Dependent_Constraint\n-     (Comp : Entity_Id) return Boolean\n-   is\n-      Comp_Decl  : constant Node_Id := Parent (Comp);\n-      Subt_Indic : constant Node_Id :=\n-                     Subtype_Indication (Component_Definition (Comp_Decl));\n-      Constr     : Node_Id;\n-      Assn       : Node_Id;\n+            --  If we do not know required alignment, any non-zero offset is\n+            --  a potential problem (but certainly may be OK, so result is\n+            --  unknown).\n \n-   begin\n-      if Nkind (Subt_Indic) = N_Subtype_Indication then\n-         Constr := Constraint (Subt_Indic);\n+            elsif Unknown_Alignment (Obj) then\n+               Set_Result (Unknown);\n \n-         if Nkind (Constr) = N_Index_Or_Discriminant_Constraint then\n-            Assn := First (Constraints (Constr));\n-            while Present (Assn) loop\n-               case Nkind (Assn) is\n-                  when N_Subtype_Indication |\n-                       N_Range              |\n-                       N_Identifier\n+            --  If we know the required alignment, see if offset is compatible\n+\n+            else\n+               if Offs mod (System_Storage_Unit * Alignment (Obj)) /= 0 then\n+                  Set_Result (Known_Incompatible);\n+               end if;\n+            end if;\n+         end Check_Offset;\n+\n+         ------------------\n+         -- Check_Prefix --\n+         ------------------\n+\n+         procedure Check_Prefix is\n+         begin\n+            --  The subtlety here is that in doing a recursive call to check\n+            --  the prefix, we have to decide what to do in the case where we\n+            --  don't find any specific indication of an alignment problem.\n+\n+            --  At the outer level, we normally set Unknown as the result in\n+            --  this case, since we can only set Known_Compatible if we really\n+            --  know that the alignment value is OK, but for the recursive\n+            --  call, in the case where the types match, and we have not\n+            --  specified a peculiar alignment for the object, we are only\n+            --  concerned about suspicious rep clauses, the default case does\n+            --  not affect us, since the compiler will, in the absence of such\n+            --  rep clauses, ensure that the alignment is correct.\n+\n+            if Default = Known_Compatible\n+              or else\n+                (Etype (Obj) = Etype (Expr)\n+                  and then (Unknown_Alignment (Obj)\n+                             or else\n+                               Alignment (Obj) = Alignment (Etype (Obj))))\n+            then\n+               Set_Result\n+                 (Has_Compatible_Alignment_Internal\n+                    (Obj, Prefix (Expr), Known_Compatible));\n+\n+            --  In all other cases, we need a full check on the prefix\n+\n+            else\n+               Set_Result\n+                 (Has_Compatible_Alignment_Internal\n+                    (Obj, Prefix (Expr), Unknown));\n+            end if;\n+         end Check_Prefix;\n+\n+         ----------------\n+         -- Set_Result --\n+         ----------------\n+\n+         procedure Set_Result (R : Alignment_Result) is\n+         begin\n+            if R > Result then\n+               Result := R;\n+            end if;\n+         end Set_Result;\n+\n+      --  Start of processing for Has_Compatible_Alignment_Internal\n+\n+      begin\n+         --  If Expr is a selected component, we must make sure there is no\n+         --  potentially troublesome component clause, and that the record is\n+         --  not packed.\n+\n+         if Nkind (Expr) = N_Selected_Component then\n+\n+            --  Packed record always generate unknown alignment\n+\n+            if Is_Packed (Etype (Prefix (Expr))) then\n+               Set_Result (Unknown);\n+            end if;\n+\n+            --  Check possible bad component offset and check prefix\n+\n+            Check_Offset\n+              (Component_Bit_Offset (Entity (Selector_Name (Expr))));\n+            Check_Prefix;\n+\n+         --  If Expr is an indexed component, we must make sure there is no\n+         --  potentially troublesome Component_Size clause and that the array\n+         --  is not bit-packed.\n+\n+         elsif Nkind (Expr) = N_Indexed_Component then\n+\n+            --  Bit packed array always generates unknown alignment\n+\n+            if Is_Bit_Packed_Array (Etype (Prefix (Expr))) then\n+               Set_Result (Unknown);\n+            end if;\n+\n+            --  Check possible bad component size and check prefix\n+\n+            Check_Offset (Component_Size (Etype (Prefix (Expr))));\n+            Check_Prefix;\n+         end if;\n+\n+         --  Case where we know the alignment of the object\n+\n+         if Known_Alignment (Obj) then\n+            declare\n+               ObjA : constant Uint := Alignment (Obj);\n+               ExpA : Uint := No_Uint;\n+               SizA : Uint := No_Uint;\n+\n+            begin\n+               --  If alignment of Obj is 1, then we are always OK\n+\n+               if ObjA = 1 then\n+                  Set_Result (Known_Compatible);\n+\n+               --  Alignment of Obj is greater than 1, so we need to check\n+\n+               else\n+                  --  See if Expr is an object with known alignment\n+\n+                  if Is_Entity_Name (Expr)\n+                    and then Known_Alignment (Entity (Expr))\n+                  then\n+                     ExpA := Alignment (Entity (Expr));\n+\n+                     --  Otherwise, we can use the alignment of the type of\n+                     --  Expr given that we already checked for\n+                     --  discombobulating rep clauses for the cases of indexed\n+                     --  and selected components above.\n+\n+                  elsif Known_Alignment (Etype (Expr)) then\n+                     ExpA := Alignment (Etype (Expr));\n+                  end if;\n+\n+                  --  If we got an alignment, see if it is acceptable\n+\n+                  if ExpA /= No_Uint then\n+                     if ExpA < ObjA then\n+                        Set_Result (Known_Incompatible);\n+                     end if;\n+\n+                     --  Case of Expr alignment unknown\n+\n+                  else\n+                     Set_Result (Default);\n+                  end if;\n+\n+                  --  See if size is given. If so, check that it is not too\n+                  --  small for the required alignment.\n+                  --  See if Expr is an object with known alignment\n+\n+                  if Is_Entity_Name (Expr)\n+                    and then Known_Static_Esize (Entity (Expr))\n+                  then\n+                     SizA := Esize (Entity (Expr));\n+\n+                     --  Otherwise, we check the object size of the Expr type\n+\n+                  elsif Known_Static_Esize (Etype (Expr)) then\n+                     SizA := Esize (Etype (Expr));\n+                  end if;\n+\n+                  --  If we got a size, see if it is a multiple of the Obj\n+                  --  alignment, if not, then the alignment cannot be\n+                  --  acceptable, since the size is always a multiple of the\n+                  --  alignment.\n+\n+                  if SizA /= No_Uint then\n+                     if SizA mod (ObjA * Ttypes.System_Storage_Unit) /= 0 then\n+                        Set_Result (Known_Incompatible);\n+                     end if;\n+                  end if;\n+               end if;\n+            end;\n+\n+         --  If we can't find the result by direct comparison of alignment\n+         --  values, then there is still one case that we can determine known\n+         --  result, and that is when we can determine that the types are the\n+         --  same, and no alignments are specified. Then we known that the\n+         --  alignments are compatible, even if we don't know the alignment\n+         --  value in the front end.\n+\n+         elsif Etype (Obj) = Etype (Expr) then\n+\n+            --  Types are the same, but we have to check for possible size\n+            --  and alignments on the Expr object that may make the alignment\n+            --  different, even though the types are the same.\n+\n+            if Is_Entity_Name (Expr) then\n+\n+               --  First check alignment of the Expr object. Any alignment less\n+               --  than Maximum_Alignment is worrisome since this is the case\n+               --  where we do not know the alignment of Obj.\n+\n+               if Known_Alignment (Entity (Expr))\n+                 and then\n+                   UI_To_Int (Alignment (Entity (Expr)))\n+                                 < Ttypes.Maximum_Alignment\n+               then\n+                  Set_Result (Unknown);\n+\n+                  --  Now check size of Expr object. Any size that is not an\n+                  --  even multiple of Maxiumum_Alignment is also worrisome\n+                  --  since it may cause the alignment of the object to be less\n+                  --  than the alignment of the type.\n+\n+               elsif Known_Static_Esize (Entity (Expr))\n+                 and then\n+                   (UI_To_Int (Esize (Entity (Expr))) mod\n+                     (Ttypes.Maximum_Alignment * Ttypes.System_Storage_Unit))\n+                         /= 0\n+               then\n+                  Set_Result (Unknown);\n+\n+                  --  Otherwise same type is decisive\n+\n+               else\n+                  Set_Result (Known_Compatible);\n+               end if;\n+            end if;\n+\n+         --  Another case to deal with is when there is an explicit size or\n+         --  alignment clause when the types are not the same. If so, then the\n+         --  result is Unknown. We don't need to do this test if the Default is\n+         --  Unknown, since that result will be set in any case.\n+\n+         elsif Default /= Unknown\n+           and then (Has_Size_Clause (Etype (Expr))\n+                      or else\n+                     Has_Alignment_Clause (Etype (Expr)))\n+         then\n+            Set_Result (Unknown);\n+\n+         --  If no indication found, set default\n+\n+         else\n+            Set_Result (Default);\n+         end if;\n+\n+         --  Return worst result found\n+\n+         return Result;\n+      end Has_Compatible_Alignment_Internal;\n+\n+   --  Start of processing for Has_Compatible_Alignment\n+\n+   begin\n+      --  If Obj has no specified alignment, then set alignment from the type\n+      --  alignment. Perhaps we should always do this, but for sure we should\n+      --  do it when there is an address clause since we can do more if the\n+      --  alignment is known.\n+\n+      if Unknown_Alignment (Obj) then\n+         Set_Alignment (Obj, Alignment (Etype (Obj)));\n+      end if;\n+\n+      --  Now do the internal call that does all the work\n+\n+      return Has_Compatible_Alignment_Internal (Obj, Expr, Unknown);\n+   end Has_Compatible_Alignment;\n+\n+   ----------------------\n+   -- Has_Declarations --\n+   ----------------------\n+\n+   function Has_Declarations (N : Node_Id) return Boolean is\n+      K : constant Node_Kind := Nkind (N);\n+   begin\n+      return    K = N_Accept_Statement\n+        or else K = N_Block_Statement\n+        or else K = N_Compilation_Unit_Aux\n+        or else K = N_Entry_Body\n+        or else K = N_Package_Body\n+        or else K = N_Protected_Body\n+        or else K = N_Subprogram_Body\n+        or else K = N_Task_Body\n+        or else K = N_Package_Specification;\n+   end Has_Declarations;\n+\n+   -------------------------------------------\n+   -- Has_Discriminant_Dependent_Constraint --\n+   -------------------------------------------\n+\n+   function Has_Discriminant_Dependent_Constraint\n+     (Comp : Entity_Id) return Boolean\n+   is\n+      Comp_Decl  : constant Node_Id := Parent (Comp);\n+      Subt_Indic : constant Node_Id :=\n+                     Subtype_Indication (Component_Definition (Comp_Decl));\n+      Constr     : Node_Id;\n+      Assn       : Node_Id;\n+\n+   begin\n+      if Nkind (Subt_Indic) = N_Subtype_Indication then\n+         Constr := Constraint (Subt_Indic);\n+\n+         if Nkind (Constr) = N_Index_Or_Discriminant_Constraint then\n+            Assn := First (Constraints (Constr));\n+            while Present (Assn) loop\n+               case Nkind (Assn) is\n+                  when N_Subtype_Indication |\n+                       N_Range              |\n+                       N_Identifier\n                   =>\n                      if Depends_On_Discriminant (Assn) then\n                         return True;\n@@ -2991,6 +3658,59 @@ package body Sem_Util is\n           and then Includes_Infinities (Scalar_Range (E));\n    end Has_Infinities;\n \n+   ------------------------\n+   -- Has_Null_Exclusion --\n+   ------------------------\n+\n+   function Has_Null_Exclusion (N : Node_Id) return Boolean is\n+   begin\n+      case Nkind (N) is\n+         when N_Access_Definition               |\n+              N_Access_Function_Definition      |\n+              N_Access_Procedure_Definition     |\n+              N_Access_To_Object_Definition     |\n+              N_Allocator                       |\n+              N_Derived_Type_Definition         |\n+              N_Function_Specification          |\n+              N_Subtype_Declaration             =>\n+            return Null_Exclusion_Present (N);\n+\n+         when N_Component_Definition            |\n+              N_Formal_Object_Declaration       |\n+              N_Object_Renaming_Declaration     =>\n+            if Present (Subtype_Mark (N)) then\n+               return Null_Exclusion_Present (N);\n+            else pragma Assert (Present (Access_Definition (N)));\n+               return Null_Exclusion_Present (Access_Definition (N));\n+            end if;\n+\n+         when N_Discriminant_Specification =>\n+            if Nkind (Discriminant_Type (N)) = N_Access_Definition then\n+               return Null_Exclusion_Present (Discriminant_Type (N));\n+            else\n+               return Null_Exclusion_Present (N);\n+            end if;\n+\n+         when N_Object_Declaration =>\n+            if Nkind (Object_Definition (N)) = N_Access_Definition then\n+               return Null_Exclusion_Present (Object_Definition (N));\n+            else\n+               return Null_Exclusion_Present (N);\n+            end if;\n+\n+         when N_Parameter_Specification =>\n+            if Nkind (Parameter_Type (N)) = N_Access_Definition then\n+               return Null_Exclusion_Present (Parameter_Type (N));\n+            else\n+               return Null_Exclusion_Present (N);\n+            end if;\n+\n+         when others =>\n+            return False;\n+\n+      end case;\n+   end Has_Null_Exclusion;\n+\n    ------------------------\n    -- Has_Null_Extension --\n    ------------------------\n@@ -3028,6 +3748,175 @@ package body Sem_Util is\n       end if;\n    end Has_Null_Extension;\n \n+   --------------------------------------\n+   -- Has_Preelaborable_Initialization --\n+   --------------------------------------\n+\n+   function Has_Preelaborable_Initialization (E : Entity_Id) return Boolean is\n+      Has_PE : Boolean;\n+\n+      procedure Check_Components (E : Entity_Id);\n+      --  Check component/discriminant chain, sets Has_PE False if a component\n+      --  or discriminant does not meet the preelaborable initialization rules.\n+\n+      ----------------------\n+      -- Check_Components --\n+      ----------------------\n+\n+      procedure Check_Components (E : Entity_Id) is\n+         Ent : Entity_Id;\n+         Exp : Node_Id;\n+\n+      begin\n+         --  Loop through entities of record or protected type\n+\n+         Ent := E;\n+         while Present (Ent) loop\n+\n+            --  We are interested only in components and discriminants\n+\n+            if Ekind (Ent) = E_Component\n+              or else\n+                Ekind (Ent) = E_Discriminant\n+            then\n+               --  Get default expression if any. If there is no declaration\n+               --  node, it means we have an internal entity. The parent and\n+               --  tag fields are examples of such entitires. For these\n+               --  cases, we just test the type of the entity.\n+\n+               if Present (Declaration_Node (Ent)) then\n+                  Exp := Expression (Declaration_Node (Ent));\n+               else\n+                  Exp := Empty;\n+               end if;\n+\n+               --  A component has PI if it has no default expression and\n+               --  the component type has PI.\n+\n+               if No (Exp) then\n+                  if not Has_Preelaborable_Initialization (Etype (Ent)) then\n+                     Has_PE := False;\n+                     exit;\n+                  end if;\n+\n+                  --  Or if expression obeys rules for preelaboration. For\n+                  --  now we approximate this by testing if the default\n+                  --  expression is a static expression or if it is an\n+                  --  access attribute reference.\n+\n+                  --  This is an approximation, it is probably incomplete???\n+\n+               elsif Is_Static_Expression (Exp) then\n+                  null;\n+\n+               elsif Nkind (Exp) = N_Attribute_Reference\n+                 and then (Attribute_Name (Exp) = Name_Access\n+                           or else\n+                           Attribute_Name (Exp) = Name_Unchecked_Access\n+                           or else\n+                           Attribute_Name (Exp) = Name_Unrestricted_Access)\n+               then\n+                  null;\n+\n+               else\n+                  Has_PE := False;\n+                  exit;\n+               end if;\n+            end if;\n+\n+            Next_Entity (Ent);\n+         end loop;\n+      end Check_Components;\n+\n+   --  Start of processing for Has_Preelaborable_Initialization\n+\n+   begin\n+      --  Immediate return if already marked as known preelaborable init\n+\n+      if Known_To_Have_Preelab_Init (E) then\n+         return True;\n+      end if;\n+\n+      --  All elementary types have preelaborable initialization\n+\n+      if Is_Elementary_Type (E) then\n+         Has_PE := True;\n+\n+      --  Array types have PI if the component type has PI\n+\n+      elsif Is_Array_Type (E) then\n+         Has_PE := Has_Preelaborable_Initialization (Component_Type (E));\n+\n+      --  Record types have PI if all components have PI\n+\n+      elsif Is_Record_Type (E) then\n+         Has_PE := True;\n+         Check_Components (First_Entity (E));\n+\n+         --  Another check here, if this is a controlled type, see if it has a\n+         --  user defined Initialize procedure. If so, then there is a special\n+         --  rule that means this type does not have PI.\n+\n+         if Is_Controlled (E)\n+           and then Present (Primitive_Operations (E))\n+         then\n+            declare\n+               P : Elmt_Id;\n+\n+            begin\n+               P := First_Elmt (Primitive_Operations (E));\n+               while Present (P) loop\n+                  if Chars (Node (P)) = Name_Initialize\n+                    and then Comes_From_Source (Node (P))\n+                  then\n+                     Has_PE := False;\n+                     exit;\n+                  end if;\n+\n+                  Next_Elmt (P);\n+               end loop;\n+            end;\n+         end if;\n+\n+      --  Protected types, must not have entries, and components must meet\n+      --  same set of rules as for record components.\n+\n+      elsif Is_Protected_Type (E) then\n+         if Has_Entries (E) then\n+            Has_PE := False;\n+         else\n+            Has_PE := True;\n+            Check_Components (First_Entity (E));\n+            Check_Components (First_Private_Entity (E));\n+         end if;\n+\n+      --  A derived type has preelaborable initialization if its parent type\n+      --  has preelaborable initialization and (in the case of a derived record\n+      --  extension) if the non-inherited components all have preelaborable\n+      --  initialization. However, a user-defined controlled type with an\n+      --  overriding Initialize procedure does not have preelaborable\n+      --  initialization.\n+\n+      --  TBD ???\n+\n+      --  Type System.Address always has preelaborable initialization\n+\n+      elsif Is_RTE (E, RE_Address) then\n+         Has_PE := True;\n+\n+      --  In all other cases, type does not have preelaborable init\n+\n+      else\n+         return False;\n+      end if;\n+\n+      if Has_PE then\n+         Set_Known_To_Have_Preelab_Init (E);\n+      end if;\n+\n+      return Has_PE;\n+   end Has_Preelaborable_Initialization;\n+\n    ---------------------------\n    -- Has_Private_Component --\n    ---------------------------\n@@ -3072,7 +3961,6 @@ package body Sem_Util is\n \n          Component := First_Component (Btype);\n          while Present (Component) loop\n-\n             if Has_Private_Component (Etype (Component)) then\n                return True;\n             end if;\n@@ -3150,7 +4038,6 @@ package body Sem_Util is\n \n       elsif Is_Record_Type (Typ) then\n          Comp := First_Component (Typ);\n-\n          while Present (Comp) loop\n             if Has_Tagged_Component (Etype (Comp)) then\n                return True;\n@@ -3171,9 +4058,11 @@ package body Sem_Util is\n    -----------------\n \n    function In_Instance return Boolean is\n-      S : Entity_Id := Current_Scope;\n+      Curr_Unit : constant Entity_Id := Cunit_Entity (Current_Sem_Unit);\n+      S         : Entity_Id;\n \n    begin\n+      S := Current_Scope;\n       while Present (S)\n         and then S /= Standard_Standard\n       loop\n@@ -3182,7 +4071,23 @@ package body Sem_Util is\n               or else Ekind (S) = E_Procedure)\n            and then Is_Generic_Instance (S)\n          then\n-            return True;\n+\n+            --  A child instance is always compiled in the context of a parent\n+            --  instance. Nevertheless, the actuals are not analyzed in an\n+            --  instance context. We detect this case by examining the current\n+            --  compilation unit, which must be a child instance, and checking\n+            --  that it is not currently on the scope stack.\n+\n+            if Is_Child_Unit (Curr_Unit)\n+              and then\n+                Nkind (Unit (Cunit (Current_Sem_Unit)))\n+                  = N_Package_Instantiation\n+              and then not In_Open_Scopes (Curr_Unit)\n+            then\n+               return False;\n+            else\n+               return True;\n+            end if;\n          end if;\n \n          S := Scope (S);\n@@ -3196,9 +4101,10 @@ package body Sem_Util is\n    ----------------------\n \n    function In_Instance_Body return Boolean is\n-      S : Entity_Id := Current_Scope;\n+      S : Entity_Id;\n \n    begin\n+      S := Current_Scope;\n       while Present (S)\n         and then S /= Standard_Standard\n       loop\n@@ -3226,9 +4132,10 @@ package body Sem_Util is\n    -----------------------------\n \n    function In_Instance_Not_Visible return Boolean is\n-      S : Entity_Id := Current_Scope;\n+      S : Entity_Id;\n \n    begin\n+      S := Current_Scope;\n       while Present (S)\n         and then S /= Standard_Standard\n       loop\n@@ -3256,9 +4163,10 @@ package body Sem_Util is\n    ------------------------------\n \n    function In_Instance_Visible_Part return Boolean is\n-      S : Entity_Id := Current_Scope;\n+      S : Entity_Id;\n \n    begin\n+      S := Current_Scope;\n       while Present (S)\n         and then S /= Standard_Standard\n       loop\n@@ -3281,9 +4189,10 @@ package body Sem_Util is\n    ----------------------\n \n    function In_Package_Body return Boolean is\n-      S : Entity_Id := Current_Scope;\n+      S : Entity_Id;\n \n    begin\n+      S := Current_Scope;\n       while Present (S)\n         and then S /= Standard_Standard\n       loop\n@@ -3366,8 +4275,8 @@ package body Sem_Util is\n          --  designated types of the interpretations of the original node.\n \n          Set_Etype (N, Any_Type);\n-         Get_First_Interp (New_Prefix, I, It);\n \n+         Get_First_Interp (New_Prefix, I, It);\n          while Present (It.Nam) loop\n             T := It.Typ;\n \n@@ -3395,7 +4304,6 @@ package body Sem_Util is\n            or else Nkind (New_Prefix) = N_Indexed_Component\n          then\n             Pref := Prefix (New_Prefix);\n-\n             while Present (Pref)\n               and then\n                 (Nkind (Pref) = N_Selected_Component\n@@ -3478,7 +4386,12 @@ package body Sem_Util is\n                       or else Ekind (E) = E_Protected_Type)\n                     and then In_Open_Scopes (E))\n \n-            --  Current instance of type\n+            --  Current instance of type, either directly or as rewritten\n+            --  reference to the current object.\n+\n+           or else (Is_Entity_Name (Original_Node (Obj))\n+                     and then Present (Entity (Original_Node (Obj)))\n+                     and then Is_Type (Entity (Original_Node (Obj))))\n \n            or else (Is_Type (E) and then E = Current_Scope)\n            or else (Is_Incomplete_Or_Private_Type (E)\n@@ -3700,21 +4613,26 @@ package body Sem_Util is\n \n             --  A heap object is constrained by its initial value\n \n-            --  Ada 2005 AI-363:if the designated type is a type with a\n-            --  constrained partial view, the resulting heap object is not\n-            --  constrained, and a renaming of the component is now unsafe.\n-\n-            if Is_Access_Type (Prefix_Type)\n-              and then\n-                 not Has_Constrained_Partial_View\n-                   (Designated_Type (Prefix_Type))\n-            then\n-               return False;\n+            --  Ada 2005 (AI-363): Always assume the object could be mutable in\n+            --  the dereferenced case, since the access value might denote an\n+            --  unconstrained aliased object, whereas in Ada 95 the designated\n+            --  object is guaranteed to be constrained. A worst-case assumption\n+            --  has to apply in Ada 2005 because we can't tell at compile time\n+            --  whether the object is \"constrained by its initial value\"\n+            --  (despite the fact that 3.10.2(26/2) and 8.5.1(5/2) are\n+            --  semantic rules -- these rules are acknowledged to need fixing).\n+\n+            if Ada_Version < Ada_05 then\n+               if Is_Access_Type (Prefix_Type)\n+                 or else Nkind (P) = N_Explicit_Dereference\n+               then\n+                  return False;\n+               end if;\n \n-            elsif Nkind (P) = N_Explicit_Dereference\n-              and then not Has_Constrained_Partial_View (Prefix_Type)\n-            then\n-               return False;\n+            elsif Ada_Version >= Ada_05 then\n+               if Is_Access_Type (Prefix_Type) then\n+                  Prefix_Type := Designated_Type (Prefix_Type);\n+               end if;\n             end if;\n \n             Comp :=\n@@ -3723,6 +4641,8 @@ package body Sem_Util is\n             --  As per AI-0017, the renaming is illegal in a generic body,\n             --  even if the subtype is indefinite.\n \n+            --  Ada 2005 (AI-363): In Ada 2005 an aliased object can be mutable\n+\n             if not Is_Constrained (Prefix_Type)\n               and then (not Is_Indefinite_Subtype (Prefix_Type)\n                          or else\n@@ -3732,7 +4652,7 @@ package body Sem_Util is\n \n               and then (Is_Declared_Within_Variant (Comp)\n                           or else Has_Discriminant_Dependent_Constraint (Comp))\n-              and then not P_Aliased\n+              and then (not P_Aliased or else Ada_Version >= Ada_05)\n             then\n                return True;\n \n@@ -3911,7 +4831,6 @@ package body Sem_Util is\n             begin\n                Indx := First_Index (Typ);\n                while Present (Indx) loop\n-\n                   if Etype (Indx) = Any_Type then\n                      return False;\n \n@@ -4008,7 +4927,6 @@ package body Sem_Util is\n \n          begin\n             Ent := First_Entity (Typ);\n-\n             while Present (Ent) loop\n                if Chars (Ent) = Name_uController then\n                   null;\n@@ -4075,8 +4993,8 @@ package body Sem_Util is\n         and then Nkind (Type_Definition (Parent (Typ))) = N_Record_Definition\n       then\n          Comp_List := Component_List (Type_Definition (Parent (Typ)));\n-         Discr := First_Discriminant (Typ);\n \n+         Discr := First_Discriminant (Typ);\n          while Present (Discr) loop\n             if Nkind (Parent (Discr)) = N_Discriminant_Specification then\n                Discr_Val := Expression (Parent (Discr));\n@@ -4108,7 +5026,6 @@ package body Sem_Util is\n          --  Check that each component present is fully initialized\n \n          Comp_Elmt := First_Elmt (Components);\n-\n          while Present (Comp_Elmt) loop\n             Comp_Id := Node (Comp_Elmt);\n \n@@ -4202,60 +5119,6 @@ package body Sem_Util is\n       end if;\n    end Is_Local_Variable_Reference;\n \n-   ---------------\n-   -- Is_Lvalue --\n-   ---------------\n-\n-   function Is_Lvalue (N : Node_Id) return Boolean is\n-      P : constant Node_Id := Parent (N);\n-\n-   begin\n-      case Nkind (P) is\n-\n-         --  Test left side of assignment\n-\n-         when N_Assignment_Statement =>\n-            return N = Name (P);\n-\n-         --  Test prefix of component or attribute\n-\n-         when N_Attribute_Reference  |\n-              N_Expanded_Name        |\n-              N_Explicit_Dereference |\n-              N_Indexed_Component    |\n-              N_Reference            |\n-              N_Selected_Component   |\n-              N_Slice                =>\n-            return N = Prefix (P);\n-\n-         --  Test subprogram parameter (we really should check the\n-         --  parameter mode, but it is not worth the trouble)\n-\n-         when N_Function_Call            |\n-              N_Procedure_Call_Statement |\n-              N_Accept_Statement         |\n-              N_Parameter_Association    =>\n-            return True;\n-\n-         --  Test for appearing in a conversion that itself appears\n-         --  in an lvalue context, since this should be an lvalue.\n-\n-         when N_Type_Conversion =>\n-            return Is_Lvalue (P);\n-\n-         --  Test for appearence in object renaming declaration\n-\n-         when N_Object_Renaming_Declaration =>\n-            return True;\n-\n-         --  All other references are definitely not Lvalues\n-\n-         when others =>\n-            return False;\n-\n-      end case;\n-   end Is_Lvalue;\n-\n    -------------------------\n    -- Is_Object_Reference --\n    -------------------------\n@@ -4839,6 +5702,8 @@ package body Sem_Util is\n    begin\n       if Kind = N_Return_Statement\n            or else\n+         Kind = N_Extended_Return_Statement\n+           or else\n          Kind = N_Goto_Statement\n            or else\n          Kind = N_Raise_Statement\n@@ -5107,127 +5972,373 @@ package body Sem_Util is\n          then\n             return True;\n \n-         elsif Nkind (N) = N_Indexed_Component\n-           or else Nkind (N) = N_Selected_Component\n-         then\n-            return Is_Volatile_Prefix (Prefix (N));\n+         elsif Nkind (N) = N_Indexed_Component\n+           or else Nkind (N) = N_Selected_Component\n+         then\n+            return Is_Volatile_Prefix (Prefix (N));\n+\n+         else\n+            return False;\n+         end if;\n+      end Object_Has_Volatile_Components;\n+\n+   --  Start of processing for Is_Volatile_Object\n+\n+   begin\n+      if Is_Volatile (Etype (N))\n+        or else (Is_Entity_Name (N) and then Is_Volatile (Entity (N)))\n+      then\n+         return True;\n+\n+      elsif Nkind (N) = N_Indexed_Component\n+        or else Nkind (N) = N_Selected_Component\n+      then\n+         return Is_Volatile_Prefix (Prefix (N));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Volatile_Object;\n+\n+   -------------------------\n+   -- Kill_Current_Values --\n+   -------------------------\n+\n+   procedure Kill_Current_Values (Ent : Entity_Id) is\n+   begin\n+      if Is_Object (Ent) then\n+         Kill_Checks (Ent);\n+         Set_Current_Value (Ent, Empty);\n+\n+         if Ekind (Ent) = E_Variable then\n+            Set_Last_Assignment (Ent, Empty);\n+         end if;\n+\n+         if not Can_Never_Be_Null (Ent) then\n+            Set_Is_Known_Non_Null (Ent, False);\n+         end if;\n+\n+         Set_Is_Known_Null (Ent, False);\n+      end if;\n+   end Kill_Current_Values;\n+\n+   procedure Kill_Current_Values is\n+      S : Entity_Id;\n+\n+      procedure Kill_Current_Values_For_Entity_Chain (E : Entity_Id);\n+      --  Clear current value for entity E and all entities chained to E\n+\n+      ------------------------------------------\n+      -- Kill_Current_Values_For_Entity_Chain --\n+      ------------------------------------------\n+\n+      procedure Kill_Current_Values_For_Entity_Chain (E : Entity_Id) is\n+         Ent : Entity_Id;\n+      begin\n+         Ent := E;\n+         while Present (Ent) loop\n+            Kill_Current_Values (Ent);\n+            Next_Entity (Ent);\n+         end loop;\n+      end Kill_Current_Values_For_Entity_Chain;\n+\n+   --  Start of processing for Kill_Current_Values\n+\n+   begin\n+      --  Kill all saved checks, a special case of killing saved values\n+\n+      Kill_All_Checks;\n+\n+      --  Loop through relevant scopes, which includes the current scope and\n+      --  any parent scopes if the current scope is a block or a package.\n+\n+      S := Current_Scope;\n+      Scope_Loop : loop\n+\n+         --  Clear current values of all entities in current scope\n+\n+         Kill_Current_Values_For_Entity_Chain (First_Entity (S));\n+\n+         --  If scope is a package, also clear current values of all\n+         --  private entities in the scope.\n+\n+         if Ekind (S) = E_Package\n+              or else\n+            Ekind (S) = E_Generic_Package\n+              or else\n+            Is_Concurrent_Type (S)\n+         then\n+            Kill_Current_Values_For_Entity_Chain (First_Private_Entity (S));\n+         end if;\n+\n+         --  If this is a not a subprogram, deal with parents\n+\n+         if not Is_Subprogram (S) then\n+            S := Scope (S);\n+            exit Scope_Loop when S = Standard_Standard;\n+         else\n+            exit Scope_Loop;\n+         end if;\n+      end loop Scope_Loop;\n+   end Kill_Current_Values;\n+\n+   --------------------------\n+   -- Kill_Size_Check_Code --\n+   --------------------------\n+\n+   procedure Kill_Size_Check_Code (E : Entity_Id) is\n+   begin\n+      if (Ekind (E) = E_Constant or else Ekind (E) = E_Variable)\n+        and then Present (Size_Check_Code (E))\n+      then\n+         Remove (Size_Check_Code (E));\n+         Set_Size_Check_Code (E, Empty);\n+      end if;\n+   end Kill_Size_Check_Code;\n+\n+   --------------------------\n+   -- Known_To_Be_Assigned --\n+   --------------------------\n+\n+   function Known_To_Be_Assigned (N : Node_Id) return Boolean is\n+      P : constant Node_Id := Parent (N);\n+\n+   begin\n+      case Nkind (P) is\n+\n+         --  Test left side of assignment\n+\n+         when N_Assignment_Statement =>\n+            return N = Name (P);\n+\n+            --  Function call arguments are never lvalues\n+\n+         when N_Function_Call =>\n+            return False;\n+\n+         --  Positional parameter for procedure or accept call\n+\n+         when N_Procedure_Call_Statement |\n+              N_Accept_Statement\n+          =>\n+            declare\n+               Proc : Entity_Id;\n+               Form : Entity_Id;\n+               Act  : Node_Id;\n+\n+            begin\n+               Proc := Get_Subprogram_Entity (P);\n+\n+               if No (Proc) then\n+                  return False;\n+               end if;\n+\n+               --  If we are not a list member, something is strange, so\n+               --  be conservative and return False.\n+\n+               if not Is_List_Member (N) then\n+                  return False;\n+               end if;\n+\n+               --  We are going to find the right formal by stepping forward\n+               --  through the formals, as we step backwards in the actuals.\n+\n+               Form := First_Formal (Proc);\n+               Act  := N;\n+               loop\n+                  --  If no formal, something is weird, so be conservative\n+                  --  and return False.\n+\n+                  if No (Form) then\n+                     return False;\n+                  end if;\n+\n+                  Prev (Act);\n+                  exit when No (Act);\n+                  Next_Formal (Form);\n+               end loop;\n+\n+               return Ekind (Form) /= E_In_Parameter;\n+            end;\n+\n+         --  Named parameter for procedure or accept call\n+\n+         when N_Parameter_Association =>\n+            declare\n+               Proc : Entity_Id;\n+               Form : Entity_Id;\n+\n+            begin\n+               Proc := Get_Subprogram_Entity (Parent (P));\n+\n+               if No (Proc) then\n+                  return False;\n+               end if;\n+\n+               --  Loop through formals to find the one that matches\n+\n+               Form := First_Formal (Proc);\n+               loop\n+                  --  If no matching formal, that's peculiar, some kind of\n+                  --  previous error, so return False to be conservative.\n+\n+                  if No (Form) then\n+                     return False;\n+                  end if;\n+\n+                  --  Else test for match\n+\n+                  if Chars (Form) = Chars (Selector_Name (P)) then\n+                     return Ekind (Form) /= E_In_Parameter;\n+                  end if;\n+\n+                  Next_Formal (Form);\n+               end loop;\n+            end;\n+\n+         --  Test for appearing in a conversion that itself appears\n+         --  in an lvalue context, since this should be an lvalue.\n+\n+         when N_Type_Conversion =>\n+            return Known_To_Be_Assigned (P);\n+\n+         --  All other references are definitely not knwon to be modifications\n+\n+         when others =>\n+            return False;\n+\n+      end case;\n+   end Known_To_Be_Assigned;\n+\n+   -------------------\n+   -- May_Be_Lvalue --\n+   -------------------\n+\n+   function May_Be_Lvalue (N : Node_Id) return Boolean is\n+      P : constant Node_Id := Parent (N);\n+\n+   begin\n+      case Nkind (P) is\n+\n+         --  Test left side of assignment\n+\n+         when N_Assignment_Statement =>\n+            return N = Name (P);\n+\n+         --  Test prefix of component or attribute\n+\n+         when N_Attribute_Reference  |\n+              N_Expanded_Name        |\n+              N_Explicit_Dereference |\n+              N_Indexed_Component    |\n+              N_Reference            |\n+              N_Selected_Component   |\n+              N_Slice                =>\n+            return N = Prefix (P);\n+\n+            --  Function call arguments are never lvalues\n \n-         else\n+         when N_Function_Call =>\n             return False;\n-         end if;\n-      end Object_Has_Volatile_Components;\n \n-   --  Start of processing for Is_Volatile_Object\n+         --  Positional parameter for procedure or accept call\n \n-   begin\n-      if Is_Volatile (Etype (N))\n-        or else (Is_Entity_Name (N) and then Is_Volatile (Entity (N)))\n-      then\n-         return True;\n+         when N_Procedure_Call_Statement |\n+              N_Accept_Statement\n+          =>\n+            declare\n+               Proc : Entity_Id;\n+               Form : Entity_Id;\n+               Act  : Node_Id;\n \n-      elsif Nkind (N) = N_Indexed_Component\n-        or else Nkind (N) = N_Selected_Component\n-      then\n-         return Is_Volatile_Prefix (Prefix (N));\n+            begin\n+               Proc := Get_Subprogram_Entity (P);\n \n-      else\n-         return False;\n-      end if;\n-   end Is_Volatile_Object;\n+               if No (Proc) then\n+                  return True;\n+               end if;\n \n-   -------------------------\n-   -- Kill_Current_Values --\n-   -------------------------\n+               --  If we are not a list member, something is strange, so\n+               --  be conservative and return True.\n \n-   procedure Kill_Current_Values (Ent : Entity_Id) is\n-   begin\n-      if Is_Object (Ent) then\n-         Kill_Checks (Ent);\n-         Set_Current_Value (Ent, Empty);\n+               if not Is_List_Member (N) then\n+                  return True;\n+               end if;\n \n-         if not Can_Never_Be_Null (Ent) then\n-            Set_Is_Known_Non_Null (Ent, False);\n-         end if;\n+               --  We are going to find the right formal by stepping forward\n+               --  through the formals, as we step backwards in the actuals.\n \n-         Set_Is_Known_Null (Ent, False);\n-      end if;\n-   end Kill_Current_Values;\n+               Form := First_Formal (Proc);\n+               Act  := N;\n+               loop\n+                  --  If no formal, something is weird, so be conservative\n+                  --  and return True.\n \n-   procedure Kill_Current_Values is\n-      S : Entity_Id;\n+                  if No (Form) then\n+                     return True;\n+                  end if;\n \n-      procedure Kill_Current_Values_For_Entity_Chain (E : Entity_Id);\n-      --  Clear current value for entity E and all entities chained to E\n+                  Prev (Act);\n+                  exit when No (Act);\n+                  Next_Formal (Form);\n+               end loop;\n \n-      ------------------------------------------\n-      -- Kill_Current_Values_For_Entity_Chain --\n-      ------------------------------------------\n+               return Ekind (Form) /= E_In_Parameter;\n+            end;\n \n-      procedure Kill_Current_Values_For_Entity_Chain (E : Entity_Id) is\n-         Ent : Entity_Id;\n-      begin\n-         Ent := E;\n-         while Present (Ent) loop\n-            Kill_Current_Values (Ent);\n-            Next_Entity (Ent);\n-         end loop;\n-      end Kill_Current_Values_For_Entity_Chain;\n+         --  Named parameter for procedure or accept call\n \n-   --  Start of processing for Kill_Current_Values\n+         when N_Parameter_Association =>\n+            declare\n+               Proc : Entity_Id;\n+               Form : Entity_Id;\n \n-   begin\n-      --  Kill all saved checks, a special case of killing saved values\n+            begin\n+               Proc := Get_Subprogram_Entity (Parent (P));\n \n-      Kill_All_Checks;\n+               if No (Proc) then\n+                  return True;\n+               end if;\n \n-      --  Loop through relevant scopes, which includes the current scope and\n-      --  any parent scopes if the current scope is a block or a package.\n+               --  Loop through formals to find the one that matches\n \n-      S := Current_Scope;\n-      Scope_Loop : loop\n+               Form := First_Formal (Proc);\n+               loop\n+                  --  If no matching formal, that's peculiar, some kind of\n+                  --  previous error, so return True to be conservative.\n \n-         --  Clear current values of all entities in current scope\n+                  if No (Form) then\n+                     return True;\n+                  end if;\n \n-         Kill_Current_Values_For_Entity_Chain (First_Entity (S));\n+                  --  Else test for match\n \n-         --  If scope is a package, also clear current values of all\n-         --  private entities in the scope.\n+                  if Chars (Form) = Chars (Selector_Name (P)) then\n+                     return Ekind (Form) /= E_In_Parameter;\n+                  end if;\n \n-         if Ekind (S) = E_Package\n-              or else\n-            Ekind (S) = E_Generic_Package\n-              or else\n-            Is_Concurrent_Type (S)\n-         then\n-            Kill_Current_Values_For_Entity_Chain (First_Private_Entity (S));\n-         end if;\n+                  Next_Formal (Form);\n+               end loop;\n+            end;\n \n-         --  If this is a block or nested package, deal with parent\n+         --  Test for appearing in a conversion that itself appears\n+         --  in an lvalue context, since this should be an lvalue.\n \n-         if Ekind (S) = E_Block\n-           or else (Ekind (S) = E_Package\n-                      and then not Is_Library_Level_Entity (S))\n-         then\n-            S := Scope (S);\n-         else\n-            exit Scope_Loop;\n-         end if;\n-      end loop Scope_Loop;\n-   end Kill_Current_Values;\n+         when N_Type_Conversion =>\n+            return May_Be_Lvalue (P);\n \n-   --------------------------\n-   -- Kill_Size_Check_Code --\n-   --------------------------\n+         --  Test for appearence in object renaming declaration\n \n-   procedure Kill_Size_Check_Code (E : Entity_Id) is\n-   begin\n-      if (Ekind (E) = E_Constant or else Ekind (E) = E_Variable)\n-        and then Present (Size_Check_Code (E))\n-      then\n-         Remove (Size_Check_Code (E));\n-         Set_Size_Check_Code (E, Empty);\n-      end if;\n-   end Kill_Size_Check_Code;\n+         when N_Object_Renaming_Declaration =>\n+            return True;\n+\n+         --  All other references are definitely not Lvalues\n+\n+         when others =>\n+            return False;\n+\n+      end case;\n+   end May_Be_Lvalue;\n \n    -------------------------\n    -- New_External_Entity --\n@@ -5508,7 +6619,6 @@ package body Sem_Util is\n \n             Actual := First_Named;\n             Found  := False;\n-\n             while Present (Actual) loop\n                if Chars (Selector_Name (Actual)) = Chars (Formal) then\n                   Found := True;\n@@ -5589,7 +6699,6 @@ package body Sem_Util is\n             --  attached to the list of associations.\n \n             Actual := First (Actuals);\n-\n             while Present (Actual) loop\n                if Nkind (Actual) = N_Parameter_Association\n                  and then Actual /= Last\n@@ -5736,9 +6845,9 @@ package body Sem_Util is\n       E : Entity_Id;\n \n    --  Returns the static accessibility level of the view denoted\n-   --  by Obj.  Note that the value returned is the result of a\n-   --  call to Scope_Depth.  Only scope depths associated with\n-   --  dynamic scopes can actually be returned.  Since only\n+   --  by Obj. Note that the value returned is the result of a\n+   --  call to Scope_Depth. Only scope depths associated with\n+   --  dynamic scopes can actually be returned. Since only\n    --  relative levels matter for accessibility checking, the fact\n    --  that the distance between successive levels of accessibility\n    --  is not always one is immaterial (invariant: if level(E2) is\n@@ -5839,6 +6948,189 @@ package body Sem_Util is\n       end if;\n    end Object_Access_Level;\n \n+   --------------------------------------\n+   -- Overrides_Synchronized_Primitive --\n+   --------------------------------------\n+\n+   function Overrides_Synchronized_Primitive\n+     (Def_Id      : Entity_Id;\n+      First_Hom   : Entity_Id;\n+      Ifaces_List : Elist_Id;\n+      In_Scope    : Boolean := True) return Entity_Id\n+   is\n+      Candidate : Entity_Id;\n+      Hom       : Entity_Id;\n+\n+      function Matches_Prefixed_View_Profile\n+        (Subp_Params : List_Id;\n+         Over_Params : List_Id) return Boolean;\n+      --  Determine if a subprogram parameter profile (Subp_Params)\n+      --  matches that of a potentially overriden subprogram (Over_Params).\n+      --  Determine if the type of first parameter in the list Over_Params\n+      --  is an implemented interface, that is to say, the interface is in\n+      --  Ifaces_List.\n+\n+      -----------------------------------\n+      -- Matches_Prefixed_View_Profile --\n+      -----------------------------------\n+\n+      function Matches_Prefixed_View_Profile\n+        (Subp_Params : List_Id;\n+         Over_Params : List_Id) return Boolean\n+      is\n+         Subp_Param     : Node_Id;\n+         Over_Param     : Node_Id;\n+         Over_Param_Typ : Entity_Id;\n+\n+         function Is_Implemented (Iface : Entity_Id) return Boolean;\n+         --  Determine if Iface is implemented by the current task or\n+         --  protected type.\n+\n+         --------------------\n+         -- Is_Implemented --\n+         --------------------\n+\n+         function Is_Implemented (Iface : Entity_Id) return Boolean is\n+            Iface_Elmt : Elmt_Id;\n+\n+         begin\n+            Iface_Elmt := First_Elmt (Ifaces_List);\n+            while Present (Iface_Elmt) loop\n+               if Node (Iface_Elmt) = Iface then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+\n+            return False;\n+         end Is_Implemented;\n+\n+      --  Start of processing for Matches_Prefixed_View_Profile\n+\n+      begin\n+         Subp_Param := First (Subp_Params);\n+         Over_Param := First (Over_Params);\n+\n+         if Nkind (Parameter_Type (Over_Param)) = N_Access_Definition then\n+            Over_Param_Typ :=\n+              Etype (Subtype_Mark (Parameter_Type (Over_Param)));\n+         else\n+            Over_Param_Typ := Etype (Parameter_Type (Over_Param));\n+         end if;\n+\n+         --  The first parameter of the potentially overriden subprogram\n+         --  must be an interface implemented by Def_Id.\n+\n+         if not Is_Interface (Over_Param_Typ)\n+           or else not Is_Implemented (Over_Param_Typ)\n+         then\n+            return False;\n+         end if;\n+\n+         --  This may be a primitive declared after a task or protected type.\n+         --  We need to skip the first parameter since it is irrelevant.\n+\n+         if not In_Scope then\n+            Subp_Param := Next (Subp_Param);\n+         end if;\n+         Over_Param := Next (Over_Param);\n+\n+         while Present (Subp_Param) and then Present (Over_Param) loop\n+\n+            --  The two parameters must be mode conformant and both types\n+            --  must be the same.\n+\n+            if Ekind (Defining_Identifier (Subp_Param)) /=\n+                 Ekind (Defining_Identifier (Over_Param))\n+              or else\n+                Etype (Parameter_Type (Subp_Param)) /=\n+                  Etype (Parameter_Type (Over_Param))\n+            then\n+               return False;\n+            end if;\n+\n+            Next (Subp_Param);\n+            Next (Over_Param);\n+         end loop;\n+\n+         --  One of the two lists contains more parameters than the other\n+\n+         if Present (Subp_Param) or else Present (Over_Param) then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Matches_Prefixed_View_Profile;\n+\n+   --  Start of processing for Overrides_Synchronized_Primitive\n+\n+   begin\n+      --  At this point the caller should have collected the interfaces\n+      --  implemented by the synchronized type.\n+\n+      pragma Assert (Present (Ifaces_List));\n+\n+      --  Traverse the homonym chain, looking at a potentially overriden\n+      --  subprogram that belongs to an implemented interface.\n+\n+      Hom := First_Hom;\n+      while Present (Hom) loop\n+         Candidate := Hom;\n+\n+         --  Entries can override abstract or null interface procedures\n+\n+         if Ekind (Def_Id) = E_Entry\n+           and then Ekind (Candidate) = E_Procedure\n+           and then Nkind (Parent (Candidate)) = N_Procedure_Specification\n+           and then (Is_Abstract (Candidate)\n+                       or else Null_Present (Parent (Candidate)))\n+         then\n+            while Present (Alias (Candidate)) loop\n+               Candidate := Alias (Candidate);\n+            end loop;\n+\n+            if Matches_Prefixed_View_Profile\n+                 (Parameter_Specifications (Parent (Def_Id)),\n+                  Parameter_Specifications (Parent (Candidate)))\n+            then\n+               return Candidate;\n+            end if;\n+\n+         --  Procedure can override abstract or null interface procedures\n+\n+         elsif Ekind (Def_Id) = E_Procedure\n+           and then Ekind (Candidate) = E_Procedure\n+           and then Nkind (Parent (Candidate)) = N_Procedure_Specification\n+           and then (Is_Abstract (Candidate)\n+                       or else Null_Present (Parent (Candidate)))\n+           and then Matches_Prefixed_View_Profile\n+                      (Parameter_Specifications (Parent (Def_Id)),\n+                       Parameter_Specifications (Parent (Candidate)))\n+         then\n+            return Candidate;\n+\n+         --  Function can override abstract interface functions\n+\n+         elsif Ekind (Def_Id) = E_Function\n+           and then Ekind (Candidate) = E_Function\n+           and then Nkind (Parent (Candidate)) = N_Function_Specification\n+           and then Is_Abstract (Candidate)\n+           and then Matches_Prefixed_View_Profile\n+                      (Parameter_Specifications (Parent (Def_Id)),\n+                       Parameter_Specifications (Parent (Candidate)))\n+           and then Etype (Result_Definition (Parent (Def_Id))) =\n+                    Etype (Result_Definition (Parent (Candidate)))\n+         then\n+            return Candidate;\n+         end if;\n+\n+         Hom := Homonym (Hom);\n+      end loop;\n+\n+      return Empty;\n+   end Overrides_Synchronized_Primitive;\n+\n    -----------------------\n    -- Private_Component --\n    -----------------------\n@@ -6296,8 +7588,7 @@ package body Sem_Util is\n \n    procedure Reset_Analyzed_Flags (N : Node_Id) is\n \n-      function Clear_Analyzed\n-        (N : Node_Id) return Traverse_Result;\n+      function Clear_Analyzed (N : Node_Id) return Traverse_Result;\n       --  Function used to reset Analyzed flags in tree. Note that we do\n       --  not reset Analyzed flags in entities, since there is no need to\n       --  renalalyze entities, and indeed, it is wrong to do so, since it\n@@ -6307,9 +7598,7 @@ package body Sem_Util is\n       -- Clear_Analyzed --\n       --------------------\n \n-      function Clear_Analyzed\n-        (N : Node_Id) return Traverse_Result\n-      is\n+      function Clear_Analyzed (N : Node_Id) return Traverse_Result is\n       begin\n          if not Has_Extension (N) then\n             Set_Analyzed (N, False);\n@@ -6335,28 +7624,48 @@ package body Sem_Util is\n    ---------------------------\n \n    function Safe_To_Capture_Value\n-     (N   : Node_Id;\n-      Ent : Entity_Id) return Boolean\n+     (N    : Node_Id;\n+      Ent  : Entity_Id;\n+      Cond : Boolean := False) return Boolean\n    is\n    begin\n       --  The only entities for which we track constant values are variables,\n-      --  out parameters and in out parameters, so check if we have this case.\n+      --  which are not renamings, out parameters and in out parameters, so\n+      --  check if we have this case.\n \n-      if Ekind (Ent) /= E_Variable\n-           and then\n-         Ekind (Ent) /= E_Out_Parameter\n-           and then\n-         Ekind (Ent) /= E_In_Out_Parameter\n+      if (Ekind (Ent) = E_Variable and then No (Renamed_Object (Ent)))\n+           or else\n+         Ekind (Ent) = E_Out_Parameter\n+           or else\n+         Ekind (Ent) = E_In_Out_Parameter\n+      then\n+         null;\n+\n+      --  For conditionals, we also allow constants, loop parameters and all\n+      --  formals, including in parameters.\n+\n+      elsif Cond\n+        and then\n+          (Ekind (Ent) = E_Constant\n+             or else\n+           Ekind (Ent) = E_Loop_Parameter\n+             or else\n+           Ekind (Ent) = E_In_Parameter)\n       then\n+         null;\n+\n+      --  For all other cases, not just unsafe, but impossible to capture\n+      --  Current_Value, since the above are the only entities which have\n+      --  Current_Value fields.\n+\n+      else\n          return False;\n       end if;\n \n       --  Skip volatile and aliased variables, since funny things might\n       --  be going on in these cases which we cannot necessarily track.\n       --  Also skip any variable for which an address clause is given.\n \n-      --  Should we have a flag Has_Address_Clause ???\n-\n       if Treat_As_Volatile (Ent)\n         or else Is_Aliased (Ent)\n         or else Present (Address_Clause (Ent))\n@@ -6366,7 +7675,7 @@ package body Sem_Util is\n \n       --  OK, all above conditions are met. We also require that the scope\n       --  of the reference be the same as the scope of the entity, not\n-      --  counting packages and blocks.\n+      --  counting packages and blocks and loops.\n \n       declare\n          E_Scope : constant Entity_Id := Scope (Ent);\n@@ -6378,8 +7687,10 @@ package body Sem_Util is\n             exit when R_Scope = E_Scope;\n \n             if Ekind (R_Scope) /= E_Package\n-                 and then\n-               Ekind (R_Scope) /= E_Block\n+                  and then\n+                Ekind (R_Scope) /= E_Block\n+                  and then\n+                Ekind (R_Scope) /= E_Loop\n             then\n                return False;\n             else\n@@ -6390,15 +7701,21 @@ package body Sem_Util is\n \n       --  We also require that the reference does not appear in a context\n       --  where it is not sure to be executed (i.e. a conditional context\n-      --  or an exception handler).\n+      --  or an exception handler). We skip this if Cond is True, since the\n+      --  capturing of values from conditional tests handles this ok.\n+\n+      if Cond then\n+         return True;\n+      end if;\n \n       declare\n          Desc : Node_Id;\n          P    : Node_Id;\n \n       begin\n          Desc := N;\n-         P    := Parent (N);\n+\n+         P := Parent (N);\n          while Present (P) loop\n             if Nkind (P) = N_If_Statement\n               or else  Nkind (P) = N_Case_Statement\n@@ -6552,10 +7869,8 @@ package body Sem_Util is\n       then\n          if Nkind (N) = N_Identifier then\n             Nod := N;\n-\n          elsif Nkind (N) = N_Expanded_Name then\n             Nod := Selector_Name (N);\n-\n          else\n             return;\n          end if;\n@@ -6797,7 +8112,6 @@ package body Sem_Util is\n \n                declare\n                   Comp : Entity_Id;\n-\n                begin\n                   Comp := First_Entity (Ent);\n                   while Present (Comp) loop\n@@ -6837,7 +8151,26 @@ package body Sem_Util is\n          if Ekind (Btyp) = E_Anonymous_Access_Type\n            and then not Is_Local_Anonymous_Access (Typ) -- Ada 2005 (AI-230)\n          then\n-            return Scope_Depth (Standard_Standard);\n+\n+            --  If this is a return_subtype, the accessibility level is that\n+            --  of the result subtype of the enclosing function.\n+\n+            if Ekind (Scope (Btyp)) = E_Return_Statement then\n+               declare\n+                  Scop : Entity_Id;\n+               begin\n+                  Scop := Scope (Scope (Btyp));\n+                  while Present (Scop) loop\n+                     exit when Ekind (Scop) = E_Function;\n+                     Scop := Scope (Scop);\n+                  end loop;\n+\n+                  return Scope_Depth (Scope (Scop));\n+               end;\n+\n+            else\n+               return Scope_Depth (Standard_Standard);\n+            end if;\n          end if;\n \n          Btyp := Root_Type (Btyp);\n@@ -6846,7 +8179,14 @@ package body Sem_Util is\n          --  discriminants is that of the current instance of the type, and\n          --  that's deeper than the type itself (AARM 3.10.2 (12.3.21)).\n \n-         if Ekind (Typ) = E_Anonymous_Access_Type\n+         --  AI-402: access discriminants have accessibility based on the\n+         --  object rather than the type in Ada2005, so the above\n+         --  paragraph doesn't apply\n+\n+         --  ??? Needs completion with rules from AI-416\n+\n+         if Ada_Version <= Ada_95\n+           and then Ekind (Typ) = E_Anonymous_Access_Type\n            and then Present (Associated_Node_For_Itype (Typ))\n            and then Nkind (Associated_Node_For_Itype (Typ)) =\n                                                  N_Discriminant_Specification\n@@ -6872,6 +8212,8 @@ package body Sem_Util is\n          return N;\n       end if;\n \n+      --  Isn't there some better way to express the following ???\n+\n       while Nkind (N) /= N_Abstract_Subprogram_Declaration\n         and then Nkind (N) /= N_Formal_Package_Declaration\n         and then Nkind (N) /= N_Function_Instantiation\n@@ -6938,6 +8280,24 @@ package body Sem_Util is\n       end if;\n    end Universal_Interpretation;\n \n+   ---------------\n+   -- Unqualify --\n+   ---------------\n+\n+   function Unqualify (Expr : Node_Id) return Node_Id is\n+   begin\n+      --  Recurse to handle unlikely case of multiple levels of qualification\n+\n+      if Nkind (Expr) = N_Qualified_Expression then\n+         return Unqualify (Expression (Expr));\n+\n+      --  Normal case, not a qualified expression\n+\n+      else\n+         return Expr;\n+      end if;\n+   end Unqualify;\n+\n    ----------------------\n    -- Within_Init_Proc --\n    ----------------------\n@@ -7096,11 +8456,11 @@ package body Sem_Util is\n            and then not Comes_From_Source (Found_Type)\n          then\n             Error_Msg_NE\n-              (\"found an access type with designated}!\",\n+              (\"\\\\found an access type with designated}!\",\n                 Expr, Designated_Type (Found_Type));\n          else\n             if From_With_Type (Found_Type) then\n-               Error_Msg_NE (\"found incomplete}!\", Expr, Found_Type);\n+               Error_Msg_NE (\"\\\\found incomplete}!\", Expr, Found_Type);\n                Error_Msg_NE\n                  (\"\\possibly missing with_clause on&\", Expr,\n                    Scope (Found_Type));\n@@ -7112,11 +8472,11 @@ package body Sem_Util is\n       --  Normal case of one type found, some other type expected\n \n       else\n-         --  If the names of the two types are the same, see if some\n-         --  number of levels of qualification will help. Don't try\n-         --  more than three levels, and if we get to standard, it's\n-         --  no use (and probably represents an error in the compiler)\n-         --  Also do not bother with internal scope names.\n+         --  If the names of the two types are the same, see if some number\n+         --  of levels of qualification will help. Don't try more than three\n+         --  levels, and if we get to standard, it's no use (and probably\n+         --  represents an error in the compiler) Also do not bother with\n+         --  internal scope names.\n \n          declare\n             Expec_Scope : Entity_Id;\n@@ -7154,7 +8514,7 @@ package body Sem_Util is\n          if Is_Entity_Name (Expr)\n            and then Is_Package_Or_Generic_Package (Entity (Expr))\n          then\n-            Error_Msg_N (\"found package name!\", Expr);\n+            Error_Msg_N (\"\\\\found package name!\", Expr);\n \n          elsif Is_Entity_Name (Expr)\n            and then\n@@ -7167,7 +8527,8 @@ package body Sem_Util is\n                  (\"found procedure name, possibly missing Access attribute!\",\n                    Expr);\n             else\n-               Error_Msg_N (\"found procedure name instead of function!\", Expr);\n+               Error_Msg_N\n+                 (\"\\\\found procedure name instead of function!\", Expr);\n             end if;\n \n          elsif Nkind (Expr) = N_Function_Call\n@@ -7196,10 +8557,10 @@ package body Sem_Util is\n            and then Present (Parent (Found_Type))\n            and then Nkind (Parent (Found_Type)) = N_Full_Type_Declaration\n          then\n-            Error_Msg_NE (\"found premature usage of}!\", Expr, Found_Type);\n+            Error_Msg_NE (\"\\\\found premature usage of}!\", Expr, Found_Type);\n \n          else\n-            Error_Msg_NE (\"found}!\", Expr, Found_Type);\n+            Error_Msg_NE (\"\\\\found}!\", Expr, Found_Type);\n          end if;\n \n          Error_Msg_Qual_Level := 0;"}, {"sha": "ad2404b372e5e1234ae4f144c745d44415bb9b98", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 123, "deletions": 30, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0986f8589f13684a6899875f8c73f42aab775a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0986f8589f13684a6899875f8c73f42aab775a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9b0986f8589f13684a6899875f8c73f42aab775a", "patch": "@@ -87,6 +87,14 @@ package Sem_Util is\n    --  Determine whether a selected component has a type that depends on\n    --  discriminants, and build actual subtype for it if so.\n \n+   function Build_Default_Subtype\n+     (T : Entity_Id;\n+      N : Node_Id) return Entity_Id;\n+   --  If T is an unconstrained type with defaulted discriminants, build a\n+   --  subtype constrained by the default values, insert the subtype\n+   --  declaration in the tree before N, and return the entity of that\n+   --  subtype. Otherwise, simply return T.\n+\n    function Build_Discriminal_Subtype_Of_Component\n      (T : Entity_Id) return Node_Id;\n    --  Determine whether a record component has a type that depends on\n@@ -108,12 +116,6 @@ package Sem_Util is\n    --  place error message on node N. Used in  object declarations, type\n    --  conversions, qualified expressions.\n \n-   procedure Check_Obsolescent (Nam : Entity_Id; N : Node_Id);\n-   --  Nam is either a subprogram or a (generic) package entity. This procedure\n-   --  checks if the Is_Obsolescent flag is set and if so, outputs appropriate\n-   --  diagnostics (it also checks the appropriate restriction). N is the node\n-   --  to which error messages are attached.\n-\n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n@@ -124,12 +126,26 @@ package Sem_Util is\n    --  with OpenVMS ports. The argument is the construct in question\n    --  and is used to post the error message.\n \n+   procedure Collect_Abstract_Interfaces\n+     (T                         : Entity_Id;\n+      Ifaces_List               : out Elist_Id;\n+      Exclude_Parent_Interfaces : Boolean := False);\n+   --  Ada 2005 (AI-251): Collect whole list of abstract interfaces that are\n+   --  directly or indirectly implemented by T. Exclude_Parent_Interfaces is\n+   --  used to avoid addition of inherited interfaces to the generated list.\n+\n    function Collect_Primitive_Operations (T : Entity_Id) return Elist_Id;\n    --  Called upon type derivation and extension. We scan the declarative\n    --  part in  which the type appears, and collect subprograms that have\n    --  one subsidiary subtype of the type. These subprograms can only\n    --  appear after the type itself.\n \n+   procedure Collect_Synchronized_Interfaces\n+     (Typ         : Entity_Id;\n+      Ifaces_List : out Elist_Id);\n+   --  Similar to Collect_Abstract_Interfaces, but tailored to task and\n+   --  protected types.\n+\n    function Compile_Time_Constraint_Error\n      (N    : Node_Id;\n       Msg  : String;\n@@ -174,13 +190,14 @@ package Sem_Util is\n    --  ignoring any child unit prefixes.\n \n    function Denotes_Discriminant\n-     (N               : Node_Id;\n-      Check_Protected : Boolean := False) return Boolean;\n+     (N                : Node_Id;\n+      Check_Concurrent : Boolean := False) return Boolean;\n    --  Returns True if node N is an Entity_Name node for a discriminant.\n-   --  If the flag Check_Protected is true, function also returns true\n-   --  when N denotes the discriminal of the discriminant of a protected\n+   --  If the flag Check_Concurrent is true, function also returns true\n+   --  when N denotes the discriminal of the discriminant of a concurrent\n    --  type. This is necessary to disable some optimizations on private\n-   --  components of protected types.\n+   --  components of protected types, and constraint checks on entry\n+   --  families constrained by discriminants.\n \n    function Depends_On_Discriminant (N : Node_Id) return Boolean;\n    --  Returns True if N denotes a discriminant or if N is a range, a subtype\n@@ -356,6 +373,12 @@ package Sem_Util is\n    --  which is the innermost visible entity with the given name. See the\n    --  body of Sem_Ch8 for further details on handling of entity visibility.\n \n+   function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n+   --  Nod is either a procedure call statement, or a function call, or\n+   --  an accept statement node. This procedure finds the Entity_Id of the\n+   --  related subprogram or entry and returns it, or if no subprogram can\n+   --  be found, returns Empty.\n+\n    function Get_Referenced_Object (N : Node_Id) return Node_Id;\n    --  Given a node, return the renamed object if the node represents\n    --  a renamed object, otherwise return the node unchanged. The node\n@@ -380,6 +403,33 @@ package Sem_Util is\n    --  T contains access values (happens for generic formals in some\n    --  cases), then False is returned.\n \n+   type Alignment_Result is (Known_Compatible, Unknown, Known_Incompatible);\n+   --  Result of Has_Compatible_Alignment test, description found below. Note\n+   --  that the values are arranged in increasing order of problematicness.\n+\n+   function Has_Abstract_Interfaces (Tagged_Type : Entity_Id) return Boolean;\n+   --  Returns true if Tagged_Type implements some abstract interface\n+\n+   function Has_Compatible_Alignment\n+     (Obj  : Entity_Id;\n+      Expr : Node_Id) return Alignment_Result;\n+   --  Obj is an object entity, and expr is a node for an object reference. If\n+   --  the alignment of the object referenced by Expr is known to be compatible\n+   --  with the alignment of Obj (i.e. is larger or the same), then the result\n+   --  is Known_Compatible. If the alignment of the object referenced by Expr\n+   --  is known to be less than the alignment of Obj, then Known_Incompatible\n+   --  is returned. If neither condition can be reliably established at compile\n+   --  time, then Unknown is returned. This is used to determine if alignment\n+   --  checks are required for address clauses, and also whether copies must\n+   --  be made when objects are passed by reference.\n+   --\n+   --  Note: Known_Incompatible does not mean that at run time the alignment\n+   --  of Expr is known to be wrong for Obj, just that it can be determined\n+   --  that alignments have been explicitly or implicitly specified which\n+   --  are incompatible (whereas Unknown means that even this is not known).\n+   --  The appropriate reaction of a caller to Known_Incompatible is to treat\n+   --  it as Unknown, but issue a warning that there may be an alignment error.\n+\n    function Has_Declarations (N : Node_Id) return Boolean;\n    --  Determines if the node can have declarations\n \n@@ -392,6 +442,13 @@ package Sem_Util is\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type.\n \n+   function Has_Null_Exclusion (N : Node_Id) return Boolean;\n+   --  Determine whether node N has a null exclusion\n+\n+   function Has_Preelaborable_Initialization (E : Entity_Id) return Boolean;\n+   --  Return True iff type E has preelaborable initialiation as defined in\n+   --  Ada 2005 (see AI-161 for details of the definition of this attribute).\n+\n    function Has_Private_Component (Type_Id : Entity_Id) return Boolean;\n    --  Check if a type has a (sub)component of a private type that has not\n    --  yet received a full declaration.\n@@ -479,7 +536,7 @@ package Sem_Util is\n    --  Returns True if Object is the name of a subcomponent that\n    --  depends on discriminants of a variable whose nominal subtype\n    --  is unconstrained and not indefinite, and the variable is\n-   --  not aliased.  Otherwise returns False.  The nodes passed\n+   --  not aliased. Otherwise returns False. The nodes passed\n    --  to this function are assumed to denote objects.\n \n    function Is_Dereferenced (N : Node_Id) return Boolean;\n@@ -521,15 +578,6 @@ package Sem_Util is\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n    --  by a derived type declarations.\n \n-   function Is_Lvalue (N : Node_Id) return Boolean;\n-   --  Determines if N could be an lvalue (e.g. an assignment left hand side).\n-   --  This determination is conservative, it must never answer False if N is\n-   --  an lvalue, but it can answer True when N is not an lvalue. An lvalue is\n-   --  defined as any expression which appears in a context where a name is\n-   --  required by the syntax, and the identity, rather than merely the value\n-   --  of the node is needed (for example, the prefix of an Access attribute\n-   --  is in this category).\n-\n    function Is_Library_Level_Entity (E : Entity_Id) return Boolean;\n    --  A library-level declaration is one that is accessible from Standard,\n    --  i.e. a library unit or an entity declared in a library package.\n@@ -621,7 +669,7 @@ package Sem_Util is\n    procedure Kill_Current_Values;\n    --  This procedure is called to clear all constant indications from all\n    --  entities in the current scope and in any parent scopes if the current\n-   --  scope is a block or a pacakage (and that recursion continues to the\n+   --  scope is a block or a package (and that recursion continues to the\n    --  top scope that is not a block or a package). This is used when the\n    --  sequential flow-of-control assumption is violated (occurence of a\n    --  label, head of a loop, or start of an exception handler). The effect\n@@ -644,6 +692,24 @@ package Sem_Util is\n    --  code is present, this size check code is killed, since the object\n    --  will not be allocated by the program.\n \n+   function Known_To_Be_Assigned (N : Node_Id) return Boolean;\n+   --  The node N is an entity reference. This function determines whether the\n+   --  reference is for sure an assignment of the entity, returning True if\n+   --  so. This differs from May_Be_Lvalue in that it defaults in the other\n+   --  direction. Cases which may possibly be assignments but are not known to\n+   --  be may return True from May_Be_Lvalue, but False from this function.\n+\n+   function May_Be_Lvalue (N : Node_Id) return Boolean;\n+   --  Determines if N could be an lvalue (e.g. an assignment left hand side).\n+   --  An lvalue is defined as any expression which appears in a context where\n+   --  a name is required by the syntax, and the identity, rather than merely\n+   --  the value of the node is needed (for example, the prefix of an Access\n+   --  attribute is in this category). Note that, as implied by the name, this\n+   --  test is conservative. If it cannot be sure that N is NOT an lvalue, then\n+   --  it returns True. It tries hard to get the answer right, but it is hard\n+   --  to guarantee this in all cases. Note that it is more possible to give\n+   --  correct answer if the tree is fully analyzed.\n+\n    function New_External_Entity\n      (Kind         : Entity_Kind;\n       Scope_Id     : Entity_Id;\n@@ -706,6 +772,18 @@ package Sem_Util is\n    --  For convenience, qualified expressions applied to object names\n    --  are also allowed as actuals for this function.\n \n+   function Overrides_Synchronized_Primitive\n+     (Def_Id      : Entity_Id;\n+      First_Hom   : Entity_Id;\n+      Ifaces_List : Elist_Id;\n+      In_Scope    : Boolean := True) return Entity_Id;\n+   --  Determine whether entry or subprogram Def_Id overrides a primitive\n+   --  operation that belongs to one of the interfaces in Ifaces_List. A\n+   --  specific homonym chain can be specified by setting First_Hom. Flag\n+   --  In_Scope is used to designate whether the entry or subprogram was\n+   --  declared inside the scope of the synchronized type or after. Return\n+   --  the overriden entity or Empty.\n+\n    function Private_Component (Type_Id : Entity_Id) return Entity_Id;\n    --  Returns some private component (if any) of the given Type_Id.\n    --  Used to enforce the rules on visibility of operations on composite\n@@ -761,14 +839,24 @@ package Sem_Util is\n \n    function Safe_To_Capture_Value\n      (N    : Node_Id;\n-      Ent  : Entity_Id) return Boolean;\n-   --  The caller is interested in capturing a value (either the current\n-   --  value, or an indication that the value is non-null) for the given\n-   --  entity Ent. This value can only be captured if sequential execution\n-   --  semantics can be properly guaranteed so that a subsequent reference\n-   --  will indeed be sure that this current value indication is correct.\n-   --  The node N is the construct which resulted in the possible capture\n-   --  of the value (this is used to check if we are in a conditional).\n+      Ent  : Entity_Id;\n+      Cond : Boolean := False) return Boolean;\n+   --  The caller is interested in capturing a value (either the current value,\n+   --  or an indication that the value is non-null) for the given entity Ent.\n+   --  This value can only be captured if sequential execution semantics can be\n+   --  properly guaranteed so that a subsequent reference will indeed be sure\n+   --  that this current value indication is correct. The node N is the\n+   --  construct which resulted in the possible capture of the value (this\n+   --  is used to check if we are in a conditional).\n+   --\n+   --  Cond is used to skip the test for being inside a conditional. It is used\n+   --  in the case of capturing values from if/while tests, which already do a\n+   --  proper job of handling scoping issues without this help.\n+   --\n+   --  The only entities whose values can be captured are OUT and IN OUT formal\n+   --  parameters, and variables unless Cond is True, in which case we also\n+   --  allow IN formals, loop parameters and constants, where we cannot ever\n+   --  capture actual value information, but we can capture conditional tests.\n \n    function Same_Name (N1, N2 : Node_Id) return Boolean;\n    --  Determine if two (possibly expanded) names are the same name\n@@ -863,6 +951,10 @@ package Sem_Util is\n    function Universal_Interpretation (Opnd : Node_Id) return Entity_Id;\n    --  Yields universal_Integer or Universal_Real if this is a candidate\n \n+   function Unqualify (Expr : Node_Id) return Node_Id;\n+   --  Removes any qualifications from Expr. For example, for T1'(T2'(X)),\n+   --  this returns X. If Expr is not a qualified expression, returns Expr.\n+\n    function Within_Init_Proc return Boolean;\n    --  Determines if Current_Scope is within an init proc\n \n@@ -882,5 +974,6 @@ private\n    pragma Inline (Set_Current_Entity);\n    pragma Inline (Set_Name_Entity_Id);\n    pragma Inline (Set_Size_Info);\n+   pragma Inline (Unqualify);\n \n end Sem_Util;"}]}