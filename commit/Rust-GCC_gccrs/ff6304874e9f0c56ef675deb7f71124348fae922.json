{"sha": "ff6304874e9f0c56ef675deb7f71124348fae922", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2MzA0ODc0ZTlmMGM1NmVmNjc1ZGViN2Y3MTEyNDM0OGZhZTkyMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-30T19:04:53Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-30T19:04:53Z"}, "message": "[C++ PATCH] operator name cleanup prepatch\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg02240.html\n\tcp/\n\t* call.c (build_op_call_1): Test for FUNCTION_DECL in same manner\n\tas a few lines earlier.\n\t* cp-tree.h (PACK_EXPANSION_PATTERN): Fix white space.\n\t* decl.c (grokfndecl): Fix indentation.\n\t(compute_array_index_type): Use processing_template_decl_sentinel.\n\t(grok_op_properties): Move warnings to end.  Reorder other checks\n\tto group similar entities.  Tweak diagnostics.\n\t* lex.c (unqualified_name_lookup_error): No need to check name is\n\tnot ERROR_MARK operator.\n\t* parser.c (cp_parser_operator): Select operator code before\n\tlooking it up.\n\t* typeck.c (check_return_expr): Fix indentation and line wrapping.\n\n\ttestsuite/\n\n\t* g++.dg/other/operator2.C: Adjust diagnostic.\n\t* g++.old-deja/g++.jason/operator.C: Likewise.\n\nFrom-SVN: r254238", "tree": {"sha": "cf00bde39e4174f28857d66ad2019885c457b8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf00bde39e4174f28857d66ad2019885c457b8c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6304874e9f0c56ef675deb7f71124348fae922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6304874e9f0c56ef675deb7f71124348fae922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6304874e9f0c56ef675deb7f71124348fae922", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6304874e9f0c56ef675deb7f71124348fae922/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b832b29f6578d3171e41d084b7a8432a24c5bf62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b832b29f6578d3171e41d084b7a8432a24c5bf62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b832b29f6578d3171e41d084b7a8432a24c5bf62"}], "stats": {"total": 735, "additions": 382, "deletions": 353}, "files": [{"sha": "7630638329c1c47edee4d6d98318fce5e91ce9df", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -1,3 +1,18 @@\n+2017-10-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* call.c (build_op_call_1): Test for FUNCTION_DECL in same manner\n+\tas a few lines earlier.\n+\t* cp-tree.h (PACK_EXPANSION_PATTERN): Fix white space.\n+\t* decl.c (grokfndecl): Fix indentation.\n+\t(compute_array_index_type): Use processing_template_decl_sentinel.\n+\t(grok_op_properties): Move warnings to end.  Reorder other checks\n+\tto group similar entities.  Tweak diagnostics.\n+\t* lex.c (unqualified_name_lookup_error): No need to check name is\n+\tnot ERROR_MARK operator.\n+\t* parser.c (cp_parser_operator): Select operator code before\n+\tlooking it up.\n+\t* typeck.c (check_return_expr): Fix indentation and line wrapping.\n+\n 2017-10-27  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* pt.c (invalid_nontype_parm_type_p): Return a bool instead of an int."}, {"sha": "de3434b3deaf95f5b102761d6cff8dae14718a20", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -4565,11 +4565,14 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \tresult = build_over_call (cand, LOOKUP_NORMAL, complain);\n       else\n \t{\n-\t  if (DECL_P (cand->fn))\n+\t  if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n \t    obj = convert_like_with_context (cand->convs[0], obj, cand->fn,\n \t\t\t\t\t     -1, complain);\n \t  else\n-\t    obj = convert_like (cand->convs[0], obj, complain);\n+\t    {\n+\t      gcc_checking_assert (TYPE_P (cand->fn));\n+\t      obj = convert_like (cand->convs[0], obj, complain);\n+\t    }\n \t  obj = convert_from_reference (obj);\n \t  result = cp_build_function_call_vec (obj, args, complain);\n \t}"}, {"sha": "3aefd7e40f46de72e443a3a751551b49c19c9470", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -3460,7 +3460,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n /* Extracts the type or expression pattern from a TYPE_PACK_EXPANSION or\n    EXPR_PACK_EXPANSION.  */\n #define PACK_EXPANSION_PATTERN(NODE)                            \\\n-  (TREE_CODE (NODE) == TYPE_PACK_EXPANSION? TREE_TYPE (NODE)    \\\n+  (TREE_CODE (NODE) == TYPE_PACK_EXPANSION ? TREE_TYPE (NODE)    \\\n    : TREE_OPERAND (NODE, 0))\n \n /* Sets the type or expression pattern for a TYPE_PACK_EXPANSION or"}, {"sha": "0e49e2b6088550f692422fc8f1a47d77e262cb6e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 283, "deletions": 290, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -8698,7 +8698,7 @@ grokfndecl (tree ctype,\n \t\t  \"deduction guide %qD must not have a function body\", decl);\n     }\n   else if (IDENTIFIER_ANY_OP_P (DECL_NAME (decl))\n-      && !grok_op_properties (decl, /*complain=*/true))\n+\t   && !grok_op_properties (decl, /*complain=*/true))\n     return NULL_TREE;\n   else if (UDLIT_OPER_P (DECL_NAME (decl)))\n     {\n@@ -9472,22 +9472,20 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n     itype = build_min (MINUS_EXPR, sizetype, size, integer_one_node);\n   else\n     {\n-      HOST_WIDE_INT saved_processing_template_decl;\n-\n       /* Compute the index of the largest element in the array.  It is\n \t one less than the number of elements in the array.  We save\n \t and restore PROCESSING_TEMPLATE_DECL so that computations in\n \t cp_build_binary_op will be appropriately folded.  */\n-      saved_processing_template_decl = processing_template_decl;\n-      processing_template_decl = 0;\n-      itype = cp_build_binary_op (input_location,\n-\t\t\t\t  MINUS_EXPR,\n-\t\t\t\t  cp_convert (ssizetype, size, complain),\n-\t\t\t\t  cp_convert (ssizetype, integer_one_node,\n-\t\t\t\t\t      complain),\n-\t\t\t\t  complain);\n-      itype = maybe_constant_value (itype);\n-      processing_template_decl = saved_processing_template_decl;\n+      {\n+\tprocessing_template_decl_sentinel s;\n+\titype = cp_build_binary_op (input_location,\n+\t\t\t\t    MINUS_EXPR,\n+\t\t\t\t    cp_convert (ssizetype, size, complain),\n+\t\t\t\t    cp_convert (ssizetype, integer_one_node,\n+\t\t\t\t\t\tcomplain),\n+\t\t\t\t    complain);\n+\titype = maybe_constant_value (itype);\n+      }\n \n       if (!TREE_CONSTANT (itype))\n \t{\n@@ -12909,25 +12907,14 @@ bool\n grok_op_properties (tree decl, bool complain)\n {\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-  tree argtype;\n   int methodp = (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n   tree name = DECL_NAME (decl);\n-  enum tree_code operator_code;\n-  int arity;\n-  bool ellipsis_p;\n-  tree class_type;\n-\n-  /* Count the number of arguments and check for ellipsis.  */\n-  for (argtype = argtypes, arity = 0;\n-       argtype && argtype != void_list_node;\n-       argtype = TREE_CHAIN (argtype))\n-    ++arity;\n-  ellipsis_p = !argtype;\n \n-  class_type = DECL_CONTEXT (decl);\n+  tree class_type = DECL_CONTEXT (decl);\n   if (class_type && !CLASS_TYPE_P (class_type))\n     class_type = NULL_TREE;\n \n+  enum tree_code operator_code = ERROR_MARK;\n   if (IDENTIFIER_CONV_OP_P (name))\n     operator_code = TYPE_EXPR;\n   else\n@@ -12953,327 +12940,333 @@ grok_op_properties (tree decl, bool complain)\n   gcc_assert (operator_code != MAX_TREE_CODES);\n   SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n \n-  if (class_type)\n-    switch (operator_code)\n-      {\n-      case NEW_EXPR:\n-\tTYPE_HAS_NEW_OPERATOR (class_type) = 1;\n-\tbreak;\n+  if (operator_code == NEW_EXPR || operator_code == VEC_NEW_EXPR\n+      || operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n+    {\n+      /* operator new and operator delete are quite special.  */\n+      if (class_type)\n+\tswitch (operator_code)\n+\t  {\n+\t  case NEW_EXPR:\n+\t    TYPE_HAS_NEW_OPERATOR (class_type) = 1;\n+\t    break;\n \n-      case DELETE_EXPR:\n-\tTYPE_GETS_DELETE (class_type) |= 1;\n-\tbreak;\n+\t  case DELETE_EXPR:\n+\t    TYPE_GETS_DELETE (class_type) |= 1;\n+\t    break;\n \n-      case VEC_NEW_EXPR:\n-\tTYPE_HAS_ARRAY_NEW_OPERATOR (class_type) = 1;\n-\tbreak;\n+\t  case VEC_NEW_EXPR:\n+\t    TYPE_HAS_ARRAY_NEW_OPERATOR (class_type) = 1;\n+\t    break;\n \n-      case VEC_DELETE_EXPR:\n-\tTYPE_GETS_DELETE (class_type) |= 2;\n-\tbreak;\n+\t  case VEC_DELETE_EXPR:\n+\t    TYPE_GETS_DELETE (class_type) |= 2;\n+\t    break;\n \n-      default:\n-\tbreak;\n-      }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n \n-    /* [basic.std.dynamic.allocation]/1:\n+      /* [basic.std.dynamic.allocation]/1:\n \n-       A program is ill-formed if an allocation function is declared\n-       in a namespace scope other than global scope or declared static\n-       in global scope.\n+\t A program is ill-formed if an allocation function is declared\n+\t in a namespace scope other than global scope or declared\n+\t static in global scope.\n \n-       The same also holds true for deallocation functions.  */\n-  if (operator_code == NEW_EXPR || operator_code == VEC_NEW_EXPR\n-      || operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n-    {\n+\t The same also holds true for deallocation functions.  */\n       if (DECL_NAMESPACE_SCOPE_P (decl))\n \t{\n \t  if (CP_DECL_CONTEXT (decl) != global_namespace)\n \t    {\n \t      error (\"%qD may not be declared within a namespace\", decl);\n \t      return false;\n \t    }\n-\t  else if (!TREE_PUBLIC (decl))\n+\n+\t  if (!TREE_PUBLIC (decl))\n \t    {\n \t      error (\"%qD may not be declared as static\", decl);\n \t      return false;\n \t    }\n \t}\n-    }\n \n-  if (operator_code == NEW_EXPR || operator_code == VEC_NEW_EXPR)\n-    {\n-      TREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl));\n-      DECL_IS_OPERATOR_NEW (decl) = 1;\n+      if (operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n+\tTREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl));\n+      else\n+\t{\n+\t  TREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl));\n+\t  DECL_IS_OPERATOR_NEW (decl) = 1;\n+\t}\n+\n+      return true;\n     }\n-  else if (operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n-    TREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl));\n-  else\n+\n+  /* An operator function must either be a non-static member function\n+     or have at least one parameter of a class, a reference to a class,\n+     an enumeration, or a reference to an enumeration.  13.4.0.6 */\n+  if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n     {\n-      /* An operator function must either be a non-static member function\n-\t or have at least one parameter of a class, a reference to a class,\n-\t an enumeration, or a reference to an enumeration.  13.4.0.6 */\n-      if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n+      if (operator_code == TYPE_EXPR\n+\t  || operator_code == CALL_EXPR\n+\t  || operator_code == COMPONENT_REF\n+\t  || operator_code == ARRAY_REF\n+\t  || operator_code == NOP_EXPR)\n+\t{\n+\t  error (\"%qD must be a nonstatic member function\", decl);\n+\t  return false;\n+\t}\n+\n+      if (DECL_STATIC_FUNCTION_P (decl))\n+\t{\n+\t  error (\"%qD must be either a non-static member \"\n+\t\t \"function or a non-member function\", decl);\n+\t  return false;\n+\t}\n+\n+      for (tree arg = argtypes; ; arg = TREE_CHAIN (arg))\n \t{\n-\t  if (operator_code == TYPE_EXPR\n-\t      || operator_code == CALL_EXPR\n-\t      || operator_code == COMPONENT_REF\n-\t      || operator_code == ARRAY_REF\n-\t      || operator_code == NOP_EXPR)\n+\t  if (!arg || arg == void_list_node)\n \t    {\n-\t      error (\"%qD must be a nonstatic member function\", decl);\n+\t      if (complain)\n+\t\terror (\"%qD must have an argument of class or \"\n+\t\t       \"enumerated type\", decl);\n \t      return false;\n \t    }\n-\t  else\n-\t    {\n-\t      tree p;\n+      \n+\t  tree type = non_reference (TREE_VALUE (arg));\n+\t  if (type == error_mark_node)\n+\t    return false;\n+\t  \n+\t  /* MAYBE_CLASS_TYPE_P, rather than CLASS_TYPE_P, is used\n+\t     because these checks are performed even on template\n+\t     functions.  */\n+\t  if (MAYBE_CLASS_TYPE_P (type)\n+\t      || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t    break;\n+\t}\n+    }\n \n-\t      if (DECL_STATIC_FUNCTION_P (decl))\n-\t\t{\n-\t\t  error (\"%qD must be either a non-static member \"\n-\t\t\t \"function or a non-member function\", decl);\n-\t\t  return false;\n-\t\t}\n+  /* There are no restrictions on the arguments to an overloaded\n+     \"operator ()\".  */\n+  if (operator_code == CALL_EXPR)\n+    return true;\n \n-\t      for (p = argtypes; p && p != void_list_node; p = TREE_CHAIN (p))\n-\t\t{\n-\t\t  tree arg = non_reference (TREE_VALUE (p));\n-\t\t  if (arg == error_mark_node)\n-\t\t    return false;\n-\n-\t\t  /* MAYBE_CLASS_TYPE_P, rather than CLASS_TYPE_P, is used\n-\t\t     because these checks are performed even on\n-\t\t     template functions.  */\n-\t\t  if (MAYBE_CLASS_TYPE_P (arg)\n-\t\t      || TREE_CODE (arg) == ENUMERAL_TYPE)\n-\t\t    break;\n-\t\t}\n+  if (operator_code == COND_EXPR)\n+    {\n+      /* 13.4.0.3 */\n+      error (\"ISO C++ prohibits overloading operator ?:\");\n+      return false;\n+    }\n \n-\t      if (!p || p == void_list_node)\n-\t\t{\n-\t\t  if (complain)\n-\t\t    error (\"%qD must have an argument of class or \"\n-\t\t\t   \"enumerated type\", decl);\n-\t\t  return false;\n-\t\t}\n-\t    }\n+  /* Count the number of arguments and check for ellipsis.  */\n+  int arity = 0;\n+  for (tree arg = argtypes; arg != void_list_node; arg = TREE_CHAIN (arg))\n+    {\n+      if (!arg)\n+\t{\n+\t  /* Variadic.  */\n+\t  error (\"%qD must not have variable number of arguments\", decl);\n+\t  return false;\n \t}\n+      ++arity;\n+    }\n \n-      /* There are no restrictions on the arguments to an overloaded\n-\t \"operator ()\".  */\n-      if (operator_code == CALL_EXPR)\n-\treturn true;\n-\n-      /* Warn about conversion operators that will never be used.  */\n-      if (IDENTIFIER_CONV_OP_P (name)\n-\t  && ! DECL_TEMPLATE_INFO (decl)\n-\t  && warn_conversion\n-\t  /* Warn only declaring the function; there is no need to\n-\t     warn again about out-of-class definitions.  */\n-\t  && class_type == current_class_type)\n+  /* Verify correct number of arguments.  */\n+  if (ambi_op_p (operator_code))\n+    {\n+      if (arity == 1)\n+\t/* We pick the one-argument operator codes by default, so\n+\t   we don't have to change anything.  */\n+\t;\n+      else if (arity == 2)\n \t{\n-\t  tree t = TREE_TYPE (name);\n-\t  int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n+\t  /* If we thought this was a unary operator, we now know\n+\t     it to be a binary operator.  */\n+\t  switch (operator_code)\n+\t    {\n+\t    case INDIRECT_REF:\n+\t      operator_code = MULT_EXPR;\n+\t      break;\n \n-\t  if (ref)\n-\t    t = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+\t    case ADDR_EXPR:\n+\t      operator_code = BIT_AND_EXPR;\n+\t      break;\n \n-\t  if (VOID_TYPE_P (t))\n-            warning (OPT_Wconversion,\n-                     ref\n-                     ? G_(\"conversion to a reference to void \"\n-                          \"will never use a type conversion operator\")\n-                     : G_(\"conversion to void \"\n-                          \"will never use a type conversion operator\"));\n-\t  else if (class_type)\n-\t    {\n-\t      if (t == class_type)\n-                warning (OPT_Wconversion,\n-                     ref\n-                     ? G_(\"conversion to a reference to the same type \"\n-                          \"will never use a type conversion operator\")\n-                     : G_(\"conversion to the same type \"\n-                          \"will never use a type conversion operator\"));\t\t\n-\t      /* Don't force t to be complete here.  */\n-\t      else if (MAYBE_CLASS_TYPE_P (t)\n-\t\t       && COMPLETE_TYPE_P (t)\n-\t\t       && DERIVED_FROM_P (t, class_type))\n-                 warning (OPT_Wconversion,\n-                          ref\n-                          ? G_(\"conversion to a reference to a base class \"\n-                               \"will never use a type conversion operator\")\n-                          : G_(\"conversion to a base class \"\n-                               \"will never use a type conversion operator\"));\t\t\n+\t    case UNARY_PLUS_EXPR:\n+\t      operator_code = PLUS_EXPR;\n+\t      break;\n+\n+\t    case NEGATE_EXPR:\n+\t      operator_code = MINUS_EXPR;\n+\t      break;\n+\n+\t    case PREINCREMENT_EXPR:\n+\t      operator_code = POSTINCREMENT_EXPR;\n+\t      break;\n+\n+\t    case PREDECREMENT_EXPR:\n+\t      operator_code = POSTDECREMENT_EXPR;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n \n-\t}\n+\t  SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n \n-      if (operator_code == COND_EXPR)\n+\t  if ((operator_code == POSTINCREMENT_EXPR\n+\t       || operator_code == POSTDECREMENT_EXPR)\n+\t      && ! processing_template_decl\n+\t      && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)), integer_type_node))\n+\t    {\n+\t      error (methodp\n+\t\t ? G_(\"postfix %qD must have %<int%> as its argument\")\n+\t\t : G_(\"postfix %qD must have %<int%> as its second argument\"),\n+\t\t decl);\n+\t      return false;\n+\t    }\n+\t}\n+      else\n \t{\n-\t  /* 13.4.0.3 */\n-\t  error (\"ISO C++ prohibits overloading operator ?:\");\n+\t  error (methodp\n+\t\t ? G_(\"%qD must have either zero or one argument\")\n+\t\t : G_(\"%qD must have either one or two arguments\"), decl);\n \t  return false;\n \t}\n-      else if (ellipsis_p)\n+    }\n+  else if (unary_op_p (operator_code))\n+    {\n+      if (arity != 1)\n \t{\n-\t  error (\"%qD must not have variable number of arguments\", decl);\n+\t  error (methodp\n+\t\t ? G_(\"%qD must have no arguments\")\n+\t\t : G_(\"%qD must have exactly one argument\"), decl);\n \t  return false;\n \t}\n-      else if (ambi_op_p (operator_code))\n+    }\n+  else\n+    {\n+      if (arity != 2)\n \t{\n-\t  if (arity == 1)\n-\t    /* We pick the one-argument operator codes by default, so\n-\t       we don't have to change anything.  */\n-\t    ;\n-\t  else if (arity == 2)\n-\t    {\n-\t      /* If we thought this was a unary operator, we now know\n-\t\t it to be a binary operator.  */\n-\t      switch (operator_code)\n-\t\t{\n-\t\tcase INDIRECT_REF:\n-\t\t  operator_code = MULT_EXPR;\n-\t\t  break;\n-\n-\t\tcase ADDR_EXPR:\n-\t\t  operator_code = BIT_AND_EXPR;\n-\t\t  break;\n+\t  error (methodp\n+\t\t ? G_(\"%qD must have exactly one argument\")\n+\t\t : G_(\"%qD must have exactly two arguments\"), decl);\n+\t  return false;\n+\t}\n+    }\n+  \n+  /* There can be no default arguments.  */\n+  for (tree arg = argtypes; arg != void_list_node; arg = TREE_CHAIN (arg))\n+    if (TREE_PURPOSE (arg))\n+      {\n+\tTREE_PURPOSE (arg) = NULL_TREE;\n+\tif (operator_code == POSTINCREMENT_EXPR\n+\t    || operator_code == POSTDECREMENT_EXPR)\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"%qD cannot have default arguments\", decl);\n+\telse\n+\t  {\n+\t    error (\"%qD cannot have default arguments\", decl);\n+\t    return false;\n+\t  }\n+      }\n \n-\t\tcase UNARY_PLUS_EXPR:\n-\t\t  operator_code = PLUS_EXPR;\n-\t\t  break;\n+  /* At this point the declaration is well-formed.  It may not be\n+     sensible though.  */\n \n-\t\tcase NEGATE_EXPR:\n-\t\t  operator_code = MINUS_EXPR;\n-\t\t  break;\n+  /* Check member function warnings only on the in-class declaration.\n+     There's no point warning on an out-of-class definition.  */\n+  if (class_type && class_type != current_class_type)\n+    return true;\n \n-\t\tcase PREINCREMENT_EXPR:\n-\t\t  operator_code = POSTINCREMENT_EXPR;\n-\t\t  break;\n+  /* Warn about conversion operators that will never be used.  */\n+  if (IDENTIFIER_CONV_OP_P (name)\n+      && ! DECL_TEMPLATE_INFO (decl)\n+      && warn_conversion)\n+    {\n+      tree t = TREE_TYPE (name);\n+      int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n \n-\t\tcase PREDECREMENT_EXPR:\n-\t\t  operator_code = POSTDECREMENT_EXPR;\n-\t\t  break;\n+      if (ref)\n+\tt = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n \n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n+      if (VOID_TYPE_P (t))\n+\twarning (OPT_Wconversion,\n+\t\t ref\n+\t\t ? G_(\"conversion to a reference to void \"\n+\t\t      \"will never use a type conversion operator\")\n+\t\t : G_(\"conversion to void \"\n+\t\t      \"will never use a type conversion operator\"));\n+      else if (class_type)\n+\t{\n+\t  if (t == class_type)\n+\t    warning (OPT_Wconversion,\n+                     ref\n+                     ? G_(\"conversion to a reference to the same type \"\n+                          \"will never use a type conversion operator\")\n+                     : G_(\"conversion to the same type \"\n+                          \"will never use a type conversion operator\"));\n+\t  /* Don't force t to be complete here.  */\n+\t  else if (MAYBE_CLASS_TYPE_P (t)\n+\t\t   && COMPLETE_TYPE_P (t)\n+\t\t   && DERIVED_FROM_P (t, class_type))\n+\t    warning (OPT_Wconversion,\n+\t\t     ref\n+\t\t     ? G_(\"conversion to a reference to a base class \"\n+\t\t\t  \"will never use a type conversion operator\")\n+\t\t     : G_(\"conversion to a base class \"\n+\t\t\t  \"will never use a type conversion operator\"));\n+\t}\n+    }\n \n-\t      SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n+  if (!warn_ecpp)\n+    return true;\n \n-\t      if ((operator_code == POSTINCREMENT_EXPR\n-\t\t   || operator_code == POSTDECREMENT_EXPR)\n-\t\t  && ! processing_template_decl\n-\t\t  && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)), integer_type_node))\n-\t\t{\n-\t\t  if (methodp)\n-\t\t    error (\"postfix %qD must take %<int%> as its argument\",\n-\t\t\t   decl);\n-\t\t  else\n-\t\t    error (\"postfix %qD must take %<int%> as its second \"\n-\t\t\t   \"argument\", decl);\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (methodp)\n-\t\terror (\"%qD must take either zero or one argument\", decl);\n-\t      else\n-\t\terror (\"%qD must take either one or two arguments\", decl);\n-\t      return false;\n-\t    }\n+  /* Effective C++ rules below.  */\n \n-\t  /* More Effective C++ rule 6.  */\n-\t  if (warn_ecpp\n-\t      && (operator_code == POSTINCREMENT_EXPR\n-\t\t  || operator_code == POSTDECREMENT_EXPR\n-\t\t  || operator_code == PREINCREMENT_EXPR\n-\t\t  || operator_code == PREDECREMENT_EXPR))\n-\t    {\n-\t      tree arg = TREE_VALUE (argtypes);\n-\t      tree ret = TREE_TYPE (TREE_TYPE (decl));\n-\t      if (methodp || TREE_CODE (arg) == REFERENCE_TYPE)\n-\t\targ = TREE_TYPE (arg);\n-\t      arg = TYPE_MAIN_VARIANT (arg);\n-\t      if (operator_code == PREINCREMENT_EXPR\n-\t\t  || operator_code == PREDECREMENT_EXPR)\n-\t\t{\n-\t\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n-\t\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n-\t\t\t\t       arg))\n-\t\t    warning (OPT_Weffc__, \"prefix %qD should return %qT\", decl,\n-\t\t\t     build_reference_type (arg));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (!same_type_p (TYPE_MAIN_VARIANT (ret), arg))\n-\t\t    warning (OPT_Weffc__, \"postfix %qD should return %qT\", decl, arg);\n-\t\t}\n-\t    }\n+  /* More Effective C++ rule 7.  */\n+  if (operator_code == TRUTH_ANDIF_EXPR\n+      || operator_code == TRUTH_ORIF_EXPR\n+      || operator_code == COMPOUND_EXPR)\n+    warning (OPT_Weffc__,\n+\t     \"user-defined %qD always evaluates both arguments\", decl);\n+  \n+  /* More Effective C++ rule 6.  */\n+  if (operator_code == POSTINCREMENT_EXPR\n+      || operator_code == POSTDECREMENT_EXPR\n+      || operator_code == PREINCREMENT_EXPR\n+      || operator_code == PREDECREMENT_EXPR)\n+    {\n+      tree arg = TREE_VALUE (argtypes);\n+      tree ret = TREE_TYPE (TREE_TYPE (decl));\n+      if (methodp || TREE_CODE (arg) == REFERENCE_TYPE)\n+\targ = TREE_TYPE (arg);\n+      arg = TYPE_MAIN_VARIANT (arg);\n+\n+      if (operator_code == PREINCREMENT_EXPR\n+\t  || operator_code == PREDECREMENT_EXPR)\n+\t{\n+\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n+\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)), arg))\n+\t    warning (OPT_Weffc__, \"prefix %qD should return %qT\", decl,\n+\t\t     build_reference_type (arg));\n \t}\n-      else if (unary_op_p (operator_code))\n+      else\n \t{\n-\t  if (arity != 1)\n-\t    {\n-\t      if (methodp)\n-\t\terror (\"%qD must take %<void%>\", decl);\n-\t      else\n-\t\terror (\"%qD must take exactly one argument\", decl);\n-\t      return false;\n-\t    }\n+\t  if (!same_type_p (TYPE_MAIN_VARIANT (ret), arg))\n+\t    warning (OPT_Weffc__, \"postfix %qD should return %qT\", decl, arg);\n \t}\n-      else /* if (binary_op_p (operator_code)) */\n-\t{\n-\t  if (arity != 2)\n-\t    {\n-\t      if (methodp)\n-\t\terror (\"%qD must take exactly one argument\", decl);\n-\t      else\n-\t\terror (\"%qD must take exactly two arguments\", decl);\n-\t      return false;\n-\t    }\n+    }\n \n-\t  /* More Effective C++ rule 7.  */\n-\t  if (warn_ecpp\n-\t      && (operator_code == TRUTH_ANDIF_EXPR\n-\t\t  || operator_code == TRUTH_ORIF_EXPR\n-\t\t  || operator_code == COMPOUND_EXPR))\n-\t    warning (OPT_Weffc__, \"user-defined %qD always evaluates both arguments\",\n-\t\t     decl);\n-\t}\n+  /* Effective C++ rule 23.  */\n+  if (!DECL_ASSIGNMENT_OPERATOR_P (decl)\n+      && (operator_code == PLUS_EXPR\n+\t  || operator_code == MINUS_EXPR\n+\t  || operator_code == TRUNC_DIV_EXPR\n+\t  || operator_code == MULT_EXPR\n+\t  || operator_code == TRUNC_MOD_EXPR)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n+    warning (OPT_Weffc__, \"%qD should return by value\", decl);\n \n-      /* Effective C++ rule 23.  */\n-      if (warn_ecpp\n-\t  && arity == 2\n-\t  && !DECL_ASSIGNMENT_OPERATOR_P (decl)\n-\t  && (operator_code == PLUS_EXPR\n-\t      || operator_code == MINUS_EXPR\n-\t      || operator_code == TRUNC_DIV_EXPR\n-\t      || operator_code == MULT_EXPR\n-\t      || operator_code == TRUNC_MOD_EXPR)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n-\twarning (OPT_Weffc__, \"%qD should return by value\", decl);\n-\n-      /* [over.oper]/8 */\n-      for (; argtypes && argtypes != void_list_node;\n-\t  argtypes = TREE_CHAIN (argtypes))\n-\tif (TREE_PURPOSE (argtypes))\n-\t  {\n-\t    TREE_PURPOSE (argtypes) = NULL_TREE;\n-\t    if (operator_code == POSTINCREMENT_EXPR\n-\t\t|| operator_code == POSTDECREMENT_EXPR)\n-\t      {\n-\t\tpedwarn (input_location, OPT_Wpedantic, \"%qD cannot have default arguments\", \n-\t\t\t decl);\n-\t      }\n-\t    else\n-\t      {\n-\t\terror (\"%qD cannot have default arguments\", decl);\n-\t\treturn false;\n-\t      }\n-\t  }\n-    }\n   return true;\n }\n \f"}, {"sha": "ff7160eb3af31c775897117c2ef0a6b438256f19", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -462,10 +462,7 @@ unqualified_name_lookup_error (tree name, location_t loc)\n     loc = EXPR_LOC_OR_LOC (name, input_location);\n \n   if (IDENTIFIER_ANY_OP_P (name))\n-    {\n-      if (name != cp_operator_id (ERROR_MARK))\n-\terror_at (loc, \"%qD not defined\", name);\n-    }\n+    error_at (loc, \"%qD not defined\", name);\n   else\n     {\n       if (!objc_diagnose_private_ivar (name))"}, {"sha": "c31cd64c026d3e4708c08e6c49927b013aa130ba", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 66, "deletions": 51, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -14715,12 +14715,13 @@ cp_parser_operator (cp_parser* parser)\n   location_t start_loc = token->location;\n \n   /* Figure out which operator we have.  */\n+  enum tree_code op = ERROR_MARK;\n+  bool assop = false;\n+  bool consumed = false;\n   switch (token->type)\n     {\n     case CPP_KEYWORD:\n       {\n-\tenum tree_code op;\n-\n \t/* The keyword should be either `new' or `delete'.  */\n \tif (token->keyword == RID_NEW)\n \t  op = NEW_EXPR;\n@@ -14744,160 +14745,166 @@ cp_parser_operator (cp_parser* parser)\n \t    if (cp_token *close_token\n \t\t= cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))\n \t      end_loc = close_token->location;\n-\t    id = cp_operator_id (op == NEW_EXPR\n-\t\t\t      ? VEC_NEW_EXPR : VEC_DELETE_EXPR);\n+\t    op = op == NEW_EXPR ? VEC_NEW_EXPR : VEC_DELETE_EXPR;\n \t  }\n-\t/* Otherwise, we have the non-array variant.  */\n-\telse\n-\t  id = cp_operator_id (op);\n-\n-\tlocation_t loc = make_location (start_loc, start_loc, end_loc);\n-\n-\treturn cp_expr (id, loc);\n+\tstart_loc = make_location (start_loc, start_loc, end_loc);\n+\tconsumed = true;\n+\tbreak;\n       }\n \n     case CPP_PLUS:\n-      id = cp_operator_id (PLUS_EXPR);\n+      op = PLUS_EXPR;\n       break;\n \n     case CPP_MINUS:\n-      id = cp_operator_id (MINUS_EXPR);\n+      op = MINUS_EXPR;\n       break;\n \n     case CPP_MULT:\n-      id = cp_operator_id (MULT_EXPR);\n+      op = MULT_EXPR;\n       break;\n \n     case CPP_DIV:\n-      id = cp_operator_id (TRUNC_DIV_EXPR);\n+      op = TRUNC_DIV_EXPR;\n       break;\n \n     case CPP_MOD:\n-      id = cp_operator_id (TRUNC_MOD_EXPR);\n+      op = TRUNC_MOD_EXPR;\n       break;\n \n     case CPP_XOR:\n-      id = cp_operator_id (BIT_XOR_EXPR);\n+      op = BIT_XOR_EXPR;\n       break;\n \n     case CPP_AND:\n-      id = cp_operator_id (BIT_AND_EXPR);\n+      op = BIT_AND_EXPR;\n       break;\n \n     case CPP_OR:\n-      id = cp_operator_id (BIT_IOR_EXPR);\n+      op = BIT_IOR_EXPR;\n       break;\n \n     case CPP_COMPL:\n-      id = cp_operator_id (BIT_NOT_EXPR);\n+      op = BIT_NOT_EXPR;\n       break;\n \n     case CPP_NOT:\n-      id = cp_operator_id (TRUTH_NOT_EXPR);\n+      op = TRUTH_NOT_EXPR;\n       break;\n \n     case CPP_EQ:\n-      id = cp_assignment_operator_id (NOP_EXPR);\n+      assop = true;\n+      op = NOP_EXPR;\n       break;\n \n     case CPP_LESS:\n-      id = cp_operator_id (LT_EXPR);\n+      op = LT_EXPR;\n       break;\n \n     case CPP_GREATER:\n-      id = cp_operator_id (GT_EXPR);\n+      op = GT_EXPR;\n       break;\n \n     case CPP_PLUS_EQ:\n-      id = cp_assignment_operator_id (PLUS_EXPR);\n+      assop = true;\n+      op = PLUS_EXPR;\n       break;\n \n     case CPP_MINUS_EQ:\n-      id = cp_assignment_operator_id (MINUS_EXPR);\n+      assop = true;\n+      op = MINUS_EXPR;\n       break;\n \n     case CPP_MULT_EQ:\n-      id = cp_assignment_operator_id (MULT_EXPR);\n+      assop = true;\n+      op = MULT_EXPR;\n       break;\n \n     case CPP_DIV_EQ:\n-      id = cp_assignment_operator_id (TRUNC_DIV_EXPR);\n+      assop = true;\n+      op = TRUNC_DIV_EXPR;\n       break;\n \n     case CPP_MOD_EQ:\n-      id = cp_assignment_operator_id (TRUNC_MOD_EXPR);\n+      assop = true;\n+      op = TRUNC_MOD_EXPR;\n       break;\n \n     case CPP_XOR_EQ:\n-      id = cp_assignment_operator_id (BIT_XOR_EXPR);\n+      assop = true;\n+      op = BIT_XOR_EXPR;\n       break;\n \n     case CPP_AND_EQ:\n-      id = cp_assignment_operator_id (BIT_AND_EXPR);\n+      assop = true;\n+      op = BIT_AND_EXPR;\n       break;\n \n     case CPP_OR_EQ:\n-      id = cp_assignment_operator_id (BIT_IOR_EXPR);\n+      assop = true;\n+      op = BIT_IOR_EXPR;\n       break;\n \n     case CPP_LSHIFT:\n-      id = cp_operator_id (LSHIFT_EXPR);\n+      op = LSHIFT_EXPR;\n       break;\n \n     case CPP_RSHIFT:\n-      id = cp_operator_id (RSHIFT_EXPR);\n+      op = RSHIFT_EXPR;\n       break;\n \n     case CPP_LSHIFT_EQ:\n-      id = cp_assignment_operator_id (LSHIFT_EXPR);\n+      assop = true;\n+      op = LSHIFT_EXPR;\n       break;\n \n     case CPP_RSHIFT_EQ:\n-      id = cp_assignment_operator_id (RSHIFT_EXPR);\n+      assop = true;\n+      op = RSHIFT_EXPR;\n       break;\n \n     case CPP_EQ_EQ:\n-      id = cp_operator_id (EQ_EXPR);\n+      op = EQ_EXPR;\n       break;\n \n     case CPP_NOT_EQ:\n-      id = cp_operator_id (NE_EXPR);\n+      op = NE_EXPR;\n       break;\n \n     case CPP_LESS_EQ:\n-      id = cp_operator_id (LE_EXPR);\n+      op = LE_EXPR;\n       break;\n \n     case CPP_GREATER_EQ:\n-      id = cp_operator_id (GE_EXPR);\n+      op = GE_EXPR;\n       break;\n \n     case CPP_AND_AND:\n-      id = cp_operator_id (TRUTH_ANDIF_EXPR);\n+      op = TRUTH_ANDIF_EXPR;\n       break;\n \n     case CPP_OR_OR:\n-      id = cp_operator_id (TRUTH_ORIF_EXPR);\n+      op = TRUTH_ORIF_EXPR;\n       break;\n \n     case CPP_PLUS_PLUS:\n-      id = cp_operator_id (POSTINCREMENT_EXPR);\n+      op = POSTINCREMENT_EXPR;\n       break;\n \n     case CPP_MINUS_MINUS:\n-      id = cp_operator_id (PREDECREMENT_EXPR);\n+      op = PREDECREMENT_EXPR;\n       break;\n \n     case CPP_COMMA:\n-      id = cp_operator_id (COMPOUND_EXPR);\n+      op = COMPOUND_EXPR;\n       break;\n \n     case CPP_DEREF_STAR:\n-      id = cp_operator_id (MEMBER_REF);\n+      op = MEMBER_REF;\n       break;\n \n     case CPP_DEREF:\n-      id = cp_operator_id (COMPONENT_REF);\n+      op = COMPONENT_REF;\n       break;\n \n     case CPP_OPEN_PAREN:\n@@ -14907,15 +14914,19 @@ cp_parser_operator (cp_parser* parser)\n         parens.consume_open (parser);\n         /* Look for the matching `)'.  */\n         parens.require_close (parser);\n-        return cp_operator_id (CALL_EXPR);\n+\top = CALL_EXPR;\n+\tconsumed = true;\n+\tbreak;\n       }\n \n     case CPP_OPEN_SQUARE:\n       /* Consume the `['.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `]'.  */\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-      return cp_operator_id (ARRAY_REF);\n+      op = ARRAY_REF;\n+      consumed = true;\n+      break;\n \n     case CPP_UTF8STRING:\n     case CPP_UTF8STRING_USERDEF:\n@@ -14994,8 +15005,12 @@ cp_parser_operator (cp_parser* parser)\n \n   /* If we have selected an identifier, we need to consume the\n      operator token.  */\n-  if (id)\n-    cp_lexer_consume_token (parser->lexer);\n+  if (op != ERROR_MARK)\n+    {\n+      id = assop ? cp_assignment_operator_id (op) : cp_operator_id (op);\n+      if (!consumed)\n+\tcp_lexer_consume_token (parser->lexer);\n+    }\n   /* Otherwise, no valid operator name was present.  */\n   else\n     {"}, {"sha": "a7dc418a0d158e3f095311686af72f33622b8bec", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -9045,10 +9045,11 @@ check_return_expr (tree retval, bool *no_warning)\n \t/* You can return a `void' value from a function of `void'\n \t   type.  In that case, we have to evaluate the expression for\n \t   its side-effects.  */\n-\t  finish_expr_stmt (retval);\n+\tfinish_expr_stmt (retval);\n       else\n-\tpermerror (input_location, \"return-statement with a value, in function \"\n-\t\t   \"returning 'void'\");\n+\tpermerror (input_location,\n+\t\t   \"return-statement with a value, in function \"\n+\t\t   \"returning %qT\", valtype);\n       current_function_returns_null = 1;\n \n       /* There's really no value to return, after all.  */"}, {"sha": "ad5d9172a3596fd227877e4c765b3ded5fd9d488", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -1,3 +1,8 @@\n+2017-10-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/other/operator2.C: Adjust diagnostic.\n+\t* g++.old-deja/g++.jason/operator.C: Likewise.\n+\n 2017-10-30  Steven Munroe  <munroesj@gcc.gnu.org>\n \n \t* sse2-check.h: New file."}, {"sha": "cc68d53354e4ffc817a8b0d9c2dade18c4e46e12", "filename": "gcc/testsuite/g++.dg/other/operator2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Foperator2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Foperator2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Foperator2.C?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -3,7 +3,7 @@\n \n struct A\n {\n-  operator int&(int);  // { dg-error \"void\" }\n+  operator int&(int);  // { dg-error \"no arguments\" }\n };\n \n A a;"}, {"sha": "bdcd5493a97e57b134c1a444e017103d39725f59", "filename": "gcc/testsuite/g++.old-deja/g++.jason/operator.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6304874e9f0c56ef675deb7f71124348fae922/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C?ref=ff6304874e9f0c56ef675deb7f71124348fae922", "patch": "@@ -9,7 +9,7 @@ struct A {\n   static int operator()(int a);\t   // { dg-error \"must be a nonstatic member\" }\n   static int operator+(A,A);\t   // { dg-error \"either a non-static member\" } \n   int operator+(int a, int b = 1); // { dg-error \"either zero or one\" }\n-  int operator++(char);\t\t   // { dg-error \"must take 'int'\" } \n+  int operator++(char);\t\t   // { dg-error \"must have 'int'\" }\n   void operator delete (void *);   \n   void operator delete (void *, unsigned long);\t\n };"}]}