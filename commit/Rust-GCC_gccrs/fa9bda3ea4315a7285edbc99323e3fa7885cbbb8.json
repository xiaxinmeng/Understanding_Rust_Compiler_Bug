{"sha": "fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "node_id": "C_kwDOANBUbNoAKGZhOWJkYTNlYTQzMTVhNzI4NWVkYmM5OTMyM2UzZmE3ODg1Y2JiYjg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-27T19:59:05Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-28T23:33:36Z"}, "message": "libstdc++: Make INVOKE<R> refuse to create dangling references [PR70692]\n\nThis is the next part of the library changes from P2255R2. This makes\nINVOKE<R> ill-formed if converting the INVOKE expression to R would bind\na reference to a temporary object.\n\nThe is_invocable_r trait is now false if the invocation would create a\ndangling reference. This is done by adding the dangling check to the\n__is_invocable_impl partial specialization used for INVOKE<R>\nexpressions. This change also slightly simplifies the nothrow checking\nrecently added to that partial specialization.\n\nThis change also removes the is_invocable_r checks from the pre-C++17\nimplementation of std::__invoke_r, because there is no need for it to be\nSFINAE-friendly. None of our C++11 and C++14 uses of INVOKE<R> require\nthose constraints. The std::function constructor needs to check\nis_invocable_r, but that's already done explicitly, so we don't need to\nrecheck when calling __is_invoke_r in std::function::operator(). The\nother uses of std::__is_invoke_r do not need to be constrained and can\njust be ill-formed if the INVOKE<R> expression is ill-formed.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/70692\n\t* include/bits/invoke.h [__cplusplus < 201703] (__invoke_r):\n\tRemove is_invocable and is_convertible constraints.\n\t* include/std/type_traits (__is_invocable_impl::_S_conv): Use\n\tnon-deduced context for parameter.\n\t(__is_invocable_impl::_S_test): Remove _Check_noex template\n\tparameter and use deduced noexcept value in its place. Add bool\n\tparameter to detect dangling references.\n\t(__is_invocable_impl::type): Adjust call to _S_test to avoid\n\tdeducing unnecessary noexcept property..\n\t(__is_invocable_impl::__nothrow_type): Rename to ...\n\t(__is_invocable_impl::__nothrow_conv): ... this. Adjust call\n\tto _S_test to deduce noexcept property.\n\t* testsuite/20_util/bind/dangling_ref.cc: New test.\n\t* testsuite/20_util/function/cons/70692.cc: New test.\n\t* testsuite/20_util/function_objects/invoke/dangling_ref.cc:\n\tNew test.\n\t* testsuite/20_util/is_invocable/dangling_ref.cc: New test.\n\t* testsuite/30_threads/packaged_task/cons/dangling_ref.cc:\n\tNew test.", "tree": {"sha": "eb182b250a0752c9019a0f2335fd4df50ae32245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb182b250a0752c9019a0f2335fd4df50ae32245"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1adf45b17f7f1ede463524d80032bb2ec866ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1adf45b17f7f1ede463524d80032bb2ec866ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1adf45b17f7f1ede463524d80032bb2ec866ead"}], "stats": {"total": 108, "additions": 80, "deletions": 28}, "files": [{"sha": "8724a764f7390e42a437753d6855ca166af31ed7", "filename": "libstdc++-v3/include/bits/invoke.h", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Finvoke.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Finvoke.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Finvoke.h?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -115,37 +115,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t  std::forward<_Callable>(__fn),\n \t\t\t\t\t  std::forward<_Args>(__args)...);\n     }\n-#else // C++11\n-  template<typename _Res, typename _Callable, typename... _Args>\n-    using __can_invoke_as_void = __enable_if_t<\n-      __and_<is_void<_Res>, __is_invocable<_Callable, _Args...>>::value,\n-      _Res\n-    >;\n-\n-  template<typename _Res, typename _Callable, typename... _Args>\n-    using __can_invoke_as_nonvoid = __enable_if_t<\n-      __and_<__not_<is_void<_Res>>,\n-\t     is_convertible<typename __invoke_result<_Callable, _Args...>::type,\n-\t\t\t    _Res>\n-      >::value,\n-      _Res\n-    >;\n+#else // C++11 or C++14\n+  // This is a non-SFINAE-friendly std::invoke_r<R>(fn, args...) for C++11/14.\n+  // It's used in std::function, std::bind, and std::packaged_task. Only\n+  // std::function is constrained on is_invocable_r, but that is checked on\n+  // construction so doesn't need to be checked again when calling __invoke_r.\n+  // Consequently, these __invoke_r overloads do not check for invocable\n+  // arguments, nor check that the invoke result is convertible to R.\n \n   // INVOKE<R>: Invoke a callable object and convert the result to R.\n   template<typename _Res, typename _Callable, typename... _Args>\n-    constexpr __can_invoke_as_nonvoid<_Res, _Callable, _Args...>\n+    constexpr __enable_if_t<!is_void<_Res>::value, _Res>\n     __invoke_r(_Callable&& __fn, _Args&&... __args)\n     {\n       using __result = __invoke_result<_Callable, _Args...>;\n       using __type = typename __result::type;\n+      static_assert(!__reference_converts_from_temporary(_Res, __type),\n+\t\t    \"INVOKE<R> must not create a dangling reference\");\n       using __tag = typename __result::__invoke_type;\n       return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),\n \t\t\t\t\tstd::forward<_Args>(__args)...);\n     }\n \n   // INVOKE<R> when R is cv void\n   template<typename _Res, typename _Callable, typename... _Args>\n-    _GLIBCXX14_CONSTEXPR __can_invoke_as_void<_Res, _Callable, _Args...>\n+    _GLIBCXX14_CONSTEXPR __enable_if_t<is_void<_Res>::value, _Res>\n     __invoke_r(_Callable&& __fn, _Args&&... __args)\n     {\n       using __result = __invoke_result<_Callable, _Args...>;\n@@ -154,7 +148,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),\n \t\t\t\t std::forward<_Args>(__args)...);\n     }\n-#endif // C++11\n+#endif // C++11 or C++14\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}, {"sha": "22c1af26397ee3d40e99b63c7e15ff2211465afe", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -2864,7 +2864,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_invocable_impl\n     : false_type\n     {\n-      using __nothrow_type = false_type; // For is_nothrow_invocable_r\n+      using __nothrow_conv = false_type; // For is_nothrow_invocable_r\n     };\n \n   // Used for valid INVOKE and INVOKE<void> expressions.\n@@ -2874,7 +2874,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t       __void_t<typename _Result::type>>\n     : true_type\n     {\n-      using __nothrow_type = true_type; // For is_nothrow_invocable_r\n+      using __nothrow_conv = true_type; // For is_nothrow_invocable_r\n     };\n \n #pragma GCC diagnostic push\n@@ -2887,18 +2887,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n     private:\n       // The type of the INVOKE expression.\n+      using _Res_t = typename _Result::type;\n+\n       // Unlike declval, this doesn't add_rvalue_reference, so it respects\n       // guaranteed copy elision.\n-      static typename _Result::type _S_get() noexcept;\n+      static _Res_t _S_get() noexcept;\n \n+      // Used to check if _Res_t can implicitly convert to _Tp.\n       template<typename _Tp>\n-\tstatic void _S_conv(_Tp) noexcept;\n+\tstatic void _S_conv(__type_identity_t<_Tp>) noexcept;\n \n       // This overload is viable if INVOKE(f, args...) can convert to _Tp.\n-      template<typename _Tp, bool _Check_Noex = false,\n+      template<typename _Tp,\n+\t       bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),\n \t       typename = decltype(_S_conv<_Tp>(_S_get())),\n-\t       bool _Noex = noexcept(_S_conv<_Tp>(_S_get()))>\n-\tstatic __bool_constant<_Check_Noex ? _Noex : true>\n+\t       bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)>\n+\tstatic __bool_constant<_Nothrow && !_Dangle>\n \t_S_test(int);\n \n       template<typename _Tp, bool = false>\n@@ -2907,10 +2911,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     public:\n       // For is_invocable_r\n-      using type = decltype(_S_test<_Ret>(1));\n+      using type = decltype(_S_test<_Ret, /* Nothrow = */ true>(1));\n \n       // For is_nothrow_invocable_r\n-      using __nothrow_type = decltype(_S_test<_Ret, true>(1));\n+      using __nothrow_conv = decltype(_S_test<_Ret>(1));\n     };\n #pragma GCC diagnostic pop\n \n@@ -3041,9 +3045,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   /// @cond undocumented\n+  // This checks that the INVOKE<R> expression is well-formed and that the\n+  // conversion to R does not throw. It does *not* check whether the INVOKE\n+  // expression itself can throw. That is done by __call_is_nothrow_ instead.\n   template<typename _Result, typename _Ret>\n     using __is_nt_invocable_impl\n-      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_type;\n+      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;\n   /// @endcond\n \n   /// std::is_nothrow_invocable_r"}, {"sha": "70393e4392f8b5bd9c6b413defa347dfcfb41c26", "filename": "libstdc++-v3/testsuite/20_util/bind/dangling_ref.cc", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fdangling_ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fdangling_ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fdangling_ref.cc?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile { target c++11 } }\n+#include <functional>\n+\n+int f();\n+auto b = std::bind<const int&>(f);\n+int i = b(); // { dg-error \"here\" \"\" { target { c++14_down } } }\n+// { dg-error \"dangling reference\" \"\" { target { c++14_down } } 0 }\n+// { dg-error \"no matching function\" \"\" { target c++17 } 0 }\n+// { dg-error \"enable_if\" \"\" { target c++17 } 0 }"}, {"sha": "7cdc472497e4b2f30326c4ba6e8dc0e2cd336a60", "filename": "libstdc++-v3/testsuite/20_util/function/cons/70692.cc", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2F70692.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2F70692.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2F70692.cc?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++11 } }\n+// PR libstdc++/70692\n+// No warning when function<const int&(...)> binds a reference to a temporary\n+#include <functional>\n+\n+int f();\n+\n+int main()\n+{\n+  std::function<const int&()> ff(f);  // { dg-error \"no matching function\" }\n+  std::function<long&&()> f2(f);      // { dg-error \"no matching function\" }\n+}\n+// { dg-error \"std::enable_if\" \"\" { target *-*-* } 0 }"}, {"sha": "1513480bd8fc16b76b41efaf5de7cf65bf1569e4", "filename": "libstdc++-v3/testsuite/20_util/function_objects/invoke/dangling_ref.cc", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Finvoke%2Fdangling_ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Finvoke%2Fdangling_ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Finvoke%2Fdangling_ref.cc?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+#include <functional>\n+\n+int f();\n+\n+template<typename R>\n+concept can_invoke = requires (int (&f)()) { std::invoke_r<R>(f); };\n+\n+static_assert( not can_invoke<const int&> );\n+static_assert( not can_invoke<int&&> );\n+static_assert( not can_invoke<const long&> );"}, {"sha": "46719b9bd95cc3e8d466f4327a52d5641aa10213", "filename": "libstdc++-v3/testsuite/20_util/is_invocable/dangling_ref.cc", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fdangling_ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fdangling_ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_invocable%2Fdangling_ref.cc?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile { target c++17 } }\n+#include <type_traits>\n+\n+static_assert( not std::is_invocable_r_v<const int&, int()> );\n+static_assert( not std::is_invocable_r_v<int&&, int()> );\n+static_assert( not std::is_invocable_r_v<const long&, int()> );"}, {"sha": "e9edb5edc8bed4234b69ea8a2609ec916ac69d95", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/dangling_ref.cc", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fdangling_ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa9bda3ea4315a7285edbc99323e3fa7885cbbb8/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fdangling_ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fdangling_ref.cc?ref=fa9bda3ea4315a7285edbc99323e3fa7885cbbb8", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++11 } }\n+#include <future>\n+\n+// C++20 [futures.task.members]\n+// Mandates: is_invocable_r_v<R, F&, ArgTypes...> is true.\n+\n+int f();\n+std::packaged_task<const int&()> task(f);\n+// { dg-error \"dangling reference\" \"\" { target { c++14_down } } 0 }\n+// { dg-error \"no matching function\" \"\" { target c++17 } 0 }\n+// { dg-error \"enable_if\" \"\" { target c++17 } 0 }"}]}