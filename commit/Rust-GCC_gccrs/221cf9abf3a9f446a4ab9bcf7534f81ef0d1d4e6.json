{"sha": "221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIxY2Y5YWJmM2E5ZjQ0NmE0YWI5YmNmNzUzNGY4MWVmMGQxZDRlNg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2009-08-10T04:38:02Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2009-08-10T04:38:02Z"}, "message": "alpha.c (struct machine_function): New flag for VMS, uses_condition_handler.\n\n\n\t* config/alpha/alpha.c (struct machine_function): New flag for VMS,\n\tuses_condition_handler.\n\t(alpha_expand_builtin_establish_vms_condition_handler): New expander.\n\t(alpha_expand_builtin_revert_vms_condition_handler): New expander.\n\t(enum alpha_builtin): New ALPHA_BUILTIN_REVERT_VMS_CONDITION_HANDLER\n\tand ALPHA_BUILTIN_ESTABLISH_VMS_CONDITION_HANDLER values.\n\t(code_for_builtin): New insn codes for the new alpha_builtins.\n\t(alpha_init_builtins): Register the new functions as BUILT_IN_MD.\n\t(alpha_sa_size): Account for uses_condition_handler.\n\t(alpha_expand_prologue): Likewise.\n\t(alpha_start_function): Likewise.\n\t(alpha_expand_epilogue): Likewise.\n\t* config/alpha/alpha-protos.h: Prototype the new alpha.c builtin\n\testablish/revert expanders.\n\t* config/alpha/alpha.h (DWARF_FRAME_REGNUM): Define.\n\t* config/alpha/alpha.md\t(builtin_establish_vms_condition_handler):\n\tNew expander, resorting to the alpha.c associated function.\n\t(builtin_revert_vms_condition_handler): Likewise.\n\t* config/alpha/vms-gcc_shell_handler.c: New file. Implements\n\t__gcc_shell_handler, the static VMS condition handler used as\n\tan indirection wrapper to the current dynamically established\n\thandler.\n\t* config/alpha/vms-unwind.h: Complete rewrite.\n\t* config/alpha/t-vms (LIB2FUNCS_EXTRA): Add vms-gcc_shell_handler.c\n\t* config/alpha/vms.h (MD_UNWIND_SUPPORT):\n\t\n\nCo-Authored-By: Douglas B Rupp <rupp@gnat.com>\n\nFrom-SVN: r150612", "tree": {"sha": "f94897c69f91dfc8c84467b5f742fe05f551e72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f94897c69f91dfc8c84467b5f742fe05f551e72f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b714133e38d25ba3a6df1eb668ead8e0da7f8f62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b714133e38d25ba3a6df1eb668ead8e0da7f8f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b714133e38d25ba3a6df1eb668ead8e0da7f8f62"}], "stats": {"total": 625, "additions": 563, "deletions": 62}, "files": [{"sha": "f9f6ac7d9e00311e44a4e10c79de64cc1b77a93e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -1,3 +1,32 @@\n+2009-08-09  Olivier Hainque  <hainque@adacore.com>\n+            Douglas B Rupp  <rupp@gnat.com>\n+\n+\t* config/alpha/alpha.c (struct machine_function): New flag for VMS,\n+\tuses_condition_handler.\n+\t(alpha_expand_builtin_establish_vms_condition_handler): New expander.\n+\t(alpha_expand_builtin_revert_vms_condition_handler): New expander.\n+\t(enum alpha_builtin): New ALPHA_BUILTIN_REVERT_VMS_CONDITION_HANDLER\n+\tand ALPHA_BUILTIN_ESTABLISH_VMS_CONDITION_HANDLER values.\n+\t(code_for_builtin): New insn codes for the new alpha_builtins.\n+\t(alpha_init_builtins): Register the new functions as BUILT_IN_MD.\n+\t(alpha_sa_size): Account for uses_condition_handler.\n+\t(alpha_expand_prologue): Likewise.\n+\t(alpha_start_function): Likewise.\n+\t(alpha_expand_epilogue): Likewise.\n+\t* config/alpha/alpha-protos.h: Prototype the new alpha.c builtin\n+\testablish/revert expanders.\n+\t* config/alpha/alpha.h (DWARF_FRAME_REGNUM): Define.\n+\t* config/alpha/alpha.md\t(builtin_establish_vms_condition_handler):\n+\tNew expander, resorting to the alpha.c associated function.\n+\t(builtin_revert_vms_condition_handler): Likewise.\n+\t* config/alpha/vms-gcc_shell_handler.c: New file. Implements\n+\t__gcc_shell_handler, the static VMS condition handler used as\n+\tan indirection wrapper to the current dynamically established\n+\thandler.\n+\t* config/alpha/vms-unwind.h: Complete rewrite.\n+\t* config/alpha/t-vms (LIB2FUNCS_EXTRA): Add vms-gcc_shell_handler.c\n+\t* config/alpha/vms.h (MD_UNWIND_SUPPORT):\n+\t\n 2009-08-09  Eric Botcazou  <botcazou@adacore.com>\n             Douglas B Rupp  <rupp@gnat.com>\n "}, {"sha": "244ff71d6027d7e9d8293c46b989a7297997a69b", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -67,6 +67,9 @@ extern rtx alpha_expand_zap_mask (HOST_WIDE_INT);\n extern void alpha_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n \t\t\t\t\t       enum machine_mode,\n \t\t\t\t\t       rtx, rtx, rtx);\n+extern void alpha_expand_builtin_establish_vms_condition_handler (rtx, rtx);\n+extern void alpha_expand_builtin_revert_vms_condition_handler (rtx);\n+\n extern rtx alpha_return_addr (int, rtx);\n extern rtx alpha_gp_save_rtx (void);\n extern void print_operand (FILE *, rtx, int);"}, {"sha": "38579093a11caf0dcf62496175c26d83e1376e21", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 99, "deletions": 6, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -4779,6 +4779,9 @@ struct GTY(()) machine_function\n \n   /* For TARGET_LD_BUGGY_LDGP.  */\n   struct rtx_def *gp_save_rtx;\n+\n+  /* For VMS condition handlers.  */\n+  bool uses_condition_handler;  \n };\n \n /* How to allocate a 'struct machine_function'.  */\n@@ -4790,6 +4793,63 @@ alpha_init_machine_status (void)\n \t\tggc_alloc_cleared (sizeof (struct machine_function)));\n }\n \n+/* Support for frame based VMS condition handlers.  */\n+\n+/* A VMS condition handler may be established for a function with a call to\n+   __builtin_establish_vms_condition_handler, and cancelled with a call to\n+   __builtin_revert_vms_condition_handler.\n+\n+   The VMS Condition Handling Facility knows about the existence of a handler\n+   from the procedure descriptor .handler field.  As the VMS native compilers,\n+   we store the user specified handler's address at a fixed location in the\n+   stack frame and point the procedure descriptor at a common wrapper which\n+   fetches the real handler's address and issues an indirect call.\n+\n+   The indirection wrapper is \"__gcc_shell_handler\", provided by libgcc.\n+\n+   We force the procedure kind to PT_STACK, and the fixed frame location is\n+   fp+8, just before the register save area. We use the handler_data field in\n+   the procedure descriptor to state the fp offset at which the installed\n+   handler address can be found.  */\n+\n+#define VMS_COND_HANDLER_FP_OFFSET 8\n+\n+/* Expand code to store the currently installed user VMS condition handler\n+   into TARGET and install HANDLER as the new condition handler.  */\n+\n+void\n+alpha_expand_builtin_establish_vms_condition_handler (rtx target, rtx handler)\n+{\n+  rtx handler_slot_address\n+    = plus_constant (hard_frame_pointer_rtx, VMS_COND_HANDLER_FP_OFFSET);\n+\n+  rtx handler_slot\n+    = gen_rtx_MEM (DImode, handler_slot_address);\n+\n+  emit_move_insn (target, handler_slot);\n+  emit_move_insn (handler_slot, handler);\n+\n+  /* Notify the start/prologue/epilogue emitters that the condition handler\n+     slot is needed.  In addition to reserving the slot space, this will force\n+     the procedure kind to PT_STACK so ensure that the hard_frame_pointer_rtx\n+     use above is correct.  */\n+  cfun->machine->uses_condition_handler = true;\n+}\n+\n+/* Expand code to store the current VMS condition handler into TARGET and\n+   nullify it.  */\n+\n+void\n+alpha_expand_builtin_revert_vms_condition_handler (rtx target)\n+{\n+  /* We implement this by establishing a null condition handler, with the tiny\n+     side effect of setting uses_condition_handler.  This is a little bit\n+     pessimistic if no actual builtin_establish call is ever issued, which is\n+     not a real problem and expected never to happen anyway.  */\n+\n+  alpha_expand_builtin_establish_vms_condition_handler (target, const0_rtx);\n+}\n+\n /* Functions to save and restore alpha_return_addr_rtx.  */\n \n /* Start the ball rolling with RETURN_ADDR_RTX.  */\n@@ -6380,6 +6440,8 @@ enum alpha_builtin\n   ALPHA_BUILTIN_RPCC,\n   ALPHA_BUILTIN_THREAD_POINTER,\n   ALPHA_BUILTIN_SET_THREAD_POINTER,\n+  ALPHA_BUILTIN_ESTABLISH_VMS_CONDITION_HANDLER,\n+  ALPHA_BUILTIN_REVERT_VMS_CONDITION_HANDLER,\n \n   /* TARGET_MAX */\n   ALPHA_BUILTIN_MINUB8,\n@@ -6435,6 +6497,8 @@ static enum insn_code const code_for_builtin[ALPHA_BUILTIN_max] = {\n   CODE_FOR_builtin_rpcc,\n   CODE_FOR_load_tp,\n   CODE_FOR_set_tp,\n+  CODE_FOR_builtin_establish_vms_condition_handler,\n+  CODE_FOR_builtin_revert_vms_condition_handler,\n \n   /* TARGET_MAX */\n   CODE_FOR_builtin_minub8,\n@@ -6580,6 +6644,21 @@ alpha_init_builtins (void)\n \t\t\t       NULL, NULL);\n   TREE_NOTHROW (decl) = 1;\n \n+  if (TARGET_ABI_OPEN_VMS)\n+    {\n+      ftype = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t\tNULL_TREE);\n+      add_builtin_function (\"__builtin_establish_vms_condition_handler\", ftype,\n+\t\t\t    ALPHA_BUILTIN_ESTABLISH_VMS_CONDITION_HANDLER,\n+\t\t\t    BUILT_IN_MD, NULL, NULL_TREE);\n+\n+      ftype = build_function_type_list (ptr_type_node, void_type_node,\n+\t\t\t\t\tNULL_TREE);\n+      add_builtin_function (\"__builtin_revert_vms_condition_handler\", ftype,\n+\t\t\t    ALPHA_BUILTIN_REVERT_VMS_CONDITION_HANDLER,\n+\t\t\t     BUILT_IN_MD, NULL, NULL_TREE);\n+    }\n+\n   alpha_v8qi_u = build_vector_type (unsigned_intQI_type_node, 8);\n   alpha_v8qi_s = build_vector_type (intQI_type_node, 8);\n   alpha_v4hi_u = build_vector_type (unsigned_intHI_type_node, 4);\n@@ -7309,7 +7388,10 @@ alpha_sa_size (void)\n \t  if (! fixed_regs[i] && call_used_regs[i] && ! df_regs_ever_live_p (i))\n \t    vms_save_fp_regno = i;\n \n-      if (vms_save_fp_regno == -1 && alpha_procedure_type == PT_REGISTER)\n+      /* A VMS condition handler requires a stack procedure in our\n+\t implementation. (not required by the calling standard).  */\n+      if ((vms_save_fp_regno == -1 && alpha_procedure_type == PT_REGISTER)\n+\t  || cfun->machine->uses_condition_handler)\n \tvms_base_regno = REG_PV, alpha_procedure_type = PT_STACK;\n       else if (alpha_procedure_type == PT_NULL)\n \tvms_base_regno = REG_PV;\n@@ -7318,9 +7400,10 @@ alpha_sa_size (void)\n       vms_unwind_regno = (vms_base_regno == REG_PV\n \t\t\t  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n \n-      /* If this is a stack procedure, allow space for saving FP and RA.  */\n+      /* If this is a stack procedure, allow space for saving FP, RA and\n+\t a condition handler slot if needed.  */\n       if (alpha_procedure_type == PT_STACK)\n-\tsa_size += 2;\n+\tsa_size += 2 + cfun->machine->uses_condition_handler;\n     }\n   else\n     {\n@@ -7572,7 +7655,7 @@ alpha_expand_prologue (void)\n \t\t\t\t + crtl->args.pretend_args_size));\n \n   if (TARGET_ABI_OPEN_VMS)\n-    reg_offset = 8;\n+    reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;\n   else\n     reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n@@ -7910,7 +7993,7 @@ alpha_start_function (FILE *file, const char *fnname,\n \t\t\t\t + crtl->args.pretend_args_size));\n \n   if (TARGET_ABI_OPEN_VMS)\n-    reg_offset = 8;\n+    reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;\n   else\n     reg_offset = ALPHA_ROUND (crtl->outgoing_args_size);\n \n@@ -8049,6 +8132,16 @@ alpha_start_function (FILE *file, const char *fnname,\n     }\n \n #if TARGET_ABI_OPEN_VMS\n+  /* If a user condition handler has been installed at some point, emit\n+     the procedure descriptor bits to point the Condition Handling Facility\n+     at the indirection wrapper, and state the fp offset at which the user\n+     handler may be found.  */\n+  if (cfun->machine->uses_condition_handler)\n+    {\n+      fprintf (file, \"\\t.handler __gcc_shell_handler\\n\");\n+      fprintf (file, \"\\t.handler_data %d\\n\", VMS_COND_HANDLER_FP_OFFSET);\n+    }\n+\n   /* Ifdef'ed cause link_section are only available then.  */\n   switch_to_section (readonly_data_section);\n   fprintf (file, \"\\t.align 3\\n\");\n@@ -8120,7 +8213,7 @@ alpha_expand_epilogue (void)\n   if (TARGET_ABI_OPEN_VMS)\n     {\n        if (alpha_procedure_type == PT_STACK)\n-          reg_offset = 8;\n+          reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;\n        else\n           reg_offset = 0;\n     }"}, {"sha": "cd8c11e32867f9c1d09c6d965707c89c5f76dfaf", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -882,6 +882,12 @@ do {\t\t\t\t\t\t\\\n \n #define RETURN_ADDR_RTX  alpha_return_addr\n \n+/* Provide a definition of DWARF_FRAME_REGNUM here so that fallback unwinders\n+   can use DWARF_ALT_FRAME_RETURN_COLUMN defined below.  This is just the same\n+   as the default definition in dwarf2out.c.  */\n+#undef DWARF_FRAME_REGNUM\n+#define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)\n+\n /* Before the prologue, RA lives in $26.  */\n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)\n #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (26)"}, {"sha": "935cc943b0636b6c55bd1626f0999bead414bfaf", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -4976,6 +4976,24 @@\n     return \"call_pal 0x9f\";\n }\n   [(set_attr \"type\" \"callpal\")])\n+\n+;; Special builtins for establishing and reverting VMS condition handlers.\n+\n+(define_expand \"builtin_establish_vms_condition_handler\"\n+  [(set (reg:DI 0) (match_operand:DI 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"address_operand\" \"\"))]\n+  \"TARGET_ABI_OPEN_VMS\"\n+{\n+  alpha_expand_builtin_establish_vms_condition_handler (operands[0],\n+                                                        operands[1]);\n+})\n+\n+(define_expand \"builtin_revert_vms_condition_handler\"\n+  [(set (reg:DI 0) (match_operand:DI 0 \"register_operand\" \"\"))]\n+  \"TARGET_ABI_OPEN_VMS\"\n+{\n+  alpha_expand_builtin_revert_vms_condition_handler (operands[0]);\n+})\n \f\n ;; Finally, we have the basic data motion insns.  The byte and word insns\n ;; are done via define_expand.  Start with the floating-point insns, since"}, {"sha": "410e219ff5bb25a91cb539cc6dd5c096f166babf", "filename": "gcc/config/alpha/t-vms", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Ft-vms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Ft-vms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-vms?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -17,6 +17,8 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n+LIB2FUNCS_EXTRA = $(srcdir)/config/alpha/vms-gcc_shell_handler.c\n+\n EXTRA_PARTS = vms-dwarf2.o vms-dwarf2eh.o $(VMS_EXTRA_PARTS) \\\n   crtbegin.o crtbeginS.o crtend.o crtendS.o\n "}, {"sha": "67d0fe7f9aa5a0b2328e99a806b73c8daa76d734", "filename": "gcc/config/alpha/vms-gcc_shell_handler.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Fvms-gcc_shell_handler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Fvms-gcc_shell_handler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-gcc_shell_handler.c?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -0,0 +1,124 @@\n+/* Static condition handler for Alpha/VMS.\n+   Copyright (C) 2005-2009\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements __gcc_shell_handler, the static VMS condition handler\n+   used as the indirection wrapper around user level handlers installed with\n+   establish_vms_condition_handler GCC builtin.\n+\n+   [ABI] in comments refers to the \"HP OpenVMS calling standard\" document\n+   dated January 2005.  */\n+\n+#include <vms/chfdef.h>\n+#include <vms/pdscdef.h>\n+#include <vms/ssdef.h>\n+\n+typedef void * ADDR;\n+typedef unsigned long long REG;\n+\n+#define REG_AT(addr) (*(REG *)(addr))\n+\n+/* Compute pointer to procedure descriptor (Procedure Value) from Frame\n+   Pointer FP, according to the rules in [ABI-3.5.1 Current Procedure].  */\n+#define PV_FOR(FP) \\\n+  (((FP) != 0) \\\n+    ? (((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP)) : 0)\n+\n+long\n+__gcc_shell_handler (struct chf$signal_array *sig_arr,\n+\t\t     struct chf$mech_array *mech_arr);\n+\n+/* Helper for __gcc_shell_handler.  Fetch the pointer to procedure currently\n+   registered as the VMS condition handler for the live function with a frame\n+   pointer FP.  */\n+\n+static ADDR\n+get_dyn_handler_pointer (REG fp)\n+{\n+  /* From the frame pointer we find the procedure descriptor, and fetch\n+     the handler_data field from there.  This field contains the offset\n+     from FP at which the address of the currently installed handler is\n+     to be found.  */\n+  \n+  PDSCDEF * pd = PV_FOR (fp);\n+  /* Procedure descriptor pointer for the live subprogram with FP as the frame\n+     pointer, and to which _gcc_shell_handler is attached as a condition\n+     handler.  */\n+\n+  REG handler_slot_offset;\n+  /* Offset from FP at which the address of the currently established real\n+     condition handler is to be found.  This offset is available from the\n+     handler_data field of the procedure descriptor.  */\n+\n+  REG handler_data_offset;\n+  /* The handler_data field position in the procedure descriptor, which\n+     depends on the kind of procedure at hand.  */\n+\n+  switch (pd->pdsc$w_flags & 0xf)\n+    {\n+    case PDSC$K_KIND_FP_STACK:    /* [3.4.2 PD for stack frame procedures]  */\n+      handler_data_offset = 40;\n+      break;\n+\t\n+    case PDSC$K_KIND_FP_REGISTER: /* [3.4.5 PD for reg frame procedures]  */\n+      handler_data_offset = 32;\n+      break;\n+      \n+    default:\n+      handler_data_offset = 0;\n+      break;\n+    }\n+\n+  /* If we couldn't determine the handler_data field position, give up.  */\n+  if (handler_data_offset == 0)\n+    return 0;\n+\n+  /* Otherwise, fetch the fp offset at which the real handler address is to be\n+     found, then fetch and return the latter in turn.  */\n+     \n+  handler_slot_offset = REG_AT ((REG)pd + handler_data_offset);\n+\n+  return (ADDR) REG_AT (fp + handler_slot_offset);\n+}\n+\n+/* The static VMS condition handler for GCC code.  Fetch the address of the\n+   currently established condition handler, then resignal if there is none or\n+   call the handler with the VMS condition arguments.  */\n+\n+long\n+__gcc_shell_handler (struct chf$signal_array *sig_arr,\n+\t\t     struct chf$mech_array *mech_arr)\n+{\n+  long ret;\n+  long (*user_handler) (struct chf$signal_array *, struct chf$mech_array *);\n+\n+  user_handler = get_dyn_handler_pointer (mech_arr->chf$q_mch_frame);\n+  if (!user_handler)\n+    ret = SS$_RESIGNAL;\n+  else\n+    ret = user_handler (sig_arr, mech_arr);\n+\n+  return ret;\n+}\n+   "}, {"sha": "09b2f8f23e0afce1091975954ff2815982cca3bc", "filename": "gcc/config/alpha/vms-unwind.h", "status": "modified", "additions": 276, "deletions": 56, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Fvms-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Fvms-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-unwind.h?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -1,71 +1,291 @@\n-/* DWARF2 EH unwinding support for Alpha VMS.\n-   Copyright (C) 2004, 2007 Free Software Foundation, Inc.\n+/* Fallback frame unwinding for Alpha/VMS.\n+   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2009\n+   Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n \n-#include <pdscdef.h>\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n-#define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <vms/pdscdef.h>\n+#include <vms/libicb.h>\n+#include <vms/chfctxdef.h>\n+#include <vms/chfdef.h>\n \n-static _Unwind_Reason_Code\n-alpha_fallback_frame_state (struct _Unwind_Context *context,\n-\t\t\t    _Unwind_FrameState *fs)\n+#define MD_FALLBACK_FRAME_STATE_FOR alpha_vms_fallback_frame_state\n+\n+typedef void * ADDR;\n+typedef unsigned long long REG;\n+typedef PDSCDEF * PV;\n+\n+#define REG_AT(addr) (*(REG *)(addr))\n+#define ADDR_AT(addr) (*(ADDR *)(addr))\n+\n+/* Compute pointer to procedure descriptor (Procedure Value) from Frame\n+   Pointer FP, according to the rules in [ABI-3.5.1 Current Procedure].  */\n+#define PV_FOR(FP) \\\n+  (((FP) != 0) \\\n+    ? (((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP)) : 0)\n+\n+extern int SYS$GL_CALL_HANDL;\n+/* This is actually defined as a \"long\", but in system code where longs\n+   are always 4bytes while GCC longs might be 8bytes.  */\n+\n+#define UPDATE_FS_FOR_CFA_GR(FS, GRN, LOC, CFA) \\\n+do { \\\n+(FS)->regs.reg[GRN].how = REG_SAVED_OFFSET;      \\\n+(FS)->regs.reg[GRN].loc.offset = (_Unwind_Sword) ((REG) (LOC) - (REG) (CFA)); \\\n+} while (0);\n+\n+#define GIVEUP_ON_FAILURE(STATUS) \\\n+  { if ((((STATUS) & 1) != 1)) return _URC_END_OF_STACK; }\n+#define DENOTES_EXC_DISPATCHER(PV) ((PV) == (ADDR) (REG) SYS$GL_CALL_HANDL)\n+\n+#define RA_COLUMN (DWARF_ALT_FRAME_RETURN_COLUMN)\n+\n+static int\n+alpha_vms_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t\t_Unwind_FrameState *fs)\n {\n-  PDSCDEF *pv = *((PDSCDEF **) context->reg [29]);\n+  static int eh_debug = -1;\n+\n+  /* Our goal is to update FS to reflect the state one step up CONTEXT, that\n+     is: the CFA, return address and *saved* registers locations associated\n+     with the function designated by CONTEXT->ra.  We are called when the\n+     libgcc unwinder has not found any dwarf FDE for this address, which\n+     typically happens when trying to propagate a language exception through a\n+     signal global vector or frame based handler.\n+\n+     The CONTEXT->reg[] entries reflect the state/location of register saves\n+     so designate values live at the CONTEXT->ra point.  Of precious value to\n+     us here is the frame pointer (r29), which gets us a procedure value.  */\n+\n+  PV pv = (context->reg[29] != 0) ? PV_FOR (ADDR_AT (context->reg[29])) : 0;\n+\n+  int pkind = pv ? pv->pdsc$w_flags & 0xf : 0;\n+  /* VMS procedure kind, as indicated by the procedure descriptor.  We only\n+     know how to deal with FP_STACK or FP_REGISTER here.  */\n+\n+  ADDR new_cfa = 0;\n+  /* CFA we will establish for the caller, computed in different ways,\n+     e.g. depending whether we cross an exception dispatcher frame.  */\n+\n+  CHFCTX *chfctx = 0;\n+  /* Pointer to the VMS CHF context associated with an exception dispatcher\n+     frame, if we happen to come across one.  */\n+\n+  int i,j;\n+\n+  if (eh_debug == -1)\n+    {\n+      char * eh_debug_env = getenv (\"EH_DEBUG\");\n+      eh_debug = eh_debug_env ? atoi (eh_debug_env) : 0;\n+    }\n+\n+  if (eh_debug)\n+    printf (\"MD_FALLBACK running ...\\n\");\n+\n+  /* We only know how to deal with stack or reg frame procedures, so give\n+     up if we're handed anything else.  */\n+  if (pkind != PDSC$K_KIND_FP_STACK && pkind != PDSC$K_KIND_FP_REGISTER)\n+    return _URC_END_OF_STACK;\n+  \n+  if (eh_debug)\n+    printf (\"FALLBACK: CTX FP = 0x%p, PV = 0x%p, EN = 0x%llx, RA = 0x%p\\n\",\n+\t    ADDR_AT (context->reg[29]), pv, pv->pdsc$q_entry, context->ra);\n+\n+  fs->retaddr_column = RA_COLUMN;\n+\n+  /* If PV designates a VMS exception vector or condition handler, we need to\n+     do as if the caller was the signaling point and estabish the state of the\n+     intermediate VMS code (CFA, RA and saved register locations) as if it was\n+     a single regular function.  This requires special processing.\n+\n+     The datastructures available from an condition dispatcher frame (signal\n+     context) do not contain the values of most callee-saved registers, so\n+     whathever PV designates, we need to account for the registers it saves.\n+\n+     Besides, we need to express all the locations with respect to a\n+     consistent CFA value, so we compute this first.  */\n+\n+  if (DENOTES_EXC_DISPATCHER (pv))\n+    {\n+      /* The CFA to establish is the signaling point's stack pointer. We\n+\t compute it using the system invocation context unwinding services and\n+\t save the CHF context data pointer along the way for later uses.  */\n+\n+      INVO_CONTEXT_BLK icb;\n+      int status, invo_handle;\n+\n+      if (eh_debug)\n+\tprintf (\"FALLBACK: SYS$HANDLER\\n\");\n+\n+      icb.libicb$q_ireg [29] = REG_AT (context->reg[29]);\n+      icb.libicb$q_ireg [30] = 0;\n+      invo_handle = LIB$GET_INVO_HANDLE (&icb);\n+\n+      status = LIB$GET_INVO_CONTEXT (invo_handle, &icb);\n+      GIVEUP_ON_FAILURE (status);\n+\n+      chfctx = (CHFCTX *) icb.libicb$ph_chfctx_addr;\n+\n+      status = LIB$GET_PREV_INVO_CONTEXT (&icb);\n+      GIVEUP_ON_FAILURE (status);\n \n-  if (pv && ((long) pv & 0x7) == 0) /* low bits 0 means address */\n-    pv = *(PDSCDEF **) pv;\n+      new_cfa = (ADDR) icb.libicb$q_ireg[30];      \n+    }\n+  else\n+    {\n+      /* The CFA to establish is the SP value on entry of the procedure\n+\t designated by PV, which we compute as the corresponding frame base\n+\t register value + frame size.  Note that the frame base may differ\n+\t from CONTEXT->cfa, typically if the caller has performed dynamic\n+\t stack allocations.  */\n+      \n+      int  base_reg  = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;\n+      ADDR base_addr = ADDR_AT (context->reg[base_reg]);\n+      \n+      new_cfa = base_addr + pv->pdsc$l_size;\n+    }\n+\n+  /* State to compute the caller's CFA by adding an offset to the current\n+     one in CONTEXT.  */\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = new_cfa - context->cfa;\n \n-  if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_STACK))\n+  /* Regular unwind first, accounting for the register saves performed by\n+     the procedure designated by PV.  */\n+\n+  switch (pkind)\n     {\n-      int i, j;\n-\n-      fs->regs.cfa_offset = pv->pdsc$l_size;\n-      fs->regs.cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;\n-      fs->retaddr_column = 26;\n-      fs->regs.cfa_how = CFA_REG_OFFSET;\n-      fs->regs.reg[27].loc.offset = -pv->pdsc$l_size;\n-      fs->regs.reg[27].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[26].loc.offset\n-\t= -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset);\n-      fs->regs.reg[26].how = REG_SAVED_OFFSET;\n-\n-      for (i = 0, j = 0; i < 32; i++)\n-\tif (1<<i & pv->pdsc$l_ireg_mask)\n-\t  {\n-\t    fs->regs.reg[i].loc.offset\n-\t      = -(pv->pdsc$l_size - pv->pdsc$w_rsa_offset - 8 * ++j);\n-\t    fs->regs.reg[i].how = REG_SAVED_OFFSET;\n-\t  }\n-\n-      return _URC_NO_REASON;\n+    case PDSC$K_KIND_FP_STACK:\n+      {\n+\t/* The saved registers are all located in the Register Save Area,\n+\t   except for the procedure value register (R27) found at the frame\n+\t   base address.  */\n+\n+\tint  base_reg  = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;\n+\tADDR base_addr = ADDR_AT (context->reg[base_reg]);\n+\tADDR rsa_addr  = base_addr + pv->pdsc$w_rsa_offset;\n+\n+\tif (eh_debug)\n+\t  printf (\"FALLBACK: STACK frame procedure\\n\");\n+\n+\tUPDATE_FS_FOR_CFA_GR (fs, 27, base_addr, new_cfa);\n+\n+\t/* The first RSA entry is for the return address register, R26.  */\n+\n+\tUPDATE_FS_FOR_CFA_GR (fs, 26, rsa_addr, new_cfa);\n+\tUPDATE_FS_FOR_CFA_GR (fs, RA_COLUMN, rsa_addr, new_cfa);\n+\n+\t/* The following entries are for registers marked as saved according\n+\t   to ireg_mask.  */\n+\tfor (i = 0, j = 0; i < 32; i++)\n+\t  if ((1 << i) & pv->pdsc$l_ireg_mask)\n+\t    UPDATE_FS_FOR_CFA_GR (fs, i, rsa_addr + 8 * ++j, new_cfa);\n+\t\n+\t/* ??? floating point registers ?  */\n+\n+\tbreak;\n+      }\n+\n+    case PDSC$K_KIND_FP_REGISTER:\n+      {\n+\tif (eh_debug)\n+\t  printf (\"FALLBACK: REGISTER frame procedure\\n\");\n+\n+\tfs->regs.reg[RA_COLUMN].how = REG_SAVED_REG;\n+\tfs->regs.reg[RA_COLUMN].loc.reg = pv->pdsc$b_save_ra;\n+\t\n+\tfs->regs.reg[29].how = REG_SAVED_REG;\n+\tfs->regs.reg[29].loc.reg = pv->pdsc$b_save_fp;\n+\t\n+\tbreak;\n+      }\n+\n+    default:\n+      /* Should never reach here.  */\n+      return _URC_END_OF_STACK;\n     }\n-  else if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_REGISTER))\n+\n+  /* If PV designates an exception dispatcher, we have to adjust the return\n+     address column to get at the signal occurrence point, and account for\n+     for what the CHF context contains.  */\n+\n+  if (DENOTES_EXC_DISPATCHER (pv))\n     {\n-      fs->regs.cfa_offset = pv->pdsc$l_size;\n-      fs->regs.cfa_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30;\n-      fs->retaddr_column = 26;\n-      fs->regs.cfa_how = CFA_REG_OFFSET;\n-      fs->regs.reg[26].loc.reg = pv->pdsc$b_save_ra;\n-      fs->regs.reg[26].how = REG_SAVED_REG;\n-      fs->regs.reg[29].loc.reg = pv->pdsc$b_save_fp;\n-      fs->regs.reg[29].how = REG_SAVED_REG;\n-\n-      return _URC_NO_REASON;\n+      /* The PC of the instruction causing the condition is available from the\n+\t signal argument vector.  Extra saved register values are available\n+\t from the mechargs array.  */\n+\n+      CHF$SIGNAL_ARRAY *sigargs\n+\t= (CHF$SIGNAL_ARRAY *) chfctx->chfctx$q_sigarglst;\n+\n+      CHF$MECH_ARRAY *mechargs\n+\t= (CHF$MECH_ARRAY *) chfctx->chfctx$q_mcharglst;\n+\n+      ADDR condpc_addr\n+\t= &((int *)(&sigargs->chf$l_sig_name)) [sigargs->chf$is_sig_args-2];\n+\n+      ADDR rei_frame_addr = (void *) mechargs->chf$q_mch_esf_addr;\n+\n+      /* Adjust the return address location.  */\n+\n+      UPDATE_FS_FOR_CFA_GR (fs, RA_COLUMN, condpc_addr, new_cfa);\n+\n+      /* The frame pointer at the condition point is available from the\n+\t chf context directly.  */\n+\n+      UPDATE_FS_FOR_CFA_GR (fs, 29, &chfctx->chfctx$q_expt_fp, new_cfa);\n+\n+      /* Registers available from the mechargs array.  */\n+\n+      UPDATE_FS_FOR_CFA_GR (fs, 0, &mechargs->chf$q_mch_savr0, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 1, &mechargs->chf$q_mch_savr1, new_cfa);\n+\n+      UPDATE_FS_FOR_CFA_GR (fs, 16, &mechargs->chf$q_mch_savr16, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 17, &mechargs->chf$q_mch_savr17, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 18, &mechargs->chf$q_mch_savr18, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 19, &mechargs->chf$q_mch_savr19, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 20, &mechargs->chf$q_mch_savr20, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 21, &mechargs->chf$q_mch_savr21, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 22, &mechargs->chf$q_mch_savr22, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 23, &mechargs->chf$q_mch_savr23, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 24, &mechargs->chf$q_mch_savr24, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 25, &mechargs->chf$q_mch_savr25, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 26, &mechargs->chf$q_mch_savr26, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 27, &mechargs->chf$q_mch_savr27, new_cfa);\n+      UPDATE_FS_FOR_CFA_GR (fs, 28, &mechargs->chf$q_mch_savr28, new_cfa);\n+      \n+      /* Registers R2 to R7 are available from the rei frame pointer.  */\n+      \n+      for (i = 2; i <= 7; i ++)\n+\tUPDATE_FS_FOR_CFA_GR (fs, i, rei_frame_addr+(i - 2)*8, new_cfa);\n+      \n+      /* ??? floating point registers ?  */\n     }\n-  return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n }\n+\n+\n+"}, {"sha": "7b149f17e784887aaff868fbd7c7a697b21b8a1f", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=221cf9abf3a9f446a4ab9bcf7534f81ef0d1d4e6", "patch": "@@ -287,7 +287,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LINK_EH_SPEC \"vms-dwarf2eh.o%s \"\n #define LINK_GCC_C_SEQUENCE_SPEC \"%G\"\n \n+#ifdef IN_LIBGCC2\n+/* Get the definition for MD_FALLBACK_FRAME_STATE_FOR from a separate\n+   file. This avoids having to recompile the world instead of libgcc only\n+   when changes to this macro are exercised.  */\n+\n #define MD_UNWIND_SUPPORT \"config/alpha/vms-unwind.h\"\n+#endif\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}]}