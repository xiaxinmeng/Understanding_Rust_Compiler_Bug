{"sha": "62ab45cc129875ec3baef6eea7d60c69d263d853", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhYjQ1Y2MxMjk4NzVlYzNiYWVmNmVlYTdkNjBjNjlkMjYzZDg1Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-09T19:18:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-09T19:18:15Z"}, "message": "fold-const.c (fold_unary, [...]): Return NULL_TREE when a given tree is not simplified.\n\n\t* fold-const.c (fold_unary, fold_binary, fold_ternary): Return\n\tNULL_TREE when a given tree is not simplified.\n\t(fold): Return the original tree when any of the functions\n\tmentioned above NULL_TREE.\n\nFrom-SVN: r96201", "tree": {"sha": "c90732402339564d28311aafda7053c310a41b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c90732402339564d28311aafda7053c310a41b2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62ab45cc129875ec3baef6eea7d60c69d263d853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab45cc129875ec3baef6eea7d60c69d263d853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ab45cc129875ec3baef6eea7d60c69d263d853", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab45cc129875ec3baef6eea7d60c69d263d853/comments", "author": null, "committer": null, "parents": [{"sha": "9e1af876ec17db808d3a1d2ace85b7734b0fca2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1af876ec17db808d3a1d2ace85b7734b0fca2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e1af876ec17db808d3a1d2ace85b7734b0fca2c"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "7ec54e8274bd94992116228a434ef62f39d527a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab45cc129875ec3baef6eea7d60c69d263d853/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab45cc129875ec3baef6eea7d60c69d263d853/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62ab45cc129875ec3baef6eea7d60c69d263d853", "patch": "@@ -1,3 +1,10 @@\n+2005-03-09  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c (fold_unary, fold_binary, fold_ternary): Return\n+\tNULL_TREE when a given tree is not simplified.\n+\t(fold): Return the original tree when any of the functions\n+\tmentioned above NULL_TREE.\n+\n 2005-03-09  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (fold_builtin_unordered_cmp): Change prototype to take"}, {"sha": "88ca036b267a97fa0eb453e48da5eca43291e8ee", "filename": "gcc/fold-const.c", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab45cc129875ec3baef6eea7d60c69d263d853/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab45cc129875ec3baef6eea7d60c69d263d853/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=62ab45cc129875ec3baef6eea7d60c69d263d853", "patch": "@@ -6884,12 +6884,12 @@ fold_unary (tree expr)\n \t}\n \n       tem = fold_convert_const (code, type, arg0);\n-      return tem ? tem : t;\n+      return tem ? tem : NULL_TREE;\n \n     case VIEW_CONVERT_EXPR:\n       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)\n \treturn build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));\n-      return t;\n+      return NULL_TREE;\n \n     case NEGATE_EXPR:\n       if (negate_expr_p (arg0))\n@@ -6898,7 +6898,7 @@ fold_unary (tree expr)\n       if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == BIT_NOT_EXPR)\n \treturn fold (build2 (PLUS_EXPR, type, TREE_OPERAND (arg0, 0),\n \t\t\t     build_int_cst (type, 1)));\n-      return t;\n+      return NULL_TREE;\n \n     case ABS_EXPR:\n       if (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST)\n@@ -6925,7 +6925,7 @@ fold_unary (tree expr)\n \t  if (tem)\n \t    return fold (build1 (ABS_EXPR, type, fold_convert (type, tem)));\n \t}\n-      return t;\n+      return NULL_TREE;\n \n     case CONJ_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n@@ -6945,7 +6945,7 @@ fold_unary (tree expr)\n \t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n       else if (TREE_CODE (arg0) == CONJ_EXPR)\n \treturn TREE_OPERAND (arg0, 0);\n-      return t;\n+      return NULL_TREE;\n \n     case BIT_NOT_EXPR:\n       if (TREE_CODE (arg0) == INTEGER_CST)\n@@ -6963,7 +6963,7 @@ fold_unary (tree expr)\n \t\t   || (TREE_CODE (arg0) == PLUS_EXPR\n \t\t       && integer_all_onesp (TREE_OPERAND (arg0, 1)))))\n \treturn fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0)));\n-      return t;\n+      return NULL_TREE;\n \n     case TRUTH_NOT_EXPR:\n       /* The argument to invert_truthvalue must have Boolean type.  */\n@@ -6977,12 +6977,12 @@ fold_unary (tree expr)\n       tem = invert_truthvalue (arg0);\n       /* Avoid infinite recursion.  */\n       if (TREE_CODE (tem) == TRUTH_NOT_EXPR)\n-\treturn t;\n+\treturn NULL_TREE;\n       return fold_convert (type, tem);\n \n     case REALPART_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n-\treturn t;\n+\treturn NULL_TREE;\n       else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n \treturn omit_one_operand (type, TREE_OPERAND (arg0, 0),\n \t\t\t\t TREE_OPERAND (arg0, 1));\n@@ -6994,7 +6994,7 @@ fold_unary (tree expr)\n \t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n \t\t\t     fold (build1 (REALPART_EXPR, type,\n \t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n-      return t;\n+      return NULL_TREE;\n \n     case IMAGPART_EXPR:\n       if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n@@ -7010,10 +7010,10 @@ fold_unary (tree expr)\n \t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n \t\t\t     fold (build1 (IMAGPART_EXPR, type,\n \t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n-      return t;\n+      return NULL_TREE;\n \n     default:\n-      return t;\n+      return NULL_TREE;\n     } /* switch (code) */\n }\n \n@@ -7630,7 +7630,7 @@ fold_binary (tree expr)\n \n \t  return t1;\n \t}\n-      return t;\n+      return NULL_TREE;\n \n     case MINUS_EXPR:\n       /* A - (-B) -> A + B */\n@@ -8164,7 +8164,7 @@ fold_binary (tree expr)\n       if (TREE_CODE (arg1) == REAL_CST\n \t  && !MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg1)))\n \t  && real_zerop (arg1))\n-\treturn t;\n+\treturn NULL_TREE;\n \n       /* (-A) / (-B) -> A / B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n@@ -8345,7 +8345,7 @@ fold_binary (tree expr)\n       if (integer_onep (arg1))\n \treturn non_lvalue (fold_convert (type, arg0));\n       if (integer_zerop (arg1))\n-\treturn t;\n+\treturn NULL_TREE;\n       /* X / -1 is -X.  */\n       if (!TYPE_UNSIGNED (type)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n@@ -8387,7 +8387,7 @@ fold_binary (tree expr)\n       /* X % 0, return X % 0 unchanged so that we can get the\n \t proper warnings and errors.  */\n       if (integer_zerop (arg1))\n-\treturn t;\n+\treturn NULL_TREE;\n \n       /* 0 % X is always zero, but be sure to preserve any side\n \t effects in X.  Place this after checking for X == 0.  */\n@@ -8476,7 +8476,7 @@ fold_binary (tree expr)\n       /* Since negative shift count is not well-defined,\n \t don't try to compute it in the compiler.  */\n       if (TREE_CODE (arg1) == INTEGER_CST && tree_int_cst_sgn (arg1) < 0)\n-\treturn t;\n+\treturn NULL_TREE;\n       /* Rewrite an LROTATE_EXPR by a constant into an\n \t RROTATE_EXPR by a new constant.  */\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n@@ -8585,7 +8585,7 @@ fold_binary (tree expr)\n     truth_andor:\n       /* We only do these simplifications if we are optimizing.  */\n       if (!optimize)\n-\treturn t;\n+\treturn NULL_TREE;\n \n       /* Check for things like (A || B) && (A || C).  We can convert this\n \t to A || (B && C).  Note that either operator can be any of the four\n@@ -8644,7 +8644,7 @@ fold_binary (tree expr)\n       if ((tem = fold_truthop (code, type, arg0, arg1)) != 0)\n \treturn tem;\n \n-      return t;\n+      return NULL_TREE;\n \n     case TRUTH_ORIF_EXPR:\n       /* Note that the operands of this must be ints\n@@ -8702,7 +8702,7 @@ fold_binary (tree expr)\n \t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n \treturn omit_one_operand (type, integer_one_node, arg0);\n \n-      return t;\n+      return NULL_TREE;\n \n     case EQ_EXPR:\n     case NE_EXPR:\n@@ -9166,7 +9166,7 @@ fold_binary (tree expr)\n \t  if (tem)\n \t    return tem;\n \n-\t  return t;\n+\t  return NULL_TREE;\n \t}\n \n       /* If we are comparing an ABS_EXPR with a constant, we can\n@@ -9569,7 +9569,7 @@ fold_binary (tree expr)\n \treturn constant_boolean_node (code==NE_EXPR, type);\n \n       t1 = fold_relational_const (code, type, arg0, arg1);\n-      return t1 == NULL_TREE ? t : t1;\n+      return t1 == NULL_TREE ? NULL_TREE : t1;\n \n     case UNORDERED_EXPR:\n     case ORDERED_EXPR:\n@@ -9632,13 +9632,13 @@ fold_binary (tree expr)\n \t\t\t       fold_convert (newtype, targ1)));\n       }\n \n-      return t;\n+      return NULL_TREE;\n \n     case COMPOUND_EXPR:\n       /* When pedantic, a compound expression can be neither an lvalue\n \t nor an integer constant expression.  */\n       if (TREE_SIDE_EFFECTS (arg0) || TREE_CONSTANT (arg1))\n-\treturn t;\n+\treturn NULL_TREE;\n       /* Don't let (0, 0) be null pointer constant.  */\n       tem = integer_zerop (arg1) ? build1 (NOP_EXPR, type, arg1)\n \t\t\t\t : fold_convert (type, arg1);\n@@ -9647,10 +9647,10 @@ fold_binary (tree expr)\n     case COMPLEX_EXPR:\n       if (wins)\n \treturn build_complex (type, arg0, arg1);\n-      return t;\n+      return NULL_TREE;\n \n     default:\n-      return t;\n+      return NULL_TREE;\n     } /* switch (code) */\n }\n \n@@ -9708,7 +9708,7 @@ fold_ternary (tree expr)\n \t  if (m)\n \t    return TREE_VALUE (m);\n \t}\n-      return t;\n+      return NULL_TREE;\n \n     case COND_EXPR:\n       /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n@@ -9722,7 +9722,7 @@ fold_ternary (tree expr)\n \t  if (! VOID_TYPE_P (TREE_TYPE (tem))\n \t      || VOID_TYPE_P (type))\n \t    return pedantic_non_lvalue (tem);\n-\t  return t;\n+\t  return NULL_TREE;\n \t}\n       if (operand_equal_p (arg1, op2, 0))\n \treturn pedantic_omit_one_operand (type, arg1, arg0);\n@@ -9862,7 +9862,7 @@ fold_ternary (tree expr)\n \t  && truth_value_p (TREE_CODE (op2)))\n \treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0, op2));\n \n-      return t;\n+      return NULL_TREE;\n \n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n@@ -9874,10 +9874,10 @@ fold_ternary (tree expr)\n \t  if (tmp)\n \t    return tmp;\n \t}\n-      return t;\n+      return NULL_TREE;\n \n     default:\n-      return t;\n+      return NULL_TREE;\n     } /* switch (code) */\n }\n \n@@ -9900,6 +9900,7 @@ fold (tree expr)\n   const tree t = expr;\n   enum tree_code code = TREE_CODE (t);\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n+  tree tem;\n \n   /* Return right away if a constant.  */\n   if (kind == tcc_constant)\n@@ -9910,11 +9911,14 @@ fold (tree expr)\n       switch (TREE_CODE_LENGTH (code))\n \t{\n \tcase 1:\n-\t  return fold_unary (expr);\n+\t  tem = fold_unary (expr);\n+\t  return tem ? tem : expr;\n \tcase 2:\n-\t  return fold_binary (expr);\n+\t  tem = fold_binary (expr);\n+\t  return tem ? tem : expr;\n \tcase 3:\n-\t  return fold_ternary (expr);\n+\t  tem = fold_ternary (expr);\n+\t  return tem ? tem : expr;\n \tdefault:\n \t  break;\n \t}"}]}