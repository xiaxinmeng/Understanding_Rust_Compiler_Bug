{"sha": "6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY0ZTljZjg0MjA0ZTY5MGI3YzMyMDYwZjhlYjdkOTc4YmZjZjJjYQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2013-12-11T16:59:24Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2013-12-11T16:59:24Z"}, "message": "re PR middle-end/23623 (volatile keyword changes bitfield access size from 32bit to 8bit)\n\n2013-12-11  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n            Sandra Loosemore  <sandra@codesourcery.com>\n\n        PR middle-end/23623\n        PR middle-end/48784\n        PR middle-end/56341\n        PR middle-end/56997\n        * expmed.c (strict_volatile_bitfield_p): Add bitregion_start\n        and bitregion_end parameters.  Test for compliance with C++\n        memory model.\n        (store_bit_field): Adjust call to strict_volatile_bitfield_p.\n        Add fallback logic for cases where -fstrict-volatile-bitfields\n        is supposed to apply, but cannot.\n        (extract_bit_field): Likewise. Use narrow_bit_field_mem and\n        extract_fixed_bit_field_1 to do the extraction.\n        (extract_fixed_bit_field): Revert to previous mode selection algorithm.\n        Call extract_fixed_bit_field_1 to do the real work.\n        (extract_fixed_bit_field_1): New function.\n\ntestsuite:        \n        * gcc.dg/pr23623.c: Update to test interaction with C++\n        memory model.\n\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r205897", "tree": {"sha": "292e9afae89e8ec005a9bb23606e011988bfbc04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/292e9afae89e8ec005a9bb23606e011988bfbc04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f"}], "stats": {"total": 85, "additions": 70, "deletions": 15}, "files": [{"sha": "b75f6a59214520fca7e77525a8a06c63cf258006", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "patch": "@@ -1,3 +1,22 @@\n+2013-12-11  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\t    Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR middle-end/23623\n+\tPR middle-end/48784\n+\tPR middle-end/56341\n+\tPR middle-end/56997\n+\t* expmed.c (strict_volatile_bitfield_p): Add bitregion_start\n+\tand bitregion_end parameters.  Test for compliance with C++\n+\tmemory model.\n+\t(store_bit_field): Adjust call to strict_volatile_bitfield_p.\n+\tAdd fallback logic for cases where -fstrict-volatile-bitfields\n+\tis supposed to apply, but cannot.\n+\t(extract_bit_field): Likewise. Use narrow_bit_field_mem and\n+\textract_fixed_bit_field_1 to do the extraction.\n+\t(extract_fixed_bit_field): Revert to previous mode selection algorithm.\n+\tCall extract_fixed_bit_field_1 to do the real work.\n+\t(extract_fixed_bit_field_1): New function.\n+\n 2013-12-11  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR middle-end/23623"}, {"sha": "08ad9e0c10dac023b9fa58ae077adaa123508a60", "filename": "gcc/expmed.c", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "patch": "@@ -56,6 +56,9 @@ static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n static rtx extract_fixed_bit_field (enum machine_mode, rtx,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, rtx, int);\n+static rtx extract_fixed_bit_field_1 (enum machine_mode, rtx,\n+\t\t\t\t      unsigned HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT, rtx, int);\n static rtx mask_rtx (enum machine_mode, int, int, int);\n static rtx lshift_value (enum machine_mode, unsigned HOST_WIDE_INT, int);\n static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n@@ -417,12 +420,17 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n }\n \n /* Return true if -fstrict-volatile-bitfields applies an access of OP0\n-   containing BITSIZE bits starting at BITNUM, with field mode FIELDMODE.  */\n+   containing BITSIZE bits starting at BITNUM, with field mode FIELDMODE.\n+   Return false if the access would touch memory outside the range\n+   BITREGION_START to BITREGION_END for conformance to the C++ memory\n+   model.  */\n \n static bool\n strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    unsigned HOST_WIDE_INT bitnum,\n-\t\t\t    enum machine_mode fieldmode)\n+\t\t\t    enum machine_mode fieldmode,\n+\t\t\t    unsigned HOST_WIDE_INT bitregion_start,\n+\t\t\t    unsigned HOST_WIDE_INT bitregion_end)\n {\n   unsigned HOST_WIDE_INT modesize = GET_MODE_BITSIZE (fieldmode);\n \n@@ -449,6 +457,12 @@ strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t  && bitnum % GET_MODE_ALIGNMENT (fieldmode) + bitsize > modesize))\n     return false;\n \n+  /* Check for cases where the C++ memory model applies.  */\n+  if (bitregion_end != 0\n+      && (bitnum - bitnum % modesize < bitregion_start\n+\t  || bitnum - bitnum % modesize + modesize > bitregion_end))\n+    return false;\n+\n   return true;\n }\n \n@@ -920,7 +934,8 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t rtx value)\n {\n   /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n-  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, fieldmode))\n+  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, fieldmode,\n+\t\t\t\t  bitregion_start, bitregion_end))\n     {\n \n       /* Storing any naturally aligned field can be done with a simple\n@@ -1711,7 +1726,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   else\n     mode1 = tmode;\n \n-  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, mode1))\n+  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, mode1, 0, 0))\n     {\n       rtx result;\n \n@@ -1721,8 +1736,13 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \tresult = adjust_bitfield_address (str_rtx, mode1,\n \t\t\t\t\t  bitnum / BITS_PER_UNIT);\n       else\n-\tresult = extract_fixed_bit_field (mode, str_rtx, bitsize, bitnum,\n-\t\t\t\t\t  target, unsignedp);\n+\t{\n+\t  str_rtx = narrow_bit_field_mem (str_rtx, mode1, bitsize, bitnum,\n+\t\t\t\t\t  &bitnum);\n+\t  result = extract_fixed_bit_field_1 (mode, str_rtx, bitsize, bitnum,\n+\t\t\t\t\t      target, unsignedp);\n+\t}\n+\n       return convert_extracted_bit_field (result, mode, tmode, unsignedp);\n     }\n   \n@@ -1748,16 +1768,8 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \n   if (MEM_P (op0))\n     {\n-      /* Get the proper mode to use for this field.  We want a mode that\n-\t includes the entire field.  If such a mode would be larger than\n-\t a word, we won't be doing the extraction the normal way.  */\n-\n-      mode = GET_MODE (op0);\n-      if (GET_MODE_BITSIZE (mode) == 0\n-\t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n-\tmode = word_mode;\n       mode = get_best_mode (bitsize, bitnum, 0, 0,\n-\t\t\t    MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n+\t\t\t    MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t/* The only way this should occur is if the field spans word\n@@ -1767,6 +1779,21 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n       op0 = narrow_bit_field_mem (op0, mode, bitsize, bitnum, &bitnum);\n     }\n \n+  return extract_fixed_bit_field_1 (tmode, op0, bitsize, bitnum,\n+\t\t\t\t    target, unsignedp);\n+}\n+\n+/* Helper function for extract_fixed_bit_field, extracts\n+   the bit field always using the MODE of OP0.  */\n+\n+static rtx\n+extract_fixed_bit_field_1 (enum machine_mode tmode, rtx op0,\n+\t\t\t   unsigned HOST_WIDE_INT bitsize,\n+\t\t\t   unsigned HOST_WIDE_INT bitnum, rtx target,\n+\t\t\t   int unsignedp)\n+{\n+  enum machine_mode mode;\n+\n   mode = GET_MODE (op0);\n   gcc_assert (SCALAR_INT_MODE_P (mode));\n "}, {"sha": "47ac2c3b44a44b30ce7f9f2c7579fcdbc1b8d2de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "patch": "@@ -1,3 +1,9 @@\n+2013-12-11  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\t    Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* gcc.dg/pr23623.c: Update to test interaction with C++\n+\tmemory model.\n+\n 2013-12-11  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR middle-end/23623"}, {"sha": "c844f945e1a1e5e954d5015ba0622e892434105c", "filename": "gcc/testsuite/gcc.dg/pr23623.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23623.c?ref=6f4e9cf84204e690b7c32060f8eb7d978bfcf2ca", "patch": "@@ -8,16 +8,19 @@\n extern struct\n {\n   unsigned int b : 1;\n+  unsigned int : 31;\n } bf1;\n \n extern volatile struct\n {\n   unsigned int b : 1;\n+  unsigned int : 31;\n } bf2;\n \n extern struct\n {\n   volatile unsigned int b : 1;\n+  volatile unsigned int : 31;\n } bf3;\n \n void writeb(void)"}]}