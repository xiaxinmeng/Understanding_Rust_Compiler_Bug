{"sha": "653b8b8d89fa0243b7e769a22f172b3264da58f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzYjhiOGQ4OWZhMDI0M2I3ZTc2OWEyMmYxNzJiMzI2NGRhNThmNA==", "commit": {"author": {"name": "Tsvetkova Alexandra", "email": "aleksandra.tsvetkova@intel.com", "date": "2015-12-11T14:38:53Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-12-11T14:38:53Z"}, "message": "Makefile.am (libmpx_la_LDFLAGS): Add -version-info option.\n\nlibmpx/\n\n2015-12-11  Tsvetkova Alexandra  <aleksandra.tsvetkova@intel.com>\n\n\t* mpxrt/Makefile.am (libmpx_la_LDFLAGS): Add -version-info\n\toption.\n\t* libmpxwrap/Makefile.am (libmpx_la_LDFLAGS): Likewise and\n\tfix include path.\n\t* libmpx/Makefile.in: Regenerate.\n\t* mpxrt/Makefile.in: Regenerate.\n\t* libmpxwrap/Makefile.in: Regenerate.\n\t* mpxrt/libtool-version: New version.\n\t* libmpxwrap/libtool-version: Likewise.\n\t* mpxrt/libmpx.map: Add new version and a new symbol.\n\t* mpxrt/mpxrt.h: New file.\n\t* mpxrt/mpxrt.c (NUM_L1_BITS): Moved to mpxrt.h.\n\t(REG_IP_IDX): Moved to mpxrt.h.\n\t(REX_PREFIX): Moved to mpxrt.h.\n\t(XSAVE_OFFSET_IN_FPMEM): Moved to mpxrt.h.\n\t(MPX_L1_SIZE): Moved to mpxrt.h.\n\t* libmpxwrap/mpx_wrappers.c (mpx_pointer): New type.\n\t(mpx_bt_entry): New type.\n\t(alloc_bt): New function.\n\t(get_bt): New function.\n\t(copy_if_possible): New function.\n\t(copy_if_possible_from_end): New function.\n\t(move_bounds): New function.\n\t(__mpx_wrapper_memmove): Use move_bounds to copy bounds.\n\ngcc/testsuite/\n\n2015-12-11  Tsvetkova Alexandra  <aleksandra.tsvetkova@intel.com>\n\n\t* gcc.target/i386/mpx/memmove-1.c: New test.\n\t* gcc.target/i386/mpx/memmove-2.c: New test.\n\nFrom-SVN: r231565", "tree": {"sha": "62169eeb0eed7ce16ceda7ca3df1cf922428c590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62169eeb0eed7ce16ceda7ca3df1cf922428c590"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/653b8b8d89fa0243b7e769a22f172b3264da58f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653b8b8d89fa0243b7e769a22f172b3264da58f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/653b8b8d89fa0243b7e769a22f172b3264da58f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653b8b8d89fa0243b7e769a22f172b3264da58f4/comments", "author": null, "committer": null, "parents": [{"sha": "a9000e1e2f60df8bd20bbbb58a64bb2addf7e648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9000e1e2f60df8bd20bbbb58a64bb2addf7e648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9000e1e2f60df8bd20bbbb58a64bb2addf7e648"}], "stats": {"total": 779, "additions": 685, "deletions": 94}, "files": [{"sha": "541228af5a179a173fba27d675c6eab42439af1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -1,3 +1,8 @@\n+2015-12-11  Tsvetkova Alexandra  <aleksandra.tsvetkova@intel.com>\n+\n+\t* gcc.target/i386/mpx/memmove-1.c: New test.\n+\t* gcc.target/i386/mpx/memmove-2.c: New test.\n+\n 2015-12-11  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.target/nvptx/ary-init.c: Repair dg_final syntax."}, {"sha": "0efd030307561cb2d2a54e403bc4ae7f9c05e08f", "filename": "gcc/testsuite/gcc.target/i386/mpx/memmove-1.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fmemmove-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fmemmove-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fmemmove-1.c?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx\" } */\n+\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include \"mpx-check.h\"\n+\n+#ifdef __i386__\n+/* i386 directory size is 4MB.  */\n+#define MPX_NUM_L2_BITS 10\n+#define MPX_NUM_IGN_BITS 2\n+#else /* __i386__ */\n+/* x86_64 directory size is 2GB.  */\n+#define MPX_NUM_L2_BITS 17\n+#define MPX_NUM_IGN_BITS 3\n+#endif /* !__i386__ */\n+\n+\n+/* bt_num_of_elems is the number of elements in bounds table.  */\n+unsigned long bt_num_of_elems = (1UL << MPX_NUM_L2_BITS);\n+/* Function to test MPX wrapper of memmove function.\n+   src_bigger_dst determines which address is bigger, can be 0 or 1.\n+   src_bt_index and dst_bt index are bt_indexes\n+   from the beginning of the page.\n+   bd_index_end is the bd index of the last element of src if we define\n+   bd index of the first element as 0.\n+   src_bt index_end is bt index of the last element of src.\n+   pointers inside determines if array being copied includes pointers\n+   src_align and dst_align are alignments of src and dst.\n+   Arrays may contain unaligned pointers.  */\n+int\n+test (int src_bigger_dst, int src_bt_index, int dst_bt_index,\n+      int bd_index_end, int src_bt_index_end, int pointers_inside,\n+      int src_align, int dst_align)\n+{\n+  const int n =\n+    src_bt_index_end - src_bt_index + bd_index_end * bt_num_of_elems;\n+  if (n < 0)\n+    {\n+      return 0;\n+    }\n+  const int num_of_pointers = (bd_index_end + 2) * bt_num_of_elems;\n+  void **arr = 0;\n+  posix_memalign ((void **) (&arr),\n+           1UL << (MPX_NUM_L2_BITS + MPX_NUM_IGN_BITS),\n+           num_of_pointers * sizeof (void *));\n+  void **src = arr, **dst = arr;\n+  if ((src_bigger_dst) && (src_bt_index < dst_bt_index))\n+    src_bt_index += bt_num_of_elems;\n+  if (!(src_bigger_dst) && (src_bt_index > dst_bt_index))\n+    dst_bt_index += bt_num_of_elems;\n+  src += src_bt_index;\n+  dst += dst_bt_index;\n+  char *realign = (char *) src;\n+  realign += src_align;\n+  src = (void **) realign;\n+  realign = (char *) dst;\n+  realign += src_align;\n+  dst = (void **) realign;\n+  if (pointers_inside)\n+    {\n+      for (int i = 0; i < n; i++)\n+        src[i] = __bnd_set_ptr_bounds (arr + i, i * sizeof (void *) + 1);\n+    }\n+  memmove (dst, src, n * sizeof (void *));\n+  if (pointers_inside)\n+    {\n+      for (int i = 0; i < n; i++)\n+        {\n+          if (dst[i] != arr + i)\n+            abort ();\n+          if (__bnd_get_ptr_lbound (dst[i]) != arr + i)\n+            abort ();\n+          if (__bnd_get_ptr_ubound (dst[i]) != arr + 2 * i)\n+            abort ();\n+        }\n+    }\n+  free (arr);\n+  return 0;\n+}\n+\n+/* Call testall to test common cases of memmove for MPX.  */\n+void\n+testall ()\n+{\n+  int align[3];\n+  align[0] = 0;\n+  align[1] = 1;\n+  align[2] = 7;\n+  for (int pointers_inside = 0; pointers_inside < 2; pointers_inside++)\n+    for (int src_bigger_dst = 0; src_bigger_dst < 2; src_bigger_dst++)\n+      for (int src_align = 0; src_align < 3; src_align ++)\n+        for (int dst_align = 0; dst_align < 3; dst_align ++)\n+          for (int pages = 0; pages < 4; pages++)\n+            {\n+              test (src_bigger_dst, 1, 2, pages, 1, pointers_inside,\n+                    align[src_align], align[dst_align]);\n+              test (src_bigger_dst, 1, 2, pages, 2, pointers_inside,\n+                    align[src_align], align[dst_align]);\n+              test (src_bigger_dst, 2, 1, pages, 12, pointers_inside,\n+                    align[src_align], align[dst_align]);\n+              test (src_bigger_dst, 2, 1, pages, 1, pointers_inside,\n+                    align[src_align], align[dst_align]);\n+              test (src_bigger_dst, 2, 3, pages, 12, pointers_inside,\n+                    align[src_align], align[dst_align]);\n+              test (src_bigger_dst, 1, bt_num_of_elems - 2, pages, 2,\n+                    pointers_inside, align[src_align], align[dst_align]);\n+            }\n+};\n+\n+int\n+mpx_test (int argc, const char **argv)\n+{\n+  testall ();\n+  return 0;\n+}"}, {"sha": "e1d78fa47c6e698eb7af1dbf00843af434449dd1", "filename": "gcc/testsuite/gcc.target/i386/mpx/memmove-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fmemmove-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fmemmove-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fmemmove-2.c?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx\" } */\n+\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include \"mpx-check.h\"\n+\n+#ifdef __i386__\n+/* i386 directory size is 4MB.  */\n+#define MPX_NUM_L2_BITS 10\n+#define MPX_NUM_IGN_BITS 2\n+#else /* __i386__ */\n+/* x86_64 directory size is 2GB.  */\n+#define MPX_NUM_L2_BITS 17\n+#define MPX_NUM_IGN_BITS 3\n+#endif /* !__i386__ */\n+\n+\n+/* bt_num_of_elems is the number of elements in bounds table.  */\n+unsigned long bt_num_of_elems = (1UL << MPX_NUM_L2_BITS);\n+\n+/* Function to test MPX wrapper of memmove function.\n+   Check case with no BT allocated for data.  */\n+\n+int\n+mpx_test (int argc, const char **argv)\n+{\n+  void **arr = 0;\n+  posix_memalign ((void **) (&arr),\n+           1UL << (MPX_NUM_L2_BITS + MPX_NUM_IGN_BITS),\n+           2 * bt_num_of_elems * sizeof (void *));\n+  void **src = arr, **dst = arr, **ptr = arr;\n+  src += 10;\n+  dst += 1;\n+  ptr += bt_num_of_elems + 100;\n+  ptr[0] = __bnd_set_ptr_bounds (arr + 1, sizeof (void *) + 1);\n+  memmove (dst, src, 5 * sizeof (void *));\n+  return 0;\n+}"}, {"sha": "93924a8e6ddba95d4c52f06256f76b7420d19c33", "filename": "libmpx/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2FChangeLog?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -1,3 +1,30 @@\n+2015-12-11  Tsvetkova Alexandra  <aleksandra.tsvetkova@intel.com>\n+\n+\t* mpxrt/Makefile.am (libmpx_la_LDFLAGS): Add -version-info\n+\toption.\n+\t* libmpxwrap/Makefile.am (libmpx_la_LDFLAGS): Likewise and\n+\tfix include path.\n+\t* libmpx/Makefile.in: Regenerate.\n+\t* mpxrt/Makefile.in: Regenerate.\n+\t* libmpxwrap/Makefile.in: Regenerate.\n+\t* mpxrt/libtool-version: New version.\n+\t* libmpxwrap/libtool-version: Likewise.\n+\t* mpxrt/libmpx.map: Add new version and a new symbol.\n+\t* mpxrt/mpxrt.h: New file.\n+\t* mpxrt/mpxrt.c (NUM_L1_BITS): Moved to mpxrt.h.\n+\t(REG_IP_IDX): Moved to mpxrt.h.\n+\t(REX_PREFIX): Moved to mpxrt.h.\n+\t(XSAVE_OFFSET_IN_FPMEM): Moved to mpxrt.h.\n+\t(MPX_L1_SIZE): Moved to mpxrt.h.\n+\t* libmpxwrap/mpx_wrappers.c (mpx_pointer): New type.\n+\t(mpx_bt_entry): New type.\n+\t(alloc_bt): New function.\n+\t(get_bt): New function.\n+\t(copy_if_possible): New function.\n+\t(copy_if_possible_from_end): New function.\n+\t(move_bounds): New function.\n+\t(__mpx_wrapper_memmove): Use move_bounds to copy bounds.\n+\n 2015-10-15  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR other/66887"}, {"sha": "d644af365269bccbaef24f05c6c74c736ad4458d", "filename": "libmpx/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2FMakefile.in?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -228,7 +228,6 @@ install_sh = @install_sh@\n libdir = @libdir@\n libexecdir = @libexecdir@\n link_libmpx = @link_libmpx@\n-link_mpx = @link_mpx@\n localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@"}, {"sha": "3280b62a96a6a96a4cdaff208116f28df083a544", "filename": "libmpx/mpxrt/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxrt%2FMakefile.am?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -13,7 +13,8 @@ libmpx_la_SOURCES = mpxrt.c mpxrt-utils.c\n \n libmpx_la_CFLAGS = -fPIC\n libmpx_la_DEPENDENCIES = libmpx.map\n-libmpx_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpx.map $(link_libmpx)\n+libmpx_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpx.map $(link_libmpx) \\\n+                    -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n \n mpxrt.lo: mpxrt-utils.h\n mpxrt-utils.lo: mpxrt-utils.h"}, {"sha": "1fdb454f4589fbb29b44e79d8eb47a4307a61c74", "filename": "libmpx/mpxrt/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxrt%2FMakefile.in?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -222,7 +222,6 @@ install_sh = @install_sh@\n libdir = @libdir@\n libexecdir = @libexecdir@\n link_libmpx = @link_libmpx@\n-link_mpx = @link_mpx@\n localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@\n@@ -257,7 +256,9 @@ ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n @LIBMPX_SUPPORTED_TRUE@libmpx_la_SOURCES = mpxrt.c mpxrt-utils.c\n @LIBMPX_SUPPORTED_TRUE@libmpx_la_CFLAGS = -fPIC\n @LIBMPX_SUPPORTED_TRUE@libmpx_la_DEPENDENCIES = libmpx.map\n-@LIBMPX_SUPPORTED_TRUE@libmpx_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpx.map $(link_libmpx)\n+@LIBMPX_SUPPORTED_TRUE@libmpx_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpx.map $(link_libmpx) \\\n+@LIBMPX_SUPPORTED_TRUE@                    -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "1f0fc2c4ce7812a7635c3a35ae072677593f0a18", "filename": "libmpx/mpxrt/libmpx.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Flibmpx.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Flibmpx.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxrt%2Flibmpx.map?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -3,3 +3,8 @@ LIBMPX_1.0\n   local:\n \t*;\n };\n+LIBMPX_2.0\n+{\n+  global:\n+    get_bd;\n+} LIBMPX_1.0;"}, {"sha": "7d9925549d1c02d83430cb7bac6ca097b52da3f0", "filename": "libmpx/mpxrt/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxrt%2Flibtool-version?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -3,4 +3,4 @@\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-1:0:0\n+2:0:0"}, {"sha": "bcdd3a63bd248cb02d5f6007523fda4f8c34dcf8", "filename": "libmpx/mpxrt/mpxrt.c", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Fmpxrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Fmpxrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxrt%2Fmpxrt.c?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -51,34 +51,11 @@\n #include <sys/prctl.h>\n #include <cpuid.h>\n #include \"mpxrt-utils.h\"\n-\n-#ifdef __i386__\n-\n-/* i386 directory size is 4MB */\n-#define NUM_L1_BITS    20\n-\n-#define REG_IP_IDX      REG_EIP\n-#define REX_PREFIX\n-\n-#define XSAVE_OFFSET_IN_FPMEM    sizeof (struct _libc_fpstate)\n-\n-#else /* __i386__ */\n-\n-/* x86_64 directory size is 2GB */\n-#define NUM_L1_BITS   28\n-\n-#define REG_IP_IDX    REG_RIP\n-#define REX_PREFIX    \"0x48, \"\n-\n-#define XSAVE_OFFSET_IN_FPMEM    0\n-\n-#endif /* !__i386__ */\n+#include \"mpxrt.h\"\n \n #define MPX_ENABLE_BIT_NO 0\n #define BNDPRESERVE_BIT_NO 1\n \n-const size_t MPX_L1_SIZE = (1UL << NUM_L1_BITS) * sizeof (void *);\n-\n struct xsave_hdr_struct\n {\n   uint64_t xstate_bv;\n@@ -508,3 +485,10 @@ mpxrt_cleanup (void)\n   __mpxrt_utils_free ();\n   process_specific_finish ();\n }\n+\n+/* Get address of bounds directory.  */\n+void *\n+get_bd ()\n+{\n+  return l1base;\n+}"}, {"sha": "e825d7d9046e5060af7ca411e4779217a62327cf", "filename": "libmpx/mpxrt/mpxrt.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Fmpxrt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxrt%2Fmpxrt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxrt%2Fmpxrt.h?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -0,0 +1,75 @@\n+/* mpxrt.h                  -*-C++-*-\n+ *\n+ *************************************************************************\n+ *\n+ *  @copyright\n+ *  Copyright (C) 2015, Intel Corporation\n+ *  All rights reserved.\n+ *\n+ *  @copyright\n+ *  Redistribution and use in source and binary forms, with or without\n+ *  modification, are permitted provided that the following conditions\n+ *  are met:\n+ *\n+ *    * Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.\n+ *    * Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in\n+ *      the documentation and/or other materials provided with the\n+ *      distribution.\n+ *    * Neither the name of Intel Corporation nor the names of its\n+ *      contributors may be used to endorse or promote products derived\n+ *      from this software without specific prior written permission.\n+ *\n+ *  @copyright\n+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ *  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ *  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ *  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ *  POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ **************************************************************************/\n+#ifdef __i386__\n+\n+/* i386 directory size is 4MB.  */\n+#define NUM_L1_BITS 20\n+#define NUM_L2_BITS 10\n+#define NUM_IGN_BITS 2\n+#define MPX_L1_ADDR_MASK  0xfffff000UL\n+#define MPX_L2_ADDR_MASK  0xfffffffcUL\n+#define MPX_L2_VALID_MASK 0x00000001UL\n+\n+#define REG_IP_IDX      REG_EIP\n+#define REX_PREFIX\n+\n+#define XSAVE_OFFSET_IN_FPMEM    sizeof (struct _libc_fpstate)\n+\n+#else /* __i386__ */\n+\n+/* x86_64 directory size is 2GB.  */\n+#define NUM_L1_BITS 28\n+#define NUM_L2_BITS 17\n+#define NUM_IGN_BITS 3\n+#define MPX_L1_ADDR_MASK  0xfffffffffffff000ULL\n+#define MPX_L2_ADDR_MASK  0xfffffffffffffff8ULL\n+#define MPX_L2_VALID_MASK 0x0000000000000001ULL\n+\n+#define REG_IP_IDX    REG_RIP\n+#define REX_PREFIX    \"0x48, \"\n+\n+#define XSAVE_OFFSET_IN_FPMEM 0\n+\n+#endif /* !__i386__ */\n+\n+#define MPX_L1_SIZE ((1UL << NUM_L1_BITS) * sizeof (void *))\n+\n+/* Get address of bounds directory.  */\n+void *\n+get_bd ();"}, {"sha": "f24cdc835dc5217c7a1ad9083bf434a9a1635d82", "filename": "libmpx/mpxwrap/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxwrap%2FMakefile.am?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -1,12 +1,14 @@\n ALCLOCAL_AMFLAGS = -I .. -I ../config\n+AM_CPPFLAGS = -I $(top_srcdir)\n \n # May be used by toolexeclibdir.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n \n libmpxwrappers_la_CFLAGS = -fcheck-pointer-bounds -mmpx -fno-chkp-check-read \\\n \t\t\t   -fno-chkp-check-write -fno-chkp-use-wrappers -fPIC\n libmpxwrappers_la_DEPENDENCIES = libmpxwrappers.map\n-libmpxwrappers_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpxwrappers.map\n+libmpxwrappers_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpxwrappers.map \\\n+               -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n \n toolexeclib_LTLIBRARIES = libmpxwrappers.la\n "}, {"sha": "df1a3347ba0ede10671856a93f5ea89eeec127a6", "filename": "libmpx/mpxwrap/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxwrap%2FMakefile.in?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -221,7 +221,6 @@ install_sh = @install_sh@\n libdir = @libdir@\n libexecdir = @libexecdir@\n link_libmpx = @link_libmpx@\n-link_mpx = @link_mpx@\n localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@\n@@ -247,14 +246,17 @@ top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n ALCLOCAL_AMFLAGS = -I .. -I ../config\n+AM_CPPFLAGS = -I $(top_srcdir)\n \n # May be used by toolexeclibdir.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n libmpxwrappers_la_CFLAGS = -fcheck-pointer-bounds -mmpx -fno-chkp-check-read \\\n \t\t\t   -fno-chkp-check-write -fno-chkp-use-wrappers -fPIC\n \n libmpxwrappers_la_DEPENDENCIES = libmpxwrappers.map\n-libmpxwrappers_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpxwrappers.map\n+libmpxwrappers_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libmpxwrappers.map \\\n+               -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+\n toolexeclib_LTLIBRARIES = libmpxwrappers.la\n libmpxwrappers_la_SOURCES = mpx_wrappers.c\n "}, {"sha": "fab30fb091d3763f9247c33e49492bacc8ab58a7", "filename": "libmpx/mpxwrap/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxwrap%2Flibtool-version?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -3,4 +3,4 @@\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-1:0:0\n+2:0:0"}, {"sha": "ffa7e7ee5fff161329ac220ed298966b6151c20f", "filename": "libmpx/mpxwrap/mpx_wrappers.c", "status": "modified", "additions": 394, "deletions": 61, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2Fmpx_wrappers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653b8b8d89fa0243b7e769a22f172b3264da58f4/libmpx%2Fmpxwrap%2Fmpx_wrappers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmpx%2Fmpxwrap%2Fmpx_wrappers.c?ref=653b8b8d89fa0243b7e769a22f172b3264da58f4", "patch": "@@ -26,6 +26,8 @@\n #include \"stdlib.h\"\n #include \"string.h\"\n #include <sys/mman.h>\n+#include <stdint.h>\n+#include \"mpxrt/mpxrt.h\"\n \n void *\n __mpx_wrapper_malloc (size_t size)\n@@ -88,75 +90,406 @@ __mpx_wrapper_bzero (void *dst, size_t len)\n   __mpx_wrapper_memset (dst, 0, len);\n }\n \n-void *\n-__mpx_wrapper_memmove (void *dst, const void *src, size_t n)\n+/* The mpx_pointer type is used for getting bits\n+   for bt_index (index in bounds table) and\n+   bd_index (index in bounds directory).  */\n+typedef union\n+{\n+  struct\n+  {\n+    unsigned long ignored:NUM_IGN_BITS;\n+    unsigned long l2entry:NUM_L2_BITS;\n+    unsigned long l1index:NUM_L1_BITS;\n+  };\n+  void *pointer;\n+} mpx_pointer;\n+\n+/* The mpx_bt_entry struct represents a cell in bounds table.\n+   lb is the lower bound, ub is the upper bound,\n+   p is the stored pointer.  */\n+struct mpx_bt_entry\n {\n-  const char *s = (const char*)src;\n-  char *d = (char*)dst;\n-  void *ret = dst;\n-  size_t offset_src = ((size_t) s) & (sizeof (void *) - 1);\n-  size_t offset_dst = ((size_t) d) & (sizeof (void *) - 1);\n+  void *lb;\n+  void *ub;\n+  void *p;\n+  void *reserved;\n+};\n+\n+/* A special type for bd is needed because bt addresses can be modified.  */\n+typedef struct mpx_bt_entry * volatile * bd_type;\n+\n+/* Function alloc_bt is used for allocating bounds table\n+   for the destination pointers if we don't have one.\n+   We generate a bounds store for some pointer belonging\n+   to that table and kernel allocates the table for us.  */\n+static inline void __attribute__ ((bnd_legacy))\n+alloc_bt (void *ptr)\n+{\n+  __asm__ __volatile__ (\"bndstx %%bnd0, (%0,%0)\"::\"r\" (ptr):\"%bnd0\");\n+}\n \n-  if (n == 0)\n-    return ret;\n+/* get_bt returns address of bounds table that should\n+   exist at BD[BD_INDEX].  If there is no address or the address is not valid,\n+   we try to allocate a valid table.\n+   If we succeed in getting bt, its address will be returned.\n+   If we can't get a valid bt, NULL will be returned.  */\n+__attribute__ ((bnd_legacy)) static inline struct mpx_bt_entry *\n+get_bt (unsigned bd_index, bd_type bd)\n+{\n+  struct mpx_bt_entry *bt = (struct mpx_bt_entry *) ((uintptr_t) bd[bd_index]\n+                            & MPX_L2_ADDR_MASK);\n+  if (!(bt) || !((uintptr_t) bd[bd_index] & MPX_L2_VALID_MASK))\n+    {\n+      mpx_pointer ptr;\n+      ptr.l1index = bd_index;\n+      /* If we don't have BT, allocate it.  */\n+      alloc_bt (ptr.pointer);\n+      bt = (struct mpx_bt_entry *) ((uintptr_t) bd[bd_index]\n+            & MPX_L2_ADDR_MASK);\n+      if (!(bt) || !((uintptr_t) bd[bd_index] & MPX_L2_VALID_MASK))\n+    return NULL;\n+    }\n+  return bt;\n+}\n \n-  __bnd_chk_ptr_bounds (dst, n);\n-  __bnd_chk_ptr_bounds (src, n);\n+/* Function copy_if_possible moves elements from *FROM to *TO.\n+   If ELEMS is less then the ELEMS_TO_COPY (elements we can copy),\n+   it copies ELEMS elements and returns 0.\n+   Otherwise, it copies ELEMS_TO_COPY elements and returns 1.  */\n+__attribute__ ((bnd_legacy)) static inline int\n+copy_if_possible (int elems, int elems_to_copy, struct mpx_bt_entry *from,\n+                  struct mpx_bt_entry *to)\n+{\n+  if (elems < elems_to_copy)\n+    memmove (to, from, elems * sizeof (struct mpx_bt_entry));\n+  else\n+    {\n+      memmove (to, from, elems_to_copy * sizeof (struct mpx_bt_entry));\n+      return 1;\n+    }\n+  return 0;\n+}\n \n-  /* Different alignment means that even if\n-     pointers exist in memory, we don't how\n-     pointers are aligned and therefore cann't\n-     copy bounds anyway.  */\n-  if (offset_src != offset_dst)\n-    memmove (dst, src, n);\n+/* Function copy_if_possible_from_end moves elements ending at *SRC_END\n+   to the place where they will end at *DST_END.\n+   If ELEMS is less then the ELEMS_TO_COPY (elements we can copy),\n+   function copies ELEMS elements and returns 0.\n+   Otherwise, it copies ELEMS_TO_COPY elements and returns 1.  */\n+__attribute__ ((bnd_legacy)) static inline int\n+copy_if_possible_from_end (int elems, int elems_to_copy, struct mpx_bt_entry\n+                           *src_end, struct mpx_bt_entry *dst_end)\n+{\n+  if (elems < elems_to_copy)\n+    memmove (dst_end - elems, src_end - elems,\n+             elems * sizeof (struct mpx_bt_entry));\n   else\n     {\n-      if (s < d)\n-\t{\n-\t  d += n;\n-\t  s += n;\n-\t  offset_src = (offset_src + n) & (sizeof (void *) -1);\n-\t  while (n-- && offset_src--)\n-\t    *--d = *--s;\n-\t  n++;\n-\t  if (!n)\n-\t    return ret;\n-\t  void **d1 = (void **)d;\n-\t  void **s1 = (void **)s;\n-\t  /* This loop will also copy bounds.  */\n-\t  while (n >= sizeof (void *))\n-\t    {\n-\t      n -= sizeof (void *);\n-\t      *--d1 = *--s1;\n-\t    }\n-\t  s = (char *)s1;\n-\t  d = (char *)d1;\n-\t  while (n--)\n-\t    *--d = *--s;\n-\t}\n+      memmove (dst_end - elems_to_copy,\n+           src_end - elems_to_copy,\n+           elems_to_copy * sizeof (struct mpx_bt_entry));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* move_bounds function copies bounds for N bytes from bt of SRC to bt of DST.\n+   It also copies bounds for all pointers inside.\n+   There are 3 parts of the algorithm:\n+   1) We copy everything till the end of the first bounds table of SRC\n+   2) In loop we copy whole bound tables till the second-last one\n+   3) Data in the last bounds table is copied separately, after the loop.\n+   If one of bound tables in SRC doesn't exist,\n+   we skip it because there are no pointers.\n+   Depending on the arrangement of SRC and DST we copy from the beginning\n+   or from the end.  */\n+__attribute__ ((bnd_legacy)) static void\n+move_bounds (void *dst, const void *src, size_t n)\n+{\n+  bd_type bd = (bd_type)get_bd ();\n+  if (!(bd))\n+    return;\n+\n+  /* We get indexes for all tables and number of elements for BT.  */\n+  unsigned long bt_num_of_elems = (1UL << NUM_L2_BITS);\n+  mpx_pointer addr_src, addr_dst, addr_src_end, addr_dst_end;\n+  addr_src.pointer = (char *) src;\n+  addr_dst.pointer = (char *) dst;\n+  addr_src_end.pointer = (char *) src + n - 1;\n+  addr_dst_end.pointer = (char *) dst + n - 1;\n+  unsigned dst_bd_index = addr_dst.l1index;\n+  unsigned src_bd_index = addr_src.l1index;\n+  unsigned dst_bt_index = addr_dst.l2entry;\n+  unsigned src_bt_index = addr_src.l2entry;\n+\n+  unsigned dst_bd_index_end = addr_dst_end.l1index;\n+  unsigned src_bd_index_end = addr_src_end.l1index;\n+  unsigned dst_bt_index_end = addr_dst_end.l2entry;\n+  unsigned src_bt_index_end = addr_src_end.l2entry;\n+\n+  int elems_to_copy = src_bt_index_end - src_bt_index + 1 + (src_bd_index_end\n+                      - src_bd_index) * bt_num_of_elems;\n+  struct mpx_bt_entry *bt_src, *bt_dst;\n+  uintptr_t bt_valid;\n+  /* size1 and size2 will be used to find out what portions\n+     can be used to copy data.  */\n+  int size1_elem, size2_elem, size1_bytes, size2_bytes;\n+\n+  /* Copy from the beginning.  */\n+  if (((char *) src - (char *) dst) > 0)\n+    {\n+      /* Copy everything till the end of the first bounds table (src)  */\n+      bt_src = (struct mpx_bt_entry *) ((uintptr_t) bd[src_bd_index]\n+                & MPX_L2_ADDR_MASK);\n+      bt_valid = (uintptr_t) bd[src_bd_index] & MPX_L2_VALID_MASK;\n+\n+      /* We can copy the whole preliminary piece of data.  */\n+      if (src_bt_index > dst_bt_index)\n+        {\n+          size1_elem = src_bt_index - dst_bt_index;\n+          size2_elem = bt_num_of_elems - size1_elem;\n+          size1_bytes = size1_elem * sizeof (struct mpx_bt_entry);\n+          size2_bytes = size2_elem * sizeof (struct mpx_bt_entry);\n+\n+          /* Check we have bounds to copy. */\n+          if (bt_src && bt_valid)\n+            {\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+              if (copy_if_possible (bt_num_of_elems - src_bt_index,\n+                  elems_to_copy, &(bt_src[src_bt_index]),\n+                  &(bt_dst[dst_bt_index])))\n+                return;\n+            }\n+          elems_to_copy -= bt_num_of_elems - src_bt_index;\n+        }\n+      /* We have to copy preliminary data in two parts.  */\n+      else\n+        {\n+          size2_elem = dst_bt_index - src_bt_index;\n+          size1_elem = bt_num_of_elems - size2_elem;\n+          size1_bytes = size1_elem * sizeof (struct mpx_bt_entry);\n+          size2_bytes = size2_elem * sizeof (struct mpx_bt_entry);\n+\n+          /* Check we have bounds to copy. */\n+          if (bt_src && bt_valid)\n+            {\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+\n+              if (copy_if_possible (bt_num_of_elems - dst_bt_index,\n+                  elems_to_copy, &(bt_src[src_bt_index]),\n+                  &(bt_dst[dst_bt_index])))\n+                return;\n+              elems_to_copy -= bt_num_of_elems - dst_bt_index;\n+\n+              dst_bd_index++;\n+\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+              if (copy_if_possible (size2_elem, elems_to_copy,\n+                  &(bt_src[size1_elem]), &(bt_dst[0])))\n+                return;\n+              elems_to_copy -= size2_elem;\n+            }\n+          else\n+            elems_to_copy -= bt_num_of_elems - src_bt_index;\n+        }\n+      src_bd_index++;\n+\n+      /* For each bounds table check if it's valid and move it.  */\n+      for (; src_bd_index < src_bd_index_end; src_bd_index++)\n+        {\n+          bt_src = (struct mpx_bt_entry *) ((uintptr_t) bd[src_bd_index]\n+                    & MPX_L2_ADDR_MASK);\n+          bt_valid = (uintptr_t) bd[src_bd_index] & MPX_L2_VALID_MASK;\n+\n+          /* Check we have bounds to copy. */\n+          if (!bt_src || !bt_valid)\n+            dst_bd_index++;\n+          else\n+            {\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+              memmove (&(bt_dst[size2_elem]), &(bt_src[0]), size1_bytes);\n+              dst_bd_index++;\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+              memmove (&(bt_dst[0]), &(bt_src[size1_elem]), size2_bytes);\n+            }\n+          elems_to_copy -= bt_num_of_elems;\n+        }\n+\n+      /* Now we have the last page that may be not full\n+         we copy it separately.  */\n+      if (elems_to_copy > 0)\n+        {\n+          bt_src = (struct mpx_bt_entry *) ((uintptr_t) bd[src_bd_index]\n+                    & MPX_L2_ADDR_MASK);\n+          bt_valid = (uintptr_t) bd[src_bd_index] & MPX_L2_VALID_MASK;\n+\n+          /* Check we have bounds to copy. */\n+          if (bt_src && bt_valid)\n+            {\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+\n+              if (copy_if_possible (size1_elem, elems_to_copy, &(bt_src[0]),\n+                  &(bt_dst[size2_elem])))\n+                return;\n+\n+              elems_to_copy -= size1_elem;\n+              dst_bd_index++;\n+              bt_dst = get_bt (dst_bd_index, bd);\n+              if (!bt_dst)\n+                return;\n+              memmove (&(bt_dst[0]), &(bt_src[size1_elem]),\n+                       elems_to_copy * sizeof (struct mpx_bt_entry));\n+\n+            }\n+        }\n+    }\n+  /* Copy from the end.  */\n+  else\n+    {\n+      /* Copy everything till the end of the first bounds table (src)  */\n+      bt_src = (struct mpx_bt_entry *) ((uintptr_t) bd[src_bd_index_end]\n+                & MPX_L2_ADDR_MASK);\n+      bt_valid = (uintptr_t) bd[src_bd_index_end] & MPX_L2_VALID_MASK;\n+\n+      if (src_bt_index_end <= dst_bt_index_end)\n+      /* We can copy the whole preliminary piece of data.  */\n+        {\n+          size2_elem = dst_bt_index_end - src_bt_index_end;\n+          size1_elem = bt_num_of_elems - size2_elem;\n+          size1_bytes = size1_elem * sizeof (struct mpx_bt_entry);\n+          size2_bytes = size2_elem * sizeof (struct mpx_bt_entry);\n+\n+          /* Check we have bounds to copy. */\n+          if (bt_src && bt_valid)\n+            {\n+              bt_dst = get_bt (dst_bd_index_end, bd);\n+              if (!bt_dst)\n+                return;\n+\n+              if (copy_if_possible_from_end (src_bt_index_end + 1,\n+                  elems_to_copy, &(bt_src[src_bt_index_end + 1]),\n+                  &(bt_dst[dst_bt_index_end + 1])))\n+                return;\n+            }\n+          elems_to_copy -= src_bt_index_end + 1;\n+        }\n+      /* We have to copy preliminary data in two parts.  */\n       else\n-\t{\n-\t  offset_src = sizeof (void *) - offset_src;\n-\t  while (n-- && offset_src--)\n-\t    *d++ = *s++;\n-\t  n++;\n-\t  if (!n)\n-\t    return ret;\n-\t  void **d1 = (void **)d;\n-\t  void **s1 = (void **)s;\n-\t  /* This loop will also copy bounds.  */\n-\t  while (n >= sizeof (void *))\n-\t    {\n-\t      n -= sizeof (void *);\n-\t      *d1++ = *s1++;\n-\t    }\n-\t  s = (char *)s1;\n-\t  d = (char *)d1;\n-\t  while (n--)\n-\t    *d++ = *s++;\n-\t}\n+        {\n+          size1_elem = src_bt_index_end - dst_bt_index_end;\n+          size2_elem = bt_num_of_elems - size1_elem;\n+          size1_bytes = size1_elem * sizeof (struct mpx_bt_entry);\n+          size2_bytes = size2_elem * sizeof (struct mpx_bt_entry);\n+\n+          /* Check we have bounds to copy. */\n+          if (bt_src && bt_valid)\n+            {\n+              bt_dst = get_bt (dst_bd_index_end, bd);\n+              if (!bt_dst)\n+                return;\n+              if (copy_if_possible_from_end (dst_bt_index_end + 1,\n+                  elems_to_copy, &(bt_src[src_bt_index_end + 1]),\n+                  &(bt_dst[dst_bt_index_end + 1])))\n+                return;\n+              elems_to_copy -= dst_bt_index_end + 1;\n+\n+              dst_bd_index_end--;\n+\n+              bt_dst = get_bt (dst_bd_index_end, bd);\n+              if (!bt_dst)\n+                return;\n+              if (copy_if_possible_from_end (size1_elem, elems_to_copy,\n+                  &(bt_src[size1_elem]), &(bt_dst[bt_num_of_elems])))\n+                return;\n+\n+              elems_to_copy -= size1_elem;\n+            }\n+          else\n+            elems_to_copy -= src_bt_index_end + 1;\n+        }\n+      src_bd_index_end--;\n+      /* For each bounds table we check if there are valid pointers inside.\n+         If there are some, we copy table in pre-counted portions.  */\n+      for (; src_bd_index_end > src_bd_index; src_bd_index_end--)\n+        {\n+          bt_src = (struct mpx_bt_entry *) ((uintptr_t) bd[src_bd_index_end]\n+                    & MPX_L2_ADDR_MASK);\n+          bt_valid = (uintptr_t) bd[src_bd_index_end] & MPX_L2_VALID_MASK;\n+          /* Check we have bounds to copy. */\n+          if (!bt_src || !bt_valid)\n+            dst_bd_index_end--;\n+          else\n+            {\n+              bt_dst = get_bt (dst_bd_index_end, bd);\n+              if (!bt_dst)\n+                return;\n+              memmove (&(bt_dst[0]), &(bt_src[size1_elem]), size2_bytes);\n+              dst_bd_index_end--;\n+              bt_dst = get_bt (dst_bd_index_end, bd);\n+              if (!bt_dst)\n+                return;\n+              memmove (&(bt_dst[size2_elem]), &(bt_src[0]), size1_bytes);\n+            }\n+          elems_to_copy -= bt_num_of_elems;\n+        }\n+\n+      /* Now we have the last page that may be not full\n+         we copy it separately.  */\n+      if (elems_to_copy > 0)\n+        {\n+          bt_src = (struct mpx_bt_entry *) ((uintptr_t) bd[src_bd_index_end]\n+                    & MPX_L2_ADDR_MASK);\n+          bt_valid = (uintptr_t) bd[src_bd_index_end] & MPX_L2_VALID_MASK;\n+          /* Check we have bounds to copy. */\n+          if (bt_src && bt_valid)\n+          {\n+            bt_dst = get_bt (dst_bd_index_end, bd);\n+            if (!bt_dst)\n+              return;\n+            if (copy_if_possible_from_end (size2_elem, elems_to_copy,\n+                &(bt_src[bt_num_of_elems]), &(bt_dst[size2_elem])))\n+              return;\n+\n+            elems_to_copy -= size2_elem;\n+            dst_bd_index_end--;\n+            bt_dst = get_bt (dst_bd_index_end, bd);\n+            if (!bt_dst)\n+              return;\n+            memmove (&(bt_dst[dst_bt_index]), &(bt_src[src_bt_index]),\n+                     elems_to_copy * sizeof (struct mpx_bt_entry));\n+          }\n+        }\n     }\n-  return ret;\n+  return;\n+}\n+\n+void *\n+__mpx_wrapper_memmove (void *dst, const void *src, size_t n)\n+{\n+  if (n == 0)\n+    return dst;\n+\n+  __bnd_chk_ptr_bounds (dst, n);\n+  __bnd_chk_ptr_bounds (src, n);\n+\n+  memmove (dst, src, n);\n+  /* Not necessary to copy bounds if size is less then size of pointer\n+     or SRC==DST.  */\n+  if ((n >= sizeof (void *)) && (src != dst))\n+    move_bounds (dst, src, n);\n+\n+  return dst;\n }\n \n "}]}