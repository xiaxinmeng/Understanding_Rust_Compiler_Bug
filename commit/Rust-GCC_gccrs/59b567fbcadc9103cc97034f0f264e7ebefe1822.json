{"sha": "59b567fbcadc9103cc97034f0f264e7ebefe1822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTliNTY3ZmJjYWRjOTEwM2NjOTcwMzRmMGYyNjRlN2ViZWZlMTgyMg==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-11-02T15:34:24Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2007-11-02T15:34:24Z"}, "message": "re PR libstdc++/33892 ([libstdc++ v3 parallel mode] Parallel mode algorithms use critical sections with global scope)\n\n2007-11-02  Johannes Singler  <singler@ira.uka.de>\n\n      PR libstdc++/33892\n\n      * include/parallel/workstealing.h: Replaced pragma by function\n        call lock.\n      * include/parallel/search.h: Same\n      * include/parallel/partition.h: Same\n      * include/parallel/find.h: Same\n\nFrom-SVN: r129852", "tree": {"sha": "cc96f86dbcdaf37ff9e7561258f0971eff5fc826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc96f86dbcdaf37ff9e7561258f0971eff5fc826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59b567fbcadc9103cc97034f0f264e7ebefe1822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b567fbcadc9103cc97034f0f264e7ebefe1822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b567fbcadc9103cc97034f0f264e7ebefe1822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b567fbcadc9103cc97034f0f264e7ebefe1822/comments", "author": null, "committer": null, "parents": [{"sha": "f3a032e9285dfac0b5f62fc9da8e082f25b9538c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a032e9285dfac0b5f62fc9da8e082f25b9538c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3a032e9285dfac0b5f62fc9da8e082f25b9538c"}], "stats": {"total": 126, "additions": 84, "deletions": 42}, "files": [{"sha": "586f3377953af8498089d5215f5fa7696641df50", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=59b567fbcadc9103cc97034f0f264e7ebefe1822", "patch": "@@ -1,3 +1,11 @@\n+2007-11-02  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/workstealing.h: Replaced pragma by function\n+          call lock.\n+        * include/parallel/search.h: Same\n+        * include/parallel/partition.h: Same\n+        * include/parallel/find.h: Same\n+\n 2007-11-01  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR testsuite/25352"}, {"sha": "bc89fa570e5decc13022417e8b42eaf3a918d0f9", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=59b567fbcadc9103cc97034f0f264e7ebefe1822", "patch": "@@ -104,6 +104,8 @@ namespace __gnu_parallel\n     difference_type result = length;\n \n     const thread_index_t num_threads = get_max_threads();\n+    omp_lock_t result_lock;\n+    omp_init_lock(&result_lock);\n \n     difference_type* borders = static_cast<difference_type*>(__builtin_alloca(sizeof(difference_type) * (num_threads + 1)));\n \n@@ -119,21 +121,24 @@ namespace __gnu_parallel\n       for (; pos < limit; pos++)\n \t{\n #pragma omp flush(result)\n-\t  // Result has been set to something lower.\n-\t  if (result < pos)\n-\t    break;\n-\n-\t  if (selector(i1, i2, pred))\n-\t    {\n-#pragma omp critical (result)\n-\t      if (result > pos)\n-\t\tresult = pos;\n-\t      break;\n-\t    }\n-\t  i1++;\n-\t  i2++;\n-\t}\n+          // Result has been set to something lower.\n+          if (result < pos)\n+            break;\n+\n+          if (selector(i1, i2, pred))\n+            {\n+              omp_set_lock(&result_lock);\n+              if (result > pos)\n+                result = pos;\n+              omp_unset_lock(&result_lock);\n+              break;\n+            }\n+          i1++;\n+          i2++;\n+        }\n     }\n+\n+    omp_destroy_lock(&result_lock);\n     return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n   }\n \n@@ -191,6 +196,9 @@ namespace __gnu_parallel\n     difference_type result = length;\n     const thread_index_t num_threads = get_max_threads();\n \n+    omp_lock_t result_lock;\n+    omp_init_lock(&result_lock);\n+\n #pragma omp parallel shared(result) num_threads(num_threads)\n     {\n       // Not within first k elements -> start parallel.\n@@ -217,14 +225,15 @@ namespace __gnu_parallel\n \t  local_result = selector.sequential_algorithm(begin1 + start, begin1 + stop, begin2 + start, pred);\n \t  if (local_result.first != (begin1 + stop))\n \t    {\n-#pragma omp critical(result)\n+              omp_set_lock(&result_lock);\n \t      if ((local_result.first - begin1) < result)\n \t\t{\n \t\t  result = local_result.first - begin1;\n \n \t\t  // Result cannot be in future blocks, stop algorithm.\n \t\t  fetch_and_add<difference_type>(&next_block_pos, length);\n \t\t}\n+              omp_unset_lock(&result_lock);\n \t    }\n \n \t  block_size = std::min<difference_type>(block_size * Settings::find_increasing_factor, Settings::find_maximum_block_size);\n@@ -235,6 +244,8 @@ namespace __gnu_parallel\n \t}\n     }\n \n+    omp_destroy_lock(&result_lock);\n+\n     // Return iterator on found element.\n     return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n   }\n@@ -286,6 +297,9 @@ namespace __gnu_parallel\n     difference_type result = length;\n     const thread_index_t num_threads = get_max_threads();\n \n+    omp_lock_t result_lock;\n+    omp_init_lock(&result_lock);\n+\n     // Not within first sequential_search_size elements -> start parallel.\n #pragma omp parallel shared(result) num_threads(num_threads)\n     {\n@@ -314,10 +328,10 @@ namespace __gnu_parallel\n \t  local_result = selector.sequential_algorithm(begin1 + start, begin1 + stop, begin2 + start, pred);\n \t  if (local_result.first != (begin1 + stop))\n \t    {\n-#pragma omp critical(result)\n+\t      omp_set_lock(&result_lock);\n \t      if ((local_result.first - begin1) < result)\n \t\tresult = local_result.first - begin1;\n-\n+              omp_unset_lock(&result_lock);\n \t      // Will not find better value in its interval.\n \t      break;\n \t    }\n@@ -330,6 +344,8 @@ namespace __gnu_parallel\n \t}\n     }\n \n+    omp_destroy_lock(&result_lock);\n+\n     // Return iterator on found element.\n     return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n   }"}, {"sha": "d21a615960e1301ef6d32867dac0f10dd2ac5f18", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=59b567fbcadc9103cc97034f0f264e7ebefe1822", "patch": "@@ -84,6 +84,9 @@ namespace __gnu_parallel\n     else\n       chunk_size = Settings::partition_chunk_size;\n \n+    omp_lock_t result_lock;\n+    omp_init_lock(&result_lock);\n+\n     // At least good for two processors.\n     while (right - left + 1 >= 2 * max_num_threads * chunk_size)\n       {\n@@ -113,8 +116,8 @@ namespace __gnu_parallel\n \t  while (!iam_finished)\n \t    {\n \t      if (thread_left > thread_left_border)\n-#pragma omp critical\n \t\t{\n+                  omp_set_lock(&result_lock);\n \t\t  if (left + (chunk_size - 1) > right)\n \t\t    iam_finished = true;\n \t\t  else\n@@ -123,11 +126,12 @@ namespace __gnu_parallel\n \t\t      thread_left_border = left + (chunk_size - 1);\n \t\t      left += chunk_size;\n \t\t    }\n+                  omp_unset_lock(&result_lock);\n \t\t}\n \n \t      if (thread_right < thread_right_border)\n-#pragma omp critical\n \t\t{\n+                  omp_set_lock(&result_lock);\n \t\t  if (left > right - (chunk_size - 1))\n \t\t    iam_finished = true;\n \t\t  else\n@@ -136,6 +140,7 @@ namespace __gnu_parallel\n \t\t      thread_right_border = right - (chunk_size - 1);\n \t\t      right -= chunk_size;\n \t\t    }\n+                  omp_unset_lock(&result_lock);\n \t\t}\n \n \t      if (iam_finished)\n@@ -199,16 +204,15 @@ namespace __gnu_parallel\n \t    {\n \t      // Find spot and swap.\n \t      difference_type swapstart = -1;\n-#pragma omp critical\n-\t      {\n-\t\tfor (int r = 0; r < leftover_left; r++)\n-\t\t  if (!reserved_left[r])\n-\t\t    {\n-\t\t      reserved_left[r] = true;\n-\t\t      swapstart = left - (r + 1) * chunk_size;\n-\t\t      break;\n-\t\t    }\n-\t      }\n+              omp_set_lock(&result_lock);\n+\t      for (int r = 0; r < leftover_left; r++)\n+                  if (!reserved_left[r])\n+                    {\n+                      reserved_left[r] = true;\n+                      swapstart = left - (r + 1) * chunk_size;\n+                      break;\n+                    }\n+              omp_unset_lock(&result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n \t      _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n@@ -222,16 +226,15 @@ namespace __gnu_parallel\n \t    {\n \t      // Find spot and swap\n \t      difference_type swapstart = -1;\n-#pragma omp critical\n-\t      {\n-\t\tfor (int r = 0; r < leftover_right; r++)\n+              omp_set_lock(&result_lock);\n+\t      for (int r = 0; r < leftover_right; r++)\n \t\t  if (!reserved_right[r])\n \t\t    {\n \t\t      reserved_right[r] = true;\n \t\t      swapstart = right + r * chunk_size + 1;\n \t\t      break;\n \t\t    }\n-\t      }\n+              omp_unset_lock(&result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n \t      _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n@@ -283,6 +286,8 @@ namespace __gnu_parallel\n     delete[] reserved_left;\n     delete[] reserved_right;\n \n+    omp_destroy_lock(&result_lock);\n+\n     // Element \"between\" final_left and final_right might not have\n     // been regarded yet\n     if (final_left < n && !pred(begin[final_left]))"}, {"sha": "ba00a8faf6ee47487bba856d89dbef99feb383cb", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=59b567fbcadc9103cc97034f0f264e7ebefe1822", "patch": "@@ -102,14 +102,17 @@ namespace __gnu_parallel\n     difference_type input_length = (end1 - begin1) - pattern_length;\n \n     // Where is first occurrence of pattern? defaults to end.\n-    difference_type res = (end1 - begin1);\n+    difference_type result = (end1 - begin1);\n \n     // Pattern too long.\n     if (input_length < 0)\n       return end1;\n \n     thread_index_t num_threads = std::max<difference_type>(1, std::min<difference_type>(input_length, __gnu_parallel::get_max_threads()));\n \n+    omp_lock_t result_lock;\n+    omp_init_lock(&result_lock);\n+\n     difference_type borders[num_threads + 1];\n     __gnu_parallel::equally_split(input_length, num_threads, borders);\n \n@@ -127,19 +130,21 @@ namespace __gnu_parallel\n \n       while (start <= stop && !found_pattern)\n \t{\n-\t  // Get new value of res.\n-#pragma omp flush(res)\n+\t  // Get new value of result.\n+#pragma omp flush(result)\n \t  // No chance for this thread to find first occurrence.\n-\t  if (res < start)\n+\t  if (result < start)\n \t    break;\n \t  while (pred(begin1[start + pos_in_pattern], begin2[pos_in_pattern]))\n \t    {\n \t      ++pos_in_pattern;\n \t      if (pos_in_pattern == pattern_length)\n \t\t{\n-\t\t  // Found new candidate for res.\n-#pragma omp critical (res)\n-\t\t  res = std::min(res, start);\n+\t\t  // Found new candidate for result.\n+                  omp_set_lock(&result_lock);\n+\t\t  result = std::min(result, start);\n+                  omp_unset_lock(&result_lock);\n+\n \t\t  found_pattern = true;\n \t\t  break;\n \t\t}\n@@ -150,8 +155,10 @@ namespace __gnu_parallel\n \t}\n     }\n \n+    omp_destroy_lock(&result_lock);\n+\n     // Return iterator on found element.\n-    return (begin1 + res);\n+    return (begin1 + result);\n   }\n } // end namespace\n "}, {"sha": "7704245d3073f30724f39997649f35334f2b6e06", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b567fbcadc9103cc97034f0f264e7ebefe1822/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=59b567fbcadc9103cc97034f0f264e7ebefe1822", "patch": "@@ -123,6 +123,9 @@ namespace __gnu_parallel\n     thread_index_t num_threads = get_max_threads();\n     difference_type num_threads_min = num_threads < end - begin ? num_threads : end - begin;\n \n+    omp_lock_t output_lock;\n+    omp_init_lock(&output_lock);\n+\n     // No more threads than jobs, at least one thread.\n     difference_type num_threads_max = num_threads_min > 1 ? num_threads_min : 1;\n     num_threads = static_cast<thread_index_t>(num_threads_max);\n@@ -276,9 +279,10 @@ namespace __gnu_parallel\n \t    }\n #pragma omp flush(busy)\n \t} // end while busy > 0\n-#pragma omp critical(writeOutput)\n       // Add accumulated result to output.\n+      omp_set_lock(&output_lock);\n       output = r(output, result);\n+      omp_unset_lock(&output_lock);\n \n       //omp_destroy_lock(&(my_job.lock));\n     }\n@@ -289,6 +293,8 @@ namespace __gnu_parallel\n     // some algorithms like transform)\n     f.finish_iterator = begin + length;\n \n+    omp_destroy_lock(&output_lock);\n+\n     return op;\n   }\n } // end namespace"}]}