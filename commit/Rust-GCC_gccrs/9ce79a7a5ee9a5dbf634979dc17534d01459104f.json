{"sha": "9ce79a7a5ee9a5dbf634979dc17534d01459104f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNlNzlhN2E1ZWU5YTVkYmY2MzQ5NzlkYzE3NTM0ZDAxNDU5MTA0Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-01-19T21:51:06Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-01-19T21:51:06Z"}, "message": "re PR rtl-optimization/5263 (a & b & ~a & ~b not optimized)\n\n\n\tPR optimization/5263\n\t* simplify-rtx.c (associative_constant_p): Delete.\n\t(simplify_associative_operation): Rewrite to linearize terms, and\n\tattempt to simplify new term against both left and right subterms.\n\t(simplify_binary_operation): Call swap_commutative_operands_p on\n\top0 and op1, not trueop0 and trueop1.  Move the initialization of\n\ttrueop0 and trueop1 down to where first needed.\n\t(simplify_relational_operation): Likewise.\n\t* rtlanal.c (commutative_operand_precedence): Also order constant\n\toperands using avoid_constant_pool_reference.\n\nFrom-SVN: r76179", "tree": {"sha": "13ca67175f8037cdb994d41ba64df008eabc1b44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13ca67175f8037cdb994d41ba64df008eabc1b44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ce79a7a5ee9a5dbf634979dc17534d01459104f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce79a7a5ee9a5dbf634979dc17534d01459104f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce79a7a5ee9a5dbf634979dc17534d01459104f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce79a7a5ee9a5dbf634979dc17534d01459104f/comments", "author": null, "committer": null, "parents": [{"sha": "0916f87331e015fa7851354dd96180543f1934d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0916f87331e015fa7851354dd96180543f1934d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0916f87331e015fa7851354dd96180543f1934d6"}], "stats": {"total": 127, "additions": 68, "deletions": 59}, "files": [{"sha": "7949b4feadc667ffcf198a0981fc9edc7ef04292", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce79a7a5ee9a5dbf634979dc17534d01459104f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce79a7a5ee9a5dbf634979dc17534d01459104f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ce79a7a5ee9a5dbf634979dc17534d01459104f", "patch": "@@ -1,3 +1,16 @@\n+2004-01-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/5263\n+\t* simplify-rtx.c (associative_constant_p): Delete.\n+\t(simplify_associative_operation): Rewrite to linearize terms, and\n+\tattempt to simplify new term against both left and right subterms.\n+\t(simplify_binary_operation): Call swap_commutative_operands_p on\n+\top0 and op1, not trueop0 and trueop1.  Move the initialization of\n+\ttrueop0 and trueop1 down to where first needed.\n+\t(simplify_relational_operation): Likewise.\n+\t* rtlanal.c (commutative_operand_precedence): Also order constant\n+\toperands using avoid_constant_pool_reference.\n+\n 2004-01-19  Richard Henderson  <rth@redhat.com>\n \n         * config/alpha/alpha.c (aligned_memory_operand): Check MEM_ALIGN,"}, {"sha": "44a6c6c40f85166dd89b79d8d350136926e65e4f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce79a7a5ee9a5dbf634979dc17534d01459104f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce79a7a5ee9a5dbf634979dc17534d01459104f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9ce79a7a5ee9a5dbf634979dc17534d01459104f", "patch": "@@ -1,6 +1,6 @@\n /* Analyze RTL for C-Compiler\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -3022,6 +3022,11 @@ int\n commutative_operand_precedence (rtx op)\n {\n   /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n+  if (GET_CODE (op) == CONST_INT)\n+    return -7;\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    return -6;\n+  op = avoid_constant_pool_reference (op);\n   if (GET_CODE (op) == CONST_INT)\n     return -5;\n   if (GET_CODE (op) == CONST_DOUBLE)"}, {"sha": "7272424f8cc346812afa9a2301a2299c9a38c9aa", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce79a7a5ee9a5dbf634979dc17534d01459104f/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce79a7a5ee9a5dbf634979dc17534d01459104f/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=9ce79a7a5ee9a5dbf634979dc17534d01459104f", "patch": "@@ -55,7 +55,6 @@ static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx,\n \t\t\t\trtx, int);\n static rtx simplify_immed_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t\t  unsigned int);\n-static bool associative_constant_p (rtx);\n static rtx simplify_associative_operation (enum rtx_code, enum machine_mode,\n \t\t\t\t\t   rtx, rtx);\n \f\n@@ -1084,67 +1083,59 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n     }\n }\n \f\n-/* Subroutine of simplify_associative_operation.  Return true if rtx OP\n-   is a suitable integer or floating point immediate constant.  */\n-static bool\n-associative_constant_p (rtx op)\n-{\n-  if (GET_CODE (op) == CONST_INT\n-      || GET_CODE (op) == CONST_DOUBLE)\n-    return true;\n-  op = avoid_constant_pool_reference (op);\n-  return GET_CODE (op) == CONST_INT\n-\t || GET_CODE (op) == CONST_DOUBLE;\n-}\n+/* Subroutine of simplify_binary_operation to simplify a commutative,\n+   associative binary operation CODE with result mode MODE, operating\n+   on OP0 and OP1.  CODE is currently one of PLUS, MULT, AND, IOR, XOR,\n+   SMIN, SMAX, UMIN or UMAX.  Return zero if no simplification or\n+   canonicalization is possible.  */\n \n-/* Subroutine of simplify_binary_operation to simplify an associative\n-   binary operation CODE with result mode MODE, operating on OP0 and OP1.\n-   Return 0 if no simplification is possible.  */\n static rtx\n simplify_associative_operation (enum rtx_code code, enum machine_mode mode,\n \t\t\t\trtx op0, rtx op1)\n {\n   rtx tem;\n \n-  /* Simplify (x op c1) op c2 as x op (c1 op c2).  */\n-  if (GET_CODE (op0) == code\n-      && associative_constant_p (op1)\n-      && associative_constant_p (XEXP (op0, 1)))\n+  /* Linearize the operator to the left.  */\n+  if (GET_CODE (op1) == code)\n     {\n-      tem = simplify_binary_operation (code, mode, XEXP (op0, 1), op1);\n-      if (! tem)\n-\treturn tem;\n-      return simplify_gen_binary (code, mode, XEXP (op0, 0), tem);\n-    }\n+      /* \"(a op b) op (c op d)\" becomes \"((a op b) op c) op d)\".  */\n+      if (GET_CODE (op0) == code)\n+\t{\n+\t  tem = simplify_gen_binary (code, mode, op0, XEXP (op1, 0));\n+\t  return simplify_gen_binary (code, mode, tem, XEXP (op1, 1));\n+\t}\n \n-  /* Simplify (x op c1) op (y op c2) as (x op y) op (c1 op c2).  */\n-  if (GET_CODE (op0) == code\n-      && GET_CODE (op1) == code\n-      && associative_constant_p (XEXP (op0, 1))\n-      && associative_constant_p (XEXP (op1, 1)))\n-    {\n-      rtx c = simplify_binary_operation (code, mode,\n-\t\t\t\t\t XEXP (op0, 1), XEXP (op1, 1));\n-      if (! c)\n-\treturn 0;\n-      tem = simplify_gen_binary (code, mode, XEXP (op0, 0), XEXP (op1, 0));\n-      return simplify_gen_binary (code, mode, tem, c);\n-    }\n+      /* \"a op (b op c)\" becomes \"(b op c) op a\".  */\n+      if (! swap_commutative_operands_p (op1, op0))\n+\treturn simplify_gen_binary (code, mode, op1, op0);\n \n-  /* Canonicalize (x op c) op y as (x op y) op c.  */\n-  if (GET_CODE (op0) == code\n-      && associative_constant_p (XEXP (op0, 1)))\n-    {\n-      tem = simplify_gen_binary (code, mode, XEXP (op0, 0), op1);\n-      return simplify_gen_binary (code, mode, tem, XEXP (op0, 1));\n+      tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n     }\n \n-  /* Canonicalize x op (y op c) as (x op y) op c.  */\n-  if (GET_CODE (op1) == code\n-      && associative_constant_p (XEXP (op1, 1)))\n+  if (GET_CODE (op0) == code)\n     {\n-      tem = simplify_gen_binary (code, mode, op0, XEXP (op1, 0));\n-      return simplify_gen_binary (code, mode, tem, XEXP (op1, 1));\n+      /* Canonicalize \"(x op c) op y\" as \"(x op y) op c\".  */\n+      if (swap_commutative_operands_p (XEXP (op0, 1), op1))\n+\t{\n+\t  tem = simplify_gen_binary (code, mode, XEXP (op0, 0), op1);\n+\t  return simplify_gen_binary (code, mode, tem, XEXP (op0, 1));\n+\t}\n+\n+      /* Attempt to simplify \"(a op b) op c\" as \"a op (b op c)\".  */\n+      tem = swap_commutative_operands_p (XEXP (op0, 1), op1)\n+\t    ? simplify_binary_operation (code, mode, op1, XEXP (op0, 1))\n+\t    : simplify_binary_operation (code, mode, XEXP (op0, 1), op1);\n+      if (tem != 0)\n+        return simplify_gen_binary (code, mode, XEXP (op0, 0), tem);\n+\n+      /* Attempt to simplify \"(a op b) op c\" as \"(a op c) op b\".  */\n+      tem = swap_commutative_operands_p (XEXP (op0, 0), op1)\n+\t    ? simplify_binary_operation (code, mode, op1, XEXP (op0, 0))\n+\t    : simplify_binary_operation (code, mode, XEXP (op0, 0), op1);\n+      if (tem != 0)\n+        return simplify_gen_binary (code, mode, tem, XEXP (op0, 1));\n     }\n \n   return 0;\n@@ -1162,9 +1153,8 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n   HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n   HOST_WIDE_INT val;\n   unsigned int width = GET_MODE_BITSIZE (mode);\n+  rtx trueop0, trueop1;\n   rtx tem;\n-  rtx trueop0 = avoid_constant_pool_reference (op0);\n-  rtx trueop1 = avoid_constant_pool_reference (op1);\n \n   /* Relational operations don't work here.  We must know the mode\n      of the operands in order to do the comparison correctly.\n@@ -1176,12 +1166,14 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n   /* Make sure the constant is second.  */\n   if (GET_RTX_CLASS (code) == 'c'\n-      && swap_commutative_operands_p (trueop0, trueop1))\n+      && swap_commutative_operands_p (op0, op1))\n     {\n       tem = op0, op0 = op1, op1 = tem;\n-      tem = trueop0, trueop0 = trueop1, trueop1 = tem;\n     }\n \n+  trueop0 = avoid_constant_pool_reference (op0);\n+  trueop1 = avoid_constant_pool_reference (op1);\n+\n   if (VECTOR_MODE_P (mode)\n       && GET_CODE (trueop0) == CONST_VECTOR\n       && GET_CODE (trueop1) == CONST_VECTOR)\n@@ -2509,22 +2501,21 @@ simplify_relational_operation (enum rtx_code code, enum machine_mode mode,\n   if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n     op1 = XEXP (op0, 1), op0 = XEXP (op0, 0);\n \n-  trueop0 = avoid_constant_pool_reference (op0);\n-  trueop1 = avoid_constant_pool_reference (op1);\n-\n   /* We can't simplify MODE_CC values since we don't know what the\n      actual comparison is.  */\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC || CC0_P (op0))\n     return 0;\n \n   /* Make sure the constant is second.  */\n-  if (swap_commutative_operands_p (trueop0, trueop1))\n+  if (swap_commutative_operands_p (op0, op1))\n     {\n       tem = op0, op0 = op1, op1 = tem;\n-      tem = trueop0, trueop0 = trueop1, trueop1 = tem;\n       code = swap_condition (code);\n     }\n \n+  trueop0 = avoid_constant_pool_reference (op0);\n+  trueop1 = avoid_constant_pool_reference (op1);\n+\n   /* For integer comparisons of A and B maybe we can simplify A - B and can\n      then simplify a comparison of that with zero.  If A and B are both either\n      a register or a CONST_INT, this can't help; testing for these cases will"}]}