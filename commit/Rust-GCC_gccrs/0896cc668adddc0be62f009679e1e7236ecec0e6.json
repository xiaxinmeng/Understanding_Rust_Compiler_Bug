{"sha": "0896cc668adddc0be62f009679e1e7236ecec0e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5NmNjNjY4YWRkZGMwYmU2MmYwMDk2NzllMWU3MjM2ZWNlYzBlNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2010-05-28T22:19:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2010-05-28T22:19:22Z"}, "message": "ira.c (ira_bad_reload_regno, [...]): New functions.\n\n\t* ira.c (ira_bad_reload_regno, ira_build_reload_regno_1): New functions.\n\t* ira.h (ira_bad_reload_regno): Declare\n\t* reload1.c (allocate_reload_reg): Use ira_bad_reload_regno.\n\nFrom-SVN: r160001", "tree": {"sha": "9dc1cb58dbd6084f4583c0e45cae66cdd60ca456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dc1cb58dbd6084f4583c0e45cae66cdd60ca456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0896cc668adddc0be62f009679e1e7236ecec0e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0896cc668adddc0be62f009679e1e7236ecec0e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0896cc668adddc0be62f009679e1e7236ecec0e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0896cc668adddc0be62f009679e1e7236ecec0e6/comments", "author": null, "committer": null, "parents": [{"sha": "bdf0eb066733a11e3d1aa6fc34d3c8724b743247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdf0eb066733a11e3d1aa6fc34d3c8724b743247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdf0eb066733a11e3d1aa6fc34d3c8724b743247"}], "stats": {"total": 63, "additions": 59, "deletions": 4}, "files": [{"sha": "7bf25681d61e021a569868945f6f31bfdc804f23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0896cc668adddc0be62f009679e1e7236ecec0e6", "patch": "@@ -1,5 +1,10 @@\n 2010-05-28  Jeff Law  <law@redhat.com>\n \n+\t* ira.c (ira_bad_reload_regno, ira_build_reload_regno_1): New\n+\tfunctions.\n+\t* ira.h (ira_bad_reload_regno): Declare\n+\t* reload1.c (allocate_reload_reg): Use ira_bad_reload_regno.\n+\n \t* ira-color.c (update_curr_costs): Free updated hard reg costs.\n \t(ira_reassign_conflict_allocnos): Remove bogus asserts.\n \t(allocno_reload_assign): Likewise."}, {"sha": "84d7bc1643b5e12d7605425990c302b7f35378cf", "filename": "gcc/ira.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=0896cc668adddc0be62f009679e1e7236ecec0e6", "patch": "@@ -1374,6 +1374,46 @@ setup_prohibited_mode_move_regs (void)\n \n \f\n \n+/* Return nonzero if REGNO is a particularly bad choice for reloading X.  */\n+static bool\n+ira_bad_reload_regno_1 (int regno, rtx x)\n+{\n+  int x_regno;\n+  ira_allocno_t a;\n+  enum reg_class pref;\n+\n+  /* We only deal with pseudo regs.  */\n+  if (! x || GET_CODE (x) != REG)\n+    return false;\n+\n+  x_regno = REGNO (x);\n+  if (x_regno < FIRST_PSEUDO_REGISTER)\n+    return false;\n+\n+  /* If the pseudo prefers REGNO explicitly, then do not consider\n+     REGNO a bad spill choice.  */\n+  pref = reg_preferred_class (x_regno);\n+  if (reg_class_size[pref] == 1)\n+    return !TEST_HARD_REG_BIT (reg_class_contents[pref], regno);\n+\n+  /* If the pseudo conflicts with REGNO, then we consider REGNO a\n+     poor choice for a reload regno.  */\n+  a = ira_regno_allocno_map[x_regno];\n+  if (TEST_HARD_REG_BIT (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), regno))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return nonzero if REGNO is a particularly bad choice for reloading\n+   IN or OUT.  */\n+bool\n+ira_bad_reload_regno (int regno, rtx in, rtx out)\n+{\n+  return (ira_bad_reload_regno_1 (regno, in)\n+\t  || ira_bad_reload_regno_1 (regno, out));\n+}\n+\n /* Function specific hard registers that can not be used for the\n    register allocation.  */\n HARD_REG_SET ira_no_alloc_regs;"}, {"sha": "8c9734b8be3cb03d35164e5951c6d4d4c11aa401", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=0896cc668adddc0be62f009679e1e7236ecec0e6", "patch": "@@ -86,4 +86,5 @@ extern bool ira_reassign_pseudos (int *, int, HARD_REG_SET, HARD_REG_SET *,\n extern rtx ira_reuse_stack_slot (int, unsigned int, unsigned int);\n extern void ira_mark_new_stack_slot (rtx, int, unsigned int);\n extern bool ira_better_spill_reload_regno_p (int *, int *, rtx, rtx, rtx);\n+extern bool ira_bad_reload_regno (int, rtx, rtx);\n "}, {"sha": "f385fbb757aaaa4333356e65be37628d98023d41", "filename": "gcc/reload1.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0896cc668adddc0be62f009679e1e7236ecec0e6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0896cc668adddc0be62f009679e1e7236ecec0e6", "patch": "@@ -5793,15 +5793,17 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n      take any reg in the right class and not in use.\n      If we want a consecutive group, here is where we look for it.\n \n-     We use two passes so we can first look for reload regs to\n+     We use three passes so we can first look for reload regs to\n      reuse, which are already in use for other reloads in this insn,\n-     and only then use additional registers.\n+     and only then use additional registers which are not \"bad\", then\n+     finally any register.\n+\n      I think that maximizing reuse is needed to make sure we don't\n      run out of reload regs.  Suppose we have three reloads, and\n      reloads A and B can share regs.  These need two regs.\n      Suppose A and B are given different regs.\n      That leaves none for C.  */\n-  for (pass = 0; pass < 2; pass++)\n+  for (pass = 0; pass < 3; pass++)\n     {\n       /* I is the index in spill_regs.\n \t We advance it round-robin between insns to use all spill regs\n@@ -5841,6 +5843,13 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t\t\t\t\t      regnum))))\n \t    {\n \t      int nr = hard_regno_nregs[regnum][rld[r].mode];\n+\n+\t      /* During the second pass we want to avoid reload registers\n+\t\t which are \"bad\" for this reload.  */\n+\t      if (pass == 1\n+\t\t  && ira_bad_reload_regno (regnum, rld[r].in, rld[r].out))\n+\t\tcontinue;\n+\n \t      /* Avoid the problem where spilling a GENERAL_OR_FP_REG\n \t\t (on 68000) got us two FP regs.  If NR is 1,\n \t\t we would reject both of them.  */\n@@ -5871,7 +5880,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t    }\n \t}\n \n-      /* If we found something on pass 1, omit pass 2.  */\n+      /* If we found something on the current pass, omit later passes.  */\n       if (count < n_spills)\n \tbreak;\n     }"}]}