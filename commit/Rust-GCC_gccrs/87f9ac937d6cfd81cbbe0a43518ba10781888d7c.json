{"sha": "87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdmOWFjOTM3ZDZjZmQ4MWNiYmUwYTQzNTE4YmExMDc4MTg4OGQ3Yw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-08T19:43:03Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-09T01:12:08Z"}, "message": "Virtualize fur_source and turn it into a proper API.\n\nNo more accessing the local info.  Also add fur_source/fold_stmt where ranges\nare provided via being specified, or a vector to replace gimple_fold_range.\n\n\t* gimple-range-gori.cc (gori_compute::outgoing_edge_range_p): Use a\n\tfur_stmt source record.\n\t* gimple-range.cc (fur_source::get_operand): Generic range query.\n\t(fur_source::get_phi_operand): New.\n\t(fur_source::register_dependency): New.\n\t(fur_source::query): New.\n\t(class fur_edge): New.  Edge source for operands.\n\t(fur_edge::fur_edge): New.\n\t(fur_edge::get_operand): New.\n\t(fur_edge::get_phi_operand): New.\n\t(fur_edge::query): New.\n\t(fur_stmt::fur_stmt): New.\n\t(fur_stmt::get_operand): New.\n\t(fur_stmt::get_phi_operand): New.\n\t(fur_stmt::query): New.\n\t(class fur_depend): New.  Statement source and process dependencies.\n\t(fur_depend::fur_depend): New.\n\t(fur_depend::register_dependency): New.\n\t(class fur_list): New.  List source for operands.\n\t(fur_list::fur_list): New.\n\t(fur_list::get_operand): New.\n\t(fur_list::get_phi_operand): New.\n\t(fold_range): New.  Instantiate appropriate fur_source class and fold.\n\t(fold_using_range::range_of_range_op): Use new API.\n\t(fold_using_range::range_of_address): Ditto.\n\t(fold_using_range::range_of_phi): Ditto.\n\t(imple_ranger::fold_range_internal): Use fur_depend class.\n\t(fold_using_range::range_of_ssa_name_with_loop_info): Use new API.\n\t* gimple-range.h (class fur_source): Now a base class.\n\t(class fur_stmt): New.\n\t(fold_range): New prototypes.\n\t(fur_source::fur_source): Delete.", "tree": {"sha": "c23bc3c72bedad47b16ec475740ce1de5edb1629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23bc3c72bedad47b16ec475740ce1de5edb1629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/comments", "author": null, "committer": null, "parents": [{"sha": "087253b9951766cbd93286b804ebb1ab59197aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/087253b9951766cbd93286b804ebb1ab59197aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/087253b9951766cbd93286b804ebb1ab59197aa8"}], "stats": {"total": 417, "additions": 315, "deletions": 102}, "files": [{"sha": "09dcd694319b81c6077582b7e15b0af8526858ea", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "patch": "@@ -1008,7 +1008,7 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n   if (!stmt)\n     return false;\n \n-  fur_source src (&q, NULL, e, stmt);\n+  fur_stmt src (stmt, &q);\n \n   // If NAME can be calculated on the edge, use that.\n   if (is_export_p (name, e->src))"}, {"sha": "b534b8e0a2cea679804332fb7e2c3eaf3bedb5b7", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 284, "deletions": 30, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "patch": "@@ -49,19 +49,284 @@ along with GCC; see the file COPYING3.  If not see\n \n // Evaluate expression EXPR using the source information the class was\n // instantiated with.  Place the result in R, and return TRUE.  If a range\n-// cannot be calcluated, return FALSE.\n+// cannot be calculated, return FALSE.\n \n bool\n fur_source::get_operand (irange &r, tree expr)\n {\n-  // First look for a stmt.\n-  if (m_stmt)\n-    return m_query->range_of_expr (r, expr, m_stmt);\n+  return get_range_query (cfun)->range_of_expr (r, expr);\n+}\n+\n+// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n+// range_query to get the range on the edge.\n+\n+bool\n+fur_source::get_phi_operand (irange &r, tree expr, edge e)\n+{\n+  return get_range_query (cfun)->range_on_edge (r, e, expr);\n+}\n+\n+// Default is to not register any dependencies from fold_using_range.\n+\n+void\n+fur_source::register_dependency (tree lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t tree rhs ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+// Default object is the current range query.\n+\n+range_query *\n+fur_source::query ()\n+{\n+  return get_range_query (cfun);\n+}\n+\n+// This version of fur_source will pick a range up off an edge.\n \n-  // Finally must be on an edge.\n+class fur_edge : public fur_source\n+{\n+public:\n+  fur_edge (edge e, range_query *q = NULL);\n+  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n+  virtual range_query *query () OVERRIDE;\n+private:\n+  range_query *m_query;\n+  edge m_edge;\n+};\n+\n+// Instantiate an edge based fur_source.\n+\n+inline\n+fur_edge::fur_edge (edge e, range_query *q)\n+{\n+  m_edge = e;\n+  if (q)\n+    m_query = q;\n+  else\n+    m_query = get_range_query (cfun);\n+}\n+\n+// Get the value of EXPR on edge m_edge.\n+\n+bool\n+fur_edge::get_operand (irange &r, tree expr)\n+{\n   return m_query->range_on_edge (r, m_edge, expr);\n }\n \n+// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n+// range_query to get the range on the edge.\n+\n+bool\n+fur_edge::get_phi_operand (irange &r, tree expr, edge e)\n+{\n+  // edge to edge recalculations not supoprted yet, until we sort it out.\n+  gcc_checking_assert (e == m_edge);\n+  return m_query->range_on_edge (r, e, expr);\n+}\n+\n+// Return the current range_query object.\n+\n+range_query *\n+fur_edge::query ()\n+{\n+  return m_query;\n+}\n+\n+\n+// Instantiate a stmt based fur_source.\n+\n+\n+fur_stmt::fur_stmt (gimple *s, range_query *q)\n+{\n+  m_stmt= s;\n+  if (q)\n+    m_query = q;\n+  else\n+    m_query = get_global_range_query ();\n+}\n+\n+// Retirenve range of EXPR as it occurs as a use on stmt M_STMT.\n+\n+bool\n+fur_stmt::get_operand (irange &r, tree expr)\n+{\n+  return m_query->range_of_expr (r, expr, m_stmt);\n+}\n+\n+// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n+// range_query to get the range on the edge.\n+\n+bool\n+fur_stmt::get_phi_operand (irange &r, tree expr, edge e)\n+{\n+  // Pick up the range of expr from edge E.\n+  fur_edge e_src (e, m_query);\n+  return e_src.get_operand (r, expr);\n+}\n+\n+// Return the current range_query object.\n+\n+range_query *\n+fur_stmt::query ()\n+{\n+  return m_query;\n+}\n+\n+// This version of fur_source will pick a range from a stmt, and register\n+// also dependencies via a gori_compute object.  This is mostly an internal API.\n+\n+class fur_depend : public fur_stmt\n+{\n+public:\n+  fur_depend (gimple *s, gori_compute *gori, range_query *q = NULL);\n+  virtual void register_dependency (tree lhs, tree rhs) OVERRIDE;\n+private:\n+  gori_compute *m_gori;\n+};\n+\n+// Instantiate a stmt based fur_source witrh a GORI object\n+inline\n+fur_depend::fur_depend (gimple *s, gori_compute *gori, range_query *q)\n+\t\t\t\t\t\t\t      : fur_stmt (s, q)\n+{\n+  gcc_checking_assert (gori);\n+  m_gori = gori;\n+}\n+\n+\n+// find and add any dependnecy between LHS and RHS\n+\n+void\n+fur_depend::register_dependency (tree lhs, tree rhs)\n+{\n+  m_gori->register_dependency (lhs, rhs);\n+}\n+\n+\n+// This version of fur_source will pick a range up from a list of ranges\n+// supplied by the caller.\n+\n+class fur_list : public fur_source\n+{\n+public:\n+  fur_list (irange &r1);\n+  fur_list (irange &r1, irange &r2);\n+  fur_list (unsigned num, irange *list);\n+  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n+private:\n+  int_range_max m_local[2];\n+  irange *m_list;\n+  unsigned m_index;\n+  unsigned m_limit;\n+};\n+\n+// One range supplied for unary operations.\n+\n+fur_list::fur_list (irange &r1)\n+{\n+  m_list = m_local;\n+  m_index = 0;\n+  m_limit = 1;\n+  m_local[0] = r1;\n+}\n+\n+// Two ranges supplied for binary operations.\n+\n+fur_list::fur_list (irange &r1, irange &r2)\n+{\n+  m_list = m_local;\n+  m_index = 0;\n+  m_limit = 2;\n+  m_local[0] = r1;\n+  m_local[0] = r2;\n+}\n+\n+// Arbitrary number of ranges in a vector.\n+\n+fur_list::fur_list (unsigned num, irange *list)\n+{\n+  m_list = list;\n+  m_index = 0;\n+  m_limit = num;\n+}\n+\n+// Get the next operand from the vector, ensure types are compatible,\n+\n+bool\n+fur_list::get_operand (irange &r, tree expr)\n+{\n+  if (m_index >= m_limit)\n+    return get_range_query (cfun)->range_of_expr (r, expr);\n+  r = m_list[m_index++];\n+  gcc_checking_assert (range_compatible_p (TREE_TYPE (expr), r.type ()));\n+  return true;\n+}\n+\n+// This will simply pick the next operand from the vector.\n+bool\n+fur_list::get_phi_operand (irange &r, tree expr, edge e ATTRIBUTE_UNUSED)\n+{\n+  return get_operand (r, expr);\n+}\n+\n+// Fold stmt S into range R using R1 as the first operand.\n+\n+bool\n+fold_range (irange &r, gimple *s, irange &r1)\n+{\n+  fold_using_range f;\n+  fur_list src (r1);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Fold stmt S into range R using R1  and R2 as the first two operands.\n+\n+bool\n+fold_range (irange &r, gimple *s, irange &r1, irange &r2)\n+{\n+  fold_using_range f;\n+  fur_list src (r1, r2);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+\n+// Fold stmt S into range R using NUM_ELEMENTS from VECTOR as the initial\n+// operands encountered.\n+\n+bool\n+fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector)\n+{\n+  fold_using_range f;\n+  fur_list src (num_elements, vector);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+\n+// Fold stmt S into range R using range query Q.\n+\n+bool\n+fold_range (irange &r, gimple *s, range_query *q)\n+{\n+  fold_using_range f;\n+  fur_stmt src (s, q);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n+\n+bool\n+fold_range (irange &r, gimple *s, edge on_edge, range_query *q)\n+{\n+  fold_using_range f;\n+  fur_edge src (on_edge, q);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// -------------------------------------------------------------------------\n \n // Adjust the range for a pointer difference where the operands came\n // from a memchr.\n@@ -375,17 +640,17 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t  // Fold range, and register any dependency if available.\n \t  int_range<2> r2 (type);\n \t  handler->fold_range (r, type, range1, r2);\n-\t  if (lhs && src.m_gori)\n-\t    src.m_gori->register_dependency (lhs, op1);\n+\t  if (lhs)\n+\t    src.register_dependency (lhs, op1);\n \t}\n       else if (src.get_operand (range2, op2))\n \t{\n \t  // Fold range, and register any dependency if available.\n \t  handler->fold_range (r, type, range1, range2);\n-\t  if (lhs && src.m_gori)\n+\t  if (lhs)\n \t    {\n-\t      src.m_gori->register_dependency (lhs, op1);\n-\t      src.m_gori->register_dependency (lhs, op2);\n+\t      src.register_dependency (lhs, op1);\n+\t      src.register_dependency (lhs, op2);\n \t    }\n \t}\n       else\n@@ -425,8 +690,8 @@ fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n     {\n       tree ssa = TREE_OPERAND (base, 0);\n       tree lhs = gimple_get_lhs (stmt);\n-      if (src.m_gori && lhs && gimple_range_ssa_p (ssa))\n-\tsrc.m_gori->register_dependency (lhs, ssa);\n+      if (lhs && gimple_range_ssa_p (ssa))\n+\tsrc.register_dependency (lhs, ssa);\n       gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n       src.get_operand (r, ssa);\n       range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n@@ -503,19 +768,12 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n       edge e = gimple_phi_arg_edge (phi, x);\n \n       // Register potential dependencies for stale value tracking.\n-      if (src.m_gori && gimple_range_ssa_p (arg))\n-\tsrc.m_gori->register_dependency (phi_def, arg);\n+      if (gimple_range_ssa_p (arg))\n+\tsrc.register_dependency (phi_def, arg);\n \n       // Get the range of the argument on its edge.\n-      fur_source e_src (src.m_query, e);\n-      e_src.get_operand (arg_range, arg);\n+      src.get_phi_operand (arg_range, arg, e);\n       // If we're recomputing the argument elsewhere, try to refine it.\n-      if (src.m_stmt != phi)\n-\t{\n-\t  int_range_max tmp;\n-\t  e_src.get_operand (tmp, arg);\n-\t  arg_range.intersect (tmp);\n-\t}\n       r.union_ (arg_range);\n       // Once the value reaches varying, stop looking.\n       if (r.varying_p ())\n@@ -1012,7 +1270,7 @@ bool\n gimple_ranger::fold_range_internal (irange &r, gimple *s, tree name)\n {\n   fold_using_range f;\n-  fur_source src (this, &(gori ()), NULL, s);\n+  fur_depend src (s, &(gori ()), this);\n   return f.fold_stmt (r, s, src, name);\n }\n \n@@ -1191,22 +1449,18 @@ fold_using_range::range_of_ssa_name_with_loop_info (irange &r, tree name,\n {\n   gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n   tree min, max, type = TREE_TYPE (name);\n-  if (bounds_of_var_in_loop (&min, &max, src.m_query, l, phi, name))\n+  if (bounds_of_var_in_loop (&min, &max, src.query (), l, phi, name))\n     {\n       if (TREE_CODE (min) != INTEGER_CST)\n \t{\n-\t  if (src.m_query\n-\t      && src.m_query->range_of_expr (r, min, phi)\n-\t      && !r.undefined_p ())\n+\t  if (src.query ()->range_of_expr (r, min, phi) && !r.undefined_p ())\n \t    min = wide_int_to_tree (type, r.lower_bound ());\n \t  else\n \t    min = vrp_val_min (type);\n \t}\n       if (TREE_CODE (max) != INTEGER_CST)\n \t{\n-\t  if (src.m_query\n-\t      && src.m_query->range_of_expr (r, max, phi)\n-\t      && !r.undefined_p ())\n+\t  if (src.query ()->range_of_expr (r, max, phi) && !r.undefined_p ())\n \t    max = wide_int_to_tree (type, r.upper_bound ());\n \t  else\n \t    max = vrp_val_max (type);"}, {"sha": "9ac779a720c5a82092060cd496e23954a15aff89", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 30, "deletions": 71, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f9ac937d6cfd81cbbe0a43518ba10781888d7c/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=87f9ac937d6cfd81cbbe0a43518ba10781888d7c", "patch": "@@ -73,28 +73,45 @@ class gimple_ranger : public range_query\n   ranger_cache m_cache;\n };\n \n-// Source of an operand for fold_using_range.\n-// It can specify a stmt or and edge, or thru an internal API which uses\n-// the ranger cache.\n-// Its primary function is to retreive an operand from the source via a\n-// call thru the range_query object.\n+// Source of all operands for fold_using_range and gori_compute.\n+// It abstracts out the source of an operand so it can come from a stmt or\n+// and edge or anywhere a derived classof fur_source wants.\n \n class fur_source\n {\n-  friend class fold_using_range;\n public:\n-  inline fur_source (range_query *q, edge e);\n-  inline fur_source (range_query *q, gimple *s);\n-  inline fur_source (range_query *q, gori_compute *g, edge e, gimple *s);\n-  bool get_operand (irange &r, tree expr);\n-protected:\n-  gori_compute *m_gori;\n+  virtual bool get_operand (irange &r, tree expr);\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e);\n+  virtual void register_dependency (tree lhs, tree rhs);\n+  virtual range_query *query ();\n+};\n+\n+// fur_stmt is the specification for drawing an operand from range_query Q\n+// via a range_of_Expr call on stmt S.\n+\n+class fur_stmt : public fur_source\n+{\n+public:\n+  fur_stmt (gimple *s, range_query *q = NULL);\n+  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n+  virtual range_query *query () OVERRIDE;\n+private:\n   range_query *m_query;\n-  edge m_edge;\n   gimple *m_stmt;\n };\n \n \n+// Fold stmt S into range R using range query Q.\n+bool fold_range (irange &r, gimple *s, range_query *q = NULL);\n+// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n+bool fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL);\n+// These routines allow you to specify the operands to use when folding.\n+// Any excess queries will be drawn from the current range_query.\n+bool fold_range (irange &r, gimple *s, irange &r1);\n+bool fold_range (irange &r, gimple *s, irange &r1, irange &r2);\n+bool fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector);\n+\n // This class uses ranges to fold a gimple statement producinf a range for\n // the LHS.  The source of all operands is supplied via the fur_source class\n // which provides a range_query as well as a source location and any other\n@@ -119,64 +136,6 @@ class fold_using_range\n };\n \n \n-// Create a source for a query on an edge.\n-\n-inline\n-fur_source::fur_source (range_query *q, edge e)\n-{\n-  m_query = q;\n-  m_gori = NULL;\n-  m_edge = e;\n-  m_stmt = NULL;\n-}\n-\n-// Create a source for a query at a statement.\n-\n-inline\n-fur_source::fur_source (range_query *q, gimple *s)\n-{\n-  m_query = q;\n-  m_gori = NULL;\n-  m_edge = NULL;\n-  m_stmt = s;\n-}\n-\n-// Create a source for Ranger.  THis can recalculate from a different location\n-// and can also set the dependency information as appropriate when invoked.\n-\n-inline\n-fur_source::fur_source (range_query *q, gori_compute *g, edge e, gimple *s)\n-{\n-  m_query = q;\n-  m_gori = g;\n-  m_edge = e;\n-  m_stmt = s;\n-}\n-\n-// Fold stmt S into range R using range query Q.\n-\n-inline bool\n-fold_range (irange &r, gimple *s, range_query *q = NULL)\n-{\n-  fold_using_range f;\n-  if (q == NULL)\n-    q = get_global_range_query ();\n-  fur_source src (q, s);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n-// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n-\n-inline bool\n-fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL)\n-{\n-  fold_using_range f;\n-  if (q == NULL)\n-    q = get_global_range_query ();\n-  fur_source src (q, on_edge);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n // These routines provide a GIMPLE interface to the range-ops code.\n extern tree gimple_range_operand1 (const gimple *s);\n extern tree gimple_range_operand2 (const gimple *s);"}]}