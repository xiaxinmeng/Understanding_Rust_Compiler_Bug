{"sha": "ed5bb68db315b7192f63866899378250810bdad8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1YmI2OGRiMzE1YjcxOTJmNjM4NjY4OTkzNzgyNTA4MTBiZGFkOA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-11T21:48:46Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-11T21:48:46Z"}, "message": "loop.h (LOOP_IVS): New macro.\n\n\t* loop.h (LOOP_IVS): New macro.\n\t(REG_IV_TYPE, REG_IV_INFO): Add ivs argument.\n\t(struct loop_ivs): New.\n\t(struct loop_info): Add ivs field.\n\t(reg_iv_type, reg_iv_info): Delete prototype.\n\t(reg_biv_class, loop_iv_list): Likewise.\n\t* loop.c (record_biv, find_life_end): Pass loop argument.\n\t(reg_iv_type): Remove global array and use\n\tfield in loop_regs structure within loop_ivs structure.\n\t(reg_iv_info, reg_biv_class, loop_iv_list): Likewise.\n\t(first_increment_giv, last_increment_giv): Use entry in\n\tloop_ivs structure.\n\t(record_initial): Pass ivs pointer.\n\t* unroll.c (copy_loop_body, remap_split_bivs): Add loop argument.\n\nFrom-SVN: r36336", "tree": {"sha": "a526b1975d0a61527c9c7397add153dd0db913f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a526b1975d0a61527c9c7397add153dd0db913f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed5bb68db315b7192f63866899378250810bdad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5bb68db315b7192f63866899378250810bdad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed5bb68db315b7192f63866899378250810bdad8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5bb68db315b7192f63866899378250810bdad8/comments", "author": null, "committer": null, "parents": [{"sha": "1ecd860b2879a4529b01208eab3484be9383c7d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ecd860b2879a4529b01208eab3484be9383c7d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ecd860b2879a4529b01208eab3484be9383c7d4"}], "stats": {"total": 388, "additions": 217, "deletions": 171}, "files": [{"sha": "a55af5f375123f3d0b319626cb0b4edb6c24b75d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5bb68db315b7192f63866899378250810bdad8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5bb68db315b7192f63866899378250810bdad8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed5bb68db315b7192f63866899378250810bdad8", "patch": "@@ -1,3 +1,20 @@\n+2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* loop.h (LOOP_IVS): New macro.\n+\t(REG_IV_TYPE, REG_IV_INFO): Add ivs argument.\n+\t(struct loop_ivs): New.\n+\t(struct loop_info): Add ivs field.\n+\t(reg_iv_type, reg_iv_info): Delete prototype.\n+\t(reg_biv_class, loop_iv_list): Likewise.\n+\t* loop.c (record_biv, find_life_end): Pass loop argument.\n+\t(reg_iv_type): Remove global array and use\n+\tfield in loop_regs structure within loop_ivs structure.\n+\t(reg_iv_info, reg_biv_class, loop_iv_list): Likewise.\n+\t(first_increment_giv, last_increment_giv): Use entry in\n+\tloop_ivs structure.\n+\t(record_initial): Pass ivs pointer.\n+\t* unroll.c (copy_loop_body, remap_split_bivs): Add loop argument.\n+\n 2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n \n \t* loop.h (LOOP_REGS): New macro."}, {"sha": "d266ab0c91d991ee32d069041ef45cbba8b2d16a", "filename": "gcc/loop.c", "status": "modified", "additions": 122, "deletions": 128, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5bb68db315b7192f63866899378250810bdad8/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5bb68db315b7192f63866899378250810bdad8/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ed5bb68db315b7192f63866899378250810bdad8", "patch": "@@ -78,6 +78,9 @@ static int max_luid;\n \n static int max_loop_num;\n \n+\n+\n+\n /* Bound on pseudo register number before loop optimization.\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n unsigned int max_reg_before_loop;\n@@ -190,13 +193,14 @@ static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *,\n \t\t\t\t\t struct loop_regs *));\n static void add_label_notes PARAMS ((rtx, rtx));\n static void move_movables PARAMS ((struct loop *loop, struct movables *,\n-\t\t\t\t   int, int, int));\n+\t\t\t\t   int, int));\n static int count_nonfixed_reads PARAMS ((const struct loop *, rtx));\n static void strength_reduce PARAMS ((struct loop *, int, int));\n static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n static void find_mem_givs PARAMS ((const struct loop *, rtx, rtx, int, int));\n-static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *,\n+static void record_biv PARAMS ((struct loop *, struct induction *,\n+\t\t\t\trtx, rtx, rtx, rtx, rtx *,\n \t\t\t\tint, int));\n static void check_final_value PARAMS ((const struct loop *,\n \t\t\t\t       struct induction *));\n@@ -220,7 +224,8 @@ static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n static void combine_givs PARAMS ((struct loop_regs *, struct iv_class *));\n struct recombine_givs_stats;\n-static int find_life_end PARAMS ((rtx, struct recombine_givs_stats *,\n+static int find_life_end PARAMS ((const struct loop *, rtx, \n+\t\t\t\t  struct recombine_givs_stats *,\n \t\t\t\t  rtx, rtx));\n static void recombine_givs PARAMS ((const struct loop *, struct iv_class *,\n \t\t\t\t    int));\n@@ -1037,7 +1042,7 @@ scan_loop (loop, flags)\n      optimizing for code size.  */\n \n   if (! optimize_size)\n-    move_movables (loop, movables, threshold, insn_count, nregs);\n+    move_movables (loop, movables, threshold, insn_count);\n \n   /* Now candidates that still are negative are those not moved.\n      Change regs->set_in_loop to indicate that those are not actually\n@@ -1349,9 +1354,8 @@ combine_movables (movables, regs)\n      struct movables *movables;\n      struct loop_regs *regs;\n {\n-  int nregs = regs->num;\n   register struct movable *m;\n-  char *matched_regs = (char *) xmalloc (nregs);\n+  char *matched_regs = (char *) xmalloc (regs->num);\n   enum machine_mode mode;\n \n   /* Regs that are set more than once are not allowed to match\n@@ -1365,7 +1369,7 @@ combine_movables (movables, regs)\n \tregister struct movable *m1;\n \tint regno = m->regno;\n \n-\tbzero (matched_regs, nregs);\n+\tbzero (matched_regs, regs->num);\n \tmatched_regs[regno] = 1;\n \n \t/* We want later insns to match the first one.  Don't make the first\n@@ -1497,7 +1501,7 @@ static int\n rtx_equal_for_loop_p (x, y, movables, regs)\n      rtx x, y;\n      struct movables *movables;\n-     struct loop_regs * regs;\n+     struct loop_regs *regs;\n {\n   register int i;\n   register int j;\n@@ -1582,8 +1586,8 @@ rtx_equal_for_loop_p (x, y, movables, regs)\n \t  break;\n \n \tcase 'e':\n-\t  if (rtx_equal_for_loop_p (XEXP (x, i), XEXP (y, i), \n-\t\t\t\t    movables, regs) == 0)\n+\t  if (rtx_equal_for_loop_p (XEXP (x, i), XEXP (y, i), movables, regs)\n+\t      == 0)\n \t    return 0;\n \t  break;\n \n@@ -1651,14 +1655,14 @@ add_label_notes (x, insns)\n    other throughout.  */\n \n static void\n-move_movables (loop, movables, threshold, insn_count, nregs)\n+move_movables (loop, movables, threshold, insn_count)\n      struct loop *loop;\n      struct movables *movables;\n      int threshold;\n      int insn_count;\n-     int nregs;\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n+  int nregs = regs->num;\n   rtx new_start = 0;\n   register struct movable *m;\n   register rtx p;\n@@ -3528,34 +3532,6 @@ loop_reg_used_before_p (loop, set, insn)\n /* Bivs are recognized by `basic_induction_var';\n    Givs by `general_induction_var'.  */\n \n-/* Indexed by register number, indicates whether or not register is an\n-   induction variable, and if so what type.  */\n-\n-varray_type reg_iv_type;\n-\n-/* Indexed by register number, contains pointer to `struct induction'\n-   if register is an induction variable.  This holds general info for\n-   all induction variables.  */\n-\n-varray_type reg_iv_info;\n-\n-/* Indexed by register number, contains pointer to `struct iv_class'\n-   if register is a basic induction variable.  This holds info describing\n-   the class (a related group) of induction variables that the biv belongs\n-   to.  */\n-\n-struct iv_class **reg_biv_class;\n-\n-/* The head of a list which links together (via the next field)\n-   every iv class for the current loop.  */\n-\n-struct iv_class *loop_iv_list;\n-\n-/* Givs made from biv increments are always splittable for loop unrolling.\n-   Since there is no regscan info for them, we have to keep track of them\n-   separately.  */\n-unsigned int first_increment_giv, last_increment_giv;\n-\n /* Communication with routines called via `note_stores'.  */\n \n static rtx note_insn;\n@@ -3761,8 +3737,9 @@ strength_reduce (loop, insn_count, flags)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx p;\n-  /* Temporary list pointers for traversing loop_iv_list.  */\n+  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n   struct iv_class *bl, **backbl;\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n@@ -3783,12 +3760,12 @@ strength_reduce (loop, insn_count, flags)\n   rtx loop_scan_start = loop->scan_start;\n   rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n-  VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n-  VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n-  reg_biv_class = (struct iv_class **)\n+  VARRAY_INT_INIT (ivs->reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n+  VARRAY_GENERIC_PTR_INIT (ivs->reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n+  ivs->reg_biv_class = (struct iv_class **)\n     xcalloc (max_reg_before_loop, sizeof (struct iv_class *));\n \n-  loop_iv_list = 0;\n+  ivs->loop_iv_list = 0;\n   addr_placeholder = gen_reg_rtx (Pmode);\n \n   /* Save insn immediately after the loop_end.  Insns inserted after loop_end\n@@ -3805,11 +3782,11 @@ strength_reduce (loop, insn_count, flags)\n \n   for_each_insn_in_loop (loop, check_insn_for_bivs);\n \n-  /* Scan loop_iv_list to remove all regs that proved not to be bivs.\n+  /* Scan ivs->loop_iv_list to remove all regs that proved not to be bivs.\n      Make a sanity check against regs->n_times_set.  */\n-  for (backbl = &loop_iv_list, bl = *backbl; bl; bl = bl->next)\n+  for (backbl = &ivs->loop_iv_list, bl = *backbl; bl; bl = bl->next)\n     {\n-      if (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n+      if (REG_IV_TYPE (ivs, bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n \t  || VARRAY_INT (regs->n_times_set, bl->regno) != bl->biv_count\n@@ -3820,12 +3797,12 @@ strength_reduce (loop, insn_count, flags)\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Reg %d: biv discarded, %s\\n\",\n \t\t     bl->regno,\n-\t\t     (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n+\t\t     (REG_IV_TYPE (ivs, bl->regno) != BASIC_INDUCT\n \t\t      ? \"not induction variable\"\n \t\t      : (! bl->incremented ? \"never incremented\"\n \t\t\t : \"count error\")));\n \n-\t  REG_IV_TYPE (bl->regno) = NOT_BASIC_INDUCT;\n+\t  REG_IV_TYPE (ivs, bl->regno) = NOT_BASIC_INDUCT;\n \t  *backbl = bl->next;\n \t}\n       else\n@@ -3838,7 +3815,7 @@ strength_reduce (loop, insn_count, flags)\n     }\n \n   /* Exit if there are no bivs.  */\n-  if (! loop_iv_list)\n+  if (! ivs->loop_iv_list)\n     {\n       /* Can still unroll the loop anyways, but indicate that there is no\n \t strength reduction info available.  */\n@@ -3860,7 +3837,7 @@ strength_reduce (loop, insn_count, flags)\n \tcall_seen = 1;\n \n       if (INSN_P (p))\n-\tnote_stores (PATTERN (p), record_initial, NULL);\n+\tnote_stores (PATTERN (p), record_initial, ivs);\n \n       /* Record any test of a biv that branches around the loop if no store\n \t between it and the start of loop.  We only care about tests with\n@@ -3871,7 +3848,7 @@ strength_reduce (loop, insn_count, flags)\n \t  && (test = get_condition_for_loop (loop, p)) != 0\n \t  && GET_CODE (XEXP (test, 0)) == REG\n \t  && REGNO (XEXP (test, 0)) < max_reg_before_loop\n-\t  && (bl = reg_biv_class[REGNO (XEXP (test, 0))]) != 0\n+\t  && (bl = ivs->reg_biv_class[REGNO (XEXP (test, 0))]) != 0\n \t  && valid_initial_value_p (XEXP (test, 1), p, call_seen, loop_start)\n \t  && bl->init_insn == 0)\n \t{\n@@ -3890,7 +3867,7 @@ strength_reduce (loop, insn_count, flags)\n   /* Look at the each biv and see if we can say anything better about its\n      initial value from any initializing insns set up above.  (This is done\n      in two passes to avoid missing SETs in a PARALLEL.)  */\n-  for (backbl = &loop_iv_list; (bl = *backbl); backbl = &bl->next)\n+  for (backbl = &ivs->loop_iv_list; (bl = *backbl); backbl = &bl->next)\n     {\n       rtx src;\n       rtx note;\n@@ -3953,7 +3930,7 @@ strength_reduce (loop, insn_count, flags)\n \t    {\n \t      unsigned int regno = REGNO (XEXP (src, 0));\n \n-\t      for (bl2 = loop_iv_list; bl2; bl2 = bl2->next)\n+\t      for (bl2 = ivs->loop_iv_list; bl2; bl2 = bl2->next)\n \t\tif (bl2->regno == regno)\n \t\t  break;\n \t    }\n@@ -3989,8 +3966,8 @@ strength_reduce (loop, insn_count, flags)\n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream, \"is giv of biv %d\\n\", bl2->regno);\n \t      /* Let this giv be discovered by the generic code.  */\n-\t      REG_IV_TYPE (bl->regno) = UNKNOWN_INDUCT;\n-\t      reg_biv_class[bl->regno] = (struct iv_class *) NULL_PTR;\n+\t      REG_IV_TYPE (ivs, bl->regno) = UNKNOWN_INDUCT;\n+\t      ivs->reg_biv_class[bl->regno] = (struct iv_class *) NULL_PTR;\n \t      /* We can get better optimization if we can move the giv setting\n \t\t before the first giv use.  */\n \t      if (dominator\n@@ -4054,22 +4031,22 @@ strength_reduce (loop, insn_count, flags)\n \n   /* Get an upper bound for the number of registers\n      we might have after all bivs have been processed.  */\n-  first_increment_giv = max_reg_num ();\n-  for (n_extra_increment = 0, bl = loop_iv_list; bl; bl = bl->next)\n+  ivs->first_increment_giv = max_reg_num ();\n+  for (n_extra_increment = 0, bl = ivs->loop_iv_list; bl; bl = bl->next)\n     n_extra_increment += bl->biv_count - 1;\n \n   /* If the loop contains volatile memory references do not allow any\n      replacements to take place, since this could loose the volatile\n      markers.  */\n   if (n_extra_increment  && ! loop_info->has_volatile)\n     {\n-      unsigned int nregs = first_increment_giv + n_extra_increment;\n+      unsigned int nregs = ivs->first_increment_giv + n_extra_increment;\n \n-      /* Reallocate reg_iv_type and reg_iv_info.  */\n-      VARRAY_GROW (reg_iv_type, nregs);\n-      VARRAY_GROW (reg_iv_info, nregs);\n+      /* Reallocate ivs->reg_iv_type and ivs->reg_iv_info.  */\n+      VARRAY_GROW (ivs->reg_iv_type, nregs);\n+      VARRAY_GROW (ivs->reg_iv_info, nregs);\n \n-      for (bl = loop_iv_list; bl; bl = bl->next)\n+      for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n \t{\n \t  struct induction **vp, *v, *next;\n \t  int biv_dead_after_loop = 0;\n@@ -4135,10 +4112,11 @@ strength_reduce (loop, insn_count, flags)\n \t      old_reg = v->dest_reg;\n \t      dest_reg = gen_reg_rtx (v->mode);\n \n-\t      /* Unlike reg_iv_type / reg_iv_info, the other three arrays\n-\t\t have been allocated with some slop space, so we may not\n-\t\t actually need to reallocate them.  If we do, the following\n-\t\t if statement will be executed just once in this loop.  */\n+\t      /* Unlike ivs->reg_iv_type / ivs->reg_iv_info, the other\n+\t\t three arrays have been allocated with some slop\n+\t\t space, so we may not actually need to reallocate\n+\t\t them.  If we do, the following if statement will be\n+\t\t executed just once in this loop.  */\n \t      if ((unsigned) max_reg_num () > regs->n_times_set->num_elements)\n \t\t{\n \t\t  /* Grow all the remaining arrays.  */\n@@ -4227,8 +4205,8 @@ strength_reduce (loop, insn_count, flags)\n \t      VARRAY_INT (regs->n_times_set, new_regno) = 1;\n \t      VARRAY_CHAR (regs->may_not_optimize, new_regno) = 0;\n \n-\t      REG_IV_TYPE (new_regno) = GENERAL_INDUCT;\n-\t      REG_IV_INFO (new_regno) = v;\n+\t      REG_IV_TYPE (ivs, new_regno) = GENERAL_INDUCT;\n+\t      REG_IV_INFO (ivs, new_regno) = v;\n \n \t      /* If next_insn has a REG_EQUAL note that mentiones OLD_REG,\n \t\t it must be replaced.  */\n@@ -4286,7 +4264,7 @@ strength_reduce (loop, insn_count, flags)\n \t    }\n \t}\n     }\n-  last_increment_giv = max_reg_num () - 1;\n+  ivs->last_increment_giv = max_reg_num () - 1;\n \n   /* Search the loop for general induction variables.  */\n \n@@ -4304,7 +4282,7 @@ strength_reduce (loop, insn_count, flags)\n      can be calculated.  This must be done after loop_iterations is called,\n      so that final_giv_value will work correctly.  */\n \n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     {\n       struct induction *v;\n \n@@ -4320,14 +4298,14 @@ strength_reduce (loop, insn_count, flags)\n \n   /* Create reg_map to hold substitutions for replaceable giv regs.\n      Some givs might have been made from biv increments, so look at\n-     reg_iv_type for a suitable size.  */\n-  reg_map_size = reg_iv_type->num_elements;\n+     ivs->reg_iv_type for a suitable size.  */\n+  reg_map_size = ivs->reg_iv_type->num_elements;\n   reg_map = (rtx *) xcalloc (reg_map_size, sizeof (rtx));\n \n   /* Examine each iv class for feasibility of strength reduction/induction\n      variable elimination.  */\n \n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     {\n       struct induction *v;\n       int benefit;\n@@ -4533,20 +4511,20 @@ strength_reduce (loop, insn_count, flags)\n \n       /* Now that we know which givs will be reduced, try to rearrange the\n          combinations to reduce register pressure.\n-         recombine_givs calls find_life_end, which needs reg_iv_type and\n-\t reg_iv_info to be valid for all pseudos.  We do the necessary\n+         recombine_givs calls find_life_end, which needs ivs->reg_iv_type and\n+\t ivs->reg_iv_info to be valid for all pseudos.  We do the necessary\n \t reallocation here since it allows to check if there are still\n \t more bivs to process.  */\n       nregs = max_reg_num ();\n-      if (nregs > reg_iv_type->num_elements)\n+      if (nregs > ivs->reg_iv_type->num_elements)\n \t{\n \t  /* If there are still more bivs to process, allocate some slack\n \t     space so that we're not constantly reallocating these arrays.  */\n \t  if (bl->next)\n \t    nregs += nregs / 4;\n-\t  /* Reallocate reg_iv_type and reg_iv_info.  */\n-\t  VARRAY_GROW (reg_iv_type, nregs);\n-\t  VARRAY_GROW (reg_iv_info, nregs);\n+\t  /* Reallocate ivs->reg_iv_type and ivs->reg_iv_info.  */\n+\t  VARRAY_GROW (ivs->reg_iv_type, nregs);\n+\t  VARRAY_GROW (ivs->reg_iv_info, nregs);\n \t}\n       recombine_givs (loop, bl, flags & LOOP_UNROLL);\n \n@@ -4958,9 +4936,9 @@ strength_reduce (loop, insn_count, flags)\n     fprintf (loop_dump_stream, \"\\n\");\n \n egress:\n-  VARRAY_FREE (reg_iv_type);\n-  VARRAY_FREE (reg_iv_info);\n-  free (reg_biv_class);\n+  VARRAY_FREE (ivs->reg_iv_type);\n+  VARRAY_FREE (ivs->reg_iv_info);\n+  free (ivs->reg_biv_class);\n   if (reg_map)\n     free (reg_map);\n }\n@@ -4973,6 +4951,7 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n      int not_every_iteration;\n      int maybe_multiple;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx set;\n   rtx dest_reg;\n   rtx inc_val;\n@@ -4986,7 +4965,7 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n       dest_reg = SET_DEST (set);\n       if (REGNO (dest_reg) < max_reg_before_loop\n \t  && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n-\t  && REG_IV_TYPE (REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n+\t  && REG_IV_TYPE (ivs, REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n \t{\n \t  if (basic_induction_var (loop, SET_SRC (set),\n \t\t\t\t   GET_MODE (SET_SRC (set)),\n@@ -4999,12 +4978,12 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n \t      struct induction *v\n \t\t= (struct induction *) oballoc (sizeof (struct induction));\n \n-\t      record_biv (v, p, dest_reg, inc_val, mult_val, location,\n+\t      record_biv (loop, v, p, dest_reg, inc_val, mult_val, location,\n \t\t\t  not_every_iteration, maybe_multiple);\n-\t      REG_IV_TYPE (REGNO (dest_reg)) = BASIC_INDUCT;\n+\t      REG_IV_TYPE (ivs, REGNO (dest_reg)) = BASIC_INDUCT;\n \t    }\n \t  else if (REGNO (dest_reg) < max_reg_before_loop)\n-\t    REG_IV_TYPE (REGNO (dest_reg)) = NOT_BASIC_INDUCT;\n+\t    REG_IV_TYPE (ivs, REGNO (dest_reg)) = NOT_BASIC_INDUCT;\n \t}\n     }\n   return p;\n@@ -5021,6 +5000,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n      int maybe_multiple;\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n+\n   rtx set;\n   /* Look for a general induction variable in a register.  */\n   if (GET_CODE (p) == INSN\n@@ -5237,8 +5217,9 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n    executed exactly once per iteration.  */\n \n static void\n-record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n+record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n \t    not_every_iteration, maybe_multiple)\n+     struct loop *loop;\n      struct induction *v;\n      rtx insn;\n      rtx dest_reg;\n@@ -5248,6 +5229,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n      int not_every_iteration;\n      int maybe_multiple;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n \n   v->insn = insn;\n@@ -5265,7 +5247,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n   /* Add this to the reg's iv_class, creating a class\n      if this is the first incrementation of the reg.  */\n \n-  bl = reg_biv_class[REGNO (dest_reg)];\n+  bl = ivs->reg_biv_class[REGNO (dest_reg)];\n   if (bl == 0)\n     {\n       /* Create and initialize new iv_class.  */\n@@ -5290,12 +5272,12 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n       bl->reversed = 0;\n       bl->total_benefit = 0;\n \n-      /* Add this class to loop_iv_list.  */\n-      bl->next = loop_iv_list;\n-      loop_iv_list = bl;\n+      /* Add this class to ivs->loop_iv_list.  */\n+      bl->next = ivs->loop_iv_list;\n+      ivs->loop_iv_list = bl;\n \n       /* Put it in the array of biv register classes.  */\n-      reg_biv_class[REGNO (dest_reg)] = bl;\n+      ivs->reg_biv_class[REGNO (dest_reg)] = bl;\n     }\n \n   /* Update IV_CLASS entry for this biv.  */\n@@ -5352,6 +5334,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n      int not_every_iteration, maybe_multiple;\n      rtx *location;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct induction *b;\n   struct iv_class *bl;\n   rtx set = single_set (insn);\n@@ -5420,13 +5403,13 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n       if (v->lifetime == 0)\n \tv->ignore = 1;\n \n-      REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;\n-      REG_IV_INFO (REGNO (dest_reg)) = v;\n+      REG_IV_TYPE (ivs, REGNO (dest_reg)) = GENERAL_INDUCT;\n+      REG_IV_INFO (ivs, REGNO (dest_reg)) = v;\n     }\n \n   /* Add the giv to the class of givs computed from one biv.  */\n \n-  bl = reg_biv_class[REGNO (src_reg)];\n+  bl = ivs->reg_biv_class[REGNO (src_reg)];\n   if (bl)\n     {\n       v->next_iv = bl->giv;\n@@ -5614,10 +5597,11 @@ check_final_value (loop, v)\n      const struct loop *loop;\n      struct induction *v;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n   rtx final_value = 0;\n \n-  bl = reg_biv_class[REGNO (v->src_reg)];\n+  bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n \n   /* DEST_ADDR givs will never reach here, because they are always marked\n      replaceable above in record_giv.  */\n@@ -5761,6 +5745,7 @@ update_giv_derive (loop, p)\n      const struct loop *loop;\n      rtx p;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n   struct induction *biv, *giv;\n   rtx tem;\n@@ -5793,7 +5778,7 @@ update_giv_derive (loop, p)\n      subsequent biv update was performed.  If this adjustment cannot be done,\n      the giv cannot derive further givs.  */\n \n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     for (biv = bl->biv; biv; biv = biv->next_iv)\n       if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n \t  || biv->insn == p)\n@@ -6069,6 +6054,7 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n      int *pbenefit;\n      enum machine_mode addr_mode;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx orig_x = x;\n   char *storage;\n \n@@ -6095,7 +6081,7 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n       /* Since this is now an invariant and wasn't before, it must be a giv\n \t with MULT_VAL == 0.  It doesn't matter which BIV we associate this\n \t with.  */\n-      *src_reg = loop_iv_list->biv->dest_reg;\n+      *src_reg = ivs->loop_iv_list->biv->dest_reg;\n       *mult_val = const0_rtx;\n       *add_val = x;\n       break;\n@@ -6184,6 +6170,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n      rtx *ext_val;\n      int *benefit;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n   enum machine_mode mode = GET_MODE (x);\n   rtx arg0, arg1;\n@@ -6453,13 +6440,13 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \treturn 0;\n \n       /* Check for biv or giv.  */\n-      switch (REG_IV_TYPE (REGNO (x)))\n+      switch (REG_IV_TYPE (ivs, REGNO (x)))\n \t{\n \tcase BASIC_INDUCT:\n \t  return x;\n \tcase GENERAL_INDUCT:\n \t  {\n-\t    struct induction *v = REG_IV_INFO (REGNO (x));\n+\t    struct induction *v = REG_IV_INFO (ivs, REGNO (x));\n \n \t    /* Form expression from giv and add benefit.  Ensure this giv\n \t       can derive another and subtract any needed adjustment if so.  */\n@@ -6679,6 +6666,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n      rtx *ext_val;\n      rtx *last_consec_insn;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n   int count;\n   enum rtx_code code;\n@@ -6703,8 +6691,8 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n   v->derive_adjustment = 0;\n   v->ext_dependant = NULL_RTX;\n \n-  REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;\n-  REG_IV_INFO (REGNO (dest_reg)) = v;\n+  REG_IV_TYPE (ivs, REGNO (dest_reg)) = GENERAL_INDUCT;\n+  REG_IV_INFO (ivs, REGNO (dest_reg)) = v;\n \n   count = VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) - 1;\n \n@@ -6750,7 +6738,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n \t      && CONSTANT_P (SET_SRC (set)))\n \t    continue;\n \n-\t  REG_IV_TYPE (REGNO (dest_reg)) = UNKNOWN_INDUCT;\n+\t  REG_IV_TYPE (ivs, REGNO (dest_reg)) = UNKNOWN_INDUCT;\n \t  return 0;\n \t}\n     }\n@@ -7416,10 +7404,12 @@ cmp_recombine_givs_stats (xp, yp)\n    Only consider givs that belong to BIV.\n    Return the total number of lifetime ends that have been found.  */\n static int\n-find_life_end (x, stats, insn, biv)\n+find_life_end (loop, x, stats, insn, biv)\n+     const struct loop *loop;\n      rtx x, insn, biv;\n      struct recombine_givs_stats *stats;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   enum rtx_code code;\n   const char *fmt;\n   int i, j;\n@@ -7434,9 +7424,9 @@ find_life_end (x, stats, insn, biv)\n \tif (GET_CODE (reg) == REG)\n \t  {\n \t    int regno = REGNO (reg);\n-\t    struct induction *v = REG_IV_INFO (regno);\n+\t    struct induction *v = REG_IV_INFO (ivs, regno);\n \n-\t    if (REG_IV_TYPE (regno) == GENERAL_INDUCT\n+\t    if (REG_IV_TYPE (ivs, regno) == GENERAL_INDUCT\n \t\t&& ! v->ignore\n \t\t&& v->src_reg == biv\n \t\t&& stats[v->ix].end_luid <= 0)\n@@ -7449,21 +7439,22 @@ find_life_end (x, stats, insn, biv)\n \t\tif (stats[v->ix].end_luid == 0)\n \t\t  {\n \t\t    stats[v->ix].end_luid = stats[v->ix].start_luid;\n-\t\t    return 1 + find_life_end (SET_SRC (x), stats, insn, biv);\n+\t\t    return 1 + find_life_end (loop, SET_SRC (x), stats,\n+\t\t\t\t\t      insn, biv);\n \t\t  }\n \t\telse if (stats[v->ix].start_luid == INSN_LUID (insn))\n \t\t  stats[v->ix].end_luid = 0;\n \t      }\n-\t    return find_life_end (SET_SRC (x), stats, insn, biv);\n+\t    return find_life_end (loop, SET_SRC (x), stats, insn, biv);\n \t  }\n \tbreak;\n       }\n     case REG:\n       {\n \tint regno = REGNO (x);\n-\tstruct induction *v = REG_IV_INFO (regno);\n+\tstruct induction *v = REG_IV_INFO (ivs, regno);\n \n-\tif (REG_IV_TYPE (regno) == GENERAL_INDUCT\n+\tif (REG_IV_TYPE (ivs, regno) == GENERAL_INDUCT\n \t    && ! v->ignore\n \t    && v->src_reg == biv\n \t    && stats[v->ix].end_luid == 0)\n@@ -7488,11 +7479,11 @@ find_life_end (x, stats, insn, biv)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tretval += find_life_end (XEXP (x, i), stats, insn, biv);\n+\tretval += find_life_end (loop, XEXP (x, i), stats, insn, biv);\n \n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  retval += find_life_end (XVECEXP (x, i, j), stats, insn, biv);\n+\t  retval += find_life_end (loop, XVECEXP (x, i, j), stats, insn, biv);\n     }\n   return retval;\n }\n@@ -7682,7 +7673,8 @@ recombine_givs (loop, bl, unroll_p)\n \t  p = PREV_INSN (p);\n \t  if (! INSN_P (p))\n \t    continue;\n-\t  ends_need_computing -= find_life_end (PATTERN (p), stats, p, biv);\n+\t  ends_need_computing -= find_life_end (loop, PATTERN (p), \n+\t\t\t\t\t\tstats, p, biv);\n \t}\n       while (ends_need_computing);\n     }\n@@ -7993,6 +7985,7 @@ check_dbra_loop (loop, insn_count)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n   rtx reg;\n   rtx jump_label;\n@@ -8047,7 +8040,7 @@ check_dbra_loop (loop, insn_count)\n      it will be zero on the last iteration.  Also skip if the biv is\n      used between its update and the test insn.  */\n \n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     {\n       if (bl->biv_count == 1\n \t  && ! bl->biv->maybe_multiple\n@@ -8237,7 +8230,7 @@ check_dbra_loop (loop, insn_count)\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n \t      + the_movables.num + compare_and_branch == insn_count)\n-\t   && (bl == loop_iv_list && bl->next == 0))\n+\t   && (bl == ivs->loop_iv_list && bl->next == 0))\n \t  || no_use_except_counting)\n \t{\n \t  rtx tem;\n@@ -8536,9 +8529,9 @@ check_dbra_loop (loop, insn_count)\n \t\t       REG_EQUAL notes should still be correct.  */\n \t\t    if (! set\n \t\t\t|| GET_CODE (SET_DEST (set)) != REG\n-\t\t\t|| (size_t) REGNO (SET_DEST (set)) >= reg_iv_type->num_elements\n-\t\t\t|| REG_IV_TYPE (REGNO (SET_DEST (set))) != GENERAL_INDUCT\n-\t\t\t|| REG_IV_INFO (REGNO (SET_DEST (set)))->src_reg != bl->biv->src_reg)\n+\t\t\t|| (size_t) REGNO (SET_DEST (set)) >= ivs->reg_iv_type->num_elements\n+\t\t\t|| REG_IV_TYPE (ivs, REGNO (SET_DEST (set))) != GENERAL_INDUCT\n+\t\t\t|| REG_IV_INFO (ivs, REGNO (SET_DEST (set)))->src_reg != bl->biv->src_reg)\n \t\t      for (pnote = &REG_NOTES (p); *pnote;)\n \t\t\t{\n \t\t\t  if (REG_NOTE_KIND (*pnote) == REG_EQUAL\n@@ -8589,6 +8582,7 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n      int eliminate_p;\n      int threshold, insn_count;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx reg = bl->biv->dest_reg;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n@@ -8617,8 +8611,8 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n \t\t  unsigned int regno = REGNO (SET_DEST (set));\n \n \t\t  if (regno < max_reg_before_loop\n-\t\t      && REG_IV_TYPE (regno) == GENERAL_INDUCT\n-\t\t      && REG_IV_INFO (regno)->src_reg == bl->biv->src_reg)\n+\t\t      && REG_IV_TYPE (ivs, regno) == GENERAL_INDUCT\n+\t\t      && REG_IV_INFO (ivs, regno)->src_reg == bl->biv->src_reg)\n \t\t    p = last;\n \t\t}\n \t    }\n@@ -9004,7 +8998,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n #if 0\n \t  /* Otherwise the reg compared with had better be a biv.  */\n \t  if (GET_CODE (arg) != REG\n-\t      || REG_IV_TYPE (REGNO (arg)) != BASIC_INDUCT)\n+\t      || REG_IV_TYPE (ivs, REGNO (arg)) != BASIC_INDUCT)\n \t    return 0;\n \n \t  /* Look for a pair of givs, one for each biv,\n@@ -9016,7 +9010,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t      if (v->ignore || v->maybe_dead || v->mode != mode)\n \t\tcontinue;\n \n-\t      for (tv = reg_biv_class[REGNO (arg)]->giv; tv; tv = tv->next_iv)\n+\t      for (tv = ivs->reg_biv_class[REGNO (arg)]->giv; tv; tv = tv->next_iv)\n \t\tif (! tv->ignore && ! tv->maybe_dead\n \t\t    && rtx_equal_p (tv->mult_val, v->mult_val)\n \t\t    && rtx_equal_p (tv->add_val, v->add_val)\n@@ -9106,14 +9100,15 @@ record_initial (dest, set, data)\n      rtx set;\n      void *data ATTRIBUTE_UNUSED;\n {\n+  struct loop_ivs *ivs = (struct loop_ivs *) data;\n   struct iv_class *bl;\n \n   if (GET_CODE (dest) != REG\n       || REGNO (dest) >= max_reg_before_loop\n-      || REG_IV_TYPE (REGNO (dest)) != BASIC_INDUCT)\n+      || REG_IV_TYPE (ivs, REGNO (dest)) != BASIC_INDUCT)\n     return;\n \n-  bl = reg_biv_class[REGNO (dest)];\n+  bl = ivs->reg_biv_class[REGNO (dest)];\n \n   /* If this is the first set found, record it.  */\n   if (bl->init_insn == 0)\n@@ -9614,8 +9609,7 @@ load_mems_and_recount_loop_regs_set (loop, insn_count)\n       bzero ((char *) &regs->may_not_optimize->data, nregs * sizeof (char));\n       bzero ((char *) &regs->single_usage->data, nregs * sizeof (rtx));\n \n-      count_loop_regs_set (loop, regs->may_not_optimize, \n-\t\t\t   regs->single_usage,\n+      count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage,\n \t\t\t   insn_count, nregs);\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)"}, {"sha": "21555a8802f7ca26241a12c9f49a2243484cddc5", "filename": "gcc/loop.h", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5bb68db315b7192f63866899378250810bdad8/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5bb68db315b7192f63866899378250810bdad8/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=ed5bb68db315b7192f63866899378250810bdad8", "patch": "@@ -32,6 +32,9 @@ Boston, MA 02111-1307, USA.  */\n /* Get a pointer to the loop registers structure.  */\n #define LOOP_REGS(LOOP) (&LOOP_INFO (loop)->regs)\n \n+/* Get a pointer to the loop induction variables structure.  */\n+#define LOOP_IVS(LOOP) (&LOOP_INFO (loop)->ivs)\n+\n /* Get the luid of an insn.  Catch the error of trying to reference the LUID\n    of an insn added during loop, since these don't have LUIDs.  */\n \n@@ -176,6 +179,34 @@ typedef struct loop_mem_info\n } loop_mem_info;\n \n \n+struct loop_ivs\n+{\n+  /* Indexed by register number, indicates whether or not register is\n+     an induction variable, and if so what type.  */\n+  varray_type reg_iv_type;\n+  \n+  /* Indexed by register number, contains pointer to `struct\n+     induction' if register is an induction variable.  This holds\n+     general info for all induction variables.  */\n+  varray_type reg_iv_info;\n+\n+  /* Indexed by register number, contains pointer to `struct iv_class'\n+     if register is a basic induction variable.  This holds info\n+     describing the class (a related group) of induction variables\n+     that the biv belongs to.  */\n+  struct iv_class **reg_biv_class;\n+  \n+  /* The head of a list which links together (via the next field)\n+     every iv class for the current loop.  */\n+  struct iv_class *loop_iv_list;\n+\n+  /* Givs made from biv increments are always splittable for loop\n+     unrolling.  Since there is no regscan info for them, we have to\n+     keep track of them separately.  */\n+  unsigned int first_increment_giv;\n+  unsigned int last_increment_giv;\n+};\n+\n \n struct loop_regs\n {\n@@ -285,6 +316,8 @@ struct loop_info\n   rtx first_loop_store_insn;\n   /* The registers used the in loop.  */\n   struct loop_regs regs;\n+  /* The induction variable information in loop.  */\n+  struct loop_ivs ivs;\n };\n \n /* Definitions used by the basic induction variable discovery code.  */\n@@ -299,18 +332,10 @@ extern unsigned int max_reg_before_loop;\n extern struct loop **uid_loop;\n extern FILE *loop_dump_stream;\n \n-extern varray_type reg_iv_type;\n-extern varray_type reg_iv_info;\n-\n-#define REG_IV_TYPE(n) \\\n-  (*(enum iv_mode *) &VARRAY_INT(reg_iv_type, (n)))\n-#define REG_IV_INFO(n) \\\n-  (*(struct induction **) &VARRAY_GENERIC_PTR(reg_iv_info, (n)))\n-\n-extern struct iv_class **reg_biv_class;\n-extern struct iv_class *loop_iv_list;\n-\n-extern unsigned int first_increment_giv, last_increment_giv;\n+#define REG_IV_TYPE(ivs, n) \\\n+  (*(enum iv_mode *) &VARRAY_INT(ivs->reg_iv_type, (n)))\n+#define REG_IV_INFO(ivs, n) \\\n+  (*(struct induction **) &VARRAY_GENERIC_PTR(ivs->reg_iv_info, (n)))\n \n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */"}, {"sha": "24a39f872b2298752442c52533aacf967be05ca1", "filename": "gcc/unroll.c", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5bb68db315b7192f63866899378250810bdad8/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5bb68db315b7192f63866899378250810bdad8/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=ed5bb68db315b7192f63866899378250810bdad8", "patch": "@@ -201,8 +201,9 @@ static void init_reg_map PARAMS ((struct inline_remap *, int));\n static rtx calculate_giv_inc PARAMS ((rtx, rtx, unsigned int));\n static rtx initial_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n static void final_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n-static void copy_loop_body PARAMS ((rtx, rtx, struct inline_remap *, rtx, int,\n-\t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n+static void copy_loop_body PARAMS ((struct loop *, rtx, rtx,\n+\t\t\t\t    struct inline_remap *, rtx, int,\n+\t\t\t\t    enum unroll_types, rtx, rtx, rtx, rtx));\n static int find_splittable_regs PARAMS ((const struct loop *,\n \t\t\t\t\t enum unroll_types, rtx, int));\n static int find_splittable_givs PARAMS ((const struct loop *, \n@@ -211,7 +212,7 @@ static int find_splittable_givs PARAMS ((const struct loop *,\n static int reg_dead_after_loop PARAMS ((const struct loop *, rtx));\n static rtx fold_rtx_mult_add PARAMS ((rtx, rtx, rtx, enum machine_mode));\n static int verify_addresses PARAMS ((struct induction *, rtx, int));\n-static rtx remap_split_bivs PARAMS ((rtx));\n+static rtx remap_split_bivs PARAMS ((struct loop *, rtx));\n static rtx find_common_reg_term PARAMS ((rtx, rtx));\n static rtx subtract_reg_term PARAMS ((rtx, rtx));\n static rtx loop_find_equiv_value PARAMS ((const struct loop *, rtx));\n@@ -235,6 +236,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n      rtx end_insert_before;\n      int strength_reduce_p;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   int i, j;\n   unsigned int r;\n   unsigned HOST_WIDE_INT temp;\n@@ -261,7 +264,6 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   rtx last_loop_insn;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n \n   /* Don't bother unrolling huge loops.  Since the minimum factor is\n      two, loops greater than one half of MAX_UNROLLED_INSNS will never\n@@ -872,7 +874,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t  }\n       /* Givs that have been created from multiple biv increments always have\n \t local registers.  */\n-      for (r = first_increment_giv; r <= last_increment_giv; r++)\n+      for (r = ivs->first_increment_giv; r <= ivs->last_increment_giv; r++)\n \t{\n \t  local_regno[r] = 1;\n \t  if (loop_dump_stream)\n@@ -1115,7 +1117,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \n \t      /* None of the copies are the `last_iteration', so just\n \t\t pass zero for that parameter.  */\n-\t      copy_loop_body (copy_start, copy_end, map, exit_label, 0,\n+\t      copy_loop_body (loop, copy_start, copy_end, map, exit_label, 0,\n \t\t\t      unroll_type, start_label, loop_end,\n \t\t\t      loop_start, copy_end);\n \t    }\n@@ -1193,7 +1195,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   /* Search the list of bivs and givs to find ones which need to be remapped\n      when split, and set their reg_map entry appropriately.  */\n \n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     {\n       if (REGNO (bl->biv->src_reg) != bl->regno)\n \tmap->reg_map[bl->regno] = bl->biv->src_reg;\n@@ -1219,7 +1221,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n     {\n       insn = NEXT_INSN (copy_end);\n       if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n-\tPATTERN (insn) = remap_split_bivs (PATTERN (insn));\n+\tPATTERN (insn) = remap_split_bivs (loop, PATTERN (insn));\n     }\n \n   /* For unroll_number times, make a copy of each instruction\n@@ -1263,7 +1265,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t  LABEL_NUSES (tem)++;\n \t}\n \n-      copy_loop_body (copy_start, copy_end, map, exit_label,\n+      copy_loop_body (loop, copy_start, copy_end, map, exit_label,\n \t\t      i == unroll_number - 1, unroll_type, start_label,\n \t\t      loop_end, insert_before, insert_before);\n     }\n@@ -1707,16 +1709,18 @@ final_reg_note_copy (notes, map)\n    This is very similar to a loop in expand_inline_function.  */\n \n static void\n-copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n+copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t\tunroll_type, start_label, loop_end, insert_before,\n \t\tcopy_notes_from)\n+     struct loop *loop;\n      rtx copy_start, copy_end;\n      struct inline_remap *map;\n      rtx exit_label;\n      int last_iteration;\n      enum unroll_types unroll_type;\n      rtx start_label, loop_end, insert_before, copy_notes_from;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx insn, pattern;\n   rtx set, tem, copy = NULL_RTX;\n   int dest_reg_was_split, i;\n@@ -1780,7 +1784,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      unsigned int regno = REGNO (SET_DEST (set));\n \n \t      v = addr_combined_regs[REGNO (SET_DEST (set))];\n-\t      bl = reg_biv_class[REGNO (v->src_reg)];\n+\t      bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n \n \t      /* Although the giv_inc amount is not needed here, we must call\n \t\t calculate_giv_inc here since it might try to delete the\n@@ -1935,9 +1939,9 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t     induction entry by find_splittable_regs.  */\n \n \t\t  if (regno < max_reg_before_loop\n-\t\t      && REG_IV_TYPE (regno) == BASIC_INDUCT)\n+\t\t      && REG_IV_TYPE (ivs, regno) == BASIC_INDUCT)\n \t\t    {\n-\t\t      giv_src_reg = reg_biv_class[regno]->biv->src_reg;\n+\t\t      giv_src_reg = ivs->reg_biv_class[regno]->biv->src_reg;\n \t\t      giv_dest_reg = giv_src_reg;\n \t\t    }\n \n@@ -2458,6 +2462,7 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n      rtx end_insert_before;\n      int unroll_number;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n   struct induction *v;\n   rtx increment, tem;\n@@ -2467,7 +2472,7 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n \n-  for (bl = loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     {\n       /* Biv_total_increment must return a constant value,\n \t otherwise we can not calculate the split values.  */\n@@ -2651,6 +2656,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n      rtx increment;\n      int unroll_number;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct induction *v, *v2;\n   rtx final_value;\n   rtx tem;\n@@ -2720,8 +2726,8 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t  >= INSN_LUID (loop->end)))\n \t  /* Givs made from biv increments are missed by the above test, so\n \t     test explicitly for them.  */\n-\t  && (REGNO (v->dest_reg) < first_increment_giv\n-\t      || REGNO (v->dest_reg) > last_increment_giv)\n+\t  && (REGNO (v->dest_reg) < ivs->first_increment_giv\n+\t      || REGNO (v->dest_reg) > ivs->last_increment_giv)\n \t  && ! (final_value = v->final_value))\n \tcontinue;\n \n@@ -3084,7 +3090,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t{\n \t  int count = 1;\n \t  if (! v->ignore)\n-\t    count = reg_biv_class[REGNO (v->src_reg)]->biv_count;\n+\t    count = ivs->reg_biv_class[REGNO (v->src_reg)]->biv_count;\n \n \t  if (count > 1 && v->derived_from)\n \t     /* In this case, there is one set where the giv insn was and one\n@@ -3277,14 +3283,15 @@ final_giv_value (loop, v)\n      const struct loop *loop;\n      struct induction *v;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n   rtx insn;\n   rtx increment, tem;\n   rtx insert_before, seq;\n   rtx loop_end = loop->end;\n   unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n \n-  bl = reg_biv_class[REGNO (v->src_reg)];\n+  bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n \n   /* The final value for givs which depend on reversed bivs must be calculated\n      differently than for ordinary givs.  In this case, there is already an\n@@ -3520,6 +3527,8 @@ unsigned HOST_WIDE_INT\n loop_iterations (loop)\n      struct loop *loop;\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n   enum rtx_code comparison_code;\n@@ -3530,7 +3539,6 @@ loop_iterations (loop)\n   int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n   rtx reg_term;\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n   struct iv_class *bl;\n \n   loop_info->n_iterations = 0;\n@@ -3605,7 +3613,7 @@ loop_iterations (loop)\n      will propagate a new pseudo into the old iteration register but\n      this will be marked by having the REG_USERVAR_P bit set.  */\n \n-  if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements\n+  if ((unsigned) REGNO (iteration_var) >= ivs->reg_iv_type->num_elements\n       && ! REG_USERVAR_P (iteration_var))\n     abort ();\n \n@@ -3623,7 +3631,7 @@ loop_iterations (loop)\n \n   /* If this is a new register, can't handle it since we don't have any\n      reg_iv_type entry for it.  */\n-  if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements)\n+  if ((unsigned) REGNO (iteration_var) >= ivs->reg_iv_type->num_elements)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -3649,7 +3657,7 @@ loop_iterations (loop)\n \t\t \"Loop iterations: Iteration var not an integer.\\n\");\n       return 0;\n     }\n-  else if (REG_IV_TYPE (REGNO (iteration_var)) == BASIC_INDUCT)\n+  else if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == BASIC_INDUCT)\n     {\n       /* When reg_iv_type / reg_iv_info is resized for biv increments\n \t that are turned into givs, reg_biv_class is not resized.\n@@ -3658,21 +3666,21 @@ loop_iterations (loop)\n \tabort ();\n \n       /* Grab initial value, only useful if it is a constant.  */\n-      bl = reg_biv_class[REGNO (iteration_var)];\n+      bl = ivs->reg_biv_class[REGNO (iteration_var)];\n       initial_value = bl->initial_value;\n \n       increment = biv_total_increment (bl);\n     }\n-  else if (REG_IV_TYPE (REGNO (iteration_var)) == GENERAL_INDUCT)\n+  else if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == GENERAL_INDUCT)\n     {\n       HOST_WIDE_INT offset = 0;\n-      struct induction *v = REG_IV_INFO (REGNO (iteration_var));\n+      struct induction *v = REG_IV_INFO (ivs, REGNO (iteration_var));\n       rtx biv_initial_value;\n \n       if (REGNO (v->src_reg) >= max_reg_before_loop)\n \tabort ();\n \n-      bl = reg_biv_class[REGNO (v->src_reg)];\n+      bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n \n       /* Increment value is mult_val times the increment value of the biv.  */\n \n@@ -4044,9 +4052,11 @@ loop_iterations (loop)\n    copying.  */\n \n static rtx\n-remap_split_bivs (x)\n+remap_split_bivs (loop, x)\n+     struct loop *loop;\n      rtx x;\n {\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n   register enum rtx_code code;\n   register int i;\n   register const char *fmt;\n@@ -4073,8 +4083,8 @@ remap_split_bivs (x)\n \t have to remap those givs also.  */\n #endif\n       if (REGNO (x) < max_reg_before_loop\n-\t  && REG_IV_TYPE (REGNO (x)) == BASIC_INDUCT)\n-\treturn reg_biv_class[REGNO (x)]->biv->src_reg;\n+\t  && REG_IV_TYPE (ivs, REGNO (x)) == BASIC_INDUCT)\n+\treturn ivs->reg_biv_class[REGNO (x)]->biv->src_reg;\n       break;\n \n     default:\n@@ -4085,12 +4095,12 @@ remap_split_bivs (x)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tXEXP (x, i) = remap_split_bivs (XEXP (x, i));\n+\tXEXP (x, i) = remap_split_bivs (loop, XEXP (x, i));\n       else if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    XVECEXP (x, i, j) = remap_split_bivs (XVECEXP (x, i, j));\n+\t    XVECEXP (x, i, j) = remap_split_bivs (loop, XVECEXP (x, i, j));\n \t}\n     }\n   return x;"}]}