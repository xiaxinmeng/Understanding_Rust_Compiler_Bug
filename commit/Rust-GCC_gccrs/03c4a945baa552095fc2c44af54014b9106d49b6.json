{"sha": "03c4a945baa552095fc2c44af54014b9106d49b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNjNGE5NDViYWE1NTIwOTVmYzJjNDRhZjU0MDE0YjkxMDZkNDliNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-01-02T18:30:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-01-02T18:30:50Z"}, "message": "re PR middle-end/88663 (internal compiler error: in check, at tree-vrp.c:188)\n\n\tPR middle-end/88663\n\t* gimple-fold.c (get_range_strlen): Update prototype to no longer\n\tneed the flexp argument.\n\t(get_range_strlen_tree): Drop flexp argument.  Drop flexp argument\n\tfrom calls to get_range_strlen.  Update comments.  Just update\n\tVAL for an unterminated const char array and let the reset of the\n\tcode handle it normally.  No longer try to set *flexp.  Adjust\n\treturn value.\n\t(get_range_strlen): Update for the new get_range_strlen API.\n\t(get_maxval_strlen): Similarly.\n\t(gimple_fold_builtin_strlen): Handle update meaning of return value\n\tfrom get_range_strlen.\n\t* gimple-ssa-sprintf.c (get_string_length): Update for the new\n\tget_range_strlen API.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267520", "tree": {"sha": "a63f41d8cecec9b31b46a918767ed1f5dee4b374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a63f41d8cecec9b31b46a918767ed1f5dee4b374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03c4a945baa552095fc2c44af54014b9106d49b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c4a945baa552095fc2c44af54014b9106d49b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c4a945baa552095fc2c44af54014b9106d49b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c4a945baa552095fc2c44af54014b9106d49b6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "905969f941d0428665ab2ff1c0826f60b5e41073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/905969f941d0428665ab2ff1c0826f60b5e41073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/905969f941d0428665ab2ff1c0826f60b5e41073"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "b344f6be61e9366e342609b53608e11ca1268061", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c4a945baa552095fc2c44af54014b9106d49b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c4a945baa552095fc2c44af54014b9106d49b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03c4a945baa552095fc2c44af54014b9106d49b6", "patch": "@@ -1,3 +1,21 @@\n+2019-01-02  Martin Sebor  <msebor@redhat.com>\n+            Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/88663\n+\t* gimple-fold.c (get_range_strlen): Update prototype to no longer\n+\tneed the flexp argument.\n+\t(get_range_strlen_tree): Drop flexp argument.  Drop flexp argument\n+\tfrom calls to get_range_strlen.  Update comments.  Just update\n+\tVAL for an unterminated const char array and let the reset of the\n+\tcode handle it normally.  No longer try to set *flexp.  Adjust\n+\treturn value.\n+\t(get_range_strlen): Update for the new get_range_strlen API.\n+\t(get_maxval_strlen): Similarly.\n+\t(gimple_fold_builtin_strlen): Handle update meaning of return value\n+\tfrom get_range_strlen.\n+\t* gimple-ssa-sprintf.c (get_string_length): Update for the new\n+\tget_range_strlen API.\n+\t\n 2019-01-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/88130"}, {"sha": "688daf921542659fb96d74a8737b9ed7ce7c19d5", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c4a945baa552095fc2c44af54014b9106d49b6/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c4a945baa552095fc2c44af54014b9106d49b6/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=03c4a945baa552095fc2c44af54014b9106d49b6", "patch": "@@ -83,8 +83,8 @@ enum strlen_range_kind {\n   SRK_INT_VALUE\n };\n \n-static bool get_range_strlen (tree, bitmap *, strlen_range_kind,\n-\t\t  c_strlen_data *, bool *, unsigned);\n+static bool\n+get_range_strlen (tree, bitmap *, strlen_range_kind, c_strlen_data *, unsigned);\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -1281,10 +1281,8 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n /* Helper of get_range_strlen for ARG that is not an SSA_NAME.  */\n \n static bool\n-get_range_strlen_tree (tree arg, bitmap *visited,\n-\t\t       strlen_range_kind rkind,\n-\t\t       c_strlen_data *pdata,\n-\t\t       bool *flexp, unsigned eltsize)\n+get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n+\t\t       c_strlen_data *pdata, unsigned eltsize)\n {\n   gcc_assert (TREE_CODE (arg) != SSA_NAME);\n  \n@@ -1307,8 +1305,8 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n \t  tree aop0 = TREE_OPERAND (op, 0);\n \t  if (TREE_CODE (aop0) == INDIRECT_REF\n \t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t    return get_range_strlen (TREE_OPERAND (aop0, 0), visited,\n-\t\t\t\t     rkind, pdata, flexp, eltsize);\n+\t    return get_range_strlen (TREE_OPERAND (aop0, 0), visited, rkind,\n+\t\t\t\t     pdata, eltsize);\n \t}\n       else if (TREE_CODE (TREE_OPERAND (op, 0)) == COMPONENT_REF\n \t       && (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2))\n@@ -1342,22 +1340,20 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n       c_strlen_data lendata = { };\n       val = c_strlen (arg, 1, &lendata, eltsize);\n \n-      /* If we potentially had a non-terminated string, then\n-\t bubble that information up to the caller.  */\n       if (!val && lendata.decl)\n \t{\n+\t  /* ARG refers to an unterminated const character array.\n+\t     DATA.DECL with size DATA.LEN.  */\n+\t  val = lendata.minlen;\n \t  pdata->decl = lendata.decl;\n-\t  pdata->minlen = lendata.minlen;\n-\t  pdata->maxlen = lendata.minlen;\n-\t  return rkind == SRK_STRLEN ? false : true;\n \t}\n     }\n \n   if (!val && (rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2))\n     {\n       if (TREE_CODE (arg) == ADDR_EXPR)\n \treturn get_range_strlen (TREE_OPERAND (arg, 0), visited, rkind,\n-\t\t\t\t pdata, flexp, eltsize);\n+\t\t\t\t pdata, eltsize);\n \n       if (TREE_CODE (arg) == ARRAY_REF)\n \t{\n@@ -1386,10 +1382,6 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n \t     the array could have zero length.  */\n \t  pdata->minlen = ssize_int (0);\n \n-\t  if (TREE_CODE (TREE_OPERAND (arg, 0)) == COMPONENT_REF\n-\t      && optype == TREE_TYPE (TREE_OPERAND (arg, 0))\n-\t      && array_at_struct_end_p (TREE_OPERAND (arg, 0)))\n-\t    *flexp = true;\n \t  tight_bound = true;\n \t}\n       else if (TREE_CODE (arg) == COMPONENT_REF\n@@ -1401,11 +1393,7 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n \t     optimistic if the array itself isn't NUL-terminated and\n \t     the caller relies on the subsequent member to contain\n \t     the NUL but that would only be considered valid if\n-\t     the array were the last member of a struct.\n-\t      Set *FLEXP to true if the array whose bound is being\n-\t     used is at the end of a struct.  */\n-\t  if (array_at_struct_end_p (arg))\n-\t    *flexp = true;\n+\t     the array were the last member of a struct.  */\n \n \t  tree fld = TREE_OPERAND (arg, 1);\n \n@@ -1550,7 +1538,7 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n     }\n \n   pdata->maxlen = val;\n-  return true;\n+  return rkind == SRK_LENRANGE || rkind == SRK_LENRANGE_2 || !integer_all_onesp (val);\n }\n \n /* For an ARG referencing one or more strings, try to obtain the range\n@@ -1570,12 +1558,13 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n    Return true if *PDATA was successfully populated and false otherwise.  */\n \n static bool\n-get_range_strlen (tree arg, bitmap *visited, strlen_range_kind rkind,\n-\t\t  c_strlen_data *pdata, bool *flexp, unsigned eltsize)\n+get_range_strlen (tree arg, bitmap *visited,\n+\t\t  strlen_range_kind rkind,\n+\t\t  c_strlen_data *pdata, unsigned eltsize)\n {\n \n   if (TREE_CODE (arg) != SSA_NAME)\n-    return get_range_strlen_tree (arg, visited, rkind, pdata, flexp, eltsize);\n+    return get_range_strlen_tree (arg, visited, rkind, pdata, eltsize);\n \n   /* If ARG is registered for SSA update we cannot look at its defining\n      statement.  */\n@@ -1601,16 +1590,15 @@ get_range_strlen (tree arg, bitmap *visited, strlen_range_kind rkind,\n             || gimple_assign_unary_nop_p (def_stmt))\n           {\n \t    tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t    return get_range_strlen (rhs, visited, rkind, pdata, flexp, eltsize);\n+\t    return get_range_strlen (rhs, visited, rkind, pdata, eltsize);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n \t    tree ops[2] = { gimple_assign_rhs2 (def_stmt),\n \t\t\t    gimple_assign_rhs3 (def_stmt) };\n \n \t    for (unsigned int i = 0; i < 2; i++)\n-\t      if (!get_range_strlen (ops[i], visited, rkind, pdata,\n-\t\t\t\t     flexp, eltsize))\n+\t      if (!get_range_strlen (ops[i], visited, rkind, pdata, eltsize))\n \t\t{\n \t\t  if (rkind != SRK_LENRANGE_2)\n \t\t    return false;\n@@ -1644,7 +1632,7 @@ get_range_strlen (tree arg, bitmap *visited, strlen_range_kind rkind,\n             if (arg == gimple_phi_result (def_stmt))\n               continue;\n \n-\t    if (!get_range_strlen (arg, visited, rkind, pdata, flexp, eltsize))\n+\t    if (!get_range_strlen (arg, visited, rkind, pdata, eltsize))\n \t      {\n \t\tif (rkind != SRK_LENRANGE_2)\n \t\t  return false;\n@@ -1696,8 +1684,8 @@ get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize, bool strict)\n {\n   bitmap visited = NULL;\n \n-  bool flexarray = false;\n-  if (!get_range_strlen (arg, &visited, strict ? SRK_LENRANGE : SRK_LENRANGE_2, pdata, &flexarray, eltsize))\n+  if (!get_range_strlen (arg, &visited, strict ? SRK_LENRANGE : SRK_LENRANGE_2,\n+\t\t\t pdata, eltsize))\n     {\n       /* On failure extend the length range to an impossible maximum\n \t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n@@ -1715,7 +1703,7 @@ get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize, bool strict)\n   if (visited)\n     BITMAP_FREE (visited);\n \n-  return flexarray;\n+  return !integer_all_onesp (pdata->maxlen);\n }\n \n /* Return the maximum value for ARG given RKIND (see strlen_range_kind).\n@@ -1741,8 +1729,7 @@ get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n   /* Reset DATA.MAXLEN if the call fails or when DATA.MAXLEN\n      is unbounded.  */\n   c_strlen_data lendata = { };\n-  bool dummy;\n-  if (!get_range_strlen (arg, &visited, rkind, &lendata, &dummy, 1))\n+  if (!get_range_strlen (arg, &visited, rkind, &lendata, /* eltsize = */1))\n     lendata.maxlen = NULL_TREE;\n   else if (lendata.maxlen && integer_all_onesp (lendata.maxlen))\n     lendata.maxlen = NULL_TREE;\n@@ -3720,7 +3707,7 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n   wide_int maxlen;\n \n   c_strlen_data lendata = { };\n-  if (!get_range_strlen (arg, &lendata, /* eltsize = */ 1)\n+  if (get_range_strlen (arg, &lendata, /* eltsize = */ 1)\n       && !lendata.decl\n       && lendata.minlen && TREE_CODE (lendata.minlen) == INTEGER_CST\n       && lendata.maxlen && TREE_CODE (lendata.maxlen) == INTEGER_CST)"}, {"sha": "8e6016fc42f3dfcec31fc93a1dea8680373d00ba", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c4a945baa552095fc2c44af54014b9106d49b6/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c4a945baa552095fc2c44af54014b9106d49b6/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=03c4a945baa552095fc2c44af54014b9106d49b6", "patch": "@@ -2009,7 +2009,7 @@ get_string_length (tree str, unsigned eltsize)\n      aren't known to point any such arrays result in LENDATA.MAXLEN\n      set to SIZE_MAX.  */\n   c_strlen_data lendata = { };\n-  bool flexarray = get_range_strlen (str, &lendata, eltsize);\n+  get_range_strlen (str, &lendata, eltsize);\n \n   /* Return the default result when nothing is known about the string. */\n   if (integer_all_onesp (lendata.maxbound)\n@@ -2026,7 +2026,7 @@ get_string_length (tree str, unsigned eltsize)\n        ? tree_to_uhwi (lendata.maxbound)\n        : HOST_WIDE_INT_M1U);\n \n-  const bool unbounded = flexarray || integer_all_onesp (lendata.maxlen);\n+  const bool unbounded = integer_all_onesp (lendata.maxlen);\n \n   /* Set the max/likely counters to unbounded when a minimum is known\n      but the maximum length isn't bounded.  This implies that STR is"}]}