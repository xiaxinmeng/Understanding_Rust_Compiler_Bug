{"sha": "23df853421a9517038d778f41d41e4b4bc2035ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNkZjg1MzQyMWE5NTE3MDM4ZDc3OGY0MWQ0MWU0YjRiYzIwMzVlZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2012-12-20T21:02:33Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2012-12-20T21:02:33Z"}, "message": "functional (_Require): Move to ...\n\n\t* include/std/functional (_Require): Move to ...\n\t* include/std/type_traits (_Require): ... here.\n\t* include/bits/shared_ptr_base.h (__shared_count::_S_create_from_up):\n\tHandle unique_ptr for arrays or with custom pointer types.\n\t(__shared_ptr::__shared_ptr(unique_ptr<_Tp1, _Del>&&): Likewise.\n\t* include/bits/unique_ptr.h (unique_ptr<_Tp[], _Dp>): Use\n\t_Dp::pointer if defined. Implement proposed resolution of LWG 2118.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr_array.cc: New.\n\t* testsuite/20_util/unique_ptr/assign/cv_qual.cc: New.\n\t* testsuite/20_util/unique_ptr/cons/array_convertible_neg.cc: New.\n\t* testsuite/20_util/unique_ptr/cons/convertible_neg.cc: New.\n\t* testsuite/20_util/unique_ptr/cons/cv_qual.cc: New.\n\t* testsuite/20_util/unique_ptr/modifiers/cv_qual.cc: New.\n\t* testsuite/20_util/unique_ptr/requirements/pointer_type_array.cc: New.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr.cc: Adjust comments.\n\t* testsuite/20_util/unique_ptr/cons/pointer_array_convertible_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/unique_ptr/requirements/pointer_type.cc: Likewise.\n\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error line number.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\t* testsuite/20_util/default_delete/48631_neg.cc: Likewise.\n\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Likewise.\n\t* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Likewise.\n\t* testsuite/20_util/unique_ptr/modifiers/reset_neg.cc: Adjust\n\tdg-error text.\n\t* testsuite/20_util/unique_ptr/cons/ptr_deleter_neg.cc: Use\n\tdifferent instantiations so static_assert fails for each.\n\nFrom-SVN: r194651", "tree": {"sha": "10c7b86dcb593feab069018b198a35a19d51237e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10c7b86dcb593feab069018b198a35a19d51237e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23df853421a9517038d778f41d41e4b4bc2035ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23df853421a9517038d778f41d41e4b4bc2035ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23df853421a9517038d778f41d41e4b4bc2035ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23df853421a9517038d778f41d41e4b4bc2035ee/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d89da9dbda394765582ae97fdd604ecde24f1186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89da9dbda394765582ae97fdd604ecde24f1186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89da9dbda394765582ae97fdd604ecde24f1186"}], "stats": {"total": 780, "additions": 668, "deletions": 112}, "files": [{"sha": "07caf0a4e33921ea62023a00b0010cd0358c19a7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1,3 +1,33 @@\n+2012-12-20  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/std/functional (_Require): Move to ...\n+\t* include/std/type_traits (_Require): ... here.\n+\t* include/bits/shared_ptr_base.h (__shared_count::_S_create_from_up):\n+\tHandle unique_ptr for arrays or with custom pointer types.\n+\t(__shared_ptr::__shared_ptr(unique_ptr<_Tp1, _Del>&&): Likewise.\n+\t* include/bits/unique_ptr.h (unique_ptr<_Tp[], _Dp>): Use\n+\t_Dp::pointer if defined. Implement proposed resolution of LWG 2118.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr_array.cc: New.\n+\t* testsuite/20_util/unique_ptr/assign/cv_qual.cc: New.\n+\t* testsuite/20_util/unique_ptr/cons/array_convertible_neg.cc: New.\n+\t* testsuite/20_util/unique_ptr/cons/convertible_neg.cc: New.\n+\t* testsuite/20_util/unique_ptr/cons/cv_qual.cc: New.\n+\t* testsuite/20_util/unique_ptr/modifiers/cv_qual.cc: New.\n+\t* testsuite/20_util/unique_ptr/requirements/pointer_type_array.cc: New.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr.cc: Adjust comments.\n+\t* testsuite/20_util/unique_ptr/cons/pointer_array_convertible_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/unique_ptr/requirements/pointer_type.cc: Likewise.\n+\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error line number.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\t* testsuite/20_util/default_delete/48631_neg.cc: Likewise.\n+\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Likewise.\n+\t* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Likewise.\n+\t* testsuite/20_util/unique_ptr/modifiers/reset_neg.cc: Adjust\n+\tdg-error text.\n+\t* testsuite/20_util/unique_ptr/cons/ptr_deleter_neg.cc: Use\n+\tdifferent instantiations so static_assert fails for each.\n+\n 2012-12-20  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/55741"}, {"sha": "9d9fecb48fe985815e297ee7174c75dd7ea2ab38", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -616,7 +616,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n \t  typename std::enable_if<!std::is_reference<_Del>::value>::type* = 0)\n \t{\n-\t  return new _Sp_counted_deleter<_Tp*, _Del, std::allocator<void>,\n+\t  typedef typename unique_ptr<_Tp, _Del>::pointer _Ptr;\n+\t  return new _Sp_counted_deleter<_Ptr, _Del, std::allocator<void>,\n \t    _Lp>(__r.get(), __r.get_deleter());\n \t}\n \n@@ -625,9 +626,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n \t  typename std::enable_if<std::is_reference<_Del>::value>::type* = 0)\n \t{\n+\t  typedef typename unique_ptr<_Tp, _Del>::pointer _Ptr;\n \t  typedef typename std::remove_reference<_Del>::type _Del1;\n \t  typedef std::reference_wrapper<_Del1> _Del2;\n-\t  return new _Sp_counted_deleter<_Tp*, _Del2, std::allocator<void>,\n+\t  return new _Sp_counted_deleter<_Ptr, _Del2, std::allocator<void>,\n \t    _Lp>(__r.get(), std::ref(__r.get_deleter()));\n \t}\n \n@@ -846,7 +848,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _M_ptr(__r.get()), _M_refcount()\n \t{\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  _Tp1* __tmp = __r.get();\n+\t  auto __tmp = std::__addressof(*__r.get());\n \t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n \t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n \t}"}, {"sha": "e17a4dc33c2b0a711e6cb1a1234504b70872873e", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 117, "deletions": 77, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -56,7 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr default_delete() noexcept = default;\n \n       template<typename _Up, typename = typename\n-\t       std::enable_if<std::is_convertible<_Up*, _Tp*>::value>::type>\n+\t       enable_if<is_convertible<_Up*, _Tp*>::value>::type>\n         default_delete(const default_delete<_Up>&) noexcept { }\n \n       void\n@@ -74,8 +74,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct default_delete<_Tp[]>\n     {\n+    private:\n+      template<typename _Up>\n+\tusing __remove_cv = typename remove_cv<_Up>::type;\n+\n+      // Like is_base_of<_Tp, _Up> but false if unqualified types are the same\n+      template<typename _Up>\n+\tusing __is_derived_Tp\n+\t  = __and_< is_base_of<_Tp, _Up>,\n+\t\t    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;\n+\n+    public:\n       constexpr default_delete() noexcept = default;\n \n+      template<typename _Up, typename = typename\n+\t       enable_if<!__is_derived_Tp<_Up>::value>::type>\n+        default_delete(const default_delete<_Up[]>&) noexcept { }\n+\n       void\n       operator()(_Tp* __ptr) const\n       {\n@@ -84,7 +99,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tdelete [] __ptr;\n       }\n \n-      template<typename _Up> void operator()(_Up*) const = delete;\n+      template<typename _Up>\n+\ttypename enable_if<__is_derived_Tp<_Up>::value>::type\n+\toperator()(_Up*) const = delete;\n     };\n \n   /// 20.7.1.2 unique_ptr for single objects.\n@@ -103,7 +120,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttypedef typename remove_reference<_Dp>::type _Del;\n \n       public:\n-\ttypedef decltype( __test<_Del>(0)) type;\n+\ttypedef decltype(__test<_Del>(0)) type;\n       };\n \n       typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;\n@@ -117,54 +134,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Constructors.\n       constexpr unique_ptr() noexcept\n       : _M_t()\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n+      { static_assert(!is_pointer<deleter_type>::value,\n \t\t     \"constructed with null function pointer deleter\"); }\n \n       explicit\n       unique_ptr(pointer __p) noexcept\n       : _M_t(__p, deleter_type())\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n+      { static_assert(!is_pointer<deleter_type>::value,\n \t\t     \"constructed with null function pointer deleter\"); }\n \n       unique_ptr(pointer __p,\n-\t  typename std::conditional<std::is_reference<deleter_type>::value,\n+\t  typename conditional<is_reference<deleter_type>::value,\n \t    deleter_type, const deleter_type&>::type __d) noexcept\n       : _M_t(__p, __d) { }\n \n       unique_ptr(pointer __p,\n-\t  typename std::remove_reference<deleter_type>::type&& __d) noexcept\n+\t  typename remove_reference<deleter_type>::type&& __d) noexcept\n       : _M_t(std::move(__p), std::move(__d))\n       { static_assert(!std::is_reference<deleter_type>::value,\n \t\t      \"rvalue deleter bound to reference\"); }\n \n-      constexpr unique_ptr(nullptr_t) noexcept\n-      : _M_t()\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t     \"constructed with null function pointer deleter\"); }\n+      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n \n       // Move constructors.\n       unique_ptr(unique_ptr&& __u) noexcept\n       : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n \n-      template<typename _Up, typename _Ep, typename = typename\n-\tstd::enable_if\n-\t  <std::is_convertible<typename unique_ptr<_Up, _Ep>::pointer,\n-\t\t\t       pointer>::value\n-\t   && !std::is_array<_Up>::value\n-\t   && ((std::is_reference<_Dp>::value\n-\t\t&& std::is_same<_Ep, _Dp>::value)\n-\t       || (!std::is_reference<_Dp>::value\n-\t\t   && std::is_convertible<_Ep, _Dp>::value))>\n-\t     ::type>\n+      template<typename _Up, typename _Ep, typename = _Require<\n+\t       is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,\n+\t       __not_<is_array<_Up>>,\n+\t       typename conditional<is_reference<_Dp>::value,\n+\t\t\t\t    is_same<_Ep, _Dp>,\n+\t\t\t\t    is_convertible<_Ep, _Dp>>::type>>\n \tunique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n \t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n \t{ }\n \n #if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Up, typename = typename\n-\tstd::enable_if<std::is_convertible<_Up*, _Tp*>::value\n-\t\t       && std::is_same<_Dp,\n-\t\t\t\t       default_delete<_Tp>>::value>::type>\n+      template<typename _Up, typename = _Require<\n+\t       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>\n \tunique_ptr(auto_ptr<_Up>&& __u) noexcept;\n #endif\n \n@@ -186,12 +194,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      template<typename _Up, typename _Ep, typename = typename\n-\tstd::enable_if\n-\t  <std::is_convertible<typename unique_ptr<_Up, _Ep>::pointer,\n-\t\t\t       pointer>::value\n-\t   && !std::is_array<_Up>::value>::type>\n-\tunique_ptr&\n+      template<typename _Up, typename _Ep>\n+\ttypename enable_if< __and_<\n+\t  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,\n+\t  __not_<is_array<_Up>>\n+\t  >::value,\n+\t  unique_ptr&>::type\n \toperator=(unique_ptr<_Up, _Ep>&& __u) noexcept\n \t{\n \t  reset(__u.release());\n@@ -207,7 +215,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       // Observers.\n-      typename std::add_lvalue_reference<element_type>::type\n+      typename add_lvalue_reference<element_type>::type\n       operator*() const\n       {\n \t_GLIBCXX_DEBUG_ASSERT(get() != pointer());\n@@ -273,47 +281,90 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Dp>\n     class unique_ptr<_Tp[], _Dp>\n     {\n-      typedef std::tuple<_Tp*, _Dp>  \t__tuple_type;\n-      __tuple_type \t\t\t_M_t;\n+      // use SFINAE to determine whether _Del::pointer exists\n+      class _Pointer\n+      {\n+\ttemplate<typename _Up>\n+\t  static typename _Up::pointer __test(typename _Up::pointer*);\n+\n+\ttemplate<typename _Up>\n+\t  static _Tp* __test(...);\n+\n+\ttypedef typename remove_reference<_Dp>::type _Del;\n+\n+      public:\n+\ttypedef decltype(__test<_Del>(0)) type;\n+      };\n+\n+      typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;\n+      __tuple_type                                      _M_t;\n+\n+      template<typename _Up>\n+\tusing __remove_cv = typename remove_cv<_Up>::type;\n+\n+      // like is_base_of<_Tp, _Up> but false if unqualified types are the same\n+      template<typename _Up>\n+\tusing __is_derived_Tp\n+\t  = __and_< is_base_of<_Tp, _Up>,\n+\t\t    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;\n+\n+      template<typename _Up, typename _Ep,\n+\t       typename _Tp_pointer = typename _Pointer::type,\n+\t       typename _Up_pointer = typename unique_ptr<_Up, _Ep>::pointer>\n+\tusing __safe_conversion = __and_<\n+\t    is_convertible<_Up_pointer, _Tp_pointer>,\n+\t    is_array<_Up>,\n+\t    __or_<__not_<is_pointer<_Up_pointer>>,\n+\t\t  __not_<is_pointer<_Tp_pointer>>,\n+\t\t  __not_<__is_derived_Tp<typename remove_extent<_Up>::type>>\n+\t    >\n+\t  >;\n \n     public:\n-      typedef _Tp*\t\t \tpointer;\n+      typedef typename _Pointer::type\tpointer;\n       typedef _Tp\t\t \telement_type;\n       typedef _Dp                       deleter_type;\n \n       // Constructors.\n       constexpr unique_ptr() noexcept\n       : _M_t()\n       { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t     \"constructed with null function pointer deleter\"); }\n+\t\t      \"constructed with null function pointer deleter\"); }\n \n       explicit\n       unique_ptr(pointer __p) noexcept\n       : _M_t(__p, deleter_type())\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t     \"constructed with null function pointer deleter\"); }\n+      { static_assert(!is_pointer<deleter_type>::value,\n+\t\t      \"constructed with null function pointer deleter\"); }\n+\n+      template<typename _Up, typename = _Require<is_pointer<pointer>,\n+\t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n+\texplicit\n+\tunique_ptr(_Up* __p) = delete;\n \n       unique_ptr(pointer __p,\n-\t  typename std::conditional<std::is_reference<deleter_type>::value,\n+\t  typename conditional<is_reference<deleter_type>::value,\n \t      deleter_type, const deleter_type&>::type __d) noexcept\n       : _M_t(__p, __d) { }\n \n       unique_ptr(pointer __p, typename\n-\t\t std::remove_reference<deleter_type>::type && __d) noexcept\n+\t\t remove_reference<deleter_type>::type&& __d) noexcept\n       : _M_t(std::move(__p), std::move(__d))\n-      { static_assert(!std::is_reference<deleter_type>::value,\n+      { static_assert(!is_reference<deleter_type>::value,\n \t\t      \"rvalue deleter bound to reference\"); }\n \n-      constexpr unique_ptr(nullptr_t) noexcept\n-      : _M_t()\n-      { static_assert(!std::is_pointer<deleter_type>::value,\n-\t\t     \"constructed with null function pointer deleter\"); }\n-\n-      // Move constructors.\n+      // Move constructor.\n       unique_ptr(unique_ptr&& __u) noexcept\n       : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n \n-      template<typename _Up, typename _Ep>\n+      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n+\n+      template<typename _Up, typename _Ep,\n+\t       typename = _Require<__safe_conversion<_Up, _Ep>,\n+\t\t typename conditional<is_reference<_Dp>::value,\n+\t\t\t\t      is_same<_Ep, _Dp>,\n+\t\t\t\t      is_convertible<_Ep, _Dp>>::type\n+\t       >>\n \tunique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n \t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n \t{ }\n@@ -337,7 +388,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       template<typename _Up, typename _Ep>\n-\tunique_ptr&\n+\ttypename\n+\tenable_if<__safe_conversion<_Up, _Ep>::value, unique_ptr&>::type\n \toperator=(unique_ptr<_Up, _Ep>&& __u) noexcept\n \t{\n \t  reset(__u.release());\n@@ -385,26 +437,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       void\n-      reset(pointer __p = pointer()) noexcept\n-      {\n-\tusing std::swap;\n-\tswap(std::get<0>(_M_t), __p);\n-\tif (__p != nullptr)\n-\t  get_deleter()(__p);\n-      }\n+      reset() noexcept\n+      { reset(pointer()); }\n \n       void\n-      reset(nullptr_t) noexcept\n+      reset(pointer __p) noexcept\n       {\n-\tpointer __p = get();\n-\tstd::get<0>(_M_t) = pointer();\n+\tusing std::swap;\n+\tswap(std::get<0>(_M_t), __p);\n \tif (__p != nullptr)\n \t  get_deleter()(__p);\n       }\n \n-      // DR 821.\n-      template<typename _Up>\n-\tvoid reset(_Up) = delete;\n+      template<typename _Up, typename = _Require<is_pointer<pointer>,\n+\t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n+\tvoid reset(_Up*) = delete;\n \n       void\n       swap(unique_ptr& __u) noexcept\n@@ -418,23 +465,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       unique_ptr& operator=(const unique_ptr&) = delete;\n \n       // Disable construction from convertible pointer types.\n-      // (N2315 - 20.7.1.3.1)\n-      template<typename _Up>\n+      template<typename _Up, typename = _Require<is_pointer<pointer>,\n+\t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n \tunique_ptr(_Up*, typename\n-\t\t   std::conditional<std::is_reference<deleter_type>::value,\n-\t\t   deleter_type, const deleter_type&>::type,\n-\t\t   typename std::enable_if<std::is_convertible<_Up*,\n-\t\t   pointer>::value>::type* = 0) = delete;\n-\n-      template<typename _Up>\n-\tunique_ptr(_Up*, typename std::remove_reference<deleter_type>::type&&,\n-\t\t   typename std::enable_if<std::is_convertible<_Up*,\n-\t\t   pointer>::value>::type* = 0) = delete;\n+\t\t   conditional<is_reference<deleter_type>::value,\n+\t\t   deleter_type, const deleter_type&>::type) = delete;\n \n-      template<typename _Up>\n-\texplicit\n-\tunique_ptr(_Up*, typename std::enable_if<std::is_convertible<_Up*,\n-\t\t   pointer>::value>::type* = 0) = delete;\n+      template<typename _Up, typename = _Require<is_pointer<pointer>,\n+\t       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>\n+\tunique_ptr(_Up*, typename\n+\t\t   remove_reference<deleter_type>::type&&) = delete;\n     };\n \n   template<typename _Tp, typename _Dp>"}, {"sha": "3ec2e1ea4ed3f4b84688c87a869e34b502245199", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -501,9 +501,6 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n   // @} group functors\n \n-  template<typename... _Cond>\n-    using _Require = typename enable_if<__and_<_Cond...>::value>::type;\n-\n   template<typename... _Types>\n     struct _Pack : integral_constant<size_t, sizeof...(_Types)>\n     { };"}, {"sha": "e2747276257800772e4b7aa53ccd273d82884036", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1771,6 +1771,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct enable_if<true, _Tp>\n     { typedef _Tp type; };\n \n+  template<typename... _Cond>\n+    using _Require = typename enable_if<__and_<_Cond...>::value>::type;\n \n   // Primary template.\n   /// Define a member typedef @c type to one of two argument types."}, {"sha": "9854176547949ca12266fbd83e809948ac42fd42", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -30,10 +30,10 @@ void test01()\n {\n   const int dummy = 0;\n   std::bind(&inc, _1)(0);               // { dg-error  \"no match\" }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1349 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1363 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1377 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1391 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1346 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1360 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1374 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1388 }\n   std::bind(&inc, std::ref(dummy))();\t// { dg-error  \"no match\" }\n }\n "}, {"sha": "015f39efd729b3399696cd92b6a7c44251103e72", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1869 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1871 }\n \n #include <utility>\n "}, {"sha": "fa2e3d11770af1f75ed1af7484835468b2ee24e6", "filename": "libstdc++-v3/testsuite/20_util/default_delete/48631_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdefault_delete%2F48631_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -27,4 +27,4 @@ struct D : B { };\n D d;\n std::default_delete<B[]> db;\n typedef decltype(db(&d)) type; // { dg-error \"use of deleted function\" }\n-// { dg-error \"declared here\" \"\" { target *-*-* } 87 }\n+// { dg-error \"declared here\" \"\" { target *-*-* } 104 }"}, {"sha": "380861c9df169f62a46d11086face470fadafca8", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -32,7 +32,7 @@ void test01()\n {\n   X* px = 0;\n   std::shared_ptr<X> p1(px);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 769 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 771 }\n \n   std::shared_ptr<X> p9(ap());  // { dg-error \"here\" }\n   // { dg-error \"incomplete\" \"\" { target *-*-* } 307 }"}, {"sha": "d6a25a0f0cb605d27e4901f5e97bab57dfbe8a53", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1,6 +1,6 @@\n-// { dg-options \"-std=gnu++0x\" }\n+// { dg-options \"-std=gnu++11\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation\n+// Copyright (C) 2008-2012 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -17,14 +17,14 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+// 20.7.2.2 Class template shared_ptr [util.smartptr.shared]\n \n #include <memory>\n #include <testsuite_hooks.h>\n \n struct A { };\n \n-// 20.7.12.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+// 20.7.2.2.1 shared_ptr constructors [util.smartptr.shared.const]\n \n // Construction from unique_ptr\n int"}, {"sha": "dc07920574ec77d8ac566e2cc332926f2c868adc", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_array.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_array.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.2.2 Class template shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+int destroyed = 0;\n+\n+struct A : std::enable_shared_from_this<A>\n+{\n+  ~A() { ++destroyed; }\n+};\n+\n+// 20.7.2.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from unique_ptr<A[]>\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unique_ptr<A[]> up(new A[2]);\n+  std::shared_ptr<A> sp(std::move(up));\n+  VERIFY( up.get() == 0 );\n+  VERIFY( sp.get() != 0 );\n+  VERIFY( sp.use_count() == 1 );\n+\n+  VERIFY( sp->shared_from_this() != nullptr );\n+\n+  sp.reset();\n+  VERIFY( destroyed == 2 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "624c225649ebcad858f3e3bb513067486f4b97d2", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2F48635_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -41,10 +41,10 @@ void f()\n   std::unique_ptr<int, B&> ub(nullptr, b);\n   std::unique_ptr<int, D&> ud(nullptr, d);\n   ub = std::move(ud);\n-// { dg-error \"use of deleted function\" \"\" { target *-*-* } 198 }\n+// { dg-error \"use of deleted function\" \"\" { target *-*-* } 206 }\n \n   std::unique_ptr<int[], B&> uba(nullptr, b);\n   std::unique_ptr<int[], D&> uda(nullptr, d);\n   uba = std::move(uda);\n-// { dg-error \"use of deleted function\" \"\" { target *-*-* } 344 }\n+// { dg-error \"use of deleted function\" \"\" { target *-*-* } 396 }\n }"}, {"sha": "1b47a9f5695703e2c58cd45348aac7763fb64b0c", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/assign/cv_qual.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fcv_qual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fcv_qual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fcv_qual.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.1 Class template unique_ptr [unique.ptr]\n+\n+#include <memory>\n+\n+struct A { virtual ~A() = default; };\n+\n+struct B : A { };\n+\n+// Assignment from objects with different cv-qualification\n+\n+void\n+test01()\n+{\n+  std::unique_ptr<A> upA;\n+\n+  std::unique_ptr<const A> cA;\n+  cA = std::move(upA);\n+  std::unique_ptr<volatile A> vA;\n+  vA = std::move(upA);\n+  std::unique_ptr<const volatile A> cvA;\n+  cvA = std::move(upA);\n+}\n+\n+void\n+test02()\n+{\n+  std::unique_ptr<B> upB;\n+\n+  std::unique_ptr<const A> cA;\n+  cA = std::move(upB);\n+  std::unique_ptr<volatile A> vA;\n+  vA = std::move(upB);\n+  std::unique_ptr<const volatile A> cvA;\n+  cvA = std::move(upB);\n+}\n+\n+void\n+test03()\n+{\n+  std::unique_ptr<A[]> upA;\n+\n+  std::unique_ptr<const A[]> cA;\n+  cA = std::move(upA);\n+  std::unique_ptr<volatile A[]> vA;\n+  vA = std::move(upA);\n+  std::unique_ptr<const volatile A[]> cvA;\n+  cvA = std::move(upA);\n+}\n+\n+struct A_pointer { operator A*() const { return nullptr; } };\n+\n+template<typename T>\n+struct deleter\n+{\n+  deleter() = default;\n+  template<typename U>\n+    deleter(const deleter<U>) { }\n+  typedef T pointer;\n+  void operator()(T) const { }\n+};\n+\n+void\n+test04()\n+{\n+  // Allow conversions from user-defined pointer-like types\n+  std::unique_ptr<B[], deleter<A_pointer>> p;\n+  std::unique_ptr<A[], deleter<A*>> upA;\n+  upA = std::move(p);\n+}"}, {"sha": "15a1f317a5ee3f8f615e1ced91b768571e1317d9", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/array_convertible_neg.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Farray_convertible_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Farray_convertible_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Farray_convertible_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+\n+struct A\n+{\n+};\n+\n+struct B : A\n+{\n+  virtual ~B() { }\n+};\n+\n+// 20.7.1.3 unique_ptr for array objects [unique.ptr.runtime]\n+\n+struct D\n+{\n+  template<typename T>\n+    void operator()(const T* p) const { delete[] p; }\n+};\n+\n+// Conversion from different type of unique_ptr<T[], D>\n+void\n+test01()\n+{\n+  std::unique_ptr<B[], D> b(new B[1]);\n+  std::unique_ptr<A[], D> a(std::move(b)); //{ dg-error \"no matching function\" }\n+  a = std::move(b); //{ dg-error \"no match\" }\n+}\n+\n+// Conversion from non-array form of unique_ptr\n+void\n+test02()\n+{\n+  std::unique_ptr<A> nonarray(new A);\n+  std::unique_ptr<A[]> array(std::move(nonarray)); //{ dg-error \"no matching function\" }\n+  array = std::move(nonarray); //{ dg-error \"no match\" }\n+}\n+\n+// { dg-prune-output \"include\" }"}, {"sha": "5e6591d8857cb89753e324d00b2e297c6ded5688", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/convertible_neg.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconvertible_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconvertible_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconvertible_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+\n+struct A\n+{\n+};\n+\n+// 20.7.1.3 unique_ptr for array objects [unique.ptr.runtime]\n+\n+// Conversion to non-array form of unique_ptr\n+void\n+test01()\n+{\n+  std::unique_ptr<A[]> array(new A[1]);\n+  std::unique_ptr<A> nonarray(std::move(array)); //{ dg-error \"no matching function\" }\n+  nonarray = std::move(array); //{ dg-error \"no match\" }\n+}\n+\n+// { dg-prune-output \"include\" }"}, {"sha": "c1d3dadd4857d546b73a373d2dd5bd7a8177fe0f", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fcv_qual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fcv_qual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fcv_qual.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,115 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.1 Class template unique_ptr [unique.ptr]\n+\n+#include <memory>\n+\n+struct A { virtual ~A() = default; };\n+\n+struct B : A { };\n+\n+// Construction from objects with different cv-qualification\n+\n+void\n+test01()\n+{\n+  std::unique_ptr<const A> cA(new A);\n+  std::unique_ptr<volatile A> vA(new A);\n+  std::unique_ptr<const volatile A> cvA(new A);\n+}\n+\n+void\n+test02()\n+{\n+  std::unique_ptr<const A> cB(new B);\n+  std::unique_ptr<volatile A> vB(new B);\n+  std::unique_ptr<const volatile A> cvB(new B);\n+}\n+\n+void\n+test03()\n+{\n+  std::unique_ptr<A> upA;\n+\n+  std::unique_ptr<const A> cA(std::move(upA));\n+  std::unique_ptr<volatile A> vA(std::move(upA));\n+  std::unique_ptr<const volatile A> cvA(std::move(upA));\n+}\n+\n+void\n+test04()\n+{\n+  std::unique_ptr<B> upB;\n+\n+  std::unique_ptr<const A> cA(std::move(upB));\n+  std::unique_ptr<volatile A> vA(std::move(upB));\n+  std::unique_ptr<const volatile A> cvA(std::move(upB));\n+}\n+\n+void\n+test05()\n+{\n+  std::unique_ptr<const A[]> cA(new A[1]);\n+  std::unique_ptr<volatile A[]> vA(new A[1]);\n+  std::unique_ptr<const volatile A[]> cvA(new A[1]);\n+}\n+\n+void\n+test06()\n+{\n+  std::unique_ptr<A[]> upA;\n+\n+  std::unique_ptr<const A[]> cA(std::move(upA));\n+  std::unique_ptr<volatile A[]> vA(std::move(upA));\n+  std::unique_ptr<const volatile A[]> cvA(std::move(upA));\n+}\n+\n+struct A_pointer { operator A*() const { return nullptr; } };\n+\n+void\n+test07()\n+{\n+  // Allow conversions from user-defined pointer-like types\n+  A_pointer p;\n+  std::unique_ptr<A[]> upA(p);\n+  std::unique_ptr<const A[]> cA(p);\n+  std::unique_ptr<volatile A[]> vA(p);\n+  std::unique_ptr<const volatile A[]> cvA(p);\n+}\n+\n+template<typename T>\n+struct deleter\n+{\n+  deleter() = default;\n+  template<typename U>\n+    deleter(const deleter<U>) { }\n+  typedef T pointer;\n+  void operator()(T) const { }\n+};\n+\n+void\n+test08()\n+{\n+  // Allow conversions from user-defined pointer-like types\n+  std::unique_ptr<B[], deleter<A_pointer>> p;\n+  std::unique_ptr<A[], deleter<A*>> upA(std::move(p));\n+}\n+"}, {"sha": "42f1eca8bb60c7ab53c6f5bc7e62e2168d21bd73", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/pointer_array_convertible_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fpointer_array_convertible_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fpointer_array_convertible_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fpointer_array_convertible_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n-// { dg-options \"-std=gnu++0x\" }\n+// { dg-options \"-std=gnu++11\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation\n+// Copyright (C) 2008-2012 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,7 +29,7 @@ struct B : A\n   virtual ~B() { }\n };\n \n-// 20.4.5.1 unique_ptr constructors [unique.ptr.cons]\n+// 20.7.1.3.1 unique_ptr constructors [unique.ptr.runtime.ctor]\n \n // Construction from pointer of derived type\n void"}, {"sha": "e2be10546535c016cd276ad1b083727cc7815069", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/ptr_deleter_neg.cc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fptr_deleter_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fptr_deleter_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fptr_deleter_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2010 Free Software Foundation\n+// Copyright (C) 2010-2012 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,10 +18,9 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 20.6.11 Template class unique_ptr [unique.ptr]\n+// 20.7.1 Class template unique_ptr [unique.ptr]\n \n #include <memory>\n-#include <testsuite_hooks.h>\n \n using std::unique_ptr;\n \n@@ -30,19 +29,19 @@ using std::unique_ptr;\n void\n test01()\n {\n-  unique_ptr<int, void(*)(int*)> p1; // { dg-error \"here\" }\n+  unique_ptr<long, void(*)(long*)> p1; // { dg-error \"here\" }\n \n-  unique_ptr<int, void(*)(int*)> p2(nullptr); // { dg-error \"here\" }\n+  unique_ptr<short, void(*)(short*)> p2(nullptr); // { dg-error \"here\" }\n \n   unique_ptr<int, void(*)(int*)> p3(new int); // { dg-error \"here\" }\n }\n \n void\n test02()\n {\n-  unique_ptr<int[], void(*)(int*)> p1; // { dg-error \"here\" }\n+  unique_ptr<long[], void(*)(long*)> p1; // { dg-error \"here\" }\n \n-  unique_ptr<int[], void(*)(int*)> p2(nullptr); // { dg-error \"here\" }\n+  unique_ptr<short[], void(*)(short*)> p2(nullptr); // { dg-error \"here\" }\n \n   unique_ptr<int[], void(*)(int*)> p3(new int[1]); // { dg-error \"here\" }\n }"}, {"sha": "c5afa7ea59a1a66b5afd5f704d29370fd526cfed", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/cv_qual.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Fcv_qual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Fcv_qual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Fcv_qual.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.1 Class template unique_ptr [unique.ptr]\n+\n+#include <memory>\n+\n+struct A { virtual ~A() = default; };\n+\n+struct B : A { };\n+\n+// Construction from objects with different cv-qualification\n+\n+void\n+test01()\n+{\n+  std::unique_ptr<const A> cA;\n+  cA.reset(new A);\n+  std::unique_ptr<volatile A> vA;\n+  vA.reset(new A);\n+  std::unique_ptr<const volatile A> cvA;\n+  cvA.reset(new A);\n+}\n+\n+void\n+test02()\n+{\n+  std::unique_ptr<const A> cB;\n+  cB.reset(new B);\n+  std::unique_ptr<volatile A> vB;\n+  vB.reset(new B);\n+  std::unique_ptr<const volatile A> cvB;\n+  cvB.reset(new B);\n+}\n+\n+void\n+test03()\n+{\n+  std::unique_ptr<const A[]> cA;\n+  cA.reset(new A[1]);\n+  std::unique_ptr<volatile A[]> vA;\n+  vA.reset(new A[1]);\n+  std::unique_ptr<const volatile A[]> cvA;\n+  cvA.reset(new A[1]);\n+}\n+\n+struct A_pointer { operator A*() const { return nullptr; } };\n+\n+void\n+test07()\n+{\n+  // Allow conversions from user-defined pointer-like types\n+  A_pointer p;\n+  std::unique_ptr<A[]> upA;\n+  upA.reset(p);\n+  std::unique_ptr<const A[]> cA;\n+  cA.reset(p);\n+  std::unique_ptr<volatile A[]> vA;\n+  vA.reset(p);\n+  std::unique_ptr<const volatile A[]> cvA;\n+  cvA.reset(p);\n+}"}, {"sha": "2f5e639b055e906ebabdf8c88c5a729739b87eaa", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/reset_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Freset_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Freset_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Freset_neg.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009, 2010 Free Software Foundation\n+// Copyright (C) 2008-2012 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@ struct B : A\n void test01()\n {\n   std::unique_ptr<B[]> up;\n-  up.reset(new A[3]);\t\t// { dg-error \"deleted\" }\n+  up.reset(new A[3]);\t\t// { dg-error \"invalid conversion\" }\n }\n \n // { dg-prune-output \"include\" }"}, {"sha": "ee2105d1cc0a274c4b1c8b02c28a8e835313ac80", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/requirements/pointer_type.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Frequirements%2Fpointer_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Frequirements%2Fpointer_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Frequirements%2Fpointer_type.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n-// { dg-options \"-std=gnu++0x\" }\n+// { dg-options \"-std=gnu++11\" }\n \n-// Copyright (C) 2010, 2011 Free Software Foundation\n+// Copyright (C) 2010-2012 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,10 +18,9 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 20.6.11 Template class unique_ptr [unique.ptr.single]\n+// 20.7.1.2 unique_ptr for single objects [unique.ptr.single]\n \n #include <memory>\n-#include <testsuite_hooks.h>\n \n struct A\n {"}, {"sha": "0f1a8e51a977b89b079c6b7ac2a637f378520a8c", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/requirements/pointer_type_array.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Frequirements%2Fpointer_type_array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23df853421a9517038d778f41d41e4b4bc2035ee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Frequirements%2Fpointer_type_array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Frequirements%2Fpointer_type_array.cc?ref=23df853421a9517038d778f41d41e4b4bc2035ee", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2010-2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.1.3 unique_ptr for array objects [unique.ptr.runtime]\n+\n+#include <memory>\n+\n+struct A\n+{\n+  void operator()(void*) const { }\n+};\n+\n+struct B\n+{\n+  typedef char* pointer;\n+  void operator()(pointer) const { }\n+};\n+\n+int main()\n+{\n+  typedef std::unique_ptr<int[]>     up;\n+  typedef std::unique_ptr<int[], A>  upA;\n+  typedef std::unique_ptr<int[], B>  upB;\n+  typedef std::unique_ptr<int[], A&> upAr;\n+  typedef std::unique_ptr<int[], B&> upBr;\n+\n+  static_assert( std::is_same< up::pointer, int*>::value, \"\" );\n+  static_assert( std::is_same< upA::pointer, int*>::value, \"\" );\n+  static_assert( std::is_same< upB::pointer, char*>::value, \"\" );\n+  static_assert( std::is_same< upAr::pointer, int*>::value, \"\" );\n+  static_assert( std::is_same< upBr::pointer, char*>::value, \"\" );\n+}"}]}