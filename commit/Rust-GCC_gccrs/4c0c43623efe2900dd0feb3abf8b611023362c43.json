{"sha": "4c0c43623efe2900dd0feb3abf8b611023362c43", "node_id": "C_kwDOANBUbNoAKDRjMGM0MzYyM2VmZTI5MDBkZDBmZWIzYWJmOGI2MTEwMjMzNjJjNDM", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-22T16:10:43Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-23T06:05:48Z"}, "message": "Overhaul jump thread state in forward threader.\n\nI've been pulling state from across the forward jump threader into the\njt_state class, but it it still didn't feel right.  The ultimate goal\nwas to keep track of candidate threading paths so that the simplifier\ncould simplify statements with the path as context.  This patch completes\nthe transition, while cleaning up a lot of things in the process.\n\nI've revamped both state and the simplifier such that a base state class\ncontains only the blocks as they're registered, and any pass specific\nknowledge is where it belongs... in the pass.  This allows VRP to keep\nits const and copies business, and DOM to keep this as well as its evrp\nclient.  This makes the threader cleaner, as it will now have no knowledge\nof either const/copies or evrp.\n\nThis also paves the wave for the upcoming hybrid threader, which will\njust derive the state class and provide almost nothing, since the ranger\ndoesn't need to register any equivalences or ranges as it folds.\n\nThere is some code duplication in the simplifier, since both the DOM and\nVRP clients use a vr_values based simplifier, but this is temporary as\nthe VRP client is about to be replaced with a hybrid ranger.\n\nFor a better view of what this patch achieves, here are the base\nclasses:\n\nclass jt_state\n{\npublic:\n  virtual ~jt_state () { }\n  virtual void push (edge);\n  virtual void pop ();\n  virtual void register_equiv (tree dest, tree src, bool update_range =\nfalse);\n  virtual void register_equivs_edge (edge e);\n  virtual void register_equivs_stmt (gimple *, basic_block,\n\t\t\t\t     class jt_simplifier *);\n  virtual void record_ranges_from_stmt (gimple *stmt, bool temporary);\n  void get_path (vec<basic_block> &);\n  void append_path (basic_block);\n  void dump (FILE *);\n  void debug ();\nprivate:\n  auto_vec<basic_block> m_blocks;\n};\n\nclass jt_simplifier\n{\npublic:\n  virtual ~jt_simplifier () { }\n  virtual tree simplify (gimple *, gimple *, basic_block, jt_state *) =\n0;\n};\n\nThere are no functional changes.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-dom.c (class dom_jump_threader_simplifier): Rename...\n\t(class dom_jt_state): ...this and provide virtual overrides.\n\t(dom_jt_state::register_equiv): New.\n\t(class dom_jt_simplifier): Rename from\n\tdom_jump_threader_simplifier.\n\t(dom_jump_threader_simplifier::simplify): Rename...\n\t(dom_jt_simplifier::simplify): ...to this.\n\t(pass_dominator::execute): Use dom_jt_simplifier and\n\tdom_jt_state.\n\t* tree-ssa-threadedge.c (jump_threader::jump_threader):\n\tClean-up.\n\t(jt_state::register_equivs_stmt): Abstract out...\n\t(jump_threader::record_temporary_equivalences_from_stmts_at_dest):\n\t...from here.\n\t(jump_threader::thread_around_empty_blocks): Update state.\n\t(jump_threader::thread_through_normal_block): Same.\n\t(jt_state::jt_state): Remove.\n\t(jt_state::push): Remove pass specific bits.  Keep block vector\n\tupdated.\n\t(jt_state::append_path): New.\n\t(jt_state::pop): Remove pass specific bits.\n\t(jt_state::register_equiv): Same.\n\t(jt_state::record_ranges_from_stmt): Same.\n\t(jt_state::register_equivs_on_edge): Same.  Rename...\n\t(jt_state::register_equivs_edge):  ...to this.\n\t(jt_state::dump): New.\n\t(jt_state::debug): New.\n\t(jump_threader_simplifier::simplify): Remove.\n\t(jt_state::get_path): New.\n\t* tree-ssa-threadedge.h (class jt_simplifier): Make into a base\n\tclass.  Expose common functionality as virtual methods.\n\t(class jump_threader_simplifier): Same.  Rename...\n\t(class jt_simplifier): ...to this.\n\t* tree-vrp.c (class vrp_jump_threader_simplifier): Rename...\n\t(class vrp_jt_simplifier): ...to this. Provide pass specific\n\toverrides.\n\t(class vrp_jt_state): New.\n\t(vrp_jump_threader_simplifier::simplify): Rename...\n\t(vrp_jt_simplifier::simplify): ...to this.  Inline code from\n\twhat used to be the base class.\n\t(vrp_jump_threader::vrp_jump_threader): Use vrp_jt_state and\n\tvrp_jt_simplifier.", "tree": {"sha": "860a45c2308629979c2118f93a69b4f17d91b6e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/860a45c2308629979c2118f93a69b4f17d91b6e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c0c43623efe2900dd0feb3abf8b611023362c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0c43623efe2900dd0feb3abf8b611023362c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c0c43623efe2900dd0feb3abf8b611023362c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0c43623efe2900dd0feb3abf8b611023362c43/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4777439fc77465b4cf89b6bfeb47cd00329cb20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4777439fc77465b4cf89b6bfeb47cd00329cb20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4777439fc77465b4cf89b6bfeb47cd00329cb20"}], "stats": {"total": 588, "additions": 351, "deletions": 237}, "files": [{"sha": "f58b6b78a4105fcfcf667eb2dfcc25e6f6587ca0", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 120, "deletions": 14, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=4c0c43623efe2900dd0feb3abf8b611023362c43", "patch": "@@ -585,31 +585,137 @@ record_edge_info (basic_block bb)\n     }\n }\n \n-class dom_jump_threader_simplifier : public jump_threader_simplifier\n+class dom_jt_state : public jt_state\n {\n public:\n-  dom_jump_threader_simplifier (vr_values *v,\n-\t\t\t\tavail_exprs_stack *avails)\n-    : jump_threader_simplifier (v), m_avail_exprs_stack (avails) { }\n+  dom_jt_state (const_and_copies *copies, avail_exprs_stack *avails,\n+\t\tevrp_range_analyzer *evrp)\n+    : m_copies (copies), m_avails (avails), m_evrp (evrp)\n+  {\n+  }\n+  void push (edge e) override\n+  {\n+    m_copies->push_marker ();\n+    m_avails->push_marker ();\n+    m_evrp->push_marker ();\n+    jt_state::push (e);\n+  }\n+  void pop () override\n+  {\n+    m_copies->pop_to_marker ();\n+    m_avails->pop_to_marker ();\n+    m_evrp->pop_to_marker ();\n+    jt_state::pop ();\n+  }\n+  void register_equivs_edge (edge e) override\n+  {\n+    record_temporary_equivalences (e, m_copies, m_avails);\n+  }\n+  void record_ranges_from_stmt (gimple *stmt, bool temporary) override\n+  {\n+    m_evrp->record_ranges_from_stmt (stmt, temporary);\n+  }\n+  void register_equiv (tree dest, tree src, bool update) override;\n+private:\n+  const_and_copies *m_copies;\n+  avail_exprs_stack *m_avails;\n+  evrp_range_analyzer *m_evrp;\n+};\n+\n+void\n+dom_jt_state::register_equiv (tree dest, tree src, bool update)\n+{\n+  m_copies->record_const_or_copy (dest, src);\n+\n+  /* If requested, update the value range associated with DST, using\n+     the range from SRC.  */\n+  if (update)\n+    {\n+      /* Get new VR we can pass to push_value_range.  */\n+      value_range_equiv *new_vr = m_evrp->allocate_value_range_equiv ();\n+      new (new_vr) value_range_equiv ();\n+\n+      /* There are three cases to consider:\n+\n+\t First if SRC is an SSA_NAME, then we can copy the value range\n+\t from SRC into NEW_VR.\n+\n+\t Second if SRC is an INTEGER_CST, then we can just set NEW_VR\n+\t to a singleton range.  Note that even if SRC is a constant we\n+\t need to set a suitable output range so that VR_UNDEFINED\n+\t ranges do not leak through.\n+\n+\t Otherwise set NEW_VR to varying.  This may be overly\n+\t conservative.  */\n+      if (TREE_CODE (src) == SSA_NAME)\n+\tnew_vr->deep_copy (m_evrp->get_value_range (src));\n+      else if (TREE_CODE (src) == INTEGER_CST)\n+\tnew_vr->set (src);\n+      else\n+\tnew_vr->set_varying (TREE_TYPE (src));\n+\n+      /* This is a temporary range for DST, so push it.  */\n+      m_evrp->push_value_range (dest, new_vr);\n+    }\n+}\n+\n+class dom_jt_simplifier : public jt_simplifier\n+{\n+public:\n+  dom_jt_simplifier (vr_values *v, avail_exprs_stack *avails)\n+    : m_vr_values (v), m_avails (avails) { }\n \n private:\n   tree simplify (gimple *, gimple *, basic_block, jt_state *) override;\n-  avail_exprs_stack *m_avail_exprs_stack;\n+  vr_values *m_vr_values;\n+  avail_exprs_stack *m_avails;\n };\n \n tree\n-dom_jump_threader_simplifier::simplify (gimple *stmt,\n-\t\t\t\t\tgimple *within_stmt,\n-\t\t\t\t\tbasic_block bb,\n-\t\t\t\t\tjt_state *state)\n+dom_jt_simplifier::simplify (gimple *stmt, gimple *within_stmt,\n+\t\t\t     basic_block, jt_state *)\n {\n   /* First see if the conditional is in the hash table.  */\n-  tree cached_lhs =  m_avail_exprs_stack->lookup_avail_expr (stmt,\n-\t\t\t\t\t\t\t     false, true);\n+  tree cached_lhs =  m_avails->lookup_avail_expr (stmt, false, true);\n   if (cached_lhs)\n     return cached_lhs;\n \n-  return jump_threader_simplifier::simplify (stmt, within_stmt, bb, state);\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    {\n+      simplify_using_ranges simplifier (m_vr_values);\n+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t  gimple_cond_lhs (cond_stmt),\n+\t\t\t\t\t\t  gimple_cond_rhs (cond_stmt),\n+\t\t\t\t\t\t  within_stmt);\n+    }\n+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree op = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      const value_range_equiv *vr = m_vr_values->get_value_range (op);\n+      return find_case_label_range (switch_stmt, vr);\n+    }\n+  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (assign_stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  edge dummy_e;\n+\t  tree dummy_tree;\n+\t  value_range_equiv new_vr;\n+\t  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,\n+\t\t\t\t\t\t&new_vr);\n+\t  tree singleton;\n+\t  if (new_vr.singleton_p (&singleton))\n+\t    return singleton;\n+\t}\n+    }\n+  return NULL;\n }\n \n class dom_opt_dom_walker : public dom_walker\n@@ -752,8 +858,8 @@ pass_dominator::execute (function *fun)\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n   evrp_range_analyzer analyzer (true);\n-  dom_jump_threader_simplifier simplifier (&analyzer, avail_exprs_stack);\n-  jt_state state (const_and_copies, avail_exprs_stack, &analyzer);\n+  dom_jt_simplifier simplifier (&analyzer, avail_exprs_stack);\n+  dom_jt_state state (const_and_copies, avail_exprs_stack, &analyzer);\n   jump_threader threader (&simplifier, &state);\n   dom_opt_dom_walker walker (CDI_DOMINATORS,\n \t\t\t     &threader,"}, {"sha": "ae77e5eb39624c01d2056e986c0da9eabf87cef8", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 139, "deletions": 183, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=4c0c43623efe2900dd0feb3abf8b611023362c43", "patch": "@@ -33,12 +33,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-threadupdate.h\"\n #include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n-#include \"tree-ssa-dom.h\"\n #include \"gimple-fold.h\"\n #include \"cfganal.h\"\n #include \"alloc-pool.h\"\n #include \"vr-values.h\"\n #include \"gimple-ssa-evrp-analyze.h\"\n+#include \"gimple-range.h\"\n \n /* To avoid code explosion due to jump threading, we limit the\n    number of statements we are going to copy.  This variable\n@@ -61,8 +61,7 @@ set_ssa_name_value (tree name, tree value)\n   ssa_name_values[SSA_NAME_VERSION (name)] = value;\n }\n \n-jump_threader::jump_threader (jump_threader_simplifier *simplifier,\n-\t\t\t      jt_state *state)\n+jump_threader::jump_threader (jt_simplifier *simplifier, jt_state *state)\n {\n   /* Initialize the per SSA_NAME value-handles array.  */\n   gcc_assert (!ssa_name_values.exists ());\n@@ -228,8 +227,6 @@ jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)\n      when we're finished processing E.  */\n   for (gsi = gsi_start_bb (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      tree cached_lhs = NULL;\n-\n       stmt = gsi_stmt (gsi);\n \n       /* Ignore empty statements and labels.  */\n@@ -326,75 +323,7 @@ jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)\n \t    continue;\n \t}\n \n-      /* At this point we have a statement which assigns an RHS to an\n-\t SSA_VAR on the LHS.  We want to try and simplify this statement\n-\t to expose more context sensitive equivalences which in turn may\n-\t allow us to simplify the condition at the end of the loop.\n-\n-\t Handle simple copy operations as well as implied copies from\n-\t ASSERT_EXPRs.  */\n-      if (gimple_assign_single_p (stmt)\n-          && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n-\tcached_lhs = gimple_assign_rhs1 (stmt);\n-      else if (gimple_assign_single_p (stmt)\n-               && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n-\tcached_lhs = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n-      else\n-\t{\n-\t  /* A statement that is not a trivial copy or ASSERT_EXPR.\n-\t     Try to fold the new expression.  Inserting the\n-\t     expression into the hash table is unlikely to help.  */\n-\t  /* ???  The DOM callback below can be changed to setting\n-\t     the mprts_hook around the call to thread_across_edge,\n-\t     avoiding the use substitution.  The VRP hook should be\n-\t     changed to properly valueize operands itself using\n-\t     SSA_NAME_VALUE in addition to its own lattice.  */\n-\t  cached_lhs = gimple_fold_stmt_to_constant_1 (stmt,\n-\t\t\t\t\t\t       threadedge_valueize);\n-          if (NUM_SSA_OPERANDS (stmt, SSA_OP_ALL_USES) != 0\n-\t      && (!cached_lhs\n-                  || (TREE_CODE (cached_lhs) != SSA_NAME\n-                      && !is_gimple_min_invariant (cached_lhs))))\n-\t    {\n-\t      /* We're going to temporarily copy propagate the operands\n-\t\t and see if that allows us to simplify this statement.  */\n-\t      tree *copy;\n-\t      ssa_op_iter iter;\n-\t      use_operand_p use_p;\n-\t      unsigned int num, i = 0;\n-\n-\t      num = NUM_SSA_OPERANDS (stmt, SSA_OP_ALL_USES);\n-\t      copy = XALLOCAVEC (tree, num);\n-\n-\t      /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n-\t\t the operands.  */\n-\t      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n-\t\t{\n-\t\t  tree tmp = NULL;\n-\t\t  tree use = USE_FROM_PTR (use_p);\n-\n-\t\t  copy[i++] = use;\n-\t\t  if (TREE_CODE (use) == SSA_NAME)\n-\t\t    tmp = SSA_NAME_VALUE (use);\n-\t\t  if (tmp)\n-\t\t    SET_USE (use_p, tmp);\n-\t\t}\n-\n-\t      cached_lhs = m_simplifier->simplify (stmt, stmt, e->src, m_state);\n-\n-\t      /* Restore the statement's original uses/defs.  */\n-\t      i = 0;\n-\t      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n-\t\tSET_USE (use_p, copy[i++]);\n-\t    }\n-\t}\n-\n-      /* Record the context sensitive equivalence if we were able\n-\t to simplify this statement.  */\n-      if (cached_lhs\n-\t  && (TREE_CODE (cached_lhs) == SSA_NAME\n-\t      || is_gimple_min_invariant (cached_lhs)))\n-\tm_state->register_equiv (gimple_get_lhs (stmt), cached_lhs);\n+      m_state->register_equivs_stmt (stmt, e->src, m_simplifier);\n     }\n   return stmt;\n }\n@@ -899,6 +828,7 @@ jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n \t  if (!bitmap_bit_p (visited, taken_edge->dest->index))\n \t    {\n \t      m_registry->push_edge (path, taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+\t      m_state->append_path (taken_edge->dest);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n \t      return thread_around_empty_blocks (path, taken_edge, visited);\n \t    }\n@@ -940,6 +870,7 @@ jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n       bitmap_set_bit (visited, taken_edge->dest->index);\n \n       m_registry->push_edge (path, taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+      m_state->append_path (taken_edge->dest);\n \n       thread_around_empty_blocks (path, taken_edge, visited);\n       return true;\n@@ -970,7 +901,7 @@ int\n jump_threader::thread_through_normal_block (vec<jump_thread_edge *> *path,\n \t\t\t\t\t    edge e, bitmap visited)\n {\n-  m_state->register_equivs_on_edge (e);\n+  m_state->register_equivs_edge (e);\n \n   /* PHIs create temporary equivalences.\n      Note that if we found a PHI that made the block non-threadable, then\n@@ -1048,6 +979,7 @@ jump_threader::thread_through_normal_block (vec<jump_thread_edge *> *path,\n \t    m_registry->push_edge (path, e, EDGE_START_JUMP_THREAD);\n \n \t  m_registry->push_edge (path, taken_edge, EDGE_COPY_SRC_BLOCK);\n+\t  m_state->append_path (taken_edge->dest);\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n@@ -1290,154 +1222,178 @@ jump_threader::thread_outgoing_edges (basic_block bb)\n     }\n }\n \n-jt_state::jt_state (const_and_copies *copies,\n-\t\t    avail_exprs_stack *exprs,\n-\t\t    evrp_range_analyzer *evrp)\n-{\n-  m_copies = copies;\n-  m_exprs = exprs;\n-  m_evrp = evrp;\n-}\n+// Marker to keep track of the start of the current path.\n+const basic_block jt_state::BB_MARKER = (basic_block) -1;\n \n // Record that E is being crossed.\n \n void\n-jt_state::push (edge)\n+jt_state::push (edge e)\n {\n-  if (m_copies)\n-    m_copies->push_marker ();\n-  if (m_exprs)\n-    m_exprs->push_marker ();\n-  if (m_evrp)\n-    m_evrp->push_marker ();\n+  m_blocks.safe_push (BB_MARKER);\n+  if (m_blocks.length () == 1)\n+    m_blocks.safe_push (e->src);\n+  m_blocks.safe_push (e->dest);\n }\n \n // Pop to the last pushed state.\n \n void\n jt_state::pop ()\n {\n-  if (m_copies)\n-    m_copies->pop_to_marker ();\n-  if (m_exprs)\n-    m_exprs->pop_to_marker ();\n-  if (m_evrp)\n-    m_evrp->pop_to_marker ();\n+  if (!m_blocks.is_empty ())\n+    {\n+      while (m_blocks.last () != BB_MARKER)\n+\tm_blocks.pop ();\n+      // Pop marker.\n+      m_blocks.pop ();\n+    }\n }\n \n-// Record an equivalence from DST to SRC.  If UPDATE_RANGE is TRUE,\n-// update the value range associated with DST.\n+// Add BB to the list of blocks seen.\n \n void\n-jt_state::register_equiv (tree dst, tree src, bool update_range)\n+jt_state::append_path (basic_block bb)\n {\n-  if (m_copies)\n-    m_copies->record_const_or_copy (dst, src);\n+  gcc_checking_assert (!m_blocks.is_empty ());\n+  m_blocks.safe_push (bb);\n+}\n \n-  /* If requested, update the value range associated with DST, using\n-     the range from SRC.  */\n-  if (m_evrp && update_range)\n+void\n+jt_state::dump (FILE *out)\n+{\n+  if (!m_blocks.is_empty ())\n     {\n-      /* Get new VR we can pass to push_value_range.  */\n-      value_range_equiv *new_vr = m_evrp->allocate_value_range_equiv ();\n-      new (new_vr) value_range_equiv ();\n-\n-      /* There are three cases to consider:\n-\n-\t First if SRC is an SSA_NAME, then we can copy the value range\n-\t from SRC into NEW_VR.\n-\n-\t Second if SRC is an INTEGER_CST, then we can just set NEW_VR\n-\t to a singleton range.  Note that even if SRC is a constant we\n-\t need to set a suitable output range so that VR_UNDEFINED\n-\t ranges do not leak through.\n-\n-\t Otherwise set NEW_VR to varying.  This may be overly\n-\t conservative.  */\n-      if (TREE_CODE (src) == SSA_NAME)\n-\tnew_vr->deep_copy (m_evrp->get_value_range (src));\n-      else if (TREE_CODE (src) == INTEGER_CST)\n-\tnew_vr->set (src);\n-      else\n-\tnew_vr->set_varying (TREE_TYPE (src));\n-\n-      /* This is a temporary range for DST, so push it.  */\n-      m_evrp->push_value_range (dst, new_vr);\n+      auto_vec<basic_block> path;\n+      get_path (path);\n+      dump_ranger (out, path);\n     }\n }\n \n-// Record any ranges calculated in STMT.  If TEMPORARY is TRUE, then\n-// this is a temporary equivalence and should be recorded into the\n-// unwind table, instead of the global table.\n+void\n+jt_state::debug ()\n+{\n+  push_dump_file save (stderr, TDF_DETAILS);\n+  dump (stderr);\n+}\n+\n+// Convert the current path in jt_state into a path suitable for the\n+// path solver.  Return the resulting path in PATH.\n \n void\n-jt_state::record_ranges_from_stmt (gimple *stmt, bool temporary)\n+jt_state::get_path (vec<basic_block> &path)\n {\n-  if (m_evrp)\n-    m_evrp->record_ranges_from_stmt (stmt, temporary);\n+  path.truncate (0);\n+\n+  for (int i = (int) m_blocks.length () - 1; i >= 0; --i)\n+    {\n+      basic_block bb = m_blocks[i];\n+\n+      if (bb != BB_MARKER)\n+\tpath.safe_push (bb);\n+    }\n }\n \n-// Record any equivalences created by traversing E.\n+// Record an equivalence from DST to SRC.  If UPDATE_RANGE is TRUE,\n+// update the value range associated with DST.\n \n void\n-jt_state::register_equivs_on_edge (edge e)\n+jt_state::register_equiv (tree dest ATTRIBUTE_UNUSED,\n+\t\t\t  tree src ATTRIBUTE_UNUSED,\n+\t\t\t  bool update_range ATTRIBUTE_UNUSED)\n {\n-  if (m_copies && m_exprs)\n-    record_temporary_equivalences (e, m_copies, m_exprs);\n }\n \n-jump_threader_simplifier::jump_threader_simplifier (vr_values *v)\n+// Record any ranges calculated in STMT.  If TEMPORARY is TRUE, then\n+// this is a temporary equivalence and should be recorded into the\n+// unwind table, instead of the global table.\n+\n+void\n+jt_state::record_ranges_from_stmt (gimple *,\n+\t\t\t\t   bool temporary ATTRIBUTE_UNUSED)\n {\n-  m_vr_values = v;\n }\n \n-// Return the singleton that resolves STMT, if it is possible to\n-// simplify it.\n-//\n-// STMT may be a dummy statement, not necessarily in the CFG, in which\n-// case WITHIN_STMT can be used to determine the position in the CFG\n-// where STMT should be evaluated as being in.\n+// Record any equivalences created by traversing E.\n \n-tree\n-jump_threader_simplifier::simplify (gimple *stmt,\n-\t\t\t\t    gimple *within_stmt,\n-\t\t\t\t    basic_block,\n-\t\t\t\t    jt_state *)\n+void\n+jt_state::register_equivs_edge (edge)\n {\n-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    {\n-      simplify_using_ranges simplifier (m_vr_values);\n-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t  gimple_cond_lhs (cond_stmt),\n-\t\t\t\t\t\t  gimple_cond_rhs (cond_stmt),\n-\t\t\t\t\t\t  within_stmt);\n-    }\n-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n-    {\n-      tree op = gimple_switch_index (switch_stmt);\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn NULL_TREE;\n+}\n \n-      const value_range_equiv *vr = m_vr_values->get_value_range (op);\n-      return find_case_label_range (switch_stmt, vr);\n-    }\n-   if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n+void\n+jt_state::register_equivs_stmt (gimple *stmt, basic_block bb,\n+\t\t\t\tjt_simplifier *simplifier)\n+{\n+  /* At this point we have a statement which assigns an RHS to an\n+     SSA_VAR on the LHS.  We want to try and simplify this statement\n+     to expose more context sensitive equivalences which in turn may\n+     allow us to simplify the condition at the end of the loop.\n+\n+     Handle simple copy operations as well as implied copies from\n+     ASSERT_EXPRs.  */\n+  tree cached_lhs = NULL;\n+  if (gimple_assign_single_p (stmt)\n+      && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n+    cached_lhs = gimple_assign_rhs1 (stmt);\n+  else if (gimple_assign_single_p (stmt)\n+\t   && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n+    cached_lhs = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n+  else\n     {\n-      tree lhs = gimple_assign_lhs (assign_stmt);\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && stmt_interesting_for_vrp (stmt))\n+      /* A statement that is not a trivial copy or ASSERT_EXPR.\n+\t Try to fold the new expression.  Inserting the\n+\t expression into the hash table is unlikely to help.  */\n+      /* ???  The DOM callback below can be changed to setting\n+\t the mprts_hook around the call to thread_across_edge,\n+\t avoiding the use substitution.  The VRP hook should be\n+\t changed to properly valueize operands itself using\n+\t SSA_NAME_VALUE in addition to its own lattice.  */\n+      cached_lhs = gimple_fold_stmt_to_constant_1 (stmt,\n+\t\t\t\t\t\t   threadedge_valueize);\n+      if (NUM_SSA_OPERANDS (stmt, SSA_OP_ALL_USES) != 0\n+\t  && (!cached_lhs\n+\t      || (TREE_CODE (cached_lhs) != SSA_NAME\n+\t\t  && !is_gimple_min_invariant (cached_lhs))))\n \t{\n-\t  edge dummy_e;\n-\t  tree dummy_tree;\n-\t  value_range_equiv new_vr;\n-\t  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,\n-\t\t\t\t\t\t&new_vr);\n-\t  tree singleton;\n-\t  if (new_vr.singleton_p (&singleton))\n-\t    return singleton;\n+\t  /* We're going to temporarily copy propagate the operands\n+\t     and see if that allows us to simplify this statement.  */\n+\t  tree *copy;\n+\t  ssa_op_iter iter;\n+\t  use_operand_p use_p;\n+\t  unsigned int num, i = 0;\n+\n+\t  num = NUM_SSA_OPERANDS (stmt, SSA_OP_ALL_USES);\n+\t  copy = XALLOCAVEC (tree, num);\n+\n+\t  /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n+\t     the operands.  */\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+\t    {\n+\t      tree tmp = NULL;\n+\t      tree use = USE_FROM_PTR (use_p);\n+\n+\t      copy[i++] = use;\n+\t      if (TREE_CODE (use) == SSA_NAME)\n+\t\ttmp = SSA_NAME_VALUE (use);\n+\t      if (tmp)\n+\t\tSET_USE (use_p, tmp);\n+\t    }\n+\n+\t  cached_lhs = simplifier->simplify (stmt, stmt, bb, this);\n+\n+\t  /* Restore the statement's original uses/defs.  */\n+\t  i = 0;\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+\t    SET_USE (use_p, copy[i++]);\n \t}\n     }\n-   return NULL;\n+\n+  /* Record the context sensitive equivalence if we were able\n+     to simplify this statement.  */\n+  if (cached_lhs\n+      && (TREE_CODE (cached_lhs) == SSA_NAME\n+\t  || is_gimple_min_invariant (cached_lhs)))\n+    register_equiv (gimple_get_lhs (stmt), cached_lhs,\n+\t\t    /*update_range=*/false);\n }"}, {"sha": "0b47a52105307c01faa994105941b370f63a0af8", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=4c0c43623efe2900dd0feb3abf8b611023362c43", "patch": "@@ -26,19 +26,31 @@ along with GCC; see the file COPYING3.  If not see\n class jt_state\n {\n public:\n-  jt_state (class const_and_copies *,\n-\t    class avail_exprs_stack *,\n-\t    class evrp_range_analyzer *);\n-  void push (edge);\n-  void pop ();\n-  void register_equiv (tree dest, tree src, bool update_range = false);\n-  void register_equivs_on_edge (edge e);\n-  void record_ranges_from_stmt (gimple *stmt, bool temporary);\n+  virtual ~jt_state () { }\n+  virtual void push (edge);\n+  virtual void pop ();\n+  virtual void register_equiv (tree dest, tree src, bool update_range);\n+  virtual void register_equivs_edge (edge e);\n+  virtual void register_equivs_stmt (gimple *, basic_block,\n+\t\t\t\t     class jt_simplifier *);\n+  virtual void record_ranges_from_stmt (gimple *stmt, bool temporary);\n+  void get_path (vec<basic_block> &);\n+  void append_path (basic_block);\n+  void dump (FILE *);\n+  void debug ();\n \n private:\n-  const_and_copies *m_copies;\n-  avail_exprs_stack *m_exprs;\n-  evrp_range_analyzer *m_evrp;\n+  auto_vec<basic_block> m_blocks;\n+  static const basic_block BB_MARKER;\n+};\n+\n+// Statement simplifier callback for the jump threader.\n+\n+class jt_simplifier\n+{\n+public:\n+  virtual ~jt_simplifier () { }\n+  virtual tree simplify (gimple *, gimple *, basic_block, jt_state *) = 0;\n };\n \n // This is the high level threader.  The entry point is\n@@ -49,7 +61,7 @@ class jt_state\n class jump_threader\n {\n public:\n-  jump_threader (class jump_threader_simplifier *, class jt_state *);\n+  jump_threader (jt_simplifier *, class jt_state *);\n   ~jump_threader ();\n   void thread_outgoing_edges (basic_block);\n   void remove_jump_threads_including (edge_def *);\n@@ -76,23 +88,10 @@ class jump_threader\n   gcond *dummy_cond;\n \n   class fwd_jt_path_registry *m_registry;\n-  jump_threader_simplifier *m_simplifier;\n+  jt_simplifier *m_simplifier;\n   jt_state *m_state;\n };\n \n-// Statement simplifier callback for the jump threader.\n-\n-class jump_threader_simplifier\n-{\n-public:\n-  jump_threader_simplifier (class vr_values *v);\n-  virtual ~jump_threader_simplifier () { }\n-  virtual tree simplify (gimple *, gimple *, basic_block, jt_state *);\n-\n-protected:\n-  vr_values *m_vr_values;\n-};\n-\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n extern bool single_succ_to_potentially_threadable_block (basic_block);\n "}, {"sha": "a5079ee48aa46ad9948aba7d672781046369ce18", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c0c43623efe2900dd0feb3abf8b611023362c43/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4c0c43623efe2900dd0feb3abf8b611023362c43", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"range-op.h\"\n #include \"value-range-equiv.h\"\n #include \"gimple-array-bounds.h\"\n+#include \"tree-ssa-dom.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -4160,28 +4161,63 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n   return simplifier.simplify (si);\n }\n \n-class vrp_jump_threader_simplifier : public jump_threader_simplifier\n+class vrp_jt_state : public jt_state\n {\n public:\n-  vrp_jump_threader_simplifier (vr_values *v, avail_exprs_stack *avails)\n-    : jump_threader_simplifier (v), m_avail_exprs_stack (avails) { }\n+  vrp_jt_state (const_and_copies *copies, avail_exprs_stack *avails)\n+    : m_copies (copies), m_avails (avails)\n+  {\n+  }\n+  void push (edge e) override\n+  {\n+    m_copies->push_marker ();\n+    m_avails->push_marker ();\n+    jt_state::push (e);\n+  }\n+  void pop () override\n+  {\n+    m_copies->pop_to_marker ();\n+    m_avails->pop_to_marker ();\n+    jt_state::pop ();\n+  }\n+  void register_equiv (tree dest, tree src, bool) override\n+  {\n+    m_copies->record_const_or_copy (dest, src);\n+  }\n+  void register_equivs_edge (edge e) override\n+  {\n+    record_temporary_equivalences (e, m_copies, m_avails);\n+  }\n+  void record_ranges_from_stmt (gimple *, bool) override\n+  {\n+  }\n+private:\n+  const_and_copies *m_copies;\n+  avail_exprs_stack *m_avails;\n+};\n+\n+class vrp_jt_simplifier : public jt_simplifier\n+{\n+public:\n+  vrp_jt_simplifier (vr_values *v, avail_exprs_stack *avails)\n+    : m_vr_values (v), m_avail_exprs_stack (avails) { }\n \n private:\n-  tree simplify (gimple *, gimple *, basic_block, jt_state *) OVERRIDE;\n+  tree simplify (gimple *, gimple *, basic_block, jt_state *) override;\n+  vr_values *m_vr_values;\n   avail_exprs_stack *m_avail_exprs_stack;\n };\n \n tree\n-vrp_jump_threader_simplifier::simplify (gimple *stmt,\n-\t\t\t\t\tgimple *within_stmt,\n-\t\t\t\t\tbasic_block bb,\n-\t\t\t\t\tjt_state *state)\n+vrp_jt_simplifier::simplify (gimple *stmt, gimple *within_stmt,\n+\t\t\t     basic_block bb, jt_state *)\n {\n   /* First see if the conditional is in the hash table.  */\n   tree cached_lhs = m_avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n   if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n     return cached_lhs;\n \n+  /* Next see if we can solve it with VRP's internal structures.  */\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n       tree op0 = gimple_cond_lhs (cond_stmt);\n@@ -4194,7 +4230,6 @@ vrp_jump_threader_simplifier::simplify (gimple *stmt,\n       return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n \t\t\t\t\t\t  op0, op1, within_stmt);\n     }\n-\n   if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n     {\n       tree op = gimple_switch_index (switch_stmt);\n@@ -4207,7 +4242,26 @@ vrp_jump_threader_simplifier::simplify (gimple *stmt,\n       return find_case_label_range (switch_stmt, vr);\n     }\n \n-  return jump_threader_simplifier::simplify (stmt, within_stmt, bb, state);\n+  /* Finally, try vr_values.  */\n+  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (assign_stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  edge dummy_e;\n+\t  tree dummy_tree;\n+\t  value_range_equiv new_vr;\n+\t  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,\n+\t\t\t\t\t\t&new_vr);\n+\t  tree singleton;\n+\t  if (new_vr.singleton_p (&singleton))\n+\t    return singleton;\n+\t}\n+    }\n+  return NULL;\n }\n \n /* Blocks which have more than one predecessor and more than\n@@ -4256,7 +4310,7 @@ class vrp_jump_threader : public dom_walker\n   const_and_copies *m_const_and_copies;\n   avail_exprs_stack *m_avail_exprs_stack;\n   hash_table<expr_elt_hasher> *m_avail_exprs;\n-  vrp_jump_threader_simplifier *m_simplifier;\n+  vrp_jt_simplifier *m_simplifier;\n   jump_threader *m_threader;\n   jt_state *m_state;\n };\n@@ -4284,10 +4338,9 @@ vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n   m_vr_values = v;\n   m_avail_exprs = new hash_table<expr_elt_hasher> (1024);\n   m_avail_exprs_stack = new avail_exprs_stack (m_avail_exprs);\n-  m_state = new jt_state (m_const_and_copies, m_avail_exprs_stack, NULL);\n+  m_state = new vrp_jt_state (m_const_and_copies, m_avail_exprs_stack);\n \n-  m_simplifier = new vrp_jump_threader_simplifier (m_vr_values,\n-\t\t\t\t\t\t   m_avail_exprs_stack);\n+  m_simplifier = new vrp_jt_simplifier (m_vr_values, m_avail_exprs_stack);\n   m_threader = new jump_threader (m_simplifier, m_state);\n }\n "}]}