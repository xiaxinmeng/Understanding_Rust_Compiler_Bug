{"sha": "30c0e2df8c68f8cda6d51c71ed945cd151ead94d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjMGUyZGY4YzY4ZjhjZGE2ZDUxYzcxZWQ5NDVjZDE1MWVhZDk0ZA==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-08-24T09:56:48Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-08-24T09:56:48Z"}, "message": "(offset_is_register): New variable\n\n(offset_is_register): New variable\n        (forwarding_offset): Use apply_args_register_offset to get\n        register offset.\n        (encode_method_def, encode_method_prototype): Prepend argument\n        offset by '+' if passed in register.\n        (apply_args_register_offset): Added declaration.\n(generate_method_descriptors, generate_ivar_lists,\n        generate_dispatch_tables): Reorganized use of constructors.\n        (build_descriptor_table_initializer, build_ivar_list_initializer,\n        build_dispatch_table_initializer): Removed argument `int *size'.\n\nFrom-SVN: r5199", "tree": {"sha": "60089e5f77cad5996c41c4f95b545f7628eebdf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60089e5f77cad5996c41c4f95b545f7628eebdf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c0e2df8c68f8cda6d51c71ed945cd151ead94d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c0e2df8c68f8cda6d51c71ed945cd151ead94d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c0e2df8c68f8cda6d51c71ed945cd151ead94d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c0e2df8c68f8cda6d51c71ed945cd151ead94d/comments", "author": null, "committer": null, "parents": [{"sha": "fb2ca25a9d578674144a76548fc4f90187a5ca03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2ca25a9d578674144a76548fc4f90187a5ca03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb2ca25a9d578674144a76548fc4f90187a5ca03"}], "stats": {"total": 154, "additions": 86, "deletions": 68}, "files": [{"sha": "7db3d88db88355e61d1b97adc48800f354d64087", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 86, "deletions": 68, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c0e2df8c68f8cda6d51c71ed945cd151ead94d/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c0e2df8c68f8cda6d51c71ed945cd151ead94d/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=30c0e2df8c68f8cda6d51c71ed945cd151ead94d", "patch": "@@ -174,6 +174,9 @@ static tree init_selector\t\t\tPROTO((int));\n static tree build_keyword_selector\t\tPROTO((tree));\n static tree synth_id_with_class_suffix\t\tPROTO((char *, tree));\n \n+/* from expr.c */\n+extern int apply_args_register_offset           PROTO((int));\n+\n /* misc. bookkeeping */\n \n typedef struct hashed_entry \t*hash;\n@@ -265,7 +268,7 @@ static tree build_class_reference_decl\t\tPROTO((tree));\n static void add_class_reference\t\t\tPROTO((tree));\n static tree objc_copy_list\t\t\tPROTO((tree, tree *));\n static tree build_protocol_template\t\tPROTO((void));\n-static tree build_descriptor_table_initializer\tPROTO((tree, tree, int *));\n+static tree build_descriptor_table_initializer\tPROTO((tree, tree));\n static tree build_method_prototype_list_template PROTO((tree, int));\n static tree build_method_prototype_template\tPROTO((void));\n static int forwarding_offset\t\t\tPROTO((tree));\n@@ -279,9 +282,9 @@ static void generate_protocols\t\t\tPROTO((void));\n static void check_ivars\t\t\t\tPROTO((tree, tree));\n static tree build_ivar_list_template\t\tPROTO((tree, int));\n static tree build_method_list_template\t\tPROTO((tree, int));\n-static tree build_ivar_list_initializer\t\tPROTO((tree, tree, int *));\n+static tree build_ivar_list_initializer\t\tPROTO((tree, tree));\n static tree generate_ivars_list\t\t\tPROTO((tree, char *, int, tree));\n-static tree build_dispatch_table_initializer\tPROTO((tree, tree, int *));\n+static tree build_dispatch_table_initializer\tPROTO((tree, tree));\n static tree generate_dispatch_table\t\tPROTO((tree, char *, int, tree));\n static tree build_shared_structure_initializer\tPROTO((tree, tree, tree, tree, tree, int, tree, tree, tree));\n static void generate_category\t\t\tPROTO((tree));\n@@ -2218,25 +2221,26 @@ build_protocol_template ()\n }\n \n static tree\n-build_descriptor_table_initializer (type, entries, size)\n+build_descriptor_table_initializer (type, entries)\n      tree type;\n      tree entries;\n-     int *size;\n {\n   tree initlist = NULLT;\n \n   do\n     {\n-      initlist = tree_cons (NULLT, build_selector (METHOD_SEL_NAME (entries)), initlist);\n+      tree eltlist = NULLT;\n+\n+      eltlist = tree_cons (NULLT, build_selector (METHOD_SEL_NAME (entries)), NULLT);\n+      eltlist = tree_cons (NULLT, add_objc_string (METHOD_ENCODING (entries), meth_var_types), eltlist);\n \n-      initlist = tree_cons (NULLT, add_objc_string (METHOD_ENCODING (entries), meth_var_types), initlist);\n+      initlist = tree_cons (NULLT, build_constructor (type, nreverse (eltlist)), initlist);\n \n-      (*size)++;\n       entries = TREE_CHAIN (entries);\n     }\n   while (entries);\n \n-  return build_constructor (type, nreverse (initlist));\n+  return build_constructor (build_array_type (type, 0), nreverse (initlist));\n }\n \n /* struct objc_method_prototype_list {\n@@ -2314,6 +2318,9 @@ build_method_prototype_template ()\n   return proto_record;\n }\n \n+/* True if last call to forwarding_offset yielded a register offset */\n+static int offset_is_register;\n+\n static int\n forwarding_offset (parm)\n       tree parm;\n@@ -2335,16 +2342,14 @@ forwarding_offset (parm)\n \toffset_in_bytes = 0;\n \n       offset_in_bytes += OBJC_FORWARDING_STACK_OFFSET;\n+      offset_is_register = 0;\n     }\n-#ifdef OBJC_FORWARDING_REG_OFFSET\n   else if (GET_CODE (DECL_INCOMING_RTL (parm)) == REG)\n     {\n       int regno = REGNO (DECL_INCOMING_RTL (parm));\n-\n-      offset_in_bytes = 4 * (regno - OBJC_FORWARDING_FIRST_REG)\n-\t\t\t+ OBJC_FORWARDING_REG_OFFSET;\n+      offset_in_bytes = apply_args_register_offset (regno);\n+      offset_is_register = 1;\n     }\n-#endif /* OBJC_FORWARDING_REG_OFFSET */\n   else\n     return 0;\n \n@@ -2391,7 +2396,7 @@ encode_method_prototype (method_decl, func_decl)\n \t\t      + (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (parms)))\n \t\t\t / BITS_PER_UNIT));\n \n-      if (parm_end > max_parm_end)\n+      if (!offset_is_register && max_parm_end < parm_end)\n \tmax_parm_end = parm_end;\n     }\n \n@@ -2420,6 +2425,11 @@ encode_method_prototype (method_decl, func_decl)\n \n       /* compute offset */\n       sprintf (buf, \"%d\", forwarding_offset (parms));\n+\n+      /* indicate register */\n+      if (offset_is_register)\n+\tobstack_1grow (&util_obstack, '+');\n+      \n       obstack_grow (&util_obstack, buf, strlen (buf));\n     }\n \n@@ -2474,17 +2484,15 @@ generate_method_descriptors (protocol)\t/* generate_dispatch_tables */\n   chain = PROTOCOL_CLS_METHODS (protocol);\n   if (chain)\n     {\n-      tree field;\n-\n-      size = 0;\n+      size = list_length (chain);\n \n       method_list_template\n \t= build_method_prototype_list_template (objc_method_prototype_template,\n \t\t\t\t\t\tsize);\n \n-      field = TREE_CHAIN (TYPE_FIELDS (method_list_template));\n-      initlist = build_descriptor_table_initializer (TREE_TYPE (field),\n-\t\t\t\t\t\t     chain, &size);\n+      initlist \n+\t= build_descriptor_table_initializer (objc_method_prototype_template,\n+\t\t\t\t\t      chain);\n \n       UOBJC_CLASS_METHODS_decl\n \t= generate_descriptor_table (method_list_template,\n@@ -2499,16 +2507,14 @@ generate_method_descriptors (protocol)\t/* generate_dispatch_tables */\n   chain = PROTOCOL_NST_METHODS (protocol);\n   if (chain)\n     {\n-      tree field;\n-\n-      size = 0;\n+      size = list_length (chain);\n \n       method_list_template\n \t= build_method_prototype_list_template (objc_method_prototype_template,\n \t\t\t\t\t\tsize);\n-      field = TREE_CHAIN (TYPE_FIELDS (method_list_template));\n-      initlist = build_descriptor_table_initializer (TREE_TYPE (field),\n-\t\t\t\t\t\t     chain, &size);\n+      initlist\n+\t= build_descriptor_table_initializer (objc_method_prototype_template,\n+\t\t\t\t\t      chain);\n \n       UOBJC_INSTANCE_METHODS_decl\n \t= generate_descriptor_table (method_list_template,\n@@ -3218,52 +3224,57 @@ build_method_list_template (list_type, size)\n }\n \n static tree\n-build_ivar_list_initializer (type, field_decl, size)\n+build_ivar_list_initializer (type, field_decl)\n      tree type;\n      tree field_decl;\n-     int *size;\n {\n   tree initlist = NULLT;\n \n   do\n     {\n+      tree ivar = NULLT;\n+\n       /* set name */\n       if (DECL_NAME (field_decl))\n-\tinitlist = tree_cons (NULLT,\n-\t\t\t      add_objc_string (DECL_NAME (field_decl),\n-\t\t\t\t\t       meth_var_names),\n-\t\t\t      initlist);\n+\tivar = tree_cons (NULLT,\n+\t\t\t  add_objc_string (DECL_NAME (field_decl),\n+\t\t\t\t\t   meth_var_names),\n+\t\t\t  ivar);\n       else\n \t/* unnamed bit-field ivar (yuck). */\n-\tinitlist = tree_cons (NULLT, build_int_2 (0, 0), initlist);\n+\tivar = tree_cons (NULLT, build_int_2 (0, 0), ivar);\n \n       /* set type */\n       encode_field_decl (field_decl,\n \t\t\t obstack_object_size (&util_obstack),\n \t\t\t OBJC_ENCODE_DONT_INLINE_DEFS);\n       obstack_1grow (&util_obstack, 0);    /* null terminate string */\n-      initlist\n+      ivar\n \t= tree_cons\n \t  (NULLT,\n \t   add_objc_string (get_identifier (obstack_finish (&util_obstack)),\n \t\t\t    meth_var_types),\n-\t   initlist);\n+\t   ivar);\n       obstack_free (&util_obstack, util_firstobj);\n \n       /* set offset */\n-      initlist\n+      ivar\n \t= tree_cons\n \t  (NULLT,\n \t   build_int_2 ((TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field_decl))\n \t\t\t / BITS_PER_UNIT),\n \t\t\t0),\n-\t   initlist);\n-      (*size)++;\n+\t   ivar);\n+\n+      initlist = tree_cons (NULLT, \n+\t\t\t    build_constructor (type, nreverse (ivar)),\n+\t\t\t    initlist);\n+\n       field_decl = TREE_CHAIN (field_decl);\n     }\n   while (field_decl);\n \n-  return build_constructor (type, nreverse (initlist));\n+  return build_constructor (build_array_type (type, 0), nreverse (initlist));\n }\n \n static tree\n@@ -3317,10 +3328,10 @@ generate_ivar_lists ()\n   if (CLASS_SUPER_NAME (implementation_template) == NULLT\n       && (chain = TYPE_FIELDS (objc_class_template)))\n     {\n-      size = 0;\n+      size = list_length (chain);\n+\n       ivar_list_template = build_ivar_list_template (objc_ivar_template, size);\n-      initlist = build_ivar_list_initializer (ivar_list_template,\n-\t\t\t\t\t      chain, &size);\n+      initlist = build_ivar_list_initializer (objc_ivar_template, chain);\n \n       UOBJC_CLASS_VARIABLES_decl\n \t= generate_ivars_list (ivar_list_template, \"_OBJC_CLASS_VARIABLES\",\n@@ -3334,10 +3345,9 @@ generate_ivar_lists ()\n   chain = CLASS_IVARS (implementation_template);\n   if (chain)\n     {\n-      size = 0;\n+      size = list_length (chain);\n       ivar_list_template = build_ivar_list_template (objc_ivar_template, size);\n-      initlist = build_ivar_list_initializer (ivar_list_template,\n-\t\t\t\t\t      chain, &size);\n+      initlist = build_ivar_list_initializer (objc_ivar_template, chain);\n \n       UOBJC_INSTANCE_VARIABLES_decl\n \t= generate_ivars_list (ivar_list_template, \"_OBJC_INSTANCE_VARIABLES\",\n@@ -3352,39 +3362,45 @@ generate_ivar_lists ()\n }\n \n static tree\n-build_dispatch_table_initializer (type, entries, size)\n+build_dispatch_table_initializer (type, entries)\n      tree type;\n      tree entries;\n-     int *size;\n {\n   tree initlist = NULLT;\n \n   do\n     {\n-      initlist = tree_cons (NULLT, build_selector (METHOD_SEL_NAME (entries)),\n-\t\t\t    initlist);\n+      tree elemlist = NULLT;\n+\n+      elemlist = tree_cons (NULLT, build_selector (METHOD_SEL_NAME (entries)),\n+\t\t\t    NULLT);\n \n-      initlist = tree_cons (NULLT, add_objc_string (METHOD_ENCODING (entries),\n+      elemlist = tree_cons (NULLT, add_objc_string (METHOD_ENCODING (entries),\n \t\t\t\t\t\t    meth_var_types),\n-\t\t\t    initlist);\n+\t\t\t    elemlist);\n \n-      initlist = tree_cons (NULLT, METHOD_DEFINITION (entries), initlist);\n+      elemlist = tree_cons (NULLT, \n+\t\t\t    build_unary_op (ADDR_EXPR, METHOD_DEFINITION (entries), 1),\n+\t\t\t    elemlist);\n+\n+      initlist = tree_cons (NULLT, \n+\t\t\t    build_constructor (type, nreverse (elemlist)),\n+\t\t\t    initlist);\n \n-      (*size)++;\n       entries = TREE_CHAIN (entries);\n     }\n   while (entries);\n \n-  return build_constructor (type, nreverse (initlist));\n+  return build_constructor (build_array_type (type, 0), nreverse (initlist));\n }\n \n /* To accomplish method prototyping without generating all kinds of\n    inane warnings, the definition of the dispatch table entries were\n    changed from:\n \n-   \tstruct objc_method { SEL _cmd; id (*_imp)(); };\n+   \tstruct objc_method { SEL _cmd; ...; id (*_imp)(); };\n    to:\n-   \tstruct objc_method { SEL _cmd; void *_imp; };  */\n+   \tstruct objc_method { SEL _cmd; ...; void *_imp; };  */\n \n static tree\n build_method_template ()\n@@ -3476,12 +3492,10 @@ generate_dispatch_tables ()\n   chain = CLASS_CLS_METHODS (implementation_context);\n   if (chain)\n     {\n-      size = 0;\n+      size = list_length (chain);\n \n-      method_list_template = build_method_list_template (objc_method_template,\n-\t\t\t\t\t\t\t size);\n-      initlist = build_dispatch_table_initializer (method_list_template,\n-\t\t\t\t\t\t   chain, &size);\n+      method_list_template = build_method_list_template (objc_method_template, size);\n+      initlist = build_dispatch_table_initializer (objc_method_template, chain);\n \n       UOBJC_CLASS_METHODS_decl\n \t= generate_dispatch_table (method_list_template,\n@@ -3499,12 +3513,11 @@ generate_dispatch_tables ()\n   chain = CLASS_NST_METHODS (implementation_context);\n   if (chain)\n     {\n-      size = 0;\n+      size = list_length (chain);\n+\n+      method_list_template = build_method_list_template (objc_method_template, size);\n+      initlist = build_dispatch_table_initializer (objc_method_template, chain);\n \n-      method_list_template = build_method_list_template (objc_method_template,\n-\t\t\t\t\t\t\t size);\n-      initlist = build_dispatch_table_initializer (method_list_template,\n-\t\t\t\t\t\t   chain, &size);\n       if (TREE_CODE (implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n \tUOBJC_INSTANCE_METHODS_decl\n \t  = generate_dispatch_table (method_list_template,\n@@ -6598,7 +6611,7 @@ encode_method_def (func_decl)\n \t\t      + (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (parms)))\n \t\t\t / BITS_PER_UNIT));\n \n-      if (parm_end > max_parm_end)\n+      if (!offset_is_register && parm_end > max_parm_end)\n \tmax_parm_end = parm_end;\n     }\n \n@@ -6618,6 +6631,11 @@ encode_method_def (func_decl)\n \n       /* compute offset */\n       sprintf (buffer, \"%d\", forwarding_offset (parms));\n+\n+      /* indicate register */\n+      if (offset_is_register)\n+\tobstack_1grow (&util_obstack, '+');\n+\n       obstack_grow (&util_obstack, buffer, strlen (buffer));\n     }\n "}]}