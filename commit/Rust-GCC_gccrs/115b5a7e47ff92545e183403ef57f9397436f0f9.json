{"sha": "115b5a7e47ff92545e183403ef57f9397436f0f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE1YjVhN2U0N2ZmOTI1NDVlMTgzNDAzZWY1N2Y5Mzk3NDM2ZjBmOQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-02-28T03:26:44Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-02-28T03:26:44Z"}, "message": "basic_file.h: Include basic_file_model.h.\n\n\n2001-02-27  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/1886\n\t* include/bits/basic_file.h: Include basic_file_model.h.\n\t* config/c_io_libio.cc: Move to...\n\t* config/basic_file_libio.cc: Here.\n\t* config/basic_file_libio.h: New file.\n\t* config/c_io_stdio.cc: Move to...\n\t* config/basic_file_stdio.cc: Here.\n\t* config/basic_file_stdio.h: New file.\n\t* config/c_io_libio.h: Tweak.\n\t* config/c_io_stdio.h: Tweak.\n\t* src/Makefile.am (build_headers): Add basic_file_model.h.\n\t(sources): Add basic_file.cc, remove c++io.cc.\n\t* src/Makefile.in: Regenerate.\n\t* acinclude.m4 (GLIBCPP_ENABLE_CSTDIO): Add support for\n\tbasic_file_model.h and basic_file.cc.\n\t* aclocal.m4: Regenerate.\n\t* configure: Regenerate.\n\t* testsuite/27_io/filebuf.cc (test05): Add regression.\n\nFrom-SVN: r40109", "tree": {"sha": "478bb88dff675e3cfb683f3ab6a26470d95035d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/478bb88dff675e3cfb683f3ab6a26470d95035d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/115b5a7e47ff92545e183403ef57f9397436f0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115b5a7e47ff92545e183403ef57f9397436f0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115b5a7e47ff92545e183403ef57f9397436f0f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115b5a7e47ff92545e183403ef57f9397436f0f9/comments", "author": null, "committer": null, "parents": [{"sha": "c0a26060f6beada90faba59760b0e38916666835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0a26060f6beada90faba59760b0e38916666835", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0a26060f6beada90faba59760b0e38916666835"}], "stats": {"total": 716, "additions": 0, "deletions": 716}, "files": [{"sha": "1747ddb3e6d0beeb2dfde8900a1d832a8a98199c", "filename": "libstdc++-v3/config/c_io_libio.cc", "status": "removed", "additions": 0, "deletions": 447, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0a26060f6beada90faba59760b0e38916666835/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0a26060f6beada90faba59760b0e38916666835/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc?ref=c0a26060f6beada90faba59760b0e38916666835", "patch": "@@ -1,447 +0,0 @@\n-// Wrapper of C-language FILE struct -*- C++ -*-\n-\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//\n-// ISO C++ 14882: 27.8  File-based streams\n-//\n-\n-#include <bits/basic_file.h>\n-#include <libioP.h>\n-\n-namespace std {\n-\n-  // __basic_file<char> specializations\n-  template<>\n-    __basic_file<char>::__basic_file(__c_lock* __lock);\n-\n-  template<>\n-    int \n-    __basic_file<char>::overflow(int __c);\n-\n-  template<>\n-    int \n-    __basic_file<char>::underflow();\n-\n-  template<>\n-    int \n-    __basic_file<char>::uflow();\n-\n-  template<>\n-    int \n-    __basic_file<char>::pbackfail(int __c);\n-\n-  template<>\n-    streamsize \n-    __basic_file<char>::xsputn(const char* __s, streamsize __n);\n-\n-  template<>\n-    streamoff\n-    __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\tios_base::openmode __mode);\n-\n-  template<>\n-    streamoff\n-    __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode);\n-\n-  template<>\n-    streambuf* \n-    __basic_file<char>::setbuf(char* __b, int __len);\n-\n-  template<>\n-    int \n-    __basic_file<char>::sync();\n-\n-  template<>\n-    int \n-    __basic_file<char>::doallocate();\n-\n-  // __basic_file<wchar_t> specializations\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    __basic_file<wchar_t>::__basic_file(__c_lock* __lock);\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::overflow(int __c);\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::underflow();\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::uflow();\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::pbackfail(int __c);\n-\n-  template<>\n-    streamsize \n-    __basic_file<wchar_t>::xsputn(const wchar_t* __s, streamsize __n);\n-\n-  template<>\n-    streamoff\n-    __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\tios_base::openmode __mode);\n-\n-  template<>\n-    streamoff\n-    __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode);\n-\n-  template<>\n-    streambuf* \n-    __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len);\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::sync();\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::doallocate();\n-#endif\n-\n-  // Generic definitions for __basic_file\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::get_fileno(void)\n-    { return _fileno; }\n- \n-  template<typename _CharT>\n-    __basic_file<_CharT>::~__basic_file()\n-    { _IO_file_finish(this, 0); }\n-      \n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::_M_open_mode(ios_base::openmode __mode, \n-\t\t\t\t       int& __p_mode, int& __rw_mode, \n-\t\t\t\t       char* /*__c_mode*/)\n-    {  \n-#ifdef O_BINARY\n-      bool __testb = __mode & ios_base::binary;\n-#endif\n-      bool __testi = __mode & ios_base::in;\n-      bool __testo = __mode & ios_base::out;\n-      bool __testt = __mode & ios_base::trunc;\n-      bool __testa = __mode & ios_base::app;\n-      \n-      if (!__testi && __testo && !__testt && !__testa)\n-\t{\n-\t  __p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n-\t  __rw_mode = _IO_NO_READS;\n-\t}\n-      if (!__testi && __testo && !__testt && __testa)\n-\t{\n-\t  __p_mode = O_WRONLY | O_APPEND | O_CREAT;\n-\t  __rw_mode = _IO_NO_READS | _IO_IS_APPENDING;\n-\t}\n-      if (!__testi && __testo && __testt && !__testa)\n-\t{\n-\t  __p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n-\t  __rw_mode = _IO_NO_READS;\n-\t}\n-      if (__testi && !__testo && !__testt && !__testa)\n-\t{\n-\t  __p_mode = O_RDONLY;\n-\t  __rw_mode = _IO_NO_WRITES;\n-\t}\n-      if (__testi && __testo && !__testt && !__testa)\n-\t{\n-\t  __p_mode = O_RDWR;\n-\t  __rw_mode = 0;\n-\t}\n-      if (__testi && __testo && __testt && !__testa)\n-\t{\n-\t  __p_mode = O_RDWR | O_TRUNC | O_CREAT;\n-\t  __rw_mode = 0;\n-\t}\n-#ifdef O_BINARY\n-      if (__testb)\n-\t__p_mode |= O_BINARY;\n-#endif\t   \n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>*\n-    __basic_file<_CharT>::sys_open(int __fd, ios_base::openmode __mode) \n-    {\n-      __basic_file* __ret = NULL;\n-      int __p_mode = 0;\n-      int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n-      char __c_mode[4];\n-      \n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-\n-      if (!_IO_file_is_open(this))\n-\t{\n-\t  _fileno = __fd;\n-\t  _flags &= ~(_IO_NO_READS+_IO_NO_WRITES);\n-\t  _flags |= _IO_DELETE_DONT_CLOSE;\n-\t  _offset = _IO_pos_BAD;\n-\t  int __mask = _IO_NO_READS + _IO_NO_WRITES + _IO_IS_APPENDING;\n-\t  _IO_mask_flags(this, __rw_mode, __mask);\n-\t}\n-\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::open(const char* __name, ios_base::openmode __mode, \n-\t\t\t       int __prot)\n-    {\n-      __basic_file* __ret = NULL;\n-      int __p_mode = 0;\n-      int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n-      char __c_mode[4];\n-\n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-      if (!_IO_file_is_open(this))\n-\t{\n-\t  __c_file_type* __f;\n-\t  __f = _IO_file_open(this, __name, __p_mode, __prot, __rw_mode, 0);\n-\t  __ret = __f ? this: NULL;\n-\t}\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-    bool \n-    __basic_file<_CharT>::is_open() { return _fileno >= 0; }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::close()\n-    { \n-      return _IO_file_close_it(this) ? static_cast<__basic_file*>(NULL) : this;\n-    }\n- \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::xsgetn(_CharT* __s, streamsize __n)\n-    { return _IO_file_xsgetn(this, __s, __n); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_read(_CharT* __s, streamsize __n) \n-    { return _IO_file_read(this, __s, __n); }\n-\n-  // NB: Unused.    \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_write(const _CharT* __s, streamsize __n) \n-    { return _IO_file_write(this, __s, __n); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::sys_seek(streamoff __pos, ios_base::seekdir __way)\n-    { return _IO_file_seek(this, __pos, __way); }\n-  \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_close() \n-    { return _IO_file_close(this); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_stat(void* __v) \n-    { return _IO_file_stat(this, __v); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::showmanyc() { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::imbue(void* /*__v*/) { }\n-\n-  // __basic_file<char> definitions\n-  __basic_file<char>::__basic_file(__c_lock* __lock)\n-  {\n-#ifdef _IO_MTSAFE_IO\n-    _lock = __lock;\n-#endif\n-    // Don't set the orientation of the stream when initializing.\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _IO_no_init(this, 0, 0, &_M_wfile, 0);\n-#else /* !defined(_GLIBCPP_USE_WCHAR_T) */\n-    _IO_no_init(this, 0, 0, NULL, 0);\n-#endif /* !defined(_GLIBCPP_USE_WCHAR_T) */\n-    _IO_JUMPS((_IO_FILE_plus *) this) = &_IO_file_jumps;\n-    _IO_file_init((_IO_FILE_plus*)this);\n-  }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::overflow(int __c) \n-  { return _IO_file_overflow(this, __c); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::underflow()  \n-  { return _IO_file_underflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::uflow()  \n-  { return _IO_default_uflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::pbackfail(int __c) \n-  { return _IO_default_pbackfail(this, __c); }\n- \n-  streamsize \n-  __basic_file<char>::xsputn(const char* __s, streamsize __n)\n-  { return _IO_file_xsputn(this, __s, __n); }\n-\n-  streamoff\n-  __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t      ios_base::openmode __mode)\n-  { return _IO_file_seekoff(this, __off, __way, __mode); }\n-\n-  streamoff\n-  __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode)\n-  { return _IO_file_seekoff(this, __pos, ios_base::beg, __mode); }\n-\n- // NB: Unused.\n-  streambuf* \n-  __basic_file<char>::setbuf(char* __b, int __len)\n-  { return (streambuf*) _IO_file_setbuf(this,__b, __len); }\n-\n- int \n-  __basic_file<char>::sync()\n-  { return _IO_file_sync(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::doallocate() \n-  { return _IO_file_doallocate(this); }\n-\n-  // __basic_file<wchar_t> definitions\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  __basic_file<wchar_t>::__basic_file(__c_lock* __lock)\n-  {\n-#ifdef _IO_MTSAFE_IO\n-    _lock = __lock;\n-#endif\n-    // Don't set the orientation of the stream when initializing.\n-    _IO_no_init(this, 0, 0, &_M_wfile, &_IO_wfile_jumps);\n-    _IO_JUMPS((_IO_FILE_plus *) this) = &_IO_wfile_jumps;\n-    _IO_file_init((_IO_FILE_plus*)this);\n-\n-    // In addition, need to allocate the buffer...\n-    _IO_wdoallocbuf(this);\n-    // Setup initial positions for this buffer...\n-    //    if (!(_flags & _IO_NO_READS))\n-    _IO_wsetg(this, _wide_data->_IO_buf_base, _wide_data->_IO_buf_base,\n-\t      _wide_data->_IO_buf_base);\n-    //    if (!(_flags & _IO_NO_WRITES))\n-    _IO_wsetp(this, _wide_data->_IO_buf_base, _wide_data->_IO_buf_base);\n-    \n-    // Setup codecvt bits...\n-    _codecvt = &__c_libio_codecvt;\n-    \n-    // Do the same for narrow bits...\n-    if (_IO_write_base == NULL)\n-      {\n-\t_IO_doallocbuf(this);\n-\t//      if (!(_flags & _IO_NO_READS))\n-\t_IO_setg(this, _IO_buf_base, _IO_buf_base, _IO_buf_base);\n-\t//    if (!(_flags & _IO_NO_WRITES))\n-\t_IO_setp(this, _IO_buf_base, _IO_buf_base);\n-      }\n-  }\n-\n- int \n-  __basic_file<wchar_t>::overflow(int __c) \n-  { return _IO_wfile_overflow(this, __c); }\n-\n-  int \n-  __basic_file<wchar_t>::underflow()  \n-  { return _IO_wfile_underflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<wchar_t>::uflow()  \n-  { return _IO_wdefault_uflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<wchar_t>::pbackfail(int __c) \n-  { return _IO_wdefault_pbackfail(this, __c); }\n-\n-  streamsize \n-  __basic_file<wchar_t>::xsputn(const wchar_t* __s, streamsize __n)\n-  { return _IO_wfile_xsputn(this, __s, __n); }\n-  \n-  streamoff\n-  __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\t ios_base::openmode __mode)\n-  { return _IO_wfile_seekoff(this, __off, __way, __mode); }\n-\n-  streamoff\n-  __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode)\n-  { return _IO_wfile_seekoff(this, __pos, ios_base::beg, __mode); }\n-\n-   streambuf* \n-  __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len)\n-  { return (streambuf*) _IO_wfile_setbuf(this,__b, __len); }\n-\n-   int \n-  __basic_file<wchar_t>::sync()\n-  { return _IO_wfile_sync(this); }\n-\n-  int \n-  __basic_file<wchar_t>::doallocate() \n-  { return _IO_wfile_doallocate(this); }\n-#endif\n-\n-  // Need to instantiate base class here for type-info bits, etc\n-  template struct __basic_file_base<char>;\n-  template class __basic_file<char>;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template struct __basic_file_base<wchar_t>;\n-  template class __basic_file<wchar_t>;\n-#endif\n-}  // namespace std\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "c9ac7705c5562e81c0106261271d8154cea54715", "filename": "libstdc++-v3/config/c_io_stdio.cc", "status": "removed", "additions": 0, "deletions": 269, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0a26060f6beada90faba59760b0e38916666835/libstdc%2B%2B-v3%2Fconfig%2Fc_io_stdio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0a26060f6beada90faba59760b0e38916666835/libstdc%2B%2B-v3%2Fconfig%2Fc_io_stdio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_io_stdio.cc?ref=c0a26060f6beada90faba59760b0e38916666835", "patch": "@@ -1,269 +0,0 @@\n-// Wrapper of C-language FILE struct -*- C++ -*-\n-\n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//\n-// ISO C++ 14882: 27.8  File-based streams\n-//\n-\n-#include <bits/basic_file.h>\n-#include <unistd.h>\n-\n-namespace std {\n-\n-  // Generic definitions for __basic_file\n-  template<typename _CharT>\n-    __basic_file<_CharT>::__basic_file(__c_lock* /*__lock*/) \n-    : _M_fileno(-1), _M_cfile(NULL) { }\n-\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::get_fileno(void)\n-    { return _M_fileno; }\n- \n-  template<typename _CharT>\n-    __basic_file<_CharT>::~__basic_file()\n-    {\n-      if (this->is_open())\n-\t{\n-\t  fflush(_M_cfile);\n-\t  this->close();\n-\t}\n-    }\n-      \n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::_M_open_mode(ios_base::openmode __mode, \n-\t\t\t\t       int& /*__p_mode*/, int& /*__rw_mode*/, \n-\t\t\t\t       char* __c_mode)\n-    {  \n-      bool __testb = __mode & ios_base::binary;\n-      bool __testi = __mode & ios_base::in;\n-      bool __testo = __mode & ios_base::out;\n-      bool __testt = __mode & ios_base::trunc;\n-      bool __testa = __mode & ios_base::app;\n-      \n-      if (!__testi && __testo && !__testt && !__testa)\n-\tstrcpy(__c_mode, \"w\");\n-      if (!__testi && __testo && !__testt && __testa)\n-\tstrcpy(__c_mode, \"a\");\n-      if (!__testi && __testo && __testt && !__testa)\n-\tstrcpy(__c_mode, \"w\");\n-      if (__testi && !__testo && !__testt && !__testa)\n-\tstrcpy(__c_mode, \"r\");\n-      if (__testi && __testo && !__testt && !__testa)\n-\tstrcpy(__c_mode, \"r+\");\n-      if (__testi && __testo && __testt && !__testa)\n-\tstrcpy(__c_mode, \"w+\");\n-      if (__testb)\n-\tstrcat(__c_mode, \"b\");\n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>*\n-    __basic_file<_CharT>::sys_open(int __fd, ios_base::openmode __mode) \n-    {\n-      __basic_file* __ret = NULL;\n-      int __p_mode = 0;\n-      int __rw_mode = 0;\n-      char __c_mode[4];\n-\n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-\n-      int __dupfd = dup(__fd);\n-\n-      if (__dupfd != -1 && !this->is_open())\n-\t{\n-\t  if ((_M_cfile = fdopen(__dupfd, __c_mode)))\n-\t    {\n-\t      _M_fileno = __dupfd;\n-\t      __ret = this;\n-\t    }\n-\t}\n-\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::open(const char* __name, ios_base::openmode __mode, \n-\t\t\t       int /*__prot*/)\n-    {\n-      __basic_file* __ret = NULL;\n-      int __p_mode = 0;\n-      int __rw_mode = 0;\n-      char __c_mode[4];\n-      \n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-\n-      if (!this->is_open())\n-\t{\n-\t  if ((_M_cfile = fopen(__name, __c_mode)))\n-\t    {\n-\t      _M_fileno = fileno(_M_cfile);\n-\t      __ret = this;\n-\t    }\n-\t}\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-    bool \n-    __basic_file<_CharT>::is_open() { return _M_fileno >= 0; }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::close()\n-    { \n-      __basic_file* __retval = static_cast<__basic_file*>(NULL);\n-      bool __testopen = fclose(_M_cfile);\n-      if (!__testopen)\n-\t{\n-\t  __retval = this;\n-\t  _M_fileno = -1;\n-\t}  \n-      return __retval;\n-    }\n- \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::xsgetn(_CharT* __s, streamsize __n)\n-    { return fread(__s, 1, __n, _M_cfile); }\n-\n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::xsputn(const _CharT* __s, streamsize __n)\n-    { return fwrite(__s, 1, __n, _M_cfile); }\n- \n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\t  ios_base::openmode /*__mode*/)\n-    { fseek(_M_cfile, __off, __way); return ftell(_M_cfile); }\n-\n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::seekpos(streamoff __pos, \n-\t\t\t\t  ios_base::openmode /*__mode*/)\n-    { fseek(_M_cfile, __pos, ios_base::beg); return ftell(_M_cfile); }\n-\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sync()\n-    { return fflush(_M_cfile); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::overflow(int /*__c*/) \n-    { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::underflow()  \n-    { return EOF; } \n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::uflow()  \n-    { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::pbackfail(int /*__c*/) \n-    { return EOF; } \n- \n- // NB: Unused.\n-  template<typename _CharT>\n-    streambuf* \n-    __basic_file<_CharT>::setbuf(_CharT* /*__b*/, int /*__len*/)\n-    { return reinterpret_cast<streambuf*>(this); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::doallocate() \n-    { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_read(_CharT* __s, streamsize __n) \n-    { return fread(__s, 1, __n, _M_cfile); }\n-\n-  // NB: Unused.    \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_write(const _CharT* __s, streamsize __n) \n-    { return fwrite(__s, 1, __n, _M_cfile); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::sys_seek(streamoff __pos, ios_base::seekdir __way)\n-    { \n-      fseek(_M_cfile, __pos, __way); \n-      return ftell(_M_cfile); \n-    }\n-  \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_close() \n-    { return fclose(_M_cfile); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_stat(void* /*__v*/) \n-    { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::showmanyc() \n-    { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::imbue(void* /*__v*/) { }\n-\n-  // Need to instantiate base class here for type-info bits, etc\n-  template struct __basic_file_base<char>;\n-  template class __basic_file<char>;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template struct __basic_file_base<wchar_t>;\n-  template class __basic_file<wchar_t>;\n-#endif\n-}  // namespace std\n-\n-"}]}