{"sha": "fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVhOWU5NTZlYzFiM2UxYjk1Zjc5ZTQ0MzA5Y2ZhOTMzMTRkZGJjZQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:19:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:19:23Z"}, "message": "errout.adb (Unwind_Internal_Type): Use predicate Is_Access__Protected_Subprogram_Type.\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* errout.adb (Unwind_Internal_Type): Use predicate\n\tIs_Access__Protected_Subprogram_Type.\n\n\t* freeze.adb (Size_Known): Use First/Next_Component_Or_Discriminant\n\t(Freeze_Entity, packed array case): Do not override explicitly set\n\talignment and size clauses.\n\t(Freeze_Entity):  An entity declared in an outer scope can be frozen if\n\tthe enclosing subprogram is a child unit body that acts as a spec.\n\t(Freeze_Entity): Use new predicate Is_Access_Protected_Subprogram_Type.\n\t(Freeze_Record_Type): New Ada 2005 processing for reverse bit order\n\tRemove all code for DSP option\n\n\t* layout.adb (Layout_Record_Type): Use First/\n\tNext_Component_Or_Discriminant\n\t(Layout_Type): Use new predicate Is_Access_Protected_Subprogram_Type,\n\tto handle properly the anonymous access case.\n\n\t* sem_attr.adb (Build_Access_Object_Type): Use E_Access_Attribute_Type\n\tfor all access attributes, because overload resolution should work the\n\tsame for 'Access, 'Unchecked_Access, and 'Unrestricted_Access. This\n\tcauses the error message for the ambiguous \"X'Access = Y'Access\" and\n\t\"X'Unrestricted_Access = Y'Access\" and so forth to match.\n\t(Resolve_Attribute, case 'Access): Remove use of Original_Access_Type,\n\tnow that anonymous access to protected operations have their own kind.\n\t(Resolve_Attribute): In case of dispatching call check the violation of\n\trestriction No_Dispatching_Calls.\n\t(Check_Array_Type): Check new -gnatyA array index style option\n\n\t* sem_ch3.ads, sem_ch3.adb (Derived_Type_Declaration): Reject an\n\tattempt to derive from a synchronized tagged type.\n\t(Analyze_Type_Declaration): If there is a incomplete tagged view of the\n\ttype, inherit the class-wide type already created, because it may\n\talready have been used in a self-referential anonymous access component.\n\t(Mentions_T): Recognize self-referential anonymous access components\n\tthat use (a subtype of) the class-wide type of the enclosing type.\n\t(Build_Derived_Record_Type): Add earlier setting of Is_Tagged_Type. Pass\n\tDerived_Type for Prev formal on call to\n\tCheck_Anonymous_Access_Components rather than Empty.\n\t(Make_Incomplete_Type_Declaration): Add test for case where the type has\n\ta record extension in deciding whether to create a class-wide type,\n\trather than just checking Tagged_Present.\n\t(Replace_Anonymous_Access_To_Protected_Subprogram): Procedure applies\n\tto stand-alone object declarations as well as component declarations.\n\t(Array_Type_Declaration): Initialize Packed_Array_Type to Empty, to\n\tprevent accidental overwriting when enclosing package appears in\n\ta limited_with_clause.\n\t(Array_Type_Declaration): If the component type is an anonymous access,\n\tthe associated_node for the itype is the type declaration itself.\n\t(Add_Interface_Tag_Components): Modified to support concurrent\n\ttypes with abstract interfaces.\n\t(Check_Abstract_Interfaces): New subprogram that verifies the ARM\n\trules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2).\n\t(Build_Derived_Record_Type): Add call to Analyze_Interface_Declaration\n\tto complete the decoration of synchronized interface types. Add also\n\ta call to Check_Abstract_Interfaces to verify the ARM rules.\n\t(Derive_Interface_Subprograms): Modified to support concurrent types\n\twith abstract interfaces.\n\t(Analyze_Subtype_Indication): Resolve the range with the given subtype\n\tmark, rather than delaying the full resolution depending on context.\n\t(Analyze_Component_Declaration,Analyze_Interface_Declaration,\n\tAnalyze_Object_Declaration,Analyze_Subtype_Declaration,\n\tArray_Type_Declaration,Build_Derived_Record_Type,\n\tBuild_Discriminated_Subtype,Check_Abstract_Overriding,Check_Completion,\n\tDerive_Interface_Subprograms,Derive_Subprogram,Make_Class_Wide_Type,\n\tProcess_Full_View,Record_Type_Declaration): Split Is_Abstract flag into\n\tIs_Abstract_Subprogram and Is_Abstract_Type. Make sure these are\n\tcalled only when appropriate.\n\t(Copy_And_Swap): Copy Has_Unreferenced_Objects flag from full type\n\tto private type.\n\t(Analyze_Subtype_Declaration): For an access subtype declaration, create\n\tan itype reference for the anonymous designated subtype, to prevent\n\tscope anonmalies in gigi.\n\t(Build_Itype_Reference): New utility, to simplify construction of such\n\treferences.\n\nFrom-SVN: r123559", "tree": {"sha": "9f5d781e78737728fca3d5a3b4e8bb2eb23708d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f5d781e78737728fca3d5a3b4e8bb2eb23708d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f937473fe94fce0786cf2a69337f402c49cb20e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f937473fe94fce0786cf2a69337f402c49cb20e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f937473fe94fce0786cf2a69337f402c49cb20e5"}], "stats": {"total": 1963, "additions": 1171, "deletions": 792}, "files": [{"sha": "6e05ec93f34633a5ac3f688c8dab404048a9ea7d", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "patch": "@@ -2706,7 +2706,7 @@ package body Errout is\n          if Is_Access_Type (Ent) then\n             if Ekind (Ent) = E_Access_Subprogram_Type\n               or else Ekind (Ent) = E_Anonymous_Access_Subprogram_Type\n-              or else Ekind (Ent) = E_Access_Protected_Subprogram_Type\n+              or else Is_Access_Protected_Subprogram_Type (Ent)\n             then\n                Ent := Directly_Designated_Type (Ent);\n "}, {"sha": "f7876bafa8602882ddc75789a1a89d09c7abfab9", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 147, "deletions": 161, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "patch": "@@ -727,144 +727,132 @@ package body Freeze is\n \n                --  Loop through components\n \n-               Comp := First_Entity (T);\n+               Comp := First_Component_Or_Discriminant (T);\n                while Present (Comp) loop\n-                  if Ekind (Comp) = E_Component\n-                       or else\n-                     Ekind (Comp) = E_Discriminant\n-                  then\n-                     Ctyp := Etype (Comp);\n+                  Ctyp := Etype (Comp);\n \n-                     --  We do not know the packed size if there is a\n-                     --  component clause present (we possibly could,\n-                     --  but this would only help in the case of a record\n-                     --  with partial rep clauses. That's because in the\n-                     --  case of full rep clauses, the size gets figured\n-                     --  out anyway by a different circuit).\n+                  --  We do not know the packed size if there is a component\n+                  --  clause present (we possibly could, but this would only\n+                  --  help in the case of a record with partial rep clauses.\n+                  --  That's because in the case of full rep clauses, the\n+                  --  size gets figured out anyway by a different circuit).\n \n-                     if Present (Component_Clause (Comp)) then\n-                        Packed_Size_Known := False;\n-                     end if;\n+                  if Present (Component_Clause (Comp)) then\n+                     Packed_Size_Known := False;\n+                  end if;\n \n-                     --  We need to identify a component that is an array\n-                     --  where the index type is an enumeration type with\n-                     --  non-standard representation, and some bound of the\n-                     --  type depends on a discriminant.\n-\n-                     --  This is because gigi computes the size by doing a\n-                     --  substituation of the appropriate discriminant value\n-                     --  in the size expression for the base type, and gigi\n-                     --  is not clever enough to evaluate the resulting\n-                     --  expression (which involves a call to rep_to_pos)\n-                     --  at compile time.\n-\n-                     --  It would be nice if gigi would either recognize that\n-                     --  this expression can be computed at compile time, or\n-                     --  alternatively figured out the size from the subtype\n-                     --  directly, where all the information is at hand ???\n-\n-                     if Is_Array_Type (Etype (Comp))\n-                       and then Present (Packed_Array_Type (Etype (Comp)))\n-                     then\n-                        declare\n-                           Ocomp  : constant Entity_Id :=\n-                                      Original_Record_Component (Comp);\n-                           OCtyp  : constant Entity_Id := Etype (Ocomp);\n-                           Ind    : Node_Id;\n-                           Indtyp : Entity_Id;\n-                           Lo, Hi : Node_Id;\n+                  --  We need to identify a component that is an array where\n+                  --  the index type is an enumeration type with non-standard\n+                  --  representation, and some bound of the type depends on a\n+                  --  discriminant.\n \n-                        begin\n-                           Ind := First_Index (OCtyp);\n-                           while Present (Ind) loop\n-                              Indtyp := Etype (Ind);\n+                  --  This is because gigi computes the size by doing a\n+                  --  substituation of the appropriate discriminant value in\n+                  --  the size expression for the base type, and gigi is not\n+                  --  clever enough to evaluate the resulting expression (which\n+                  --  involves a call to rep_to_pos) at compile time.\n \n-                              if Is_Enumeration_Type (Indtyp)\n-                                and then Has_Non_Standard_Rep (Indtyp)\n-                              then\n-                                 Lo := Type_Low_Bound  (Indtyp);\n-                                 Hi := Type_High_Bound (Indtyp);\n-\n-                                 if Is_Entity_Name (Lo)\n-                                   and then\n-                                     Ekind (Entity (Lo)) = E_Discriminant\n-                                 then\n-                                    return False;\n-\n-                                 elsif Is_Entity_Name (Hi)\n-                                   and then\n-                                     Ekind (Entity (Hi)) = E_Discriminant\n-                                 then\n-                                    return False;\n-                                 end if;\n-                              end if;\n+                  --  It would be nice if gigi would either recognize that\n+                  --  this expression can be computed at compile time, or\n+                  --  alternatively figured out the size from the subtype\n+                  --  directly, where all the information is at hand ???\n \n-                              Next_Index (Ind);\n-                           end loop;\n-                        end;\n-                     end if;\n+                  if Is_Array_Type (Etype (Comp))\n+                    and then Present (Packed_Array_Type (Etype (Comp)))\n+                  then\n+                     declare\n+                        Ocomp  : constant Entity_Id :=\n+                                   Original_Record_Component (Comp);\n+                        OCtyp  : constant Entity_Id := Etype (Ocomp);\n+                        Ind    : Node_Id;\n+                        Indtyp : Entity_Id;\n+                        Lo, Hi : Node_Id;\n \n-                     --  Clearly size of record is not known if the size of\n-                     --  one of the components is not known.\n+                     begin\n+                        Ind := First_Index (OCtyp);\n+                        while Present (Ind) loop\n+                           Indtyp := Etype (Ind);\n \n-                     if not Size_Known (Ctyp) then\n-                        return False;\n-                     end if;\n+                           if Is_Enumeration_Type (Indtyp)\n+                             and then Has_Non_Standard_Rep (Indtyp)\n+                           then\n+                              Lo := Type_Low_Bound  (Indtyp);\n+                              Hi := Type_High_Bound (Indtyp);\n \n-                     --  Accumulate packed size if possible\n+                              if Is_Entity_Name (Lo)\n+                                and then Ekind (Entity (Lo)) = E_Discriminant\n+                              then\n+                                 return False;\n \n-                     if Packed_Size_Known then\n+                              elsif Is_Entity_Name (Hi)\n+                                and then Ekind (Entity (Hi)) = E_Discriminant\n+                              then\n+                                 return False;\n+                              end if;\n+                           end if;\n \n-                        --  We can only deal with elementary types, since for\n-                        --  non-elementary components, alignment enters into\n-                        --  the picture, and we don't know enough to handle\n-                        --  proper alignment in this context. Packed arrays\n-                        --  count as elementary if the representation is a\n-                        --  modular type.\n+                           Next_Index (Ind);\n+                        end loop;\n+                     end;\n+                  end if;\n \n-                        if Is_Elementary_Type (Ctyp)\n-                          or else (Is_Array_Type (Ctyp)\n-                                     and then\n-                                       Present (Packed_Array_Type (Ctyp))\n-                                     and then\n-                                       Is_Modular_Integer_Type\n-                                         (Packed_Array_Type (Ctyp)))\n-                        then\n-                           --  If RM_Size is known and static, then we can\n-                           --  keep accumulating the packed size.\n+                  --  Clearly size of record is not known if the size of\n+                  --  one of the components is not known.\n \n-                           if Known_Static_RM_Size (Ctyp) then\n+                  if not Size_Known (Ctyp) then\n+                     return False;\n+                  end if;\n \n-                              --  A little glitch, to be removed sometime ???\n-                              --  gigi does not understand zero sizes yet.\n+                  --  Accumulate packed size if possible\n \n-                              if RM_Size (Ctyp) = Uint_0 then\n-                                 Packed_Size_Known := False;\n+                  if Packed_Size_Known then\n \n-                              --  Normal case where we can keep accumulating\n-                              --  the packed array size.\n+                     --  We can only deal with elementary types, since for\n+                     --  non-elementary components, alignment enters into the\n+                     --  picture, and we don't know enough to handle proper\n+                     --  alignment in this context. Packed arrays count as\n+                     --  elementary if the representation is a modular type.\n \n-                              else\n-                                 Packed_Size := Packed_Size + RM_Size (Ctyp);\n-                              end if;\n+                     if Is_Elementary_Type (Ctyp)\n+                       or else (Is_Array_Type (Ctyp)\n+                                and then Present (Packed_Array_Type (Ctyp))\n+                                and then Is_Modular_Integer_Type\n+                                           (Packed_Array_Type (Ctyp)))\n+                     then\n+                        --  If RM_Size is known and static, then we can\n+                        --  keep accumulating the packed size.\n \n-                           --  If we have a field whose RM_Size is not known\n-                           --  then we can't figure out the packed size here.\n+                        if Known_Static_RM_Size (Ctyp) then\n \n-                           else\n+                           --  A little glitch, to be removed sometime ???\n+                           --  gigi does not understand zero sizes yet.\n+\n+                           if RM_Size (Ctyp) = Uint_0 then\n                               Packed_Size_Known := False;\n+\n+                           --  Normal case where we can keep accumulating the\n+                           --  packed array size.\n+\n+                           else\n+                              Packed_Size := Packed_Size + RM_Size (Ctyp);\n                            end if;\n \n-                        --  If we have a non-elementary type we can't figure\n-                        --  out the packed array size (alignment issues).\n+                        --  If we have a field whose RM_Size is not known then\n+                        --  we can't figure out the packed size here.\n \n                         else\n                            Packed_Size_Known := False;\n                         end if;\n+\n+                     --  If we have a non-elementary type we can't figure out\n+                     --  the packed array size (alignment issues).\n+\n+                     else\n+                        Packed_Size_Known := False;\n                      end if;\n                   end if;\n \n-                  Next_Entity (Comp);\n+                  Next_Component_Or_Discriminant (Comp);\n                end loop;\n \n                if Packed_Size_Known then\n@@ -1627,9 +1615,9 @@ package body Freeze is\n                   end if;\n \n                   --  If component clause is present, then deal with the\n-                  --  non-default bit order case. We cannot do this before\n-                  --  the freeze point, because there is no required order\n-                  --  for the component clause and the bit_order clause.\n+                  --  non-default bit order case for Ada 95 mode. The required\n+                  --  processing for Ada 2005 mode is handled separately after\n+                  --  processing all components.\n \n                   --  We only do this processing for the base type, and in\n                   --  fact that's important, since otherwise if there are\n@@ -1639,6 +1627,7 @@ package body Freeze is\n                   if Present (CC)\n                     and then Reverse_Bit_Order (Rec)\n                     and then Ekind (E) = E_Record_Type\n+                    and then Ada_Version <= Ada_95\n                   then\n                      declare\n                         CFB : constant Uint    := Component_Bit_Offset (Comp);\n@@ -1693,7 +1682,9 @@ package body Freeze is\n                         else\n                            --  Give warning if suspicious component clause\n \n-                           if Intval (FB) >= System_Storage_Unit then\n+                           if Intval (FB) >= System_Storage_Unit\n+                             and then Warn_On_Reverse_Bit_Order\n+                           then\n                               Error_Msg_N\n                                 (\"?Bit_Order clause does not affect \" &\n                                  \"byte ordering\", Pos);\n@@ -1762,20 +1753,20 @@ package body Freeze is\n                   S : Entity_Id := Scope (Rec);\n \n                begin\n-                  --  We have a pretty bad kludge here. Suppose Rec is a\n-                  --  subtype being defined in a subprogram that's created\n-                  --  as part of the freezing of Rec'Base. In that case,\n-                  --  we know that Comp'Base must have already been frozen by\n-                  --  the time we get to elaborate this because Gigi doesn't\n-                  --  elaborate any bodies until it has elaborated all of the\n-                  --  declarative part. But Is_Frozen will not be  set at this\n-                  --  point because we are processing code in lexical order.\n-\n-                  --  We detect this case by going up the Scope chain of\n-                  --  Rec and seeing if we have a subprogram scope before\n-                  --  reaching the top of the scope chain or that of Comp'Base.\n-                  --  If we do, then mark that Comp'Base will actually be\n-                  --  frozen. If so, we merely undelay it.\n+                  --  We have a pretty bad kludge here. Suppose Rec is subtype\n+                  --  being defined in a subprogram that's created as part of\n+                  --  the freezing of Rec'Base. In that case, we know that\n+                  --  Comp'Base must have already been frozen by the time we\n+                  --  get to elaborate this because Gigi doesn't elaborate any\n+                  --  bodies until it has elaborated all of the declarative\n+                  --  part. But Is_Frozen will not be set at this point because\n+                  --  we are processing code in lexical order.\n+\n+                  --  We detect this case by going up the Scope chain of Rec\n+                  --  and seeing if we have a subprogram scope before reaching\n+                  --  the top of the scope chain or that of Comp'Base. If we\n+                  --  do, then mark that Comp'Base will actually be frozen. If\n+                  --  so, we merely undelay it.\n \n                   while Present (S) loop\n                      if Is_Subprogram (S) then\n@@ -1873,12 +1864,23 @@ package body Freeze is\n             Next_Entity (Comp);\n          end loop;\n \n-         --  Check for useless pragma Bit_Order\n+         --  Deal with pragma Bit_Order\n+\n+         if Reverse_Bit_Order (Rec) and then Base_Type (Rec) = Rec then\n+            if not Placed_Component then\n+               ADC :=\n+                 Get_Attribute_Definition_Clause (Rec, Attribute_Bit_Order);\n+               Error_Msg_N\n+                 (\"?Bit_Order specification has no effect\", ADC);\n+               Error_Msg_N\n+                 (\"\\?since no component clauses were specified\", ADC);\n+\n+            --  Here is where we do Ada 2005 processing for bit order (the\n+            --  Ada 95 case was already taken care of above).\n \n-         if not Placed_Component and then Reverse_Bit_Order (Rec) then\n-            ADC := Get_Attribute_Definition_Clause (Rec, Attribute_Bit_Order);\n-            Error_Msg_N (\"?Bit_Order specification has no effect\", ADC);\n-            Error_Msg_N (\"\\?since no component clauses were specified\", ADC);\n+            elsif Ada_Version >= Ada_05 then\n+               Adjust_Record_For_Reverse_Bit_Order (Rec);\n+            end if;\n          end if;\n \n          --  Check for useless pragma Pack when all components placed. We only\n@@ -2017,6 +2019,8 @@ package body Freeze is\n       --  must be diagnosed (see e.g. 1522-005). If the enclosing subprogram\n       --  comes from source, or is a generic instance, then the freeze point\n       --  is the one mandated by the language. and we freze the entity.\n+      --  A subprogram that is a child unit body that acts as a spec does not\n+      --  have a spec that comes from source, but can only come from source.\n \n       elsif In_Open_Scopes (Scope (Test_E))\n         and then Scope (Test_E) /= Current_Scope\n@@ -2030,6 +2034,7 @@ package body Freeze is\n                if Is_Overloadable (S) then\n                   if Comes_From_Source (S)\n                     or else Is_Generic_Instance (S)\n+                    or else Is_Child_Unit (S)\n                   then\n                      exit;\n                   else\n@@ -2320,17 +2325,6 @@ package body Freeze is\n                Freeze_And_Append (Alias (E), Loc, Result);\n             end if;\n \n-            --  If the return type requires a transient scope, and we are on\n-            --  a target allowing functions to return with a depressed stack\n-            --  pointer, then we mark the function as requiring this treatment.\n-\n-            if Ekind (E) = E_Function\n-              and then Functions_Return_By_DSP_On_Target\n-              and then Requires_Transient_Scope (Etype (E))\n-            then\n-               Set_Function_Returns_With_DSP (E);\n-            end if;\n-\n             if not Is_Internal (E) then\n                Freeze_Subprogram (E);\n             end if;\n@@ -2766,10 +2760,17 @@ package body Freeze is\n                   Freeze_And_Append (Packed_Array_Type (E), Loc, Result);\n \n                   --  Size information of packed array type is copied to the\n-                  --  array type, since this is really the representation.\n+                  --  array type, since this is really the representation. But\n+                  --  do not override explicit existing size values.\n+\n+                  if not Has_Size_Clause (E) then\n+                     Set_Esize     (E, Esize     (Packed_Array_Type (E)));\n+                     Set_RM_Size   (E, RM_Size   (Packed_Array_Type (E)));\n+                  end if;\n \n-                  Set_Size_Info (E, Packed_Array_Type (E));\n-                  Set_RM_Size   (E, RM_Size (Packed_Array_Type (E)));\n+                  if not Has_Alignment_Clause (E) then\n+                     Set_Alignment (E, Alignment (Packed_Array_Type (E)));\n+                  end if;\n                end if;\n \n                --  For non-packed arrays set the alignment of the array\n@@ -2993,16 +2994,6 @@ package body Freeze is\n                Next_Formal (Formal);\n             end loop;\n \n-            --  If the return type requires a transient scope, and we are on\n-            --  a target allowing functions to return with a depressed stack\n-            --  pointer, then we mark the function as requiring this treatment.\n-\n-            if Functions_Return_By_DSP_On_Target\n-              and then Requires_Transient_Scope (Etype (E))\n-            then\n-               Set_Function_Returns_With_DSP (E);\n-            end if;\n-\n             Freeze_Subprogram (E);\n \n             --  Ada 2005 (AI-326): Check wrong use of tag incomplete type\n@@ -3022,7 +3013,7 @@ package body Freeze is\n          --  (however this is not set if we are not generating code or if this\n          --  is an anonymous type used just for resolution).\n \n-         elsif Ekind (E) = E_Access_Protected_Subprogram_Type then\n+         elsif Is_Access_Protected_Subprogram_Type (E) then\n \n             --  AI-326: Check wrong use of tagged incomplete types\n \n@@ -3192,10 +3183,6 @@ package body Freeze is\n                if Is_Concurrent_Type (Aux_E)\n                  and then Present (Corresponding_Record_Type (Aux_E))\n                then\n-                  pragma Assert (not Is_Empty_Elmt_List\n-                                       (Abstract_Interfaces\n-                                        (Corresponding_Record_Type (Aux_E))));\n-\n                   Prim_List := Primitive_Operations\n                                 (Corresponding_Record_Type (Aux_E));\n                else\n@@ -4458,7 +4445,6 @@ package body Freeze is\n \n          elsif Is_Record_Type (Typ) then\n             C := First_Entity (Typ);\n-\n             while Present (C) loop\n                if Ekind (C) = E_Discriminant\n                  or else Ekind (C) = E_Component"}, {"sha": "22ef17d2e557cd293dd47a7f2ddf168e06059e73", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "patch": "@@ -2252,12 +2252,9 @@ package body Layout is\n \n          Prev_Comp := Empty;\n \n-         Comp := First_Entity (E);\n+         Comp := First_Component_Or_Discriminant (E);\n          while Present (Comp) loop\n-            if (Ekind (Comp) = E_Component\n-                 or else Ekind (Comp) = E_Discriminant)\n-              and then Present (Component_Clause (Comp))\n-            then\n+            if Present (Component_Clause (Comp)) then\n                if No (Prev_Comp)\n                  or else\n                    Component_Bit_Offset (Comp) >\n@@ -2267,7 +2264,7 @@ package body Layout is\n                end if;\n             end if;\n \n-            Next_Entity (Comp);\n+            Next_Component_Or_Discriminant (Comp);\n          end loop;\n \n          --  We have two separate circuits, one for non-variant records and\n@@ -2336,7 +2333,7 @@ package body Layout is\n          --  backend figure out what is needed (it may be some kind\n          --  of fat pointer, including the static link for example.\n \n-         elsif Ekind (E) = E_Access_Protected_Subprogram_Type then\n+         elsif Is_Access_Protected_Subprogram_Type (E) then\n             null;\n \n          --  For access subtypes, copy the size information from base type"}, {"sha": "ffae61ba96715858978c3ba0a40e2c9d88fb1eea", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 87, "deletions": 36, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "patch": "@@ -58,6 +58,8 @@ with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Stringt;  use Stringt;\n+with Style;\n+with Stylesw;  use Stylesw;\n with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n with Ttypef;   use Ttypef;\n@@ -353,19 +355,10 @@ package body Sem_Attr is\n          ------------------------------\n \n          function Build_Access_Object_Type (DT : Entity_Id) return Entity_Id is\n-            Typ : Entity_Id;\n-\n+            Typ : constant Entity_Id :=\n+                    New_Internal_Entity\n+                      (E_Access_Attribute_Type, Current_Scope, Loc, 'A');\n          begin\n-            if Aname = Name_Unrestricted_Access then\n-               Typ :=\n-                 New_Internal_Entity\n-                   (E_Allocator_Type, Current_Scope, Loc, 'A');\n-            else\n-               Typ :=\n-                 New_Internal_Entity\n-                   (E_Access_Attribute_Type, Current_Scope, Loc, 'A');\n-            end if;\n-\n             Set_Etype                     (Typ, Typ);\n             Init_Size_Align               (Typ);\n             Set_Is_Itype                  (Typ);\n@@ -841,6 +834,12 @@ package body Sem_Attr is\n                Error_Attr (\"invalid dimension number for array type\", E1);\n             end if;\n          end if;\n+\n+         if (Style_Check and Style_Check_Array_Attribute_Index)\n+           and then Comes_From_Source (N)\n+         then\n+            Style.Check_Array_Attribute_Index (N, E1, D);\n+         end if;\n       end Check_Array_Type;\n \n       -------------------------\n@@ -1394,7 +1393,7 @@ package body Sem_Attr is\n \n          --  Note: the double call to Root_Type here is needed because the\n          --  root type of a class-wide type is the corresponding type (e.g.\n-         --  X for X'Class, and we really want to go to the root.\n+         --  X for X'Class, and we really want to go to the root.)\n \n          if not Is_Access_Type (Etyp)\n            or else Root_Type (Root_Type (Designated_Type (Etyp))) /=\n@@ -1900,7 +1899,28 @@ package body Sem_Attr is\n \n             begin\n                if Is_Subprogram (Ent) then\n-                  if not Is_Library_Level_Entity (Ent) then\n+                  if not Is_Library_Level_Entity (Ent)\n+\n+                     --  Do not take into account nodes generated by the\n+                     --  expander for the elaboration of the dispatch tables;\n+                     --  otherwise we erroneously generate warnings indicating\n+                     --  violation of restriction No_Implicit_Dynamic_Code\n+                     --  with those nodes.\n+\n+                    and then not (Is_Dispatching_Operation (Ent)\n+                       and then Nkind (Parent (N)) = N_Assignment_Statement\n+                       and then Nkind (Name (Parent (N))) = N_Indexed_Component\n+                       and then Nkind (Prefix (Name (Parent (N)))) =\n+                                  N_Selected_Component\n+                       and then Nkind (Selector_Name\n+                                        (Prefix (Name (Parent (N))))) =\n+                                  N_Identifier\n+                       and then Present (Entity (Selector_Name\n+                                                 (Prefix (Name (Parent (N))))))\n+                       and then Entity (Selector_Name\n+                                         (Prefix (Name (Parent (N))))) =\n+                                  RTE_Record_Component (RE_Prims_Ptr))\n+                  then\n                      Check_Restriction (No_Implicit_Dynamic_Code, P);\n                   end if;\n \n@@ -7044,31 +7064,37 @@ package body Sem_Attr is\n             if Is_Entity_Name (P) then\n                if Is_Overloaded (P) then\n                   Get_First_Interp (P, Index, It);\n-\n                   while Present (It.Nam) loop\n-\n                      if Type_Conformant (Designated_Type (Typ), It.Nam) then\n                         Set_Entity (P, It.Nam);\n \n-                        --  The prefix is definitely NOT overloaded anymore\n-                        --  at this point, so we reset the Is_Overloaded\n-                        --  flag to avoid any confusion when reanalyzing\n-                        --  the node.\n+                        --  The prefix is definitely NOT overloaded anymore at\n+                        --  this point, so we reset the Is_Overloaded flag to\n+                        --  avoid any confusion when reanalyzing the node.\n \n                         Set_Is_Overloaded (P, False);\n+                        Set_Is_Overloaded (N, False);\n                         Generate_Reference (Entity (P), P);\n                         exit;\n                      end if;\n \n                      Get_Next_Interp (Index, It);\n                   end loop;\n \n-               --  If it is a subprogram name or a type, there is nothing\n-               --  to resolve.\n+               --  If Prefix is a subprogram name, it is frozen by this\n+               --  reference:\n+               --\n+               --    If it is a type, there is nothing to resolve.\n+               --    If it is an object, complete its resolution.\n \n-               elsif not Is_Overloadable (Entity (P))\n-                 and then not Is_Type (Entity (P))\n-               then\n+               elsif Is_Overloadable (Entity (P)) then\n+                  if not In_Default_Expression then\n+                     Insert_Actions (N, Freeze_Entity (Entity (P), Loc));\n+                  end if;\n+\n+               elsif Is_Type (Entity (P)) then\n+                  null;\n+               else\n                   Resolve (P);\n                end if;\n \n@@ -7077,8 +7103,8 @@ package body Sem_Attr is\n                if not Is_Entity_Name (P) then\n                   null;\n \n-               elsif Is_Abstract (Entity (P))\n-                 and then Is_Overloadable (Entity (P))\n+               elsif Is_Overloadable (Entity (P))\n+                 and then Is_Abstract_Subprogram (Entity (P))\n                then\n                   Error_Msg_N (\"prefix of % attribute cannot be abstract\", P);\n                   Set_Etype (N, Any_Type);\n@@ -7211,16 +7237,27 @@ package body Sem_Attr is\n                      if Enclosing_Generic_Unit (Entity (P)) /=\n                           Enclosing_Generic_Unit (Root_Type (Btyp))\n                      then\n+                        Error_Msg_N\n+                          (\"''Access attribute not allowed in generic body\",\n+                           N);\n+\n                         if Root_Type (Btyp) = Btyp then\n-                           Error_Msg_N\n-                             (\"access type must not be outside generic unit\",\n-                              N);\n+                           Error_Msg_NE\n+                             (\"\\because \" &\n+                              \"access type & is declared outside \" &\n+                              \"generic unit ('R'M 3.10.2(32))\", N, Btyp);\n                         else\n-                           Error_Msg_N\n-                             (\"ancestor access type must not be outside \" &\n-                              \"generic unit\", N);\n+                           Error_Msg_NE\n+                             (\"\\because ancestor of \" &\n+                              \"access type & is declared outside \" &\n+                              \"generic unit ('R'M 3.10.2(32))\", N, Btyp);\n                         end if;\n \n+                        Error_Msg_NE\n+                          (\"\\move ''Access to private part, or \" &\n+                           \"(Ada 2005) use anonymous access type instead of &\",\n+                           N, Btyp);\n+\n                      --  If the ultimate ancestor of the attribute's type is\n                      --  a formal type, then the attribute is illegal because\n                      --  the actual type might be declared at a higher level.\n@@ -7244,11 +7281,17 @@ package body Sem_Attr is\n                end if;\n \n                --  If this is a renaming, an inherited operation, or a\n-               --  subprogram instance, use the original entity.\n+               --  subprogram instance, use the original entity. This may make\n+               --  the node type-inconsistent, so this transformation can only\n+               --  be done if the node will not be reanalyzed. In particular,\n+               --  if it is within a default expression, the transformation\n+               --  must be delayed until the default subprogram is created for\n+               --  it, when the enclosing subprogram is frozen.\n \n                if Is_Entity_Name (P)\n                  and then Is_Overloadable (Entity (P))\n                  and then Present (Alias (Entity (P)))\n+                 and then Expander_Active\n                then\n                   Rewrite (P,\n                     New_Occurrence_Of (Alias (Entity (P)), Sloc (P)));\n@@ -7520,7 +7563,6 @@ package body Sem_Attr is\n                elsif Object_Access_Level (P) > Type_Access_Level (Btyp)\n                  and then Comes_From_Source (N)\n                  and then Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n-                 and then No (Original_Access_Type (Typ))\n                then\n                   Accessibility_Message;\n                   return;\n@@ -7940,6 +7982,15 @@ package body Sem_Attr is\n \n                when others => null;\n             end case;\n+\n+            --  If the prefix of the attribute is a class-wide type then it\n+            --  will be expanded into a dispatching call to a predefined\n+            --  primitive. Therefore we must check for potential violation\n+            --  of such restriction.\n+\n+            if Is_Class_Wide_Type (Etype (P)) then\n+               Check_Restriction (No_Dispatching_Calls, N);\n+            end if;\n       end case;\n \n       --  Normally the Freezing is done by Resolve but sometimes the Prefix\n@@ -7978,7 +8029,7 @@ package body Sem_Attr is\n       end if;\n \n       if Nam = TSS_Stream_Input\n-        and then Is_Abstract (Typ)\n+        and then Is_Abstract_Type (Typ)\n         and then not Is_Class_Wide_Type (Typ)\n       then\n          return False;"}, {"sha": "71afa7d18137147ed94e78a39500780f8e56273b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 927, "deletions": 580, "changes": 1507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "patch": "@@ -104,7 +104,7 @@ package body Sem_Ch3 is\n    --  implicit derived full type for a type derived from a private type (in\n    --  that case the subprograms must only be derived for the private view of\n    --  the type).\n-\n+   --\n    --  ??? These flags need a bit of re-examination and re-documentation:\n    --  ???  are they both necessary (both seem related to the recursion)?\n \n@@ -227,6 +227,20 @@ package body Sem_Ch3 is\n    --  Needs a more complete spec--what are the parameters exactly, and what\n    --  exactly is the returned value, and how is Bound affected???\n \n+   procedure Build_Itype_Reference\n+     (Ityp : Entity_Id;\n+      Nod  : Node_Id);\n+   --  Create a reference to an internal type, for use by Gigi. The back-end\n+   --  elaborates itypes on demand, i.e. when their first use is seen. This\n+   --  can lead to scope anomalies if the first use is within a scope that is\n+   --  nested within the scope that contains  the point of definition of the\n+   --  itype. The Itype_Reference node forces the elaboration of the itype\n+   --  in the proper scope. The node is inserted after Nod, which is the\n+   --  enclosing declaration that generated Ityp.\n+   --  A related mechanism is used during expansion, for itypes created in\n+   --  branches of conditionals. See Ensure_Defined in exp_util.\n+   --  Could both mechanisms be merged ???\n+\n    procedure Build_Underlying_Full_View\n      (N   : Node_Id;\n       Typ : Entity_Id;\n@@ -239,32 +253,49 @@ package body Sem_Ch3 is\n    --  view cannot itself have a full view (it would get clobbered during\n    --  view exchanges).\n \n+   procedure Check_Abstract_Interfaces (N : Node_Id; Def : Node_Id);\n+   --  Check ARM rules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2)\n+\n    procedure Check_Access_Discriminant_Requires_Limited\n      (D   : Node_Id;\n       Loc : Node_Id);\n    --  Check the restriction that the type to which an access discriminant\n    --  belongs must be a concurrent type or a descendant of a type with\n    --  the reserved word 'limited' in its declaration.\n \n+   procedure Check_Anonymous_Access_Components\n+      (Typ_Decl  : Node_Id;\n+       Typ       : Entity_Id;\n+       Prev      : Entity_Id;\n+       Comp_List : Node_Id);\n+   --  Ada 2005 AI-382: an access component in a record definition can refer to\n+   --  the enclosing record, in which case it denotes the type itself, and not\n+   --  the current instance of the type. We create an anonymous access type for\n+   --  the component, and flag it as an access to a component, so accessibility\n+   --  checks are properly performed on it. The declaration of the access type\n+   --  is placed ahead of that of the record to prevent order-of-elaboration\n+   --  circularity issues in Gigi. We create an incomplete type for the record\n+   --  declaration, which is the designated type of the anonymous access.\n+\n    procedure Check_Delta_Expression (E : Node_Id);\n-   --  Check that the expression represented by E is suitable for use\n-   --  as a delta expression, i.e. it is of real type and is static.\n+   --  Check that the expression represented by E is suitable for use as a\n+   --  delta expression, i.e. it is of real type and is static.\n \n    procedure Check_Digits_Expression (E : Node_Id);\n-   --  Check that the expression represented by E is suitable for use as\n-   --  a digits expression, i.e. it is of integer type, positive and static.\n+   --  Check that the expression represented by E is suitable for use as a\n+   --  digits expression, i.e. it is of integer type, positive and static.\n \n    procedure Check_Initialization (T : Entity_Id; Exp : Node_Id);\n-   --  Validate the initialization of an object declaration. T is the\n-   --  required type, and Exp is the initialization expression.\n+   --  Validate the initialization of an object declaration. T is the required\n+   --  type, and Exp is the initialization expression.\n \n    procedure Check_Or_Process_Discriminants\n      (N    : Node_Id;\n       T    : Entity_Id;\n       Prev : Entity_Id := Empty);\n-   --  If T is the full declaration of an incomplete or private type, check\n-   --  the conformance of the discriminants, otherwise process them. Prev\n-   --  is the entity of the partial declaration, if any.\n+   --  If T is the full declaration of an incomplete or private type, check the\n+   --  conformance of the discriminants, otherwise process them. Prev is the\n+   --  entity of the partial declaration, if any.\n \n    procedure Check_Real_Bound (Bound : Node_Id);\n    --  Check given bound for being of real type and static. If not, post an\n@@ -283,19 +314,17 @@ package body Sem_Ch3 is\n       Parent_Type  : Entity_Id;\n       Derived_Type : Entity_Id;\n       Loc          : Source_Ptr);\n-   --  For derived scalar types, convert the bounds in the type definition\n-   --  to the derived type, and complete their analysis. Given a constraint\n-   --  of the form:\n-   --                   ..  new T range Lo .. Hi;\n-   --  Lo and Hi are analyzed and resolved with T'Base, the parent_type.\n-   --  The bounds of the derived type (the anonymous base) are copies of\n-   --  Lo and Hi. Finally, the bounds of the derived subtype are conversions\n-   --  of those bounds to the derived_type, so that their typing is\n-   --  consistent.\n+   --  For derived scalar types, convert the bounds in the type definition to\n+   --  the derived type, and complete their analysis. Given a constraint of the\n+   --  form \".. new T range Lo .. Hi\", Lo and Hi are analyzed and resolved with\n+   --  T'Base, the parent_type. The bounds of the derived type (the anonymous\n+   --  base) are copies of Lo and Hi. Finally, the bounds of the derived\n+   --  subtype are conversions of those bounds to the derived_type, so that\n+   --  their typing is consistent.\n \n    procedure Copy_Array_Base_Type_Attributes (T1, T2 : Entity_Id);\n-   --  Copies attributes from array base type T2 to array base type T1.\n-   --  Copies only attributes that apply to base types, but not subtypes.\n+   --  Copies attributes from array base type T2 to array base type T1. Copies\n+   --  only attributes that apply to base types, but not subtypes.\n \n    procedure Copy_Array_Subtype_Attributes (T1, T2 : Entity_Id);\n    --  Copies attributes from array subtype T2 to array subtype T1. Copies\n@@ -308,12 +337,12 @@ package body Sem_Ch3 is\n       Constraints : Elist_Id);\n    --  Build the list of entities for a constrained discriminated record\n    --  subtype. If a component depends on a discriminant, replace its subtype\n-   --  using the discriminant values in the discriminant constraint.\n-   --  Subt is the defining identifier for the subtype whose list of\n-   --  constrained entities we will create. Decl_Node is the type declaration\n-   --  node where we will attach all the itypes created. Typ is the base\n-   --  discriminated type for the subtype Subt. Constraints is the list of\n-   --  discriminant constraints for Typ.\n+   --  using the discriminant values in the discriminant constraint. Subt is\n+   --  the defining identifier for the subtype whose list of constrained\n+   --  entities we will create. Decl_Node is the type declaration node where we\n+   --  will attach all the itypes created. Typ is the base discriminated type\n+   --  for the subtype Subt. Constraints is the list of discriminant\n+   --  constraints for Typ.\n \n    function Constrain_Component_Type\n      (Comp            : Entity_Id;\n@@ -324,11 +353,12 @@ package body Sem_Ch3 is\n    --  Given a discriminated base type Typ, a list of discriminant constraint\n    --  Constraints for Typ and a component of Typ, with type Compon_Type,\n    --  create and return the type corresponding to Compon_type where all\n-   --  discriminant references are replaced with the corresponding\n-   --  constraint. If no discriminant references occur in Compon_Typ then\n-   --  return it as is. Constrained_Typ is the final constrained subtype to\n-   --  which the constrained Compon_Type belongs. Related_Node is the node\n-   --  where we will attach all the itypes created.\n+   --  discriminant references are replaced with the corresponding constraint.\n+   --  If no discriminant references occur in Compon_Typ then return it as is.\n+   --  Constrained_Typ is the final constrained subtype to which the\n+   --  constrained Compon_Type belongs. Related_Node is the node where we will\n+   --  attach all the itypes created.\n+   --  Above description is confused, what is Compon_Type???\n \n    procedure Constrain_Access\n      (Def_Id      : in out Entity_Id;\n@@ -418,10 +448,10 @@ package body Sem_Ch3 is\n       Suffix       : Character;\n       Suffix_Index : Nat);\n    --  Process an index constraint in a constrained array declaration. The\n-   --  constraint can be a subtype name, or a range with or without an\n-   --  explicit subtype mark. The index is the corresponding index of the\n-   --  unconstrained array. The Related_Id and Suffix parameters are used to\n-   --  build the associated Implicit type name.\n+   --  constraint can be a subtype name, or a range with or without an explicit\n+   --  subtype mark. The index is the corresponding index of the unconstrained\n+   --  array. The Related_Id and Suffix parameters are used to build the\n+   --  associated Implicit type name.\n \n    procedure Constrain_Integer (Def_Id : Node_Id; S : Node_Id);\n    --  Build subtype of a signed or modular integer type\n@@ -431,9 +461,9 @@ package body Sem_Ch3 is\n    --  build an E_Ordinary_Fixed_Point_Subtype entity.\n \n    procedure Copy_And_Swap (Priv, Full : Entity_Id);\n-   --  Copy the Priv entity into the entity of its full declaration\n-   --  then swap the two entities in such a manner that the former private\n-   --  type is now seen as a full type.\n+   --  Copy the Priv entity into the entity of its full declaration then swap\n+   --  the two entities in such a manner that the former private type is now\n+   --  seen as a full type.\n \n    procedure Decimal_Fixed_Point_Type_Declaration\n      (T   : Entity_Id;\n@@ -522,8 +552,8 @@ package body Sem_Ch3 is\n    --\n    --    Is_Tagged is set if we are dealing with tagged types\n    --\n-   --    If Inherit_Discr is set, Derived_Base inherits its discriminants\n-   --    from Parent_Base, otherwise no discriminants are inherited.\n+   --    If Inherit_Discr is set, Derived_Base inherits its discriminants from\n+   --    Parent_Base, otherwise no discriminants are inherited.\n    --\n    --    Discs gives the list of constraints that apply to Parent_Base in the\n    --    derived type declaration. If Discs is set to No_Elist, then we have\n@@ -542,8 +572,8 @@ package body Sem_Ch3 is\n    --\n    --    (Old_Component => New_Component),\n    --\n-   --  where Old_Component is the Entity_Id of a component in Parent_Base\n-   --  and New_Component is the Entity_Id of the corresponding component in\n+   --  where Old_Component is the Entity_Id of a component in Parent_Base and\n+   --  New_Component is the Entity_Id of the corresponding component in\n    --  Derived_Base. For untagged records, this association list is needed when\n    --  copying the record declaration for the derived base. In the tagged case\n    --  the value returned is irrelevant.\n@@ -684,6 +714,7 @@ package body Sem_Ch3 is\n         and then Is_Task_Type (Etype (Scope (Current_Scope)))\n       then\n          Error_Msg_N (\"task entries cannot have access parameters\", N);\n+         return Empty;\n       end if;\n \n       --  Ada 2005: for an object declaration the corresponding anonymous\n@@ -701,24 +732,26 @@ package body Sem_Ch3 is\n             (E_Anonymous_Access_Type, Related_Nod,\n                Scope_Id => Current_Scope);\n \n-      --  For the anonymous function result case, retrieve the scope of\n-      --  the function specification's associated entity rather than using\n-      --  the current scope. The current scope will be the function itself\n-      --  if the formal part is currently being analyzed, but will be the\n-      --  parent scope in the case of a parameterless function, and we\n-      --  always want to use the function's parent scope.\n+      --  For the anonymous function result case, retrieve the scope of the\n+      --  function specification's associated entity rather than using the\n+      --  current scope. The current scope will be the function itself if the\n+      --  formal part is currently being analyzed, but will be the parent scope\n+      --  in the case of a parameterless function, and we always want to use\n+      --  the function's parent scope. Finally, if the function is a child\n+      --  unit, we must traverse the the tree to retrieve the proper entity.\n \n       elsif Nkind (Related_Nod) = N_Function_Specification\n          and then Nkind (Parent (N)) /= N_Parameter_Specification\n       then\n          Anon_Type :=\n            Create_Itype\n-            (E_Anonymous_Access_Type, Related_Nod,\n-               Scope_Id => Scope (Defining_Unit_Name (Related_Nod)));\n+             (E_Anonymous_Access_Type,\n+              Related_Nod,\n+              Scope_Id => Scope (Defining_Entity (Related_Nod)));\n \n       else\n-         --  For access formals, access components, and access\n-         --  discriminants, the scope is that of the enclosing declaration,\n+         --  For access formals, access components, and access discriminants,\n+         --  the scope is that of the enclosing declaration,\n \n          Anon_Type :=\n            Create_Itype\n@@ -732,8 +765,8 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"ALL is not permitted for anonymous access types\", N);\n       end if;\n \n-      --  Ada 2005 (AI-254): In case of anonymous access to subprograms\n-      --  call the corresponding semantic routine\n+      --  Ada 2005 (AI-254): In case of anonymous access to subprograms call\n+      --  the corresponding semantic routine\n \n       if Present (Access_To_Subprogram_Definition (N)) then\n          Access_Subprogram_Declaration\n@@ -761,9 +794,8 @@ package body Sem_Ch3 is\n       Set_Depends_On_Private (Anon_Type, Has_Private_Component (Anon_Type));\n \n       --  Ada 2005 (AI-231): Ada 2005 semantics for anonymous access differs\n-      --  from Ada 95 semantics. In Ada 2005, anonymous access must specify\n-      --  if the null value is allowed. In Ada 95 the null value is never\n-      --  allowed.\n+      --  from Ada 95 semantics. In Ada 2005, anonymous access must specify if\n+      --  the null value is allowed. In Ada 95 the null value is never allowed.\n \n       if Ada_Version >= Ada_05 then\n          Set_Can_Never_Be_Null (Anon_Type, Null_Exclusion_Present (N));\n@@ -804,9 +836,9 @@ package body Sem_Ch3 is\n \n       --  Ada 2005: if the designated type is an interface that may contain\n       --  tasks, create a Master entity for the declaration. This must be done\n-      --  before expansion of the full declaration, because the declaration\n-      --  may include an expression that is an allocator, whose expansion needs\n-      --  the proper Master for the created tasks.\n+      --  before expansion of the full declaration, because the declaration may\n+      --  include an expression that is an allocator, whose expansion needs the\n+      --  proper Master for the created tasks.\n \n       if Nkind (Related_Nod) = N_Object_Declaration\n          and then Expander_Active\n@@ -845,6 +877,16 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  For a private component of a protected type, it is imperative that\n+      --  the back-end elaborate the type immediately after the protected\n+      --  declaration, because this type will be used in the declarations\n+      --  created for the component within each protected body, so we must\n+      --  create an itype reference for it now.\n+\n+      if Nkind (Parent (Related_Nod)) = N_Protected_Definition then\n+         Build_Itype_Reference (Anon_Type, Parent (Parent (Related_Nod)));\n+      end if;\n+\n       return Anon_Type;\n    end Access_Definition;\n \n@@ -864,8 +906,8 @@ package body Sem_Ch3 is\n                      Create_Itype (E_Subprogram_Type, Parent (T_Def));\n \n    begin\n-      --  Associate the Itype node with the inner full-type declaration\n-      --  or subprogram spec. This is required to handle nested anonymous\n+      --  Associate the Itype node with the inner full-type declaration or\n+      --  subprogram spec. This is required to handle nested anonymous\n       --  declarations. For example:\n \n       --      procedure P\n@@ -1109,9 +1151,30 @@ package body Sem_Ch3 is\n       Last_Tag : Node_Id;\n       Comp     : Node_Id;\n \n+      procedure Add_Sync_Iface_Tags (T : Entity_Id);\n+      --  Local subprogram used to recursively climb through the parents\n+      --  of T to add the tags of all the progenitor interfaces.\n+\n       procedure Add_Tag (Iface : Entity_Id);\n       --  Add tag for one of the progenitor interfaces\n \n+      -------------------------\n+      -- Add_Sync_Iface_Tags --\n+      -------------------------\n+\n+      procedure Add_Sync_Iface_Tags (T : Entity_Id) is\n+      begin\n+         if Etype (T) /= T then\n+            Add_Sync_Iface_Tags (Etype (T));\n+         end if;\n+\n+         Elmt := First_Elmt (Abstract_Interfaces (T));\n+         while Present (Elmt) loop\n+            Add_Tag (Node (Elmt));\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end Add_Sync_Iface_Tags;\n+\n       -------------\n       -- Add_Tag --\n       -------------\n@@ -1191,69 +1254,80 @@ package body Sem_Ch3 is\n          end if;\n       end Add_Tag;\n \n+      --  Local variables\n+\n+      Iface_List : List_Id;\n+\n    --  Start of processing for Add_Interface_Tag_Components\n \n    begin\n       if Ekind (Typ) /= E_Record_Type\n-        or else No (Abstract_Interfaces (Typ))\n-        or else Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n         or else not RTE_Available (RE_Interface_Tag)\n+        or else (Is_Concurrent_Record_Type (Typ)\n+                  and then Is_Empty_List (Abstract_Interface_List (Typ)))\n+        or else (not Is_Concurrent_Record_Type (Typ)\n+                  and then No (Abstract_Interfaces (Typ))\n+                  and then Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n       then\n          return;\n       end if;\n \n-      if Present (Abstract_Interfaces (Typ)) then\n+      --  Find the current last tag\n+\n+      if Nkind (Type_Definition (N)) = N_Derived_Type_Definition then\n+         Ext := Record_Extension_Part (Type_Definition (N));\n+      else\n+         pragma Assert (Nkind (Type_Definition (N)) = N_Record_Definition);\n+         Ext := Type_Definition (N);\n+      end if;\n \n-         --  Find the current last tag\n+      Last_Tag := Empty;\n \n+      if not (Present (Component_List (Ext))) then\n+         Set_Null_Present (Ext, False);\n+         L := New_List;\n+         Set_Component_List (Ext,\n+           Make_Component_List (Loc,\n+             Component_Items => L,\n+             Null_Present => False));\n+      else\n          if Nkind (Type_Definition (N)) = N_Derived_Type_Definition then\n-            Ext := Record_Extension_Part (Type_Definition (N));\n+            L := Component_Items\n+                   (Component_List\n+                     (Record_Extension_Part\n+                       (Type_Definition (N))));\n          else\n-            pragma Assert (Nkind (Type_Definition (N)) = N_Record_Definition);\n-            Ext := Type_Definition (N);\n+            L := Component_Items\n+                   (Component_List\n+                     (Type_Definition (N)));\n          end if;\n \n-         Last_Tag := Empty;\n+         --  Find the last tag component\n \n-         if not (Present (Component_List (Ext))) then\n-            Set_Null_Present (Ext, False);\n-            L := New_List;\n-            Set_Component_List (Ext,\n-              Make_Component_List (Loc,\n-                Component_Items => L,\n-                Null_Present => False));\n-         else\n-            if Nkind (Type_Definition (N)) = N_Derived_Type_Definition then\n-               L := Component_Items\n-                      (Component_List\n-                        (Record_Extension_Part\n-                          (Type_Definition (N))));\n-            else\n-               L := Component_Items\n-                      (Component_List\n-                        (Type_Definition (N)));\n+         Comp := First (L);\n+         while Present (Comp) loop\n+            if Is_Tag (Defining_Identifier (Comp)) then\n+               Last_Tag := Comp;\n             end if;\n \n-            --  Find the last tag component\n-\n-            Comp := First (L);\n-            while Present (Comp) loop\n-               if Is_Tag (Defining_Identifier (Comp)) then\n-                  Last_Tag := Comp;\n-               end if;\n+            Next (Comp);\n+         end loop;\n+      end if;\n \n-               Next (Comp);\n-            end loop;\n-         end if;\n+      --  At this point L references the list of components and Last_Tag\n+      --  references the current last tag (if any). Now we add the tag\n+      --  corresponding with all the interfaces that are not implemented\n+      --  by the parent.\n \n-         --  At this point L references the list of components and Last_Tag\n-         --  references the current last tag (if any). Now we add the tag\n-         --  corresponding with all the interfaces that are not implemented\n-         --  by the parent.\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Iface_List := Abstract_Interface_List (Typ);\n \n-         pragma Assert (Present\n-                        (First_Elmt (Abstract_Interfaces (Typ))));\n+         if Is_Non_Empty_List (Iface_List) then\n+            Add_Sync_Iface_Tags (Etype (First (Iface_List)));\n+         end if;\n+      end if;\n \n+      if Present (Abstract_Interfaces (Typ)) then\n          Elmt := First_Elmt (Abstract_Interfaces (Typ));\n          while Present (Elmt) loop\n             Add_Tag (Node (Elmt));\n@@ -1396,7 +1470,7 @@ package body Sem_Ch3 is\n                                         (Access_Definition\n                                           (Component_Definition (N))))\n          then\n-            T := Replace_Anonymous_Access_To_Protected_Subprogram (N, T);\n+            T := Replace_Anonymous_Access_To_Protected_Subprogram (N);\n          end if;\n       end if;\n \n@@ -1485,7 +1559,7 @@ package body Sem_Ch3 is\n       --  Components cannot be abstract, except for the special case of\n       --  the _Parent field (case of extending an abstract tagged type)\n \n-      elsif Is_Abstract (T) and then Chars (Id) /= Name_uParent then\n+      elsif Is_Abstract_Type (T) and then Chars (Id) /= Name_uParent then\n          Error_Msg_N (\"type of a component cannot be abstract\", N);\n       end if;\n \n@@ -1674,11 +1748,19 @@ package body Sem_Ch3 is\n             end if;\n \n          --  If next node is a body then freeze all types before the body.\n-         --  An exception occurs for expander generated bodies, which can\n-         --  be recognized by their already being analyzed. The expander\n-         --  ensures that all types needed by these bodies have been frozen\n-         --  but it is not necessary to freeze all types (and would be wrong\n-         --  since it would not correspond to an RM defined freeze point).\n+         --  An exception occurs for some expander-generated bodies. If these\n+         --  are generated at places where in general language rules would not\n+         --  allow a freeze point, then we assume that the expander has\n+         --  explicitly checked that all required types are properly frozen,\n+         --  and we do not cause general freezing here. This special circuit\n+         --  is used when the encountered body is marked as having already\n+         --  been analyzed.\n+\n+         --  In all other cases (bodies that come from source, and expander\n+         --  generated bodies that have not been analyzed yet), freeze all\n+         --  types now. Note that in the latter case, the expander must take\n+         --  care to attach the bodies at a proper place in the tree so as to\n+         --  not cause unwanted freezing at that point.\n \n          elsif not Analyzed (Next_Node)\n            and then (Nkind (Next_Node) = N_Subprogram_Body\n@@ -1765,8 +1847,8 @@ package body Sem_Ch3 is\n       --  Type is abstract if full declaration carries keyword, or if\n       --  previous partial view did.\n \n-      Set_Is_Abstract  (T);\n-      Set_Is_Interface (T);\n+      Set_Is_Abstract_Type (T);\n+      Set_Is_Interface     (T);\n \n       Set_Is_Limited_Interface      (T, Limited_Present (Def));\n       Set_Is_Protected_Interface    (T, Protected_Present (Def));\n@@ -2061,6 +2143,15 @@ package body Sem_Ch3 is\n \n          T := Find_Type_Of_Object (Object_Definition (N), N);\n \n+         if Nkind (Object_Definition (N)) = N_Access_Definition\n+           and then Present\n+             (Access_To_Subprogram_Definition (Object_Definition (N)))\n+           and then Protected_Present\n+             (Access_To_Subprogram_Definition (Object_Definition (N)))\n+         then\n+            T := Replace_Anonymous_Access_To_Protected_Subprogram (N);\n+         end if;\n+\n          if Error_Posted (Id) then\n             Set_Etype (Id, T);\n             Set_Ekind (Id, E_Variable);\n@@ -2241,7 +2332,7 @@ package body Sem_Ch3 is\n       --  x'class'input where x is abstract) where we legitimately\n       --  generate an abstract object.\n \n-      if Is_Abstract (T) and then Comes_From_Source (N) then\n+      if Is_Abstract_Type (T) and then Comes_From_Source (N) then\n          Error_Msg_N (\"type of object cannot be abstract\",\n                       Object_Definition (N));\n \n@@ -3035,7 +3126,7 @@ package body Sem_Ch3 is\n \n                if Is_Tagged_Type (T) then\n                   Set_Is_Tagged_Type    (Id);\n-                  Set_Is_Abstract       (Id, Is_Abstract (T));\n+                  Set_Is_Abstract_Type  (Id, Is_Abstract_Type (T));\n                   Set_Primitive_Operations\n                                         (Id, Primitive_Operations (T));\n                   Set_Class_Wide_Type   (Id, Class_Wide_Type (T));\n@@ -3053,11 +3144,10 @@ package body Sem_Ch3 is\n                                       (Id, Has_Unknown_Discriminants (T));\n \n                if Is_Tagged_Type (T) then\n-                  Set_Is_Tagged_Type  (Id);\n-                  Set_Is_Abstract     (Id, Is_Abstract (T));\n-                  Set_Primitive_Operations\n-                                        (Id, Primitive_Operations (T));\n-                  Set_Class_Wide_Type (Id, Class_Wide_Type (T));\n+                  Set_Is_Tagged_Type       (Id);\n+                  Set_Is_Abstract_Type     (Id, Is_Abstract_Type (T));\n+                  Set_Primitive_Operations (Id, Primitive_Operations (T));\n+                  Set_Class_Wide_Type      (Id, Class_Wide_Type (T));\n                end if;\n \n                --  In general the attributes of the subtype of a private type\n@@ -3275,6 +3365,7 @@ package body Sem_Ch3 is\n       if R /= Error then\n          Analyze (R);\n          Set_Etype (N, Etype (R));\n+         Resolve (R, Entity (T));\n       else\n          Set_Error_Posted (R);\n          Set_Error_Posted (T);\n@@ -3293,10 +3384,9 @@ package body Sem_Ch3 is\n \n       Is_Remote : constant Boolean :=\n                     (Is_Remote_Types (Current_Scope)\n-                          or else Is_Remote_Call_Interface (Current_Scope))\n-                       and then not (In_Private_Part (Current_Scope)\n-                                       or else\n-                                     In_Package_Body (Current_Scope));\n+                       or else Is_Remote_Call_Interface (Current_Scope))\n+                    and then not (In_Private_Part (Current_Scope)\n+                                    or else In_Package_Body (Current_Scope));\n \n       procedure Check_Ops_From_Incomplete_Type;\n       --  If there is a tagged incomplete partial view of the type, transfer\n@@ -3351,11 +3441,24 @@ package body Sem_Ch3 is\n       --  Ada 2005 (AI-50217): If the type was previously decorated when\n       --  imported through a LIMITED WITH clause, it appears as incomplete\n       --  but has no full view.\n+      --  If the incomplete view is tagged, a class_wide type has been\n+      --  created already. Use it for the full view as well, to prevent\n+      --  multiple incompatible class-wide types that may be  created for\n+      --  self-referential anonymous access components.\n \n       if Ekind (Prev) = E_Incomplete_Type\n         and then Present (Full_View (Prev))\n       then\n          T := Full_View (Prev);\n+\n+         if Is_Tagged_Type (Prev)\n+           and then Present (Class_Wide_Type (Prev))\n+         then\n+            Set_Ekind (T, Ekind (Prev));         --  will be reset later\n+            Set_Class_Wide_Type (T, Class_Wide_Type (Prev));\n+            Set_Etype (Class_Wide_Type (T), T);\n+         end if;\n+\n       else\n          T := Prev;\n       end if;\n@@ -3517,7 +3620,18 @@ package body Sem_Ch3 is\n          --  made which is the \"real\" entity, i.e. the one swapped in,\n          --  and the second parameter provides the reference location.\n \n-         Generate_Reference (T, T, 'c');\n+         --  Also, we want to kill Has_Pragma_Unreferenced temporarily here\n+         --  since we don't want a complaint about the full type being an\n+         --  unwanted reference to the private type\n+\n+         declare\n+            B : constant Boolean := Has_Pragma_Unreferenced (T);\n+         begin\n+            Set_Has_Pragma_Unreferenced (T, False);\n+            Generate_Reference (T, T, 'c');\n+            Set_Has_Pragma_Unreferenced (T, B);\n+         end;\n+\n          Set_Completion_Referenced (Def_Id);\n \n       --  For completion of incomplete type, process incomplete dependents\n@@ -3727,11 +3841,21 @@ package body Sem_Ch3 is\n       --  Ada 2005 (AI-230): Access Definition case\n \n       else pragma Assert (Present (Access_Definition (Component_Def)));\n+\n+         --  Indicate that the anonymous access type is created by the\n+         --  array type declaration.\n+\n          Element_Type := Access_Definition\n-                           (Related_Nod => Related_Id,\n+                           (Related_Nod => P,\n                             N           => Access_Definition (Component_Def));\n          Set_Is_Local_Anonymous_Access (Element_Type);\n \n+         --  Propagate the parent. This field is needed if we have to generate\n+         --  the master_id associated with an anonymous access to task type\n+         --  component (see Expand_N_Full_Type_Declaration.Build_Master)\n+\n+         Set_Parent (Element_Type, Parent (T));\n+\n          --  Ada 2005 (AI-230): In case of components that are anonymous\n          --  access types the level of accessibility depends on the enclosing\n          --  type declaration\n@@ -3747,8 +3871,7 @@ package body Sem_Ch3 is\n          begin\n             if Present (CD) and then Protected_Present (CD) then\n                Element_Type :=\n-                 Replace_Anonymous_Access_To_Protected_Subprogram\n-                   (Def, Element_Type);\n+                 Replace_Anonymous_Access_To_Protected_Subprogram (Def);\n             end if;\n          end;\n       end if;\n@@ -3782,18 +3905,19 @@ package body Sem_Ch3 is\n \n          --  Complete setup of implicit base type\n \n-         Set_First_Index    (Implicit_Base, First_Index (T));\n-         Set_Component_Type (Implicit_Base, Element_Type);\n-         Set_Has_Task       (Implicit_Base, Has_Task      (Element_Type));\n-         Set_Component_Size (Implicit_Base, Uint_0);\n+         Set_First_Index       (Implicit_Base, First_Index (T));\n+         Set_Component_Type    (Implicit_Base, Element_Type);\n+         Set_Has_Task          (Implicit_Base, Has_Task (Element_Type));\n+         Set_Component_Size    (Implicit_Base, Uint_0);\n+         Set_Packed_Array_Type (Implicit_Base, Empty);\n          Set_Has_Controlled_Component\n-                            (Implicit_Base, Has_Controlled_Component\n-                                                          (Element_Type)\n-                                              or else\n-                                            Is_Controlled (Element_Type));\n+                               (Implicit_Base, Has_Controlled_Component\n+                                                        (Element_Type)\n+                                                 or else Is_Controlled\n+                                                        (Element_Type));\n          Set_Finalize_Storage_Only\n-                            (Implicit_Base, Finalize_Storage_Only\n-                                                          (Element_Type));\n+                               (Implicit_Base, Finalize_Storage_Only\n+                                                        (Element_Type));\n \n       --  Unconstrained array case\n \n@@ -3815,7 +3939,10 @@ package body Sem_Ch3 is\n                                                         (Element_Type));\n       end if;\n \n+      --  Common attributes for both cases\n+\n       Set_Component_Type (Base_Type (T), Element_Type);\n+      Set_Packed_Array_Type (T, Empty);\n \n       if Aliased_Present (Component_Definition (Def)) then\n          Set_Has_Aliased_Components (Etype (T));\n@@ -3885,7 +4012,7 @@ package body Sem_Ch3 is\n            (\"unconstrained element type in array declaration\",\n             Subtype_Indication (Component_Def));\n \n-      elsif Is_Abstract (Element_Type) then\n+      elsif Is_Abstract_Type (Element_Type) then\n          Error_Msg_N\n            (\"the type of a component cannot be abstract\",\n             Subtype_Indication (Component_Def));\n@@ -3898,8 +4025,7 @@ package body Sem_Ch3 is\n    ------------------------------------------------------\n \n    function Replace_Anonymous_Access_To_Protected_Subprogram\n-     (N      : Node_Id;\n-      Prev_E : Entity_Id) return Entity_Id\n+     (N      : Node_Id) return Entity_Id\n    is\n       Loc : constant Source_Ptr := Sloc (N);\n \n@@ -3923,15 +4049,19 @@ package body Sem_Ch3 is\n            N_Unconstrained_Array_Definition |\n            N_Constrained_Array_Definition   =>\n             Comp := Component_Definition (N);\n-            Acc  := Access_Definition (Component_Definition (N));\n+            Acc  := Access_Definition (Comp);\n \n          when N_Discriminant_Specification =>\n             Comp := Discriminant_Type (N);\n-            Acc  := Discriminant_Type (N);\n+            Acc  := Comp;\n \n          when N_Parameter_Specification =>\n             Comp := Parameter_Type (N);\n-            Acc  := Parameter_Type (N);\n+            Acc  := Comp;\n+\n+         when N_Object_Declaration  =>\n+            Comp := Object_Definition (N);\n+            Acc  := Comp;\n \n          when others =>\n             raise Program_Error;\n@@ -3969,6 +4099,11 @@ package body Sem_Ch3 is\n          Rewrite (Comp, New_Occurrence_Of (Anon, Loc));\n          Set_Etype (Defining_Identifier (N), Anon);\n          Set_Null_Exclusion_Present (N, False);\n+\n+      elsif Nkind (N) = N_Object_Declaration then\n+         Rewrite (Comp, New_Occurrence_Of (Anon, Loc));\n+         Set_Etype (Defining_Identifier (N), Anon);\n+\n       else\n          Rewrite (Comp,\n            Make_Component_Definition (Loc,\n@@ -3980,11 +4115,15 @@ package body Sem_Ch3 is\n       --  Temporarily remove the current scope from the stack to add the new\n       --  declarations to the enclosing scope\n \n-      Scope_Stack.Decrement_Last;\n-      Analyze (Decl);\n-      Scope_Stack.Append (Curr_Scope);\n+      if Nkind (N) /= N_Object_Declaration then\n+         Scope_Stack.Decrement_Last;\n+         Analyze (Decl);\n+         Scope_Stack.Append (Curr_Scope);\n+      else\n+         Analyze (Decl);\n+      end if;\n \n-      Set_Original_Access_Type (Anon, Prev_E);\n+      Set_Ekind (Anon, E_Anonymous_Access_Protected_Subprogram_Type);\n       return Anon;\n    end Replace_Anonymous_Access_To_Protected_Subprogram;\n \n@@ -5134,32 +5273,25 @@ package body Sem_Ch3 is\n             --  be possibly non-private. We build a underlying full view that\n             --  will be installed when the enclosing child body is compiled.\n \n-            declare\n-               IR : constant Node_Id := Make_Itype_Reference (Sloc (N));\n+            Full_Der :=\n+              Make_Defining_Identifier (Sloc (Derived_Type),\n+                Chars => Chars (Derived_Type));\n+            Set_Is_Itype (Full_Der);\n+            Build_Itype_Reference (Full_Der, N);\n \n-            begin\n-               Full_Der :=\n-                 Make_Defining_Identifier (Sloc (Derived_Type),\n-                   Chars (Derived_Type));\n-               Set_Is_Itype (Full_Der);\n-               Set_Itype (IR, Full_Der);\n-               Insert_After (N, IR);\n-\n-               --  The full view will be used to swap entities on entry/exit\n-               --  to the body, and must appear in the entity list for the\n-               --  package.\n-\n-               Append_Entity (Full_Der, Scope (Derived_Type));\n-               Set_Has_Private_Declaration (Full_Der);\n-               Set_Has_Private_Declaration (Derived_Type);\n-               Set_Associated_Node_For_Itype (Full_Der, N);\n-               Set_Parent (Full_Der, Parent (Derived_Type));\n-               Full_P := Full_View (Parent_Type);\n-               Exchange_Declarations (Parent_Type);\n-               Copy_And_Build;\n-               Exchange_Declarations (Full_P);\n-               Set_Underlying_Full_View (Derived_Type, Full_Der);\n-            end;\n+            --  The full view will be used to swap entities on entry/exit to\n+            --  the body, and must appear in the entity list for the package.\n+\n+            Append_Entity (Full_Der, Scope (Derived_Type));\n+            Set_Has_Private_Declaration (Full_Der);\n+            Set_Has_Private_Declaration (Derived_Type);\n+            Set_Associated_Node_For_Itype (Full_Der, N);\n+            Set_Parent (Full_Der, Parent (Derived_Type));\n+            Full_P := Full_View (Parent_Type);\n+            Exchange_Declarations (Parent_Type);\n+            Copy_And_Build;\n+            Exchange_Declarations (Full_P);\n+            Set_Underlying_Full_View (Derived_Type, Full_Der);\n          end if;\n       end if;\n    end Build_Derived_Private_Type;\n@@ -5179,12 +5311,12 @@ package body Sem_Ch3 is\n    --     type R (...) is [tagged] record ... end record;\n    --     type T (...) is new R (...) [with ...];\n \n-   --  The representation clauses of T can specify a completely different\n-   --  record layout from R's. Hence the same component can be placed in\n-   --  two very different positions in objects of type T and R. If R and T\n-   --  are tagged types, representation clauses for T can only specify the\n-   --  layout of non inherited components, thus components that are common\n-   --  in R and T have the same position in objects of type R and T.\n+   --  The representation clauses for T can specify a completely different\n+   --  record layout from R's. Hence the same component can be placed in two\n+   --  very different positions in objects of type T and R. If R and are tagged\n+   --  types, representation clauses for T can only specify the layout of non\n+   --  inherited components, thus components that are common in R and T have\n+   --  the same position in objects of type R and T.\n \n    --  This has two implications. The first is that the entire tree for R's\n    --  declaration needs to be copied for T in the untagged case, so that T\n@@ -5651,23 +5783,28 @@ package body Sem_Ch3 is\n       end if;\n \n       --  Before we start the previously documented transformations, here is\n-      --  a little fix for size and alignment of tagged types. Normally when\n-      --  we derive type D from type P, we copy the size and alignment of P\n-      --  as the default for D, and in the absence of explicit representation\n-      --  clauses for D, the size and alignment are indeed the same as the\n-      --  parent.\n+      --  little fix for size and alignment of tagged types. Normally when we\n+      --  derive type D from type P, we copy the size and alignment of P as the\n+      --  default for D, and in the absence of explicit representation clauses\n+      --  for D, the size and alignment are indeed the same as the parent.\n+\n+      --  But this is wrong for tagged types, since fields may be added, and\n+      --  the default size may need to be larger, and the default alignment may\n+      --  need to be larger.\n \n-      --  But this is wrong for tagged types, since fields may be added,\n-      --  and the default size may need to be larger, and the default\n-      --  alignment may need to be larger.\n+      --  We therefore reset the size and alignment fields in the tagged case.\n+      --  Note that the size and alignment will in any case be at least as\n+      --  large as the parent type (since the derived type has a copy of the\n+      --  parent type in the _parent field)\n \n-      --  We therefore reset the size and alignment fields in the tagged\n-      --  case. Note that the size and alignment will in any case be at\n-      --  least as large as the parent type (since the derived type has\n-      --  a copy of the parent type in the _parent field)\n+      --  The type is also marked as being tagged here, which is needed when\n+      --  processing components with a self-referential anonymous access type\n+      --  in the call to Check_Anonymous_Access_Components below. Note that\n+      --  this flag is also set later on for completeness.\n \n       if Is_Tagged then\n-         Init_Size_Align (Derived_Type);\n+         Set_Is_Tagged_Type (Derived_Type);\n+         Init_Size_Align    (Derived_Type);\n       end if;\n \n       --  STEP 0a: figure out what kind of derived type declaration we have\n@@ -5688,6 +5825,16 @@ package body Sem_Ch3 is\n \n          if Present (Record_Extension_Part (Type_Def)) then\n             Set_Ekind (Derived_Type, E_Record_Type);\n+\n+            --  Create internal access types for components with anonymous\n+            --  access types.\n+\n+            if Ada_Version >= Ada_05 then\n+               Check_Anonymous_Access_Components\n+                 (N, Derived_Type, Derived_Type,\n+                   Component_List (Record_Extension_Part (Type_Def)));\n+            end if;\n+\n          else\n             Set_Ekind (Derived_Type, Ekind (Parent_Base));\n          end if;\n@@ -5966,7 +6113,6 @@ package body Sem_Ch3 is\n       if Ada_Version = Ada_05\n         and then Is_Tagged\n       then\n-\n          --  \"The declaration of a specific descendant of an interface type\n          --  freezes the interface type\" (RM 13.14).\n \n@@ -6198,7 +6344,10 @@ package body Sem_Ch3 is\n          and then Ekind (Derived_Type) /= E_Private_Type\n          and then Ekind (Derived_Type) /= E_Limited_Private_Type\n       then\n-         Set_Is_Interface (Derived_Type, Interface_Present (Type_Def));\n+         if Interface_Present (Type_Def) then\n+            Analyze_Interface_Declaration (Derived_Type, Type_Def);\n+         end if;\n+\n          Set_Abstract_Interfaces (Derived_Type, No_Elist);\n       end if;\n \n@@ -6210,13 +6359,16 @@ package body Sem_Ch3 is\n         (Derived_Type, Has_Specified_Layout     (Parent_Type));\n       Set_Is_Limited_Composite\n         (Derived_Type, Is_Limited_Composite     (Parent_Type));\n-      Set_Is_Limited_Record\n-        (Derived_Type,\n-           Is_Limited_Record        (Parent_Type)\n-             and then not Is_Interface (Parent_Type));\n       Set_Is_Private_Composite\n         (Derived_Type, Is_Private_Composite     (Parent_Type));\n \n+      if not Is_Limited_Record (Derived_Type) then\n+         Set_Is_Limited_Record\n+           (Derived_Type,\n+              Is_Limited_Record (Parent_Type)\n+                and then not Is_Interface (Parent_Type));\n+      end if;\n+\n       --  Fields inherited from the Parent_Base\n \n       Set_Has_Controlled_Component\n@@ -6278,7 +6430,7 @@ package body Sem_Ch3 is\n          end if;\n \n          Make_Class_Wide_Type (Derived_Type);\n-         Set_Is_Abstract      (Derived_Type, Abstract_Present (Type_Def));\n+         Set_Is_Abstract_Type (Derived_Type, Abstract_Present (Type_Def));\n \n          if Has_Discriminants (Derived_Type)\n            and then Constraint_Present\n@@ -6287,13 +6439,17 @@ package body Sem_Ch3 is\n               (Derived_Type, Expand_To_Stored_Constraint (Parent_Base, Discs));\n          end if;\n \n-         --  Ada 2005 (AI-251): Collect the list of progenitors that are not\n-         --  already in the parents.\n-\n          if Ada_Version >= Ada_05 then\n             declare\n                Ifaces_List : Elist_Id;\n             begin\n+               --  Check ARM rules 3.9.4 (15/2), 9.1 (9.d/2) and 9.4 (11.d/2)\n+\n+               Check_Abstract_Interfaces (N, Type_Def);\n+\n+               --  Ada 2005 (AI-251): Collect the list of progenitors that are\n+               --  not already in the parents.\n+\n                Collect_Abstract_Interfaces\n                  (T                         => Derived_Type,\n                   Ifaces_List               => Ifaces_List,\n@@ -6395,7 +6551,9 @@ package body Sem_Ch3 is\n          --  Ada 2005 (AI-251): Addition of the Tag corresponding to all the\n          --  implemented interfaces if we are in expansion mode\n \n-         if Expander_Active then\n+         if Expander_Active\n+           and then Has_Abstract_Interfaces (Derived_Type)\n+         then\n             Add_Interface_Tag_Components (N, Derived_Type);\n          end if;\n \n@@ -7025,7 +7183,7 @@ package body Sem_Ch3 is\n             Set_Primitive_Operations (Def_Id, Primitive_Operations (T));\n          end if;\n \n-         Set_Is_Abstract (Def_Id, Is_Abstract (T));\n+         Set_Is_Abstract_Type (Def_Id, Is_Abstract_Type (T));\n       end if;\n \n       --  Subtypes introduced by component declarations do not need to be\n@@ -7059,6 +7217,20 @@ package body Sem_Ch3 is\n       end if;\n    end Build_Discriminated_Subtype;\n \n+   ---------------------------\n+   -- Build_Itype_Reference --\n+   ---------------------------\n+\n+   procedure Build_Itype_Reference\n+     (Ityp : Entity_Id;\n+      Nod  : Node_Id)\n+   is\n+      IR : constant Node_Id := Make_Itype_Reference (Sloc (Nod));\n+   begin\n+      Set_Itype (IR, Ityp);\n+      Insert_After (Nod, IR);\n+   end Build_Itype_Reference;\n+\n    ------------------------\n    -- Build_Scalar_Bound --\n    ------------------------\n@@ -7206,6 +7378,131 @@ package body Sem_Ch3 is\n       Set_Underlying_Full_View (Typ, Full_View (Subt));\n    end Build_Underlying_Full_View;\n \n+   -------------------------------\n+   -- Check_Abstract_Interfaces --\n+   -------------------------------\n+\n+   procedure Check_Abstract_Interfaces (N : Node_Id; Def : Node_Id) is\n+\n+      procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id);\n+      --  Local subprogram used to avoid code duplication. In case of error\n+      --  the message will be associated to Error_Node.\n+\n+      ------------------\n+      -- Check_Ifaces --\n+      ------------------\n+\n+      procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id) is\n+      begin\n+         --  Ada 2005 (AI-345): Protected interfaces can only inherit from\n+         --  limited, synchronized or protected interfaces.\n+\n+         if Protected_Present (Def) then\n+            if Limited_Present (Iface_Def)\n+              or else Synchronized_Present (Iface_Def)\n+              or else Protected_Present (Iface_Def)\n+            then\n+               null;\n+\n+            elsif Task_Present (Iface_Def) then\n+               Error_Msg_N (\"(Ada 2005) protected interface cannot inherit\"\n+                            & \" from task interface\", Error_Node);\n+\n+            else\n+               Error_Msg_N (\"(Ada 2005) protected interface cannot inherit\"\n+                            & \" from non-limited interface\", Error_Node);\n+            end if;\n+\n+         --  Ada 2005 (AI-345): Synchronized interfaces can only inherit from\n+         --  limited and synchronized.\n+\n+         elsif Synchronized_Present (Def) then\n+            if Limited_Present (Iface_Def)\n+              or else Synchronized_Present (Iface_Def)\n+            then\n+               null;\n+\n+            elsif Protected_Present (Iface_Def) then\n+               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n+                            & \" from protected interface\", Error_Node);\n+\n+            elsif Task_Present (Iface_Def) then\n+               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n+                            & \" from task interface\", Error_Node);\n+\n+            else\n+               Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n+                            & \" from non-limited interface\", Error_Node);\n+            end if;\n+\n+         --  Ada 2005 (AI-345): Task interfaces can only inherit from limited,\n+         --  synchronized or task interfaces.\n+\n+         elsif Task_Present (Def) then\n+            if Limited_Present (Iface_Def)\n+              or else Synchronized_Present (Iface_Def)\n+              or else Task_Present (Iface_Def)\n+            then\n+               null;\n+\n+            elsif Protected_Present (Iface_Def) then\n+               Error_Msg_N (\"(Ada 2005) task interface cannot inherit from\"\n+                            & \" protected interface\", Error_Node);\n+\n+            else\n+               Error_Msg_N (\"(Ada 2005) task interface cannot inherit from\"\n+                            & \" non-limited interface\", Error_Node);\n+            end if;\n+         end if;\n+      end Check_Ifaces;\n+\n+      --  Local variables\n+\n+      Iface     : Node_Id;\n+      Iface_Def : Node_Id;\n+      Iface_Typ : Entity_Id;\n+\n+   --  Start of processing for Check_Abstract_Interfaces\n+\n+   begin\n+      --  Why is this still unsupported???\n+\n+      if Nkind (N) = N_Private_Extension_Declaration then\n+         return;\n+      end if;\n+\n+      --  Check the parent in case of derivation of interface type\n+\n+      if Nkind (Type_Definition (N)) = N_Derived_Type_Definition\n+        and then Is_Interface (Etype (Defining_Identifier (N)))\n+      then\n+         Check_Ifaces\n+           (Iface_Def  => Type_Definition\n+                            (Parent (Etype (Defining_Identifier (N)))),\n+            Error_Node => Subtype_Indication (Type_Definition (N)));\n+      end if;\n+\n+      Iface := First (Interface_List (Def));\n+      while Present (Iface) loop\n+         Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+         Iface_Def := Type_Definition (Parent (Iface_Typ));\n+\n+         if not Is_Interface (Iface_Typ) then\n+            Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                          Iface, Iface_Typ);\n+\n+         else\n+            --  \"The declaration of a specific descendant of an interface\n+            --   type freezes the interface type\" RM 13.14\n+\n+            Freeze_Before (N, Iface_Typ);\n+            Check_Ifaces (Iface_Def, Error_Node => Iface);\n+         end if;\n+\n+         Next (Iface);\n+      end loop;\n+   end Check_Abstract_Interfaces;\n+\n    -------------------------------\n    -- Check_Abstract_Overriding --\n    -------------------------------\n@@ -7231,19 +7528,23 @@ package body Sem_Ch3 is\n          --  come from source, and the associated source location is the\n          --  location of the first subtype of the derived type.\n \n+         --  Ada 2005 (AI-228): Apply the rules of RM-3.9.3(6/2) for\n+         --  subprograms that \"require overriding\".\n+\n          --  Special exception, do not complain about failure to override the\n          --  stream routines _Input and _Output, as well as the primitive\n          --  operations used in dispatching selects since we always provide\n          --  automatic overridings for these subprograms.\n \n-         if (Is_Abstract (Subp)\n-               or else (Has_Controlling_Result (Subp)\n-                         and then Present (Alias_Subp)\n-                         and then not Comes_From_Source (Subp)\n-                         and then Sloc (Subp) = Sloc (First_Subtype (T))))\n+         if (Is_Abstract_Subprogram (Subp)\n+              or else Requires_Overriding (Subp)\n+              or else (Has_Controlling_Result (Subp)\n+                        and then Present (Alias_Subp)\n+                        and then not Comes_From_Source (Subp)\n+                        and then Sloc (Subp) = Sloc (First_Subtype (T))))\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n-           and then not Is_Abstract (T)\n+           and then not Is_Abstract_Type (T)\n            and then Chars (Subp) /= Name_uDisp_Asynchronous_Select\n            and then Chars (Subp) /= Name_uDisp_Conditional_Select\n            and then Chars (Subp) /= Name_uDisp_Get_Prim_Op_Kind\n@@ -7280,7 +7581,8 @@ package body Sem_Ch3 is\n                       or else not Is_Null_Extension (T)\n                       or else Ekind (Subp) = E_Procedure\n                       or else not Has_Controlling_Result (Subp)\n-                      or else Is_Abstract (Alias_Subp)\n+                      or else Is_Abstract_Subprogram (Alias_Subp)\n+                      or else Requires_Overriding (Subp)\n                       or else Is_Access_Type (Etype (Subp)))\n                then\n                   Error_Msg_NE\n@@ -7347,12 +7649,17 @@ package body Sem_Ch3 is\n                end if;\n \n             else\n-               Error_Msg_NE\n-                 (\"abstract subprogram not allowed for type&\",\n-                  Subp, T);\n-               Error_Msg_NE\n-                 (\"nonabstract type has abstract subprogram&\",\n-                  T, Subp);\n+               Error_Msg_Node_2 := T;\n+               Error_Msg_N\n+                 (\"abstract subprogram& not allowed for type&\", Subp);\n+\n+               --  Also post unconditional warning on the type (unconditional\n+               --  so that if there are more than one of these cases, we get\n+               --  them all, and not just the first one).\n+\n+               Error_Msg_Node_2 := Subp;\n+               Error_Msg_N\n+                 (\"nonabstract type& has abstract subprogram&!\", T);\n             end if;\n          end if;\n \n@@ -7479,7 +7786,7 @@ package body Sem_Ch3 is\n \n          --  If a generated entity has no completion, then either previous\n          --  semantic errors have disabled the expansion phase, or else we had\n-         --  missing subunits, or else we are compiling without expan- sion,\n+         --  missing subunits, or else we are compiling without expansion,\n          --  or else something is very wrong.\n \n          if not Comes_From_Source (E) then\n@@ -7571,13 +7878,23 @@ package body Sem_Ch3 is\n          --  be flagged as requiring completion, because it is a\n          --  compilation unit.\n \n+         --  Ignore missing completion for a subprogram that does not come from\n+         --  source (including the _Call primitive operation of RAS types,\n+         --  which has to have the flag Comes_From_Source for other purposes):\n+         --  we assume that the expander will provide the missing completion.\n+\n          elsif     Ekind (E) = E_Function\n            or else Ekind (E) = E_Procedure\n            or else Ekind (E) = E_Generic_Function\n            or else Ekind (E) = E_Generic_Procedure\n          then\n             if not Has_Completion (E)\n-              and then not Is_Abstract (E)\n+              and then not (Is_Subprogram (E)\n+                            and then Is_Abstract_Subprogram (E))\n+              and then not (Is_Subprogram (E)\n+                              and then\n+                            (not Comes_From_Source (E)\n+                              or else Chars (E) = Name_uCall))\n               and then Nkind (Parent (Unit_Declaration_Node (E))) /=\n                                                        N_Compilation_Unit\n               and then Chars (E) /= Name_uSize\n@@ -8310,6 +8627,7 @@ package body Sem_Ch3 is\n             --  a derivation from a private type) has no discriminants.\n             --  (Defect Report 8652/0008, Technical Corrigendum 1, checked\n             --  by ACATS B371001).\n+\n             --  Rule updated for Ada 2005: the private type is said to have\n             --  a constrained partial view, given that objects of the type\n             --  can be declared.\n@@ -8401,20 +8719,35 @@ package body Sem_Ch3 is\n       --  generic body, the rule is checked assuming that the actual type has\n       --  defaulted discriminants.\n \n-      if Ada_Version >=  Ada_05 then\n+      if Ada_Version >= Ada_05 or else Warn_On_Ada_2005_Compatibility then\n          if Ekind (Base_Type (T)) = E_General_Access_Type\n            and then Has_Defaulted_Discriminants (Desig_Type)\n          then\n-            Error_Msg_N\n-              (\"access subype of general access type not allowed\", S);\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_N\n+                 (\"access subtype of general access type would not \" &\n+                  \"be allowed in Ada 2005?\", S);\n+            else\n+               Error_Msg_N\n+                 (\"access subype of general access type not allowed\", S);\n+            end if;\n+\n             Error_Msg_N (\"\\discriminants have defaults\", S);\n \n          elsif Is_Access_Type (T)\n            and then Is_Generic_Type (Desig_Type)\n            and then Has_Discriminants (Desig_Type)\n            and then In_Package_Body (Current_Scope)\n          then\n-            Error_Msg_N (\"access subtype not allowed in generic body\", S);\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_N\n+                 (\"access subtype would not be allowed in generic body \" &\n+                  \"in Ada 2005?\", S);\n+            else\n+               Error_Msg_N\n+                 (\"access subtype not allowed in generic body\", S);\n+            end if;\n+\n             Error_Msg_N\n               (\"\\designated type is a discriminated formal\", S);\n          end if;\n@@ -9648,6 +9981,10 @@ package body Sem_Ch3 is\n       Set_Is_Public                  (Full, Is_Public               (Priv));\n       Set_Is_Pure                    (Full, Is_Pure                 (Priv));\n       Set_Is_Tagged_Type             (Full, Is_Tagged_Type          (Priv));\n+      Set_Has_Pragma_Unreferenced    (Full, Has_Pragma_Unreferenced (Priv));\n+      Set_Has_Pragma_Unreferenced_Objects\n+                                     (Full, Has_Pragma_Unreferenced_Objects\n+                                                                    (Priv));\n \n       Conditional_Delay              (Full,                          Priv);\n \n@@ -10379,7 +10716,13 @@ package body Sem_Ch3 is\n          Subp  := Node (Elmt);\n          Iface := Find_Dispatching_Type (Subp);\n \n-         if not Is_Ancestor (Iface, Tagged_Type) then\n+         if Is_Concurrent_Record_Type (Tagged_Type) then\n+            if not Present (Abstract_Interface_Alias (Subp)) then\n+               Derive_Subprogram (New_Subp, Subp, Tagged_Type, Iface);\n+               Append_Elmt (New_Subp, Ifaces_List);\n+            end if;\n+\n+         elsif not Is_Parent (Iface, Tagged_Type) then\n             Derive_Subprogram (New_Subp, Subp, Tagged_Type, Iface);\n             Append_Elmt (New_Subp, Ifaces_List);\n          end if;\n@@ -10441,7 +10784,8 @@ package body Sem_Ch3 is\n             Set_Is_Hidden                (Iface_Subp);\n             Set_Abstract_Interface_Alias (Iface_Subp, Alias (Iface_Subp));\n             Set_Alias                    (Iface_Subp, E);\n-            Set_Is_Abstract              (Iface_Subp, Is_Abstract (E));\n+            Set_Is_Abstract_Subprogram   (Iface_Subp,\n+                                          Is_Abstract_Subprogram (E));\n             Remove_Homonym               (Iface_Subp);\n \n             Next_Elmt (Elmt);\n@@ -10527,7 +10871,6 @@ package body Sem_Ch3 is\n \n       procedure Replace_Type (Id, New_Id : Entity_Id) is\n          Acc_Type : Entity_Id;\n-         IR       : Node_Id;\n          Par      : constant Node_Id := Parent (Derived_Type);\n \n       begin\n@@ -10578,10 +10921,7 @@ package body Sem_Ch3 is\n                   Set_Scope (New_Id, New_Subp);\n \n                   --  Create a reference to it\n-\n-                  IR := Make_Itype_Reference (Sloc (Parent (Derived_Type)));\n-                  Set_Itype (IR, Acc_Type);\n-                  Insert_After (Parent (Derived_Type), IR);\n+                  Build_Itype_Reference (Acc_Type, Parent (Derived_Type));\n \n                else\n                   Set_Etype (New_Id, Etype (Id));\n@@ -10802,16 +11142,42 @@ package body Sem_Ch3 is\n       --  function is not abstract unless the actual is.\n \n       if Is_Generic_Type (Derived_Type)\n-        and then not Is_Abstract (Derived_Type)\n+        and then not Is_Abstract_Type (Derived_Type)\n       then\n          null;\n \n-      elsif Is_Abstract (Alias (New_Subp))\n-        or else (Is_Tagged_Type (Derived_Type)\n-                   and then Etype (New_Subp) = Derived_Type\n-                   and then No (Actual_Subp))\n+      --  Ada 2005 (AI-228): Calculate the \"require overriding\" and \"abstract\"\n+      --  properties of the subprogram, as defined in RM-3.9.3(4/2-6/2).\n+\n+      elsif Ada_Version >= Ada_05\n+        and then (Is_Abstract_Subprogram (Alias (New_Subp))\n+                   or else (Is_Tagged_Type (Derived_Type)\n+                            and then Etype (New_Subp) = Derived_Type\n+                            and then not Is_Null_Extension (Derived_Type))\n+                   or else (Is_Tagged_Type (Derived_Type)\n+                            and then Ekind (Etype (New_Subp)) =\n+                                                       E_Anonymous_Access_Type\n+                            and then Designated_Type (Etype (New_Subp)) =\n+                                                       Derived_Type\n+                            and then not Is_Null_Extension (Derived_Type)))\n+        and then No (Actual_Subp)\n+      then\n+         if not Is_Tagged_Type (Derived_Type)\n+           or else Is_Abstract_Type (Derived_Type)\n+           or else Is_Abstract_Subprogram (Alias (New_Subp))\n+         then\n+            Set_Is_Abstract_Subprogram (New_Subp);\n+         else\n+            Set_Requires_Overriding (New_Subp);\n+         end if;\n+\n+      elsif Ada_Version < Ada_05\n+        and then (Is_Abstract_Subprogram (Alias (New_Subp))\n+                   or else (Is_Tagged_Type (Derived_Type)\n+                             and then Etype (New_Subp) = Derived_Type\n+                             and then No (Actual_Subp)))\n       then\n-         Set_Is_Abstract (New_Subp);\n+         Set_Is_Abstract_Subprogram (New_Subp);\n \n       --  Finally, if the parent type is abstract  we must verify that all\n       --  inherited operations are either non-abstract or overridden, or\n@@ -10822,13 +11188,13 @@ package body Sem_Ch3 is\n       --  the parent type, in which case the abstractness of the inherited\n       --  operation is carried to the new subprogram.\n \n-      elsif Is_Abstract (Parent_Type)\n+      elsif Is_Abstract_Type (Parent_Type)\n         and then not In_Open_Scopes (Scope (Parent_Type))\n         and then Is_Private_Overriding\n-        and then Is_Abstract (Visible_Subp)\n+        and then Is_Abstract_Subprogram (Visible_Subp)\n       then\n          Set_Alias (New_Subp, Visible_Subp);\n-         Set_Is_Abstract (New_Subp);\n+         Set_Is_Abstract_Subprogram (New_Subp);\n       end if;\n \n       New_Overloaded_Entity (New_Subp, Derived_Type);\n@@ -10918,7 +11284,7 @@ package body Sem_Ch3 is\n \n                --  Ada 2005 (AI-251): Add the derivation of an abstract\n                --  interface primitive to the list of entities to which\n-               --  we have to associate aliased entity.\n+               --  we have to associate an aliased entity.\n \n                if Ada_Version >= Ada_05\n                  and then Is_Dispatching_Operation (Subp)\n@@ -10939,7 +11305,11 @@ package body Sem_Ch3 is\n          Next_Elmt (Elmt);\n       end loop;\n \n-      Derive_Interface_Subprograms (Parent_Type, Derived_Type, Ifaces_List);\n+      if Ada_Version >= Ada_05\n+        and then Is_Tagged_Type (Derived_Type)\n+      then\n+         Derive_Interface_Subprograms (Parent_Type, Derived_Type, Ifaces_List);\n+      end if;\n    end Derive_Subprograms;\n \n    --------------------------------\n@@ -11116,16 +11486,19 @@ package body Sem_Ch3 is\n                   null;\n \n                elsif Protected_Present (Iface_Def) then\n-                  Error_Msg_N (\"(Ada 2005) non-limited interface cannot\" &\n-                    \" inherit from protected interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) non-limited interface cannot \" &\n+                     \"inherit from protected interface\", Indic);\n \n                elsif Synchronized_Present (Iface_Def) then\n-                  Error_Msg_N (\"(Ada 2005) non-limited interface cannot\" &\n-                    \" inherit from synchronized interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) non-limited interface cannot \" &\n+                     \"inherit from synchronized interface\", Indic);\n \n                elsif Task_Present (Iface_Def) then\n-                  Error_Msg_N (\"(Ada 2005) non-limited interface cannot\" &\n-                    \" inherit from task interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) non-limited interface cannot \" &\n+                     \"inherit from task interface\", Indic);\n \n                else\n                   null;\n@@ -11134,6 +11507,16 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      if Is_Tagged_Type (Parent_Type)\n+        and then Is_Concurrent_Type (Parent_Type)\n+        and then not Is_Interface (Parent_Type)\n+        and then not Is_Completion\n+      then\n+         Error_Msg_N (\"parent type of a record extension cannot be \" &\n+            \"a synchronized tagged type (3.9.1 (3/1)\", N);\n+         return;\n+      end if;\n+\n       --  Ada 2005 (AI-251): Decorate all the names in the list of ancestor\n       --  interfaces\n \n@@ -12681,21 +13064,24 @@ package body Sem_Ch3 is\n    -----------------------\n \n    function Is_Null_Extension (T : Entity_Id) return Boolean is\n-      Full_Type_Decl : constant Node_Id := Parent (T);\n-      Full_Type_Defn : constant Node_Id := Type_Definition (Full_Type_Decl);\n-      Comp_List      : Node_Id;\n-      First_Comp     : Node_Id;\n+      Type_Decl  : constant Node_Id := Parent (T);\n+      Comp_List  : Node_Id;\n+      First_Comp : Node_Id;\n \n    begin\n-      if not Is_Tagged_Type (T)\n-        or else Nkind (Full_Type_Defn) /= N_Derived_Type_Definition\n+      if Nkind (Type_Decl) /= N_Full_Type_Declaration\n+        or else not Is_Tagged_Type (T)\n+        or else Nkind (Type_Definition (Type_Decl)) /=\n+                                              N_Derived_Type_Definition\n+        or else No (Record_Extension_Part (Type_Definition (Type_Decl)))\n       then\n          return False;\n       end if;\n \n-      Comp_List := Component_List (Record_Extension_Part (Full_Type_Defn));\n+      Comp_List :=\n+        Component_List (Record_Extension_Part (Type_Definition (Type_Decl)));\n \n-      if Present (Discriminant_Specifications (Full_Type_Decl)) then\n+      if Present (Discriminant_Specifications (Type_Decl)) then\n          return False;\n \n       elsif Present (Comp_List)\n@@ -12956,7 +13342,7 @@ package body Sem_Ch3 is\n       Set_Ekind                (CW_Type, E_Class_Wide_Type);\n       Set_Is_Tagged_Type       (CW_Type, True);\n       Set_Primitive_Operations (CW_Type, New_Elmt_List);\n-      Set_Is_Abstract          (CW_Type, False);\n+      Set_Is_Abstract_Type     (CW_Type, False);\n       Set_Is_Constrained       (CW_Type, False);\n       Set_Is_First_Subtype     (CW_Type, Is_First_Subtype (T));\n       Init_Size_Align          (CW_Type);\n@@ -13705,8 +14091,7 @@ package body Sem_Ch3 is\n                                            (Discriminant_Type (Discr)))\n             then\n                Discr_Type :=\n-                 Replace_Anonymous_Access_To_Protected_Subprogram\n-                   (Discr, Discr_Type);\n+                 Replace_Anonymous_Access_To_Protected_Subprogram (Discr);\n             end if;\n \n          else\n@@ -14080,7 +14465,9 @@ package body Sem_Ch3 is\n            (\"completion of nonlimited type cannot be limited\", Full_T);\n          Explain_Limited_Type (Full_T, Full_T);\n \n-      elsif Is_Abstract (Full_T) and then not Is_Abstract (Priv_T) then\n+      elsif Is_Abstract_Type (Full_T)\n+        and then not Is_Abstract_Type (Priv_T)\n+      then\n          Error_Msg_N\n            (\"completion of nonabstract type cannot be abstract\", Full_T);\n \n@@ -14105,13 +14492,12 @@ package body Sem_Ch3 is\n \n       --  Check that ancestor interfaces of private and full views are\n       --  consistent. We omit this check for synchronized types because\n-      --  they are performed on thecorresponding record type when frozen.\n+      --  they are performed on the corresponding record type when frozen.\n \n       if Ada_Version >= Ada_05\n         and then Is_Tagged_Type (Priv_T)\n         and then Is_Tagged_Type (Full_T)\n-        and then Ekind (Full_T) /= E_Task_Type\n-        and then Ekind (Full_T) /= E_Protected_Type\n+        and then not Is_Concurrent_Type (Full_T)\n       then\n          declare\n             Iface         : Entity_Id;\n@@ -14309,8 +14695,7 @@ package body Sem_Ch3 is\n       if Ada_Version >= Ada_05\n         and then Nkind (Parent (Priv_T)) = N_Private_Extension_Declaration\n         and then Synchronized_Present (Parent (Priv_T))\n-        and then Ekind (Full_T) /= E_Task_Type\n-        and then Ekind (Full_T) /= E_Protected_Type\n+        and then not Is_Concurrent_Type (Full_T)\n       then\n          Error_Msg_N (\"full view of synchronized extension must \" &\n                       \"be synchronized type\", N);\n@@ -14374,8 +14759,7 @@ package body Sem_Ch3 is\n       --  operations from the private view to the full view.\n \n       if Is_Tagged_Type (Full_T)\n-        and then Ekind (Full_T) /= E_Task_Type\n-        and then Ekind (Full_T) /= E_Protected_Type\n+        and then not Is_Concurrent_Type (Full_T)\n       then\n          declare\n             Priv_List : Elist_Id;\n@@ -15079,6 +15463,15 @@ package body Sem_Ch3 is\n             when Access_Kind =>\n                Constrain_Access (Def_Id, S, Related_Nod);\n \n+               if Expander_Active\n+                 and then  Is_Itype (Designated_Type (Def_Id))\n+                 and then Nkind (Related_Nod) = N_Subtype_Declaration\n+                 and then not Is_Incomplete_Type (Designated_Type (Def_Id))\n+               then\n+                  Build_Itype_Reference\n+                    (Designated_Type (Def_Id), Related_Nod);\n+               end if;\n+\n             when Array_Kind =>\n                Constrain_Array (Def_Id, S, Related_Nod, Related_Id, Suffix);\n \n@@ -15142,13 +15535,7 @@ package body Sem_Ch3 is\n                     and then\n                       Nkind (Parent (P)) = N_Full_Type_Declaration\n                   then\n-                     declare\n-                        Ref_Node : Node_Id;\n-                     begin\n-                        Ref_Node := Make_Itype_Reference (Sloc (Related_Nod));\n-                        Set_Itype (Ref_Node, Def_Id);\n-                        Insert_After (Parent (P), Ref_Node);\n-                     end;\n+                     Build_Itype_Reference (Def_Id, Parent (P));\n                   end if;\n \n                else\n@@ -15172,274 +15559,317 @@ package body Sem_Ch3 is\n       end if;\n    end Process_Subtype;\n \n-   -----------------------------\n-   -- Record_Type_Declaration --\n-   -----------------------------\n+   ---------------------------------------\n+   -- Check_Anonymous_Access_Components --\n+   ---------------------------------------\n \n-   procedure Record_Type_Declaration\n-     (T    : Entity_Id;\n-      N    : Node_Id;\n-      Prev : Entity_Id)\n+   procedure Check_Anonymous_Access_Components\n+      (Typ_Decl  : Node_Id;\n+       Typ       : Entity_Id;\n+       Prev      : Entity_Id;\n+       Comp_List : Node_Id)\n    is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Def   : constant Node_Id    := Type_Definition (N);\n-      Inc_T : Entity_Id := Empty;\n-\n-      Is_Tagged : Boolean;\n-      Tag_Comp  : Entity_Id;\n-\n-      procedure Check_Anonymous_Access_Types (Comp_List : Node_Id);\n-      --  Ada 2005 AI-382: an access component in a record declaration can\n-      --  refer to the enclosing record, in which case it denotes the type\n-      --  itself, and not the current instance of the type. We create an\n-      --  anonymous access type for the component, and flag it as an access\n-      --  to a component, so that accessibility checks are properly performed\n-      --  on it. The declaration of the access type is placed ahead of that\n-      --  of the record, to prevent circular order-of-elaboration issues in\n-      --  Gigi. We create an incomplete type for the record declaration, which\n-      --  is the designated type of the anonymous access.\n-\n-      procedure Make_Incomplete_Type_Declaration;\n+      Loc         : constant Source_Ptr := Sloc (Typ_Decl);\n+      Anon_Access : Entity_Id;\n+      Acc_Def     : Node_Id;\n+      Comp        : Node_Id;\n+      Comp_Def    : Node_Id;\n+      Decl        : Node_Id;\n+      Type_Def    : Node_Id;\n+\n+      procedure Build_Incomplete_Type_Declaration;\n       --  If the record type contains components that include an access to the\n-      --  current record, create an incomplete type declaration for the record,\n-      --  to be used as the designated type of the anonymous access. This is\n-      --  done only once, and only if there is no previous partial view of the\n-      --  type.\n-\n-      ----------------------------------\n-      -- Check_Anonymous_Access_Types --\n-      ----------------------------------\n+      --  current record, then create an incomplete type declaration for the\n+      --  record, to be used as the designated type of the anonymous access.\n+      --  This is done only once, and only if there is no previous partial\n+      --  view of the type.\n+\n+      function Mentions_T (Acc_Def : Node_Id) return Boolean;\n+      --  Check whether an access definition includes a reference to\n+      --  the enclosing record type. The reference can be a subtype\n+      --  mark in the access definition itself, or a 'Class attribute\n+      --  reference, or recursively a reference appearing in a parameter\n+      --  type in an access_to_subprogram definition.\n \n-      procedure Check_Anonymous_Access_Types (Comp_List : Node_Id) is\n-         Anon_Access : Entity_Id;\n-         Acc_Def     : Node_Id;\n-         Comp        : Node_Id;\n-         Comp_Def    : Node_Id;\n-         Decl        : Node_Id;\n-         Type_Def    : Node_Id;\n+      --------------------------------------\n+      -- Build_Incomplete_Type_Declaration --\n+      --------------------------------------\n \n-         function Mentions_T (Acc_Def : Node_Id) return Boolean;\n-         --  Check whether an access definition includes a reference to\n-         --  the enclosing record type. The reference can be a subtype\n-         --  mark in the access definition itself, or a 'Class attribute\n-         --  reference, or recursively a reference appearing in a parameter\n-         --  type in an access_to_subprogram definition.\n+      procedure Build_Incomplete_Type_Declaration is\n+         Decl  : Node_Id;\n+         Inc_T : Entity_Id;\n+         H     : Entity_Id;\n \n-         ----------------\n-         -- Mentions_T --\n-         ----------------\n+      begin\n+         --  If there is a previous partial view, no need to create a new one\n+         --  If the partial view, given by Prev, is incomplete,  If Prev is\n+         --  a private declaration, full declaration is flagged accordingly.\n \n-         function Mentions_T (Acc_Def : Node_Id) return Boolean is\n-            Subt : Node_Id;\n+         if Prev /= Typ then\n+            if Tagged_Present (Type_Definition (Typ_Decl)) then\n+               Make_Class_Wide_Type (Prev);\n+               Set_Class_Wide_Type (Typ, Class_Wide_Type (Prev));\n+               Set_Etype (Class_Wide_Type (Typ), Typ);\n+            end if;\n \n-         begin\n-            if No (Access_To_Subprogram_Definition (Acc_Def)) then\n-               Subt := Subtype_Mark (Acc_Def);\n+            return;\n \n-               if Nkind (Subt) = N_Identifier then\n-                  return Chars (Subt) = Chars (T);\n+         elsif Has_Private_Declaration (Typ) then\n+            return;\n \n-               --  A reference to the current type may appear as the prefix\n-               --  of a 'Class attribute.\n+         --  If there was a previous anonymous access type, the incomplete\n+         --  type declaration will have been created already.\n \n-               elsif Nkind (Subt) = N_Attribute_Reference\n-                  and then Attribute_Name (Subt) = Name_Class\n-                  and then Is_Entity_Name (Prefix (Subt))\n-               then\n-                  return (Chars (Prefix (Subt))) = Chars (T);\n-               else\n-                  return False;\n-               end if;\n+         elsif Present (Current_Entity (Typ))\n+           and then Ekind (Current_Entity (Typ)) = E_Incomplete_Type\n+           and then Full_View (Current_Entity (Typ)) = Typ\n+         then\n+            return;\n \n-            else\n-               --  Component is an access_to_subprogram: examine its formals\n+         else\n+            Inc_T  := Make_Defining_Identifier (Loc, Chars (Typ));\n+            Decl   := Make_Incomplete_Type_Declaration (Loc, Inc_T);\n \n-               declare\n-                  Param_Spec : Node_Id;\n+            --  Type has already been inserted into the current scope.\n+            --  Remove it, and add incomplete declaration for type, so\n+            --  that subsequent anonymous access types can use it.\n+            --  The entity is unchained from the homonym list and from\n+            --  immediate visibility. After analysis, the entity in the\n+            --  incomplete declaration becomes immediately visible in the\n+            --  record declaration that follows.\n \n-               begin\n-                  Param_Spec :=\n-                    First\n-                      (Parameter_Specifications\n-                        (Access_To_Subprogram_Definition (Acc_Def)));\n-                  while Present (Param_Spec) loop\n-                     if Nkind (Parameter_Type (Param_Spec))\n-                          = N_Access_Definition\n-                       and then Mentions_T (Parameter_Type (Param_Spec))\n-                     then\n-                        return True;\n-                     end if;\n+            H := Current_Entity (Typ);\n \n-                     Next (Param_Spec);\n-                  end loop;\n+            if H = Typ then\n+               Set_Name_Entity_Id (Chars (Typ), Homonym (Typ));\n+            else\n+               while Present (H)\n+                 and then Homonym (H) /= Typ\n+               loop\n+                  H := Homonym (Typ);\n+               end loop;\n \n-                  return False;\n-               end;\n+               Set_Homonym (H, Homonym (Typ));\n             end if;\n-         end Mentions_T;\n-\n-      --  Start of processing for Check_Anonymous_Access_Types\n \n-      begin\n-         if No (Comp_List) then\n-            return;\n-         end if;\n+            Insert_Before (Typ_Decl, Decl);\n+            Analyze (Decl);\n+            Set_Full_View (Inc_T, Typ);\n \n-         Comp := First (Component_Items (Comp_List));\n-         while Present (Comp) loop\n-            if Nkind (Comp) = N_Component_Declaration\n-              and then Present\n-                (Access_Definition (Component_Definition (Comp)))\n-              and then\n-                Mentions_T (Access_Definition (Component_Definition (Comp)))\n+            if (Nkind (Type_Definition (Typ_Decl)) = N_Derived_Type_Definition\n+                 and then\n+                   Present\n+                     (Record_Extension_Part (Type_Definition (Typ_Decl))))\n+              or else Tagged_Present (Type_Definition (Typ_Decl))\n             then\n-               Comp_Def := Component_Definition (Comp);\n-               Acc_Def :=\n-                 Access_To_Subprogram_Definition\n-                   (Access_Definition (Comp_Def));\n+               --  Create a common class-wide type for both views, and set\n+               --  the etype of the class-wide type to the full view.\n \n-               Make_Incomplete_Type_Declaration;\n-               Anon_Access :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_Internal_Name ('S'));\n-\n-               --  Create a declaration for the anonymous access type: either\n-               --  an access_to_object or an access_to_subprogram.\n-\n-               if Present (Acc_Def) then\n-                  if Nkind  (Acc_Def) = N_Access_Function_Definition then\n-                     Type_Def :=\n-                       Make_Access_Function_Definition (Loc,\n-                         Parameter_Specifications =>\n-                           Parameter_Specifications (Acc_Def),\n-                         Result_Definition => Result_Definition (Acc_Def));\n-                  else\n-                     Type_Def :=\n-                       Make_Access_Procedure_Definition (Loc,\n-                         Parameter_Specifications =>\n-                           Parameter_Specifications (Acc_Def));\n-                  end if;\n+               Make_Class_Wide_Type (Inc_T);\n+               Set_Class_Wide_Type (Typ, Class_Wide_Type (Inc_T));\n+               Set_Etype (Class_Wide_Type (Typ), Typ);\n+            end if;\n+         end if;\n+      end Build_Incomplete_Type_Declaration;\n \n-               else\n-                  Type_Def :=\n-                    Make_Access_To_Object_Definition (Loc,\n-                      Subtype_Indication =>\n-                         Relocate_Node\n-                           (Subtype_Mark\n-                             (Access_Definition (Comp_Def))));\n-               end if;\n+      ----------------\n+      -- Mentions_T --\n+      ----------------\n \n-               Decl := Make_Full_Type_Declaration (Loc,\n-                  Defining_Identifier => Anon_Access,\n-                  Type_Definition => Type_Def);\n+      function Mentions_T (Acc_Def : Node_Id) return Boolean is\n+         Subt : Node_Id;\n+         Type_Id : constant Name_Id := Chars (Typ);\n \n-               Insert_Before (N, Decl);\n-               Analyze (Decl);\n+      begin\n+         if No (Access_To_Subprogram_Definition (Acc_Def)) then\n+            Subt := Subtype_Mark (Acc_Def);\n \n-               --  If an access to object, Preserve entity of designated type,\n-               --  for ASIS use, before rewriting the component definition.\n+            if Nkind (Subt) = N_Identifier then\n+               return Chars (Subt) = Type_Id;\n \n-               if No (Acc_Def) then\n-                  declare\n-                     Desig : Entity_Id;\n+            --  Reference can be through an expanded name which has not been\n+            --  analyzed yet, and designates enclosing scopes.\n \n-                  begin\n-                     Desig := Entity (Subtype_Indication (Type_Def));\n+            elsif Nkind (Subt) = N_Selected_Component then\n+               Analyze (Prefix (Subt));\n \n-                     --  If the access definition is to the current  record,\n-                     --  the visible entity at this point is an  incomplete\n-                     --  type. Retrieve the full view to simplify  ASIS queries\n+               if Chars (Selector_Name (Subt)) = Type_Id then\n+                  return Is_Entity_Name (Prefix (Subt))\n+                    and then Entity (Prefix (Subt)) = Current_Scope;\n \n-                     if Ekind (Desig) = E_Incomplete_Type then\n-                        Desig := Full_View (Desig);\n-                     end if;\n+               --  The access definition may name a subtype of the enclosing\n+               --  type, if there is a previous incomplete declaration for it.\n \n-                     Set_Entity\n-                       (Subtype_Mark (Access_Definition  (Comp_Def)), Desig);\n-                  end;\n+               else\n+                  Find_Selected_Component (Subt);\n+                  return\n+                    Is_Entity_Name (Subt)\n+                      and then Scope (Entity (Subt)) = Current_Scope\n+                      and then (Chars (Base_Type (Entity (Subt))) = Type_Id\n+                        or else\n+                          (Is_Class_Wide_Type (Entity (Subt))\n+                            and then\n+                              Chars (Etype (Base_Type (Entity (Subt))))\n+                                = Type_Id));\n                end if;\n \n-               Rewrite (Comp_Def,\n-                 Make_Component_Definition (Loc,\n-                   Subtype_Indication =>\n-                  New_Occurrence_Of (Anon_Access, Loc)));\n-               Set_Ekind (Anon_Access, E_Anonymous_Access_Type);\n-               Set_Is_Local_Anonymous_Access (Anon_Access);\n+            --  A reference to the current type may appear as the prefix of\n+            --  a 'Class attribute.\n+\n+            elsif Nkind (Subt) = N_Attribute_Reference\n+               and then Attribute_Name (Subt) = Name_Class\n+               and then Is_Entity_Name (Prefix (Subt))\n+            then\n+               return (Chars (Prefix (Subt))) = Type_Id;\n+            else\n+               return False;\n             end if;\n \n-            Next (Comp);\n-         end loop;\n+         else\n+            --  Component is an access_to_subprogram: examine its formals\n \n-         if Present (Variant_Part (Comp_List)) then\n             declare\n-               V : Node_Id;\n+               Param_Spec : Node_Id;\n+\n             begin\n-               V := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n-               while Present (V) loop\n-                  Check_Anonymous_Access_Types (Component_List (V));\n-                  Next_Non_Pragma (V);\n+               Param_Spec :=\n+                 First\n+                   (Parameter_Specifications\n+                     (Access_To_Subprogram_Definition (Acc_Def)));\n+               while Present (Param_Spec) loop\n+                  if Nkind (Parameter_Type (Param_Spec))\n+                       = N_Access_Definition\n+                    and then Mentions_T (Parameter_Type (Param_Spec))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next (Param_Spec);\n                end loop;\n+\n+               return False;\n             end;\n          end if;\n-      end Check_Anonymous_Access_Types;\n+      end Mentions_T;\n \n-      --------------------------------------\n-      -- Make_Incomplete_Type_Declaration --\n-      --------------------------------------\n+   --  Start of processing for Check_Anonymous_Access_Components\n \n-      procedure Make_Incomplete_Type_Declaration is\n-         Decl : Node_Id;\n-         H    : Entity_Id;\n-\n-      begin\n-         --  If there is a previous partial view, no need to create a new one\n-         --  If the partial view is incomplete, it is given by Prev. If it is\n-         --  a private declaration, full declaration is flagged accordingly.\n+   begin\n+      if No (Comp_List) then\n+         return;\n+      end if;\n \n-         if Prev /= T\n-           or else Has_Private_Declaration (T)\n+      Comp := First (Component_Items (Comp_List));\n+      while Present (Comp) loop\n+         if Nkind (Comp) = N_Component_Declaration\n+           and then Present\n+             (Access_Definition (Component_Definition (Comp)))\n+           and then\n+             Mentions_T (Access_Definition (Component_Definition (Comp)))\n          then\n-            return;\n+            Comp_Def := Component_Definition (Comp);\n+            Acc_Def :=\n+              Access_To_Subprogram_Definition\n+                (Access_Definition (Comp_Def));\n \n-         elsif No (Inc_T) then\n-            Inc_T  := Make_Defining_Identifier (Loc, Chars (T));\n-            Decl   := Make_Incomplete_Type_Declaration (Loc, Inc_T);\n+            Build_Incomplete_Type_Declaration;\n+            Anon_Access :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('S'));\n \n-            --  Type has already been inserted into the current scope.\n-            --  Remove it, and add incomplete declaration for type, so\n-            --  that subsequent anonymous access types can use it.\n-            --  The entity is unchained from the homonym list and from\n-            --  immediate visibility. After analysis, the entity in the\n-            --  incomplete declaration becomes immediately visible in the\n-            --  record declaration that follows.\n+            --  Create a declaration for the anonymous access type: either\n+            --  an access_to_object or an access_to_subprogram.\n \n-            H := Current_Entity (T);\n+            if Present (Acc_Def) then\n+               if Nkind  (Acc_Def) = N_Access_Function_Definition then\n+                  Type_Def :=\n+                    Make_Access_Function_Definition (Loc,\n+                      Parameter_Specifications =>\n+                        Parameter_Specifications (Acc_Def),\n+                      Result_Definition => Result_Definition (Acc_Def));\n+               else\n+                  Type_Def :=\n+                    Make_Access_Procedure_Definition (Loc,\n+                      Parameter_Specifications =>\n+                        Parameter_Specifications (Acc_Def));\n+               end if;\n \n-            if H = T then\n-               Set_Name_Entity_Id (Chars (T), Homonym (T));\n             else\n-               while Present (H)\n-                 and then Homonym (H) /= T\n-               loop\n-                  H := Homonym (T);\n-               end loop;\n-\n-               Set_Homonym (H, Homonym (T));\n+               Type_Def :=\n+                 Make_Access_To_Object_Definition (Loc,\n+                   Subtype_Indication =>\n+                      Relocate_Node\n+                        (Subtype_Mark\n+                          (Access_Definition (Comp_Def))));\n             end if;\n \n-            Insert_Before (N, Decl);\n+            Decl := Make_Full_Type_Declaration (Loc,\n+               Defining_Identifier => Anon_Access,\n+               Type_Definition => Type_Def);\n+\n+            Insert_Before (Typ_Decl, Decl);\n             Analyze (Decl);\n-            Set_Full_View (Inc_T, T);\n \n-            if Tagged_Present (Def) then\n-               Make_Class_Wide_Type (Inc_T);\n-               Set_Class_Wide_Type (T, Class_Wide_Type (Inc_T));\n-               Set_Etype (Class_Wide_Type (T), T);\n+            --  If an access to object, Preserve entity of designated type,\n+            --  for ASIS use, before rewriting the component definition.\n+\n+            if No (Acc_Def) then\n+               declare\n+                  Desig : Entity_Id;\n+\n+               begin\n+                  Desig := Entity (Subtype_Indication (Type_Def));\n+\n+                  --  If the access definition is to the current  record,\n+                  --  the visible entity at this point is an  incomplete\n+                  --  type. Retrieve the full view to simplify  ASIS queries\n+\n+                  if Ekind (Desig) = E_Incomplete_Type then\n+                     Desig := Full_View (Desig);\n+                  end if;\n+\n+                  Set_Entity\n+                    (Subtype_Mark (Access_Definition  (Comp_Def)), Desig);\n+               end;\n             end if;\n+\n+            Rewrite (Comp_Def,\n+              Make_Component_Definition (Loc,\n+                Subtype_Indication =>\n+               New_Occurrence_Of (Anon_Access, Loc)));\n+            Set_Ekind (Anon_Access, E_Anonymous_Access_Type);\n+            Set_Is_Local_Anonymous_Access (Anon_Access);\n          end if;\n-      end Make_Incomplete_Type_Declaration;\n \n-   --  Start of processing for Record_Type_Declaration\n+         Next (Comp);\n+      end loop;\n+\n+      if Present (Variant_Part (Comp_List)) then\n+         declare\n+            V : Node_Id;\n+         begin\n+            V := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n+            while Present (V) loop\n+               Check_Anonymous_Access_Components\n+                 (Typ_Decl, Typ, Prev, Component_List (V));\n+               Next_Non_Pragma (V);\n+            end loop;\n+         end;\n+      end if;\n+   end Check_Anonymous_Access_Components;\n+\n+   -----------------------------\n+   -- Record_Type_Declaration --\n+   -----------------------------\n+\n+   procedure Record_Type_Declaration\n+     (T    : Entity_Id;\n+      N    : Node_Id;\n+      Prev : Entity_Id)\n+   is\n+      Def       : constant Node_Id := Type_Definition (N);\n+      Is_Tagged : Boolean;\n+      Tag_Comp  : Entity_Id;\n \n    begin\n       --  These flags must be initialized before calling Process_Discriminants\n@@ -15471,7 +15901,7 @@ package body Sem_Ch3 is\n          --  Type is abstract if full declaration carries keyword, or if\n          --  previous partial view did.\n \n-         Set_Is_Abstract         (T, Is_Abstract (T)\n+         Set_Is_Abstract_Type    (T, Is_Abstract_Type (T)\n                                       or else Abstract_Present (Def));\n \n       else\n@@ -15490,100 +15920,17 @@ package body Sem_Ch3 is\n       --  create the required anonymous access type declarations, and if\n       --  need be an incomplete type declaration for T itself.\n \n-      Check_Anonymous_Access_Types (Component_List (Def));\n+      Check_Anonymous_Access_Components (N, T, Prev, Component_List (Def));\n \n       if Ada_Version >= Ada_05\n         and then Present (Interface_List (Def))\n       then\n+         Check_Abstract_Interfaces (N, Def);\n+\n          declare\n-            Iface       : Node_Id;\n-            Iface_Def   : Node_Id;\n-            Iface_Typ   : Entity_Id;\n             Ifaces_List : Elist_Id;\n \n          begin\n-            Iface := First (Interface_List (Def));\n-            while Present (Iface) loop\n-               Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n-               Iface_Def := Type_Definition (Parent (Iface_Typ));\n-\n-               if not Is_Interface (Iface_Typ) then\n-                  Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n-                                Iface, Iface_Typ);\n-\n-               else\n-                  --  \"The declaration of a specific descendant of an\n-                  --  interface type freezes the interface type\" RM 13.14\n-\n-                  Freeze_Before (N, Iface_Typ);\n-\n-                  --  Ada 2005 (AI-345): Protected interfaces can only\n-                  --  inherit from limited, synchronized or protected\n-                  --  interfaces.\n-\n-                  if Protected_Present (Def) then\n-                     if Limited_Present (Iface_Def)\n-                       or else Synchronized_Present (Iface_Def)\n-                       or else Protected_Present (Iface_Def)\n-                     then\n-                        null;\n-\n-                     elsif Task_Present (Iface_Def) then\n-                        Error_Msg_N (\"(Ada 2005) protected interface cannot\"\n-                          & \" inherit from task interface\", Iface);\n-\n-                     else\n-                        Error_Msg_N (\"(Ada 2005) protected interface cannot\"\n-                          & \" inherit from non-limited interface\", Iface);\n-                     end if;\n-\n-                  --  Ada 2005 (AI-345): Synchronized interfaces can only\n-                  --  inherit from limited and synchronized.\n-\n-                  elsif Synchronized_Present (Def) then\n-                     if Limited_Present (Iface_Def)\n-                       or else Synchronized_Present (Iface_Def)\n-                     then\n-                        null;\n-\n-                     elsif Protected_Present (Iface_Def) then\n-                        Error_Msg_N (\"(Ada 2005) synchronized interface \" &\n-                          \"cannot inherit from protected interface\", Iface);\n-\n-                     elsif Task_Present (Iface_Def) then\n-                        Error_Msg_N (\"(Ada 2005) synchronized interface \" &\n-                          \"cannot inherit from task interface\", Iface);\n-\n-                     else\n-                        Error_Msg_N (\"(Ada 2005) synchronized interface \" &\n-                          \"cannot inherit from non-limited interface\",\n-                          Iface);\n-                     end if;\n-\n-                  --  Ada 2005 (AI-345): Task interfaces can only inherit\n-                  --  from limited, synchronized or task interfaces.\n-\n-                  elsif Task_Present (Def) then\n-                     if Limited_Present (Iface_Def)\n-                       or else Synchronized_Present (Iface_Def)\n-                       or else Task_Present (Iface_Def)\n-                     then\n-                        null;\n-\n-                     elsif Protected_Present (Iface_Def) then\n-                        Error_Msg_N (\"(Ada 2005) task interface cannot\" &\n-                          \" inherit from protected interface\", Iface);\n-\n-                     else\n-                        Error_Msg_N (\"(Ada 2005) task interface cannot\" &\n-                          \" inherit from non-limited interface\", Iface);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Next (Iface);\n-            end loop;\n-\n             --  Ada 2005 (AI-251): Collect the list of progenitors that are not\n             --  already in the parents.\n \n@@ -15637,9 +15984,11 @@ package body Sem_Ch3 is\n             Init_Component_Location       (Tag_Comp);\n \n             --  Ada 2005 (AI-251): Addition of the Tag corresponding to all the\n-            --  implemented interfaces\n+            --  implemented interfaces.\n \n-            Add_Interface_Tag_Components (N, T);\n+            if Has_Abstract_Interfaces (T) then\n+               Add_Interface_Tag_Components (N, T);\n+            end if;\n          end if;\n \n          Make_Class_Wide_Type (T);\n@@ -15732,8 +16081,8 @@ package body Sem_Ch3 is\n       end if;\n \n       --  After completing the semantic analysis of the record definition,\n-      --  record components, both new and inherited, are accessible. Set\n-      --  their kind accordingly.\n+      --  record components, both new and inherited, are accessible. Set their\n+      --  kind accordingly.\n \n       Component := First_Entity (Current_Scope);\n       while Present (Component) loop\n@@ -15762,8 +16111,8 @@ package body Sem_Ch3 is\n          Next_Entity (Component);\n       end loop;\n \n-      --  A type is Finalize_Storage_Only only if all its controlled\n-      --  components are so.\n+      --  A Type is Finalize_Storage_Only only if all its controlled components\n+      --  are also.\n \n       if Ctrl_Components then\n          Set_Finalize_Storage_Only (T, Final_Storage_Only);\n@@ -15880,7 +16229,6 @@ package body Sem_Ch3 is\n             Make_Range (Loc,\n               Low_Bound  => Make_Real_Literal (Loc, Lo),\n               High_Bound => Make_Real_Literal (Loc, Hi));\n-\n    begin\n       Set_Scalar_Range (E, S);\n       Set_Parent (S, E);\n@@ -15916,7 +16264,6 @@ package body Sem_Ch3 is\n       Set_Ekind (Def_Id, E_Void);\n       Process_Range_Expr_In_Decl (R, Subt);\n       Set_Ekind (Def_Id, Kind);\n-\n    end Set_Scalar_Range_For_Subtype;\n \n    --------------------------------------------------------"}, {"sha": "2d5fabce206c6c28fef0606682b02c3d279fe642", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea9e956ec1b3e1b95f79e44309cfa93314ddbce/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=fea9e956ec1b3e1b95f79e44309cfa93314ddbce", "patch": "@@ -246,14 +246,12 @@ package Sem_Ch3  is\n    --  Prev is entity on the partial view, on which references are posted.\n \n    function Replace_Anonymous_Access_To_Protected_Subprogram\n-     (N      : Node_Id;\n-      Prev_E : Entity_Id) return Entity_Id;\n+     (N : Node_Id) return Entity_Id;\n    --  Ada 2005 (AI-254): Create and decorate an internal full type declaration\n-   --  in the enclosing scope corresponding to an anonymous access to protected\n-   --  subprogram. In addition, replace the anonymous access by an occurrence\n-   --  of this internal type. Prev_Etype is used to link the new internal\n-   --  entity with the anonymous entity. Return the entity of this type\n-   --  declaration.\n+   --  for an anonymous access to protected subprogram. For a record component\n+   --  declaration, the type is created in the enclosing scope, for an array\n+   --  type declaration or an object declaration it is simply placed ahead of\n+   --  this declaration.\n \n    procedure Set_Completion_Referenced (E : Entity_Id);\n    --  If E is the completion of a private or incomplete  type declaration,"}]}