{"sha": "c5563e117b59e25743f745e976e0c252db635b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU1NjNlMTE3YjU5ZTI1NzQzZjc0NWU5NzZlMGMyNTJkYjYzNWI3MQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-06-01T00:48:34Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-06-01T00:48:34Z"}, "message": "(movesi_unaligned, movsi_ulw, movsi_usw): Delete.\n\n(extv, extzv, insv, movsi_ulw, movsi_usw): New patterns.\n\nFrom-SVN: r7413", "tree": {"sha": "f9861521b9b219cd729b01a411170a05ed029fc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9861521b9b219cd729b01a411170a05ed029fc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5563e117b59e25743f745e976e0c252db635b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5563e117b59e25743f745e976e0c252db635b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5563e117b59e25743f745e976e0c252db635b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5563e117b59e25743f745e976e0c252db635b71/comments", "author": null, "committer": null, "parents": [{"sha": "a40ed31be5fb790bd5281404c0703039ee34de06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ed31be5fb790bd5281404c0703039ee34de06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a40ed31be5fb790bd5281404c0703039ee34de06"}], "stats": {"total": 259, "additions": 136, "deletions": 123}, "files": [{"sha": "f21c90a0b6901204645188df9d3a7d0dacca330e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 136, "deletions": 123, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5563e117b59e25743f745e976e0c252db635b71/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5563e117b59e25743f745e976e0c252db635b71/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=c5563e117b59e25743f745e976e0c252db635b71", "patch": "@@ -2545,130 +2545,143 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\n ;;  ....................\n \n-;; unaligned word moves generated by the block moves.\n-\n-;; I don't think these are used anymore.  Ian Taylor 30 Sep 93\n-\n-;;(define_expand \"movsi_unaligned\"\n-;;  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-;;\t(unspec [(match_operand:SI 1 \"general_operand\" \"\")] 0))]\n-;;  \"\"\n-;;  \"\n-;;{\n-;;  /* Handle stores.  */\n-;;  if (GET_CODE (operands[0]) == MEM)\n-;;    {\n-;;      rtx reg = gen_reg_rtx (SImode);\n-;;      rtx insn = emit_insn (gen_movsi_ulw (reg, operands[1]));\n-;;      rtx addr = XEXP (operands[0], 0);\n-;;      if (CONSTANT_P (addr))\n-;;\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUIV, addr, REG_NOTES (insn));\n-;;\n-;;      if (reg_or_0_operand (operands[1], SImode))\n-;;\tDONE;\n-;;\n-;;      operands[1] = reg;\n-;;    }\n-;;\n-;;  /* Generate appropriate load, store.  If not a load or store,\n-;;     do a normal movsi.  */\n-;;  if (GET_CODE (operands[0]) != MEM && GET_CODE (operands[1]) != MEM)\n-;;    {\n-;;      emit_insn (gen_movsi (operands[0], operands[1]));\n-;;      DONE;\n-;;    }\n-;;\n-;;  /* Fall through and generate normal code.  */\n-;;}\")\n-;;\n-;;(define_insn \"movsi_ulw\"\n-;;  [(set (match_operand:SI 0 \"register_operand\" \"=&d,&d,d,d\")\n-;;\t(unspec [(match_operand:SI 1 \"general_operand\" \"R,o,dIKL,M\")] 0))]\n-;;  \"\"\n-;;  \"*\n-;;{\n-;;  enum rtx_code code;\n-;;  char *ret;\n-;;  rtx offset;\n-;;  rtx addr;\n-;;  rtx mem_addr;\n-;;\n-;;  if (which_alternative != 0)\n-;;    return mips_move_1word (operands, insn, FALSE);\n-;;\n-;;  if (TARGET_STATS)\n-;;    mips_count_memory_refs (operands[1], 2);\n-;;\n-;;  /* The stack/frame pointers are always aligned, so we can convert\n-;;     to the faster lw if we are referencing an aligned stack location.  */\n-;;\n-;;  offset = const0_rtx;\n-;;  addr = XEXP (operands[1], 0);\n-;;  mem_addr = eliminate_constant_term (addr, &offset);\n-;;\n-;;  if ((INTVAL (offset) & (UNITS_PER_WORD-1)) == 0\n-;;      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n-;;    ret = \\\"lw\\\\t%0,%1\\\";\n-;;\n-;;  else\n-;;    {\n-;;      ret = \\\"ulw\\\\t%0,%1\\\";\n-;;      if (TARGET_GAS)\n-;;\t{\n-;;\t  enum rtx_code code = GET_CODE (addr);\n-;;\n-;;\t  if (code == CONST || code == SYMBOL_REF || code == LABEL_REF)\n-;;\t    {\n-;;\t      operands[2] = gen_rtx (REG, SImode, GP_REG_FIRST + 1);\n-;;\t      ret = \\\"%[la\\\\t%2,%1\\;ulw\\\\t%0,0(%2)%]\\\";\n-;;\t    }\n-;;\t}\n-;;    }\n-;;\n-;;  return mips_fill_delay_slot (ret, DELAY_LOAD, operands, insn);\n-;;}\"\n-;;  [(set_attr \"type\"\t\"load,load,move,arith\")\n-;;   (set_attr \"mode\"\t\"SI\")\n-;;   (set_attr \"length\"\t\"2,4,1,2\")])\n-;;\n-;;(define_insn \"movsi_usw\"\n-;;  [(set (match_operand:SI 0 \"memory_operand\" \"=R,o\")\n-;;\t(unspec [(match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")] 0))]\n-;;  \"\"\n-;;  \"*\n-;;{\n-;;  rtx offset = const0_rtx;\n-;;  rtx addr = XEXP (operands[0], 0);\n-;;  rtx mem_addr = eliminate_constant_term (addr, &offset);\n-;;\n-;;  if (TARGET_STATS)\n-;;    mips_count_memory_refs (operands[0], 2);\n-;;\n-;;  /* The stack/frame pointers are always aligned, so we can convert\n-;;     to the faster sw if we are referencing an aligned stack location.  */\n-;;\n-;;  if ((INTVAL (offset) & (UNITS_PER_WORD-1)) == 0\n-;;      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n-;;    return \\\"sw\\\\t%1,%0\\\";\n-;;\n-;;\n-;;  if (TARGET_GAS)\n-;;    {\n-;;      enum rtx_code code = GET_CODE (XEXP (operands[0], 0));\n-;;\n-;;      if (code == CONST || code == SYMBOL_REF || code == LABEL_REF)\n-;;\t{\n-;;\t  operands[2] = gen_rtx (REG, SImode, GP_REG_FIRST + 1);\n-;;\t  return \\\"%[la\\\\t%2,%0\\;usw\\\\t%z1,0(%2)%]\\\";\n-;;\t}\n-;;    }\n-;;\n-;;  return \\\"usw\\\\t%z1,%0\\\";\n-;;}\"\n-;;  [(set_attr \"type\"\t\"store\")\n-;;   (set_attr \"mode\"\t\"SI\")\n-;;   (set_attr \"length\"\t\"2,4\")])\n+;; Bit field extract patterns which use lwl/lwr.\n+\n+;; ??? There should be DImode variants for 64 bit code, but the current\n+;; bitfield scheme can't handle that.  We would need to add new optabs\n+;; in order to make that work.\n+\n+;; ??? There could be HImode variants for the ulh/ulhu/ush macros.\n+;; It isn't clear whether this will give better code.\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* If this isn't a 32 bit field, and it doesn't start on a byte boundary\n+     then fail.  */\n+  if (INTVAL (operands[2]) != 32 || (INTVAL (operands[3]) % 8) != 0)\n+    FAIL;\n+\n+  /* This can happen for a 64 bit target, when extracting a value from\n+     a 64 bit union member.  extract_bit_field doesn't verify that our\n+     source matches the predicate, so we force it to be a MEM here.  */\n+  if (GET_CODE (operands[1]) != MEM)\n+    FAIL;\n+\n+  /* Otherwise, emit a lwl/lwr pair to load the value.  */\n+  emit_insn (gen_movsi_ulw (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* If this isn't a 32 bit field, and it doesn't start on a byte boundary\n+     then fail.  */\n+  if (INTVAL (operands[2]) != 32 || (INTVAL (operands[3]) % 8) != 0)\n+    FAIL;\n+\n+  /* This can happen for a 64 bit target, when extracting a value from\n+     a 64 bit union member.  extract_bit_field doesn't verify that our\n+     source matches the predicate, so we force it to be a MEM here.  */\n+  if (GET_CODE (operands[1]) != MEM)\n+    FAIL;\n+\n+  /* Otherwise, emit a lwl/lwr pair to load the value.  */\n+  emit_insn (gen_movsi_ulw (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\"))\n+\t(match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* If this isn't a 32 bit field, and it doesn't start on a byte boundary\n+     then fail.  */\n+  if (INTVAL (operands[1]) != 32 || (INTVAL (operands[2]) % 8) != 0)\n+    FAIL;\n+\n+  /* This can happen for a 64 bit target, when storing into a 32 bit union\n+     member.  store_bit_field doesn't verify that our target matches the\n+     predicate, so we force it to be a MEM here.  */\n+  if (GET_CODE (operands[0]) != MEM)\n+    FAIL;\n+\n+  /* Otherwise, emit a swl/swr pair to load the value.  */\n+  emit_insn (gen_movsi_usw (operands[0], operands[3]));\n+  DONE;\n+}\")\n+\n+;; unaligned word moves generated by the bit field patterns\n+\n+(define_insn \"movsi_ulw\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d,&d\")\n+\t(unspec [(match_operand:QI 1 \"general_operand\" \"R,o\")] 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx offset = const0_rtx;\n+  rtx addr = XEXP (operands[1], 0);\n+  rtx mem_addr = eliminate_constant_term (addr, &offset);\n+  char *ret;\n+\n+  if (TARGET_STATS)\n+    mips_count_memory_refs (operands[1], 2);\n+\n+  /* The stack/frame pointers are always aligned, so we can convert\n+     to the faster lw if we are referencing an aligned stack location.  */\n+\n+  if ((INTVAL (offset) & 3) == 0\n+      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n+    ret = \\\"lw\\\\t%0,%1\\\";\n+  else\n+    ret = \\\"ulw\\\\t%0,%1\\\";\n \n+  return mips_fill_delay_slot (ret, DELAY_LOAD, operands, insn);\n+}\"\n+  [(set_attr \"type\"\t\"load,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,4\")])\n+\n+(define_insn \"movsi_usw\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=R,o\")\n+\t(unspec [(match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")] 1))]\n+  \"\"\n+  \"*\n+{\n+  rtx offset = const0_rtx;\n+  rtx addr = XEXP (operands[0], 0);\n+  rtx mem_addr = eliminate_constant_term (addr, &offset);\n+\n+  if (TARGET_STATS)\n+    mips_count_memory_refs (operands[0], 2);\n+\n+  /* The stack/frame pointers are always aligned, so we can convert\n+     to the faster sw if we are referencing an aligned stack location.  */\n+\n+  if ((INTVAL (offset) & 3) == 0\n+      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n+    return \\\"sw\\\\t%1,%0\\\";\n+\n+  return \\\"usw\\\\t%z1,%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,4\")])\n \n ;; 64-bit integer moves\n "}]}