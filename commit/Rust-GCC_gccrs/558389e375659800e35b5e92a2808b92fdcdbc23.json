{"sha": "558389e375659800e35b5e92a2808b92fdcdbc23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU4Mzg5ZTM3NTY1OTgwMGUzNWI1ZTkyYTI4MDhiOTJmZGNkYmMyMw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-09-20T12:34:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-20T12:34:26Z"}, "message": "flow.c (merge_blocks_move_predecessor_nojumps): New function.\n\n        * flow.c (merge_blocks_move_predecessor_nojumps): New function.\n        (merge-blocks_move_successor_nojumps): Likewise.\n        (merge_blocks): Allow merging of some blocks, even if it requires\n        physical movement of the blocks, but not if it requires new jumps.\n\nFrom-SVN: r29519", "tree": {"sha": "2ac884d1fad16ea842131c445e07877b59b0bc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ac884d1fad16ea842131c445e07877b59b0bc6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/558389e375659800e35b5e92a2808b92fdcdbc23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558389e375659800e35b5e92a2808b92fdcdbc23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/558389e375659800e35b5e92a2808b92fdcdbc23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558389e375659800e35b5e92a2808b92fdcdbc23/comments", "author": null, "committer": null, "parents": [{"sha": "bfd384967d6e0b1148d608d2132a86d8ee871f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd384967d6e0b1148d608d2132a86d8ee871f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd384967d6e0b1148d608d2132a86d8ee871f27"}], "stats": {"total": 153, "additions": 143, "deletions": 10}, "files": [{"sha": "9d070d179461f362ea8bb2c83829195327dd691c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558389e375659800e35b5e92a2808b92fdcdbc23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558389e375659800e35b5e92a2808b92fdcdbc23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=558389e375659800e35b5e92a2808b92fdcdbc23", "patch": "@@ -1,5 +1,10 @@\n Mon Sep 20 05:41:36 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* flow.c (merge_blocks_move_predecessor_nojumps): New function.\n+\t(merge-blocks_move_successor_nojumps): Likewise.\n+\t(merge_blocks): Allow merging of some blocks, even if it requires\n+\tphysical movement of the blocks, but not if it requires new jumps.\n+\n \t* bitmap.c (debug_bitmap_file): Renmaed from bitmap_debug_file.\n \tCallers and prototype changed.\n \t* bitmap.h: Fix debug_bitmap and debug_bitmap_file prototypes."}, {"sha": "834af4db00f0c2f93fb6adb6b84455131ca9630c", "filename": "gcc/flow.c", "status": "modified", "additions": 138, "deletions": 10, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558389e375659800e35b5e92a2808b92fdcdbc23/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558389e375659800e35b5e92a2808b92fdcdbc23/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=558389e375659800e35b5e92a2808b92fdcdbc23", "patch": "@@ -1847,6 +1847,95 @@ can_delete_label_p (label)\n   return 1;\n }\n \n+/* Blocks A and B are to be merged into a single block.  A has no incoming\n+   fallthru edge, so it can be moved before B without adding or modifying\n+   any jumps (aside from the jump from A to B).  */\n+\n+static int\n+merge_blocks_move_predecessor_nojumps (e, a, b)\n+     edge e;\n+     basic_block a, b;\n+{\n+  rtx start, end, insertpoint, barrier;\n+\n+  start = a->head;\n+  end = a->end;\n+  insertpoint = PREV_INSN (b->head);\n+\n+  /* We want to delete the BARRIER after the end of the insns we are\n+     going to move.  If we don't find a BARRIER, then do nothing.  This\n+     can happen in some cases if we have labels we can not delete. \n+\n+     Similarly, do nothing if we can not delete the label at the start\n+     of the target block.  */\n+  barrier = next_nonnote_insn (end);\n+  if (GET_CODE (barrier) != BARRIER\n+      || (GET_CODE (b->head) == CODE_LABEL\n+\t  && ! can_delete_label_p (b->head)))\n+    return 0;\n+  else\n+    flow_delete_insn (barrier);\n+\n+  /* Move block and loop notes out of the chain so that we do not\n+     disturb their order.\n+\n+     ??? A better solution would be to squeeze out all the non-nested notes\n+     and adjust the block trees appropriately.   Even better would be to have\n+     a tighter connection between block trees and rtl so that this is not\n+     necessary.  */\n+  start = squeeze_notes (start, end);\n+\n+  /* Scramble the insn chain.  */\n+  reorder_insns (start, end, insertpoint);\n+\n+  /* Now blocks A and B are contiguous.  Merge them.  */\n+  merge_blocks_nomove (a, b);\n+  return 1;\n+}\n+\n+/* Blocks A and B are to be merged into a single block.  B has no outgoing\n+   fallthru edge, so it can be moved after A without adding or modifying\n+   any jumps (aside from the jump from A to B).  */\n+\n+static int\n+merge_blocks_move_successor_nojumps (e, a, b)\n+     edge e;\n+     basic_block a, b;\n+{\n+  rtx start, end, insertpoint, barrier;\n+\n+  start = b->head;\n+  end = b->end;\n+  insertpoint = a->end;\n+\n+  /* We want to delete the BARRIER before the start of the insns we are\n+     going to move.  If we don't find a BARRIER, then do nothing.  This\n+     can happen in some cases if we have labels we can not delete.  */\n+  barrier = prev_nonnote_insn (start);\n+  if (GET_CODE (barrier) != BARRIER\n+      || (GET_CODE (b->head) == CODE_LABEL\n+\t  && ! can_delete_label_p (b->head)))\n+    return 0;\n+  else\n+    flow_delete_insn (barrier);\n+\n+  /* Move block and loop notes out of the chain so that we do not\n+     disturb their order.\n+\n+     ??? A better solution would be to squeeze out all the non-nested notes\n+     and adjust the block trees appropriately.   Even better would be to have\n+     a tighter connection between block trees and rtl so that this is not\n+     necessary.  */\n+  start = squeeze_notes (start, end);\n+\n+  /* Scramble the insn chain.  */\n+  reorder_insns (start, end, insertpoint);\n+\n+  /* Now blocks A and B are contiguous.  Merge them.  */\n+  merge_blocks_nomove (a, b);\n+  return 1;\n+}\n+\n /* Blocks A and B are to be merged into a single block.  The insns\n    are already contiguous, hence `nomove'.  */\n \n@@ -1946,19 +2035,58 @@ merge_blocks (e, b, c)\n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (!(e->flags & EDGE_FALLTHRU))\n     {\n+      edge tmp_edge;\n+      int c_has_outgoing_fallthru;\n+      int b_has_incoming_fallthru;\n+\n       /* ??? From here on out we must make sure to not munge nesting\n-\t of exception regions and lexical blocks.  Need to think about\n-\t these cases before this gets implemented.  */\n-      return 0;\n+\t of exception regions and lexical blocks.\n+\n+\t A few notes on the subject:\n+\n+\t  Not only do we have to be careful not to lose the nesting of\n+\t  exception regions or lexical blocks, we also have to be careful\n+\t  about merging blocks which are in different EH regions.\n+\n+\t  A call that throws may end a block.  The insn to copy the return\n+\t  value from its hard reg into a pseudo could end up in a\n+\t  different block than the call.  Moving either block might cause\n+\t  problems for SMALL_REGISTER_CLASS machines.\n \n-      /* If C has an outgoing fallthru, and B does not have an incoming\n-\t fallthru, move B before C.  The later clause is somewhat arbitrary,\n-\t but avoids modifying blocks other than the two we've been given.  */\n+\t  A throw/catch edge (or any abnormal edge) should be rarely\n+\t  executed and we may want to treat blocks which have two out\n+\t  edges, one normal, one abnormal as only having one edge for\n+\t  block merging purposes.\n \n-      /* Otherwise, move C after B.  If C had a fallthru, which doesn't\n-\t happen to be the physical successor to B, insert an unconditional\n-\t branch.  If C already ended with a conditional branch, the new\n-\t jump must go in a new basic block D.  */\n+\t  For now we avoid the EH issues by not allowing any physical\n+\t  block movement when exception handling is enabled.  */\n+      if (flag_exceptions)\n+\treturn 0;\n+\n+      for (tmp_edge = c->succ; tmp_edge ; tmp_edge = tmp_edge->succ_next)\n+\tif (tmp_edge->flags & EDGE_FALLTHRU)\n+\t  break;\n+      c_has_outgoing_fallthru = (tmp_edge != NULL);\n+\n+      for (tmp_edge = b->pred; tmp_edge ; tmp_edge = tmp_edge->pred_next)\n+\tif (tmp_edge->flags & EDGE_FALLTHRU)\n+\t  break;\n+      b_has_incoming_fallthru = (tmp_edge != NULL);\n+\n+      /* If B does not have an incoming fallthru, then it can be moved\n+\t immediately before C without introducing or modifying jumps.\n+\n+\t Else if C does not have an outgoing fallthru, then it can be moved\n+\t immediately after B without introducing or modifying jumps.\n+\n+\t Else move C after B, which will likely require insertion of a\n+\t new jump.  ??? Not implemented yet.  */\n+      if (! b_has_incoming_fallthru)\n+\treturn merge_blocks_move_predecessor_nojumps (e, b, c);\n+      else if (! c_has_outgoing_fallthru)\n+\treturn merge_blocks_move_successor_nojumps (e, b, c);\n+      else\n+\treturn 0;\n     }\n \n   /* If a label still appears somewhere and we cannot delete the label,"}]}