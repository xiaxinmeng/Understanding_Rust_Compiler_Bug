{"sha": "3c219134152f645103f2fcd50735b177ccd76cde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyMTkxMzQxNTJmNjQ1MTAzZjJmY2Q1MDczNWIxNzdjY2Q3NmNkZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-03T11:38:50Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-03T11:46:13Z"}, "message": "libstdc++: Optimise GCD algorithms\n\nThe current std::gcd and std::chrono::duration::_S_gcd algorithms are\nboth recursive. This is potentially expensive to evaluate in constant\nexpressions, because each level of recursion makes a new copy of the\nfunction to evaluate. The maximum number of steps is bounded\n(proportional to the number of decimal digits in the smaller value) and\nso unlikely to exceed the limit for constexpr nesting, but the memory\nusage is still suboptimal. By using an iterative algorithm we avoid\nthat compile-time cost. Because looping in constexpr functions is not\nallowed until C++14, we need to keep the recursive implementation in\nduration::_S_gcd for C++11 mode.\n\nFor std::gcd we can also optimise runtime performance by using the\nbinary GCD algorithm.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/chrono (duration::_S_gcd): Use iterative algorithm\n\tfor C++14 and later.\n\t* include/std/numeric (__detail::__gcd): Replace recursive\n\tEuclidean algorithm with iterative version of binary GCD algorithm.\n\t* testsuite/26_numerics/gcd/1.cc: Test additional inputs.\n\t* testsuite/26_numerics/gcd/gcd_neg.cc: Adjust dg-error lines.\n\t* testsuite/26_numerics/lcm/lcm_neg.cc: Likewise.\n\t* testsuite/experimental/numeric/gcd.cc: Test additional inputs.\n\t* testsuite/26_numerics/gcd/2.cc: New test.", "tree": {"sha": "ddd487657c9d90fa34983735e3664ca056febc7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddd487657c9d90fa34983735e3664ca056febc7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c219134152f645103f2fcd50735b177ccd76cde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c219134152f645103f2fcd50735b177ccd76cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c219134152f645103f2fcd50735b177ccd76cde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c219134152f645103f2fcd50735b177ccd76cde/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3536ff2de8317c430546fd97574d44c5146cef2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3536ff2de8317c430546fd97574d44c5146cef2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3536ff2de8317c430546fd97574d44c5146cef2b"}], "stats": {"total": 350, "additions": 332, "deletions": 18}, "files": [{"sha": "0e2efb2522b74bc0611261190bcac31bad4f6ea3", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -428,8 +428,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_gcd(intmax_t __m, intmax_t __n) noexcept\n \t{\n \t  // Duration only allows positive periods so we don't need to\n-\t  // support negative values here (unlike __static_gcd and std::gcd).\n+\t  // handle negative values here (unlike __static_gcd and std::gcd).\n+#if __cplusplus >= 201402L\n+\t  while (__m != 0 && __n != 0)\n+\t    {\n+\t      intmax_t __rem = __m % __n;\n+\t      __m = __n;\n+\t      __n = __rem;\n+\t    }\n+\t  return __m + __n;\n+#else\n+\t  // C++11 doesn't allow loops in constexpr functions, but this\n+\t  // recursive version can be more expensive to evaluate.\n \t  return (__m == 0) ? __n : (__n == 0) ? __m : _S_gcd(__n, __m % __n);\n+#endif\n \t}\n \n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "2de6aaf06ec7a572a6453f66871a2a66dc14a3d9", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -76,6 +76,7 @@\n \n #if __cplusplus >= 201402L\n #include <type_traits>\n+#include <bit>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -97,15 +98,40 @@ namespace __detail\n \n   template<typename _Up> void __absu(bool) = delete;\n \n-  // GCD implementation\n+  // GCD implementation, using Stein's algorithm\n   template<typename _Tp>\n     constexpr _Tp\n     __gcd(_Tp __m, _Tp __n)\n     {\n       static_assert(is_unsigned<_Tp>::value, \"type must be unsigned\");\n-      return __m == 0 ? __n\n-\t: __n == 0 ? __m\n-\t: __detail::__gcd(__n, _Tp(__m % __n));\n+\n+      if (__m == 0)\n+\treturn __n;\n+      if (__n == 0)\n+\treturn __m;\n+\n+      const int __i = std::__countr_zero(__m);\n+      __m >>= __i;\n+      const int __j = std::__countr_zero(__n);\n+      __n >>= __j;\n+      const int __k = __i < __j ? __i : __j; // min(i, j)\n+\n+      while (true)\n+\t{\n+\t  if (__m > __n)\n+\t    {\n+\t      _Tp __tmp = __m;\n+\t      __m = __n;\n+\t      __n = __tmp;\n+\t    }\n+\n+\t  __n -= __m;\n+\n+\t  if (__n == 0)\n+\t    return __m << __k;\n+\n+\t  __n >>= std::__countr_zero(__n);\n+\t}\n     }\n \n   // LCM implementation"}, {"sha": "dc43cda395c96e64ee523baa22196c1aa104173e", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/1.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F1.cc?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -15,7 +15,6 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-std=gnu++17\" }\n // { dg-do compile { target c++17 } }\n \n #include <numeric>\n@@ -27,18 +26,28 @@\n #endif\n \n using std::gcd;\n+using std::is_same_v;\n \n static_assert( gcd(1071, 462) == 21, \"\" );\n static_assert( gcd(2000, 20) == 20, \"\" );\n static_assert( gcd(2011, 17) == 1, \"GCD of two primes is 1\" );\n static_assert( gcd(200, 200) == 200, \"GCD of equal numbers is that number\" );\n static_assert( gcd(0, 13) == 13, \"GCD of any number and 0 is that number\" );\n static_assert( gcd(29, 0) == 29, \"GCD of any number and 0 is that number\" );\n-static_assert( gcd(0, 0) == 0, \"\" );\n+static_assert( gcd(0, 0) == 0, \"Zarro Boogs found\" );\n \n static_assert(gcd(1u, 2) == 1, \"unsigned and signed\");\n+static_assert(gcd(9, 6u) == 3, \"unsigned and signed\");\n static_assert(gcd(3, 4u) == 1, \"signed and unsigned\");\n+static_assert(gcd(32u, 24) == 8, \"signed and unsigned\");\n+static_assert(gcd(1u, -2) == 1, \"unsigned and negative\");\n+static_assert(gcd(-21, 28u) == 7, \"unsigned and negative\");\n+static_assert(gcd(-3, 4u) == 1, \"negative and unsigned\");\n+static_assert(gcd(33u, -44) == 11, \"negative and unsigned\");\n static_assert(gcd(5u, 6u) == 1, \"unsigned and unsigned\");\n+static_assert(gcd(54u, 36u) == 18, \"unsigned and unsigned\");\n+static_assert(gcd(-5, -6) == 1, \"negative and negative\");\n+static_assert(gcd(-50, -60) == 10, \"negative and negative\");\n \n-static_assert( std::is_same_v<decltype(gcd(1l, 1)), long> );\n-static_assert( std::is_same_v<decltype(gcd(1ul, 1ull)), unsigned long long> );\n+static_assert( is_same_v<decltype(gcd(1l, 1)), long> );\n+static_assert( is_same_v<decltype(gcd(1ul, 1ull)), unsigned long long> );"}, {"sha": "186dbac24253b58d22c1af5a523ef55f09d8444b", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/2.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F2.cc?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -0,0 +1,133 @@\n+// Copyright (C) 2015-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++17 } }\n+\n+#include <numeric>\n+#include <climits>\n+#include <testsuite_hooks.h>\n+\n+constexpr struct testcase { unsigned long long p, q, r; } testcases[] = {\n+  { 5, 8, 1 },\n+  { 6, 35, 1 },\n+  { 30, 42, 6 },\n+  { 24, 60, 12 },\n+  { 55, 144, 1 },\n+  { 105, 252, 21 },\n+  { 253, 22121, 11 },\n+  { 1386, 3213, 63 },\n+  { 2028, 2049, 3 },\n+  { 46391, 62527, 2017 },\n+  { 63245986, 39088169, 1 },\n+  { 77160074263, 47687519812, 1 },\n+  { 77160074264, 47687519812, 4 },\n+};\n+\n+template<typename P, typename Q>\n+constexpr bool\n+check(P p, Q q, unsigned long long r)\n+{\n+  using R = std::common_type_t<P, Q>;\n+  static_assert( std::is_same_v<decltype(std::gcd(p, q)), R> );\n+  static_assert( std::is_same_v<decltype(std::gcd(q, p)), R> );\n+  R r1 = std::gcd(p, q);\n+  // Check non-negative, so conversion to unsigned long doesn't alter value.\n+  VERIFY( r1 >= 0 );\n+  // Check for expected result\n+  VERIFY( (unsigned long long)r1 == r );\n+  // Check reversing arguments doesn't change result\n+  VERIFY( std::gcd(q, p) == r1 );\n+\n+  P pabs = p < 0 ? -p : p;\n+  VERIFY( std::gcd(p, p) == pabs );\n+  VERIFY( std::gcd(0, p) == pabs );\n+  VERIFY( std::gcd(p, 0) == pabs );\n+  VERIFY( std::gcd(1, p) == 1 );\n+  VERIFY( std::gcd(p, 1) == 1 );\n+  Q qabs = q < 0 ? -q : q;\n+  VERIFY( std::gcd(q, q) == qabs );\n+  VERIFY( std::gcd(0, q) == qabs );\n+  VERIFY( std::gcd(q, 0) == qabs );\n+  VERIFY( std::gcd(1, q) == 1 );\n+  VERIFY( std::gcd(q, 1) == 1 );\n+  VERIFY( std::gcd(r, r) == r );\n+  VERIFY( std::gcd(0, r) == r );\n+  VERIFY( std::gcd(r, 0) == r );\n+  VERIFY( std::gcd(1, r) == 1 );\n+  VERIFY( std::gcd(r, 1) == 1 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test01()\n+{\n+  for (auto t : testcases)\n+  {\n+    check(t.p, t.q, t.r);\n+\n+    if (t.p <= LONG_MAX && t.q <= LONG_MAX)\n+    {\n+      check( (long)t.p,  (long)t.p, t.p);\n+      check(-(long)t.p,  (long)t.p, t.p);\n+      check(-(long)t.p, -(long)t.p, t.p);\n+\n+      check( (long)t.p, t.q, t.r);\n+      check(-(long)t.p, t.q, t.r);\n+\n+      check(t.p,  (long)t.q, t.r);\n+      check(t.p, -(long)t.q, t.r);\n+\n+      check( (long)t.p,  (long)t.q, t.r);\n+      check( (long)t.p, -(long)t.q, t.r);\n+      check(-(long)t.p,  (long)t.q, t.r);\n+      check(-(long)t.p, -(long)t.q, t.r);\n+    }\n+\n+    if (t.p <= INT_MAX && t.q <= INT_MAX)\n+    {\n+      check((long)t.p,  (int)t.q, t.r);\n+      check(-(int)t.p, (long)t.q, t.r);\n+\n+      check( (int)t.p, (unsigned)t.q, t.r);\n+      check(-(int)t.p, (unsigned)t.q, t.r);\n+\n+      check(-(int)t.p,  -(int)t.q, t.r);\n+      check(-(int)t.p, -(long)t.q, t.r);\n+    }\n+\n+    if (t.p <= SHRT_MAX && t.q <= SHRT_MAX)\n+    {\n+      check(  (long)t.p, (short)t.q, t.r);\n+      check(-(short)t.p,  (long)t.q, t.r);\n+\n+      check( (short)t.p, (unsigned short)t.q, t.r);\n+      check(-(short)t.p, (unsigned short)t.q, t.r);\n+\n+      check(-(short)t.p, -(short)t.q, t.r);\n+      check(-(short)t.p,  -(long)t.q, t.r);\n+    }\n+  }\n+  return true;\n+}\n+\n+\n+int main()\n+{\n+  static_assert( test01() );  // constexpr\n+  VERIFY( test01() );\t      // non-constexpr\n+}"}, {"sha": "fa559b6f47599a7c5d64b12156a5a77e7fa0288e", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -46,9 +46,9 @@ test01()\n   std::gcd<const int&, const int&>(0.1, 0.1);   // { dg-error \"from here\" }\n }\n \n-// { dg-error \"must be integers\" \"\" { target *-*-* } 134 }\n-// { dg-error \"must be integers\" \"\" { target *-*-* } 135 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 136 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 137 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 160 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 161 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 162 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 163 }\n // { dg-prune-output \"deleted function\" }\n // { dg-prune-output \"incomplete type .*make_unsigned\" }"}, {"sha": "7e36c2654b0c9f1c7925afe5557c7e0b538b10fd", "filename": "libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -46,9 +46,9 @@ test01()\n   std::lcm<const int&, const int&>(0.1, 0.1);   // { dg-error \"from here\" }\n }\n \n-// { dg-error \"must be integers\" \"\" { target *-*-* } 148 }\n-// { dg-error \"must be integers\" \"\" { target *-*-* } 149 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 150 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 151 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 174 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 175 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 176 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 177 }\n // { dg-prune-output \"deleted function\" }\n // { dg-prune-output \"incomplete type .*make_unsigned\" }"}, {"sha": "8555421b1183438a65a25de6cb061d521eeec980", "filename": "libstdc++-v3/testsuite/experimental/numeric/gcd.cc", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnumeric%2Fgcd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c219134152f645103f2fcd50735b177ccd76cde/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnumeric%2Fgcd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnumeric%2Fgcd.cc?ref=3c219134152f645103f2fcd50735b177ccd76cde", "patch": "@@ -18,17 +18,151 @@\n // { dg-do compile { target c++14 } }\n \n #include <experimental/numeric>\n+#include <experimental/type_traits>\n+\n+#ifndef __cpp_lib_experimental_gcd_lcm\n+# error \"Feature-test macro for gcd missing\"\n+#elif __cpp_lib_experimental_gcd_lcm != 201411\n+# error \"Feature-test macro for gcd has wrong value\"\n+#endif\n \n using std::experimental::fundamentals_v2::gcd;\n+using std::experimental::is_same_v;\n \n static_assert( gcd(1071, 462) == 21, \"\" );\n static_assert( gcd(2000, 20) == 20, \"\" );\n static_assert( gcd(2011, 17) == 1, \"GCD of two primes is 1\" );\n static_assert( gcd(200, 200) == 200, \"GCD of equal numbers is that number\" );\n static_assert( gcd(0, 13) == 13, \"GCD of any number and 0 is that number\" );\n static_assert( gcd(29, 0) == 29, \"GCD of any number and 0 is that number\" );\n-static_assert( gcd(0, 0) == 0, \"\" );\n+static_assert( gcd(0, 0) == 0, \"Zarro Boogs found\" );\n \n static_assert(gcd(1u, 2) == 1, \"unsigned and signed\");\n+static_assert(gcd(9, 6u) == 3, \"unsigned and signed\");\n static_assert(gcd(3, 4u) == 1, \"signed and unsigned\");\n+static_assert(gcd(32u, 24) == 8, \"signed and unsigned\");\n+static_assert(gcd(1u, -2) == 1, \"unsigned and negative\");\n+static_assert(gcd(-21, 28u) == 7, \"unsigned and negative\");\n+static_assert(gcd(-3, 4u) == 1, \"negative and unsigned\");\n+static_assert(gcd(33u, -44) == 11, \"negative and unsigned\");\n static_assert(gcd(5u, 6u) == 1, \"unsigned and unsigned\");\n+static_assert(gcd(54u, 36u) == 18, \"unsigned and unsigned\");\n+static_assert(gcd(-5, -6) == 1, \"negative and negative\");\n+static_assert(gcd(-50, -60) == 10, \"negative and negative\");\n+\n+static_assert( is_same_v<decltype(gcd(1l, 1)), long>, \"\" );\n+static_assert( is_same_v<decltype(gcd(1ul, 1ull)), unsigned long long>, \"\" );\n+\n+#include <climits>\n+#include <testsuite_hooks.h>\n+\n+constexpr struct testcase { unsigned long long p, q, r; } testcases[] = {\n+  { 5, 8, 1 },\n+  { 6, 35, 1 },\n+  { 30, 42, 6 },\n+  { 24, 60, 12 },\n+  { 55, 144, 1 },\n+  { 105, 252, 21 },\n+  { 253, 22121, 11 },\n+  { 1386, 3213, 63 },\n+  { 2028, 2049, 3 },\n+  { 46391, 62527, 2017 },\n+  { 63245986, 39088169, 1 },\n+  { 77160074263, 47687519812, 1 },\n+  { 77160074264, 47687519812, 4 },\n+};\n+\n+template<typename P, typename Q>\n+constexpr bool\n+check(P p, Q q, unsigned long long r)\n+{\n+  using R = std::common_type_t<P, Q>;\n+  static_assert( is_same_v<decltype(gcd(p, q)), R>, \"\" );\n+  static_assert( is_same_v<decltype(gcd(q, p)), R>, \"\" );\n+  R r1 = gcd(p, q);\n+  // Check non-negative, so conversion to unsigned long doesn't alter value.\n+  VERIFY( r1 >= 0 );\n+  // Check for expected result\n+  VERIFY( (unsigned long long)r1 == r );\n+  // Check reversing arguments doesn't change result\n+  VERIFY( gcd(q, p) == r1 );\n+\n+  P pabs = p < 0 ? -p : p;\n+  VERIFY( gcd(p, p) == pabs );\n+  VERIFY( gcd(0, p) == pabs );\n+  VERIFY( gcd(p, 0) == pabs );\n+  VERIFY( gcd(1, p) == 1 );\n+  VERIFY( gcd(p, 1) == 1 );\n+  Q qabs = q < 0 ? -q : q;\n+  VERIFY( gcd(q, q) == qabs );\n+  VERIFY( gcd(0, q) == qabs );\n+  VERIFY( gcd(q, 0) == qabs );\n+  VERIFY( gcd(1, q) == 1 );\n+  VERIFY( gcd(q, 1) == 1 );\n+  VERIFY( gcd(r, r) == r );\n+  VERIFY( gcd(0, r) == r );\n+  VERIFY( gcd(r, 0) == r );\n+  VERIFY( gcd(1, r) == 1 );\n+  VERIFY( gcd(r, 1) == 1 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test01()\n+{\n+  for (auto t : testcases)\n+  {\n+    check(t.p, t.q, t.r);\n+\n+    if (t.p <= LONG_MAX && t.q <= LONG_MAX)\n+    {\n+      check( (long)t.p,  (long)t.p, t.p);\n+      check(-(long)t.p,  (long)t.p, t.p);\n+      check(-(long)t.p, -(long)t.p, t.p);\n+\n+      check( (long)t.p, t.q, t.r);\n+      check(-(long)t.p, t.q, t.r);\n+\n+      check(t.p,  (long)t.q, t.r);\n+      check(t.p, -(long)t.q, t.r);\n+\n+      check( (long)t.p,  (long)t.q, t.r);\n+      check( (long)t.p, -(long)t.q, t.r);\n+      check(-(long)t.p,  (long)t.q, t.r);\n+      check(-(long)t.p, -(long)t.q, t.r);\n+    }\n+\n+    if (t.p <= INT_MAX && t.q <= INT_MAX)\n+    {\n+      check((long)t.p,  (int)t.q, t.r);\n+      check(-(int)t.p, (long)t.q, t.r);\n+\n+      check( (int)t.p, (unsigned)t.q, t.r);\n+      check(-(int)t.p, (unsigned)t.q, t.r);\n+\n+      check(-(int)t.p,  -(int)t.q, t.r);\n+      check(-(int)t.p, -(long)t.q, t.r);\n+    }\n+\n+    if (t.p <= SHRT_MAX && t.q <= SHRT_MAX)\n+    {\n+      check(  (long)t.p, (short)t.q, t.r);\n+      check(-(short)t.p,  (long)t.q, t.r);\n+\n+      check( (short)t.p, (unsigned short)t.q, t.r);\n+      check(-(short)t.p, (unsigned short)t.q, t.r);\n+\n+      check(-(short)t.p, -(short)t.q, t.r);\n+      check(-(short)t.p,  -(long)t.q, t.r);\n+    }\n+  }\n+  return true;\n+}\n+\n+\n+int main()\n+{\n+  static_assert( test01() );  // constexpr\n+  VERIFY( test01() );\t      // non-constexpr\n+}"}]}