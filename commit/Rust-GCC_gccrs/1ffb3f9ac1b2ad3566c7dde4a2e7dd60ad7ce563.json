{"sha": "1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmYjNmOWFjMWIyYWQzNTY2YzdkZGU0YTJlN2RkNjBhZDdjZTU2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-04T18:44:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-04T18:44:57Z"}, "message": "simplify-rtx.c (simplify_subreg): Fix combining of paradoxical subregs.\n\n\t* simplify-rtx.c (simplify_subreg): Fix combining of\n\tparadoxical subregs.\n\nFrom-SVN: r42868", "tree": {"sha": "30475c537d943f52186266be37590ce52d15ae8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30475c537d943f52186266be37590ce52d15ae8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563/comments", "author": null, "committer": null, "parents": [{"sha": "978f547fa2d821d32e86fc7ed775750301ace8b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/978f547fa2d821d32e86fc7ed775750301ace8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/978f547fa2d821d32e86fc7ed775750301ace8b5"}], "stats": {"total": 77, "additions": 52, "deletions": 25}, "files": [{"sha": "38d6aaf5d5bb40f8beb5e708df44b89028219898", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563", "patch": "@@ -1,3 +1,8 @@\n+Mon Jun  4 20:44:25 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* simplify-rtx.c (simplify_subreg): Fix combining of\n+\tparadoxical subregs.\n+\n Mon Jun  4 20:15:25 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* rtlanal.c (rtx_unsable_p): ADDRESSOF is stable."}, {"sha": "97d6f6bc709e3510b9e2dfb594368b3e893ecbb3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1ffb3f9ac1b2ad3566c7dde4a2e7dd60ad7ce563", "patch": "@@ -2297,41 +2297,63 @@ simplify_subreg (outermode, op, innermode, byte)\n   if (GET_CODE (op) == SUBREG)\n     {\n       enum machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n-      unsigned int final_offset = byte + SUBREG_BYTE (op);\n+      int final_offset = byte + SUBREG_BYTE (op);\n       rtx new;\n \n       if (outermode == innermostmode\n \t  && byte == 0 && SUBREG_BYTE (op) == 0)\n \treturn SUBREG_REG (op);\n \n-      if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n-\t  && GET_MODE_SIZE (innermode) > GET_MODE_SIZE (outermode)\n-\t  && GET_MODE_SIZE (innermode) > GET_MODE_SIZE (innermostmode))\n+      /* The SUBREG_BYTE represents offset, as if the value were stored\n+\t in memory.  Irritating exception is paradoxical subreg, where\n+\t we define SUBREG_BYTE to be 0.  On big endian machines, this\n+\t value should be negative.  For a moment, undo this exception. */\n+      if (byte == 0 && GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n \t{\n-\t  /* Inner SUBREG is paradoxical, outer is not.  On big endian\n-\t     we have to special case this.  */\n-\t  if (SUBREG_BYTE (op))\n-\t    abort(); /* Can a paradoxical subreg have nonzero offset? */\n-\t  if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n-\t    final_offset = (byte - GET_MODE_SIZE (innermode)\n-\t\t\t    + GET_MODE_SIZE (innermostmode));\n-\t  else if (WORDS_BIG_ENDIAN)\n-\t    final_offset = ((final_offset % UNITS_PER_WORD)\n-\t\t\t    + ((byte - GET_MODE_SIZE (innermode)\n-\t\t\t        + GET_MODE_SIZE (innermostmode))\n-\t\t\t       * UNITS_PER_WORD) / UNITS_PER_WORD);\n+\t  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    final_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    final_offset += difference % UNITS_PER_WORD;\n+\t}\n+      if (SUBREG_BYTE (op) == 0\n+\t  && GET_MODE_SIZE (innermostmode) < GET_MODE_SIZE (innermode))\n+\t{\n+\t  int difference = (GET_MODE_SIZE (innermostmode) - GET_MODE_SIZE (innermode));\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    final_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    final_offset += difference % UNITS_PER_WORD;\n+\t}\n+\n+      /* See whether resulting subreg will be paradoxical.  */\n+      if (GET_MODE_SIZE (innermostmode) < GET_MODE_SIZE (outermode))\n+\t{\n+\t  /* In nonparadoxical subregs we can't handle negative offsets.  */\n+\t  if (final_offset < 0)\n+\t    return NULL_RTX;\n+\t  /* Bail out in case resulting subreg would be incorrect.  */\n+\t  if (final_offset % GET_MODE_SIZE (outermode)\n+\t      || final_offset >= GET_MODE_SIZE (innermostmode))\n+\t    return NULL;\n+\t}\n+      else\n+\t{\n+\t  int offset = 0;\n+\t  int difference = (GET_MODE_SIZE (innermostmode) - GET_MODE_SIZE (outermode));\n+\n+\t  /* In paradoxical subreg, see if we are still looking on lower part.\n+\t     If so, our SUBREG_BYTE will be 0.  */\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += difference % UNITS_PER_WORD;\n+\t  if (offset == final_offset)\n+\t    final_offset = 0;\n \t  else\n-\t    final_offset = (((final_offset * UNITS_PER_WORD)\n-\t\t\t     / UNITS_PER_WORD)\n-\t\t\t    + ((byte - GET_MODE_SIZE (innermode)\n-\t\t\t        + GET_MODE_SIZE (innermostmode))\n-\t\t\t       % UNITS_PER_WORD));\n+\t    return NULL;\n \t}\n \n-      /* Bail out in case resulting subreg would be incorrect.  */\n-      if (final_offset % GET_MODE_SIZE (outermode)\n-\t  || final_offset >= GET_MODE_SIZE (innermostmode))\n-\treturn NULL;\n       /* Recurse for futher possible simplifications.  */\n       new = simplify_subreg (outermode, SUBREG_REG (op),\n \t\t\t     GET_MODE (SUBREG_REG (op)),"}]}