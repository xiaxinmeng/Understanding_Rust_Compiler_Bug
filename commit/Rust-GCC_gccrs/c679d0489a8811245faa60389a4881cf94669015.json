{"sha": "c679d0489a8811245faa60389a4881cf94669015", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY3OWQwNDg5YTg4MTEyNDVmYWE2MDM4OWE0ODgxY2Y5NDY2OTAxNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-28T17:49:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-28T17:49:37Z"}, "message": "i386.md (sse_andti3, [...]): Add SSE2 versions; add missing '%' in constraints.\n\n\t* i386.md (sse_andti3, sse_nandti_3, sse_xorti3): Add SSE2 versions;\n\tadd missing '%' in constraints.\n\nFrom-SVN: r40127", "tree": {"sha": "6a8487d440b422e29aa8ab6a1c32699d03bc4515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a8487d440b422e29aa8ab6a1c32699d03bc4515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c679d0489a8811245faa60389a4881cf94669015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c679d0489a8811245faa60389a4881cf94669015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c679d0489a8811245faa60389a4881cf94669015", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c679d0489a8811245faa60389a4881cf94669015/comments", "author": null, "committer": null, "parents": [{"sha": "11014a3b3886458a25601381d4bccbc3d293c19a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11014a3b3886458a25601381d4bccbc3d293c19a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11014a3b3886458a25601381d4bccbc3d293c19a"}], "stats": {"total": 242, "additions": 205, "deletions": 37}, "files": [{"sha": "89f7af6c206bd52e97db5d2f8b84a7bd95ad1fa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c679d0489a8811245faa60389a4881cf94669015/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c679d0489a8811245faa60389a4881cf94669015/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c679d0489a8811245faa60389a4881cf94669015", "patch": "@@ -1,3 +1,8 @@\n+Wed Feb 28 18:47:37 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (sse_andti3, sse_nandti_3, sse_xorti3): Add SSE2 versions;\n+\tadd missing '%' in constraints.\n+\n Wed Feb 28 17:24:24 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* c-common.c (build_common_tree_nodes): Build intTI_type_nodes"}, {"sha": "0e65701ee54adc5f2150bb4b89157cf462a298ab", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 151, "deletions": 7, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c679d0489a8811245faa60389a4881cf94669015/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c679d0489a8811245faa60389a4881cf94669015/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c679d0489a8811245faa60389a4881cf94669015", "patch": "@@ -13917,38 +13917,182 @@\n ;; into DImode subregs of SSE registers, and them together, and move out\n ;; of DImode subregs again!\n \n+(define_insn \"*sse_andti3_df_1\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (and:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"%0\") 0)\n+\t\t(subreg:TI (match_operand:DF 2 \"register_operand\" \"Y\") 0)))]\n+  \"TARGET_SSE2\"\n+  \"andpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_andti3_df_2\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (and:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0)\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n+  \"TARGET_SSE2\"\n+  \"andpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_andti3_sf_1\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"%0\") 0)\n+\t\t(subreg:TI (match_operand:SF 2 \"register_operand\" \"x\") 0)))]\n+  \"TARGET_SSE\"\n+  \"andps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_andti3_sf_2\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0)\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"andps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n (define_insn \"sse_andti3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (and:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+        (and:TI (match_operand:TI 1 \"register_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE && !TARGET_SSE2\"\n   \"andps\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sse\")])\n \n+(define_insn \"*sse_andti3_sse2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (and:TI (match_operand:TI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\"\n+  \"pand\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_nandti3_df\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (and:TI (not:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0))\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n+  \"TARGET_SSE2\"\n+  \"andnpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_nandti3_sf\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (not:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0))\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"andnps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n (define_insn \"sse_nandti3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n         (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE && !TARGET_SSE2\"\n   \"andnps\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sse\")])\n \n+(define_insn \"*sse_nandti3_sse2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\"\n+  \"pnand\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_iorti3_df_1\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (ior:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"%0\") 0)\n+\t\t(subreg:TI (match_operand:DF 2 \"register_operand\" \"Y\") 0)))]\n+  \"TARGET_SSE2\"\n+  \"orpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_iorti3_df_2\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (ior:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0)\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n+  \"TARGET_SSE2\"\n+  \"orpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_iorti3_sf_1\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (ior:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"%0\") 0)\n+\t\t(subreg:TI (match_operand:SF 2 \"register_operand\" \"x\") 0)))]\n+  \"TARGET_SSE\"\n+  \"orps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_iorti3_sf_2\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (ior:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0)\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"orps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n (define_insn \"sse_iorti3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (ior:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+        (ior:TI (match_operand:TI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE && !TARGET_SSE2\"\n+  \"orps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_iorti3_sse2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (ior:TI (match_operand:TI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\"\n+  \"por\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_xorti3_df_1\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (xor:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"%0\") 0)\n+\t\t(subreg:TI (match_operand:DF 2 \"register_operand\" \"Y\") 0)))]\n+  \"TARGET_SSE2\"\n+  \"xorpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_xorti3_df_2\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n+        (xor:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0)\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n+  \"TARGET_SSE2\"\n+  \"xorpd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_xorti3_sf_1\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (xor:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"%0\") 0)\n+\t\t(subreg:TI (match_operand:SF 2 \"register_operand\" \"x\") 0)))]\n+  \"TARGET_SSE\"\n+  \"xorps\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n+(define_insn \"*sse_xorti3_sf_2\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (xor:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0)\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE\"\n-  \"iorps\\\\t{%2, %0|%0, %2}\"\n+  \"xorps\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sse\")])\n \n (define_insn \"sse_xorti3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (xor:TI (match_operand:TI 1 \"register_operand\" \"0\")\n+        (xor:TI (match_operand:TI 1 \"register_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE && !TARGET_SSE2\"\n   \"xorps\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sse\")])\n \n+(define_insn \"*sse_xorti3_sse2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (xor:TI (match_operand:TI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\"\n+  \"pxor\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")])\n+\n ;; Use xor, but don't show input operands so they aren't live before\n ;; this insn.\n (define_insn \"sse_clrti\""}, {"sha": "7bf859462895ce795efe46d91640668e76dda077", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c679d0489a8811245faa60389a4881cf94669015/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c679d0489a8811245faa60389a4881cf94669015/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c679d0489a8811245faa60389a4881cf94669015", "patch": "@@ -1732,6 +1732,9 @@ dwarf2out_frame_debug (insn)\n \n   if (insn == NULL_RTX)\n     {\n+      rtx insn;\n+      int n_alternate_entry_points;\n+\n       /* Set up state for generating call frame debug info.  */\n       lookup_cfa (&cfa);\n       if (cfa.reg != (unsigned long) DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM))\n@@ -1740,6 +1743,39 @@ dwarf2out_frame_debug (insn)\n       cfa_store = cfa;\n       cfa_temp.reg = -1;\n       cfa_temp.offset = 0;\n+\n+      n_alternate_entry_points = 0;\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == CODE_LABEL && LABEL_ALTERNATE_NAME (insn))\n+\t  n_alternate_entry_points ++;\n+\n+      /* For each alternate entry point amit an store_state command.  We will pop\n+\t the state once we will reach it.  */\n+      while (n_alternate_entry_points--)\n+\t{\n+\t  register dw_cfi_ref xcfi;\n+\n+\t  /* Set the location counter to the new label.  */\n+\t  xcfi = new_cfi ();\n+\t  xcfi->dw_cfi_opc = DW_CFA_remember_state;\n+\t  add_fde_cfi (NULL, xcfi);\n+\t}\n+      return;\n+    }\n+  /* An alternate entry point.  Pop the state we pushed during initialization\n+     and re-initialize our tables.  */\n+  if (GET_CODE (insn) == CODE_LABEL && LABEL_ALTERNATE_NAME (insn))\n+    {\n+      register dw_cfi_ref xcfi;\n+      label = dwarf2out_cfi_label ();\n+\n+      /* On entry, the Canonical Frame Address is at SP.  */\n+      dwarf2out_def_cfa (label, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n+\n+      /* Restore the frame state we had right before entering function.  */\n+      xcfi = new_cfi ();\n+      xcfi->dw_cfi_opc = DW_CFA_restore_state;\n+      add_fde_cfi (label, xcfi);\n       return;\n     }\n "}, {"sha": "7a8e7147ad1fca2744854f389a13f43db74a01a3", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c679d0489a8811245faa60389a4881cf94669015/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c679d0489a8811245faa60389a4881cf94669015/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=c679d0489a8811245faa60389a4881cf94669015", "patch": "@@ -2332,6 +2332,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       break;\n \n     case CODE_LABEL:\n+#if defined (DWARF2_UNWIND_INFO)\n+      /* If we push arguments, we need to check all insns for stack\n+\t adjustments.  */\n+      if (dwarf2out_do_frame ())\n+\tdwarf2out_frame_debug (insn);\n+#endif\n       /* The target port might emit labels in the output function for\n \t some insn, e.g. sh.c output_branchy_insn.  */\n       if (CODE_LABEL_NUMBER (insn) <= max_labelno)"}, {"sha": "544c16bb75d7a8c002834cd9a1be09da069ea781", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c679d0489a8811245faa60389a4881cf94669015/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c679d0489a8811245faa60389a4881cf94669015/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=c679d0489a8811245faa60389a4881cf94669015", "patch": "@@ -1874,35 +1874,6 @@ reversed_comparison_code (comparison, insn)\n \t\t\t\t\t XEXP (comparison, 1), insn);\n }\n \f\n-/* Given a comparison, COMPARISON, inside a conditional jump insn, INSN,\n-   return non-zero if it is safe to reverse this comparison.  It is if our\n-   floating-point is not IEEE, if this is an NE or EQ comparison, or if\n-   this is known to be an integer comparison.  \n- \n-   Use of this function is depreached and you should use\n-   REVERSED_COMPARISON_CODE bits instead.\n- */\n-\n-int\n-can_reverse_comparison_p (comparison, insn)\n-     rtx comparison;\n-     rtx insn;\n-{\n-  enum rtx_code code;\n-\n-  /* If this is not actually a comparison, we can't reverse it.  */\n-  if (GET_RTX_CLASS (GET_CODE (comparison)) != '<')\n-    return 0;\n-\n-  code = reversed_comparison_code (comparison, insn);\n-  if (code == UNKNOWN)\n-    return 0;\n-\n-  /* The code will follow can_reverse_comparison_p with reverse_condition,\n-     so see if it will get proper result.  */\n-  return (code == reverse_condition (GET_CODE (comparison)));\n-}\n-\n /* Given an rtx-code for a comparison, return the code for the negated\n    comparison.  If no such code exists, return UNKNOWN.\n "}, {"sha": "b316178cffaa3caaae00c68bc07d92fd9d9e93b4", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c679d0489a8811245faa60389a4881cf94669015/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c679d0489a8811245faa60389a4881cf94669015/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c679d0489a8811245faa60389a4881cf94669015", "patch": "@@ -3489,8 +3489,14 @@ rest_of_compilation (decl)\n     }\n \n   /* If optimizing, then go ahead and split insns now since we are about\n-     to recompute flow information anyway.  */\n+     to recompute flow information anyway.  Since we can't split insns after\n+     reload, do the splitting unconditionally here to avoid gcc from losing\n+     REG_DEAD notes.  */\n+#ifdef STACK_REGS\n+  if (1)\n+#else\n   if (optimize > 0)\n+#endif\n     {\n       int old_labelnum = max_label_num ();\n "}]}