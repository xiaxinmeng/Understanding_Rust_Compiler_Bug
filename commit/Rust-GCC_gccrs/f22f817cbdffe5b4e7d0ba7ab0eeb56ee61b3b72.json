{"sha": "f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyZjgxN2NiZGZmZTViNGU3ZDBiYTdhYjBlZWI1NmVlNjFiM2I3Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-05T23:50:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-05T23:50:08Z"}, "message": "Various small C++ changes.\n\nWrappers for lookup_qualified_name and build_x_binary_op to make calling\nthem more convenient in places, and a function named contextual_conv_bool\nfor places that want contextual conversion to bool.\n\nI noticed that we weren't showing the declaration location when we complain\nabout a call to a non-constexpr function where a constant expression is\nrequired.\n\nIf maybe_instantiate_noexcept doesn't actually instantiate, there's no\nreason for it to mess with clones.\n\n\t* constexpr.c (explain_invalid_constexpr_fn): Show location of fn.\n\n\t* pt.c (maybe_instantiate_noexcept): Only update clones if we\n\tinstantiated.\n\n\t* typeck.c (contextual_conv_bool): New.\n\n\t* name-lookup.c (lookup_qualified_name): Add wrapper overload taking\n\tC string rather than identifier.\n\t* parser.c (cp_parser_userdef_numeric_literal): Use it.\n\t* rtti.c (emit_support_tinfos): Use it.\n\t* cp-tree.h (ovl_op_identifier): Change to inline functions.\n\t(build_x_binary_op): Add wrapper with fewer parms.\n\nFrom-SVN: r277862", "tree": {"sha": "297e198f67433c4deed3dde93c59355d41a91c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/297e198f67433c4deed3dde93c59355d41a91c01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a81ffd93b83c4be250514ff385b5b88fa5c3835b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81ffd93b83c4be250514ff385b5b88fa5c3835b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81ffd93b83c4be250514ff385b5b88fa5c3835b"}], "stats": {"total": 88, "additions": 66, "deletions": 22}, "files": [{"sha": "f6abb8445903947db5265a2a4816a43f3fa3c09d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -1,3 +1,19 @@\n+2019-11-04  Jason Merrill  <jason@redhat.com>\n+\n+\t* constexpr.c (explain_invalid_constexpr_fn): Show location of fn.\n+\n+\t* pt.c (maybe_instantiate_noexcept): Only update clones if we\n+\tinstantiated.\n+\n+\t* typeck.c (contextual_conv_bool): New.\n+\n+\t* name-lookup.c (lookup_qualified_name): Add wrapper overload taking\n+\tC string rather than identifier.\n+\t* parser.c (cp_parser_userdef_numeric_literal): Use it.\n+\t* rtti.c (emit_support_tinfos): Use it.\n+\t* cp-tree.h (ovl_op_identifier): Change to inline functions.\n+\t(build_x_binary_op): Add wrapper with fewer parms.\n+\n 2019-11-05  Jason Merrill  <jason@redhat.com>\n \n \t* decl2.c (mark_used): Diagnose use of a function with unsatisfied"}, {"sha": "ce910cd5a3be81dc6fdcc19ab4b4338d3f2b6e56", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -934,7 +934,10 @@ explain_invalid_constexpr_fn (tree fun)\n   if (!DECL_DEFAULTED_FN (fun)\n       && !LAMBDA_TYPE_P (CP_DECL_CONTEXT (fun))\n       && !is_instantiation_of_constexpr (fun))\n-    return;\n+    {\n+      inform (DECL_SOURCE_LOCATION (fun), \"%qD declared here\", fun);\n+      return;\n+    }\n   if (diagnosed == NULL)\n     diagnosed = new hash_set<tree>;\n   if (diagnosed->add (fun))"}, {"sha": "58d7d016197d44dab79b34e33aec60fd29ea415c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -270,9 +270,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    then deletes the entire object.  */\n #define deleting_dtor_identifier\tcp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n \n-#define ovl_op_identifier(ISASS, CODE)  (OVL_OP_INFO(ISASS, CODE)->identifier)\n-#define assign_op_identifier (ovl_op_info[true][OVL_OP_NOP_EXPR].identifier)\n-#define call_op_identifier (ovl_op_info[false][OVL_OP_CALL_EXPR].identifier)\n /* The name used for conversion operators -- but note that actual\n    conversion functions use special identifiers outside the identifier\n    table.  */\n@@ -5816,6 +5813,12 @@ extern GTY(()) unsigned char ovl_op_alternate[OVL_OP_MAX];\n #define IDENTIFIER_OVL_OP_FLAGS(NODE) \\\n   (IDENTIFIER_OVL_OP_INFO (NODE)->flags)\n \n+inline tree ovl_op_identifier (bool isass, tree_code code)\n+{ return OVL_OP_INFO(isass, code)->identifier; }\n+inline tree ovl_op_identifier (tree_code code) { return ovl_op_identifier (false, code); }\n+#define assign_op_identifier (ovl_op_info[true][OVL_OP_NOP_EXPR].identifier)\n+#define call_op_identifier (ovl_op_info[false][OVL_OP_CALL_EXPR].identifier)\n+\n /* A type-qualifier, or bitmask therefore, using the TYPE_QUAL\n    constants.  */\n \n@@ -7422,6 +7425,7 @@ enum compare_bounds_t { bounds_none, bounds_either, bounds_first };\n extern bool cxx_mark_addressable\t\t(tree, bool = false);\n extern int string_conv_p\t\t\t(const_tree, const_tree, int);\n extern tree cp_truthvalue_conversion\t\t(tree);\n+extern tree contextual_conv_bool\t\t(tree, tsubst_flags_t);\n extern tree condition_conversion\t\t(tree);\n extern tree require_complete_type\t\t(tree);\n extern tree require_complete_type_sfinae\t(tree, tsubst_flags_t);\n@@ -7470,6 +7474,13 @@ extern tree build_x_binary_op\t\t\t(const op_location_t &,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n+inline tree build_x_binary_op (const op_location_t &loc,\n+\t\t\t       enum tree_code code, tree arg1, tree arg2,\n+\t\t\t       tsubst_flags_t complain)\n+{\n+  return build_x_binary_op (loc, code, arg1, TREE_CODE (arg1), arg2,\n+\t\t\t    TREE_CODE (arg2), NULL, complain);\n+}\n extern tree build_x_array_ref\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_unary_op\t\t\t(location_t,"}, {"sha": "cbb61697d7c0a0b5c8f82962025ebaefbbb775c4", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -1273,7 +1273,7 @@ get_class_binding_direct (tree klass, tree name, bool want_type)\n    special function creation as necessary.  */\n \n tree\n-get_class_binding (tree klass, tree name, bool want_type)\n+get_class_binding (tree klass, tree name, bool want_type /*=false*/)\n {\n   klass = complete_type (klass);\n \n@@ -5943,7 +5943,7 @@ suggest_alternative_in_scoped_enum (tree name, tree scoped_enum)\n \n tree\n lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,\n-\t\t       bool find_hidden)\n+\t\t       bool find_hidden /*=false*/)\n {\n   tree t = NULL_TREE;\n \n@@ -5967,6 +5967,12 @@ lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,\n   return t;\n }\n \n+/* Wrapper for the above that takes a string argument.  The function name is\n+   not at the beginning of the line to keep this wrapper out of etags.  */\n+\n+tree lookup_qualified_name (tree t, const char *p, int wt, bool c, bool fh)\n+{ return lookup_qualified_name (t, get_identifier (p), wt, c, fh); }\n+\n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n    Returns the name/type pair found into the cxx_binding *RESULT,"}, {"sha": "f5295114cc6343ebd8ee55f1c248c2ef4fdcd58f", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -287,7 +287,8 @@ inline tree get_global_binding (tree id)\n {\n   return get_namespace_binding (NULL_TREE, id);\n }\n-extern tree lookup_qualified_name (tree, tree, int, bool, /*hidden*/bool = false);\n+extern tree lookup_qualified_name (tree, tree, int = 0, bool = true, /*hidden*/bool = false);\n+extern tree lookup_qualified_name (tree t, const char *p, int = 0, bool = true, bool = false);\n extern tree lookup_name_nonclass (tree);\n extern bool is_local_extern (tree);\n extern bool pushdecl_class_level (tree);"}, {"sha": "11468c0af428484d5f349303a910480e999a5032", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -4546,9 +4546,8 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n \n   if (i14 && ext)\n     {\n-      tree cxlit = lookup_qualified_name (std_node,\n-\t\t\t\t\t  get_identifier (\"complex_literals\"),\n-\t\t\t\t\t  0, false, false);\n+      tree cxlit = lookup_qualified_name (std_node, \"complex_literals\",\n+\t\t\t\t\t  0, false);\n       if (cxlit == error_mark_node)\n \t{\n \t  /* No <complex>, so pedwarn and use GNU semantics.  */"}, {"sha": "b8f8f6dbb5980e156b6be5bae30f8ff884016d9d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -24862,14 +24862,14 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n       TREE_TYPE (fn) = build_exception_variant (fntype, spec);\n       if (orig_fn)\n \tTREE_TYPE (orig_fn) = TREE_TYPE (fn);\n-    }\n \n-  FOR_EACH_CLONE (clone, fn)\n-    {\n-      if (TREE_TYPE (clone) == fntype)\n-\tTREE_TYPE (clone) = TREE_TYPE (fn);\n-      else\n-\tTREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);\n+      FOR_EACH_CLONE (clone, fn)\n+\t{\n+\t  if (TREE_TYPE (clone) == fntype)\n+\t    TREE_TYPE (clone) = TREE_TYPE (fn);\n+\t  else\n+\t    TREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);\n+\t}\n     }\n \n   return true;"}, {"sha": "1ba4a46c5cca2545ab01198ae305a67016a37e62", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -1553,7 +1553,7 @@ emit_support_tinfos (void)\n \n   /* Look for a defined class.  */\n   tree bltn_type = lookup_qualified_name\n-    (abi_node, get_identifier (\"__fundamental_type_info\"), true, false, false);\n+    (abi_node, \"__fundamental_type_info\", true, false);\n   if (TREE_CODE (bltn_type) != TYPE_DECL)\n     return;\n "}, {"sha": "bf2502a3686dc3e4e11080624f53c237273f3169", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -5931,15 +5931,22 @@ cp_truthvalue_conversion (tree expr)\n     return c_common_truthvalue_conversion (input_location, expr);\n }\n \n+/* Returns EXPR contextually converted to bool.  */\n+\n+tree\n+contextual_conv_bool (tree expr, tsubst_flags_t complain)\n+{\n+  return perform_implicit_conversion_flags (boolean_type_node, expr,\n+\t\t\t\t\t    complain, LOOKUP_NORMAL);\n+}\n+\n /* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  This\n    is a low-level function; most callers should use maybe_convert_cond.  */\n \n tree\n condition_conversion (tree expr)\n {\n-  tree t;\n-  t = perform_implicit_conversion_flags (boolean_type_node, expr,\n-\t\t\t\t\t tf_warning_or_error, LOOKUP_NORMAL);\n+  tree t = contextual_conv_bool (expr, tf_warning_or_error);\n   if (!processing_template_decl)\n     t = fold_build_cleanup_point_expr (boolean_type_node, t);\n   return t;"}, {"sha": "7884d423a596ccaf36b375862bc7e88f6076f91c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f22f817cbdffe5b4e7d0ba7ab0eeb56ee61b3b72", "patch": "@@ -938,7 +938,8 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n    constants.  */\n \n bool\n-check_narrowing (tree type, tree init, tsubst_flags_t complain, bool const_only)\n+check_narrowing (tree type, tree init, tsubst_flags_t complain,\n+\t\t bool const_only/*= false*/)\n {\n   tree ftype = unlowered_expr_type (init);\n   bool ok = true;"}]}