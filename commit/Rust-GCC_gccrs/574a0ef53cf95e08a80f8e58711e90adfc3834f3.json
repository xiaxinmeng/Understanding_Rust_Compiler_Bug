{"sha": "574a0ef53cf95e08a80f8e58711e90adfc3834f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc0YTBlZjUzY2Y5NWUwOGE4MGY4ZTU4NzExZTkwYWRmYzM4MzRmMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-02-25T01:36:03Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-02-25T01:36:03Z"}, "message": "lex.c (check_newline): Use push_srcloc and pop_srcloc, rather than duplicating functionality here.\n\n\t* lex.c (check_newline): Use push_srcloc and pop_srcloc, rather\n\tthan duplicating functionality here.\n\t* optimize.c: Include input.h.\n\t(expand_call_inline): Use push_srcloc and pop_srcloc.\n\t* parse.y (maybe_cv_qualifier): Remove calls to emit_line_note.\n\t* parse.c: Regenerated.\n\t* Makefile.in (lex.o): Depend on input.h.\n\t(optimize.o): Likewise.\n\nFrom-SVN: r32142", "tree": {"sha": "2fe743cce5c60c9804689fb64441246f66c1a9d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe743cce5c60c9804689fb64441246f66c1a9d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/574a0ef53cf95e08a80f8e58711e90adfc3834f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574a0ef53cf95e08a80f8e58711e90adfc3834f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574a0ef53cf95e08a80f8e58711e90adfc3834f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574a0ef53cf95e08a80f8e58711e90adfc3834f3/comments", "author": null, "committer": null, "parents": [{"sha": "68723fae698fb8b031395612a75b0bcb905d240b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68723fae698fb8b031395612a75b0bcb905d240b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68723fae698fb8b031395612a75b0bcb905d240b"}], "stats": {"total": 277, "additions": 139, "deletions": 138}, "files": [{"sha": "96ad5bd99583a38d260a515c1b3069687d3857ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=574a0ef53cf95e08a80f8e58711e90adfc3834f3", "patch": "@@ -1,3 +1,14 @@\n+2000-02-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* lex.c (check_newline): Use push_srcloc and pop_srcloc, rather\n+\tthan duplicating functionality here.\n+\t* optimize.c: Include input.h.\n+\t(expand_call_inline): Use push_srcloc and pop_srcloc.\n+\t* parse.y (maybe_cv_qualifier): Remove calls to emit_line_note.\n+\t* parse.c: Regenerated.\n+\t* Makefile.in (lex.o): Depend on input.h.\n+\t(optimize.o): Likewise.\n+\t\n 2000-02-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (grokdeclarator): Diagnose qualifiers on non-member"}, {"sha": "13c66286371738184fe1c6eae34b141867290373", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=574a0ef53cf95e08a80f8e58711e90adfc3834f3", "patch": "@@ -1,5 +1,5 @@\n # Makefile for GNU C++ compiler.\n-#   Copyright (C) 1987, 88, 90-5, 1998, 1999 Free Software Foundation, Inc.\n+#   Copyright (C) 1987, 88, 90-5, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -246,7 +246,8 @@ spew.o : spew.c $(CXX_TREE_H) $(PARSE_H) $(srcdir)/../flags.h \\\n lex.o : lex.c $(CXX_TREE_H) \\\n   $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h \\\n   $(srcdir)/../c-pragma.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../output.h $(srcdir)/../mbchar.h $(srcdir)/../ggc.h\n+  $(srcdir)/../output.h $(srcdir)/../mbchar.h $(srcdir)/../ggc.h \\\n+  $(srcdir)/../input.h\n decl.o : decl.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n   $(srcdir)/../except.h $(srcdir)/../toplev.h \\\n@@ -301,7 +302,8 @@ semantics.o: semantics.c $(CXX_TREE_H) lex.h \\\n   $(srcdir)/../output.h $(RTL_H) \n dump.o: dump.c $(CXX_TREE_H)\n optimize.o: optimize.c $(CXX_TREE_H) \\\n-  $(srcdir)/../rtl.h $(srcdir)/../integrate.h ../insn-config.h\n+  $(srcdir)/../rtl.h $(srcdir)/../integrate.h ../insn-config.h \\\n+  $(srcdir)/../input.h\n \n #\f\n # These exist for maintenance purposes."}, {"sha": "9f948f522e69983e671c974b310805c166c33566", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=574a0ef53cf95e08a80f8e58711e90adfc3834f3", "patch": "@@ -2322,8 +2322,9 @@ check_newline ()\n   register int token;\n   int saw_line;\n   enum { act_none, act_push, act_pop } action;\n-  int old_lineno, action_number, l;\n+  int action_number, l;\n   int entering_c_header;\n+  char *new_file;\n \n  restart:\n   /* Read first nonwhite char on the line.  Do this before incrementing the\n@@ -2531,9 +2532,9 @@ check_newline ()\n       body_time = this_time;\n     }\n \n-  input_filename = TREE_STRING_POINTER (yylval.ttype);\n+  new_file = TREE_STRING_POINTER (yylval.ttype);\n \n-  GNU_xref_file (input_filename);\n+  GNU_xref_file (new_file);\n       \n   if (main_input_filename == 0)\n     {\n@@ -2543,29 +2544,24 @@ check_newline ()\n \t{\n \t  while (ifiles->next)\n \t    ifiles = ifiles->next;\n-\t  ifiles->filename = file_name_nondirectory (input_filename);\n+\t  ifiles->filename = file_name_nondirectory (new_file);\n \t}\n \n-      main_input_filename = input_filename;\n+      main_input_filename = new_file;\n     }\n \n-  extract_interface_info ();\n-\n-  old_lineno = lineno;\n   action = act_none;\n   action_number = 0;\n-  lineno = l;\n \n   /* Each change of file name\n      reinitializes whether we are now in a system header.  */\n   in_system_header = 0;\n   entering_c_header = 0;\n \n-  if (!read_line_number (&action_number))\n+  if (!read_line_number (&action_number) && input_file_stack)\n     {\n-      /* Update the name in the top element of input_file_stack.  */\n-      if (input_file_stack)\n-\tinput_file_stack->name = input_filename;\n+      input_file_stack->name = input_filename = new_file;\n+      input_file_stack->line = lineno = l;\n     }\n \n   /* `1' after file name means entering new file.\n@@ -2599,14 +2595,8 @@ check_newline ()\n   if (action == act_push)\n     {\n       /* Pushing to a new file.  */\n-      struct file_stack *p\n-\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n-      input_file_stack->line = old_lineno;\n-      p->next = input_file_stack;\n-      p->name = input_filename;\n-      p->indent_level = indent_level;\n-      input_file_stack = p;\n-      input_file_stack_tick++;\n+      push_srcloc (new_file, l);\n+      input_file_stack->indent_level = indent_level;\n       debug_start_source_file (input_filename);\n       if (c_header_level)\n \t++c_header_level;\n@@ -2621,36 +2611,32 @@ check_newline ()\n       /* Popping out of a file.  */\n       if (input_file_stack->next)\n \t{\n-\t  struct file_stack *p = input_file_stack;\n-\n \t  if (c_header_level && --c_header_level == 0)\n \t    {\n \t      if (entering_c_header)\n \t\twarning (\"badly nested C headers from preprocessor\");\n \t      --pending_lang_change;\n \t    }\n \n-\t  if (indent_level != p->indent_level)\n+\t  if (indent_level != input_file_stack->indent_level)\n \t    {\n \t      warning_with_file_and_line\n-\t\t(p->name, old_lineno,\n+\t\t(input_filename, lineno,\n \t\t \"This file contains more `%c's than `%c's.\",\n-\t\t indent_level > p->indent_level ? '{' : '}',\n-\t\t indent_level > p->indent_level ? '}' : '{');\n+\t\t indent_level > input_file_stack->indent_level ? '{' : '}',\n+\t\t indent_level > input_file_stack->indent_level ? '}' : '{');\n \t    }\n-\t  input_file_stack = p->next;\n-\t  free (p);\n-\t  input_file_stack_tick++;\n+\n+\t  pop_srcloc ();\n+\t  input_file_stack->name = new_file;\n+\t  lineno = l;\n \t  debug_end_source_file (input_file_stack->line);\n \t}\n       else\n \terror (\"#-lines for entering and leaving files don't match\");\n     }\n \n-  /* Now that we've pushed or popped the input stack,\n-     update the name in the top element.  */\n-  if (input_file_stack)\n-    input_file_stack->name = input_filename;\n+  extract_interface_info ();\n \n   /* skip the rest of this line.  */\n  skipline:"}, {"sha": "e18f9568b829e9bc02ba0bd112b099a574079f1b", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=574a0ef53cf95e08a80f8e58711e90adfc3834f3", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cp-tree.h\"\n #include \"rtl.h\"\n #include \"insn-config.h\"\n+#include \"input.h\"\n #include \"integrate.h\"\n #include \"varray.h\"\n \n@@ -569,6 +570,13 @@ expand_call_inline (tp, walk_subtrees, data)\n   if (!inlinable_function_p (fn, id))\n     return NULL_TREE;\n \n+  /* Set the current filename and line number to the function we are\n+     inlining so that when we create new _STMT nodes here they get\n+     line numbers corresponding to the function we are calling.  We\n+     wrap the whole inlined body in an EXPR_WITH_FILE_AND_LINE as well\n+     because individual statements don't record the filename.  */\n+  push_srcloc (fn->decl.filename, fn->decl.linenum);\n+\n   /* Build a statement-expression containing code to initialize the\n      arguments, the actual inline expansion of the body, and a label\n      for the return statements within the function to jump to.  The\n@@ -660,6 +668,7 @@ expand_call_inline (tp, walk_subtrees, data)\n \t\t\t/*col=*/0);\n   EXPR_WFL_EMIT_LINE_NOTE (*tp) = 1;\n   TREE_CHAIN (*tp) = chain;\n+  pop_srcloc ();\n \n   /* If the value of the new expression is ignored, that's OK.  We\n      don't warn about this for CALL_EXPRs, so we shouldn't warn about"}, {"sha": "6532e2722838d33261d9f9b0c780a30914b247e7", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 93, "deletions": 98, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=574a0ef53cf95e08a80f8e58711e90adfc3834f3", "patch": "@@ -810,16 +810,16 @@ static const short yyrline[] = { 0,\n   3307,  3309,  3312,  3315,  3318,  3321,  3327,  3329,  3330,  3333,\n   3335,  3336,  3337,  3339,  3342,  3345,  3348,  3354,  3358,  3360,\n   3363,  3365,  3368,  3372,  3374,  3377,  3379,  3382,  3399,  3407,\n-  3410,  3412,  3414,  3418,  3421,  3422,  3430,  3434,  3438,  3441,\n-  3442,  3448,  3451,  3454,  3456,  3460,  3465,  3468,  3478,  3483,\n-  3484,  3491,  3494,  3497,  3499,  3502,  3504,  3514,  3528,  3532,\n-  3535,  3537,  3541,  3545,  3548,  3551,  3553,  3557,  3559,  3566,\n-  3573,  3576,  3580,  3584,  3588,  3594,  3598,  3603,  3605,  3608,\n-  3613,  3619,  3630,  3633,  3635,  3639,  3647,  3650,  3654,  3657,\n-  3659,  3661,  3667,  3672,  3675,  3677,  3679,  3681,  3683,  3685,\n-  3687,  3689,  3691,  3693,  3695,  3697,  3699,  3701,  3703,  3705,\n-  3707,  3709,  3711,  3713,  3715,  3717,  3719,  3721,  3723,  3725,\n-  3727,  3729,  3731,  3733,  3735,  3737,  3740,  3742\n+  3410,  3412,  3414,  3418,  3421,  3422,  3430,  3433,  3436,  3439,\n+  3440,  3446,  3449,  3452,  3454,  3458,  3463,  3466,  3476,  3481,\n+  3482,  3489,  3492,  3495,  3497,  3500,  3502,  3512,  3526,  3530,\n+  3533,  3535,  3539,  3543,  3546,  3549,  3551,  3555,  3557,  3564,\n+  3571,  3574,  3578,  3582,  3586,  3592,  3596,  3601,  3603,  3606,\n+  3611,  3617,  3628,  3631,  3633,  3637,  3645,  3648,  3652,  3655,\n+  3657,  3659,  3665,  3670,  3673,  3675,  3677,  3679,  3681,  3683,\n+  3685,  3687,  3689,  3691,  3693,  3695,  3697,  3699,  3701,  3703,\n+  3705,  3707,  3709,  3711,  3713,  3715,  3717,  3719,  3721,  3723,\n+  3725,  3727,  3729,  3731,  3733,  3735,  3738,  3740\n };\n #endif\n \n@@ -7848,75 +7848,70 @@ case 786:\n     break;}\n case 787:\n #line 3432 \"parse.y\"\n-{ emit_line_note (input_filename, lineno);\n-\t\t  yyval.ttype = NULL_TREE; ;\n-    break;}\n-case 788:\n-#line 3435 \"parse.y\"\n-{ emit_line_note (input_filename, lineno); ;\n+{ yyval.ttype = NULL_TREE; ;\n     break;}\n case 789:\n-#line 3440 \"parse.y\"\n+#line 3438 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 791:\n-#line 3443 \"parse.y\"\n+#line 3441 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 792:\n-#line 3450 \"parse.y\"\n+#line 3448 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 795:\n-#line 3457 \"parse.y\"\n+#line 3455 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 796:\n-#line 3462 \"parse.y\"\n+#line 3460 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 797:\n-#line 3467 \"parse.y\"\n+#line 3465 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 798:\n-#line 3469 \"parse.y\"\n+#line 3467 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 799:\n-#line 3480 \"parse.y\"\n+#line 3478 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 801:\n-#line 3485 \"parse.y\"\n+#line 3483 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 802:\n-#line 3493 \"parse.y\"\n+#line 3491 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 803:\n-#line 3495 \"parse.y\"\n+#line 3493 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 804:\n-#line 3498 \"parse.y\"\n+#line 3496 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 805:\n-#line 3500 \"parse.y\"\n+#line 3498 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 806:\n-#line 3503 \"parse.y\"\n+#line 3501 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 807:\n-#line 3505 \"parse.y\"\n+#line 3503 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7928,7 +7923,7 @@ case 807:\n \t\t;\n     break;}\n case 808:\n-#line 3515 \"parse.y\"\n+#line 3513 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7941,99 +7936,99 @@ case 808:\n \t\t;\n     break;}\n case 809:\n-#line 3530 \"parse.y\"\n+#line 3528 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 810:\n-#line 3532 \"parse.y\"\n+#line 3530 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 813:\n-#line 3543 \"parse.y\"\n+#line 3541 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 814:\n-#line 3546 \"parse.y\"\n+#line 3544 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 815:\n-#line 3549 \"parse.y\"\n+#line 3547 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 816:\n-#line 3552 \"parse.y\"\n+#line 3550 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 817:\n-#line 3554 \"parse.y\"\n+#line 3552 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 819:\n-#line 3560 \"parse.y\"\n+#line 3558 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 820:\n-#line 3570 \"parse.y\"\n+#line 3568 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 821:\n-#line 3574 \"parse.y\"\n+#line 3572 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 822:\n-#line 3577 \"parse.y\"\n+#line 3575 \"parse.y\"\n { yyval.ftype.t = build_tree_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 823:\n-#line 3581 \"parse.y\"\n+#line 3579 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 824:\n-#line 3585 \"parse.y\"\n+#line 3583 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 825:\n-#line 3589 \"parse.y\"\n+#line 3587 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 826:\n-#line 3596 \"parse.y\"\n+#line 3594 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 827:\n-#line 3599 \"parse.y\"\n+#line 3597 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 830:\n-#line 3610 \"parse.y\"\n+#line 3608 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 831:\n-#line 3615 \"parse.y\"\n+#line 3613 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 832:\n-#line 3620 \"parse.y\"\n+#line 3618 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -8044,192 +8039,192 @@ case 832:\n \t\t;\n     break;}\n case 833:\n-#line 3632 \"parse.y\"\n+#line 3630 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 834:\n-#line 3634 \"parse.y\"\n+#line 3632 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 835:\n-#line 3636 \"parse.y\"\n+#line 3634 \"parse.y\"\n { yyval.ttype = empty_except_spec; ;\n     break;}\n case 836:\n-#line 3641 \"parse.y\"\n+#line 3639 \"parse.y\"\n {\n \t\t  check_for_new_type (\"exception specifier\", yyvsp[0].ftype);\n \t\t  yyval.ttype = groktypename (yyvsp[0].ftype.t);\n \t\t;\n     break;}\n case 837:\n-#line 3649 \"parse.y\"\n+#line 3647 \"parse.y\"\n { yyval.ttype = add_exception_specifier (NULL_TREE, yyvsp[0].ttype, 1); ;\n     break;}\n case 838:\n-#line 3651 \"parse.y\"\n+#line 3649 \"parse.y\"\n { yyval.ttype = add_exception_specifier (yyvsp[-2].ttype, yyvsp[0].ttype, 1); ;\n     break;}\n case 839:\n-#line 3656 \"parse.y\"\n+#line 3654 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 840:\n-#line 3658 \"parse.y\"\n+#line 3656 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 841:\n-#line 3660 \"parse.y\"\n+#line 3658 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 842:\n-#line 3662 \"parse.y\"\n+#line 3660 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 843:\n-#line 3669 \"parse.y\"\n+#line 3667 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 844:\n-#line 3674 \"parse.y\"\n+#line 3672 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 845:\n-#line 3676 \"parse.y\"\n+#line 3674 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 846:\n-#line 3678 \"parse.y\"\n+#line 3676 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 847:\n-#line 3680 \"parse.y\"\n+#line 3678 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 848:\n-#line 3682 \"parse.y\"\n+#line 3680 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 849:\n-#line 3684 \"parse.y\"\n+#line 3682 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 850:\n-#line 3686 \"parse.y\"\n+#line 3684 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 851:\n-#line 3688 \"parse.y\"\n+#line 3686 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 852:\n-#line 3690 \"parse.y\"\n+#line 3688 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 853:\n-#line 3692 \"parse.y\"\n+#line 3690 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 854:\n-#line 3694 \"parse.y\"\n+#line 3692 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 855:\n-#line 3696 \"parse.y\"\n+#line 3694 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 856:\n-#line 3698 \"parse.y\"\n+#line 3696 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 857:\n-#line 3700 \"parse.y\"\n+#line 3698 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 858:\n-#line 3702 \"parse.y\"\n+#line 3700 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 859:\n-#line 3704 \"parse.y\"\n+#line 3702 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 860:\n-#line 3706 \"parse.y\"\n+#line 3704 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 861:\n-#line 3708 \"parse.y\"\n+#line 3706 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 862:\n-#line 3710 \"parse.y\"\n+#line 3708 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 863:\n-#line 3712 \"parse.y\"\n+#line 3710 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 864:\n-#line 3714 \"parse.y\"\n+#line 3712 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 865:\n-#line 3716 \"parse.y\"\n+#line 3714 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 866:\n-#line 3718 \"parse.y\"\n+#line 3716 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 867:\n-#line 3720 \"parse.y\"\n+#line 3718 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 868:\n-#line 3722 \"parse.y\"\n+#line 3720 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 869:\n-#line 3724 \"parse.y\"\n+#line 3722 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 870:\n-#line 3726 \"parse.y\"\n+#line 3724 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 871:\n-#line 3728 \"parse.y\"\n+#line 3726 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 872:\n-#line 3730 \"parse.y\"\n+#line 3728 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 873:\n-#line 3732 \"parse.y\"\n+#line 3730 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 874:\n-#line 3734 \"parse.y\"\n+#line 3732 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 875:\n-#line 3736 \"parse.y\"\n+#line 3734 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 876:\n-#line 3738 \"parse.y\"\n+#line 3736 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 877:\n-#line 3741 \"parse.y\"\n+#line 3739 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 878:\n-#line 3743 \"parse.y\"\n+#line 3741 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -8454,7 +8449,7 @@ case 878:\n     }\n   return 1;\n }\n-#line 3746 \"parse.y\"\n+#line 3744 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "9a85922849d0c6a9bdd1482b1d22e7b4d2b0c644", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574a0ef53cf95e08a80f8e58711e90adfc3834f3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=574a0ef53cf95e08a80f8e58711e90adfc3834f3", "patch": "@@ -3429,10 +3429,8 @@ for.init.statement:\n \n maybe_cv_qualifier:\n \t  /* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ $$ = NULL_TREE; }\n \t| CV_QUALIFIER\n-\t\t{ emit_line_note (input_filename, lineno); }\n \t;\n \n xexpr:"}]}