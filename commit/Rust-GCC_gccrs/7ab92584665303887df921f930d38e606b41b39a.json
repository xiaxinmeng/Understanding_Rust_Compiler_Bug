{"sha": "7ab92584665303887df921f930d38e606b41b39a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FiOTI1ODQ2NjUzMDM4ODdkZjkyMWY5MzBkMzhlNjA2YjQxYjM5YQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-06-29T22:01:35Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-06-29T22:01:35Z"}, "message": "Make sure types in assignments are compatible.\n\n2004-06-29  Steven Bosscher  <stevenb@suse.de>\n\n\tMake sure types in assignments are compatible.  Mostly mechanical.\n\t* trans-const.h (gfc_index_one_node): New define.\n\t* trans-array.c (gfc_trans_allocate_array_storage,\n\tgfc_trans_allocate_temp_array, gfc_trans_array_constructor_subarray,\n\tgfc_trans_array_constructor_value, gfc_trans_array_constructor,\n\tgfc_conv_array_ubound, gfc_conv_array_ref,\n\tgfc_trans_scalarized_loop_end, gfc_conv_section_startstride,\n\tgfc_conv_ss_startstride, gfc_conv_loop_setup, gfc_array_init_size,\n\tgfc_trans_array_bounds, gfc_trans_dummy_array_bias,\n\tgfc_conv_expr_descriptor, gfc_trans_deferred_array): Use the correct\n\ttypes in assignments, conversions and conditionals for expressions.\n\t* trans-expr.c (gfc_conv_expr_present, gfc_conv_substring,\n\tgfc_conv_unary_op, gfc_conv_cst_int_power, gfc_conv_string_tmp,\n\tgfc_conv_function_call, gfc_trans_pointer_assignment,\n\tgfc_trans_scalar_assign): Likewise.\n\t* trans-intrinsic.c (build_fixbound_expr, gfc_conv_intrinsic_bound,\n\tgfc_conv_intrinsic_anyall, gfc_conv_intrinsic_count,\n\tgfc_conv_intrinsic_minmaxloc, gfc_conv_intrinsic_btest,\n\tgfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ishft,\n\tgfc_conv_intrinsic_ishftc, gfc_conv_intrinsic_strcmp,\n\tgfc_conv_allocated, gfc_conv_associated,\n\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_trim): Likewise.\n\t* trans-io.c (set_string): Likewise.\n\t* trans-stmt.c (gfc_trans_do, gfc_trans_forall_loop,\n\tgfc_do_allocate, generate_loop_for_temp_to_lhs,\n\tgenerate_loop_for_rhs_to_temp, compute_inner_temp_size,\n\tcompute_overall_iter_number, gfc_trans_assign_need_temp,\n\tgfc_trans_pointer_assign_need_temp, gfc_trans_forall_1,\n\tgfc_evaluate_where_mask, gfc_trans_where_assign,\n\tgfc_trans_where_2): Likewise.\n\t* trans-types.c (gfc_get_character_type, gfc_build_array_type,\n\tgfc_get_nodesc_array_type, gfc_get_array_type_bounds): Likewise.\n\n\t* trans.c (gfc_add_modify_expr): Add sanity check that types\n\tfor the lhs and rhs are the same for scalar assignments.\n\nFrom-SVN: r83877", "tree": {"sha": "5200b1c6f390cd74c55fea19d853189ee1fb3d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5200b1c6f390cd74c55fea19d853189ee1fb3d1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ab92584665303887df921f930d38e606b41b39a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ab92584665303887df921f930d38e606b41b39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ab92584665303887df921f930d38e606b41b39a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ab92584665303887df921f930d38e606b41b39a/comments", "author": null, "committer": null, "parents": [{"sha": "e23667c608660cde7885ceb7aaaf0cc97eac3723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e23667c608660cde7885ceb7aaaf0cc97eac3723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e23667c608660cde7885ceb7aaaf0cc97eac3723"}], "stats": {"total": 440, "additions": 264, "deletions": 176}, "files": [{"sha": "135d8cfa8cac1d28a043090e9ce82d51c40fd8d2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -1,3 +1,41 @@\n+2004-06-29  Steven Bosscher  <stevenb@suse.de>\n+\n+\tMake sure types in assignments are compatible.  Mostly mechanical.\n+\t* trans-const.h (gfc_index_one_node): New define.\n+\t* trans-array.c (gfc_trans_allocate_array_storage,\n+\tgfc_trans_allocate_temp_array, gfc_trans_array_constructor_subarray,\n+\tgfc_trans_array_constructor_value, gfc_trans_array_constructor,\n+\tgfc_conv_array_ubound, gfc_conv_array_ref,\n+\tgfc_trans_scalarized_loop_end, gfc_conv_section_startstride,\n+\tgfc_conv_ss_startstride, gfc_conv_loop_setup, gfc_array_init_size,\n+\tgfc_trans_array_bounds, gfc_trans_dummy_array_bias,\n+\tgfc_conv_expr_descriptor, gfc_trans_deferred_array): Use the correct\n+\ttypes in assignments, conversions and conditionals for expressions.\n+\t* trans-expr.c (gfc_conv_expr_present, gfc_conv_substring,\n+\tgfc_conv_unary_op, gfc_conv_cst_int_power, gfc_conv_string_tmp,\n+\tgfc_conv_function_call, gfc_trans_pointer_assignment,\n+\tgfc_trans_scalar_assign): Likewise.\n+\t* trans-intrinsic.c (build_fixbound_expr, gfc_conv_intrinsic_bound,\n+\tgfc_conv_intrinsic_anyall, gfc_conv_intrinsic_count,\n+\tgfc_conv_intrinsic_minmaxloc, gfc_conv_intrinsic_btest,\n+\tgfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ishft,\n+\tgfc_conv_intrinsic_ishftc, gfc_conv_intrinsic_strcmp,\n+\tgfc_conv_allocated, gfc_conv_associated,\n+\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_trim): Likewise.\n+\t* trans-io.c (set_string): Likewise.\n+\t* trans-stmt.c (gfc_trans_do, gfc_trans_forall_loop,\n+\tgfc_do_allocate, generate_loop_for_temp_to_lhs,\n+\tgenerate_loop_for_rhs_to_temp, compute_inner_temp_size,\n+\tcompute_overall_iter_number, gfc_trans_assign_need_temp,\n+\tgfc_trans_pointer_assign_need_temp, gfc_trans_forall_1,\n+\tgfc_evaluate_where_mask, gfc_trans_where_assign,\n+\tgfc_trans_where_2): Likewise.\n+\t* trans-types.c (gfc_get_character_type, gfc_build_array_type,\n+\tgfc_get_nodesc_array_type, gfc_get_array_type_bounds): Likewise.\n+\n+\t* trans.c (gfc_add_modify_expr): Add sanity check that types\n+\tfor the lhs and rhs are the same for scalar assignments.\n+\n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* dump-parse-tree.c (show_common): New function."}, {"sha": "731fb193099863fae78d875cf2aa0b73fdef7925", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 61, "deletions": 54, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -443,7 +443,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n       /* Make a temporary variable to hold the data.  */\n       tmp = fold (build (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n \t\t\t integer_one_node));\n-      tmp = build_range_type (gfc_array_index_type, integer_zero_node, tmp);\n+      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n       tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)), tmp);\n       tmp = gfc_create_var (tmp, \"A\");\n       tmp = gfc_build_addr_expr (TREE_TYPE (data), tmp);\n@@ -515,12 +515,12 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \t{\n \t  loop->to[n] = fold (build (MINUS_EXPR, gfc_array_index_type,\n \t\t\t\t     loop->to[n], loop->from[n]));\n-\t  loop->from[n] = integer_zero_node;\n+\t  loop->from[n] = gfc_index_zero_node;\n \t}\n \n-      info->delta[dim] = integer_zero_node;\n-      info->start[dim] = integer_zero_node;\n-      info->stride[dim] = integer_one_node;\n+      info->delta[dim] = gfc_index_zero_node;\n+      info->start[dim] = gfc_index_zero_node;\n+      info->stride[dim] = gfc_index_one_node;\n       info->dim[dim] = dim;\n     }\n \n@@ -531,36 +531,40 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n   GFC_DECL_PACKED_ARRAY (desc) = 1;\n \n   info->descriptor = desc;\n-  size = integer_one_node;\n+  size = gfc_index_one_node;\n \n   /* Fill in the array dtype.  */\n   tmp = gfc_conv_descriptor_dtype (desc);\n   gfc_add_modify_expr (&loop->pre, tmp,\n \t\t       GFC_TYPE_ARRAY_DTYPE (TREE_TYPE (desc)));\n \n-  /* Fill in the bounds and stride.  This is a packed array, so:\n+  /*\n+     Fill in the bounds and stride.  This is a packed array, so:\n+\n      size = 1;\n      for (n = 0; n < rank; n++)\n-     {\n-     stride[n] = size\n-     delta = ubound[n] + 1 - lbound[n];\n-     size = size * delta;\n-     }\n-     size = size * sizeof(element);  */\n+       {\n+\t stride[n] = size\n+\t delta = ubound[n] + 1 - lbound[n];\n+         size = size * delta;\n+       }\n+     size = size * sizeof(element);\n+  */\n+\n   for (n = 0; n < info->dimen; n++)\n     {\n       /* Store the stride and bound components in the descriptor.  */\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[n]);\n       gfc_add_modify_expr (&loop->pre, tmp, size);\n \n       tmp = gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (&loop->pre, tmp, integer_zero_node);\n+      gfc_add_modify_expr (&loop->pre, tmp, gfc_index_zero_node);\n \n       tmp = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]);\n       gfc_add_modify_expr (&loop->pre, tmp, loop->to[n]);\n \n       tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t loop->to[n], integer_one_node));\n+\t\t\t loop->to[n], gfc_index_one_node));\n \n       size = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n       size = gfc_evaluate_now (size, &loop->pre);\n@@ -645,7 +649,7 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   gfc_add_modify_expr (&body, tmp, se.expr);\n \n   /* Increment the offset.  */\n-  tmp = build (PLUS_EXPR, gfc_array_index_type, *poffset, integer_one_node);\n+  tmp = build (PLUS_EXPR, gfc_array_index_type, *poffset, gfc_index_one_node);\n   gfc_add_modify_expr (&body, *poffset, tmp);\n \n   /* Finish the loop.  */\n@@ -716,11 +720,12 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \n \t      ref = gfc_build_indirect_ref (pointer);\n \t      ref = gfc_build_array_ref (ref, *poffset);\n-\t      gfc_add_modify_expr (&body, ref, se.expr);\n+\t      gfc_add_modify_expr (&body, ref,\n+\t\t\t\t   fold_convert (TREE_TYPE (ref), se.expr));\n \t      gfc_add_block_to_block (&body, &se.post);\n \n \t      *poffset = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      *poffset, integer_one_node));\n+\t\t\t\t      *poffset, gfc_index_one_node));\n \t    }\n \t  else\n \t    {\n@@ -746,7 +751,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      bound = build_int_2 (n - 1, 0);\n               /* Create an array type to hold them.  */\n \t      tmptype = build_range_type (gfc_array_index_type,\n-\t\t\t\t\t  integer_zero_node, bound);\n+\t\t\t\t\t  gfc_index_zero_node, bound);\n \t      tmptype = build_array_type (type, tmptype);\n \n \t      init = build1 (CONSTRUCTOR, tmptype, nreverse (list));\n@@ -942,7 +947,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n     gfc_trans_allocate_temp_array (loop, &ss->data.info, type, NULL_TREE);\n \n   desc = ss->data.info.descriptor;\n-  offset = integer_zero_node;\n+  offset = gfc_index_zero_node;\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n   TREE_USED (offsetvar) = 0;\n   gfc_trans_array_constructor_value (&loop->pre, type,\n@@ -1214,7 +1219,7 @@ gfc_conv_array_ubound (tree descriptor, int dim)\n   /* This should only ever happen when passing an assumed shape array\n      as an actual parameter.  The value will never be used.  */\n   if (GFC_ARRAY_TYPE_P (TREE_TYPE (descriptor)))\n-    return integer_zero_node;\n+    return gfc_index_zero_node;\n \n   tmp = gfc_conv_descriptor_ubound (descriptor, gfc_rank_cst[dim]);\n   return tmp;\n@@ -1466,9 +1471,9 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar)\n       return;\n     }\n \n-  index = integer_zero_node;\n+  index = gfc_index_zero_node;\n \n-  fault = integer_zero_node;\n+  fault = gfc_index_zero_node;\n \n   /* Calculate the offsets from all the dimensions.  */\n   for (n = 0; n < ar->dimen; n++)\n@@ -1687,7 +1692,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n \n   /* Increment the loopvar.  */\n   tmp = build (PLUS_EXPR, gfc_array_index_type,\n-\t       loop->loopvar[n], integer_one_node);\n+\t       loop->loopvar[n], gfc_index_one_node);\n   gfc_add_modify_expr (&block, loop->loopvar[n], tmp);\n \n   /* Build the loop.  */\n@@ -1885,7 +1890,7 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n \n   /* Calculate the stride.  */\n   if (stride == NULL)\n-    info->stride[n] = integer_one_node;\n+    info->stride[n] = gfc_index_one_node;\n   else\n     {\n       gfc_init_se (&se, NULL);\n@@ -1948,8 +1953,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \tcase GFC_SS_FUNCTION:\n \t  for (n = 0; n < ss->data.info.dimen; n++)\n \t    {\n-\t      ss->data.info.start[n] = integer_zero_node;\n-\t      ss->data.info.stride[n] = integer_one_node;\n+\t      ss->data.info.start[n] = gfc_index_zero_node;\n+\t      ss->data.info.stride[n] = gfc_index_one_node;\n \t    }\n \t  break;\n \n@@ -2322,7 +2327,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \n       /* Transform everything so we have a simple incrementing variable.  */\n       if (integer_onep (info->stride[n]))\n-\tinfo->delta[n] = integer_zero_node;\n+\tinfo->delta[n] = gfc_index_zero_node;\n       else\n \t{\n \t  /* Set the delta for this section.  */\n@@ -2337,7 +2342,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t\t\t     info->stride[n]));\n \t  loop->to[n] = gfc_evaluate_now (tmp, &loop->pre);\n \t  /* Make the loop variable start at 0.  */\n-\t  loop->from[n] = integer_zero_node;\n+\t  loop->from[n] = gfc_index_zero_node;\n \t}\n     }\n \n@@ -2435,8 +2440,8 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n \n   type = TREE_TYPE (descriptor);\n \n-  stride = integer_one_node;\n-  offset = integer_zero_node;\n+  stride = gfc_index_one_node;\n+  offset = gfc_index_zero_node;\n \n   /* Set the dtype.  */\n   tmp = gfc_conv_descriptor_dtype (descriptor);\n@@ -2454,7 +2459,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       /* Set lower bound.  */\n       gfc_init_se (&se, NULL);\n       if (lower == NULL)\n-\tse.expr = integer_one_node;\n+\tse.expr = gfc_index_one_node;\n       else\n \t{\n \t  assert (lower[n]);\n@@ -2465,7 +2470,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n             }\n           else\n             {\n-              se.expr = integer_one_node;\n+              se.expr = gfc_index_one_node;\n               ubound = lower[n];\n             }\n \t}\n@@ -2478,7 +2483,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n \n       /* Start the calculation for the size of this dimension.  */\n       size = build (MINUS_EXPR, gfc_array_index_type,\n-\t\t    integer_one_node, se.expr);\n+\t\t    gfc_index_one_node, se.expr);\n \n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n@@ -2754,8 +2759,8 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \n   as = sym->as;\n \n-  size = integer_one_node;\n-  offset = integer_zero_node;\n+  size = gfc_index_one_node;\n+  offset = gfc_index_zero_node;\n   for (dim = 0; dim < as->rank; dim++)\n     {\n       /* Evaluate non-constant array bound expressions.  */\n@@ -2789,7 +2794,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n         {\n           /* Calculate stride = size * (ubound + 1 - lbound).  */\n           tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-                             integer_one_node, lbound));\n+                             gfc_index_one_node, lbound));\n           tmp = fold (build (PLUS_EXPR, gfc_array_index_type, ubound, tmp));\n           tmp = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n           if (stride)\n@@ -3062,7 +3067,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n       tmp = build (EQ_EXPR, boolean_type_node, stride, integer_zero_node);\n       tmp = build (COND_EXPR, gfc_array_index_type, tmp,\n-                   integer_one_node, stride);\n+                   gfc_index_one_node, stride);\n       stride = GFC_TYPE_ARRAY_STRIDE (type, 0);\n       gfc_add_modify_expr (&block, stride, tmp);\n \n@@ -3077,7 +3082,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       tmp = gfc_chainon_list (NULL_TREE, tmp);\n       stmt_unpacked = gfc_build_function_call (gfor_fndecl_in_pack, tmp);\n \n-      stride = integer_one_node;\n+      stride = gfc_index_one_node;\n     }\n \n   /* This is for the case where the array data is used directly without\n@@ -3096,10 +3101,10 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n     }\n   else\n     tmp = stmt_packed != NULL_TREE ? stmt_packed : stmt_unpacked;\n-  gfc_add_modify_expr (&block, tmpdesc, tmp);\n+  gfc_add_modify_expr (&block, tmpdesc, fold_convert (type, tmp));\n \n-  offset = integer_zero_node;\n-  size = integer_one_node;\n+  offset = gfc_index_zero_node;\n+  size = gfc_index_one_node;\n \n   /* Evaluate the bounds of the array.  */\n   for (n = 0; n < sym->as->rank; n++)\n@@ -3185,7 +3190,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n                 {\n                   /* Calculate stride = size * (ubound + 1 - lbound).  */\n                   tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-                                     integer_one_node, lbound));\n+                                     gfc_index_one_node, lbound));\n                   tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n                                      ubound, tmp));\n                   size = fold (build (MULT_EXPR, gfc_array_index_type,\n@@ -3266,8 +3271,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n }\n \n \n-/* Convert an array for passing as an actual parameter.  Expressions\n-   and vector subscripts are evaluated and stored in a teporary, which is then\n+/* Convert an array for passing as an actual parameter.  Expressions and\n+   vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n    a modified copy of the descriptor is passed, but using the original data.\n    Also used for array pointer assignments by setting se->direct_byref.  */\n@@ -3435,7 +3440,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       /* Set the first stride component to zero to indicate a temporary.  */\n       desc = loop.temp_ss->data.info.descriptor;\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[0]);\n-      gfc_add_modify_expr (&loop.pre, tmp, integer_zero_node);\n+      gfc_add_modify_expr (&loop.pre, tmp, gfc_index_zero_node);\n \n       assert (is_gimple_lvalue (desc));\n       se->expr = gfc_build_addr_expr (NULL, desc);\n@@ -3473,7 +3478,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  parm = gfc_create_var (parmtype, \"parm\");\n \t}\n \n-      offset = integer_zero_node;\n+      offset = gfc_index_zero_node;\n       dim = 0;\n \n       /* The following can be somewhat confusing.  We have two\n@@ -3490,7 +3495,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       gfc_add_modify_expr (&loop.pre, tmp, GFC_TYPE_ARRAY_DTYPE (parmtype));\n \n       if (se->direct_byref)\n-\tbase = integer_zero_node;\n+\tbase = gfc_index_zero_node;\n       else\n \tbase = NULL_TREE;\n \n@@ -3536,10 +3541,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n           if (!integer_onep (from))\n \t    {\n \t      /* Make sure the new section starts at 1.  */\n-\t      tmp = fold (build (MINUS_EXPR, TREE_TYPE (from),\n-\t\t\t\t integer_one_node, from));\n-\t      to = fold (build (PLUS_EXPR, TREE_TYPE (to), to, tmp));\n-\t      from = integer_one_node;\n+\t      tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t gfc_index_one_node, from));\n+\t      to = fold (build (PLUS_EXPR, gfc_array_index_type, to, tmp));\n+\t      from = gfc_index_one_node;\n \t    }\n \t  tmp = gfc_conv_descriptor_lbound (parm, gfc_rank_cst[dim]);\n \t  gfc_add_modify_expr (&loop.pre, tmp, from);\n@@ -3573,7 +3578,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       offset = gfc_build_addr_expr (gfc_array_dataptr_type (desc), tmp);\n \n       tmp = gfc_conv_descriptor_data (parm);\n-      gfc_add_modify_expr (&loop.pre, tmp, offset);\n+      gfc_add_modify_expr (&loop.pre, tmp,\n+\t\t\t   fold_convert (TREE_TYPE (tmp), offset));\n \n       if (se->direct_byref)\n \t{\n@@ -3737,7 +3743,8 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \n   /* NULLIFY the data pointer.  */\n   tmp = gfc_conv_descriptor_data (descriptor);\n-  gfc_add_modify_expr (&fnblock, tmp, integer_zero_node);\n+  gfc_add_modify_expr (&fnblock, tmp,\n+\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n \n   gfc_add_expr_to_block (&fnblock, body);\n "}, {"sha": "97e831346feb5cef0cf57c3d9de04227008db4f9", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -56,4 +56,6 @@ extern GTY(()) tree gfc_strconst_wrong_return;\n \n /* Integer constants 0..GFC_MAX_DIMENSIONS.  */\n extern GTY(()) tree gfc_rank_cst[GFC_MAX_DIMENSIONS + 1];\n+\n #define gfc_index_zero_node gfc_rank_cst[0]\n+#define gfc_index_one_node gfc_rank_cst[1]"}, {"sha": "47a844d92d232ad6d08fbdd75946ca2ea9b0a5e3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -135,7 +135,8 @@ gfc_conv_expr_present (gfc_symbol * sym)\n              || GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n-  return build (NE_EXPR, boolean_type_node, decl, null_pointer_node);\n+  return build (NE_EXPR, boolean_type_node, decl,\n+\t\tfold_convert (TREE_TYPE (decl), null_pointer_node));\n }\n \n \n@@ -174,9 +175,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind)\n   gfc_add_block_to_block (&se->pre, &start.pre);\n \n   if (integer_onep (start.expr))\n-    {\n-      gfc_conv_string_parameter (se);\n-    }\n+    gfc_conv_string_parameter (se);\n   else\n     {\n       /* Change the start of the string.  */\n@@ -198,7 +197,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind)\n       gfc_add_block_to_block (&se->pre, &end.pre);\n     }\n   tmp =\n-    build (MINUS_EXPR, gfc_strlen_type_node, integer_one_node, start.expr);\n+    build (MINUS_EXPR, gfc_strlen_type_node,\n+\t   fold_convert (gfc_strlen_type_node, integer_one_node),\n+\t   start.expr);\n   tmp = build (PLUS_EXPR, gfc_strlen_type_node, end.expr, tmp);\n   se->string_length = fold (tmp);\n }\n@@ -376,7 +377,8 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n      We must convert it to a compare to 0 (e.g. EQ_EXPR (op1, 0)).\n      All other unary operators have an equivalent GIMPLE unary operator  */\n   if (code == TRUTH_NOT_EXPR)\n-    se->expr = build (EQ_EXPR, type, operand.expr, integer_zero_node);\n+    se->expr = build (EQ_EXPR, type, operand.expr,\n+\t\t      convert (type, integer_zero_node));\n   else\n     se->expr = build1 (code, type, operand.expr);\n \n@@ -502,24 +504,27 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   if ((sgn == -1) && (TREE_CODE (type) == INTEGER_TYPE))\n     {\n       tmp = build (EQ_EXPR, boolean_type_node, lhs,\n-\t\t\tinteger_minus_one_node);\n+\t\t   fold_convert (TREE_TYPE (lhs), integer_minus_one_node));\n       cond = build (EQ_EXPR, boolean_type_node, lhs,\n-\t\t\tinteger_one_node);\n+\t\t    convert (TREE_TYPE (lhs), integer_one_node));\n \n       /* If rhs is an even,\n-\tresult = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n+\t result = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n       if ((n & 1) == 0)\n         {\n \t  tmp = build (TRUTH_OR_EXPR, boolean_type_node, tmp, cond);\n-\t  se->expr = build (COND_EXPR, type, tmp, integer_one_node, \n-\t\t\tinteger_zero_node);\n+\t  se->expr = build (COND_EXPR, type, tmp,\n+\t\t\t    convert (type, integer_one_node),\n+\t\t\t    convert (type, integer_zero_node));\n \t  return 1;\n \t}\n       /* If rhs is an odd,\n \t result = (lhs == 1) ? 1 : (lhs == -1) ? -1 : 0.  */\n-      tmp = build (COND_EXPR, type, tmp, integer_minus_one_node,\n-\t\t\tinteger_zero_node);\n-      se->expr = build (COND_EXPR, type, cond, integer_one_node,\n+      tmp = build (COND_EXPR, type, tmp,\n+\t\t   convert (type, integer_minus_one_node),\n+\t\t   convert (type, integer_zero_node));\n+      se->expr = build (COND_EXPR, type, cond,\n+\t\t\tconvert (type, integer_one_node),\n \t\t\ttmp);\n       return 1;\n     }\n@@ -675,11 +680,16 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n   tree tmp;\n   tree args;\n \n+  if (TREE_TYPE (len) != gfc_strlen_type_node)\n+    abort ();\n+\n   if (gfc_can_put_var_on_stack (len))\n     {\n       /* Create a temporary variable to hold the result.  */\n-      tmp = fold (build (MINUS_EXPR, TREE_TYPE (len), len, integer_one_node));\n-      tmp = build_range_type (gfc_array_index_type, integer_zero_node, tmp);\n+      tmp = fold (build (MINUS_EXPR, gfc_strlen_type_node, len,\n+\t\t\t convert (gfc_strlen_type_node,\n+\t\t\t\t  integer_one_node)));\n+      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n       tmp = build_array_type (gfc_character1_type_node, tmp);\n       var = gfc_create_var (tmp, \"str\");\n       var = gfc_build_addr_expr (type, var);\n@@ -1030,7 +1040,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Zero the first stride to indicate a temporary.  */\n \t  tmp =\n \t    gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n-\t  gfc_add_modify_expr (&se->pre, tmp, integer_zero_node);\n+\t  gfc_add_modify_expr (&se->pre, tmp,\n+\t\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n \t  /* Pass the temporary as the first argument.  */\n \t  tmp = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL, tmp);\n@@ -1080,8 +1091,10 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      parmse.expr = null_pointer_node;\n               if (arg->missing_arg_type == BT_CHARACTER)\n                 {\n-                  stringargs = gfc_chainon_list (stringargs,\n-                      convert (gfc_strlen_type_node, integer_zero_node));\n+                  stringargs =\n+\t\t    gfc_chainon_list (stringargs,\n+\t\t\t\t      convert (gfc_strlen_type_node,\n+\t\t\t\t\t       integer_zero_node));\n                 }\n \t    }\n \t}\n@@ -1589,7 +1602,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_ss *lss;\n   gfc_ss *rss;\n   stmtblock_t block;\n-  tree tmp;\n \n   gfc_start_block (&block);\n \n@@ -1607,7 +1619,8 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_conv_expr (&rse, expr2);\n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n-      gfc_add_modify_expr (&block, lse.expr, rse.expr);\n+      gfc_add_modify_expr (&block, lse.expr,\n+\t\t\t   fold_convert (TREE_TYPE (lse.expr), rse.expr));\n       gfc_add_block_to_block (&block, &rse.post);\n       gfc_add_block_to_block (&block, &lse.post);\n     }\n@@ -1618,9 +1631,8 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       if (expr2->expr_type == EXPR_NULL)\n         {\n           lse.expr = gfc_conv_descriptor_data (lse.expr);\n-          rse.expr = null_pointer_node;\n-          tmp = build_v (MODIFY_EXPR, lse.expr, rse.expr);\n-          gfc_add_expr_to_block (&block, tmp);\n+          rse.expr = fold_convert (TREE_TYPE (lse.expr), null_pointer_node);\n+          gfc_add_modify_expr (&block, lse.expr, rse.expr);\n         }\n       else\n         {\n@@ -1690,7 +1702,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, bt type)\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n \n-      gfc_add_modify_expr (&block, lse->expr, rse->expr);\n+      gfc_add_modify_expr (&block, lse->expr,\n+\t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n     }\n \n   gfc_add_block_to_block (&block, &lse->post);"}, {"sha": "37a6a05761ed9ab8d52b699729ab71dc49fcb164", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -228,7 +228,8 @@ build_fixbound_expr (stmtblock_t * pblock, tree arg, tree type, int up)\n   tmp = convert (argtype, intval);\n   cond = build (up ? GE_EXPR : LE_EXPR, boolean_type_node, tmp, arg);\n \n-  tmp = build (up ? PLUS_EXPR : MINUS_EXPR, type, intval, integer_one_node);\n+  tmp = build (up ? PLUS_EXPR : MINUS_EXPR, type, intval,\n+\t       convert (type, integer_one_node));\n   tmp = build (COND_EXPR, type, cond, intval, tmp);\n   return tmp;\n }\n@@ -651,7 +652,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       bound = argse.expr;\n       /* Convert from one based to zero based.  */\n       bound = fold (build (MINUS_EXPR, gfc_array_index_type, bound,\n-                    integer_one_node));\n+\t\t\t   gfc_index_one_node));\n     }\n \n   /* TODO: don't re-evaluate the descriptor on each iteration.  */\n@@ -677,7 +678,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n         {\n           bound = gfc_evaluate_now (bound, &se->pre);\n           cond = fold (build (LT_EXPR, boolean_type_node, bound,\n-                              integer_zero_node));\n+                              convert (TREE_TYPE (bound), integer_zero_node)));\n           tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n           tmp = fold (build (GE_EXPR, boolean_type_node, bound, tmp));\n           cond = fold(build (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp));\n@@ -1172,7 +1173,9 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, int op)\n   gfc_conv_expr_val (&arrayse, actual->expr);\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n-  tmp = build (op, boolean_type_node, arrayse.expr, integer_zero_node);\n+  tmp = build (op, boolean_type_node, arrayse.expr,\n+\t       fold_convert (TREE_TYPE (arrayse.expr),\n+\t\t\t     integer_zero_node));\n   tmp = build_v (COND_EXPR, tmp, found, build_empty_stmt ());\n   gfc_add_expr_to_block (&body, tmp);\n   gfc_add_block_to_block (&body, &arrayse.post);\n@@ -1214,7 +1217,7 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   type = gfc_typenode_for_spec (&expr->ts);\n   /* Initialize the result.  */\n   resvar = gfc_create_var (type, \"count\");\n-  gfc_add_modify_expr (&se->pre, resvar, integer_zero_node);\n+  gfc_add_modify_expr (&se->pre, resvar, convert (type, integer_zero_node));\n \n   /* Walk the arguments.  */\n   arrayss = gfc_walk_expr (actual->expr);\n@@ -1232,7 +1235,8 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (&loop, &body);\n \n-  tmp = build (PLUS_EXPR, TREE_TYPE (resvar), resvar, integer_one_node);\n+  tmp = build (PLUS_EXPR, TREE_TYPE (resvar), resvar,\n+\t       convert (TREE_TYPE (resvar), integer_one_node));\n   tmp = build_v (MODIFY_EXPR, resvar, tmp);\n \n   gfc_init_se (&arrayse, NULL);\n@@ -1453,7 +1457,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n      array, in case all elements are equal to the limit.\n      ie. pos = (ubound >= lbound) ? lbound, lbound - 1;  */\n   tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-\t             loop.from[0], integer_one_node));\n+\t             loop.from[0], gfc_index_one_node));\n   cond = fold (build (GE_EXPR, boolean_type_node,\n \t\t      loop.to[0], loop.from[0]));\n   tmp = fold (build (COND_EXPR, gfc_array_index_type, cond,\n@@ -1522,7 +1526,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Return a value in the range 1..SIZE(array).  */\n   tmp = fold (build (MINUS_EXPR, gfc_array_index_type, loop.from[0],\n-\t\t     integer_one_node));\n+\t\t     gfc_index_one_node));\n   tmp = fold (build (MINUS_EXPR, gfc_array_index_type, pos, tmp));\n   /* And convert to the required type.  */\n   se->expr = convert (type, tmp);\n@@ -1670,9 +1674,10 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  tmp = build (LSHIFT_EXPR, type, integer_one_node, arg2);\n+  tmp = build (LSHIFT_EXPR, type, convert (type, integer_one_node), arg2);\n   tmp = build (BIT_AND_EXPR, type, arg, tmp);\n-  tmp = fold (build (NE_EXPR, boolean_type_node, tmp, integer_zero_node));\n+  tmp = fold (build (NE_EXPR, boolean_type_node, tmp,\n+\t\t     convert (type, integer_zero_node)));\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, tmp);\n }\n@@ -1720,7 +1725,8 @@ gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  tmp = fold (build (LSHIFT_EXPR, type, integer_one_node, arg2));\n+  tmp = fold (build (LSHIFT_EXPR, type,\n+\t\t     convert (type, integer_one_node), arg2));\n   if (set)\n     op = BIT_IOR_EXPR;\n   else\n@@ -1783,11 +1789,13 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   tmp = build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n   rshift = build (RSHIFT_EXPR, type, arg, tmp);\n \n-  tmp = build (GT_EXPR, boolean_type_node, arg2, integer_zero_node);\n+  tmp = build (GT_EXPR, boolean_type_node, arg2,\n+\t       convert (TREE_TYPE (arg2), integer_zero_node));\n   rshift = build (COND_EXPR, type, tmp, lshift, rshift);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = build (EQ_EXPR, boolean_type_node, arg2, integer_zero_node);\n+  tmp = build (EQ_EXPR, boolean_type_node, arg2,\n+\t       convert (TREE_TYPE (arg2), integer_zero_node));\n   se->expr = build (COND_EXPR, type, tmp, arg, rshift);\n }\n \n@@ -1843,11 +1851,13 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   tmp = build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n   rrot = build (RROTATE_EXPR, type, arg, tmp);\n \n-  tmp = build (GT_EXPR, boolean_type_node, arg2, integer_zero_node);\n+  tmp = build (GT_EXPR, boolean_type_node, arg2,\n+\t       convert (TREE_TYPE (arg2), integer_zero_node));\n   rrot = build (COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = build (EQ_EXPR, boolean_type_node, arg2, integer_zero_node);\n+  tmp = build (EQ_EXPR, boolean_type_node, arg2,\n+\t       convert (TREE_TYPE (arg2), integer_zero_node));\n   se->expr = build (COND_EXPR, type, tmp, arg, rrot);\n }\n \n@@ -2040,7 +2050,8 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n   se->expr = gfc_build_function_call (gfor_fndecl_compare_string, args);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = build (op, type, se->expr, integer_zero_node);\n+  se->expr = build (op, type, se->expr,\n+\t\t    convert (TREE_TYPE (se->expr), integer_zero_node));\n }\n \n /* Generate a call to the adjustl/adjustr library function.  */\n@@ -2130,7 +2141,8 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n \n   tmp = gfc_conv_descriptor_data (arg1se.expr);\n-  tmp = build (NE_EXPR, boolean_type_node, tmp, null_pointer_node);\n+  tmp = build (NE_EXPR, boolean_type_node, tmp,\n+\t       fold_convert (TREE_TYPE (tmp), null_pointer_node));\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n \n@@ -2176,7 +2188,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           gfc_conv_expr_lhs (&arg1se, arg1->expr);\n           tmp2 = gfc_conv_descriptor_data (arg1se.expr);\n         }\n-      tmp = build (NE_EXPR, boolean_type_node, tmp2, null_pointer_node);\n+      tmp = build (NE_EXPR, boolean_type_node, tmp2,\n+\t\t   fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n       se->expr = tmp;\n     }\n   else\n@@ -2450,7 +2463,8 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n \n    cond2 = build (EQ_EXPR, boolean_type_node, rcs.frac, zero);\n    cond = build (TRUTH_ANDIF_EXPR, boolean_type_node, cond, cond2);\n-   tmp = build (COND_EXPR, masktype, cond, integer_zero_node, tmp);\n+   tmp = build (COND_EXPR, masktype, cond,\n+\t\tconvert (masktype, integer_zero_node), tmp);\n \n    tmp = build1 (VIEW_CONVERT_EXPR, rcs.type, tmp);\n    se->expr = tmp;\n@@ -2527,7 +2541,8 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build (GT_EXPR, boolean_type_node, len, integer_zero_node);\n+  cond = build (GT_EXPR, boolean_type_node, len,\n+\t\tconvert (TREE_TYPE (len), integer_zero_node));\n   arglist = gfc_chainon_list (NULL_TREE, var);\n   tmp = gfc_build_function_call (gfor_fndecl_internal_free, arglist);\n   tmp = build_v (COND_EXPR, cond, tmp, build_empty_stmt ());"}, {"sha": "9c4acc5e035dcb58dbc2cbe53b540f41fd3f8f34", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -404,21 +404,22 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n   len = build (COMPONENT_REF, TREE_TYPE (var_len), ioparm_var, var_len,\n \t       NULL_TREE);\n \n-  /*  Integer variable assigned a format label.  */\n+  /* Integer variable assigned a format label.  */\n   if (e->ts.type == BT_INTEGER && e->symtree->n.sym->attr.assign == 1)\n     {\n       msg =\n         gfc_build_string_const (37, \"Assigned label is not a format label\");\n       tmp = GFC_DECL_STRING_LEN (se.expr);\n-      tmp = build (LE_EXPR, boolean_type_node, tmp, integer_minus_one_node);\n+      tmp = build (LE_EXPR, boolean_type_node,\n+\t\t   tmp, convert (TREE_TYPE (tmp), integer_minus_one_node));\n       gfc_trans_runtime_check (tmp, msg, &se.pre);\n       gfc_add_modify_expr (&se.pre, io, GFC_DECL_ASSIGN_ADDR (se.expr));\n       gfc_add_modify_expr (&se.pre, len, GFC_DECL_STRING_LEN (se.expr));\n     }\n   else\n     {\n       gfc_conv_string_parameter (&se);\n-      gfc_add_modify_expr (&se.pre, io, se.expr);\n+      gfc_add_modify_expr (&se.pre, io, fold_convert (TREE_TYPE (io), se.expr));\n       gfc_add_modify_expr (&se.pre, len, se.string_length);\n     }\n \n@@ -432,10 +433,10 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n static void\n set_flag (stmtblock_t *block, tree var)\n {\n-  tree tmp;\n+  tree tmp, type = TREE_TYPE (var);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE(var), ioparm_var, var, NULL_TREE);\n-  gfc_add_modify_expr (block, tmp, integer_one_node);\n+  tmp = build (COMPONENT_REF, type, ioparm_var, var, NULL_TREE);\n+  gfc_add_modify_expr (block, tmp, convert (type, integer_one_node));\n }\n \n "}, {"sha": "794e2fc90176eda28d2e3654d3323e8ab654f353", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -615,7 +615,7 @@ gfc_trans_do (gfc_code * code)\n   gfc_add_modify_expr (&body, dovar, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = build (MINUS_EXPR, type, count, integer_one_node);\n+  tmp = build (MINUS_EXPR, type, count, gfc_index_one_node);\n   gfc_add_modify_expr (&body, count, tmp);\n \n   /* End of loop body.  */\n@@ -1240,13 +1240,13 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n           maskindex = forall_tmp->maskindex;\n           if (mask)\n             {\n-              tmp = build (PLUS_EXPR, gfc_array_index_type, maskindex,\n-                           integer_one_node);\n+              tmp = build (PLUS_EXPR, gfc_array_index_type,\n+                           maskindex, gfc_index_one_node);\n               gfc_add_modify_expr (&block, maskindex, tmp);\n             }\n         }\n       /* Decrement the loop counter.  */\n-      tmp = build (MINUS_EXPR, TREE_TYPE (var), count, integer_one_node);\n+      tmp = build (MINUS_EXPR, TREE_TYPE (var), count, gfc_index_one_node);\n       gfc_add_modify_expr (&block, count, tmp);\n \n       body = gfc_finish_block (&block);\n@@ -1348,12 +1348,12 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n   if (INTEGER_CST_P (size))\n     {\n       tmp = fold (build (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t\t integer_one_node));\n+\t\t\t gfc_index_one_node));\n     }\n   else\n     tmp = NULL_TREE;\n \n-  type = build_range_type (gfc_array_index_type, integer_zero_node, tmp);\n+  type = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n   type = build_array_type (elem_type, type);\n   if (gfc_can_put_var_on_stack (bytesize))\n     {\n@@ -1438,7 +1438,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n \n       gfc_mark_ss_chain_used (lss, 1);\n       /* Initialize count2.  */\n-      gfc_add_modify_expr (&block, count2, integer_zero_node);\n+      gfc_add_modify_expr (&block, count2, gfc_index_zero_node);\n \n       /* Start the scalarized loop body.  */\n       gfc_start_scalarized_body (&loop1, &body);\n@@ -1480,15 +1480,15 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_add_expr_to_block (&body, tmp);\n \n       /* Increment count2.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count2), count2,\n-                         integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count2, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count2, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n         {\n-          tmp = fold (build (PLUS_EXPR, TREE_TYPE (count3), count3,\n-                             integer_one_node));\n+          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                             count3, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count3, tmp);\n         }\n \n@@ -1537,7 +1537,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n   else\n     {\n       /* Initilize count2.  */\n-      gfc_add_modify_expr (&block, count2, integer_zero_node);\n+      gfc_add_modify_expr (&block, count2, gfc_index_zero_node);\n \n       /* Initiliaze the loop.  */\n       gfc_init_loopinfo (&loop);\n@@ -1592,15 +1592,15 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n   else\n     {\n       /* Increment count2.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type, count2,\n-\t\t\t integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t count2, gfc_index_one_node));\n       gfc_add_modify_expr (&body1, count2, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n         {\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type, count3,\n-                             integer_one_node));\n+          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                             count3, gfc_index_one_node));\n           gfc_add_modify_expr (&body1, count3, tmp);\n         }\n \n@@ -1639,7 +1639,7 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n   *lss = gfc_walk_expr (expr1);\n   *rss = NULL;\n \n-  size = integer_one_node;\n+  size = gfc_index_one_node;\n   if (*lss != gfc_ss_terminator)\n     {\n       gfc_init_loopinfo (&loop);\n@@ -1672,10 +1672,11 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n       /* Figure out how many elements we need.  */\n       for (i = 0; i < loop.dimen; i++)\n         {\n-\t  tmp = fold (build (MINUS_EXPR, TREE_TYPE (loop.from[i]),\n-\t\t\t     integer_one_node, loop.from[i]));\n-          tmp = fold (build (PLUS_EXPR, TREE_TYPE (tmp), tmp, loop.to[i]));\n-          size = fold (build (MULT_EXPR, TREE_TYPE (size), size, tmp));\n+\t  tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_index_one_node, loop.from[i]));\n+          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, loop.to[i]));\n+          size = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n         }\n       gfc_add_block_to_block (pblock, &loop.pre);\n       size = gfc_evaluate_now (size, pblock);\n@@ -1700,7 +1701,7 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \n   /* TODO: optimizing the computing process.  */\n   number = gfc_create_var (gfc_array_index_type, \"num\");\n-  gfc_add_modify_expr (block, number, integer_zero_node);\n+  gfc_add_modify_expr (block, number, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n   if (nested_forall_info)\n@@ -1778,13 +1779,13 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   if (wheremask)\n     {\n       count = gfc_create_var (gfc_array_index_type, \"count\");\n-      gfc_add_modify_expr (block, count, integer_zero_node);\n+      gfc_add_modify_expr (block, count, gfc_index_zero_node);\n     }\n   else\n     count = NULL;\n \n   /* Initialize count1.  */\n-  gfc_add_modify_expr (block, count1, integer_zero_node);\n+  gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n \n   /* Calculate the size of temporary needed in the assignment. Return loop, lss\n      and rss which are used in function generate_loop_for_rhs_to_temp().  */\n@@ -1805,7 +1806,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n       mask = forall_tmp->mask;\n       maskindex = forall_tmp->maskindex;\n       if (mask)\n-        gfc_add_modify_expr (block, maskindex, integer_zero_node);\n+        gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n       forall_tmp = forall_tmp->next_nest;\n     }\n \n@@ -1819,7 +1820,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Reset count1.  */\n-  gfc_add_modify_expr (block, count1, integer_zero_node);\n+  gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n \n   /* Reset maskindexed.  */\n   forall_tmp = nested_forall_info;\n@@ -1828,13 +1829,13 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n       mask = forall_tmp->mask;\n       maskindex = forall_tmp->maskindex;\n       if (mask)\n-        gfc_add_modify_expr (block, maskindex, integer_zero_node);\n+        gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n       forall_tmp = forall_tmp->next_nest;\n     }\n \n   /* Reset count.  */\n   if (wheremask)\n-    gfc_add_modify_expr (block, count, integer_zero_node);\n+    gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n   /* Generate codes to copy the temporary to lhs.  */\n   tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, inner_size, count,\n@@ -1879,7 +1880,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   forall_info *forall_tmp;\n \n   count = gfc_create_var (gfc_array_index_type, \"count\");\n-  gfc_add_modify_expr (block, count, integer_zero_node);\n+  gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n   inner_size = integer_one_node;\n   lss = gfc_walk_expr (expr1);\n@@ -1904,8 +1905,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &rse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count), count,\n-                         integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                         count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -1917,7 +1918,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n           mask = forall_tmp->mask;\n           maskindex = forall_tmp->maskindex;\n           if (mask)\n-            gfc_add_modify_expr (block, maskindex, integer_zero_node);\n+            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n           forall_tmp = forall_tmp->next_nest;\n         }\n \n@@ -1927,7 +1928,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_expr_to_block (block, tmp);\n \n       /* Reset count.  */\n-      gfc_add_modify_expr (block, count, integer_zero_node);\n+      gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n       /* Reset maskindexes.  */\n       forall_tmp = nested_forall_info;\n@@ -1936,7 +1937,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n           mask = forall_tmp->mask;\n           maskindex = forall_tmp->maskindex;\n           if (mask)\n-            gfc_add_modify_expr (block, maskindex, integer_zero_node);\n+            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n           forall_tmp = forall_tmp->next_nest;\n         }\n       gfc_start_block (&body);\n@@ -1949,8 +1950,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_modify_expr (&body, lse.expr, rse.expr);\n       gfc_add_block_to_block (&body, &lse.post);\n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count), count,\n-                         integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                         count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n       tmp = gfc_finish_block (&body);\n \n@@ -1993,8 +1994,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count), count,\n-                         integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                         count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2006,7 +2007,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n           mask = forall_tmp->mask;\n           maskindex = forall_tmp->maskindex;\n           if (mask)\n-            gfc_add_modify_expr (block, maskindex, integer_zero_node);\n+            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n           forall_tmp = forall_tmp->next_nest;\n         }\n \n@@ -2016,7 +2017,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_expr_to_block (block, tmp);\n \n       /* Reset count.  */\n-      gfc_add_modify_expr (block, count, integer_zero_node);\n+      gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n       /* Reset maskindexes.  */\n       forall_tmp = nested_forall_info;\n@@ -2025,7 +2026,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n           mask = forall_tmp->mask;\n           maskindex = forall_tmp->maskindex;\n           if (mask)\n-            gfc_add_modify_expr (block, maskindex, integer_zero_node);\n+            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n           forall_tmp = forall_tmp->next_nest;\n         }\n       parm = gfc_build_array_ref (tmp1, count);\n@@ -2038,8 +2039,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count), count,\n-                         integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                         count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2207,7 +2208,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   /* Work out the number of elements in the mask array.  */\n   tmpvar = NULL_TREE;\n   lenvar = NULL_TREE;\n-  size = integer_one_node;\n+  size = gfc_index_one_node;\n   sizevar = NULL_TREE;\n \n   for (n = 0; n < nvar; n++)\n@@ -2257,7 +2258,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       info->mask = mask;\n       info->maskindex = maskindex;\n \n-      gfc_add_modify_expr (&block, maskindex, integer_zero_node);\n+      gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n \n       /* Start of mask assignment loop body.  */\n       gfc_start_block (&body);\n@@ -2278,8 +2279,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       gfc_add_modify_expr (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n-      tmp = build (PLUS_EXPR, gfc_array_index_type, maskindex,\n-\t\t   integer_one_node);\n+      tmp = build (PLUS_EXPR, gfc_array_index_type,\n+\t\t   maskindex, gfc_index_one_node);\n       gfc_add_modify_expr (&body, maskindex, tmp);\n \n       /* Generate the loops.  */\n@@ -2317,7 +2318,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n               /* Reset the mask index.  */\n               if (mask)\n-                gfc_add_modify_expr (&block, maskindex, integer_zero_node);\n+                gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n \n               /* Generate body and loops.  */\n               tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1, 1);\n@@ -2362,7 +2363,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n               /* Reset the mask index.  */\n               if (mask)\n-                gfc_add_modify_expr (&block, maskindex, integer_zero_node);\n+                gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n \n               /* Generate body and loops.  */\n               tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign,\n@@ -2478,7 +2479,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   /* Variable to index the temporary.  */\n   count = gfc_create_var (gfc_array_index_type, \"count\");\n   /* Initilize count.  */\n-  gfc_add_modify_expr (block, count, integer_zero_node);\n+  gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n \n@@ -2530,7 +2531,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n     {\n       /* Increment count.  */\n       tmp1 = fold (build (PLUS_EXPR, gfc_array_index_type, count,\n-                          integer_one_node));\n+                          gfc_index_one_node));\n       gfc_add_modify_expr (&body1, count, tmp1);\n \n       /* Generate the copying loops.  */\n@@ -2696,8 +2697,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n   if (lss == gfc_ss_terminator)\n     {\n       /* Increment count1.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count1), count1,\n-                         integer_one_node));\n+      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                         count1, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count1, tmp);\n \n       /* Use the scalar assignment as is.  */\n@@ -2714,8 +2715,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n         {\n           /* Increment count1 before finish the main body of a scalarized\n              expression.  */\n-          tmp = fold (build (PLUS_EXPR, TREE_TYPE (count1), count1,\n-                             integer_one_node));\n+          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                             count1, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count1, tmp);\n           gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n@@ -2758,16 +2759,17 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n           tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n           tmp = build_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n           gfc_add_expr_to_block (&body, tmp);\n+\n           /* Increment count2.  */\n-          tmp = fold (build (PLUS_EXPR, TREE_TYPE (count2), count2,\n-                             integer_one_node));\n+          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                             count2, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count2, tmp);\n         }\n       else\n         {\n           /* Increment count1.  */\n-          tmp = fold (build (PLUS_EXPR, TREE_TYPE (count1), count1,\n-                             integer_one_node));\n+          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n+                             count1, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count1, tmp);\n         }\n \n@@ -2876,8 +2878,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n                       /* Variables to control maskexpr.  */\n                       count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n                       count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n-                      gfc_add_modify_expr (block, count1, integer_zero_node);\n-                      gfc_add_modify_expr (block, count2, integer_zero_node);\n+                      gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n+                      gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n \n                       tmp = gfc_trans_where_assign (expr1, expr2, mask, count1,\n                                                     count2);\n@@ -2891,8 +2893,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n                   /* Variables to control maskexpr.  */\n                   count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n                   count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n-                  gfc_add_modify_expr (block, count1, integer_zero_node);\n-                  gfc_add_modify_expr (block, count2, integer_zero_node);\n+                  gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n+                  gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n \n                   tmp = gfc_trans_where_assign (expr1, expr2, mask, count1,\n                                                 count2);"}, {"sha": "46146a941a064466706f88dfc8de1da1f9f78ddf", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -290,7 +290,7 @@ gfc_get_character_type (int kind, gfc_charlen * cl)\n \n   len = (cl == 0) ? NULL_TREE : cl->backend_decl;\n \n-  bounds = build_range_type (gfc_array_index_type, integer_one_node, len);\n+  bounds = build_range_type (gfc_array_index_type, gfc_index_one_node, len);\n   type = build_array_type (base, bounds);\n   TYPE_STRING_FLAG (type) = 1;\n \n@@ -493,7 +493,7 @@ gfc_build_array_type (tree type, gfc_array_spec * as)\n     {\n       /* Create expressions for the known bounds of the array.  */\n       if (as->type == AS_ASSUMED_SHAPE && as->lower[n] == NULL)\n-        lbound[n] = integer_one_node;\n+        lbound[n] = gfc_index_one_node;\n       else\n         lbound[n] = gfc_conv_array_bound (as->lower[n]);\n       ubound[n] = gfc_conv_array_bound (as->upper[n]);\n@@ -727,7 +727,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, int packed)\n \n   GFC_TYPE_ARRAY_DTYPE (type) = gfc_get_dtype (etype, as->rank);\n   GFC_TYPE_ARRAY_RANK (type) = as->rank;\n-  range = build_range_type (gfc_array_index_type, integer_zero_node,\n+  range = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t    NULL_TREE);\n   /* TODO: use main type if it is unbounded.  */\n   GFC_TYPE_ARRAY_DATAPTR_TYPE (type) =\n@@ -741,7 +741,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, int packed)\n   else\n     range = NULL_TREE;\n \n-  range = build_range_type (gfc_array_index_type, integer_zero_node, range);\n+  range = build_range_type (gfc_array_index_type, gfc_index_zero_node, range);\n   TYPE_DOMAIN (type) = range;\n \n   build_pointer_type (etype);\n@@ -806,7 +806,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \n   /* Build an array descriptor record type.  */\n   if (packed != 0)\n-    stride = integer_one_node;\n+    stride = gfc_index_one_node;\n   else\n     stride = NULL_TREE;\n \n@@ -840,7 +840,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \t{\n \t  tmp = fold (build (MINUS_EXPR, gfc_array_index_type, upper, lower));\n \t  tmp = fold (build (PLUS_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     integer_one_node));\n+\t\t\t     gfc_index_one_node));\n \t  stride =\n \t    fold (build (MULT_EXPR, gfc_array_index_type, tmp, stride));\n \t  /* Check the folding worked.  */\n@@ -858,7 +858,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n   arraytype =\n     build_array_type (etype,\n \t\t      build_range_type (gfc_array_index_type,\n-\t\t\t\t\tinteger_zero_node, NULL_TREE));\n+\t\t\t\t\tgfc_index_zero_node, NULL_TREE));\n   arraytype = build_pointer_type (arraytype);\n   GFC_TYPE_ARRAY_DATAPTR_TYPE (fat_type) = arraytype;\n \n@@ -885,7 +885,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n   arraytype =\n     build_array_type (gfc_get_desc_dim_type (),\n \t\t      build_range_type (gfc_array_index_type,\n-\t\t\t\t\tinteger_zero_node,\n+\t\t\t\t\tgfc_index_zero_node,\n \t\t\t\t\tgfc_rank_cst[dimen - 1]));\n \n   decl = build_decl (FIELD_DECL, get_identifier (\"dim\"), arraytype);"}, {"sha": "00215f6a2a4e63be9ef0c8025e17e666a6cefda8", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab92584665303887df921f930d38e606b41b39a/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=7ab92584665303887df921f930d38e606b41b39a", "patch": "@@ -146,6 +146,16 @@ gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n {\n   tree tmp;\n \n+#ifdef ENABLE_CHECKING\n+  /* Make sure that the types of the rhs and the lhs are the same\n+     for scalar assignments.  We should probably have something\n+     similar for aggregates, but right now removing that check just\n+     breaks everything.  */\n+  if (TREE_TYPE (rhs) != TREE_TYPE (lhs)\n+      && !AGGREGATE_TYPE_P (TREE_TYPE (lhs)))\n+    abort ();\n+#endif\n+\n   tmp = fold (build_v (MODIFY_EXPR, lhs, rhs));\n   gfc_add_expr_to_block (pblock, tmp);\n }"}]}