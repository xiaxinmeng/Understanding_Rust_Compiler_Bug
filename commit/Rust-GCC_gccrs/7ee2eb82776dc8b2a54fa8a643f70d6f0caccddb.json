{"sha": "7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VlMmViODI3NzZkYzhiMmE1NGZhOGE2NDNmNzBkNmYwY2FjY2RkYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-11-15T17:22:21Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-11-15T17:22:21Z"}, "message": "fmaq.c (fmaq): Merge from GLIBC.\n\n2012-11-15  Tobias Burnus  <burnus@net-b.de>\n            Joseph Myers  <joseph@codesourcery.com>\n\n        * math/fmaq.c (fmaq): Merge from GLIBC. Fix fma\n        underflows with small x * y; Fix overflow results\n        outside round-to-nearest mode; make use of Dekker\n        and Knuth algorithms use round-to-nearest.\n\n\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\n\nFrom-SVN: r193538", "tree": {"sha": "8afb54539fd762efa866c28e48f50243e4020a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8afb54539fd762efa866c28e48f50243e4020a17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c604a61a3ea932bc4cf17f543d014c740c4a28a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c604a61a3ea932bc4cf17f543d014c740c4a28a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c604a61a3ea932bc4cf17f543d014c740c4a28a"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "6f731ca84ad20b10119755d00fd8734dabaa787d", "filename": "libquadmath/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb/libquadmath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb/libquadmath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FChangeLog?ref=7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb", "patch": "@@ -1,3 +1,11 @@\n+2012-11-15  Tobias Burnus  <burnus@net-b.de>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* math/fmaq.c (fmaq): Merge from GLIBC. Fix fma\n+\tunderflows with small x * y; Fix overflow results\n+\toutside round-to-nearest mode; make use of Dekker\n+\tand Knuth algorithms use round-to-nearest.\n+\n 2012-11-01  Tobias Burnus  <burnus@net-b.de>\n \n \t* math/fmaq.c (fmaq): Fix build."}, {"sha": "fa3b3eafc0513c519b17fd7ed20909b213201073", "filename": "libquadmath/math/fmaq.c", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb/libquadmath%2Fmath%2Ffmaq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb/libquadmath%2Fmath%2Ffmaq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffmaq.c?ref=7ee2eb82776dc8b2a54fa8a643f70d6f0caccddb", "patch": "@@ -14,9 +14,8 @@\n    Lesser General Public License for more details.\n \n    You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-   02111-1307 USA.  */\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"quadmath-imp.h\"\n #include <math.h>\n@@ -62,17 +61,18 @@ fmaq (__float128 x, __float128 y, __float128 z)\n \t underflows to 0.  */\n       if (z == 0 && x != 0 && y != 0)\n \treturn x * y;\n-      /* If x or y or z is Inf/NaN, or if fma will certainly overflow,\n-\t or if x * y is less than half of FLT128_DENORM_MIN,\n-\t compute as x * y + z.  */\n+      /* If x or y or z is Inf/NaN, or if x * y is zero, compute as\n+\t x * y + z.  */\n       if (u.ieee.exponent == 0x7fff\n \t  || v.ieee.exponent == 0x7fff\n \t  || w.ieee.exponent == 0x7fff\n-\t  || u.ieee.exponent + v.ieee.exponent\n-\t     > 0x7fff + IEEE854_FLOAT128_BIAS\n-\t  || u.ieee.exponent + v.ieee.exponent\n-\t     < IEEE854_FLOAT128_BIAS - FLT128_MANT_DIG - 2)\n+\t  || x == 0\n+\t  || y == 0)\n \treturn x * y + z;\n+      /* If fma will certainly overflow, compute as x * y.  */\n+      if (u.ieee.exponent + v.ieee.exponent\n+\t  > 0x7fff + IEEE854_FLOAT128_BIAS)\n+\treturn x * y;\n       /* If x * y is less than 1/4 of FLT128_DENORM_MIN, neither the\n \t result nor whether there is underflow depends on its exact\n \t value, only on its sign.  */\n@@ -121,8 +121,17 @@ fmaq (__float128 x, __float128 y, __float128 z)\n \t{\n \t  /* Similarly.\n \t     If z exponent is very large and x and y exponents are\n-\t     very small, it doesn't matter if we don't adjust it.  */\n-\t  if (u.ieee.exponent > v.ieee.exponent)\n+\t     very small, adjust them up to avoid spurious underflows,\n+\t     rather than down.  */\n+\t  if (u.ieee.exponent + v.ieee.exponent\n+\t      <= IEEE854_FLOAT128_BIAS + FLT128_MANT_DIG)\n+\t    {\n+\t      if (u.ieee.exponent > v.ieee.exponent)\n+\t\tu.ieee.exponent += 2 * FLT128_MANT_DIG + 2;\n+\t      else\n+\t\tv.ieee.exponent += 2 * FLT128_MANT_DIG + 2;\n+\t    }\n+\t  else if (u.ieee.exponent > v.ieee.exponent)\n \t    {\n \t      if (u.ieee.exponent > FLT128_MANT_DIG)\n \t\tu.ieee.exponent -= FLT128_MANT_DIG;\n@@ -175,6 +184,12 @@ fmaq (__float128 x, __float128 y, __float128 z)\n   if (__builtin_expect ((x == 0 || y == 0) && z == 0, 0))\n     return x * y + z;\n \n+#ifdef USE_FENV_H\n+  fenv_t env;\n+  feholdexcept (&env);\n+  fesetround (FE_TONEAREST);\n+#endif\n+\n   /* Multiplication m1 + m2 = x * y using Dekker's algorithm.  */\n #define C ((1LL << (FLT128_MANT_DIG + 1) / 2) + 1)\n   __float128 x1 = x * C;\n@@ -193,10 +208,25 @@ fmaq (__float128 x, __float128 y, __float128 z)\n   t1 = m1 - t1;\n   t2 = z - t2;\n   __float128 a2 = t1 + t2;\n+#ifdef USE_FENV_H\n+  feclearexcept (FE_INEXACT);\n+#endif\n+\n+  /* If the result is an exact zero, ensure it has the correct\n+     sign.  */\n+  if (a1 == 0 && m2 == 0)\n+    {\n+#ifdef USE_FENV_H\n+      feupdateenv (&env);\n+#endif\n+      /* Ensure that round-to-nearest value of z + m1 is not\n+\t reused.  */\n+      asm volatile (\"\" : \"=m\" (z) : \"m\" (z));\n+      return z + m1;\n+    }\n+\n \n #ifdef USE_FENV_H\n-  fenv_t env;\n-  feholdexcept (&env);\n   fesetround (FE_TOWARDZERO);\n #endif\n   /* Perform m2 + a2 addition with round to odd.  */"}]}