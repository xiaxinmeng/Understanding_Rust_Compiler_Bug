{"sha": "06b39289a203be6859a3ec99df3fdd80a72a88f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiMzkyODlhMjAzYmU2ODU5YTNlYzk5ZGYzZmRkODBhNzJhODhmOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-04-24T22:42:25Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-04-24T22:42:25Z"}, "message": "extend.texi (PowerPC Built-in Functions): Document new powerpc extended divide, bcd, pack/unpack 128-bit, builtin functions.\n\n[gcc]\n2014-04-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* doc/extend.texi (PowerPC Built-in Functions): Document new\n\tpowerpc extended divide, bcd, pack/unpack 128-bit, builtin\n\tfunctions.\n\t(PowerPC AltiVec/VSX Built-in Functions): Likewise.\n\n\t* config/rs6000/predicates.md (const_0_to_3_operand): New\n\tpredicate to match 0..3 integer constants.\n\n\t* config/rs6000/rs6000-builtin.def (BU_DFP_MISC_1): Add new macros\n\tto support adding miscellaneous builtin functions.\n\t(BU_DFP_MISC_2): Likewise.\n\t(BU_P7_MISC_1): Likewise.\n\t(BU_P7_MISC_2): Likewise.\n\t(BU_P8V_MISC_3): Likewise.\n\t(BU_MISC_1): Likewise.\n\t(BU_MISC_2): Likewise.\n\t(DIVWE): Add extended divide builtin functions.\n\t(DIVWEO): Likewise.\n\t(DIVWEU): Likewise.\n\t(DIVWEUO): Likewise.\n\t(DIVDE): Likewise.\n\t(DIVDEO): Likewise.\n\t(DIVDEU): Likewise.\n\t(DIVDEUO): Likewise.\n\t(DXEX): Add decimal floating-point builtin functions.\n\t(DXEXQ): Likewise.\n\t(DDEDPD): Likewise.\n\t(DDEDPDQ): Likewise.\n\t(DENBCD): Likewise.\n\t(DENBCDQ): Likewise.\n\t(DIEX): Likewise.\n\t(DIEXQ): Likewise.\n\t(DSCLI): Likewise.\n\t(DSCLIQ): Likewise.\n\t(DSCRI): Likewise.\n\t(DSCRIQ): Likewise.\n\t(CDTBCD): Add new BCD builtin functions.\n\t(CBCDTD): Likewise.\n\t(ADDG6S): Likewise.\n\t(BCDADD): Likewise.\n\t(BCDADD_LT): Likewise.\n\t(BCDADD_EQ): Likewise.\n\t(BCDADD_GT): Likewise.\n\t(BCDADD_OV): Likewise.\n\t(BCDSUB): Likewise.\n\t(BCDSUB_LT): Likewise.\n\t(BCDSUB_EQ): Likewise.\n\t(BCDSUB_GT): Likewise.\n\t(BCDSUB_OV): Likewise.\n\t(PACK_TD): Add new pack/unpack 128-bit type builtin functions.\n\t(UNPACK_TD): Likewise.\n\t(PACK_TF): Likewise.\n\t(UNPACK_TF): Likewise.\n\t(UNPACK_TF_0): Likewise.\n\t(UNPACK_TF_1): Likewise.\n\t(PACK_V1TI): Likewise.\n\t(UNPACK_V1TI): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_builtin_mask_calculate): Add\n\tsupport for decimal floating point builtin functions.\n\t(rs6000_expand_ternop_builtin): Add checks for the new builtin\n\tfunctions that take constant arguments.\n\t(rs6000_invalid_builtin): Add decimal floating point builtin\n\tsupport.\n\t(rs6000_init_builtins): Setup long double, _Decimal64, and\n\t_Decimal128 types for new builtin functions.\n\t(builtin_function_type): Set the unsigned flags appropriately for\n\tthe new builtin functions.\n\t(rs6000_opt_masks): Add support for decimal floating point builtin\n\tfunctions.\n\n\t* config/rs6000/rs6000.h (RS6000_BTM_DFP): Add support for decimal\n\tfloating point builtin functions.\n\t(RS6000_BTM_COMMON): Likewise.\n\t(RS6000_BTI_long_double): Likewise.\n\t(RS6000_BTI_dfloat64): Likewise.\n\t(RS6000_BTI_dfloat128): Likewise.\n\t(long_double_type_internal_node): Likewise.\n\t(dfloat64_type_internal_node): Likewise.\n\t(dfloat128_type_internal_node): Likewise.\n\n\t* config/rs6000/altivec.h (UNSPEC_BCDADD): Add support for ISA\n\t2.07 bcd arithmetic instructions.\n\t(UNSPEC_BCDSUB): Likewise.\n\t(UNSPEC_BCD_OVERFLOW): Likewise.\n\t(UNSPEC_BCD_ADD_SUB): Likewise.\n\t(bcd_add_sub): Likewise.\n\t(BCD_TEST): Likewise.\n\t(bcd<bcd_add_sub>): Likewise.\n\t(bcd<bcd_add_sub>_test): Likewise.\n\t(bcd<bcd_add_sub>_test2): Likewise.\n\t(bcd<bcd_add_sub>_<code>): Likewise.\n\t(peephole2 for combined bcd ops): Likewise.\n\n\t* config/rs6000/dfp.md (UNSPEC_DDEDPD): Add support for new\n\tdecimal floating point builtin functions.\n\t(UNSPEC_DENBCD): Likewise.\n\t(UNSPEC_DXEX): Likewise.\n\t(UNSPEC_DIEX): Likewise.\n\t(UNSPEC_DSCLI): Likewise.\n\t(UNSPEC_DSCRI): Likewise.\n\t(D64_D128): Likewise.\n\t(dfp_suffix): Likewise.\n\t(dfp_ddedpd_<mode>): Likewise.\n\t(dfp_denbcd_<mode>): Likewise.\n\t(dfp_dxex_<mode>): Likewise.\n\t(dfp_diex_<mode>): Likewise.\n\t(dfp_dscli_<mode>): Likewise.\n\t(dfp_dscri_<mode>): Likewise.\n\n\t* config/rs6000/rs6000.md (UNSPEC_ADDG6S): Add support for new BCD\n\tbuiltin functions.\n\t(UNSPEC_CDTBCD): Likewise.\n\t(UNSPEC_CBCDTD): Likewise.\n\t(UNSPEC_DIVE): Add support for new extended divide builtin\n\tfunctions.\n\t(UNSPEC_DIVEO): Likewise.\n\t(UNSPEC_DIVEU): Likewise.\n\t(UNSPEC_DIVEUO): Likewise.\n\t(UNSPEC_UNPACK_128BIT): Add support for new builtin functions to\n\tpack/unpack 128-bit types.\n\t(UNSPEC_PACK_128BIT): Likewise.\n\t(idiv_ldiv): New mode attribute to set the 32/64-bit divide type.\n\t(udiv<mode>3): Use idiv_ldiv mode attribute.\n\t(div<mode>3): Likewise.\n\t(addg6s): Add new BCD builtin functions.\n\t(cdtbcd): Likewise.\n\t(cbcdtd): Likewise.\n\t(UNSPEC_DIV_EXTEND): Add support for new extended divide\n\tinstructions.\n\t(div_extend): Likewise.\n\t(div<div_extend>_<mode>\"): Likewise.\n\t(FP128_64): Add support for new builtin functions to pack/unpack\n\t128-bit types.\n\t(unpack<mode>): Likewise.\n\t(unpacktf_0): Likewise.\n\t(unpacktf_1): Likewise.\n\t(unpack<mode>_dm): Likewise.\n\t(unpack<mode>_nodm): Likewise.\n\t(pack<mode>): Likewise.\n\t(unpackv1ti): Likewise.\n\t(packv1ti): Likewise.\n\n[gcc/testsuite]\n2014-04-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/pack01.c: New test to test the new pack and\n\tunpack builtin functionss for 128-bit types.\n\t* gcc.target/powerpc/pack02.c: Likewise.\n\t* gcc.target/powerpc/pack03.c: Likewise.\n\t* gcc.target/powerpc/extend-divide-1.c: New test to test extended\n\tdivide builtin functionss.\n\t* gcc.target/powerpc/extend-divide-2.c: Likewise.\n\t* gcc.target/powerpc/bcd-1.c: New test for the new BCD builtin\n\tfunctions.\n\t* gcc.target/powerpc/bcd-2.c: Likewise.\n\t* gcc.target/powerpc/bcd-3.c: Likewise.\n\t* gcc.target/powerpc/dfp-builtin-1.c: New test for the new DFP\n\tbuiltin functionss.\n\t* gcc.target/powerpc/dfp-builtin-2.c: Likewise.\n\nFrom-SVN: r209768", "tree": {"sha": "c8f8ec9a6730285ce8bb60248b53e28228a38ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8f8ec9a6730285ce8bb60248b53e28228a38ac7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06b39289a203be6859a3ec99df3fdd80a72a88f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b39289a203be6859a3ec99df3fdd80a72a88f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b39289a203be6859a3ec99df3fdd80a72a88f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b39289a203be6859a3ec99df3fdd80a72a88f9/comments", "author": null, "committer": null, "parents": [{"sha": "6e4f81db33c6cefcf0cea11e087c1896917a101a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4f81db33c6cefcf0cea11e087c1896917a101a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e4f81db33c6cefcf0cea11e087c1896917a101a"}], "stats": {"total": 1542, "additions": 1526, "deletions": 16}, "files": [{"sha": "d3d594dfed7c809124e097fe5ae5235d8dc01fe1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -1,3 +1,148 @@\n+2014-04-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* doc/extend.texi (PowerPC Built-in Functions): Document new\n+\tpowerpc extended divide, bcd, pack/unpack 128-bit, builtin\n+\tfunctions.\n+\t(PowerPC AltiVec/VSX Built-in Functions): Likewise.\n+\n+\t* config/rs6000/predicates.md (const_0_to_3_operand): New\n+\tpredicate to match 0..3 integer constants.\n+\n+\t* config/rs6000/rs6000-builtin.def (BU_DFP_MISC_1): Add new macros\n+\tto support adding miscellaneous builtin functions.\n+\t(BU_DFP_MISC_2): Likewise.\n+\t(BU_P7_MISC_1): Likewise.\n+\t(BU_P7_MISC_2): Likewise.\n+\t(BU_P8V_MISC_3): Likewise.\n+\t(BU_MISC_1): Likewise.\n+\t(BU_MISC_2): Likewise.\n+\t(DIVWE): Add extended divide builtin functions.\n+\t(DIVWEO): Likewise.\n+\t(DIVWEU): Likewise.\n+\t(DIVWEUO): Likewise.\n+\t(DIVDE): Likewise.\n+\t(DIVDEO): Likewise.\n+\t(DIVDEU): Likewise.\n+\t(DIVDEUO): Likewise.\n+\t(DXEX): Add decimal floating-point builtin functions.\n+\t(DXEXQ): Likewise.\n+\t(DDEDPD): Likewise.\n+\t(DDEDPDQ): Likewise.\n+\t(DENBCD): Likewise.\n+\t(DENBCDQ): Likewise.\n+\t(DIEX): Likewise.\n+\t(DIEXQ): Likewise.\n+\t(DSCLI): Likewise.\n+\t(DSCLIQ): Likewise.\n+\t(DSCRI): Likewise.\n+\t(DSCRIQ): Likewise.\n+\t(CDTBCD): Add new BCD builtin functions.\n+\t(CBCDTD): Likewise.\n+\t(ADDG6S): Likewise.\n+\t(BCDADD): Likewise.\n+\t(BCDADD_LT): Likewise.\n+\t(BCDADD_EQ): Likewise.\n+\t(BCDADD_GT): Likewise.\n+\t(BCDADD_OV): Likewise.\n+\t(BCDSUB): Likewise.\n+\t(BCDSUB_LT): Likewise.\n+\t(BCDSUB_EQ): Likewise.\n+\t(BCDSUB_GT): Likewise.\n+\t(BCDSUB_OV): Likewise.\n+\t(PACK_TD): Add new pack/unpack 128-bit type builtin functions.\n+\t(UNPACK_TD): Likewise.\n+\t(PACK_TF): Likewise.\n+\t(UNPACK_TF): Likewise.\n+\t(UNPACK_TF_0): Likewise.\n+\t(UNPACK_TF_1): Likewise.\n+\t(PACK_V1TI): Likewise.\n+\t(UNPACK_V1TI): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_builtin_mask_calculate): Add\n+\tsupport for decimal floating point builtin functions.\n+\t(rs6000_expand_ternop_builtin): Add checks for the new builtin\n+\tfunctions that take constant arguments.\n+\t(rs6000_invalid_builtin): Add decimal floating point builtin\n+\tsupport.\n+\t(rs6000_init_builtins): Setup long double, _Decimal64, and\n+\t_Decimal128 types for new builtin functions.\n+\t(builtin_function_type): Set the unsigned flags appropriately for\n+\tthe new builtin functions.\n+\t(rs6000_opt_masks): Add support for decimal floating point builtin\n+\tfunctions.\n+\n+\t* config/rs6000/rs6000.h (RS6000_BTM_DFP): Add support for decimal\n+\tfloating point builtin functions.\n+\t(RS6000_BTM_COMMON): Likewise.\n+\t(RS6000_BTI_long_double): Likewise.\n+\t(RS6000_BTI_dfloat64): Likewise.\n+\t(RS6000_BTI_dfloat128): Likewise.\n+\t(long_double_type_internal_node): Likewise.\n+\t(dfloat64_type_internal_node): Likewise.\n+\t(dfloat128_type_internal_node): Likewise.\n+\n+\t* config/rs6000/altivec.h (UNSPEC_BCDADD): Add support for ISA\n+\t2.07 bcd arithmetic instructions.\n+\t(UNSPEC_BCDSUB): Likewise.\n+\t(UNSPEC_BCD_OVERFLOW): Likewise.\n+\t(UNSPEC_BCD_ADD_SUB): Likewise.\n+\t(bcd_add_sub): Likewise.\n+\t(BCD_TEST): Likewise.\n+\t(bcd<bcd_add_sub>): Likewise.\n+\t(bcd<bcd_add_sub>_test): Likewise.\n+\t(bcd<bcd_add_sub>_test2): Likewise.\n+\t(bcd<bcd_add_sub>_<code>): Likewise.\n+\t(peephole2 for combined bcd ops): Likewise.\n+\n+\t* config/rs6000/dfp.md (UNSPEC_DDEDPD): Add support for new\n+\tdecimal floating point builtin functions.\n+\t(UNSPEC_DENBCD): Likewise.\n+\t(UNSPEC_DXEX): Likewise.\n+\t(UNSPEC_DIEX): Likewise.\n+\t(UNSPEC_DSCLI): Likewise.\n+\t(UNSPEC_DSCRI): Likewise.\n+\t(D64_D128): Likewise.\n+\t(dfp_suffix): Likewise.\n+\t(dfp_ddedpd_<mode>): Likewise.\n+\t(dfp_denbcd_<mode>): Likewise.\n+\t(dfp_dxex_<mode>): Likewise.\n+\t(dfp_diex_<mode>): Likewise.\n+\t(dfp_dscli_<mode>): Likewise.\n+\t(dfp_dscri_<mode>): Likewise.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_ADDG6S): Add support for new BCD\n+\tbuiltin functions.\n+\t(UNSPEC_CDTBCD): Likewise.\n+\t(UNSPEC_CBCDTD): Likewise.\n+\t(UNSPEC_DIVE): Add support for new extended divide builtin\n+\tfunctions.\n+\t(UNSPEC_DIVEO): Likewise.\n+\t(UNSPEC_DIVEU): Likewise.\n+\t(UNSPEC_DIVEUO): Likewise.\n+\t(UNSPEC_UNPACK_128BIT): Add support for new builtin functions to\n+\tpack/unpack 128-bit types.\n+\t(UNSPEC_PACK_128BIT): Likewise.\n+\t(idiv_ldiv): New mode attribute to set the 32/64-bit divide type.\n+\t(udiv<mode>3): Use idiv_ldiv mode attribute.\n+\t(div<mode>3): Likewise.\n+\t(addg6s): Add new BCD builtin functions.\n+\t(cdtbcd): Likewise.\n+\t(cbcdtd): Likewise.\n+\t(UNSPEC_DIV_EXTEND): Add support for new extended divide\n+\tinstructions.\n+\t(div_extend): Likewise.\n+\t(div<div_extend>_<mode>\"): Likewise.\n+\t(FP128_64): Add support for new builtin functions to pack/unpack\n+\t128-bit types.\n+\t(unpack<mode>): Likewise.\n+\t(unpacktf_0): Likewise.\n+\t(unpacktf_1): Likewise.\n+\t(unpack<mode>_dm): Likewise.\n+\t(unpack<mode>_nodm): Likewise.\n+\t(pack<mode>): Likewise.\n+\t(unpackv1ti): Likewise.\n+\t(packv1ti): Likewise.\n+\n 2014-04-24  Vishnu K S  <Vishnu.k_s@atmel.com>\n \n \t* gcc/config/avr/avr.c: Add comment on why -fdelete-null-pointer-checks"}, {"sha": "a8cfcb739eabfed16960c5e2f8cd507042b50764", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -143,6 +143,9 @@\n    UNSPEC_VSUBEUQM\n    UNSPEC_VSUBECUQ\n    UNSPEC_VBPERMQ\n+   UNSPEC_BCDADD\n+   UNSPEC_BCDSUB\n+   UNSPEC_BCD_OVERFLOW\n ])\n \n (define_c_enum \"unspecv\"\n@@ -3334,3 +3337,112 @@\n   \"vbpermq %0,%1,%2\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"vecsimple\")])\n+\n+;; Decimal Integer operations\n+(define_int_iterator UNSPEC_BCD_ADD_SUB [UNSPEC_BCDADD UNSPEC_BCDSUB])\n+\n+(define_int_attr bcd_add_sub [(UNSPEC_BCDADD \"add\")\n+\t\t\t      (UNSPEC_BCDSUB \"sub\")])\n+\n+(define_code_iterator BCD_TEST [eq lt gt unordered])\n+\n+(define_insn \"bcd<bcd_add_sub>\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"\")\n+\t\t      (match_operand:QI 3 \"const_0_to_1_operand\" \"\")]\n+\t\t     UNSPEC_BCD_ADD_SUB))\n+   (clobber (reg:CCFP 74))]\n+  \"TARGET_P8_VECTOR\"\n+  \"bcd<bcd_add_sub>. %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+;; Use a floating point type (V2DFmode) for the compare to set CR6 so that we\n+;; can use the unordered test for BCD nans and add/subtracts that overflow.  An\n+;; UNORDERED test on an integer type (like V1TImode) is not defined.  The type\n+;; probably should be one that can go in the VMX (Altivec) registers, so we\n+;; can't use DDmode or DFmode.\n+(define_insn \"*bcd<bcd_add_sub>_test\"\n+  [(set (reg:CCFP 74)\n+\t(compare:CCFP\n+\t (unspec:V2DF [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t       (match_operand:V1TI 2 \"register_operand\" \"v\")\n+\t\t       (match_operand:QI 3 \"const_0_to_1_operand\" \"i\")]\n+\t\t      UNSPEC_BCD_ADD_SUB)\n+\t (match_operand:V2DF 4 \"zero_constant\" \"j\")))\n+   (clobber (match_scratch:V1TI 0 \"=v\"))]\n+  \"TARGET_P8_VECTOR\"\n+  \"bcd<bcd_add_sub>. %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*bcd<bcd_add_sub>_test2\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")\n+\t\t      (match_operand:QI 3 \"const_0_to_1_operand\" \"i\")]\n+\t\t     UNSPEC_BCD_ADD_SUB))\n+   (set (reg:CCFP 74)\n+\t(compare:CCFP\n+\t (unspec:V2DF [(match_dup 1)\n+\t\t       (match_dup 2)\n+\t\t       (match_dup 3)]\n+\t\t      UNSPEC_BCD_ADD_SUB)\n+\t (match_operand:V2DF 4 \"zero_constant\" \"j\")))]\n+  \"TARGET_P8_VECTOR\"\n+  \"bcd<bcd_add_sub>. %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_expand \"bcd<bcd_add_sub>_<code>\"\n+  [(parallel [(set (reg:CCFP 74)\n+\t\t   (compare:CCFP\n+\t\t    (unspec:V2DF [(match_operand:V1TI 1 \"register_operand\" \"\")\n+\t\t\t\t  (match_operand:V1TI 2 \"register_operand\" \"\")\n+\t\t\t\t  (match_operand:QI 3 \"const_0_to_1_operand\" \"\")]\n+\t\t\t\t UNSPEC_BCD_ADD_SUB)\n+\t\t    (match_dup 4)))\n+\t      (clobber (match_scratch:V1TI 5 \"\"))])\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(BCD_TEST:SI (reg:CCFP 74)\n+\t\t     (const_int 0)))]\n+  \"TARGET_P8_VECTOR\"\n+{\n+  operands[4] = CONST0_RTX (V2DFmode);\n+})\n+\n+;; Peephole2 pattern to combine a bcdadd/bcdsub that calculates the value and\n+;; the bcdadd/bcdsub that tests the value.  The combiner won't work since\n+;; CR6 is a hard coded register.  Unfortunately, all of the Altivec predicate\n+;; support is hard coded to use the fixed register CR6 instead of creating\n+;; a register class for CR6.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:V1TI 0 \"register_operand\" \"\")\n+\t\t   (unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"\")\n+\t\t\t\t (match_operand:V1TI 2 \"register_operand\" \"\")\n+\t\t\t\t (match_operand:QI 3 \"const_0_to_1_operand\" \"\")]\n+\t\t\t\tUNSPEC_BCD_ADD_SUB))\n+\t      (clobber (reg:CCFP 74))])\n+   (parallel [(set (reg:CCFP 74)\n+\t\t   (compare:CCFP\n+\t\t    (unspec:V2DF [(match_dup 1)\n+\t\t\t\t  (match_dup 2)\n+\t\t\t\t  (match_dup 3)]\n+\t\t\t\t UNSPEC_BCD_ADD_SUB)\n+\t\t    (match_operand:V2DF 4 \"zero_constant\" \"\")))\n+\t      (clobber (match_operand:V1TI 5 \"register_operand\" \"\"))])]\n+  \"TARGET_P8_VECTOR\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (unspec:V1TI [(match_dup 1)\n+\t\t\t\t (match_dup 2)\n+\t\t\t\t (match_dup 3)]\n+\t\t\t\tUNSPEC_BCD_ADD_SUB))\n+\t      (set (reg:CCFP 74)\n+\t\t   (compare:CCFP\n+\t\t    (unspec:V2DF [(match_dup 1)\n+\t\t\t\t  (match_dup 2)\n+\t\t\t\t  (match_dup 3)]\n+\t\t\t\t UNSPEC_BCD_ADD_SUB)\n+\t\t    (match_dup 4)))])])"}, {"sha": "40e27e77d2332b629674eb3e2480c950eccede6f", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -322,3 +322,72 @@\n   \"TARGET_DFP\"\n   \"dctfixq %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n+\n+\f\n+;; Decimal builtin support\n+\n+(define_c_enum \"unspec\"\n+  [UNSPEC_DDEDPD\n+   UNSPEC_DENBCD\n+   UNSPEC_DXEX\n+   UNSPEC_DIEX\n+   UNSPEC_DSCLI\n+   UNSPEC_DSCRI])\n+\n+(define_mode_iterator D64_D128 [DD TD])\n+\n+(define_mode_attr dfp_suffix [(DD \"\")\n+\t\t\t      (TD \"q\")])\n+\n+(define_insn \"dfp_ddedpd_<mode>\"\n+  [(set (match_operand:D64_D128 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:D64_D128 [(match_operand:QI 1 \"const_0_to_3_operand\" \"i\")\n+\t\t\t  (match_operand:D64_D128 2 \"gpc_reg_operand\" \"d\")]\n+\t\t\t UNSPEC_DDEDPD))]\n+  \"TARGET_DFP\"\n+  \"ddedpd<dfp_suffix> %1,%0,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"dfp_denbcd_<mode>\"\n+  [(set (match_operand:D64_D128 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:D64_D128 [(match_operand:QI 1 \"const_0_to_1_operand\" \"i\")\n+\t\t\t  (match_operand:D64_D128 2 \"gpc_reg_operand\" \"d\")]\n+\t\t\t UNSPEC_DENBCD))]\n+  \"TARGET_DFP\"\n+  \"denbcd<dfp_suffix> %1,%0,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"dfp_dxex_<mode>\"\n+  [(set (match_operand:D64_D128 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:D64_D128 [(match_operand:D64_D128 1 \"gpc_reg_operand\" \"d\")]\n+\t\t\t UNSPEC_DXEX))]\n+  \"TARGET_DFP\"\n+  \"dxex<dfp_suffix> %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"dfp_diex_<mode>\"\n+  [(set (match_operand:D64_D128 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:D64_D128 [(match_operand:D64_D128 1 \"gpc_reg_operand\" \"d\")\n+\t\t\t  (match_operand:D64_D128 2 \"gpc_reg_operand\" \"d\")]\n+\t\t\t UNSPEC_DXEX))]\n+  \"TARGET_DFP\"\n+  \"diex<dfp_suffix> %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"dfp_dscli_<mode>\"\n+  [(set (match_operand:D64_D128 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:D64_D128 [(match_operand:D64_D128 1 \"gpc_reg_operand\" \"d\")\n+\t\t\t  (match_operand:QI 2 \"immediate_operand\" \"i\")]\n+\t\t\t UNSPEC_DSCLI))]\n+  \"TARGET_DFP\"\n+  \"dscli<dfp_suffix> %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"dfp_dscri_<mode>\"\n+  [(set (match_operand:D64_D128 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec:D64_D128 [(match_operand:D64_D128 1 \"gpc_reg_operand\" \"d\")\n+\t\t\t  (match_operand:QI 2 \"immediate_operand\" \"i\")]\n+\t\t\t UNSPEC_DSCRI))]\n+  \"TARGET_DFP\"\n+  \"dscri<dfp_suffix> %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])"}, {"sha": "99903f367691b2be2de4655997a911a764d46603", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -171,6 +171,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 0, 1)\")))\n \n+;; Match op = 0..3.\n+(define_predicate \"const_0_to_3_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 3)\")))\n+\n ;; Match op = 2 or op = 3.\n (define_predicate \"const_2_to_3_operand\"\n   (and (match_code \"const_int\")"}, {"sha": "16793f501e722cdf4609a525d83a8105e9d5a011", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 131, "deletions": 4, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -570,6 +570,75 @@\n \t\t    MASK,\t\t\t\t/* MASK */\t\\\n \t\t    (ATTR | RS6000_BTC_SPECIAL),\t/* ATTR */\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+\n+/* Decimal floating point builtins for instructions.  */\n+#define BU_DFP_MISC_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_1 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_DFP,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_DFP_MISC_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_DFP,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+\n+/* Miscellaneous builtins for instructions added in ISA 2.06.  These\n+   instructions don't require either the DFP or VSX options, just the basic ISA\n+   2.06 (popcntd) enablement since they operate on general purpose\n+   registers.  */\n+#define BU_P7_MISC_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_1 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_POPCNTD,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P7_MISC_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_POPCNTD,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+\n+/* Miscellaneous builtins for instructions added in ISA 2.07.  These\n+   instructions do require the ISA 2.07 vector support, but they aren't vector\n+   instructions.  */\n+#define BU_P8V_MISC_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_3 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+/* Miscellaneous builtins.  */\n+#define BU_MISC_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_ALWAYS,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_MISC_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_ALWAYS,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #endif\n \n /* Insure 0 is not a legitimate index.  */\n@@ -1412,10 +1481,10 @@ BU_P8V_AV_2 (ORC_V4SF,\t\t\"orc_v4sf\",\tCONST,\torcv4sf3)\n BU_P8V_AV_2 (ORC_V2DF,\t\t\"orc_v2df\",\tCONST,\torcv2df3)\n \n /* 3 argument altivec instructions added in ISA 2.07.  */\n-BU_P8V_AV_3 (VADDEUQM,\t\t\"vaddeuqm\",\t CONST,\taltivec_vaddeuqm)\n-BU_P8V_AV_3 (VADDECUQ,\t\t\"vaddecuq\",\t CONST,\taltivec_vaddecuq)\n-BU_P8V_AV_3 (VSUBEUQM,\t\t\"vsubeuqm\",\t CONST,\taltivec_vsubeuqm)\n-BU_P8V_AV_3 (VSUBECUQ,\t\t\"vsubecuq\",\t CONST,\taltivec_vsubecuq)\n+BU_P8V_AV_3 (VADDEUQM,\t\t\"vaddeuqm\",\tCONST,\taltivec_vaddeuqm)\n+BU_P8V_AV_3 (VADDECUQ,\t\t\"vaddecuq\",\tCONST,\taltivec_vaddecuq)\n+BU_P8V_AV_3 (VSUBEUQM,\t\t\"vsubeuqm\",\tCONST,\taltivec_vsubeuqm)\n+BU_P8V_AV_3 (VSUBECUQ,\t\t\"vsubecuq\",\tCONST,\taltivec_vsubecuq)\n \n /* Vector comparison instructions added in ISA 2.07.  */\n BU_P8V_AV_2 (VCMPEQUD,\t\t\"vcmpequd\",\tCONST,\tvector_eqv2di)\n@@ -1474,6 +1543,64 @@ BU_P8V_OVERLOAD_3 (VADDEUQM,\t\"vaddeuqm\")\n BU_P8V_OVERLOAD_3 (VSUBECUQ,\t\"vsubecuq\")\n BU_P8V_OVERLOAD_3 (VSUBEUQM,\t\"vsubeuqm\")\n \n+\f\n+/* 2 argument extended divide functions added in ISA 2.06.  */\n+BU_P7_MISC_2 (DIVWE,\t\t\"divwe\",\tCONST,\tdive_si)\n+BU_P7_MISC_2 (DIVWEO,\t\t\"divweo\",\tCONST,\tdiveo_si)\n+BU_P7_MISC_2 (DIVWEU,\t\t\"divweu\",\tCONST,\tdiveu_si)\n+BU_P7_MISC_2 (DIVWEUO,\t\t\"divweuo\",\tCONST,\tdiveuo_si)\n+BU_P7_MISC_2 (DIVDE,\t\t\"divde\",\tCONST,\tdive_di)\n+BU_P7_MISC_2 (DIVDEO,\t\t\"divdeo\",\tCONST,\tdiveo_di)\n+BU_P7_MISC_2 (DIVDEU,\t\t\"divdeu\",\tCONST,\tdiveu_di)\n+BU_P7_MISC_2 (DIVDEUO,\t\t\"divdeuo\",\tCONST,\tdiveuo_di)\n+\n+/* 1 argument DFP (decimal floating point) functions added in ISA 2.05.  */\n+BU_DFP_MISC_1 (DXEX,\t\t\"dxex\",\t\tCONST,\tdfp_dxex_dd)\n+BU_DFP_MISC_1 (DXEXQ,\t\t\"dxexq\",\tCONST,\tdfp_dxex_td)\n+\n+/* 2 argument DFP (decimal floating point) functions added in ISA 2.05.  */\n+BU_DFP_MISC_2 (DDEDPD,\t\t\"ddedpd\",\tCONST,\tdfp_ddedpd_dd)\n+BU_DFP_MISC_2 (DDEDPDQ,\t\t\"ddedpdq\",\tCONST,\tdfp_ddedpd_td)\n+BU_DFP_MISC_2 (DENBCD,\t\t\"denbcd\",\tCONST,\tdfp_denbcd_dd)\n+BU_DFP_MISC_2 (DENBCDQ,\t\t\"denbcdq\",\tCONST,\tdfp_denbcd_td)\n+BU_DFP_MISC_2 (DIEX,\t\t\"diex\",\t\tCONST,\tdfp_diex_dd)\n+BU_DFP_MISC_2 (DIEXQ,\t\t\"diexq\",\tCONST,\tdfp_diex_td)\n+BU_DFP_MISC_2 (DSCLI,\t\t\"dscli\",\tCONST,\tdfp_dscli_dd)\n+BU_DFP_MISC_2 (DSCLIQ,\t\t\"dscliq\",\tCONST,\tdfp_dscli_td)\n+BU_DFP_MISC_2 (DSCRI,\t\t\"dscri\",\tCONST,\tdfp_dscri_dd)\n+BU_DFP_MISC_2 (DSCRIQ,\t\t\"dscriq\",\tCONST,\tdfp_dscri_td)\n+\n+/* 1 argument BCD functions added in ISA 2.06.  */\n+BU_P7_MISC_1 (CDTBCD,\t\t\"cdtbcd\",\tCONST,\tcdtbcd)\n+BU_P7_MISC_1 (CBCDTD,\t\t\"cbcdtd\",\tCONST,\tcbcdtd)\n+\n+/* 2 argument BCD functions added in ISA 2.06.  */\n+BU_P7_MISC_2 (ADDG6S,\t\t\"addg6s\",\tCONST,\taddg6s)\n+\n+/* 3 argument BCD functions added in ISA 2.07.  */\n+BU_P8V_MISC_3 (BCDADD,\t\t\"bcdadd\",\tCONST,\tbcdadd)\n+BU_P8V_MISC_3 (BCDADD_LT,\t\"bcdadd_lt\",\tCONST,\tbcdadd_lt)\n+BU_P8V_MISC_3 (BCDADD_EQ,\t\"bcdadd_eq\",\tCONST,\tbcdadd_eq)\n+BU_P8V_MISC_3 (BCDADD_GT,\t\"bcdadd_gt\",\tCONST,\tbcdadd_gt)\n+BU_P8V_MISC_3 (BCDADD_OV,\t\"bcdadd_ov\",\tCONST,\tbcdadd_unordered)\n+BU_P8V_MISC_3 (BCDSUB,\t\t\"bcdsub\",\tCONST,\tbcdsub)\n+BU_P8V_MISC_3 (BCDSUB_LT,\t\"bcdsub_lt\",\tCONST,\tbcdsub_lt)\n+BU_P8V_MISC_3 (BCDSUB_EQ,\t\"bcdsub_eq\",\tCONST,\tbcdsub_eq)\n+BU_P8V_MISC_3 (BCDSUB_GT,\t\"bcdsub_gt\",\tCONST,\tbcdsub_gt)\n+BU_P8V_MISC_3 (BCDSUB_OV,\t\"bcdsub_ov\",\tCONST,\tbcdsub_unordered)\n+\n+/* 2 argument pack/unpack 128-bit floating point types.  */\n+BU_DFP_MISC_2 (PACK_TD,\t\t\"pack_dec128\",\t\tCONST,\tpacktd)\n+BU_DFP_MISC_2 (UNPACK_TD,\t\"unpack_dec128\",\tCONST,\tunpacktd)\n+\n+BU_MISC_2 (PACK_TF,\t\t\"pack_longdouble\",\tCONST,\tpacktf)\n+BU_MISC_2 (UNPACK_TF,\t\t\"unpack_longdouble\",\tCONST,\tunpacktf)\n+BU_MISC_1 (UNPACK_TF_0,\t\t\"longdouble_dw0\",\tCONST,\tunpacktf_0)\n+BU_MISC_1 (UNPACK_TF_1,\t\t\"longdouble_dw1\",\tCONST,\tunpacktf_1)\n+\n+BU_P7_MISC_2 (PACK_V1TI,\t\"pack_vector_int128\",\tCONST,\tpackv1ti)\n+BU_P7_MISC_2 (UNPACK_V1TI,\t\"unpack_vector_int128\",\tCONST,\tunpackv1ti)\n+\n \f\n /* 1 argument crypto functions.  */\n BU_CRYPTO_1 (VSBOX,\t\t\"vsbox\",\t  CONST, crypto_vsbox)"}, {"sha": "ca8fa5953c29480a7311f00596cf120dba60842b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -3038,7 +3038,8 @@ rs6000_builtin_mask_calculate (void)\n \t  | ((rs6000_cpu == PROCESSOR_CELL) ? RS6000_BTM_CELL      : 0)\n \t  | ((TARGET_P8_VECTOR)\t\t    ? RS6000_BTM_P8_VECTOR : 0)\n \t  | ((TARGET_CRYPTO)\t\t    ? RS6000_BTM_CRYPTO\t   : 0)\n-\t  | ((TARGET_HTM)\t\t    ? RS6000_BTM_HTM\t   : 0));\n+\t  | ((TARGET_HTM)\t\t    ? RS6000_BTM_HTM\t   : 0)\n+\t  | ((TARGET_DFP)\t\t    ? RS6000_BTM_DFP\t   : 0));\n }\n \n /* Override command line options.  Mostly we process the processor type and\n@@ -12402,7 +12403,15 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n \t}\n     }\n   else if (icode == CODE_FOR_vsx_set_v2df\n-           || icode == CODE_FOR_vsx_set_v2di)\n+           || icode == CODE_FOR_vsx_set_v2di\n+\t   || icode == CODE_FOR_bcdadd\n+\t   || icode == CODE_FOR_bcdadd_lt\n+\t   || icode == CODE_FOR_bcdadd_eq\n+\t   || icode == CODE_FOR_bcdadd_gt\n+\t   || icode == CODE_FOR_bcdsub\n+\t   || icode == CODE_FOR_bcdsub_lt\n+\t   || icode == CODE_FOR_bcdsub_eq\n+\t   || icode == CODE_FOR_bcdsub_gt)\n     {\n       /* Only allow 1-bit unsigned literals.  */\n       STRIP_NOPS (arg2);\n@@ -12413,6 +12422,44 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n \t  return const0_rtx;\n \t}\n     }\n+  else if (icode == CODE_FOR_dfp_ddedpd_dd\n+           || icode == CODE_FOR_dfp_ddedpd_td)\n+    {\n+      /* Only allow 2-bit unsigned literals where the value is 0 or 2.  */\n+      STRIP_NOPS (arg0);\n+      if (TREE_CODE (arg0) != INTEGER_CST\n+\t  || TREE_INT_CST_LOW (arg2) & ~0x3)\n+\t{\n+\t  error (\"argument 1 must be 0 or 2\");\n+\t  return const0_rtx;\n+\t}\n+    }\n+  else if (icode == CODE_FOR_dfp_denbcd_dd\n+\t   || icode == CODE_FOR_dfp_denbcd_td)\n+    {\n+      /* Only allow 1-bit unsigned literals.  */\n+      STRIP_NOPS (arg0);\n+      if (TREE_CODE (arg0) != INTEGER_CST\n+\t  || TREE_INT_CST_LOW (arg0) & ~0x1)\n+\t{\n+\t  error (\"argument 1 must be a 1-bit unsigned literal\");\n+\t  return const0_rtx;\n+\t}\n+    }\n+  else if (icode == CODE_FOR_dfp_dscli_dd\n+           || icode == CODE_FOR_dfp_dscli_td\n+\t   || icode == CODE_FOR_dfp_dscri_dd\n+\t   || icode == CODE_FOR_dfp_dscri_td)\n+    {\n+      /* Only allow 6-bit unsigned literals.  */\n+      STRIP_NOPS (arg1);\n+      if (TREE_CODE (arg1) != INTEGER_CST\n+\t  || TREE_INT_CST_LOW (arg1) & ~0x3f)\n+\t{\n+\t  error (\"argument 2 must be a 6-bit unsigned literal\");\n+\t  return const0_rtx;\n+\t}\n+    }\n   else if (icode == CODE_FOR_crypto_vshasigmaw\n \t   || icode == CODE_FOR_crypto_vshasigmad)\n     {\n@@ -13504,6 +13551,14 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n     error (\"Builtin function %s requires the -mpaired option\", name);\n   else if ((fnmask & RS6000_BTM_SPE) != 0)\n     error (\"Builtin function %s requires the -mspe option\", name);\n+  else if ((fnmask & (RS6000_BTM_DFP | RS6000_BTM_P8_VECTOR))\n+\t   == (RS6000_BTM_DFP | RS6000_BTM_P8_VECTOR))\n+    error (\"Builtin function %s requires the -mhard-dfp and\"\n+\t   \"-mpower8-vector options\", name);\n+  else if ((fnmask & RS6000_BTM_DFP) != 0)\n+    error (\"Builtin function %s requires the -mhard-dfp option\", name);\n+  else if ((fnmask & RS6000_BTM_P8_VECTOR) != 0)\n+    error (\"Builtin function %s requires the -mpower8-vector option\", name);\n   else\n     error (\"Builtin function %s is not supported with the current options\",\n \t   name);\n@@ -13783,6 +13838,9 @@ rs6000_init_builtins (void)\n   uintTI_type_internal_node = unsigned_intTI_type_node;\n   float_type_internal_node = float_type_node;\n   double_type_internal_node = double_type_node;\n+  long_double_type_internal_node = long_double_type_node;\n+  dfloat64_type_internal_node = dfloat64_type_node;\n+  dfloat128_type_internal_node = dfloat128_type_node;\n   void_type_internal_node = void_type_node;\n \n   /* Initialize the modes for builtin_function_type, mapping a machine mode to\n@@ -13797,6 +13855,9 @@ rs6000_init_builtins (void)\n   builtin_mode_to_type[TImode][1] = unsigned_intTI_type_node;\n   builtin_mode_to_type[SFmode][0] = float_type_node;\n   builtin_mode_to_type[DFmode][0] = double_type_node;\n+  builtin_mode_to_type[TFmode][0] = long_double_type_node;\n+  builtin_mode_to_type[DDmode][0] = dfloat64_type_node;\n+  builtin_mode_to_type[TDmode][0] = dfloat128_type_node;\n   builtin_mode_to_type[V1TImode][0] = V1TI_type_node;\n   builtin_mode_to_type[V1TImode][1] = unsigned_V1TI_type_node;\n   builtin_mode_to_type[V2SImode][0] = V2SI_type_node;\n@@ -14889,6 +14950,8 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n       /* unsigned 1 argument functions.  */\n     case CRYPTO_BUILTIN_VSBOX:\n     case P8V_BUILTIN_VGBBD:\n+    case MISC_BUILTIN_CDTBCD:\n+    case MISC_BUILTIN_CBCDTD:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       break;\n@@ -14907,6 +14970,11 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n     case CRYPTO_BUILTIN_VPMSUMW:\n     case CRYPTO_BUILTIN_VPMSUMD:\n     case CRYPTO_BUILTIN_VPMSUM:\n+    case MISC_BUILTIN_ADDG6S:\n+    case MISC_BUILTIN_DIVWEU:\n+    case MISC_BUILTIN_DIVWEUO:\n+    case MISC_BUILTIN_DIVDEU:\n+    case MISC_BUILTIN_DIVDEUO:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       h.uns_p[2] = 1;\n@@ -14968,9 +15036,18 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n       /* signed args, unsigned return.  */\n     case VSX_BUILTIN_XVCVDPUXDS_UNS:\n     case ALTIVEC_BUILTIN_FIXUNS_V4SF_V4SI:\n+    case MISC_BUILTIN_UNPACK_TD:\n+    case MISC_BUILTIN_UNPACK_V1TI:\n       h.uns_p[0] = 1;\n       break;\n \n+      /* unsigned arguments for 128-bit pack instructions.  */\n+    case MISC_BUILTIN_PACK_TD:\n+    case MISC_BUILTIN_PACK_V1TI:\n+      h.uns_p[1] = 1;\n+      h.uns_p[2] = 1;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -31224,6 +31301,7 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n   { \"power8-vector\",\t RS6000_BTM_P8_VECTOR,\tfalse, false },\n   { \"crypto\",\t\t RS6000_BTM_CRYPTO,\tfalse, false },\n   { \"htm\",\t\t RS6000_BTM_HTM,\tfalse, false },\n+  { \"hard-dfp\",\t\t RS6000_BTM_DFP,\tfalse, false },\n };\n \n /* Option variables that we want to support inside attribute((target)) and"}, {"sha": "5a96bebaf10628cff2d13cc5239335d50f067802", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -2516,6 +2516,7 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_FRSQRTES\tMASK_POPCNTB\t/* FRSQRTES instruction.  */\n #define RS6000_BTM_POPCNTD\tMASK_POPCNTD\t/* Target supports ISA 2.06.  */\n #define RS6000_BTM_CELL\t\tMASK_FPRND\t/* Target is cell powerpc.  */\n+#define RS6000_BTM_DFP\t\tMASK_DFP\t/* Decimal floating point.  */\n \n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\\n@@ -2527,7 +2528,8 @@ extern int frame_pointer_needed;\n \t\t\t\t | RS6000_BTM_FRSQRTES\t\t\t\\\n \t\t\t\t | RS6000_BTM_HTM\t\t\t\\\n \t\t\t\t | RS6000_BTM_POPCNTD\t\t\t\\\n-\t\t\t\t | RS6000_BTM_CELL)\n+\t\t\t\t | RS6000_BTM_CELL\t\t\t\\\n+\t\t\t\t | RS6000_BTM_DFP)\n \n /* Define builtin enum index.  */\n \n@@ -2622,6 +2624,9 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_UINTTI,\t\t /* unsigned_intTI_type_node */\n   RS6000_BTI_float,\t         /* float_type_node */\n   RS6000_BTI_double,\t         /* double_type_node */\n+  RS6000_BTI_long_double,        /* long_double_type_node */\n+  RS6000_BTI_dfloat64,\t\t /* dfloat64_type_node */\n+  RS6000_BTI_dfloat128,\t\t /* dfloat128_type_node */\n   RS6000_BTI_void,\t         /* void_type_node */\n   RS6000_BTI_MAX\n };\n@@ -2673,6 +2678,9 @@ enum rs6000_builtin_type_index\n #define uintTI_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_UINTTI])\n #define float_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_float])\n #define double_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_double])\n+#define long_double_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_long_double])\n+#define dfloat64_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_dfloat64])\n+#define dfloat128_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_dfloat128])\n #define void_type_internal_node\t\t (rs6000_builtin_types[RS6000_BTI_void])\n \n extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];"}, {"sha": "9207b4d5106f74ee5afda7f3bb1f3bc865c44e14", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 200, "deletions": 8, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -125,6 +125,15 @@\n    UNSPEC_P8V_MTVSRD\n    UNSPEC_P8V_XXPERMDI\n    UNSPEC_P8V_RELOAD_FROM_VSX\n+   UNSPEC_ADDG6S\n+   UNSPEC_CDTBCD\n+   UNSPEC_CBCDTD\n+   UNSPEC_DIVE\n+   UNSPEC_DIVEO\n+   UNSPEC_DIVEU\n+   UNSPEC_DIVEUO\n+   UNSPEC_UNPACK_128BIT\n+   UNSPEC_PACK_128BIT\n   ])\n \n ;;\n@@ -481,6 +490,10 @@\n \t\t\t\t\t (V2DF\t\"X,X,X,X,X\")\n \t\t\t\t\t (V1TI\t\"X,X,X,X,X\")])\n \n+;; Mode attribute to give the correct type for integer divides\n+(define_mode_attr idiv_ldiv [(SI \"idiv\")\n+\t\t\t     (DI \"ldiv\")])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -2755,10 +2768,7 @@\n \t\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n   \"\"\n   \"div<wd>u %0,%1,%2\"\n-   [(set (attr \"type\")\n-      (cond [(match_operand:SI 0 \"\" \"\")\n-\t\t(const_string \"idiv\")]\n-\t(const_string \"ldiv\")))])\n+   [(set_attr \"type\" \"<idiv_ldiv>\")])\n \n \n ;; For powers of two we can do srai/aze for divide and then adjust for\n@@ -2782,10 +2792,7 @@\n \t\t (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n   \"\"\n   \"div<wd> %0,%1,%2\"\n-  [(set (attr \"type\")\n-     (cond [(match_operand:SI 0 \"\" \"\")\n-\t\t(const_string \"idiv\")]\n-\t(const_string \"ldiv\")))])\n+  [(set_attr \"type\" \"<idiv_ldiv>\")])\n \n (define_expand \"mod<mode>3\"\n   [(use (match_operand:GPR 0 \"gpc_reg_operand\" \"\"))\n@@ -15734,6 +15741,191 @@\n   DONE;\n })\n \n+\f\n+;; Miscellaneous ISA 2.06 (power7) instructions\n+(define_insn \"addg6s\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_ADDG6S))]\n+  \"TARGET_POPCNTD\"\n+  \"addg6s %0,%1,%2\"\n+  [(set_attr \"type\" \"integer\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"cdtbcd\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_CDTBCD))]\n+  \"TARGET_POPCNTD\"\n+  \"cdtbcd %0,%1\"\n+  [(set_attr \"type\" \"integer\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"cbcdtd\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_CBCDTD))]\n+  \"TARGET_POPCNTD\"\n+  \"cbcdtd %0,%1\"\n+  [(set_attr \"type\" \"integer\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_int_iterator UNSPEC_DIV_EXTEND [UNSPEC_DIVE\n+\t\t\t\t\tUNSPEC_DIVEO\n+\t\t\t\t\tUNSPEC_DIVEU\n+\t\t\t\t\tUNSPEC_DIVEUO])\n+\n+(define_int_attr div_extend [(UNSPEC_DIVE\t\"e\")\n+\t\t\t     (UNSPEC_DIVEO\t\"eo\")\n+\t\t\t     (UNSPEC_DIVEU\t\"eu\")\n+\t\t\t     (UNSPEC_DIVEUO\t\"euo\")])\n+\n+(define_insn \"div<div_extend>_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(unspec:GPR [(match_operand:GPR 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:GPR 2 \"register_operand\" \"r\")]\n+\t\t    UNSPEC_DIV_EXTEND))]\n+  \"TARGET_POPCNTD\"\n+  \"div<wd><div_extend> %0,%1,%2\"\n+  [(set_attr \"type\" \"<idiv_ldiv>\")])\n+\n+\f\n+;; Pack/unpack 128-bit floating point types that take 2 scalar registers\n+\n+; Type of the 64-bit part when packing/unpacking 128-bit floating point types\n+(define_mode_attr FP128_64 [(TF \"DF\") (TD \"DI\")])\n+\n+(define_expand \"unpack<mode>\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:<FP128_64>\n+\t [(match_operand:FMOVE128 1 \"register_operand\" \"\")\n+\t  (match_operand:QI 2 \"const_0_to_1_operand\" \"\")]\n+\t UNSPEC_UNPACK_128BIT))]\n+  \"\"\n+  \"\")\n+\n+;; The Advance Toolchain 7.0-3 added private builtins: __builtin_longdouble_dw0\n+;; and __builtin_longdouble_dw1 to optimize glibc.  Add support for these\n+;; builtins here.\n+\n+(define_expand \"unpacktf_0\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:DF [(match_operand:TF 1 \"register_operand\" \"\")\n+\t\t    (const_int 0)]\n+\t UNSPEC_UNPACK_128BIT))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"unpacktf_1\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:DF [(match_operand:TF 1 \"register_operand\" \"\")\n+\t\t    (const_int 1)]\n+\t UNSPEC_UNPACK_128BIT))]\n+  \"\"\n+  \"\")\n+\n+(define_insn_and_split \"unpack<mode>_dm\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=d,m,d,r,m\")\n+\t(unspec:<FP128_64>\n+\t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d,r,d,r\")\n+\t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i,i,i,i\")]\n+\t UNSPEC_UNPACK_128BIT))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 3))]\n+{\n+  unsigned fp_regno = REGNO (operands[1]) + UINTVAL (operands[2]);\n+\n+  if (REG_P (operands[0]) && REGNO (operands[0]) == fp_regno)\n+    {\n+      emit_note (NOTE_INSN_DELETED);\n+      DONE;\n+    }\n+\n+  operands[3] = gen_rtx_REG (<FP128_64>mode, fp_regno);\n+}\n+  [(set_attr \"type\" \"fp,fpstore,mffgpr,mftgpr,store\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"unpack<mode>_nodm\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(unspec:<FP128_64>\n+\t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d\")\n+\t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i\")]\n+\t UNSPEC_UNPACK_128BIT))]\n+  \"!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 3))]\n+{\n+  unsigned fp_regno = REGNO (operands[1]) + UINTVAL (operands[2]);\n+\n+  if (REG_P (operands[0]) && REGNO (operands[0]) == fp_regno)\n+    {\n+      emit_note (NOTE_INSN_DELETED);\n+      DONE;\n+    }\n+\n+  operands[3] = gen_rtx_REG (<FP128_64>mode, fp_regno);\n+}\n+  [(set_attr \"type\" \"fp,fpstore\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"pack<mode>\"\n+  [(set (match_operand:FMOVE128 0 \"register_operand\" \"=d,&d\")\n+\t(unspec:FMOVE128\n+\t [(match_operand:<FP128_64> 1 \"register_operand\" \"0,d\")\n+\t  (match_operand:<FP128_64> 2 \"register_operand\" \"d,d\")]\n+\t UNSPEC_PACK_128BIT))]\n+  \"\"\n+  \"@\n+   fmr %L0,%2\n+   #\"\n+  \"&& reload_completed && REGNO (operands[0]) != REGNO (operands[1])\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 4) (match_dup 2))]\n+{\n+  unsigned dest_hi = REGNO (operands[0]);\n+  unsigned dest_lo = dest_hi + 1;\n+\n+  gcc_assert (!IN_RANGE (REGNO (operands[1]), dest_hi, dest_lo));\n+  gcc_assert (!IN_RANGE (REGNO (operands[2]), dest_hi, dest_lo));\n+\n+  operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);\n+  operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);\n+}\n+  [(set_attr \"type\" \"fp,fp\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"unpackv1ti\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:DI [(match_operand:V1TI 1 \"register_operand\" \"0,wa\")\n+\t\t    (match_operand:QI 2 \"const_0_to_1_operand\" \"O,i\")]\n+\t UNSPEC_UNPACK_128BIT))]\n+  \"TARGET_VSX\"\n+{\n+  if (REGNO (operands[0]) == REGNO (operands[1]) && INTVAL (operands[2]) == 0)\n+    return ASM_COMMENT_START \" xxpermdi to same register\";\n+\n+  operands[3] = GEN_INT (INTVAL (operands[2]) == 0 ? 0 : 3);\n+  return \"xxpermdi %x0,%x1,%x1,%3\";\n+}\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"packv1ti\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=wa\")\n+\t(unspec:V1TI\n+\t [(match_operand:DI 1 \"register_operand\" \"d\")\n+\t  (match_operand:DI 2 \"register_operand\" \"d\")]\n+\t UNSPEC_PACK_128BIT))]\n+  \"TARGET_VSX\"\n+  \"xxpermdi %x0,%x1,%x2,0\"\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"length\" \"4\")])\n+\n \f\n \n (include \"sync.md\")"}, {"sha": "9780d923804b0a37bb44eac068fa2a8f97bc45ae", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -12787,9 +12787,12 @@ float __builtin_recipdivf (float, float);\n float __builtin_rsqrtf (float);\n double __builtin_recipdiv (double, double);\n double __builtin_rsqrt (double);\n-long __builtin_bpermd (long, long);\n uint64_t __builtin_ppc_get_timebase ();\n unsigned long __builtin_ppc_mftb ();\n+double __builtin_unpack_longdouble (long double, int);\n+double __builtin_longdouble_dw0 (long double);\n+double __builtin_longdouble_dw1 (long double);\n+long double __builtin_pack_longdouble (double, double);\n @end smallexample\n \n The @code{vec_rsqrt}, @code{__builtin_rsqrt}, and\n@@ -12809,6 +12812,57 @@ The @code{__builtin_ppc_mftb} function always generates one instruction and\n returns the Time Base Register value as an unsigned long, throwing away\n the most significant word on 32-bit environments.\n \n+The following built-in functions are available for the PowerPC family\n+of processors, starting with ISA 2.06 or later (@option{-mcpu=power7}\n+or @option{-mpopcntd}):\n+@smallexample\n+long __builtin_bpermd (long, long);\n+int __builtin_divwe (int, int);\n+int __builtin_divweo (int, int);\n+unsigned int __builtin_divweu (unsigned int, unsigned int);\n+unsigned int __builtin_divweuo (unsigned int, unsigned int);\n+long __builtin_divde (long, long);\n+long __builtin_divdeo (long, long);\n+unsigned long __builtin_divdeu (unsigned long, unsigned long);\n+unsigned long __builtin_divdeuo (unsigned long, unsigned long);\n+unsigned int cdtbcd (unsigned int);\n+unsigned int cbcdtd (unsigned int);\n+unsigned int addg6s (unsigned int, unsigned int);\n+@end smallexample\n+\n+The @code{__builtin_divde}, @code{__builtin_divdeo},\n+@code{__builitin_divdeu}, @code{__builtin_divdeou} functions require a\n+64-bit environment support ISA 2.06 or later.\n+\n+The following built-in functions are available for the PowerPC family\n+of processors when hardware decimal floating point\n+(@option{-mhard-dfp}) is available:\n+@smallexample\n+_Decimal64 __builtin_dxex (_Decimal64);\n+_Decimal128 __builtin_dxexq (_Decimal128);\n+_Decimal64 __builtin_ddedpd (int, _Decimal64);\n+_Decimal128 __builtin_ddedpdq (int, _Decimal128);\n+_Decimal64 __builtin_denbcd (int, _Decimal64);\n+_Decimal128 __builtin_denbcdq (int, _Decimal128);\n+_Decimal64 __builtin_diex (_Decimal64, _Decimal64);\n+_Decimal128 _builtin_diexq (_Decimal128, _Decimal128);\n+_Decimal64 __builtin_dscli (_Decimal64, int);\n+_Decimal128 __builitn_dscliq (_Decimal128, int);\n+_Decimal64 __builtin_dscri (_Decimal64, int);\n+_Decimal128 __builitn_dscriq (_Decimal128, int);\n+unsigned long long __builtin_unpack_dec128 (_Decimal128, int);\n+_Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);\n+@end smallexample\n+\n+The following built-in functions are available for the PowerPC family\n+of processors when the Vector Scalar (vsx) instruction set is\n+available:\n+@smallexample\n+unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);\n+vector __int128_t __builtin_pack_vector_int128 (unsigned long long,\n+                                                unsigned long long);\n+@end smallexample\n+\n @node PowerPC AltiVec/VSX Built-in Functions\n @subsection PowerPC AltiVec Built-in Functions\n \n@@ -15220,6 +15274,17 @@ vector __uint128_t vec_vsubcuq (vector __uint128_t, vector __uint128_t);\n \n __int128_t vec_vsubuqm (__int128_t, __int128_t);\n __uint128_t vec_vsubuqm (__uint128_t, __uint128_t);\n+\n+vector __int128_t __builtin_bcdadd (vector __int128_t, vector__int128_t);\n+int __builtin_bcdadd_lt (vector __int128_t, vector__int128_t);\n+int __builtin_bcdadd_eq (vector __int128_t, vector__int128_t);\n+int __builtin_bcdadd_gt (vector __int128_t, vector__int128_t);\n+int __builtin_bcdadd_ov (vector __int128_t, vector__int128_t);\n+vector __int128_t bcdsub (vector __int128_t, vector__int128_t);\n+int __builtin_bcdsub_lt (vector __int128_t, vector__int128_t);\n+int __builtin_bcdsub_eq (vector __int128_t, vector__int128_t);\n+int __builtin_bcdsub_gt (vector __int128_t, vector__int128_t);\n+int __builtin_bcdsub_ov (vector __int128_t, vector__int128_t);\n @end smallexample\n \n If the cryptographic instructions are enabled (@option{-mcrypto} or"}, {"sha": "9906c94146389419892f64727fb3fb16bb79abb0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -1,3 +1,20 @@\n+2014-04-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/pack01.c: New test to test the new pack and\n+\tunpack builtin functionss for 128-bit types.\n+\t* gcc.target/powerpc/pack02.c: Likewise.\n+\t* gcc.target/powerpc/pack03.c: Likewise.\n+\t* gcc.target/powerpc/extend-divide-1.c: New test to test extended\n+\tdivide builtin functionss.\n+\t* gcc.target/powerpc/extend-divide-2.c: Likewise.\n+\t* gcc.target/powerpc/bcd-1.c: New test for the new BCD builtin\n+\tfunctions.\n+\t* gcc.target/powerpc/bcd-2.c: Likewise.\n+\t* gcc.target/powerpc/bcd-3.c: Likewise.\n+\t* gcc.target/powerpc/dfp-builtin-1.c: New test for the new DFP\n+\tbuiltin functionss.\n+\t* gcc.target/powerpc/dfp-builtin-2.c: Likewise.\n+\n 2014-04-24  Vishnu K S  <Vishnu.k_s@atmel.com>\n \n \t* gcc/testsuite/gcc.dg/tree-ssa/isolate-1.c: Skip test if"}, {"sha": "c7496c2357990e6e2a8055fb194076afb2308584", "filename": "gcc/testsuite/gcc.target/powerpc/bcd-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-1.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+/* { dg-final { scan-assembler-times \"cdtbcd \" 1 } } */\n+/* { dg-final { scan-assembler-times \"cbcdtd \" 1 } } */\n+/* { dg-final { scan-assembler-times \"addg6s \" 1 } } */\n+/* { dg-final { scan-assembler-not    \"bl __builtin\" } } */\n+\n+unsigned int\n+to_bcd (unsigned int a)\n+{\n+  return __builtin_cdtbcd (a);\n+}\n+\n+unsigned int\n+from_bcd (unsigned int a)\n+{\n+  return __builtin_cbcdtd (a);\n+}\n+\n+unsigned int\n+bcd_arith (unsigned int a, unsigned int b)\n+{\n+  return __builtin_addg6s (a, b);\n+}"}, {"sha": "d330b742376ddd1b42a80003b862b4b99fa126fd", "filename": "gcc/testsuite/gcc.target/powerpc/bcd-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-2.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"bcdadd\\[.\\] \" 2 } } */\n+/* { dg-final { scan-assembler-times \"bcdsub\\[.\\] \" 2 } } */\n+/* { dg-final { scan-assembler-not   \"bl __builtin\"   } } */\n+/* { dg-final { scan-assembler-not   \"mtvsr\"   \t      } } */\n+/* { dg-final { scan-assembler-not   \"mfvsr\"   \t      } } */\n+/* { dg-final { scan-assembler-not   \"lvx\"     \t      } } */\n+/* { dg-final { scan-assembler-not   \"lxvw4x\"  \t      } } */\n+/* { dg-final { scan-assembler-not   \"lxvd2x\"  \t      } } */\n+/* { dg-final { scan-assembler-not   \"stvx\"    \t      } } */\n+/* { dg-final { scan-assembler-not   \"stxvw4x\" \t      } } */\n+/* { dg-final { scan-assembler-not   \"stxvd2x\" \t      } } */\n+\n+typedef __int128_t __attribute__((__vector_size__(16)))\tvector_128_t;\n+typedef __int128_t\t\t\t\t\tscalar_128_t;\n+typedef\tunsigned long long\t\t\t\tscalar_64_t;\n+\n+vector_128_t\n+do_add_0 (vector_128_t a, vector_128_t b)\n+{\n+  return __builtin_bcdadd (a, b, 0);\n+}\n+\n+vector_128_t\n+do_add_1 (vector_128_t a, vector_128_t b)\n+{\n+  return __builtin_bcdadd (a, b, 1);\n+}\n+\n+vector_128_t\n+do_sub_0 (vector_128_t a, vector_128_t b)\n+{\n+  return __builtin_bcdsub (a, b, 0);\n+}\n+\n+vector_128_t\n+do_sub_1 (vector_128_t a, vector_128_t b)\n+{\n+  return __builtin_bcdsub (a, b, 1);\n+}"}, {"sha": "436cecf6fffc99c61c0bff89d932793668eb1758", "filename": "gcc/testsuite/gcc.target/powerpc/bcd-3.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbcd-3.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"bcdadd\\[.\\] \" 4 } } */\n+/* { dg-final { scan-assembler-times \"bcdsub\\[.\\] \" 4 } } */\n+/* { dg-final { scan-assembler-not   \"bl __builtin\"   } } */\n+/* { dg-final { scan-assembler-not   \"mtvsr\"   \t      } } */\n+/* { dg-final { scan-assembler-not   \"mfvsr\"   \t      } } */\n+/* { dg-final { scan-assembler-not   \"lvx\"     \t      } } */\n+/* { dg-final { scan-assembler-not   \"lxvw4x\"  \t      } } */\n+/* { dg-final { scan-assembler-not   \"lxvd2x\"  \t      } } */\n+/* { dg-final { scan-assembler-not   \"stvx\"    \t      } } */\n+/* { dg-final { scan-assembler-not   \"stxvw4x\" \t      } } */\n+/* { dg-final { scan-assembler-not   \"stxvd2x\" \t      } } */\n+\n+typedef __int128_t __attribute__((__vector_size__(16)))\tvector_128_t;\n+typedef __int128_t\t\t\t\t\tscalar_128_t;\n+typedef\tunsigned long long\t\t\t\tscalar_64_t;\n+\n+/* Test whether the peephole works to allow folding a bcdadd, with a\n+   bcdadd_<test> into a single instruction.  */\n+\n+vector_128_t\n+do_add_lt (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdadd (a, b, 0);\n+  if (__builtin_bcdadd_lt (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_add_eq (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdadd (a, b, 0);\n+  if (__builtin_bcdadd_eq (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_add_gt (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdadd (a, b, 0);\n+  if (__builtin_bcdadd_gt (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_add_ov (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdadd (a, b, 0);\n+  if (__builtin_bcdadd_ov (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_sub_lt (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdsub (a, b, 0);\n+  if (__builtin_bcdsub_lt (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_sub_eq (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdsub (a, b, 0);\n+  if (__builtin_bcdsub_eq (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_sub_gt (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdsub (a, b, 0);\n+  if (__builtin_bcdsub_gt (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}\n+\n+vector_128_t\n+do_sub_ov (vector_128_t a, vector_128_t b, int *p)\n+{\n+  vector_128_t ret = __builtin_bcdsub (a, b, 0);\n+  if (__builtin_bcdsub_ov (a, b, 0))\n+    *p = 1;\n+\n+  return ret;\n+}"}, {"sha": "614f272642ce2ff2df75ee63ffd77b80a774a8f9", "filename": "gcc/testsuite/gcc.target/powerpc/dfp-builtin-1.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-builtin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-builtin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-builtin-1.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+/* { dg-final { scan-assembler-times \"ddedpd \" 4    } } */\n+/* { dg-final { scan-assembler-times \"denbcd \" 2    } } */\n+/* { dg-final { scan-assembler-times \"dxex \"   1    } } */\n+/* { dg-final { scan-assembler-times \"diex \"   1    } } */\n+/* { dg-final { scan-assembler-times \"dscli \"  2    } } */\n+/* { dg-final { scan-assembler-times \"dscri \"  2    } } */\n+/* { dg-final { scan-assembler-not   \"bl __builtin\" } } */\n+/* { dg-final { scan-assembler-not   \"dctqpq\"       } } */\n+/* { dg-final { scan-assembler-not   \"drdpq\"        } } */\n+/* { dg-final { scan-assembler-not   \"stfd\"         } } */\n+/* { dg-final { scan-assembler-not   \"lfd\"          } } */\n+\n+_Decimal64\n+do_dedpd_0 (_Decimal64 a)\n+{\n+  return __builtin_ddedpd (0, a);\n+}\n+\n+_Decimal64\n+do_dedpd_1 (_Decimal64 a)\n+{\n+  return __builtin_ddedpd (1, a);\n+}\n+\n+_Decimal64\n+do_dedpd_2 (_Decimal64 a)\n+{\n+  return __builtin_ddedpd (2, a);\n+}\n+\n+_Decimal64\n+do_dedpd_3 (_Decimal64 a)\n+{\n+  return __builtin_ddedpd (3, a);\n+}\n+\n+_Decimal64\n+do_enbcd_0 (_Decimal64 a)\n+{\n+  return __builtin_denbcd (0, a);\n+}\n+\n+_Decimal64\n+do_enbcd_1 (_Decimal64 a)\n+{\n+  return __builtin_denbcd (1, a);\n+}\n+\n+_Decimal64\n+do_xex (_Decimal64 a)\n+{\n+  return __builtin_dxex (a);\n+}\n+\n+_Decimal64\n+do_iex (_Decimal64 a, _Decimal64 b)\n+{\n+  return __builtin_diex (a, b);\n+}\n+\n+_Decimal64\n+do_scli_1 (_Decimal64 a)\n+{\n+  return __builtin_dscli (a, 1);\n+}\n+\n+_Decimal64\n+do_scli_10 (_Decimal64 a)\n+{\n+  return __builtin_dscli (a, 10);\n+}\n+\n+_Decimal64\n+do_scri_1 (_Decimal64 a)\n+{\n+  return __builtin_dscri (a, 1);\n+}\n+\n+_Decimal64\n+do_scri_10 (_Decimal64 a)\n+{\n+  return __builtin_dscri (a, 10);\n+}"}, {"sha": "189bc9ad6aed5ba2215d2f0127762479cf2abd5f", "filename": "gcc/testsuite/gcc.target/powerpc/dfp-builtin-2.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-builtin-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-builtin-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-builtin-2.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+/* { dg-final { scan-assembler-times \"ddedpdq \" 4    } } */\n+/* { dg-final { scan-assembler-times \"denbcdq \" 2    } } */\n+/* { dg-final { scan-assembler-times \"dxexq \"   1    } } */\n+/* { dg-final { scan-assembler-times \"diexq \"   1    } } */\n+/* { dg-final { scan-assembler-times \"dscliq \"  2    } } */\n+/* { dg-final { scan-assembler-times \"dscriq \"  2    } } */\n+/* { dg-final { scan-assembler-not    \"bl __builtin\" } } */\n+/* { dg-final { scan-assembler-not   \"dctqpq\"        } } */\n+/* { dg-final { scan-assembler-not   \"drdpq\"         } } */\n+/* { dg-final { scan-assembler-not   \"stfd\"          } } */\n+/* { dg-final { scan-assembler-not   \"lfd\"           } } */\n+\n+_Decimal128\n+do_dedpdq_0 (_Decimal128 a)\n+{\n+  return __builtin_ddedpdq (0, a);\n+}\n+\n+_Decimal128\n+do_dedpdq_1 (_Decimal128 a)\n+{\n+  return __builtin_ddedpdq (1, a);\n+}\n+\n+_Decimal128\n+do_dedpdq_2 (_Decimal128 a)\n+{\n+  return __builtin_ddedpdq (2, a);\n+}\n+\n+_Decimal128\n+do_dedpdq_3 (_Decimal128 a)\n+{\n+  return __builtin_ddedpdq (3, a);\n+}\n+\n+_Decimal128\n+do_enbcdq_0 (_Decimal128 a)\n+{\n+  return __builtin_denbcdq (0, a);\n+}\n+\n+_Decimal128\n+do_enbcdq_1 (_Decimal128 a)\n+{\n+  return __builtin_denbcdq (1, a);\n+}\n+\n+_Decimal128\n+do_xexq (_Decimal128 a)\n+{\n+  return __builtin_dxexq (a);\n+}\n+\n+_Decimal128\n+do_iexq (_Decimal128 a, _Decimal128 b)\n+{\n+  return __builtin_diexq (a, b);\n+}\n+\n+_Decimal128\n+do_scliq_1 (_Decimal128 a)\n+{\n+  return __builtin_dscliq (a, 1);\n+}\n+\n+_Decimal128\n+do_scliq_10 (_Decimal128 a)\n+{\n+  return __builtin_dscliq (a, 10);\n+}\n+\n+_Decimal128\n+do_scriq_1 (_Decimal128 a)\n+{\n+  return __builtin_dscriq (a, 1);\n+}\n+\n+_Decimal128\n+do_scriq_10 (_Decimal128 a)\n+{\n+  return __builtin_dscriq (a, 10);\n+}"}, {"sha": "5f948b7212fba2908442ea1a0cf5c0c1bd129886", "filename": "gcc/testsuite/gcc.target/powerpc/extend-divide-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextend-divide-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextend-divide-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextend-divide-1.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+/* { dg-final { scan-assembler-times \"divwe \"   1 } } */\n+/* { dg-final { scan-assembler-times \"divweo \"  1 } } */\n+/* { dg-final { scan-assembler-times \"divweu \"  1 } } */\n+/* { dg-final { scan-assembler-times \"divweuo \" 1 } } */\n+/* { dg-final { scan-assembler-not    \"bl __builtin\" } } */\n+\n+int\n+div_we (int a, int b)\n+{\n+  return __builtin_divwe (a, b);\n+}\n+\n+int\n+div_weo (int a, int b)\n+{\n+  return __builtin_divweo (a, b);\n+}\n+\n+unsigned int\n+div_weu (unsigned int a, unsigned int b)\n+{\n+  return __builtin_divweu (a, b);\n+}\n+\n+unsigned int\n+div_weuo (unsigned int a, unsigned int b)\n+{\n+  return __builtin_divweuo (a, b);\n+}"}, {"sha": "8ee6c8cf768e6830aa6af6cf17d04ce37793d3c5", "filename": "gcc/testsuite/gcc.target/powerpc/extend-divide-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextend-divide-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextend-divide-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextend-divide-2.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+/* { dg-final { scan-assembler-times \"divde \"   1 } } */\n+/* { dg-final { scan-assembler-times \"divdeo \"  1 } } */\n+/* { dg-final { scan-assembler-times \"divdeu \"  1 } } */\n+/* { dg-final { scan-assembler-times \"divdeuo \" 1 } } */\n+/* { dg-final { scan-assembler-not    \"bl __builtin\" } } */\n+\n+long\n+div_de (long a, long b)\n+{\n+  return __builtin_divde (a, b);\n+}\n+\n+long\n+div_deo (long a, long b)\n+{\n+  return __builtin_divdeo (a, b);\n+}\n+\n+unsigned long\n+div_deu (unsigned long a, unsigned long b)\n+{\n+  return __builtin_divdeu (a, b);\n+}\n+\n+unsigned long\n+div_deuo (unsigned long a, unsigned long b)\n+{\n+  return __builtin_divdeuo (a, b);\n+}"}, {"sha": "efac4087c78193a3a2394c5636253f11ae07ce76", "filename": "gcc/testsuite/gcc.target/powerpc/pack01.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack01.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <altivec.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+typedef __int128_t __attribute__((__vector_size__(16)))\tvector_128_t;\n+typedef __int128_t\t\t\t\t\tscalar_128_t;\n+typedef\tunsigned long long\t\t\t\tscalar_64_t;\n+\n+volatile scalar_64_t one = 1;\n+volatile scalar_64_t two = 2;\n+\n+int\n+main (void)\n+{\n+  scalar_128_t a = (((scalar_128_t)one) << 64) | ((scalar_128_t)two);\n+  vector_128_t v1 = (vector_128_t) { a };\n+  vector_128_t v2 = __builtin_pack_vector_int128 (one, two);\n+  scalar_64_t x0 = __builtin_unpack_vector_int128 (v1, 0);\n+  scalar_64_t x1 = __builtin_unpack_vector_int128 (v1, 1);\n+  vector_128_t v3 = __builtin_pack_vector_int128 (x0, x1);\n+\n+  size_t i;\n+  union {\n+    scalar_128_t i128;\n+    vector_128_t v128;\n+    scalar_64_t u64;\n+    unsigned char uc[sizeof (scalar_128_t)];\n+    char c[sizeof (scalar_128_t)];\n+  } u, u2;\n+\n+#ifdef DEBUG\n+  {\n+    printf (\"a  = 0x\");\n+    u.i128 = a;\n+    for (i = 0; i < sizeof (scalar_128_t); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\nv1 = 0x\");\n+    u.v128 = v1;\n+    for (i = 0; i < sizeof (scalar_128_t); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\nv2 = 0x\");\n+    u.v128 = v2;\n+    for (i = 0; i < sizeof (scalar_128_t); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\nv3 = 0x\");\n+    u.v128 = v3;\n+    for (i = 0; i < sizeof (scalar_128_t); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\nx0 = 0x\");\n+    u.u64 = x0;\n+    for (i = 0; i < sizeof (scalar_64_t); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\nx1 = 0x\");\n+    u.u64 = x1;\n+    for (i = 0; i < sizeof (scalar_64_t); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\n\");\n+  }\n+#endif\n+\n+  u2.i128 = a;\n+  u.v128 = v1;\n+  if (memcmp (u.c, u2.c, sizeof (scalar_128_t)) != 0)\n+    abort ();\n+\n+  u.v128 = v2;\n+  if (memcmp (u.c, u2.c, sizeof (scalar_128_t)) != 0)\n+    abort ();\n+\n+  u.v128 = v3;\n+  if (memcmp (u.c, u2.c, sizeof (scalar_128_t)) != 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "74b6cd04dcca00ab9b89a67ce498771710e6528e", "filename": "gcc/testsuite/gcc.target/powerpc/pack02.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack02.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <math.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+int\n+main (void)\n+{\n+  double high = pow (2.0, 60);\n+  double low  = 2.0;\n+  long double a = ((long double)high) + ((long double)low);\n+  double x0 = __builtin_unpack_longdouble (a, 0);\n+  double x1 = __builtin_unpack_longdouble (a, 1);\n+  long double b = __builtin_pack_longdouble (x0, x1);\n+\n+#ifdef DEBUG\n+  {\n+    size_t i;\n+    union {\n+      long double ld;\n+      double d;\n+      unsigned char uc[sizeof (long double)];\n+      char c[sizeof (long double)];\n+    } u;\n+\n+    printf (\"a  = 0x\");\n+    u.ld = a;\n+    for (i = 0; i < sizeof (long double); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\", %Lg\\n\", a);\n+\n+    printf (\"b  = 0x\");\n+    u.ld = b;\n+    for (i = 0; i < sizeof (long double); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\", %Lg\\n\", b);\n+\n+    printf (\"hi = 0x\");\n+    u.d = high;\n+    for (i = 0; i < sizeof (double); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", high);\n+\n+    printf (\"lo = 0x\");\n+    u.d = low;\n+    for (i = 0; i < sizeof (double); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", low);\n+\n+    printf (\"x0 = 0x\");\n+    u.d = x0;\n+    for (i = 0; i < sizeof (double); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", x0);\n+\n+    printf (\"x1 = 0x\");\n+    u.d = x1;\n+    for (i = 0; i < sizeof (double); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", x1);\n+  }\n+#endif\n+\n+  if (high != x0)\n+    abort ();\n+\n+  if (low != x1)\n+    abort ();\n+\n+  if (a != b)\n+    abort ();\n+\n+  if (x0 != high)\n+    abort ();\n+\n+  if (x1 != low)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "59f0e74ba9c7e36b51a405c636e6aad192ae8e14", "filename": "gcc/testsuite/gcc.target/powerpc/pack03.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack03.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b39289a203be6859a3ec99df3fdd80a72a88f9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack03.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack03.c?ref=06b39289a203be6859a3ec99df3fdd80a72a88f9", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <math.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+int\n+main (void)\n+{\n+  _Decimal128 one\t= (_Decimal128)1.0;\n+  _Decimal128 two\t= (_Decimal128)2.0;\n+  _Decimal128 ten\t= (_Decimal128)10.0;\n+  _Decimal128 a\t\t= one;\n+  _Decimal128 b;\n+  _Decimal128 c;\n+  unsigned long long x0;\n+  unsigned long long x1;\n+  size_t i;\n+\n+  for (i = 0; i < 25; i++)\n+    a *= ten;\n+\n+  a += two;\n+\n+  x0 = __builtin_unpack_dec128 (a, 0);\n+  x1 = __builtin_unpack_dec128 (a, 1);\n+  b = __builtin_pack_dec128 (x0, x1);\n+  c = __builtin_dscliq (one, 25) + two;\n+\n+#ifdef DEBUG\n+  {\n+    union {\n+      _Decimal128 d;\n+      unsigned long long ull;\n+      unsigned char uc[sizeof (_Decimal128)];\n+    } u;\n+\n+    printf (\"a  = 0x\");\n+    u.d = a;\n+    for (i = 0; i < sizeof (_Decimal128); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\", %Lg\\n\", (long double)a);\n+\n+    printf (\"b  = 0x\");\n+    u.d = b;\n+    for (i = 0; i < sizeof (_Decimal128); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\", %Lg\\n\", (long double)b);\n+\n+    printf (\"c  = 0x\");\n+    u.d = c;\n+    for (i = 0; i < sizeof (_Decimal128); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\", %Lg\\n\", (long double)c);\n+\n+    printf (\"x0 = 0x\");\n+    u.ull = x0;\n+    for (i = 0; i < sizeof (unsigned long long); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\nx1 = 0x\");\n+    u.ull = x1;\n+    for (i = 0; i < sizeof (unsigned long long); i++)\n+      printf (\"%.2x\", u.uc[i]);\n+\n+    printf (\"\\n\");\n+  }\n+#endif\n+\n+  if (a != b)\n+    abort ();\n+\n+  if (a != c)\n+    abort ();\n+\n+  return 0;\n+}"}]}