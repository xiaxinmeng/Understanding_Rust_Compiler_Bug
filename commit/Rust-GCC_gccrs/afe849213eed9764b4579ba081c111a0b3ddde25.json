{"sha": "afe849213eed9764b4579ba081c111a0b3ddde25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlODQ5MjEzZWVkOTc2NGI0NTc5YmEwODFjMTExYTBiM2RkZGUyNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-30T03:52:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-30T03:52:37Z"}, "message": "expr.c (get_inner_reference): Handle REAL/IMAGPART_EXPR.\n\n        * expr.c (get_inner_reference): Handle REAL/IMAGPART_EXPR.\n        (handled_component_p): Likewise.\n        * alias.c (can_address_p): Reformat and simplify.  Handle\n        REAL/IMAGPART_EXPR.  Do not disable addressability based on\n        alias set zero.\n        * fold-const.c (build_fold_addr_expr_with_type): Remove duplicate\n        check for REAL/IMAGPART_EXPR.\n        * gimplify.c (gimplify_compound_lval): Likewise.\n        * tree-cfg.c (verify_expr): Likewise.\n        * tree-gimple.c (is_gimple_addressable, get_base_address): Likewise.\n        * tree-nested.c (build_addr, convert_nonlocal_reference): Likewise.\n        (convert_local_reference): Likewise.\n        * tree-ssa-loop-ivopts.c (prepare_decl_rtl): Likewise.\n\nFrom-SVN: r91511", "tree": {"sha": "4b6086cd760db3d4e0eef4da7e0f58d8a24f0d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b6086cd760db3d4e0eef4da7e0f58d8a24f0d0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afe849213eed9764b4579ba081c111a0b3ddde25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe849213eed9764b4579ba081c111a0b3ddde25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe849213eed9764b4579ba081c111a0b3ddde25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe849213eed9764b4579ba081c111a0b3ddde25/comments", "author": null, "committer": null, "parents": [{"sha": "f2978871b26c69d516916d280e81cc1f9b460416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2978871b26c69d516916d280e81cc1f9b460416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2978871b26c69d516916d280e81cc1f9b460416"}], "stats": {"total": 239, "additions": 135, "deletions": 104}, "files": [{"sha": "da0f52dbb346fc1bc865a43854002704e40e1460", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -1,3 +1,19 @@\n+2004-11-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (get_inner_reference): Handle REAL/IMAGPART_EXPR.\n+\t(handled_component_p): Likewise.\n+\t* alias.c (can_address_p): Reformat and simplify.  Handle\n+\tREAL/IMAGPART_EXPR.  Do not disable addressability based on\n+\talias set zero.\n+\t* fold-const.c (build_fold_addr_expr_with_type): Remove duplicate\n+\tcheck for REAL/IMAGPART_EXPR.\n+\t* gimplify.c (gimplify_compound_lval): Likewise.\n+\t* tree-cfg.c (verify_expr): Likewise.\n+\t* tree-gimple.c (is_gimple_addressable, get_base_address): Likewise.\n+\t* tree-nested.c (build_addr, convert_nonlocal_reference): Likewise.\n+\t(convert_local_reference): Likewise.\n+\t* tree-ssa-loop-ivopts.c (prepare_decl_rtl): Likewise.\n+\n 2004-11-30  Alan Modra  <amodra@bigpond.net.au>\n \n \t* expr.c (emit_group_load_1): Don't die on const_int orig_src."}, {"sha": "3246082af23d7f5149a872af302e33a77e8cd375", "filename": "gcc/alias.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -384,30 +384,36 @@ find_base_decl (tree t)\n int\n can_address_p (tree t)\n {\n-  /* If we're at the end, it is vacuously addressable.  */\n-  if (! handled_component_p (t))\n-    return 1;\n+  while (1)\n+    {\n+      /* If we're at the end, it is vacuously addressable.  */\n+      if (!handled_component_p (t))\n+\treturn true;\n \n-  /* Bitfields are never addressable.  */\n-  else if (TREE_CODE (t) == BIT_FIELD_REF)\n-    return 0;\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase COMPONENT_REF:\n+\t  if (DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1)))\n+\t    return false;\n+\t  break;\n \n-  /* Fields are addressable unless they are marked as nonaddressable or\n-     the containing type has alias set 0.  */\n-  else if (TREE_CODE (t) == COMPONENT_REF\n-\t   && ! DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1))\n-\t   && get_alias_set (TREE_TYPE (TREE_OPERAND (t, 0))) != 0\n-\t   && can_address_p (TREE_OPERAND (t, 0)))\n-    return 1;\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  if (TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0))))\n+\t    return false;\n+\t  break;\n \n-  /* Likewise for arrays.  */\n-  else if ((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n-\t   && ! TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t   && get_alias_set (TREE_TYPE (TREE_OPERAND (t, 0))) != 0\n-\t   && can_address_p (TREE_OPERAND (t, 0)))\n-    return 1;\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n+\t  break;\n \n-  return 0;\n+\tdefault:\n+\t  /* Bitfields and casts are never addressable.  */\n+\t  return false;\n+\t}\n+\n+      t = TREE_OPERAND (t, 0);\n+    }\n }\n \n /* Return the alias set for T, which may be either a type or an"}, {"sha": "9ab2c4a0b9f9b18ff793da5ec4dab47a5e46d16e", "filename": "gcc/expr.c", "status": "modified", "additions": 81, "deletions": 53, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -5311,72 +5311,98 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n      and find the ultimate containing object.  */\n   while (1)\n     {\n-      if (TREE_CODE (exp) == BIT_FIELD_REF)\n-\tbit_offset = size_binop (PLUS_EXPR, bit_offset, TREE_OPERAND (exp, 2));\n-      else if (TREE_CODE (exp) == COMPONENT_REF)\n+      switch (TREE_CODE (exp))\n \t{\n-\t  tree field = TREE_OPERAND (exp, 1);\n-\t  tree this_offset = component_ref_field_offset (exp);\n+\tcase BIT_FIELD_REF:\n+\t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n+\t\t\t\t   TREE_OPERAND (exp, 2));\n+\t  break;\n \n-\t  /* If this field hasn't been filled in yet, don't go\n-\t     past it.  This should only happen when folding expressions\n-\t     made during type construction.  */\n-\t  if (this_offset == 0)\n-\t    break;\n+\tcase COMPONENT_REF:\n+\t  {\n+\t    tree field = TREE_OPERAND (exp, 1);\n+\t    tree this_offset = component_ref_field_offset (exp);\n \n-\t  offset = size_binop (PLUS_EXPR, offset, this_offset);\n-\t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n-\t\t\t\t   DECL_FIELD_BIT_OFFSET (field));\n+\t    /* If this field hasn't been filled in yet, don't go past it.\n+\t       This should only happen when folding expressions made during\n+\t       type construction.  */\n+\t    if (this_offset == 0)\n+\t      break;\n \n-\t  /* ??? Right now we don't do anything with DECL_OFFSET_ALIGN.  */\n-\t}\n+\t    offset = size_binop (PLUS_EXPR, offset, this_offset);\n+\t    bit_offset = size_binop (PLUS_EXPR, bit_offset,\n+\t\t\t\t     DECL_FIELD_BIT_OFFSET (field));\n \n-      else if (TREE_CODE (exp) == ARRAY_REF\n-\t       || TREE_CODE (exp) == ARRAY_RANGE_REF)\n-\t{\n-\t  tree index = TREE_OPERAND (exp, 1);\n-\t  tree low_bound = array_ref_low_bound (exp);\n-\t  tree unit_size = array_ref_element_size (exp);\n-\n-\t  /* We assume all arrays have sizes that are a multiple of a byte.\n-\t     First subtract the lower bound, if any, in the type of the\n-\t     index, then convert to sizetype and multiply by the size of the\n-\t     array element.  */\n-\t  if (! integer_zerop (low_bound))\n-\t    index = fold (build2 (MINUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t  index, low_bound));\n-\n-\t  offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t       size_binop (MULT_EXPR,\n-\t\t\t\t\t   convert (sizetype, index),\n-\t\t\t\t\t   unit_size));\n-\t}\n+\t    /* ??? Right now we don't do anything with DECL_OFFSET_ALIGN.  */\n+\t  }\n+\t  break;\n \n-      /* We can go inside most conversions: all NON_VALUE_EXPRs, all normal\n-\t conversions that don't change the mode, and all view conversions\n-\t except those that need to \"step up\" the alignment.  */\n-      else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n-\t       && ! (TREE_CODE (exp) == VIEW_CONVERT_EXPR\n-\t\t     && ! ((TYPE_ALIGN (TREE_TYPE (exp))\n-\t\t\t    > TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t\t\t   && STRICT_ALIGNMENT\n-\t\t\t   && (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t\t\t       < BIGGEST_ALIGNMENT)\n-\t\t\t   && (TYPE_ALIGN_OK (TREE_TYPE (exp))\n-\t\t\t       || TYPE_ALIGN_OK (TREE_TYPE\n-\t\t\t\t\t\t (TREE_OPERAND (exp, 0))))))\n-\t       && ! ((TREE_CODE (exp) == NOP_EXPR\n-\t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n-\t\t     && (TYPE_MODE (TREE_TYPE (exp))\n-\t\t\t == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))))\n-\tbreak;\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  {\n+\t    tree index = TREE_OPERAND (exp, 1);\n+\t    tree low_bound = array_ref_low_bound (exp);\n+\t    tree unit_size = array_ref_element_size (exp);\n+\n+\t    /* We assume all arrays have sizes that are a multiple of a byte.\n+\t       First subtract the lower bound, if any, in the type of the\n+\t       index, then convert to sizetype and multiply by the size of\n+\t       the array element.  */\n+\t    if (! integer_zerop (low_bound))\n+\t      index = fold (build2 (MINUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t    index, low_bound));\n+\n+\t    offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t         size_binop (MULT_EXPR,\n+\t\t\t\t\t     convert (sizetype, index),\n+\t\t\t\t\t     unit_size));\n+\t  }\n+\t  break;\n+\n+\tcase REALPART_EXPR:\n+\t  bit_offset = bitsize_zero_node;\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  bit_offset = build_int_cst (bitsizetype, *pbitsize);\n+\t  break;\n+\n+\t/* We can go inside most conversions: all NON_VALUE_EXPRs, all normal\n+\t   conversions that don't change the mode, and all view conversions\n+\t   except those that need to \"step up\" the alignment.  */\n+\n+\tcase NON_LVALUE_EXPR:\n+\t  break;\n+\n+\tcase NOP_EXPR:\n+\tcase CONVERT_EXPR:\n+\t  if (TYPE_MODE (TREE_TYPE (exp))\n+\t      != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t    goto done;\n+\t  break;\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  if ((TYPE_ALIGN (TREE_TYPE (exp))\n+\t       > TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t      && STRICT_ALIGNMENT\n+\t      && (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n+\t\t  < BIGGEST_ALIGNMENT)\n+\t      && (TYPE_ALIGN_OK (TREE_TYPE (exp))\n+\t\t  || TYPE_ALIGN_OK (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+\t    goto done;\n+\t  break;\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n \n       /* If any reference in the chain is volatile, the effect is volatile.  */\n       if (TREE_THIS_VOLATILE (exp))\n \t*pvolatilep = 1;\n \n       exp = TREE_OPERAND (exp, 0);\n     }\n+ done:\n \n   /* If OFFSET is constant, see if we can return the whole thing as a\n      constant bit position.  Otherwise, split it up.  */\n@@ -5499,6 +5525,8 @@ handled_component_p (tree t)\n     case ARRAY_RANGE_REF:\n     case NON_LVALUE_EXPR:\n     case VIEW_CONVERT_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n       return 1;\n \n     /* ??? Sure they are handled, but get_inner_reference may return"}, {"sha": "98b827eafdb5c2d053322c22d4bf0151e701935e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -10799,9 +10799,7 @@ build_fold_addr_expr_with_type (tree t, tree ptrtype)\n     {\n       tree base = t;\n \n-      while (handled_component_p (base)\n-\t     || TREE_CODE (base) == REALPART_EXPR\n-\t     || TREE_CODE (base) == IMAGPART_EXPR)\n+      while (handled_component_p (base))\n \tbase = TREE_OPERAND (base, 0);\n       if (DECL_P (base))\n \tTREE_ADDRESSABLE (base) = 1;"}, {"sha": "6ee49b67f31f2f677d18c270610cc04a2197e4ac", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -1427,12 +1427,8 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n      it VARRAY_TREE.  */\n   VARRAY_GENERIC_PTR_NOGC_INIT (stack, 10, \"stack\");\n \n-  /* We can either handle REALPART_EXPR, IMAGEPART_EXPR anything that\n-     handled_components can deal with.  */\n-  for (p = expr_p;\n-       (handled_component_p (*p)\n-\t|| TREE_CODE (*p) == REALPART_EXPR || TREE_CODE (*p) == IMAGPART_EXPR);\n-       p = &TREE_OPERAND (*p, 0))\n+  /* We can handle anything that get_inner_reference can deal with.  */\n+  for (p = expr_p; handled_component_p (*p); p = &TREE_OPERAND (*p, 0))\n     VARRAY_PUSH_GENERIC_PTR_NOGC (stack, *p);\n \n   gcc_assert (VARRAY_ACTIVE_SIZE (stack));"}, {"sha": "93ce053f327fd3abeb67386bbfef6c12be59b4dd", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -3238,9 +3238,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t tree) and ensure that any variable used as a prefix is marked\n \t addressable.  */\n       for (x = TREE_OPERAND (t, 0);\n-\t   (handled_component_p (x)\n-\t    || TREE_CODE (x) == REALPART_EXPR\n-\t    || TREE_CODE (x) == IMAGPART_EXPR);\n+\t   handled_component_p (x);\n \t   x = TREE_OPERAND (x, 0))\n \t;\n \n@@ -3288,8 +3286,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t that determine where to reference is either a constant or a variable,\n \t verify that the base is valid, and then show we've already checked\n \t the subtrees.  */\n-      while (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR\n-\t     || handled_component_p (t))\n+      while (handled_component_p (t))\n \t{\n \t  if (TREE_CODE (t) == COMPONENT_REF && TREE_OPERAND (t, 2))\n \t    CHECK_OP (2, \"Invalid COMPONENT_REF offset operator\");"}, {"sha": "0d52611f86736f045ce8ef8fd09edeccebf70c0c", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -161,10 +161,7 @@ bool\n is_gimple_addressable (tree t)\n {\n   return (is_gimple_id (t) || handled_component_p (t)\n-\t  || TREE_CODE (t) == REALPART_EXPR\n-\t  || TREE_CODE (t) == IMAGPART_EXPR\n \t  || INDIRECT_REF_P (t));\n-\n }\n \n /* Return true if T is function invariant.  Or rather a restricted\n@@ -430,8 +427,7 @@ get_call_expr_in (tree t)\n tree\n get_base_address (tree t)\n {\n-  while (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR\n-\t || handled_component_p (t))\n+  while (handled_component_p (t))\n     t = TREE_OPERAND (t, 0);\n   \n   if (SSA_VAR_P (t)"}, {"sha": "e5befa43a99c6602759936d0815dfcdb3a371677", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -155,8 +155,7 @@ build_addr (tree exp)\n {\n   tree base = exp;\n \n-  while (TREE_CODE (base) == REALPART_EXPR || TREE_CODE (base) == IMAGPART_EXPR\n-\t || handled_component_p (base))\n+  while (handled_component_p (base))\n     base = TREE_OPERAND (base, 0);\n \n   if (DECL_P (base))\n@@ -849,9 +848,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t anything that describes the references.  Otherwise, we lose track\n \t of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */\n       wi->val_only = true;\n-      for (; handled_component_p (t)\n-\t   || TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR;\n-\t   tp = &TREE_OPERAND (t, 0), t = *tp)\n+      for (; handled_component_p (t); tp = &TREE_OPERAND (t, 0), t = *tp)\n \t{\n \t  if (TREE_CODE (t) == COMPONENT_REF)\n \t    walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi,\n@@ -966,9 +963,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t anything that describes the references.  Otherwise, we lose track\n \t of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */\n       wi->val_only = true;\n-      for (; handled_component_p (t)\n-\t   || TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR;\n-\t   tp = &TREE_OPERAND (t, 0), t = *tp)\n+      for (; handled_component_p (t); tp = &TREE_OPERAND (t, 0), t = *tp)\n \t{\n \t  if (TREE_CODE (t) == COMPONENT_REF)\n \t    walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi,"}, {"sha": "a08923b9636081ef3cb3a99de61d3e48e8ff927d", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe849213eed9764b4579ba081c111a0b3ddde25/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=afe849213eed9764b4579ba081c111a0b3ddde25", "patch": "@@ -2162,10 +2162,9 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n     {\n     case ADDR_EXPR:\n       for (expr_p = &TREE_OPERAND (*expr_p, 0);\n-\t   (handled_component_p (*expr_p)\n-\t    || TREE_CODE (*expr_p) == REALPART_EXPR\n-\t    || TREE_CODE (*expr_p) == IMAGPART_EXPR);\n-\t   expr_p = &TREE_OPERAND (*expr_p, 0));\n+\t   handled_component_p (*expr_p);\n+\t   expr_p = &TREE_OPERAND (*expr_p, 0))\n+\tcontinue;\n       obj = *expr_p;\n       if (DECL_P (obj))\n         x = produce_memory_decl_rtl (obj, regno);"}]}