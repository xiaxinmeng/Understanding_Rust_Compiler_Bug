{"sha": "895de5a8a986d9a1c5c25d102458215dca6fa225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk1ZGU1YThhOTg2ZDlhMWM1YzI1ZDEwMjQ1ODIxNWRjYTZmYTIyNQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2006-03-24T21:59:48Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-03-24T21:59:48Z"}, "message": "[multiple changes]\n\n2006-03-23  Geoffrey Keating  <geoffk@apple.com>\n\n\tPR 26793\n\t* config/t-darwin (crt3.o): Work around bug 26840.\n\t* config/darwin-crt3.c: Rewrite.\n\t* config/darwin.h (STARTFILE_SPEC): Don't use -l for crt3.o.\n\nIndex: gcc/testsuite/ChangeLog\n2006-03-24  Geoffrey Keating  <geoffk@apple.com>\n\n\t* g++.old-deja/g++.other/init19.C: New.\n\nFrom-SVN: r112361", "tree": {"sha": "9167ce1f04f8c8057edc2a048d5102b1811fb922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9167ce1f04f8c8057edc2a048d5102b1811fb922"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/895de5a8a986d9a1c5c25d102458215dca6fa225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895de5a8a986d9a1c5c25d102458215dca6fa225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/895de5a8a986d9a1c5c25d102458215dca6fa225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895de5a8a986d9a1c5c25d102458215dca6fa225/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e713adf6454bc88303e4708378948ac831b14b10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e713adf6454bc88303e4708378948ac831b14b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e713adf6454bc88303e4708378948ac831b14b10"}], "stats": {"total": 718, "additions": 581, "deletions": 137}, "files": [{"sha": "cdb1fdcaa820204a8d823da75138240bf2c78933", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -1,3 +1,10 @@\n+2006-03-24  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tPR 26793\n+\t* config/t-darwin (crt3.o): Work around bug 26840.\n+\t* config/darwin-crt3.c: Rewrite.\n+\t* config/darwin.h (STARTFILE_SPEC): Don't use -l for crt3.o.\n+\n 2006-03-24  Carlos O'Donell  <carlos@codesourcery.com>\n \n \t* doc/invoke.texi: Document -femit-class-debug-always"}, {"sha": "1cbb4b5fc2dac122e2af12185b47c8a88304d015", "filename": "gcc/config/darwin-crt3.c", "status": "modified", "additions": 442, "deletions": 122, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fconfig%2Fdarwin-crt3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fconfig%2Fdarwin-crt3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-crt3.c?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -37,172 +37,492 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include <dlfcn.h>\n #include <stdbool.h>\n #include <stdlib.h>\n+#include <string.h>\n \n /* This file works around two different problems.\n \n    The first problem is that there is no __cxa_atexit on Mac OS versions\n-   before 10.4.  It fixes this by providing one, and having it called from\n-   a destructor.  This is not quite as good as having a real __cxa_atexit,\n-   but it's good enough to imitate the behaviour that you'd get if\n-   you didn't have one.\n+   before 10.4.  It fixes this by providing a complete atexit and\n+   __cxa_atexit emulation called from the regular atexit.\n \n-   The second problem is that on 10.4 Mac OS versions, __cxa_finalize\n-   doesn't work right: it doesn't run routines that were registered\n-   while other atexit routines are running.  This is worked around by\n-   installing our own handler so that it runs last, and repeatedly\n-   running __cxa_finalize until no new calls to __cxa_atexit are made.  */\n+   The second problem is that on all shipping versions of Mac OS,\n+   __cxa_finalize and exit() don't work right: they don't run routines\n+   that were registered while other atexit routines are running.  This\n+   is worked around by wrapping each atexit/__cxa_atexit routine with\n+   our own routine which ensures that any __cxa_atexit calls while it\n+   is running are honoured.\n \n-typedef int (*cxa_atexit_p)(void (*func) (void*), void* arg, void* dso);\n+   There are still problems which this does not solve.  Before 10.4,\n+   shared objects linked with previous compilers won't have their\n+   atexit calls properly interleaved with code compiled with newer\n+   compilers.  Also, atexit routines registered from shared objects\n+   linked with previous compilers won't get the bug fix.  */\n+\n+typedef int (*cxa_atexit_p)(void (*func) (void*), void* arg, const void* dso);\n+typedef void (*cxa_finalize_p)(const void *dso);\n+typedef int (*atexit_p)(void (*func)(void));\n+\n+/* These are from \"keymgr.h\".  */\n+extern void *_keymgr_get_and_lock_processwide_ptr (unsigned key);\n+extern int _keymgr_get_and_lock_processwide_ptr_2 (unsigned, void **);\n+extern int _keymgr_set_and_unlock_processwide_ptr (unsigned key, void *ptr);\n+\n+extern void *__keymgr_global[];\n+typedef struct _Sinfo_Node {\n+        unsigned int size ;             /*size of this node*/\n+        unsigned short major_version ;  /*API major version.*/\n+        unsigned short minor_version ;  /*API minor version.*/\n+        } _Tinfo_Node ;\n \n #ifdef __ppc__\n-void __cxa_finalize (void* dso) __attribute__((weak));\n+#define CHECK_KEYMGR_ERROR(e) \\\n+  (((_Tinfo_Node *)__keymgr_global[2])->major_version >= 4 ? (e) : 0)\n #else\n-void __cxa_finalize (void* dso);\n+#define CHECK_KEYMGR_ERROR(e) (e)\n #endif\n \n-/* new_atexit_routines is set if __cxa_finalize exists in the system C\n-   library and our copy of __cxa_atexit has been called.  */\n+/* Our globals are stored under this keymgr index.  */\n+#define KEYMGR_ATEXIT_LIST\t14\n \n-static bool new_atexit_routines;\n+/* The different kinds of callback routines.  */\n+typedef void (*atexit_callback)(void);\n+typedef void (*cxa_atexit_callback)(void *);\n \n-/* first_atexit_handler is called after all other atexit routines\n-   that were registered before __cxa_finalize is called.\n-   It may be called more than once, but is not re-entered.  */\n+/* This structure holds a routine to call.  There may be extra fields\n+   at the end of the structure that this code doesn't know about.  */\n+struct one_atexit_routine \n+{\n+  union {\n+    atexit_callback ac;\n+    cxa_atexit_callback cac;\n+  } callback;\n+  /* has_arg is 0/2/4 if 'ac' is live, 1/3/5 if 'cac' is live.  \n+     Higher numbers indicate a later version of the structure that this\n+     code doesn't understand and will ignore.  */\n+  int has_arg;\n+  void * arg;\n+};\n \n-static void\n-first_atexit_handler(void* dso)\n-{\n-  /* Keep running __cxa_finalize until no new atexit routines are\n-     registered.  \n-     Note that this means __cxa_finalize will be called at least twice,\n-     even if the first call didn't register any new routines.  */\n-  while (new_atexit_routines) {\n-    new_atexit_routines = false;\n-    __cxa_finalize (dso);\n-  };\n+struct atexit_routine_list\n+{\n+  struct atexit_routine_list * next;\n+  struct one_atexit_routine r;\n+};\n+\n+/* The various possibilities for status of atexit().  */\n+enum atexit_status {\n+  atexit_status_unknown = 0,\n+  atexit_status_missing = 1,\n+  atexit_status_broken = 2,\n+  atexit_status_working = 16\n+};\n+\n+struct keymgr_atexit_list\n+{\n+  /* Version of this list.  This code knows only about version 0.\n+     If the version is higher than 0, this code may add new atexit routines\n+     but should not attempt to run the list.  */\n+  short version;\n+  /* 1 if an atexit routine is currently being run by this code, 0\n+     otherwise.  */\n+  char running_routines;\n+  /* Holds a value from 'enum atexit_status'.  */\n+  unsigned char atexit_status;\n+  /* The list of atexit and cxa_atexit routines registered.  If\n+   atexit_status_missing it contains all routines registered while\n+   linked with this code.  If atexit_status_broken it contains all\n+   routines registered during cxa_finalize while linked with this\n+   code.  */\n+  struct atexit_routine_list *l;\n+  /* &__cxa_atexit; set if atexit_status >= atexit_status_broken.  */\n+  cxa_atexit_p cxa_atexit_f;\n+  /* &__cxa_finalize; set if atexit_status >= atexit_status_broken.  */\n+  cxa_finalize_p cxa_finalize_f;\n+  /* &atexit; set if atexit_status >= atexit_status_working\n+     or atexit_status == atexit_status_missing.  */\n+  atexit_p atexit_f;\n+};\n+\n+/* Return 0 if __cxa_atexit has the bug it has in Mac OS 10.4: it\n+   fails to call routines registered while an atexit routine is\n+   running.  Return 1 if it works properly, and -1 if an error occurred.  */\n+\n+struct atexit_data \n+{\n+  int result;\n+  cxa_atexit_p cxa_atexit;\n+};\n+\n+static void cxa_atexit_check_2 (void *arg)\n+{\n+  ((struct atexit_data *)arg)->result = 1;\n }\n \n-/* This is our wrapper around __cxa_atexit that's called if __cxa_finalize\n-   exists in the system library.  All it does is, on its first call,\n-   install first_atexit_handler; and on every call, set new_atexit_routines\n-   and pass control to the system __cxa_atexit.\n-   This proves to be somewhat more complicated than you might expect,\n-   because it may be called in a multithreaded environment.  Fortunately\n-   it turns out to be possible to do what's needed without resorting\n-   to locking.  */\n+static void cxa_atexit_check_1 (void *arg)\n+{\n+  struct atexit_data * aed = arg;\n+  if (aed->cxa_atexit (cxa_atexit_check_2, arg, arg) != 0)\n+    aed->result = -1;\n+}\n \n static int\n-cxa_atexit_wrapper (void (*func) (void*), void* arg, void* dso)\n+check_cxa_atexit (cxa_atexit_p cxa_atexit, cxa_finalize_p cxa_finalize)\n {\n-  static volatile cxa_atexit_p real_cxa_atexit;\n-  cxa_atexit_p auto_cxa_atexit = real_cxa_atexit;\n-  if (! auto_cxa_atexit)\n+  struct atexit_data aed = { 0, cxa_atexit };\n+\n+  /* We re-use &aed as the 'dso' parameter, since it's a unique address.  */\n+  if (cxa_atexit (cxa_atexit_check_1, &aed, &aed) != 0)\n+    return -1;\n+  cxa_finalize (&aed);\n+  if (aed.result == 0)\n     {\n-      void* handle = dlopen (\"/usr/lib/libSystem.B.dylib\", RTLD_NOLOAD);\n-      if (! handle)\n-\treturn -1;\n-      \n-      auto_cxa_atexit = (cxa_atexit_p)dlsym (handle, \"__cxa_atexit\");\n-      if (! auto_cxa_atexit)\n-\treturn -1;\n+      /* Call __cxa_finalize again to make sure that cxa_atexit_check_2\n+\t is removed from the list before AED goes out of scope.  */\n+      cxa_finalize (&aed);\n+      aed.result = 0;\n     }\n-  /* At this point, auto_cxa_atexit contains the address of\n-     the system __cxa_atexit.  */\n-  if (! real_cxa_atexit)\n+  return aed.result;\n+}\n+\n+#ifdef __ppc__\n+/* This comes from Csu.  It works only before 10.4.  The prototype has\n+   been altered a bit to avoid casting.  */\n+extern int _dyld_func_lookup(const char *dyld_func_name,\n+     void *address) __attribute__((visibility(\"hidden\")));\n+\n+static void our_atexit (void);\n+\n+/* We're running on 10.3.9.  Find the address of the system atexit()\n+   function.  So easy to say, so hard to do.  */\n+static atexit_p\n+find_atexit_10_3 (void)\n+{\n+  unsigned int (*dyld_image_count_fn)(void);\n+  const char *(*dyld_get_image_name_fn)(unsigned int image_index);\n+  const void *(*dyld_get_image_header_fn)(unsigned int image_index);\n+  const void *(*NSLookupSymbolInImage_fn)(const void *image, \n+\t\t\t\t\t  const char *symbolName,\n+\t\t\t\t\t  unsigned int options);\n+  void *(*NSAddressOfSymbol_fn)(const void *symbol);\n+  unsigned i, count;\n+  \n+  /* Find some dyld functions.  */\n+  _dyld_func_lookup(\"__dyld_image_count\", &dyld_image_count_fn);\n+  _dyld_func_lookup(\"__dyld_get_image_name\", &dyld_get_image_name_fn);\n+  _dyld_func_lookup(\"__dyld_get_image_header\", &dyld_get_image_header_fn);\n+  _dyld_func_lookup(\"__dyld_NSLookupSymbolInImage\", &NSLookupSymbolInImage_fn);\n+  _dyld_func_lookup(\"__dyld_NSAddressOfSymbol\", &NSAddressOfSymbol_fn);\n+\n+  /* If any of these don't exist, that's an error.  */\n+  if (! dyld_image_count_fn || ! dyld_get_image_name_fn\n+      || ! dyld_get_image_header_fn || ! NSLookupSymbolInImage_fn\n+      || ! NSAddressOfSymbol_fn)\n+    return NULL;\n+  \n+  count = dyld_image_count_fn ();\n+  for (i = 0; i < count; i++)\n     {\n-      /* Install our handler above before any other handlers\n-\t for this image, so it will be called last.  */\n-      int result = (*auto_cxa_atexit)(first_atexit_handler, dso, dso);\n-      if (result != 0)\n-\treturn result;\n-      /* Now set the global real_cxa_atexit to prevent further\n-\t installations of first_atexit_handler.  Do this after\n-\t the installation so that if another thread sees it is set,\n-\t it can be sure that first_atexit_handler really has been\n-\t installed.  */\n-      real_cxa_atexit = auto_cxa_atexit;\n+      const char * path = dyld_get_image_name_fn (i);\n+      const void * image;\n+      const void * symbol;\n+      \n+      if (strcmp (path, \"/usr/lib/libSystem.B.dylib\") != 0)\n+\tcontinue;\n+      image = dyld_get_image_header_fn (i);\n+      if (! image)\n+\treturn NULL;\n+      /* '4' is NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR.  */\n+      symbol = NSLookupSymbolInImage_fn (image, \"_atexit\", 4);\n+      if (! symbol)\n+\treturn NULL;\n+      return NSAddressOfSymbol_fn (symbol);\n     }\n-  /* At this point, we know that first_atexit_handler has been\n-     installed at least once, and real_cxa_atexit is not NULL.  */\n-  /* It's not necessary to mark new_atexit_routines as volatile, so long\n-     as this write eventually happens before this shared object is\n-     unloaded.  */\n-  new_atexit_routines = true;\n-  /* Call the original __cxa_atexit for this function.  */\n-  return (*auto_cxa_atexit)(func, arg, dso);\n+  return NULL;\n }\n-\f\n-#ifdef __ppc__\n-/* This code is used while running on 10.3.9, when __cxa_atexit doesn't\n-   exist in the system library.  10.3.9 only supported regular PowerPC,\n-   so this code isn't necessary on x86 or ppc64.  */\n+#endif\n \n-/* This structure holds a routine to call.  */\n-struct atexit_routine\n+/* Create (if necessary), find, lock, fill in, and return our globals.  \n+   Return NULL on error, in which case the globals will not be locked.  \n+   The caller should call keymgr_set_and_unlock.  */\n+static struct keymgr_atexit_list *\n+get_globals (void)\n {\n-  struct atexit_routine * next;\n-  void (*func)(void *);\n-  void * arg;\n-};\n+  struct keymgr_atexit_list * r;\n+  \n+#ifdef __ppc__\n+  /* 10.3.9 doesn't have _keymgr_get_and_lock_processwide_ptr_2 so the\n+     PPC side can't use it.  On 10.4 this just means the error gets\n+     reported a little later when\n+     _keymgr_set_and_unlock_processwide_ptr finds that the key was\n+     never locked.  */\n+  r = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n+#else\n+  void * rr;\n+  if (_keymgr_get_and_lock_processwide_ptr_2 (KEYMGR_ATEXIT_LIST, &rr))\n+    return NULL;\n+  r = rr;\n+#endif\n+  \n+  if (r == NULL)\n+    {\n+      r = calloc (sizeof (struct keymgr_atexit_list), 1);\n+      if (! r)\n+\treturn NULL;\n+    }\n+\n+  if (r->atexit_status == atexit_status_unknown)\n+    {\n+      void *handle;\n+\n+      handle = dlopen (\"/usr/lib/libSystem.B.dylib\", RTLD_NOLOAD);\n+      if (!handle)\n+\t{\n+#ifdef __ppc__\n+\t  r->atexit_status = atexit_status_missing;\n+\t  r->atexit_f = find_atexit_10_3 ();\n+\t  if (! r->atexit_f)\n+\t    goto error;\n+\t  if (r->atexit_f (our_atexit))\n+\t    goto error;\n+#else\n+\t  goto error;\n+#endif\n+\t}\n+      else\n+\t{\n+\t  int chk_result;\n+\n+\t  r->cxa_atexit_f = (cxa_atexit_p)dlsym (handle, \"__cxa_atexit\");\n+\t  r->cxa_finalize_f = (cxa_finalize_p)dlsym (handle, \"__cxa_finalize\");\n+\t  if (! r->cxa_atexit_f || ! r->cxa_finalize_f)\n+\t    goto error;\n \n-static struct atexit_routine * volatile atexit_routines_list;\n+\t  chk_result = check_cxa_atexit (r->cxa_atexit_f, r->cxa_finalize_f);\n+\t  if (chk_result == -1)\n+\t    goto error;\n+\t  else if (chk_result == 0)\n+\t    r->atexit_status = atexit_status_broken;\n+\t  else\n+\t    {\n+\t      r->atexit_f = (atexit_p)dlsym (handle, \"atexit\");\n+\t      if (! r->atexit_f)\n+\t\tgoto error;\n+\t      r->atexit_status = atexit_status_working;\n+\t    }\n+\t}\n+    }\n \n-/* If __cxa_atexit doesn't exist at all in the system library, this\n-   routine is used; it completely emulates __cxa_atexit.  \n+  return r;\n+  \n+ error:\n+  _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, r);\n+  return NULL;\n+}\n \n-   This routine has to be thread-safe, but fortunately this just means\n-   that it has to do atomic list insertion.  */\n+/* Add TO_ADD to ATEXIT_LIST.  ATEXIT_LIST may be NULL but is\n+   always the result of calling _keymgr_get_and_lock_processwide_ptr and\n+   so KEYMGR_ATEXIT_LIST is known to be locked; this routine is responsible\n+   for unlocking it.  */\n \n static int\n-cxa_atexit_substitute (void (*func) (void*), void* arg,\n-\t\t       /* The 'dso' value will always be equal to this\n-\t\t\t  object's __dso_handle.  */\n-\t\t       void* dso __attribute__((unused)))\n+add_routine (struct keymgr_atexit_list * g,\n+\t     const struct one_atexit_routine * to_add)\n {\n-  struct atexit_routine * s = malloc (sizeof (struct atexit_routine));\n-  struct atexit_routine * next, * old_next;\n+  struct atexit_routine_list * s\n+    = malloc (sizeof (struct atexit_routine_list));\n+  int result;\n+  \n   if (!s)\n-    return -1;\n-  s->func = func;\n-  s->arg = arg;\n-  next = atexit_routines_list;\n-  do {\n-    s->next = old_next = next;\n-    next = __sync_val_compare_and_swap (&atexit_routines_list, old_next, s);\n-  } while (next != old_next);\n-  return 0;\n+    {\n+      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+      return -1;\n+    }\n+  s->r = *to_add;\n+  s->next = g->l;\n+  g->l = s;\n+  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+  return CHECK_KEYMGR_ERROR (result) == 0 ? 0 : -1;\n }\n \n-/* The routines added in cxa_atexit_substitute get run here, in a destructor.\n-   This routine doesn't have to be thread-safe.  */\n+/* This runs the routines in G->L up to STOP.  */\n+static struct keymgr_atexit_list *\n+run_routines (struct keymgr_atexit_list *g,\n+\t      struct atexit_routine_list *stop)\n+{\n+  for (;;)\n+    {\n+      struct atexit_routine_list * cur = g->l;\n+      if (! cur || cur == stop)\n+\tbreak;\n+      g->l = cur->next;\n+      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+\n+      switch (cur->r.has_arg) {\n+      case 0: case 2: case 4:\n+\tcur->r.callback.ac ();\n+\tbreak;\n+      case 1: case 3: case 5:\n+\tcur->r.callback.cac (cur->r.arg);\n+\tbreak;\n+      default:\n+\t/* Don't understand, so don't call it.  */\n+\tbreak;\n+      }\n+      free (cur);\n+\n+      g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n+      if (! g)\n+\tbreak;\n+    }\n+  return g;\n+}\n+\n+/* Call the routine described by ROUTINE_PARAM and then call any\n+   routines added to KEYMGR_ATEXIT_LIST while that routine was\n+   running, all with in_cxa_finalize set.  */\n \n-static void cxa_dtor (void) __attribute__((destructor));\n static void\n-cxa_dtor (void)\n+cxa_atexit_wrapper (void* routine_param)\n {\n-  while (atexit_routines_list)\n+  struct one_atexit_routine * routine = routine_param;\n+  struct keymgr_atexit_list *g;\n+  struct atexit_routine_list * base = NULL;\n+  char prev_running = 0;\n+  \n+  g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n+  if (g)\n     {\n-      struct atexit_routine * working_list = atexit_routines_list;\n-      atexit_routines_list = NULL;\n-      while (working_list)\n+      prev_running = g->running_routines;\n+      g->running_routines = 1;\n+      base = g->l;\n+      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+    }\n+\n+  if (routine->has_arg)\n+    routine->callback.cac (routine->arg);\n+  else\n+    routine->callback.ac ();\n+\n+  if (g)\n+    g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n+  if (g)\n+    g = run_routines (g, base);\n+  if (g)\n+    {\n+      g->running_routines = prev_running;\n+      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+    }\n+}\n+\n+#ifdef __ppc__\n+/* This code is used while running on 10.3.9, when __cxa_atexit doesn't\n+   exist in the system library.  10.3.9 only supported regular PowerPC,\n+   so this code isn't necessary on x86 or ppc64.  */\n+\n+/* This routine is called from the system atexit(); it runs everything\n+   registered on the KEYMGR_ATEXIT_LIST.  */\n+\n+static void\n+our_atexit (void)\n+{\n+  struct keymgr_atexit_list *g;\n+  char prev_running;\n+\n+  g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n+  if (! g || g->version != 0 || g->atexit_status != atexit_status_missing)\n+    return;\n+  \n+  prev_running = g->running_routines;\n+  g->running_routines = 1;\n+  g = run_routines (g, NULL);\n+  if (! g)\n+    return;\n+  g->running_routines = prev_running;\n+  _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+}\n+#endif\n+\n+/* This is our wrapper around atexit and __cxa_atexit.  It will return\n+   nonzero if an error occurs, and otherwise:\n+   - if in_cxa_finalize is set, or running on 10.3.9, add R to\n+     KEYMGR_ATEXIT_LIST; or\n+   - call the system __cxa_atexit to add cxa_atexit_wrapper with an argument\n+     that indicates how cxa_atexit_wrapper should call R.  */\n+\n+static int\n+atexit_common (const struct one_atexit_routine *r, const void *dso)\n+{\n+  struct keymgr_atexit_list *g = get_globals ();\n+\n+  if (! g)\n+    return -1;\n+  \n+  if (g->running_routines || g->atexit_status == atexit_status_missing)\n+    return add_routine (g, r);\n+\n+  if (g->atexit_status >= atexit_status_working)\n+    {\n+      int result;\n+      if (r->has_arg)\n \t{\n-\t  struct atexit_routine * called_routine = working_list;\n-\t  working_list->func (working_list->arg);\n-\t  working_list = working_list->next;\n-\t  free (called_routine);\n+\t  cxa_atexit_p cxa_atexit = g->cxa_atexit_f;\n+\t  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST,\n+\t\t\t\t\t\t\t   g);\n+\t  if (CHECK_KEYMGR_ERROR (result))\n+\t    return -1;\n+\t  return cxa_atexit (r->callback.cac, r->arg, dso);\n \t}\n+      else\n+\t{\n+\t  atexit_p atexit_f = g->atexit_f;\n+\t  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST,\n+\t\t\t\t\t\t\t   g);\n+\t  if (CHECK_KEYMGR_ERROR (result))\n+\t    return -1;\n+\t  return atexit_f (r->callback.ac);\n+\t}\n+    }\n+  else\n+    {\n+      cxa_atexit_p cxa_atexit = g->cxa_atexit_f;\n+      struct one_atexit_routine *alloced;\n+      int result;\n+\n+      result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n+      if (CHECK_KEYMGR_ERROR (result))\n+\treturn -1;\n+\n+      alloced = malloc (sizeof (struct one_atexit_routine));\n+      if (! alloced)\n+\treturn -1;\n+      *alloced = *r;\n+      return cxa_atexit (cxa_atexit_wrapper, alloced, dso);\n     }\n }\n-#endif\n \n-int __cxa_atexit (void (*func) (void*), void* arg, \n-\t\t  void* dso) __attribute__((visibility(\"hidden\")));\n+/* These are the actual replacement routines; they just funnel into\n+   atexit_common.  */\n+\n+int __cxa_atexit (cxa_atexit_callback func, void* arg, \n+\t\t  const void* dso) __attribute__((visibility(\"hidden\")));\n+\n int\n-__cxa_atexit (void (*func) (void*), void* arg, void* dso)\n+__cxa_atexit (cxa_atexit_callback func, void* arg, const void* dso)\n {\n-#ifdef __ppc__\n-  if (! __cxa_finalize)\n-    return cxa_atexit_substitute (func, arg, dso);\n-#endif\n-  return cxa_atexit_wrapper (func, arg, dso);\n+  struct one_atexit_routine r;\n+  r.callback.cac = func;\n+  r.has_arg = 1;\n+  r.arg = arg;\n+  return atexit_common (&r, dso);\n+}\n+\n+int atexit (atexit_callback func) __attribute__((visibility(\"hidden\")));\n+\n+int\n+atexit (atexit_callback func)\n+{\n+  struct one_atexit_routine r;\n+  r.callback.ac = func;\n+  r.has_arg = 0;\n+  return atexit_common (&r, NULL);\n }"}, {"sha": "eef5e451311110487d4baef8c26bb43a2eb720ec", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -341,7 +341,7 @@ Boston, MA 02110-1301, USA.  */\n                       %{!static:%{object:-lcrt0.o}\t\t\t    \\\n                                 %{!object:%{preload:-lcrt0.o}\t\t    \\\n                                   %{!preload:-lcrt1.o %(darwin_crt2)}}}}}}  \\\n-  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= -lcrt3.o)}\"\n+  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}\"\n \n /* The native Darwin linker doesn't necessarily place files in the order\n    that they're specified on the link line.  Thus, it is pointless"}, {"sha": "b6ee9c025d43ba09c8d8b83623e6c4ba38c3becc", "filename": "gcc/config/t-darwin", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fconfig%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fconfig%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-darwin?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -14,9 +14,11 @@ gt-darwin.h : s-gtype ; @true\n \n # How to build crt3.o\n EXTRA_MULTILIB_PARTS=crt3.o\n+# Pass -fno-tree-dominator-opts to work around bug 26840.\n $(T)crt3$(objext): $(srcdir)/config/darwin-crt3.c $(GCC_PASSES) \\\n \t$(TCONFIG_H) stmp-int-hdrs tsystem.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) \\\n+\t  -fno-tree-dominator-opts \\\n \t  -c $(srcdir)/config/darwin-crt3.c -o $(T)crt3$(objext)\n \n # Use unwind-dw2-fde-darwin"}, {"sha": "5b1894c5be001f62fec412123faba760c12ca4d4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -5326,17 +5326,19 @@ is_c_family (void)\n {\n   unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n \n-  return (lang == DW_LANG_C || lang == DW_LANG_C89\n-\t  || lang == DW_LANG_C_plus_plus);\n+  return (lang == DW_LANG_C || lang == DW_LANG_C89 || lang == DW_LANG_ObjC\n+\t  || lang == DW_LANG_C99\n+\t  || lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus);\n }\n \n /* Return TRUE if the language is C++.  */\n \n static inline bool\n is_cxx (void)\n {\n-  return (get_AT_unsigned (comp_unit_die, DW_AT_language)\n-\t  == DW_LANG_C_plus_plus);\n+  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  \n+  return lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus;\n }\n \n /* Return TRUE if the language is Fortran.  */\n@@ -9927,6 +9929,23 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n }\n \n+/* Determine whether the evaluation of EXPR references any variables\n+   or functions which aren't otherwise used (and therefore may not be\n+   output).  */\n+static tree\n+reference_to_unused (tree * tp, int * walk_subtrees,\n+\t\t     void * data ATTRIBUTE_UNUSED)\n+{\n+  if (! EXPR_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n+    *walk_subtrees = 0;\n+  \n+  if (DECL_P (*tp) && ! TREE_PUBLIC (*tp) && ! TREE_USED (*tp)\n+      && ! TREE_ASM_WRITTEN (*tp))\n+    return *tp;\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Generate an RTL constant from a decl initializer INIT with decl type TYPE,\n    for use in a later add_const_value_attribute call.  */\n \n@@ -9953,15 +9972,16 @@ rtl_for_decl_init (tree init, tree type)\n \trtl = gen_rtx_CONST_STRING (VOIDmode,\n \t\t\t\t    ggc_strdup (TREE_STRING_POINTER (init)));\n     }\n+  /* Although DWARF could easily handle other kinds of aggregates, we\n+     have no way to represent such values as RTL constants, so skip\n+     those.  */\n+  else if (AGGREGATE_TYPE_P (type))\n+    ;\n   /* If the initializer is something that we know will expand into an\n-     immediate RTL constant, expand it now.  Expanding anything else\n-     tends to produce unresolved symbols; see debug/5770 and c++/6381.  */\n-  /* Aggregate, vector, and complex types may contain constructors that may\n-     result in code being generated when expand_expr is called, so we can't\n-     handle them here.  Integer and float are useful and safe types to handle\n-     here.  */\n-  else if ((INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type))\n-\t   && initializer_constant_valid_p (init, type) == null_pointer_node)\n+     immediate RTL constant, expand it now.  We must be careful not to\n+     reference variables which won't be output.  */\n+  else if (initializer_constant_valid_p (init, type)\n+\t   && ! walk_tree (&init, reference_to_unused, NULL, NULL))\n     {\n       rtl = expand_expr (init, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n \n@@ -10325,6 +10345,9 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       add_AT_location_description (die, attr, descr);\n       return;\n     }\n+  /* None of that worked, so it must not really have a location;\n+     try adding a constant value attribute from the DECL_INITIAL.  */\n+  tree_add_const_value_attribute (die, decl);\n }\n \n /* If we don't have a copy of this variable in memory for some reason (such\n@@ -12204,6 +12227,10 @@ gen_compile_unit_die (const char *filename)\n     language = DW_LANG_Pascal83;\n   else if (strcmp (language_string, \"GNU Java\") == 0)\n     language = DW_LANG_Java;\n+  else if (strcmp (language_string, \"GNU Objective-C\") == 0)\n+    language = DW_LANG_ObjC;\n+  else if (strcmp (language_string, \"GNU Objective-C++\") == 0)\n+    language = DW_LANG_ObjC_plus_plus;\n   else\n     language = DW_LANG_C89;\n \n@@ -13314,8 +13341,7 @@ dwarf2out_decl (tree decl)\n \t{\n \t  /* OK, we need to generate one for `bool' so GDB knows what type\n \t     comparisons have.  */\n-\t  if ((get_AT_unsigned (comp_unit_die, DW_AT_language)\n-\t       == DW_LANG_C_plus_plus)\n+\t  if (is_cxx ()\n \t      && TREE_CODE (TREE_TYPE (decl)) == BOOLEAN_TYPE\n \t      && ! DECL_IGNORED_P (decl))\n \t    modified_type_die (TREE_TYPE (decl), 0, 0, NULL);"}, {"sha": "6857acec979c61dfb035ce3c5f7d58f2417ac9b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -1,3 +1,7 @@\n+2006-03-24  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* g++.old-deja/g++.other/init19.C: New.\n+\n 2006-03-24  David Edelsohn  <edelsohn@gnu.org>\n \n \t* g++.dg/eh/spbp.C: Skip on AIX."}, {"sha": "297ae781ec2cc9274b2b77d9ee22d35e11419e72", "filename": "gcc/testsuite/g++.old-deja/g++.other/init19.C", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895de5a8a986d9a1c5c25d102458215dca6fa225/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit19.C?ref=895de5a8a986d9a1c5c25d102458215dca6fa225", "patch": "@@ -0,0 +1,85 @@\n+// { dg-do run }\n+#include <stdlib.h>\n+\n+#define assert(x) do { if (! (x)) abort(); } while (0)\n+\n+int count = 0;\n+\n+class A\n+{\n+public:\n+\texplicit A(int i);\n+\t~A();\n+\n+\tint i;\n+\n+\tA(const A&);\n+\tA& operator=(const A&);\n+};\n+\n+A::A(int i_)\n+\t: i(i_)\n+{\n+}\n+\n+A::~A()\n+{\n+\tassert(++count == i);\n+\ti = -1;\n+}\n+\n+extern \"C\" {\n+\n+void one()\n+{\n+\tstatic bool second_time;\n+\tif (second_time)\n+\t\tassert(++count == 9);\n+\telse\n+\t{\n+\t\tassert(++count == 1);\n+\t\tsecond_time = true;\n+\t}\n+\tstatic A a(10);\n+\tassert(a.i == 10);\n+}\n+\n+void two()\n+{\n+\tassert(++count == 7);\n+\tstatic A a(8);\n+\tassert(a.i == 8);\n+}\n+\n+void three()\n+{\n+\tassert(++count == 2);\n+\tstatic A a(6);\n+\tassert(a.i == 6);\n+}\n+\n+void five()\n+{\n+\tassert(++count == 4);\n+\tstatic A a(5);\n+\tassert(a.i == 5);\n+}\n+\n+void four()\n+{\n+\tassert(++count == 3);\n+\tatexit(five);\n+}\n+\n+}\n+\n+A zero(11);\n+\n+int main()\n+{\n+\tone();\n+\tatexit(one);\n+\tatexit(two);\n+\tthree();\n+\tatexit(four);\n+}"}]}