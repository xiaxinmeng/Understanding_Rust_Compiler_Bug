{"sha": "999c066978f30fa90fb38b35017db4aec97f8c2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk5YzA2Njk3OGYzMGZhOTBmYjM4YjM1MDE3ZGI0YWVjOTdmOGMyYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-14T18:39:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-14T18:39:16Z"}, "message": "ifcvt.c (find_cond_trap): New.\n\n        * ifcvt.c (find_cond_trap): New.\n        (find_if_header): Call it.\n        (merge_if_block): Relax existing jump sanity check.\n        * jump.c (jump_optimize_1): Remove conditional trap handling.\n\n\t* gcc.dg/iftrap-1.c: New.\n\nFrom-SVN: r44006", "tree": {"sha": "4e62c7a3872a1090591940a36b0d9134005d4e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e62c7a3872a1090591940a36b0d9134005d4e78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/999c066978f30fa90fb38b35017db4aec97f8c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999c066978f30fa90fb38b35017db4aec97f8c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/999c066978f30fa90fb38b35017db4aec97f8c2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999c066978f30fa90fb38b35017db4aec97f8c2b/comments", "author": null, "committer": null, "parents": [{"sha": "386eda2e22ce6fa01bef774257be8c3e4f426ec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/386eda2e22ce6fa01bef774257be8c3e4f426ec0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/386eda2e22ce6fa01bef774257be8c3e4f426ec0"}], "stats": {"total": 262, "additions": 180, "deletions": 82}, "files": [{"sha": "11aec1281cd8e9b39657602de8c691c9fff76346", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=999c066978f30fa90fb38b35017db4aec97f8c2b", "patch": "@@ -1,3 +1,10 @@\n+2001-07-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* ifcvt.c (find_cond_trap): New.\n+\t(find_if_header): Call it.\n+\t(merge_if_block): Relax existing jump sanity check.\n+\t* jump.c (jump_optimize_1): Remove conditional trap handling.\n+\n 2001-07-14  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/pa/pa.c (emit_hpdiv_const): Return reg is r2 for 64-bit"}, {"sha": "6196522d228ee9a872ed101abcc26a2c88800b39", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 131, "deletions": 3, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=999c066978f30fa90fb38b35017db4aec97f8c2b", "patch": "@@ -48,6 +48,12 @@\n #ifndef HAVE_decscc\n #define HAVE_decscc 0\n #endif\n+#ifndef HAVE_trap\n+#define HAVE_trap 0\n+#endif\n+#ifndef HAVE_conditional_trap\n+#define HAVE_conditional_trap 0\n+#endif\n \n #ifndef MAX_CONDITIONAL_EXECUTE\n #define MAX_CONDITIONAL_EXECUTE   (BRANCH_COST + 1)\n@@ -97,6 +103,7 @@ static int find_if_header\t\tPARAMS ((basic_block));\n static int find_if_block\t\tPARAMS ((basic_block, edge, edge));\n static int find_if_case_1\t\tPARAMS ((basic_block, edge, edge));\n static int find_if_case_2\t\tPARAMS ((basic_block, edge, edge));\n+static int find_cond_trap\t\tPARAMS ((basic_block, edge, edge));\n static int find_memory\t\t\tPARAMS ((rtx *, void *));\n static int dead_or_predicable\t\tPARAMS ((basic_block, basic_block,\n \t\t\t\t\t\t basic_block, rtx, int));\n@@ -1757,10 +1764,9 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n       if (combo_bb->succ == NULL_EDGE)\n \tabort ();\n \n-      /* There should sill be a branch at the end of the THEN or ELSE\n+      /* There should still be a branch at the end of the THEN or ELSE\n          blocks taking us to our final destination.  */\n-      if (! any_uncondjump_p (combo_bb->end)\n-          && ! returnjump_p (combo_bb->end))\n+      if (GET_CODE (combo_bb->end) != JUMP_INSN)\n \tabort ();\n     }\n \n@@ -1835,6 +1841,9 @@ find_if_header (test_bb)\n \n   if (find_if_block (test_bb, then_edge, else_edge))\n     goto success;\n+  if (HAVE_trap && HAVE_conditional_trap\n+      && find_cond_trap (test_bb, then_edge, else_edge))\n+    goto success;\n   if (post_dominators\n       && (! HAVE_conditional_execution || reload_completed))\n     {\n@@ -1965,6 +1974,125 @@ find_if_block (test_bb, then_edge, else_edge)\n   return process_if_block (test_bb, then_bb, else_bb, join_bb);\n }\n \n+/* Convert a branch over a trap, or a branch to a trap,\n+   into a conditional trap.  */\n+\n+static int\n+find_cond_trap (test_bb, then_edge, else_edge)\n+     basic_block test_bb;\n+     edge then_edge, else_edge;\n+{\n+  basic_block then_bb, else_bb, join_bb, trap_bb;\n+  rtx trap, jump, cond, cond_earliest, seq;\n+  enum rtx_code code;\n+\n+  then_bb = then_edge->dest;\n+  else_bb = else_edge->dest;\n+  join_bb = NULL;\n+\n+  /* Locate the block with the trap instruction.  */\n+  /* ??? While we look for no successors, we really ought to allow\n+     EH successors.  Need to fix merge_if_block for that to work.  */\n+  /* ??? We can't currently handle merging the blocks if they are not\n+     already adjacent.  Prevent losage in merge_if_block by detecting\n+     this now.  */\n+  if (then_bb->succ == NULL)\n+    {\n+      trap_bb = then_bb;\n+      if (else_bb->index != then_bb->index + 1)\n+\treturn FALSE;\n+      join_bb = else_bb;\n+      else_bb = NULL;\n+    }\n+  else if (else_bb->succ == NULL)\n+    {\n+      trap_bb = else_bb;\n+      if (else_bb->index != then_bb->index + 1)\n+\telse_bb = NULL;\n+      else if (then_bb->succ\n+\t  && ! then_bb->succ->succ_next\n+\t  && ! (then_bb->succ->flags & EDGE_COMPLEX)\n+\t  && then_bb->succ->dest->index == else_bb->index + 1)\n+\tjoin_bb = then_bb->succ->dest;\n+    }\n+  else\n+    return FALSE;\n+\n+  /* The only instruction in the THEN block must be the trap.  */\n+  trap = first_active_insn (trap_bb);\n+  if (! (trap == trap_bb->end\n+\t && GET_CODE (PATTERN (trap)) == TRAP_IF\n+         && TRAP_CONDITION (PATTERN (trap)) == const_true_rtx))\n+    return FALSE;\n+\n+  if (rtl_dump_file)\n+    {\n+      if (trap_bb == then_bb)\n+\tfprintf (rtl_dump_file,\n+\t\t \"\\nTRAP-IF block found, start %d, trap %d\",\n+\t\t test_bb->index, then_bb->index);\n+      else\n+\tfprintf (rtl_dump_file,\n+\t\t \"\\nTRAP-IF block found, start %d, then %d, trap %d\",\n+\t\t test_bb->index, then_bb->index, trap_bb->index);\n+      if (join_bb)\n+\tfprintf (rtl_dump_file, \", join %d\\n\", join_bb->index);\n+      else\n+\tfputc ('\\n', rtl_dump_file);\n+    }\n+\n+  /* If this is not a standard conditional jump, we can't parse it.  */\n+  jump = test_bb->end;\n+  cond = noce_get_condition (jump, &cond_earliest);\n+  if (! cond)\n+    return FALSE;\n+\n+  /* If the conditional jump is more than just a conditional jump,\n+     then we can not do if-conversion on this block.  */\n+  if (! onlyjump_p (jump))\n+    return FALSE;\n+\n+  /* We must be comparing objects whose modes imply the size.  */\n+  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n+    return FALSE;\n+\n+  /* Reverse the comparison code, if necessary.  */\n+  code = GET_CODE (cond);\n+  if (then_bb == trap_bb)\n+    {\n+      code = reversed_comparison_code (cond, jump);\n+      if (code == UNKNOWN)\n+\treturn FALSE;\n+    }\n+\n+  /* Attempt to generate the conditional trap.  */\n+  seq = gen_cond_trap (code, XEXP (cond, 0), XEXP (cond, 1),\n+\t\t       TRAP_CODE (PATTERN (trap)));\n+  if (seq == NULL)\n+    return FALSE;\n+\n+  /* Emit the new insns before cond_earliest; delete the old jump\n+     and trap insns.  */\n+\n+  emit_insn_before (seq, cond_earliest);\n+\n+  test_bb->end = PREV_INSN (jump);\n+  flow_delete_insn (jump);\n+\n+  trap_bb->end = PREV_INSN (trap);\n+  flow_delete_insn (trap);\n+\n+  /* Merge the blocks!  */\n+  if (trap_bb != then_bb && ! else_bb)\n+    {\n+      flow_delete_block (trap_bb);\n+      num_removed_blocks++;\n+    }\n+  merge_if_block (test_bb, then_bb, else_bb, join_bb);\n+\n+  return TRUE;\n+}\n+\n /* Look for IF-THEN-ELSE cases in which one of THEN or ELSE is\n    transformable, but not necessarily the other.  There need be no\n    JOIN block."}, {"sha": "f98da2d368179532d3c9637fd067ed23c83a121b", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=999c066978f30fa90fb38b35017db4aec97f8c2b", "patch": "@@ -208,9 +208,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n   int first = 1;\n   int max_uid = 0;\n   rtx last_insn;\n-#ifdef HAVE_trap\n-  enum rtx_code reversed_code;\n-#endif\n \n   cross_jump_death_matters = (cross_jump == 2);\n   max_uid = init_label_info (f) + 1;\n@@ -498,82 +495,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t      changed = 1;\n \t      next = NEXT_INSN (insn);\n \t    }\n-\n-#ifdef HAVE_trap\n-\t  /* Detect a conditional jump jumping over an unconditional trap.  */\n-\t  if (HAVE_trap\n-\t      && this_is_any_condjump && this_is_onlyjump\n-\t      && reallabelprev != 0\n-\t      && GET_CODE (reallabelprev) == INSN\n-\t      && GET_CODE (PATTERN (reallabelprev)) == TRAP_IF\n-\t      && TRAP_CONDITION (PATTERN (reallabelprev)) == const_true_rtx\n-\t      && prev_active_insn (reallabelprev) == insn\n-\t      && no_labels_between_p (insn, reallabelprev)\n-\t      && (temp2 = get_condition (insn, &temp4))\n-\t      && ((reversed_code = reversed_comparison_code (temp2, insn))\n-\t\t  != UNKNOWN))\n-\t    {\n-\t      rtx new = gen_cond_trap (reversed_code,\n-\t\t\t\t       XEXP (temp2, 0), XEXP (temp2, 1),\n-\t\t\t\t       TRAP_CODE (PATTERN (reallabelprev)));\n-\n-\t      if (new)\n-\t\t{\n-\t\t  emit_insn_before (new, temp4);\n-\t\t  delete_insn (reallabelprev);\n-\t\t  delete_jump (insn);\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  /* Detect a jump jumping to an unconditional trap.  */\n-\t  else if (HAVE_trap && this_is_onlyjump\n-\t\t   && (temp = next_active_insn (JUMP_LABEL (insn)))\n-\t\t   && GET_CODE (temp) == INSN\n-\t\t   && GET_CODE (PATTERN (temp)) == TRAP_IF\n-\t\t   && (this_is_any_uncondjump\n-\t\t       || (this_is_any_condjump\n-\t\t\t   && (temp2 = get_condition (insn, &temp4)))))\n-\t    {\n-\t      rtx tc = TRAP_CONDITION (PATTERN (temp));\n-\n-\t      if (tc == const_true_rtx\n-\t\t  || (! this_is_any_uncondjump && rtx_equal_p (temp2, tc)))\n-\t\t{\n-\t\t  rtx new;\n-\t\t  /* Replace an unconditional jump to a trap with a trap.  */\n-\t\t  if (this_is_any_uncondjump)\n-\t\t    {\n-\t\t      emit_barrier_after (emit_insn_before (gen_trap (), insn));\n-\t\t      delete_jump (insn);\n-\t\t      changed = 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t  new = gen_cond_trap (GET_CODE (temp2), XEXP (temp2, 0),\n-\t\t\t\t       XEXP (temp2, 1),\n-\t\t\t\t       TRAP_CODE (PATTERN (temp)));\n-\t\t  if (new)\n-\t\t    {\n-\t\t      emit_insn_before (new, temp4);\n-\t\t      delete_jump (insn);\n-\t\t      changed = 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      /* If the trap condition and jump condition are mutually\n-\t\t exclusive, redirect the jump to the following insn.  */\n-\t      else if (GET_RTX_CLASS (GET_CODE (tc)) == '<'\n-\t\t       && this_is_any_condjump\n-\t\t       && swap_condition (GET_CODE (temp2)) == GET_CODE (tc)\n-\t\t       && rtx_equal_p (XEXP (tc, 0), XEXP (temp2, 0))\n-\t\t       && rtx_equal_p (XEXP (tc, 1), XEXP (temp2, 1))\n-\t\t       && redirect_jump (insn, get_label_after (temp), 1))\n-\t\t{\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-#endif\n \t  else\n \t    {\n \t      /* Now that the jump has been tensioned,"}, {"sha": "3075c3f90b82715f5d61b4bce4e88d6f3c32a403", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=999c066978f30fa90fb38b35017db4aec97f8c2b", "patch": "@@ -1,3 +1,7 @@\n+2001-07-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/iftrap-1.c: New.\n+\n 2001-07-11  David Billinghurst <David.Billinghurst@riotinto.com>\n \n \t* g77.f-torture/execute/intrinsic77.f: New test."}, {"sha": "a9f6a77edbe4c612a498a623299cf91caab9e32c", "filename": "gcc/testsuite/gcc.dg/iftrap-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Ftestsuite%2Fgcc.dg%2Fiftrap-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999c066978f30fa90fb38b35017db4aec97f8c2b/gcc%2Ftestsuite%2Fgcc.dg%2Fiftrap-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fiftrap-1.c?ref=999c066978f30fa90fb38b35017db4aec97f8c2b", "patch": "@@ -0,0 +1,38 @@\n+/* Verify that we optimize to conditional traps.  */\n+/* { dg-options \"-O\" } */\n+/* { dg-do compile { target rs6000-* powerpc-* sparc*-* } } */\n+/* { dg-final { scan-assembler-not iftrap-1.c \"^\\t(trap|ta)\\[ \\t\\]\" } } */\n+\n+void f1(int p)\n+{\n+  if (p)\n+    __builtin_trap();\n+}\n+\n+void f2(int p)\n+{\n+  if (p)\n+    __builtin_trap();\n+  else\n+    bar();\n+}\n+\n+void f3(int p)\n+{\n+  if (p)\n+    bar();\n+  else\n+    __builtin_trap();\n+}\n+\n+void f4(int p, int q)\n+{\n+  if (p)\n+    {\n+      bar();\n+      if (q)\n+\tbar();\n+    }\n+  else\n+    __builtin_trap();\n+}"}]}