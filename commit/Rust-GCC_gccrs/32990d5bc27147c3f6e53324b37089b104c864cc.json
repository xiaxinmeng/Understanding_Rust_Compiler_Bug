{"sha": "32990d5bc27147c3f6e53324b37089b104c864cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI5OTBkNWJjMjcxNDdjM2Y2ZTUzMzI0YjM3MDg5YjEwNGM4NjRjYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-09-24T14:37:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-09-24T14:37:02Z"}, "message": "re PR middle-end/45234 (ICE in expand_call, at calls.c:2845 when passing aligned function argument from unaligned stack after alloca)\n\n\tPR middle-end/45234\n\t* rtl.h (enum global_rtl_index): Add\n\tGR_VIRTUAL_PREFERRED_STACK_BOUNDARY.\n\t(LAST_VIRTUAL_POINTER_REGISTER): Define.\n\t(virtual_preferred_stack_boundary_rtx,\n\tVIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM): Define.\n\t(LAST_VIRTUAL_REGISTER): Increase by one.\n\t(REGNO_PTR_FRAME_P): Use LAST_VIRTUAL_POINTER_REGISTER\n\tinstead of LAST_VIRTUAL_REGISTER.\n\t* function.c (instantiate_new_reg): Handle\n\tvirtual_preferred_stack_boundary_rtx.\n\t* emit-rtl.c (init_virtual_regs): Handle\n\tVIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM.\n\t(init_emit_regs): Initialize virtual_preferred_stack_boundary_rtx.\n\t* explow.c (round_push): If crtl->preferred_stack_boundary\n\tis smaller than MAX_SUPPORTED_STACK_ALIGNMENT, use\n\tvirtual_preferred_stack_boundary_rtx alignment instead of\n\tcrtl->preferred_stack_boundary alignment.\n\t(allocate_dynamic_stack_space): Use CONST_INT_P and REG_P\n\tmacros.  Never decrease crtl->preferred_stack_boundary,\n\tuse crtl->preferred_stack_boundary or MAX_SUPPORTED_STACK_ALIGNMENT\n\tinstead of PREFERRED_STACK_BOUNDARY.  Don't modify\n\tstack_pointer_delta in dynamic allocation, even when size\n\tis constant.\n\t(probe_stack_range, anti_adjust_stack_and_probe): Use CONST_INT_P\n\tmacro.\n\t* print-rtl.c (print_rtx): Handle\n\tVIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM.\n\t* config/alpha/alpha.h (NONSTRICT_REG_OK_FP_BASE_P): Use\n\tLAST_VIRTUAL_POINTER_REGISTER instead of LAST_VIRTUAL_REGISTER.\n\t* config/frv/frv.c (frv_emit_movsi): Likewise.\n\t* config/arm/arm.c (thumb1_legitimate_address_p): Likewise.\n\t* config/rs6000/rs6000.c (virtual_stack_registers_memory_p):\n\tLikewise.\n\n\t* gcc.dg/torture/stackalign/alloca-6.c: New test.\n\t* gcc.target/i386/pr45234.c: New test.\n\n\tRevert:\n\t2010-09-17  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR middle-end/45234\n\t* calls.c (expand_call): Make sure that all variable sized\n\tadjustments are multiple of preferred stack boundary after\n\tstack alignment.\n\nFrom-SVN: r164593", "tree": {"sha": "96c049e5b6aaaf1182db5e68e2f764aacc90ede6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96c049e5b6aaaf1182db5e68e2f764aacc90ede6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32990d5bc27147c3f6e53324b37089b104c864cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32990d5bc27147c3f6e53324b37089b104c864cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32990d5bc27147c3f6e53324b37089b104c864cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32990d5bc27147c3f6e53324b37089b104c864cc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d1b7f135d4507cc748a09256d1e8c37e9222d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d1b7f135d4507cc748a09256d1e8c37e9222d80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d1b7f135d4507cc748a09256d1e8c37e9222d80"}], "stats": {"total": 230, "additions": 185, "deletions": 45}, "files": [{"sha": "e957d02a335e9d5a969a06bdf829d768cdfcd56b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -1,3 +1,48 @@\n+2010-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/45234\n+\t* rtl.h (enum global_rtl_index): Add\n+\tGR_VIRTUAL_PREFERRED_STACK_BOUNDARY.\n+\t(LAST_VIRTUAL_POINTER_REGISTER): Define.\n+\t(virtual_preferred_stack_boundary_rtx,\n+\tVIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM): Define.\n+\t(LAST_VIRTUAL_REGISTER): Increase by one.\n+\t(REGNO_PTR_FRAME_P): Use LAST_VIRTUAL_POINTER_REGISTER\n+\tinstead of LAST_VIRTUAL_REGISTER.\n+\t* function.c (instantiate_new_reg): Handle\n+\tvirtual_preferred_stack_boundary_rtx.\n+\t* emit-rtl.c (init_virtual_regs): Handle\n+\tVIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM.\n+\t(init_emit_regs): Initialize virtual_preferred_stack_boundary_rtx.\n+\t* explow.c (round_push): If crtl->preferred_stack_boundary\n+\tis smaller than MAX_SUPPORTED_STACK_ALIGNMENT, use\n+\tvirtual_preferred_stack_boundary_rtx alignment instead of\n+\tcrtl->preferred_stack_boundary alignment.\n+\t(allocate_dynamic_stack_space): Use CONST_INT_P and REG_P\n+\tmacros.  Never decrease crtl->preferred_stack_boundary,\n+\tuse crtl->preferred_stack_boundary or MAX_SUPPORTED_STACK_ALIGNMENT\n+\tinstead of PREFERRED_STACK_BOUNDARY.  Don't modify\n+\tstack_pointer_delta in dynamic allocation, even when size\n+\tis constant.\n+\t(probe_stack_range, anti_adjust_stack_and_probe): Use CONST_INT_P\n+\tmacro.\n+\t* print-rtl.c (print_rtx): Handle\n+\tVIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM.\n+\t* config/alpha/alpha.h (NONSTRICT_REG_OK_FP_BASE_P): Use\n+\tLAST_VIRTUAL_POINTER_REGISTER instead of LAST_VIRTUAL_REGISTER.\n+\t* config/frv/frv.c (frv_emit_movsi): Likewise.\n+\t* config/arm/arm.c (thumb1_legitimate_address_p): Likewise.\n+\t* config/rs6000/rs6000.c (virtual_stack_registers_memory_p):\n+\tLikewise.\n+\n+\tRevert:\n+\t2010-09-17  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR middle-end/45234\n+\t* calls.c (expand_call): Make sure that all variable sized\n+\tadjustments are multiple of preferred stack boundary after\n+\tstack alignment.\n+\n 2010-09-24  Iain Sandoe  <iains@gcc.gnu.org>\n \t    Dominique Dhumieres  <dominiq@lps.ens.fr>\n \t    "}, {"sha": "388883137be27c1f059773b08b68bbe70c9a54e3", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -2385,19 +2385,6 @@ expand_call (tree exp, rtx target, int ignore)\n \n   preferred_unit_stack_boundary = preferred_stack_boundary / BITS_PER_UNIT;\n \n-  if (SUPPORTS_STACK_ALIGNMENT)\n-    {\n-      /* All variable sized adjustments must be multiple of preferred\n-\t stack boundary.  Stack alignment may change preferred stack\n-\t boundary after variable sized adjustments have been made.  We\n-\t need to compensate it here.  */\n-      unsigned HOST_WIDE_INT delta\n-\t= ((stack_pointer_delta - pending_stack_adjust)\n-\t   % preferred_unit_stack_boundary);\n-      if (delta)\n-\tanti_adjust_stack (GEN_INT (preferred_unit_stack_boundary - delta));\n-    }\n-\n   /* We want to make two insn chains; one for a sibling call, the other\n      for a normal call.  We will select one of the two chains after\n      initial RTL generation is complete.  */"}, {"sha": "be885c1235df064533721e8c0d3694db6c7fa2bd", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -916,7 +916,7 @@ extern int alpha_memory_latency;\n #define NONSTRICT_REG_OK_FP_BASE_P(X)\t\t\\\n   (REGNO (X) == 31 || REGNO (X) == 63\t\t\\\n    || (REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n-       && REGNO (X) < LAST_VIRTUAL_REGISTER))\n+       && REGNO (X) < LAST_VIRTUAL_POINTER_REGISTER))\n \n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define STRICT_REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))"}, {"sha": "44cbc8e135309204671a71a495a507ba183f3b4f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -5855,7 +5855,8 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t       && (REGNO (XEXP (x, 0)) == FRAME_POINTER_REGNUM\n \t\t   || REGNO (XEXP (x, 0)) == ARG_POINTER_REGNUM\n \t\t   || (REGNO (XEXP (x, 0)) >= FIRST_VIRTUAL_REGISTER\n-\t\t       && REGNO (XEXP (x, 0)) <= LAST_VIRTUAL_REGISTER))\n+\t\t       && REGNO (XEXP (x, 0))\n+\t\t\t  <= LAST_VIRTUAL_POINTER_REGISTER))\n \t       && GET_MODE_SIZE (mode) >= 4\n \t       && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t       && (INTVAL (XEXP (x, 1)) & 3) == 0)"}, {"sha": "42d0b1d9d0eaa35f3b3d741b4280e5438390a873", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -4067,7 +4067,7 @@ frv_emit_movsi (rtx dest, rtx src)\n \t  || (GET_CODE (src) == REG\n \t      && IN_RANGE_P (REGNO (src),\n \t\t\t     FIRST_VIRTUAL_REGISTER,\n-\t\t\t     LAST_VIRTUAL_REGISTER))))\n+\t\t\t     LAST_VIRTUAL_POINTER_REGISTER))))\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, dest, copy_to_mode_reg (SImode, src)));\n       return TRUE;"}, {"sha": "5a3e333ffbe25647c8d172c3235a240babc3e61c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -5489,7 +5489,7 @@ virtual_stack_registers_memory_p (rtx op)\n     return false;\n \n   return (regnum >= FIRST_VIRTUAL_REGISTER\n-\t  && regnum <= LAST_VIRTUAL_REGISTER);\n+\t  && regnum <= LAST_VIRTUAL_POINTER_REGISTER);\n }\n \n static bool"}, {"sha": "35a4360c973a1b4e5c608fe9572e0b3d3c93695f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -5376,6 +5376,8 @@ init_virtual_regs (void)\n   regno_reg_rtx[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n   regno_reg_rtx[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n   regno_reg_rtx[VIRTUAL_CFA_REGNUM] = virtual_cfa_rtx;\n+  regno_reg_rtx[VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM]\n+    = virtual_preferred_stack_boundary_rtx;\n }\n \n \f\n@@ -5698,6 +5700,8 @@ init_emit_regs (void)\n   virtual_outgoing_args_rtx =\n     gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);\n   virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n+  virtual_preferred_stack_boundary_rtx =\n+    gen_raw_REG (Pmode, VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM);\n \n   /* Initialize RTL for commonly used hard registers.  These are\n      copied into regno_reg_rtx as we begin to compile each function.  */"}, {"sha": "2024b5324d8676dad9b2d6f121991b10728cc77b", "filename": "gcc/explow.c", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -915,30 +915,47 @@ anti_adjust_stack (rtx adjust)\n static rtx\n round_push (rtx size)\n {\n-  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+  rtx align_rtx, alignm1_rtx;\n \n-  if (align == 1)\n-    return size;\n-\n-  if (CONST_INT_P (size))\n+  if (!SUPPORTS_STACK_ALIGNMENT\n+      || crtl->preferred_stack_boundary == MAX_SUPPORTED_STACK_ALIGNMENT)\n     {\n-      HOST_WIDE_INT new_size = (INTVAL (size) + align - 1) / align * align;\n+      int align = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n+\n+      if (align == 1)\n+\treturn size;\n+\n+      if (CONST_INT_P (size))\n+\t{\n+\t  HOST_WIDE_INT new_size = (INTVAL (size) + align - 1) / align * align;\n \n-      if (INTVAL (size) != new_size)\n-\tsize = GEN_INT (new_size);\n+\t  if (INTVAL (size) != new_size)\n+\t    size = GEN_INT (new_size);\n+\t  return size;\n+\t}\n+\n+      align_rtx = GEN_INT (align);\n+      alignm1_rtx = GEN_INT (align - 1);\n     }\n   else\n     {\n-      /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n-\t but we know it can't.  So add ourselves and then do\n-\t TRUNC_DIV_EXPR.  */\n-      size = expand_binop (Pmode, add_optab, size, GEN_INT (align - 1),\n-\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-      size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size, GEN_INT (align),\n-\t\t\t    NULL_RTX, 1);\n-      size = expand_mult (Pmode, size, GEN_INT (align), NULL_RTX, 1);\n+      /* If crtl->preferred_stack_boundary might still grow, use\n+\t virtual_preferred_stack_boundary_rtx instead.  This will be\n+\t substituted by the right value in vregs pass and optimized\n+\t during combine.  */\n+      align_rtx = virtual_preferred_stack_boundary_rtx;\n+      alignm1_rtx = force_operand (plus_constant (align_rtx, -1), NULL_RTX);\n     }\n \n+  /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n+     but we know it can't.  So add ourselves and then do\n+     TRUNC_DIV_EXPR.  */\n+  size = expand_binop (Pmode, add_optab, size, alignm1_rtx,\n+\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size, align_rtx,\n+\t\t\tNULL_RTX, 1);\n+  size = expand_mult (Pmode, size, align_rtx, NULL_RTX, 1);\n+\n   return size;\n }\n \f\n@@ -1144,20 +1161,20 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n      introduced later by the various alignment operations.  */\n   if (flag_stack_usage)\n     {\n-      if (GET_CODE (size) == CONST_INT)\n+      if (CONST_INT_P (size))\n \tstack_usage_size = INTVAL (size);\n-      else if (GET_CODE (size) == REG)\n+      else if (REG_P (size))\n         {\n \t  /* Look into the last emitted insn and see if we can deduce\n \t     something for the register.  */\n \t  rtx insn, set, note;\n \t  insn = get_last_insn ();\n \t  if ((set = single_set (insn)) && rtx_equal_p (SET_DEST (set), size))\n \t    {\n-\t      if (GET_CODE (SET_SRC (set)) == CONST_INT)\n+\t      if (CONST_INT_P (SET_SRC (set)))\n \t\tstack_usage_size = INTVAL (SET_SRC (set));\n \t      else if ((note = find_reg_equal_equiv_note (insn))\n-\t\t       && GET_CODE (XEXP (note, 0)) == CONST_INT)\n+\t\t       && CONST_INT_P (XEXP (note, 0)))\n \t\tstack_usage_size = INTVAL (XEXP (note, 0));\n \t    }\n \t}\n@@ -1177,7 +1194,8 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n   /* We can't attempt to minimize alignment necessary, because we don't\n      know the final value of preferred_stack_boundary yet while executing\n      this code.  */\n-  crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+  if (crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n \n   /* We will need to ensure that the address we return is aligned to\n      BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't\n@@ -1195,7 +1213,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n #if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET)\n #define MUST_ALIGN 1\n #else\n-#define MUST_ALIGN (PREFERRED_STACK_BOUNDARY < BIGGEST_ALIGNMENT)\n+#define MUST_ALIGN (crtl->preferred_stack_boundary < BIGGEST_ALIGNMENT)\n #endif\n \n   if (MUST_ALIGN)\n@@ -1255,13 +1273,13 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n      insns.  Since this is an extremely rare event, we have no reliable\n      way of knowing which systems have this problem.  So we avoid even\n      momentarily mis-aligning the stack.  */\n-  if (!known_align_valid || known_align % PREFERRED_STACK_BOUNDARY != 0)\n+  if (!known_align_valid || known_align % MAX_SUPPORTED_STACK_ALIGNMENT != 0)\n     {\n       size = round_push (size);\n \n       if (flag_stack_usage)\n \t{\n-\t  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+\t  int align = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n \t  stack_usage_size = (stack_usage_size + align - 1) / align * align;\n \t}\n     }\n@@ -1328,6 +1346,8 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n   else\n #endif\n     {\n+      int saved_stack_pointer_delta;\n+\n #ifndef STACK_GROWS_DOWNWARD\n       emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif\n@@ -1358,10 +1378,15 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n \t  emit_label (space_available);\n \t}\n \n+      saved_stack_pointer_delta = stack_pointer_delta;\n       if (flag_stack_check && STACK_CHECK_MOVING_SP)\n \tanti_adjust_stack_and_probe (size, false);\n       else\n \tanti_adjust_stack (size);\n+      /* Even if size is constant, don't modify stack_pointer_delta.\n+\t The constant size alloca should preserve\n+\t crtl->preferred_stack_boundary alignment.  */\n+      stack_pointer_delta = saved_stack_pointer_delta;\n \n #ifdef STACK_GROWS_DOWNWARD\n       emit_move_insn (target, virtual_stack_dynamic_rtx);\n@@ -1572,7 +1597,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \t{\n \t  rtx addr;\n \n-\t  if (GET_CODE (temp) == CONST_INT)\n+\t  if (CONST_INT_P (temp))\n \t    {\n \t      /* Use [base + disp} addressing mode if supported.  */\n \t      HOST_WIDE_INT offset = INTVAL (temp);\n@@ -1613,7 +1638,7 @@ anti_adjust_stack_and_probe (rtx size, bool adjust_back)\n \n   /* If we have a constant small number of probes to generate, that's the\n      easy case.  */\n-  if (GET_CODE (size) == CONST_INT && INTVAL (size) < 7 * PROBE_INTERVAL)\n+  if (CONST_INT_P (size) && INTVAL (size) < 7 * PROBE_INTERVAL)\n     {\n       HOST_WIDE_INT isize = INTVAL (size), i;\n       bool first_probe = true;"}, {"sha": "a11f248dc35c2d78103f911870882502c834334d", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -1405,6 +1405,11 @@ instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n #endif\n       offset = cfa_offset;\n     }\n+  else if (x == virtual_preferred_stack_boundary_rtx)\n+    {\n+      new_rtx = GEN_INT (crtl->preferred_stack_boundary / BITS_PER_UNIT);\n+      offset = 0;\n+    }\n   else\n     return NULL_RTX;\n "}, {"sha": "2a6a19846c9a6e531b0da50f685ec551a019dc63", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -457,6 +457,9 @@ print_rtx (const_rtx in_rtx)\n \t\t  fprintf (outfile, \" %d virtual-outgoing-args\", value);\n \t\telse if (value == VIRTUAL_CFA_REGNUM)\n \t\t  fprintf (outfile, \" %d virtual-cfa\", value);\n+\t\telse if (value == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n+\t\t  fprintf (outfile, \" %d virtual-preferred-stack-boundary\",\n+\t\t\t   value);\n \t\telse\n \t\t  fprintf (outfile, \" %d virtual-reg-%d\", value,\n \t\t\t   value-FIRST_VIRTUAL_REGISTER);"}, {"sha": "24a735ffa518fee9051b4be9c73867a3e4113d8a", "filename": "gcc/rtl.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -2010,6 +2010,7 @@ enum global_rtl_index\n   GR_VIRTUAL_STACK_DYNAMIC,\n   GR_VIRTUAL_OUTGOING_ARGS,\n   GR_VIRTUAL_CFA,\n+  GR_VIRTUAL_PREFERRED_STACK_BOUNDARY,\n \n   GR_MAX\n };\n@@ -2157,7 +2158,18 @@ extern rtx gen_rtx_MEM (enum machine_mode, rtx);\n \n #define VIRTUAL_CFA_REGNUM\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n \n-#define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n+#define LAST_VIRTUAL_POINTER_REGISTER\t((FIRST_VIRTUAL_REGISTER) + 4)\n+\n+/* This is replaced by crtl->preferred_stack_boundary / BITS_PER_UNIT\n+   when finalized.  */\n+\n+#define virtual_preferred_stack_boundary_rtx \\\n+\t(global_rtl[GR_VIRTUAL_PREFERRED_STACK_BOUNDARY])\n+\n+#define VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM \\\n+\t\t\t\t\t((FIRST_VIRTUAL_REGISTER) + 5)\n+\n+#define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 5)\n \n /* Nonzero if REGNUM is a pointer into the stack frame.  */\n #define REGNO_PTR_FRAME_P(REGNUM)\t\t\\\n@@ -2166,7 +2178,7 @@ extern rtx gen_rtx_MEM (enum machine_mode, rtx);\n    || (REGNUM) == HARD_FRAME_POINTER_REGNUM\t\\\n    || (REGNUM) == ARG_POINTER_REGNUM\t\t\\\n    || ((REGNUM) >= FIRST_VIRTUAL_REGISTER\t\\\n-       && (REGNUM) <= LAST_VIRTUAL_REGISTER))\n+       && (REGNUM) <= LAST_VIRTUAL_POINTER_REGISTER))\n \n /* REGNUM never really appearing in the INSN stream.  */\n #define INVALID_REGNUM\t\t\t(~(unsigned int) 0)"}, {"sha": "1917147d79d32511f721e06b957e221bd2bce4c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -1,3 +1,9 @@\n+2010-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/45234\n+\t* gcc.dg/torture/stackalign/alloca-6.c: New test.\n+\t* gcc.target/i386/pr45234.c: New test.\n+\n 2010-09-24  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/lto/20091006-2_0.c: Prune warnings."}, {"sha": "f0e4513de0e55c08259d4d87e5fd2b6dfefa8866", "filename": "gcc/testsuite/gcc.dg/torture/stackalign/alloca-6.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Falloca-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Falloca-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Falloca-6.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -0,0 +1,34 @@\n+/* PR middle-end/45234 */\n+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+/* { dg-options \"-mincoming-stack-boundary=2 -mpreferred-stack-boundary=2\" } */\n+\n+#include \"check.h\"\n+\n+void\n+__attribute__ ((noinline))\n+bar (__float128 f)\n+{\n+  check (&f, __alignof__(f));\n+}\n+\n+volatile int z = 6;\n+\n+int\n+main (void)\n+{\n+  char *p = __builtin_alloca (z);\n+\n+  bar (0);\n+\n+  __builtin_strncpy (p, \"good\", 5);\n+  if (__builtin_strncmp (p, \"good\", 5) != 0)\n+    {\n+#ifdef DEBUG\n+      p[z - 1] = '\\0';\n+      printf (\"Failed: %s != good\\n\", p);\n+#endif\n+     abort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "b11096b65e22fe594ee80ea62f59d69b50374b5a", "filename": "gcc/testsuite/gcc.target/i386/pr45234.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45234.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32990d5bc27147c3f6e53324b37089b104c864cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45234.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45234.c?ref=32990d5bc27147c3f6e53324b37089b104c864cc", "patch": "@@ -0,0 +1,18 @@\n+/* PR middle-end/45234 */\n+/* { dg-do compile } */\n+/* { dg-options \"-march=i586\" { target ilp32 } } */\n+\n+struct S { union { double b[4]; } a[18]; } s, a[5];\n+void foo (struct S);\n+struct S bar (struct S, struct S *, struct S);\n+\n+void\n+foo (struct S arg)\n+{\n+}\n+\n+void\n+baz (void)\n+{\n+ foo (bar (s, &a[1], a[2]));\n+}"}]}