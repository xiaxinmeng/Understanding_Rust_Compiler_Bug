{"sha": "3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkMDgxN2QxY2MxOTFmMGQ4OWQyZmVmYTU3YmYxMDhhNTMzMzFmMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-09-12T19:25:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-09-12T19:25:59Z"}, "message": "mips.c (mips_epilogue): New structure.\n\ngcc/\n2011-09-11  Bernd Schmidt  <bernds@codesourcery.com>\n\t    Richard Sandiford  <rdsandiford@googlemail.com>\n\n\t* config/mips/mips.c (mips_epilogue): New structure.\n\t(mips16e_save_restore_reg): Queue REG_CFA_RESTORE notes when\n\trestoring registers.\n\t(mips_epilogue_emit_cfa_restores): New function.\n\t(mips_epilogue_set_cfa): Likewise.\n\t(mips_restore_reg): Queue REG_CFA_RESTORE notes.  When restoring\n\tthe current CFA register from the stack, redefine the CFA in terms\n\tof the stack pointer.\n\t(mips_expand_epilogue): Set up mips_epilogue.  Attach CFA information\n\tto the epilogue instructions.\n\ngcc/testsuite/\n\t* gcc.target/mips/mips.exp (mips_option_groups): Add debug options.\n\t* gcc.target/mips/interrupt_handler-2.c: New test.\n\t* gcc.target/mips/interrupt_handler-3.c: Likewise.\n\nFrom-SVN: r178794", "tree": {"sha": "80766a87a89d7394a98e1bc442392e27b83edda5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80766a87a89d7394a98e1bc442392e27b83edda5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/comments", "author": null, "committer": null, "parents": [{"sha": "42ae51f40ec3816094cc48b6e46623d1701f98d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ae51f40ec3816094cc48b6e46623d1701f98d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ae51f40ec3816094cc48b6e46623d1701f98d7"}], "stats": {"total": 168, "additions": 160, "deletions": 8}, "files": [{"sha": "48b4af76907243455d892e834f4034632ed73bff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "patch": "@@ -1,3 +1,17 @@\n+2011-09-12  Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.c (mips_epilogue): New structure.\n+\t(mips16e_save_restore_reg): Queue REG_CFA_RESTORE notes when\n+\trestoring registers.\n+\t(mips_epilogue_emit_cfa_restores): New function.\n+\t(mips_epilogue_set_cfa): Likewise.\n+\t(mips_restore_reg): Queue REG_CFA_RESTORE notes.  When restoring\n+\tthe current CFA register from the stack, redefine the CFA in terms\n+\tof the stack pointer.\n+\t(mips_expand_epilogue): Set up mips_epilogue.  Attach CFA information\n+\tto the epilogue instructions.\n+\n 2011-09-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.c (mips16e_save_restore_reg): Add a reg_parm_p"}, {"sha": "0c3b184bcb2d201e96d93650d941ebc231c044eb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "patch": "@@ -501,6 +501,21 @@ int sdb_label_count;\n int mips_dbx_regno[FIRST_PSEUDO_REGISTER];\n int mips_dwarf_regno[FIRST_PSEUDO_REGISTER];\n \n+/* Information about the current function's epilogue, used only while\n+   expanding it.  */\n+static struct {\n+  /* A list of queued REG_CFA_RESTORE notes.  */\n+  rtx cfa_restores;\n+\n+  /* The CFA is currently defined as CFA_REG + CFA_OFFSET.  */\n+  rtx cfa_reg;\n+  HOST_WIDE_INT cfa_offset;\n+\n+  /* The offset of the CFA from the stack pointer while restoring\n+     registers.  */\n+  HOST_WIDE_INT cfa_restore_sp_offset;\n+} mips_epilogue;\n+\n /* The nesting depth of the PRINT_OPERAND '%(', '%<' and '%[' constructs.  */\n struct mips_asm_switch mips_noreorder = { \"reorder\", 0 };\n struct mips_asm_switch mips_nomacro = { \"macro\", 0 };\n@@ -8377,7 +8392,11 @@ mips16e_save_restore_reg (bool restore_p, bool reg_parm_p,\n   mem = gen_frame_mem (SImode, plus_constant (stack_pointer_rtx, offset));\n   reg = gen_rtx_REG (SImode, regno);\n   if (restore_p)\n-    return gen_rtx_SET (VOIDmode, reg, mem);\n+    {\n+      mips_epilogue.cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n+\t\t\t\t\t\t   mips_epilogue.cfa_restores);\n+      return gen_rtx_SET (VOIDmode, reg, mem);\n+    }\n   if (reg_parm_p)\n     return gen_rtx_SET (VOIDmode, mem, reg);\n   return mips_frame_set (mem, reg);\n@@ -10222,7 +10241,47 @@ mips_expand_prologue (void)\n     emit_insn (gen_blockage ());\n }\n \f\n-/* Emit instructions to restore register REG from slot MEM.  */\n+/* Attach all pending register saves to the previous instruction.\n+   Return that instruction.  */\n+\n+static rtx\n+mips_epilogue_emit_cfa_restores (void)\n+{\n+  rtx insn;\n+\n+  insn = get_last_insn ();\n+  gcc_assert (insn && !REG_NOTES (insn));\n+  if (mips_epilogue.cfa_restores)\n+    {\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      REG_NOTES (insn) = mips_epilogue.cfa_restores;\n+      mips_epilogue.cfa_restores = 0;\n+    }\n+  return insn;\n+}\n+\n+/* Like mips_epilogue_emit_cfa_restores, but also record that the CFA is\n+   now at REG + OFFSET.  */\n+\n+static void\n+mips_epilogue_set_cfa (rtx reg, HOST_WIDE_INT offset)\n+{\n+  rtx insn;\n+\n+  insn = mips_epilogue_emit_cfa_restores ();\n+  if (reg != mips_epilogue.cfa_reg || offset != mips_epilogue.cfa_offset)\n+    {\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      REG_NOTES (insn) = alloc_reg_note (REG_CFA_DEF_CFA,\n+\t\t\t\t\t plus_constant (reg, offset),\n+\t\t\t\t\t REG_NOTES (insn));\n+      mips_epilogue.cfa_reg = reg;\n+      mips_epilogue.cfa_offset = offset;\n+    }\n+}\n+\n+/* Emit instructions to restore register REG from slot MEM.  Also update\n+   the cfa_restores list.  */\n \n static void\n mips_restore_reg (rtx reg, rtx mem)\n@@ -10231,8 +10290,17 @@ mips_restore_reg (rtx reg, rtx mem)\n      $7 instead and adjust the return insn appropriately.  */\n   if (TARGET_MIPS16 && REGNO (reg) == RETURN_ADDR_REGNUM)\n     reg = gen_rtx_REG (GET_MODE (reg), GP_REG_FIRST + 7);\n+  else\n+    mips_epilogue.cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n+\t\t\t\t\t\t mips_epilogue.cfa_restores);\n \n   mips_emit_save_slot_move (reg, mem, MIPS_EPILOGUE_TEMP (GET_MODE (reg)));\n+  if (REGNO (reg) == REGNO (mips_epilogue.cfa_reg))\n+    /* The CFA is currently defined in terms of the register whose\n+       value we have just restored.  Redefine the CFA in terms of\n+       the stack pointer.  */\n+    mips_epilogue_set_cfa (stack_pointer_rtx,\n+\t\t\t   mips_epilogue.cfa_restore_sp_offset);\n }\n \n /* Emit any instructions needed before a return.  */\n@@ -10291,6 +10359,9 @@ mips_expand_epilogue (bool sibcall_p)\n       base = hard_frame_pointer_rtx;\n       step1 -= frame->hard_frame_pointer_offset;\n     }\n+  mips_epilogue.cfa_reg = base;\n+  mips_epilogue.cfa_offset = step1;\n+  mips_epilogue.cfa_restores = NULL_RTX;\n \n   /* If we need to restore registers, deallocate as much stack as\n      possible in the second step without going out of range.  */\n@@ -10320,6 +10391,7 @@ mips_expand_epilogue (bool sibcall_p)\n \ttarget = stack_pointer_rtx;\n \n       emit_insn (gen_add3_insn (target, base, adjust));\n+      mips_epilogue_set_cfa (target, step2);\n     }\n \n   /* Copy TARGET into the stack pointer.  */\n@@ -10332,6 +10404,7 @@ mips_expand_epilogue (bool sibcall_p)\n   if (TARGET_CALL_SAVED_GP && !TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n \n+  mips_epilogue.cfa_restore_sp_offset = step2;\n   if (GENERATE_MIPS16E_SAVE_RESTORE && frame->mask != 0)\n     {\n       unsigned int regno, mask;\n@@ -10353,6 +10426,7 @@ mips_expand_epilogue (bool sibcall_p)\n       /* Restore the remaining registers and deallocate the final bit\n \t of the frame.  */\n       emit_insn (restore);\n+      mips_epilogue_set_cfa (stack_pointer_rtx, 0);\n     }\n   else\n     {\n@@ -10388,9 +10462,15 @@ mips_expand_epilogue (bool sibcall_p)\n \n \t  /* If we don't use shoadow register set, we need to update SP.  */\n \t  if (!cfun->machine->use_shadow_register_set_p && step2 > 0)\n-\t    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (step2)));\n+\t    {\n+\t      emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (step2)));\n+\t      mips_epilogue_set_cfa (stack_pointer_rtx, 0);\n+\t    }\n+\t  else\n+\t    /* The choice of position is somewhat arbitrary in this case.  */\n+\t    mips_epilogue_emit_cfa_restores ();\n \n \t  /* Move to COP0 Status.  */\n \t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),\n@@ -10400,11 +10480,15 @@ mips_expand_epilogue (bool sibcall_p)\n \t{\n \t  /* Deallocate the final bit of the frame.  */\n \t  if (step2 > 0)\n-\t    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (step2)));\n+\t    {\n+\t      emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (step2)));\n+\t      mips_epilogue_set_cfa (stack_pointer_rtx, 0);\n+\t    }\n \t}\n     }\n+  gcc_assert (!mips_epilogue.cfa_restores);\n \n   /* Add in the __builtin_eh_return stack adjustment.  We need to\n      use a temporary in MIPS16 code.  */"}, {"sha": "eea712ece6c987d8776cf5074eece87bd96d773e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "patch": "@@ -1,3 +1,9 @@\n+2011-09-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/mips.exp (mips_option_groups): Add debug options.\n+\t* gcc.target/mips/interrupt_handler-2.c: New test.\n+\t* gcc.target/mips/interrupt_handler-3.c: Likewise.\n+\n 2011-09-12  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/fntmpdefarg2.C: Add more tests."}, {"sha": "13b41e11885993195094d9ea43c6b58a198919be", "filename": "gcc/testsuite/gcc.target/mips/interrupt_handler-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-2.c?ref=3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "patch": "@@ -0,0 +1,14 @@\n+/* Make sure that we emit .cfa_restore notes for LO and HI.  */\n+/* { dg-options \"-mips32r2 -msoft-float -O -g\" } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 64\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 65\\n\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\.cfi_def_cfa( |\\t)\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\.cfi_def_cfa_register( |\\t)\" } } */\n+\n+extern void f (void);\n+\n+NOMIPS16 void __attribute__ ((interrupt, use_shadow_register_set))\n+v1 (void)\n+{\n+  f ();\n+}"}, {"sha": "2380123b16eebf629b4445fc5b94728b3fd99c21", "filename": "gcc/testsuite/gcc.target/mips/interrupt_handler-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finterrupt_handler-3.c?ref=3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "patch": "@@ -0,0 +1,33 @@\n+/* Make sure that we emit .cfa_restore notes for LO, HI and GPRs.  */\n+/* { dg-options \"-mips32r2 -msoft-float -O -g\" } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 1\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 2\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 3\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 4\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 5\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 6\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 7\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 8\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 9\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 10\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 11\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 13\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 14\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 15\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 24\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 25\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 31\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 64\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_restore 65\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\\\.cfi_def_cfa_offset 0\\n\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\.cfi_def_cfa( |\\t)\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\.cfi_def_cfa_register( |\\t)\" } } */\n+\n+extern void f (void);\n+\n+NOMIPS16 void __attribute__ ((interrupt))\n+v1 (void)\n+{\n+  f ();\n+}"}, {"sha": "857cfe87eba5ec39361437f8309002b4e1dd2d80", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd0817d1cc191f0d89d2fefa57bf108a53331f2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=3bd0817d1cc191f0d89d2fefa57bf108a53331f2", "patch": "@@ -226,6 +226,7 @@ set mips_option_groups {\n     abi \"-mabi=.*\"\n     addressing \"addressing=.*\"\n     arch \"-mips([1-5]|32.*|64.*)|-march=.*|isa(|_rev)(=|<=|>=).*\"\n+    debug \"-g*\"\n     dump_pattern \"-dp\"\n     endianness \"-E(L|B)|-me(l|b)\"\n     float \"-m(hard|soft)-float\""}]}