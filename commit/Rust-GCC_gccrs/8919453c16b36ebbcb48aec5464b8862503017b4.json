{"sha": "8919453c16b36ebbcb48aec5464b8862503017b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkxOTQ1M2MxNmIzNmViYmNiNDhhZWM1NDY0Yjg4NjI1MDMwMTdiNA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2014-09-24T18:22:50Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2014-09-24T18:22:50Z"}, "message": "[AArch64] Improve regmove_costs for 128-bit types.\n\n  2014-09-24  Wilco Dijkstra <wdijkstr@arm.com>\n\n  gcc/\n    * config/aarch64/aarch64.c (aarch64_register_move_cost): Add register move\n    costs for 128-bit types.\n\nFrom-SVN: r215562", "tree": {"sha": "195278075d7ca5c2d4a265900e0eb27ef36037d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/195278075d7ca5c2d4a265900e0eb27ef36037d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8919453c16b36ebbcb48aec5464b8862503017b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8919453c16b36ebbcb48aec5464b8862503017b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8919453c16b36ebbcb48aec5464b8862503017b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8919453c16b36ebbcb48aec5464b8862503017b4/comments", "author": null, "committer": null, "parents": [{"sha": "6fe459553452ee75e87959331db336a1152d9451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe459553452ee75e87959331db336a1152d9451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fe459553452ee75e87959331db336a1152d9451"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "ce6738c852dd55a9cd2fd44e010e876393dd39a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919453c16b36ebbcb48aec5464b8862503017b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919453c16b36ebbcb48aec5464b8862503017b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8919453c16b36ebbcb48aec5464b8862503017b4", "patch": "@@ -1,3 +1,8 @@\n+2014-09-24  Wilco Dijkstra  <wilco.dijkstra@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_register_move_cost): Add register\n+\tmove costs for 128-bit types.\n+\n 2014-09-24  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.c (ipa_edge_duplication_hook): Update controlled_use_count"}, {"sha": "4e0cba8da740ea2f64ee3ed31354fd29c093032c", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919453c16b36ebbcb48aec5464b8862503017b4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919453c16b36ebbcb48aec5464b8862503017b4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8919453c16b36ebbcb48aec5464b8862503017b4", "patch": "@@ -5986,21 +5986,34 @@ aarch64_register_move_cost (enum machine_mode mode,\n     return aarch64_register_move_cost (mode, from, GENERAL_REGS)\n             + aarch64_register_move_cost (mode, GENERAL_REGS, to);\n \n+  if (GET_MODE_SIZE (mode) == 16)\n+    {\n+      /* 128-bit operations on general registers require 2 instructions.  */\n+      if (from == GENERAL_REGS && to == GENERAL_REGS)\n+\treturn regmove_cost->GP2GP * 2;\n+      else if (from == GENERAL_REGS)\n+\treturn regmove_cost->GP2FP * 2;\n+      else if (to == GENERAL_REGS)\n+\treturn regmove_cost->FP2GP * 2;\n+\n+      /* When AdvSIMD instructions are disabled it is not possible to move\n+\t a 128-bit value directly between Q registers.  This is handled in\n+\t secondary reload.  A general register is used as a scratch to move\n+\t the upper DI value and the lower DI value is moved directly,\n+\t hence the cost is the sum of three moves. */\n+      if (! TARGET_SIMD)\n+\treturn regmove_cost->GP2FP + regmove_cost->FP2GP + regmove_cost->FP2FP;\n+\n+      return regmove_cost->FP2FP;\n+    }\n+\n   if (from == GENERAL_REGS && to == GENERAL_REGS)\n     return regmove_cost->GP2GP;\n   else if (from == GENERAL_REGS)\n     return regmove_cost->GP2FP;\n   else if (to == GENERAL_REGS)\n     return regmove_cost->FP2GP;\n \n-  /* When AdvSIMD instructions are disabled it is not possible to move\n-     a 128-bit value directly between Q registers.  This is handled in\n-     secondary reload.  A general register is used as a scratch to move\n-     the upper DI value and the lower DI value is moved directly,\n-     hence the cost is the sum of three moves. */\n-  if (! TARGET_SIMD && GET_MODE_SIZE (mode) == 16)\n-    return regmove_cost->GP2FP + regmove_cost->FP2GP + regmove_cost->FP2FP;\n-\n   return regmove_cost->FP2FP;\n }\n "}]}