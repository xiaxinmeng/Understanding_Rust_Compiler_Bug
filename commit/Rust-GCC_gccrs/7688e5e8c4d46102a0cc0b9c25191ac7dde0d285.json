{"sha": "7688e5e8c4d46102a0cc0b9c25191ac7dde0d285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY4OGU1ZThjNGQ0NjEwMmEwY2MwYjljMjUxOTFhYzdkZGUwZDI4NQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-05-24T10:04:38Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-05-29T11:12:36Z"}, "message": "libstdc++: Review unordered_map insert_or_assign/try_emplace (PR 95079)\n\nThose methods are making a double lookup in case of insertion, they can\nperform only one.\n\n\tPR libstdc++/95079\n\t* include/bits/hashtable_policy.h (_Insert_base<>::try_emplace): New.\n\t* include/bits/unordered_map.h (unordered_map<>::try_emplace): Adapt.\n\t(unordered_map<>::insert_or_assign): Adapt.", "tree": {"sha": "6b2ea4cd581aa9dc529a6fe99c1377f5c70914d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b2ea4cd581aa9dc529a6fe99c1377f5c70914d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285/comments", "author": null, "committer": null, "parents": [{"sha": "c735929a2503a7d03ac4739bba5b25336bf954c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c735929a2503a7d03ac4739bba5b25336bf954c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c735929a2503a7d03ac4739bba5b25336bf954c3"}], "stats": {"total": 194, "additions": 82, "deletions": 112}, "files": [{"sha": "33f3f143bd0168cbae7dbef985b82e35e7ca8bf4", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=7688e5e8c4d46102a0cc0b9c25191ac7dde0d285", "patch": "@@ -848,6 +848,28 @@ namespace __detail\n \treturn __h._M_insert(__hint, __v, __node_gen, __unique_keys());\n       }\n \n+      template<typename _KType, typename... _Args>\n+\tstd::pair<iterator, bool>\n+\ttry_emplace(const_iterator, _KType&& __k, _Args&&... __args)\n+\t{\n+\t  __hashtable& __h = _M_conjure_hashtable();\n+\t  auto __code = __h._M_hash_code(__k);\n+\t  std::size_t __bkt = __h._M_bucket_index(__k, __code);\n+\t  if (__node_type* __node = __h._M_find_node(__bkt, __k, __code))\n+\t    return { iterator(__node), false };\n+\n+\t  typename __hashtable::_Scoped_node __node {\n+\t    &__h,\n+\t    std::piecewise_construct,\n+\t    std::forward_as_tuple(std::forward<_KType>(__k)),\n+\t    std::forward_as_tuple(std::forward<_Args>(__args)...)\n+\t    };\n+\t  auto __it\n+\t    = __h._M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\t  __node._M_node = nullptr;\n+\t  return { __it, true };\n+\t}\n+\n       void\n       insert(initializer_list<value_type> __l)\n       { this->insert(__l.begin(), __l.end()); }"}, {"sha": "33f632ddb794a94e817f679f95e3f931e001dfb7", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 60, "deletions": 112, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7688e5e8c4d46102a0cc0b9c25191ac7dde0d285/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=7688e5e8c4d46102a0cc0b9c25191ac7dde0d285", "patch": "@@ -466,39 +466,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires amortized constant time.\n        */\n       template <typename... _Args>\n-        pair<iterator, bool>\n-        try_emplace(const key_type& __k, _Args&&... __args)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            {\n-              __i = emplace(std::piecewise_construct,\n-                            std::forward_as_tuple(__k),\n-                            std::forward_as_tuple(\n-                              std::forward<_Args>(__args)...))\n-                .first;\n-              return {__i, true};\n-            }\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\ttry_emplace(const key_type& __k, _Args&&... __args)\n+\t{\n+\t  return _M_h.try_emplace(cend(), __k, std::forward<_Args>(__args)...);\n+\t}\n \n       // move-capable overload\n       template <typename... _Args>\n-        pair<iterator, bool>\n-        try_emplace(key_type&& __k, _Args&&... __args)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            {\n-              __i = emplace(std::piecewise_construct,\n-                            std::forward_as_tuple(std::move(__k)),\n-                            std::forward_as_tuple(\n-                              std::forward<_Args>(__args)...))\n-                .first;\n-              return {__i, true};\n-            }\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\ttry_emplace(key_type&& __k, _Args&&... __args)\n+\t{\n+\t  return _M_h.try_emplace(cend(), std::move(__k),\n+\t\t\t\t  std::forward<_Args>(__args)...);\n+\t}\n \n       /**\n        *  @brief Attempts to build and insert a std::pair into the\n@@ -529,32 +510,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires amortized constant time.\n        */\n       template <typename... _Args>\n-        iterator\n-        try_emplace(const_iterator __hint, const key_type& __k,\n-                    _Args&&... __args)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            __i = emplace_hint(__hint, std::piecewise_construct,\n-                               std::forward_as_tuple(__k),\n-                               std::forward_as_tuple(\n-                                 std::forward<_Args>(__args)...));\n-          return __i;\n-        }\n+\titerator\n+\ttry_emplace(const_iterator __hint, const key_type& __k,\n+\t\t    _Args&&... __args)\n+\t{\n+\t  return _M_h.try_emplace(__hint, __k,\n+\t\t\t\t  std::forward<_Args>(__args)...).first;\n+\t}\n \n       // move-capable overload\n       template <typename... _Args>\n-        iterator\n-        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            __i = emplace_hint(__hint, std::piecewise_construct,\n-                               std::forward_as_tuple(std::move(__k)),\n-                               std::forward_as_tuple(\n-                                 std::forward<_Args>(__args)...));\n-          return __i;\n-        }\n+\titerator\n+\ttry_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n+\t{\n+\t  return _M_h.try_emplace(__hint, std::move(__k),\n+\t\t\t\t  std::forward<_Args>(__args)...).first;\n+\t}\n #endif // C++17\n \n       //@{\n@@ -678,39 +649,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires amortized constant time.\n        */\n       template <typename _Obj>\n-        pair<iterator, bool>\n-        insert_or_assign(const key_type& __k, _Obj&& __obj)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            {\n-              __i = emplace(std::piecewise_construct,\n-                            std::forward_as_tuple(__k),\n-                            std::forward_as_tuple(std::forward<_Obj>(__obj)))\n-                .first;\n-              return {__i, true};\n-            }\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\tinsert_or_assign(const key_type& __k, _Obj&& __obj)\n+\t{\n+\t  auto __ret = _M_h.try_emplace(cend(), __k,\n+\t\t\t\t\tstd::forward<_Obj>(__obj));\n+\t  if (!__ret.second)\n+\t    __ret.first->second = std::forward<_Obj>(__obj);\n+\t  return __ret;\n+\t}\n \n       // move-capable overload\n       template <typename _Obj>\n-        pair<iterator, bool>\n-        insert_or_assign(key_type&& __k, _Obj&& __obj)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            {\n-              __i = emplace(std::piecewise_construct,\n-                            std::forward_as_tuple(std::move(__k)),\n-                            std::forward_as_tuple(std::forward<_Obj>(__obj)))\n-                .first;\n-              return {__i, true};\n-            }\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\tinsert_or_assign(key_type&& __k, _Obj&& __obj)\n+\t{\n+\t  auto __ret = _M_h.try_emplace(cend(), std::move(__k),\n+\t\t\t\t\tstd::forward<_Obj>(__obj));\n+\t  if (!__ret.second)\n+\t    __ret.first->second = std::forward<_Obj>(__obj);\n+\t  return __ret;\n+\t}\n \n       /**\n        *  @brief Attempts to insert a std::pair into the %unordered_map.\n@@ -739,38 +698,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires amortized constant time.\n        */\n       template <typename _Obj>\n-        iterator\n-        insert_or_assign(const_iterator __hint, const key_type& __k,\n-                         _Obj&& __obj)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            {\n-              return emplace_hint(__hint, std::piecewise_construct,\n-                                  std::forward_as_tuple(__k),\n-                                  std::forward_as_tuple(\n-                                    std::forward<_Obj>(__obj)));\n-            }\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return __i;\n-        }\n+\titerator\n+\tinsert_or_assign(const_iterator __hint, const key_type& __k,\n+\t\t\t _Obj&& __obj)\n+\t{\n+\t  auto __ret = _M_h.try_emplace(__hint, __k, std::forward<_Obj>(__obj));\n+\t  if (!__ret.second)\n+\t    __ret.first->second = std::forward<_Obj>(__obj);\n+\t  return __ret.first;\n+\t}\n \n       // move-capable overload\n       template <typename _Obj>\n-        iterator\n-        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n-        {\n-          iterator __i = find(__k);\n-          if (__i == end())\n-            {\n-              return emplace_hint(__hint, std::piecewise_construct,\n-                                  std::forward_as_tuple(std::move(__k)),\n-                                  std::forward_as_tuple(\n-                                    std::forward<_Obj>(__obj)));\n-            }\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return __i;\n-        }\n+\titerator\n+\tinsert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n+\t{\n+\t  auto __ret = _M_h.try_emplace(__hint, std::move(__k),\n+\t\t\t\t\tstd::forward<_Obj>(__obj));\n+\t  if (!__ret.second)\n+\t    __ret.first->second = std::forward<_Obj>(__obj);\n+\t  return __ret.first;\n+\t}\n #endif\n \n       //@{"}]}