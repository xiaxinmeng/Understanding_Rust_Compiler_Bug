{"sha": "47821ba07a19b672d3cba351a03af2b122e02213", "node_id": "C_kwDOANBUbNoAKDQ3ODIxYmEwN2ExOWI2NzJkM2NiYTM1MWEwM2FmMmIxMjJlMDIyMTM", "commit": {"author": {"name": "Martin Uecker", "email": "uecker@tugraz.at", "date": "2023-02-15T09:54:00Z"}, "committer": {"name": "Martin Uecker", "email": "uecker@tugraz.at", "date": "2023-02-18T09:39:01Z"}, "message": "C: Detect all variably modified types [PR108375]\n\nSome variably modified types were not detected correctly.\nDefine C_TYPE_VARIABLY_MODIFIED via TYPE_LANG_FLAG 6 in the CFE.\nThis flag records whether a type is variably modified and is\nset for all such types including arrays with variably modified\nelement type or structures and unions with variably modified\nmembers. This is then used to detect such types in the C FE\nand middle-end (via the existing language hook).\n\ngcc/c/ChangeLog:\n\tPR c/108375\n\t* c-decl.cc (decl_jump_unsafe): Use c_type_variably_modified_p.\n\t(diagnose_mismatched_decl): Dito.\n\t(warn_about_goto): Dito:\n\t(c_check_switch_jump_warnings): Dito.\n\t(finish_decl): Dito.\n\t(finish_struct): Dito.\n\t(grokdeclarator): Set C_TYPE_VARIABLY_MODIFIED.\n\t(finish_struct): Set C_TYPE_VARIABLY_MODIFIED.\n\t* c-objc-common.cc (c_var_mod_p): New function.\n\t(c_var_unspec_p): Remove.\n\t* c-objc-common.h: Set lang hook.\n\t* c-parser.cc (c_parser_declararion_or_fndef): Use c_type_variably_modified_p.\n\t(c_parser_typeof_specifier): Dito.\n\t(c_parser_has_attribute_expression): Dito.\n\t(c_parser_generic_selection): Dito.\n\t* c-tree.h: Define C_TYPE_VARIABLY_MODIFIED and define c_var_mode_p.\n\t* c-typeck.cc: Remove c_vla_mod_p and use C_TYPE_VARIABLY_MODIFIED.\n\ngcc/testsuite/ChangeLog:\n\tPR c/108375\n\t* gcc.dg/pr108375-1.c: New test.\n\t* gcc.dg/pr108375-2.c: New test.", "tree": {"sha": "51bd978038361d057159355eacc58f4561f4e852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51bd978038361d057159355eacc58f4561f4e852"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47821ba07a19b672d3cba351a03af2b122e02213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47821ba07a19b672d3cba351a03af2b122e02213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47821ba07a19b672d3cba351a03af2b122e02213", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47821ba07a19b672d3cba351a03af2b122e02213/comments", "author": {"login": "uecker", "id": 2036635, "node_id": "MDQ6VXNlcjIwMzY2MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/2036635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uecker", "html_url": "https://github.com/uecker", "followers_url": "https://api.github.com/users/uecker/followers", "following_url": "https://api.github.com/users/uecker/following{/other_user}", "gists_url": "https://api.github.com/users/uecker/gists{/gist_id}", "starred_url": "https://api.github.com/users/uecker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uecker/subscriptions", "organizations_url": "https://api.github.com/users/uecker/orgs", "repos_url": "https://api.github.com/users/uecker/repos", "events_url": "https://api.github.com/users/uecker/events{/privacy}", "received_events_url": "https://api.github.com/users/uecker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "uecker", "id": 2036635, "node_id": "MDQ6VXNlcjIwMzY2MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/2036635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uecker", "html_url": "https://github.com/uecker", "followers_url": "https://api.github.com/users/uecker/followers", "following_url": "https://api.github.com/users/uecker/following{/other_user}", "gists_url": "https://api.github.com/users/uecker/gists{/gist_id}", "starred_url": "https://api.github.com/users/uecker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uecker/subscriptions", "organizations_url": "https://api.github.com/users/uecker/orgs", "repos_url": "https://api.github.com/users/uecker/repos", "events_url": "https://api.github.com/users/uecker/events{/privacy}", "received_events_url": "https://api.github.com/users/uecker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3057d7928c0dbc78dbf748c9621ccd102e06beee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3057d7928c0dbc78dbf748c9621ccd102e06beee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3057d7928c0dbc78dbf748c9621ccd102e06beee"}], "stats": {"total": 120, "additions": 79, "deletions": 41}, "files": [{"sha": "08078eadeb88047a8b5261fb1b815c613ce73ec3", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -683,7 +683,7 @@ decl_jump_unsafe (tree decl)\n \n   /* Always warn about crossing variably modified types.  */\n   if ((VAR_P (decl) || TREE_CODE (decl) == TYPE_DECL)\n-      && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+      && c_type_variably_modified_p (TREE_TYPE (decl)))\n     return true;\n \n   /* Otherwise, only warn if -Wgoto-misses-init and this is an\n@@ -2247,7 +2247,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t  || warning_suppressed_p (olddecl, OPT_Wpedantic))\n \treturn true;  /* Allow OLDDECL to continue in use.  */\n \n-      if (variably_modified_type_p (newtype, NULL))\n+      if (c_type_variably_modified_p (newtype))\n \t{\n \t  error (\"redefinition of typedef %q+D with variably modified type\",\n \t\t newdecl);\n@@ -3975,7 +3975,7 @@ static void\n warn_about_goto (location_t goto_loc, tree label, tree decl)\n {\n   auto_diagnostic_group d;\n-  if (variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+  if (c_type_variably_modified_p (TREE_TYPE (decl)))\n     error_at (goto_loc,\n \t      \"jump into scope of identifier with variably modified type\");\n   else\n@@ -4249,7 +4249,7 @@ c_check_switch_jump_warnings (struct c_spot_bindings *switch_bindings,\n \t    {\n \t      auto_diagnostic_group d;\n \t      bool emitted;\n-\t      if (variably_modified_type_p (TREE_TYPE (b->decl), NULL_TREE))\n+\t      if (c_type_variably_modified_p (TREE_TYPE (b->decl)))\n \t\t{\n \t\t  saw_error = true;\n \t\t  error_at (case_loc,\n@@ -5862,7 +5862,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n-\t  && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+\t  && c_type_variably_modified_p (TREE_TYPE (decl)))\n \tadd_stmt (build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl));\n \n       rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl), 0);\n@@ -6682,7 +6682,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n   if ((decl_context == NORMAL || decl_context == FIELD)\n       && current_scope == file_scope\n-      && variably_modified_type_p (type, NULL_TREE))\n+      && c_type_variably_modified_p (type))\n     {\n       if (name)\n \terror_at (loc, \"variably modified %qE at file scope\", name);\n@@ -6928,6 +6928,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  array_parm_static = false;\n \t}\n \n+      bool varmod = C_TYPE_VARIABLY_MODIFIED (type);\n+\n       switch (declarator->kind)\n \t{\n \tcase cdk_attrs:\n@@ -7282,8 +7284,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       variable size, so the enclosing shared array type\n \t\t       must too.  */\n \t\t    if (size && TREE_CODE (size) == INTEGER_CST)\n-\t\t      type\n-\t\t\t= build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n+\t\t      type = build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n \t\t    C_TYPE_VARIABLE_SIZE (type) = 1;\n \t\t  }\n \n@@ -7493,7 +7494,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       the size evaluation prior to the side effects.  We therefore\n \t       use BIND_EXPRs in TYPENAME contexts too.  */\n \t    if (!TYPE_NAME (type)\n-\t\t&& variably_modified_type_p (type, NULL_TREE))\n+\t\t&& c_type_variably_modified_p (type))\n \t      {\n \t\ttree bind = NULL_TREE;\n \t\tif (decl_context == TYPENAME || decl_context == PARM)\n@@ -7534,6 +7535,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      if (type != error_mark_node)\n+\tC_TYPE_VARIABLY_MODIFIED (type) = varmod || size_varies;\n     }\n   *decl_attrs = chainon (returned_attrs, *decl_attrs);\n   *decl_attrs = chainon (decl_id_attrs, *decl_attrs);\n@@ -7728,7 +7731,7 @@ grokdeclarator (const struct c_declarator *declarator,\n     }\n \n   if (pedantic && decl_context == FIELD\n-      && variably_modified_type_p (type, NULL_TREE))\n+      && c_type_variably_modified_p (type))\n     {\n       /* C99 6.7.2.1p8 */\n       pedwarn (loc, OPT_Wpedantic, \"a member of a structure or union cannot \"\n@@ -7996,7 +7999,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       have a member with such a qualifier.  const\n \t       qualification is implicitly added, and, at file scope,\n \t       has internal linkage.  */\n-\t    if (variably_modified_type_p (type, NULL_TREE))\n+\t    if (c_type_variably_modified_p (type))\n \t      error_at (loc, \"%<constexpr%> object has variably modified \"\n \t\t\t\"type\");\n \t    if (type_quals\n@@ -8078,7 +8081,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t || (storage_class == csc_none\n \t     && TREE_CODE (type) == FUNCTION_TYPE\n \t     && !funcdef_flag))\n-\t&& variably_modified_type_p (type, NULL_TREE))\n+\t&& c_type_variably_modified_p (type))\n       {\n \t/* C99 6.7.5.2p2 */\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -9233,6 +9236,10 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       if (C_DECL_VARIABLE_SIZE (x))\n \tC_TYPE_VARIABLE_SIZE (t) = 1;\n \n+      /* If any field is variably modified, record this fact. */\n+      if (C_TYPE_VARIABLY_MODIFIED (TREE_TYPE (x)))\n+\tC_TYPE_VARIABLY_MODIFIED (t) = 1;\n+\n       if (DECL_C_BIT_FIELD (x))\n \t{\n \t  unsigned HOST_WIDE_INT width = tree_to_uhwi (DECL_INITIAL (x));\n@@ -9431,6 +9438,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       C_TYPE_FIELDS_VOLATILE (x) = C_TYPE_FIELDS_VOLATILE (t);\n       C_TYPE_FIELDS_NON_CONSTEXPR (x) = C_TYPE_FIELDS_NON_CONSTEXPR (t);\n       C_TYPE_VARIABLE_SIZE (x) = C_TYPE_VARIABLE_SIZE (t);\n+      C_TYPE_VARIABLY_MODIFIED (x) = C_TYPE_VARIABLY_MODIFIED (t);\n       C_TYPE_INCOMPLETE_VARS (x) = NULL_TREE;\n     }\n \n@@ -9447,7 +9455,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   /* If we're inside a function proper, i.e. not file-scope and not still\n      parsing parameters, then arrange for the size of a variable sized type\n      to be bound now.  */\n-  if (building_stmt_list_p () && variably_modified_type_p (t, NULL_TREE))\n+  if (building_stmt_list_p () && c_type_variably_modified_p(t))\n     add_stmt (build_stmt (loc,\n \t\t\t  DECL_EXPR, build_decl (loc, TYPE_DECL, NULL, t)));\n "}, {"sha": "e4aed61ed007ce507009c2f31f437f77398d8c7e", "filename": "gcc/c/c-objc-common.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-objc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-objc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.cc?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -371,12 +371,12 @@ c_types_compatible_p (tree x, tree y)\n   return comptypes (TYPE_MAIN_VARIANT (x), TYPE_MAIN_VARIANT (y));\n }\n \n-/* Determine if the type is a vla type for the backend.  */\n+/* Determine if the type is a variably modified type for the backend.  */\n \n bool\n-c_vla_unspec_p (tree x, tree fn ATTRIBUTE_UNUSED)\n+c_var_mod_p (tree x, tree fn ATTRIBUTE_UNUSED)\n {\n-  return c_vla_type_p (x);\n+  return C_TYPE_VARIABLY_MODIFIED (x);\n }\n \n /* Special routine to get the alias set of T for C.  */"}, {"sha": "d31dacb9dd47bf46b0c36d9c791b2fad92656d72", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -123,5 +123,5 @@ along with GCC; see the file COPYING3.  If not see\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP c_omp_clause_copy_ctor\n \n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P\n-#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_vla_unspec_p\n+#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_var_mod_p\n #endif /* GCC_C_OBJC_COMMON */"}, {"sha": "21bc3167ce224823c214efc064be399f2da9c787", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -2494,8 +2494,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  init = convert_lvalue_to_rvalue (init_loc, init, true, true,\n \t\t\t\t\t\t   true);\n \t\t  tree init_type = TREE_TYPE (init.value);\n-\t\t  bool vm_type = variably_modified_type_p (init_type,\n-\t\t\t\t\t\t\t   NULL_TREE);\n+\t\t  bool vm_type = c_type_variably_modified_p (init_type);\n \t\t  if (vm_type)\n \t\t    init.value = save_expr (init.value);\n \t\t  finish_init ();\n@@ -4143,7 +4142,7 @@ c_parser_typeof_specifier (c_parser *parser)\n       if (type != NULL)\n \t{\n \t  ret.spec = groktypename (type, &ret.expr, &ret.expr_const_operands);\n-\t  pop_maybe_used (variably_modified_type_p (ret.spec, NULL_TREE));\n+\t  pop_maybe_used (c_type_variably_modified_p (ret.spec));\n \t}\n     }\n   else\n@@ -4158,7 +4157,7 @@ c_parser_typeof_specifier (c_parser *parser)\n \terror_at (here, \"%<typeof%> applied to a bit-field\");\n       mark_exp_read (expr.value);\n       ret.spec = TREE_TYPE (expr.value);\n-      was_vm = variably_modified_type_p (ret.spec, NULL_TREE);\n+      was_vm = c_type_variably_modified_p (ret.spec);\n       /* This is returned with the type so that when the type is\n \t evaluated, this can be evaluated.  */\n       if (was_vm)\n@@ -9058,7 +9057,7 @@ c_parser_has_attribute_expression (c_parser *parser)\n       if (tname)\n \t{\n \t  oper = groktypename (tname, NULL, NULL);\n-\t  pop_maybe_used (variably_modified_type_p (oper, NULL_TREE));\n+\t  pop_maybe_used (c_type_variably_modified_p (oper));\n \t}\n     }\n   else\n@@ -9071,7 +9070,7 @@ c_parser_has_attribute_expression (c_parser *parser)\n \t  mark_exp_read (cexpr.value);\n \t  oper = cexpr.value;\n \t  tree etype = TREE_TYPE (oper);\n-\t  bool was_vm = variably_modified_type_p (etype, NULL_TREE);\n+\t  bool was_vm = c_type_variably_modified_p (etype);\n \t  /* This is returned with the type so that when the type is\n \t     evaluated, this can be evaluated.  */\n \t  if (was_vm)\n@@ -9320,7 +9319,7 @@ c_parser_generic_selection (c_parser *parser)\n \t    error_at (assoc.type_location,\n \t\t      \"%<_Generic%> association has incomplete type\");\n \n-\t  if (variably_modified_type_p (assoc.type, NULL_TREE))\n+\t  if (c_type_variably_modified_p (assoc.type))\n \t    error_at (assoc.type_location,\n \t\t      \"%<_Generic%> association has \"\n \t\t      \"variable length type\");"}, {"sha": "e6b6fe9a40e7cd94df73af4bd283c72fcd8e5175", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -59,6 +59,10 @@ along with GCC; see the file COPYING3.  If not see\n #define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n #define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n \n+/* Record whether a type is variably modified. */\n+#define C_TYPE_VARIABLY_MODIFIED(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n+\n+\n /* Record whether a type is defined inside a struct or union type.\n    This is used for -Wc++-compat. */\n #define C_TYPE_DEFINED_IN_STRUCT(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n@@ -714,7 +718,7 @@ extern bool c_objc_common_init (void);\n extern bool c_missing_noreturn_ok_p (tree);\n extern bool c_warn_unused_global_decl (const_tree);\n extern void c_initialize_diagnostics (diagnostic_context *);\n-extern bool c_vla_unspec_p (tree x, tree fn);\n+extern bool c_var_mod_p (tree x, tree fn);\n extern alias_set_type c_get_alias_set (tree);\n \n /* in c-typeck.cc */\n@@ -729,14 +733,22 @@ extern location_t c_last_sizeof_loc;\n extern struct c_switch *c_switch_stack;\n \n extern bool null_pointer_constant_p (const_tree);\n+\n+\n+inline\n+bool c_type_variably_modified_p (tree t)\n+{\n+  return error_mark_node != t && C_TYPE_VARIABLY_MODIFIED (t);\n+}\n+\n+\n extern bool char_type_p (tree);\n extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (location_t, tree);\n extern bool same_translation_unit_p (const_tree, const_tree);\n extern int comptypes (tree, tree);\n extern int comptypes_check_different_types (tree, tree, bool *);\n extern int comptypes_check_enum_int (tree, tree, bool *);\n-extern bool c_vla_type_p (const_tree);\n extern bool c_mark_addressable (tree, bool = false);\n extern void c_incomplete_type_error (location_t, const_tree, const_tree);\n extern tree c_type_promotes_to (tree);"}, {"sha": "45bacc06c474f75144386c387cbd59d70fbaf37d", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -356,16 +356,6 @@ qualify_type (tree type, tree like)\n \t\t\t\t | ENCODE_QUAL_ADDR_SPACE (as_common));\n }\n \n-/* Return true iff the given tree T is a variable length array.  */\n-\n-bool\n-c_vla_type_p (const_tree t)\n-{\n-  if (TREE_CODE (t) == ARRAY_TYPE\n-      && C_TYPE_VARIABLE_SIZE (t))\n-    return true;\n-  return false;\n-}\n \n /* If NTYPE is a type of a non-variadic function with a prototype\n    and OTYPE is a type of a function without a prototype and ATTRS\n@@ -471,8 +461,8 @@ composite_type (tree t1, tree t2)\n \td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n-\td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n-\td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n+\td1_variable = d1_variable || (d1_zero && C_TYPE_VARIABLE_SIZE (t1));\n+\td2_variable = d2_variable || (d2_zero && C_TYPE_VARIABLE_SIZE (t2));\n \n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1)\n@@ -1248,8 +1238,8 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n \td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n-\td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n-\td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n+\td1_variable = d1_variable || (d1_zero && C_TYPE_VARIABLE_SIZE (t1));\n+\td2_variable = d2_variable || (d2_zero && C_TYPE_VARIABLE_SIZE (t2));\n \n \tif (different_types_p != NULL\n \t    && d1_variable != d2_variable)\n@@ -3346,7 +3336,7 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n   /* In this improbable scenario, a nested function returns a VM type.\n      Create a TARGET_EXPR so that the call always has a LHS, much as\n      what the C++ FE does for functions returning non-PODs.  */\n-  if (variably_modified_type_p (TREE_TYPE (fntype), NULL_TREE))\n+  if (C_TYPE_VARIABLY_MODIFIED (TREE_TYPE (fntype)))\n     {\n       tree tmp = create_tmp_var_raw (TREE_TYPE (fntype));\n       result = build4 (TARGET_EXPR, TREE_TYPE (fntype), tmp, result,"}, {"sha": "1cbb05b03ce82a572915e487d6bca4629fca8b13", "filename": "gcc/testsuite/gcc.dg/pr108375-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-1.c?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -0,0 +1,14 @@\n+/* PR 108375\n+ * { dg-do compile }\n+ * { dg-options \"\" }\n+ * */\n+\n+void\n+f (int a)\n+{\n+  goto x;\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+  struct { char (*p)[a]; } B;\n+  x : ;\n+}\n+\n+"}, {"sha": "0401ead5b2143e40516068d239d7b33fe6dc1b89", "filename": "gcc/testsuite/gcc.dg/pr108375-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47821ba07a19b672d3cba351a03af2b122e02213/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-2.c?ref=47821ba07a19b672d3cba351a03af2b122e02213", "patch": "@@ -0,0 +1,15 @@\n+/* PR 108375\n+ * { dg-do compile }\n+ * { dg-options \"\" }\n+ * */\n+\n+void\n+f (int a)\n+{\n+  typedef int A[a];\n+  goto x;\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+  A *p[2];\n+  x : ;\n+}\n+\n+"}]}