{"sha": "a8d9381738d229b9ebad9a91bc2cd211e368c750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThkOTM4MTczOGQyMjliOWViYWQ5YTkxYmMyY2QyMTFlMzY4Yzc1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-01T22:22:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-01T22:22:26Z"}, "message": "ipa-icf.c (sem_function::init): Fix formating; skip GIMPLE_PREDICT.\n\n\t* ipa-icf.c (sem_function::init): Fix formating; skip GIMPLE_PREDICT.\n\t(sem_item::add_expr): New function.\n\t(sem_function::hash_stmt): Handle operands of most statements.\n\t(sem_variable::get_hash): Hash the actual constructor.\n\t* ipa-icf.h (sem_item): Add add_expr.\n\t(sem_function): Update prototype of hash_stmt\n\nFrom-SVN: r221092", "tree": {"sha": "bca4388d8754c5208003420a930bf8c221bf2c88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bca4388d8754c5208003420a930bf8c221bf2c88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8d9381738d229b9ebad9a91bc2cd211e368c750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d9381738d229b9ebad9a91bc2cd211e368c750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8d9381738d229b9ebad9a91bc2cd211e368c750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d9381738d229b9ebad9a91bc2cd211e368c750/comments", "author": null, "committer": null, "parents": [{"sha": "f7f64d539a9d97d9f52bd408bec309233831e36c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f64d539a9d97d9f52bd408bec309233831e36c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7f64d539a9d97d9f52bd408bec309233831e36c"}], "stats": {"total": 177, "additions": 129, "deletions": 48}, "files": [{"sha": "dcaa0f3283029b24d87a1552a139832cd38b3248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8d9381738d229b9ebad9a91bc2cd211e368c750/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8d9381738d229b9ebad9a91bc2cd211e368c750/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8d9381738d229b9ebad9a91bc2cd211e368c750", "patch": "@@ -1,3 +1,12 @@\n+2015-02-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c (sem_function::init): Fix formating; skip GIMPLE_PREDICT.\n+\t(sem_item::add_expr): New function.\n+\t(sem_function::hash_stmt): Handle operands of most statements.\n+\t(sem_variable::get_hash): Hash the actual constructor.\n+\t* ipa-icf.h (sem_item): Add add_expr.\n+\t(sem_function): Update prototype of hash_stmt\n+\n 2015-02-28  Martin Liska  <mliska@suse.cz>\n \t    Jan Hubicka   <hubicka@ucw.cz>\n "}, {"sha": "68d02e473321a7962f329a06a26e2cdb7351ff29", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 117, "deletions": 47, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8d9381738d229b9ebad9a91bc2cd211e368c750/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8d9381738d229b9ebad9a91bc2cd211e368c750/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=a8d9381738d229b9ebad9a91bc2cd211e368c750", "patch": "@@ -1030,7 +1030,8 @@ sem_function::init (void)\n     unsigned nondbg_stmt_count = 0;\n \n     edge e;\n-    for (edge_iterator ei = ei_start (bb->preds); ei_cond (ei, &e); ei_next (&ei))\n+    for (edge_iterator ei = ei_start (bb->preds); ei_cond (ei, &e);\n+\t ei_next (&ei))\n       cfg_checksum = iterative_hash_host_wide_int (e->flags,\n \t\t     cfg_checksum);\n \n@@ -1039,9 +1040,10 @@ sem_function::init (void)\n       {\n \tgimple stmt = gsi_stmt (gsi);\n \n-\tif (gimple_code (stmt) != GIMPLE_DEBUG)\n+\tif (gimple_code (stmt) != GIMPLE_DEBUG\n+\t    && gimple_code (stmt) != GIMPLE_PREDICT)\n \t  {\n-\t    hash_stmt (&hstate, stmt);\n+\t    hash_stmt (stmt, hstate);\n \t    nondbg_stmt_count++;\n \t  }\n       }\n@@ -1051,60 +1053,128 @@ sem_function::init (void)\n \n     /* Inserting basic block to hash table.  */\n     sem_bb *semantic_bb = new sem_bb (bb, nondbg_stmt_count,\n-\t\t\t\t      EDGE_COUNT (bb->preds) + EDGE_COUNT (bb->succs));\n+\t\t\t\t      EDGE_COUNT (bb->preds)\n+\t\t\t\t      + EDGE_COUNT (bb->succs));\n \n     bb_sorted.safe_push (semantic_bb);\n   }\n \n   parse_tree_args ();\n }\n \n+/* Accumulate to HSTATE a hash of expression EXP.\n+   Identical to inchash::add_expr, but guaranteed to be stable across LTO\n+   and DECL equality classes.  */\n+\n+void\n+sem_item::add_expr (const_tree exp, inchash::hash &hstate)\n+{\n+  if (exp == NULL_TREE)\n+    {\n+      hstate.merge_hash (0);\n+      return;\n+    }\n+\n+  /* Handled component can be matched in a cureful way proving equivalence\n+     even if they syntactically differ.  Just skip them.  */\n+  STRIP_NOPS (exp);\n+  while (handled_component_p (exp))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  enum tree_code code = TREE_CODE (exp);\n+  hstate.add_int (code);\n+\n+  switch (code)\n+    {\n+    /* Use inchash::add_expr for everything that is LTO stable.  */\n+    case VOID_CST:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+      inchash::add_expr (exp, hstate);\n+      break;\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree value;\n+\n+\thstate.add_wide_int (int_size_in_bytes (TREE_TYPE (exp)));\n+\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n+\t  if (value)\n+\t    add_expr (value, hstate);\n+\tbreak;\n+      }\n+    case ADDR_EXPR:\n+    case FDESC_EXPR:\n+      add_expr (get_base_address (TREE_OPERAND (exp, 0)), hstate);\n+      break;\n+    case SSA_NAME:\n+    case VAR_DECL:\n+    case CONST_DECL:\n+    case PARM_DECL:\n+      hstate.add_wide_int (int_size_in_bytes (TREE_TYPE (exp)));\n+      break;\n+    case MEM_REF:\n+    case POINTER_PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case RANGE_EXPR:\n+      add_expr (TREE_OPERAND (exp, 0), hstate);\n+      add_expr (TREE_OPERAND (exp, 1), hstate);\n+      break;\n+    case PLUS_EXPR:\n+      {\n+\tinchash::hash one, two;\n+\tadd_expr (TREE_OPERAND (exp, 0), one);\n+\tadd_expr (TREE_OPERAND (exp, 1), two);\n+\thstate.add_commutative (one, two);\n+      }\n+      break;\n+    CASE_CONVERT:\n+      hstate.add_wide_int (int_size_in_bytes (TREE_TYPE (exp)));\n+      return add_expr (TREE_OPERAND (exp, 0), hstate);\n+    default:\n+      break;\n+    }\n+}\n+\n /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n \n void\n-sem_function::hash_stmt (inchash::hash *hstate, gimple stmt)\n+sem_function::hash_stmt (gimple stmt, inchash::hash &hstate)\n {\n   enum gimple_code code = gimple_code (stmt);\n \n-  hstate->add_int (code);\n+  hstate.add_int (code);\n \n-  if (code == GIMPLE_CALL)\n+  switch (code)\n     {\n-      /* Checking of argument.  */\n-      for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n+    case GIMPLE_ASSIGN:\n+      if (commutative_tree_code (gimple_assign_rhs_code (stmt))\n+\t  || commutative_ternary_tree_code (gimple_assign_rhs_code (stmt)))\n \t{\n-\t  tree argument = gimple_call_arg (stmt, i);\n+\t  inchash::hash one, two;\n \n-\t  switch (TREE_CODE (argument))\n-\t    {\n-\t    case INTEGER_CST:\n-\t      if (tree_fits_shwi_p (argument))\n-\t\thstate->add_wide_int (tree_to_shwi (argument));\n-\t      else if (tree_fits_uhwi_p (argument))\n-\t\thstate->add_wide_int (tree_to_uhwi (argument));\n-\t      break;\n-\t    case REAL_CST:\n-\t      REAL_VALUE_TYPE c;\n-\t      HOST_WIDE_INT n;\n-\n-\t      c = TREE_REAL_CST (argument);\n-\t      n = real_to_integer (&c);\n-\n-\t      hstate->add_wide_int (n);\n-\t      break;\n-\t    case ADDR_EXPR:\n-\t      {\n-\t\ttree addr_operand = TREE_OPERAND (argument, 0);\n-\n-\t\tif (TREE_CODE (addr_operand) == STRING_CST)\n-\t\t  hstate->add (TREE_STRING_POINTER (addr_operand),\n-\t\t\t       TREE_STRING_LENGTH (addr_operand));\n-\t\tbreak;\n-\t      }\n-\t    default:\n-\t      break;\n-\t    }\n+\t  add_expr (gimple_assign_rhs1 (stmt), one);\n+\t  add_expr (gimple_assign_rhs2 (stmt), two);\n+\t  hstate.add_commutative (one, two);\n+\t  add_expr (gimple_assign_lhs (stmt), hstate);\n+\t  break;\n \t}\n+      /* ... fall through ... */\n+    case GIMPLE_CALL:\n+    case GIMPLE_ASM:\n+    case GIMPLE_COND:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_RETURN:\n+      /* All these statements are equivalent if their operands are.  */\n+      for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n+\tadd_expr (gimple_op (stmt, i), hstate);\n+    default:\n+      break;\n     }\n }\n \n@@ -1474,17 +1544,17 @@ sem_variable::get_hash (void)\n   if (hash)\n     return hash;\n \n+  /* All WPA streamed in symbols should have their hashes computed at compile\n+     time.  At this point, the constructor may not be in memory at all.\n+     DECL_INITIAL (decl) would be error_mark_node in that case.  */\n+  gcc_assert (!node->lto_file_data);\n+  tree ctor = DECL_INITIAL (decl);\n   inchash::hash hstate;\n \n   hstate.add_int (456346417);\n-  hstate.add_int (TREE_CODE (ctor));\n-\n-  if (TREE_CODE (ctor) == CONSTRUCTOR)\n-    {\n-      unsigned length = vec_safe_length (CONSTRUCTOR_ELTS (ctor));\n-      hstate.add_int (length);\n-    }\n-\n+  if (DECL_SIZE (decl) && tree_fits_shwi_p (DECL_SIZE (decl)))\n+    hstate.add_wide_int (tree_to_shwi (DECL_SIZE (decl)));\n+  add_expr (ctor, hstate);\n   hash = hstate.end ();\n \n   return hash;"}, {"sha": "3e5d458247c8781ea996f0ce5e76c3efb88ba3ce", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8d9381738d229b9ebad9a91bc2cd211e368c750/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8d9381738d229b9ebad9a91bc2cd211e368c750/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=a8d9381738d229b9ebad9a91bc2cd211e368c750", "patch": "@@ -241,6 +241,8 @@ class sem_item\n protected:\n   /* Cached, once calculated hash for the item.  */\n   hashval_t hash;\n+  /* Accumulate to HSTATE a hash of constructor expression EXP.  */\n+  static void add_expr (const_tree exp, inchash::hash &hstate);\n \n private:\n   /* Initialize internal data structures. Bitmap STACK is used for\n@@ -290,7 +292,7 @@ class sem_function: public sem_item\n   }\n \n   /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n-  void hash_stmt (inchash::hash *inchash, gimple stmt);\n+  void hash_stmt (gimple stmt, inchash::hash &inchash);\n \n   /* Return true if polymorphic comparison must be processed.  */\n   bool compare_polymorphic_p (void);"}]}