{"sha": "322821b9ad320f6f0104844d6442b02c57da1a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIyODIxYjlhZDMyMGY2ZjAxMDQ4NDRkNjQ0MmIwMmM1N2RhMWE5NA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-10-24T02:37:56Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-10-24T02:37:56Z"}, "message": "Make -fno-exceptions work.\n\n\n2001-10-23  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tMake -fno-exceptions work.\n\t* config/locale/c_locale_gnu.cc: Use functexcept.\n\t* include/bits/c++config (__stl_assert): Remove.\n\t(__STL_USE_EXCEPTIONS): Same.\n\t(__STL_TRY): Same.\n\t(__STL_CATCH_ALL): Same.\n\t(__STL_THROW): Same.\n\t(__STL_RETHROW): Same.\n\t(__STL_NOTHROW): Same.\n\t(__STL_UNWIND): Same.\n\t* include/bits/pthread_allocimpl.h: Fix.\n\t* include/bits/std_bitset.h: Same.\n\t* include/bits/std_list.h: Same.\n\t* include/bits/std_memory.h: Same.\n\t* include/bits/std_queue.h: Same.\n\t* include/bits/stl_alloc.h: Same.\n\t* include/bits/stl_deque.h: Same.\n\t* include/bits/stl_list.h: Same.\n\t* include/bits/stl_queue.h: Same.\n\t* include/bits/stl_tempbuf.h: Same.\n\t* include/bits/stl_tree.h: Same.\n\t* include/bits/stl_uninitialized.h: Same.\n\t* include/bits/stl_vector.h: Same.\n\t* include/ext/ropeimpl.h: Same.\n\t* include/ext/slist: Same.\n\t* include/ext/stl_hashtable.h: Same.\n\t* include/ext/stl_rope.h: Same.\n\t* libsupc++/new_op.cc: Include cstdlib.\n\t* libsupc++/eh_personality.cc: Add exception_defines include. Use\n\t__throw_exception_again, tweak.\n\t* libsupc++/eh_aux_runtime.cc: Include stdlib for abort.\n\t* libsupc++/vec.cc: Tweak.\n\t* src/functexcept.cc: Remove unused arguments.\n\t* testsuite/23_containers/bitset_members.cc: Tweak.\n\nFrom-SVN: r46455", "tree": {"sha": "95892375e0037abfccb367e7ddf20eb86e127183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95892375e0037abfccb367e7ddf20eb86e127183"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/322821b9ad320f6f0104844d6442b02c57da1a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322821b9ad320f6f0104844d6442b02c57da1a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/322821b9ad320f6f0104844d6442b02c57da1a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322821b9ad320f6f0104844d6442b02c57da1a94/comments", "author": null, "committer": null, "parents": [{"sha": "c8cf201f95b9847d9a50acba19506fdec461351c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8cf201f95b9847d9a50acba19506fdec461351c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8cf201f95b9847d9a50acba19506fdec461351c"}], "stats": {"total": 941, "additions": 554, "deletions": 387}, "files": [{"sha": "d0ad067222fd201479ffb15d58f3942bdb9c3ce9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -1,3 +1,40 @@\n+2001-10-23  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tMake -fno-exceptions work.\n+\t* config/locale/c_locale_gnu.cc: Use functexcept.\n+\t* include/bits/c++config (__stl_assert): Remove.\n+\t(__STL_USE_EXCEPTIONS): Same.\n+\t(__STL_TRY): Same.\n+\t(__STL_CATCH_ALL): Same.\n+\t(__STL_THROW): Same.\n+\t(__STL_RETHROW): Same.\n+\t(__STL_NOTHROW): Same.\n+\t(__STL_UNWIND): Same.\n+\t* include/bits/pthread_allocimpl.h: Fix.\n+\t* include/bits/std_bitset.h: Same.\n+\t* include/bits/std_list.h: Same.\n+\t* include/bits/std_memory.h: Same.\n+\t* include/bits/std_queue.h: Same.\n+\t* include/bits/stl_alloc.h: Same.\n+\t* include/bits/stl_deque.h: Same.\n+\t* include/bits/stl_list.h: Same.\n+\t* include/bits/stl_queue.h: Same.\n+\t* include/bits/stl_tempbuf.h: Same.\n+\t* include/bits/stl_tree.h: Same.\n+\t* include/bits/stl_uninitialized.h: Same.\n+\t* include/bits/stl_vector.h: Same.\n+\t* include/ext/ropeimpl.h: Same.\n+\t* include/ext/slist: Same.\n+\t* include/ext/stl_hashtable.h: Same.\n+\t* include/ext/stl_rope.h: Same.\n+\t* libsupc++/new_op.cc: Include cstdlib.\n+\t* libsupc++/eh_personality.cc: Add exception_defines include. Use\n+\t__throw_exception_again, tweak.\n+\t* libsupc++/eh_aux_runtime.cc: Include stdlib for abort.\n+\t* libsupc++/vec.cc: Tweak.\n+\t* src/functexcept.cc: Remove unused arguments.\n+\t* testsuite/23_containers/bitset_members.cc: Tweak.\n+\n 2001-10-22  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* config/cpu/i386/bits/limits.h: Move to..."}, {"sha": "8b11d672d932b68ed3dd348be2a48bdd8fdd2bd3", "filename": "libstdc++-v3/config/locale/c_locale_gnu.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fc_locale_gnu.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fc_locale_gnu.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fc_locale_gnu.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -50,7 +50,7 @@ namespace std\n     if (!__cloc)\n       {\n \t// This named locale is not supported by the underlying OS.\n-\tthrow runtime_error(\"attempt to create locale from unknown name\");\n+\t__throw_runtime_error(\"attempt to create locale from unknown name\");\n       }\n   }\n   "}, {"sha": "e1d5ae36386b1237a0a4e5f7006ca11ac11d01cb", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -72,25 +72,6 @@\n // internal ABI change).\n #define __STL_GTHREADS\n #define __STL_THREADS\n-#define __STL_VOLATILE volatile\n-\n-// This is also a user hook, but via -f[no-]exceptions, not direct #defines.\n-#ifdef __EXCEPTIONS\n-# define __STL_USE_EXCEPTIONS\n-# define __STL_TRY try\n-# define __STL_CATCH_ALL catch(...)\n-# define __STL_THROW(x) throw x\n-# define __STL_RETHROW throw\n-# define __STL_NOTHROW throw()\n-# define __STL_UNWIND(action) catch(...) { action; throw; }\n-#else\n-# define __STL_TRY \n-# define __STL_CATCH_ALL if (false)\n-# define __STL_THROW(x) \n-# define __STL_RETHROW \n-# define __STL_NOTHROW \n-# define __STL_UNWIND(action) \n-#endif\n \n // Default to the typically high-speed, pool-based allocator (as\n // libstdc++-v2) instead of the malloc-based allocator (libstdc++-v3\n@@ -104,11 +85,6 @@\n // The remainder of the prewritten config is mostly automatic; all the\n // user hooks are listed above.\n \n-// XXX \n-// Only used in the SGI rope extensions; this is from stl_config.h and\n-// should be cleaned up.\n-# define __stl_assert(expr)\n-\n /** @namespace std\n  *  @brief Everything defined by the ISO C++ Standard is within namespace std.\n  */"}, {"sha": "1c52127f1922416b8c812212d08522bd02e6b10a", "filename": "libstdc++-v3/include/bits/pthread_allocimpl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -422,12 +422,12 @@ class pthread_allocator {\n     typedef pthread_allocator<_NewType> other;\n   };\n \n-  pthread_allocator() __STL_NOTHROW {}\n-  pthread_allocator(const pthread_allocator& a) __STL_NOTHROW {}\n+  pthread_allocator() throw() {}\n+  pthread_allocator(const pthread_allocator& a) throw() {}\n   template <class _OtherType>\n \tpthread_allocator(const pthread_allocator<_OtherType>&)\n-\t\t__STL_NOTHROW {}\n-  ~pthread_allocator() __STL_NOTHROW {}\n+\t\tthrow() {}\n+  ~pthread_allocator() throw() {}\n \n   pointer address(reference __x) const { return &__x; }\n   const_pointer address(const_reference __x) const { return &__x; }\n@@ -443,7 +443,7 @@ class pthread_allocator {\n   void deallocate(pointer __p, size_type __n)\n     { _S_Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n \n-  size_type max_size() const __STL_NOTHROW \n+  size_type max_size() const throw() \n     { return size_t(-1) / sizeof(_Tp); }\n \n   void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }"}, {"sha": "d8524cac390247080122ab3a03d2780492fb6e44", "filename": "libstdc++-v3/include/bits/std_bitset.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -59,9 +59,9 @@\n #include <bits/std_cstddef.h>     // for size_t\n #include <bits/std_cstring.h>     // for memset\n #include <bits/std_string.h>\n-#include <bits/std_stdexcept.h>   // for invalid_argument, out_of_range, \n-\t\t\t\t  // overflow_error\n-\n+#include <bits/std_stdexcept.h>\n+#include <bits/functexcept.h>   // for invalid_argument, out_of_range, \n+\t\t\t         // overflow_error\n #include <bits/std_ostream.h>     // for ostream (operator<<)\n #include <bits/std_istream.h>     // for istream (operator>>)\n \n@@ -244,7 +244,7 @@ unsigned long _Base_bitset<_Nw>::_M_do_to_ulong() const\n {\n   for (size_t __i = 1; __i < _Nw; ++__i) \n     if (_M_w[__i]) \n-      __STL_THROW(overflow_error(\"bitset\"));\n+      __throw_overflow_error(\"bitset\");\n   \n   return _M_w[0];\n }\n@@ -490,7 +490,7 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n     : _Base() \n   {\n     if (__pos > __s.size()) \n-      __STL_THROW(out_of_range(\"bitset\"));\n+      __throw_out_of_range(\"bitset\");\n     _M_copy_from_string(__s, __pos,\n                         basic_string<_CharT, _Traits, _Alloc>::npos);\n   }\n@@ -501,7 +501,7 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n     : _Base() \n   {\n     if (__pos > __s.size()) \n-      __STL_THROW(out_of_range(\"bitset\"));\n+      __throw_out_of_range(\"bitset\");\n     _M_copy_from_string(__s, __pos, __n);\n   }\n \n@@ -577,7 +577,7 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n \n   bitset<_Nb>& set(size_t __pos, bool __val = true) {\n     if (__pos >= _Nb)\n-      __STL_THROW(out_of_range(\"bitset\"));\n+      __throw_out_of_range(\"bitset\");\n \n     return _Unchecked_set(__pos, __val);\n   }\n@@ -589,7 +589,7 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n \n   bitset<_Nb>& reset(size_t __pos) {\n     if (__pos >= _Nb)\n-      __STL_THROW(out_of_range(\"bitset\"));\n+      __throw_out_of_range(\"bitset\");\n \n     return _Unchecked_reset(__pos);\n   }\n@@ -602,7 +602,7 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n \n   bitset<_Nb>& flip(size_t __pos) {\n     if (__pos >= _Nb)\n-      __STL_THROW(out_of_range(\"bitset\"));\n+      __throw_out_of_range(\"bitset\");\n \n     return _Unchecked_flip(__pos);\n   }\n@@ -650,7 +650,7 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n \n   bool test(size_t __pos) const {\n     if (__pos >= _Nb)\n-      __STL_THROW(out_of_range(\"bitset\"));\n+      __throw_out_of_range(\"bitset\");\n \n     return _Unchecked_test(__pos);\n   }\n@@ -700,7 +700,7 @@ void bitset<_Nb>\n       set(__i);\n       break;\n     default:\n-      __STL_THROW(invalid_argument(\"bitset\"));\n+      __throw_invalid_argument(\"bitset\");\n     }\n   }\n }"}, {"sha": "e34734d1d449461f2b585de902208ff41b65e20d", "filename": "libstdc++-v3/include/bits/std_list.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_list.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -58,6 +58,7 @@\n \n #pragma GCC system_header\n \n+#include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n #include <bits/stl_alloc.h>\n #include <bits/stl_construct.h>"}, {"sha": "1aab9ffe13f4e3fe8a91c978fb12a611db10bd14", "filename": "libstdc++-v3/include/bits/std_memory.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -69,19 +69,19 @@ template <class _Tp> class auto_ptr {\n public:\n   typedef _Tp element_type;\n \n-  explicit auto_ptr(_Tp* __p = 0) __STL_NOTHROW : _M_ptr(__p) {}\n-  auto_ptr(auto_ptr& __a) __STL_NOTHROW : _M_ptr(__a.release()) {}\n+  explicit auto_ptr(_Tp* __p = 0) throw() : _M_ptr(__p) {}\n+  auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) {}\n \n-  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) __STL_NOTHROW\n+  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) throw()\n     : _M_ptr(__a.release()) {}\n \n-  auto_ptr& operator=(auto_ptr& __a) __STL_NOTHROW {\n+  auto_ptr& operator=(auto_ptr& __a) throw() {\n     reset(__a.release());\n     return *this;\n   }\n \n   template <class _Tp1>\n-  auto_ptr& operator=(auto_ptr<_Tp1>& __a) __STL_NOTHROW {\n+  auto_ptr& operator=(auto_ptr<_Tp1>& __a) throw() {\n     reset(__a.release());\n     return *this;\n   }\n@@ -92,21 +92,21 @@ template <class _Tp> class auto_ptr {\n   // this is prohibited.\n   ~auto_ptr() { delete _M_ptr; }\n  \n-  _Tp& operator*() const __STL_NOTHROW {\n+  _Tp& operator*() const throw() {\n     return *_M_ptr;\n   }\n-  _Tp* operator->() const __STL_NOTHROW {\n+  _Tp* operator->() const throw() {\n     return _M_ptr;\n   }\n-  _Tp* get() const __STL_NOTHROW {\n+  _Tp* get() const throw() {\n     return _M_ptr;\n   }\n-  _Tp* release() __STL_NOTHROW {\n+  _Tp* release() throw() {\n     _Tp* __tmp = _M_ptr;\n     _M_ptr = 0;\n     return __tmp;\n   }\n-  void reset(_Tp* __p = 0) __STL_NOTHROW {\n+  void reset(_Tp* __p = 0) throw() {\n     if (__p != _M_ptr) {\n       delete _M_ptr;\n       _M_ptr = __p;\n@@ -118,20 +118,20 @@ template <class _Tp> class auto_ptr {\n   // in fact, most present-day compilers do not support the language \n   // features that these conversions rely on.\n public:\n-  auto_ptr(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW\n+  auto_ptr(auto_ptr_ref<_Tp> __ref) throw()\n     : _M_ptr(__ref._M_ptr) {}\n \n-  auto_ptr& operator=(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW {\n+  auto_ptr& operator=(auto_ptr_ref<_Tp> __ref) throw() {\n     if (__ref._M_ptr != this->get()) {\n       delete _M_ptr;\n       _M_ptr = __ref._M_ptr;\n     }\n     return *this;\n   }\n \n-  template <class _Tp1> operator auto_ptr_ref<_Tp1>() __STL_NOTHROW \n+  template <class _Tp1> operator auto_ptr_ref<_Tp1>() throw() \n     { return auto_ptr_ref<_Tp>(this->release()); }\n-  template <class _Tp1> operator auto_ptr<_Tp1>() __STL_NOTHROW\n+  template <class _Tp1> operator auto_ptr<_Tp1>() throw()\n     { return auto_ptr<_Tp1>(this->release()); }\n };\n "}, {"sha": "87dc80a98c019df6077cf80aa3b5323ff725bc0b", "filename": "libstdc++-v3/include/bits/std_queue.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_queue.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -58,6 +58,7 @@\n \n #pragma GCC system_header\n #include <bits/c++config.h>\n+#include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n #include <bits/stl_alloc.h>\n #include <bits/stl_construct.h>"}, {"sha": "c0a9a46197b930fae97ef747dcef69396e036187", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -306,7 +306,7 @@ class __default_alloc_template {\n         char _M_client_data[1];    /* The client sees this.        */\n   };\n \n-  static _Obj* __STL_VOLATILE _S_free_list[]; \n+  static _Obj* volatile _S_free_list[]; \n         // Specifying a size results in duplicate def for 4.1\n   static  size_t _S_freelist_index(size_t __bytes) {\n         return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);\n@@ -349,7 +349,7 @@ class __default_alloc_template {\n       __ret = __mem_interface::allocate(__n);\n     else \n       {\n-\t_Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n);\n+\t_Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n);\n \t// Acquire the lock here with a constructor call.\n \t// This ensures that it is released in exit or during stack\n \t// unwinding.\n@@ -377,7 +377,7 @@ class __default_alloc_template {\n       __mem_interface::deallocate(__p, __n);\n     else \n       {\n-\t_Obj* __STL_VOLATILE*  __my_free_list\n+\t_Obj* volatile*  __my_free_list\n           = _S_free_list + _S_freelist_index(__n);\n \t_Obj* __q = (_Obj*)__p;\n \t\n@@ -448,7 +448,7 @@ __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,\n         // Try to make use of the left-over piece.\n         if (__bytes_left > 0) \n \t  {\n-\t    _Obj* __STL_VOLATILE* __my_free_list =\n+\t    _Obj* volatile* __my_free_list =\n \t      _S_free_list + _S_freelist_index(__bytes_left);\n \t    \n \t    ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n@@ -458,7 +458,7 @@ __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,\n         if (0 == _S_start_free) \n \t  {\n             size_t __i;\n-            _Obj* __STL_VOLATILE* __my_free_list;\n+            _Obj* volatile* __my_free_list;\n \t    _Obj* __p;\n             // Try to make do with what we have.  That can't hurt.  We\n             // do not try smaller requests, since that tends to result\n@@ -500,7 +500,7 @@ __default_alloc_template<__threads, __inst>::_S_refill(size_t __n)\n {\n     int __nobjs = 20;\n     char* __chunk = _S_chunk_alloc(__n, __nobjs);\n-    _Obj* __STL_VOLATILE* __my_free_list;\n+    _Obj* volatile* __my_free_list;\n     _Obj* __result;\n     _Obj* __current_obj;\n     _Obj* __next_obj;\n@@ -563,7 +563,7 @@ template <bool __threads, int __inst>\n size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n \n template <bool __threads, int __inst>\n-typename __default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE\n+typename __default_alloc_template<__threads, __inst>::_Obj* volatile\n __default_alloc_template<__threads, __inst> ::_S_free_list[\n     __default_alloc_template<__threads, __inst>::_NFREELISTS\n ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n@@ -597,10 +597,10 @@ class allocator {\n     typedef allocator<_Tp1> other;\n   };\n \n-  allocator() __STL_NOTHROW {}\n-  allocator(const allocator&) __STL_NOTHROW {}\n-  template <class _Tp1> allocator(const allocator<_Tp1>&) __STL_NOTHROW {}\n-  ~allocator() __STL_NOTHROW {}\n+  allocator() throw() {}\n+  allocator(const allocator&) throw() {}\n+  template <class _Tp1> allocator(const allocator<_Tp1>&) throw() {}\n+  ~allocator() throw() {}\n \n   pointer address(reference __x) const { return &__x; }\n   const_pointer address(const_reference __x) const { return &__x; }\n@@ -616,7 +616,7 @@ class allocator {\n   void deallocate(pointer __p, size_type __n)\n     { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n \n-  size_type max_size() const __STL_NOTHROW \n+  size_type max_size() const throw() \n     { return size_t(-1) / sizeof(_Tp); }\n \n   void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n@@ -673,13 +673,13 @@ struct __allocator {\n     typedef __allocator<_Tp1, _Alloc> other;\n   };\n \n-  __allocator() __STL_NOTHROW {}\n-  __allocator(const __allocator& __a) __STL_NOTHROW\n+  __allocator() throw() {}\n+  __allocator(const __allocator& __a) throw()\n     : __underlying_alloc(__a.__underlying_alloc) {}\n   template <class _Tp1> \n-  __allocator(const __allocator<_Tp1, _Alloc>& __a) __STL_NOTHROW\n+  __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()\n     : __underlying_alloc(__a.__underlying_alloc) {}\n-  ~__allocator() __STL_NOTHROW {}\n+  ~__allocator() throw() {}\n \n   pointer address(reference __x) const { return &__x; }\n   const_pointer address(const_reference __x) const { return &__x; }\n@@ -695,7 +695,7 @@ struct __allocator {\n   void deallocate(pointer __p, size_type __n)\n     { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n \n-  size_type max_size() const __STL_NOTHROW \n+  size_type max_size() const throw() \n     { return size_t(-1) / sizeof(_Tp); }\n \n   void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }"}, {"sha": "1024252ddfabe13276ce662465059d0a8658cd30", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 118, "deletions": 56, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -100,15 +100,14 @@\n \n namespace std\n { \n-\n-// Note: this function is simply a kludge to work around several compilers'\n-//  bugs in handling constant expressions.\n-inline size_t __deque_buf_size(size_t __size) {\n-  return __size < 512 ? size_t(512 / __size) : size_t(1);\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-struct _Deque_iterator {\n+  // Note: this function is simply a kludge to work around several compilers'\n+  //  bugs in handling constant expressions.\n+  inline size_t \n+  __deque_buf_size(size_t __size) \n+  { return __size < 512 ? size_t(512 / __size) : size_t(1); }\n+\n+  template <class _Tp, class _Ref, class _Ptr>\n+  struct _Deque_iterator {\n   typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n   typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n   static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n@@ -351,11 +350,16 @@ _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n   _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2;\n   _Tp** __nfinish = __nstart + __num_nodes;\n     \n-  __STL_TRY {\n-    _M_create_nodes(__nstart, __nfinish);\n-  }\n-  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), \n-                _M_map = 0, _M_map_size = 0));\n+  try \n+    { _M_create_nodes(__nstart, __nfinish); }\n+  catch(...)\n+    {\n+      _M_deallocate_map(_M_map, _M_map_size);\n+      _M_map = 0;\n+      _M_map_size = 0;\n+      __throw_exception_again;\n+    }\n+  \n   _M_start._M_set_node(__nstart);\n   _M_finish._M_set_node(__nfinish - 1);\n   _M_start._M_cur = _M_start._M_first;\n@@ -367,11 +371,15 @@ template <class _Tp, class _Alloc>\n void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n {\n   _Tp** __cur;\n-  __STL_TRY {\n+  try {\n     for (__cur = __nstart; __cur < __nfinish; ++__cur)\n       *__cur = _M_allocate_node();\n   }\n-  __STL_UNWIND(_M_destroy_nodes(__nstart, __cur));\n+  catch(...)\n+    { \n+      _M_destroy_nodes(__nstart, __cur);\n+      __throw_exception_again; \n+    }\n }\n \n template <class _Tp, class _Alloc>\n@@ -850,20 +858,27 @@ void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n {\n   if (__pos._M_cur == _M_start._M_cur) {\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n-    __STL_TRY {\n+    try {\n       uninitialized_fill(__new_start, _M_start, __x);\n       _M_start = __new_start;\n     }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n+    catch(...)\n+      {\n+\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+\t__throw_exception_again;\n+      }\n   }\n   else if (__pos._M_cur == _M_finish._M_cur) {\n     iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    __STL_TRY {\n+    try {\n       uninitialized_fill(_M_finish, __new_finish, __x);\n       _M_finish = __new_finish;\n     }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                                  __new_finish._M_node + 1));    \n+    catch(...)\n+      {\n+\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);    \n+\t__throw_exception_again;\n+      }\n   }\n   else \n     _M_insert_aux(__pos, __n, __x);\n@@ -924,12 +939,16 @@ void deque<_Tp,_Alloc>::clear()\n template <class _Tp, class _Alloc>\n void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {\n   _Map_pointer __cur;\n-  __STL_TRY {\n+  try {\n     for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n       uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n     uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n   }\n-  __STL_UNWIND(_Destroy(_M_start, iterator(*__cur, __cur)));\n+  catch(...)\n+    {\n+      _Destroy(_M_start, iterator(*__cur, __cur));\n+      __throw_exception_again;\n+    }\n }\n \n template <class _Tp, class _Alloc> template <class _InputIterator>\n@@ -938,11 +957,15 @@ void deque<_Tp,_Alloc>::_M_range_initialize(_InputIterator __first,\n                                             input_iterator_tag)\n {\n   _M_initialize_map(0);\n-  __STL_TRY {\n+  try {\n     for ( ; __first != __last; ++__first)\n       push_back(*__first);\n   }\n-  __STL_UNWIND(clear());\n+  catch(...)\n+    {\n+      clear();\n+      __throw_exception_again;\n+    }\n }\n \n template <class _Tp, class _Alloc> template <class _ForwardIterator>\n@@ -955,7 +978,7 @@ void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n   _M_initialize_map(__n);\n \n   _Map_pointer __cur_node;\n-  __STL_TRY {\n+  try {\n     for (__cur_node = _M_start._M_node; \n          __cur_node < _M_finish._M_node; \n          ++__cur_node) {\n@@ -966,7 +989,11 @@ void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n     }\n     uninitialized_copy(__first, __last, _M_finish._M_first);\n   }\n-  __STL_UNWIND(_Destroy(_M_start, iterator(*__cur_node, __cur_node)));\n+  catch(...)\n+    {\n+      _Destroy(_M_start, iterator(*__cur_node, __cur_node));\n+      __throw_exception_again;\n+    }\n }\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n@@ -977,12 +1004,16 @@ deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n   value_type __t_copy = __t;\n   _M_reserve_map_at_back();\n   *(_M_finish._M_node + 1) = _M_allocate_node();\n-  __STL_TRY {\n+  try {\n     _Construct(_M_finish._M_cur, __t_copy);\n     _M_finish._M_set_node(_M_finish._M_node + 1);\n     _M_finish._M_cur = _M_finish._M_first;\n   }\n-  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));\n+  catch(...)\n+    {\n+      _M_deallocate_node(*(_M_finish._M_node + 1));\n+      __throw_exception_again;\n+    }\n }\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n@@ -992,12 +1023,16 @@ deque<_Tp,_Alloc>::_M_push_back_aux()\n {\n   _M_reserve_map_at_back();\n   *(_M_finish._M_node + 1) = _M_allocate_node();\n-  __STL_TRY {\n+  try {\n     _Construct(_M_finish._M_cur);\n     _M_finish._M_set_node(_M_finish._M_node + 1);\n     _M_finish._M_cur = _M_finish._M_first;\n   }\n-  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));\n+  catch(...)\n+    {\n+      _M_deallocate_node(*(_M_finish._M_node + 1));\n+      __throw_exception_again;\n+    }\n }\n \n // Called only if _M_start._M_cur == _M_start._M_first.\n@@ -1008,12 +1043,17 @@ deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)\n   value_type __t_copy = __t;\n   _M_reserve_map_at_front();\n   *(_M_start._M_node - 1) = _M_allocate_node();\n-  __STL_TRY {\n+  try {\n     _M_start._M_set_node(_M_start._M_node - 1);\n     _M_start._M_cur = _M_start._M_last - 1;\n     _Construct(_M_start._M_cur, __t_copy);\n   }\n-  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));\n+  catch(...)\n+    {\n+      ++_M_start;\n+      _M_deallocate_node(*(_M_start._M_node - 1));\n+      __throw_exception_again;\n+    }\n } \n \n // Called only if _M_start._M_cur == _M_start._M_first.\n@@ -1023,12 +1063,17 @@ deque<_Tp,_Alloc>::_M_push_front_aux()\n {\n   _M_reserve_map_at_front();\n   *(_M_start._M_node - 1) = _M_allocate_node();\n-  __STL_TRY {\n+  try {\n     _M_start._M_set_node(_M_start._M_node - 1);\n     _M_start._M_cur = _M_start._M_last - 1;\n     _Construct(_M_start._M_cur);\n   }\n-  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));\n+  catch(...)\n+    {\n+      ++_M_start;\n+      _M_deallocate_node(*(_M_start._M_node - 1));\n+      __throw_exception_again;\n+    }\n } \n \n // Called only if _M_finish._M_cur == _M_finish._M_first.\n@@ -1071,20 +1116,27 @@ deque<_Tp,_Alloc>::insert(iterator __pos,\n   distance(__first, __last, __n);\n   if (__pos._M_cur == _M_start._M_cur) {\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n-    __STL_TRY {\n+    try {\n       uninitialized_copy(__first, __last, __new_start);\n       _M_start = __new_start;\n     }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n+    catch(...)\n+      {\n+\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+\t__throw_exception_again;\n+      }\n   }\n   else if (__pos._M_cur == _M_finish._M_cur) {\n     iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    __STL_TRY {\n+    try {\n       uninitialized_copy(__first, __last, _M_finish);\n       _M_finish = __new_finish;\n     }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                                  __new_finish._M_node + 1));\n+    catch(...)\n+      {\n+\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+\t__throw_exception_again;\n+      }\n   }\n   else\n     _M_insert_aux(__pos, __first, __last, __n);\n@@ -1161,7 +1213,7 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n     iterator __old_start = _M_start;\n     __pos = _M_start + __elems_before;\n-    __STL_TRY {\n+    try {\n       if (__elems_before >= difference_type(__n)) {\n         iterator __start_n = _M_start + difference_type(__n);\n         uninitialized_copy(_M_start, __start_n, __new_start);\n@@ -1176,15 +1228,19 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n         fill(__old_start, __pos, __x_copy);\n       }\n     }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n+    catch(...)\n+      { \n+\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+\t__throw_exception_again;\n+      }\n   }\n   else {\n     iterator __new_finish = _M_reserve_elements_at_back(__n);\n     iterator __old_finish = _M_finish;\n     const difference_type __elems_after = \n       difference_type(__length) - __elems_before;\n     __pos = _M_finish - __elems_after;\n-    __STL_TRY {\n+    try {\n       if (__elems_after > difference_type(__n)) {\n         iterator __finish_n = _M_finish - difference_type(__n);\n         uninitialized_copy(__finish_n, _M_finish, _M_finish);\n@@ -1199,8 +1255,11 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n         fill(__pos, __old_finish, __x_copy);\n       }\n     }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                                  __new_finish._M_node + 1));\n+    catch(...)\n+      { \n+\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+\t__throw_exception_again;\n+      }\n   }\n }\n \n@@ -1216,7 +1275,7 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n     iterator __old_start = _M_start;\n     __pos = _M_start + __elemsbefore;\n-    __STL_TRY {\n+    try {\n       if (__elemsbefore >= difference_type(__n)) {\n         iterator __start_n = _M_start + difference_type(__n); \n         uninitialized_copy(_M_start, __start_n, __new_start);\n@@ -1233,15 +1292,19 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n         copy(__mid, __last, __old_start);\n       }\n     }\n-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));\n+    catch(...)\n+      {\n+\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+\t__throw_exception_again;\n+      }\n   }\n   else {\n     iterator __new_finish = _M_reserve_elements_at_back(__n);\n     iterator __old_finish = _M_finish;\n     const difference_type __elemsafter = \n       difference_type(__length) - __elemsbefore;\n     __pos = _M_finish - __elemsafter;\n-    __STL_TRY {\n+    try {\n       if (__elemsafter > difference_type(__n)) {\n         iterator __finish_n = _M_finish - difference_type(__n);\n         uninitialized_copy(__finish_n, _M_finish, _M_finish);\n@@ -1257,8 +1320,11 @@ void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n         copy(__first, __mid, __pos);\n       }\n     }\n-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, \n-                                  __new_finish._M_node + 1));\n+    catch(...)\n+      {\n+\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+\t__throw_exception_again;\n+      }\n   }\n }\n \n@@ -1269,17 +1335,15 @@ void deque<_Tp,_Alloc>::_M_new_elements_at_front(size_type __new_elems)\n       = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n   _M_reserve_map_at_front(__new_nodes);\n   size_type __i;\n-  __STL_TRY {\n+  try {\n     for (__i = 1; __i <= __new_nodes; ++__i)\n       *(_M_start._M_node - __i) = _M_allocate_node();\n   }\n-#       ifdef __STL_USE_EXCEPTIONS\n   catch(...) {\n     for (size_type __j = 1; __j < __i; ++__j)\n       _M_deallocate_node(*(_M_start._M_node - __j));      \n     throw;\n   }\n-#       endif /* __STL_USE_EXCEPTIONS */\n }\n \n template <class _Tp, class _Alloc>\n@@ -1289,17 +1353,15 @@ void deque<_Tp,_Alloc>::_M_new_elements_at_back(size_type __new_elems)\n       = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n   _M_reserve_map_at_back(__new_nodes);\n   size_type __i;\n-  __STL_TRY {\n+  try {\n     for (__i = 1; __i <= __new_nodes; ++__i)\n       *(_M_finish._M_node + __i) = _M_allocate_node();\n   }\n-#       ifdef __STL_USE_EXCEPTIONS\n   catch(...) {\n     for (size_type __j = 1; __j < __i; ++__j)\n       _M_deallocate_node(*(_M_finish._M_node + __j));      \n     throw;\n   }\n-#       endif /* __STL_USE_EXCEPTIONS */\n }\n \n template <class _Tp, class _Alloc>"}, {"sha": "275699e94d35a5de7453edab5fab349b6eb70de7", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -265,20 +265,28 @@ class list : protected _List_base<_Tp, _Alloc>\n   _Node* _M_create_node(const _Tp& __x)\n   {\n     _Node* __p = _M_get_node();\n-    __STL_TRY {\n+    try {\n       _Construct(&__p->_M_data, __x);\n     }\n-    __STL_UNWIND(_M_put_node(__p));\n+    catch(...)\n+      { \n+\t_M_put_node(__p);\n+\t__throw_exception_again; \n+      }\n     return __p;\n   }\n \n   _Node* _M_create_node()\n   {\n     _Node* __p = _M_get_node();\n-    __STL_TRY {\n+    try {\n       _Construct(&__p->_M_data);\n     }\n-    __STL_UNWIND(_M_put_node(__p));\n+    catch(...)\n+      { \n+\t_M_put_node(__p);\n+\t__throw_exception_again; \n+      }\n     return __p;\n   }\n "}, {"sha": "7bf33c1314b4cf8ae60873e0aa51c73adc329e87", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -200,19 +200,35 @@ class priority_queue\n   bool empty() const { return c.empty(); }\n   size_type size() const { return c.size(); }\n   const_reference top() const { return c.front(); }\n-  void push(const value_type& __x) {\n-    __STL_TRY {\n-      c.push_back(__x); \n-      push_heap(c.begin(), c.end(), comp);\n-    }\n-    __STL_UNWIND(c.clear());\n+\n+  void \n+  push(const value_type& __x) \n+  {\n+    try \n+      {\n+\tc.push_back(__x); \n+\tpush_heap(c.begin(), c.end(), comp);\n+      }\n+    catch(...)\n+      {\n+\tc.clear();\n+\t__throw_exception_again; \n+      }\n   }\n-  void pop() {\n-    __STL_TRY {\n-      pop_heap(c.begin(), c.end(), comp);\n-      c.pop_back();\n-    }\n-    __STL_UNWIND(c.clear());\n+\n+  void \n+  pop() \n+  {\n+    try \n+      {\n+\tpop_heap(c.begin(), c.end(), comp);\n+\tc.pop_back();\n+      }\n+    catch(...)\n+      {\n+\tc.clear();\n+\t__throw_exception_again; \n+      }\n   }\n };\n "}, {"sha": "f6b154f585463addd3a40900e3390ab7cfa7ae44", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -138,14 +138,20 @@ class _Temporary_buffer {\n     typedef typename __type_traits<_Tp>::has_trivial_default_constructor\n             _Trivial;\n \n-    __STL_TRY {\n+    try {\n       _M_len = 0;\n       distance(__first, __last, _M_len);\n       _M_allocate_buffer();\n       if (_M_len > 0)\n         _M_initialize_buffer(*__first, _Trivial());\n     }\n-    __STL_UNWIND(free(_M_buffer); _M_buffer = 0; _M_len = 0);\n+    catch(...)\n+      { \n+\tfree(_M_buffer); \n+\t_M_buffer = 0; \n+\t_M_len = 0;\n+\t__throw_exception_again; \n+      }\n   }\n  \n   ~_Temporary_buffer() {  "}, {"sha": "87dc603c6ec13c4c76c80ca373a09f79c769b95f", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -556,10 +556,14 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n   _M_create_node(const value_type& __x)\n   {\n     _Link_type __tmp = _M_get_node();\n-    __STL_TRY {\n+    try {\n       _Construct(&__tmp->_M_value_field, __x);\n     }\n-    __STL_UNWIND(_M_put_node(__tmp));\n+    catch(...)\n+      {\n+\t_M_put_node(__tmp);\n+\t__throw_exception_again; \n+      }\n     return __tmp;\n   }\n \n@@ -1032,7 +1036,7 @@ _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>\n   _Link_type __top = _M_clone_node(__x);\n   __top->_M_parent = __p;\n  \n-  __STL_TRY {\n+  try {\n     if (__x->_M_right)\n       __top->_M_right = _M_copy(_S_right(__x), __top);\n     __p = __top;\n@@ -1048,8 +1052,11 @@ _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>\n       __x = _S_left(__x);\n     }\n   }\n-  __STL_UNWIND(_M_erase(__top));\n-\n+  catch(...)\n+    {\n+      _M_erase(__top);\n+      __throw_exception_again; \n+    }\n   return __top;\n }\n "}, {"sha": "383e0842179865e35830c87d1e58cb0ebd59f7ab", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -81,12 +81,16 @@ namespace std\n \t\t\t     __false_type)\n     {\n       _ForwardIter __cur = __result;\n-      __STL_TRY {\n+      try {\n \tfor ( ; __first != __last; ++__first, ++__cur)\n \t  _Construct(&*__cur, *__first);\n \treturn __cur;\n       }\n-      __STL_UNWIND(_Destroy(__result, __cur));\n+      catch(...)\n+\t{\n+\t  _Destroy(__result, __cur);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n   template<typename _InputIter, typename _ForwardIter>\n@@ -122,12 +126,16 @@ namespace std\n \t\t\t   input_iterator_tag)\n     {\n       _ForwardIter __cur = __result;\n-      __STL_TRY {\n+      try {\n \tfor ( ; __count > 0 ; --__count, ++__first, ++__cur) \n \t  _Construct(&*__cur, *__first);\n \treturn pair<_InputIter, _ForwardIter>(__first, __cur);\n       }\n-      __STL_UNWIND(_Destroy(__result, __cur));\n+      catch(...)\n+\t{\n+\t  _Destroy(__result, __cur);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n   template<typename _RandomAccessIter, typename _Size, typename _ForwardIter>\n@@ -172,11 +180,15 @@ namespace std\n \t\t\t     const _Tp& __x, __false_type)\n     {\n       _ForwardIter __cur = __first;\n-      __STL_TRY {\n+      try {\n \tfor ( ; __cur != __last; ++__cur)\n \t  _Construct(&*__cur, __x);\n       }\n-      __STL_UNWIND(_Destroy(__first, __cur));\n+      catch(...)\n+\t{\n+\t  _Destroy(__first, __cur);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n   template<typename _ForwardIter, typename _Tp>\n@@ -204,12 +216,16 @@ namespace std\n \t\t\t       const _Tp& __x, __false_type)\n     {\n       _ForwardIter __cur = __first;\n-      __STL_TRY {\n+      try {\n \tfor ( ; __n > 0; --__n, ++__cur)\n \t  _Construct(&*__cur, __x);\n \treturn __cur;\n       }\n-      __STL_UNWIND(_Destroy(__first, __cur));\n+      catch(...)\n+\t{ \n+\t  _Destroy(__first, __cur);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n   template<typename _ForwardIter, typename _Size, typename _Tp>\n@@ -236,10 +252,14 @@ namespace std\n \t\t\t      _ForwardIter __result)\n     {\n       _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);\n-      __STL_TRY {\n+      try {\n \treturn uninitialized_copy(__first2, __last2, __mid);\n       }\n-      __STL_UNWIND(_Destroy(__result, __mid));\n+      catch(...)\n+\t{ \n+\t  _Destroy(__result, __mid);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n   // __uninitialized_fill_copy\n@@ -252,10 +272,14 @@ namespace std\n \t\t\t      _InputIter __first, _InputIter __last)\n     {\n       uninitialized_fill(__result, __mid, __x);\n-      __STL_TRY {\n+      try {\n \treturn uninitialized_copy(__first, __last, __mid);\n       }\n-      __STL_UNWIND(_Destroy(__result, __mid));\n+      catch(...)\n+\t{\n+\t  _Destroy(__result, __mid);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n   // __uninitialized_copy_fill\n@@ -268,10 +292,14 @@ namespace std\n \t\t\t      const _Tp& __x)\n     {\n       _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);\n-      __STL_TRY {\n+      try {\n \tuninitialized_fill(__mid2, __last2, __x);\n       }\n-      __STL_UNWIND(_Destroy(__first2, __mid2));\n+      catch(...)\n+\t{\n+\t  _Destroy(__first2, __mid2);\n+\t  __throw_exception_again; \n+\t}\n     }\n \n } // namespace std"}, {"sha": "8237c3e23b1ceb0f3e6223385c83ed9711e81c05", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -437,11 +437,15 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n                                                _ForwardIterator __last)\n   {\n     pointer __result = _M_allocate(__n);\n-    __STL_TRY {\n+    try {\n       uninitialized_copy(__first, __last, __result);\n       return __result;\n     }\n-    __STL_UNWIND(_M_deallocate(__result, __n));\n+    catch(...)\n+      { \n+\t_M_deallocate(__result, __n);\n+\t__throw_exception_again;\n+      }\n   }\n \n   template <class _InputIterator>\n@@ -617,16 +621,20 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n     const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n     iterator __new_start(_M_allocate(__len));\n     iterator __new_finish(__new_start);\n-    __STL_TRY {\n+    try {\n       __new_finish = uninitialized_copy(iterator(_M_start), __position,\n                                         __new_start);\n       _Construct(__new_finish.base(), __x);\n       ++__new_finish;\n       __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n                                         __new_finish);\n     }\n-    __STL_UNWIND((_Destroy(__new_start,__new_finish), \n-                  _M_deallocate(__new_start.base(),__len)));\n+    catch(...)\n+      { \n+\t_Destroy(__new_start,__new_finish); \n+\t_M_deallocate(__new_start.base(),__len);\n+\t__throw_exception_again;\n+      }\n     _Destroy(begin(), end());\n     _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n     _M_start = __new_start.base();\n@@ -651,16 +659,20 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n     const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n     pointer __new_start = _M_allocate(__len);\n     pointer __new_finish = __new_start;\n-    __STL_TRY {\n+    try {\n       __new_finish = uninitialized_copy(iterator(_M_start), __position, \n \t\t\t\t\t__new_start);\n       _Construct(__new_finish);\n       ++__new_finish;\n       __new_finish = uninitialized_copy(__position, iterator(_M_finish), \n \t\t\t\t\t__new_finish);\n     }\n-    __STL_UNWIND((_Destroy(__new_start,__new_finish), \n-                  _M_deallocate(__new_start,__len)));\n+    catch(...)\n+      {\n+\t_Destroy(__new_start,__new_finish); \n+\t_M_deallocate(__new_start,__len);\n+\t__throw_exception_again;\n+      }\n     _Destroy(begin(), end());\n     _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n     _M_start = __new_start;\n@@ -697,14 +709,18 @@ void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n       const size_type __len = __old_size + max(__old_size, __n);\n       iterator __new_start(_M_allocate(__len));\n       iterator __new_finish(__new_start);\n-      __STL_TRY {\n+      try {\n         __new_finish = uninitialized_copy(begin(), __position, __new_start);\n         __new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n         __new_finish\n           = uninitialized_copy(__position, end(), __new_finish);\n       }\n-      __STL_UNWIND((_Destroy(__new_start,__new_finish), \n-                    _M_deallocate(__new_start.base(),__len)));\n+      catch(...)\n+\t{\n+\t  _Destroy(__new_start,__new_finish); \n+\t  _M_deallocate(__new_start.base(),__len);\n+\t  __throw_exception_again;\n+\t}\n       _Destroy(_M_start, _M_finish);\n       _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n       _M_start = __new_start.base();\n@@ -761,15 +777,19 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n       const size_type __len = __old_size + max(__old_size, __n);\n       iterator __new_start(_M_allocate(__len));\n       iterator __new_finish(__new_start);\n-      __STL_TRY {\n+      try {\n         __new_finish = uninitialized_copy(iterator(_M_start), \n \t\t\t\t\t  __position, __new_start);\n         __new_finish = uninitialized_copy(__first, __last, __new_finish);\n         __new_finish\n           = uninitialized_copy(__position, iterator(_M_finish), __new_finish);\n       }\n-      __STL_UNWIND((_Destroy(__new_start,__new_finish), \n-                    _M_deallocate(__new_start.base(),__len)));\n+      catch(...)\n+\t{\n+\t  _Destroy(__new_start,__new_finish);\n+\t  _M_deallocate(__new_start.base(), __len);\n+\t  __throw_exception_again;\n+\t}\n       _Destroy(_M_start, _M_finish);\n       _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n       _M_start = __new_start.base();"}, {"sha": "e36fedfada5f27f58e92c3c29ed1a94858ad15ed", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 118, "deletions": 121, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -46,10 +46,7 @@\n \n #include <bits/std_cstdio.h>     \n #include <bits/std_iostream.h>\n-\n-#ifdef __STL_USE_EXCEPTIONS\n-# include <bits/std_stdexcept.h>\n-#endif\n+# include <bits/functexcept.h>\n \n namespace std\n {\n@@ -98,7 +95,7 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf(\n \t    }\n \t    break;\n \tdefault:\n-\t    __stl_assert(0);\n+\t  break;\n     }\n }\n \n@@ -115,7 +112,6 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n     size_t __pos = __x._M_current_pos;\n     unsigned char __dirns = 0; // Bit vector marking right turns in the path\n \n-    __stl_assert(__pos <= __x._M_root->_M_size);\n     if (__pos >= __x._M_root->_M_size) {\n \t__x._M_buf_ptr = 0;\n \treturn;\n@@ -133,7 +129,6 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n     }\n     for(;;) {\n \t++__curr_depth;\n-\t__stl_assert(__curr_depth <= _RopeRep::_S_max_rope_depth);\n \t__path[__curr_depth] = __curr_rope;\n \tswitch(__curr_rope->_M_tag) {\n \t  case _RopeRep::_S_leaf:\n@@ -189,13 +184,11 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache_for_incr\n     unsigned char __dirns = __x._M_path_directions;\n     _Rope_RopeConcatenation<_CharT,_Alloc>* __c;\n \n-    __stl_assert(__x._M_current_pos <= __x._M_root->_M_size);\n     if (__x._M_current_pos - __node_start_pos < __len) {\n \t/* More stuff in this leaf, we just didn't cache it. */\n \t_S_setbuf(__x);\n \treturn;\n     }\n-    __stl_assert(__node_start_pos + __len == __x._M_current_pos);\n     //  node_start_pos is starting position of last_node.\n     while (--__current_index >= 0) {\n \tif (!(__dirns & 1) /* Path turned left */) \n@@ -408,12 +401,16 @@ rope<_CharT,_Alloc>::_S_leaf_concat_char_iter\n     uninitialized_copy_n(__r->_M_data, __old_len, __new_data);\n     uninitialized_copy_n(__iter, __len, __new_data + __old_len);\n     _S_cond_store_eos(__new_data[__old_len + __len]);\n-    __STL_TRY {\n+    try {\n \t__result = _S_new_RopeLeaf(__new_data, __old_len + __len,\n \t\t\t\t   __r->get_allocator());\n     }\n-    __STL_UNWIND(_RopeRep::__STL_FREE_STRING(__new_data, __old_len + __len,\n-\t\t\t\t\t     __r->get_allocator()));\n+    catch(...)\n+      {\n+\t_RopeRep::__STL_FREE_STRING(__new_data, __old_len + __len,\n+\t\t\t\t    __r->get_allocator());\n+\t__throw_exception_again;\n+      }\n     return __result;\n }\n \n@@ -424,7 +421,6 @@ rope<_CharT,_Alloc>::_RopeLeaf*\n rope<_CharT,_Alloc>::_S_destr_leaf_concat_char_iter\n \t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n {\n-    __stl_assert(__r->_M_ref_count >= 1);\n     if (__r->_M_ref_count > 1)\n       return _S_leaf_concat_char_iter(__r, __iter, __len);\n     size_t __old_len = __r->_M_size;\n@@ -434,18 +430,15 @@ rope<_CharT,_Alloc>::_S_destr_leaf_concat_char_iter\n \tuninitialized_copy_n(__iter, __len, __r->_M_data + __old_len);\n \tif (_S_is_basic_char_type((_CharT*)0)) {\n \t    _S_cond_store_eos(__r->_M_data[__old_len + __len]);\n-\t    __stl_assert(__r->_M_c_string == __r->_M_data);\n \t} else if (__r->_M_c_string != __r->_M_data && 0 != __r->_M_c_string) {\n \t    __r->_M_free_c_string();\n \t    __r->_M_c_string = 0;\n \t}\n \t__r->_M_size = __old_len + __len;\n-\t__stl_assert(__r->_M_ref_count == 1);\n \t__r->_M_ref_count = 2;\n \treturn __r;\n     } else {\n \t_RopeLeaf* __result = _S_leaf_concat_char_iter(__r, __iter, __len);\n-\t__stl_assert(__result->_M_ref_count == 1);\n \treturn __result;\n     }\n }\n@@ -458,34 +451,33 @@ template <class _CharT, class _Alloc>\n rope<_CharT,_Alloc>::_RopeRep*\n rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n {\n-    _RopeConcatenation* __result =\n-      _S_new_RopeConcatenation(__left, __right, __left->get_allocator());\n-    size_t __depth = __result->_M_depth;\n+  _RopeConcatenation* __result = _S_new_RopeConcatenation(__left, __right, \n+\t\t\t\t\t\t      __left->get_allocator());\n+  size_t __depth = __result->_M_depth;\n     \n-      __stl_assert(__left->get_allocator() == __right->get_allocator());\n-    if (__depth > 20 && (__result->_M_size < 1000 ||\n-\t\t\t __depth > _RopeRep::_S_max_rope_depth)) {\n-        _RopeRep* __balanced;\n+  if (__depth > 20 && (__result->_M_size < 1000 ||\n+\t\t       __depth > _RopeRep::_S_max_rope_depth)) \n+    {\n+      _RopeRep* __balanced;\n       \n-\t__STL_TRY {\n-\t   __balanced = _S_balance(__result);\n-#          ifndef __GC\n-\t     if (__result != __balanced) {\n-\t\t__stl_assert(1 == __result->_M_ref_count\n-\t\t\t     && 1 == __balanced->_M_ref_count);\n-\t     }\n-#          endif\n-\t   __result->_M_unref_nonnil();\n+      try \n+\t{\n+\t  __balanced = _S_balance(__result);\n+\t  __result->_M_unref_nonnil();\n         }\n-\t__STL_UNWIND((_C_deallocate(__result,1)));\n-\t\t// In case of exception, we need to deallocate\n-\t\t// otherwise dangling result node.  But caller\n-\t\t// still owns its children.  Thus unref is\n-\t\t// inappropriate.\n-\treturn __balanced;\n-    } else {\n-\treturn __result;\n-    }\n+      catch(...)\n+\t{ \n+\t  _C_deallocate(__result,1);\n+\t  __throw_exception_again;\n+\t}\n+      // In case of exception, we need to deallocate\n+      // otherwise dangling result node.  But caller\n+      // still owns its children.  Thus unref is\n+      // inappropriate.\n+      return __balanced;\n+    } \n+  else \n+    return __result;\n }\n \n template <class _CharT, class _Alloc>\n@@ -503,9 +495,6 @@ rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n     if (_RopeRep::_S_leaf == __r->_M_tag && \n           __r->_M_size + __slen <= _S_copy_max) {\n \t__result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n-#       ifndef __GC\n-\t  __stl_assert(1 == __result->_M_ref_count);\n-#       endif\n \treturn __result;\n     }\n     if (_RopeRep::_S_concat == __r->_M_tag\n@@ -517,26 +506,30 @@ rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n \t  _RopeRep* __nright = \n \t    _S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);\n \t  __left->_M_ref_nonnil();\n-\t  __STL_TRY {\n+\t  try {\n \t    __result = _S_tree_concat(__left, __nright);\n           }\n-\t  __STL_UNWIND(_S_unref(__left); _S_unref(__nright));\n-#         ifndef __GC\n-\t    __stl_assert(1 == __result->_M_ref_count);\n-#         endif\n+\t  catch(...)\n+\t    {\n+\t      _S_unref(__left); \n+\t      _S_unref(__nright);\n+\t      __throw_exception_again;\n+\t    }\n \t  return __result;\n \t}\n     }\n     _RopeRep* __nright =\n       __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n-    __STL_TRY {\n+    try {\n       __r->_M_ref_nonnil();\n       __result = _S_tree_concat(__r, __nright);\n     }\n-    __STL_UNWIND(_S_unref(__r); _S_unref(__nright));\n-#   ifndef __GC\n-      __stl_assert(1 == __result->_M_ref_count);\n-#   endif\n+    catch(...)\n+      {\n+\t_S_unref(__r); \n+\t_S_unref(__nright);\n+\t__throw_exception_again;\n+      }\n     return __result;\n }\n \n@@ -552,7 +545,6 @@ rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n \t\t\t\t\t      __r->get_allocator());\n     size_t __count = __r->_M_ref_count;\n     size_t __orig_size = __r->_M_size;\n-    __stl_assert(__count >= 1);\n     if (__count > 1) return _S_concat_char_iter(__r, __s, __slen);\n     if (0 == __slen) {\n \t__r->_M_ref_count = 2;      // One more than before\n@@ -569,14 +561,10 @@ rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n \t    && __right->_M_size + __slen <= _S_copy_max) {\n \t  _RopeRep* __new_right = \n \t    _S_destr_leaf_concat_char_iter(__right, __s, __slen);\n-\t  if (__right == __new_right) {\n-\t      __stl_assert(__new_right->_M_ref_count == 2);\n-\t      __new_right->_M_ref_count = 1;\n-\t  } else {\n-\t      __stl_assert(__new_right->_M_ref_count >= 1);\n-\t      __right->_M_unref_nonnil();\n-\t  }\n-\t  __stl_assert(__r->_M_ref_count == 1);\n+\t  if (__right == __new_right) \n+\t    __new_right->_M_ref_count = 1;\n+\t  else \n+\t    __right->_M_unref_nonnil();\n \t  __r->_M_ref_count = 2;    // One more than before.\n \t  ((_RopeConcatenation*)__r)->_M_right = __new_right;\n \t  __r->_M_size = __orig_size + __slen;\n@@ -590,11 +578,15 @@ rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n     _RopeRep* __right =\n       __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n     __r->_M_ref_nonnil();\n-    __STL_TRY {\n+    try {\n       __result = _S_tree_concat(__r, __right);\n     }\n-    __STL_UNWIND(_S_unref(__r); _S_unref(__right))\n-    __stl_assert(1 == __result->_M_ref_count);\n+    catch(...)\n+      {\n+\t_S_unref(__r); \n+\t_S_unref(__right);\n+\t__throw_exception_again;\n+      }\n     return __result;\n }\n #endif /* !__GC */\n@@ -629,19 +621,29 @@ rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n \t\t\t\t\t   ((_RopeLeaf*)__right)->_M_data,\n \t\t\t\t\t   __right->_M_size);\n \t    __leftleft->_M_ref_nonnil();\n-\t    __STL_TRY {\n+\t    try {\n \t      return(_S_tree_concat(__leftleft, __rest));\n             }\n-\t    __STL_UNWIND(_S_unref(__leftleft); _S_unref(__rest))\n+\t    catch(...)\n+\t      {\n+\t\t_S_unref(__leftleft); \n+\t\t_S_unref(__rest);\n+\t\t__throw_exception_again;\n+\t      }\n \t  }\n \t}\n     }\n     __left->_M_ref_nonnil();\n     __right->_M_ref_nonnil();\n-    __STL_TRY {\n+    try {\n       return(_S_tree_concat(__left, __right));\n     }\n-    __STL_UNWIND(_S_unref(__left); _S_unref(__right));\n+    catch(...)\n+      {\n+\t_S_unref(__left); \n+\t_S_unref(__right);\n+\t__throw_exception_again;\n+      }\t\n }\n \n template <class _CharT, class _Alloc>\n@@ -684,9 +686,6 @@ rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base,\n \t\t_Self_destruct_ptr __right_result(\n \t\t  _S_substring(__right, 0, __endp1 - __left_len));\n \t\t__result = _S_concat(__left_result, __right_result);\n-#               ifndef __GC\n-\t\t  __stl_assert(1 == __result->_M_ref_count);\n-#               endif\n \t\treturn __result;\n \t    }\n \tcase _RopeRep::_S_leaf:\n@@ -738,18 +737,20 @@ rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base,\n \t\tif (__result_len > __lazy_threshold) goto lazy;\n \t\t__section = (_CharT*)\n \t\t\t_Data_allocate(_S_rounded_up_size(__result_len));\n-\t\t__STL_TRY {\n+\t\ttry {\n \t\t  (*(__f->_M_fn))(__start, __result_len, __section);\n                 }\n-\t\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(\n-\t               __section, __result_len, __base->get_allocator()));\n+\t\tcatch(...)\n+\t\t  {\n+\t\t    _RopeRep::__STL_FREE_STRING(\n+\t               __section, __result_len, __base->get_allocator());\n+\t\t    __throw_exception_again;\n+\t\t  }\n \t\t_S_cond_store_eos(__section[__result_len]);\n \t\treturn _S_new_RopeLeaf(__section, __result_len,\n \t\t\t\t       __base->get_allocator());\n \t    }\n     }\n-    /*NOTREACHED*/\n-    __stl_assert(false);\n   lazy:\n     {\n \t// Create substring node.\n@@ -862,19 +863,20 @@ bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n \t\tbool __result;\n \t\t_CharT* __buffer =\n \t\t  (_CharT*)alloc::allocate(__len * sizeof(_CharT));\n-\t\t__STL_TRY {\n+\t\ttry {\n \t\t  (*(__f->_M_fn))(__begin, __len, __buffer);\n \t\t  __result = __c(__buffer, __len);\n                   alloc::deallocate(__buffer, __len * sizeof(_CharT));\n                 }\n-\t\t__STL_UNWIND((alloc::deallocate(__buffer,\n-\t\t\t\t\t\t__len * sizeof(_CharT))))\n+\t\tcatch(...)\n+\t\t  {\n+\t\t    alloc::deallocate(__buffer, __len * sizeof(_CharT));\n+\t\t    __throw_exception_again;\n+\t\t  }\n \t\treturn __result;\n \t    }\n \tdefault:\n-\t    __stl_assert(false);\n-\t    /*NOTREACHED*/\n-\t    return false;\n+\t  return false;\n     }\n }\n \n@@ -909,7 +911,7 @@ basic_ostream<_CharT, _Traits>& operator<< (basic_ostream<_CharT, _Traits>& __o,\n \t__pad_len = 0;\n     }\n     if (!__is_simple) __o.width(__w/__rope_len);\n-    __STL_TRY {\n+    try {\n       if (__is_simple && !__left && __pad_len > 0) {\n \t_Rope_fill(__o, __pad_len);\n       }\n@@ -920,7 +922,12 @@ basic_ostream<_CharT, _Traits>& operator<< (basic_ostream<_CharT, _Traits>& __o,\n       if (!__is_simple)\n         __o.width(__w);\n     }\n-    __STL_UNWIND(if (!__is_simple) __o.width(__w))\n+    catch(...)\n+      {\n+\tif (!__is_simple) \n+\t  __o.width(__w);\n+\t__throw_exception_again;\n+      }\n     return __o;\n }\n \n@@ -977,8 +984,6 @@ rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r, _CharT* __buffer)\n \t\treturn __buffer + __f->_M_size;\n \t    }\n \tdefault:\n-\t    __stl_assert(false);\n-\t    /*NOTREACHED*/\n \t    return 0;\n     }\n }\n@@ -1081,7 +1086,7 @@ rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)\n \n     for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n       __forest[__i] = 0;\n-    __STL_TRY {\n+    try {\n       _S_add_to_forest(__r, __forest);\n       for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n         if (0 != __forest[__i]) {\n@@ -1090,20 +1095,20 @@ rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)\n #\tendif\n \t  __result = _S_concat(__forest[__i], __result);\n \t__forest[__i]->_M_unref_nonnil();\n-#\tif !defined(__GC) && defined(__STL_USE_EXCEPTIONS)\n+#\tif !defined(__GC) && defined(__EXCEPTIONS)\n \t  __forest[__i] = 0;\n #\tendif\n       }\n     }\n-    __STL_UNWIND(for(__i = 0; __i <= _RopeRep::_S_max_rope_depth; __i++)\n-\t\t _S_unref(__forest[__i]))\n-    if (__result->_M_depth > _RopeRep::_S_max_rope_depth) {\n-#     ifdef __STL_USE_EXCEPTIONS\n-\t__STL_THROW(length_error(\"rope too long\"));\n-#     else\n-\tabort();\n-#     endif\n-    }\n+    catch(...)\n+      {\n+\tfor(__i = 0; __i <= _RopeRep::_S_max_rope_depth; __i++)\n+\t  _S_unref(__forest[__i]);\n+\t__throw_exception_again;\n+      }\n+\n+    if (__result->_M_depth > _RopeRep::_S_max_rope_depth)\n+      __throw_length_error(\"rope too long\");\n     return(__result);\n }\n \n@@ -1116,7 +1121,7 @@ rope<_CharT,_Alloc>::_S_add_to_forest(_RopeRep* __r, _RopeRep** __forest)\n \t_S_add_leaf_to_forest(__r, __forest);\n \treturn;\n     }\n-    __stl_assert(__r->_M_tag == _RopeRep::_S_concat);\n+\n     {\n \t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n \n@@ -1153,8 +1158,6 @@ rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n     }\n     // Too_tiny dead, and no longer included in refcount.\n     // Insertee is live and included.\n-    __stl_assert(_S_is_almost_balanced(__insertee));\n-    __stl_assert(__insertee->_M_depth <= __r->_M_depth + 1);\n     for (;; ++__i) {\n \tif (0 != __forest[__i]) {\n #\t    ifndef __GC\n@@ -1163,10 +1166,7 @@ rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n \t    __insertee = _S_concat_and_set_balanced(__forest[__i], __insertee);\n \t    __forest[__i]->_M_unref_nonnil();\n \t    __forest[__i] = 0;\n-\t    __stl_assert(_S_is_almost_balanced(__insertee));\n \t}\n-\t__stl_assert(_S_min_len[__i] <= __insertee->_M_size);\n-\t__stl_assert(__forest[__i] == 0);\n \tif (__i == _RopeRep::_S_max_rope_depth || \n \t      __insertee->_M_size < _S_min_len[__i+1]) {\n \t    __forest[__i] = __insertee;\n@@ -1182,7 +1182,6 @@ rope<_CharT,_Alloc>::_S_fetch(_RopeRep* __r, size_type __i)\n {\n     __GC_CONST _CharT* __cstr = __r->_M_c_string;\n \n-    __stl_assert(__i < __r->_M_size);\n     if (0 != __cstr) return __cstr[__i]; \n     for(;;) {\n       switch(__r->_M_tag) {\n@@ -1336,13 +1335,9 @@ _Rope_char_ref_proxy<_CharT, _Alloc>::operator= (_CharT __c) {\n     _Self_destruct_ptr __result_left(\n       _My_rope::_S_destr_concat_char_iter(__left, &__c, 1));\n \n-#   ifndef __GC\n-      __stl_assert(__left == __result_left || 1 == __result_left->_M_ref_count);\n-#   endif\n     _RopeRep* __result =\n \t\t_My_rope::_S_concat(__result_left, __right);\n #   ifndef __GC\n-      __stl_assert(1 <= __result->_M_ref_count);\n       _RopeRep::_S_unref(__old);\n #   endif\n     _M_root->_M_tree_ptr = __result;\n@@ -1388,10 +1383,14 @@ rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n \t__rest_buffer = _Data_allocate(_S_rounded_up_size(__rest));\n \tuninitialized_fill_n(__rest_buffer, __rest, __c);\n \t_S_cond_store_eos(__rest_buffer[__rest]);\n-\t__STL_TRY {\n+\ttry {\n \t    __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a);\n         }\n-\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a))\n+\tcatch(...)\n+\t  {\n+\t    _RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a);\n+\t    __throw_exception_again;\n+\t  }\n     }\n     __remainder_rope._M_tree_ptr = __remainder;\n     if (__exponent != 0) {\n@@ -1401,19 +1400,19 @@ rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n \trope __base_rope;\n \tuninitialized_fill_n(__base_buffer, __exponentiate_threshold, __c);\n \t_S_cond_store_eos(__base_buffer[__exponentiate_threshold]);\n-\t__STL_TRY {\n+\ttry {\n           __base_leaf = _S_new_RopeLeaf(__base_buffer,\n                                         __exponentiate_threshold, __a);\n         }\n-\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(__base_buffer, \n-\t                                         __exponentiate_threshold, __a))\n+\tcatch(...)\n+\t  {\n+\t    _RopeRep::__STL_FREE_STRING(__base_buffer, \n+\t\t\t\t\t__exponentiate_threshold, __a);\n+\t    __throw_exception_again;\n+\t  }\n \t__base_rope._M_tree_ptr = __base_leaf;\n  \tif (1 == __exponent) {\n \t  __result = __base_rope;\n-#         ifndef __GC\n-\t    __stl_assert(2 == __result._M_tree_ptr->_M_ref_count);\n-\t\t// One each for base_rope and __result\n-#         endif\n \t} else {\n \t  __result = power(__base_rope, __exponent,\n \t\t\t   _Rope_Concat_fn<_CharT,_Alloc>());\n@@ -1490,8 +1489,6 @@ _Rope_rotate(_Rope_iterator __first,\n   typedef typename _Rope_iterator::value_type _CharT;\n   typedef typename _Rope_iterator::_allocator_type _Alloc;\n   \n-  __stl_assert(__first.container() == __middle.container()\n-                           && __middle.container() == __last.container());\n   rope<_CharT,_Alloc>& __r(__first.container());\n   rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n   rope<_CharT,_Alloc> __suffix = "}, {"sha": "cc6b6dfa6d212b1025d0153886e1bf5ba8b6b27d", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -317,21 +317,29 @@ private:\n \n   _Node* _M_create_node(const value_type& __x) {\n     _Node* __node = this->_M_get_node();\n-    __STL_TRY {\n+    try {\n       _Construct(&__node->_M_data, __x);\n       __node->_M_next = 0;\n     }\n-    __STL_UNWIND(this->_M_put_node(__node));\n+    catch(...)\n+      {\n+\tthis->_M_put_node(__node);\n+\t__throw_exception_again;\n+      }\n     return __node;\n   }\n   \n   _Node* _M_create_node() {\n     _Node* __node = this->_M_get_node();\n-    __STL_TRY {\n+    try {\n       _Construct(&__node->_M_data);\n       __node->_M_next = 0;\n     }\n-    __STL_UNWIND(this->_M_put_node(__node));\n+    catch(...)\n+      {\n+\tthis->_M_put_node(__node);\n+\t__throw_exception_again;\n+      }\n     return __node;\n   }\n "}, {"sha": "83e6ad6c1964bd9212efb47cae34a6aec9c2d31a", "filename": "libstdc++-v3/include/ext/stl_hashtable.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -516,11 +516,15 @@ class hashtable {\n   {\n     _Node* __n = _M_get_node();\n     __n->_M_next = 0;\n-    __STL_TRY {\n+    try {\n       _Construct(&__n->_M_val, __obj);\n       return __n;\n     }\n-    __STL_UNWIND(_M_put_node(__n));\n+    catch(...)\n+      {\n+\t_M_put_node(__n);\n+\t__throw_exception_again;\n+      }\n   }\n   \n   void _M_delete_node(_Node* __n)\n@@ -849,7 +853,7 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n     if (__n > __old_n) {\n       vector<_Node*, _All> __tmp(__n, (_Node*)(0),\n                                  _M_buckets.get_allocator());\n-      __STL_TRY {\n+      try {\n         for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {\n           _Node* __first = _M_buckets[__bucket];\n           while (__first) {\n@@ -862,7 +866,6 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n         }\n         _M_buckets.swap(__tmp);\n       }\n-#         ifdef __STL_USE_EXCEPTIONS\n       catch(...) {\n         for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {\n           while (__tmp[__bucket]) {\n@@ -871,9 +874,8 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n             __tmp[__bucket] = __next;\n           }\n         }\n-        throw;\n+        __throw_exception_again;\n       }\n-#         endif /* __STL_USE_EXCEPTIONS */\n     }\n   }\n }\n@@ -937,7 +939,7 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   _M_buckets.clear();\n   _M_buckets.reserve(__ht._M_buckets.size());\n   _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n-  __STL_TRY {\n+  try {\n     for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n       const _Node* __cur = __ht._M_buckets[__i];\n       if (__cur) {\n@@ -954,7 +956,11 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n     }\n     _M_num_elements = __ht._M_num_elements;\n   }\n-  __STL_UNWIND(clear());\n+  catch(...)\n+    {\n+      clear();\n+      __throw_exception_again;\n+    }\n }\n \n } // namespace std"}, {"sha": "96ec4952d6959506b382c28eec0ab80524090ffb", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -572,7 +572,6 @@ struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {\n         : _Rope_RopeRep<_CharT,_Alloc>(_S_leaf, 0, true, __size, __a),\n           _M_data(__d)\n         {\n-        __stl_assert(__size > 0);\n         if (_S_is_basic_char_type((_CharT *)0)) {\n             // already eos terminated.\n             _M_c_string = __d;\n@@ -646,7 +645,6 @@ struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {\n       , _M_delete_when_done(__d)\n #       endif\n     {\n-        __stl_assert(__size > 0);\n #       ifdef __GC\n             if (__d) {\n                 GC_REGISTER_FINALIZER(\n@@ -685,8 +683,6 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n               {\n                 char_producer<_CharT>* __fn =\n                         ((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;\n-                __stl_assert(__start_pos + __req_len <= _M_size);\n-                __stl_assert(_M_start + _M_size <= _M_base->_M_size);\n                 (*__fn)(__start_pos + _M_start, __req_len, __buffer);\n               }\n               break;\n@@ -699,7 +695,7 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n               }\n               break;\n             default:\n-              __stl_assert(false);\n+\t      break;\n         }\n     }\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n@@ -711,8 +707,6 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n         _M_base(__b),\n         _M_start(__s)\n     {\n-        __stl_assert(__l > 0);\n-        __stl_assert(__s + __l <= __b->_M_size);\n #       ifndef __GC\n             _M_base->_M_ref_nonnil();\n #       endif\n@@ -743,11 +737,11 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n     _Rope_RopeRep<_CharT,_Alloc>* _M_ptr;\n     ~_Rope_self_destruct_ptr() \n       { _Rope_RopeRep<_CharT,_Alloc>::_S_unref(_M_ptr); }\n-#   ifdef __STL_USE_EXCEPTIONS\n+#ifdef __EXCEPTIONS\n         _Rope_self_destruct_ptr() : _M_ptr(0) {};\n-#   else\n+#else\n         _Rope_self_destruct_ptr() {};\n-#   endif\n+#endif\n     _Rope_self_destruct_ptr(_Rope_RopeRep<_CharT,_Alloc>* __p) : _M_ptr(__p) {}\n     _Rope_RopeRep<_CharT,_Alloc>& operator*() { return *_M_ptr; }\n     _Rope_RopeRep<_CharT,_Alloc>* operator->() { return _M_ptr; }\n@@ -818,7 +812,6 @@ class _Rope_char_ptr_proxy {\n       : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n     _Rope_char_ptr_proxy() {}\n     _Rope_char_ptr_proxy(_CharT* __x) : _M_root(0), _M_pos(0) {\n-        __stl_assert(0 == __x);\n     }\n     _Rope_char_ptr_proxy& \n     operator= (const _Rope_char_ptr_proxy& __x) {\n@@ -1403,10 +1396,14 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n             uninitialized_copy_n(__s, __size, __buf);\n             _S_cond_store_eos(__buf[__size]);\n-            __STL_TRY {\n+            try {\n               return _S_new_RopeLeaf(__buf, __size, __a);\n             }\n-            __STL_UNWIND(_RopeRep::__STL_FREE_STRING(__buf, __size, __a))\n+            catch(...)\n+\t      {\n+\t\t_RopeRep::__STL_FREE_STRING(__buf, __size, __a);\n+\t\t__throw_exception_again;\n+\t      }\n         }\n             \n \n@@ -1541,10 +1538,14 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             _CharT* __buf = _Data_allocate(_S_rounded_up_size(1));\n \n             _Construct(__buf, __c);\n-            __STL_TRY {\n+            try {\n                 _M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a);\n             }\n-            __STL_UNWIND(_RopeRep::__STL_FREE_STRING(__buf, 1, __a))\n+            catch(...)\n+\t      {\n+\t\t_RopeRep::__STL_FREE_STRING(__buf, 1, __a);\n+\t\t__throw_exception_again;\n+\t      }\n         }\n \n         rope(size_t __n, _CharT __c,\n@@ -1576,7 +1577,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         rope& operator=(const rope& __x)\n         {\n             _RopeRep* __old = _M_tree_ptr;\n-            __stl_assert(get_allocator() == __x.get_allocator());\n             _M_tree_ptr = __x._M_tree_ptr;\n             _S_ref(_M_tree_ptr);\n             _S_unref(__old);\n@@ -1614,12 +1614,16 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             _RopeRep* __old = _M_tree_ptr;\n             _RopeRep* __left =\n               __STL_ROPE_FROM_UNOWNED_CHAR_PTR(&__x, 1, get_allocator());\n-            __STL_TRY {\n+            try {\n               _M_tree_ptr = _S_concat(__left, _M_tree_ptr);\n               _S_unref(__old);\n               _S_unref(__left);\n             }\n-            __STL_UNWIND(_S_unref(__left))\n+            catch(...)\n+\t      {\n+\t\t_S_unref(__left);\n+\t\t__throw_exception_again;\n+\t      }\n         }\n \n         void pop_front()\n@@ -1793,8 +1797,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         rope& append(const_iterator __s, const_iterator __e) {\n-            __stl_assert(__s._M_root == __e._M_root);\n-            __stl_assert(get_allocator() == __s._M_root->get_allocator());\n             _Self_destruct_ptr __appendee(_S_substring(\n               __s._M_root, __s._M_current_pos, __e._M_current_pos));\n             _RopeRep* __result = \n@@ -1815,7 +1817,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         rope& append() { return append(_CharT()); }  // XXX why?\n \n         rope& append(const rope& __y) {\n-            __stl_assert(__y.get_allocator() == get_allocator());\n             _RopeRep* __result = _S_concat(_M_tree_ptr, __y._M_tree_ptr);\n             _S_unref(_M_tree_ptr);\n             _M_tree_ptr = __result;\n@@ -1828,7 +1829,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         void swap(rope& __b) {\n-            __stl_assert(get_allocator() == __b.get_allocator());\n             _RopeRep* __tmp = _M_tree_ptr;\n             _M_tree_ptr = __b._M_tree_ptr;\n             __b._M_tree_ptr = __tmp;\n@@ -1846,7 +1846,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n               _S_substring(__old, __pos2, __old->_M_size));\n             _RopeRep* __result;\n \n-            __stl_assert(__old->get_allocator() == __r->get_allocator());\n             if (0 == __r) {\n                 __result = _S_concat(__left, __right);\n             } else {\n@@ -1860,7 +1859,6 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         void insert(size_t __p, const rope& __r) {\n             _RopeRep* __result = \n               replace(_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n-            __stl_assert(get_allocator() == __r.get_allocator());\n             _S_unref(_M_tree_ptr);\n             _M_tree_ptr = __result;\n         }\n@@ -2326,7 +2324,6 @@ rope<_CharT,_Alloc>\n operator+ (const rope<_CharT,_Alloc>& __left,\n            const rope<_CharT,_Alloc>& __right)\n {\n-    __stl_assert(__left.get_allocator() == __right.get_allocator());\n     return rope<_CharT,_Alloc>(\n       rope<_CharT,_Alloc>::_S_concat(__left._M_tree_ptr, __right._M_tree_ptr));\n     // Inlining this should make it possible to keep __left and"}, {"sha": "118aa913bd3a7dcc0782b10bea678c4addf3cb99", "filename": "libstdc++-v3/libsupc++/eh_aux_runtime.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -30,7 +30,7 @@\n \n #include \"typeinfo\"\n #include \"exception\"\n-#include <cstddef>\n+#include <cstdlib>\n #include \"unwind-cxx.h\"\n #include \"exception_defines.h\"\n \n@@ -54,3 +54,4 @@ __cxa_bad_typeid ()\n   std::abort();\n #endif\n }\n+"}, {"sha": "5c0ec500632566876ef8742eca0ad2a8a41090c6", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -30,6 +30,7 @@\n \n #include <bits/c++config.h>\n #include <cstdlib>\n+#include <exception_defines.h>\n #include \"unwind-cxx.h\"\n \n using namespace __cxxabiv1;\n@@ -412,31 +413,33 @@ __cxa_call_unexpected (_Unwind_Exception *exc_obj)\n \n   __cxa_exception *xh = __get_exception_header_from_ue (exc_obj);\n \n-  try {\n-    __unexpected (xh->unexpectedHandler);\n-  } catch (...) {\n-    // Get the exception thrown from unexpected.\n-    // ??? Foreign exceptions can't be stacked this way.\n-\n-    __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n-    __cxa_exception *new_xh = globals->caughtExceptions;\n-\n-    // We don't quite have enough stuff cached; re-parse the LSDA.\n-    lsda_header_info info;\n-    parse_lsda_header (0, xh->languageSpecificData, &info);\n-    info.ttype_base = (_Unwind_Ptr) xh->catchTemp;\n-\n-    // If this new exception meets the exception spec, allow it.\n-    if (check_exception_spec (&info, new_xh->exceptionType,\n-\t\t\t      xh->handlerSwitchValue))\n-      throw;\n-\n-    // If the exception spec allows std::bad_exception, throw that.\n-    const std::type_info &bad_exc = typeid (std::bad_exception);\n-    if (check_exception_spec (&info, &bad_exc, xh->handlerSwitchValue))\n-      throw std::bad_exception ();\n-\n-    // Otherwise, die.\n-    __terminate(xh->terminateHandler);\n-  }\n+  try \n+    { __unexpected (xh->unexpectedHandler); } \n+  catch(...) \n+    {\n+      // Get the exception thrown from unexpected.\n+      // ??? Foreign exceptions can't be stacked this way.\n+      \n+      __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n+      __cxa_exception *new_xh = globals->caughtExceptions;\n+      \n+      // We don't quite have enough stuff cached; re-parse the LSDA.\n+      lsda_header_info info;\n+      parse_lsda_header (0, xh->languageSpecificData, &info);\n+      info.ttype_base = (_Unwind_Ptr) xh->catchTemp;\n+      \n+      // If this new exception meets the exception spec, allow it.\n+      if (check_exception_spec (&info, new_xh->exceptionType,\n+\t\t\t\txh->handlerSwitchValue))\n+\t__throw_exception_again;\n+      \n+      // If the exception spec allows std::bad_exception, throw that.\n+#ifdef __EXCEPTIONS  \n+      const std::type_info &bad_exc = typeid (std::bad_exception);\n+      if (check_exception_spec (&info, &bad_exc, xh->handlerSwitchValue))\n+\tthrow std::bad_exception();\n+#endif   \n+      // Otherwise, die.\n+      __terminate(xh->terminateHandler);\n+    }\n }"}, {"sha": "df43e6e45769c95f07203c8d01a3fd649c9d614a", "filename": "libstdc++-v3/libsupc++/new_op.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_op.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -28,6 +28,7 @@\n // the GNU General Public License.\n \n #include \"new\"\n+#include <cstdlib>\n #include <exception_defines.h>\n \n using std::new_handler;"}, {"sha": "557fd039432ca9bd8aeb23cabd99acd757f926c6", "filename": "libstdc++-v3/libsupc++/vec.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -34,7 +34,6 @@\n #include <new>\n #include <exception>\n #include <exception_defines.h>\n-\n #include \"unwind-cxx.h\"\n \n namespace __cxxabiv1"}, {"sha": "9798e8f2ca0a1accc39d9e693f4c9b4c24e0b350", "filename": "libstdc++-v3/src/functexcept.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Fsrc%2Ffunctexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Fsrc%2Ffunctexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffunctexcept.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -110,43 +110,43 @@ namespace std\n   { abort(); }\n \n   void\n-  __throw_logic_error(const char* __s)\n+  __throw_logic_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_domain_error(const char* __s)\n+  __throw_domain_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_invalid_argument(const char* __s)\n+  __throw_invalid_argument(const char*)\n   { abort(); }\n \n   void\n-  __throw_length_error(const char* __s)\n+  __throw_length_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_out_of_range(const char* __s)\n+  __throw_out_of_range(const char*)\n   { abort(); }\n \n   void\n-  __throw_runtime_error(const char* __s)\n+  __throw_runtime_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_range_error(const char* __s)\n+  __throw_range_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_overflow_error(const char* __s)\n+  __throw_overflow_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_underflow_error(const char* __s)\n+  __throw_underflow_error(const char*)\n   { abort(); }\n \n   void\n-  __throw_ios_failure(const char* __s)\n+  __throw_ios_failure(const char*)\n   { abort(); }\n #endif //__EXCEPTIONS\n }"}, {"sha": "f9a9726c198ee1a074b0e3dba95fbcb7f0305b27", "filename": "libstdc++-v3/testsuite/23_containers/bitset_members.cc", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/322821b9ad320f6f0104844d6442b02c57da1a94/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_members.cc?ref=322821b9ad320f6f0104844d6442b02c57da1a94", "patch": "@@ -23,15 +23,13 @@\n #include <bitset>\n #include <testsuite_hooks.h>\n \n-bool test01(void)\n+void \n+test01(void)\n {\n   bool test = true;\n   const size_t n1 = 5;\n \n-// the other 22 member functions should be in here too...\n-\n-\n-  // test()\n+  // the other 22 member functions should be in here too...\n   try {\n     std::bitset<n1> five_bits;\n     bool unused = five_bits.test(n1);   // should throw\n@@ -43,12 +41,7 @@ bool test01(void)\n   catch(...) {\n     VERIFY( false );\n   }\n-  \n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-  return test;\n+  VERIFY( test );\n }\n \n int main()"}]}