{"sha": "049eda8274b7394523238b17ab12c3e2889f253e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ5ZWRhODI3NGI3Mzk0NTIzMjM4YjE3YWIxMmMzZTI4ODlmMjUzZQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-06T10:09:12Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-16T09:57:27Z"}, "message": "Avoid 'GTY' use for 'gcc/omp-oacc-neuter-broadcast.cc:field_map'\n\n... and further simplify related things a bit.\n\nFix-up/clean-up for recent commit e2a58ed6dc5293602d0d168475109caa81ad0f0d\n\"openacc: Middle-end worker-partitioning support\".\n\n\tgcc/\n\t* omp-oacc-neuter-broadcast.cc (field_map): Move variable into...\n\t(execute_omp_oacc_neuter_broadcast): ... here.\n\t(install_var_field, build_receiver_ref, build_sender_ref): Take\n\t'field_map_t *' parameter.  Adjust all users.\n\t(worker_single_copy, neuter_worker_single): Take a\n\t'record_field_map_t *' parameter.  Adjust all users.", "tree": {"sha": "f85c2fcbf36389e28ad91a07a647f168d9d7d126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f85c2fcbf36389e28ad91a07a647f168d9d7d126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/049eda8274b7394523238b17ab12c3e2889f253e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049eda8274b7394523238b17ab12c3e2889f253e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/049eda8274b7394523238b17ab12c3e2889f253e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049eda8274b7394523238b17ab12c3e2889f253e/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1afcf5705a0becdca96111a6cb67670217c335b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afcf5705a0becdca96111a6cb67670217c335b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1afcf5705a0becdca96111a6cb67670217c335b3"}], "stats": {"total": 48, "additions": 26, "deletions": 22}, "files": [{"sha": "9bde0aca10fef292822f01564945fa257eb5def7", "filename": "gcc/omp-oacc-neuter-broadcast.cc", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049eda8274b7394523238b17ab12c3e2889f253e/gcc%2Fomp-oacc-neuter-broadcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049eda8274b7394523238b17ab12c3e2889f253e/gcc%2Fomp-oacc-neuter-broadcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-oacc-neuter-broadcast.cc?ref=049eda8274b7394523238b17ab12c3e2889f253e", "patch": "@@ -538,12 +538,9 @@ typedef hash_map<tree, tree> field_map_t;\n \n typedef hash_map<tree, field_map_t *> record_field_map_t;\n \n-static GTY(()) record_field_map_t *field_map;\n-\n static void\n-install_var_field (tree var, tree record_type)\n+install_var_field (tree var, tree record_type, field_map_t *fields)\n {\n-  field_map_t *fields = *field_map->get (record_type);\n   tree name;\n   char tmp[20];\n \n@@ -959,9 +956,8 @@ oacc_build_component_ref (tree obj, tree field)\n }\n \n static tree\n-build_receiver_ref (tree record_type, tree var, tree receiver_decl)\n+build_receiver_ref (tree var, tree receiver_decl, field_map_t *fields)\n {\n-  field_map_t *fields = *field_map->get (record_type);\n   tree x = build_simple_mem_ref (receiver_decl);\n   tree field = *fields->get (var);\n   TREE_THIS_NOTRAP (x) = 1;\n@@ -970,9 +966,8 @@ build_receiver_ref (tree record_type, tree var, tree receiver_decl)\n }\n \n static tree\n-build_sender_ref (tree record_type, tree var, tree sender_decl)\n+build_sender_ref (tree var, tree sender_decl, field_map_t *fields)\n {\n-  field_map_t *fields = *field_map->get (record_type);\n   tree field = *fields->get (var);\n   return oacc_build_component_ref (sender_decl, field);\n }\n@@ -1010,7 +1005,7 @@ static void\n worker_single_copy (basic_block from, basic_block to,\n \t\t    hash_set<tree> *def_escapes_block,\n \t\t    hash_set<tree> *worker_partitioned_uses,\n-\t\t    tree record_type)\n+\t\t    tree record_type, record_field_map_t *record_field_map)\n {\n   /* If we only have virtual defs, we'll have no record type, but we still want\n      to emit single_copy_start and (particularly) single_copy_end to act as\n@@ -1147,7 +1142,7 @@ worker_single_copy (basic_block from, basic_block to,\n \tgcc_assert (TREE_CODE (var) == VAR_DECL);\n \n       /* If we had no record type, we will have no fields map.  */\n-      field_map_t **fields_p = field_map->get (record_type);\n+      field_map_t **fields_p = record_field_map->get (record_type);\n       field_map_t *fields = fields_p ? *fields_p : NULL;\n \n       if (worker_partitioned_uses->contains (var)\n@@ -1158,8 +1153,7 @@ worker_single_copy (basic_block from, basic_block to,\n \n \t  /* Receive definition from shared memory block.  */\n \n-\t  tree receiver_ref = build_receiver_ref (record_type, var,\n-\t\t\t\t\t\t  receiver_decl);\n+\t  tree receiver_ref = build_receiver_ref (var, receiver_decl, fields);\n \t  gassign *recv = gimple_build_assign (neutered_def,\n \t\t\t\t\t       receiver_ref);\n \t  gsi_insert_after (&copyout_gsi, recv, GSI_CONTINUE_LINKING);\n@@ -1189,7 +1183,7 @@ worker_single_copy (basic_block from, basic_block to,\n \n \t  /* Send definition to shared memory block.  */\n \n-\t  tree sender_ref = build_sender_ref (record_type, var, sender_decl);\n+\t  tree sender_ref = build_sender_ref (var, sender_decl, fields);\n \n \t  if (TREE_CODE (var) == SSA_NAME)\n \t    {\n@@ -1232,7 +1226,8 @@ static void\n neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \t\t      bitmap worker_single, bitmap vector_single,\n \t\t      vec<propagation_set *> *prop_set,\n-\t\t      hash_set<tree> *partitioned_var_uses)\n+\t\t      hash_set<tree> *partitioned_var_uses,\n+\t\t      record_field_map_t *record_field_map)\n {\n   unsigned mask = outer_mask | par->mask;\n \n@@ -1322,7 +1317,8 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \n \t  if (has_defs)\n \t    worker_single_copy (block, block, &def_escapes_block,\n-\t\t\t\t&worker_partitioned_uses, record_type);\n+\t\t\t\t&worker_partitioned_uses, record_type,\n+\t\t\t\trecord_field_map);\n \t  else\n \t    worker_single_simple (block, block, &def_escapes_block);\n \t}\n@@ -1358,10 +1354,10 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \n   if (par->inner)\n     neuter_worker_single (par->inner, mask, worker_single, vector_single,\n-\t\t\t  prop_set, partitioned_var_uses);\n+\t\t\t  prop_set, partitioned_var_uses, record_field_map);\n   if (par->next)\n     neuter_worker_single (par->next, outer_mask, worker_single, vector_single,\n-\t\t\t  prop_set, partitioned_var_uses);\n+\t\t\t  prop_set, partitioned_var_uses, record_field_map);\n }\n \n static int\n@@ -1402,8 +1398,6 @@ execute_omp_oacc_neuter_broadcast ()\n   FOR_ALL_BB_FN (bb, cfun)\n     bb->aux = NULL;\n \n-  field_map = record_field_map_t::create_ggc (40);\n-\n   vec<propagation_set *> prop_set;\n   prop_set.create (last_basic_block_for_fn (cfun));\n \n@@ -1421,6 +1415,8 @@ execute_omp_oacc_neuter_broadcast ()\n   find_local_vars_to_propagate (par, mask, &partitioned_var_uses,\n \t\t\t\t&gang_private_vars, &prop_set);\n \n+  record_field_map_t record_field_map;\n+\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n       propagation_set *ws_prop = prop_set[bb->index];\n@@ -1441,12 +1437,16 @@ execute_omp_oacc_neuter_broadcast ()\n \n \t  field_vec.qsort (sort_by_size_then_ssa_version_or_uid);\n \n-\t  field_map->put (record_type, field_map_t::create_ggc (17));\n+\t  field_map_t *fields = new field_map_t;\n+\n+\t  bool existed;\n+\t  existed = record_field_map.put (record_type, fields);\n+\t  gcc_checking_assert (!existed);\n \n \t  /* Insert var fields in reverse order, so the last inserted element\n \t     is the first in the structure.  */\n \t  for (int i = field_vec.length () - 1; i >= 0; i--)\n-\t    install_var_field (field_vec[i], record_type);\n+\t    install_var_field (field_vec[i], record_type, fields);\n \n \t  layout_type (record_type);\n \n@@ -1455,7 +1455,11 @@ execute_omp_oacc_neuter_broadcast ()\n     }\n \n   neuter_worker_single (par, mask, worker_single, vector_single, &prop_set,\n-\t\t\t&partitioned_var_uses);\n+\t\t\t&partitioned_var_uses, &record_field_map);\n+\n+  for (auto it : record_field_map)\n+    delete it.second;\n+  record_field_map.empty ();\n \n   prop_set.release ();\n "}]}