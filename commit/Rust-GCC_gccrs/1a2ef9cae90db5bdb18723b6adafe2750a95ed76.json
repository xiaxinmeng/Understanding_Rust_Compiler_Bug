{"sha": "1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "node_id": "C_kwDOANBUbNoAKDFhMmVmOWNhZTkwZGI1YmRiMTg3MjNiNmFkYWZlMjc1MGE5NWVkNzY", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-14T16:08:07Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-17T14:51:06Z"}, "message": "macros: Add remaining context and improve parsing macro dispatch\n\nThis allows us to expand macor invocations in more places, as macro\ncalls are not limited to statements or expressions. It is quite common\nto use macros to abstract writing repetitive boilerplate for type\nimplementations, for example.", "tree": {"sha": "c634ec46956c01a631ba528854975b45b82739a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c634ec46956c01a631ba528854975b45b82739a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a14348afefc62313e38156fde768744378f9ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a14348afefc62313e38156fde768744378f9ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a14348afefc62313e38156fde768744378f9ebf"}], "stats": {"total": 389, "additions": 298, "deletions": 91}, "files": [{"sha": "e33fff2d988ac645243241dabc1d5cea726951f5", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 103, "deletions": 16, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -1511,18 +1511,45 @@ class SingleASTNode\n     EXPRESSION,\n     ITEM,\n     STMT,\n+    EXTERN,\n+    TRAIT,\n+    IMPL,\n   };\n \n+private:\n+  NodeType kind;\n+\n+  // FIXME make this a union\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Stmt> stmt;\n+  std::unique_ptr<ExternalItem> external_item;\n+  std::unique_ptr<TraitItem> trait_item;\n+  std::unique_ptr<InherentImplItem> impl_item;\n+\n+public:\n   SingleASTNode (std::unique_ptr<Expr> expr)\n-    : kind (EXPRESSION), expr (std::move (expr)), item (nullptr), stmt (nullptr)\n+    : kind (EXPRESSION), expr (std::move (expr))\n   {}\n \n   SingleASTNode (std::unique_ptr<Item> item)\n-    : kind (ITEM), expr (nullptr), item (std::move (item)), stmt (nullptr)\n+    : kind (ITEM), item (std::move (item))\n   {}\n \n   SingleASTNode (std::unique_ptr<Stmt> stmt)\n-    : kind (STMT), expr (nullptr), item (nullptr), stmt (std::move (stmt))\n+    : kind (STMT), stmt (std::move (stmt))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<ExternalItem> item)\n+    : kind (EXTERN), external_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<TraitItem> item)\n+    : kind (TRAIT), trait_item (std::move (item))\n+  {}\n+\n+  SingleASTNode (std::unique_ptr<InherentImplItem> item)\n+    : kind (IMPL), impl_item (std::move (item))\n   {}\n \n   SingleASTNode (SingleASTNode const &other)\n@@ -1541,6 +1568,18 @@ class SingleASTNode\n       case STMT:\n \tstmt = other.stmt->clone_stmt ();\n \tbreak;\n+\n+      case EXTERN:\n+\texternal_item = other.external_item->clone_external_item ();\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item = other.trait_item->clone_trait_item ();\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item = other.impl_item->clone_inherent_impl_item ();\n+\tbreak;\n       }\n   }\n \n@@ -1560,6 +1599,18 @@ class SingleASTNode\n       case STMT:\n \tstmt = other.stmt->clone_stmt ();\n \tbreak;\n+\n+      case EXTERN:\n+\texternal_item = other.external_item->clone_external_item ();\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item = other.trait_item->clone_trait_item ();\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item = other.impl_item->clone_inherent_impl_item ();\n+\tbreak;\n       }\n     return *this;\n   }\n@@ -1569,7 +1620,7 @@ class SingleASTNode\n \n   NodeType get_kind () const { return kind; }\n \n-  std::unique_ptr<Expr> &get_inner ()\n+  std::unique_ptr<Expr> &get_expr ()\n   {\n     rust_assert (kind == EXPRESSION);\n     return expr;\n@@ -1610,6 +1661,24 @@ class SingleASTNode\n     return std::move (item);\n   }\n \n+  std::unique_ptr<TraitItem> take_trait_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (trait_item);\n+  }\n+\n+  std::unique_ptr<ExternalItem> take_external_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (external_item);\n+  }\n+\n+  std::unique_ptr<InherentImplItem> take_impl_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (impl_item);\n+  }\n+\n   void accept_vis (ASTVisitor &vis)\n   {\n     switch (kind)\n@@ -1625,6 +1694,18 @@ class SingleASTNode\n       case STMT:\n \tstmt->accept_vis (vis);\n \tbreak;\n+\n+      case EXTERN:\n+\texternal_item->accept_vis (vis);\n+\tbreak;\n+\n+      case TRAIT:\n+\ttrait_item->accept_vis (vis);\n+\tbreak;\n+\n+      case IMPL:\n+\timpl_item->accept_vis (vis);\n+\tbreak;\n       }\n   }\n \n@@ -1638,9 +1719,16 @@ class SingleASTNode\n \treturn item == nullptr;\n       case STMT:\n \treturn stmt == nullptr;\n-      default:\n-\treturn true;\n+      case EXTERN:\n+\treturn external_item == nullptr;\n+      case TRAIT:\n+\treturn trait_item == nullptr;\n+      case IMPL:\n+\treturn impl_item == nullptr;\n       }\n+\n+    gcc_unreachable ();\n+    return true;\n   }\n \n   std::string as_string ()\n@@ -1653,18 +1741,17 @@ class SingleASTNode\n \treturn \"Item: \" + item->as_string ();\n       case STMT:\n \treturn \"Stmt: \" + stmt->as_string ();\n-      default:\n-\treturn \"\";\n+      case EXTERN:\n+\treturn \"External Item: \" + external_item->as_string ();\n+      case TRAIT:\n+\treturn \"Trait Item: \" + trait_item->as_string ();\n+      case IMPL:\n+\treturn \"Impl Item: \" + impl_item->as_string ();\n       }\n-  }\n-\n-private:\n-  NodeType kind;\n \n-  // FIXME make this a union\n-  std::unique_ptr<Expr> expr;\n-  std::unique_ptr<Item> item;\n-  std::unique_ptr<Stmt> stmt;\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n };\n \n /* Basically, a \"fragment\" that can be incorporated into the AST, created as"}, {"sha": "5ecd5d7261192a16a355d3120ed3f295744721a0", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -460,6 +460,7 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic TraitItem,\n \t\t\tpublic TraitImplItem,\n \t\t\tpublic InherentImplItem,\n+\t\t\tpublic ExternalItem,\n \t\t\tpublic ExprWithoutBlock\n {\n   std::vector<Attribute> outer_attrs;\n@@ -537,6 +538,11 @@ class MacroInvocation : public TypeNoBounds,\n     return clone_macro_invocation_impl ();\n   }\n \n+  MacroInvocation *clone_external_item_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n   /*virtual*/ MacroInvocation *clone_macro_invocation_impl () const\n   {\n     return new MacroInvocation (*this);"}, {"sha": "50821edcfae59b2a02be247617ba27b882f2edc1", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -1114,8 +1114,6 @@ AttrVisitor::visit (AST::ClosureExprInner &expr)\n void\n AttrVisitor::visit (AST::BlockExpr &expr)\n {\n-  expander.push_context (MacroExpander::BLOCK);\n-\n   // initial strip test based on outer attrs\n   expander.expand_cfg_attrs (expr.get_outer_attrs ());\n   if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n@@ -1135,31 +1133,13 @@ AttrVisitor::visit (AST::BlockExpr &expr)\n       return;\n     }\n \n-  // strip all statements\n-  auto &stmts = expr.get_statements ();\n-  for (auto it = stmts.begin (); it != stmts.end ();)\n-    {\n-      auto &stmt = *it;\n-\n-      stmt->accept_vis (*this);\n+  std::function<std::unique_ptr<AST::Stmt> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_stmt (); };\n \n-      auto fragment = expander.take_expanded_fragment (*this);\n-      if (fragment.should_expand ())\n-\t{\n-\t  // Remove the current expanded invocation\n-\t  it = stmts.erase (it);\n-\t  for (auto &node : fragment.get_nodes ())\n-\t    {\n-\t      it = stmts.insert (it, node.take_stmt ());\n-\t      it++;\n-\t    }\n-\t}\n+  expand_macro_children (MacroExpander::BLOCK, expr.get_statements (),\n+\t\t\t extractor);\n \n-      else if (stmt->is_marked_for_strip ())\n-\tit = stmts.erase (it);\n-      else\n-\tit++;\n-    }\n+  expander.push_context (MacroExpander::BLOCK);\n \n   // strip tail expression if exists - can actually fully remove it\n   if (expr.has_tail_expr ())\n@@ -2489,8 +2469,11 @@ AttrVisitor::visit (AST::Trait &trait)\n   if (trait.has_where_clause ())\n     expand_where_clause (trait.get_where_clause ());\n \n-  // strip trait items if required\n-  expand_pointer_allow_strip (trait.get_trait_items ());\n+  std::function<std::unique_ptr<AST::TraitItem> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_trait_item (); };\n+\n+  expand_macro_children (MacroExpander::TRAIT, trait.get_trait_items (),\n+\t\t\t extractor);\n }\n void\n AttrVisitor::visit (AST::InherentImpl &impl)\n@@ -2523,8 +2506,11 @@ AttrVisitor::visit (AST::InherentImpl &impl)\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n-  // strip inherent impl items if required\n-  expand_pointer_allow_strip (impl.get_impl_items ());\n+  std::function<std::unique_ptr<AST::InherentImplItem> (AST::SingleASTNode)>\n+    extractor = [] (AST::SingleASTNode node) { return node.take_impl_item (); };\n+\n+  expand_macro_children (MacroExpander::IMPL, impl.get_impl_items (),\n+\t\t\t extractor);\n }\n void\n AttrVisitor::visit (AST::TraitImpl &impl)\n@@ -2659,8 +2645,12 @@ AttrVisitor::visit (AST::ExternBlock &block)\n       return;\n     }\n \n-  // strip external items if required\n-  expand_pointer_allow_strip (block.get_extern_items ());\n+  std::function<std::unique_ptr<AST::ExternalItem> (AST::SingleASTNode)>\n+    extractor\n+    = [] (AST::SingleASTNode node) { return node.take_external_item (); };\n+\n+  expand_macro_children (MacroExpander::EXTERN, block.get_extern_items (),\n+\t\t\t extractor);\n }\n \n // I don't think it would be possible to strip macros without expansion"}, {"sha": "6da6583030c593fd929111811497d533e30020de", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -40,19 +40,70 @@ class AttrVisitor : public AST::ASTVisitor\n   void expand_trait_function_decl (AST::TraitFunctionDecl &decl);\n   void expand_trait_method_decl (AST::TraitMethodDecl &decl);\n \n-  template <typename T> void expand_pointer_allow_strip (T &values)\n+  /**\n+   * Expand a set of values, erasing them if they are marked for strip, and\n+   * replacing them with expanded macro nodes if necessary.\n+   * This function is slightly different from `expand_pointer_allow_strip` as\n+   * it can only be called in certain expansion contexts - where macro\n+   * invocations are allowed.\n+   *\n+   * @param ctx Context to use for macro expansion\n+   * @param values Iterable reference over values to replace or erase\n+   * @param extractor Function to call when replacing values with the content\n+   * \t\tof an expanded AST node\n+   */\n+  template <typename T, typename U>\n+  void expand_macro_children (MacroExpander::ContextType ctx, T &values,\n+\t\t\t      std::function<U (AST::SingleASTNode)> extractor)\n   {\n+    expander.push_context (ctx);\n+\n     for (auto it = values.begin (); it != values.end ();)\n       {\n \tauto &value = *it;\n \n \t// mark for stripping if required\n \tvalue->accept_vis (*this);\n \n+\tauto fragment = expander.take_expanded_fragment (*this);\n+\tif (fragment.should_expand ())\n+\t  {\n+\t    it = values.erase (it);\n+\t    for (auto &node : fragment.get_nodes ())\n+\t      {\n+\t\tit = values.insert (it, extractor (node));\n+\t\tit++;\n+\t      }\n+\t  }\n+\telse if (value->is_marked_for_strip ())\n+\t  {\n+\t    it = values.erase (it);\n+\t  }\n+\telse\n+\t  {\n+\t    ++it;\n+\t  }\n+      }\n+\n+    expander.pop_context ();\n+  }\n+\n+  template <typename T> void expand_pointer_allow_strip (T &values)\n+  {\n+    for (auto it = values.begin (); it != values.end ();)\n+      {\n+\tauto &value = *it;\n+\n+\t// mark for stripping if required\n+\tvalue->accept_vis (*this);\n \tif (value->is_marked_for_strip ())\n-\t  it = values.erase (it);\n+\t  {\n+\t    it = values.erase (it);\n+\t  }\n \telse\n-\t  ++it;\n+\t  {\n+\t    ++it;\n+\t  }\n       }\n   }\n "}, {"sha": "80f822b3e530ed3d12ad86e724677e5790dd3f72", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 104, "deletions": 35, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -786,7 +786,6 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t    std::function<AST::SingleASTNode ()> parse_fn)\n {\n   std::vector<AST::SingleASTNode> nodes;\n-\n   while (true)\n     {\n       if (parser.peek_current_token ()->get_id () == delimiter)\n@@ -814,6 +813,52 @@ transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n   });\n }\n \n+/**\n+ * Transcribe 0 or more external items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_external_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more trait items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n+\t\t\t     TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_trait_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more impl items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_inherent_impl_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n /**\n  * Transcribe 0 or more statements from a macro invocation\n  *\n@@ -845,6 +890,57 @@ transcribe_expression (Parser<MacroInvocLexer> &parser)\n   return {AST::SingleASTNode (std::move (expr))};\n }\n \n+static std::vector<AST::SingleASTNode>\n+transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n+\t\t\t AST::DelimType delimiter, TokenId last_token_id)\n+{\n+  if (semicolon || delimiter == AST::DelimType::CURLY)\n+    return transcribe_many_stmts (parser, last_token_id);\n+  else\n+    return transcribe_expression (parser);\n+} // namespace Rust\n+\n+static std::vector<AST::SingleASTNode>\n+transcribe_context (MacroExpander::ContextType ctx,\n+\t\t    Parser<MacroInvocLexer> &parser, bool semicolon,\n+\t\t    AST::DelimType delimiter, TokenId last_token_id)\n+{\n+  // The flow-chart in order to choose a parsing function is as follows:\n+  //\n+  // [switch special context]\n+  //     -- Item --> parser.parse_item();\n+  //     -- Trait --> parser.parse_trait_item();\n+  //     -- Impl --> parser.parse_impl_item();\n+  //     -- Extern --> parser.parse_extern_item();\n+  //     -- None --> [has semicolon?]\n+  //                 -- Yes --> parser.parse_stmt();\n+  //                 -- No --> [switch invocation.delimiter()]\n+  //                             -- { } --> parser.parse_stmt();\n+  //                             -- _ --> parser.parse_expr(); // once!\n+\n+  // If there is a semicolon OR we are expanding a MacroInvocationSemi, then\n+  // we can parse multiple items. Otherwise, parse *one* expression\n+\n+  switch (ctx)\n+    {\n+    case MacroExpander::ContextType::ITEM:\n+      return transcribe_many_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::TRAIT:\n+      return transcribe_many_trait_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::IMPL:\n+      return transcribe_many_impl_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::EXTERN:\n+      return transcribe_many_ext (parser, last_token_id);\n+      break;\n+    default:\n+      return transcribe_on_delimiter (parser, semicolon, delimiter,\n+\t\t\t\t      last_token_id);\n+    }\n+}\n+\n AST::ASTFragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n@@ -864,18 +960,15 @@ MacroExpander::transcribe_rule (\n   std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n     = substitute_context.substitute_tokens ();\n \n+  // handy for debugging\n+  // for (auto &tok : substituted_tokens)\n+  //   rust_debug (\"[tok] %s\", tok->as_string ().c_str ());\n+\n   // parse it to an ASTFragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n   Parser<MacroInvocLexer> parser (std::move (lex));\n \n-  // handy for debugging\n-  // for (auto &tok : substituted_tokens)\n-  //   {\n-  //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n-  //   }\n-\n   auto last_token_id = TokenId::RIGHT_CURLY;\n-  std::vector<AST::SingleASTNode> nodes;\n \n   // this is used so we can check that we delimit the stream correctly.\n   switch (transcribe_tree.get_delim_type ())\n@@ -905,33 +998,9 @@ MacroExpander::transcribe_rule (\n   //   as a statement (either via ExpressionStatement or\n   //   MacroInvocationWithSemi)\n \n-  // The flow-chart in order to choose a parsing function is as follows:\n-  //\n-  // [is in item context?]\n-  //     -- Yes --> parser.parse_item();\n-  //     -- No --> [has semicolon?]\n-  //                 -- Yes --> parser.parse_stmt();\n-  //                 -- No --> [switch invocation.delimiter()]\n-  //                             -- { } --> parser.parse_stmt();\n-  //                             -- _ --> parser.parse_expr();\n-\n-  // If there is a semicolon OR we are expanding a MacroInvocationSemi, then\n-  // we can parse multiple items. Otherwise, parse *one* expression\n-\n-  if (ctx == ContextType::ITEM)\n-    nodes = transcribe_many_items (parser, last_token_id);\n-  else if (semicolon)\n-    nodes = transcribe_many_stmts (parser, last_token_id);\n-  else\n-    switch (invoc_token_tree.get_delim_type ())\n-      {\n-      case AST::CURLY:\n-\tnodes = transcribe_many_stmts (parser, last_token_id);\n-\tbreak;\n-      default:\n-\tnodes = transcribe_expression (parser);\n-\tbreak;\n-      }\n+  auto nodes\n+    = transcribe_context (ctx, parser, semicolon,\n+\t\t\t  invoc_token_tree.get_delim_type (), last_token_id);\n \n   // emit any errors\n   if (parser.has_errors ())"}, {"sha": "61b69e412a48db6c1aee1371dc348132a135c533", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -187,6 +187,9 @@ struct MacroExpander\n   {\n     ITEM,\n     BLOCK,\n+    TRAIT,\n+    IMPL,\n+    EXTERN,\n   };\n \n   ExpansionCfg cfg;"}, {"sha": "82e7e249531fc1e76a535fc7594e1f2d7f574f21", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -5251,12 +5251,11 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n   switch (t->get_id ())\n     {\n     case IDENTIFIER:\n+      // FIXME: Arthur: Do we need to some lookahead here?\n+      return parse_macro_invocation_semi (outer_attrs);\n     case SUPER:\n     case SELF:\n     case CRATE:\n-    case DOLLAR_SIGN:\n-      // these seem to be SimplePath tokens, so this is a macro invocation semi\n-      return parse_macro_invocation_semi (std::move (outer_attrs));\n       case PUB: {\n \t// visibility, so not a macro invocation semi - must be constant,\n \t// function, or method\n@@ -5813,6 +5812,8 @@ Parser<ManagedTokenSource>::parse_external_item ()\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n+    case IDENTIFIER:\n+      return parse_macro_invocation_semi (outer_attrs);\n       case STATIC_TOK: {\n \t// parse extern static item\n \tlexer.skip_token ();"}, {"sha": "bb5bf3d70727b56e04aa477f80177e6ed573fb4d", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2ef9cae90db5bdb18723b6adafe2750a95ed76/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=1a2ef9cae90db5bdb18723b6adafe2750a95ed76", "patch": "@@ -135,6 +135,9 @@ template <typename ManagedTokenSource> class Parser\n    */\n   std::unique_ptr<AST::Stmt> parse_stmt (bool allow_no_semi = false);\n   std::unique_ptr<AST::Type> parse_type ();\n+  std::unique_ptr<AST::ExternalItem> parse_external_item ();\n+  std::unique_ptr<AST::TraitItem> parse_trait_item ();\n+  std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n   AST::PathInExpression parse_path_in_expression ();\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   AST::Visibility parse_visibility ();\n@@ -285,15 +288,13 @@ template <typename ManagedTokenSource> class Parser\n \t\t\t\t\t\t      AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::Trait> parse_trait (AST::Visibility vis,\n \t\t\t\t\t   AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::TraitItem> parse_trait_item ();\n   std::unique_ptr<AST::TraitItemType>\n   parse_trait_type (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TraitItemConst>\n   parse_trait_const (AST::AttrVec outer_attrs);\n   AST::SelfParam parse_self_param ();\n   std::unique_ptr<AST::Impl> parse_impl (AST::Visibility vis,\n \t\t\t\t\t AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n   std::unique_ptr<AST::InherentImplItem>\n   parse_inherent_impl_function_or_method (AST::Visibility vis,\n \t\t\t\t\t  AST::AttrVec outer_attrs);\n@@ -303,7 +304,6 @@ template <typename ManagedTokenSource> class Parser\n \t\t\t\t       AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExternBlock>\n   parse_extern_block (AST::Visibility vis, AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   AST::NamedFunctionParam parse_named_function_param (AST::AttrVec outer_attrs\n \t\t\t\t\t\t      = AST::AttrVec ());\n   AST::Method parse_method ();"}]}