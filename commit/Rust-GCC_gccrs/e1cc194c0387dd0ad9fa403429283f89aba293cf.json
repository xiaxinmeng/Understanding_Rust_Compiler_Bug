{"sha": "e1cc194c0387dd0ad9fa403429283f89aba293cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFjYzE5NGMwMzg3ZGQwYWQ5ZmE0MDM0MjkyODNmODlhYmEyOTNjZg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-07-09T19:41:37Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-07-09T19:41:37Z"}, "message": "trans-decl.c (set_tree_decl_type_code): Remove function.\n\n2007-07-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\t* trans-decl.c (set_tree_decl_type_code): Remove function.\n\t(generate_local_decl): Remove reference to set_tree_decl_type_code.\n\nFrom-SVN: r126493", "tree": {"sha": "8e91729786ea2797b67de1619df7e5af6efeaf90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e91729786ea2797b67de1619df7e5af6efeaf90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1cc194c0387dd0ad9fa403429283f89aba293cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1cc194c0387dd0ad9fa403429283f89aba293cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1cc194c0387dd0ad9fa403429283f89aba293cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1cc194c0387dd0ad9fa403429283f89aba293cf/comments", "author": null, "committer": null, "parents": [{"sha": "694dd537b964f0a5869c9519f3968a6eddea827a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694dd537b964f0a5869c9519f3968a6eddea827a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694dd537b964f0a5869c9519f3968a6eddea827a"}], "stats": {"total": 49, "additions": 5, "deletions": 44}, "files": [{"sha": "5f414f73dcdb4a849658e790ef7ef73904a6e02a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cc194c0387dd0ad9fa403429283f89aba293cf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cc194c0387dd0ad9fa403429283f89aba293cf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e1cc194c0387dd0ad9fa403429283f89aba293cf", "patch": "@@ -1,3 +1,8 @@\n+2007-07-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* trans-decl.c (set_tree_decl_type_code): Remove function.\n+\t(generate_local_decl): Remove reference to set_tree_decl_type_code.\n+\n 2007-07-09  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/31129"}, {"sha": "5a7ad254a2e0607d6a10eb2793d52b85ad23edbb", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cc194c0387dd0ad9fa403429283f89aba293cf/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cc194c0387dd0ad9fa403429283f89aba293cf/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e1cc194c0387dd0ad9fa403429283f89aba293cf", "patch": "@@ -2840,41 +2840,6 @@ gfc_generate_contained_functions (gfc_namespace * parent)\n }\n \n \n-/* Set up the tree type for the given symbol to allow the dummy\n-   variable (parameter) to be passed by-value.  To do this, the main\n-   idea is to simply remove the extra layer added by Fortran\n-   automatically (the POINTER_TYPE node).  This pointer type node\n-   would normally just contain the real type underneath, but we remove\n-   it here and later we change the way the argument is converted for a\n-   function call (trans-expr.c:gfc_conv_function_call).  This is the\n-   approach the C compiler takes (or it appears to be this way).  When\n-   the middle-end is given the typed node rather than the POINTER_TYPE\n-   node, it knows to pass the value.  */\n-\n-static void\n-set_tree_decl_type_code (gfc_symbol *sym)\n-{\n-   /* This should not happen.  during the gfc_sym_type function,\n-      when the backend_decl is being built for a dummy arg, if the arg\n-      is pass-by-value then no reference type is wrapped around the\n-      true type (e.g., REAL_TYPE).  */\n-  if (TREE_CODE (TREE_TYPE (sym->backend_decl)) == POINTER_TYPE ||\n-      TREE_CODE (TREE_TYPE (sym->backend_decl)) == REFERENCE_TYPE)\n-    TREE_TYPE (sym->backend_decl) = gfc_typenode_for_spec (&sym->ts);\n-  DECL_BY_REFERENCE (sym->backend_decl) = 0;\n-  \n-   /* the tree can't be addressable if it's pass-by-value..?  x*/\n-/*    TREE_TYPE(sym->backend_decl)->common.addressable_flag = 0; */\n-\n-   DECL_ARG_TYPE (sym->backend_decl) = TREE_TYPE (sym->backend_decl);\n-\n-   DECL_MODE (sym->backend_decl) =\n-      TYPE_MODE (TREE_TYPE (sym->backend_decl));\n-\n-   return;\n-}\n-\n-\n /* Drill down through expressions for the array specification bounds and\n    character length calling generate_local_decl for all those variables\n    that have not already been declared.  */\n@@ -3044,15 +3009,6 @@ generate_local_decl (gfc_symbol * sym)\n \t\t     &sym->declared_at);\n     }\n \n-  if (sym->attr.dummy == 1)\n-    {\n-      /* The sym->backend_decl can be NULL if this is one of the\n-\t intrinsic types, such as the symbol of type c_ptr for the\n-\t c_f_pointer function, so don't set up the tree code for it.  */\n-      if (sym->attr.value == 1 && sym->backend_decl != NULL)\n-\tset_tree_decl_type_code (sym);\n-    }\n-\n   /* Make sure we convert the types of the derived types from iso_c_binding\n      into (void *).  */\n   if (sym->attr.flavor != FL_PROCEDURE && sym->attr.is_iso_c"}]}