{"sha": "6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "node_id": "C_kwDOANBUbNoAKDZmZmJmODdjYTY2ZjRlZDljZDc5Y2ZmNjc1ZmFiZTIxMDllNDZlODU", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-09-17T10:04:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-10-08T00:25:51Z"}, "message": "c++: track whether we expect a TARGET_EXPR to be elided\n\nA discussion at Cauldron made me think that with the formalization of copy\nelision in C++17, we should be able to determine before optimization which\nTARGET_EXPRs will become temporaries and which are initializers.  This patch\nimplements that: we set TARGET_EXPR_ELIDING_P if it's used as an\ninitializer, and later check that we were right.\n\nThere's an exception in the cp_gimplify_expr check to allow extra\ntemporaries of non-addressable type: this is used by\ngimplify_init_ctor_preeval to materialize subobjects of a CONSTRUCTOR on the\nrhs of a MODIFY_EXPR rather than materializing the whole object.  If the\ntype isn't addressable, there's no way for a program to tell the difference,\nso this is a valid optimization.\n\nI considered changing replace_placeholders_for_class_temp_r to check\nTARGET_EXPR_ELIDING_P instead of potential_prvalue_result_of, but decided\nthat would be wrong: if we have an eliding TARGET_EXPR inside a non-eliding\none, we would miss replacing its placeholders.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (TARGET_EXPR_ELIDING_P): New.\n\t(unsafe_copy_elision_p, set_target_expr_eliding)\n\t(cp_build_init_expr): Declare.\n\t* call.cc (unsafe_copy_elision_p): No longer static.\n\t(build_over_call, build_special_member_call)\n\t(build_new_method_call): Use cp_build_init_expr.\n\t* coroutines.cc (expand_one_await_expression)\n\t(build_actor_fn, flatten_await_stmt, handle_nested_conditionals)\n\t(await_statement_walker, morph_fn_to_coro): Use cp_build_init_expr.\n\t* cp-gimplify.cc (cp_gimplify_init_expr)\n\t(cp_gimplify_expr): Check TARGET_EXPR_ELIDING_P.\n\t(cp_fold_r): Propagate it.\n\t(cp_fold): Use cp_build_init_expr.\n\t* decl.cc (check_initializer): Use cp_build_init_expr.\n\t* except.cc (build_throw): Use cp_build_init_expr.\n\t* init.cc (get_nsdmi): Call set_target_expr_eliding.\n\t(perform_member_init, expand_default_init, expand_aggr_init_1)\n\t(build_new_1, build_vec_init): Use cp_build_init_expr.\n\t* method.cc (do_build_copy_constructor): Use cp_build_init_expr.\n\t* semantics.cc (simplify_aggr_init_expr, finalize_nrv_r)\n\t(finish_omp_reduction_clause): Use cp_build_init_expr.\n\t* tree.cc (build_target_expr): Call set_target_expr_eliding.\n\t(bot_manip): Copy TARGET_EXPR_ELIDING_P.\n\t* typeck.cc (cp_build_modify_expr): Call set_target_expr_eliding.\n\t(check_return_expr): Use cp_build_modify_expr.\n\t* typeck2.cc (split_nonconstant_init_1)\n\t(split_nonconstant_init): Use cp_build_init_expr.\n\t(massage_init_elt): Call set_target_expr_eliding.\n\t(process_init_constructor_record): Clear TARGET_EXPR_ELIDING_P on\n\tunsafe copy elision.\n\t(set_target_expr_eliding, cp_build_init_expr): New.", "tree": {"sha": "dc67518a45f51746a76021cdca31b0d4c10677ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc67518a45f51746a76021cdca31b0d4c10677ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ff6c33e2ec0d75958d3f19089519034e8f96a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff6c33e2ec0d75958d3f19089519034e8f96a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff6c33e2ec0d75958d3f19089519034e8f96a30"}], "stats": {"total": 200, "additions": 138, "deletions": 62}, "files": [{"sha": "70ec964a21914b2252b8bd865d7565a80aaa5c95", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -9144,7 +9144,7 @@ init_by_return_slot_p (tree exp)\n    Places that use this function (or _opt) to decide to elide a copy should\n    probably use make_safe_copy_elision instead.  */\n \n-static bool\n+bool\n unsafe_copy_elision_p (tree target, tree exp)\n {\n   return unsafe_return_slot_p (target) && init_by_return_slot_p (exp);\n@@ -9941,7 +9941,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t       && !unsafe)\n \t{\n \t  tree to = cp_build_fold_indirect_ref (fa);\n-\t  val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n+\t  val = cp_build_init_expr (to, arg);\n \t  return val;\n \t}\n     }\n@@ -10100,7 +10100,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    }\n \t  call = cxx_constant_value (call, obj_arg, complain);\n \t  if (obj_arg && !error_operand_p (call))\n-\t    call = build2 (INIT_EXPR, void_type_node, obj_arg, call);\n+\t    call = cp_build_init_expr (obj_arg, call);\n \t  call = convert_from_reference (call);\n \t}\n     }\n@@ -10765,7 +10765,7 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n \t    check_self_delegation (arg);\n \t  /* Avoid change of behavior on Wunused-var-2.C.  */\n \t  instance = mark_lvalue_use (instance);\n-\t  return build2 (INIT_EXPR, class_type, instance, arg);\n+\t  return cp_build_init_expr (instance, arg);\n \t}\n     }\n \n@@ -11183,9 +11183,7 @@ build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n \t{\n \t  if (is_dummy_object (instance))\n \t    return get_target_expr (init, complain);\n-\t  init = build2 (INIT_EXPR, TREE_TYPE (instance), instance, init);\n-\t  TREE_SIDE_EFFECTS (init) = true;\n-\t  return init;\n+\t  return cp_build_init_expr (instance, init);\n \t}\n \n       /* Otherwise go ahead with overload resolution.  */\n@@ -11232,9 +11230,7 @@ build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n \t      ctor = digest_init (basetype, ctor, complain);\n \t      if (ctor == error_mark_node)\n \t\treturn error_mark_node;\n-\t      ctor = build2 (INIT_EXPR, TREE_TYPE (instance), instance, ctor);\n-\t      TREE_SIDE_EFFECTS (ctor) = true;\n-\t      return ctor;\n+\t      return cp_build_init_expr (instance, ctor);\n \t    }\n \t}\n       if (complain & tf_error)"}, {"sha": "01a3e831ee5fb8b2e64f6d8a5c7701b25b11b1d3", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -1732,7 +1732,7 @@ expand_one_await_expression (tree *stmt, tree *await_expr, void *d)\n       if (!same_type_ignoring_top_level_qualifiers_p (susp_type,\n \t\t\t\t\t\t      void_coro_handle_type))\n \tr = build1_loc (loc, VIEW_CONVERT_EXPR, void_coro_handle_type, r);\n-      r = build2_loc (loc, INIT_EXPR, void_coro_handle_type, data->conthand, r);\n+      r = cp_build_init_expr (loc, data->conthand, r);\n       r = build1 (CONVERT_EXPR, void_type_node, r);\n       append_to_statement_list (r, &body_list);\n       is_cont = true;\n@@ -1755,7 +1755,7 @@ expand_one_await_expression (tree *stmt, tree *await_expr, void *d)\n   r = build_call_expr_internal_loc (loc, IFN_CO_YIELD, integer_type_node, 5,\n \t\t\t\t    susp_idx, final_susp, r_l, d_l,\n \t\t\t\t    data->coro_fp);\n-  r = build2 (INIT_EXPR, integer_type_node, cond, r);\n+  r = cp_build_init_expr (cond, r);\n   finish_switch_cond (r, sw);\n   r = build_case_label (build_int_cst (integer_type_node, 0), NULL_TREE,\n \t\t\tcreate_anon_label_with_ctx (loc, actor));\n@@ -2304,7 +2304,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   vec<tree, va_gc> *args = make_tree_vector_single (r);\n   tree hfa = build_new_method_call (ash, hfa_m, &args, NULL_TREE, LOOKUP_NORMAL,\n \t\t\t\t    NULL, tf_warning_or_error);\n-  r = build2 (INIT_EXPR, handle_type, ash, hfa);\n+  r = cp_build_init_expr (ash, hfa);\n   r = coro_build_cvt_void_expr_stmt (r, loc);\n   add_stmt (r);\n   release_tree_vector (args);\n@@ -2776,17 +2776,19 @@ flatten_await_stmt (var_nest_node *n, hash_set<tree> *promoted,\n \t  if (!VOID_TYPE_P (TREE_TYPE (then_cl)))\n \t    {\n \t      gcc_checking_assert (TREE_CODE (then_cl) != STATEMENT_LIST);\n-\t      then_cl\n-\t\t= build2 (init_expr ? INIT_EXPR : MODIFY_EXPR, var_type,\n-\t\t\t  var, then_cl);\n+\t      if (init_expr)\n+\t\tthen_cl = cp_build_init_expr (var, then_cl);\n+\t      else\n+\t\tthen_cl = build2 (MODIFY_EXPR, var_type, var, then_cl);\n \t    }\n \t  tree else_cl = COND_EXPR_ELSE (old_expr);\n \t  if (!VOID_TYPE_P (TREE_TYPE (else_cl)))\n \t    {\n \t      gcc_checking_assert (TREE_CODE (else_cl) != STATEMENT_LIST);\n-\t      else_cl\n-\t\t= build2 (init_expr ? INIT_EXPR : MODIFY_EXPR, var_type,\n-\t\t\t  var, else_cl);\n+\t      if (init_expr)\n+\t\telse_cl = cp_build_init_expr (var, else_cl);\n+\t      else\n+\t\telse_cl = build2 (MODIFY_EXPR, var_type, var, else_cl);\n \t    }\n \t  n->init = build3 (COND_EXPR, var_type, cond, then_cl, else_cl);\n \t}\n@@ -2804,7 +2806,7 @@ flatten_await_stmt (var_nest_node *n, hash_set<tree> *promoted,\n \t      DECL_ARTIFICIAL (cond_var) = true;\n \t      layout_decl (cond_var, 0);\n \t      gcc_checking_assert (!TYPE_NEEDS_CONSTRUCTING (cond_type));\n-\t      cond = build2 (INIT_EXPR, cond_type, cond_var, cond);\n+\t      cond = cp_build_init_expr (cond_var, cond);\n \t      var_nest_node *ins\n \t\t= new var_nest_node (cond_var, cond, n->prev, n);\n \t      COND_EXPR_COND (n->init) = cond_var;\n@@ -2957,8 +2959,7 @@ handle_nested_conditionals (var_nest_node *n, vec<tree>& list,\n \t\t expression that performs the init and then records that the\n \t\t variable is live (and the DTOR should be run at the scope\n \t\t exit.  */\n-\t      tree set_flag = build2 (INIT_EXPR, boolean_type_node,\n-\t\t\t\t      flag, boolean_true_node);\n+\t      tree set_flag = cp_build_init_expr (flag, boolean_true_node);\n \t      n->init\n \t\t= build2 (COMPOUND_EXPR, boolean_type_node, n->init, set_flag);\n \t}\n@@ -3471,8 +3472,7 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    /* We want to initialize the new variable with the expression\n \t       that contains the await(s) and potentially also needs to\n \t       have truth_if expressions expanded.  */\n-\t    tree new_s = build2_loc (sloc, INIT_EXPR, boolean_type_node,\n-\t\t\t\t     newvar, cond_inner);\n+\t    tree new_s = cp_build_init_expr (sloc, newvar, cond_inner);\n \t    finish_expr_stmt (new_s);\n \t    IF_COND (if_stmt) = newvar;\n \t    add_stmt (if_stmt);\n@@ -3656,7 +3656,7 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    if (TREE_CODE (cond_inner) == CLEANUP_POINT_EXPR)\n \t      cond_inner = TREE_OPERAND (cond_inner, 0);\n \t    location_t sloc = EXPR_LOCATION (SWITCH_STMT_COND (sw_stmt));\n-\t    tree new_s = build2_loc (sloc, INIT_EXPR, sw_type, newvar,\n+\t    tree new_s = cp_build_init_expr (sloc, newvar,\n \t\t\t\t     cond_inner);\n \t    finish_expr_stmt (new_s);\n \t    SWITCH_STMT_COND (sw_stmt) = newvar;\n@@ -4735,7 +4735,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n \n   tree allocated = build1 (CONVERT_EXPR, coro_frame_ptr, new_fn);\n-  tree r = build2 (INIT_EXPR, TREE_TYPE (coro_fp), coro_fp, allocated);\n+  tree r = cp_build_init_expr (coro_fp, allocated);\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n@@ -4796,7 +4796,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t      1, 0,tf_warning_or_error);\n   tree fnf_x = build_class_member_access_expr (deref_fp, fnf_m, NULL_TREE,\n \t\t\t\t\t       false, tf_warning_or_error);\n-  r = build2 (INIT_EXPR, boolean_type_node, fnf_x, boolean_true_node);\n+  r = cp_build_init_expr (fnf_x, boolean_true_node);\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n@@ -4808,7 +4808,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree resume_x = build_class_member_access_expr (deref_fp, resume_m, NULL_TREE,\n \t\t\t\t\t\t  false, tf_warning_or_error);\n-  r = build2_loc (fn_start, INIT_EXPR, act_des_fn_ptr, resume_x, actor_addr);\n+  r = cp_build_init_expr (fn_start, resume_x, actor_addr);\n   finish_expr_stmt (r);\n \n   tree destroy_addr = build1 (ADDR_EXPR, act_des_fn_ptr, destroy);\n@@ -4818,7 +4818,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree destroy_x\n     = build_class_member_access_expr (deref_fp, destroy_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n-  r = build2_loc (fn_start, INIT_EXPR, act_des_fn_ptr, destroy_x, destroy_addr);\n+  r = cp_build_init_expr (fn_start, destroy_x, destroy_addr);\n   finish_expr_stmt (r);\n \n   /* [dcl.fct.def.coroutine] /13\n@@ -5011,8 +5011,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  release_tree_vector (arg);\n \t}\n       else\n-\tr = build2_loc (fn_start, INIT_EXPR, gro_type,\n-\t\t\tDECL_RESULT (orig), get_ro);\n+\tr = cp_build_init_expr (fn_start, DECL_RESULT (orig), get_ro);\n \n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (gro_type))\n \t/* If some part of the initalization code (prior to the await_resume\n@@ -5067,7 +5066,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     = build_class_member_access_expr (deref_fp, resume_idx_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n   r = build_int_cst (short_unsigned_type_node, 0);\n-  r = build2_loc (fn_start, INIT_EXPR, short_unsigned_type_node, resume_idx, r);\n+  r = cp_build_init_expr (fn_start, resume_idx, r);\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n "}, {"sha": "d0e12c9ee173a19bee156b5d8a07551a4fe6fa2f", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -250,6 +250,7 @@ cp_gimplify_init_expr (tree *expr_p)\n   if (TREE_CODE (from) == TARGET_EXPR)\n     if (tree init = TARGET_EXPR_INITIAL (from))\n       {\n+\tgcc_checking_assert (TARGET_EXPR_ELIDING_P (from));\n \tif (target_expr_needs_replace (from))\n \t  {\n \t    /* If this was changed by cp_genericize_target_expr, we need to\n@@ -745,6 +746,11 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       /* A TARGET_EXPR that expresses direct-initialization should have been\n \t elided by cp_gimplify_init_expr.  */\n       gcc_checking_assert (!TARGET_EXPR_DIRECT_INIT_P (*expr_p));\n+      /* Likewise, but allow extra temps of trivial type so that\n+\t gimplify_init_ctor_preeval can materialize subobjects of a CONSTRUCTOR\n+\t on the rhs of an assignment, as in constexpr-aggr1.C.  */\n+      gcc_checking_assert (!TARGET_EXPR_ELIDING_P (*expr_p)\n+\t\t\t   || !TREE_ADDRESSABLE (TREE_TYPE (*expr_p)));\n       ret = GS_UNHANDLED;\n       break;\n \n@@ -1110,7 +1116,10 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n \t  cp_walk_tree (&init, cp_fold_r, data, NULL);\n \t  *walk_subtrees = 0;\n \t  if (TREE_CODE (init) == TARGET_EXPR)\n-\t    *stmt_p = init;\n+\t    {\n+\t      TARGET_EXPR_ELIDING_P (init) = TARGET_EXPR_ELIDING_P (stmt);\n+\t      *stmt_p = init;\n+\t    }\n \t}\n       break;\n \n@@ -2902,7 +2911,7 @@ cp_fold (tree x)\n \t\tloc = EXPR_LOCATION (x);\n \t\ttree s = build_fold_indirect_ref_loc (loc,\n \t\t\t\t\t\t      CALL_EXPR_ARG (x, 0));\n-\t\tr = build2_loc (loc, INIT_EXPR, TREE_TYPE (s), s, r);\n+\t\tr = cp_build_init_expr (s, r);\n \t      }\n \t    x = r;\n \t    break;"}, {"sha": "ab6f85a2490aa7a4999a0c814a822033b762a5c8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -505,6 +505,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECL_MODULE_EXPORT_P (in _DECL)\n       PACK_EXPANSION_FORCE_EXTRA_ARGS_P (in *_PACK_EXPANSION)\n       LAMBDA_EXPR_STATIC_P (in LAMBDA_EXPR)\n+      TARGET_EXPR_ELIDING_P (in TARGET_EXPR)\n    4: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n@@ -5370,6 +5371,11 @@ get_vec_init_expr (tree t)\n #define TARGET_EXPR_DIRECT_INIT_P(NODE) \\\n   TREE_LANG_FLAG_2 (TARGET_EXPR_CHECK (NODE))\n \n+/* True if we expect this TARGET_EXPR to be used as an initializer, not to\n+   materialize as a temporary.  */\n+#define TARGET_EXPR_ELIDING_P(NODE) \\\n+  TREE_LANG_FLAG_3 (TARGET_EXPR_CHECK (NODE))\n+\n /* True if NODE is a TARGET_EXPR that just expresses a copy of its INITIAL; if\n    the initializer has void type, it's doing something more complicated.  */\n #define SIMPLE_TARGET_EXPR_P(NODE)\t\t\t\t\\\n@@ -6657,6 +6663,7 @@ extern bool is_list_ctor\t\t\t(tree);\n extern void validate_conversion_obstack\t\t(void);\n extern void mark_versions_used\t\t\t(tree);\n extern int unsafe_return_slot_p\t\t\t(tree);\n+extern bool unsafe_copy_elision_p\t\t(tree, tree);\n extern bool make_safe_copy_elision\t\t(tree, tree);\n extern bool cp_handle_deprecated_or_unavailable (tree, tsubst_flags_t = tf_warning_or_error);\n extern void cp_warn_deprecated_use_scopes\t(tree);\n@@ -8182,6 +8189,10 @@ extern tree build_functional_cast\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree add_exception_specifier\t\t(tree, tree, tsubst_flags_t);\n extern tree merge_exception_specifiers\t\t(tree, tree);\n+extern void set_target_expr_eliding\t\t(tree);\n+extern tree cp_build_init_expr\t\t\t(location_t, tree, tree);\n+inline tree cp_build_init_expr (tree t, tree i)\n+{ return cp_build_init_expr (input_location, t, i); }\n \n /* in mangle.cc */\n extern void init_mangle\t\t\t\t(void);"}, {"sha": "82eb0c2f22a91aed062eb7e730e25f5fc7d02071", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -7500,7 +7500,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n     }\n \n   if (init && init != error_mark_node)\n-    init_code = build2 (INIT_EXPR, type, decl, init);\n+    init_code = cp_build_init_expr (decl, init);\n \n   if (init_code && !TREE_SIDE_EFFECTS (init_code)\n       && init_code != error_mark_node)"}, {"sha": "b8a85ed05726a70f8b3cae3daf67642b2ae78f34", "filename": "gcc/cp/except.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -755,7 +755,7 @@ build_throw (location_t loc, tree exp)\n \t  tree tmp = decay_conversion (exp, tf_warning_or_error);\n \t  if (tmp == error_mark_node)\n \t    return error_mark_node;\n-\t  exp = build2 (INIT_EXPR, temp_type, object, tmp);\n+\t  exp = cp_build_init_expr (object, tmp);\n \t}\n \n       /* Mark any cleanups from the initialization as MUST_NOT_THROW, since"}, {"sha": "3d5d39049443b8e2f1913c3dde6ad1f108e997cb", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -686,6 +686,8 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n     /* Now put it back so C++17 copy elision works.  */\n     init = get_target_expr (init);\n \n+  set_target_expr_eliding (init);\n+\n   current_class_ptr = save_ccp;\n   current_class_ref = save_ccr;\n   return init;\n@@ -1006,15 +1008,15 @@ perform_member_init (tree member, tree init, hash_set<tree> &uninitialized)\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n \t  init = build_vec_init_expr (type, init, tf_warning_or_error);\n-\t  init = build2 (INIT_EXPR, type, decl, init);\n+\t  init = cp_build_init_expr (decl, init);\n \t  finish_expr_stmt (init);\n \t}\n       else\n \t{\n \t  tree value = build_value_init (type, tf_warning_or_error);\n \t  if (value == error_mark_node)\n \t    return;\n-\t  init = build2 (INIT_EXPR, type, decl, value);\n+\t  init = cp_build_init_expr (decl, value);\n \t  finish_expr_stmt (init);\n \t}\n     }\n@@ -1025,7 +1027,7 @@ perform_member_init (tree member, tree init, hash_set<tree> &uninitialized)\n     {\n       if (init)\n \t{\n-\t  init = build2 (INIT_EXPR, type, decl, TREE_VALUE (init));\n+\t  init = cp_build_init_expr (decl, TREE_VALUE (init));\n \t  finish_expr_stmt (init);\n \t}\n     }\n@@ -1062,7 +1064,7 @@ perform_member_init (tree member, tree init, hash_set<tree> &uninitialized)\n       if (TREE_CODE (type) == ARRAY_TYPE\n \t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (type)))\n \tinit = build_vec_init_expr (type, init, tf_warning_or_error);\n-      init = build2 (INIT_EXPR, type, decl, init);\n+      init = cp_build_init_expr (decl, init);\n       finish_expr_stmt (init);\n       FOR_EACH_VEC_ELT (*cleanups, i, t)\n \tpush_cleanup (NULL_TREE, t, false);\n@@ -1081,7 +1083,7 @@ perform_member_init (tree member, tree init, hash_set<tree> &uninitialized)\n \t\t  /* Initialize the array only if it's not a flexible\n \t\t     array member (i.e., if it has an upper bound).  */\n \t\t  init = build_vec_init_expr (type, init, tf_warning_or_error);\n-\t\t  init = build2 (INIT_EXPR, type, decl, init);\n+\t\t  init = cp_build_init_expr (decl, init);\n \t\t  finish_expr_stmt (init);\n \t\t}\n \t    }\n@@ -2097,7 +2099,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t complete objects.  */\n       gcc_assert (TREE_CODE (init) == CONSTRUCTOR || true_exp == exp);\n \n-      init = build2 (INIT_EXPR, TREE_TYPE (exp), exp, init);\n+      init = cp_build_init_expr (exp, init);\n       TREE_SIDE_EFFECTS (init) = 1;\n       finish_expr_stmt (init);\n       return true;\n@@ -2136,8 +2138,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t  TREE_TYPE (*p) = void_type_node;\n \t  p = &TREE_OPERAND (*p, 0);\n \t}\n-      *p = build2 (INIT_EXPR, TREE_TYPE (exp), exp, *p);\n-      TREE_SIDE_EFFECTS (*p) = 1;\n+      *p = cp_build_init_expr (exp, *p);\n       finish_expr_stmt (init);\n       return true;\n     }\n@@ -2202,7 +2203,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t{\n \t  tree e = maybe_constant_init (rval, exp);\n \t  if (TREE_CONSTANT (e))\n-\t    rval = build2 (INIT_EXPR, type, exp, e);\n+\t    rval = cp_build_init_expr (exp, e);\n \t}\n     }\n \n@@ -2290,7 +2291,7 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t    field_size = TYPE_SIZE (CLASSTYPE_AS_BASE (type));\n \t  init = build_zero_init_1 (type, NULL_TREE, /*static_storage_p=*/false,\n \t\t\t\t    field_size);\n-\t  init = build2 (INIT_EXPR, type, exp, init);\n+\t  init = cp_build_init_expr (exp, init);\n \t  finish_expr_stmt (init);\n \t}\n \n@@ -3678,7 +3679,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t      tree val = build_value_init (type, complain | tf_no_cleanup);\n \t      if (val == error_mark_node)\n \t\treturn error_mark_node;\n-\t      init_expr = build2 (INIT_EXPR, type, init_expr, val);\n+\t      init_expr = cp_build_init_expr (init_expr, val);\n \t    }\n \t  else\n \t    {\n@@ -4430,7 +4431,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n       if (BRACE_ENCLOSED_INITIALIZER_P (init))\n \tinit = digest_init (atype, init, complain);\n-      stmt_expr = build2 (INIT_EXPR, atype, base, init);\n+      stmt_expr = cp_build_init_expr (base, init);\n       return stmt_expr;\n     }\n \n@@ -4602,7 +4603,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  gcc_checking_assert (!target_expr_needs_replace (elt));\n \n \t  if (digested)\n-\t    one_init = build2 (INIT_EXPR, type, baseref, elt);\n+\t    one_init = cp_build_init_expr (baseref, elt);\n \t  else if (tree vi = get_vec_init_expr (elt))\n \t    one_init = expand_vec_init_expr (baseref, vi, complain, flags);\n \t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n@@ -4623,7 +4624,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t\t  if (do_static_init)\n \t\t    one_init = NULL_TREE;\n \t\t  else\n-\t\t    one_init = build2 (INIT_EXPR, type, baseref, e);\n+\t\t    one_init = cp_build_init_expr (baseref, e);\n \t\t}\n \t      else\n \t\t{\n@@ -4805,7 +4806,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t{\n \t  elt_init = build_value_init (type, complain);\n \t  if (elt_init != error_mark_node)\n-\t    elt_init = build2 (INIT_EXPR, type, to, elt_init);\n+\t    elt_init = cp_build_init_expr (to, elt_init);\n \t}\n       else\n \t{"}, {"sha": "c217d7e5aad063e70e182523716c57330e626e8e", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -680,7 +680,7 @@ do_build_copy_constructor (tree fndecl)\n       else if (tree_int_cst_equal (TYPE_SIZE (current_class_type),\n \t\t\t\t   CLASSTYPE_SIZE (current_class_type)))\n \t{\n-\t  tree t = build2 (INIT_EXPR, void_type_node, current_class_ref, parm);\n+\t  tree t = cp_build_init_expr (current_class_ref, parm);\n \t  finish_expr_stmt (t);\n \t}\n       else\n@@ -695,7 +695,7 @@ do_build_copy_constructor (tree fndecl)\n \t\t\t     current_class_ptr, alias_set);\n \t  tree rhs = build2 (MEM_REF, array_type,\n \t\t\t     TREE_OPERAND (parm, 0), alias_set);\n-\t  tree t = build2 (INIT_EXPR, void_type_node, lhs, rhs);\n+\t  tree t = cp_build_init_expr (lhs, rhs);\n \t  finish_expr_stmt (t);\n \t}\n     }"}, {"sha": "7d46c3c2db94cb1e0028be75e7d3dd976004483c", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -2519,6 +2519,10 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t  /* Update for array-to-pointer decay.  */\n \t  type = TREE_TYPE (expr);\n \n+\t  /* This TARGET_EXPR will initialize the outer one added by\n+\t     finish_stmt_expr.  */\n+\t  set_target_expr_eliding (expr);\n+\n \t  /* Wrap it in a CLEANUP_POINT_EXPR and add it to the list like a\n \t     normal statement, but don't convert to void or actually add\n \t     the EXPR_STMT.  */\n@@ -4668,7 +4672,7 @@ simplify_aggr_init_expr (tree *tp)\n \t expand_call{,_inline}.  */\n       cxx_mark_addressable (slot);\n       CALL_EXPR_RETURN_SLOT_OPT (call_expr) = true;\n-      call_expr = build2 (INIT_EXPR, TREE_TYPE (call_expr), slot, call_expr);\n+      call_expr = cp_build_init_expr (slot, call_expr);\n     }\n   else if (style == pcc)\n     {\n@@ -4687,7 +4691,7 @@ simplify_aggr_init_expr (tree *tp)\n     {\n       tree init = build_zero_init (type, NULL_TREE,\n \t\t\t\t   /*static_storage_p=*/false);\n-      init = build2 (INIT_EXPR, void_type_node, slot, init);\n+      init = cp_build_init_expr (slot, init);\n       call_expr = build2 (COMPOUND_EXPR, TREE_TYPE (call_expr),\n \t\t\t  init, call_expr);\n     }\n@@ -4882,7 +4886,7 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n       tree init;\n       if (DECL_INITIAL (dp->var)\n \t  && DECL_INITIAL (dp->var) != error_mark_node)\n-\tinit = build2 (INIT_EXPR, void_type_node, dp->result,\n+\tinit = cp_build_init_expr (dp->result,\n \t\t       DECL_INITIAL (dp->var));\n       else\n \tinit = build_empty_stmt (EXPR_LOCATION (*tp));\n@@ -6426,7 +6430,7 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t\t  else\n \t\t    init = fold_convert (TREE_TYPE (v), integer_zero_node);\n \t\t  OMP_CLAUSE_REDUCTION_INIT (c)\n-\t\t    = build2 (INIT_EXPR, TREE_TYPE (v), v, init);\n+\t\t    = cp_build_init_expr (v, init);\n \t\t}\n \t    }\n \t}"}, {"sha": "3532e44279fa3f38dda16367bdf990a0e35eac35", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -533,6 +533,9 @@ build_target_expr (tree decl, tree value, tsubst_flags_t complain)\n       if (t == error_mark_node)\n \treturn error_mark_node;\n     }\n+\n+  set_target_expr_eliding (value);\n+\n   t = build4 (TARGET_EXPR, type, decl, value, t, NULL_TREE);\n   if (location_t eloc = cp_expr_location (value))\n     SET_EXPR_LOCATION (t, eloc);\n@@ -3194,6 +3197,7 @@ bot_manip (tree* tp, int* walk_subtrees, void* data_)\n       TARGET_EXPR_IMPLICIT_P (u) = TARGET_EXPR_IMPLICIT_P (t);\n       TARGET_EXPR_LIST_INIT_P (u) = TARGET_EXPR_LIST_INIT_P (t);\n       TARGET_EXPR_DIRECT_INIT_P (u) = TARGET_EXPR_DIRECT_INIT_P (t);\n+      TARGET_EXPR_ELIDING_P (u) = TARGET_EXPR_ELIDING_P (t);\n \n       /* Map the old variable to the new one.  */\n       splay_tree_insert (target_remap,"}, {"sha": "b4a8e3c205c26155c0d54064921d4309ab6d060d", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -9294,7 +9294,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t  if (! same_type_p (TREE_TYPE (rhs), lhstype))\n \t    /* Call convert to generate an error; see PR 11063.  */\n \t    rhs = convert (lhstype, rhs);\n-\t  result = build2 (INIT_EXPR, lhstype, lhs, rhs);\n+\t  result = cp_build_init_expr (lhs, rhs);\n \t  TREE_SIDE_EFFECTS (result) = 1;\n \t  goto ret;\n \t}\n@@ -9542,6 +9542,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \n   result = build2_loc (loc, modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR,\n \t\t       lhstype, lhs, newrhs);\n+  if (modifycode == INIT_EXPR)\n+    set_target_expr_eliding (newrhs);\n \n   TREE_SIDE_EFFECTS (result) = 1;\n   if (!plain_assign)\n@@ -11105,7 +11107,7 @@ check_return_expr (tree retval, bool *no_warning)\n \n   /* Actually copy the value returned into the appropriate location.  */\n   if (retval && retval != result)\n-    retval = build2 (INIT_EXPR, TREE_TYPE (result), result, retval);\n+    retval = cp_build_init_expr (result, retval);\n \n   if (tree set = maybe_set_retval_sentinel ())\n     retval = build2 (COMPOUND_EXPR, void_type_node, retval, set);"}, {"sha": "26444720cb817b4b7a5d7d28767b457835123602", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ffbf87ca66f4ed9cd79cff675fabe2109e46e85/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=6ffbf87ca66f4ed9cd79cff675fabe2109e46e85", "patch": "@@ -649,7 +649,7 @@ split_nonconstant_init_1 (tree dest, tree init, bool last,\n \t\t  else\n \t\t    {\n \t\t    build_init:\n-\t\t      code = build2 (INIT_EXPR, inner_type, sub, value);\n+\t\t      code = cp_build_init_expr (sub, value);\n \t\t    }\n \t\t  code = build_stmt (input_location, EXPR_STMT, code);\n \t\t  add_stmt (code);\n@@ -764,7 +764,7 @@ split_nonconstant_init (tree dest, tree init)\n \t}\n       else if (init)\n \t{\n-\t  tree ie = build2 (INIT_EXPR, void_type_node, dest, init);\n+\t  tree ie = cp_build_init_expr (dest, init);\n \t  code = add_stmt_to_compound (ie, code);\n \t}\n     }\n@@ -773,7 +773,7 @@ split_nonconstant_init (tree dest, tree init)\n     code = build_vec_init (dest, NULL_TREE, init, /*value-init*/false,\n \t\t\t   /*from array*/1, tf_warning_or_error);\n   else\n-    code = build2 (INIT_EXPR, TREE_TYPE (dest), dest, init);\n+    code = cp_build_init_expr (dest, init);\n \n   return code;\n }\n@@ -1464,6 +1464,7 @@ digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)\n       && CP_AGGREGATE_TYPE_P (type))\n     init = reshape_init (type, init, complain);\n   init = digest_init_flags (type, init, flags, complain);\n+  set_target_expr_eliding (init);\n \n   /* We may have temporary materialization in a NSDMI, if the initializer\n      has something like A{} in it.  Digesting the {} could have introduced\n@@ -1542,6 +1543,7 @@ massage_init_elt (tree type, tree init, int nested, int flags,\n       tree t = fold_non_dependent_init (init, complain);\n       if (TREE_CONSTANT (t))\n \tinit = t;\n+      set_target_expr_eliding (init);\n     }\n   return init;\n }\n@@ -1771,6 +1773,13 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,\n \t    {\n \t      gcc_assert (ce->value);\n \t      next = massage_init_elt (fldtype, next, nested, flags, complain);\n+\t      /* We can't actually elide the temporary when initializing a\n+\t\t potentially-overlapping field from a function that returns by\n+\t\t value.  */\n+\t      if (ce->index\n+\t\t  && TREE_CODE (next) == TARGET_EXPR\n+\t\t  && unsafe_copy_elision_p (ce->index, next))\n+\t\tTARGET_EXPR_ELIDING_P (next) = false;\n \t      ++idx;\n \t    }\n \t}\n@@ -1804,6 +1813,9 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,\n \t     a class, just build one up; if it's an array, recurse.  */\n \t  next = build_constructor (init_list_type_node, NULL);\n \t  next = massage_init_elt (fldtype, next, nested, flags, complain);\n+\t  if (TREE_CODE (next) == TARGET_EXPR\n+\t      && unsafe_copy_elision_p (field, next))\n+\t    TARGET_EXPR_ELIDING_P (next) = false;\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  if ((complain & tf_warning)\n@@ -2727,3 +2739,41 @@ require_complete_eh_spec_types (tree fntype, tree decl)\n \t}\n     }\n }\n+\n+/* Record that any TARGET_EXPR in T are going to be elided in\n+   cp_gimplify_init_expr (or sooner).  */\n+\n+void\n+set_target_expr_eliding (tree t)\n+{\n+  if (!t)\n+    return;\n+  switch (TREE_CODE (t))\n+    {\n+    case TARGET_EXPR:\n+      TARGET_EXPR_ELIDING_P (t) = true;\n+      break;\n+    case COMPOUND_EXPR:\n+      set_target_expr_eliding (TREE_OPERAND (t, 1));\n+      break;\n+    case COND_EXPR:\n+      set_target_expr_eliding (TREE_OPERAND (t, 1));\n+      set_target_expr_eliding (TREE_OPERAND (t, 2));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Call the above in the process of building an INIT_EXPR.  */\n+\n+tree\n+cp_build_init_expr (location_t loc, tree target, tree init)\n+{\n+  set_target_expr_eliding (init);\n+  tree ie = build2_loc (loc, INIT_EXPR, TREE_TYPE (target),\n+\t\t\ttarget, init);\n+  TREE_SIDE_EFFECTS (ie) = true;\n+  return ie;\n+}"}]}