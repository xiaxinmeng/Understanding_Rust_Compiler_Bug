{"sha": "4577f7309a8b7c410e1ebe350250398997f0a8df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU3N2Y3MzA5YThiN2M0MTBlMWViZTM1MDI1MDM5ODk5N2YwYThkZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-05-19T07:44:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-05-19T07:44:31Z"}, "message": "re PR c++/48869 (OpenMP task construct fails to instantiate copy constructor(same as Bug 36523))\n\n\tPR c++/48869\n\t* method.c (get_dtor, get_copy_ctor): Add COMPLAIN argument,\n\tpass it down to locate_fn_flags.\n\t* cp-tree.h (get_dtor, get_copy_ctor): Adjust prototypes.\n\t* semantics.c (cxx_omp_create_clause_info): Adjust callers.\n\t* cp-gimplify.c: Include splay-tree.h.\n\t(splay_tree_compare_decl_uid, omp_var_to_track,\n\tomp_cxx_notice_variable): New functions.\n\t(struct cp_genericize_omp_taskreg): New type.\n\t(struct cp_genericize_data): Add omp_ctx field.\n\t(cp_genericize_r): Attempt to determine implicitly determined\n\tfirstprivate class type variables.\n\t(cp_genericize): Clear omp_ctx.\n\t* Make-lang.in (cp/cp-gimplify.o): Depend on $(SPLAY_TREE_H).\n\n\t* testsuite/libgomp.c++/pr48869.C: New test.\n\nFrom-SVN: r173888", "tree": {"sha": "6ab10bfd313ec6b9af503559d01810292772524a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ab10bfd313ec6b9af503559d01810292772524a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4577f7309a8b7c410e1ebe350250398997f0a8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4577f7309a8b7c410e1ebe350250398997f0a8df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4577f7309a8b7c410e1ebe350250398997f0a8df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4577f7309a8b7c410e1ebe350250398997f0a8df/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1e5eb3ef68e87807a6046d8746cf262d42c7394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e5eb3ef68e87807a6046d8746cf262d42c7394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e5eb3ef68e87807a6046d8746cf262d42c7394"}], "stats": {"total": 302, "additions": 290, "deletions": 12}, "files": [{"sha": "1ab211918dc9055988c58019fec078afd4b3127b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -1,3 +1,20 @@\n+2011-05-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/48869\n+\t* method.c (get_dtor, get_copy_ctor): Add COMPLAIN argument,\n+\tpass it down to locate_fn_flags.\n+\t* cp-tree.h (get_dtor, get_copy_ctor): Adjust prototypes.\n+\t* semantics.c (cxx_omp_create_clause_info): Adjust callers.\n+\t* cp-gimplify.c: Include splay-tree.h.\n+\t(splay_tree_compare_decl_uid, omp_var_to_track,\n+\tomp_cxx_notice_variable): New functions.\n+\t(struct cp_genericize_omp_taskreg): New type.\n+\t(struct cp_genericize_data): Add omp_ctx field.\n+\t(cp_genericize_r): Attempt to determine implicitly determined\n+\tfirstprivate class type variables.\n+\t(cp_genericize): Clear omp_ctx.\n+\t* Make-lang.in (cp/cp-gimplify.o): Depend on $(SPLAY_TREE_H).\n+\n 2011-05-18  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/48948"}, {"sha": "a93edc2de9cea18900e26e5991ea4c7d9f8d1c9e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -1,6 +1,6 @@\n # Top level -*- makefile -*- fragment for GNU C++.\n #   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-#   2005, 2007, 2008, 2009, 2010\n+#   2005, 2007, 2008, 2009, 2010, 2011\n #   Free Software Foundation, Inc.\n \n #This file is part of GCC.\n@@ -328,7 +328,7 @@ cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   gt-cp-parser.h output.h $(TARGET_H) $(PLUGIN_H) intl.h \\\n   c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR.H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n-\t$(TM_H) coretypes.h pointer-set.h tree-iterator.h\n+\t$(TM_H) coretypes.h pointer-set.h tree-iterator.h $(SPLAY_TREE_H)\n \n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(CXX_TREE_H) $(TIMEVAR_H) gt-cp-name-lookup.h \\"}, {"sha": "d26c0e0ca51fa2db445df1f2b177e9a040e2f872", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 189, "deletions": 1, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -1,6 +1,6 @@\n /* C++-specific tree lowering bits; see also c-gimplify.c and tree-gimple.c.\n \n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Jason Merrill <jason@redhat.com>\n \n@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"pointer-set.h\"\n #include \"flags.h\"\n+#include \"splay-tree.h\"\n \n /* Local declarations.  */\n \n@@ -731,10 +732,105 @@ cxx_int_tree_map_hash (const void *item)\n   return ((const struct cxx_int_tree_map *)item)->uid;\n }\n \n+/* A stable comparison routine for use with splay trees and DECLs.  */\n+\n+static int\n+splay_tree_compare_decl_uid (splay_tree_key xa, splay_tree_key xb)\n+{\n+  tree a = (tree) xa;\n+  tree b = (tree) xb;\n+\n+  return DECL_UID (a) - DECL_UID (b);\n+}\n+\n+/* OpenMP context during genericization.  */\n+\n+struct cp_genericize_omp_taskreg\n+{\n+  bool is_parallel;\n+  bool default_shared;\n+  struct cp_genericize_omp_taskreg *outer;\n+  splay_tree variables;\n+};\n+\n+/* Return true if genericization should try to determine if\n+   DECL is firstprivate or shared within task regions.  */\n+\n+static bool\n+omp_var_to_track (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (is_invisiref_parm (decl))\n+    type = TREE_TYPE (type);\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+  if (type == error_mark_node || !CLASS_TYPE_P (type))\n+    return false;\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+    return false;\n+  if (cxx_omp_predetermined_sharing (decl) != OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n+    return false;\n+  return true;\n+}\n+\n+/* Note DECL use in OpenMP region OMP_CTX during genericization.  */\n+\n+static void\n+omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)\n+{\n+  splay_tree_node n = splay_tree_lookup (omp_ctx->variables,\n+\t\t\t\t\t (splay_tree_key) decl);\n+  if (n == NULL)\n+    {\n+      int flags = OMP_CLAUSE_DEFAULT_SHARED;\n+      if (omp_ctx->outer)\n+\tomp_cxx_notice_variable (omp_ctx->outer, decl);\n+      if (!omp_ctx->default_shared)\n+\t{\n+\t  struct cp_genericize_omp_taskreg *octx;\n+\n+\t  for (octx = omp_ctx->outer; octx; octx = octx->outer)\n+\t    {\n+\t      n = splay_tree_lookup (octx->variables, (splay_tree_key) decl);\n+\t      if (n && n->value != OMP_CLAUSE_DEFAULT_SHARED)\n+\t\t{\n+\t\t  flags = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n+\t\t  break;\n+\t\t}\n+\t      if (octx->is_parallel)\n+\t\tbreak;\n+\t    }\n+\t  if (octx == NULL\n+\t      && (TREE_CODE (decl) == PARM_DECL\n+\t\t  || (!(TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n+\t\t      && DECL_CONTEXT (decl) == current_function_decl)))\n+\t    flags = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n+\t  if (flags == OMP_CLAUSE_DEFAULT_FIRSTPRIVATE)\n+\t    {\n+\t      /* DECL is implicitly determined firstprivate in\n+\t\t the current task construct.  Ensure copy ctor and\n+\t\t dtor are instantiated, because during gimplification\n+\t\t it will be already too late.  */\n+\t      tree type = TREE_TYPE (decl);\n+\t      if (is_invisiref_parm (decl))\n+\t\ttype = TREE_TYPE (type);\n+\t      while (TREE_CODE (type) == ARRAY_TYPE)\n+\t\ttype = TREE_TYPE (type);\n+\t      get_copy_ctor (type, tf_none);\n+\t      get_dtor (type, tf_none);\n+\t    }\n+\t}\n+      splay_tree_insert (omp_ctx->variables, (splay_tree_key) decl, flags);\n+    }\n+}\n+\n+/* Genericization context.  */\n+\n struct cp_genericize_data\n {\n   struct pointer_set_t *p_set;\n   VEC (tree, heap) *bind_expr_stack;\n+  struct cp_genericize_omp_taskreg *omp_ctx;\n };\n \n /* Perform any pre-gimplification lowering of C++ front end trees to\n@@ -747,6 +843,14 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n   struct cp_genericize_data *wtd = (struct cp_genericize_data *) data;\n   struct pointer_set_t *p_set = wtd->p_set;\n \n+  /* If in an OpenMP context, note var uses.  */\n+  if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n+      && (TREE_CODE (stmt) == VAR_DECL\n+\t  || TREE_CODE (stmt) == PARM_DECL\n+\t  || TREE_CODE (stmt) == RESULT_DECL)\n+      && omp_var_to_track (stmt))\n+    omp_cxx_notice_variable (wtd->omp_ctx, stmt);\n+\n   if (is_invisiref_parm (stmt)\n       /* Don't dereference parms in a thunk, pass the references through. */\n       && !(DECL_THUNK_P (current_function_decl)\n@@ -786,6 +890,10 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n   if (TREE_CODE (stmt) == ADDR_EXPR\n       && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n     {\n+      /* If in an OpenMP context, note var uses.  */\n+      if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n+\t  && omp_var_to_track (TREE_OPERAND (stmt, 0)))\n+\tomp_cxx_notice_variable (wtd->omp_ctx, TREE_OPERAND (stmt, 0));\n       *stmt_p = convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n       *walk_subtrees = 0;\n     }\n@@ -808,6 +916,22 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  }\n \tbreak;\n       case OMP_CLAUSE_PRIVATE:\n+\t/* Don't dereference an invisiref in OpenMP clauses.  */\n+\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n+\t  *walk_subtrees = 0;\n+\telse if (wtd->omp_ctx != NULL)\n+\t  {\n+\t    /* Private clause doesn't cause any references to the\n+\t       var in outer contexts, avoid calling\n+\t       omp_cxx_notice_variable for it.  */\n+\t    struct cp_genericize_omp_taskreg *old = wtd->omp_ctx;\n+\t    wtd->omp_ctx = NULL;\n+\t    cp_walk_tree (&OMP_CLAUSE_DECL (stmt), cp_genericize_r,\n+\t\t\t  data, NULL);\n+\t    wtd->omp_ctx = old;\n+\t    *walk_subtrees = 0;\n+\t  }\n+\tbreak;\n       case OMP_CLAUSE_SHARED:\n       case OMP_CLAUSE_FIRSTPRIVATE:\n       case OMP_CLAUSE_COPYIN:\n@@ -876,6 +1000,25 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   else if (TREE_CODE (stmt) == BIND_EXPR)\n     {\n+      if (__builtin_expect (wtd->omp_ctx != NULL, 0))\n+\t{\n+\t  tree decl;\n+\t  for (decl = BIND_EXPR_VARS (stmt); decl; decl = DECL_CHAIN (decl))\n+\t    if (TREE_CODE (decl) == VAR_DECL\n+\t\t&& !DECL_EXTERNAL (decl)\n+\t\t&& omp_var_to_track (decl))\n+\t      {\n+\t\tsplay_tree_node n\n+\t\t  = splay_tree_lookup (wtd->omp_ctx->variables,\n+\t\t\t\t       (splay_tree_key) decl);\n+\t\tif (n == NULL)\n+\t\t  splay_tree_insert (wtd->omp_ctx->variables,\n+\t\t\t\t     (splay_tree_key) decl,\n+\t\t\t\t     TREE_STATIC (decl)\n+\t\t\t\t     ? OMP_CLAUSE_DEFAULT_SHARED\n+\t\t\t\t     : OMP_CLAUSE_DEFAULT_PRIVATE);\n+\t      }\n+\t}\n       VEC_safe_push (tree, heap, wtd->bind_expr_stack, stmt);\n       cp_walk_tree (&BIND_EXPR_BODY (stmt),\n \t\t    cp_genericize_r, data, NULL);\n@@ -922,6 +1065,50 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n       *walk_subtrees = 0;\n     }\n+  else if (TREE_CODE (stmt) == OMP_PARALLEL || TREE_CODE (stmt) == OMP_TASK)\n+    {\n+      struct cp_genericize_omp_taskreg omp_ctx;\n+      tree c, decl;\n+      splay_tree_node n;\n+\n+      *walk_subtrees = 0;\n+      cp_walk_tree (&OMP_CLAUSES (stmt), cp_genericize_r, data, NULL);\n+      omp_ctx.is_parallel = TREE_CODE (stmt) == OMP_PARALLEL;\n+      omp_ctx.default_shared = omp_ctx.is_parallel;\n+      omp_ctx.outer = wtd->omp_ctx;\n+      omp_ctx.variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);\n+      wtd->omp_ctx = &omp_ctx;\n+      for (c = OMP_CLAUSES (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n+\tswitch (OMP_CLAUSE_CODE (c))\n+\t  {\n+\t  case OMP_CLAUSE_SHARED:\n+\t  case OMP_CLAUSE_PRIVATE:\n+\t  case OMP_CLAUSE_FIRSTPRIVATE:\n+\t  case OMP_CLAUSE_LASTPRIVATE:\n+\t    decl = OMP_CLAUSE_DECL (c);\n+\t    if (decl == error_mark_node || !omp_var_to_track (decl))\n+\t      break;\n+\t    n = splay_tree_lookup (omp_ctx.variables, (splay_tree_key) decl);\n+\t    if (n != NULL)\n+\t      break;\n+\t    splay_tree_insert (omp_ctx.variables, (splay_tree_key) decl,\n+\t\t\t       OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t\t\t       ? OMP_CLAUSE_DEFAULT_SHARED\n+\t\t\t       : OMP_CLAUSE_DEFAULT_PRIVATE);\n+\t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_PRIVATE\n+\t\t&& omp_ctx.outer)\n+\t      omp_cxx_notice_variable (omp_ctx.outer, decl);\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULT:\n+\t    if (OMP_CLAUSE_DEFAULT_KIND (c) == OMP_CLAUSE_DEFAULT_SHARED)\n+\t      omp_ctx.default_shared = true;\n+\t  default:\n+\t    break;\n+\t  }\n+      cp_walk_tree (&OMP_BODY (stmt), cp_genericize_r, data, NULL);\n+      wtd->omp_ctx = omp_ctx.outer;\n+      splay_tree_delete (omp_ctx.variables);\n+    }\n \n   pointer_set_insert (p_set, *stmt_p);\n \n@@ -985,6 +1172,7 @@ cp_genericize (tree fndecl)\n      walk_tree's hash functionality.  */\n   wtd.p_set = pointer_set_create ();\n   wtd.bind_expr_stack = NULL;\n+  wtd.omp_ctx = NULL;\n   cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_genericize_r, &wtd, NULL);\n   pointer_set_destroy (wtd.p_set);\n   VEC_free (tree, heap, wtd.bind_expr_stack);"}, {"sha": "3ccbfda2adc54dff28d1b80cc0d9df57983f526f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -5081,10 +5081,10 @@ extern tree lazily_declare_fn\t\t\t(special_function_kind,\n extern tree skip_artificial_parms_for\t\t(const_tree, tree);\n extern int num_artificial_parms_for\t\t(const_tree);\n extern tree make_alias_for\t\t\t(tree, tree);\n-extern tree get_copy_ctor\t\t\t(tree);\n+extern tree get_copy_ctor\t\t\t(tree, tsubst_flags_t);\n extern tree get_copy_assign\t\t\t(tree);\n extern tree get_default_ctor\t\t\t(tree);\n-extern tree get_dtor\t\t\t\t(tree);\n+extern tree get_dtor\t\t\t\t(tree, tsubst_flags_t);\n extern tree locate_ctor\t\t\t\t(tree);\n \n /* In optimize.c */"}, {"sha": "cf35b4aab0080d4fa7488318ed55ddf233f9da62", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -1,7 +1,7 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -843,10 +843,10 @@ locate_fn_flags (tree type, tree name, tree argtype, int flags,\n /* Locate the dtor of TYPE.  */\n \n tree\n-get_dtor (tree type)\n+get_dtor (tree type, tsubst_flags_t complain)\n {\n   tree fn = locate_fn_flags (type, complete_dtor_identifier, NULL_TREE,\n-\t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n+\t\t\t     LOOKUP_NORMAL, complain);\n   if (fn == error_mark_node)\n     return NULL_TREE;\n   return fn;\n@@ -883,13 +883,13 @@ get_default_ctor (tree type)\n /* Locate the copy ctor of TYPE.  */\n \n tree\n-get_copy_ctor (tree type)\n+get_copy_ctor (tree type, tsubst_flags_t complain)\n {\n   int quals = (TYPE_HAS_CONST_COPY_CTOR (type)\n \t       ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED);\n   tree argtype = build_stub_type (type, quals, false);\n   tree fn = locate_fn_flags (type, complete_ctor_identifier, argtype,\n-\t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n+\t\t\t     LOOKUP_NORMAL, complain);\n   if (fn == error_mark_node)\n     return NULL_TREE;\n   return fn;"}, {"sha": "6b62dd2cb53277f5556251fbc0af9c15a54df8e5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -3756,15 +3756,15 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n       if (need_default_ctor)\n \tt = get_default_ctor (type);\n       else\n-\tt = get_copy_ctor (type);\n+\tt = get_copy_ctor (type, tf_warning_or_error);\n \n       if (t && !trivial_fn_p (t))\n \tTREE_VEC_ELT (info, 0) = t;\n     }\n \n   if ((need_default_ctor || need_copy_ctor)\n       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-    TREE_VEC_ELT (info, 1) = get_dtor (type);\n+    TREE_VEC_ELT (info, 1) = get_dtor (type, tf_warning_or_error);\n \n   if (need_copy_assignment)\n     {"}, {"sha": "97382893917c4d72bfd86d8903592a613e85c87d", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -1,3 +1,8 @@\n+2011-05-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/48869\n+\t* testsuite/libgomp.c++/pr48869.C: New test.\n+\n 2011-05-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/48894"}, {"sha": "ec952d9b78733754f461fb8a923e3c34000bab44", "filename": "libgomp/testsuite/libgomp.c++/pr48869.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577f7309a8b7c410e1ebe350250398997f0a8df/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr48869.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577f7309a8b7c410e1ebe350250398997f0a8df/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr48869.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr48869.C?ref=4577f7309a8b7c410e1ebe350250398997f0a8df", "patch": "@@ -0,0 +1,68 @@\n+// PR c++/48869\n+// { dg-do run }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template <const int N>\n+struct A\n+{\n+  A () {}\n+  A (const A&) = delete;\n+  void foo () {}\n+  ~A () {}\n+};\n+\n+template <const int N>\n+struct B\n+{\n+  B () {}\n+  B (const B&) {}\n+  void foo () {}\n+  ~B () {}\n+};\n+\n+void __attribute__((used))\n+foo (B<6> b6)\n+{\n+  #pragma omp task\n+    b6.foo ();\n+}\n+\n+int\n+main ()\n+{\n+  A<0> a0;\n+  #pragma omp task shared(a0)\n+    a0.foo ();\n+  #pragma omp task default(shared)\n+    a0.foo ();\n+  #pragma omp parallel shared(a0)\n+    #pragma omp task\n+      a0.foo ();\n+  #pragma omp task\n+  {\n+    A<1> a1;\n+    a1.foo ();\n+  }\n+  B<0> b0;\n+  #pragma omp task shared(b0)\n+    b0.foo ();\n+  B<1> b1;\n+  #pragma omp task default(shared)\n+    b1.foo ();\n+  B<2> b2;\n+  #pragma omp parallel shared(b2)\n+    #pragma omp task\n+      b2.foo ();\n+  B<3> b3;\n+  #pragma omp task\n+    b3.foo ();\n+  B<4> b4;\n+  #pragma omp parallel private (b4)\n+    #pragma omp task\n+      b4.foo ();\n+  B<5> b5;\n+  #pragma omp parallel firstprivate (b5)\n+    #pragma omp task\n+      b5.foo ();\n+  return 0;\n+}"}]}