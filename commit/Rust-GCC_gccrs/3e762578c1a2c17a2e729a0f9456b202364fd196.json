{"sha": "3e762578c1a2c17a2e729a0f9456b202364fd196", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U3NjI1NzhjMWEyYzE3YTJlNzI5YTBmOTQ1NmIyMDIzNjRmZDE5Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-08-08T09:27:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-08-08T09:27:40Z"}, "message": "modulo-sched.c (get_sched_window): Use a table for the debug output.\n\ngcc/\n\t* modulo-sched.c (get_sched_window): Use a table for the debug output.\n\tPrint the current ii.\n\t(sms_schedule_by_order): Reduce whitespace in dump line.\n\nFrom-SVN: r177556", "tree": {"sha": "39acb12e01550c28283cdf43f0df616993d775bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39acb12e01550c28283cdf43f0df616993d775bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e762578c1a2c17a2e729a0f9456b202364fd196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e762578c1a2c17a2e729a0f9456b202364fd196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e762578c1a2c17a2e729a0f9456b202364fd196", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e762578c1a2c17a2e729a0f9456b202364fd196/comments", "author": null, "committer": null, "parents": [{"sha": "fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe43febc8cbcff3a69f17934b501ca55bb30ac8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe43febc8cbcff3a69f17934b501ca55bb30ac8b"}], "stats": {"total": 100, "additions": 52, "deletions": 48}, "files": [{"sha": "cda57dd131adcb464ed53a53742300416032756d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e762578c1a2c17a2e729a0f9456b202364fd196/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e762578c1a2c17a2e729a0f9456b202364fd196/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e762578c1a2c17a2e729a0f9456b202364fd196", "patch": "@@ -1,3 +1,9 @@\n+2011-08-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* modulo-sched.c (get_sched_window): Use a table for the debug output.\n+\tPrint the current ii.\n+\t(sms_schedule_by_order): Reduce whitespace in dump line.\n+\n 2011-08-08  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* modulo-sched.c (get_sched_window): Use just one loop for predecessors"}, {"sha": "a12200c170122616e14b211eccbb4ef5470bcb39", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e762578c1a2c17a2e729a0f9456b202364fd196/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e762578c1a2c17a2e729a0f9456b202364fd196/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=3e762578c1a2c17a2e729a0f9456b202364fd196", "patch": "@@ -1662,44 +1662,41 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   count_preds = 0;\n   count_succs = 0;\n \n+  if (dump_file && (psp_not_empty || pss_not_empty))\n+    {\n+      fprintf (dump_file, \"\\nAnalyzing dependencies for node %d (INSN %d)\"\n+\t       \"; ii = %d\\n\\n\", u_node->cuid, INSN_UID (u_node->insn), ii);\n+      fprintf (dump_file, \"%11s %11s %11s %11s %5s\\n\",\n+\t       \"start\", \"early start\", \"late start\", \"end\", \"time\");\n+      fprintf (dump_file, \"=========== =========== =========== ===========\"\n+\t       \" =====\\n\");\n+    }\n   /* Calculate early_start and limit end.  Both bounds are inclusive.  */\n   if (psp_not_empty)\n     for (e = u_node->in; e != 0; e = e->next_in)\n       {\n \tddg_node_ptr v_node = e->src;\n \n-\tif (dump_file)\n-\t  {\n-\t    fprintf (dump_file, \"\\nProcessing edge: \");\n-\t    print_ddg_edge (dump_file, e);\n-\t    fprintf (dump_file,\n-\t\t     \"\\nScheduling %d (%d) in psp_not_empty,\"\n-\t\t     \" checking p %d (%d): \", u_node->cuid,\n-\t\t     INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n-\t\t     (v_node->insn));\n-\t  }\n-\n \tif (TEST_BIT (sched_nodes, v_node->cuid))\n \t  {\n \t    int p_st = SCHED_TIME (v_node);\n+\t    int earliest = p_st + e->latency - (e->distance * ii);\n+\t    int latest = (e->data_type == MEM_DEP ? p_st + ii - 1 : INT_MAX);\n \n-\t    early_start = MAX (early_start,\n-\t\t\t       p_st + e->latency - (e->distance * ii));\n+\t    if (dump_file)\n+\t      {\n+\t\tfprintf (dump_file, \"%11s %11d %11s %11d %5d\",\n+\t\t\t \"\", earliest, \"\", latest, p_st);\n+\t\tprint_ddg_edge (dump_file, e);\n+\t\tfprintf (dump_file, \"\\n\");\n+\t      }\n \n-\t    if (e->data_type == MEM_DEP)\n-\t      end = MIN (end, p_st + ii - 1);\n+\t    early_start = MAX (early_start, earliest);\n+\t    end = MIN (end, latest);\n \n \t    if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n \t      count_preds++;\n-\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"pred st = %d; early_start = %d; latency: %d;\"\n-\t\t       \" end: %d\\n\", p_st, early_start, e->latency, end);\n-\n \t  }\n-\telse if (dump_file)\n-\t  fprintf (dump_file, \"the node is not scheduled\\n\");\n       }\n \n   /* Calculate late_start and limit start.  Both bounds are inclusive.  */\n@@ -1708,40 +1705,37 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n       {\n \tddg_node_ptr v_node = e->dest;\n \n-\tif (dump_file)\n-\t  {\n-\t    fprintf (dump_file, \"\\nProcessing edge:\");\n-\t    print_ddg_edge (dump_file, e);\n-\t    fprintf (dump_file,\n-\t\t     \"\\nScheduling %d (%d) in pss_not_empty,\"\n-\t\t     \" checking s %d (%d): \", u_node->cuid,\n-\t\t     INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n-\t\t     (v_node->insn));\n-\t  }\n-\n \tif (TEST_BIT (sched_nodes, v_node->cuid))\n \t  {\n \t    int s_st = SCHED_TIME (v_node);\n+\t    int earliest = (e->data_type == MEM_DEP ? s_st - ii + 1 : INT_MIN);\n+\t    int latest = s_st - e->latency + (e->distance * ii);\n \n-\t    late_start = MIN (late_start,\n-\t\t\t      s_st - e->latency + (e->distance * ii));\n+\t    if (dump_file)\n+\t      {\n+\t\tfprintf (dump_file, \"%11d %11s %11d %11s %5d\",\n+\t\t\t earliest, \"\", latest, \"\", s_st);\n+\t\tprint_ddg_edge (dump_file, e);\n+\t\tfprintf (dump_file, \"\\n\");\n+\t      }\n \n-\t    if (e->data_type == MEM_DEP)\n-\t      start = MAX (start, s_st - ii + 1);\n+\t    start = MAX (start, earliest);\n+\t    late_start = MIN (late_start, latest);\n \n \t    if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n \t      count_succs++;\n-\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"succ st = %d; late_start = %d; latency = %d;\"\n-\t\t       \" start=%d\", s_st, late_start, e->latency, start);\n-\n \t  }\n-\telse if (dump_file)\n-\t  fprintf (dump_file, \"the node is not scheduled\\n\");\n       }\n \n+  if (dump_file && (psp_not_empty || pss_not_empty))\n+    {\n+      fprintf (dump_file, \"----------- ----------- ----------- -----------\"\n+\t       \" -----\\n\");\n+      fprintf (dump_file, \"%11d %11d %11d %11d %5s %s\\n\",\n+\t       start, early_start, late_start, end, \"\",\n+\t       \"(max, max, min, min)\");\n+    }\n+\n   /* Get a target scheduling window no bigger than ii.  */\n   if (early_start == INT_MIN && late_start == INT_MAX)\n     early_start = SCHED_ASAP (u_node);\n@@ -1753,6 +1747,10 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   start = MAX (start, early_start);\n   end = MIN (end, late_start);\n \n+  if (dump_file && (psp_not_empty || pss_not_empty))\n+    fprintf (dump_file, \"%11s %11d %11d %11s %5s final window\\n\",\n+\t     \"\", start, end, \"\", \"\");\n+\n   /* If there are at least as many successors as predecessors, schedule the\n      node close to its successors.  */\n   if (pss_not_empty && count_succs >= count_preds)\n@@ -1960,8 +1958,8 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n                                 &step, &end) == 0)\n             {\n               if (dump_file)\n-                fprintf (dump_file, \"\\nTrying to schedule node %d \\\n-                        INSN = %d  in (%d .. %d) step %d\\n\", u, (INSN_UID\n+                fprintf (dump_file, \"\\nTrying to schedule node %d \"\n+\t\t\t \"INSN = %d  in (%d .. %d) step %d\\n\", u, (INSN_UID\n                         (g->nodes[u].insn)), start, end, step);\n \n               gcc_assert ((step > 0 && start < end)"}]}