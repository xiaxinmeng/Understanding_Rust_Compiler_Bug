{"sha": "5d50fab3144e5114b3a848749da6717a94117be1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1MGZhYjMxNDRlNTExNGIzYTg0ODc0OWRhNjcxN2E5NDExN2JlMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-05-06T16:53:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-06T16:53:34Z"}, "message": "pa-protos.h (hppa_fpstore_bypass_p): Declare.\n\n        * pa-protos.h (hppa_fpstore_bypass_p): Declare.\n        * pa.c (pa_adjust_cost): Remove all true dependency cost\n        adjustments.  Also remove support for non-DFA scheduling.\n        * pa.md (700, 7100, 7100lc, 7200, 7300): Use bypass mechanism\n        to adjust true dependency costs.  Update various comments.\n        (7100lc, 7200, 7300 scheduling): Simplify by combining the\n        FP ALU & MPY units into a single unit.\n\nFrom-SVN: r53227", "tree": {"sha": "c2fc16f6240dd6da25d67fb2b545a192112712a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2fc16f6240dd6da25d67fb2b545a192112712a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d50fab3144e5114b3a848749da6717a94117be1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d50fab3144e5114b3a848749da6717a94117be1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d50fab3144e5114b3a848749da6717a94117be1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d50fab3144e5114b3a848749da6717a94117be1/comments", "author": null, "committer": null, "parents": [{"sha": "a17a104c210359e3e94287270b4613e100082703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a17a104c210359e3e94287270b4613e100082703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a17a104c210359e3e94287270b4613e100082703"}], "stats": {"total": 256, "additions": 144, "deletions": 112}, "files": [{"sha": "bb742b6dd88901863b6aa3193a226d8760693511", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d50fab3144e5114b3a848749da6717a94117be1", "patch": "@@ -1,3 +1,13 @@\n+2002-05-06  Jeff Law  <law@redhat.com>\n+\n+\t* pa-protos.h (hppa_fpstore_bypass_p): Declare.\n+\t* pa.c (pa_adjust_cost): Remove all true dependency cost\n+\tadjustments.  Also remove support for non-DFA scheduling.\n+\t* pa.md (700, 7100, 7100lc, 7200, 7300): Use bypass mechanism\n+\tto adjust true dependency costs.  Update various comments.\n+\t(7100lc, 7200, 7300 scheduling): Simplify by combining the\n+\tFP ALU & MPY units into a single unit.\n+\n 2002-05-06  Catherine Moore  <clm@redhat.com>\n \n \t* config/v850/v850.c (compute_register_save_size): Make sure"}, {"sha": "57d9d4160e4b8a23701a3abd2b49411629fc0018", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=5d50fab3144e5114b3a848749da6717a94117be1", "patch": "@@ -103,6 +103,7 @@ extern int is_function_label_plus_const PARAMS ((rtx));\n extern int jump_in_call_delay PARAMS ((rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode, rtx));\n+extern int hppa_fpstore_bypass_p PARAMS ((rtx, rtx));\n \n /* Declare functions defined in pa.c and used in templates.  */\n "}, {"sha": "f5852b9c07417b7621cd86491dc655ec5c6004c0", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 35, "deletions": 77, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5d50fab3144e5114b3a848749da6717a94117be1", "patch": "@@ -60,6 +60,33 @@ hppa_use_dfa_pipeline_interface ()\n   return 1;\n }\n \n+/* Return nonzero if there is a bypass for the output of \n+   OUT_INSN and the fp store IN_INSN.  */\n+int\n+hppa_fpstore_bypass_p (out_insn, in_insn)\n+     rtx out_insn, in_insn;\n+{\n+  enum machine_mode store_mode;\n+  enum machine_mode other_mode;\n+  rtx set;\n+\n+  if (recog_memoized (in_insn) < 0\n+      || get_attr_type (in_insn) != TYPE_FPSTORE\n+      || recog_memoized (out_insn) < 0)\n+    return 0;\n+\n+  store_mode = GET_MODE (SET_SRC (PATTERN (in_insn)));\n+\n+  set = single_set (out_insn);\n+  if (!set)\n+    return 0;\n+\n+  other_mode = GET_MODE (SET_SRC (set));\n+\n+  return (GET_MODE_SIZE (store_mode) == GET_MODE_SIZE (other_mode));\n+}\n+  \n+\n #ifndef DO_FRAME_NOTES\n #ifdef INCOMING_RETURN_ADDR_RTX\n #define DO_FRAME_NOTES 1\n@@ -3907,74 +3934,17 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n {\n   enum attr_type attr_type;\n \n-  /* Don't adjust costs for a pa8000 chip.  */\n-  if (pa_cpu >= PROCESSOR_8000)\n+  /* Don't adjust costs for a pa8000 chip, also do not adjust any\n+     true dependencies as they are described with bypasses now.  */\n+  if (pa_cpu >= PROCESSOR_8000 || REG_NOTE_KIND (link) == 0)\n     return cost;\n \n   if (! recog_memoized (insn))\n     return 0;\n \n   attr_type = get_attr_type (insn);\n \n-  if (REG_NOTE_KIND (link) == 0)\n-    {\n-      /* Data dependency; DEP_INSN writes a register that INSN reads some\n-\t cycles later.  */\n-\n-      if (attr_type == TYPE_FPSTORE)\n-\t{\n-\t  rtx pat = PATTERN (insn);\n-\t  rtx dep_pat = PATTERN (dep_insn);\n-\t  if (GET_CODE (pat) == PARALLEL)\n-\t    {\n-\t      /* This happens for the fstXs,mb patterns.  */\n-\t      pat = XVECEXP (pat, 0, 0);\n-\t    }\n-\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n-\t    /* If this happens, we have to extend this to schedule\n-\t       optimally.  Return 0 for now.  */\n-\t  return 0;\n-\n-\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n-\t    {\n-\t      if (! recog_memoized (dep_insn))\n-\t\treturn 0;\n-\t      /* DEP_INSN is writing its result to the register\n-\t\t being stored in the fpstore INSN.  */\n-\t      switch (get_attr_type (dep_insn))\n-\t\t{\n-\t\tcase TYPE_FPLOAD:\n-\t\t  /* This cost 3 cycles, not 2 as the md says for the\n-\t\t     700 and 7100, 7100lc, 7200 and 7300.  */\n-\t\t  return cost + 1;\n-\n-\t\tcase TYPE_FPALU:\n-\t\tcase TYPE_FPMULSGL:\n-\t\tcase TYPE_FPMULDBL:\n-\t\tcase TYPE_FPDIVSGL:\n-\t\tcase TYPE_FPDIVDBL:\n-\t\tcase TYPE_FPSQRTSGL:\n-\t\tcase TYPE_FPSQRTDBL:\n-\t\t  /* In these important cases, we save one cycle compared to\n-\t\t     when flop instruction feed each other.  */\n-\t\t  return cost - 1;\n-\n-\t\tdefault:\n-\t\t  return cost;\n-\t\t}\n-\t    }\n-\n-\t  /* A flop-flop true depenendency where the sizes of the operand\n-\t     carrying the dependency is difference causes an additional\n-\t     cycle stall on the 7100lc, 7200, and 7300.   Similarly for\n-\t     a fpload-flop true dependency.  */\n-\t}\n-\n-      /* For other data dependencies, the default cost specified in the\n-\t md is correct.  */\n-      return cost;\n-    }\n-  else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+  if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n     {\n       /* Anti dependency; DEP_INSN reads a register that INSN writes some\n \t cycles later.  */\n@@ -4010,10 +3980,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     preceding arithmetic operation has finished if\n \t\t     the target of the fpload is any of the sources\n \t\t     (or destination) of the arithmetic operation.  */\n-\t\t  if (hppa_use_dfa_pipeline_interface ())\n-\t\t    return insn_default_latency (dep_insn) - 1;\n-\t\t  else\n-\t\t    return cost - 1;\n+\t\t  return insn_default_latency (dep_insn) - 1;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4048,10 +4015,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     preceding divide or sqrt operation has finished if\n \t\t     the target of the ALU flop is any of the sources\n \t\t     (or destination) of the divide or sqrt operation.  */\n-\t\t  if (hppa_use_dfa_pipeline_interface ())\n-\t\t    return insn_default_latency (dep_insn) - 2;\n-\t\t  else\n-\t\t    return cost - 2;\n+\t\t  return insn_default_latency (dep_insn) - 2;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4101,10 +4065,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     Exception: For PA7100LC, PA7200 and PA7300, the cost\n \t\t     is 3 cycles, unless they bundle together.   We also\n \t\t     pay the penalty if the second insn is a fpload.  */\n-\t\t  if (hppa_use_dfa_pipeline_interface ())\n-\t\t    return insn_default_latency (dep_insn) - 1;\n-\t\t  else\n-\t\t    return cost - 1;\n+\t\t  return insn_default_latency (dep_insn) - 1;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4139,10 +4100,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     preceding divide or sqrt operation has finished if\n \t\t     the target of the ALU flop is also the target of\n \t\t     the divide or sqrt operation.  */\n-\t\t  if (hppa_use_dfa_pipeline_interface ())\n-\t\t    return insn_default_latency (dep_insn) - 2;\n-\t\t  else\n-\t\t    return cost - 2;\n+\t\t  return insn_default_latency (dep_insn) - 2;\n \n \t\tdefault:\n \t\t  return 0;"}, {"sha": "e1b952bfce8c851ab740566bc809a6e6a06c0de3", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 98, "deletions": 35, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d50fab3144e5114b3a848749da6717a94117be1/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=5d50fab3144e5114b3a848749da6717a94117be1", "patch": "@@ -206,20 +206,41 @@\n   \"fpmpy_700*18\")\n \n (define_insn_reservation \"W7\" 2\n-  (and (eq_attr \"type\" \"load,fpload\")\n+  (and (eq_attr \"type\" \"load\")\n        (eq_attr \"cpu\" \"700\"))\n   \"mem_700\")\n \n-(define_insn_reservation \"W8\" 3\n-  (and (eq_attr \"type\" \"store,fpstore\")\n+(define_insn_reservation \"W8\" 2\n+  (and (eq_attr \"type\" \"fpload\")\n+       (eq_attr \"cpu\" \"700\"))\n+  \"mem_700\")\n+\n+(define_insn_reservation \"W9\" 3\n+  (and (eq_attr \"type\" \"store\")\n+       (eq_attr \"cpu\" \"700\"))\n+  \"mem_700*3\")\n+\n+(define_insn_reservation \"W10\" 3\n+  (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"700\"))\n   \"mem_700*3\")\n \n-(define_insn_reservation \"W9\" 1\n+(define_insn_reservation \"W11\" 1\n   (and (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,load,fpload,store,fpstore\")\n        (eq_attr \"cpu\" \"700\"))\n   \"dummy_700\")\n \n+;; We have a bypass for all computations in the FP unit which feed an\n+;; FP store as long as the sizes are the same.\n+(define_bypass 2 \"W1,W2\" \"W10\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 9 \"W3\" \"W10\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 11 \"W4\" \"W10\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 13 \"W5\" \"W10\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 17 \"W6\" \"W10\" \"hppa_fpstore_bypass_p\")\n+\n+;; We have an \"anti-bypass\" for FP loads which feed an FP store.\n+(define_bypass 4 \"W8\" \"W10\" \"hppa_fpstore_bypass_p\")\n+\n ;; Function units for the 7100 and 7150.  The 7100/7150 can dual-issue\n ;; floating point computations with non-floating point computations (fp loads\n ;; and stores are not fp computations).\n@@ -228,8 +249,12 @@\n ;; take two cycles, during which no Dcache operations should be scheduled.\n ;; Any special cases are handled in pa_adjust_cost.  The 7100, 7150 and 7100LC\n ;; all have the same memory characteristics if one disregards cache misses.\n-\n+;;\n ;; The 7100/7150 has three floating-point units: ALU, MUL, and DIV.\n+;; There's no value in modeling the ALU and MUL separately though\n+;; since there can never be a functional unit conflict given the\n+;; latency and issue rates for those units.\n+;;\n ;; Timings:\n ;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n ;; fcpy\t\t2\tALU\t1\n@@ -247,11 +272,6 @@\n ;; fdiv,dbl\t15\tDIV\t15\n ;; fsqrt,sgl\t8\tDIV\t8\n ;; fsqrt,dbl\t15\tDIV\t15\n-;;\n-;; We don't really model the FP ALU/MPY units properly (they are\n-;; distinct subunits in the FP unit).  However, there can never be\n-;; a functional unit; conflict given the latency and issue rates\n-;; for those units.\n \n (define_automaton \"pa7100\")\n (define_cpu_unit \"i_7100, f_7100,fpmac_7100,fpdivsqrt_7100,mem_7100\" \"pa7100\")\n@@ -272,21 +292,45 @@\n   \"f_7100+fpdivsqrt_7100,fpdivsqrt_7100*14\")\n \n (define_insn_reservation \"X3\" 2\n-  (and (eq_attr \"type\" \"load,fpload\")\n+  (and (eq_attr \"type\" \"load\")\n        (eq_attr \"cpu\" \"7100\"))\n   \"i_7100+mem_7100\")\n \n (define_insn_reservation \"X4\" 2\n-  (and (eq_attr \"type\" \"store,fpstore\")\n+  (and (eq_attr \"type\" \"fpload\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"i_7100+mem_7100\")\n+\n+(define_insn_reservation \"X5\" 2\n+  (and (eq_attr \"type\" \"store\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"i_7100+mem_7100,mem_7100\")\n+\n+(define_insn_reservation \"X6\" 2\n+  (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"7100\"))\n   \"i_7100+mem_7100,mem_7100\")\n \n-(define_insn_reservation \"X5\" 1\n+(define_insn_reservation \"X7\" 1\n   (and (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl,load,fpload,store,fpstore\")\n        (eq_attr \"cpu\" \"7100\"))\n   \"i_7100\")\n \n+;; We have a bypass for all computations in the FP unit which feed an\n+;; FP store as long as the sizes are the same.\n+(define_bypass 1 \"X0\" \"X6\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 7 \"X1\" \"X6\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 14 \"X2\" \"X6\" \"hppa_fpstore_bypass_p\")\n+\n+;; We have an \"anti-bypass\" for FP loads which feed an FP store.\n+(define_bypass 3 \"X4\" \"X6\" \"hppa_fpstore_bypass_p\")\n+\n ;; The 7100LC has three floating-point units: ALU, MUL, and DIV.\n+;; There's no value in modeling the ALU and MUL separately though\n+;; since there can never be a functional unit conflict that\n+;; can be avoided given the latency, issue rates and mandatory\n+;; one cycle cpu-wide lock for a double precision fp multiply.\n+;;\n ;; Timings:\n ;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n ;; fcpy\t\t2\tALU\t1\n@@ -321,73 +365,92 @@\n ;;\n ;;   load-load pairs\n ;;   store-store pairs\n-;;   fmpyadd,dbl\n-;;   fmpysub,dbl\n ;;   other issue modeling\n \n (define_automaton \"pa7100lc\")\n (define_cpu_unit \"i0_7100lc, i1_7100lc, f_7100lc\" \"pa7100lc\")\n-(define_cpu_unit \"fpalu_7100lc,fpmul_7100lc\" \"pa7100lc\")\n+(define_cpu_unit \"fpmac_7100lc\" \"pa7100lc\")\n (define_cpu_unit \"mem_7100lc\" \"pa7100lc\")\n \n-(define_insn_reservation \"Y0\" 2\n-  (and (eq_attr \"type\" \"fpcc,fpalu\")\n-       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n-  \"f_7100lc,fpalu_7100lc\")\n-\n ;; Double precision multiplies lock the entire CPU for one\n ;; cycle.  There is no way to avoid this lock and trying to\n ;; schedule around the lock is pointless and thus there is no\n-;; value in trying to model this lock.  Not modeling the lock\n-;; allows for a smaller DFA and may reduce register pressure.\n-(define_insn_reservation \"Y1\" 2\n-  (and (eq_attr \"type\" \"fpmulsgl,fpmuldbl\")\n+;; value in trying to model this lock.\n+;;\n+;; Not modeling the lock allows us to treat fp multiplies just\n+;; like any other FP alu instruction.  It allows for a smaller\n+;; DFA and may reduce register pressure.\n+(define_insn_reservation \"Y0\" 2\n+  (and (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl\")\n        (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n-  \"f_7100lc,fpmul_7100lc\")\n+  \"f_7100lc,fpmac_7100lc\")\n \n ;; fp division and sqrt instructions lock the entire CPU for\n ;; 7 cycles (single precision) or 14 cycles (double precision).\n ;; There is no way to avoid this lock and trying to schedule\n ;; around the lock is pointless and thus there is no value in\n ;; trying to model this lock.  Not modeling the lock allows\n ;; for a smaller DFA and may reduce register pressure.\n-(define_insn_reservation \"Y2\" 1\n+(define_insn_reservation \"Y1\" 1\n   (and (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n        (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n   \"f_7100lc\")\n \n+(define_insn_reservation \"Y2\" 2\n+  (and (eq_attr \"type\" \"load\")\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"i1_7100lc+mem_7100lc\")\n+\n (define_insn_reservation \"Y3\" 2\n-  (and (eq_attr \"type\" \"load,fpload\")\n+  (and (eq_attr \"type\" \"fpload\")\n        (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n   \"i1_7100lc+mem_7100lc\")\n \n (define_insn_reservation \"Y4\" 2\n-  (and (eq_attr \"type\" \"store,fpstore\")\n+  (and (eq_attr \"type\" \"store\")\n+       (eq_attr \"cpu\" \"7100LC\"))\n+  \"i1_7100lc+mem_7100lc,mem_7100lc\")\n+\n+(define_insn_reservation \"Y5\" 2\n+  (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"7100LC\"))\n   \"i1_7100lc+mem_7100lc,mem_7100lc\")\n \n-(define_insn_reservation \"Y5\" 1\n+(define_insn_reservation \"Y6\" 1\n   (and (eq_attr \"type\" \"shift,nullshift\")\n        (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n   \"i1_7100lc\")\n \n-(define_insn_reservation \"Y6\" 1\n+(define_insn_reservation \"Y7\" 1\n   (and (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl,load,fpload,store,fpstore,shift,nullshift\")\n        (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n   \"(i0_7100lc|i1_7100lc)\")\n \n ;; The 7200 has a store-load penalty\n-(define_insn_reservation \"Y7\" 2\n-  (and (eq_attr \"type\" \"store,fpstore\")\n+(define_insn_reservation \"Y8\" 2\n+  (and (eq_attr \"type\" \"store\")\n+       (eq_attr \"cpu\" \"7200\"))\n+  \"i1_7100lc,mem_7100lc\")\n+\n+(define_insn_reservation \"Y9\" 2\n+  (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"7200\"))\n   \"i1_7100lc,mem_7100lc\")\n \n ;; The 7300 has no penalty for store-store or store-load\n-(define_insn_reservation \"Y8\" 2\n-  (and (eq_attr \"type\" \"store,fpstore\")\n+(define_insn_reservation \"Y10\" 2\n+  (and (eq_attr \"type\" \"store\")\n        (eq_attr \"cpu\" \"7300\"))\n   \"i1_7100lc\")\n \n+(define_insn_reservation \"Y11\" 2\n+  (and (eq_attr \"type\" \"fpstore\")\n+       (eq_attr \"cpu\" \"7300\"))\n+  \"i1_7100lc\")\n+\n+;; We have an \"anti-bypass\" for FP loads which feed an FP store.\n+(define_bypass 3 \"Y3\" \"Y5,Y9,Y11\" \"hppa_fpstore_bypass_p\")\n+\n ;; Scheduling for the PA8000 is somewhat different than scheduling for a\n ;; traditional architecture.\n ;;"}]}