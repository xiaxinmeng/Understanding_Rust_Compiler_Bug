{"sha": "4644aad40e09371c44094b976bb43e49ae40ba3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0NGFhZDQwZTA5MzcxYzQ0MDk0Yjk3NmJiNDNlNDlhZTQwYmEzYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-18T11:57:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-18T11:57:54Z"}, "message": "(earlyclobber_operand_p): New function.\n\n(combine_reloads): Use it.\n(find_reloads): Set reload_earlyclobbers earlier.\n(refers_to_regno_for_reload_p): Count something being stored into if it is\nan earlyclobber operand.\n\nFrom-SVN: r5352", "tree": {"sha": "c750721a1b12c446790507c7e0083d2a741f4f6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c750721a1b12c446790507c7e0083d2a741f4f6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4644aad40e09371c44094b976bb43e49ae40ba3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4644aad40e09371c44094b976bb43e49ae40ba3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4644aad40e09371c44094b976bb43e49ae40ba3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4644aad40e09371c44094b976bb43e49ae40ba3b/comments", "author": null, "committer": null, "parents": [{"sha": "efc1a4d9b4b426c5c26e2ef599f9992c7ba04914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc1a4d9b4b426c5c26e2ef599f9992c7ba04914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc1a4d9b4b426c5c26e2ef599f9992c7ba04914"}], "stats": {"total": 41, "additions": 29, "deletions": 12}, "files": [{"sha": "a0199e8067497affb60718cc05fadbf95190bcef", "filename": "gcc/reload.c", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4644aad40e09371c44094b976bb43e49ae40ba3b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4644aad40e09371c44094b976bb43e49ae40ba3b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4644aad40e09371c44094b976bb43e49ae40ba3b", "patch": "@@ -269,6 +269,7 @@ static void combine_reloads\tPROTO((void));\n static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       enum reg_class, int));\n+static int earlyclobber_operand_p PROTO((rtx));\n static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n static struct decomposition decompose PROTO((rtx));\n static int immune_p\t\tPROTO((rtx, rtx, struct decomposition));\n@@ -1448,10 +1449,8 @@ combine_reloads ()\n     return;\n \n   /* If this reload is for an earlyclobber operand, we can't do anything.  */\n-\n-  for (i = 0; i < n_earlyclobbers; i++)\n-    if (reload_out[output_reload] == reload_earlyclobbers[i])\n-      return;\n+  if (earlyclobber_operand_p (reload_out[output_reload]))\n+    return;\n \n   /* Check each input reload; can we combine it?  */\n \n@@ -1732,6 +1731,21 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n    whether the IN or an OUT of a reload can serve as the\n    reload register.  */\n \n+/* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n+\n+static int\n+earlyclobber_operand_p (x)\n+     rtx x;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_earlyclobbers; i++)\n+    if (reload_earlyclobbers[i] == x)\n+      return 1;\n+\n+  return 0;\n+}\n+\n /* Return 1 if expression X alters a hard reg in the range\n    from BEG_REGNO (inclusive) to END_REGNO (exclusive),\n    either explicitly or in the guise of a pseudo-reg allocated to REGNO.\n@@ -3276,6 +3290,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  goal_alternative_win[i] = 1;\n       }\n \n+  /* Record the values of the earlyclobber operands for the caller.  */\n+  if (goal_earlyclobber)\n+    for (i = 0; i < noperands; i++)\n+      if (goal_alternative_earlyclobber[i])\n+\treload_earlyclobbers[n_earlyclobbers++] = recog_operand[i];\n+\n   /* Now record reloads for all the operands that need them.  */\n   for (i = 0; i < noperands; i++)\n     if (! goal_alternative_win[i])\n@@ -3434,12 +3454,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   0, 1, goal_alternative_matches[i], RELOAD_OTHER);\n       }\n   \n-  /* Record the values of the earlyclobber operands for the caller.  */\n-  if (goal_earlyclobber)\n-    for (i = 0; i < noperands; i++)\n-      if (goal_alternative_earlyclobber[i])\n-\treload_earlyclobbers[n_earlyclobbers++] = recog_operand[i];\n-\n   /* If this insn pattern contains any MATCH_DUP's, make sure that\n      they will be substituted if the operands they match are substituted.\n      Also do now any substitutions we already did on the operands.\n@@ -4854,7 +4868,7 @@ find_replacement (loc)\n \f\n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X\n-   other than being stored into.\n+   other than being stored into (except for earlyclobber operands).\n \n    References contained within the substructure at LOC do not count.\n    LOC may be zero, meaning don't ignore anything.\n@@ -4931,7 +4945,10 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \t       && refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\tSUBREG_REG (SET_DEST (x)),\n \t\t\t\t\t\tloc))\n-\t      || (GET_CODE (SET_DEST (x)) != REG\n+\t      /* If the ouput is an earlyclobber operand, this is\n+\t\t a conflict.  */\n+\t      || ((GET_CODE (SET_DEST (x)) != REG\n+\t\t   || earlyclobber_operand_p (SET_DEST (x)))\n \t\t  && refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\t   SET_DEST (x), loc))))\n \treturn 1;"}]}