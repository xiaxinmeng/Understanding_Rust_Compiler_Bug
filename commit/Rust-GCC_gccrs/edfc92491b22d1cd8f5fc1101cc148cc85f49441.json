{"sha": "edfc92491b22d1cd8f5fc1101cc148cc85f49441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRmYzkyNDkxYjIyZDFjZDhmNWZjMTEwMWNjMTQ4Y2M4NWY0OTQ0MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-18T19:33:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-18T19:33:48Z"}, "message": "[PATCH] const_and_copies is no longer file scoped\n\n        PR tree-optimization/47679\n\t* tree-ssa-dom.c (const_and_copies): No longer file scoped.  Move\n\tit here ...\n\t(dom_opt_dom_walker): New private member holding the const_and_copies\n\tobject.  Update constructor.\n\t(pass_dominator::execute): Corresponding changes to declaration\n\tand initialization of const_and_copies.  Update constructor call\n\tfor the dom_opt_dom_walker object.\n\t(record_temporary_equivalences): Accept const_and_copies argument\n\tpass it down to children as needed.\n\t(record_equality): Likewise.\n\t(record_equivalences_from_incoming_edge): Likewise.\n\t(cprop_into_successor_phis, optimize_stmt): Likewise.\n\t(eliminate_redundant_computations): Likewise.\n\t(dom_opt_dom_walker::thread_across_edge): Update access to\n\tconst_and_copies object and pass it to children as needed.\n\t(dom_opt_dom_walker::before_dom_children): Similarly.\n\t(dom_opt_dom_walker::after_dom_children): Similarly.\n\nFrom-SVN: r227922", "tree": {"sha": "1b110fc175cdaaf1412e67cdd7ea07193bbd6aaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b110fc175cdaaf1412e67cdd7ea07193bbd6aaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edfc92491b22d1cd8f5fc1101cc148cc85f49441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edfc92491b22d1cd8f5fc1101cc148cc85f49441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edfc92491b22d1cd8f5fc1101cc148cc85f49441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edfc92491b22d1cd8f5fc1101cc148cc85f49441/comments", "author": null, "committer": null, "parents": [{"sha": "1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4"}], "stats": {"total": 96, "additions": 63, "deletions": 33}, "files": [{"sha": "475497713f421729eec5a2e2c90d09746e1e7449", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfc92491b22d1cd8f5fc1101cc148cc85f49441/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfc92491b22d1cd8f5fc1101cc148cc85f49441/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edfc92491b22d1cd8f5fc1101cc148cc85f49441", "patch": "@@ -1,5 +1,24 @@\n 2015-09-18  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (const_and_copies): No longer file scoped.  Move\n+\tit here ...\n+\t(dom_opt_dom_walker): New private member holding the const_and_copies\n+\tobject.  Update constructor.\n+\t(pass_dominator::execute): Corresponding changes to declaration\n+\tand initialization of const_and_copies.  Update constructor call\n+\tfor the dom_opt_dom_walker object.\n+\t(record_temporary_equivalences): Accept const_and_copies argument\n+\tpass it down to children as needed.\n+\t(record_equality): Likewise.\n+\t(record_equivalences_from_incoming_edge): Likewise.\n+\t(cprop_into_successor_phis, optimize_stmt): Likewise.\n+\t(eliminate_redundant_computations): Likewise.\n+\t(dom_opt_dom_walker::thread_across_edge): Update access to\n+\tconst_and_copies object and pass it to children as needed.\n+\t(dom_opt_dom_walker::before_dom_children): Similarly.\n+\t(dom_opt_dom_walker::after_dom_children): Similarly.\n+\n \tPR tree-optimization/47679\n \t* tree-ssa-dom.c (avail_exprs): No longer file scoped.  Bury\n \tit into the avail_exprs_stack class."}, {"sha": "fd2566c72dcfb3266e287bdc1bdb33801d032407", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfc92491b22d1cd8f5fc1101cc148cc85f49441/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfc92491b22d1cd8f5fc1101cc148cc85f49441/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=edfc92491b22d1cd8f5fc1101cc148cc85f49441", "patch": "@@ -79,7 +79,6 @@ struct edge_info\n };\n \n /* Unwindable equivalences, both const/copy and expression varieties.  */\n-static const_and_copies *const_and_copies;\n static avail_exprs_stack *avail_exprs_stack;\n \n /* Track whether or not we have changed the control flow graph.  */\n@@ -103,13 +102,16 @@ struct opt_stats_d\n static struct opt_stats_d opt_stats;\n \n /* Local functions.  */\n-static void optimize_stmt (basic_block, gimple_stmt_iterator);\n+static void optimize_stmt (basic_block, gimple_stmt_iterator,\n+\t\t\t   class const_and_copies *);\n static tree lookup_avail_expr (gimple, bool);\n static void record_cond (cond_equivalence *);\n-static void record_equality (tree, tree);\n+static void record_equality (tree, tree, class const_and_copies *);\n static void record_equivalences_from_phis (basic_block);\n-static void record_equivalences_from_incoming_edge (basic_block);\n-static void eliminate_redundant_computations (gimple_stmt_iterator *);\n+static void record_equivalences_from_incoming_edge (basic_block,\n+\t\t\t\t\t\t    class const_and_copies *);\n+static void eliminate_redundant_computations (gimple_stmt_iterator *,\n+\t\t\t\t\t      class const_and_copies *);\n static void record_equivalences_from_stmt (gimple, int);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void dump_dominator_optimization_stats (FILE *file,\n@@ -487,15 +489,21 @@ record_edge_info (basic_block bb)\n class dom_opt_dom_walker : public dom_walker\n {\n public:\n-  dom_opt_dom_walker (cdi_direction direction)\n-    : dom_walker (direction), m_dummy_cond (NULL) {}\n+  dom_opt_dom_walker (cdi_direction direction,\n+\t\t      class const_and_copies *const_and_copies)\n+    : dom_walker (direction),\n+      m_const_and_copies (const_and_copies),\n+      m_dummy_cond (NULL) {}\n \n   virtual void before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n private:\n   void thread_across_edge (edge);\n \n+  /* Unwindable equivalences, both const/copy and expression varieties.  */\n+  class const_and_copies *m_const_and_copies;\n+\n   gcond *m_dummy_cond;\n };\n \n@@ -543,7 +551,7 @@ pass_dominator::execute (function *fun)\n   hash_table<expr_elt_hasher> *avail_exprs\n     = new hash_table<expr_elt_hasher> (1024);\n   avail_exprs_stack = new class avail_exprs_stack (avail_exprs);\n-  const_and_copies = new class const_and_copies ();\n+  class const_and_copies *const_and_copies = new class const_and_copies ();\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_noreturn_fixup.create (0);\n \n@@ -581,7 +589,8 @@ pass_dominator::execute (function *fun)\n     record_edge_info (bb);\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n-  dom_opt_dom_walker (CDI_DOMINATORS).walk (fun->cfg->x_entry_block_ptr);\n+  dom_opt_dom_walker walker (CDI_DOMINATORS, const_and_copies);\n+  walker.walk (fun->cfg->x_entry_block_ptr);\n \n   {\n     gimple_stmt_iterator gsi;\n@@ -764,7 +773,8 @@ dom_valueize (tree t)\n \n    Callers are responsible for managing the unwinding markers.  */\n static void\n-record_temporary_equivalences (edge e)\n+record_temporary_equivalences (edge e,\n+\t\t\t       class const_and_copies *const_and_copies)\n {\n   int i;\n   struct edge_info *edge_info = (struct edge_info *) e->aux;\n@@ -779,7 +789,7 @@ record_temporary_equivalences (edge e)\n \n       /* If we have a simple NAME = VALUE equivalence, record it.  */\n       if (lhs)\n-\trecord_equality (lhs, rhs);\n+\trecord_equality (lhs, rhs, const_and_copies);\n \n       /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n \t set via a widening type conversion, then we may be able to record\n@@ -808,7 +818,7 @@ record_temporary_equivalences (edge e)\n \t\t  && int_fits_type_p (rhs, TREE_TYPE (old_rhs)))\n \t\t{\n \t\t  tree newval = fold_convert (TREE_TYPE (old_rhs), rhs);\n-\t\t  record_equality (old_rhs, newval);\n+\t\t  record_equality (old_rhs, newval, const_and_copies);\n \t\t}\n \t    }\n \t}\n@@ -843,7 +853,7 @@ record_temporary_equivalences (edge e)\n \t\t  if (res\n \t\t      && (TREE_CODE (res) == SSA_NAME\n \t\t\t  || is_gimple_min_invariant (res)))\n-\t\t    record_equality (lhs2, res);\n+\t\t    record_equality (lhs2, res, const_and_copies);\n \t\t}\n \t    }\n \t}\n@@ -871,15 +881,15 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n   /* Push a marker on both stacks so we can unwind the tables back to their\n      current state.  */\n   avail_exprs_stack->push_marker ();\n-  const_and_copies->push_marker ();\n+  m_const_and_copies->push_marker ();\n \n   /* Traversing E may result in equivalences we can utilize.  */\n-  record_temporary_equivalences (e);\n+  record_temporary_equivalences (e, m_const_and_copies);\n \n   /* With all the edge equivalences in the tables, go ahead and attempt\n      to thread through E->dest.  */\n   ::thread_across_edge (m_dummy_cond, e, false,\n-\t\t        const_and_copies, avail_exprs_stack,\n+\t\t        m_const_and_copies, avail_exprs_stack,\n \t\t        simplify_stmt_for_jump_threading);\n \n   /* And restore the various tables to their state before\n@@ -983,7 +993,8 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n    has more than one incoming edge, then no equivalence is created.  */\n \n static void\n-record_equivalences_from_incoming_edge (basic_block bb)\n+record_equivalences_from_incoming_edge (basic_block bb,\n+    class const_and_copies *const_and_copies)\n {\n   edge e;\n   basic_block parent;\n@@ -998,7 +1009,7 @@ record_equivalences_from_incoming_edge (basic_block bb)\n   /* If we had a single incoming edge from our parent block, then enter\n      any data associated with the edge into our tables.  */\n   if (e && e->src == parent)\n-    record_temporary_equivalences (e);\n+    record_temporary_equivalences (e, const_and_copies);\n }\n \n /* Dump statistics for the hash table HTAB.  */\n@@ -1083,7 +1094,7 @@ loop_depth_of_name (tree x)\n    This constrains the cases in which we may treat this as assignment.  */\n \n static void\n-record_equality (tree x, tree y)\n+record_equality (tree x, tree y, class const_and_copies *const_and_copies)\n {\n   tree prev_x = NULL, prev_y = NULL;\n \n@@ -1183,14 +1194,12 @@ simple_iv_increment_p (gimple stmt)\n   return false;\n }\n \n-/* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n-   known value for that SSA_NAME (or NULL if no value is known).\n-\n-   Propagate values from CONST_AND_COPIES into the PHI nodes of the\n+/* Propagate know values from SSA_NAME_VALUE into the PHI nodes of the\n    successors of BB.  */\n \n static void\n-cprop_into_successor_phis (basic_block bb)\n+cprop_into_successor_phis (basic_block bb,\n+\t\t\t   class const_and_copies *const_and_copies)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1272,9 +1281,9 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n   avail_exprs_stack->push_marker ();\n-  const_and_copies->push_marker ();\n+  m_const_and_copies->push_marker ();\n \n-  record_equivalences_from_incoming_edge (bb);\n+  record_equivalences_from_incoming_edge (bb, m_const_and_copies);\n \n   /* PHI nodes can create equivalences too.  */\n   record_equivalences_from_phis (bb);\n@@ -1284,15 +1293,15 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n      marker and unwind right afterwards.  */\n   avail_exprs_stack->push_marker ();\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    eliminate_redundant_computations (&gsi);\n+    eliminate_redundant_computations (&gsi, m_const_and_copies);\n   avail_exprs_stack->pop_to_marker ();\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    optimize_stmt (bb, gsi);\n+    optimize_stmt (bb, gsi, m_const_and_copies);\n \n   /* Now prepare to process dominated blocks.  */\n   record_edge_info (bb);\n-  cprop_into_successor_phis (bb);\n+  cprop_into_successor_phis (bb, m_const_and_copies);\n }\n \n /* We have finished processing the dominator children of BB, perform\n@@ -1337,7 +1346,7 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n \n   /* These remove expressions local to BB from the tables.  */\n   avail_exprs_stack->pop_to_marker ();\n-  const_and_copies->pop_to_marker ();\n+  m_const_and_copies->pop_to_marker ();\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -1347,7 +1356,8 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n    table.  */\n \n static void\n-eliminate_redundant_computations (gimple_stmt_iterator* gsi)\n+eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n+\t\t\t\t  class const_and_copies *const_and_copies)\n {\n   tree expr_type;\n   tree cached_lhs;\n@@ -1655,7 +1665,8 @@ cprop_into_stmt (gimple stmt)\n       the variable in the LHS in the CONST_AND_COPIES table.  */\n \n static void\n-optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n+optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n+\t       class const_and_copies *const_and_copies)\n {\n   gimple stmt, old_stmt;\n   bool may_optimize_p;\n@@ -1745,7 +1756,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n \t}\n \n       update_stmt_if_modified (stmt);\n-      eliminate_redundant_computations (&si);\n+      eliminate_redundant_computations (&si, const_and_copies);\n       stmt = gsi_stmt (si);\n \n       /* Perform simple redundant store elimination.  */"}]}