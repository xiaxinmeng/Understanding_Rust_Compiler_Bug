{"sha": "a502f7b6e47d3f790e01e91ab5c480ee4b261486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUwMmY3YjZlNDdkM2Y3OTBlMDFlOTFhYjVjNDgwZWU0YjI2MTQ4Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-18T15:29:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-18T15:29:01Z"}, "message": "[PATCH] Break out phi-only cprop into its own file\n\n\tPR tree-optimization/47679\n\t* Makefile.in (OBJS): Add tree-ssa-phionlycprop.o\n\t* tree-ssa-dom.c: Remove unnecessary header includes.\n\t(remove_stmt_or_phi): Moved from here into tree-ssa-phionlycprop.c\n\t(get_rhs_or_phi_arg, get_lhs_or_phi_result): Likewise.\n\t(propagate_rhs_into_lhs, eliminate_const_or_copy): Likewise.\n\t(eliminate_degenerate_phis_1, pass_phi_only_cprop): Likewise.\n\t(pass_phi_only_cprop::execute): Likewise.\n\t(make_pass_phi_only_cprop): Likewise.\n\t* tree-ssa-phionlycprop.c: New file with moved code.  Eliminate\n\tuses of file scoped statics by passing the required objects\n\tas parameters wherever needed.\n\nFrom-SVN: r227908", "tree": {"sha": "6635c075164421ea26114d5493d1d3a225bd5829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6635c075164421ea26114d5493d1d3a225bd5829"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a502f7b6e47d3f790e01e91ab5c480ee4b261486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a502f7b6e47d3f790e01e91ab5c480ee4b261486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a502f7b6e47d3f790e01e91ab5c480ee4b261486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a502f7b6e47d3f790e01e91ab5c480ee4b261486/comments", "author": null, "committer": null, "parents": [{"sha": "e707a2dd666f2ba1acaf9f0e91684ab4d2b72850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e707a2dd666f2ba1acaf9f0e91684ab4d2b72850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e707a2dd666f2ba1acaf9f0e91684ab4d2b72850"}], "stats": {"total": 1133, "additions": 605, "deletions": 528}, "files": [{"sha": "469abad356fdaf1efcc9bf010d0627e2bc6f7aca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a502f7b6e47d3f790e01e91ab5c480ee4b261486", "patch": "@@ -1,3 +1,18 @@\n+2015-09-16  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/47679\n+\t* Makefile.in (OBJS): Add tree-ssa-phionlycprop.o\n+\t* tree-ssa-dom.c: Remove unnecessary header includes.\n+\t(remove_stmt_or_phi): Moved from here into tree-ssa-phionlycprop.c\n+\t(get_rhs_or_phi_arg, get_lhs_or_phi_result): Likewise.\n+\t(propagate_rhs_into_lhs, eliminate_const_or_copy): Likewise.\n+\t(eliminate_degenerate_phis_1, pass_phi_only_cprop): Likewise.\n+\t(pass_phi_only_cprop::execute): Likewise.\n+\t(make_pass_phi_only_cprop): Likewise.\n+\t* tree-ssa-phionlycprop.c: New file with moved code.  Eliminate\n+\tuses of file scoped statics by passing the required objects\n+\tas parameters wherever needed.\n+\n 2015-09-18  Andrew Dixie  <andrewd@gentrack.com>\n \t    David Edelsohn  <dje.gcc@gmail.com>\n "}, {"sha": "440c4515aecb11e316d53899f9dd42015f101248", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a502f7b6e47d3f790e01e91ab5c480ee4b261486", "patch": "@@ -1465,6 +1465,7 @@ OBJS = \\\n \ttree-ssa-loop.o \\\n \ttree-ssa-math-opts.o \\\n \ttree-ssa-operands.o \\\n+\ttree-ssa-phionlycprop.o \\\n \ttree-ssa-phiopt.o \\\n \ttree-ssa-phiprop.o \\\n \ttree-ssa-pre.o \\"}, {"sha": "963dea9b711815f0d19cb2e6a4258666bcc8dc46", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 0, "deletions": 528, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=a502f7b6e47d3f790e01e91ab5c480ee4b261486", "patch": "@@ -22,20 +22,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n-#include \"cfghooks.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n-#include \"hard-reg-set.h\"\n #include \"ssa.h\"\n-#include \"alias.h\"\n #include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"flags.h\"\n-#include \"tm_p.h\"\n #include \"cfganal.h\"\n #include \"cfgloop.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"internal-fn.h\"\n #include \"gimple-fold.h\"\n #include \"tree-eh.h\"\n #include \"gimple-iterator.h\"\n@@ -45,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-threadupdate.h\"\n-#include \"langhooks.h\"\n #include \"params.h\"\n #include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n@@ -1986,523 +1978,3 @@ lookup_avail_expr (gimple stmt, bool insert)\n \n   return lhs;\n }\n-\n-/* PHI-ONLY copy and constant propagation.  This pass is meant to clean\n-   up degenerate PHIs created by or exposed by jump threading.  */\n-\n-/* Given a statement STMT, which is either a PHI node or an assignment,\n-   remove it from the IL.  */\n-\n-static void\n-remove_stmt_or_phi (gimple stmt)\n-{\n-  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    remove_phi_node (&gsi, true);\n-  else\n-    {\n-      gsi_remove (&gsi, true);\n-      release_defs (stmt);\n-    }\n-}\n-\n-/* Given a statement STMT, which is either a PHI node or an assignment,\n-   return the \"rhs\" of the node, in the case of a non-degenerate\n-   phi, NULL is returned.  */\n-\n-static tree\n-get_rhs_or_phi_arg (gimple stmt)\n-{\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    return degenerate_phi_result (as_a <gphi *> (stmt));\n-  else if (gimple_assign_single_p (stmt))\n-    return gimple_assign_rhs1 (stmt);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-\n-/* Given a statement STMT, which is either a PHI node or an assignment,\n-   return the \"lhs\" of the node.  */\n-\n-static tree\n-get_lhs_or_phi_result (gimple stmt)\n-{\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    return gimple_phi_result (stmt);\n-  else if (is_gimple_assign (stmt))\n-    return gimple_assign_lhs (stmt);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Propagate RHS into all uses of LHS (when possible).\n-\n-   RHS and LHS are derived from STMT, which is passed in solely so\n-   that we can remove it if propagation is successful.\n-\n-   When propagating into a PHI node or into a statement which turns\n-   into a trivial copy or constant initialization, set the\n-   appropriate bit in INTERESTING_NAMEs so that we will visit those\n-   nodes as well in an effort to pick up secondary optimization\n-   opportunities.  */\n-\n-static void\n-propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs, bitmap interesting_names)\n-{\n-  /* First verify that propagation is valid.  */\n-  if (may_propagate_copy (lhs, rhs))\n-    {\n-      use_operand_p use_p;\n-      imm_use_iterator iter;\n-      gimple use_stmt;\n-      bool all = true;\n-\n-      /* Dump details.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  Replacing '\");\n-\t  print_generic_expr (dump_file, lhs, dump_flags);\n-\t  fprintf (dump_file, \"' with %s '\",\n-\t           (TREE_CODE (rhs) != SSA_NAME ? \"constant\" : \"variable\"));\n-\t\t   print_generic_expr (dump_file, rhs, dump_flags);\n-\t  fprintf (dump_file, \"'\\n\");\n-\t}\n-\n-      /* Walk over every use of LHS and try to replace the use with RHS.\n-\t At this point the only reason why such a propagation would not\n-\t be successful would be if the use occurs in an ASM_EXPR.  */\n-      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-\t{\n-\t  /* Leave debug stmts alone.  If we succeed in propagating\n-\t     all non-debug uses, we'll drop the DEF, and propagation\n-\t     into debug stmts will occur then.  */\n-\t  if (gimple_debug_bind_p (use_stmt))\n-\t    continue;\n-\n-\t  /* It's not always safe to propagate into an ASM_EXPR.  */\n-\t  if (gimple_code (use_stmt) == GIMPLE_ASM\n-              && ! may_propagate_copy_into_asm (lhs))\n-\t    {\n-\t      all = false;\n-\t      continue;\n-\t    }\n-\n-\t  /* It's not ok to propagate into the definition stmt of RHS.\n-\t\t<bb 9>:\n-\t\t  # prephitmp.12_36 = PHI <g_67.1_6(9)>\n-\t\t  g_67.1_6 = prephitmp.12_36;\n-\t\t  goto <bb 9>;\n-\t     While this is strictly all dead code we do not want to\n-\t     deal with this here.  */\n-\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t      && SSA_NAME_DEF_STMT (rhs) == use_stmt)\n-\t    {\n-\t      all = false;\n-\t      continue;\n-\t    }\n-\n-\t  /* Dump details.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"    Original statement:\");\n-\t      print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n-\t    }\n-\n-\t  /* Propagate the RHS into this use of the LHS.  */\n-\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t    propagate_value (use_p, rhs);\n-\n-\t  /* Special cases to avoid useless calls into the folding\n-\t     routines, operand scanning, etc.\n-\n-\t     Propagation into a PHI may cause the PHI to become\n-\t     a degenerate, so mark the PHI as interesting.  No other\n-\t     actions are necessary.  */\n-\t  if (gimple_code (use_stmt) == GIMPLE_PHI)\n-\t    {\n-\t      tree result;\n-\n-\t      /* Dump details.  */\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"    Updated statement:\");\n-\t\t  print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n-\t\t}\n-\n-\t      result = get_lhs_or_phi_result (use_stmt);\n-\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n-\t      continue;\n-\t    }\n-\n-\t  /* From this point onward we are propagating into a\n-\t     real statement.  Folding may (or may not) be possible,\n-\t     we may expose new operands, expose dead EH edges,\n-\t     etc.  */\n-          /* NOTE tuples. In the tuples world, fold_stmt_inplace\n-             cannot fold a call that simplifies to a constant,\n-             because the GIMPLE_CALL must be replaced by a\n-             GIMPLE_ASSIGN, and there is no way to effect such a\n-             transformation in-place.  We might want to consider\n-             using the more general fold_stmt here.  */\n-\t    {\n-\t      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-\t      fold_stmt_inplace (&gsi);\n-\t    }\n-\n-\t  /* Sometimes propagation can expose new operands to the\n-\t     renamer.  */\n-\t  update_stmt (use_stmt);\n-\n-\t  /* Dump details.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"    Updated statement:\");\n-\t      print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n-\t    }\n-\n-\t  /* If we replaced a variable index with a constant, then\n-\t     we would need to update the invariant flag for ADDR_EXPRs.  */\n-          if (gimple_assign_single_p (use_stmt)\n-              && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr\n-                (gimple_assign_rhs1 (use_stmt));\n-\n-\t  /* If we cleaned up EH information from the statement,\n-\t     mark its containing block as needing EH cleanups.  */\n-\t  if (maybe_clean_or_replace_eh_stmt (use_stmt, use_stmt))\n-\t    {\n-\t      bitmap_set_bit (need_eh_cleanup, gimple_bb (use_stmt)->index);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  Flagged to clear EH edges.\\n\");\n-\t    }\n-\n-\t  /* Propagation may expose new trivial copy/constant propagation\n-\t     opportunities.  */\n-          if (gimple_assign_single_p (use_stmt)\n-              && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n-              && (TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n-                  || is_gimple_min_invariant (gimple_assign_rhs1 (use_stmt))))\n-            {\n-\t      tree result = get_lhs_or_phi_result (use_stmt);\n-\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n-\t    }\n-\n-\t  /* Propagation into these nodes may make certain edges in\n-\t     the CFG unexecutable.  We want to identify them as PHI nodes\n-\t     at the destination of those unexecutable edges may become\n-\t     degenerates.  */\n-\t  else if (gimple_code (use_stmt) == GIMPLE_COND\n-\t\t   || gimple_code (use_stmt) == GIMPLE_SWITCH\n-\t\t   || gimple_code (use_stmt) == GIMPLE_GOTO)\n-            {\n-\t      tree val;\n-\n-\t      if (gimple_code (use_stmt) == GIMPLE_COND)\n-                val = fold_binary_loc (gimple_location (use_stmt),\n-\t\t\t\t   gimple_cond_code (use_stmt),\n-                                   boolean_type_node,\n-                                   gimple_cond_lhs (use_stmt),\n-                                   gimple_cond_rhs (use_stmt));\n-              else if (gimple_code (use_stmt) == GIMPLE_SWITCH)\n-\t\tval = gimple_switch_index (as_a <gswitch *> (use_stmt));\n-\t      else\n-\t\tval = gimple_goto_dest  (use_stmt);\n-\n-\t      if (val && is_gimple_min_invariant (val))\n-\t\t{\n-\t\t  basic_block bb = gimple_bb (use_stmt);\n-\t\t  edge te = find_taken_edge (bb, val);\n-\t\t  if (!te)\n-\t\t    continue;\n-\n-\t\t  edge_iterator ei;\n-\t\t  edge e;\n-\t\t  gimple_stmt_iterator gsi;\n-\t\t  gphi_iterator psi;\n-\n-\t\t  /* Remove all outgoing edges except TE.  */\n-\t\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei));)\n-\t\t    {\n-\t\t      if (e != te)\n-\t\t\t{\n-\t\t\t  /* Mark all the PHI nodes at the destination of\n-\t\t\t     the unexecutable edge as interesting.  */\n-                          for (psi = gsi_start_phis (e->dest);\n-                               !gsi_end_p (psi);\n-                               gsi_next (&psi))\n-                            {\n-                              gphi *phi = psi.phi ();\n-\n-\t\t\t      tree result = gimple_phi_result (phi);\n-\t\t\t      int version = SSA_NAME_VERSION (result);\n-\n-\t\t\t      bitmap_set_bit (interesting_names, version);\n-\t\t\t    }\n-\n-\t\t\t  te->probability += e->probability;\n-\n-\t\t\t  te->count += e->count;\n-\t\t\t  remove_edge (e);\n-\t\t\t  cfg_altered = true;\n-\t\t\t}\n-\t\t      else\n-\t\t\tei_next (&ei);\n-\t\t    }\n-\n-\t\t  gsi = gsi_last_bb (gimple_bb (use_stmt));\n-\t\t  gsi_remove (&gsi, true);\n-\n-\t\t  /* And fixup the flags on the single remaining edge.  */\n-\t\t  te->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-\t\t  te->flags &= ~EDGE_ABNORMAL;\n-\t\t  te->flags |= EDGE_FALLTHRU;\n-\t\t  if (te->probability > REG_BR_PROB_BASE)\n-\t\t    te->probability = REG_BR_PROB_BASE;\n-\t        }\n-\t    }\n-\t}\n-\n-      /* Ensure there is nothing else to do. */\n-      gcc_assert (!all || has_zero_uses (lhs));\n-\n-      /* If we were able to propagate away all uses of LHS, then\n-\t we can remove STMT.  */\n-      if (all)\n-\tremove_stmt_or_phi (stmt);\n-    }\n-}\n-\n-/* STMT is either a PHI node (potentially a degenerate PHI node) or\n-   a statement that is a trivial copy or constant initialization.\n-\n-   Attempt to eliminate T by propagating its RHS into all uses of\n-   its LHS.  This may in turn set new bits in INTERESTING_NAMES\n-   for nodes we want to revisit later.\n-\n-   All exit paths should clear INTERESTING_NAMES for the result\n-   of STMT.  */\n-\n-static void\n-eliminate_const_or_copy (gimple stmt, bitmap interesting_names)\n-{\n-  tree lhs = get_lhs_or_phi_result (stmt);\n-  tree rhs;\n-  int version = SSA_NAME_VERSION (lhs);\n-\n-  /* If the LHS of this statement or PHI has no uses, then we can\n-     just eliminate it.  This can occur if, for example, the PHI\n-     was created by block duplication due to threading and its only\n-     use was in the conditional at the end of the block which was\n-     deleted.  */\n-  if (has_zero_uses (lhs))\n-    {\n-      bitmap_clear_bit (interesting_names, version);\n-      remove_stmt_or_phi (stmt);\n-      return;\n-    }\n-\n-  /* Get the RHS of the assignment or PHI node if the PHI is a\n-     degenerate.  */\n-  rhs = get_rhs_or_phi_arg (stmt);\n-  if (!rhs)\n-    {\n-      bitmap_clear_bit (interesting_names, version);\n-      return;\n-    }\n-\n-  if (!virtual_operand_p (lhs))\n-    propagate_rhs_into_lhs (stmt, lhs, rhs, interesting_names);\n-  else\n-    {\n-      gimple use_stmt;\n-      imm_use_iterator iter;\n-      use_operand_p use_p;\n-      /* For virtual operands we have to propagate into all uses as\n-         otherwise we will create overlapping life-ranges.  */\n-      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t  SET_USE (use_p, rhs);\n-      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n-\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;\n-      remove_stmt_or_phi (stmt);\n-    }\n-\n-  /* Note that STMT may well have been deleted by now, so do\n-     not access it, instead use the saved version # to clear\n-     T's entry in the worklist.  */\n-  bitmap_clear_bit (interesting_names, version);\n-}\n-\n-/* The first phase in degenerate PHI elimination.\n-\n-   Eliminate the degenerate PHIs in BB, then recurse on the\n-   dominator children of BB.  */\n-\n-static void\n-eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names)\n-{\n-  gphi_iterator gsi;\n-  basic_block son;\n-\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gphi *phi = gsi.phi ();\n-\n-      eliminate_const_or_copy (phi, interesting_names);\n-    }\n-\n-  /* Recurse into the dominator children of BB.  */\n-  for (son = first_dom_son (CDI_DOMINATORS, bb);\n-       son;\n-       son = next_dom_son (CDI_DOMINATORS, son))\n-    eliminate_degenerate_phis_1 (son, interesting_names);\n-}\n-\n-\n-/* A very simple pass to eliminate degenerate PHI nodes from the\n-   IL.  This is meant to be fast enough to be able to be run several\n-   times in the optimization pipeline.\n-\n-   Certain optimizations, particularly those which duplicate blocks\n-   or remove edges from the CFG can create or expose PHIs which are\n-   trivial copies or constant initializations.\n-\n-   While we could pick up these optimizations in DOM or with the\n-   combination of copy-prop and CCP, those solutions are far too\n-   heavy-weight for our needs.\n-\n-   This implementation has two phases so that we can efficiently\n-   eliminate the first order degenerate PHIs and second order\n-   degenerate PHIs.\n-\n-   The first phase performs a dominator walk to identify and eliminate\n-   the vast majority of the degenerate PHIs.  When a degenerate PHI\n-   is identified and eliminated any affected statements or PHIs\n-   are put on a worklist.\n-\n-   The second phase eliminates degenerate PHIs and trivial copies\n-   or constant initializations using the worklist.  This is how we\n-   pick up the secondary optimization opportunities with minimal\n-   cost.  */\n-\n-namespace {\n-\n-const pass_data pass_data_phi_only_cprop =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"phicprop\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_PHI_CPROP, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_phi_only_cprop : public gimple_opt_pass\n-{\n-public:\n-  pass_phi_only_cprop (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_dom != 0; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_phi_only_cprop\n-\n-unsigned int\n-pass_phi_only_cprop::execute (function *fun)\n-{\n-  bitmap interesting_names;\n-  bitmap interesting_names1;\n-\n-  /* Bitmap of blocks which need EH information updated.  We can not\n-     update it on-the-fly as doing so invalidates the dominator tree.  */\n-  need_eh_cleanup = BITMAP_ALLOC (NULL);\n-\n-  /* INTERESTING_NAMES is effectively our worklist, indexed by\n-     SSA_NAME_VERSION.\n-\n-     A set bit indicates that the statement or PHI node which\n-     defines the SSA_NAME should be (re)examined to determine if\n-     it has become a degenerate PHI or trivial const/copy propagation\n-     opportunity.\n-\n-     Experiments have show we generally get better compilation\n-     time behavior with bitmaps rather than sbitmaps.  */\n-  interesting_names = BITMAP_ALLOC (NULL);\n-  interesting_names1 = BITMAP_ALLOC (NULL);\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  cfg_altered = false;\n-\n-  /* First phase.  Eliminate degenerate PHIs via a dominator\n-     walk of the CFG.\n-\n-     Experiments have indicated that we generally get better\n-     compile-time behavior by visiting blocks in the first\n-     phase in dominator order.  Presumably this is because walking\n-     in dominator order leaves fewer PHIs for later examination\n-     by the worklist phase.  */\n-  eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (fun),\n-\t\t\t       interesting_names);\n-\n-  /* Second phase.  Eliminate second order degenerate PHIs as well\n-     as trivial copies or constant initializations identified by\n-     the first phase or this phase.  Basically we keep iterating\n-     until our set of INTERESTING_NAMEs is empty.   */\n-  while (!bitmap_empty_p (interesting_names))\n-    {\n-      unsigned int i;\n-      bitmap_iterator bi;\n-\n-      /* EXECUTE_IF_SET_IN_BITMAP does not like its bitmap\n-\t changed during the loop.  Copy it to another bitmap and\n-\t use that.  */\n-      bitmap_copy (interesting_names1, interesting_names);\n-\n-      EXECUTE_IF_SET_IN_BITMAP (interesting_names1, 0, i, bi)\n-\t{\n-\t  tree name = ssa_name (i);\n-\n-\t  /* Ignore SSA_NAMEs that have been released because\n-\t     their defining statement was deleted (unreachable).  */\n-\t  if (name)\n-\t    eliminate_const_or_copy (SSA_NAME_DEF_STMT (ssa_name (i)),\n-\t\t\t\t     interesting_names);\n-\t}\n-    }\n-\n-  if (cfg_altered)\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-      /* If we changed the CFG schedule loops for fixup by cfgcleanup.  */\n-      loops_state_set (LOOPS_NEED_FIXUP);\n-    }\n-\n-  /* Propagation of const and copies may make some EH edges dead.  Purge\n-     such edges from the CFG as needed.  */\n-  if (!bitmap_empty_p (need_eh_cleanup))\n-    {\n-      gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n-      BITMAP_FREE (need_eh_cleanup);\n-    }\n-\n-  BITMAP_FREE (interesting_names);\n-  BITMAP_FREE (interesting_names1);\n-  return 0;\n-}\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_phi_only_cprop (gcc::context *ctxt)\n-{\n-  return new pass_phi_only_cprop (ctxt);\n-}"}, {"sha": "2093273e57ca3189361c6a98819bd572a8f819f8", "filename": "gcc/tree-ssa-phionlycprop.c", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2Ftree-ssa-phionlycprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a502f7b6e47d3f790e01e91ab5c480ee4b261486/gcc%2Ftree-ssa-phionlycprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phionlycprop.c?ref=a502f7b6e47d3f790e01e91ab5c480ee4b261486", "patch": "@@ -0,0 +1,589 @@\n+/* Const/Copy propagation originating from degenerate PHIs\n+   Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"cfghooks.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"fold-const.h\"\n+#include \"cfgloop.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-ssa-propagate.h\"\n+\n+\n+/* PHI-ONLY copy and constant propagation.  This pass is meant to clean\n+   up degenerate PHIs created by or exposed by jump threading.  */\n+\n+/* Given a statement STMT, which is either a PHI node or an assignment,\n+   remove it from the IL.  */\n+\n+static void\n+remove_stmt_or_phi (gimple stmt)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    remove_phi_node (&gsi, true);\n+  else\n+    {\n+      gsi_remove (&gsi, true);\n+      release_defs (stmt);\n+    }\n+}\n+\n+/* Given a statement STMT, which is either a PHI node or an assignment,\n+   return the \"rhs\" of the node, in the case of a non-degenerate\n+   phi, NULL is returned.  */\n+\n+static tree\n+get_rhs_or_phi_arg (gimple stmt)\n+{\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    return degenerate_phi_result (as_a <gphi *> (stmt));\n+  else if (gimple_assign_single_p (stmt))\n+    return gimple_assign_rhs1 (stmt);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* Given a statement STMT, which is either a PHI node or an assignment,\n+   return the \"lhs\" of the node.  */\n+\n+static tree\n+get_lhs_or_phi_result (gimple stmt)\n+{\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    return gimple_phi_result (stmt);\n+  else if (is_gimple_assign (stmt))\n+    return gimple_assign_lhs (stmt);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Propagate RHS into all uses of LHS (when possible).\n+\n+   RHS and LHS are derived from STMT, which is passed in solely so\n+   that we can remove it if propagation is successful.\n+\n+   When propagating into a PHI node or into a statement which turns\n+   into a trivial copy or constant initialization, set the\n+   appropriate bit in INTERESTING_NAMEs so that we will visit those\n+   nodes as well in an effort to pick up secondary optimization\n+   opportunities. \n+\n+   NEED_EH_CLEANUP tracks blocks that need their EH information\n+   cleaned up after changing EH information on a statement.  */\n+\n+static bool\n+propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs,\n+\t\t\tbitmap interesting_names, bitmap need_eh_cleanup)\n+{\n+  bool cfg_altered = false;\n+\n+  /* First verify that propagation is valid.  */\n+  if (may_propagate_copy (lhs, rhs))\n+    {\n+      use_operand_p use_p;\n+      imm_use_iterator iter;\n+      gimple use_stmt;\n+      bool all = true;\n+\n+      /* Dump details.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  Replacing '\");\n+\t  print_generic_expr (dump_file, lhs, dump_flags);\n+\t  fprintf (dump_file, \"' with %s '\",\n+\t           (TREE_CODE (rhs) != SSA_NAME ? \"constant\" : \"variable\"));\n+\t\t   print_generic_expr (dump_file, rhs, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n+\n+      /* Walk over every use of LHS and try to replace the use with RHS.\n+\t At this point the only reason why such a propagation would not\n+\t be successful would be if the use occurs in an ASM_EXPR.  */\n+      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+\t{\n+\t  /* Leave debug stmts alone.  If we succeed in propagating\n+\t     all non-debug uses, we'll drop the DEF, and propagation\n+\t     into debug stmts will occur then.  */\n+\t  if (gimple_debug_bind_p (use_stmt))\n+\t    continue;\n+\n+\t  /* It's not always safe to propagate into an ASM_EXPR.  */\n+\t  if (gimple_code (use_stmt) == GIMPLE_ASM\n+              && ! may_propagate_copy_into_asm (lhs))\n+\t    {\n+\t      all = false;\n+\t      continue;\n+\t    }\n+\n+\t  /* It's not ok to propagate into the definition stmt of RHS.\n+\t\t<bb 9>:\n+\t\t  # prephitmp.12_36 = PHI <g_67.1_6(9)>\n+\t\t  g_67.1_6 = prephitmp.12_36;\n+\t\t  goto <bb 9>;\n+\t     While this is strictly all dead code we do not want to\n+\t     deal with this here.  */\n+\t  if (TREE_CODE (rhs) == SSA_NAME\n+\t      && SSA_NAME_DEF_STMT (rhs) == use_stmt)\n+\t    {\n+\t      all = false;\n+\t      continue;\n+\t    }\n+\n+\t  /* Dump details.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"    Original statement:\");\n+\t      print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n+\t    }\n+\n+\t  /* Propagate the RHS into this use of the LHS.  */\n+\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t    propagate_value (use_p, rhs);\n+\n+\t  /* Special cases to avoid useless calls into the folding\n+\t     routines, operand scanning, etc.\n+\n+\t     Propagation into a PHI may cause the PHI to become\n+\t     a degenerate, so mark the PHI as interesting.  No other\n+\t     actions are necessary.  */\n+\t  if (gimple_code (use_stmt) == GIMPLE_PHI)\n+\t    {\n+\t      tree result;\n+\n+\t      /* Dump details.  */\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"    Updated statement:\");\n+\t\t  print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n+\t\t}\n+\n+\t      result = get_lhs_or_phi_result (use_stmt);\n+\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n+\t      continue;\n+\t    }\n+\n+\t  /* From this point onward we are propagating into a\n+\t     real statement.  Folding may (or may not) be possible,\n+\t     we may expose new operands, expose dead EH edges,\n+\t     etc.  */\n+          /* NOTE tuples. In the tuples world, fold_stmt_inplace\n+             cannot fold a call that simplifies to a constant,\n+             because the GIMPLE_CALL must be replaced by a\n+             GIMPLE_ASSIGN, and there is no way to effect such a\n+             transformation in-place.  We might want to consider\n+             using the more general fold_stmt here.  */\n+\t    {\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\t      fold_stmt_inplace (&gsi);\n+\t    }\n+\n+\t  /* Sometimes propagation can expose new operands to the\n+\t     renamer.  */\n+\t  update_stmt (use_stmt);\n+\n+\t  /* Dump details.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"    Updated statement:\");\n+\t      print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n+\t    }\n+\n+\t  /* If we replaced a variable index with a constant, then\n+\t     we would need to update the invariant flag for ADDR_EXPRs.  */\n+          if (gimple_assign_single_p (use_stmt)\n+              && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr\n+                (gimple_assign_rhs1 (use_stmt));\n+\n+\t  /* If we cleaned up EH information from the statement,\n+\t     mark its containing block as needing EH cleanups.  */\n+\t  if (maybe_clean_or_replace_eh_stmt (use_stmt, use_stmt))\n+\t    {\n+\t      bitmap_set_bit (need_eh_cleanup, gimple_bb (use_stmt)->index);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Flagged to clear EH edges.\\n\");\n+\t    }\n+\n+\t  /* Propagation may expose new trivial copy/constant propagation\n+\t     opportunities.  */\n+          if (gimple_assign_single_p (use_stmt)\n+              && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n+              && (TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n+                  || is_gimple_min_invariant (gimple_assign_rhs1 (use_stmt))))\n+            {\n+\t      tree result = get_lhs_or_phi_result (use_stmt);\n+\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n+\t    }\n+\n+\t  /* Propagation into these nodes may make certain edges in\n+\t     the CFG unexecutable.  We want to identify them as PHI nodes\n+\t     at the destination of those unexecutable edges may become\n+\t     degenerates.  */\n+\t  else if (gimple_code (use_stmt) == GIMPLE_COND\n+\t\t   || gimple_code (use_stmt) == GIMPLE_SWITCH\n+\t\t   || gimple_code (use_stmt) == GIMPLE_GOTO)\n+            {\n+\t      tree val;\n+\n+\t      if (gimple_code (use_stmt) == GIMPLE_COND)\n+                val = fold_binary_loc (gimple_location (use_stmt),\n+\t\t\t\t   gimple_cond_code (use_stmt),\n+                                   boolean_type_node,\n+                                   gimple_cond_lhs (use_stmt),\n+                                   gimple_cond_rhs (use_stmt));\n+              else if (gimple_code (use_stmt) == GIMPLE_SWITCH)\n+\t\tval = gimple_switch_index (as_a <gswitch *> (use_stmt));\n+\t      else\n+\t\tval = gimple_goto_dest  (use_stmt);\n+\n+\t      if (val && is_gimple_min_invariant (val))\n+\t\t{\n+\t\t  basic_block bb = gimple_bb (use_stmt);\n+\t\t  edge te = find_taken_edge (bb, val);\n+\t\t  if (!te)\n+\t\t    continue;\n+\n+\t\t  edge_iterator ei;\n+\t\t  edge e;\n+\t\t  gimple_stmt_iterator gsi;\n+\t\t  gphi_iterator psi;\n+\n+\t\t  /* Remove all outgoing edges except TE.  */\n+\t\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei));)\n+\t\t    {\n+\t\t      if (e != te)\n+\t\t\t{\n+\t\t\t  /* Mark all the PHI nodes at the destination of\n+\t\t\t     the unexecutable edge as interesting.  */\n+                          for (psi = gsi_start_phis (e->dest);\n+                               !gsi_end_p (psi);\n+                               gsi_next (&psi))\n+                            {\n+                              gphi *phi = psi.phi ();\n+\n+\t\t\t      tree result = gimple_phi_result (phi);\n+\t\t\t      int version = SSA_NAME_VERSION (result);\n+\n+\t\t\t      bitmap_set_bit (interesting_names, version);\n+\t\t\t    }\n+\n+\t\t\t  te->probability += e->probability;\n+\n+\t\t\t  te->count += e->count;\n+\t\t\t  remove_edge (e);\n+\t\t\t  cfg_altered = true;\n+\t\t\t}\n+\t\t      else\n+\t\t\tei_next (&ei);\n+\t\t    }\n+\n+\t\t  gsi = gsi_last_bb (gimple_bb (use_stmt));\n+\t\t  gsi_remove (&gsi, true);\n+\n+\t\t  /* And fixup the flags on the single remaining edge.  */\n+\t\t  te->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\t\t  te->flags &= ~EDGE_ABNORMAL;\n+\t\t  te->flags |= EDGE_FALLTHRU;\n+\t\t  if (te->probability > REG_BR_PROB_BASE)\n+\t\t    te->probability = REG_BR_PROB_BASE;\n+\t        }\n+\t    }\n+\t}\n+\n+      /* Ensure there is nothing else to do. */\n+      gcc_assert (!all || has_zero_uses (lhs));\n+\n+      /* If we were able to propagate away all uses of LHS, then\n+\t we can remove STMT.  */\n+      if (all)\n+\tremove_stmt_or_phi (stmt);\n+    }\n+  return cfg_altered;\n+}\n+\n+/* STMT is either a PHI node (potentially a degenerate PHI node) or\n+   a statement that is a trivial copy or constant initialization.\n+\n+   Attempt to eliminate STMT by propagating its RHS into all uses of\n+   its LHS.  This may in turn set new bits in INTERESTING_NAMES\n+   for nodes we want to revisit later.\n+\n+   All exit paths should clear INTERESTING_NAMES for the result\n+   of STMT.\n+\n+   NEED_EH_CLEANUP tracks blocks that need their EH information\n+   cleaned up after changing EH information on a statement.  It is\n+   not set or queried here, but passed along to children.  */\n+\n+static bool\n+eliminate_const_or_copy (gimple stmt, bitmap interesting_names,\n+\t\t\t bitmap need_eh_cleanup)\n+{\n+  tree lhs = get_lhs_or_phi_result (stmt);\n+  tree rhs;\n+  int version = SSA_NAME_VERSION (lhs);\n+  bool cfg_altered = false;\n+\n+  /* If the LHS of this statement or PHI has no uses, then we can\n+     just eliminate it.  This can occur if, for example, the PHI\n+     was created by block duplication due to threading and its only\n+     use was in the conditional at the end of the block which was\n+     deleted.  */\n+  if (has_zero_uses (lhs))\n+    {\n+      bitmap_clear_bit (interesting_names, version);\n+      remove_stmt_or_phi (stmt);\n+      return cfg_altered;\n+    }\n+\n+  /* Get the RHS of the assignment or PHI node if the PHI is a\n+     degenerate.  */\n+  rhs = get_rhs_or_phi_arg (stmt);\n+  if (!rhs)\n+    {\n+      bitmap_clear_bit (interesting_names, version);\n+      return cfg_altered;\n+    }\n+\n+  if (!virtual_operand_p (lhs))\n+    cfg_altered = propagate_rhs_into_lhs (stmt, lhs, rhs,\n+\t\t\t\t\t  interesting_names, need_eh_cleanup);\n+  else\n+    {\n+      gimple use_stmt;\n+      imm_use_iterator iter;\n+      use_operand_p use_p;\n+      /* For virtual operands we have to propagate into all uses as\n+         otherwise we will create overlapping life-ranges.  */\n+      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t  SET_USE (use_p, rhs);\n+      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;\n+      remove_stmt_or_phi (stmt);\n+    }\n+\n+  /* Note that STMT may well have been deleted by now, so do\n+     not access it, instead use the saved version # to clear\n+     T's entry in the worklist.  */\n+  bitmap_clear_bit (interesting_names, version);\n+  return cfg_altered;\n+}\n+\n+/* The first phase in degenerate PHI elimination.\n+\n+   Eliminate the degenerate PHIs in BB, then recurse on the\n+   dominator children of BB. \n+\n+   INTERESTING_NAMES tracks SSA_NAMEs that we may want to revisit\n+   in the future.  It is not set or queried here, but passed along\n+   to children. \n+\n+   NEED_EH_CLEANUP tracks blocks that need their EH information\n+   cleaned up after changing EH information on a statement.  It is\n+   not set or queried here, but passed along to children.  */\n+\n+static bool\n+eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names,\n+\t\t\t     bitmap need_eh_cleanup)\n+{\n+  gphi_iterator gsi;\n+  basic_block son;\n+  bool cfg_altered = false;\n+\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+\n+      cfg_altered |= eliminate_const_or_copy (phi, interesting_names,\n+\t\t\t\t\t      need_eh_cleanup);\n+    }\n+\n+  /* Recurse into the dominator children of BB.  */\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    cfg_altered |= eliminate_degenerate_phis_1 (son, interesting_names,\n+\t\t\t\t\t\tneed_eh_cleanup);\n+\n+  return cfg_altered;\n+}\n+\n+\n+/* A very simple pass to eliminate degenerate PHI nodes from the\n+   IL.  This is meant to be fast enough to be able to be run several\n+   times in the optimization pipeline.\n+\n+   Certain optimizations, particularly those which duplicate blocks\n+   or remove edges from the CFG can create or expose PHIs which are\n+   trivial copies or constant initializations.\n+\n+   While we could pick up these optimizations in DOM or with the\n+   combination of copy-prop and CCP, those solutions are far too\n+   heavy-weight for our needs.\n+\n+   This implementation has two phases so that we can efficiently\n+   eliminate the first order degenerate PHIs and second order\n+   degenerate PHIs.\n+\n+   The first phase performs a dominator walk to identify and eliminate\n+   the vast majority of the degenerate PHIs.  When a degenerate PHI\n+   is identified and eliminated any affected statements or PHIs\n+   are put on a worklist.\n+\n+   The second phase eliminates degenerate PHIs and trivial copies\n+   or constant initializations using the worklist.  This is how we\n+   pick up the secondary optimization opportunities with minimal\n+   cost.  */\n+\n+namespace {\n+\n+const pass_data pass_data_phi_only_cprop =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"phicprop\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_PHI_CPROP, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */\n+};\n+\n+class pass_phi_only_cprop : public gimple_opt_pass\n+{\n+public:\n+  pass_phi_only_cprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_dom != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_phi_only_cprop\n+\n+unsigned int\n+pass_phi_only_cprop::execute (function *fun)\n+{\n+  bitmap interesting_names;\n+  bitmap interesting_names1;\n+  bool cfg_altered = false;\n+\n+  /* Bitmap of blocks which need EH information updated.  We can not\n+     update it on-the-fly as doing so invalidates the dominator tree.  */\n+  bitmap need_eh_cleanup = BITMAP_ALLOC (NULL);\n+\n+  /* INTERESTING_NAMES is effectively our worklist, indexed by\n+     SSA_NAME_VERSION.\n+\n+     A set bit indicates that the statement or PHI node which\n+     defines the SSA_NAME should be (re)examined to determine if\n+     it has become a degenerate PHI or trivial const/copy propagation\n+     opportunity.\n+\n+     Experiments have show we generally get better compilation\n+     time behavior with bitmaps rather than sbitmaps.  */\n+  interesting_names = BITMAP_ALLOC (NULL);\n+  interesting_names1 = BITMAP_ALLOC (NULL);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  cfg_altered = false;\n+\n+  /* First phase.  Eliminate degenerate PHIs via a dominator\n+     walk of the CFG.\n+\n+     Experiments have indicated that we generally get better\n+     compile-time behavior by visiting blocks in the first\n+     phase in dominator order.  Presumably this is because walking\n+     in dominator order leaves fewer PHIs for later examination\n+     by the worklist phase.  */\n+  cfg_altered = eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (fun),\n+\t\t\t\t\t     interesting_names,\n+\t\t\t\t\t     need_eh_cleanup);\n+\n+  /* Second phase.  Eliminate second order degenerate PHIs as well\n+     as trivial copies or constant initializations identified by\n+     the first phase or this phase.  Basically we keep iterating\n+     until our set of INTERESTING_NAMEs is empty.   */\n+  while (!bitmap_empty_p (interesting_names))\n+    {\n+      unsigned int i;\n+      bitmap_iterator bi;\n+\n+      /* EXECUTE_IF_SET_IN_BITMAP does not like its bitmap\n+\t changed during the loop.  Copy it to another bitmap and\n+\t use that.  */\n+      bitmap_copy (interesting_names1, interesting_names);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (interesting_names1, 0, i, bi)\n+\t{\n+\t  tree name = ssa_name (i);\n+\n+\t  /* Ignore SSA_NAMEs that have been released because\n+\t     their defining statement was deleted (unreachable).  */\n+\t  if (name)\n+\t    cfg_altered\n+\t      |= eliminate_const_or_copy (SSA_NAME_DEF_STMT (ssa_name (i)),\n+\t\t\t\t\t  interesting_names, need_eh_cleanup);\n+\t}\n+    }\n+\n+  if (cfg_altered)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      /* If we changed the CFG schedule loops for fixup by cfgcleanup.  */\n+      loops_state_set (LOOPS_NEED_FIXUP);\n+    }\n+\n+  /* Propagation of const and copies may make some EH edges dead.  Purge\n+     such edges from the CFG as needed.  */\n+  if (!bitmap_empty_p (need_eh_cleanup))\n+    {\n+      gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n+      BITMAP_FREE (need_eh_cleanup);\n+    }\n+\n+  BITMAP_FREE (interesting_names);\n+  BITMAP_FREE (interesting_names1);\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_phi_only_cprop (gcc::context *ctxt)\n+{\n+  return new pass_phi_only_cprop (ctxt);\n+}"}]}