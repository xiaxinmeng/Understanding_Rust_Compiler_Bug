{"sha": "99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkzNTNmY2ZlNGY1MGQxMzFmYWU5OTc4Y2U5Y2QxOWJjYWYyNDNjZg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:11:48Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:11:48Z"}, "message": "Rename get methods in symbol-summary.h to get_create.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* config/i386/i386.c (ix86_can_inline_p): Use get_create instead\n\tof get.\n\t* hsa-common.c (hsa_summary_t::link_functions): Likewise.\n\t(hsa_register_kernel): Likewise.\n\t* hsa-common.h (hsa_gpu_implementation_p): Likewise.\n\t* hsa-gen.c (hsa_get_host_function): Likewise.\n\t(get_brig_function_name): Likewise.\n\t(generate_hsa): Likewise.\n\t(pass_gen_hsail::execute): Likewise.\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Likewise.\n\t(devirtualization_time_bonus): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t* ipa-fnsummary.c (redirect_to_unreachable): Likewise.\n\t(edge_set_predicate): Likewise.\n\t(evaluate_conditions_for_known_args): Likewise.\n\t(evaluate_properties_for_edge): Likewise.\n\t(ipa_fn_summary::reset): Likewise.\n\t(ipa_fn_summary_t::duplicate): Likewise.\n\t(dump_ipa_call_summary): Likewise.\n\t(ipa_dump_fn_summary): Likewise.\n\t(analyze_function_body): Likewise.\n\t(compute_fn_summary): Likewise.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(estimate_edge_size_and_time): Likewise.\n\t(estimate_calls_size_and_time): Likewise.\n\t(estimate_node_size_and_time): Likewise.\n\t(inline_update_callee_summaries): Likewise.\n\t(remap_edge_change_prob): Likewise.\n\t(remap_edge_summaries): Likewise.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.\n\t(ipa_update_overall_fn_summary): Likewise.\n\t(read_ipa_call_summary): Likewise.\n\t(inline_read_section): Likewise.\n\t(write_ipa_call_summary): Likewise.\n\t(ipa_fn_summary_write): Likewise.\n\t(ipa_free_fn_summary): Likewise.\n\t* ipa-hsa.c (process_hsa_functions): Likewise.\n\t(ipa_hsa_write_summary): Likewise.\n\t(ipa_hsa_read_section): Likewise.\n\t* ipa-icf.c (sem_function::merge): Likewise.\n\t* ipa-inline-analysis.c (simple_edge_hints): Likewise.\n\t(do_estimate_edge_time): Likewise.\n\t(estimate_size_after_inlining): Likewise.\n\t(estimate_growth): Likewise.\n\t(growth_likely_positive): Likewise.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Likewise.\n\t(inline_call): Likewise.\n\t* ipa-inline.c (caller_growth_limits): Likewise.\n\t(can_inline_edge_p): Likewise.\n\t(can_inline_edge_by_limits_p): Likewise.\n\t(compute_uninlined_call_time): Likewise.\n\t(compute_inlined_call_time): Likewise.\n\t(want_inline_small_function_p): Likewise.\n\t(edge_badness): Likewise.\n\t(update_caller_keys): Likewise.\n\t(update_callee_keys): Likewise.\n\t(recursive_inlining): Likewise.\n\t(inline_small_functions): Likewise.\n\t(inline_to_all_callers_1): Likewise.\n\t(dump_overall_stats): Likewise.\n\t(early_inline_small_functions): Likewise.\n\t(early_inliner): Likewise.\n\t* ipa-inline.h (estimate_edge_growth): Likewise.\n\t* ipa-profile.c (ipa_propagate_frequency_1): Likewise.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n\t* ipa-prop.h (IPA_NODE_REF): Likewise.\n\t(IPA_EDGE_REF): Likewise.\n\t* ipa-pure-const.c (malloc_candidate_p): Likewise.\n\t(propagate_malloc): Likewise.\n\t* ipa-split.c (execute_split_functions): Likewise.\n\t* symbol-summary.h: Rename get to get_create.\n\t(get): Likewise.\n\t(get_create): Likewise.\n\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* lto-partition.c (add_symbol_to_partition_1): Use get_create instead\n\tof get.\n\t(undo_partition): Likewise.\n\t(lto_balanced_map): Likewise.\n\nFrom-SVN: r261309", "tree": {"sha": "fbbefc6f259347afb53703958f7a24081975a0cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbbefc6f259347afb53703958f7a24081975a0cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a281178f70c38d796c8ec77e049f8139e1110fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a281178f70c38d796c8ec77e049f8139e1110fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a281178f70c38d796c8ec77e049f8139e1110fc"}], "stats": {"total": 395, "additions": 246, "deletions": 149}, "files": [{"sha": "73260b62a003b11da47ee409f9e10a5d331ef370", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -1,3 +1,80 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* config/i386/i386.c (ix86_can_inline_p): Use get_create instead\n+\tof get.\n+\t* hsa-common.c (hsa_summary_t::link_functions): Likewise.\n+\t(hsa_register_kernel): Likewise.\n+\t* hsa-common.h (hsa_gpu_implementation_p): Likewise.\n+\t* hsa-gen.c (hsa_get_host_function): Likewise.\n+\t(get_brig_function_name): Likewise.\n+\t(generate_hsa): Likewise.\n+\t(pass_gen_hsail::execute): Likewise.\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Likewise.\n+\t(devirtualization_time_bonus): Likewise.\n+\t(ipcp_propagate_stage): Likewise.\n+\t* ipa-fnsummary.c (redirect_to_unreachable): Likewise.\n+\t(edge_set_predicate): Likewise.\n+\t(evaluate_conditions_for_known_args): Likewise.\n+\t(evaluate_properties_for_edge): Likewise.\n+\t(ipa_fn_summary::reset): Likewise.\n+\t(ipa_fn_summary_t::duplicate): Likewise.\n+\t(dump_ipa_call_summary): Likewise.\n+\t(ipa_dump_fn_summary): Likewise.\n+\t(analyze_function_body): Likewise.\n+\t(compute_fn_summary): Likewise.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(estimate_edge_size_and_time): Likewise.\n+\t(estimate_calls_size_and_time): Likewise.\n+\t(estimate_node_size_and_time): Likewise.\n+\t(inline_update_callee_summaries): Likewise.\n+\t(remap_edge_change_prob): Likewise.\n+\t(remap_edge_summaries): Likewise.\n+\t(ipa_merge_fn_summary_after_inlining): Likewise.\n+\t(ipa_update_overall_fn_summary): Likewise.\n+\t(read_ipa_call_summary): Likewise.\n+\t(inline_read_section): Likewise.\n+\t(write_ipa_call_summary): Likewise.\n+\t(ipa_fn_summary_write): Likewise.\n+\t(ipa_free_fn_summary): Likewise.\n+\t* ipa-hsa.c (process_hsa_functions): Likewise.\n+\t(ipa_hsa_write_summary): Likewise.\n+\t(ipa_hsa_read_section): Likewise.\n+\t* ipa-icf.c (sem_function::merge): Likewise.\n+\t* ipa-inline-analysis.c (simple_edge_hints): Likewise.\n+\t(do_estimate_edge_time): Likewise.\n+\t(estimate_size_after_inlining): Likewise.\n+\t(estimate_growth): Likewise.\n+\t(growth_likely_positive): Likewise.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Likewise.\n+\t(inline_call): Likewise.\n+\t* ipa-inline.c (caller_growth_limits): Likewise.\n+\t(can_inline_edge_p): Likewise.\n+\t(can_inline_edge_by_limits_p): Likewise.\n+\t(compute_uninlined_call_time): Likewise.\n+\t(compute_inlined_call_time): Likewise.\n+\t(want_inline_small_function_p): Likewise.\n+\t(edge_badness): Likewise.\n+\t(update_caller_keys): Likewise.\n+\t(update_callee_keys): Likewise.\n+\t(recursive_inlining): Likewise.\n+\t(inline_small_functions): Likewise.\n+\t(inline_to_all_callers_1): Likewise.\n+\t(dump_overall_stats): Likewise.\n+\t(early_inline_small_functions): Likewise.\n+\t(early_inliner): Likewise.\n+\t* ipa-inline.h (estimate_edge_growth): Likewise.\n+\t* ipa-profile.c (ipa_propagate_frequency_1): Likewise.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n+\t* ipa-prop.h (IPA_NODE_REF): Likewise.\n+\t(IPA_EDGE_REF): Likewise.\n+\t* ipa-pure-const.c (malloc_candidate_p): Likewise.\n+\t(propagate_malloc): Likewise.\n+\t* ipa-split.c (execute_split_functions): Likewise.\n+\t* symbol-summary.h: Rename get to get_create.\n+\t(get): Likewise.\n+\t(get_create): Likewise.\n+\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* symbol-summary.h (release): Move definition out of class"}, {"sha": "95cfa05ce61de210ac113d89f9094d97dd6e733a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -5789,7 +5789,7 @@ ix86_can_inline_p (tree caller, tree callee)\n \t      for multi-versioning call optimization, so beware of\n \t      ipa_fn_summaries not available.  */\n \t   && (! ipa_fn_summaries\n-\t       || ipa_fn_summaries->get\n+\t       || ipa_fn_summaries->get_create\n \t       (cgraph_node::get (callee))->fp_expressions))\n     ret = false;\n "}, {"sha": "0e18fa74a2c408f259dda0926a0ac5688d9917ad", "filename": "gcc/hsa-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fhsa-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fhsa-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -810,8 +810,8 @@ void\n hsa_summary_t::link_functions (cgraph_node *gpu, cgraph_node *host,\n \t\t\t       hsa_function_kind kind, bool gridified_kernel_p)\n {\n-  hsa_function_summary *gpu_summary = get (gpu);\n-  hsa_function_summary *host_summary = get (host);\n+  hsa_function_summary *gpu_summary = get_create (gpu);\n+  hsa_function_summary *host_summary = get_create (host);\n \n   gpu_summary->m_kind = kind;\n   host_summary->m_kind = kind;\n@@ -840,7 +840,7 @@ hsa_register_kernel (cgraph_node *host)\n {\n   if (hsa_summaries == NULL)\n     hsa_summaries = new hsa_summary_t (symtab);\n-  hsa_function_summary *s = hsa_summaries->get (host);\n+  hsa_function_summary *s = hsa_summaries->get_create (host);\n   s->m_kind = HSA_KERNEL;\n }\n "}, {"sha": "849363c7b4954efff169be47a3dfe860fa80d3e4", "filename": "gcc/hsa-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fhsa-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fhsa-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.h?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -1407,7 +1407,8 @@ hsa_gpu_implementation_p (tree decl)\n   if (hsa_summaries == NULL)\n     return false;\n \n-  hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (decl));\n+  hsa_function_summary *s\n+    = hsa_summaries->get_create (cgraph_node::get_create (decl));\n \n   return s->m_gpu_implementation_p;\n }"}, {"sha": "25d79c6419df78daeca94138a4f36be73d5acd8a", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -962,7 +962,7 @@ tree\n hsa_get_host_function (tree decl)\n {\n   hsa_function_summary *s\n-    = hsa_summaries->get (cgraph_node::get_create (decl));\n+    = hsa_summaries->get_create (cgraph_node::get_create (decl));\n   gcc_assert (s->m_kind != HSA_NONE);\n   gcc_assert (s->m_gpu_implementation_p);\n \n@@ -976,7 +976,8 @@ get_brig_function_name (tree decl)\n {\n   tree d = decl;\n \n-  hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (d));\n+  hsa_function_summary *s\n+    = hsa_summaries->get_create (cgraph_node::get_create (d));\n   if (s->m_kind != HSA_NONE\n       && s->m_gpu_implementation_p\n       && s->m_bound_function)\n@@ -6609,7 +6610,7 @@ generate_hsa (bool kernel)\n   if (hsa_cfun->m_kern_p)\n     {\n       hsa_function_summary *s\n-\t= hsa_summaries->get (cgraph_node::get (hsa_cfun->m_decl));\n+\t= hsa_summaries->get_create (cgraph_node::get (hsa_cfun->m_decl));\n       hsa_add_kern_decl_mapping (current_function_decl, hsa_cfun->m_name,\n \t\t\t\t hsa_cfun->m_maximum_omp_data_size,\n \t\t\t\t s->m_gridified_kernel_p);\n@@ -6679,8 +6680,8 @@ pass_gen_hsail::gate (function *f)\n unsigned int\n pass_gen_hsail::execute (function *)\n {\n-  hsa_function_summary *s\n-    = hsa_summaries->get (cgraph_node::get_create (current_function_decl));\n+  cgraph_node *node = cgraph_node::get_create (current_function_decl);\n+  hsa_function_summary *s = hsa_summaries->get_create (node);\n \n   expand_builtins ();\n   generate_hsa (s->m_kind == HSA_KERNEL);"}, {"sha": "35e7436b450c96a7c160b55c975f9fa54a1f9cfd", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -736,7 +736,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   init_caller_stats (&stats);\n   node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats, false);\n \n-  if (ipa_fn_summaries->get (node)->self_size < stats.n_calls)\n+  if (ipa_fn_summaries->get_create (node)->self_size < stats.n_calls)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n@@ -2583,7 +2583,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       callee = callee->function_symbol (&avail);\n       if (avail < AVAIL_AVAILABLE)\n \tcontinue;\n-      isummary = ipa_fn_summaries->get (callee);\n+      isummary = ipa_fn_summaries->get_create (callee);\n       if (!isummary->inlinable)\n \tcontinue;\n \n@@ -3288,7 +3288,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n \tinitialize_node_lattices (node);\n       }\n     if (node->definition && !node->alias)\n-      overall_size += ipa_fn_summaries->get (node)->self_size;\n+      overall_size += ipa_fn_summaries->get_create (node)->self_size;\n     max_count = max_count.max (node->count.ipa ());\n   }\n "}, {"sha": "8a6c5d0b5d8c2168c85319312d4724479b941394", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -241,7 +241,7 @@ redirect_to_unreachable (struct cgraph_edge *e)\n     e->make_direct (target);\n   else\n     e->redirect_callee (target);\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n   e->inline_failed = CIF_UNREACHABLE;\n   e->count = profile_count::zero ();\n   es->call_stmt_size = 0;\n@@ -266,7 +266,7 @@ edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n       && (!e->speculative || e->callee))\n     e = redirect_to_unreachable (e);\n \n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n   if (predicate && *predicate != true)\n     {\n       if (!es->predicate)\n@@ -328,7 +328,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n   clause_t nonspec_clause = 1 << predicate::not_inlined_condition;\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   int i;\n   struct condition *c;\n \n@@ -428,7 +428,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n \n@@ -445,7 +445,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n     {\n       struct ipa_node_params *caller_parms_info, *callee_pi;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->global.inlined_to)\n@@ -583,9 +583,9 @@ ipa_fn_summary::reset (struct cgraph_node *node)\n   vec_free (conds);\n   vec_free (size_time_table);\n   for (e = node->callees; e; e = e->next_callee)\n-    ipa_call_summaries->get (e)->reset ();\n+    ipa_call_summaries->get_create (e)->reset ();\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    ipa_call_summaries->get (e)->reset ();\n+    ipa_call_summaries->get_create (e)->reset ();\n   fp_expressions = false;\n }\n \n@@ -625,7 +625,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t\t\t     ipa_fn_summary *,\n \t\t\t     ipa_fn_summary *info)\n {\n-  memcpy (info, ipa_fn_summaries->get (src), sizeof (ipa_fn_summary));\n+  memcpy (info, ipa_fn_summaries->get_create (src), sizeof (ipa_fn_summary));\n   /* TODO: as an optimization, we may avoid copying conditions\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n@@ -700,7 +700,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->callees; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t  next = edge->next_callee;\n \n \t  if (!edge->inline_failed)\n@@ -719,7 +719,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t  next = edge->next_callee;\n \n \t  gcc_checking_assert (edge->inline_failed);\n@@ -813,7 +813,7 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n       struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n       int i;\n \n@@ -825,8 +825,9 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n \t       indent, \"\", es->loop_depth, edge->sreal_frequency ().to_double (),\n \t       es->call_stmt_size, es->call_stmt_time,\n-\t       (int) ipa_fn_summaries->get (callee)->size / ipa_fn_summary::size_scale,\n-\t       (int) ipa_fn_summaries->get (callee)->estimated_stack_size);\n+\t       (int) (ipa_fn_summaries->get_create (callee)->size\n+\t\t      / ipa_fn_summary::size_scale),\n+\t       (int) ipa_fn_summaries->get_create (callee)->estimated_stack_size);\n \n       if (es->predicate)\n \t{\n@@ -849,18 +850,19 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t  }\n       if (!edge->inline_failed)\n \t{\n+\t  ipa_fn_summary *s = ipa_fn_summaries->get_create (callee);\n \t  fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n \t\t   \" callee size %i\\n\",\n \t\t   indent + 2, \"\",\n-\t\t   (int) ipa_fn_summaries->get (callee)->stack_frame_offset,\n-\t\t   (int) ipa_fn_summaries->get (callee)->estimated_self_stack_size,\n-\t\t   (int) ipa_fn_summaries->get (callee)->estimated_stack_size);\n+\t\t   (int) s->stack_frame_offset,\n+\t\t   (int) s->estimated_self_stack_size,\n+\t\t   (int) s->estimated_stack_size);\n \t  dump_ipa_call_summary (f, indent + 2, callee, info);\n \t}\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n       fprintf (f, \"%*sindirect call loop depth:%2i freq:%4.2f size:%2i\"\n \t       \" time: %2i\",\n \t       indent, \"\",\n@@ -883,7 +885,7 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n {\n   if (node->definition)\n     {\n-      struct ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+      struct ipa_fn_summary *s = ipa_fn_summaries->get_create (node);\n       size_time_entry *e;\n       int i;\n       fprintf (f, \"IPA function summary for %s/%i\", node->name (),\n@@ -2009,7 +2011,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   basic_block bb;\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   sreal freq;\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n   vec<predicate> nonconstant_names = vNULL;\n@@ -2177,7 +2179,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      && !gimple_call_internal_p (stmt))\n \t    {\n \t      struct cgraph_edge *edge = node->get_edge (stmt);\n-\t      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t      ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \n \t      /* Special case: results of BUILT_IN_CONSTANT_P will be always\n \t         resolved as constant.  We however don't want to optimize\n@@ -2275,7 +2277,8 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t    }\n \t}\n     }\n-  set_hint_predicate (&ipa_fn_summaries->get (node)->array_index, array_index);\n+  set_hint_predicate (&ipa_fn_summaries->get_create (node)->array_index,\n+\t\t      array_index);\n   free (order);\n \n   if (nonconstant_names.exists () && !early)\n@@ -2360,9 +2363,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t    }\n \t  free (body);\n \t}\n-      set_hint_predicate (&ipa_fn_summaries->get (node)->loop_iterations,\n+      set_hint_predicate (&ipa_fn_summaries->get_create (node)->loop_iterations,\n \t\t\t  loop_iterations);\n-      set_hint_predicate (&ipa_fn_summaries->get (node)->loop_stride,\n+      set_hint_predicate (&ipa_fn_summaries->get_create (node)->loop_stride,\n \t\t\t  loop_stride);\n       scev_finalize ();\n     }\n@@ -2381,8 +2384,8 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  e->aux = NULL;\n \t}\n     }\n-  ipa_fn_summaries->get (node)->time = time;\n-  ipa_fn_summaries->get (node)->self_size = size;\n+  ipa_fn_summaries->get_create (node)->time = time;\n+  ipa_fn_summaries->get_create (node)->self_size = size;\n   nonconstant_names.release ();\n   ipa_release_body_info (&fbi);\n   if (opt_for_fn (node->decl, optimize))\n@@ -2416,7 +2419,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   if (!ipa_fn_summaries)\n     ipa_fn_summary_alloc ();\n \n-  info = ipa_fn_summaries->get (node);\n+  info = ipa_fn_summaries->get_create (node);\n   info->reset (node);\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n@@ -2428,7 +2431,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n \n   if (node->thunk.thunk_p)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (node->callees);\n+      ipa_call_summary *es = ipa_call_summaries->get_create (node->callees);\n       predicate t = true;\n \n       node->local.can_change_signature = false;\n@@ -2572,7 +2575,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   callee = callee->function_symbol (&avail);\n   if (avail < AVAIL_AVAILABLE)\n     return false;\n-  isummary = ipa_fn_summaries->get (callee);\n+  isummary = ipa_fn_summaries->get_create (callee);\n   return isummary->inlinable;\n }\n \n@@ -2591,7 +2594,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     ipa_hints *hints)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n   int call_size = es->call_stmt_size;\n   int call_time = es->call_stmt_time;\n   int cur_size;\n@@ -2628,7 +2631,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n \n       /* Do not care about zero sized builtins.  */\n       if (e->inline_failed && !es->call_stmt_size)\n@@ -2659,7 +2662,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n       if (!es->predicate\n \t  || es->predicate->evaluate (possible_truths))\n \testimate_edge_size_and_time (e, size,\n@@ -2694,7 +2697,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n {\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   size_time_entry *e;\n   int size = 0;\n   sreal time = 0;\n@@ -2848,26 +2851,29 @@ static void\n inline_update_callee_summaries (struct cgraph_node *node, int depth)\n {\n   struct cgraph_edge *e;\n-  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (node);\n-  struct ipa_fn_summary *caller_info = ipa_fn_summaries->get (node->callers->caller);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (node);\n+  ipa_fn_summary *caller_info\n+    = ipa_fn_summaries->get_create (node->callers->caller);\n   HOST_WIDE_INT peak;\n \n   callee_info->stack_frame_offset\n     = caller_info->stack_frame_offset\n     + caller_info->estimated_self_stack_size;\n   peak = callee_info->stack_frame_offset\n     + callee_info->estimated_self_stack_size;\n-  if (ipa_fn_summaries->get (node->global.inlined_to)->estimated_stack_size < peak)\n-      ipa_fn_summaries->get (node->global.inlined_to)->estimated_stack_size = peak;\n+\n+  ipa_fn_summary *s = ipa_fn_summaries->get_create (node->global.inlined_to);\n+  if (s->estimated_stack_size < peak)\n+    s->estimated_stack_size = peak;\n   ipa_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       if (!e->inline_failed)\n \tinline_update_callee_summaries (e->callee, depth);\n-      ipa_call_summaries->get (e)->loop_depth += depth;\n+      ipa_call_summaries->get_create (e)->loop_depth += depth;\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    ipa_call_summaries->get (e)->loop_depth += depth;\n+    ipa_call_summaries->get_create (e)->loop_depth += depth;\n }\n \n /* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n@@ -2884,9 +2890,9 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n     {\n       int i;\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n-      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n       struct ipa_call_summary *inlined_es\n-\t= ipa_call_summaries->get (inlined_edge);\n+\t= ipa_call_summaries->get_create (inlined_edge);\n \n       for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n \t{\n@@ -2933,7 +2939,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -2959,7 +2965,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n     }\n   for (e = node->indirect_calls; e; e = next)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -3009,18 +3015,18 @@ remap_hint_predicate (struct ipa_fn_summary *info,\n void\n ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n {\n-  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (edge->callee);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (edge->callee);\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (to);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (to);\n   clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   vec<int> operand_map = vNULL;\n   vec<int> offset_map = vNULL;\n   int i;\n   predicate toplev_predicate;\n   predicate true_p = true;\n-  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n@@ -3109,8 +3115,8 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t\t\t&callee_info->array_index,\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n-  inline_update_callee_summaries (edge->callee,\n-\t\t\t\t  ipa_call_summaries->get (edge)->loop_depth);\n+  ipa_call_summary *s = ipa_call_summaries->get_create (edge);\n+  inline_update_callee_summaries (edge->callee, s->loop_depth);\n \n   /* We do not maintain predicates of inlined edges, free it.  */\n   edge_set_predicate (edge, &true_p);\n@@ -3126,7 +3132,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n void\n ipa_update_overall_fn_summary (struct cgraph_node *node)\n {\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   size_time_entry *e;\n   int i;\n \n@@ -3224,7 +3230,7 @@ ipa_fn_summary_generate (void)\n static void\n read_ipa_call_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n   predicate p;\n   int length, i;\n \n@@ -3283,7 +3289,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       encoder = file_data->symtab_node_encoder;\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n-      info = ipa_fn_summaries->get (node);\n+      info = ipa_fn_summaries->get_create (node);\n \n       info->estimated_stack_size\n \t= info->estimated_self_stack_size = streamer_read_uhwi (&ib);\n@@ -3384,7 +3390,7 @@ ipa_fn_summary_read (void)\n static void\n write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n   int i;\n \n   streamer_write_uhwi (ob, es->call_stmt_size);\n@@ -3432,7 +3438,7 @@ ipa_fn_summary_write (void)\n       cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n-\t  struct ipa_fn_summary *info = ipa_fn_summaries->get (cnode);\n+\t  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (cnode);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;\n@@ -3507,7 +3513,7 @@ ipa_free_fn_summary (void)\n     return;\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n-      ipa_fn_summaries->get (node)->reset (node);\n+      ipa_fn_summaries->get_create (node)->reset (node);\n   ipa_fn_summaries->release ();\n   ipa_fn_summaries = NULL;\n   ipa_call_summaries->release ();"}, {"sha": "bd19cbbf460e7ab5c72ba244280549e5e4b8f64d", "filename": "gcc/ipa-hsa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-hsa.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -76,7 +76,7 @@ process_hsa_functions (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      hsa_function_summary *s = hsa_summaries->get (node);\n+      hsa_function_summary *s = hsa_summaries->get_create (node);\n \n       /* A linked function is skipped.  */\n       if (s->m_bound_function != NULL)\n@@ -130,10 +130,10 @@ process_hsa_functions (void)\n \n       while (e)\n \t{\n-\t  hsa_function_summary *src = hsa_summaries->get (node);\n+\t  hsa_function_summary *src = hsa_summaries->get_create (node);\n \t  if (src->m_kind != HSA_NONE && src->m_gpu_implementation_p)\n \t    {\n-\t      hsa_function_summary *dst = hsa_summaries->get (e->callee);\n+\t      hsa_function_summary *dst = hsa_summaries->get_create (e->callee);\n \t      if (dst->m_kind != HSA_NONE && !dst->m_gpu_implementation_p)\n \t\t{\n \t\t  e->redirect_callee (dst->m_bound_function);\n@@ -174,7 +174,7 @@ ipa_hsa_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      hsa_function_summary *s = hsa_summaries->get (node);\n+      hsa_function_summary *s = hsa_summaries->get_create (node);\n \n       if (s->m_kind != HSA_NONE)\n \tcount++;\n@@ -187,7 +187,7 @@ ipa_hsa_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      hsa_function_summary *s = hsa_summaries->get (node);\n+      hsa_function_summary *s = hsa_summaries->get_create (node);\n \n       if (s->m_kind != HSA_NONE)\n \t{\n@@ -244,7 +244,7 @@ ipa_hsa_read_section (struct lto_file_decl_data *file_data, const char *data,\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n       gcc_assert (node->definition);\n-      hsa_function_summary *s = hsa_summaries->get (node);\n+      hsa_function_summary *s = hsa_summaries->get_create (node);\n \n       struct bitpack_d bp = streamer_read_bitpack (&ib_main);\n       s->m_kind = (hsa_function_kind) bp_unpack_value (&bp, 2);"}, {"sha": "bededc3bbd5cd9b8956911cd4c3a3e6104ca0d27", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -1199,7 +1199,7 @@ sem_function::merge (sem_item *alias_item)\n \t\t     \"can not create wrapper of stdarg function.\\n\");\n \t}\n       else if (ipa_fn_summaries\n-\t       && ipa_fn_summaries->get (alias)->self_size <= 2)\n+\t       && ipa_fn_summaries->get_create (alias)->self_size <= 2)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Wrapper creation is not \""}, {"sha": "c4f904730e6f881f9f16aed4f4403744a118d7b2", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -125,9 +125,9 @@ simple_edge_hints (struct cgraph_edge *edge)\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  if (ipa_fn_summaries->get (to)->scc_no\n-      && ipa_fn_summaries->get (to)->scc_no\n-\t == ipa_fn_summaries->get (callee)->scc_no\n+  if (ipa_fn_summaries->get_create (to)->scc_no\n+      && ipa_fn_summaries->get_create (to)->scc_no\n+\t == ipa_fn_summaries->get_create (callee)->scc_no\n       && !edge->recursive_p ())\n     hints |= INLINE_HINT_same_scc;\n \n@@ -157,7 +157,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n-  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n   int min_size;\n \n   callee = edge->callee->ultimate_alias_target ();\n@@ -190,7 +190,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache.exists ())\n     {\n-      ipa_fn_summaries->get (edge->callee)->min_size = min_size;\n+      ipa_fn_summaries->get_create (edge->callee)->min_size = min_size;\n       if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n       edge_growth_cache[edge->uid].time = time;\n@@ -293,14 +293,15 @@ int\n estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+  ipa_fn_summary *s = ipa_fn_summaries->get_create (node);\n   if (!es->predicate || *es->predicate != false)\n     {\n-      int size = ipa_fn_summaries->get (node)->size + estimate_edge_growth (edge);\n+      int size = s->size + estimate_edge_growth (edge);\n       gcc_assert (size >= 0);\n       return size;\n     }\n-  return ipa_fn_summaries->get (node)->size;\n+  return s->size;\n }\n \n \n@@ -349,7 +350,7 @@ int\n estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, false, false, 0 };\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n \n   node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n \n@@ -424,7 +425,7 @@ growth_likely_positive (struct cgraph_node *node,\n       || node->address_taken)\n     return true;\n \n-  max_callers = ipa_fn_summaries->get (node)->size * 4 / edge_growth + 2;\n+  max_callers = ipa_fn_summaries->get_create (node)->size * 4 / edge_growth + 2;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {"}, {"sha": "6a3b5291c139f81c9f1426dfd7f094b269177d77", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -200,7 +200,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    {\n \t      gcc_assert (!e->callee->alias);\n \t      if (overall_size)\n-\t        *overall_size -= ipa_fn_summaries->get (e->callee)->size;\n+\t\t*overall_size -= ipa_fn_summaries->get_create (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n@@ -351,8 +351,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n       reload_optimization_node = true;\n     }\n \n-  ipa_fn_summary *caller_info = ipa_fn_summaries->get (to);\n-  ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n+  ipa_fn_summary *caller_info = ipa_fn_summaries->get_create (to);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (callee);\n   if (!caller_info->fp_expressions && callee_info->fp_expressions)\n     {\n       caller_info->fp_expressions = true;\n@@ -444,7 +444,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n \n-  old_size = ipa_fn_summaries->get (to)->size;\n+  old_size = ipa_fn_summaries->get_create (to)->size;\n   ipa_merge_fn_summary_after_inlining (e);\n   if (e->in_polymorphic_cdtor)\n     mark_all_inlined_calls_cdtor (e->callee);\n@@ -458,8 +458,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n        work for further inlining into this function.  Before inlining\n        the function we inlined to again we expect the caller to update\n        the overall summary.  */\n-    ipa_fn_summaries->get (to)->size += estimated_growth;\n-  new_size = ipa_fn_summaries->get (to)->size;\n+    ipa_fn_summaries->get_create (to)->size += estimated_growth;\n+  new_size = ipa_fn_summaries->get_create (to)->size;\n \n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;"}, {"sha": "ffde9b9c472e7bc359df1e5cd90e9a676a9bca50", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -150,7 +150,8 @@ caller_growth_limits (struct cgraph_edge *e)\n   int newsize;\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n-  ipa_fn_summary *info, *what_info, *outer_info = ipa_fn_summaries->get (to);\n+  ipa_fn_summary *info, *what_info;\n+  ipa_fn_summary *outer_info = ipa_fn_summaries->get_create (to);\n \n   /* Look for function e->caller is inlined to.  While doing\n      so work out the largest function body on the way.  As\n@@ -162,7 +163,7 @@ caller_growth_limits (struct cgraph_edge *e)\n      too much in order to prevent compiler from exploding\".  */\n   while (true)\n     {\n-      info = ipa_fn_summaries->get (to);\n+      info = ipa_fn_summaries->get_create (to);\n       if (limit < info->self_size)\n \tlimit = info->self_size;\n       if (stack_size_limit < info->estimated_self_stack_size)\n@@ -173,7 +174,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \tbreak;\n     }\n \n-  what_info = ipa_fn_summaries->get (what);\n+  what_info = ipa_fn_summaries->get_create (what);\n \n   if (limit < what_info->self_size)\n     limit = what_info->self_size;\n@@ -363,7 +364,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n-  else if (!ipa_fn_summaries->get (callee)->inlinable)\n+  else if (!ipa_fn_summaries->get_create (callee)->inlinable)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       inlinable = false;\n@@ -425,8 +426,8 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t     (DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t      && lookup_attribute (\"always_inline\",\n \t\t\t\t   DECL_ATTRIBUTES (callee->decl)));\n-      ipa_fn_summary *caller_info = ipa_fn_summaries->get (caller);\n-      ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n+      ipa_fn_summary *caller_info = ipa_fn_summaries->get_create (caller);\n+      ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (callee);\n \n      /* Until GCC 4.9 we did not check the semantics alterning flags\n \tbellow and inline across optimization boundry.\n@@ -529,7 +530,7 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t\t   > opt_for_fn (caller->decl, optimize)))\n \t{\n \t  if (estimate_edge_time (e)\n-\t      >= 20 + ipa_call_summaries->get (e)->call_stmt_time)\n+\t      >= 20 + ipa_call_summaries->get_create (e)->call_stmt_time)\n \t    {\n \t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t      inlinable = false;\n@@ -679,7 +680,7 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n   else\n     uninlined_call_time = uninlined_call_time >> 11;\n \n-  sreal caller_time = ipa_fn_summaries->get (caller)->time;\n+  sreal caller_time = ipa_fn_summaries->get_create (caller)->time;\n   return uninlined_call_time + caller_time;\n }\n \n@@ -693,7 +694,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n-  sreal caller_time = ipa_fn_summaries->get (caller)->time;\n+  sreal caller_time = ipa_fn_summaries->get_create (caller)->time;\n \n   sreal freq = edge->sreal_frequency ();\n   if (freq > 0)\n@@ -703,7 +704,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n \n   /* This calculation should match one in ipa-inline-analysis.c\n      (estimate_edge_size_and_time).  */\n-  time -= (sreal)ipa_call_summaries->get (edge)->call_stmt_time * freq;\n+  time -= (sreal)ipa_call_summaries->get_create (edge)->call_stmt_time * freq;\n   time += caller_time;\n   if (time <= 0)\n     time = ((sreal) 1) >> 8;\n@@ -755,17 +756,17 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && (!e->count.ipa ().initialized_p () || !e->maybe_hot_p ()))\n-\t   && ipa_fn_summaries->get (callee)->min_size\n-\t\t- ipa_call_summaries->get (e)->call_stmt_size\n+\t   && ipa_fn_summaries->get_create (callee)->min_size\n+\t\t- ipa_call_summaries->get_create (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl)\n \t    || e->count.ipa ().nonzero_p ())\n-\t   && ipa_fn_summaries->get (callee)->min_size\n-\t\t- ipa_call_summaries->get (e)->call_stmt_size\n+\t   && ipa_fn_summaries->get_create (callee)->min_size\n+\t\t- ipa_call_summaries->get_create (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n     {\n       e->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n@@ -1017,7 +1018,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   int growth;\n   sreal edge_time, unspec_edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n+  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get_create (callee);\n   ipa_hints hints;\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n@@ -1130,7 +1131,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n \t{\n-\t  struct ipa_fn_summary *caller_info = ipa_fn_summaries->get (caller);\n+\t  ipa_fn_summary *caller_info = ipa_fn_summaries->get_create (caller);\n \t  int caller_growth = caller_info->growth;\n \n \t  /* Only apply the penalty when caller looks like inline candidate,\n@@ -1189,7 +1190,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      of functions fully inlined in program.  */\n   else\n     {\n-      int nest = MIN (ipa_call_summaries->get (edge)->loop_depth, 8);\n+      int nest = MIN (ipa_call_summaries->get_create (edge)->loop_depth, 8);\n       badness = growth;\n \n       /* Decrease badness if call is nested.  */\n@@ -1332,7 +1333,7 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   struct ipa_ref *ref;\n \n-  if ((!node->alias && !ipa_fn_summaries->get (node)->inlinable)\n+  if ((!node->alias && !ipa_fn_summaries->get_create (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n@@ -1391,7 +1392,7 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n            don't need updating.  */\n \tif (e->inline_failed\n \t    && (callee = e->callee->ultimate_alias_target (&avail, e->caller))\n-\t    && ipa_fn_summaries->get (callee)->inlinable\n+\t    && ipa_fn_summaries->get_create (callee)->inlinable\n \t    && avail >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, callee->uid))\n \t  {\n@@ -1558,10 +1559,10 @@ recursive_inlining (struct cgraph_edge *edge,\n     fprintf (dump_file,\n \t     \"\\n   Inlined %i times, \"\n \t     \"body grown from size %i to %i, time %f to %f\\n\", n,\n-\t     ipa_fn_summaries->get (master_clone)->size,\n-\t     ipa_fn_summaries->get (node)->size,\n-\t     ipa_fn_summaries->get (master_clone)->time.to_double (),\n-\t     ipa_fn_summaries->get (node)->time.to_double ());\n+\t     ipa_fn_summaries->get_create (master_clone)->size,\n+\t     ipa_fn_summaries->get_create (node)->size,\n+\t     ipa_fn_summaries->get_create (master_clone)->time.to_double (),\n+\t     ipa_fn_summaries->get_create (node)->time.to_double ());\n \n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n@@ -1763,7 +1764,7 @@ inline_small_functions (void)\n \t    && (node->has_gimple_body_p () || node->thunk.thunk_p)\n \t    && opt_for_fn (node->decl, optimize))\n \t  {\n-\t    struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+\t    struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n \t    /* Do not account external functions, they will be optimized out\n@@ -1785,7 +1786,7 @@ inline_small_functions (void)\n \t\t     n2 = ((struct ipa_dfs_info *) n2->aux)->next_cycle)\n \t\t  if (opt_for_fn (n2->decl, optimize))\n \t\t    {\n-\t\t      struct ipa_fn_summary *info2 = ipa_fn_summaries->get (n2);\n+\t\t      ipa_fn_summary *info2 = ipa_fn_summaries->get_create (n2);\n \t\t      if (info2->scc_no)\n \t\t\tbreak;\n \t\t      info2->scc_no = id;\n@@ -1944,7 +1945,7 @@ inline_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s with %i size\\n\",\n \t\t   callee->dump_name (),\n-\t\t   ipa_fn_summaries->get (callee)->size);\n+\t\t   ipa_fn_summaries->get_create (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n@@ -2070,13 +2071,14 @@ inline_small_functions (void)\n \n       if (dump_file)\n \t{\n+\t  ipa_fn_summary *s = ipa_fn_summaries->get_create (edge->caller);\n \t  fprintf (dump_file,\n \t\t   \" Inlined %s into %s which now has time %f and size %i, \"\n \t\t   \"net change of %+i.\\n\",\n \t\t   xstrdup_for_dump (edge->callee->name ()),\n \t\t   xstrdup_for_dump (edge->caller->name ()),\n-\t\t   ipa_fn_summaries->get (edge->caller)->time.to_double (),\n-\t\t   ipa_fn_summaries->get (edge->caller)->size,\n+\t\t   s->time.to_double (),\n+\t\t   s->size,\n \t\t   overall_size - old_size);\n \t}\n       if (min_size > overall_size)\n@@ -2211,11 +2213,11 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \t  fprintf (dump_file,\n \t\t   \"\\nInlining %s size %i.\\n\",\n \t\t   node->name (),\n-\t\t   ipa_fn_summaries->get (node)->size);\n+\t\t   ipa_fn_summaries->get_create (node)->size);\n \t  fprintf (dump_file,\n \t\t   \" Called once from %s %i insns.\\n\",\n \t\t   node->callers->caller->name (),\n-\t\t   ipa_fn_summaries->get (node->callers->caller)->size);\n+\t\t   ipa_fn_summaries->get_create (node->callers->caller)->size);\n \t}\n \n       /* Remember which callers we inlined to, delaying updating the\n@@ -2226,7 +2228,7 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \tfprintf (dump_file,\n \t\t \" Inlined into %s which now has %i size\\n\",\n \t\t caller->name (),\n-\t\t ipa_fn_summaries->get (caller)->size);\n+\t\t ipa_fn_summaries->get_create (caller)->size);\n       if (!(*num_calls)--)\n \t{\n \t  if (dump_file)\n@@ -2267,7 +2269,7 @@ dump_overall_stats (void)\n     if (!node->global.inlined_to\n \t&& !node->alias)\n       {\n-\tsreal time = ipa_fn_summaries->get (node)->time;\n+\tsreal time = ipa_fn_summaries->get_create (node)->time;\n \tsum += time;\n \tif (node->count.ipa ().initialized_p ())\n \t  sum_weighted += time * node->count.ipa ().to_gcov_type ();\n@@ -2646,7 +2648,7 @@ early_inline_small_functions (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-      if (!ipa_fn_summaries->get (callee)->inlinable\n+      if (!ipa_fn_summaries->get_create (callee)->inlinable\n \t  || !e->inline_failed)\n \tcontinue;\n \n@@ -2756,7 +2758,7 @@ early_inliner (function *fun)\n \t     statements that don't have inline parameters computed.  */\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n-\t      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t      ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t      es->call_stmt_size\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n \t      es->call_stmt_time\n@@ -2781,7 +2783,7 @@ early_inliner (function *fun)\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n \t      /* We have no summary for new bound store calls yet.  */\n-\t      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t      ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t      es->call_stmt_size\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n \t      es->call_stmt_time"}, {"sha": "e8ae206d7b7e1dfa29e99f71bf03e2bbf4e8ec7c", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -81,10 +81,10 @@ estimate_edge_size (struct cgraph_edge *edge)\n static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n-  gcc_checking_assert (ipa_call_summaries->get (edge)->call_stmt_size\n+  gcc_checking_assert (ipa_call_summaries->get_create (edge)->call_stmt_size\n \t\t       || !edge->callee->analyzed);\n   return (estimate_edge_size (edge)\n-\t  - ipa_call_summaries->get (edge)->call_stmt_size);\n+\t  - ipa_call_summaries->get_create (edge)->call_stmt_size);\n }\n \n /* Return estimated callee runtime increase after inlining"}, {"sha": "7500f5438e825a59fa86deea20e361912b3e4078", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -349,7 +349,7 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n \t\t     edge->caller->name ());\n \t  d->maybe_unlikely_executed = false;\n-\t  if (ipa_call_summaries->get (edge)->loop_depth)\n+\t  if (ipa_call_summaries->get_create (edge)->loop_depth)\n \t    {\n \t      d->maybe_executed_once = false;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "c725b30c33de1ab6ab20a6bf20110f2d3c030e81", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -2818,7 +2818,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t\t\t\tbool speculative)\n {\n   struct cgraph_node *callee;\n-  struct ipa_call_summary *es = ipa_call_summaries->get (ie);\n+  struct ipa_call_summary *es = ipa_call_summaries->get_create (ie);\n   bool unreachable = false;\n \n   if (TREE_CODE (target) == ADDR_EXPR)\n@@ -2956,7 +2956,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t for direct call (adjusted by inline_edge_duplication_hook).  */\n       if (ie == orig)\n \t{\n-\t  es = ipa_call_summaries->get (ie);\n+\t  es = ipa_call_summaries->get_create (ie);\n \t  es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n \t\t\t\t - eni_size_weights.call_cost);\n \t  es->call_stmt_time -= (eni_time_weights.indirect_call_cost"}, {"sha": "6fd3159826125b0134b620565efcf5e6e7efbc9e", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -654,8 +654,8 @@ extern GTY(()) vec<ipcp_transformation_summary, va_gc> *ipcp_transformations;\n \n /* Return the associated parameter/argument info corresponding to the given\n    node/edge.  */\n-#define IPA_NODE_REF(NODE) (ipa_node_params_sum->get (NODE))\n-#define IPA_EDGE_REF(EDGE) (ipa_edge_args_sum->get (EDGE))\n+#define IPA_NODE_REF(NODE) (ipa_node_params_sum->get_create (NODE))\n+#define IPA_EDGE_REF(EDGE) (ipa_edge_args_sum->get_create (EDGE))\n /* This macro checks validity of index returned by\n    ipa_get_param_decl_index function.  */\n #define IS_VALID_JUMP_FUNC_INDEX(I) ((I) != -1)"}, {"sha": "a704329d7a1c8c2c0685f808136f65e2511529fe", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -954,7 +954,7 @@ malloc_candidate_p (function *fun, bool ipa)\n \t  cgraph_edge *cs = node->get_edge (call_stmt);\n \t  if (cs)\n \t    {\n-\t      ipa_call_summary *es = ipa_call_summaries->get (cs);\n+\t      ipa_call_summary *es = ipa_call_summaries->get_create (cs);\n \t      gcc_assert (es);\n \t      es->is_return_callee_uncaptured = true;\n \t    }\n@@ -990,7 +990,7 @@ malloc_candidate_p (function *fun, bool ipa)\n \t      cgraph_edge *cs = node->get_edge (call_stmt);\n \t      if (cs)\n \t\t{\n-\t\t  ipa_call_summary *es = ipa_call_summaries->get (cs);\n+\t\t  ipa_call_summary *es = ipa_call_summaries->get_create (cs);\n \t\t  gcc_assert (es);\n \t\t  es->is_return_callee_uncaptured = true;\n \t\t}\n@@ -1950,7 +1950,7 @@ propagate_malloc (void)\n \t  vec<cgraph_node *> callees = vNULL;\n \t  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n \t    {\n-\t      ipa_call_summary *es = ipa_call_summaries->get (cs);\n+\t      ipa_call_summary *es = ipa_call_summaries->get_create (cs);\n \t      if (es && es->is_return_callee_uncaptured)\n \t\tcallees.safe_push (cs->callee);\n \t    }"}, {"sha": "c3771f178bf5a83b18b7ce85a8248ae4c8d31260", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -1691,7 +1691,7 @@ execute_split_functions (void)\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n   if (ipa_fn_summaries\n-      && !ipa_fn_summaries->get (node)->inlinable)\n+      && !ipa_fn_summaries->get_create (node)->inlinable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");"}, {"sha": "5004a30880190fd086cf76053c65b766973975e8", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -1,3 +1,10 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-partition.c (add_symbol_to_partition_1): Use get_create instead\n+\tof get.\n+\t(undo_partition): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* lto-partition.c (add_references_to_partition): Remove support"}, {"sha": "1cca082732a2c75c5bda40dfc6ab5b55c712fa97", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -171,7 +171,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n     {\n       struct cgraph_edge *e;\n       if (!node->alias && c == SYMBOL_PARTITION)\n-        part->insns += ipa_fn_summaries->get (cnode)->size;\n+        part->insns += ipa_fn_summaries->get_create (cnode)->size;\n \n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n@@ -291,7 +291,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \n       if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node))\n           && node->get_partitioning_class () == SYMBOL_PARTITION)\n-        partition->insns -= ipa_fn_summaries->get (cnode)->size;\n+        partition->insns -= ipa_fn_summaries->get_create (cnode)->size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }\n@@ -530,7 +530,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \telse\n \t  order[n_nodes++] = node;\n \tif (!node->alias)\n-\t  total_size += ipa_fn_summaries->get (node)->size;\n+\t  total_size += ipa_fn_summaries->get_create (node)->size;\n       }\n \n   original_total_size = total_size;"}, {"sha": "7ba769739ee8bb085855670cb0767041e4faa743", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -86,11 +86,12 @@ class GTY((user)) function_summary <T *>\n   /* Release an item that is stored within map.  */\n   void release (T *item);\n \n-  /* Getter for summary callgraph node pointer.  */\n-  T* get (cgraph_node *node)\n+  /* Getter for summary callgraph node pointer.  If a summary for a node\n+     does not exist it will be created.  */\n+  T* get_create (cgraph_node *node)\n   {\n     gcc_checking_assert (node->summary_uid);\n-    return get (node->summary_uid);\n+    return get_create (node->summary_uid);\n   }\n \n   /* Return number of elements handled by data structure.  */\n@@ -135,7 +136,7 @@ class GTY((user)) function_summary <T *>\n   typedef int_hash <int, 0, -1> map_hash;\n \n   /* Getter for summary callgraph ID.  */\n-  T* get (int uid);\n+  T* get_create (int uid);\n \n   /* Indicates if insertion hook is enabled.  */\n   bool m_insertion_enabled;\n@@ -214,7 +215,7 @@ function_summary<T *>::symtab_insertion (cgraph_node *node, void *data)\n   function_summary *summary = (function_summary <T *> *) (data);\n \n   if (summary->m_insertion_enabled)\n-    summary->insert (node, summary->get (node));\n+    summary->insert (node, summary->get_create (node));\n }\n \n template <typename T>\n@@ -260,7 +261,7 @@ function_summary<T *>::symtab_duplication (cgraph_node *node,\n \n template <typename T>\n T*\n-function_summary<T *>::get (int uid)\n+function_summary<T *>::get_create (int uid)\n {\n   bool existed;\n   T **v = &m_map.get_or_insert (uid, &existed);\n@@ -357,10 +358,11 @@ class GTY((user)) call_summary <T *>\n   /* Release an item that is stored within map.  */\n   void release (T *item);\n \n-  /* Getter for summary callgraph edge pointer.  */\n-  T* get (cgraph_edge *edge)\n+  /* Getter for summary callgraph edge pointer.\n+     If a summary for an edge does not exist, it will be created.  */\n+  T* get_create (cgraph_edge *edge)\n   {\n-    return get (hashable_uid (edge));\n+    return get_create (hashable_uid (edge));\n   }\n \n   /* Return number of elements handled by data structure.  */\n@@ -390,7 +392,7 @@ class GTY((user)) call_summary <T *>\n   typedef int_hash <int, 0, -1> map_hash;\n \n   /* Getter for summary callgraph ID.  */\n-  T* get (int uid)\n+  T* get_create (int uid)\n   {\n     bool existed;\n     T **v = &m_map.get_or_insert (uid, &existed);"}, {"sha": "09d56d10e7f304e4558ff1d690bba8ad19a5ec26", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99353fcfe4f50d131fae9978ce9cd19bcaf243cf/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=99353fcfe4f50d131fae9978ce9cd19bcaf243cf", "patch": "@@ -5458,7 +5458,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n     }\n \n   if ((DECL_ONE_ONLY (node->decl) || DECL_EXTERNAL (node->decl))\n-      && ipa_fn_summaries->get (node)->size >= MAX_INLINE_INSNS_AUTO)\n+      && ipa_fn_summaries->get_create (node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function too big to be made truly local.\\n\");"}]}