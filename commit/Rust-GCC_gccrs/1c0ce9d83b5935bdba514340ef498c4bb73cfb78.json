{"sha": "1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMwY2U5ZDgzYjU5MzViZGJhNTE0MzQwZWY0OThjNGJiNzNjZmI3OA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:46:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:46:18Z"}, "message": "sem_ch12.ads, [...] (Instantiate_Type): If the formal is a derived type with interface progenitors use the analyzed...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch12.ads, sem_ch12.adb (Instantiate_Type): If the formal is a\n\tderived type with interface progenitors use the analyzed formal as the\n\tparent of the actual, to create renamings for all the inherited\n\toperations in Derive_Subprograms.\n\t(Collect_Previous_Instances): new procedure within of\n\tLoad_Parent_Of_Generic, to instantiate all bodies in the compilation\n\tunit being loaded, to ensure that the generation of global symbols is\n\tconsistent in different compilation modes.\n\t(Is_Tagged_Ancestor): New function testing the ancestor relation that\n\ttakes progenitor types into account.\n\t(Validate_Derived_Type_Instance): Enforce the rule of 3.9.3(9) by\n\ttraversing over the primitives of the formal and actual types to locate\n\tany abstract subprograms of the actual type that correspond to a\n\tnonabstract subprogram of the formal type's ancestor type(s), and issue\n\tan error if such is found.\n\t(Analyze_Package_Instantiation, Analyze_Subprogram_Instantiation,\n\tInstantiate_Package_Body, Instantiate_Subprogram_Body):\n\tRemove bogus guard around calls to Inherit_Context.\n\t(Reset_Entity): If the entity is the selector of a selected component\n\tthat denotes a named number, propagate constant-folding to the generic\n\ttemplate only if the named number is global to the generic unit.\n\t(Set_Instance_Env): Only reset the compilation switches when compiling\n\ta predefined or internal unit.\n\nFrom-SVN: r127443", "tree": {"sha": "9b937a5c8f93ec82861ab5daedf9a3635ca174ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b937a5c8f93ec82861ab5daedf9a3635ca174ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0ce9d83b5935bdba514340ef498c4bb73cfb78/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d6f10a19473c4c174bcb8295163be080ae6f64e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6f10a19473c4c174bcb8295163be080ae6f64e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d6f10a19473c4c174bcb8295163be080ae6f64e"}], "stats": {"total": 759, "additions": 598, "deletions": 161}, "files": [{"sha": "fc649dc625d34f8d19cbda50d064eb071fec6658", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 575, "deletions": 156, "changes": 731, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0ce9d83b5935bdba514340ef498c4bb73cfb78/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0ce9d83b5935bdba514340ef498c4bb73cfb78/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "patch": "@@ -613,25 +613,32 @@ package body Sem_Ch12 is\n    function Is_In_Main_Unit (N : Node_Id) return Boolean;\n    --  Test if given node is in the main unit\n \n-   procedure Load_Parent_Of_Generic (N : Node_Id; Spec : Node_Id);\n-   --  If the generic appears in a separate non-generic library unit,\n-   --  load the corresponding body to retrieve the body of the generic.\n-   --  N is the node for the generic instantiation, Spec is the generic\n-   --  package declaration.\n+   procedure Load_Parent_Of_Generic\n+     (N             : Node_Id;\n+      Spec          : Node_Id;\n+      Body_Optional : Boolean := False);\n+   --  If the generic appears in a separate non-generic library unit, load the\n+   --  corresponding body to retrieve the body of the generic. N is the node\n+   --  for the generic instantiation, Spec is the generic package declaration.\n+   --\n+   --  Body_Optional is a flag that indicates that the body is being loaded to\n+   --  ensure that temporaries are generated consistently when there are other\n+   --  instances in the current declarative part that precede the one being\n+   --  loaded. In that case a missing body is acceptable.\n \n    procedure Inherit_Context (Gen_Decl : Node_Id; Inst : Node_Id);\n-   --  Add the context clause of the unit containing a generic unit to\n-   --  an instantiation that is a compilation unit.\n+   --  Add the context clause of the unit containing a generic unit to an\n+   --  instantiation that is a compilation unit.\n \n    function Get_Associated_Node (N : Node_Id) return Node_Id;\n-   --  In order to propagate semantic information back from the analyzed\n-   --  copy to the original generic, we maintain links between selected nodes\n-   --  in the generic and their corresponding copies. At the end of generic\n-   --  analysis, the routine Save_Global_References traverses the generic\n-   --  tree, examines the semantic information, and preserves the links to\n-   --  those nodes that contain global information. At instantiation, the\n-   --  information from the associated node is placed on the new copy, so\n-   --  that name resolution is not repeated.\n+   --  In order to propagate semantic information back from the analyzed copy\n+   --  to the original generic, we maintain links between selected nodes in the\n+   --  generic and their corresponding copies. At the end of generic analysis,\n+   --  the routine Save_Global_References traverses the generic tree, examines\n+   --  the semantic information, and preserves the links to those nodes that\n+   --  contain global information. At instantiation, the information from the\n+   --  associated node is placed on the new copy, so that name resolution is\n+   --  not repeated.\n    --\n    --  Three kinds of source nodes have associated nodes:\n    --\n@@ -651,9 +658,9 @@ package body Sem_Ch12 is\n    --  For aggregates, the associated node allows retrieval of the type, which\n    --  may otherwise not appear in the generic. The view of this type may be\n    --  different between generic and instantiation, and the full view can be\n-   --  installed before the instantiation is analyzed. For aggregates of\n-   --  type extensions, the same view exchange may have to be performed for\n-   --  some of the ancestor types, if their view is private at the point of\n+   --  installed before the instantiation is analyzed. For aggregates of type\n+   --  extensions, the same view exchange may have to be performed for some of\n+   --  the ancestor types, if their view is private at the point of\n    --  instantiation.\n    --\n    --  Nodes that are selected components in the parse tree may be rewritten\n@@ -692,9 +699,9 @@ package body Sem_Ch12 is\n    -------------------------------------------\n \n    --  The map Generic_Renamings associates generic entities with their\n-   --  corresponding actuals. Currently used to validate type instances.\n-   --  It will eventually be used for all generic parameters to eliminate\n-   --  the need for overload resolution in the instance.\n+   --  corresponding actuals. Currently used to validate type instances. It\n+   --  will eventually be used for all generic parameters to eliminate the\n+   --  need for overload resolution in the instance.\n \n    type Assoc_Ptr is new Int;\n \n@@ -996,6 +1003,10 @@ package body Sem_Ch12 is\n             Actual := First_Named;\n          end if;\n \n+         if Is_Entity_Name (Act) and then Present (Entity (Act)) then\n+            Set_Used_As_Generic_Actual (Entity (Act));\n+         end if;\n+\n          return Act;\n       end Matching_Actual;\n \n@@ -1494,7 +1505,7 @@ package body Sem_Ch12 is\n       then\n          Error_Msg_N\n            (\"in a formal, a subtype indication can only be \"\n-             & \"a subtype mark ('R'M 12.5.3(3))\",\n+             & \"a subtype mark (RM 12.5.3(3))\",\n              Subtype_Indication (Component_Definition (Def)));\n       end if;\n \n@@ -2828,8 +2839,7 @@ package body Sem_Ch12 is\n       begin\n          if not Delay_Subprogram_Descriptors (E) then\n             Set_Delay_Subprogram_Descriptors (E);\n-            Pending_Descriptor.Increment_Last;\n-            Pending_Descriptor.Table (Pending_Descriptor.Last) := E;\n+            Pending_Descriptor.Append (E);\n          end if;\n       end Delay_Descriptors;\n \n@@ -3121,12 +3131,12 @@ package body Sem_Ch12 is\n                end if;\n \n                --  If the current scope is itself an instance within a child\n-               --  unit,there will be duplications in the scope stack, and the\n+               --  unit, there will be duplications in the scope stack, and the\n                --  unstacking mechanism in Inline_Instance_Body will fail.\n                --  This loses some rare cases of optimization, and might be\n                --  improved some day, if we can find a proper abstraction for\n                --  \"the complete compilation context\" that can be saved and\n-               --  restored ???\n+               --  restored. ???\n \n                if Is_Generic_Instance (Current_Scope) then\n                   declare\n@@ -3168,7 +3178,7 @@ package body Sem_Ch12 is\n             --  instantiated is declared within a formal package, there is no\n             --  body to instantiate until the enclosing generic is instantiated\n             --  and there is an actual for the formal package. If the formal\n-            --  package has parameters, we build regular package instance for\n+            --  package has parameters, we build a regular package instance for\n             --  it, that preceeds the original formal package declaration.\n \n             if In_Open_Scopes (Scope (Scope (Gen_Unit))) then\n@@ -3248,9 +3258,9 @@ package body Sem_Ch12 is\n                      elsif Is_Generic_Subprogram (Enclosing_Master)\n                        or else Ekind (Enclosing_Master) = E_Void\n                      then\n-                        --  Cleanup actions will eventually be performed on\n-                        --  the enclosing instance, if any. enclosing scope\n-                        --  is void in the formal part of a generic subp.\n+                        --  Cleanup actions will eventually be performed on the\n+                        --  enclosing instance, if any. Enclosing scope is void\n+                        --  in the formal part of a generic subprogram.\n \n                         exit Scope_Loop;\n \n@@ -3296,9 +3306,13 @@ package body Sem_Ch12 is\n \n                --  Make entry in table\n \n-               Pending_Instantiations.Increment_Last;\n-               Pending_Instantiations.Table (Pending_Instantiations.Last) :=\n-                 (N, Act_Decl, Expander_Active, Current_Sem_Unit);\n+               Pending_Instantiations.Append\n+                 ((Inst_Node                => N,\n+                   Act_Decl                 => Act_Decl,\n+                   Expander_Status          => Expander_Active,\n+                   Current_Sem_Unit         => Current_Sem_Unit,\n+                   Scope_Suppress           => Scope_Suppress,\n+                   Local_Suppress_Stack_Top => Local_Suppress_Stack_Top));\n             end if;\n          end if;\n \n@@ -3310,8 +3324,8 @@ package body Sem_Ch12 is\n \n          Set_Instance_Spec (N, Act_Decl);\n \n-         --  If not a compilation unit, insert the package declaration\n-         --  before the original instantiation node.\n+         --  If not a compilation unit, insert the package declaration before\n+         --  the original instantiation node.\n \n          if Nkind (Parent (N)) /= N_Compilation_Unit then\n             Mark_Rewrite_Insertion (Act_Decl);\n@@ -3320,7 +3334,7 @@ package body Sem_Ch12 is\n \n          --  For an instantiation that is a compilation unit, place declaration\n          --  on current node so context is complete for analysis (including\n-         --  nested instantiations). It this is the main unit, the declaration\n+         --  nested instantiations). If this is the main unit, the declaration\n          --  eventually replaces the instantiation node. If the instance body\n          --  is later created, it replaces the instance node, and the declation\n          --  is attached to it (see Build_Instance_Compilation_Unit_Nodes).\n@@ -3360,6 +3374,7 @@ package body Sem_Ch12 is\n          if ABE_Is_Certain (N) and then Needs_Body then\n             Pending_Instantiations.Decrement_Last;\n          end if;\n+\n          Check_Hidden_Child_Unit (N, Gen_Unit, Act_Decl_Id);\n \n          Set_First_Private_Entity (Defining_Unit_Name (Unit_Renaming),\n@@ -3386,9 +3401,7 @@ package body Sem_Ch12 is\n \n          Restore_Private_Views (Act_Decl_Id);\n \n-         if not Generic_Separately_Compiled (Gen_Unit) then\n-            Inherit_Context (Gen_Decl, N);\n-         end if;\n+         Inherit_Context (Gen_Decl, N);\n \n          if Parent_Installed then\n             Remove_Parent;\n@@ -3415,7 +3428,7 @@ package body Sem_Ch12 is\n \n       --  The following is a tree patch for ASIS: ASIS needs separate nodes to\n       --  be used as defining identifiers for a formal package and for the\n-      --  corresponding expanded package\n+      --  corresponding expanded package.\n \n       if Nkind (N) = N_Formal_Package_Declaration then\n          Act_Decl_Id := New_Copy (Defining_Entity (N));\n@@ -3597,7 +3610,15 @@ package body Sem_Ch12 is\n          Push_Scope (Standard_Standard);\n          Scope_Stack.Table (Scope_Stack.Last).Is_Active_Stack_Base := True;\n          Instantiate_Package_Body\n-           ((N, Act_Decl, Expander_Active, Current_Sem_Unit), True);\n+           (Body_Info =>\n+             ((Inst_Node                => N,\n+               Act_Decl                 => Act_Decl,\n+               Expander_Status          => Expander_Active,\n+               Current_Sem_Unit         => Current_Sem_Unit,\n+               Scope_Suppress           => Scope_Suppress,\n+               Local_Suppress_Stack_Top => Local_Suppress_Stack_Top)),\n+            Inlined_Body => True);\n+\n          Pop_Scope;\n \n          --  Restore context\n@@ -3704,7 +3725,14 @@ package body Sem_Ch12 is\n \n       else\n          Instantiate_Package_Body\n-           ((N, Act_Decl, Expander_Active, Current_Sem_Unit), True);\n+           (Body_Info =>\n+             ((Inst_Node                => N,\n+               Act_Decl                 => Act_Decl,\n+               Expander_Status          => Expander_Active,\n+               Current_Sem_Unit         => Current_Sem_Unit,\n+               Scope_Suppress           => Scope_Suppress,\n+               Local_Suppress_Stack_Top => Local_Suppress_Stack_Top)),\n+            Inlined_Body => True);\n       end if;\n    end Inline_Instance_Body;\n \n@@ -4099,9 +4127,7 @@ package body Sem_Ch12 is\n          Validate_Categorization_Dependency (N, Act_Decl_Id);\n \n          if not Is_Intrinsic_Subprogram (Act_Decl_Id) then\n-            if not Generic_Separately_Compiled (Gen_Unit) then\n-               Inherit_Context (Gen_Decl, N);\n-            end if;\n+            Inherit_Context (Gen_Decl, N);\n \n             Restore_Private_Views (Pack_Id, False);\n \n@@ -4117,9 +4143,14 @@ package body Sem_Ch12 is\n               and then not ABE_Is_Certain (N)\n               and then not Is_Eliminated (Act_Decl_Id)\n             then\n-               Pending_Instantiations.Increment_Last;\n-               Pending_Instantiations.Table (Pending_Instantiations.Last) :=\n-                 (N, Act_Decl, Expander_Active, Current_Sem_Unit);\n+               Pending_Instantiations.Append\n+                 ((Inst_Node                => N,\n+                   Act_Decl                 => Act_Decl,\n+                   Expander_Status          => Expander_Active,\n+                   Current_Sem_Unit         => Current_Sem_Unit,\n+                   Scope_Suppress           => Scope_Suppress,\n+                   Local_Suppress_Stack_Top => Local_Suppress_Stack_Top));\n+\n                Check_Forward_Instantiation (Gen_Decl);\n \n                --  The wrapper package is always delayed, because it does not\n@@ -5747,10 +5778,11 @@ package body Sem_Ch12 is\n                Subunit := Cunit (Unum);\n \n                if Nkind (Unit (Subunit)) /= N_Subunit then\n-                  Error_Msg_Sloc := Sloc (N);\n                   Error_Msg_N\n-                    (\"expected SEPARATE subunit to complete stub at#,\"\n-                       & \" found child unit\", Subunit);\n+                    (\"found child unit instead of expected SEPARATE subunit\",\n+                     Subunit);\n+                  Error_Msg_Sloc := Sloc (N);\n+                  Error_Msg_N (\"\\to complete stub #\", Subunit);\n                   goto Subunit_Not_Found;\n                end if;\n \n@@ -6578,8 +6610,7 @@ package body Sem_Ch12 is\n \n       Save_Opt_Config_Switches (Saved.Switches);\n \n-      Instance_Envs.Increment_Last;\n-      Instance_Envs.Table (Instance_Envs.Last) := Saved;\n+      Instance_Envs.Append (Saved);\n \n       Exchanged_Views := New_Elmt_List;\n       Hidden_Entities := New_Elmt_List;\n@@ -8335,8 +8366,9 @@ package body Sem_Ch12 is\n    ------------------------------\n \n    procedure Instantiate_Package_Body\n-     (Body_Info    : Pending_Body_Info;\n-      Inlined_Body : Boolean := False)\n+     (Body_Info     : Pending_Body_Info;\n+      Inlined_Body  : Boolean := False;\n+      Body_Optional : Boolean := False)\n    is\n       Act_Decl    : constant Node_Id    := Body_Info.Act_Decl;\n       Inst_Node   : constant Node_Id    := Body_Info.Inst_Node;\n@@ -8369,8 +8401,17 @@ package body Sem_Ch12 is\n \n       Expander_Mode_Save_And_Set (Body_Info.Expander_Status);\n \n+      --  Re-establish the state of information on which checks are suppressed.\n+      --  This information was set in Body_Info at the point of instantiation,\n+      --  and now we restore it so that the instance is compiled using the\n+      --  check status at the instantiation (RM 11.5 (7.2/2), AI95-00224-01).\n+\n+      Local_Suppress_Stack_Top := Body_Info.Local_Suppress_Stack_Top;\n+      Scope_Suppress           := Body_Info.Scope_Suppress;\n+\n       if No (Gen_Body_Id) then\n-         Load_Parent_Of_Generic (Inst_Node, Specification (Gen_Decl));\n+         Load_Parent_Of_Generic\n+           (Inst_Node, Specification (Gen_Decl), Body_Optional);\n          Gen_Body_Id := Corresponding_Body (Gen_Decl);\n       end if;\n \n@@ -8491,9 +8532,7 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n \n-         if not Generic_Separately_Compiled (Gen_Unit) then\n-            Inherit_Context (Gen_Body, Inst_Node);\n-         end if;\n+         Inherit_Context (Gen_Body, Inst_Node);\n \n          --  Remove the parent instances if they have been placed on the scope\n          --  stack to compile the body.\n@@ -8518,7 +8557,9 @@ package body Sem_Ch12 is\n       --  complaint is suppressed if we have detected other errors (since a\n       --  common reason for missing the body is that it had errors).\n \n-      elsif Unit_Requires_Body (Gen_Unit) then\n+      elsif Unit_Requires_Body (Gen_Unit)\n+        and then not Body_Optional\n+      then\n          if Serious_Errors_Detected = 0 then\n             Error_Msg_NE\n               (\"cannot find body of generic package &\", Inst_Node, Gen_Unit);\n@@ -8596,6 +8637,14 @@ package body Sem_Ch12 is\n \n       Expander_Mode_Save_And_Set (Body_Info.Expander_Status);\n \n+      --  Re-establish the state of information on which checks are suppressed.\n+      --  This information was set in Body_Info at the point of instantiation,\n+      --  and now we restore it so that the instance is compiled using the\n+      --  check status at the instantiation (RM 11.5 (7.2/2), AI95-00224-01).\n+\n+      Local_Suppress_Stack_Top := Body_Info.Local_Suppress_Stack_Top;\n+      Scope_Suppress           := Body_Info.Scope_Suppress;\n+\n       if No (Gen_Body_Id) then\n          Load_Parent_Of_Generic (Inst_Node, Specification (Gen_Decl));\n          Gen_Body_Id := Corresponding_Body (Gen_Decl);\n@@ -8740,9 +8789,7 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n \n-         if not Generic_Separately_Compiled (Gen_Unit) then\n-            Inherit_Context (Gen_Body, Inst_Node);\n-         end if;\n+         Inherit_Context (Gen_Body, Inst_Node);\n \n          Restore_Private_Views (Pack_Id, False);\n \n@@ -8808,7 +8855,8 @@ package body Sem_Ch12 is\n                   Handled_Statement_Sequence =>\n                     Make_Handled_Sequence_Of_Statements (Loc,\n                       Statements =>\n-                        New_List (Make_Return_Statement (Loc, Ret_Expr))));\n+                        New_List\n+                          (Make_Simple_Return_Statement (Loc, Ret_Expr))));\n          end if;\n \n          Pack_Body := Make_Package_Body (Loc,\n@@ -9387,6 +9435,247 @@ package body Sem_Ch12 is\n                Abandon_Instantiation (Actual);\n             end if;\n          end if;\n+\n+         --  If the formal and actual types are abstract, check that there\n+         --  are no abstract primitives of the actual type that correspond to\n+         --  nonabstract primitives of the formal type (second sentence of\n+         --  RM95-3.9.3(9)).\n+\n+         if Is_Abstract_Type (A_Gen_T) and then Is_Abstract_Type (Act_T) then\n+            Check_Abstract_Primitives : declare\n+               Gen_Prims  : constant Elist_Id :=\n+                             Primitive_Operations (A_Gen_T);\n+               Gen_Elmt   : Elmt_Id;\n+               Gen_Subp   : Entity_Id;\n+               Anc_Subp   : Entity_Id;\n+               Anc_Formal : Entity_Id;\n+               Anc_F_Type : Entity_Id;\n+\n+               Act_Prims  : constant Elist_Id  := Primitive_Operations (Act_T);\n+               Act_Elmt   : Elmt_Id;\n+               Act_Subp   : Entity_Id;\n+               Act_Formal : Entity_Id;\n+               Act_F_Type : Entity_Id;\n+\n+               Subprograms_Correspond : Boolean;\n+\n+               function Is_Tagged_Ancestor (T1, T2 : Entity_Id) return Boolean;\n+               --  Returns true if T2 is derived directly or indirectly from\n+               --  T1, including derivations from interfaces. T1 and T2 are\n+               --  required to be specific tagged base types.\n+\n+               ------------------------\n+               -- Is_Tagged_Ancestor --\n+               ------------------------\n+\n+               function Is_Tagged_Ancestor (T1, T2 : Entity_Id) return Boolean\n+               is\n+                  Interfaces : Elist_Id;\n+                  Intfc_Elmt : Elmt_Id;\n+\n+               begin\n+                  --  The predicate is satisfied if the types are the same\n+\n+                  if T1 = T2 then\n+                     return True;\n+\n+                  --  If we've reached the top of the derivation chain then\n+                  --  we know that T1 is not an ancestor of T2.\n+\n+                  elsif Etype (T2) = T2 then\n+                     return False;\n+\n+                  --  Proceed to check T2's immediate parent\n+\n+                  elsif Is_Ancestor (T1, Base_Type (Etype (T2))) then\n+                     return True;\n+\n+                  --  Finally, check to see if T1 is an ancestor of any of T2's\n+                  --  progenitors.\n+\n+                  else\n+                     Interfaces := Abstract_Interfaces (T2);\n+\n+                     Intfc_Elmt := First_Elmt (Interfaces);\n+                     while Present (Intfc_Elmt) loop\n+                        if Is_Ancestor (T1, Node (Intfc_Elmt)) then\n+                           return True;\n+                        end if;\n+\n+                        Next_Elmt (Intfc_Elmt);\n+                     end loop;\n+                  end if;\n+\n+                  return False;\n+               end Is_Tagged_Ancestor;\n+\n+            --  Start of processing for Check_Abstract_Primitives\n+\n+            begin\n+               --  Loop over all of the formal derived type's primitives\n+\n+               Gen_Elmt := First_Elmt (Gen_Prims);\n+               while Present (Gen_Elmt) loop\n+                  Gen_Subp := Node (Gen_Elmt);\n+\n+                  --  If the primitive of the formal is not abstract, then\n+                  --  determine whether there is a corresponding primitive of\n+                  --  the actual type that's abstract.\n+\n+                  if not Is_Abstract_Subprogram (Gen_Subp) then\n+                     Act_Elmt := First_Elmt (Act_Prims);\n+                     while Present (Act_Elmt) loop\n+                        Act_Subp := Node (Act_Elmt);\n+\n+                        --  If we find an abstract primitive of the actual,\n+                        --  then we need to test whether it corresponds to the\n+                        --  subprogram from which the generic formal primitive\n+                        --  is inherited.\n+\n+                        if Is_Abstract_Subprogram (Act_Subp) then\n+                           Anc_Subp := Alias (Gen_Subp);\n+\n+                           --  Test whether we have a corresponding primitive\n+                           --  by comparing names, kinds, formal types, and\n+                           --  result types.\n+\n+                           if Chars (Anc_Subp) = Chars (Act_Subp)\n+                             and then Ekind (Anc_Subp) = Ekind (Act_Subp)\n+                           then\n+                              Anc_Formal := First_Formal (Anc_Subp);\n+                              Act_Formal := First_Formal (Act_Subp);\n+                              while Present (Anc_Formal)\n+                                and then Present (Act_Formal)\n+                              loop\n+                                 Anc_F_Type := Etype (Anc_Formal);\n+                                 Act_F_Type := Etype (Act_Formal);\n+\n+                                 if Ekind (Anc_F_Type)\n+                                      = E_Anonymous_Access_Type\n+                                 then\n+                                    Anc_F_Type := Designated_Type (Anc_F_Type);\n+\n+                                    if Ekind (Act_F_Type)\n+                                         = E_Anonymous_Access_Type\n+                                    then\n+                                       Act_F_Type :=\n+                                         Designated_Type (Act_F_Type);\n+                                    else\n+                                       exit;\n+                                    end if;\n+\n+                                 elsif\n+                                   Ekind (Act_F_Type) = E_Anonymous_Access_Type\n+                                 then\n+                                    exit;\n+                                 end if;\n+\n+                                 Anc_F_Type := Base_Type (Anc_F_Type);\n+                                 Act_F_Type := Base_Type (Act_F_Type);\n+\n+                                 --  If the formal is controlling, then the\n+                                 --  the type of the actual primitive's formal\n+                                 --  must be derived directly or indirectly\n+                                 --  from the type of the ancestor primitive's\n+                                 --  formal.\n+\n+                                 if Is_Controlling_Formal (Anc_Formal) then\n+                                    if not Is_Tagged_Ancestor\n+                                             (Anc_F_Type, Act_F_Type)\n+                                    then\n+                                       exit;\n+                                    end if;\n+\n+                                 --  Otherwise the types of the formals must\n+                                 --  be the same.\n+\n+                                 elsif Anc_F_Type /= Act_F_Type then\n+                                    exit;\n+                                 end if;\n+\n+                                 Next_Entity (Anc_Formal);\n+                                 Next_Entity (Act_Formal);\n+                              end loop;\n+\n+                              --  If we traversed through all of the formals\n+                              --  then so far the subprograms correspond, so\n+                              --  now check that any result types correspond.\n+\n+                              if No (Anc_Formal)\n+                                and then No (Act_Formal)\n+                              then\n+                                 Subprograms_Correspond := True;\n+\n+                                 if Ekind (Act_Subp) = E_Function then\n+                                    Anc_F_Type := Etype (Anc_Subp);\n+                                    Act_F_Type := Etype (Act_Subp);\n+\n+                                    if Ekind (Anc_F_Type)\n+                                         = E_Anonymous_Access_Type\n+                                    then\n+                                       Anc_F_Type :=\n+                                         Designated_Type (Anc_F_Type);\n+\n+                                       if Ekind (Act_F_Type)\n+                                            = E_Anonymous_Access_Type\n+                                       then\n+                                          Act_F_Type :=\n+                                            Designated_Type (Act_F_Type);\n+                                       else\n+                                          Subprograms_Correspond := False;\n+                                       end if;\n+\n+                                    elsif\n+                                      Ekind (Act_F_Type)\n+                                        = E_Anonymous_Access_Type\n+                                    then\n+                                       Subprograms_Correspond := False;\n+                                    end if;\n+\n+                                    Anc_F_Type := Base_Type (Anc_F_Type);\n+                                    Act_F_Type := Base_Type (Act_F_Type);\n+\n+                                    --  Now either the result types must be\n+                                    --  the same or, if the result type is\n+                                    --  controlling, the result type of the\n+                                    --  actual primitive must descend from the\n+                                    --  result type of the ancestor primitive.\n+\n+                                    if Subprograms_Correspond\n+                                      and then Anc_F_Type /= Act_F_Type\n+                                      and then\n+                                        Has_Controlling_Result (Anc_Subp)\n+                                      and then\n+                                        not Is_Tagged_Ancestor\n+                                              (Anc_F_Type, Act_F_Type)\n+                                    then\n+                                       Subprograms_Correspond := False;\n+                                    end if;\n+                                 end if;\n+\n+                                 --  Found a matching subprogram belonging to\n+                                 --  formal ancestor type, so actual subprogram\n+                                 --  corresponds and this violates 3.9.3(9).\n+\n+                                 if Subprograms_Correspond then\n+                                    Error_Msg_NE\n+                                      (\"abstract subprogram & overrides \" &\n+                                       \"nonabstract subprogram of ancestor\",\n+                                       Actual,\n+                                       Act_Subp);\n+                                 end if;\n+                              end if;\n+                           end if;\n+                        end if;\n+\n+                        Next_Elmt (Act_Elmt);\n+                     end loop;\n+                  end if;\n+\n+                  Next_Elmt (Gen_Elmt);\n+               end loop;\n+            end Check_Abstract_Primitives;\n+         end if;\n       end Validate_Derived_Type_Instance;\n \n       --------------------------------------\n@@ -9411,8 +9700,8 @@ package body Sem_Ch12 is\n                Is_Synchronized_Interface (Act_T)\n          then\n             Error_Msg_NE\n-              (\"actual for interface& does not match ('R'M 12.5.5(4))\",\n-                 Actual, Gen_T);\n+              (\"actual for interface& does not match (RM 12.5.5(4))\",\n+               Actual, Gen_T);\n          end if;\n       end Validate_Interface_Type_Instance;\n \n@@ -9636,78 +9925,84 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n-      case Nkind (Def) is\n-         when N_Formal_Private_Type_Definition =>\n-            Validate_Private_Type_Instance;\n+      if Error_Posted (Act_T) then\n+         null;\n+      else\n+         case Nkind (Def) is\n+            when N_Formal_Private_Type_Definition =>\n+               Validate_Private_Type_Instance;\n \n-         when N_Formal_Derived_Type_Definition =>\n-            Validate_Derived_Type_Instance;\n+            when N_Formal_Derived_Type_Definition =>\n+               Validate_Derived_Type_Instance;\n \n-         when N_Formal_Discrete_Type_Definition =>\n-            if not Is_Discrete_Type (Act_T) then\n-               Error_Msg_NE\n-                 (\"expect discrete type in instantiation of&\", Actual, Gen_T);\n-               Abandon_Instantiation (Actual);\n-            end if;\n+            when N_Formal_Discrete_Type_Definition =>\n+               if not Is_Discrete_Type (Act_T) then\n+                  Error_Msg_NE\n+                    (\"expect discrete type in instantiation of&\",\n+                       Actual, Gen_T);\n+                  Abandon_Instantiation (Actual);\n+               end if;\n \n-         when N_Formal_Signed_Integer_Type_Definition =>\n-            if not Is_Signed_Integer_Type (Act_T) then\n-               Error_Msg_NE\n-                 (\"expect signed integer type in instantiation of&\",\n-                  Actual, Gen_T);\n-               Abandon_Instantiation (Actual);\n-            end if;\n+            when N_Formal_Signed_Integer_Type_Definition =>\n+               if not Is_Signed_Integer_Type (Act_T) then\n+                  Error_Msg_NE\n+                    (\"expect signed integer type in instantiation of&\",\n+                     Actual, Gen_T);\n+                  Abandon_Instantiation (Actual);\n+               end if;\n \n-         when N_Formal_Modular_Type_Definition =>\n-            if not Is_Modular_Integer_Type (Act_T) then\n-               Error_Msg_NE\n-                 (\"expect modular type in instantiation of &\", Actual, Gen_T);\n-               Abandon_Instantiation (Actual);\n-            end if;\n+            when N_Formal_Modular_Type_Definition =>\n+               if not Is_Modular_Integer_Type (Act_T) then\n+                  Error_Msg_NE\n+                    (\"expect modular type in instantiation of &\",\n+                       Actual, Gen_T);\n+                  Abandon_Instantiation (Actual);\n+               end if;\n \n-         when N_Formal_Floating_Point_Definition =>\n-            if not Is_Floating_Point_Type (Act_T) then\n-               Error_Msg_NE\n-                 (\"expect float type in instantiation of &\", Actual, Gen_T);\n-               Abandon_Instantiation (Actual);\n-            end if;\n+            when N_Formal_Floating_Point_Definition =>\n+               if not Is_Floating_Point_Type (Act_T) then\n+                  Error_Msg_NE\n+                    (\"expect float type in instantiation of &\", Actual, Gen_T);\n+                  Abandon_Instantiation (Actual);\n+               end if;\n \n-         when N_Formal_Ordinary_Fixed_Point_Definition =>\n-            if not Is_Ordinary_Fixed_Point_Type (Act_T) then\n-               Error_Msg_NE\n-                 (\"expect ordinary fixed point type in instantiation of &\",\n-                  Actual, Gen_T);\n-               Abandon_Instantiation (Actual);\n-            end if;\n+            when N_Formal_Ordinary_Fixed_Point_Definition =>\n+               if not Is_Ordinary_Fixed_Point_Type (Act_T) then\n+                  Error_Msg_NE\n+                    (\"expect ordinary fixed point type in instantiation of &\",\n+                     Actual, Gen_T);\n+                  Abandon_Instantiation (Actual);\n+               end if;\n \n-         when N_Formal_Decimal_Fixed_Point_Definition =>\n-            if not Is_Decimal_Fixed_Point_Type (Act_T) then\n-               Error_Msg_NE\n-                 (\"expect decimal type in instantiation of &\",\n-                  Actual, Gen_T);\n-               Abandon_Instantiation (Actual);\n-            end if;\n+            when N_Formal_Decimal_Fixed_Point_Definition =>\n+               if not Is_Decimal_Fixed_Point_Type (Act_T) then\n+                  Error_Msg_NE\n+                    (\"expect decimal type in instantiation of &\",\n+                     Actual, Gen_T);\n+                  Abandon_Instantiation (Actual);\n+               end if;\n \n-         when N_Array_Type_Definition =>\n-            Validate_Array_Type_Instance;\n+            when N_Array_Type_Definition =>\n+               Validate_Array_Type_Instance;\n \n-         when N_Access_To_Object_Definition =>\n-            Validate_Access_Type_Instance;\n+            when N_Access_To_Object_Definition =>\n+               Validate_Access_Type_Instance;\n \n-         when N_Access_Function_Definition |\n-              N_Access_Procedure_Definition =>\n-            Validate_Access_Subprogram_Instance;\n+            when N_Access_Function_Definition |\n+                 N_Access_Procedure_Definition =>\n+               Validate_Access_Subprogram_Instance;\n \n-         when N_Record_Definition           =>\n-            Validate_Interface_Type_Instance;\n+            when N_Record_Definition           =>\n+               Validate_Interface_Type_Instance;\n \n-         when N_Derived_Type_Definition     =>\n-            Validate_Derived_Interface_Type_Instance;\n+            when N_Derived_Type_Definition     =>\n+               Validate_Derived_Interface_Type_Instance;\n \n-         when others =>\n-            raise Program_Error;\n+            when others =>\n+               raise Program_Error;\n \n-      end case;\n+         end case;\n+      end if;\n \n       Subt := New_Copy (Gen_T);\n \n@@ -9736,10 +10031,18 @@ package body Sem_Ch12 is\n       --  appropriate renamings for the primitive operations of the ancestor.\n       --  Flag actual for formal private types as well, to determine whether\n       --  operations in the private part may override inherited operations.\n+      --  If the formal has an interface list, the ancestor is not the\n+      --  parent, but the analyzed formal that includes the interface\n+      --  operations of all its progenitors.\n \n-      if Nkind (Def) = N_Formal_Derived_Type_Definition\n-        or else Nkind (Def) = N_Formal_Private_Type_Definition\n-      then\n+      if Nkind (Def) = N_Formal_Derived_Type_Definition then\n+         if Present (Interface_List (Def)) then\n+            Set_Generic_Parent_Type (Decl_Node, A_Gen_T);\n+         else\n+            Set_Generic_Parent_Type (Decl_Node, Ancestor);\n+         end if;\n+\n+      elsif Nkind (Def) = N_Formal_Private_Type_Definition then\n          Set_Generic_Parent_Type (Decl_Node, Ancestor);\n       end if;\n \n@@ -9792,7 +10095,6 @@ package body Sem_Ch12 is\n \n    function Is_Generic_Formal (E : Entity_Id) return Boolean is\n       Kind : Node_Kind;\n-\n    begin\n       if No (E) then\n          return False;\n@@ -9852,12 +10154,57 @@ package body Sem_Ch12 is\n    -- Load_Parent_Of_Generic --\n    ----------------------------\n \n-   procedure Load_Parent_Of_Generic (N : Node_Id; Spec : Node_Id) is\n-      Comp_Unit        : constant Node_Id := Cunit (Get_Source_Unit (Spec));\n-      Save_Style_Check : constant Boolean := Style_Check;\n-      True_Parent      : Node_Id;\n-      Inst_Node        : Node_Id;\n-      OK               : Boolean;\n+   procedure Load_Parent_Of_Generic\n+     (N             : Node_Id;\n+      Spec          : Node_Id;\n+      Body_Optional : Boolean := False)\n+   is\n+      Comp_Unit          : constant Node_Id := Cunit (Get_Source_Unit (Spec));\n+      Save_Style_Check   : constant Boolean := Style_Check;\n+      True_Parent        : Node_Id;\n+      Inst_Node          : Node_Id;\n+      OK                 : Boolean;\n+      Previous_Instances : constant Elist_Id := New_Elmt_List;\n+\n+      procedure Collect_Previous_Instances (Decls : List_Id);\n+      --  Collect all instantiations in the given list of declarations,\n+      --  that precedes the generic that we need to load. If the bodies\n+      --  of these instantiations are available, we must analyze them,\n+      --  to ensure that the public symbols generated are the same when\n+      --  the unit is compiled to generate code, and when it is compiled\n+      --  in the context of the unit that needs a particular nested instance.\n+\n+      --------------------------------\n+      -- Collect_Previous_Instances --\n+      --------------------------------\n+\n+      procedure Collect_Previous_Instances (Decls : List_Id) is\n+         Decl : Node_Id;\n+\n+      begin\n+         Decl := First (Decls);\n+         while Present (Decl) loop\n+            if Sloc (Decl) >= Sloc (Inst_Node) then\n+               return;\n+\n+            elsif Nkind (Decl) = N_Package_Instantiation then\n+               Append_Elmt (Decl, Previous_Instances);\n+\n+            elsif Nkind (Decl) = N_Package_Declaration then\n+               Collect_Previous_Instances\n+                 (Visible_Declarations (Specification (Decl)));\n+               Collect_Previous_Instances\n+                 (Private_Declarations (Specification (Decl)));\n+\n+            elsif Nkind (Decl) = N_Package_Body then\n+               Collect_Previous_Instances (Declarations (Decl));\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end Collect_Previous_Instances;\n+\n+   --  Start of processing for Load_Parent_Of_Generic\n \n    begin\n       if not In_Same_Source_Unit (N, Spec)\n@@ -9875,9 +10222,9 @@ package body Sem_Ch12 is\n          --  in a package body, the instance defined in the same package body,\n          --  and the original enclosing body may not be in the main unit.\n \n-         True_Parent := Parent (Spec);\n-         Inst_Node   := Empty;\n+         Inst_Node := Empty;\n \n+         True_Parent := Parent (Spec);\n          while Present (True_Parent)\n            and then Nkind (True_Parent) /= N_Compilation_Unit\n          loop\n@@ -9900,7 +10247,6 @@ package body Sem_Ch12 is\n                --  instantiation node. A direct link would be preferable?\n \n                Inst_Node := Next (True_Parent);\n-\n                while Present (Inst_Node)\n                  and then Nkind (Inst_Node) /= N_Package_Instantiation\n                loop\n@@ -9917,6 +10263,7 @@ package body Sem_Ch12 is\n                end if;\n \n                exit;\n+\n             else\n                True_Parent := Parent (True_Parent);\n             end if;\n@@ -9949,8 +10296,8 @@ package body Sem_Ch12 is\n                --  applies.\n \n                declare\n-                  Exp_Status : Boolean := True;\n-                  Scop       : Entity_Id;\n+                  Exp_Status         : Boolean := True;\n+                  Scop               : Entity_Id;\n \n                begin\n                   --  Loop through scopes looking for generic package\n@@ -9967,10 +10314,73 @@ package body Sem_Ch12 is\n                      Scop := Scope (Scop);\n                   end loop;\n \n+                  --  Collect previous instantiations in the unit that\n+                  --  contains the desired generic,\n+\n+                  if Nkind (Parent (True_Parent)) /= N_Compilation_Unit\n+                    and then not Body_Optional\n+                  then\n+                     declare\n+                        Decl : Elmt_Id;\n+                        Par  : Node_Id;\n+\n+                     begin\n+                        Par := Parent (Inst_Node);\n+                        while Present (Par) loop\n+                           exit when Nkind (Parent (Par)) = N_Compilation_Unit;\n+                           Par := Parent (Par);\n+                        end loop;\n+\n+                        pragma Assert (Present (Par));\n+\n+                        if Nkind (Par) = N_Package_Body then\n+                           Collect_Previous_Instances (Declarations (Par));\n+\n+                        elsif Nkind (Par) = N_Package_Declaration then\n+                           Collect_Previous_Instances\n+                             (Visible_Declarations (Specification (Par)));\n+                           Collect_Previous_Instances\n+                             (Private_Declarations (Specification (Par)));\n+\n+                        else\n+                           --  Enclosing unit is a subprogram body, In this\n+                           --  case all instance bodies are processed in order\n+                           --  and there is no need to collect them separately.\n+\n+                           null;\n+                        end if;\n+\n+                        Decl := First_Elmt (Previous_Instances);\n+                        while Present (Decl) loop\n+                           Instantiate_Package_Body\n+                             (Body_Info =>\n+                                ((Inst_Node                => Node (Decl),\n+                                  Act_Decl                 =>\n+                                    Instance_Spec (Node (Decl)),\n+                                  Expander_Status          => Exp_Status,\n+                                  Current_Sem_Unit         =>\n+                                    Get_Code_Unit (Sloc (Node (Decl))),\n+                                  Scope_Suppress           => Scope_Suppress,\n+                                  Local_Suppress_Stack_Top =>\n+                                    Local_Suppress_Stack_Top)),\n+                              Body_Optional => True);\n+\n+                           Next_Elmt (Decl);\n+                        end loop;\n+                     end;\n+                  end if;\n+\n                   Instantiate_Package_Body\n-                    (Pending_Body_Info'(\n-                       Inst_Node, True_Parent, Exp_Status,\n-                         Get_Code_Unit (Sloc (Inst_Node))));\n+                    (Body_Info =>\n+                       ((Inst_Node                => Inst_Node,\n+                         Act_Decl                 => True_Parent,\n+                         Expander_Status          => Exp_Status,\n+                         Current_Sem_Unit         =>\n+                           Get_Code_Unit (Sloc (Inst_Node)),\n+                         Scope_Suppress           => Scope_Suppress,\n+                         Local_Suppress_Stack_Top =>\n+                           Local_Suppress_Stack_Top)),\n+                                 Body_Optional => Body_Optional);\n                end;\n             end if;\n \n@@ -9985,6 +10395,7 @@ package body Sem_Ch12 is\n \n             if not OK\n               and then Unit_Requires_Body (Defining_Entity (Spec))\n+              and then not Body_Optional\n             then\n                declare\n                   Bname : constant Unit_Name_Type :=\n@@ -10619,8 +11030,8 @@ package body Sem_Ch12 is\n       procedure Reset_Entity (N : Node_Id) is\n \n          procedure Set_Global_Type (N : Node_Id; N2 : Node_Id);\n-         --  The type of N2 is global to the generic unit. Save the\n-         --  type in the generic node.\n+         --  If the type of N2 is global to the generic unit. Save\n+         --  the type in the generic node.\n \n          function Top_Ancestor (E : Entity_Id) return Entity_Id;\n          --  Find the ultimate ancestor of the current unit. If it is\n@@ -10766,15 +11177,22 @@ package body Sem_Ch12 is\n             end if;\n \n          --  A selected component may denote a static constant that has been\n-         --  folded. Make the same replacement in original tree.\n+         --  folded. If the static constant is global to the generic, capture\n+         --  its value. Otherwise the folding will happen in any instantiation,\n \n          elsif Nkind (Parent (N)) = N_Selected_Component\n            and then (Nkind (Parent (N2)) = N_Integer_Literal\n                       or else Nkind (Parent (N2)) = N_Real_Literal)\n          then\n-            Rewrite (Parent (N),\n-              New_Copy (Parent (N2)));\n-            Set_Analyzed (Parent (N), False);\n+            if Present (Entity (Original_Node (Parent (N2))))\n+              and then Is_Global (Entity (Original_Node (Parent (N2))))\n+            then\n+               Rewrite (Parent (N), New_Copy (Parent (N2)));\n+               Set_Analyzed (Parent (N), False);\n+\n+            else\n+               null;\n+            end if;\n \n          --  A selected component may be transformed into a parameterless\n          --  function call. If the called entity is global, rewrite the node\n@@ -11377,11 +11795,10 @@ package body Sem_Ch12 is\n \n    procedure Start_Generic is\n    begin\n-      --  ??? I am sure more things could be factored out in this routine.\n+      --  ??? More things could be factored out in this routine.\n       --  Should probably be done at a later stage.\n \n-      Generic_Flags.Increment_Last;\n-      Generic_Flags.Table (Generic_Flags.Last) := Inside_A_Generic;\n+      Generic_Flags.Append (Inside_A_Generic);\n       Inside_A_Generic := True;\n \n       Expander_Mode_Save_And_Set (False);\n@@ -11398,13 +11815,15 @@ package body Sem_Ch12 is\n    begin\n       --  Regardless of the current mode, predefined units are analyzed in\n       --  the most current Ada mode, and earlier version Ada checks do not\n-      --  apply to predefined units.\n+      --  apply to predefined units. Nothing needs to be done for non-internal\n+      --  units. These are always analyzed in the current mode.\n \n-      Set_Opt_Config_Switches (\n-        Is_Internal_File_Name\n+      if Is_Internal_File_Name\n           (Fname => Unit_File_Name (Get_Source_Unit (Gen_Unit)),\n-           Renamings_Included => True),\n-        Current_Sem_Unit = Main_Unit);\n+           Renamings_Included => True)\n+      then\n+         Set_Opt_Config_Switches (True, Current_Sem_Unit = Main_Unit);\n+      end if;\n \n       Current_Instantiated_Parent := (Gen_Unit, Act_Unit, Assoc_Null);\n    end Set_Instance_Env;"}, {"sha": "831e4807c7c36f269e3d1dd7a956881e25e5377e", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0ce9d83b5935bdba514340ef498c4bb73cfb78/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0ce9d83b5935bdba514340ef498c4bb73cfb78/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -58,8 +58,7 @@ package Sem_Ch12 is\n    function Copy_Generic_Node\n      (N             : Node_Id;\n       Parent_Id     : Node_Id;\n-      Instantiating : Boolean)\n-      return          Node_Id;\n+      Instantiating : Boolean) return Node_Id;\n    --  Copy the tree for a generic unit or its body. The unit is copied\n    --  repeatedly: once to produce a copy on which semantic analysis of\n    --  the generic is performed, and once for each instantiation. The tree\n@@ -76,11 +75,30 @@ package Sem_Ch12 is\n    --  of the ancestors of a child generic that is being instantiated.\n \n    procedure Instantiate_Package_Body\n-     (Body_Info    : Pending_Body_Info;\n-      Inlined_Body : Boolean := False);\n+     (Body_Info     : Pending_Body_Info;\n+      Inlined_Body  : Boolean := False;\n+      Body_Optional : Boolean := False);\n    --  Called after semantic analysis, to complete the instantiation of\n    --  package instances. The flag Inlined_Body is set if the body is\n    --  being instantiated on the fly for inlined purposes.\n+   --\n+   --  The flag Body_Optional indicates that the call is for an instance\n+   --  that precedes the current instance in the same declarative part.\n+   --  This call is needed when instantiating a nested generic whose body\n+   --  is to be found in the body of an instance. Normally we instantiate\n+   --  package bodies only when they appear in the main unit, or when their\n+   --  contents are needed for a nested generic G. If unit U contains several\n+   --  instances I1, I2, etc. and I2 contains a nested generic, then when U\n+   --  appears in the context of some other unit P that contains an instance\n+   --  of G, we compile the body of I2, but not that of I1. However, when we\n+   --  compile U as the main unit, we compile both bodies. This will lead to\n+   --  lead to link-time errors if the compilation of I1 generates public\n+   --  symbols, because those in I2 will receive different names in both\n+   --  cases. This forces us to analyze the body of I1 even when U is not the\n+   --  main unit. We don't want this additional mechanism to generate an error\n+   --  when the body of the generic for I1 is not present, and this is the\n+   --  reason for the presence of the flag Body_Optional, which is exchanged\n+   --  between the current procedure and Load_Parent_Of_Generic.\n \n    procedure Instantiate_Subprogram_Body\n      (Body_Info : Pending_Body_Info);"}]}