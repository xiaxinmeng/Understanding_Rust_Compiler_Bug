{"sha": "4a2353126ec971d01425b1fdec42afa316804337", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEyMzUzMTI2ZWM5NzFkMDE0MjViMWZkZWM0MmFmYTMxNjgwNDMzNw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2016-06-02T13:46:20Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-06-02T13:46:20Z"}, "message": "Update TARGET_FUNCTION_INCOMING_ARG documentation\n\nOn x86, interrupt handlers are only called by processors which push\ninterrupt data onto stack at the address where the normal return address\nis.  Since interrupt handlers must access interrupt data via pointers so\nthat they can update interrupt data, the pointer argument is passed as\n\"argument pointer - word\".\n\nTARGET_FUNCTION_INCOMING_ARG defines how callee sees its argument.\nNormally it returns REG, NULL, or CONST_INT.  This patch adds arbitrary\naddress computation based on hard register, which can be forced into a\nregister, to the list.\n\nWhen copying an incoming argument onto stack, assign_parm_setup_stack\nhas:\n\nif (argument in memory)\n  copy argument in memory to stack\nelse\n  move argument to stack\n\nSince an arbitrary address computation may be passed as an argument, we\nchange it to:\n\nif (argument in memory)\n  copy argument in memory to stack\nelse\n  {\n    if (argument isn't in register)\n      force argument into a register\n    move argument to stack\n  }\n\n\t* function.c (assign_parm_setup_stack): Force source into a\n\tregister if needed.\n\t* target.def (function_incoming_arg): Update documentation to\n\tallow arbitrary address computation based on hard register.\n\t* doc/tm.texi: Regenerated.\n\nCo-Authored-By: Julia Koval <julia.koval@intel.com>\n\nFrom-SVN: r237037", "tree": {"sha": "b0b73d22e0c8a955f7f397790e174ba0ffe5305b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0b73d22e0c8a955f7f397790e174ba0ffe5305b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a2353126ec971d01425b1fdec42afa316804337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2353126ec971d01425b1fdec42afa316804337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2353126ec971d01425b1fdec42afa316804337", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2353126ec971d01425b1fdec42afa316804337/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3c5ecc2b984e186f043ad03cc7a96a6275f4670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c5ecc2b984e186f043ad03cc7a96a6275f4670", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3c5ecc2b984e186f043ad03cc7a96a6275f4670"}], "stats": {"total": 45, "additions": 32, "deletions": 13}, "files": [{"sha": "770df0732f8256d5555c2717a24622a888e07a7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2353126ec971d01425b1fdec42afa316804337/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2353126ec971d01425b1fdec42afa316804337/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a2353126ec971d01425b1fdec42afa316804337", "patch": "@@ -1,3 +1,12 @@\n+2016-06-02  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Julia Koval  <julia.koval@intel.com>\n+\n+\t* function.c (assign_parm_setup_stack): Force source into a\n+\tregister if needed.\n+\t* target.def (function_incoming_arg): Update documentation to\n+\tallow arbitrary address computation based on hard register.\n+\t* doc/tm.texi: Regenerated.\n+\n 2016-06-02  Martin Liska  <mliska@suse.cz>\n \n \t* predict.c (combine_predictions_for_bb): Fix first match in"}, {"sha": "a343e913edaead6a46ce1ba2e81d1702a0ef9dd0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2353126ec971d01425b1fdec42afa316804337/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2353126ec971d01425b1fdec42afa316804337/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4a2353126ec971d01425b1fdec42afa316804337", "patch": "@@ -3938,17 +3938,21 @@ documentation.\n @end deftypefn\n \n @deftypefn {Target Hook} rtx TARGET_FUNCTION_INCOMING_ARG (cumulative_args_t @var{ca}, machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n-Define this hook if the target machine has ``register windows'', so\n-that the register in which a function sees an arguments is not\n-necessarily the same as the one in which the caller passed the\n-argument.\n+Define this hook if the caller and callee on the target have different\n+views of where arguments are passed.  Also define this hook if there are\n+functions that are never directly called, but are invoked by the hardware\n+and which have nonstandard calling conventions.\n \n-For such machines, @code{TARGET_FUNCTION_ARG} computes the register in\n+In this case @code{TARGET_FUNCTION_ARG} computes the register in\n which the caller passes the value, and\n @code{TARGET_FUNCTION_INCOMING_ARG} should be defined in a similar\n fashion to tell the function being called where the arguments will\n arrive.\n \n+@code{TARGET_FUNCTION_INCOMING_ARG} can also return arbitrary address\n+computation using hard register, which can be forced into a register,\n+so that it can be used to pass special arguments.\n+\n If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\n @code{TARGET_FUNCTION_ARG} serves both purposes.\n @end deftypefn"}, {"sha": "c15d47d21033a01ae0ebbf69d78ad5c2fb31d494", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2353126ec971d01425b1fdec42afa316804337/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2353126ec971d01425b1fdec42afa316804337/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4a2353126ec971d01425b1fdec42afa316804337", "patch": "@@ -3466,7 +3466,11 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \t\t\t   BLOCK_OP_NORMAL);\n \t}\n       else\n-\temit_move_insn (dest, src);\n+\t{\n+\t  if (!REG_P (src))\n+\t    src = force_reg (GET_MODE (src), src);\n+\t  emit_move_insn (dest, src);\n+\t}\n     }\n \n   if (to_conversion)"}, {"sha": "5285e57345cc7191054dd1e52959425fc23b67d8", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2353126ec971d01425b1fdec42afa316804337/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2353126ec971d01425b1fdec42afa316804337/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=4a2353126ec971d01425b1fdec42afa316804337", "patch": "@@ -4468,21 +4468,23 @@ a register.\",\n        bool named),\n  default_function_arg)\n \n-/* Likewise, but for machines with register windows.  Return the\n-   location where the argument will appear to the callee.  */\n DEFHOOK\n (function_incoming_arg,\n- \"Define this hook if the target machine has ``register windows'', so\\n\\\n-that the register in which a function sees an arguments is not\\n\\\n-necessarily the same as the one in which the caller passed the\\n\\\n-argument.\\n\\\n+ \"Define this hook if the caller and callee on the target have different\\n\\\n+views of where arguments are passed.  Also define this hook if there are\\n\\\n+functions that are never directly called, but are invoked by the hardware\\n\\\n+and which have nonstandard calling conventions.\\n\\\n \\n\\\n-For such machines, @code{TARGET_FUNCTION_ARG} computes the register in\\n\\\n+In this case @code{TARGET_FUNCTION_ARG} computes the register in\\n\\\n which the caller passes the value, and\\n\\\n @code{TARGET_FUNCTION_INCOMING_ARG} should be defined in a similar\\n\\\n fashion to tell the function being called where the arguments will\\n\\\n arrive.\\n\\\n \\n\\\n+@code{TARGET_FUNCTION_INCOMING_ARG} can also return arbitrary address\\n\\\n+computation using hard register, which can be forced into a register,\\n\\\n+so that it can be used to pass special arguments.\\n\\\n+\\n\\\n If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\\n\\\n @code{TARGET_FUNCTION_ARG} serves both purposes.\",\n  rtx, (cumulative_args_t ca, machine_mode mode, const_tree type,"}]}