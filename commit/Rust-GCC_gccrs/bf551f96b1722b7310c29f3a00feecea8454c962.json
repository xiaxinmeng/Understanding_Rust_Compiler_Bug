{"sha": "bf551f96b1722b7310c29f3a00feecea8454c962", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY1NTFmOTZiMTcyMmI3MzEwYzI5ZjNhMDBmZWVjZWE4NDU0Yzk2Mg==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-04-18T02:55:50Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-04-18T02:55:50Z"}, "message": "doxygroups.cc: New group on binary searching.\n\n2002-04-17  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/doxygen/doxygroups.cc:  New group on binary searching.\n\t* include/bits/stl_algo.h:  Document binary searches and merges.\n\t* include/bits/stl_deque.h:  The 'map' member is not the 'map' class.\n\nFrom-SVN: r52453", "tree": {"sha": "f86fda1c73b68c5da6c930d161c1bd88fb7020d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f86fda1c73b68c5da6c930d161c1bd88fb7020d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf551f96b1722b7310c29f3a00feecea8454c962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf551f96b1722b7310c29f3a00feecea8454c962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf551f96b1722b7310c29f3a00feecea8454c962", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf551f96b1722b7310c29f3a00feecea8454c962/comments", "author": null, "committer": null, "parents": [{"sha": "d4c6e01f81bd51ed7dbac060086f9a97ba19eb50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c6e01f81bd51ed7dbac060086f9a97ba19eb50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4c6e01f81bd51ed7dbac060086f9a97ba19eb50"}], "stats": {"total": 275, "additions": 259, "deletions": 16}, "files": [{"sha": "8b509cc627da9d1a7485ecc61e4d9b46c17e9a1a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bf551f96b1722b7310c29f3a00feecea8454c962", "patch": "@@ -1,3 +1,9 @@\n+2002-04-17  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/doxygen/doxygroups.cc:  New group on binary searching.\n+\t* include/bits/stl_algo.h:  Document binary searches and merges.\n+\t* include/bits/stl_deque.h:  The 'map' member is not the 'map' class.\n+\n 2002-04-17  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/doxygen/mainpage.html:  Doxygen logo is now a PNG file."}, {"sha": "ccf72049598687e3530e28c5cc1a1ffa4d87be7d", "filename": "libstdc++-v3/docs/doxygen/doxygroups.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc?ref=bf551f96b1722b7310c29f3a00feecea8454c962", "patch": "@@ -178,6 +178,36 @@ char* __cxa_demangle (const char* mangled_name, char* output_buffer,\n                       size_t* length, int* status);\n } // namespace abi\n \n+// // // // // // // // // // // // // // // // // // // // // // // //\n+/** @addtogroup binarysearch Binary search algorithms\n+These algorithms are variations of a classic binary search.  They all assume\n+that the sequence being searched is already sorted.\n+\n+The number of comparisons will be logarithmic (and as few as possible).\n+The number of steps through the sequence will be logarithmic for\n+random-access iterators (e.g., pointers), and linear otherwise.\n+\n+The LWG has passed Defect Report 270, which notes:  <em>The proposed\n+resolution reinterprets binary search. Instead of thinking about searching\n+for a value in a sorted range, we view that as an important special\n+case of a more general algorithm: searching for the partition point in a\n+partitioned range.  We also add a guarantee that the old wording did not:\n+we ensure that the upper bound is no earlier than the lower bound, that\n+the pair returned by equal_range is a valid range, and that the first part\n+of that pair is the lower bound.</em>\n+\n+The actual effect of the first sentence is that a comparison functor\n+passed by the user doesn't necessarily need to induce a strict weak ordering\n+relation.  Rather, it partitions the range.\n+*/\n+\n+// // // // // // // // // // // // // // // // // // // // // // // //\n+\n+// // // // // // // // // // // // // // // // // // // // // // // //\n+/* * @addtogroup groupname description of group\n+placeholder text\n+*/\n+\n // // // // // // // // // // // // // // // // // // // // // // // //\n \n // vim:et:noai:"}, {"sha": "009c409b6fb17d74e718d42a28174784541d9aaf", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 212, "deletions": 6, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=bf551f96b1722b7310c29f3a00feecea8454c962", "patch": "@@ -2756,8 +2756,15 @@ __result, __binary_pred, _IterType());\n     }\n \n \n-  // Binary search (lower_bound, upper_bound, equal_range, binary_search).\n-\n+  /**\n+   *  @brief Finds the first position in which @a val could be inserted\n+   *         without changing the ordering.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @return  An iterator pointing to the first element \"not less than\" @a val.\n+   *  @ingroup binarysearch\n+  */\n   template<typename _ForwardIter, typename _Tp>\n     _ForwardIter\n     lower_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)\n@@ -2793,6 +2800,19 @@ __result, __binary_pred, _IterType());\n       return __first;\n     }\n \n+  /**\n+   *  @brief Finds the first position in which @a val could be inserted\n+   *         without changing the ordering.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @param  comp    A functor to use for comparisons.\n+   *  @return  An iterator pointing to the first element \"not less than\" @a val.\n+   *  @ingroup binarysearch\n+   *\n+   *  The comparison function should have the same effects on ordering as\n+   *  the function used for the initial sort.\n+  */\n   template<typename _ForwardIter, typename _Tp, typename _Compare>\n     _ForwardIter\n     lower_bound(_ForwardIter __first, _ForwardIter __last,\n@@ -2824,6 +2844,15 @@ __result, __binary_pred, _IterType());\n       return __first;\n     }\n \n+  /**\n+   *  @brief Finds the last position in which @a val could be inserted\n+   *         without changing the ordering.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @return  An iterator pointing to the first element greater than @a val.\n+   *  @ingroup binarysearch\n+  */\n   template<typename _ForwardIter, typename _Tp>\n     _ForwardIter\n     upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)\n@@ -2856,6 +2885,19 @@ __result, __binary_pred, _IterType());\n       return __first;\n     }\n \n+  /**\n+   *  @brief Finds the last position in which @a val could be inserted\n+   *         without changing the ordering.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @param  comp    A functor to use for comparisons.\n+   *  @return  An iterator pointing to the first element greater than @a val.\n+   *  @ingroup binarysearch\n+   *\n+   *  The comparison function should have the same effects on ordering as\n+   *  the function used for the initial sort.\n+  */\n   template<typename _ForwardIter, typename _Tp, typename _Compare>\n     _ForwardIter\n     upper_bound(_ForwardIter __first, _ForwardIter __last,\n@@ -2887,6 +2929,22 @@ __result, __binary_pred, _IterType());\n       return __first;\n     }\n \n+  /**\n+   *  @brief Finds the largest subrange in which @a val could be inserted\n+   *         at any place in it without changing the ordering.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @return  An pair of iterators defining the subrange.\n+   *  @ingroup binarysearch\n+   *\n+   *  This is equivalent to\n+   *  @code\n+   *    std::make_pair(lower_bound(first, last, val),\n+   *                   upper_bound(first, last, val))\n+   *  @endcode\n+   *  but does not actually call those functions.\n+  */\n   template<typename _ForwardIter, typename _Tp>\n     pair<_ForwardIter, _ForwardIter>\n     equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)\n@@ -2925,6 +2983,23 @@ __result, __binary_pred, _IterType());\n       return pair<_ForwardIter, _ForwardIter>(__first, __first);\n     }\n \n+  /**\n+   *  @brief Finds the largest subrange in which @a val could be inserted\n+   *         at any place in it without changing the ordering.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @param  comp    A functor to use for comparisons.\n+   *  @return  An pair of iterators defining the subrange.\n+   *  @ingroup binarysearch\n+   *\n+   *  This is equivalent to\n+   *  @code\n+   *    std::make_pair(lower_bound(first, last, val, comp),\n+   *                   upper_bound(first, last, val, comp))\n+   *  @endcode\n+   *  but does not actually call those functions.\n+  */\n   template<typename _ForwardIter, typename _Tp, typename _Compare>\n     pair<_ForwardIter, _ForwardIter>\n     equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,\n@@ -2963,6 +3038,17 @@ __result, __binary_pred, _IterType());\n       return pair<_ForwardIter, _ForwardIter>(__first, __first);\n     }\n \n+  /**\n+   *  @brief Determines whether an element exists in a range.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @return  True if @a val (or its equivelent) is in [@a first,@a last ].\n+   *  @ingroup binarysearch\n+   *\n+   *  Note that this does not actually return an iterator to @a val.  For\n+   *  that, use std::find or a container's specialized find member functions.\n+  */\n   template<typename _ForwardIter, typename _Tp>\n     bool\n     binary_search(_ForwardIter __first, _ForwardIter __last,\n@@ -2979,6 +3065,21 @@ __result, __binary_pred, _IterType());\n       return __i != __last && !(__val < *__i);\n     }\n \n+  /**\n+   *  @brief Determines whether an element exists in a range.\n+   *  @param  first   An iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  val     The search term.\n+   *  @param  comp    A functor to use for comparisons.\n+   *  @return  True if @a val (or its equivelent) is in [@a first,@a last ].\n+   *  @ingroup binarysearch\n+   *\n+   *  Note that this does not actually return an iterator to @a val.  For\n+   *  that, use std::find or a container's specialized find member functions.\n+   *\n+   *  The comparison function should have the same effects on ordering as\n+   *  the function used for the initial sort.\n+  */\n   template<typename _ForwardIter, typename _Tp, typename _Compare>\n     bool\n     binary_search(_ForwardIter __first, _ForwardIter __last,\n@@ -2995,8 +3096,22 @@ __result, __binary_pred, _IterType());\n       return __i != __last && !__comp(__val, *__i);\n     }\n \n-  // merge, with and without an explicitly supplied comparison function.\n-\n+  /**\n+   *  @brief Merges two sorted ranges.\n+   *  @param  first1  An iterator.\n+   *  @param  first2  Another iterator.\n+   *  @param  last1   Another iterator.\n+   *  @param  last2   Another iterator.\n+   *  @param  result  An iterator pointing to the end of the merged range.\n+   *  @return  An iterator pointing to the first element \"not less than\" @a val.\n+   *\n+   *  Merges the ranges [first1,last1) and [first2,last2) into the sorted range\n+   *  [result, result + (last1-first1) + (last2-first2)).  Both input ranges\n+   *  must be sorted, and the output range must not overlap with either of\n+   *  the input ranges.  The sort is @e stable, that is, for equivalent\n+   *  elements in the two ranges, elements from the first range will always\n+   *  come before elements from the second.\n+  */\n   template<typename _InputIter1, typename _InputIter2, typename _OutputIter>\n     _OutputIter\n     merge(_InputIter1 __first1, _InputIter1 __last1,\n@@ -3028,6 +3143,26 @@ __result, __binary_pred, _IterType());\n       return copy(__first2, __last2, copy(__first1, __last1, __result));\n     }\n \n+  /**\n+   *  @brief Merges two sorted ranges.\n+   *  @param  first1  An iterator.\n+   *  @param  first2  Another iterator.\n+   *  @param  last1   Another iterator.\n+   *  @param  last2   Another iterator.\n+   *  @param  result  An iterator pointing to the end of the merged range.\n+   *  @param  comp    A functor to use for comparisons.\n+   *  @return  An iterator pointing to the first element \"not less than\" @a val.\n+   *\n+   *  Merges the ranges [first1,last1) and [first2,last2) into the sorted range\n+   *  [result, result + (last1-first1) + (last2-first2)).  Both input ranges\n+   *  must be sorted, and the output range must not overlap with either of\n+   *  the input ranges.  The sort is @e stable, that is, for equivalent\n+   *  elements in the two ranges, elements from the first range will always\n+   *  come before elements from the second.\n+   *\n+   *  The comparison function should have the same effects on ordering as\n+   *  the function used for the initial sort.\n+  */\n   template<typename _InputIter1, typename _InputIter2, typename _OutputIter,\n \t   typename _Compare>\n     _OutputIter\n@@ -3061,8 +3196,11 @@ __result, __binary_pred, _IterType());\n       return copy(__first2, __last2, copy(__first1, __last1, __result));\n     }\n \n-  // inplace_merge and its auxiliary functions.\n-\n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter, typename _Distance>\n     void\n     __merge_without_buffer(_BidirectionalIter __first,\n@@ -3102,6 +3240,11 @@ __result, __binary_pred, _IterType());\n \t\t\t     __len1 - __len11, __len2 - __len22);\n     }\n \n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter, typename _Distance, typename _Compare>\n     void\n     __merge_without_buffer(_BidirectionalIter __first,\n@@ -3142,6 +3285,11 @@ __result, __binary_pred, _IterType());\n \t\t\t     __len1 - __len11, __len2 - __len22, __comp);\n     }\n \n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter1, typename _BidirectionalIter2,\n \t   typename _Distance>\n     _BidirectionalIter1\n@@ -3170,6 +3318,11 @@ __result, __binary_pred, _IterType());\n       }\n     }\n \n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter1, typename _BidirectionalIter2,\n \t   typename _BidirectionalIter3>\n     _BidirectionalIter3\n@@ -3199,6 +3352,11 @@ __result, __binary_pred, _IterType());\n       }\n     }\n \n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter1, typename _BidirectionalIter2,\n \t   typename _BidirectionalIter3, typename _Compare>\n     _BidirectionalIter3\n@@ -3229,6 +3387,11 @@ __result, __binary_pred, _IterType());\n       }\n     }\n \n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter, typename _Distance, typename _Pointer>\n     void\n     __merge_adaptive(_BidirectionalIter __first,\n@@ -3273,6 +3436,11 @@ __result, __binary_pred, _IterType());\n \t  }\n     }\n \n+  /**\n+   *  @if maint\n+   *  This is a helper function for the merge routines.\n+   *  @endif\n+  */\n   template<typename _BidirectionalIter, typename _Distance, typename _Pointer,\n \t   typename _Compare>\n     void\n@@ -3320,6 +3488,23 @@ __result, __binary_pred, _IterType());\n \t  }\n     }\n \n+  /**\n+   *  @brief Merges two sorted ranges in place.\n+   *  @param  first   An iterator.\n+   *  @param  middle  Another iterator.\n+   *  @param  last    Another iterator.\n+   *  @return  Nothing.\n+   *\n+   *  Merges two sorted and consecutive ranges, [first,middle) and\n+   *  [middle,last), and puts the result in [first,last).  The output will\n+   *  be sorted.  The sort is @e stable, that is, for equivalent\n+   *  elements in the two ranges, elements from the first range will always\n+   *  come before elements from the second.\n+   *\n+   *  If enough additional memory is available, this takes (last-first)-1\n+   *  comparisons.  Otherwise an NlogN algorithm is used, where N is\n+   *  distance(first,last).\n+  */\n   template<typename _BidirectionalIter>\n     void\n     inplace_merge(_BidirectionalIter __first,\n@@ -3350,6 +3535,27 @@ __result, __binary_pred, _IterType());\n \t\t\t __buf.begin(), _DistanceType(__buf.size()));\n     }\n \n+  /**\n+   *  @brief Merges two sorted ranges in place.\n+   *  @param  first   An iterator.\n+   *  @param  middle  Another iterator.\n+   *  @param  last    Another iterator.\n+   *  @param  comp    A functor to use for comparisons.\n+   *  @return  Nothing.\n+   *\n+   *  Merges two sorted and consecutive ranges, [first,middle) and\n+   *  [middle,last), and puts the result in [first,last).  The output will\n+   *  be sorted.  The sort is @e stable, that is, for equivalent\n+   *  elements in the two ranges, elements from the first range will always\n+   *  come before elements from the second.\n+   *\n+   *  If enough additional memory is available, this takes (last-first)-1\n+   *  comparisons.  Otherwise an NlogN algorithm is used, where N is\n+   *  distance(first,last).\n+   *\n+   *  The comparison function should have the same effects on ordering as\n+   *  the function used for the initial sort.\n+  */\n   template<typename _BidirectionalIter, typename _Compare>\n     void\n     inplace_merge(_BidirectionalIter __first,"}, {"sha": "5fa8d125e75612525b88637bd34f556418f40c8a", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf551f96b1722b7310c29f3a00feecea8454c962/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=bf551f96b1722b7310c29f3a00feecea8454c962", "patch": "@@ -437,7 +437,8 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *  - size_t      _M_map_size\n  *  - iterator    _M_start, _M_finish\n  *  \n- *  map_size is at least 8.  map is an array of map_size pointers-to-\"nodes\".\n+ *  map_size is at least 8.  %map is an array of map_size pointers-to-\"nodes\".\n+ *  (The name has nothing to do with the std::map class.)\n  *  \n  *  A \"node\" has no specific type name as such, but it is referred to as\n  *  \"node\" in this file.  It is a simple array-of-Tp.  If Tp is very large,\n@@ -451,18 +452,18 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *  memory pool.  There are 20 hours left in the year; perhaps I can fix\n  *  this before 2002.\n  *  \n- *  Not every pointer in the map array will point to a node.  If the initial\n- *  number of elements in the deque is small, the /middle/ map pointers will\n+ *  Not every pointer in the %map array will point to a node.  If the initial\n+ *  number of elements in the deque is small, the /middle/ %map pointers will\n  *  be valid, and the ones at the edges will be unused.  This same situation\n- *  will arise as the map grows:  available map pointers, if any, will be on\n- *  the ends.  As new nodes are created, only a subset of the map's pointers\n+ *  will arise as the %map grows:  available %map pointers, if any, will be on\n+ *  the ends.  As new nodes are created, only a subset of the %map's pointers\n  *  need to be copied \"outward\".\n  *\n  *  Class invariants:\n  * - For any nonsingular iterator i:\n- *    - i.node points to a member of the map array.  (Yes, you read that\n+ *    - i.node points to a member of the %map array.  (Yes, you read that\n  *      correctly:  i.node does not actually point to a node.)  The member of\n- *      the map array is what actually points to the node.\n+ *      the %map array is what actually points to the node.\n  *    - i.first == *(i.node)    (This points to the node (first Tp element).)\n  *    - i.last  == i.first + node_size\n  *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:\n@@ -478,10 +479,10 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *   that range are uninitialized storage.  Otherwise, [start.cur, start.last)\n  *   and [finish.first, finish.cur) are initialized objects, and [start.first,\n  *   start.cur) and [finish.cur, finish.last) are uninitialized storage.\n- * - [map, map + map_size) is a valid, non-empty range.  \n+ * - [%map, %map + map_size) is a valid, non-empty range.  \n  * - [start.node, finish.node] is a valid range contained within \n- *   [map, map + map_size).  \n- * - A pointer in the range [map, map + map_size) points to an allocated node\n+ *   [%map, %map + map_size).  \n+ * - A pointer in the range [%map, %map + map_size) points to an allocated node\n  *   if and only if the pointer is in the range [start.node, finish.node].\n  *\n  *  Here's the magic:  nothing in deque is \"aware\" of the discontiguous storage!"}]}