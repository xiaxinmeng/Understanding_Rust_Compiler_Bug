{"sha": "6e1f65b5446d38f86db908b071d4b953f5c7d7da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUxZjY1YjU0NDZkMzhmODZkYjkwOGIwNzFkNGI5NTNmNWM3ZDdkYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-06T13:58:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-06T13:58:17Z"}, "message": "mcore.c (mcore_print_operand_address): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/mcore/mcore.c (mcore_print_operand_address): Use\n\tgcc_assert and gcc_unreachable as appropriate.\n\t(mcore_print_operand, mcore_gen_compare_reg, mcore_output_call,\n\tmcore_output_andn, output_inline_const, mcore_output_move,\n\tmcore_output_movedouble, mcore_expand_block_move,\n\tlayout_mcore_frame, mcore_initial_elimination_offset,\n\tmcore_expand_prolog, mcore_mark_dllexport,\n\tmcore_mark_dllimport): Likewise.\n\t* config/mcore/mcore.h (switch_to_section): Likewise.\n\t* config/mcore/mcore.md: Likewise.\n\nFrom-SVN: r99315", "tree": {"sha": "91eaf09501634f066ef20a09392320fe3f5b28f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91eaf09501634f066ef20a09392320fe3f5b28f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e1f65b5446d38f86db908b071d4b953f5c7d7da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1f65b5446d38f86db908b071d4b953f5c7d7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1f65b5446d38f86db908b071d4b953f5c7d7da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1f65b5446d38f86db908b071d4b953f5c7d7da/comments", "author": null, "committer": null, "parents": [{"sha": "858081ad6bcc54f16ad4e8500cd3ffdccf37ab39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858081ad6bcc54f16ad4e8500cd3ffdccf37ab39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858081ad6bcc54f16ad4e8500cd3ffdccf37ab39"}], "stats": {"total": 155, "additions": 68, "deletions": 87}, "files": [{"sha": "ccb0ffa15b7c75b0989bc5b0daa7a1534c68341e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e1f65b5446d38f86db908b071d4b953f5c7d7da", "patch": "@@ -1,3 +1,16 @@\n+2005-05-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/mcore/mcore.c (mcore_print_operand_address): Use\n+\tgcc_assert and gcc_unreachable as appropriate.\n+\t(mcore_print_operand, mcore_gen_compare_reg, mcore_output_call,\n+\tmcore_output_andn, output_inline_const, mcore_output_move,\n+\tmcore_output_movedouble, mcore_expand_block_move,\n+\tlayout_mcore_frame, mcore_initial_elimination_offset,\n+\tmcore_expand_prolog, mcore_mark_dllexport,\n+\tmcore_mark_dllimport): Likewise.\n+\t* config/mcore/mcore.h (switch_to_section): Likewise.\n+\t* config/mcore/mcore.md: Likewise.\n+\n 2005-05-06  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/linux64.h: Remove MASK_PROFILE_KERNEL, and"}, {"sha": "fff8a3e2896b9e61cffa6d2631801eb0749d8541", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 46, "deletions": 76, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=6e1f65b5446d38f86db908b071d4b953f5c7d7da", "patch": "@@ -309,9 +309,7 @@ mcore_print_operand_address (FILE * stream, rtx x)\n \t    break;\n \n \t  default:\n-\t    debug_rtx (x);\n-\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n       }\n \n@@ -370,7 +368,7 @@ mcore_print_operand (FILE * stream, rtx x, int code)\n \t    (stream, XEXP (adjust_address (x, SImode, 4), 0));\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n     case 'U':\n@@ -598,18 +596,12 @@ mcore_gen_compare_reg (enum rtx_code code)\n       break;\n \n     case GTU:\t/* Use inverted condition, cmple.  */\n-      if (GET_CODE (op1) == CONST_INT && INTVAL (op1) == 0)\n-\t{\n-\t  /* Unsigned > 0 is the same as != 0, but we need\n-\t     to invert the condition, so we want to set\n-\t     code = EQ.  This cannot be done however, as the\n-\t     mcore does not support such a test.  Instead we\n-\t     cope with this case in the \"bgtu\" pattern itself\n-\t     so we should never reach this point.  */\n-\t  /* code = EQ; */\n-\t  abort ();\n-\t  break;\n-\t}\n+      /* Unsigned > 0 is the same as != 0, but we need to invert the\n+\t condition, so we want to set code = EQ.  This cannot be done\n+\t however, as the mcore does not support such a test.  Instead\n+\t we cope with this case in the \"bgtu\" pattern itself so we\n+\t should never reach this point.  */\n+      gcc_assert (GET_CODE (op1) != CONST_INT || INTVAL (op1) != 0);\n       code = LEU;\n       /* Drop through.  */\n       \n@@ -666,8 +658,7 @@ mcore_output_call (rtx operands[], int index)\n     {\n       if (TARGET_CG_DATA)\n \t{\n-\t  if (mcore_current_function_name == 0)\n-\t    abort ();\n+\t  gcc_assert (mcore_current_function_name);\n \t  \n \t  ASM_OUTPUT_CG_EDGE (asm_out_file, mcore_current_function_name,\n \t\t\t      \"unknown\", 1);\n@@ -679,13 +670,11 @@ mcore_output_call (rtx operands[], int index)\n     {\n       if (TARGET_CG_DATA)\n \t{\n-\t  if (mcore_current_function_name == 0)\n-\t    abort ();\n-\t  \n-\t  if (GET_CODE (addr) != SYMBOL_REF)\n-\t    abort ();\n+\t  gcc_assert (mcore_current_function_name);\n+\t  gcc_assert (GET_CODE (addr) == SYMBOL_REF);\n \t  \n-\t  ASM_OUTPUT_CG_EDGE (asm_out_file, mcore_current_function_name, XSTR (addr, 0), 0);\n+\t  ASM_OUTPUT_CG_EDGE (asm_out_file, mcore_current_function_name,\n+\t\t\t      XSTR (addr, 0), 0);\n \t}\n       \n       sprintf (buffer, \"jbsr\\t%%%d\", index);\n@@ -1094,9 +1083,10 @@ mcore_output_andn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n   rtx out_operands[3];\n   const char * load_op;\n   char buf[256];\n+  int trick_no;\n \n-  if (try_constant_tricks (INTVAL (operands[1]), &x, &y) != 2)\n-    abort ();\n+  trick_no = try_constant_tricks (INTVAL (operands[1]), &x, &y);\n+  gcc_assert (trick_no == 2);\n \n   out_operands[0] = operands[0];\n   out_operands[1] = GEN_INT(x);\n@@ -1136,15 +1126,13 @@ output_inline_const (enum machine_mode mode, rtx operands[])\n   int value;\n \n   value = INTVAL (operands[1]);\n-   \n-  if ((trick_no = try_constant_tricks (value, &x, &y)) == 0)\n-    {\n-      /* lrw's are handled separately:  Large inlinable constants\n-\t never get turned into lrw's.  Our caller uses try_constant_tricks\n-         to back off to an lrw rather than calling this routine.  */\n-      abort ();\n-    }\n \n+  trick_no = try_constant_tricks (value, &x, &y);\n+  /* lrw's are handled separately: Large inlinable constants never get\n+     turned into lrw's.  Our caller uses try_constant_tricks to back\n+     off to an lrw rather than calling this routine.  */\n+  gcc_assert (trick_no != 0);\n+  \n   if (trick_no == 1)\n     x = value;\n \n@@ -1252,7 +1240,7 @@ mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \t      case QImode:\n \t\treturn \"ld.b\\t%0,%1\";\n \t      default:\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      }\n \t}\n       else if (GET_CODE (src) == CONST_INT)\n@@ -1283,10 +1271,10 @@ mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n       case QImode:\n \treturn \"st.b\\t%1,%0\";\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return a sequence of instructions to perform DI or DF move.\n@@ -1329,10 +1317,10 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \t      else if (GET_CODE (XEXP (memexp, 1)) == REG)\n \t\tbasereg = REGNO (XEXP (memexp, 1));\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t    }\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \n           /* ??? length attribute is wrong here.  */\n \t  if (dstreg == basereg)\n@@ -1359,7 +1347,7 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \t      else if (CONST_OK_FOR_N (INTVAL (src)))\n \t\toutput_asm_insn (\"bmaski\t%0,%N1\", operands);\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \n \t      if (INTVAL (src) < 0)\n \t\treturn \"bmaski\t%R0,32\";\n@@ -1377,7 +1365,7 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \t      else if (CONST_OK_FOR_N (INTVAL (src)))\n \t\toutput_asm_insn (\"bmaski\t%R0,%N1\", operands);\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      \n \t      if (INTVAL (src) < 0)\n \t\treturn \"bmaski\t%0,32\";\n@@ -1386,12 +1374,12 @@ mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED\n \t    }\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   else if (GET_CODE (dst) == MEM && GET_CODE (src) == REG)\n     return \"stw\\t%1,%0\\n\\tstw\\t%R1,%R0\";\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \n /* Predicates used by the templates.  */\n@@ -1624,7 +1612,7 @@ mcore_expand_block_move (rtx *operands)\n       max = 4*1;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (bytes <= max)\n@@ -1859,14 +1847,7 @@ layout_mcore_frame (struct mcore_frame * infp)\n   assert (growths <= MAX_STACK_GROWS);\n   \n   for (i = 0; i < growths; i++)\n-    {\n-      if (infp->growth[i] % STACK_BYTES)\n-\t{\n-\t  fprintf (stderr,\"stack growth of %d is not %d aligned\\n\",\n-\t\t   infp->growth[i], STACK_BYTES);\n-\t  abort ();\n-\t}\n-    }\n+    gcc_assert (!(infp->growth[i] % STACK_BYTES));\n }\n \n /* Define the offset between two registers, one to be eliminated, and\n@@ -1895,9 +1876,7 @@ mcore_initial_elimination_offset (int from, int to)\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return below_frame;\n \n-  abort ();\n-\n-  return 0;\n+  gcc_unreachable ();\n }\n \n /* Keep track of some information about varargs for the prolog.  */\n@@ -1946,13 +1925,11 @@ mcore_expand_prolog (void)\n \n       x = DECL_RTL (current_function_decl);\n       \n-      if (GET_CODE (x) != MEM)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == MEM);\n       \n       x = XEXP (x, 0);\n       \n-      if (GET_CODE (x) != SYMBOL_REF)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == SYMBOL_REF);\n       \n       if (mcore_current_function_name)\n \tfree (mcore_current_function_name);\n@@ -2866,13 +2843,10 @@ mcore_mark_dllexport (tree decl)\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n   \n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (   GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n   \n   if (mcore_dllexport_name_p (oldname))\n     return;  /* Already done.  */\n@@ -2904,17 +2878,13 @@ mcore_mark_dllimport (tree decl)\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n   \n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (   GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n   \n-  if (mcore_dllexport_name_p (oldname))\n-    abort (); /* This shouldn't happen.  */\n-  else if (mcore_dllimport_name_p (oldname))\n+  gcc_assert (!mcore_dllexport_name_p (oldname));\n+  if (mcore_dllimport_name_p (oldname))\n     return; /* Already done.  */\n \n   /* ??? One can well ask why we're making these checks here,"}, {"sha": "2e2d8656c1f8b4fa529044664e6acdf0a47c57a4", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=6e1f65b5446d38f86db908b071d4b953f5c7d7da", "patch": "@@ -885,7 +885,7 @@ switch_to_section (enum in_section section, tree decl)\t\t\\\n       case in_data: data_section (); break;\t\t\t\\\n       case in_named: named_section (decl, NULL, 0); break;\t\\\n       SUBTARGET_SWITCH_SECTIONS      \t\t\t\t\\\n-      default: abort (); break;\t\t\t\t\t\\\n+      default: gcc_unreachable (); \t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n "}, {"sha": "e79f80bc94f82ce6087895e93aaa7e3eff557f14", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1f65b5446d38f86db908b071d4b953f5c7d7da/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=6e1f65b5446d38f86db908b071d4b953f5c7d7da", "patch": "@@ -384,7 +384,7 @@\n      case 2: return \\\"and\t%0,%1\\\";\n      /* case -1: return \\\"bclri\t%0,%Q2\\\";\t will not happen */\n      case 3: return mcore_output_bclri (operands[0], INTVAL (operands[2]));\n-     default: abort ();\n+     default: gcc_unreachable ();\n      }\n }\")\n \n@@ -404,7 +404,7 @@\n      case 1: return \\\"andi\t%0,%2\\\";\n      case 2: return \\\"and\t%0,%1\\\";\n      case 3: return mcore_output_bclri (operands[0], INTVAL (operands[2]));\n-     default: abort ();\n+     default: gcc_unreachable ();\n      }\n }\")\n \n@@ -439,7 +439,7 @@\n      case 0: return \\\"or\t%0,%2\\\";\n      case 1: return \\\"bseti\t%0,%P2\\\";\n      case 2: return mcore_output_bseti (operands[0], INTVAL (operands[2]));\n-     default: abort ();\n+     default: gcc_unreachable ();\n      }\n }\")\n \n@@ -455,7 +455,7 @@\n      case 0: return \\\"or\t%0,%2\\\";\n      case 1: return \\\"bseti\t%0,%P2\\\";\n      case 2: return mcore_output_bseti (operands[0], INTVAL (operands[2]));\n-     default: abort ();\n+     default: gcc_unreachable ();\n      }\n }\")\n \n@@ -928,8 +928,7 @@\n    && INTVAL (operands[2]) > 0 && ! (INTVAL (operands[2]) & 0x80000000)\"\n   \"*\n {\n-  if (GET_MODE (operands[2]) != SImode)\n-     abort ();\n+  gcc_assert (GET_MODE (operands[2]) == SImode);\n   if (TARGET_LITTLE_END)\n     return \\\"addu\t%0,%2\\;cmphs\t%0,%2\\;incf\t%R0\\\";\n   return \\\"addu\t%R0,%2\\;cmphs\t%R0,%2\\;incf\t%0\\\";\n@@ -3072,7 +3071,7 @@\n    else if ((ofs = mcore_halfword_offset (INTVAL (operands[3]))) > -1)\n       mode = HImode;\n    else\n-      abort ();\n+      gcc_unreachable ();\n \n    if (ofs > 0) \n       operands[4] = gen_rtx_MEM (mode, \n@@ -3148,15 +3147,14 @@\n  \t   return \\\"btsti\t%1,%2\\\\n\\\\tmovt\t%0,%4\\\";\n        }\n \n-     abort ();\n+     gcc_unreachable ();\n     }\n   else if (GET_CODE (operands[3]) == CONST_INT\n            && INTVAL (operands[3]) == 0\n \t   && GET_CODE (operands[4]) == REG)\n      return \\\"btsti\t%1,%2\\\\n\\\\tclrt\t%0\\\";\n \n-  abort ();\n-  return \\\"\\\"; \n+  gcc_unreachable ();\n }\")\n \n ; experimental - do the constant folding ourselves.  note that this isn't"}]}