{"sha": "20e545c381eecde36210a913e013e588422a3cef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBlNTQ1YzM4MWVlY2RlMzYyMTBhOTEzZTAxM2U1ODg0MjJhM2NlZg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2007-10-24T07:51:09Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2007-10-24T07:51:09Z"}, "message": "tree-vect-analyze.c (vect_build_slp_tree): Return false if vectype cannot be determined for the scalar type.\n\n\t* tree-vect-analyze.c (vect_build_slp_tree): Return false if\n\tvectype cannot be determined for the scalar type.\n\t(vect_analyze_slp_instance): Likewise.\n\t* tree-vect-transform.c (vect_model_reduction_cost): Change the\n\treturn type to bool. Return false if vectype cannot be determined \n\tfor the scalar type.\n\t(vect_get_constant_vectors): Return false if vectype cannot be\n\tdetermined for the scalar type.\n\t(get_initial_def_for_induction, vect_get_vec_def_for_operand,\n\tget_initial_def_for_reduction, vect_create_epilog_for_reduction,\n\tvectorizable_reduction): Likewise.\n\nFrom-SVN: r129598", "tree": {"sha": "be49be44f7fe1b474532f24bb801a3fab5d4758b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be49be44f7fe1b474532f24bb801a3fab5d4758b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20e545c381eecde36210a913e013e588422a3cef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20e545c381eecde36210a913e013e588422a3cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20e545c381eecde36210a913e013e588422a3cef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20e545c381eecde36210a913e013e588422a3cef/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f4fd5362d14e6ca794b629befd60b7b3aa56a42"}], "stats": {"total": 77, "additions": 72, "deletions": 5}, "files": [{"sha": "5c53f623f92e9aeec32a44bc87ab8a172baa2655", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20e545c381eecde36210a913e013e588422a3cef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20e545c381eecde36210a913e013e588422a3cef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20e545c381eecde36210a913e013e588422a3cef", "patch": "@@ -1,3 +1,17 @@\n+2007-10-24  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (vect_build_slp_tree): Return false if\n+\tvectype cannot be determined for the scalar type.\n+\t(vect_analyze_slp_instance): Likewise.\n+\t* tree-vect-transform.c (vect_model_reduction_cost): Change the\n+\treturn type to bool. Return false if vectype cannot be determined \n+\tfor the scalar type.\n+\t(vect_get_constant_vectors): Return false if vectype cannot be\n+\tdetermined for the scalar type.\n+\t(get_initial_def_for_induction, vect_get_vec_def_for_operand,\n+\tget_initial_def_for_reduction, vect_create_epilog_for_reduction,\n+\tvectorizable_reduction): Likewise.\t\n+\n 2007-10-23  Craig Rodrigues  <rodrigc@gcc.gnu.org>\n \n \t* config.gcc: For a FreeBSD target, parse the value of ${target}"}, {"sha": "8975e64ab719eb9ab6a6b9c6063405827e306e31", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20e545c381eecde36210a913e013e588422a3cef/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20e545c381eecde36210a913e013e588422a3cef/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=20e545c381eecde36210a913e013e588422a3cef", "patch": "@@ -2682,6 +2682,16 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \n       scalar_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n       vectype = get_vectype_for_scalar_type (scalar_type);\n+      if (!vectype)\n+        {\n+          if (vect_print_dump_info (REPORT_SLP))\n+            {\n+              fprintf (vect_dump, \"Build SLP failed: unsupported data-type \");\n+              print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+            }\n+          return false;\n+        }\n+\n       gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n       vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n@@ -2987,6 +2997,16 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, tree stmt)\n   /* FORNOW: multiple types are not supported.  */\n   scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))));\n   vectype = get_vectype_for_scalar_type (scalar_type);\n+  if (!vectype)\n+    {\n+      if (vect_print_dump_info (REPORT_SLP))\n+        {\n+          fprintf (vect_dump, \"Build SLP failed: unsupported data-type \");\n+          print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+        }\n+      return false;\n+    }\n+\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   ncopies = vectorization_factor / nunits;"}, {"sha": "81abd36faddcbb274a843c3a3c691f4beea9cd3d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20e545c381eecde36210a913e013e588422a3cef/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20e545c381eecde36210a913e013e588422a3cef/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=20e545c381eecde36210a913e013e588422a3cef", "patch": "@@ -380,7 +380,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n    generated within the strip-mine loop, the initial definition before\n    the loop, and the epilogue code that must be generated.  */\n \n-static void\n+static bool \n vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t\t\t   int ncopies)\n {\n@@ -401,6 +401,16 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n   reduction_op = TREE_OPERAND (operation, op_type-1);\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n+  if (!vectype)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"unsupported data-type \");\n+          print_generic_expr (vect_dump, TREE_TYPE (reduction_op), TDF_SLIM);\n+        }\n+      return false;\n+   }\n+  \n   mode = TYPE_MODE (vectype);\n   orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n \n@@ -452,6 +462,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n     fprintf (vect_dump, \"vect_model_reduction_cost: inside_cost = %d, \"\n              \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n              STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+\n+  return true;\n }\n \n \n@@ -1349,6 +1361,7 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n               number_of_places_left_in_vector = nunits;\n \n \t      vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+              gcc_assert (vector_type);\n               vec_cst = build_constructor_from_list (vector_type, t);\n               VEC_quick_push (tree, voprnds,\n                               vect_init_vector (stmt, vec_cst, vector_type,\n@@ -1473,8 +1486,8 @@ get_initial_def_for_induction (tree iv_phi)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (PHI_RESULT_TREE (iv_phi));\n-  tree vectype = get_vectype_for_scalar_type (scalar_type);\n-  int nunits =  TYPE_VECTOR_SUBPARTS (vectype);\n+  tree vectype; \n+  int nunits;\n   edge pe = loop_preheader_edge (loop);\n   struct loop *iv_loop;\n   basic_block new_bb;\n@@ -1488,7 +1501,7 @@ get_initial_def_for_induction (tree iv_phi)\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   int i;\n   bool ok;\n-  int ncopies = vf / nunits;\n+  int ncopies;\n   tree expr;\n   stmt_vec_info phi_info = vinfo_for_stmt (iv_phi);\n   bool nested_in_vect_loop = false;\n@@ -1501,6 +1514,11 @@ get_initial_def_for_induction (tree iv_phi)\n   block_stmt_iterator si;\n   basic_block bb = bb_for_stmt (iv_phi);\n \n+  vectype = get_vectype_for_scalar_type (scalar_type);\n+  gcc_assert (vectype);\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  ncopies = vf / nunits;\n+\n   gcc_assert (phi_info);\n   gcc_assert (ncopies >= 1);\n \n@@ -1791,6 +1809,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n             t = tree_cons (NULL_TREE, op, t);\n           }\n         vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+        gcc_assert (vector_type);\n         vec_cst = build_vector (vector_type, t);\n \n         return vect_init_vector (stmt, vec_cst, vector_type, NULL);\n@@ -1813,6 +1832,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n \n \t/* FIXME: use build_constructor directly.  */\n \tvector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n+        gcc_assert (vector_type);\n         vec_inv = build_constructor_from_list (vector_type, t);\n         return vect_init_vector (stmt, vec_inv, vector_type, NULL);\n       }\n@@ -2112,6 +2132,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *adjustment_def)\n       for (i = nunits - 1; i >= 0; --i)\n     t = tree_cons (NULL_TREE, def_for_init, t);\n     vector_type = get_vectype_for_scalar_type (TREE_TYPE (def_for_init));\n+    gcc_assert (vector_type);\n     init_def = build_vector (vector_type, t);\n     break;\n \n@@ -2222,6 +2243,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   op_type = TREE_OPERAND_LENGTH (operation);\n   reduction_op = TREE_OPERAND (operation, op_type-1);\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n+  gcc_assert (vectype);\n   mode = TYPE_MODE (vectype);\n \n   /*** 1. Create the reduction def-use cycle  ***/\n@@ -2795,6 +2817,16 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n          reduction variable, and get the tree-code from orig_stmt.  */\n       orig_code = TREE_CODE (GIMPLE_STMT_OPERAND (orig_stmt, 1));\n       vectype = get_vectype_for_scalar_type (TREE_TYPE (def));\n+      if (!vectype)\n+\t{\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"unsupported data-type \");\n+              print_generic_expr (vect_dump, TREE_TYPE (def), TDF_SLIM);\n+            }\n+          return false;\n+        }\n+\n       vec_mode = TYPE_MODE (vectype);\n     }\n   else\n@@ -2823,7 +2855,8 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n-      vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies);\n+      if (!vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies))\n+        return false;\n       return true;\n     }\n "}]}