{"sha": "9a4ac625f18628b863f6e58c0effd749039ff7a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE0YWM2MjVmMTg2MjhiODYzZjZlNThjMGVmZmQ3NDkwMzlmZjdhNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-30T14:08:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-30T14:08:03Z"}, "message": "ipa-inline.c (can_inline_edge_p): Disregard limits when inlining into function with flatten attribute.\n\n\t* ipa-inline.c (can_inline_edge_p): Disregard limits when\n\tinlining into function with flatten attribute.\n\t(want_inline_small_function_p): Be more realistic about inlining\n\tcold calls where callee size grows.\n\nFrom-SVN: r173216", "tree": {"sha": "f8a79be03ab3f9bdbe5c053e8f6b97f09a0b90fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8a79be03ab3f9bdbe5c053e8f6b97f09a0b90fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a4ac625f18628b863f6e58c0effd749039ff7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4ac625f18628b863f6e58c0effd749039ff7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a4ac625f18628b863f6e58c0effd749039ff7a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4ac625f18628b863f6e58c0effd749039ff7a5/comments", "author": null, "committer": null, "parents": [{"sha": "dd8352ee7addba482fb1130cc91b22dc9df39d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd8352ee7addba482fb1130cc91b22dc9df39d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd8352ee7addba482fb1130cc91b22dc9df39d60"}], "stats": {"total": 51, "additions": 48, "deletions": 3}, "files": [{"sha": "2d7deb984e99a3fa4b8352d4ffc2f3fcfcdc3835", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a4ac625f18628b863f6e58c0effd749039ff7a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a4ac625f18628b863f6e58c0effd749039ff7a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a4ac625f18628b863f6e58c0effd749039ff7a5", "patch": "@@ -1,3 +1,10 @@\n+2011-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (can_inline_edge_p): Disregard limits when\n+\tinlining into function with flatten attribute.\n+\t(want_inline_small_function_p): Be more realistic about inlining\n+\tcold calls where callee size grows.\n+\n 2011-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_create_virtual_clone): Clear constructor/destructor"}, {"sha": "4665c82ac887ac44b63b41cbea32ae4513edd00f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a4ac625f18628b863f6e58c0effd749039ff7a5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a4ac625f18628b863f6e58c0effd749039ff7a5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9a4ac625f18628b863f6e58c0effd749039ff7a5", "patch": "@@ -272,9 +272,11 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n      FIXME: this is obviously wrong for LTO where STRUCT_FUNCTION is missing.\n      Move the flag into cgraph node or mirror it in the inline summary.  */\n   else if (DECL_STRUCT_FUNCTION (e->callee->decl)\n-\t   && DECL_STRUCT_FUNCTION (e->callee->decl)->can_throw_non_call_exceptions\n+\t   && DECL_STRUCT_FUNCTION\n+\t        (e->callee->decl)->can_throw_non_call_exceptions\n \t   && !(DECL_STRUCT_FUNCTION (e->caller->decl)\n-\t        && DECL_STRUCT_FUNCTION (e->caller->decl)->can_throw_non_call_exceptions))\n+\t        && DECL_STRUCT_FUNCTION\n+\t\t     (e->caller->decl)->can_throw_non_call_exceptions))\n     {\n       e->inline_failed = CIF_NON_CALL_EXCEPTIONS;\n       inlinable = false;\n@@ -288,6 +290,11 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n     }\n   /* Check if caller growth allows the inlining.  */\n   else if (!DECL_DISREGARD_INLINE_LIMITS (e->callee->decl)\n+\t   && !lookup_attribute (\"flatten\",\n+\t\t\t\t DECL_ATTRIBUTES\n+\t\t\t\t   (e->caller->global.inlined_to\n+\t\t\t\t    ? e->caller->global.inlined_to->decl\n+\t\t\t\t    : e->caller->decl))\n            && !caller_growth_limits (e))\n     inlinable = false;\n   /* Don't inline a function with a higher optimization level than the\n@@ -468,8 +475,39 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n           e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n \t  want_inline = false;\n \t}\n+      /* If call is cold, do not inline when function body would grow.\n+\t Still inline when the overall unit size will shrink because the offline\n+\t copy of function being eliminated.\n+\n+\t This is slightly wrong on aggressive side:  it is entirely possible\n+\t that function is called many times with a context where inlining\n+\t reduces code size and few times with a context where inlining increase\n+\t code size.  Resoluting growth estimate will be negative even if it\n+\t would make more sense to keep offline copy and do not inline into the\n+\t call sites that makes the code size grow.  \n+\n+\t When badness orders the calls in a way that code reducing calls come\n+\t first, this situation is not a problem at all: after inlining all\n+\t \"good\" calls, we will realize that keeping the function around is\n+\t better.  */\n       else if (!cgraph_maybe_hot_edge_p (e)\n-\t       && estimate_growth (e->callee) > 0)\n+\t       && (DECL_EXTERNAL (e->callee->decl)\n+\n+\t\t   /* Unlike for functions called once, we play unsafe with\n+\t\t      COMDATs.  We can allow that since we know functions\n+\t\t      in consideration are small (and thus risk is small) and\n+\t\t      moreover grow estimates already accounts that COMDAT\n+\t\t      functions may or may not disappear when eliminated from\n+\t\t      current unit. With good probability making aggressive\n+\t\t      choice in all units is going to make overall program\n+\t\t      smaller.\n+\n+\t\t      Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n+\t\t      instead of\n+\t\t      cgraph_will_be_removed_from_program_if_no_direct_calls  */\n+\n+\t\t   || !cgraph_can_remove_if_no_direct_calls_p (e->callee)\n+\t\t   || estimate_growth (e->callee) > 0))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n \t  want_inline = false;"}]}