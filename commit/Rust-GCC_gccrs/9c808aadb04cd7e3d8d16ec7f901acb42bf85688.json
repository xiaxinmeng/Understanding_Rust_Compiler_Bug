{"sha": "9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM4MDhhYWRiMDRjZDdlM2Q4ZDE2ZWM3ZjkwMWFjYjQyYmY4NTY4OA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-08-17T10:00:04Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-08-17T10:00:04Z"}, "message": "alpha.md: Remove usage of PARAMS.\n\n        * config/alpha/alpha.md: Remove usage of PARAMS.\n\n        * config/i386/cygwin.h: Convert K&R prototypes to ISO C90.\n        * config/i386/i386-interix.h: Likewise.\n        * config/i386/winnt.c: Likewise.\n        * config/i386/cygming.h: Likewise.\n        * config/i386/cygwin2.c: Likewise.\n        * config/darwin.c: Likewise.\n        * config/darwin-c.c: Likewise.\n        * config/darwin-protos.h: Likewise.\n        * config/darwin.h: Likewise.\n        * config/s390/s390-protos.h: Likewise.\n        * config/s390/s390.c: Likewise.\n        * config/ia64/ia64.c: Likewse\n        * config/ia64/ia64-protos.h: Likewise.\n\nFrom-SVN: r70515", "tree": {"sha": "d6b23a5151dcb5d2757cb4feb4eb386e92948955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b23a5151dcb5d2757cb4feb4eb386e92948955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e20bcc5e135de04fb4fa4126f47207b569782542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e20bcc5e135de04fb4fa4126f47207b569782542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e20bcc5e135de04fb4fa4126f47207b569782542"}], "stats": {"total": 2739, "additions": 1072, "deletions": 1667}, "files": [{"sha": "3f147d7d6a06e2ec455321d73070a926775b134a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -1,3 +1,21 @@\n+2003-08-17  Andreas Jaeger  <aj@suse.de>\n+\n+\t* config/alpha/alpha.md: Remove usage of PARAMS.\n+\n+\t* config/i386/cygwin.h: Convert K&R prototypes to ISO C90.\n+\t* config/i386/i386-interix.h: Likewise.\n+\t* config/i386/winnt.c: Likewise.\n+\t* config/i386/cygming.h: Likewise.\n+\t* config/i386/cygwin2.c: Likewise.\n+\t* config/darwin.c: Likewise.\n+\t* config/darwin-c.c: Likewise.\n+\t* config/darwin-protos.h: Likewise.\n+\t* config/darwin.h: Likewise.\n+\t* config/s390/s390-protos.h: Likewise.\n+\t* config/s390/s390.c: Likewise.\n+\t* config/ia64/ia64.c: Likewse\n+\t* config/ia64/ia64-protos.h: Likewise.\n+\n 2003-08-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/sparc/sparc.c: Convert to ISO C."}, {"sha": "a7680d9ac9974d287c16871f690fc80f5bc0ee95", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -7171,7 +7171,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extxl_be;\n   else\n@@ -7186,7 +7186,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extxl_be;\n   else\n@@ -7201,7 +7201,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extxl_be;\n   else\n@@ -7216,7 +7216,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extxl_be;\n   else\n@@ -7231,7 +7231,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extwh_be;\n   else\n@@ -7246,7 +7246,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extlh_be;\n   else\n@@ -7261,7 +7261,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_extqh_be;\n   else\n@@ -7276,7 +7276,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_insbl_be;\n   else\n@@ -7292,7 +7292,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_inswl_be;\n   else\n@@ -7308,7 +7308,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_insll_be;\n   else\n@@ -7325,7 +7325,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx);\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_insql_be;\n   else\n@@ -7370,7 +7370,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx mask;\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_mskxl_be;\n@@ -7387,7 +7387,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx mask;\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_mskxl_be;\n@@ -7404,7 +7404,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx mask;\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_mskxl_be;\n@@ -7421,7 +7421,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n    (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n   \"\"\n {\n-  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx mask;\n   if (WORDS_BIG_ENDIAN)\n     gen = gen_mskxl_be;"}, {"sha": "c92c12f2ff98b036178104ab69dda07dafe8ab0d", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -1,6 +1,5 @@\n /* Darwin support needed only by C/C++ frontends.\n-   Copyright (C) 2001\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003  Free Software Foundation, Inc.\n    Contributed by Apple Computer Inc.\n \n This file is part of GNU CC.\n@@ -38,8 +37,8 @@ Boston, MA 02111-1307, USA.  */\n /* Maintain a small stack of alignments.  This is similar to pragma\n    pack's stack, but simpler.  */\n \n-static void push_field_alignment PARAMS ((int));\n-static void pop_field_alignment PARAMS ((void));\n+static void push_field_alignment (int);\n+static void pop_field_alignment (void);\n \n typedef struct align_stack\n {\n@@ -50,8 +49,7 @@ typedef struct align_stack\n static struct align_stack * field_align_stack = NULL;\n \n static void\n-push_field_alignment (bit_alignment)\n-     int bit_alignment;\n+push_field_alignment (int bit_alignment)\n {\n   align_stack *entry = (align_stack *) xmalloc (sizeof (align_stack));\n \n@@ -63,7 +61,7 @@ push_field_alignment (bit_alignment)\n }\n \n static void\n-pop_field_alignment ()\n+pop_field_alignment (void)\n {\n   if (field_align_stack)\n     {\n@@ -80,17 +78,15 @@ pop_field_alignment ()\n /* Handlers for Darwin-specific pragmas.  */\n \n void\n-darwin_pragma_ignore (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+darwin_pragma_ignore (cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   /* Do nothing.  */\n }\n \n /* #pragma options align={mac68k|power|reset} */\n \n void\n-darwin_pragma_options (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+darwin_pragma_options (cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   const char *arg;\n   tree t, x;\n@@ -122,8 +118,7 @@ darwin_pragma_options (pfile)\n /* #pragma unused ([var {, var}*]) */\n \n void\n-darwin_pragma_unused (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+darwin_pragma_unused (cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   tree decl, x;\n   int tok;"}, {"sha": "68ae21c44a7dded7dab38f3854488daa020ee6f4", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -18,105 +18,105 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern int name_needs_quotes PARAMS ((const char *));\n+extern int name_needs_quotes (const char *);\n \n-extern void machopic_validate_stub_or_non_lazy_ptr PARAMS ((const char *, int));\n+extern void machopic_validate_stub_or_non_lazy_ptr (const char *, int);\n \n-extern const char *machopic_function_base_name PARAMS ((void));\n+extern const char *machopic_function_base_name (void);\n extern void machopic_output_function_base_name (FILE *);\n-extern const char *machopic_non_lazy_ptr_name PARAMS ((const char*));\n-extern const char *machopic_stub_name PARAMS ((const char*));\n+extern const char *machopic_non_lazy_ptr_name (const char*);\n+extern const char *machopic_stub_name (const char*);\n \n-extern void machopic_picsymbol_stub_section PARAMS ((void));\n-extern void machopic_picsymbol_stub1_section PARAMS ((void));\n-extern void machopic_symbol_stub_section PARAMS ((void));\n-extern void machopic_symbol_stub1_section PARAMS ((void));\n-extern void machopic_lazy_symbol_ptr_section PARAMS ((void));\n-extern void machopic_nl_symbol_ptr_section PARAMS ((void));\n+extern void machopic_picsymbol_stub_section (void);\n+extern void machopic_picsymbol_stub1_section (void);\n+extern void machopic_symbol_stub_section (void);\n+extern void machopic_symbol_stub1_section (void);\n+extern void machopic_lazy_symbol_ptr_section (void);\n+extern void machopic_nl_symbol_ptr_section (void);\n \n-extern void constructor_section PARAMS ((void));\n-extern void destructor_section PARAMS ((void));\n-extern void mod_init_section PARAMS ((void));\n-extern void mod_term_section PARAMS ((void));\n+extern void constructor_section (void);\n+extern void destructor_section (void);\n+extern void mod_init_section (void);\n+extern void mod_term_section (void);\n \n #ifdef RTX_CODE\n \n-extern int machopic_operand_p PARAMS ((rtx));\n-extern enum machopic_addr_class machopic_classify_name PARAMS ((const char*));\n+extern int machopic_operand_p (rtx);\n+extern enum machopic_addr_class machopic_classify_name (const char*);\n \n-extern rtx machopic_indirect_data_reference PARAMS ((rtx, rtx));\n-extern rtx machopic_indirect_call_target PARAMS ((rtx));\n-extern rtx machopic_legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n+extern rtx machopic_indirect_data_reference (rtx, rtx);\n+extern rtx machopic_indirect_call_target (rtx);\n+extern rtx machopic_legitimize_pic_address (rtx, enum machine_mode, rtx);\n \n-extern void machopic_asm_out_constructor PARAMS ((rtx, int));\n-extern void machopic_asm_out_destructor PARAMS ((rtx, int));\n+extern void machopic_asm_out_constructor (rtx, int);\n+extern void machopic_asm_out_destructor (rtx, int);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n \n-extern enum machopic_addr_class machopic_classify_ident PARAMS ((tree));\n-extern void machopic_define_ident PARAMS ((tree));\n-extern void machopic_define_name PARAMS ((const char*));\n-extern int machopic_name_defined_p PARAMS ((const char*));\n-extern int machopic_ident_defined_p PARAMS ((tree));\n-extern void darwin_encode_section_info PARAMS ((tree, rtx, int));\n-extern const char *darwin_strip_name_encoding PARAMS ((const char *));\n+extern enum machopic_addr_class machopic_classify_ident (tree);\n+extern void machopic_define_ident (tree);\n+extern void machopic_define_name (const char*);\n+extern int machopic_name_defined_p (const char*);\n+extern int machopic_ident_defined_p (tree);\n+extern void darwin_encode_section_info (tree, rtx, int);\n+extern const char *darwin_strip_name_encoding (const char *);\n \n #endif /* TREE_CODE */\n \n-extern void machopic_finish PARAMS ((FILE *));\n+extern void machopic_finish (FILE *);\n \n-extern void machopic_output_possible_stub_label PARAMS ((FILE *, const char*));\n+extern void machopic_output_possible_stub_label (FILE *, const char*);\n \n-extern void darwin_exception_section PARAMS ((void));\n-extern void darwin_eh_frame_section PARAMS ((void));\n-extern void machopic_select_section PARAMS ((tree, int,\n-\t\t\t\t\t     unsigned HOST_WIDE_INT));\n-extern void machopic_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n+extern void darwin_exception_section (void);\n+extern void darwin_eh_frame_section (void);\n+extern void machopic_select_section (tree, int, unsigned HOST_WIDE_INT);\n+extern void machopic_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\t unsigned HOST_WIDE_INT);\n \n-extern void darwin_pragma_ignore PARAMS ((struct cpp_reader *));\n-extern void darwin_pragma_options PARAMS ((struct cpp_reader *));\n-extern void darwin_pragma_unused PARAMS ((struct cpp_reader *));\n+extern void darwin_pragma_ignore (struct cpp_reader *);\n+extern void darwin_pragma_options (struct cpp_reader *);\n+extern void darwin_pragma_unused (struct cpp_reader *);\n \n-extern void darwin_file_end PARAMS ((void));\n+extern void darwin_file_end (void);\n \n /* Expanded by EXTRA_SECTION_FUNCTIONS into varasm.o.  */\n-extern void const_section PARAMS ((void));\n-extern void const_data_section PARAMS ((void));\n-extern void cstring_section PARAMS ((void));\n-extern void literal4_section PARAMS ((void));\n-extern void literal8_section PARAMS ((void));\n-extern void constructor_section PARAMS ((void));\n-extern void mod_init_section PARAMS ((void));\n-extern void mod_term_section PARAMS ((void));\n-extern void destructor_section PARAMS ((void));\n-extern void objc_class_section PARAMS ((void));\n-extern void objc_meta_class_section PARAMS ((void));\n-extern void objc_category_section PARAMS ((void));\n-extern void objc_class_vars_section PARAMS ((void));\n-extern void objc_instance_vars_section PARAMS ((void));\n-extern void objc_cls_meth_section PARAMS ((void));\n-extern void objc_inst_meth_section PARAMS ((void));\n-extern void objc_cat_cls_meth_section PARAMS ((void));\n-extern void objc_cat_inst_meth_section PARAMS ((void));\n-extern void objc_selector_refs_section PARAMS ((void));\n-extern void objc_selector_fixup_section PARAMS ((void));\n-extern void objc_symbols_section PARAMS ((void));\n-extern void objc_module_info_section PARAMS ((void));\n-extern void objc_protocol_section PARAMS ((void));\n-extern void objc_string_object_section PARAMS ((void));\n-extern void objc_constant_string_object_section PARAMS ((void));\n-extern void objc_class_names_section PARAMS ((void));\n-extern void objc_meth_var_names_section PARAMS ((void));\n-extern void objc_meth_var_types_section PARAMS ((void));\n-extern void objc_cls_refs_section PARAMS ((void));\n-extern void machopic_lazy_symbol_ptr_section PARAMS ((void));\n-extern void machopic_nl_symbol_ptr_section PARAMS ((void));\n-extern void machopic_symbol_stub_section PARAMS ((void));\n-extern void machopic_picsymbol_stub_section PARAMS ((void));\n-extern void machopic_output_stub PARAMS ((FILE *, const char *, const char *));\n-extern void darwin_exception_section PARAMS ((void));\n-extern void darwin_eh_frame_section PARAMS ((void));\n-extern void darwin_globalize_label PARAMS ((FILE *, const char *));\n-extern void darwin_asm_output_dwarf_delta PARAMS ((FILE *, int, const char *, const char *));\n+extern void const_section (void);\n+extern void const_data_section (void);\n+extern void cstring_section (void);\n+extern void literal4_section (void);\n+extern void literal8_section (void);\n+extern void constructor_section (void);\n+extern void mod_init_section (void);\n+extern void mod_term_section (void);\n+extern void destructor_section (void);\n+extern void objc_class_section (void);\n+extern void objc_meta_class_section (void);\n+extern void objc_category_section (void);\n+extern void objc_class_vars_section (void);\n+extern void objc_instance_vars_section (void);\n+extern void objc_cls_meth_section (void);\n+extern void objc_inst_meth_section (void);\n+extern void objc_cat_cls_meth_section (void);\n+extern void objc_cat_inst_meth_section (void);\n+extern void objc_selector_refs_section (void);\n+extern void objc_selector_fixup_section (void);\n+extern void objc_symbols_section (void);\n+extern void objc_module_info_section (void);\n+extern void objc_protocol_section (void);\n+extern void objc_string_object_section (void);\n+extern void objc_constant_string_object_section (void);\n+extern void objc_class_names_section (void);\n+extern void objc_meth_var_names_section (void);\n+extern void objc_meth_var_types_section (void);\n+extern void objc_cls_refs_section (void);\n+extern void machopic_lazy_symbol_ptr_section (void);\n+extern void machopic_nl_symbol_ptr_section (void);\n+extern void machopic_symbol_stub_section (void);\n+extern void machopic_picsymbol_stub_section (void);\n+extern void machopic_output_stub (FILE *, const char *, const char *);\n+extern void darwin_exception_section (void);\n+extern void darwin_eh_frame_section (void);\n+extern void darwin_globalize_label (FILE *, const char *);\n+extern void darwin_asm_output_dwarf_delta (FILE *, int, const char *,\n+\t\t\t\t\t   const char *);"}, {"sha": "4c019c7eef7b4a8f00abf534aa1d44824b0b4128", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 90, "deletions": 129, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -42,13 +42,12 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include \"tm_p.h\"\n \n-static int machopic_data_defined_p PARAMS ((const char *));\n-static void update_non_lazy_ptrs PARAMS ((const char *));\n-static void update_stubs PARAMS ((const char *));\n+static int machopic_data_defined_p (const char *);\n+static void update_non_lazy_ptrs (const char *);\n+static void update_stubs (const char *);\n \n int\n-name_needs_quotes (name)\n-     const char *name;\n+name_needs_quotes (const char *name)\n {\n   int c;\n   while ((c = *name++) != '\\0')\n@@ -57,7 +56,7 @@ name_needs_quotes (name)\n   return 0;\n }\n \n-/* \n+/*\n  * flag_pic = 1 ... generate only indirections\n  * flag_pic = 2 ... generate indirections and pure code\n  */\n@@ -68,20 +67,19 @@ name_needs_quotes (name)\n static GTY(()) tree machopic_defined_list;\n \n enum machopic_addr_class\n-machopic_classify_ident (ident)\n-     tree ident;\n+machopic_classify_ident (tree ident)\n {\n   const char *name = IDENTIFIER_POINTER (ident);\n   int lprefix = (((name[0] == '*' || name[0] == '&')\n \t\t  && (name[1] == 'L' || (name[1] == '\"' && name[2] == 'L')))\n-\t\t || (   name[0] == '_' \n-\t\t     && name[1] == 'O' \n-\t\t     && name[2] == 'B' \n+\t\t || (   name[0] == '_'\n+\t\t     && name[1] == 'O'\n+\t\t     && name[2] == 'B'\n \t\t     && name[3] == 'J'\n \t\t     && name[4] == 'C'\n \t\t     && name[5] == '_'));\n   tree temp;\n-  \n+\n   /* The PIC base symbol is always defined. */\n   if (! strcmp (name, \"<pic base>\"))\n     return MACHOPIC_DEFINED_DATA;\n@@ -146,7 +144,7 @@ machopic_classify_ident (ident)\n \t    return MACHOPIC_DEFINED_DATA;\n \t}\n     }\n-  \n+\n   if (name[1] == 't' || name[1] == 'T')\n     {\n       if (lprefix)\n@@ -163,17 +161,15 @@ machopic_classify_ident (ident)\n     }\n }\n \n-     \n+\n enum machopic_addr_class\n-machopic_classify_name (name)\n-     const char *name;\n+machopic_classify_name (const char *name)\n {\n   return machopic_classify_ident (get_identifier (name));\n }\n \n int\n-machopic_ident_defined_p (ident)\n-     tree ident;\n+machopic_ident_defined_p (tree ident)\n {\n   switch (machopic_classify_ident (ident))\n     {\n@@ -187,8 +183,7 @@ machopic_ident_defined_p (ident)\n }\n \n static int\n-machopic_data_defined_p (name)\n-     const char *name;\n+machopic_data_defined_p (const char *name)\n {\n   switch (machopic_classify_ident (get_identifier (name)))\n     {\n@@ -200,42 +195,39 @@ machopic_data_defined_p (name)\n }\n \n int\n-machopic_name_defined_p (name)\n-     const char *name;\n+machopic_name_defined_p (const char *name)\n {\n   return machopic_ident_defined_p (get_identifier (name));\n }\n \n void\n-machopic_define_ident (ident)\n-     tree ident;\n+machopic_define_ident (tree ident)\n {\n   if (!machopic_ident_defined_p (ident))\n-    machopic_defined_list = \n+    machopic_defined_list =\n       tree_cons (NULL_TREE, ident, machopic_defined_list);\n }\n \n void\n-machopic_define_name (name)\n-     const char *name;\n+machopic_define_name (const char *name)\n {\n   machopic_define_ident (get_identifier (name));\n }\n \n static GTY(()) char * function_base;\n \n const char *\n-machopic_function_base_name ()\n+machopic_function_base_name (void)\n {\n   const char *current_name;\n   /* if dynamic-no-pic is on, we should not get here */\n   if (MACHO_DYNAMIC_NO_PIC_P)\n     abort ();\n-  current_name = \n+  current_name =\n     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n \n   if (function_base == NULL)\n-    function_base = \n+    function_base =\n       (char *) ggc_alloc_string (\"<pic base>\", sizeof (\"<pic base>\"));\n \n   current_function_uses_pic_offset_table = 1;\n@@ -254,7 +246,7 @@ machopic_output_function_base_name (FILE *file)\n   /* If dynamic-no-pic is on, we should not get here. */\n   if (MACHO_DYNAMIC_NO_PIC_P)\n     abort ();\n-  current_name = \n+  current_name =\n     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n   if (function_base_func_name != current_name)\n     {\n@@ -270,15 +262,14 @@ static GTY(()) tree machopic_non_lazy_pointers;\n    either by finding it in our list of pointer names, or by generating\n    a new one.  */\n \n-const char * \n-machopic_non_lazy_ptr_name (name)\n-     const char *name;\n+const char *\n+machopic_non_lazy_ptr_name (const char *name)\n {\n   const char *temp_name;\n   tree temp, ident = get_identifier (name);\n-  \n+\n   for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE; \n+       temp != NULL_TREE;\n        temp = TREE_CHAIN (temp))\n     {\n       if (ident == TREE_VALUE (temp))\n@@ -289,7 +280,7 @@ machopic_non_lazy_ptr_name (name)\n \n   /* Try again, but comparing names this time.  */\n   for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE; \n+       temp != NULL_TREE;\n        temp = TREE_CHAIN (temp))\n     {\n       if (TREE_VALUE (temp))\n@@ -315,11 +306,11 @@ machopic_non_lazy_ptr_name (name)\n \tstrcat (buffer, \"_\");\n \tstrcat (buffer, name);\n       }\n-      \n+\n     strcat (buffer, \"$non_lazy_ptr\");\n     ptr_name = get_identifier (buffer);\n \n-    machopic_non_lazy_pointers \n+    machopic_non_lazy_pointers\n       = tree_cons (ptr_name, ident, machopic_non_lazy_pointers);\n \n     TREE_USED (machopic_non_lazy_pointers) = 0;\n@@ -333,15 +324,14 @@ static GTY(()) tree machopic_stubs;\n /* Return the name of the stub corresponding to the given name,\n    generating a new stub name if necessary.  */\n \n-const char * \n-machopic_stub_name (name)\n-     const char *name;\n+const char *\n+machopic_stub_name (const char *name)\n {\n   tree temp, ident = get_identifier (name);\n   const char *tname;\n \n   for (temp = machopic_stubs;\n-       temp != NULL_TREE; \n+       temp != NULL_TREE;\n        temp = TREE_CHAIN (temp))\n     {\n       if (ident == TREE_VALUE (temp))\n@@ -394,9 +384,7 @@ machopic_stub_name (name)\n }\n \n void\n-machopic_validate_stub_or_non_lazy_ptr (name, validate_stub)\n-     const char *name;\n-     int validate_stub;\n+machopic_validate_stub_or_non_lazy_ptr (const char *name, int validate_stub)\n {\n   const char *real_name;\n   tree temp, ident = get_identifier (name), id2;\n@@ -423,11 +411,10 @@ machopic_validate_stub_or_non_lazy_ptr (name, validate_stub)\n    source using indirections.  */\n \n rtx\n-machopic_indirect_data_reference (orig, reg)\n-     rtx orig, reg;\n+machopic_indirect_data_reference (rtx orig, rtx reg)\n {\n   rtx ptr_ref = orig;\n-  \n+\n   if (! MACHOPIC_INDIRECT)\n     return orig;\n \n@@ -440,7 +427,7 @@ machopic_indirect_data_reference (orig, reg)\n       if (defined && MACHO_DYNAMIC_NO_PIC_P)\n \t{\n #if defined (TARGET_TOC)\n-           emit_insn (gen_macho_high (reg, orig));  \n+           emit_insn (gen_macho_high (reg, orig));\n            emit_insn (gen_macho_low (reg, reg, orig));\n #else\n \t   /* some other cpu -- writeme!  */\n@@ -451,7 +438,7 @@ machopic_indirect_data_reference (orig, reg)\n       else if (defined)\n \t{\n #if defined (TARGET_TOC) || defined (HAVE_lo_sum)\n-\t  rtx pic_base = gen_rtx (SYMBOL_REF, Pmode, \n+\t  rtx pic_base = gen_rtx (SYMBOL_REF, Pmode,\n \t\t\t\t  machopic_function_base_name ());\n \t  rtx offset = gen_rtx (CONST, Pmode,\n \t\t\t\tgen_rtx (MINUS, Pmode, orig, pic_base));\n@@ -507,7 +494,7 @@ machopic_indirect_data_reference (orig, reg)\n \t  orig = machopic_indirect_data_reference (XEXP (XEXP (orig, 0), 1),\n \t\t\t\t\t\t   (base == reg ? 0 : reg));\n \t}\n-      else \n+      else\n \treturn orig;\n \n       if (MACHOPIC_PURE && GET_CODE (orig) == CONST_INT)\n@@ -557,14 +544,13 @@ machopic_indirect_data_reference (orig, reg)\n    corresponding symbol_stub if necessary.  Return a new MEM.  */\n \n rtx\n-machopic_indirect_call_target (target)\n-     rtx target;\n+machopic_indirect_call_target (rtx target)\n {\n   if (GET_CODE (target) != MEM)\n     return target;\n \n   if (MACHOPIC_INDIRECT && GET_CODE (XEXP (target, 0)) == SYMBOL_REF)\n-    { \n+    {\n       enum machine_mode mode = GET_MODE (XEXP (target, 0));\n       const char *name = XSTR (XEXP (target, 0), 0);\n \n@@ -578,16 +564,14 @@ machopic_indirect_call_target (target)\n \n \t  XEXP (target, 0) = gen_rtx (SYMBOL_REF, mode, stub_name);\n \t  RTX_UNCHANGING_P (target) = 1;\n-\t} \n+\t}\n     }\n \n   return target;\n }\n \n rtx\n-machopic_legitimize_pic_address (orig, mode, reg)\n-     rtx orig, reg;\n-     enum machine_mode mode;\n+machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n {\n   rtx pic_ref = orig;\n \n@@ -604,15 +588,15 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \n       orig = machopic_indirect_data_reference (orig, reg);\n \n-      if (GET_CODE (orig) == PLUS \n+      if (GET_CODE (orig) == PLUS\n \t  && GET_CODE (XEXP (orig, 0)) == REG)\n \t{\n \t  if (reg == 0)\n \t    return force_reg (mode, orig);\n \n \t  emit_move_insn (reg, orig);\n \t  return reg;\n-\t}  \n+\t}\n \n       /* if dynamic-no-pic then use 0 as the pic base  */\n       if (MACHO_DYNAMIC_NO_PIC_P)\n@@ -629,7 +613,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t      else\n \t\treg = gen_reg_rtx (Pmode);\n \t    }\n-\t\n+\n #ifdef HAVE_lo_sum\n \t  if (MACHO_DYNAMIC_NO_PIC_P\n \t      && (GET_CODE (XEXP (orig, 0)) == SYMBOL_REF\n@@ -652,7 +636,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t      pic_ref = reg;\n \t    }\n \t  else\n-\t  if (GET_CODE (XEXP (orig, 0)) == SYMBOL_REF \n+\t  if (GET_CODE (XEXP (orig, 0)) == SYMBOL_REF\n \t      || GET_CODE (XEXP (orig, 0)) == LABEL_REF)\n \t    {\n \t      rtx offset = gen_rtx (CONST, Pmode,\n@@ -670,7 +654,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t\t\t\t\t   gen_rtx (HIGH, Pmode, offset))));\n \t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n \t\t\t\t  gen_rtx (MEM, GET_MODE (orig),\n-\t\t\t\t\t   gen_rtx (LO_SUM, Pmode, \n+\t\t\t\t\t   gen_rtx (LO_SUM, Pmode,\n \t\t\t\t\t\t    hi_sum_reg, offset))));\n \t      pic_ref = reg;\n \n@@ -679,10 +663,10 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t\t\t      gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM)));\n \n \t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t  gen_rtx (HIGH, Pmode, \n+\t\t\t\t  gen_rtx (HIGH, Pmode,\n \t\t\t\t\t   gen_rtx (CONST, Pmode, offset))));\n \t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t  gen_rtx (LO_SUM, Pmode, reg, \n+\t\t\t\t  gen_rtx (LO_SUM, Pmode, reg,\n \t\t\t\t\t   gen_rtx (CONST, Pmode, offset))));\n \t      pic_ref = gen_rtx (PLUS, Pmode,\n \t\t\t\t pic_offset_table_rtx, reg);\n@@ -703,13 +687,13 @@ machopic_legitimize_pic_address (orig, mode, reg)\n #endif\n \n \t      pic_ref = gen_rtx (PLUS, Pmode,\n-\t\t\t\t pic, \n-\t\t\t\t gen_rtx (CONST, Pmode, \n+\t\t\t\t pic,\n+\t\t\t\t gen_rtx (CONST, Pmode,\n \t\t\t\t\t  gen_rtx (MINUS, Pmode,\n-\t\t\t\t\t\t   XEXP (orig, 0), \n+\t\t\t\t\t\t   XEXP (orig, 0),\n \t\t\t\t\t\t   pic_base)));\n \t    }\n-\t  \n+\n #if !defined (TARGET_TOC)\n \t  emit_move_insn (reg, pic_ref);\n \t  pic_ref = gen_rtx (MEM, GET_MODE (orig), reg);\n@@ -720,7 +704,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t{\n \n #ifdef HAVE_lo_sum\n-\t  if (GET_CODE (orig) == SYMBOL_REF \n+\t  if (GET_CODE (orig) == SYMBOL_REF\n \t      || GET_CODE (orig) == LABEL_REF)\n \t    {\n \t      rtx offset = gen_rtx (CONST, Pmode,\n@@ -735,7 +719,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t\t  else\n \t\t    reg = gen_reg_rtx (SImode);\n \t\t}\n-\t\n+\n \t      hi_sum_reg = reg;\n \n \t      emit_insn (gen_rtx (SET, Pmode, hi_sum_reg,\n@@ -780,7 +764,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n #endif\n \t\t  pic_ref = gen_rtx (PLUS, Pmode,\n \t\t\t\t     pic,\n-\t\t\t\t     gen_rtx (CONST, Pmode, \n+\t\t\t\t     gen_rtx (CONST, Pmode,\n \t\t\t\t\t      gen_rtx (MINUS, Pmode,\n \t\t\t\t\t\t       orig, pic_base)));\n \t\t}\n@@ -814,7 +798,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \t       || GET_CODE (XEXP (orig, 0)) == LABEL_REF)\n \t   && XEXP (orig, 0) != pic_offset_table_rtx\n \t   && GET_CODE (XEXP (orig, 1)) != REG)\n-    \n+\n     {\n       rtx base;\n       int is_complex = (GET_CODE (XEXP (orig, 0)) == MEM);\n@@ -862,8 +846,7 @@ machopic_legitimize_pic_address (orig, mode, reg)\n \n \n void\n-machopic_finish (asm_out_file)\n-     FILE *asm_out_file;\n+machopic_finish (FILE *asm_out_file)\n {\n   tree temp;\n \n@@ -889,7 +872,7 @@ machopic_finish (asm_out_file)\n       if (sym_name[0] == '*' || sym_name[0] == '&')\n \tstrcpy (sym, sym_name + 1);\n       else if (sym_name[0] == '-' || sym_name[0] == '+')\n-\tstrcpy (sym, sym_name);\t  \n+\tstrcpy (sym, sym_name);\n       else\n \tsym[0] = '_', strcpy (sym + 1, sym_name);\n \n@@ -903,7 +886,7 @@ machopic_finish (asm_out_file)\n     }\n \n   for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE; \n+       temp != NULL_TREE;\n        temp = TREE_CHAIN (temp))\n     {\n       const char *const sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n@@ -924,11 +907,11 @@ machopic_finish (asm_out_file)\n       else\n \t{\n \t  machopic_nl_symbol_ptr_section ();\n-\t  assemble_name (asm_out_file, lazy_name); \n+\t  assemble_name (asm_out_file, lazy_name);\n \t  fprintf (asm_out_file, \":\\n\");\n \n \t  fprintf (asm_out_file, \"\\t.indirect_symbol \");\n-\t  assemble_name (asm_out_file, sym_name); \n+\t  assemble_name (asm_out_file, sym_name);\n \t  fprintf (asm_out_file, \"\\n\");\n \n \t  assemble_integer (const0_rtx, GET_MODE_SIZE (Pmode),\n@@ -937,9 +920,8 @@ machopic_finish (asm_out_file)\n     }\n }\n \n-int \n-machopic_operand_p (op)\n-     rtx op;\n+int\n+machopic_operand_p (rtx op)\n {\n   if (MACHOPIC_JUST_INDIRECT)\n     {\n@@ -970,10 +952,7 @@ machopic_operand_p (op)\n    use later.  */\n \n void\n-darwin_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first ATTRIBUTE_UNUSED;\n+darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n {\n   char code = '\\0';\n   int defined = 0;\n@@ -1043,8 +1022,7 @@ darwin_encode_section_info (decl, rtl, first)\n /* Undo the effects of the above.  */\n \n const char *\n-darwin_strip_name_encoding (str)\n-     const char *str;\n+darwin_strip_name_encoding (const char *str)\n {\n   return str[0] == '!' ? str + 4 : str;\n }\n@@ -1053,16 +1031,15 @@ darwin_strip_name_encoding (str)\n    stripped name matches the argument.  */\n \n static void\n-update_non_lazy_ptrs (name)\n-     const char *name;\n+update_non_lazy_ptrs (const char *name)\n {\n   const char *name1, *name2;\n   tree temp;\n \n   name1 = darwin_strip_name_encoding (name);\n \n   for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE; \n+       temp != NULL_TREE;\n        temp = TREE_CHAIN (temp))\n     {\n       const char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n@@ -1073,7 +1050,7 @@ update_non_lazy_ptrs (name)\n \t  if (strcmp (name1, name2) == 0)\n \t    {\n \t      /* FIXME: This breaks the identifier hash table.  */\n-\t      IDENTIFIER_NODE_CHECK (TREE_VALUE (temp))->identifier.id.str \n+\t      IDENTIFIER_NODE_CHECK (TREE_VALUE (temp))->identifier.id.str\n \t\t= (unsigned char *) name;\n \t      break;\n \t    }\n@@ -1086,9 +1063,7 @@ update_non_lazy_ptrs (name)\n    just emit the stub label now and we don't bother emitting the stub later.  */\n \n void\n-machopic_output_possible_stub_label (file, name)\n-     FILE *file;\n-     const char *name;\n+machopic_output_possible_stub_label (FILE *file, const char *name)\n {\n   tree temp;\n \n@@ -1119,16 +1094,15 @@ machopic_output_possible_stub_label (file, name)\n    stripped name matches the argument.  */\n \n static void\n-update_stubs (name)\n-     const char *name;\n+update_stubs (const char *name)\n {\n   const char *name1, *name2;\n   tree temp;\n \n   name1 = darwin_strip_name_encoding (name);\n \n   for (temp = machopic_stubs;\n-       temp != NULL_TREE; \n+       temp != NULL_TREE;\n        temp = TREE_CHAIN (temp))\n     {\n       const char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n@@ -1139,7 +1113,7 @@ update_stubs (name)\n \t  if (strcmp (name1, name2) == 0)\n \t    {\n \t      /* FIXME: This breaks the identifier hash table.  */\n-\t      IDENTIFIER_NODE_CHECK (TREE_VALUE (temp))->identifier.id.str \n+\t      IDENTIFIER_NODE_CHECK (TREE_VALUE (temp))->identifier.id.str\n \t\t= (unsigned char *) name;\n \t      break;\n \t    }\n@@ -1148,22 +1122,20 @@ update_stubs (name)\n }\n \n void\n-machopic_select_section (exp, reloc, align)\n-     tree exp;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+machopic_select_section (tree exp, int reloc,\n+\t\t\t unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   void (*base_function)(void);\n-  \n+\n   if (decl_readonly_section_1 (exp, reloc, MACHOPIC_INDIRECT))\n     base_function = readonly_data_section;\n   else if (TREE_READONLY (exp) || TREE_CONSTANT (exp))\n     base_function = const_data_section;\n   else\n     base_function = data_section;\n-  \n+\n   if (TREE_CODE (exp) == STRING_CST\n-      && ((size_t) TREE_STRING_LENGTH (exp) \n+      && ((size_t) TREE_STRING_LENGTH (exp)\n \t  == strlen (TREE_STRING_POINTER (exp)) + 1)\n       && ! flag_writable_strings)\n     cstring_section ();\n@@ -1261,10 +1233,8 @@ machopic_select_section (exp, reloc, align)\n    They must go in \"const\".  */\n \n void\n-machopic_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+machopic_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (GET_MODE_SIZE (mode) == 8)\n     literal8_section ();\n@@ -1277,29 +1247,25 @@ machopic_select_rtx_section (mode, x, align)\n }\n \n void\n-machopic_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+machopic_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n-  \n+\n   if (MACHOPIC_INDIRECT)\n     mod_init_section ();\n   else\n     constructor_section ();\n   assemble_align (POINTER_SIZE);\n   assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n \n- \n+\n   if (! MACHOPIC_INDIRECT)\n     fprintf (asm_out_file, \".reference .constructors_used\\n\");\n }\n \n void\n-machopic_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+machopic_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n-  \n+\n   if (MACHOPIC_INDIRECT)\n     mod_term_section ();\n   else\n@@ -1312,9 +1278,7 @@ machopic_asm_out_destructor (symbol, priority)\n }\n \n void\n-darwin_globalize_label (stream, name)\n-     FILE *stream;\n-     const char *name;\n+darwin_globalize_label (FILE *stream, const char *name)\n {\n   if (!!strncmp (name, \"_OBJC_\", 6))\n     default_globalize_label (stream, name);\n@@ -1330,10 +1294,8 @@ darwin_globalize_label (stream, name)\n static int darwin_dwarf_label_counter;\n \n void\n-darwin_asm_output_dwarf_delta (file, size, lab1, lab2)\n-     FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n-     const char *lab1, *lab2;\n+darwin_asm_output_dwarf_delta (FILE *file, int size ATTRIBUTE_UNUSED,\n+\t\t\t       const char *lab1, const char *lab2)\n {\n   const char *p = lab1 + (lab1[0] == '*');\n   int islocaldiff = (p[0] == 'L');\n@@ -1350,7 +1312,7 @@ darwin_asm_output_dwarf_delta (file, size, lab1, lab2)\n }\n \n void\n-darwin_file_end ()\n+darwin_file_end (void)\n {\n   machopic_finish (asm_out_file);\n   if (strcmp (lang_hooks.name, \"GNU C++\") == 0)\n@@ -1362,4 +1324,3 @@ darwin_file_end ()\n }\n \n #include \"gt-darwin.h\"\n-"}, {"sha": "bc25ff0409160acafb044af42c0b72e895552f79", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -368,7 +368,7 @@ do { text_section ();\t\t\t\t\t\t\t\\\n         || DECL_INITIAL (DECL))\t\t\t\t\t\t\\\n       (* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\t\\\n     ASM_OUTPUT_LABEL (FILE, xname);\t\t\t\t\t\\\n-    /* Darwin doesn't support zero-size objects, so give them a \t\\\n+    /* Darwin doesn't support zero-size objects, so give them a\t\\\n        byte.  */\t\t\t\t\t\t\t\\\n     if (tree_low_cst (DECL_SIZE_UNIT (DECL), 1) == 0)\t\t\t\\\n       assemble_zeros (1);\t\t\t\t\t\t\\\n@@ -478,9 +478,9 @@ do { text_section ();\t\t\t\t\t\t\t\\\n \n #undef\tSECTION_FUNCTION\n #define SECTION_FUNCTION(FUNCTION, SECTION, DIRECTIVE, OBJC)\t\t\\\n-extern void FUNCTION PARAMS ((void));\t\t\t\t\t\\\n+extern void FUNCTION (void);\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n-FUNCTION ()\t\t\t\t\t\t\t\t\\\n+FUNCTION (void)\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != SECTION)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -509,7 +509,7 @@ FUNCTION ()\t\t\t\t\t\t\t\t\\\n   in_objc_protocol, in_objc_string_object,\t\t\\\n   in_objc_constant_string_object,\t\t\t\\\n   in_objc_class_names, in_objc_meth_var_names,\t\t\\\n-  in_objc_meth_var_types, in_objc_cls_refs, \t\t\\\n+  in_objc_meth_var_types, in_objc_cls_refs,\t\t\\\n   in_machopic_nl_symbol_ptr,\t\t\t\t\\\n   in_machopic_lazy_symbol_ptr,\t\t\t\t\\\n   in_machopic_symbol_stub,\t\t\t\t\\\n@@ -521,7 +521,7 @@ FUNCTION ()\t\t\t\t\t\t\t\t\\\n \n #undef\tEXTRA_SECTION_FUNCTIONS\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\\\n-static void objc_section_init PARAMS ((void));\t\\\n+static void objc_section_init (void);\t\t\\\n SECTION_FUNCTION (const_section,\t\t\\\n                   in_const,\t\t\t\\\n                   \".const\", 0)\t\t\t\\\n@@ -612,19 +612,19 @@ SECTION_FUNCTION (objc_cls_refs_section,\t\\\n \t\t\t\t\t\t\\\n SECTION_FUNCTION (machopic_lazy_symbol_ptr_section,\t\\\n \t\tin_machopic_lazy_symbol_ptr,\t\t\\\n-\t\t\".lazy_symbol_pointer\", 0)      \t\\\n+\t\t\".lazy_symbol_pointer\", 0)\t\\\n SECTION_FUNCTION (machopic_nl_symbol_ptr_section,\t\\\n \t\tin_machopic_nl_symbol_ptr,\t\t\\\n-\t\t\".non_lazy_symbol_pointer\", 0)      \t\\\n+\t\t\".non_lazy_symbol_pointer\", 0)\t\\\n SECTION_FUNCTION (machopic_symbol_stub_section,\t\t\\\n \t\tin_machopic_symbol_stub,\t\t\\\n-\t\t\".symbol_stub\", 0)      \t\t\\\n+\t\t\".symbol_stub\", 0)\t\t\\\n SECTION_FUNCTION (machopic_symbol_stub1_section,\t\\\n \t\tin_machopic_symbol_stub1,\t\t\\\n \t\t\".section __TEXT,__symbol_stub1,symbol_stubs,pure_instructions,16\", 0)\\\n SECTION_FUNCTION (machopic_picsymbol_stub_section,\t\\\n \t\tin_machopic_picsymbol_stub,\t\t\\\n-\t\t\".picsymbol_stub\", 0)      \t\t\\\n+\t\t\".picsymbol_stub\", 0)\t\t\\\n SECTION_FUNCTION (machopic_picsymbol_stub1_section,\t\\\n \t\tin_machopic_picsymbol_stub1,\t\t\\\n \t\t\".section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\", 0)\\\n@@ -636,7 +636,7 @@ SECTION_FUNCTION (darwin_eh_frame_section,\t\t\\\n \t\t\".section __TEXT,__eh_frame\", 0)\t\\\n \t\t\t\t\t\t\t\\\n static void\t\t\t\t\t\\\n-objc_section_init ()\t\t\t\t\\\n+objc_section_init (void)\t\t\t\\\n {\t\t\t\t\t\t\\\n   static int been_here = 0;\t\t\t\\\n \t\t\t\t\t\t\\\n@@ -653,7 +653,7 @@ objc_section_init ()\t\t\t\t\\\n       objc_cls_refs_section ();\t\t\t\\\n       objc_class_section ();\t\t\t\\\n       objc_meta_class_section ();\t\t\\\n-          /* shared, hot -> cold */    \t\t\\\n+          /* shared, hot -> cold */\t\t\\\n       objc_cls_meth_section ();\t\t\t\\\n       objc_inst_meth_section ();\t\t\\\n       objc_protocol_section ();\t\t\t\\\n@@ -676,7 +676,7 @@ objc_section_init ()\t\t\t\t\\\n #define TARGET_ASM_SELECT_RTX_SECTION machopic_select_rtx_section\n \n #define ASM_DECLARE_UNRESOLVED_REFERENCE(FILE,NAME)\t\t\t\\\n-    do { \t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n \t if (FILE) {\t\t\t\t\t\t\t\\\n \t   if (MACHOPIC_INDIRECT)\t\t\t\t\t\\\n \t     fprintf (FILE, \"\\t.lazy_reference \");\t\t\t\\\n@@ -691,7 +691,7 @@ objc_section_init ()\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n \t if (FILE) {\t\t\t\t\t\t\t\\\n \t   fprintf (FILE, \"\\t\");\t\t\t\t\t\\\n-\t   assemble_name (FILE, NAME); \t\t\t\t\t\\\n+\t   assemble_name (FILE, NAME);\t\t\t\t\t\\\n \t   fprintf (FILE, \"=0\\n\");\t\t\t\t\t\\\n \t   (*targetm.asm_out.globalize_label) (FILE, NAME);\t\t\\\n \t }\t\t\t\t\t\t\t\t\\\n@@ -793,7 +793,7 @@ enum machopic_addr_class {\n #define TARGET_ASM_EXCEPTION_SECTION darwin_exception_section\n \n #define TARGET_ASM_EH_FRAME_SECTION darwin_eh_frame_section\n-  \n+\n #undef ASM_PREFERRED_EH_DATA_FORMAT\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  \\\n   (((CODE) == 2 && (GLOBAL) == 1) \\"}, {"sha": "95b894ad217a0d5452db0ec2a4c4e59e6aae3ad6", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n { \"console\",\t\t  0, N_(\"Create console application\") },\\\n { \"dll\",\t\t  0, N_(\"Generate code for a DLL\") },\t\\\n { \"nop-fun-dllimport\",\t  MASK_NOP_FUN_DLLIMPORT,\t\t\\\n-  N_(\"Ignore dllimport for functions\") }, \t\t\t\\\n+  N_(\"Ignore dllimport for functions\") },\t\t\t\\\n { \"no-nop-fun-dllimport\", -MASK_NOP_FUN_DLLIMPORT, \"\" },\t\\\n { \"threads\",\t\t  0, N_(\"Use Mingw-specific thread support\") },\n \n@@ -94,7 +94,7 @@ Boston, MA 02111-1307, USA.  */\n    Do not define this macro if it does not need to do anything.  */\n \n #undef  SUBTARGET_EXTRA_SPECS\n-#define SUBTARGET_EXTRA_SPECS \t\t\t\t\t\t\\\n+#define SUBTARGET_EXTRA_SPECS\t\t\t\t\t\t\\\n   { \"mingw_include_path\", DEFAULT_TARGET_MACHINE }\n \n #undef MATH_LIBRARY\n@@ -130,29 +130,27 @@ drectve_section ()\t\t\t\t\t\t\t\\\n       in_section = in_drectve;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n-void drectve_section PARAMS ((void));\n+void drectve_section (void);\n \n /* Switch to SECTION (an `enum in_section').\n \n    ??? This facility should be provided by GCC proper.\n    The problem is that we want to temporarily switch sections in\n    ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n    afterwards.  */\n-#define SWITCH_TO_SECTION_FUNCTION \t\t\t\t\\\n-void switch_to_section PARAMS ((enum in_section, tree));        \\\n-void \t\t\t\t\t\t\t\t\\\n-switch_to_section (section, decl) \t\t\t\t\\\n-     enum in_section section; \t\t\t\t\t\\\n-     tree decl; \t\t\t\t\t\t\\\n-{ \t\t\t\t\t\t\t\t\\\n-  switch (section) \t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\t\t\\\n-      case in_text: text_section (); break; \t\t\t\\\n-      case in_data: data_section (); break; \t\t\t\\\n-      case in_named: named_section (decl, NULL, 0); break; \t\\\n-      case in_drectve: drectve_section (); break; \t\t\\\n-      default: abort (); break; \t\t\t\t\\\n-    } \t\t\t\t\t\t\t\t\\\n+#define SWITCH_TO_SECTION_FUNCTION\t\t\t\t\\\n+void switch_to_section (enum in_section, tree);\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+switch_to_section (enum in_section section, tree decl)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  switch (section)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      case in_text: text_section (); break;\t\t\t\\\n+      case in_data: data_section (); break;\t\t\t\\\n+      case in_named: named_section (decl, NULL, 0); break;\t\\\n+      case in_drectve: drectve_section (); break;\t\t\\\n+      default: abort (); break;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n }\n \n /* Don't allow flag_pic to propagate since gas may produce invalid code\n@@ -173,15 +171,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n    differently depending on something about the variable or\n    function named by the symbol (such as what section it is in).\n \n-   On i386 running Windows NT, modify the assembler name with a suffix \n+   On i386 running Windows NT, modify the assembler name with a suffix\n    consisting of an atsign (@) followed by string of digits that represents\n-   the number of bytes of arguments passed to the function, if it has the \n+   the number of bytes of arguments passed to the function, if it has the\n    attribute STDCALL.\n \n-   In addition, we must mark dll symbols specially. Definitions of \n-   dllexport'd objects install some info in the .drectve section.  \n+   In addition, we must mark dll symbols specially. Definitions of\n+   dllexport'd objects install some info in the .drectve section.\n    References to dllimport'd objects are fetched indirectly via\n-   _imp__.  If both are declared, dllexport overrides.  This is also \n+   _imp__.  If both are declared, dllexport overrides.  This is also\n    needed to implement one-only vtables: they go into their own\n    section and we need to set DECL_SECTION_NAME so we do that here.\n    Note that we can be called twice on the same decl.  */\n@@ -203,7 +201,7 @@ do {\t\t\t\t\t\t\t\\\n     i386_pe_record_exported_symbol (NAME, 1);\t\t\\\n   if (! i386_pe_dllimport_name_p (NAME))\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n+      fprintf ((STREAM), \"\\t.comm\\t\");\t\t\t\\\n       assemble_name ((STREAM), (NAME));\t\t\t\\\n       fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n \t       (int)(ROUNDED), ASM_COMMENT_START, (int)(SIZE));\t\\\n@@ -212,7 +210,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* Output the label for an initialized variable.  */\n #undef ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \t\\\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\\\n do {\t\t\t\t\t\t\t\\\n   if (i386_pe_dllexport_name_p (NAME))\t\t\t\\\n     i386_pe_record_exported_symbol (NAME, 1);\t\t\\\n@@ -248,7 +246,7 @@ do {\t\t\t\t\t\t\t\\\n    symbols must be explicitly imported from shared libraries (DLLs).  */\n #define MULTIPLE_SYMBOL_SPACES\n \n-extern void i386_pe_unique_section PARAMS ((TREE, int));\n+extern void i386_pe_unique_section (TREE, int);\n #define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section\n \n #define SUPPORTS_ONE_ONLY 1\n@@ -328,12 +326,12 @@ extern void i386_pe_unique_section PARAMS ((TREE, int));\n \n /* External function declarations.  */\n \n-extern void i386_pe_record_external_function PARAMS ((const char *));\n-extern void i386_pe_declare_function_type PARAMS ((FILE *, const char *, int));\n-extern void i386_pe_record_exported_symbol PARAMS ((const char *, int));\n-extern void i386_pe_file_end PARAMS ((void));\n-extern int i386_pe_dllexport_name_p PARAMS ((const char *));\n-extern int i386_pe_dllimport_name_p PARAMS ((const char *));\n+extern void i386_pe_record_external_function (const char *);\n+extern void i386_pe_declare_function_type (FILE *, const char *, int);\n+extern void i386_pe_record_exported_symbol (const char *, int);\n+extern void i386_pe_file_end (void);\n+extern int i386_pe_dllexport_name_p (const char *);\n+extern int i386_pe_dllimport_name_p (const char *);\n \n /* For Win32 ABI compatibility */\n #undef DEFAULT_PCC_STRUCT_RETURN"}, {"sha": "6fe7e197e58636502415d6bee66c5bab229dd776", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -20,7 +20,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#define TARGET_VERSION fprintf (stderr, \" (x86 Cygwin)\"); \n+#define TARGET_VERSION fprintf (stderr, \" (x86 Cygwin)\");\n \n #define EXTRA_OS_CPP_BUILTINS()  /* Nothing.  */\n \n@@ -81,7 +81,7 @@ Boston, MA 02111-1307, USA.  */\n \n #ifndef CYGWIN_MINGW_SUBDIR\n #define CYGWIN_MINGW_SUBDIR \"/mingw\"\n-#endif \n+#endif\n #define CYGWIN_MINGW_SUBDIR_LEN (sizeof (CYGWIN_MINGW_SUBDIR) - 1)\n \n #ifdef GPLUSPLUS_INCLUDE_DIR\n@@ -199,7 +199,7 @@ char *cvt_to_mingw[] =\n #undef GEN_CVT_ARRAY\n #endif /*GEN_CVT_ARRAY*/\n \n-void mingw_scan PARAMS ((int, const char * const *, char **));\n+void mingw_scan (int, const char * const *, char **);\n #if 1\n #define GCC_DRIVER_HOST_INITIALIZATION \\\n do \\"}, {"sha": "598aa0fec169a0772b6d8fcb3a3880d31c0a68b2", "filename": "gcc/config/i386/cygwin2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fcygwin2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fcygwin2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin2.c?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -28,13 +28,13 @@ Boston, MA 02111-1307, USA.  */\n #include <string.h>\n \n /*\n-static void remove_w32api PARAMS ((void));\n+static void remove_w32api (void);\n */\n-static void add_mingw PARAMS ((void));\n-static void set_mingw PARAMS((void)) __attribute__ ((constructor));\n+static void add_mingw (void);\n+static void set_mingw (void) __attribute__ ((constructor));\n \n static void\n-add_mingw ()\n+add_mingw (void)\n {\n   char **av;\n   char *p;\n@@ -59,7 +59,7 @@ add_mingw ()\n \n \n static void\n-set_mingw ()\n+set_mingw (void)\n {\n   char *env = getenv (\"GCC_CYGWIN_MINGW\");\n   if (env && *env == '1')"}, {"sha": "664cda19b301747d04d51995419db8b2a25a552a", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -1,5 +1,5 @@\n /* Target definitions for GNU compiler for Intel 80386 running Interix\n-   Parts Copyright (C) 1991, 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Parts Copyright (C) 1991, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n \n    Parts:\n      by Douglas B. Rupp (drupp@cs.washington.edu).\n@@ -341,7 +341,7 @@ while (0)\n    symbols must be explicitly imported from shared libraries (DLLs).  */\n #define MULTIPLE_SYMBOL_SPACES\n \n-extern void i386_pe_unique_section PARAMS ((tree, int));\n+extern void i386_pe_unique_section (tree, int);\n #define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section\n \n #define SUPPORTS_ONE_ONLY 1"}, {"sha": "076a2934a78d0c3f5387f9fcb2a01b164b6bce1e", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 54, "deletions": 88, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -46,13 +46,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    multiple times.\n */\n \n-static tree associated_type PARAMS ((tree));\n-const char * gen_stdcall_suffix PARAMS ((tree));\n-const char * gen_fastcall_suffix PARAMS ((tree));\n-int i386_pe_dllexport_p PARAMS ((tree));\n-int i386_pe_dllimport_p PARAMS ((tree));\n-void i386_pe_mark_dllexport PARAMS ((tree));\n-void i386_pe_mark_dllimport PARAMS ((tree));\n+static tree associated_type (tree);\n+const char * gen_stdcall_suffix (tree);\n+const char * gen_fastcall_suffix (tree);\n+int i386_pe_dllexport_p (tree);\n+int i386_pe_dllimport_p (tree);\n+void i386_pe_mark_dllexport (tree);\n+void i386_pe_mark_dllimport (tree);\n \n /* This is we how mark internal identifiers with dllimport or dllexport\n    attributes.  */\n@@ -66,12 +66,8 @@ void i386_pe_mark_dllimport PARAMS ((tree));\n /* Handle a \"dllimport\" or \"dllexport\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n tree\n-ix86_handle_dll_attribute (pnode, name, args, flags, no_add_attrs)\n-     tree * pnode;\n-     tree name;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n+ix86_handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n+\t\t\t   bool *no_add_attrs)\n {\n   tree node = *pnode;\n \n@@ -121,18 +117,18 @@ ix86_handle_dll_attribute (pnode, name, args, flags, no_add_attrs)\n \n \t  /* `extern' needn't be specified with dllimport.\n \t     Specify `extern' now and hope for the best.  Sigh.  */\n-\t  DECL_EXTERNAL (node) = 1; \n+\t  DECL_EXTERNAL (node) = 1;\n \t  /* Also, implicitly give dllimport'd variables declared within\n \t     a function global scope, unless declared static.  */\n \t  if (current_function_decl != NULL_TREE && !TREE_STATIC (node))\n-  \t    TREE_PUBLIC (node) = 1;\n+\t    TREE_PUBLIC (node) = 1;\n \t}\n     }\n \n   /*  Report error if symbol is not accessible at global scope. */\n   if (!TREE_PUBLIC (node)\n       && (TREE_CODE (node) == VAR_DECL\n-\t  || TREE_CODE (node) == FUNCTION_DECL)) \n+\t  || TREE_CODE (node) == FUNCTION_DECL))\n     {\n       error (\"%Hexternal linkage required for symbol '%D' because of '%s' attribute.\",\n \t       &DECL_SOURCE_LOCATION (node), node, IDENTIFIER_POINTER (name));\n@@ -145,12 +141,9 @@ ix86_handle_dll_attribute (pnode, name, args, flags, no_add_attrs)\n /* Handle a \"shared\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n tree\n-ix86_handle_shared_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+ix86_handle_shared_attribute (tree *node, tree name,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != VAR_DECL)\n     {\n@@ -166,8 +159,7 @@ ix86_handle_shared_attribute (node, name, args, flags, no_add_attrs)\n    imported or exported.  */\n \n static tree\n-associated_type (decl)\n-     tree decl;\n+associated_type (tree decl)\n {\n   tree t = NULL_TREE;\n \n@@ -192,8 +184,7 @@ associated_type (decl)\n /* Return nonzero if DECL is a dllexport'd object.  */\n \n int\n-i386_pe_dllexport_p (decl)\n-     tree decl;\n+i386_pe_dllexport_p (tree decl)\n {\n   tree exp;\n \n@@ -219,8 +210,7 @@ i386_pe_dllexport_p (decl)\n /* Return nonzero if DECL is a dllimport'd object.  */\n \n int\n-i386_pe_dllimport_p (decl)\n-     tree decl;\n+i386_pe_dllimport_p (tree decl)\n {\n   tree imp;\n   int context_imp = 0;\n@@ -262,11 +252,11 @@ i386_pe_dllimport_p (decl)\n \n       /* We ignore the dllimport attribute for inline member functions.\n \t This differs from MSVC behavior which treats it like GNUC\n-     \t 'extern inline' extension.   */\n+\t 'extern inline' extension.   */\n       else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n         {\n \t  if (extra_warnings)\n-\t    warning (\"%Hinline function '%D' is declared as dllimport: attribute ignored.\", \n+\t    warning (\"%Hinline function '%D' is declared as dllimport: attribute ignored.\",\n \t\t     &DECL_SOURCE_LOCATION (decl), decl);\n \t  return 0;\n \t}\n@@ -278,7 +268,7 @@ i386_pe_dllimport_p (decl)\n \t       && !DECL_EXTERNAL (decl) && context_imp)\n \t{\n \t  if (!DECL_VIRTUAL_P (decl))\n-            error (\"%Hdefinition of static data member '%D' of dllimport'd class.\", \n+            error (\"%Hdefinition of static data member '%D' of dllimport'd class.\",\n \t\t   &DECL_SOURCE_LOCATION (decl), decl);           return 0;\n \t}\n \n@@ -300,8 +290,7 @@ i386_pe_dllimport_p (decl)\n /* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n \n int\n-i386_pe_dllexport_name_p (symbol)\n-     const char *symbol;\n+i386_pe_dllexport_name_p (const char *symbol)\n {\n   return (strncmp (DLL_EXPORT_PREFIX, symbol,\n \t\t   strlen (DLL_EXPORT_PREFIX)) == 0);\n@@ -310,8 +299,7 @@ i386_pe_dllexport_name_p (symbol)\n /* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n \n int\n-i386_pe_dllimport_name_p (symbol)\n-     const char *symbol;\n+i386_pe_dllimport_name_p (const char *symbol)\n {\n   return (strncmp (DLL_IMPORT_PREFIX, symbol,\n \t\t   strlen (DLL_IMPORT_PREFIX)) == 0);\n@@ -321,8 +309,7 @@ i386_pe_dllimport_name_p (symbol)\n    Note that we override the previous setting (eg: dllimport).  */\n \n void\n-i386_pe_mark_dllexport (decl)\n-     tree decl;\n+i386_pe_mark_dllexport (tree decl)\n {\n   const char *oldname;\n   char  *newname;\n@@ -364,8 +351,7 @@ i386_pe_mark_dllexport (decl)\n /* Mark a DECL as being dllimport'd.  */\n \n void\n-i386_pe_mark_dllimport (decl)\n-     tree decl;\n+i386_pe_mark_dllimport (tree decl)\n {\n   const char *oldname;\n   char  *newname;\n@@ -391,7 +377,7 @@ i386_pe_mark_dllimport (decl)\n       /* Already done, but do a sanity check to prevent assembler errors. */\n       if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n \t{\n-\t  error (\"%Hfailure in redeclaration of '%D': dllimport'd symbol lacks external linkage.\", \n+\t  error (\"%Hfailure in redeclaration of '%D': dllimport'd symbol lacks external linkage.\",\n \t\t &DECL_SOURCE_LOCATION (decl), decl);\n \t  abort();\n \t}\n@@ -416,13 +402,12 @@ i386_pe_mark_dllimport (decl)\n   DECL_NON_ADDR_CONST_P (decl) = 1;\n }\n \n-/* Return string which is the former assembler name modified with a \n+/* Return string which is the former assembler name modified with a\n    prefix consisting of FASTCALL_PREFIX and a suffix consisting of an\n    atsign (@) followed by the number of bytes of arguments.  */\n \n const char *\n-gen_fastcall_suffix (decl)\n-  tree decl;\n+gen_fastcall_suffix (tree decl)\n {\n   int total = 0;\n \n@@ -448,19 +433,18 @@ gen_fastcall_suffix (decl)\n \t  }\n       }\n \n-  /* Assume max of 8 base 10 digits in the suffix.  */ \n+  /* Assume max of 8 base 10 digits in the suffix.  */\n   newsym = xmalloc (1 + strlen (asmname) + 1 + 8 + 1);\n   sprintf (newsym, \"%c%s@%d\", FASTCALL_PREFIX, asmname, total/BITS_PER_UNIT);\n   return IDENTIFIER_POINTER (get_identifier (newsym));\n }\n \n-/* Return string which is the former assembler name modified with a \n-   suffix consisting of an atsign (@) followed by the number of bytes of \n+/* Return string which is the former assembler name modified with a\n+   suffix consisting of an atsign (@) followed by the number of bytes of\n    arguments */\n \n const char *\n-gen_stdcall_suffix (decl)\n-  tree decl;\n+gen_stdcall_suffix (tree decl)\n {\n   int total = 0;\n   /* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead\n@@ -469,7 +453,7 @@ gen_stdcall_suffix (decl)\n   char *newsym;\n \n   if (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n-    if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (decl)))) \n+    if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (decl))))\n         == void_type_node)\n       {\n \ttree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n@@ -487,25 +471,22 @@ gen_stdcall_suffix (decl)\n \t  }\n       }\n \n-  /* Assume max of 8 base 10 digits in the suffix.  */ \n+  /* Assume max of 8 base 10 digits in the suffix.  */\n   newsym = xmalloc (strlen (asmname) + 1 + 8 + 1);\n   sprintf (newsym, \"%s@%d\", asmname, total/BITS_PER_UNIT);\n   return IDENTIFIER_POINTER (get_identifier (newsym));\n }\n \n void\n-i386_pe_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+i386_pe_encode_section_info (tree decl, rtx rtl, int first)\n {\n   default_encode_section_info (decl, rtl, first);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       if (lookup_attribute (\"stdcall\",\n \t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (decl))))\n-        XEXP (DECL_RTL (decl), 0) = \n+        XEXP (DECL_RTL (decl), 0) =\n \t  gen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (decl));\n       else if (lookup_attribute (\"fastcall\",\n \t\t\t\t TYPE_ATTRIBUTES (TREE_TYPE (decl))))\n@@ -540,7 +521,7 @@ i386_pe_encode_section_info (decl, rtl, first)\n \n       warning (\"%H%s '%D' %s after being referenced with dllimport linkage.\",\n \t         &DECL_SOURCE_LOCATION (decl),\n-\t         TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\", \n+\t         TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n \t         decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n \t\t\t? \"defined locally\" : \"redeclared without dllimport attribute\");\n \n@@ -557,8 +538,7 @@ i386_pe_encode_section_info (decl, rtl, first)\n    prefix if it exists.  */\n \n const char *\n-i386_pe_strip_name_encoding (str)\n-     const char *str;\n+i386_pe_strip_name_encoding (const char *str)\n {\n   if (strncmp (str, DLL_IMPORT_PREFIX, strlen (DLL_IMPORT_PREFIX))\n       == 0)\n@@ -574,12 +554,11 @@ i386_pe_strip_name_encoding (str)\n /* Also strip the stdcall suffix.  */\n \n const char *\n-i386_pe_strip_name_encoding_full (str)\n-     const char *str;\n+i386_pe_strip_name_encoding_full (const char *str)\n {\n   const char *p;\n   const char *name = i386_pe_strip_name_encoding (str);\n- \n+\n   p = strchr (name, '@');\n   if (p)\n     return ggc_alloc_string (name, p - name);\n@@ -597,24 +576,24 @@ void i386_pe_output_labelref (stream, name)\n {\n   if (strncmp (name, DLL_IMPORT_PREFIX, strlen (DLL_IMPORT_PREFIX))\n       == 0)\n-    /* A dll import */ \n+    /* A dll import */\n     {\n       if (name[strlen (DLL_IMPORT_PREFIX)] == FASTCALL_PREFIX)\n-      /* A dllimport fastcall symbol.  */   \n+      /* A dllimport fastcall symbol.  */\n         {\n           fprintf (stream, \"__imp_%s\",\n                    i386_pe_strip_name_encoding (name));\n         }\n       else\n-      /* A dllimport non-fastcall symbol.  */ \n+      /* A dllimport non-fastcall symbol.  */\n         {\n           fprintf (stream, \"__imp__%s\",\n                    i386_pe_strip_name_encoding (name));\n         }\n     }\n   else if ((name[0] == FASTCALL_PREFIX)\n            || (strncmp (name, DLL_EXPORT_PREFIX, strlen (DLL_EXPORT_PREFIX)\n-\t       == 0 \n+\t       == 0\n \t       && name[strlen (DLL_EXPORT_PREFIX)] == FASTCALL_PREFIX)))\n     /* A fastcall symbol.  */\n     {\n@@ -630,9 +609,7 @@ void i386_pe_output_labelref (stream, name)\n }\n \n void\n-i386_pe_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc;\n+i386_pe_unique_section (tree decl, int reloc)\n {\n   int len;\n   const char *name, *prefix;\n@@ -644,7 +621,7 @@ i386_pe_unique_section (decl, reloc)\n   /* The object is put in, for example, section .text$foo.\n      The linker will then ultimately place them in .text\n      (everything from the $ on is stripped). Don't put\n-     read-only data in .rdata section to avoid a PE linker \n+     read-only data in .rdata section to avoid a PE linker\n      bug when .rdata$* grouped sections are used in code\n      without a .rdata section.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -678,10 +655,7 @@ i386_pe_unique_section (decl, reloc)\n #define SECTION_PE_SHARED\tSECTION_MACH_DEP\n \n unsigned int\n-i386_pe_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n {\n   static htab_t htab;\n   unsigned int flags;\n@@ -727,9 +701,7 @@ i386_pe_section_type_flags (decl, name, reloc)\n }\n \n void\n-i386_pe_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+i386_pe_asm_named_section (const char *name, unsigned int flags)\n {\n   char flagchars[8], *f = flagchars;\n \n@@ -766,10 +738,7 @@ i386_pe_asm_named_section (name, flags)\n    visible.  */\n \n void\n-i386_pe_declare_function_type (file, name, public)\n-     FILE *file;\n-     const char *name;\n-     int public;\n+i386_pe_declare_function_type (FILE *file, const char *name, int public)\n {\n   fprintf (file, \"\\t.def\\t\");\n   assemble_name (file, name);\n@@ -795,8 +764,7 @@ static struct extern_list *extern_head;\n    for it then.  */\n \n void\n-i386_pe_record_external_function (name)\n-     const char *name;\n+i386_pe_record_external_function (const char *name)\n {\n   struct extern_list *p;\n \n@@ -820,13 +788,11 @@ static struct export_list *export_head;\n /* Assemble an export symbol entry.  We need to keep a list of\n    these, so that we can output the export list at the end of the\n    assembly.  We used to output these export symbols in each function,\n-   but that causes problems with GNU ld when the sections are \n+   but that causes problems with GNU ld when the sections are\n    linkonce.  */\n \n void\n-i386_pe_record_exported_symbol (name, is_data)\n-     const char *name;\n-     int is_data;\n+i386_pe_record_exported_symbol (const char *name, int is_data)\n {\n   struct export_list *p;\n \n@@ -842,7 +808,7 @@ i386_pe_record_exported_symbol (name, is_data)\n    output the .drectve section.  */\n \n void\n-i386_pe_file_end ()\n+i386_pe_file_end (void)\n {\n   struct extern_list *p;\n \n@@ -859,7 +825,7 @@ i386_pe_file_end ()\n \t{\n \t  TREE_ASM_WRITTEN (decl) = 1;\n \t  i386_pe_declare_function_type (asm_out_file, p->name,\n-\t\t\t  \t\t TREE_PUBLIC (decl));\n+\t\t\t\t\t TREE_PUBLIC (decl));\n \t}\n     }\n "}, {"sha": "52dacb73e7a50affb506392342d25927cc6194bb", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 104, "deletions": 108, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -1,5 +1,6 @@\n /* Definitions of target machine for GNU compiler for IA-64.\n-   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -29,130 +30,125 @@ extern GTY(()) rtx ia64_compare_op1;\n \n extern int bundling_p;\n #ifdef RTX_CODE\n-extern int ia64_st_address_bypass_p PARAMS((rtx, rtx));\n-extern int ia64_ld_address_bypass_p PARAMS((rtx, rtx));\n-extern int ia64_produce_address_p PARAMS((rtx));\n-extern int call_operand PARAMS((rtx, enum machine_mode));\n-extern int sdata_symbolic_operand PARAMS((rtx, enum machine_mode));\n-extern int got_symbolic_operand PARAMS((rtx, enum machine_mode));\n-extern int symbolic_operand PARAMS((rtx, enum machine_mode));\n-extern int tls_symbolic_operand PARAMS((rtx, enum machine_mode));\n-extern int function_operand PARAMS((rtx, enum machine_mode));\n-extern int setjmp_operand PARAMS((rtx, enum machine_mode));\n-extern int move_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_register_operand PARAMS((rtx, enum machine_mode));\n-extern int fr_register_operand PARAMS((rtx, enum machine_mode));\n-extern int grfr_register_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_nonimmediate_operand PARAMS((rtx, enum machine_mode));\n-extern int fr_nonimmediate_operand PARAMS((rtx, enum machine_mode));\n-extern int grfr_nonimmediate_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_0_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_5bit_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_6bit_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_8bit_operand PARAMS((rtx, enum machine_mode));\n-extern int grfr_reg_or_8bit_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_8bit_adjusted_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_8bit_and_adjusted_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_14bit_operand PARAMS((rtx, enum machine_mode));\n-extern int gr_reg_or_22bit_operand PARAMS((rtx, enum machine_mode));\n-extern int shift_count_operand PARAMS((rtx, enum machine_mode));\n-extern int shift_32bit_count_operand PARAMS((rtx, enum machine_mode));\n-extern int shladd_operand PARAMS((rtx, enum machine_mode));\n-extern int fetchadd_operand PARAMS((rtx, enum machine_mode));\n-extern int fr_reg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n-extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n-extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n-extern int signed_inequality_operator PARAMS((rtx, enum machine_mode));\n-extern int destination_operand PARAMS((rtx, enum machine_mode));\n-extern int not_postinc_memory_operand PARAMS((rtx, enum machine_mode));\n-extern int predicate_operator PARAMS((rtx, enum machine_mode));\n-extern int ar_lc_reg_operand PARAMS((rtx, enum machine_mode));\n-extern int ar_ccv_reg_operand PARAMS((rtx, enum machine_mode));\n-extern int ar_pfs_reg_operand PARAMS((rtx, enum machine_mode));\n-extern int general_tfmode_operand PARAMS((rtx, enum machine_mode));\n-extern int destination_tfmode_operand PARAMS((rtx, enum machine_mode));\n-extern int tfreg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n-extern int basereg_operand PARAMS((rtx, enum machine_mode));\n-\n-extern rtx ia64_expand_move PARAMS ((rtx, rtx));\n-extern int ia64_move_ok PARAMS((rtx, rtx));\n-extern int addp4_optimize_ok PARAMS((rtx, rtx));\n-extern void ia64_emit_cond_move PARAMS((rtx, rtx, rtx));\n-extern int ia64_depz_field_mask PARAMS((rtx, rtx));\n-extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));\n-extern rtx spill_tfmode_operand PARAMS((rtx, int));\n-extern rtx ia64_expand_compare PARAMS((enum rtx_code, enum machine_mode));\n-extern void ia64_expand_call PARAMS((rtx, rtx, rtx, int));\n-extern void ia64_split_call PARAMS((rtx, rtx, rtx, rtx, rtx, int, int));\n-extern void ia64_reload_gp PARAMS((void));\n-\n-extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n-extern void ia64_expand_prologue PARAMS((void));\n-extern void ia64_expand_epilogue PARAMS((int));\n-\n-extern int ia64_direct_return PARAMS((void));\n-extern void ia64_expand_load_address PARAMS((rtx, rtx));\n-extern int ia64_hard_regno_rename_ok PARAMS((int, int));\n-\n-extern void ia64_initialize_trampoline PARAMS((rtx, rtx, rtx));\n-extern void ia64_print_operand_address PARAMS((FILE *, rtx));\n-extern void ia64_print_operand PARAMS((FILE *, rtx, int));\n-extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n-\t\t\t\t\t\t\t  enum machine_mode,\n-\t\t\t\t\t\t\t  rtx));\n-extern void ia64_output_dwarf_dtprel PARAMS ((FILE*, int, rtx));\n-extern void process_for_unwind_directive PARAMS ((FILE *, rtx));\n-extern const char *get_bundle_name PARAMS ((int));\n+extern int ia64_st_address_bypass_p (rtx, rtx);\n+extern int ia64_ld_address_bypass_p (rtx, rtx);\n+extern int ia64_produce_address_p (rtx);\n+extern int call_operand (rtx, enum machine_mode);\n+extern int sdata_symbolic_operand (rtx, enum machine_mode);\n+extern int got_symbolic_operand (rtx, enum machine_mode);\n+extern int symbolic_operand (rtx, enum machine_mode);\n+extern int tls_symbolic_operand (rtx, enum machine_mode);\n+extern int function_operand (rtx, enum machine_mode);\n+extern int setjmp_operand (rtx, enum machine_mode);\n+extern int move_operand (rtx, enum machine_mode);\n+extern int gr_register_operand (rtx, enum machine_mode);\n+extern int fr_register_operand (rtx, enum machine_mode);\n+extern int grfr_register_operand (rtx, enum machine_mode);\n+extern int gr_nonimmediate_operand (rtx, enum machine_mode);\n+extern int fr_nonimmediate_operand (rtx, enum machine_mode);\n+extern int grfr_nonimmediate_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_0_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_5bit_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_6bit_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_8bit_operand (rtx, enum machine_mode);\n+extern int grfr_reg_or_8bit_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_8bit_adjusted_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_8bit_and_adjusted_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_14bit_operand (rtx, enum machine_mode);\n+extern int gr_reg_or_22bit_operand (rtx, enum machine_mode);\n+extern int shift_count_operand (rtx, enum machine_mode);\n+extern int shift_32bit_count_operand (rtx, enum machine_mode);\n+extern int shladd_operand (rtx, enum machine_mode);\n+extern int fetchadd_operand (rtx, enum machine_mode);\n+extern int fr_reg_or_fp01_operand (rtx, enum machine_mode);\n+extern int normal_comparison_operator (rtx, enum machine_mode);\n+extern int adjusted_comparison_operator (rtx, enum machine_mode);\n+extern int signed_inequality_operator (rtx, enum machine_mode);\n+extern int destination_operand (rtx, enum machine_mode);\n+extern int not_postinc_memory_operand (rtx, enum machine_mode);\n+extern int predicate_operator (rtx, enum machine_mode);\n+extern int ar_lc_reg_operand (rtx, enum machine_mode);\n+extern int ar_ccv_reg_operand (rtx, enum machine_mode);\n+extern int ar_pfs_reg_operand (rtx, enum machine_mode);\n+extern int general_tfmode_operand (rtx, enum machine_mode);\n+extern int destination_tfmode_operand (rtx, enum machine_mode);\n+extern int tfreg_or_fp01_operand (rtx, enum machine_mode);\n+extern int basereg_operand (rtx, enum machine_mode);\n+\n+extern rtx ia64_expand_move (rtx, rtx);\n+extern int ia64_move_ok (rtx, rtx);\n+extern int addp4_optimize_ok (rtx, rtx);\n+extern void ia64_emit_cond_move (rtx, rtx, rtx);\n+extern int ia64_depz_field_mask (rtx, rtx);\n+extern rtx ia64_split_timode (rtx[], rtx, rtx);\n+extern rtx spill_tfmode_operand (rtx, int);\n+extern rtx ia64_expand_compare (enum rtx_code, enum machine_mode);\n+extern void ia64_expand_call (rtx, rtx, rtx, int);\n+extern void ia64_split_call (rtx, rtx, rtx, rtx, rtx, int, int);\n+extern void ia64_reload_gp (void);\n+\n+extern HOST_WIDE_INT ia64_initial_elimination_offset (int, int);\n+extern void ia64_expand_prologue (void);\n+extern void ia64_expand_epilogue (int);\n+\n+extern int ia64_direct_return (void);\n+extern void ia64_expand_load_address (rtx, rtx);\n+extern int ia64_hard_regno_rename_ok (int, int);\n+\n+extern void ia64_initialize_trampoline (rtx, rtx, rtx);\n+extern void ia64_print_operand_address (FILE *, rtx);\n+extern void ia64_print_operand (FILE *, rtx, int);\n+extern enum reg_class ia64_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t   enum machine_mode, rtx);\n+extern void ia64_output_dwarf_dtprel (FILE*, int, rtx);\n+extern void process_for_unwind_directive (FILE *, rtx);\n+extern const char *get_bundle_name (int);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n #ifdef RTX_CODE\n-extern rtx ia64_function_arg PARAMS((CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t     tree, int, int));\n-extern rtx ia64_expand_builtin PARAMS((tree, rtx, rtx,\n-\t\t\t\t       enum machine_mode, int));\n-extern rtx ia64_va_arg PARAMS((tree, tree));\n-extern rtx ia64_function_value PARAMS((tree, tree));\n+extern rtx ia64_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t      tree, int, int);\n+extern rtx ia64_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern rtx ia64_va_arg (tree, tree);\n+extern rtx ia64_function_value (tree, tree);\n #endif /* RTX_CODE */\n \n-extern void ia64_setup_incoming_varargs PARAMS((CUMULATIVE_ARGS, int, tree,\n-\t\t\t\t\t\tint *, int));\n-extern int ia64_function_arg_partial_nregs PARAMS((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t\t   tree, int));\n-extern void ia64_function_arg_advance PARAMS((CUMULATIVE_ARGS *,\n-\t\t\t\t\t      enum machine_mode,\n-\t\t\t\t\t      tree, int));\n-extern int ia64_function_arg_pass_by_reference PARAMS((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       tree, int));\n-extern int ia64_return_in_memory PARAMS((tree));\n-extern void ia64_asm_output_external PARAMS((FILE *, tree, const char *));\n+extern void ia64_setup_incoming_varargs (CUMULATIVE_ARGS, int, tree,\n+\t\t\t\t\t int *, int);\n+extern int ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *,\n+\t\t\t\t\t    enum machine_mode, tree, int);\n+extern void ia64_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       tree, int);\n+extern int ia64_function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n+\t\t\t\t\t\tenum machine_mode, tree, int);\n+extern int ia64_return_in_memory (tree);\n+extern void ia64_asm_output_external (FILE *, tree, const char *);\n #endif /* TREE_CODE */\n \n-extern int ia64_register_move_cost PARAMS((enum machine_mode, enum reg_class,\n-\t\t\t\t\t   enum reg_class));\n-extern int ia64_epilogue_uses PARAMS((int));\n-extern int ia64_eh_uses PARAMS((int));\n-extern void emit_safe_across_calls PARAMS((void));\n-extern void ia64_init_builtins PARAMS((void));\n-extern void ia64_override_options PARAMS((void));\n-extern int ia64_dbx_register_number PARAMS((int));\n+extern int ia64_register_move_cost (enum machine_mode, enum reg_class,\n+\t\t\t\t    enum reg_class);\n+extern int ia64_epilogue_uses (int);\n+extern int ia64_eh_uses (int);\n+extern void emit_safe_across_calls (void);\n+extern void ia64_init_builtins (void);\n+extern void ia64_override_options (void);\n+extern int ia64_dbx_register_number (int);\n \n-extern rtx ia64_return_addr_rtx PARAMS ((HOST_WIDE_INT, rtx));\n-extern void ia64_split_return_addr_rtx PARAMS ((rtx));\n+extern rtx ia64_return_addr_rtx (HOST_WIDE_INT, rtx);\n+extern void ia64_split_return_addr_rtx (rtx);\n \n #ifdef SDATA_SECTION_ASM_OP\n-extern void sdata_section PARAMS ((void));\n+extern void sdata_section (void);\n #endif\n \n #ifdef SBSS_SECTION_ASM_OP\n-extern void sbss_section PARAMS ((void));\n+extern void sbss_section (void);\n #endif\n \n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction'.  */\n-extern enum direction ia64_hpux_function_arg_padding PARAMS ((enum machine_mode, tree));\n+extern enum direction ia64_hpux_function_arg_padding (enum machine_mode, tree);\n #endif /* ARGS_SIZE_RTX */\n \n-extern void ia64_hpux_handle_builtin_pragma PARAMS ((struct cpp_reader *));\n+extern void ia64_hpux_handle_builtin_pragma (struct cpp_reader *);"}, {"sha": "efed0b11deb84b0dfbe27da03d9fbdcce2fa7880", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 366, "deletions": 682, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler.\n    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by James E. Wilson <wilson@cygnus.com> and\n-   \t\t  David Mosberger <davidm@hpl.hp.com>.\n+\t\t  David Mosberger <davidm@hpl.hp.com>.\n \n This file is part of GCC.\n \n@@ -136,7 +136,7 @@ struct ia64_frame_info\n   HOST_WIDE_INT spill_size;\t/* size of the gr/br/fr spill area.  */\n   HOST_WIDE_INT extra_spill_size;  /* size of spill area for others.  */\n   HARD_REG_SET mask;\t\t/* mask of saved registers.  */\n-  unsigned int gr_used_mask;\t/* mask of registers in use as gr spill \n+  unsigned int gr_used_mask;\t/* mask of registers in use as gr spill\n \t\t\t\t   registers or long-term scratches.  */\n   int n_spilled;\t\t/* number of spilled registers.  */\n   int reg_fp;\t\t\t/* register for fp.  */\n@@ -158,108 +158,100 @@ struct ia64_frame_info\n /* Current frame information calculated by ia64_compute_frame_size.  */\n static struct ia64_frame_info current_frame_info;\n \f\n-static int ia64_use_dfa_pipeline_interface PARAMS ((void));\n-static int ia64_first_cycle_multipass_dfa_lookahead PARAMS ((void));\n-static void ia64_dependencies_evaluation_hook PARAMS ((rtx, rtx));\n-static void ia64_init_dfa_pre_cycle_insn PARAMS ((void));\n-static rtx ia64_dfa_pre_cycle_insn PARAMS ((void));\n-static int ia64_first_cycle_multipass_dfa_lookahead_guard PARAMS ((rtx));\n-static int ia64_dfa_new_cycle PARAMS ((FILE *, int, rtx, int, int, int *));\n-static rtx gen_tls_get_addr PARAMS ((void));\n-static rtx gen_thread_pointer PARAMS ((void));\n-static rtx ia64_expand_tls_address PARAMS ((enum tls_model, rtx, rtx));\n-static int find_gr_spill PARAMS ((int));\n-static int next_scratch_gr_reg PARAMS ((void));\n-static void mark_reg_gr_used_mask PARAMS ((rtx, void *));\n-static void ia64_compute_frame_size PARAMS ((HOST_WIDE_INT));\n-static void setup_spill_pointers PARAMS ((int, rtx, HOST_WIDE_INT));\n-static void finish_spill_pointers PARAMS ((void));\n-static rtx spill_restore_mem PARAMS ((rtx, HOST_WIDE_INT));\n-static void do_spill PARAMS ((rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT, rtx));\n-static void do_restore PARAMS ((rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT));\n-static rtx gen_movdi_x PARAMS ((rtx, rtx, rtx));\n-static rtx gen_fr_spill_x PARAMS ((rtx, rtx, rtx));\n-static rtx gen_fr_restore_x PARAMS ((rtx, rtx, rtx));\n-\n-static enum machine_mode hfa_element_mode PARAMS ((tree, int));\n-static bool ia64_function_ok_for_sibcall PARAMS ((tree, tree));\n-static bool ia64_rtx_costs PARAMS ((rtx, int, int, int *));\n-static void fix_range PARAMS ((const char *));\n-static struct machine_function * ia64_init_machine_status PARAMS ((void));\n-static void emit_insn_group_barriers PARAMS ((FILE *));\n-static void emit_all_insn_group_barriers PARAMS ((FILE *));\n-static void final_emit_insn_group_barriers PARAMS ((FILE *));\n-static void emit_predicate_relation_info PARAMS ((void));\n-static void ia64_reorg PARAMS ((void));\n-static bool ia64_in_small_data_p PARAMS ((tree));\n-static void process_epilogue PARAMS ((void));\n-static int process_set PARAMS ((FILE *, rtx));\n-\n-static rtx ia64_expand_fetch_and_op PARAMS ((optab, enum machine_mode,\n-\t\t\t\t\t     tree, rtx));\n-static rtx ia64_expand_op_and_fetch PARAMS ((optab, enum machine_mode,\n-\t\t\t\t\t     tree, rtx));\n-static rtx ia64_expand_compare_and_swap PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t int, tree, rtx));\n-static rtx ia64_expand_lock_test_and_set PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t  tree, rtx));\n-static rtx ia64_expand_lock_release PARAMS ((enum machine_mode, tree, rtx));\n-static bool ia64_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void ia64_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void ia64_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void ia64_output_function_end_prologue PARAMS ((FILE *));\n-\n-static int ia64_issue_rate PARAMS ((void));\n-static int ia64_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static void ia64_sched_init PARAMS ((FILE *, int, int));\n-static void ia64_sched_finish PARAMS ((FILE *, int));\n-static int ia64_dfa_sched_reorder PARAMS ((FILE *, int, rtx *, int *,\n-\t\t\t\t\t   int, int));\n-static int ia64_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int));\n-static int ia64_sched_reorder2 PARAMS ((FILE *, int, rtx *, int *, int));\n-static int ia64_variable_issue PARAMS ((FILE *, int, rtx, int));\n-\n-static struct bundle_state *get_free_bundle_state PARAMS ((void));\n-static void free_bundle_state PARAMS ((struct bundle_state *));\n-static void initiate_bundle_states PARAMS ((void));\n-static void finish_bundle_states PARAMS ((void));\n-static unsigned bundle_state_hash PARAMS ((const void *));\n-static int bundle_state_eq_p PARAMS ((const void *, const void *));\n-static int insert_bundle_state PARAMS ((struct bundle_state *));\n-static void initiate_bundle_state_table PARAMS ((void));\n-static void finish_bundle_state_table PARAMS ((void));\n-static int try_issue_nops PARAMS ((struct bundle_state *, int));\n-static int try_issue_insn PARAMS ((struct bundle_state *, rtx));\n-static void issue_nops_and_insn PARAMS ((struct bundle_state *, int,\n-\t\t\t\t\t rtx, int, int));\n-static int get_max_pos PARAMS ((state_t));\n-static int get_template PARAMS ((state_t, int));\n-\n-static rtx get_next_important_insn PARAMS ((rtx, rtx));\n-static void bundling PARAMS ((FILE *, int, rtx, rtx));\n-\n-static void ia64_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t  HOST_WIDE_INT, tree));\n-static void ia64_file_start PARAMS ((void));\n-\n-static void ia64_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t     unsigned HOST_WIDE_INT));\n-static void ia64_rwreloc_select_section PARAMS ((tree, int,\n-\t\t\t\t\t         unsigned HOST_WIDE_INT))\n+static int ia64_use_dfa_pipeline_interface (void);\n+static int ia64_first_cycle_multipass_dfa_lookahead (void);\n+static void ia64_dependencies_evaluation_hook (rtx, rtx);\n+static void ia64_init_dfa_pre_cycle_insn (void);\n+static rtx ia64_dfa_pre_cycle_insn (void);\n+static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx);\n+static int ia64_dfa_new_cycle (FILE *, int, rtx, int, int, int *);\n+static rtx gen_tls_get_addr (void);\n+static rtx gen_thread_pointer (void);\n+static rtx ia64_expand_tls_address (enum tls_model, rtx, rtx);\n+static int find_gr_spill (int);\n+static int next_scratch_gr_reg (void);\n+static void mark_reg_gr_used_mask (rtx, void *);\n+static void ia64_compute_frame_size (HOST_WIDE_INT);\n+static void setup_spill_pointers (int, rtx, HOST_WIDE_INT);\n+static void finish_spill_pointers (void);\n+static rtx spill_restore_mem (rtx, HOST_WIDE_INT);\n+static void do_spill (rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT, rtx);\n+static void do_restore (rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT);\n+static rtx gen_movdi_x (rtx, rtx, rtx);\n+static rtx gen_fr_spill_x (rtx, rtx, rtx);\n+static rtx gen_fr_restore_x (rtx, rtx, rtx);\n+\n+static enum machine_mode hfa_element_mode (tree, int);\n+static bool ia64_function_ok_for_sibcall (tree, tree);\n+static bool ia64_rtx_costs (rtx, int, int, int *);\n+static void fix_range (const char *);\n+static struct machine_function * ia64_init_machine_status (void);\n+static void emit_insn_group_barriers (FILE *);\n+static void emit_all_insn_group_barriers (FILE *);\n+static void final_emit_insn_group_barriers (FILE *);\n+static void emit_predicate_relation_info (void);\n+static void ia64_reorg (void);\n+static bool ia64_in_small_data_p (tree);\n+static void process_epilogue (void);\n+static int process_set (FILE *, rtx);\n+\n+static rtx ia64_expand_fetch_and_op (optab, enum machine_mode, tree, rtx);\n+static rtx ia64_expand_op_and_fetch (optab, enum machine_mode, tree, rtx);\n+static rtx ia64_expand_compare_and_swap (enum machine_mode, enum machine_mode,\n+\t\t\t\t\t int, tree, rtx);\n+static rtx ia64_expand_lock_test_and_set (enum machine_mode, tree, rtx);\n+static rtx ia64_expand_lock_release (enum machine_mode, tree, rtx);\n+static bool ia64_assemble_integer (rtx, unsigned int, int);\n+static void ia64_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void ia64_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void ia64_output_function_end_prologue (FILE *);\n+\n+static int ia64_issue_rate (void);\n+static int ia64_adjust_cost (rtx, rtx, rtx, int);\n+static void ia64_sched_init (FILE *, int, int);\n+static void ia64_sched_finish (FILE *, int);\n+static int ia64_dfa_sched_reorder (FILE *, int, rtx *, int *, int, int);\n+static int ia64_sched_reorder (FILE *, int, rtx *, int *, int);\n+static int ia64_sched_reorder2 (FILE *, int, rtx *, int *, int);\n+static int ia64_variable_issue (FILE *, int, rtx, int);\n+\n+static struct bundle_state *get_free_bundle_state (void);\n+static void free_bundle_state (struct bundle_state *);\n+static void initiate_bundle_states (void);\n+static void finish_bundle_states (void);\n+static unsigned bundle_state_hash (const void *);\n+static int bundle_state_eq_p (const void *, const void *);\n+static int insert_bundle_state (struct bundle_state *);\n+static void initiate_bundle_state_table (void);\n+static void finish_bundle_state_table (void);\n+static int try_issue_nops (struct bundle_state *, int);\n+static int try_issue_insn (struct bundle_state *, rtx);\n+static void issue_nops_and_insn (struct bundle_state *, int, rtx, int, int);\n+static int get_max_pos (state_t);\n+static int get_template (state_t, int);\n+\n+static rtx get_next_important_insn (rtx, rtx);\n+static void bundling (FILE *, int, rtx, rtx);\n+\n+static void ia64_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t  HOST_WIDE_INT, tree);\n+static void ia64_file_start (void);\n+\n+static void ia64_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t     unsigned HOST_WIDE_INT);\n+static void ia64_rwreloc_select_section (tree, int, unsigned HOST_WIDE_INT)\n      ATTRIBUTE_UNUSED;\n-static void ia64_rwreloc_unique_section PARAMS ((tree, int))\n+static void ia64_rwreloc_unique_section (tree, int)\n      ATTRIBUTE_UNUSED;\n-static void ia64_rwreloc_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t             unsigned HOST_WIDE_INT))\n+static void ia64_rwreloc_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\t     unsigned HOST_WIDE_INT)\n      ATTRIBUTE_UNUSED;\n-static unsigned int ia64_rwreloc_section_type_flags\n-     PARAMS ((tree, const char *, int))\n+static unsigned int ia64_rwreloc_section_type_flags (tree, const char *, int)\n      ATTRIBUTE_UNUSED;\n \n-static void ia64_hpux_add_extern_decl PARAMS ((const char *name))\n+static void ia64_hpux_add_extern_decl (const char *name)\n      ATTRIBUTE_UNUSED;\n-static void ia64_hpux_file_end PARAMS ((void))\n+static void ia64_hpux_file_end (void)\n      ATTRIBUTE_UNUSED;\n \n static tree ia64_handle_model_attribute (tree *, tree, tree, int, bool *);\n@@ -380,9 +372,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n \n int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != GET_MODE (op) && mode != VOIDmode)\n     return 0;\n@@ -394,9 +384,7 @@ call_operand (op, mode)\n /* Return 1 if OP refers to a symbol in the sdata section.  */\n \n int\n-sdata_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+sdata_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -429,9 +417,7 @@ small_addr_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n /* Return 1 if OP refers to a symbol, and is appropriate for a GOT load.  */\n \n int\n-got_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+got_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -476,9 +462,7 @@ got_symbolic_operand (op, mode)\n /* Return 1 if OP refers to a symbol.  */\n \n int\n-symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -496,9 +480,7 @@ symbolic_operand (op, mode)\n /* Return tls_model if OP refers to a TLS symbol.  */\n \n int\n-tls_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n@@ -509,9 +491,7 @@ tls_symbolic_operand (op, mode)\n /* Return 1 if OP refers to a function.  */\n \n int\n-function_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+function_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (op))\n     return 1;\n@@ -524,9 +504,7 @@ function_operand (op, mode)\n /* ??? This is an unsatisfying solution.  Should rethink.  */\n \n int\n-setjmp_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+setjmp_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   const char *name;\n   int retval = 0;\n@@ -572,19 +550,15 @@ setjmp_operand (op, mode)\n /* Return 1 if OP is a general operand, excluding tls symbolic operands.  */\n \n int\n-move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_operand (rtx op, enum machine_mode mode)\n {\n   return general_operand (op, mode) && !tls_symbolic_operand (op, mode);\n }\n \n /* Return 1 if OP is a register operand that is (or could be) a GR reg.  */\n \n int\n-gr_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_register_operand (rtx op, enum machine_mode mode)\n {\n   if (! register_operand (op, mode))\n     return 0;\n@@ -602,9 +576,7 @@ gr_register_operand (op, mode)\n /* Return 1 if OP is a register operand that is (or could be) an FR reg.  */\n \n int\n-fr_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fr_register_operand (rtx op, enum machine_mode mode)\n {\n   if (! register_operand (op, mode))\n     return 0;\n@@ -622,9 +594,7 @@ fr_register_operand (op, mode)\n /* Return 1 if OP is a register operand that is (or could be) a GR/FR reg.  */\n \n int\n-grfr_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+grfr_register_operand (rtx op, enum machine_mode mode)\n {\n   if (! register_operand (op, mode))\n     return 0;\n@@ -642,9 +612,7 @@ grfr_register_operand (op, mode)\n /* Return 1 if OP is a nonimmediate operand that is (or could be) a GR reg.  */\n \n int\n-gr_nonimmediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_nonimmediate_operand (rtx op, enum machine_mode mode)\n {\n   if (! nonimmediate_operand (op, mode))\n     return 0;\n@@ -662,9 +630,7 @@ gr_nonimmediate_operand (op, mode)\n /* Return 1 if OP is a nonimmediate operand that is (or could be) a FR reg.  */\n \n int\n-fr_nonimmediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fr_nonimmediate_operand (rtx op, enum machine_mode mode)\n {\n   if (! nonimmediate_operand (op, mode))\n     return 0;\n@@ -682,9 +648,7 @@ fr_nonimmediate_operand (op, mode)\n /* Return 1 if OP is a nonimmediate operand that is a GR/FR reg.  */\n \n int\n-grfr_nonimmediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+grfr_nonimmediate_operand (rtx op, enum machine_mode mode)\n {\n   if (! nonimmediate_operand (op, mode))\n     return 0;\n@@ -702,19 +666,15 @@ grfr_nonimmediate_operand (op, mode)\n /* Return 1 if OP is a GR register operand, or zero.  */\n \n int\n-gr_reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   return (op == const0_rtx || gr_register_operand (op, mode));\n }\n \n /* Return 1 if OP is a GR register operand, or a 5 bit immediate operand.  */\n \n int\n-gr_reg_or_5bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_5bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 32)\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -724,9 +684,7 @@ gr_reg_or_5bit_operand (op, mode)\n /* Return 1 if OP is a GR register operand, or a 6 bit immediate operand.  */\n \n int\n-gr_reg_or_6bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_6bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -736,9 +694,7 @@ gr_reg_or_6bit_operand (op, mode)\n /* Return 1 if OP is a GR register operand, or an 8 bit immediate operand.  */\n \n int\n-gr_reg_or_8bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -748,9 +704,7 @@ gr_reg_or_8bit_operand (op, mode)\n /* Return 1 if OP is a GR/FR register operand, or an 8 bit immediate.  */\n \n int\n-grfr_reg_or_8bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+grfr_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -761,9 +715,7 @@ grfr_reg_or_8bit_operand (op, mode)\n    operand.  */\n \n int\n-gr_reg_or_8bit_adjusted_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_8bit_adjusted_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -776,9 +728,7 @@ gr_reg_or_8bit_adjusted_operand (op, mode)\n    so we need the union of the immediates accepted by GT and LT.  */\n \n int\n-gr_reg_or_8bit_and_adjusted_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_8bit_and_adjusted_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op))\n \t   && CONST_OK_FOR_L (INTVAL (op)))\n@@ -789,9 +739,7 @@ gr_reg_or_8bit_and_adjusted_operand (op, mode)\n /* Return 1 if OP is a register operand, or a 14 bit immediate operand.  */\n \n int\n-gr_reg_or_14bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_14bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -801,9 +749,7 @@ gr_reg_or_14bit_operand (op, mode)\n /* Return 1 if OP is a register operand, or a 22 bit immediate operand.  */\n \n int\n-gr_reg_or_22bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gr_reg_or_22bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_J (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX\n@@ -813,9 +759,7 @@ gr_reg_or_22bit_operand (op, mode)\n /* Return 1 if OP is a 6 bit immediate operand.  */\n \n int\n-shift_count_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+shift_count_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n \t  || GET_CODE (op) == CONSTANT_P_RTX);\n@@ -824,9 +768,7 @@ shift_count_operand (op, mode)\n /* Return 1 if OP is a 5 bit immediate operand.  */\n \n int\n-shift_32bit_count_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+shift_32bit_count_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (INTVAL (op) >= 0 && INTVAL (op) < 32))\n@@ -836,9 +778,7 @@ shift_32bit_count_operand (op, mode)\n /* Return 1 if OP is a 2, 4, 8, or 16 immediate operand.  */\n \n int\n-shladd_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+shladd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) == 2 || INTVAL (op) == 4\n@@ -848,9 +788,7 @@ shladd_operand (op, mode)\n /* Return 1 if OP is a -16, -8, -4, -1, 1, 4, 8, or 16 immediate operand.  */\n \n int\n-fetchadd_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+fetchadd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n           && (INTVAL (op) == -16 || INTVAL (op) == -8 ||\n@@ -862,9 +800,7 @@ fetchadd_operand (op, mode)\n /* Return 1 if OP is a floating-point constant zero, one, or a register.  */\n \n int\n-fr_reg_or_fp01_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fr_reg_or_fp01_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (op))\n \t  || fr_register_operand (op, mode));\n@@ -874,9 +810,7 @@ fr_reg_or_fp01_operand (op, mode)\n    POST_MODIFY with a REG as displacement.  */\n \n int\n-destination_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+destination_operand (rtx op, enum machine_mode mode)\n {\n   if (! nonimmediate_operand (op, mode))\n     return 0;\n@@ -890,9 +824,7 @@ destination_operand (op, mode)\n /* Like memory_operand, but don't allow post-increments.  */\n \n int\n-not_postinc_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+not_postinc_memory_operand (rtx op, enum machine_mode mode)\n {\n   return (memory_operand (op, mode)\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != 'a');\n@@ -902,9 +834,7 @@ not_postinc_memory_operand (op, mode)\n    signed immediate operand.  */\n \n int\n-normal_comparison_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+normal_comparison_operator (register rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n@@ -916,9 +846,7 @@ normal_comparison_operator (op, mode)\n    signed immediate operand.  */\n \n int\n-adjusted_comparison_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+adjusted_comparison_operator (register rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n@@ -928,9 +856,7 @@ adjusted_comparison_operator (op, mode)\n /* Return 1 if this is a signed inequality operator.  */\n \n int\n-signed_inequality_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+signed_inequality_operator (register rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n@@ -941,9 +867,7 @@ signed_inequality_operator (op, mode)\n /* Return 1 if this operator is valid for predication.  */\n \n int\n-predicate_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+predicate_operator (register rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n@@ -953,9 +877,7 @@ predicate_operator (op, mode)\n /* Return 1 if this operator can be used in a conditional operation.  */\n \n int\n-condop_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+condop_operator (register rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n@@ -966,9 +888,7 @@ condop_operator (op, mode)\n /* Return 1 if this is the ar.lc register.  */\n \n int\n-ar_lc_reg_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+ar_lc_reg_operand (register rtx op, enum machine_mode mode)\n {\n   return (GET_MODE (op) == DImode\n \t  && (mode == DImode || mode == VOIDmode)\n@@ -979,9 +899,7 @@ ar_lc_reg_operand (op, mode)\n /* Return 1 if this is the ar.ccv register.  */\n \n int\n-ar_ccv_reg_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+ar_ccv_reg_operand (register rtx op, enum machine_mode mode)\n {\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && GET_CODE (op) == REG\n@@ -991,9 +909,7 @@ ar_ccv_reg_operand (op, mode)\n /* Return 1 if this is the ar.pfs register.  */\n \n int\n-ar_pfs_reg_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+ar_pfs_reg_operand (register rtx op, enum machine_mode mode)\n {\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && GET_CODE (op) == REG\n@@ -1003,9 +919,7 @@ ar_pfs_reg_operand (op, mode)\n /* Like general_operand, but don't allow (mem (addressof)).  */\n \n int\n-general_tfmode_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_tfmode_operand (rtx op, enum machine_mode mode)\n {\n   if (! general_operand (op, mode))\n     return 0;\n@@ -1017,9 +931,7 @@ general_tfmode_operand (op, mode)\n /* Similarly.  */\n \n int\n-destination_tfmode_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+destination_tfmode_operand (rtx op, enum machine_mode mode)\n {\n   if (! destination_operand (op, mode))\n     return 0;\n@@ -1031,9 +943,7 @@ destination_tfmode_operand (op, mode)\n /* Similarly.  */\n \n int\n-tfreg_or_fp01_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+tfreg_or_fp01_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == SUBREG)\n     return 0;\n@@ -1043,9 +953,7 @@ tfreg_or_fp01_operand (op, mode)\n /* Return 1 if OP is valid as a base register in a reg + offset address.  */\n \n int\n-basereg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+basereg_operand (rtx op, enum machine_mode mode)\n {\n   /* ??? Should I copy the flag_omit_frame_pointer and cse_not_expected\n      checks from pa.c basereg_operand as well?  Seems to be OK without them\n@@ -1096,10 +1004,7 @@ ia64_get_addr_area (tree decl)\n }\n \n static tree\n-ia64_handle_model_attribute (tree *node, tree name,\n-\t\t\t     tree args,\n-\t\t\t     int flags ATTRIBUTE_UNUSED,\n-\t\t\t     bool *no_add_attrs)\n+ia64_handle_model_attribute (tree *node, tree name, tree args, int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   ia64_addr_area addr_area = ADDR_AREA_NORMAL;\n   ia64_addr_area area;\n@@ -1181,8 +1086,7 @@ ia64_encode_section_info (tree decl, rtx rtl, int first)\n /* Return 1 if the operands of a move are ok.  */\n \n int\n-ia64_move_ok (dst, src)\n-     rtx dst, src;\n+ia64_move_ok (rtx dst, rtx src)\n {\n   /* If we're under init_recog_no_volatile, we'll not be able to use\n      memory_operand.  So check the code directly and don't worry about\n@@ -1206,8 +1110,7 @@ ia64_move_ok (dst, src)\n    C++ because of GNAT c++/6685.  */\n \n int\n-addp4_optimize_ok (op1, op2)\n-     rtx op1, op2;\n+addp4_optimize_ok (rtx op1, rtx op2)\n {\n \n   if (!strcmp (lang_hooks.name, \"GNU C++\"))\n@@ -1221,8 +1124,7 @@ addp4_optimize_ok (op1, op2)\n    Return the length of the field, or <= 0 on failure.  */\n \n int\n-ia64_depz_field_mask (rop, rshift)\n-     rtx rop, rshift;\n+ia64_depz_field_mask (rtx rop, rtx rshift)\n {\n   unsigned HOST_WIDE_INT op = INTVAL (rop);\n   unsigned HOST_WIDE_INT shift = INTVAL (rshift);\n@@ -1237,8 +1139,7 @@ ia64_depz_field_mask (rop, rshift)\n /* Expand a symbolic constant load.  */\n \n void\n-ia64_expand_load_address (dest, src)\n-      rtx dest, src;\n+ia64_expand_load_address (rtx dest, rtx src)\n {\n   if (tls_symbolic_operand (src, VOIDmode))\n     abort ();\n@@ -1305,7 +1206,7 @@ ia64_expand_load_address (dest, src)\n \n static GTY(()) rtx gen_tls_tga;\n static rtx\n-gen_tls_get_addr ()\n+gen_tls_get_addr (void)\n {\n   if (!gen_tls_tga)\n     gen_tls_tga = init_one_libfunc (\"__tls_get_addr\");\n@@ -1314,7 +1215,7 @@ gen_tls_get_addr ()\n \n static GTY(()) rtx thread_pointer_rtx;\n static rtx\n-gen_thread_pointer ()\n+gen_thread_pointer (void)\n {\n   if (!thread_pointer_rtx)\n     {\n@@ -1325,9 +1226,7 @@ gen_thread_pointer ()\n }\n \n static rtx\n-ia64_expand_tls_address (tls_kind, op0, op1)\n-     enum tls_model tls_kind;\n-     rtx op0, op1;\n+ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n {\n   rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp, insns;\n \n@@ -1345,7 +1244,7 @@ ia64_expand_tls_address (tls_kind, op0, op1)\n       emit_insn (gen_load_ltoff_dtprel (tga_op2, op1));\n       tga_op2 = gen_rtx_MEM (Pmode, tga_op2);\n       RTX_UNCHANGING_P (tga_op2) = 1;\n-\t      \n+\n       tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n \t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n \t\t\t\t\t Pmode, tga_op2, Pmode);\n@@ -1432,8 +1331,7 @@ ia64_expand_tls_address (tls_kind, op0, op1)\n }\n \n rtx\n-ia64_expand_move (op0, op1)\n-     rtx op0, op1;\n+ia64_expand_move (rtx op0, rtx op1)\n {\n   enum machine_mode mode = GET_MODE (op0);\n \n@@ -1459,8 +1357,7 @@ ia64_expand_move (op0, op1)\n /* Split a move from OP1 to OP0 conditional on COND.  */\n \n void\n-ia64_emit_cond_move (op0, op1, cond)\n-     rtx op0, op1, cond;\n+ia64_emit_cond_move (rtx op0, rtx op1, rtx cond)\n {\n   rtx insn, first = get_last_insn ();\n \n@@ -1475,9 +1372,7 @@ ia64_emit_cond_move (op0, op1, cond)\n /* Split a post-reload TImode reference into two DImode components.  */\n \n rtx\n-ia64_split_timode (out, in, scratch)\n-     rtx out[2];\n-     rtx in, scratch;\n+ia64_split_timode (rtx out[2], rtx in, rtx scratch)\n {\n   switch (GET_CODE (in))\n     {\n@@ -1544,14 +1439,12 @@ ia64_split_timode (out, in, scratch)\n    SECONDARY_RELOAD_CLASS, but not both.\n \n    We got into problems in the first place by allowing a construct like\n-   (subreg:TF (reg:TI)), which we got from a union containing a long double.  \n+   (subreg:TF (reg:TI)), which we got from a union containing a long double.\n    This solution attempts to prevent this situation from occurring.  When\n    we see something like the above, we spill the inner register to memory.  */\n \n rtx\n-spill_tfmode_operand (in, force)\n-     rtx in;\n-     int force;\n+spill_tfmode_operand (rtx in, int force)\n {\n   if (GET_CODE (in) == SUBREG\n       && GET_MODE (SUBREG_REG (in)) == TImode\n@@ -1576,9 +1469,7 @@ spill_tfmode_operand (in, force)\n    that holds the compare result in the proper mode.  */\n \n rtx\n-ia64_expand_compare (code, mode)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n+ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n {\n   rtx op0 = ia64_compare_op0, op1 = ia64_compare_op1;\n   rtx cmp;\n@@ -1606,11 +1497,8 @@ ia64_expand_compare (code, mode)\n /* Emit the appropriate sequence for a call.  */\n \n void\n-ia64_expand_call (retval, addr, nextarg, sibcall_p)\n-     rtx retval;\n-     rtx addr;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n-     int sibcall_p;\n+ia64_expand_call (rtx retval, rtx addr, rtx nextarg ATTRIBUTE_UNUSED,\n+\t\t  int sibcall_p)\n {\n   rtx insn, b0;\n \n@@ -1646,7 +1534,7 @@ ia64_expand_call (retval, addr, nextarg, sibcall_p)\n }\n \n void\n-ia64_reload_gp ()\n+ia64_reload_gp (void)\n {\n   rtx tmp;\n \n@@ -1686,10 +1574,8 @@ ia64_reload_gp ()\n }\n \n void\n-ia64_split_call (retval, addr, retaddr, scratch_r, scratch_b,\n-\t\t noreturn_p, sibcall_p)\n-     rtx retval, addr, retaddr, scratch_r, scratch_b;\n-     int noreturn_p, sibcall_p;\n+ia64_split_call (rtx retval, rtx addr, rtx retaddr, rtx scratch_r,\n+\t\t rtx scratch_b, int noreturn_p, int sibcall_p)\n {\n   rtx insn;\n   bool is_desc = false;\n@@ -1703,7 +1589,7 @@ ia64_split_call (retval, addr, retaddr, scratch_r, scratch_b,\n \n       /* ??? We are currently constrained to *not* use peep2, because\n \t we can legitimately change the global lifetime of the GP\n-\t (in the form of killing where previously live).  This is \n+\t (in the form of killing where previously live).  This is\n \t because a call through a descriptor doesn't use the previous\n \t value of the GP, while a direct call does, and we do not\n \t commit to either form until the split here.\n@@ -1752,14 +1638,14 @@ ia64_split_call (retval, addr, retaddr, scratch_r, scratch_b,\n /* Begin the assembly file.  */\n \n static void\n-ia64_file_start ()\n+ia64_file_start (void)\n {\n   default_file_start ();\n   emit_safe_across_calls ();\n }\n \n void\n-emit_safe_across_calls ()\n+emit_safe_across_calls (void)\n {\n   unsigned int rs, re;\n   int out_state;\n@@ -1797,8 +1683,7 @@ emit_safe_across_calls ()\n    TRY_LOCALS is true if we should attempt to locate a local regnum.  */\n \n static int\n-find_gr_spill (try_locals)\n-     int try_locals;\n+find_gr_spill (int try_locals)\n {\n   int regno;\n \n@@ -1847,7 +1732,7 @@ find_gr_spill (try_locals)\n static int last_scratch_gr_reg;\n \n static int\n-next_scratch_gr_reg ()\n+next_scratch_gr_reg (void)\n {\n   int i, regno;\n \n@@ -1872,9 +1757,7 @@ next_scratch_gr_reg ()\n    diddle_return_value.  Mark REG in current_frame_info.gr_used_mask.  */\n \n static void\n-mark_reg_gr_used_mask (reg, data)\n-     rtx reg;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_reg_gr_used_mask (rtx reg, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int regno = REGNO (reg);\n   if (regno < 32)\n@@ -1890,8 +1773,7 @@ mark_reg_gr_used_mask (reg, data)\n    needed for local variables.  */\n \n static void\n-ia64_compute_frame_size (size)\n-     HOST_WIDE_INT size;\n+ia64_compute_frame_size (HOST_WIDE_INT size)\n {\n   HOST_WIDE_INT total_size;\n   HOST_WIDE_INT spill_size = 0;\n@@ -1964,7 +1846,7 @@ ia64_compute_frame_size (size)\n   current_frame_info.n_rotate_regs = 0;\n \n   /* Discover which registers need spilling, and how much room that\n-     will take.  Begin with floating point and general registers, \n+     will take.  Begin with floating point and general registers,\n      which will always wind up on the stack.  */\n \n   for (regno = FR_REG (2); regno <= FR_REG (127); regno++)\n@@ -1995,7 +1877,7 @@ ia64_compute_frame_size (size)\n \n   /* Now come all special registers that might get saved in other\n      general registers.  */\n-  \n+\n   if (frame_pointer_needed)\n     {\n       current_frame_info.reg_fp = find_gr_spill (1);\n@@ -2157,8 +2039,7 @@ ia64_compute_frame_size (size)\n /* Compute the initial difference between the specified pair of registers.  */\n \n HOST_WIDE_INT\n-ia64_initial_elimination_offset (from, to)\n-     int from, to;\n+ia64_initial_elimination_offset (int from, int to)\n {\n   HOST_WIDE_INT offset;\n \n@@ -2230,10 +2111,7 @@ struct spill_fill_data\n static struct spill_fill_data spill_fill_data;\n \n static void\n-setup_spill_pointers (n_spills, init_reg, cfa_off)\n-     int n_spills;\n-     rtx init_reg;\n-     HOST_WIDE_INT cfa_off;\n+setup_spill_pointers (int n_spills, rtx init_reg, HOST_WIDE_INT cfa_off)\n {\n   int i;\n \n@@ -2259,15 +2137,13 @@ setup_spill_pointers (n_spills, init_reg, cfa_off)\n }\n \n static void\n-finish_spill_pointers ()\n+finish_spill_pointers (void)\n {\n   current_frame_info.gr_used_mask = spill_fill_data.save_gr_used_mask;\n }\n \n static rtx\n-spill_restore_mem (reg, cfa_off)\n-     rtx reg;\n-     HOST_WIDE_INT cfa_off;\n+spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n {\n   int iter = spill_fill_data.next_iter;\n   HOST_WIDE_INT disp = spill_fill_data.prev_off[iter] - cfa_off;\n@@ -2380,10 +2256,8 @@ spill_restore_mem (reg, cfa_off)\n }\n \n static void\n-do_spill (move_fn, reg, cfa_off, frame_reg)\n-     rtx (*move_fn) PARAMS ((rtx, rtx, rtx));\n-     rtx reg, frame_reg;\n-     HOST_WIDE_INT cfa_off;\n+do_spill (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off,\n+\t  rtx frame_reg)\n {\n   int iter = spill_fill_data.next_iter;\n   rtx mem, insn;\n@@ -2399,7 +2273,7 @@ do_spill (move_fn, reg, cfa_off, frame_reg)\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      /* Don't even pretend that the unwind code can intuit its way \n+      /* Don't even pretend that the unwind code can intuit its way\n \t through a pair of interleaved post_modify iterators.  Just\n \t provide the correct answer.  */\n \n@@ -2425,10 +2299,7 @@ do_spill (move_fn, reg, cfa_off, frame_reg)\n }\n \n static void\n-do_restore (move_fn, reg, cfa_off)\n-     rtx (*move_fn) PARAMS ((rtx, rtx, rtx));\n-     rtx reg;\n-     HOST_WIDE_INT cfa_off;\n+do_restore (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off)\n {\n   int iter = spill_fill_data.next_iter;\n   rtx insn;\n@@ -2443,25 +2314,19 @@ do_restore (move_fn, reg, cfa_off)\n    use a consistent function interface.  */\n \n static rtx\n-gen_movdi_x (dest, src, offset)\n-     rtx dest, src;\n-     rtx offset ATTRIBUTE_UNUSED;\n+gen_movdi_x (rtx dest, rtx src, rtx offset ATTRIBUTE_UNUSED)\n {\n   return gen_movdi (dest, src);\n }\n \n static rtx\n-gen_fr_spill_x (dest, src, offset)\n-     rtx dest, src;\n-     rtx offset ATTRIBUTE_UNUSED;\n+gen_fr_spill_x (rtx dest, rtx src, rtx offset ATTRIBUTE_UNUSED)\n {\n   return gen_fr_spill (dest, src);\n }\n \n static rtx\n-gen_fr_restore_x (dest, src, offset)\n-     rtx dest, src;\n-     rtx offset ATTRIBUTE_UNUSED;\n+gen_fr_restore_x (rtx dest, rtx src, rtx offset ATTRIBUTE_UNUSED)\n {\n   return gen_fr_restore (dest, src);\n }\n@@ -2489,7 +2354,7 @@ gen_fr_restore_x (dest, src, offset)\n    adds instruction.  */\n \n void\n-ia64_expand_prologue ()\n+ia64_expand_prologue (void)\n {\n   rtx insn, ar_pfs_save_reg, ar_unat_save_reg;\n   int i, epilogue_p, regno, alt_regno, cfa_off, n_varargs;\n@@ -2568,7 +2433,7 @@ ia64_expand_prologue ()\n \tregno = next_scratch_gr_reg ();\n       ar_pfs_save_reg = gen_rtx_REG (DImode, regno);\n \n-      insn = emit_insn (gen_alloc (ar_pfs_save_reg, \n+      insn = emit_insn (gen_alloc (ar_pfs_save_reg,\n \t\t\t\t   GEN_INT (current_frame_info.n_input_regs),\n \t\t\t\t   GEN_INT (current_frame_info.n_local_regs),\n \t\t\t\t   GEN_INT (current_frame_info.n_output_regs),\n@@ -2598,7 +2463,7 @@ ia64_expand_prologue ()\n       else\n \t{\n \t  regno = next_scratch_gr_reg ();\n- \t  offset = gen_rtx_REG (DImode, regno);\n+\t  offset = gen_rtx_REG (DImode, regno);\n \t  emit_move_insn (offset, frame_size_rtx);\n \t}\n \n@@ -2835,8 +2700,7 @@ ia64_expand_prologue ()\n    insn to prevent such scheduling.  */\n \n void\n-ia64_expand_epilogue (sibcall_p)\n-     int sibcall_p;\n+ia64_expand_epilogue (int sibcall_p)\n {\n   rtx insn, reg, alt_reg, ar_unat_save_reg;\n   int regno, alt_regno, cfa_off;\n@@ -2850,7 +2714,7 @@ ia64_expand_epilogue (sibcall_p)\n     setup_spill_pointers (current_frame_info.n_spilled,\n \t\t\t  hard_frame_pointer_rtx, 0);\n   else\n-    setup_spill_pointers (current_frame_info.n_spilled, stack_pointer_rtx, \n+    setup_spill_pointers (current_frame_info.n_spilled, stack_pointer_rtx,\n \t\t\t  current_frame_info.total_size);\n \n   if (current_frame_info.total_size != 0)\n@@ -2902,7 +2766,7 @@ ia64_expand_epilogue (sibcall_p)\n     }\n   else\n     ar_unat_save_reg = NULL_RTX;\n-      \n+\n   if (current_frame_info.reg_save_ar_pfs != 0)\n     {\n       alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_pfs);\n@@ -2952,7 +2816,7 @@ ia64_expand_epilogue (sibcall_p)\n \tdo_restore (gen_gr_restore, reg, cfa_off);\n \tcfa_off -= 8;\n       }\n-  \n+\n   /* Restore the branch registers.  Handle B0 specially, as it may\n      have gotten stored in some GR register.  */\n   if (TEST_HARD_REG_BIT (current_frame_info.mask, BR_REG (0)))\n@@ -2969,7 +2833,7 @@ ia64_expand_epilogue (sibcall_p)\n       reg = gen_rtx_REG (DImode, BR_REG (0));\n       emit_move_insn (reg, alt_reg);\n     }\n-    \n+\n   for (regno = BR_REG (1); regno <= BR_REG (7); ++regno)\n     if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n       {\n@@ -3053,15 +2917,15 @@ ia64_expand_epilogue (sibcall_p)\n \n   if (cfun->machine->ia64_eh_epilogue_bsp)\n     emit_insn (gen_set_bsp (cfun->machine->ia64_eh_epilogue_bsp));\n- \n+\n   if (! sibcall_p)\n     emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));\n   else\n     {\n       int fp = GR_REG (2);\n       /* We need a throw away register here, r0 and r1 are reserved, so r2 is the\n-\t first available call clobbered register.  If there was a frame_pointer \n-\t register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM, \n+\t first available call clobbered register.  If there was a frame_pointer\n+\t register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM,\n \t so we have to make sure we're using the string \"r2\" when emitting\n \t the register name for the assembler.  */\n       if (current_frame_info.reg_fp && current_frame_info.reg_fp == GR_REG (2))\n@@ -3086,7 +2950,7 @@ ia64_expand_epilogue (sibcall_p)\n    function.  */\n \n int\n-ia64_direct_return ()\n+ia64_direct_return (void)\n {\n   if (reload_completed && ! frame_pointer_needed)\n     {\n@@ -3107,9 +2971,7 @@ ia64_direct_return ()\n    during early compilation.  */\n \n rtx\n-ia64_return_addr_rtx (count, frame)\n-     HOST_WIDE_INT count;\n-     rtx frame ATTRIBUTE_UNUSED;\n+ia64_return_addr_rtx (HOST_WIDE_INT count, rtx frame ATTRIBUTE_UNUSED)\n {\n   if (count != 0)\n     return NULL;\n@@ -3120,8 +2982,7 @@ ia64_return_addr_rtx (count, frame)\n    address is saved.  */\n \n void\n-ia64_split_return_addr_rtx (dest)\n-     rtx dest;\n+ia64_split_return_addr_rtx (rtx dest)\n {\n   rtx src;\n \n@@ -3170,9 +3031,7 @@ ia64_split_return_addr_rtx (dest)\n }\n \n int\n-ia64_hard_regno_rename_ok (from, to)\n-     int from;\n-     int to;\n+ia64_hard_regno_rename_ok (int from, int to)\n {\n   /* Don't clobber any of the registers we reserved for the prologue.  */\n   if (to == current_frame_info.reg_fp\n@@ -3206,10 +3065,7 @@ ia64_hard_regno_rename_ok (from, to)\n    aligned objects and detect the cases when @fptr is needed.  */\n \n static bool\n-ia64_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+ia64_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (size == (TARGET_ILP32 ? 4 : 8)\n       && aligned_p\n@@ -3231,9 +3087,7 @@ ia64_assemble_integer (x, size, aligned_p)\n /* Emit the function prologue.  */\n \n static void\n-ia64_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+ia64_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   int mask, grsave, grsave_prev;\n \n@@ -3300,8 +3154,7 @@ ia64_output_function_prologue (file, size)\n /* Emit the .body directive at the scheduled end of the prologue.  */\n \n static void\n-ia64_output_function_end_prologue (file)\n-     FILE *file;\n+ia64_output_function_end_prologue (FILE *file)\n {\n   if (!flag_unwind_tables && (!flag_exceptions || USING_SJLJ_EXCEPTIONS))\n     return;\n@@ -3312,9 +3165,8 @@ ia64_output_function_end_prologue (file)\n /* Emit the function epilogue.  */\n \n static void\n-ia64_output_function_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+ia64_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   int i;\n \n@@ -3339,8 +3191,7 @@ ia64_output_function_epilogue (file, size)\n }\n \n int\n-ia64_dbx_register_number (regno)\n-     int regno;\n+ia64_dbx_register_number (int regno)\n {\n   /* In ia64_expand_prologue we quite literally renamed the frame pointer\n      from its home at loc79 to something inside the register frame.  We\n@@ -3365,8 +3216,7 @@ ia64_dbx_register_number (regno)\n }\n \n void\n-ia64_initialize_trampoline (addr, fnaddr, static_chain)\n-     rtx addr, fnaddr, static_chain;\n+ia64_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)\n {\n   rtx addr_reg, eight = GEN_INT (8);\n \n@@ -3398,12 +3248,9 @@ ia64_initialize_trampoline (addr, fnaddr, static_chain)\n    We generate the actual spill instructions during prologue generation.  */\n \n void\n-ia64_setup_incoming_varargs (cum, int_mode, type, pretend_size, second_time)\n-     CUMULATIVE_ARGS cum;\n-     int             int_mode;\n-     tree            type;\n-     int *           pretend_size;\n-     int\t     second_time ATTRIBUTE_UNUSED;\n+ia64_setup_incoming_varargs (CUMULATIVE_ARGS cum, int int_mode, tree type,\n+\t\t\t     int * pretend_size,\n+\t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n   /* Skip the current argument.  */\n   ia64_function_arg_advance (&cum, int_mode, type, 1);\n@@ -3425,9 +3272,7 @@ ia64_setup_incoming_varargs (cum, int_mode, type, pretend_size, second_time)\n    SFmode).  128-bit quad-precision floats are excluded.  */\n \n static enum machine_mode\n-hfa_element_mode (type, nested)\n-     tree type;\n-     int nested;\n+hfa_element_mode (tree type, int nested)\n {\n   enum machine_mode element_mode = VOIDmode;\n   enum machine_mode mode;\n@@ -3508,12 +3353,8 @@ hfa_element_mode (type, nested)\n    registers.  */\n \n rtx\n-ia64_function_arg (cum, mode, type, named, incoming)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-     int incoming;\n+ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t\t   int named, int incoming)\n {\n   int basereg = (incoming ? GR_ARG_FIRST : AR_ARG_FIRST);\n   int words = (((mode == BLKmode ? int_size_in_bytes (type)\n@@ -3684,11 +3525,8 @@ ia64_function_arg (cum, mode, type, named, incoming)\n    in memory.  */\n \n int\n-ia64_function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t\t tree type, int named ATTRIBUTE_UNUSED)\n {\n   int words = (((mode == BLKmode ? int_size_in_bytes (type)\n \t\t : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n@@ -3721,11 +3559,8 @@ ia64_function_arg_partial_nregs (cum, mode, type, named)\n    ia64_function_arg.  */\n \n void\n-ia64_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t   tree type, int named)\n {\n   int words = (((mode == BLKmode ? int_size_in_bytes (type)\n \t\t : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n@@ -3805,7 +3640,7 @@ ia64_function_arg_advance (cum, mode, type, named)\n   /* If there is no prototype, then FP values go in both FR and GR\n      registers.  */\n   else\n-    { \n+    {\n       /* ??? Complex types should not reach here.  */\n       cum->fp_regs += (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n       cum->int_regs = cum->words;\n@@ -3816,11 +3651,9 @@ ia64_function_arg_advance (cum, mode, type, named)\n /* ??? At present this is a GCC extension to the IA-64 ABI.  */\n \n int\n-ia64_function_arg_pass_by_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+ia64_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t     tree type, int named ATTRIBUTE_UNUSED)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n }\n@@ -3829,9 +3662,7 @@ ia64_function_arg_pass_by_reference (cum, mode, type, named)\n    call expression EXP.  DECL will be the called function, or NULL if\n    this is an indirect call.  */\n static bool\n-ia64_function_ok_for_sibcall (decl, exp)\n-     tree decl;\n-     tree exp ATTRIBUTE_UNUSED;\n+ia64_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   /* We must always return with our current GP.  This means we can\n      only sibcall to functions defined in the current module.  */\n@@ -3842,8 +3673,7 @@ ia64_function_ok_for_sibcall (decl, exp)\n /* Implement va_arg.  */\n \n rtx\n-ia64_va_arg (valist, type)\n-     tree valist, type;\n+ia64_va_arg (tree valist, tree type)\n {\n   tree t;\n \n@@ -3874,8 +3704,7 @@ ia64_va_arg (valist, type)\n    in a register.  */\n \n int\n-ia64_return_in_memory (valtype)\n-     tree valtype;\n+ia64_return_in_memory (tree valtype)\n {\n   enum machine_mode mode;\n   enum machine_mode hfa_mode;\n@@ -3911,9 +3740,7 @@ ia64_return_in_memory (valtype)\n /* Return rtx for register that holds the function return value.  */\n \n rtx\n-ia64_function_value (valtype, func)\n-     tree valtype;\n-     tree func ATTRIBUTE_UNUSED;\n+ia64_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode;\n   enum machine_mode hfa_mode;\n@@ -3980,10 +3807,7 @@ ia64_function_value (valtype, func)\n    We need to emit DTP-relative relocations.  */\n \n void\n-ia64_output_dwarf_dtprel (file, size, x)\n-     FILE *file;\n-     int size;\n-     rtx x;\n+ia64_output_dwarf_dtprel (FILE *file, int size, rtx x)\n {\n   if (size != 8)\n     abort ();\n@@ -3998,9 +3822,8 @@ ia64_output_dwarf_dtprel (file, size, x)\n    also call this from ia64_print_operand for memory addresses.  */\n \n void\n-ia64_print_operand_address (stream, address)\n-     FILE * stream ATTRIBUTE_UNUSED;\n-     rtx    address ATTRIBUTE_UNUSED;\n+ia64_print_operand_address (FILE * stream ATTRIBUTE_UNUSED,\n+\t\t\t    rtx address ATTRIBUTE_UNUSED)\n {\n }\n \n@@ -4025,10 +3848,7 @@ ia64_print_operand_address (stream, address)\n    r\tPrint register name, or constant 0 as r0.  HP compatibility for\n \tLinux kernel.  */\n void\n-ia64_print_operand (file, x, code)\n-     FILE * file;\n-     rtx    x;\n-     int    code;\n+ia64_print_operand (FILE * file, rtx x, int code)\n {\n   const char *str;\n \n@@ -4187,7 +4007,7 @@ ia64_print_operand (file, x, code)\n     case '+':\n       {\n \tconst char *which;\n-\t\n+\n \t/* For conditional branches, returns or calls, substitute\n \t   sptk, dptk, dpnt, or spnt for %s.  */\n \tx = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n@@ -4266,10 +4086,7 @@ ia64_print_operand (file, x, code)\n /* ??? This is incomplete.  */\n \n static bool\n-ia64_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+ia64_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -4343,9 +4160,8 @@ ia64_rtx_costs (x, code, outer_code, total)\n    one in class TO, using MODE.  */\n \n int\n-ia64_register_move_cost (mode, from, to)\n-     enum machine_mode mode;\n-     enum reg_class from, to;\n+ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n+\t\t\t enum reg_class to)\n {\n   /* ADDL_REGS is the same as GR_REGS for movement purposes.  */\n   if (to == ADDL_REGS)\n@@ -4417,10 +4233,8 @@ ia64_register_move_cost (mode, from, to)\n    is required.  */\n \n enum reg_class\n-ia64_secondary_reload_class (class, mode, x)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x;\n+ia64_secondary_reload_class (enum reg_class class,\n+\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   int regno = -1;\n \n@@ -4457,7 +4271,7 @@ ia64_secondary_reload_class (class, mode, x)\n       /* Need to go through general registers to get to other class regs.  */\n       if (regno >= 0 && ! (FR_REGNO_P (regno) || GENERAL_REGNO_P (regno)))\n \treturn GR_REGS;\n- \n+\n       /* This can happen when a paradoxical subreg is an operand to the\n \t muldi3 pattern.  */\n       /* ??? This shouldn't be necessary after instruction scheduling is\n@@ -4517,10 +4331,7 @@ ia64_secondary_reload_class (class, mode, x)\n    the Intel assembler does not support undefined externals.  */\n \n void\n-ia64_asm_output_external (file, decl, name)\n-     FILE *file;\n-     tree decl;\n-     const char *name;\n+ia64_asm_output_external (FILE *file, tree decl, const char *name)\n {\n   int save_referenced;\n \n@@ -4562,8 +4373,7 @@ ia64_asm_output_external (file, decl, name)\n /* Parse the -mfixed-range= option string.  */\n \n static void\n-fix_range (const_str)\n-     const char *const_str;\n+fix_range (const char *const_str)\n {\n   int i, first, last;\n   char *str, *dash, *comma;\n@@ -4626,15 +4436,15 @@ fix_range (const_str)\n }\n \n static struct machine_function *\n-ia64_init_machine_status ()\n+ia64_init_machine_status (void)\n {\n   return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n /* Handle TARGET_OPTIONS switches.  */\n \n void\n-ia64_override_options ()\n+ia64_override_options (void)\n {\n   static struct pta\n     {\n@@ -4706,12 +4516,11 @@ ia64_override_options ()\n     real_format_for_mode[TFmode - QFmode] = &ieee_extended_intel_128_format;\n }\n \f\n-static enum attr_itanium_class ia64_safe_itanium_class PARAMS((rtx));\n-static enum attr_type ia64_safe_type PARAMS((rtx));\n+static enum attr_itanium_class ia64_safe_itanium_class (rtx);\n+static enum attr_type ia64_safe_type (rtx);\n \n static enum attr_itanium_class\n-ia64_safe_itanium_class (insn)\n-     rtx insn;\n+ia64_safe_itanium_class (rtx insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_itanium_class (insn);\n@@ -4720,8 +4529,7 @@ ia64_safe_itanium_class (insn)\n }\n \n static enum attr_type\n-ia64_safe_type (insn)\n-     rtx insn;\n+ia64_safe_type (rtx insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_type (insn);\n@@ -4799,26 +4607,21 @@ struct reg_flags\n   unsigned int is_sibcall : 1;\t/* Is this a sibling or normal call?  */\n };\n \n-static void rws_update PARAMS ((struct reg_write_state *, int,\n-\t\t\t\tstruct reg_flags, int));\n-static int rws_access_regno PARAMS ((int, struct reg_flags, int));\n-static int rws_access_reg PARAMS ((rtx, struct reg_flags, int));\n-static void update_set_flags PARAMS ((rtx, struct reg_flags *, int *, rtx *));\n-static int set_src_needs_barrier PARAMS ((rtx, struct reg_flags, int, rtx));\n-static int rtx_needs_barrier PARAMS ((rtx, struct reg_flags, int));\n-static void init_insn_group_barriers PARAMS ((void));\n-static int group_barrier_needed_p PARAMS ((rtx));\n-static int safe_group_barrier_needed_p PARAMS ((rtx));\n+static void rws_update (struct reg_write_state *, int, struct reg_flags, int);\n+static int rws_access_regno (int, struct reg_flags, int);\n+static int rws_access_reg (rtx, struct reg_flags, int);\n+static void update_set_flags (rtx, struct reg_flags *, int *, rtx *);\n+static int set_src_needs_barrier (rtx, struct reg_flags, int, rtx);\n+static int rtx_needs_barrier (rtx, struct reg_flags, int);\n+static void init_insn_group_barriers (void);\n+static int group_barrier_needed_p (rtx);\n+static int safe_group_barrier_needed_p (rtx);\n \n /* Update *RWS for REGNO, which is being written by the current instruction,\n    with predicate PRED, and associated register flags in FLAGS.  */\n \n static void\n-rws_update (rws, regno, flags, pred)\n-     struct reg_write_state *rws;\n-     int regno;\n-     struct reg_flags flags;\n-     int pred;\n+rws_update (struct reg_write_state *rws, int regno, struct reg_flags flags, int pred)\n {\n   if (pred)\n     rws[regno].write_count++;\n@@ -4836,10 +4639,7 @@ rws_update (rws, regno, flags, pred)\n    a dependency with an earlier instruction in the same group.  */\n \n static int\n-rws_access_regno (regno, flags, pred)\n-     int regno;\n-     struct reg_flags flags;\n-     int pred;\n+rws_access_regno (int regno, struct reg_flags flags, int pred)\n {\n   int need_barrier = 0;\n \n@@ -4874,7 +4674,7 @@ rws_access_regno (regno, flags, pred)\n \t  /* ??? This assumes that P and P+1 are always complementary\n \t     predicates for P even.  */\n \t  if (flags.is_and && rws_sum[regno].written_by_and)\n-\t    ; \n+\t    ;\n \t  else if (flags.is_or && rws_sum[regno].written_by_or)\n \t    ;\n \t  else if ((rws_sum[regno].first_pred ^ 1) != pred)\n@@ -4957,10 +4757,7 @@ rws_access_regno (regno, flags, pred)\n }\n \n static int\n-rws_access_reg (reg, flags, pred)\n-     rtx reg;\n-     struct reg_flags flags;\n-     int pred;\n+rws_access_reg (rtx reg, struct reg_flags flags, int pred)\n {\n   int regno = REGNO (reg);\n   int n = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));\n@@ -4980,11 +4777,7 @@ rws_access_reg (reg, flags, pred)\n    the condition, stored in *PFLAGS, *PPRED and *PCOND.  */\n \n static void\n-update_set_flags (x, pflags, ppred, pcond)\n-     rtx x;\n-     struct reg_flags *pflags;\n-     int *ppred;\n-     rtx *pcond;\n+update_set_flags (rtx x, struct reg_flags *pflags, int *ppred, rtx *pcond)\n {\n   rtx src = SET_SRC (x);\n \n@@ -4998,7 +4791,7 @@ update_set_flags (x, pflags, ppred, pcond)\n     case IF_THEN_ELSE:\n       if (SET_DEST (x) == pc_rtx)\n \t/* X is a conditional branch.  */\n-\treturn;\t\n+\treturn;\n       else\n \t{\n \t  int is_complemented = 0;\n@@ -5061,13 +4854,9 @@ update_set_flags (x, pflags, ppred, pcond)\n    source of a given SET rtx found in X needs a barrier.  FLAGS and PRED\n    are as in rtx_needs_barrier.  COND is an rtx that holds the condition\n    for this insn.  */\n-   \n+\n static int\n-set_src_needs_barrier (x, flags, pred, cond)\n-     rtx x;\n-     struct reg_flags flags;\n-     int pred;\n-     rtx cond;\n+set_src_needs_barrier (rtx x, struct reg_flags flags, int pred, rtx cond)\n {\n   int need_barrier = 0;\n   rtx dst;\n@@ -5107,10 +4896,7 @@ set_src_needs_barrier (x, flags, pred, cond)\n    in the same group.  */\n \n static int\n-rtx_needs_barrier (x, flags, pred)\n-     rtx x;\n-     struct reg_flags flags;\n-     int pred;\n+rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n {\n   int i, j;\n   int is_complemented = 0;\n@@ -5126,7 +4912,7 @@ rtx_needs_barrier (x, flags, pred)\n \n   switch (GET_CODE (x))\n     {\n-    case SET:      \n+    case SET:\n       update_set_flags (x, &new_flags, &pred, &cond);\n       need_barrier = set_src_needs_barrier (x, new_flags, pred, cond);\n       if (GET_CODE (SET_SRC (x)) != CALL)\n@@ -5329,7 +5115,7 @@ rtx_needs_barrier (x, flags, pred)\n \t\t\t\t\t      new_flags, pred);\n \t    break;\n \t  }\n-\t  \n+\n \tcase UNSPEC_FR_SPILL:\n \tcase UNSPEC_FR_RESTORE:\n \tcase UNSPEC_GETF_EXP:\n@@ -5431,7 +5217,7 @@ rtx_needs_barrier (x, flags, pred)\n    sequence of insns.  */\n \n static void\n-init_insn_group_barriers ()\n+init_insn_group_barriers (void)\n {\n   memset (rws_sum, 0, sizeof (rws_sum));\n   first_instruction = 1;\n@@ -5442,8 +5228,7 @@ init_insn_group_barriers ()\n    Return nonzero if so.  */\n \n static int\n-group_barrier_needed_p (insn)\n-     rtx insn;\n+group_barrier_needed_p (rtx insn)\n {\n   rtx pat;\n   int need_barrier = 0;\n@@ -5554,8 +5339,7 @@ group_barrier_needed_p (insn)\n /* Like group_barrier_needed_p, but do not clobber the current state.  */\n \n static int\n-safe_group_barrier_needed_p (insn)\n-     rtx insn;\n+safe_group_barrier_needed_p (rtx insn)\n {\n   struct reg_write_state rws_saved[NUM_REGS];\n   int saved_first_instruction;\n@@ -5580,8 +5364,7 @@ safe_group_barrier_needed_p (insn)\n    invisible to the scheduler.  */\n \n static void\n-emit_insn_group_barriers (dump)\n-     FILE *dump;\n+emit_insn_group_barriers (FILE *dump)\n {\n   rtx insn;\n   rtx last_label = 0;\n@@ -5637,8 +5420,7 @@ emit_insn_group_barriers (dump)\n    This function has to emit all necessary group barriers.  */\n \n static void\n-emit_all_insn_group_barriers (dump)\n-     FILE *dump ATTRIBUTE_UNUSED;\n+emit_all_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n {\n   rtx insn;\n \n@@ -5675,9 +5457,9 @@ emit_all_insn_group_barriers (dump)\n }\n \n \f\n-static int errata_find_address_regs PARAMS ((rtx *, void *));\n-static void errata_emit_nops PARAMS ((rtx));\n-static void fixup_errata PARAMS ((void));\n+static int errata_find_address_regs (rtx *, void *);\n+static void errata_emit_nops (rtx);\n+static void fixup_errata (void);\n \n /* This structure is used to track some details about the previous insns\n    groups so we can determine if it may be necessary to insert NOPs to\n@@ -5695,9 +5477,7 @@ static int group_idx;\n    conditionally set in the previous group is used as an address register.\n    It ensures that for_each_rtx returns 1 in that case.  */\n static int\n-errata_find_address_regs (xp, data)\n-     rtx *xp;\n-     void *data ATTRIBUTE_UNUSED;\n+errata_find_address_regs (rtx *xp, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *xp;\n   if (GET_CODE (x) != MEM)\n@@ -5720,8 +5500,7 @@ errata_find_address_regs (xp, data)\n    last_group and emits additional NOPs if necessary to work around\n    an Itanium A/B step erratum.  */\n static void\n-errata_emit_nops (insn)\n-     rtx insn;\n+errata_emit_nops (rtx insn)\n {\n   struct group *this_group = last_group + group_idx;\n   struct group *prev_group = last_group + (group_idx ^ 1);\n@@ -5794,7 +5573,7 @@ errata_emit_nops (insn)\n /* Emit extra nops if they are required to work around hardware errata.  */\n \n static void\n-fixup_errata ()\n+fixup_errata (void)\n {\n   rtx insn;\n \n@@ -5903,14 +5682,13 @@ static int *clocks;\n \n static int *add_cycles;\n \n-static rtx ia64_single_set PARAMS ((rtx));\n-static void ia64_emit_insn_before PARAMS ((rtx, rtx));\n+static rtx ia64_single_set (rtx);\n+static void ia64_emit_insn_before (rtx, rtx);\n \n /* Map a bundle number to its pseudo-op.  */\n \n const char *\n-get_bundle_name (b)\n-     int b;\n+get_bundle_name (int b)\n {\n   return bundle_name[b];\n }\n@@ -5919,16 +5697,15 @@ get_bundle_name (b)\n /* Return the maximum number of instructions a cpu can issue.  */\n \n static int\n-ia64_issue_rate ()\n+ia64_issue_rate (void)\n {\n   return 6;\n }\n \n /* Helper function - like single_set, but look inside COND_EXEC.  */\n \n static rtx\n-ia64_single_set (insn)\n-     rtx insn;\n+ia64_single_set (rtx insn)\n {\n   rtx x = PATTERN (insn), ret;\n   if (GET_CODE (x) == COND_EXEC)\n@@ -5958,9 +5735,7 @@ ia64_single_set (insn)\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-ia64_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn, link, dep_insn;\n-     int cost;\n+ia64_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   enum attr_itanium_class dep_class;\n   enum attr_itanium_class insn_class;\n@@ -5981,8 +5756,7 @@ ia64_adjust_cost (insn, link, dep_insn, cost)\n    ??? When cycle display notes are implemented, update this.  */\n \n static void\n-ia64_emit_insn_before (insn, before)\n-     rtx insn, before;\n+ia64_emit_insn_before (rtx insn, rtx before)\n {\n   emit_insn_before (insn, before);\n }\n@@ -5993,11 +5767,10 @@ ia64_emit_insn_before (insn, before)\n    `ia64_produce_address_p' and the DFA descriptions).  */\n \n static void\n-ia64_dependencies_evaluation_hook (head, tail)\n-     rtx head, tail;\n+ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n {\n   rtx insn, link, next, next_tail;\n-  \n+\n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n@@ -6026,14 +5799,13 @@ ia64_dependencies_evaluation_hook (head, tail)\n /* We're beginning a new block.  Initialize data structures as necessary.  */\n \n static void\n-ia64_sched_init (dump, sched_verbose, max_ready)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     int max_ready ATTRIBUTE_UNUSED;\n+ia64_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t int max_ready ATTRIBUTE_UNUSED)\n {\n #ifdef ENABLE_CHECKING\n   rtx insn;\n-  \n+\n   if (reload_completed)\n     for (insn = NEXT_INSN (current_sched_info->prev_head);\n \t insn != current_sched_info->next_tail;\n@@ -6049,14 +5821,9 @@ ia64_sched_init (dump, sched_verbose, max_ready)\n    Override the default sort algorithm to better slot instructions.  */\n \n static int\n-ia64_dfa_sched_reorder (dump, sched_verbose, ready, pn_ready,\n-\t\t\tclock_var, reorder_type)\n-     FILE *dump;\n-     int sched_verbose;\n-     rtx *ready;\n-     int *pn_ready;\n-     int clock_var  ATTRIBUTE_UNUSED;\n-     int reorder_type;\n+ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n+\t\t\tint *pn_ready, int clock_var ATTRIBUTE_UNUSED,\n+\t\t\tint reorder_type)\n {\n   int n_asms;\n   int n_ready = *pn_ready;\n@@ -6113,7 +5880,7 @@ ia64_dfa_sched_reorder (dump, sched_verbose, ready, pn_ready,\n       for (insnp = ready; insnp < e_ready; insnp++)\n \tif (safe_group_barrier_needed_p (*insnp))\n \t  nr_need_stop++;\n-      \n+\n       if (reorder_type == 1 && n_ready == nr_need_stop)\n \treturn 0;\n       if (reorder_type == 0)\n@@ -6142,12 +5909,8 @@ ia64_dfa_sched_reorder (dump, sched_verbose, ready, pn_ready,\n    the default sort algorithm to better slot instructions.  */\n \n static int\n-ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, clock_var)\n-     FILE *dump;\n-     int sched_verbose;\n-     rtx *ready;\n-     int *pn_ready;\n-     int clock_var;\n+ia64_sched_reorder (FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n+\t\t    int clock_var)\n {\n   return ia64_dfa_sched_reorder (dump, sched_verbose, ready,\n \t\t\t\t pn_ready, clock_var, 0);\n@@ -6157,12 +5920,9 @@ ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, clock_var)\n    Override the default sort algorithm to better slot instructions.  */\n \n static int\n-ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx *ready;\n-     int *pn_ready;\n-     int clock_var;\n+ia64_sched_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t     int sched_verbose ATTRIBUTE_UNUSED, rtx *ready,\n+\t\t     int *pn_ready, int clock_var)\n {\n   if (ia64_tune == PROCESSOR_ITANIUM && reload_completed && last_scheduled_insn)\n     clocks [INSN_UID (last_scheduled_insn)] = clock_var;\n@@ -6174,11 +5934,10 @@ ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n    ready queue that can be issued this cycle.  */\n \n static int\n-ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int can_issue_more ATTRIBUTE_UNUSED;\n+ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t     int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t     rtx insn ATTRIBUTE_UNUSED,\n+\t\t     int can_issue_more ATTRIBUTE_UNUSED)\n {\n   last_scheduled_insn = insn;\n   memcpy (prev_cycle_state, curr_state, dfa_state_size);\n@@ -6198,8 +5957,7 @@ ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n    can be chosen.  */\n \n static int\n-ia64_first_cycle_multipass_dfa_lookahead_guard (insn)\n-     rtx insn;\n+ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn)\n {\n   if (insn == NULL_RTX || !INSN_P (insn))\n     abort ();\n@@ -6218,12 +5976,8 @@ static rtx dfa_pre_cycle_insn;\n    the ready queue on the next clock start.  */\n \n static int\n-ia64_dfa_new_cycle (dump, verbose, insn, last_clock, clock, sort_p)\n-     FILE *dump;\n-     int verbose;\n-     rtx insn;\n-     int last_clock, clock;\n-     int *sort_p;\n+ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n+\t\t    int clock, int *sort_p)\n {\n   int setup_clocks_p = FALSE;\n \n@@ -6262,18 +6016,18 @@ ia64_dfa_new_cycle (dump, verbose, insn, last_clock, clock, sort_p)\n   if (setup_clocks_p && ia64_tune == PROCESSOR_ITANIUM)\n     {\n       enum attr_itanium_class c = ia64_safe_itanium_class (insn);\n-      \n+\n       if (c != ITANIUM_CLASS_MMMUL && c != ITANIUM_CLASS_MMSHF)\n \t{\n \t  rtx link;\n \t  int d = -1;\n-\t  \n+\n \t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n \t    if (REG_NOTE_KIND (link) == 0)\n \t      {\n \t\tenum attr_itanium_class dep_class;\n \t\trtx dep_insn = XEXP (link, 0);\n-\t\t\n+\n \t\tdep_class = ia64_safe_itanium_class (dep_insn);\n \t\tif ((dep_class == ITANIUM_CLASS_MMMUL\n \t\t     || dep_class == ITANIUM_CLASS_MMSHF)\n@@ -6339,7 +6093,7 @@ static struct bundle_state *free_bundle_state_chain;\n /* The following function returns a free bundle state.  */\n \n static struct bundle_state *\n-get_free_bundle_state ()\n+get_free_bundle_state (void)\n {\n   struct bundle_state *result;\n \n@@ -6357,14 +6111,13 @@ get_free_bundle_state ()\n     }\n   result->unique_num = bundle_states_num++;\n   return result;\n-  \n+\n }\n \n /* The following function frees given bundle state.  */\n \n static void\n-free_bundle_state (state)\n-     struct bundle_state *state;\n+free_bundle_state (struct bundle_state *state)\n {\n   state->next = free_bundle_state_chain;\n   free_bundle_state_chain = state;\n@@ -6373,7 +6126,7 @@ free_bundle_state (state)\n /* Start work with abstract data `bundle states'.  */\n \n static void\n-initiate_bundle_states ()\n+initiate_bundle_states (void)\n {\n   bundle_states_num = 0;\n   free_bundle_state_chain = NULL;\n@@ -6383,7 +6136,7 @@ initiate_bundle_states ()\n /* Finish work with abstract data `bundle states'.  */\n \n static void\n-finish_bundle_states ()\n+finish_bundle_states (void)\n {\n   struct bundle_state *curr_state, *next_state;\n \n@@ -6405,8 +6158,7 @@ static htab_t bundle_state_table;\n /* The function returns hash of BUNDLE_STATE.  */\n \n static unsigned\n-bundle_state_hash (bundle_state)\n-     const void *bundle_state;\n+bundle_state_hash (const void *bundle_state)\n {\n   const struct bundle_state *state = (struct bundle_state *) bundle_state;\n   unsigned result, i;\n@@ -6420,9 +6172,7 @@ bundle_state_hash (bundle_state)\n /* The function returns nonzero if the bundle state keys are equal.  */\n \n static int\n-bundle_state_eq_p (bundle_state_1, bundle_state_2)\n-     const void *bundle_state_1;\n-     const void *bundle_state_2;\n+bundle_state_eq_p (const void *bundle_state_1, const void *bundle_state_2)\n {\n   const struct bundle_state * state1 = (struct bundle_state *) bundle_state_1;\n   const struct bundle_state * state2 = (struct bundle_state *) bundle_state_2;\n@@ -6437,8 +6187,7 @@ bundle_state_eq_p (bundle_state_1, bundle_state_2)\n    table.  The table contains the best bundle state with given key.  */\n \n static int\n-insert_bundle_state (bundle_state)\n-     struct bundle_state *bundle_state;\n+insert_bundle_state (struct bundle_state *bundle_state)\n {\n   void **entry_ptr;\n \n@@ -6460,7 +6209,7 @@ insert_bundle_state (bundle_state)\n \t\t       && ((struct bundle_state *)\n \t\t\t   *entry_ptr)->branch_deviation\n \t\t       > bundle_state->branch_deviation))))\n-\t\t   \n+\n     {\n       struct bundle_state temp;\n \n@@ -6475,7 +6224,7 @@ insert_bundle_state (bundle_state)\n /* Start work with the hash table.  */\n \n static void\n-initiate_bundle_state_table ()\n+initiate_bundle_state_table (void)\n {\n   bundle_state_table = htab_create (50, bundle_state_hash, bundle_state_eq_p,\n \t\t\t\t    (htab_del) 0);\n@@ -6484,7 +6233,7 @@ initiate_bundle_state_table ()\n /* Finish work with the hash table.  */\n \n static void\n-finish_bundle_state_table ()\n+finish_bundle_state_table (void)\n {\n   htab_delete (bundle_state_table);\n }\n@@ -6501,9 +6250,7 @@ static rtx ia64_nop;\n    function returns FALSE and frees the current state.  */\n \n static int\n-try_issue_nops (curr_state, nops_num)\n-     struct bundle_state *curr_state;\n-     int nops_num;\n+try_issue_nops (struct bundle_state *curr_state, int nops_num)\n {\n   int i;\n \n@@ -6521,9 +6268,7 @@ try_issue_nops (curr_state, nops_num)\n    function returns FALSE and frees the current state.  */\n \n static int\n-try_issue_insn (curr_state, insn)\n-     struct bundle_state *curr_state;\n-     rtx insn;\n+try_issue_insn (struct bundle_state *curr_state, rtx insn)\n {\n   if (insn && state_transition (curr_state->dfa_state, insn) >= 0)\n     {\n@@ -6541,12 +6286,8 @@ try_issue_insn (curr_state, insn)\n    insert into the hash table and into `index_to_bundle_states'.  */\n \n static void\n-issue_nops_and_insn (originator, before_nops_num, insn, try_bundle_end_p,\n-\t\t     only_bundle_end_p)\n-     struct bundle_state *originator;\n-     int before_nops_num;\n-     rtx insn;\n-     int try_bundle_end_p, only_bundle_end_p;\n+issue_nops_and_insn (struct bundle_state *originator, int before_nops_num,\n+\t\t     rtx insn, int try_bundle_end_p, int only_bundle_end_p)\n {\n   struct bundle_state *curr_state;\n \n@@ -6652,8 +6393,7 @@ issue_nops_and_insn (originator, before_nops_num, insn, try_bundle_end_p,\n    for given STATE.  */\n \n static int\n-get_max_pos (state)\n-     state_t state;\n+get_max_pos (state_t state)\n {\n   if (cpu_unit_reservation_p (state, pos_6))\n     return 6;\n@@ -6676,9 +6416,7 @@ get_max_pos (state)\n    position equal to 3 or 6.  */\n \n static int\n-get_template (state, pos)\n-     state_t state;\n-     int pos;\n+get_template (state_t state, int pos)\n {\n   switch (pos)\n     {\n@@ -6737,8 +6475,7 @@ get_template (state, pos)\n    followed by INSN and before TAIL.  */\n \n static rtx\n-get_next_important_insn (insn, tail)\n-     rtx insn, tail;\n+get_next_important_insn (rtx insn, rtx tail)\n {\n   for (; insn && insn != tail; insn = NEXT_INSN (insn))\n     if (INSN_P (insn)\n@@ -6758,10 +6495,7 @@ get_next_important_insn (insn, tail)\n    scheduling.  */\n \n static void\n-bundling (dump, verbose, prev_head_insn, tail)\n-     FILE *dump;\n-     int verbose;\n-     rtx prev_head_insn, tail;\n+bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n {\n   struct bundle_state *curr_state, *next_state, *best_state;\n   rtx insn, next_insn;\n@@ -6876,7 +6610,7 @@ bundling (dump, verbose, prev_head_insn, tail)\n \t      unsigned short two_automaton_state;\n \t      unsigned short twob_automaton_state;\n \t    };\n-\t    \n+\n \t    fprintf\n \t      (dump,\n \t       \"//    Bundle state %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\\n\",\n@@ -6929,7 +6663,7 @@ bundling (dump, verbose, prev_head_insn, tail)\n \t    unsigned short two_automaton_state;\n \t    unsigned short twob_automaton_state;\n \t  };\n-\t  \n+\n \t  fprintf\n \t    (dump,\n \t     \"//    Best %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\\n\",\n@@ -7042,7 +6776,7 @@ bundling (dump, verbose, prev_head_insn, tail)\n \t    rtx last;\n \t    int i, j, n;\n \t    int pred_stop_p;\n-\t    \n+\n \t    last = prev_active_insn (insn);\n \t    pred_stop_p = recog_memoized (last) == CODE_FOR_insn_group_barrier;\n \t    if (pred_stop_p)\n@@ -7106,9 +6840,7 @@ bundling (dump, verbose, prev_head_insn, tail)\n    EBB.  After reload, it inserts stop bits and does insn bundling.  */\n \n static void\n-ia64_sched_finish (dump, sched_verbose)\n-     FILE *dump;\n-     int sched_verbose;\n+ia64_sched_finish (FILE *dump, int sched_verbose)\n {\n   if (sched_verbose)\n     fprintf (dump, \"// Finishing schedule.\\n\");\n@@ -7123,16 +6855,15 @@ ia64_sched_finish (dump, sched_verbose)\n \tfprintf (dump, \"//    finishing %d-%d\\n\",\n \t\t INSN_UID (NEXT_INSN (current_sched_info->prev_head)),\n \t\t INSN_UID (PREV_INSN (current_sched_info->next_tail)));\n-      \n+\n       return;\n     }\n }\n \n /* The following function inserts stop bits in scheduled BB or EBB.  */\n \n static void\n-final_emit_insn_group_barriers (dump)\n-     FILE *dump ATTRIBUTE_UNUSED;\n+final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n {\n   rtx insn;\n   int need_barrier_p = 0;\n@@ -7173,7 +6904,7 @@ final_emit_insn_group_barriers (dump)\n \t      if (TARGET_EARLY_STOP_BITS)\n \t\t{\n \t\t  rtx last;\n-\t\t  \n+\n \t\t  for (last = insn;\n \t\t       last != current_sched_info->prev_head;\n \t\t       last = PREV_INSN (last))\n@@ -7218,7 +6949,7 @@ final_emit_insn_group_barriers (dump)\n    insn scheduler.  */\n \n static int\n-ia64_use_dfa_pipeline_interface ()\n+ia64_use_dfa_pipeline_interface (void)\n {\n   return 1;\n }\n@@ -7227,15 +6958,15 @@ ia64_use_dfa_pipeline_interface ()\n    insn scheduler.  */\n \n static int\n-ia64_first_cycle_multipass_dfa_lookahead ()\n+ia64_first_cycle_multipass_dfa_lookahead (void)\n {\n   return (reload_completed ? 6 : 4);\n }\n \n /* The following function initiates variable `dfa_pre_cycle_insn'.  */\n \n static void\n-ia64_init_dfa_pre_cycle_insn ()\n+ia64_init_dfa_pre_cycle_insn (void)\n {\n   if (temp_dfa_state == NULL)\n     {\n@@ -7255,7 +6986,7 @@ ia64_init_dfa_pre_cycle_insn ()\n    used by the DFA insn scheduler.  */\n \n static rtx\n-ia64_dfa_pre_cycle_insn ()\n+ia64_dfa_pre_cycle_insn (void)\n {\n   return dfa_pre_cycle_insn;\n }\n@@ -7264,9 +6995,7 @@ ia64_dfa_pre_cycle_insn ()\n    ld) produces address for CONSUMER (of type st or stf). */\n \n int\n-ia64_st_address_bypass_p (producer, consumer)\n-     rtx producer;\n-     rtx consumer;\n+ia64_st_address_bypass_p (rtx producer, rtx consumer)\n {\n   rtx dest, reg, mem;\n \n@@ -7289,9 +7018,7 @@ ia64_st_address_bypass_p (producer, consumer)\n    ld) produces address for CONSUMER (of type ld or fld). */\n \n int\n-ia64_ld_address_bypass_p (producer, consumer)\n-     rtx producer;\n-     rtx consumer;\n+ia64_ld_address_bypass_p (rtx producer, rtx consumer)\n {\n   rtx dest, src, reg, mem;\n \n@@ -7323,8 +7050,7 @@ ia64_ld_address_bypass_p (producer, consumer)\n    decreases its latency time. */\n \n int\n-ia64_produce_address_p (insn)\n-     rtx insn;\n+ia64_produce_address_p (rtx insn)\n {\n   return insn->call;\n }\n@@ -7336,7 +7062,7 @@ ia64_produce_address_p (insn)\n    straight-line code.  */\n \n static void\n-emit_predicate_relation_info ()\n+emit_predicate_relation_info (void)\n {\n   basic_block bb;\n \n@@ -7370,7 +7096,7 @@ emit_predicate_relation_info ()\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       rtx insn = bb->head;\n-      \n+\n       while (1)\n \t{\n \t  if (GET_CODE (insn) == CALL_INSN\n@@ -7384,7 +7110,7 @@ emit_predicate_relation_info ()\n \t      if (bb->end == insn)\n \t\tbb->end = a;\n \t    }\n-\t  \n+\n \t  if (insn == bb->end)\n \t    break;\n \t  insn = NEXT_INSN (insn);\n@@ -7395,7 +7121,7 @@ emit_predicate_relation_info ()\n /* Perform machine dependent operations on the rtl chain INSNS.  */\n \n static void\n-ia64_reorg ()\n+ia64_reorg (void)\n {\n   /* We are freeing block_for_insn in the toplev to keep compatibility\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n@@ -7533,8 +7259,7 @@ ia64_reorg ()\n /* Return true if REGNO is used by the epilogue.  */\n \n int\n-ia64_epilogue_uses (regno)\n-     int regno;\n+ia64_epilogue_uses (int regno)\n {\n   switch (regno)\n     {\n@@ -7573,8 +7298,7 @@ ia64_epilogue_uses (regno)\n /* Return true if REGNO is used by the frame unwinder.  */\n \n int\n-ia64_eh_uses (regno)\n-     int regno;\n+ia64_eh_uses (int regno)\n {\n   if (! reload_completed)\n     return 0;\n@@ -7606,8 +7330,7 @@ ia64_eh_uses (regno)\n    types which can't go in sdata/sbss.  */\n \n static bool\n-ia64_in_small_data_p (exp)\n-     tree exp;\n+ia64_in_small_data_p (tree exp)\n {\n   if (TARGET_NO_SDATA)\n     return false;\n@@ -7649,7 +7372,7 @@ static bool need_copy_state;\n /* The function emits unwind directives for the start of an epilogue.  */\n \n static void\n-process_epilogue ()\n+process_epilogue (void)\n {\n   /* If this isn't the last block of the function, then we need to label the\n      current state, and copy it back in at the start of the next block.  */\n@@ -7667,9 +7390,7 @@ process_epilogue ()\n    which result in emitting an assembly directive required for unwinding.  */\n \n static int\n-process_set (asm_out_file, pat)\n-     FILE *asm_out_file;\n-     rtx pat;\n+process_set (FILE *asm_out_file, rtx pat)\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n@@ -7879,9 +7600,7 @@ process_set (asm_out_file, pat)\n /* This function looks at a single insn and emits any directives\n    required to unwind this insn.  */\n void\n-process_for_unwind_directive (asm_out_file, insn)\n-     FILE *asm_out_file;\n-     rtx insn;\n+process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n {\n   if (flag_unwind_tables\n       || (flag_exceptions && !USING_SJLJ_EXCEPTIONS))\n@@ -7938,7 +7657,7 @@ process_for_unwind_directive (asm_out_file, insn)\n \n \f\n void\n-ia64_init_builtins ()\n+ia64_init_builtins (void)\n {\n   tree psi_type_node = build_pointer_type (integer_type_node);\n   tree pdi_type_node = build_pointer_type (long_integer_type_node);\n@@ -8010,8 +7729,8 @@ ia64_init_builtins ()\n \t       build_function_type (ptr_type_node, void_list_node),\n \t       IA64_BUILTIN_BSP);\n \n-  def_builtin (\"__builtin_ia64_flushrs\", \n-\t       build_function_type (void_type_node, void_list_node), \n+  def_builtin (\"__builtin_ia64_flushrs\",\n+\t       build_function_type (void_type_node, void_list_node),\n \t       IA64_BUILTIN_FLUSHRS);\n \n   def_builtin (\"__sync_fetch_and_add_si\", si_ftype_psi_si,\n@@ -8082,11 +7801,8 @@ ia64_init_builtins ()\n */\n \n static rtx\n-ia64_expand_fetch_and_op (binoptab, mode, arglist, target)\n-     optab binoptab;\n-     enum machine_mode mode;\n-     tree arglist;\n-     rtx target;\n+ia64_expand_fetch_and_op (optab binoptab, enum machine_mode mode,\n+\t\t\t  tree arglist, rtx target)\n {\n   rtx ret, label, tmp, ccv, insn, mem, value;\n   tree arg0, arg1;\n@@ -8163,11 +7879,8 @@ ia64_expand_fetch_and_op (binoptab, mode, arglist, target)\n */\n \n static rtx\n-ia64_expand_op_and_fetch (binoptab, mode, arglist, target)\n-     optab binoptab;\n-     enum machine_mode mode;\n-     tree arglist;\n-     rtx target;\n+ia64_expand_op_and_fetch (optab binoptab, enum machine_mode mode,\n+\t\t\t  tree arglist, rtx target)\n {\n   rtx old, label, tmp, ret, ccv, insn, mem, value;\n   tree arg0, arg1;\n@@ -8231,12 +7944,8 @@ ia64_expand_op_and_fetch (binoptab, mode, arglist, target)\n */\n \n static rtx\n-ia64_expand_compare_and_swap (rmode, mode, boolp, arglist, target)\n-     enum machine_mode rmode;\n-     enum machine_mode mode;\n-     int boolp;\n-     tree arglist;\n-     rtx target;\n+ia64_expand_compare_and_swap (enum machine_mode rmode, enum machine_mode mode,\n+\t\t\t      int boolp, tree arglist, rtx target)\n {\n   tree arg0, arg1, arg2;\n   rtx mem, old, new, ccv, tmp, insn;\n@@ -8290,10 +7999,8 @@ ia64_expand_compare_and_swap (rmode, mode, boolp, arglist, target)\n /* Expand lock_test_and_set.  I.e. `xchgsz ret = [ptr], new'.  */\n \n static rtx\n-ia64_expand_lock_test_and_set (mode, arglist, target)\n-     enum machine_mode mode;\n-     tree arglist;\n-     rtx target;\n+ia64_expand_lock_test_and_set (enum machine_mode mode, tree arglist,\n+\t\t\t       rtx target)\n {\n   tree arg0, arg1;\n   rtx mem, new, ret, insn;\n@@ -8325,10 +8032,8 @@ ia64_expand_lock_test_and_set (mode, arglist, target)\n /* Expand lock_release.  I.e. `stsz.rel [ptr] = r0'.  */\n \n static rtx\n-ia64_expand_lock_release (mode, arglist, target)\n-     enum machine_mode mode;\n-     tree arglist;\n-     rtx target ATTRIBUTE_UNUSED;\n+ia64_expand_lock_release (enum machine_mode mode, tree arglist,\n+\t\t\t  rtx target ATTRIBUTE_UNUSED)\n {\n   tree arg0;\n   rtx mem;\n@@ -8345,12 +8050,9 @@ ia64_expand_lock_release (mode, arglist, target)\n }\n \n rtx\n-ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+ia64_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -8509,9 +8211,7 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n    most significant bits of the stack slot.  */\n \n enum direction\n-ia64_hpux_function_arg_padding (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+ia64_hpux_function_arg_padding (enum machine_mode mode, tree type)\n {\n    /* Exception to normal case for structures/unions/etc.  */\n \n@@ -8540,8 +8240,7 @@ struct extern_func_list\n } *extern_func_head = 0;\n \n static void\n-ia64_hpux_add_extern_decl (name)\n-        const char *name;\n+ia64_hpux_add_extern_decl (const char *name)\n {\n   struct extern_func_list *p;\n \n@@ -8555,7 +8254,7 @@ ia64_hpux_add_extern_decl (name)\n /* Print out the list of used global functions.  */\n \n static void\n-ia64_hpux_file_end ()\n+ia64_hpux_file_end (void)\n {\n   while (extern_func_head)\n     {\n@@ -8587,10 +8286,8 @@ ia64_hpux_file_end ()\n    special we do here is to honor small data.  */\n \n static void\n-ia64_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+ia64_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t unsigned HOST_WIDE_INT align)\n {\n   if (GET_MODE_SIZE (mode) > 0\n       && GET_MODE_SIZE (mode) <= ia64_section_threshold)\n@@ -8603,27 +8300,20 @@ ia64_select_rtx_section (mode, x, align)\n    Pretend flag_pic is always set.  */\n \n static void\n-ia64_rwreloc_select_section (exp, reloc, align)\n-     tree exp;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align;\n+ia64_rwreloc_select_section (tree exp, int reloc, unsigned HOST_WIDE_INT align)\n {\n   default_elf_select_section_1 (exp, reloc, align, true);\n }\n \n static void\n-ia64_rwreloc_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc;\n+ia64_rwreloc_unique_section (tree decl, int reloc)\n {\n   default_unique_section_1 (decl, reloc, true);\n }\n \n static void\n-ia64_rwreloc_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+ia64_rwreloc_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t\t unsigned HOST_WIDE_INT align)\n {\n   int save_pic = flag_pic;\n   flag_pic = 1;\n@@ -8632,10 +8322,7 @@ ia64_rwreloc_select_rtx_section (mode, x, align)\n }\n \n static unsigned int\n-ia64_rwreloc_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+ia64_rwreloc_section_type_flags (tree decl, const char *name, int reloc)\n {\n   return default_section_type_flags_1 (decl, name, reloc, true);\n }\n@@ -8648,12 +8335,9 @@ ia64_rwreloc_section_type_flags (decl, name, reloc)\n    *(*this + vcall_offset) should be added to THIS.  */\n \n static void\n-ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset;\n-     tree function;\n+ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t      tree function)\n {\n   rtx this, insn, funexp;\n "}, {"sha": "c64e97413188feaa1cf9db835952c15508358777", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -21,77 +21,81 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Declare functions in s390.c.  */\n \n-extern void optimization_options PARAMS ((int, int));\n-extern void override_options PARAMS ((void));\n-extern int s390_arg_frame_offset PARAMS ((void));\n-extern void s390_load_got PARAMS ((int));\n-extern void s390_emit_prologue PARAMS ((void));\n-extern void s390_emit_epilogue PARAMS ((void));\n-extern void s390_function_profiler PARAMS ((FILE *, int));\n+extern void optimization_options (int, int);\n+extern void override_options (void);\n+extern int s390_arg_frame_offset (void);\n+extern void s390_load_got (int);\n+extern void s390_emit_prologue (void);\n+extern void s390_emit_epilogue (void);\n+extern void s390_function_profiler (FILE *, int);\n \n #ifdef RTX_CODE\n-extern int s390_extra_constraint PARAMS ((rtx, int));\n-extern int const0_operand PARAMS ((rtx, enum machine_mode));\n-extern int consttable_operand PARAMS ((rtx, enum machine_mode));\n-extern int larl_operand PARAMS ((rtx, enum machine_mode));\n-extern int s_operand PARAMS ((rtx, enum machine_mode));\n-extern int s_imm_operand PARAMS ((rtx, enum machine_mode));\n-extern int bras_sym_operand PARAMS ((rtx, enum machine_mode));\n-extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern int s390_single_hi PARAMS ((rtx, enum machine_mode, int));\n-extern int s390_extract_hi PARAMS ((rtx, enum machine_mode, int));\n-extern int s390_single_qi PARAMS ((rtx, enum machine_mode, int));\n-extern int s390_extract_qi PARAMS ((rtx, enum machine_mode, int));\n-extern bool s390_split_ok_p PARAMS ((rtx, rtx, enum machine_mode, int));\n-extern int tls_symbolic_operand PARAMS ((rtx));\n+extern int s390_extra_constraint (rtx, int);\n+extern int const0_operand (rtx, enum machine_mode);\n+extern int consttable_operand (rtx, enum machine_mode);\n+extern int larl_operand (rtx, enum machine_mode);\n+extern int s_operand (rtx, enum machine_mode);\n+extern int s_imm_operand (rtx, enum machine_mode);\n+extern int bras_sym_operand (rtx, enum machine_mode);\n+extern int load_multiple_operation (rtx, enum machine_mode);\n+extern int store_multiple_operation (rtx, enum machine_mode);\n+extern int s390_single_hi (rtx, enum machine_mode, int);\n+extern int s390_extract_hi (rtx, enum machine_mode, int);\n+extern int s390_single_qi (rtx, enum machine_mode, int);\n+extern int s390_extract_qi (rtx, enum machine_mode, int);\n+extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);\n+extern int tls_symbolic_operand (rtx);\n \n-extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n-extern enum machine_mode s390_tm_ccmode PARAMS ((rtx, rtx, int));\n-extern enum machine_mode s390_select_ccmode PARAMS ((enum rtx_code, rtx, rtx));\n-extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n-extern int tls_symbolic_reference_mentioned_p PARAMS ((rtx));\n-extern rtx s390_tls_get_offset PARAMS ((void));\n-extern int legitimate_la_operand_p PARAMS ((rtx));\n-extern int preferred_la_operand_p PARAMS ((rtx));\n-extern int legitimate_pic_operand_p PARAMS ((rtx));\n-extern int legitimate_constant_p PARAMS ((rtx));\n-extern int legitimate_reload_constant_p PARAMS ((rtx));\n-extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n-extern rtx legitimize_pic_address PARAMS ((rtx, rtx));\n-extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n-extern enum reg_class s390_preferred_reload_class PARAMS ((rtx, enum reg_class));\n-extern enum reg_class s390_secondary_input_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n-extern enum reg_class s390_secondary_output_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n-extern int s390_plus_operand PARAMS ((rtx, enum machine_mode));\n-extern void s390_expand_plus_operand PARAMS ((rtx, rtx, rtx));\n-extern void emit_symbolic_move PARAMS ((rtx *));\n-extern void s390_load_address PARAMS ((rtx, rtx));\n-extern void s390_expand_movstr PARAMS ((rtx, rtx, rtx));\n-extern void s390_expand_clrstr PARAMS ((rtx, rtx));\n-extern void s390_expand_cmpmem PARAMS ((rtx, rtx, rtx, rtx));\n-extern rtx s390_return_addr_rtx PARAMS ((int, rtx));\n+extern int s390_match_ccmode (rtx, enum machine_mode);\n+extern enum machine_mode s390_tm_ccmode (rtx, rtx, int);\n+extern enum machine_mode s390_select_ccmode (enum rtx_code, rtx, rtx);\n+extern int symbolic_reference_mentioned_p (rtx);\n+extern int tls_symbolic_reference_mentioned_p (rtx);\n+extern rtx s390_tls_get_offset (void);\n+extern int legitimate_la_operand_p (rtx);\n+extern int preferred_la_operand_p (rtx);\n+extern int legitimate_pic_operand_p (rtx);\n+extern int legitimate_constant_p (rtx);\n+extern int legitimate_reload_constant_p (rtx);\n+extern int legitimate_address_p (enum machine_mode, rtx, int);\n+extern rtx legitimize_pic_address (rtx, rtx);\n+extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n+extern enum reg_class s390_preferred_reload_class (rtx, enum reg_class);\n+extern enum reg_class s390_secondary_input_reload_class (enum reg_class,\n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t rtx);\n+extern enum reg_class s390_secondary_output_reload_class (enum reg_class,\n+\t\t\t\t\t\t\t  enum machine_mode,\n+\t\t\t\t\t\t\t  rtx);\n+extern int s390_plus_operand (rtx, enum machine_mode);\n+extern void s390_expand_plus_operand (rtx, rtx, rtx);\n+extern void emit_symbolic_move (rtx *);\n+extern void s390_load_address (rtx, rtx);\n+extern void s390_expand_movstr (rtx, rtx, rtx);\n+extern void s390_expand_clrstr (rtx, rtx);\n+extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n+extern rtx s390_return_addr_rtx (int, rtx);\n \n-extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void s390_output_constant_pool PARAMS ((rtx, rtx));\n-extern void s390_trampoline_template PARAMS ((FILE *));\n-extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n-extern rtx s390_gen_rtx_const_DI PARAMS ((int, int));\n-extern void s390_output_dwarf_dtprel PARAMS ((FILE*, int, rtx));\n-extern int s390_agen_dep_p PARAMS ((rtx, rtx));\n+extern void s390_output_symbolic_const (FILE *, rtx);\n+extern void print_operand_address (FILE *, rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern void s390_output_constant_pool (rtx, rtx);\n+extern void s390_trampoline_template (FILE *);\n+extern void s390_initialize_trampoline (rtx, rtx, rtx);\n+extern rtx s390_gen_rtx_const_DI (int, int);\n+extern void s390_output_dwarf_dtprel (FILE*, int, rtx);\n+extern int s390_agen_dep_p (rtx, rtx);\n \n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern int s390_function_arg_pass_by_reference PARAMS ((enum machine_mode, tree));\n-extern void s390_function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n-extern tree s390_build_va_list PARAMS ((void));\n+extern int s390_function_arg_pass_by_reference (enum machine_mode, tree);\n+extern void s390_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       tree, int);\n+extern tree s390_build_va_list (void);\n #ifdef RTX_CODE\n-extern rtx s390_function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n-extern void s390_va_start PARAMS ((tree, rtx));\n-extern rtx s390_va_arg PARAMS ((tree, tree));\n+extern rtx s390_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern void s390_va_start (tree, rtx);\n+extern rtx s390_va_arg (tree, tree);\n #endif /* RTX_CODE */\n #endif /* TREE_CODE */\n-"}, {"sha": "55e5149cbd110cf2400b37f7aab555a1f98aed75", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 217, "deletions": 434, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c808aadb04cd7e3d8d16ec7f901acb42bf85688/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9c808aadb04cd7e3d8d16ec7f901acb42bf85688", "patch": "@@ -54,29 +54,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define SYMBOL_FLAG_ALIGN1\t(SYMBOL_FLAG_MACH_DEP << 0)\n \n \n-static bool s390_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void s390_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t     unsigned HOST_WIDE_INT));\n-static void s390_encode_section_info PARAMS ((tree, rtx, int));\n-static bool s390_cannot_force_const_mem PARAMS ((rtx));\n-static rtx s390_delegitimize_address PARAMS ((rtx));\n-static void s390_init_builtins PARAMS ((void));\n-static rtx s390_expand_builtin PARAMS ((tree, rtx, rtx,\n-\t\t\t\t\tenum machine_mode, int));\n-static void s390_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t  HOST_WIDE_INT, tree));\n-static enum attr_type s390_safe_attr_type PARAMS ((rtx));\n-\n-static int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int s390_adjust_priority PARAMS ((rtx, int));\n-static int s390_issue_rate PARAMS ((void));\n-static int s390_use_dfa_pipeline_interface PARAMS ((void));\n-static int s390_first_cycle_multipass_dfa_lookahead PARAMS ((void));\n-static int s390_sched_reorder2 PARAMS ((FILE *, int, rtx *, int *, int));\n-static bool s390_rtx_costs PARAMS ((rtx, int, int, int *));\n-static int s390_address_cost PARAMS ((rtx));\n-static void s390_reorg PARAMS ((void));\n-static bool s390_valid_pointer_mode PARAMS ((enum machine_mode));\n+static bool s390_assemble_integer (rtx, unsigned int, int);\n+static void s390_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t     unsigned HOST_WIDE_INT);\n+static void s390_encode_section_info (tree, rtx, int);\n+static bool s390_cannot_force_const_mem (rtx);\n+static rtx s390_delegitimize_address (rtx);\n+static void s390_init_builtins (void);\n+static rtx s390_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static void s390_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t  HOST_WIDE_INT, tree);\n+static enum attr_type s390_safe_attr_type (rtx);\n+\n+static int s390_adjust_cost (rtx, rtx, rtx, int);\n+static int s390_adjust_priority (rtx, int);\n+static int s390_issue_rate (void);\n+static int s390_use_dfa_pipeline_interface (void);\n+static int s390_first_cycle_multipass_dfa_lookahead (void);\n+static int s390_sched_reorder2 (FILE *, int, rtx *, int *, int);\n+static bool s390_rtx_costs (rtx, int, int, int *);\n+static int s390_address_cost (rtx);\n+static void s390_reorg (void);\n+static bool s390_valid_pointer_mode (enum machine_mode);\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n@@ -202,35 +201,35 @@ struct machine_function GTY(())\n   const char *some_ld_name;\n };\n \n-static int s390_match_ccmode_set PARAMS ((rtx, enum machine_mode));\n-static int s390_branch_condition_mask PARAMS ((rtx));\n-static const char *s390_branch_condition_mnemonic PARAMS ((rtx, int));\n-static int check_mode PARAMS ((rtx, enum machine_mode *));\n-static int general_s_operand PARAMS ((rtx, enum machine_mode, int));\n-static int s390_short_displacement PARAMS ((rtx));\n-static int s390_decompose_address PARAMS ((rtx, struct s390_address *));\n-static rtx get_thread_pointer PARAMS ((void));\n-static rtx legitimize_tls_address PARAMS ((rtx, rtx));\n-static const char *get_some_local_dynamic_name PARAMS ((void));\n-static int get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));\n-static int reg_used_in_mem_p PARAMS ((int, rtx));\n-static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n-static int s390_split_branches PARAMS ((rtx, bool *));\n-static void find_constant_pool_ref PARAMS ((rtx, rtx *));\n-static void replace_constant_pool_ref PARAMS ((rtx *, rtx, rtx));\n-static rtx find_ltrel_base PARAMS ((rtx));\n-static void replace_ltrel_base PARAMS ((rtx *, rtx));\n-static void s390_optimize_prolog PARAMS ((int));\n-static bool s390_fixup_clobbered_return_reg PARAMS ((rtx));\n-static int find_unused_clobbered_reg PARAMS ((void));\n-static void s390_frame_info PARAMS ((void));\n-static rtx save_fpr PARAMS ((rtx, int, int));\n-static rtx restore_fpr PARAMS ((rtx, int, int));\n-static rtx save_gprs PARAMS ((rtx, int, int, int));\n-static rtx restore_gprs PARAMS ((rtx, int, int, int));\n-static int s390_function_arg_size PARAMS ((enum machine_mode, tree));\n-static bool s390_function_arg_float PARAMS ((enum machine_mode, tree));\n-static struct machine_function * s390_init_machine_status PARAMS ((void));\n+static int s390_match_ccmode_set (rtx, enum machine_mode);\n+static int s390_branch_condition_mask (rtx);\n+static const char *s390_branch_condition_mnemonic (rtx, int);\n+static int check_mode (rtx, enum machine_mode *);\n+static int general_s_operand (rtx, enum machine_mode, int);\n+static int s390_short_displacement (rtx);\n+static int s390_decompose_address (rtx, struct s390_address *);\n+static rtx get_thread_pointer (void);\n+static rtx legitimize_tls_address (rtx, rtx);\n+static const char *get_some_local_dynamic_name (void);\n+static int get_some_local_dynamic_name_1 (rtx *, void *);\n+static int reg_used_in_mem_p (int, rtx);\n+static int addr_generation_dependency_p (rtx, rtx);\n+static int s390_split_branches (rtx, bool *);\n+static void find_constant_pool_ref (rtx, rtx *);\n+static void replace_constant_pool_ref (rtx *, rtx, rtx);\n+static rtx find_ltrel_base (rtx);\n+static void replace_ltrel_base (rtx *, rtx);\n+static void s390_optimize_prolog (int);\n+static bool s390_fixup_clobbered_return_reg (rtx);\n+static int find_unused_clobbered_reg (void);\n+static void s390_frame_info (void);\n+static rtx save_fpr (rtx, int, int);\n+static rtx restore_fpr (rtx, int, int);\n+static rtx save_gprs (rtx, int, int, int);\n+static rtx restore_gprs (rtx, int, int, int);\n+static int s390_function_arg_size (enum machine_mode, tree);\n+static bool s390_function_arg_float (enum machine_mode, tree);\n+static struct machine_function * s390_init_machine_status (void);\n \n /* Check whether integer displacement is in range.  */\n #define DISP_IN_RANGE(d) \\\n@@ -242,9 +241,7 @@ static struct machine_function * s390_init_machine_status PARAMS ((void));\n    CC mode is at least as constrained as REQ_MODE.  */\n \n static int\n-s390_match_ccmode_set (set, req_mode)\n-     rtx set;\n-     enum machine_mode req_mode;\n+s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n {\n   enum machine_mode set_mode;\n \n@@ -296,9 +293,7 @@ s390_match_ccmode_set (set, req_mode)\n    If REQ_MODE is VOIDmode, always return false.  */\n \n int\n-s390_match_ccmode (insn, req_mode)\n-     rtx insn;\n-     enum machine_mode req_mode;\n+s390_match_ccmode (rtx insn, enum machine_mode req_mode)\n {\n   int i;\n \n@@ -329,10 +324,7 @@ s390_match_ccmode (insn, req_mode)\n    if the instruction cannot (TM).  */\n \n enum machine_mode\n-s390_tm_ccmode (op1, op2, mixed)\n-     rtx op1;\n-     rtx op2;\n-     int mixed;\n+s390_tm_ccmode (rtx op1, rtx op2, int mixed)\n {\n   int bit0, bit1;\n \n@@ -365,10 +357,7 @@ s390_tm_ccmode (op1, op2, mixed)\n    comparison.  */\n \n enum machine_mode\n-s390_select_ccmode (code, op0, op1)\n-     enum rtx_code code;\n-     rtx op0;\n-     rtx op1;\n+s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n {\n   switch (code)\n     {\n@@ -462,8 +451,7 @@ s390_select_ccmode (code, op0, op1)\n    specified by CODE.  */\n \n static int\n-s390_branch_condition_mask (code)\n-    rtx code;\n+s390_branch_condition_mask (rtx code)\n {\n   const int CC0 = 1 << 3;\n   const int CC1 = 1 << 2;\n@@ -657,9 +645,7 @@ s390_branch_condition_mask (code)\n    for the corresponding inverted branch.  */\n \n static const char *\n-s390_branch_condition_mnemonic (code, inv)\n-     rtx code;\n-     int inv;\n+s390_branch_condition_mnemonic (rtx code, int inv)\n {\n   static const char *const mnemonic[16] =\n     {\n@@ -686,10 +672,7 @@ s390_branch_condition_mnemonic (code, inv)\n    equal to DEF, return zero.  Otherwise, return -1.  */\n \n int\n-s390_single_hi (op, mode, def)\n-     rtx op;\n-     enum machine_mode mode;\n-     int def;\n+s390_single_hi (rtx op, enum machine_mode mode, int def)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -751,10 +734,7 @@ s390_single_hi (op, mode, def)\n    constant OP of mode MODE.  */\n \n int\n-s390_extract_hi (op, mode, part)\n-    rtx op;\n-    enum machine_mode mode;\n-    int part;\n+s390_extract_hi (rtx op, enum machine_mode mode, int part)\n {\n   int n_parts = GET_MODE_SIZE (mode) / 2;\n   if (part < 0 || part >= n_parts)\n@@ -789,10 +769,7 @@ s390_extract_hi (op, mode, part)\n    equal to DEF, return zero.  Otherwise, return -1.  */\n \n int\n-s390_single_qi (op, mode, def)\n-     rtx op;\n-     enum machine_mode mode;\n-     int def;\n+s390_single_qi (rtx op, enum machine_mode mode, int def)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -854,10 +831,7 @@ s390_single_qi (op, mode, def)\n    constant OP of mode MODE.  */\n \n int\n-s390_extract_qi (op, mode, part)\n-    rtx op;\n-    enum machine_mode mode;\n-    int part;\n+s390_extract_qi (rtx op, enum machine_mode mode, int part)\n {\n   int n_parts = GET_MODE_SIZE (mode);\n   if (part < 0 || part >= n_parts)\n@@ -891,11 +865,7 @@ s390_extract_qi (op, mode, part)\n    moves, moving the subword FIRST_SUBWORD first.  */\n \n bool\n-s390_split_ok_p (dst, src, mode, first_subword)\n-     rtx dst;\n-     rtx src;\n-     enum machine_mode mode;\n-     int first_subword;\n+s390_split_ok_p (rtx dst, rtx src, enum machine_mode mode, int first_subword)\n {\n   /* Floating point registers cannot be split.  */\n   if (FP_REG_P (src) || FP_REG_P (dst))\n@@ -932,9 +902,7 @@ s390_split_ok_p (dst, src, mode, first_subword)\n    SIZE is nonzero if `-Os' is specified and zero otherwise.  */\n \n void\n-optimization_options (level, size)\n-     int level ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+optimization_options (int level ATTRIBUTE_UNUSED, int size ATTRIBUTE_UNUSED)\n {\n   /* ??? There are apparently still problems with -fcaller-saves.  */\n   flag_caller_saves = 0;\n@@ -945,7 +913,7 @@ optimization_options (level, size)\n }\n \n void\n-override_options ()\n+override_options (void)\n {\n   int i;\n   static struct pta\n@@ -1038,8 +1006,7 @@ const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n /* Return attribute type of insn.  */\n \n static enum attr_type\n-s390_safe_attr_type (insn)\n-     rtx insn;\n+s390_safe_attr_type (rtx insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_type (insn);\n@@ -1052,9 +1019,7 @@ s390_safe_attr_type (insn)\n    MODE is the current operation mode.  */\n \n int\n-const0_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+const0_operand (register rtx op, enum machine_mode mode)\n {\n   return op == CONST0_RTX (mode);\n }\n@@ -1064,9 +1029,7 @@ const0_operand (op, mode)\n    MODE is the current operation mode.  */\n \n int\n-consttable_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+consttable_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return CONSTANT_P (op);\n }\n@@ -1075,9 +1038,7 @@ consttable_operand (op, mode)\n    If MODE is set to VOIDmode, set it to the mode of OP.  */\n \n static int\n-check_mode (op, mode)\n-     register rtx op;\n-     enum machine_mode *mode;\n+check_mode (register rtx op, enum machine_mode *mode)\n {\n   if (*mode == VOIDmode)\n       *mode = GET_MODE (op);\n@@ -1094,9 +1055,7 @@ check_mode (op, mode)\n    MODE is the current operation mode.  */\n \n int\n-larl_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+larl_operand (register rtx op, enum machine_mode mode)\n {\n   if (! check_mode (op, &mode))\n     return 0;\n@@ -1158,10 +1117,8 @@ larl_operand (op, mode)\n    be accepted or not.  */\n \n static int\n-general_s_operand (op, mode, allow_immediate)\n-     register rtx op;\n-     enum machine_mode mode;\n-     int allow_immediate;\n+general_s_operand (register rtx op, enum machine_mode mode,\n+\t\t   int allow_immediate)\n {\n   struct s390_address addr;\n \n@@ -1216,9 +1173,7 @@ general_s_operand (op, mode, allow_immediate)\n    MODE is the current operation mode.  */\n \n int\n-s_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+s_operand (register rtx op, enum machine_mode mode)\n {\n   return general_s_operand (op, mode, 0);\n }\n@@ -1230,18 +1185,15 @@ s_operand (op, mode)\n    MODE is the current operation mode.  */\n \n int\n-s_imm_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+s_imm_operand (register rtx op, enum machine_mode mode)\n {\n   return general_s_operand (op, mode, 1);\n }\n \n /* Return true if DISP is a valid short displacement.  */\n \n static int\n-s390_short_displacement (disp)\n-     rtx disp;\n+s390_short_displacement (rtx disp)\n {\n   /* No displacement is OK.  */\n   if (!disp)\n@@ -1268,9 +1220,7 @@ s390_short_displacement (disp)\n /* Return true if OP is a valid operand for a C constraint.  */\n \n int\n-s390_extra_constraint (op, c)\n-     rtx op;\n-     int c;\n+s390_extra_constraint (rtx op, int c)\n {\n   struct s390_address addr;\n \n@@ -1361,10 +1311,7 @@ s390_extra_constraint (op, c)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-s390_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -1432,8 +1379,7 @@ s390_rtx_costs (x, code, outer_code, total)\n /* Return the cost of an address rtx ADDR.  */\n \n static int\n-s390_address_cost (addr)\n-     rtx addr;\n+s390_address_cost (rtx addr)\n {\n   struct s390_address ad;\n   if (!s390_decompose_address (addr, &ad))\n@@ -1447,9 +1393,7 @@ s390_address_cost (addr)\n    MODE is the current operation mode.  */\n \n int\n-bras_sym_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+bras_sym_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   register enum rtx_code code = GET_CODE (op);\n \n@@ -1469,8 +1413,7 @@ bras_sym_operand (op, mode)\n    otherwise return 0.  */\n \n int\n-tls_symbolic_operand (op)\n-     register rtx op;\n+tls_symbolic_operand (register rtx op)\n {\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n@@ -1483,9 +1426,7 @@ tls_symbolic_operand (op)\n    MODE is the current operation mode.  */\n \n int\n-load_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   unsigned int dest_regno;\n@@ -1547,9 +1488,7 @@ load_multiple_operation (op, mode)\n    MODE is the current operation mode.  */\n \n int\n-store_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   unsigned int src_regno;\n@@ -1607,8 +1546,7 @@ store_multiple_operation (op, mode)\n /* Return true if OP contains a symbol reference */\n \n int\n-symbolic_reference_mentioned_p (op)\n-     rtx op;\n+symbolic_reference_mentioned_p (rtx op)\n {\n   register const char *fmt;\n   register int i;\n@@ -1638,8 +1576,7 @@ symbolic_reference_mentioned_p (op)\n /* Return true if OP contains a reference to a thread-local symbol.  */\n \n int\n-tls_symbolic_reference_mentioned_p (op)\n-     rtx op;\n+tls_symbolic_reference_mentioned_p (rtx op)\n {\n   register const char *fmt;\n   register int i;\n@@ -1672,8 +1609,7 @@ tls_symbolic_reference_mentioned_p (op)\n    and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n int\n-legitimate_pic_operand_p (op)\n-     register rtx op;\n+legitimate_pic_operand_p (register rtx op)\n {\n   /* Accept all non-symbolic constants.  */\n   if (!SYMBOLIC_CONST (op))\n@@ -1688,8 +1624,7 @@ legitimate_pic_operand_p (op)\n    It is given that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n int\n-legitimate_constant_p (op)\n-     register rtx op;\n+legitimate_constant_p (register rtx op)\n {\n   /* Accept all non-symbolic constants.  */\n   if (!SYMBOLIC_CONST (op))\n@@ -1721,8 +1656,7 @@ legitimate_constant_p (op)\n    not constant (TLS) or not known at final link time (PIC).  */\n \n static bool\n-s390_cannot_force_const_mem (x)\n-     rtx x;\n+s390_cannot_force_const_mem (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1783,8 +1717,7 @@ s390_cannot_force_const_mem (x)\n    before it can be used as operand.  */\n \n int\n-legitimate_reload_constant_p (op)\n-     register rtx op;\n+legitimate_reload_constant_p (register rtx op)\n {\n   /* Accept la(y) operands.  */\n   if (GET_CODE (op) == CONST_INT\n@@ -1814,9 +1747,7 @@ legitimate_reload_constant_p (op)\n    return the class of reg to actually use.  */\n \n enum reg_class\n-s390_preferred_reload_class (op, class)\n-     rtx op;\n-     enum reg_class class;\n+s390_preferred_reload_class (rtx op, enum reg_class class)\n {\n   /* This can happen if a floating point constant is being\n      reloaded into an integer register.  Leave well alone.  */\n@@ -1863,10 +1794,8 @@ s390_preferred_reload_class (op, class)\n    is not a legitimate operand of the LOAD ADDRESS instruction.  */\n \n enum reg_class\n-s390_secondary_input_reload_class (class, mode, in)\n-     enum reg_class class ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-     rtx in;\n+s390_secondary_input_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n+\t\t\t\t   enum machine_mode mode, rtx in)\n {\n   if (s390_plus_operand (in, mode))\n     return ADDR_REGS;\n@@ -1881,10 +1810,8 @@ s390_secondary_input_reload_class (class, mode, in)\n    non-offsettable memory address.  */\n \n enum reg_class\n-s390_secondary_output_reload_class (class, mode, out)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx out;\n+s390_secondary_output_reload_class (enum reg_class class,\n+\t\t\t\t    enum machine_mode mode, rtx out)\n {\n   if ((TARGET_64BIT ? mode == TImode\n                     : (mode == DImode || mode == DFmode))\n@@ -1903,9 +1830,7 @@ s390_secondary_output_reload_class (class, mode, out)\n    MODE is the current operation mode.  */\n \n int\n-s390_plus_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+s390_plus_operand (register rtx op, enum machine_mode mode)\n {\n   if (!check_mode (op, &mode) || mode != Pmode)\n     return FALSE;\n@@ -1924,10 +1849,8 @@ s390_plus_operand (op, mode)\n    SCRATCH may be used as scratch register.  */\n \n void\n-s390_expand_plus_operand (target, src, scratch)\n-     register rtx target;\n-     register rtx src;\n-     register rtx scratch;\n+s390_expand_plus_operand (register rtx target, register rtx src,\n+\t\t\t  register rtx scratch)\n {\n   rtx sum1, sum2;\n   struct s390_address ad;\n@@ -1993,9 +1916,7 @@ s390_expand_plus_operand (target, src, scratch)\n    canonical form so that they will be recognized.  */\n \n static int\n-s390_decompose_address (addr, out)\n-     register rtx addr;\n-     struct s390_address *out;\n+s390_decompose_address (register rtx addr, struct s390_address *out)\n {\n   rtx base = NULL_RTX;\n   rtx indx = NULL_RTX;\n@@ -2232,10 +2153,8 @@ s390_decompose_address (addr, out)\n    STRICT specifies whether strict register checking applies.  */\n \n int\n-legitimate_address_p (mode, addr, strict)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     register rtx addr;\n-     int strict;\n+legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t      register rtx addr, int strict)\n {\n   struct s390_address ad;\n   if (!s390_decompose_address (addr, &ad))\n@@ -2264,8 +2183,7 @@ legitimate_address_p (mode, addr, strict)\n    address, as LA performs only a 31-bit addition.  */\n \n int\n-legitimate_la_operand_p (op)\n-     register rtx op;\n+legitimate_la_operand_p (register rtx op)\n {\n   struct s390_address addr;\n   if (!s390_decompose_address (op, &addr))\n@@ -2281,8 +2199,7 @@ legitimate_la_operand_p (op)\n    and we prefer to use LA over addition to compute it.  */\n \n int\n-preferred_la_operand_p (op)\n-     register rtx op;\n+preferred_la_operand_p (register rtx op)\n {\n   struct s390_address addr;\n   if (!s390_decompose_address (op, &addr))\n@@ -2306,9 +2223,7 @@ preferred_la_operand_p (op)\n    where legitimate_la_operand_p (SRC) returns false.  */\n \n void\n-s390_load_address (dst, src)\n-     rtx dst;\n-     rtx src;\n+s390_load_address (rtx dst, rtx src)\n {\n   if (TARGET_64BIT)\n     emit_move_insn (dst, src);\n@@ -2335,9 +2250,7 @@ s390_load_address (dst, src)\n    reg also appears in the address.  */\n \n rtx\n-legitimize_pic_address (orig, reg)\n-     rtx orig;\n-     rtx reg;\n+legitimize_pic_address (rtx orig, rtx reg)\n {\n   rtx addr = orig;\n   rtx new = orig;\n@@ -2550,7 +2463,7 @@ legitimize_pic_address (orig, reg)\n                   addr = gen_rtx_PLUS (Pmode, addr, op1);\n                   addr = gen_rtx_CONST (Pmode, addr);\n                   addr = force_const_mem (Pmode, addr);\n-        \t  emit_move_insn (temp, addr);\n+\t  emit_move_insn (temp, addr);\n \n                   new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n                   if (reg != 0)\n@@ -2605,7 +2518,7 @@ legitimize_pic_address (orig, reg)\n /* Load the thread pointer into a register.  */\n \n static rtx\n-get_thread_pointer ()\n+get_thread_pointer (void)\n {\n   rtx tp;\n \n@@ -2620,7 +2533,7 @@ get_thread_pointer ()\n \n static GTY(()) rtx s390_tls_symbol;\n rtx\n-s390_tls_get_offset ()\n+s390_tls_get_offset (void)\n {\n   if (!s390_tls_symbol)\n     s390_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_offset\");\n@@ -2632,9 +2545,7 @@ s390_tls_get_offset ()\n    this (thread-local) address.  REG may be used as temporary.  */\n \n static rtx\n-legitimize_tls_address (addr, reg)\n-     rtx addr;\n-     rtx reg;\n+legitimize_tls_address (rtx addr, rtx reg)\n {\n   rtx new, tls_call, temp, base, r2, insn;\n \n@@ -2823,8 +2734,7 @@ legitimize_tls_address (addr, reg)\n /* Emit insns to move operands[1] into operands[0].  */\n \n void\n-emit_symbolic_move (operands)\n-     rtx *operands;\n+emit_symbolic_move (rtx *operands)\n {\n   rtx temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n \n@@ -2848,10 +2758,8 @@ emit_symbolic_move (operands)\n    See comments by legitimize_pic_address for details.  */\n \n rtx\n-legitimize_address (x, oldx, mode)\n-     register rtx x;\n-     register rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+legitimize_address (register rtx x, register rtx oldx ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx constant_term = const0_rtx;\n \n@@ -2933,14 +2841,11 @@ legitimize_address (x, oldx, mode)\n /* Emit code to move LEN bytes from DST to SRC.  */\n \n void\n-s390_expand_movstr (dst, src, len)\n-     rtx dst;\n-     rtx src;\n-     rtx len;\n+s390_expand_movstr (rtx dst, rtx src, rtx len)\n {\n-  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) =\n+  rtx (*gen_short) (rtx, rtx, rtx) =\n     TARGET_64BIT ? gen_movstr_short_64 : gen_movstr_short_31;\n-  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) =\n+  rtx (*gen_long) (rtx, rtx, rtx, rtx) =\n     TARGET_64BIT ? gen_movstr_long_64 : gen_movstr_long_31;\n \n \n@@ -3030,13 +2935,11 @@ s390_expand_movstr (dst, src, len)\n /* Emit code to clear LEN bytes at DST.  */\n \n void\n-s390_expand_clrstr (dst, len)\n-     rtx dst;\n-     rtx len;\n+s390_expand_clrstr (rtx dst, rtx len)\n {\n-  rtx (*gen_short) PARAMS ((rtx, rtx)) =\n+  rtx (*gen_short) (rtx, rtx) =\n     TARGET_64BIT ? gen_clrstr_short_64 : gen_clrstr_short_31;\n-  rtx (*gen_long) PARAMS ((rtx, rtx, rtx)) =\n+  rtx (*gen_long) (rtx, rtx, rtx) =\n     TARGET_64BIT ? gen_clrstr_long_64 : gen_clrstr_long_31;\n \n \n@@ -3122,17 +3025,13 @@ s390_expand_clrstr (dst, len)\n    and return the result in TARGET.  */\n \n void\n-s390_expand_cmpmem (target, op0, op1, len)\n-     rtx target;\n-     rtx op0;\n-     rtx op1;\n-     rtx len;\n+s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n {\n-  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) =\n+  rtx (*gen_short) (rtx, rtx, rtx) =\n     TARGET_64BIT ? gen_cmpmem_short_64 : gen_cmpmem_short_31;\n-  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) =\n+  rtx (*gen_long) (rtx, rtx, rtx, rtx) =\n     TARGET_64BIT ? gen_cmpmem_long_64 : gen_cmpmem_long_31;\n-  rtx (*gen_result) PARAMS ((rtx)) =\n+  rtx (*gen_result) (rtx) =\n     GET_MODE (target) == DImode ? gen_cmpint_di : gen_cmpint_si;\n \n   op0 = protect_from_queue (op0, 0);\n@@ -3244,10 +3143,7 @@ s390_expand_cmpmem (target, op0, op1, len)\n    We need to emit DTP-relative relocations.  */\n \n void\n-s390_output_dwarf_dtprel (file, size, x)\n-     FILE *file;\n-     int size;\n-     rtx x;\n+s390_output_dwarf_dtprel (FILE *file, int size, rtx x)\n {\n   switch (size)\n     {\n@@ -3269,8 +3165,7 @@ s390_output_dwarf_dtprel (file, size, x)\n    and turn them back into a direct symbol reference.  */\n \n static rtx\n-s390_delegitimize_address (orig_x)\n-     rtx orig_x;\n+s390_delegitimize_address (rtx orig_x)\n {\n   rtx x = orig_x, y;\n \n@@ -3306,7 +3201,7 @@ s390_delegitimize_address (orig_x)\n    so that we can print its name in local-dynamic base patterns.  */\n \n static const char *\n-get_some_local_dynamic_name ()\n+get_some_local_dynamic_name (void)\n {\n   rtx insn;\n \n@@ -3322,9 +3217,7 @@ get_some_local_dynamic_name ()\n }\n \n static int\n-get_some_local_dynamic_name_1 (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n+get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *px;\n \n@@ -3348,9 +3241,7 @@ get_some_local_dynamic_name_1 (px, data)\n    stdio stream FILE.  */\n \n void\n-s390_output_symbolic_const (file, x)\n-     FILE *file;\n-     rtx x;\n+s390_output_symbolic_const (FILE *file, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -3388,7 +3279,7 @@ s390_output_symbolic_const (file, x)\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n           fprintf (file, \"-\");\n \t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n- \t  break;\n+\t  break;\n \tcase UNSPEC_GOTENT:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  fprintf (file, \"@GOTENT\");\n@@ -3449,9 +3340,7 @@ s390_output_symbolic_const (file, x)\n    stdio stream FILE.  */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   struct s390_address ad;\n \n@@ -3489,10 +3378,7 @@ print_operand_address (file, addr)\n     'h': print integer X as if it's a signed word.  */\n \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -3629,10 +3515,7 @@ print_operand (file, x, code)\n    handle values smaller than INT_MIN when printed in decimal.  */\n \n static bool\n-s390_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+s390_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (size == 8 && aligned_p\n       && GET_CODE (x) == CONST_INT && INTVAL (x) < INT_MIN)\n@@ -3648,9 +3531,7 @@ s390_assemble_integer (x, size, aligned_p)\n    a memory address in expression X.  */\n \n static int\n-reg_used_in_mem_p (regno, x)\n-     int regno;\n-     rtx x;\n+reg_used_in_mem_p (int regno, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -3689,9 +3570,7 @@ reg_used_in_mem_p (regno, x)\n    used by instruction INSN to address memory.  */\n \n static int\n-addr_generation_dependency_p (dep_rtx, insn)\n-     rtx dep_rtx;\n-     rtx insn;\n+addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n {\n   rtx target, pat;\n \n@@ -3734,9 +3613,7 @@ addr_generation_dependency_p (dep_rtx, insn)\n /* Return 1, if dep_insn sets register used in insn in the agen unit.  */\n \n int\n-s390_agen_dep_p(dep_insn, insn)\n-     rtx dep_insn;\n-     rtx insn;\n+s390_agen_dep_p (rtx dep_insn, rtx insn)\n {\n   rtx dep_rtx = PATTERN (dep_insn);\n   int i;\n@@ -3767,11 +3644,7 @@ s390_agen_dep_p(dep_insn, insn)\n    be used by introducing only a one cycle stall on the pipeline.  */\n \n static int\n-s390_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n+s390_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   rtx dep_rtx;\n   int i;\n@@ -3825,9 +3698,7 @@ s390_adjust_cost (insn, link, dep_insn, cost)\n    in order to use the bypass.  */\n \n static int\n-s390_adjust_priority (insn, priority)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int priority;\n+s390_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n {\n   if (! INSN_P (insn))\n     return priority;\n@@ -3853,7 +3724,7 @@ s390_adjust_priority (insn, priority)\n /* The number of instructions that can be issued per cycle.  */\n \n static int\n-s390_issue_rate ()\n+s390_issue_rate (void)\n {\n   if (s390_tune == PROCESSOR_2084_Z990)\n     return 3;\n@@ -3864,7 +3735,7 @@ s390_issue_rate ()\n    insn scheduler.  */\n \n static int\n-s390_use_dfa_pipeline_interface ()\n+s390_use_dfa_pipeline_interface (void)\n {\n   if (s390_tune == PROCESSOR_2064_Z900\n       || s390_tune == PROCESSOR_2084_Z990)\n@@ -3874,7 +3745,7 @@ s390_use_dfa_pipeline_interface ()\n }\n \n static int\n-s390_first_cycle_multipass_dfa_lookahead ()\n+s390_first_cycle_multipass_dfa_lookahead (void)\n {\n   return s390_use_dfa_pipeline_interface () ? 4 : 0;\n }\n@@ -3883,12 +3754,11 @@ s390_first_cycle_multipass_dfa_lookahead ()\n    Triggers default sort algorithm to better slot instructions.  */\n \n static int\n-s390_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx *ready ATTRIBUTE_UNUSED;\n-     int *pn_ready ATTRIBUTE_UNUSED;\n-     int clock_var ATTRIBUTE_UNUSED;\n+s390_sched_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t     int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t     rtx *ready ATTRIBUTE_UNUSED,\n+\t\t     int *pn_ready ATTRIBUTE_UNUSED,\n+\t\t     int clock_var ATTRIBUTE_UNUSED)\n {\n     return s390_issue_rate();\n }\n@@ -3902,9 +3772,7 @@ s390_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n    done, TEMP_USED is set to true.  */\n \n static int\n-s390_split_branches (temp_reg, temp_used)\n-     rtx temp_reg;\n-     bool *temp_used;\n+s390_split_branches (rtx temp_reg, bool *temp_used)\n {\n   int new_literal = 0;\n   rtx insn, pat, tmp, target;\n@@ -3996,9 +3864,7 @@ s390_split_branches (temp_reg, temp_used)\n    by the caller before calling this routine.  */\n \n static void\n-find_constant_pool_ref (x, ref)\n-     rtx x;\n-     rtx *ref;\n+find_constant_pool_ref (rtx x, rtx *ref)\n {\n   int i, j;\n   const char *fmt;\n@@ -4036,10 +3902,7 @@ find_constant_pool_ref (x, ref)\n    in X by the address ADDR.  Fix up MEMs as required.  */\n \n static void\n-replace_constant_pool_ref (x, ref, addr)\n-     rtx *x;\n-     rtx ref;\n-     rtx addr;\n+replace_constant_pool_ref (rtx *x, rtx ref, rtx addr)\n {\n   int i, j;\n   const char *fmt;\n@@ -4110,8 +3973,7 @@ replace_constant_pool_ref (x, ref, addr)\n    Return its constant pool symbol if found, NULL_RTX otherwise.  */\n \n static rtx\n-find_ltrel_base (x)\n-     rtx x;\n+find_ltrel_base (rtx x)\n {\n   int i, j;\n   const char *fmt;\n@@ -4146,9 +4008,7 @@ find_ltrel_base (x)\n /* Replace any occurrence of UNSPEC_LTREL_BASE in X with BASE.  */\n \n static void\n-replace_ltrel_base (x, base)\n-     rtx *x;\n-     rtx base;\n+replace_ltrel_base (rtx *x, rtx base)\n {\n   int i, j;\n   const char *fmt;\n@@ -4191,11 +4051,7 @@ enum machine_mode constant_modes[NR_C_MODES] =\n \n rtx (*gen_consttable[NR_C_MODES])(rtx) =\n {\n-  gen_consttable_ti,\n-  gen_consttable_df, gen_consttable_di,\n-  gen_consttable_sf, gen_consttable_si,\n-  gen_consttable_hi,\n-  gen_consttable_qi\n+  gen_consttable_ti, gen_consttable_df, gen_consttable_di, gen_consttable_sf, gen_consttable_si, gen_consttable_hi, gen_consttable_qi\n };\n \n struct constant\n@@ -4217,26 +4073,24 @@ struct constant_pool\n   int size;\n };\n \n-static struct constant_pool * s390_chunkify_start PARAMS ((void));\n-static void s390_chunkify_finish PARAMS ((struct constant_pool *));\n-static void s390_chunkify_cancel PARAMS ((struct constant_pool *));\n+static struct constant_pool * s390_chunkify_start (void);\n+static void s390_chunkify_finish (struct constant_pool *);\n+static void s390_chunkify_cancel (struct constant_pool *);\n \n-static struct constant_pool *s390_start_pool PARAMS ((struct constant_pool **, rtx));\n-static void s390_end_pool PARAMS ((struct constant_pool *, rtx));\n-static void s390_add_pool_insn PARAMS ((struct constant_pool *, rtx));\n-static struct constant_pool *s390_find_pool PARAMS ((struct constant_pool *, rtx));\n-static void s390_add_constant PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n-static rtx s390_find_constant PARAMS ((struct constant_pool *, rtx, enum machine_mode));\n-static rtx s390_dump_pool PARAMS ((struct constant_pool *));\n-static void s390_free_pool PARAMS ((struct constant_pool *));\n+static struct constant_pool *s390_start_pool (struct constant_pool **, rtx);\n+static void s390_end_pool (struct constant_pool *, rtx);\n+static void s390_add_pool_insn (struct constant_pool *, rtx);\n+static struct constant_pool *s390_find_pool (struct constant_pool *, rtx);\n+static void s390_add_constant (struct constant_pool *, rtx, enum machine_mode);\n+static rtx s390_find_constant (struct constant_pool *, rtx, enum machine_mode);\n+static rtx s390_dump_pool (struct constant_pool *);\n+static void s390_free_pool (struct constant_pool *);\n \n /* Create new constant pool covering instructions starting at INSN\n    and chain it to the end of POOL_LIST.  */\n \n static struct constant_pool *\n-s390_start_pool (pool_list, insn)\n-     struct constant_pool **pool_list;\n-     rtx insn;\n+s390_start_pool (struct constant_pool **pool_list, rtx insn)\n {\n   struct constant_pool *pool, **prev;\n   int i;\n@@ -4263,9 +4117,7 @@ s390_start_pool (pool_list, insn)\n    placeholder insn representing the pool.  */\n \n static void\n-s390_end_pool (pool, insn)\n-     struct constant_pool *pool;\n-     rtx insn;\n+s390_end_pool (struct constant_pool *pool, rtx insn)\n {\n   rtx pool_size = GEN_INT (pool->size + 8 /* alignment slop */);\n \n@@ -4279,19 +4131,15 @@ s390_end_pool (pool, insn)\n /* Add INSN to the list of insns covered by POOL.  */\n \n static void\n-s390_add_pool_insn (pool, insn)\n-     struct constant_pool *pool;\n-     rtx insn;\n+s390_add_pool_insn (struct constant_pool *pool, rtx insn)\n {\n   bitmap_set_bit (pool->insns, INSN_UID (insn));\n }\n \n /* Return pool out of POOL_LIST that covers INSN.  */\n \n static struct constant_pool *\n-s390_find_pool (pool_list, insn)\n-     struct constant_pool *pool_list;\n-     rtx insn;\n+s390_find_pool (struct constant_pool *pool_list, rtx insn)\n {\n   struct constant_pool *pool;\n \n@@ -4305,10 +4153,7 @@ s390_find_pool (pool_list, insn)\n /* Add constant VAL of mode MODE to the constant pool POOL.  */\n \n static void\n-s390_add_constant (pool, val, mode)\n-     struct constant_pool *pool;\n-     rtx val;\n-     enum machine_mode mode;\n+s390_add_constant (struct constant_pool *pool, rtx val, enum machine_mode mode)\n {\n   struct constant *c;\n   int i;\n@@ -4339,10 +4184,8 @@ s390_add_constant (pool, val, mode)\n    the pool to the location of the new constant.  */\n \n static rtx\n-s390_find_constant (pool, val, mode)\n-     struct constant_pool *pool;\n-     rtx val;\n-     enum machine_mode mode;\n+s390_find_constant (struct constant_pool *pool, rtx val,\n+\t\t    enum machine_mode mode)\n {\n   struct constant *c;\n   rtx offset;\n@@ -4370,8 +4213,7 @@ s390_find_constant (pool, val, mode)\n /* Dump out the constants in POOL.  */\n \n static rtx\n-s390_dump_pool (pool)\n-     struct constant_pool *pool;\n+s390_dump_pool (struct constant_pool *pool)\n {\n   struct constant *c;\n   rtx insn;\n@@ -4401,7 +4243,7 @@ s390_dump_pool (pool)\n \t    && XVECLEN (XEXP (value, 0), 0) == 1)\n \t  {\n \t    value = gen_rtx_MINUS (Pmode, XVECEXP (XEXP (value, 0), 0, 0),\n-\t    \t\t\t   gen_rtx_LABEL_REF (VOIDmode, pool->label));\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, pool->label));\n \t    value = gen_rtx_CONST (VOIDmode, value);\n \t  }\n \n@@ -4431,8 +4273,7 @@ s390_dump_pool (pool)\n /* Free all memory used by POOL.  */\n \n static void\n-s390_free_pool (pool)\n-     struct constant_pool *pool;\n+s390_free_pool (struct constant_pool *pool)\n {\n   int i;\n \n@@ -4468,7 +4309,7 @@ s390_chunkify_start (void)\n   rtx pending_ltrel = NULL_RTX;\n   rtx insn;\n \n-  rtx (*gen_reload_base) PARAMS ((rtx, rtx)) =\n+  rtx (*gen_reload_base) (rtx, rtx) =\n     TARGET_64BIT? gen_reload_base_64 : gen_reload_base_31;\n \n \n@@ -4551,7 +4392,7 @@ s390_chunkify_start (void)\n       else\n \t{\n           int chunk_size = INSN_ADDRESSES (INSN_UID (insn))\n-\t\t \t   - INSN_ADDRESSES (INSN_UID (curr_pool->first_insn))\n+\t\t\t   - INSN_ADDRESSES (INSN_UID (curr_pool->first_insn))\n \t\t\t + extra_size;\n \n \t  /* We will later have to insert base register reload insns.\n@@ -4590,7 +4431,7 @@ s390_chunkify_start (void)\n \t      if (pending_ltrel)\n \t\tcontinue;\n \n- \t      label = gen_label_rtx ();\n+\t      label = gen_label_rtx ();\n \t      jump = emit_jump_insn_after (gen_jump (label), insn);\n \t      barrier = emit_barrier_after (jump);\n \t      insn = emit_label_after (label, barrier);\n@@ -4728,8 +4569,7 @@ s390_chunkify_start (void)\n    all changes to the current function as required.  */\n \n static void\n-s390_chunkify_finish (pool_list)\n-     struct constant_pool *pool_list;\n+s390_chunkify_finish (struct constant_pool *pool_list)\n {\n   rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n   struct constant_pool *curr_pool = NULL;\n@@ -4782,8 +4622,7 @@ s390_chunkify_finish (pool_list)\n    to the current function that were done by s390_chunkify_start.  */\n \n static void\n-s390_chunkify_cancel (pool_list)\n-     struct constant_pool *pool_list;\n+s390_chunkify_cancel (struct constant_pool *pool_list)\n {\n   struct constant_pool *curr_pool = NULL;\n   rtx insn;\n@@ -4849,9 +4688,7 @@ int s390_nr_constants;\n /* Output main constant pool to stdio stream FILE.  */\n \n void\n-s390_output_constant_pool (start_label, end_label)\n-     rtx start_label;\n-     rtx end_label;\n+s390_output_constant_pool (rtx start_label, rtx end_label)\n {\n   if (TARGET_64BIT)\n     {\n@@ -4887,8 +4724,7 @@ s390_output_constant_pool (start_label, end_label)\n    machine dependent reorg.  */\n \n static void\n-s390_optimize_prolog (temp_regno)\n-     int temp_regno;\n+s390_optimize_prolog (int temp_regno)\n {\n   int save_first, save_last, restore_first, restore_last;\n   int i, j;\n@@ -5039,8 +4875,7 @@ s390_optimize_prolog (temp_regno)\n    Return true if any such insn was found.  */\n \n static bool\n-s390_fixup_clobbered_return_reg (return_reg)\n-    rtx return_reg;\n+s390_fixup_clobbered_return_reg (rtx return_reg)\n {\n   bool replacement_done = 0;\n   rtx insn;\n@@ -5092,7 +4927,7 @@ s390_fixup_clobbered_return_reg (return_reg)\n /* Perform machine-dependent processing.  */\n \n static void\n-s390_reorg ()\n+s390_reorg (void)\n {\n   bool fixed_up_clobbered_return_reg = 0;\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n@@ -5182,9 +5017,7 @@ s390_reorg ()\n    frame pointer of that frame.  */\n \n rtx\n-s390_return_addr_rtx (count, frame)\n-     int count;\n-     rtx frame;\n+s390_return_addr_rtx (int count, rtx frame)\n {\n   rtx addr;\n \n@@ -5207,7 +5040,7 @@ s390_return_addr_rtx (count, frame)\n    or for holding the return address before epilogue.  */\n \n static int\n-find_unused_clobbered_reg ()\n+find_unused_clobbered_reg (void)\n {\n   int i;\n   for (i = 0; i < 6; i++)\n@@ -5219,7 +5052,7 @@ find_unused_clobbered_reg ()\n /* Fill FRAME with info about frame of current function.  */\n \n static void\n-s390_frame_info ()\n+s390_frame_info (void)\n {\n   char gprs_ever_live[16];\n   int i, j;\n@@ -5288,7 +5121,7 @@ s390_frame_info ()\n    initially after prologue.  */\n \n int\n-s390_arg_frame_offset ()\n+s390_arg_frame_offset (void)\n {\n   HOST_WIDE_INT fsize = get_frame_size ();\n   int save_fprs_p, i;\n@@ -5319,10 +5152,7 @@ s390_arg_frame_offset ()\n    to register BASE.  Return generated insn.  */\n \n static rtx\n-save_fpr (base, offset, regnum)\n-     rtx base;\n-     int offset;\n-     int regnum;\n+save_fpr (rtx base, int offset, int regnum)\n {\n   rtx addr;\n   addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n@@ -5335,10 +5165,7 @@ save_fpr (base, offset, regnum)\n    to register BASE.  Return generated insn.  */\n \n static rtx\n-restore_fpr (base, offset, regnum)\n-     rtx base;\n-     int offset;\n-     int regnum;\n+restore_fpr (rtx base, int offset, int regnum)\n {\n   rtx addr;\n   addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n@@ -5352,11 +5179,7 @@ restore_fpr (base, offset, regnum)\n    relative to register BASE.  */\n \n static rtx\n-save_gprs (base, offset, first, last)\n-     rtx base;\n-     int offset;\n-     int first;\n-     int last;\n+save_gprs (rtx base, int offset, int first, int last)\n {\n   rtx addr, insn, note;\n   int i;\n@@ -5432,11 +5255,7 @@ save_gprs (base, offset, first, last)\n    relative to register BASE.  */\n \n static rtx\n-restore_gprs (base, offset, first, last)\n-     rtx base;\n-     int offset;\n-     int first;\n-     int last;\n+restore_gprs (rtx base, int offset, int first, int last)\n {\n   rtx addr, insn;\n \n@@ -5466,8 +5285,7 @@ restore_gprs (base, offset, first, last)\n \n static GTY(()) rtx got_symbol;\n void\n-s390_load_got (maybe_dead)\n-     int maybe_dead;\n+s390_load_got (int maybe_dead)\n {\n   if (!got_symbol)\n     {\n@@ -5510,7 +5328,7 @@ s390_load_got (maybe_dead)\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n-s390_emit_prologue ()\n+s390_emit_prologue (void)\n {\n   rtx insn, addr;\n   rtx temp_reg;\n@@ -5546,7 +5364,7 @@ s390_emit_prologue ()\n \n   if (TARGET_64BIT)\n     insn = emit_insn (gen_literal_pool_64 (gen_rtx_REG (Pmode, BASE_REGISTER),\n-                 \t\t\t   pool_start_label, pool_end_label));\n+\t\t\t   pool_start_label, pool_end_label));\n   else\n     insn = emit_insn (gen_literal_pool_31 (gen_rtx_REG (Pmode, BASE_REGISTER),\n \t\t\t\t\t     pool_start_label, pool_end_label));\n@@ -5605,7 +5423,7 @@ s390_emit_prologue ()\n \t{\n \t  insn = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n \t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t      \t    frame_off));\n+\t\t\t\t\t    frame_off));\n \t  insn = emit_insn (insn);\n \t}\n       else\n@@ -5706,7 +5524,7 @@ s390_emit_prologue ()\n /* Expand the epilogue into a bunch of separate insns.  */\n \n void\n-s390_emit_epilogue ()\n+s390_emit_epilogue (void)\n {\n   rtx frame_pointer, return_reg;\n   int area_bottom, area_top, offset = 0;\n@@ -5917,9 +5735,7 @@ s390_emit_epilogue ()\n    MODE must be specified.  */\n \n static int\n-s390_function_arg_size (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+s390_function_arg_size (enum machine_mode mode, tree type)\n {\n   if (type)\n     return int_size_in_bytes (type);\n@@ -5936,9 +5752,7 @@ s390_function_arg_size (mode, type)\n    is to be passed in a floating-point register, if available.  */\n \n static bool\n-s390_function_arg_float (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+s390_function_arg_float (enum machine_mode mode, tree type)\n {\n   /* Soft-float changes the ABI: no floating-point registers are used.  */\n   if (TARGET_SOFT_FLOAT)\n@@ -5981,9 +5795,7 @@ s390_function_arg_float (mode, type)\n    reference.  */\n \n int\n-s390_function_arg_pass_by_reference (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+s390_function_arg_pass_by_reference (enum machine_mode mode, tree type)\n {\n   int size = s390_function_arg_size (mode, type);\n \n@@ -6008,11 +5820,8 @@ s390_function_arg_pass_by_reference (mode, type)\n    matching an ellipsis).  */\n \n void\n-s390_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+s390_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t   tree type, int named ATTRIBUTE_UNUSED)\n {\n   if (s390_function_arg_pass_by_reference (mode, type))\n     {\n@@ -6049,11 +5858,8 @@ s390_function_arg_advance (cum, mode, type, named)\n    are pushed to the stack.  */\n \n rtx\n-s390_function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t\t   int named ATTRIBUTE_UNUSED)\n {\n   if (s390_function_arg_pass_by_reference (mode, type))\n       return 0;\n@@ -6101,7 +5907,7 @@ s390_function_arg (cum, mode, type, named)\n    area if the function uses variable arguments.  */\n \n tree\n-s390_build_va_list ()\n+s390_build_va_list (void)\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n@@ -6151,9 +5957,7 @@ s390_build_va_list ()\n        (relative to the virtual arg pointer).  */\n \n void\n-s390_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n+s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT n_gpr, n_fpr;\n   int off;\n@@ -6233,9 +6037,7 @@ s390_va_start (valist, nextarg)\n    } */\n \n rtx\n-s390_va_arg (valist, type)\n-     tree valist;\n-     tree type;\n+s390_va_arg (tree valist, tree type)\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav;\n   tree gpr, fpr, ovf, sav, reg, t, u;\n@@ -6412,7 +6214,7 @@ static unsigned int const code_for_builtin_31[S390_BUILTIN_max] = {\n };\n \n static void\n-s390_init_builtins ()\n+s390_init_builtins (void)\n {\n   tree ftype;\n \n@@ -6434,12 +6236,9 @@ s390_init_builtins ()\n    IGNORE is nonzero if the value is to be ignored.  */\n \n static rtx\n-s390_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     int ignore ATTRIBUTE_UNUSED)\n {\n #define MAX_ARGS 2\n \n@@ -6526,8 +6325,7 @@ s390_expand_builtin (exp, target, subtarget, mode, ignore)\n    gpr 0 is used to hold the static chain.  */\n \n void\n-s390_trampoline_template (file)\n-     FILE *file;\n+s390_trampoline_template (FILE *file)\n {\n   if (TARGET_64BIT)\n     {\n@@ -6554,10 +6352,7 @@ s390_trampoline_template (file)\n    CXT is an RTX for the static chain value for the function.  */\n \n void\n-s390_initialize_trampoline (addr, fnaddr, cxt)\n-     rtx addr;\n-     rtx fnaddr;\n-     rtx cxt;\n+s390_initialize_trampoline (rtx addr, rtx fnaddr, rtx cxt)\n {\n   emit_move_insn (gen_rtx\n \t\t  (MEM, Pmode,\n@@ -6573,9 +6368,7 @@ s390_initialize_trampoline (addr, fnaddr, cxt)\n    LOW and HIGH, independent of the host word size.  */\n \n rtx\n-s390_gen_rtx_const_DI (high, low)\n-     int high;\n-     int low;\n+s390_gen_rtx_const_DI (int high, int low)\n {\n #if HOST_BITS_PER_WIDE_INT >= 64\n   HOST_WIDE_INT val;\n@@ -6597,9 +6390,7 @@ s390_gen_rtx_const_DI (high, low)\n    for profiling a function entry.  */\n \n void\n-s390_function_profiler (file, labelno)\n-     FILE *file;\n-     int labelno;\n+s390_function_profiler (FILE *file, int labelno)\n {\n   rtx op[7];\n \n@@ -6667,10 +6458,9 @@ s390_function_profiler (file, labelno)\n    constants go in the function section; in 64-bit mode in .rodata.  */\n \n static void\n-s390_select_rtx_section (mode, x, align)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+s390_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t rtx x ATTRIBUTE_UNUSED,\n+\t\t\t unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (TARGET_64BIT)\n     readonly_data_section ();\n@@ -6682,10 +6472,7 @@ s390_select_rtx_section (mode, x, align)\n    into its SYMBOL_REF_FLAGS.  */\n \n static void\n-s390_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+s390_encode_section_info (tree decl, rtx rtl, int first)\n {\n   default_encode_section_info (decl, rtl, first);\n \n@@ -6703,12 +6490,9 @@ s390_encode_section_info (decl, rtl, first)\n    relative to the resulting this pointer.  */\n \n static void\n-s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset;\n-     tree function;\n+s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t      tree function)\n {\n   rtx op[10];\n   int nonlocal = 0;\n@@ -6945,16 +6729,15 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n }\n \n bool\n-s390_valid_pointer_mode (mode)\n-     enum machine_mode mode;\n+s390_valid_pointer_mode (enum machine_mode mode)\n {\n   return (mode == SImode || (TARGET_64BIT && mode == DImode));\n }\n \n /* How to allocate a 'struct machine_function'.  */\n \n static struct machine_function *\n-s390_init_machine_status ()\n+s390_init_machine_status (void)\n {\n   return ggc_alloc_cleared (sizeof (struct machine_function));\n }"}]}