{"sha": "09dd11338ac0ffd6917b2e0d10266c8dc221607b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlkZDExMzM4YWMwZmZkNjkxN2IyZTBkMTAyNjZjOGRjMjIxNjA3Yg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-02T10:23:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-02T10:23:37Z"}, "message": "reload1.c (reload): Break out some more pieces into separate functions.\n\n\t* reload1.c (reload): Break out some more pieces into separate\n\tfunctions.\n\t(dump_needs): New function, broken out of reload.\n\t(set_initial_elim_offsets): Likewise.\n\t(init_elim_table): Likewise.\n\t(update_eliminables): Likewise.\n\nFrom-SVN: r22752", "tree": {"sha": "44e9e33ecd91c8a53ac2bf91c079490dd81504ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44e9e33ecd91c8a53ac2bf91c079490dd81504ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09dd11338ac0ffd6917b2e0d10266c8dc221607b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09dd11338ac0ffd6917b2e0d10266c8dc221607b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09dd11338ac0ffd6917b2e0d10266c8dc221607b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09dd11338ac0ffd6917b2e0d10266c8dc221607b/comments", "author": null, "committer": null, "parents": [{"sha": "34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3"}], "stats": {"total": 394, "additions": 222, "deletions": 172}, "files": [{"sha": "1bdc7e17f35c7e2e9d8239b03f088563de34dd2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09dd11338ac0ffd6917b2e0d10266c8dc221607b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09dd11338ac0ffd6917b2e0d10266c8dc221607b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09dd11338ac0ffd6917b2e0d10266c8dc221607b", "patch": "@@ -1,5 +1,12 @@\n Fri Oct  2 10:51:35 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n \n+\t* reload1.c (reload): Break out some more pieces into separate\n+\tfunctions.\n+\t(dump_needs): New function, broken out of reload.\n+\t(set_initial_elim_offsets): Likewise.\n+\t(init_elim_table): Likewise.\n+\t(update_eliminables): Likewise.\n+\n \t* global.c (global_alloc): Delete code to manage the scratch_list.\n \t* local-alloc.c (qty_scratch_rtx): Delete.\n \t(scratch_block): Delete."}, {"sha": "6b11bb95646987ceddb4a339c5fbbc638c61162b", "filename": "gcc/reload1.c", "status": "modified", "additions": 215, "deletions": 172, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09dd11338ac0ffd6917b2e0d10266c8dc221607b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09dd11338ac0ffd6917b2e0d10266c8dc221607b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=09dd11338ac0ffd6917b2e0d10266c8dc221607b", "patch": "@@ -348,6 +348,7 @@ static int num_labels;\n \n struct hard_reg_n_uses { int regno; int uses; };\n \f\n+static void dump_needs\t\t\tPROTO((FILE *));\n static int calculate_needs_all_insns\tPROTO((rtx, int));\n static int calculate_needs\t\tPROTO((int, rtx, rtx, int));\n static int find_reload_regs\t\tPROTO((int, FILE *));\n@@ -367,6 +368,9 @@ static void alter_reg  \t\t\tPROTO((int, int));\n static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n static int eliminate_regs_in_insn\tPROTO((rtx, int));\n static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n+static void set_initial_elim_offsets\tPROTO((void));\n+static void init_elim_table\t\tPROTO((void));\n+static void update_eliminables\t\tPROTO((HARD_REG_SET *));\n static int spill_hard_reg\t\tPROTO((int, int, FILE *, int));\n static void scan_paradoxical_subregs\tPROTO((rtx));\n static int hard_reg_use_compare\t\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n@@ -749,46 +753,7 @@ reload (first, global, dumpfile)\n \tscan_paradoxical_subregs (PATTERN (insn));\n     }\n \n-  /* Does this function require a frame pointer?  */\n-\n-  frame_pointer_needed = (! flag_omit_frame_pointer\n-#ifdef EXIT_IGNORE_STACK\n-\t\t\t  /* ?? If EXIT_IGNORE_STACK is set, we will not save\n-\t\t\t     and restore sp for alloca.  So we can't eliminate\n-\t\t\t     the frame pointer in that case.  At some point,\n-\t\t\t     we should improve this by emitting the\n-\t\t\t     sp-adjusting insns for this case.  */\n-\t\t\t  || (current_function_calls_alloca\n-\t\t\t      && EXIT_IGNORE_STACK)\n-#endif\n-\t\t\t  || FRAME_POINTER_REQUIRED);\n-\n-  num_eliminable = 0;\n-\n-  /* Initialize the table of registers to eliminate.  The way we do this\n-     depends on how the eliminable registers were defined.  */\n-#ifdef ELIMINABLE_REGS\n-  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-    {\n-      ep->can_eliminate = ep->can_eliminate_previous\n-\t= (CAN_ELIMINATE (ep->from, ep->to)\n-\t   && ! (ep->to == STACK_POINTER_REGNUM && frame_pointer_needed));\n-    }\n-#else\n-  reg_eliminate[0].can_eliminate = reg_eliminate[0].can_eliminate_previous\n-    = ! frame_pointer_needed;\n-#endif\n-\n-  /* Count the number of eliminable registers and build the FROM and TO\n-     REG rtx's.  Note that code in gen_rtx will cause, e.g.,\n-     gen_rtx (REG, Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.\n-     We depend on this.  */\n-  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-    {\n-      num_eliminable += ep->can_eliminate;\n-      ep->from_rtx = gen_rtx_REG (Pmode, ep->from);\n-      ep->to_rtx = gen_rtx_REG (Pmode, ep->to);\n-    }\n+  init_elim_table ();\n \n   num_labels = max_label_num () - get_first_label_num ();\n \n@@ -903,12 +868,7 @@ reload (first, global, dumpfile)\n   something_needs_elimination = 0;\n   while (something_changed)\n     {\n-      rtx x;\n       HOST_WIDE_INT starting_frame_size;\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-      int previous_frame_pointer_needed = frame_pointer_needed;\n-#endif\n-      static char *reg_class_names[] = REG_CLASS_NAMES;\n \n       something_changed = 0;\n       bzero ((char *) max_needs, sizeof max_needs);\n@@ -929,39 +889,8 @@ reload (first, global, dumpfile)\n \n       starting_frame_size = get_frame_size ();\n \n-      /* Reset all offsets on eliminable registers to their initial values.  */\n-#ifdef ELIMINABLE_REGS\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\t{\n-\t  INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->initial_offset);\n-\t  ep->previous_offset = ep->offset\n-\t    = ep->max_offset = ep->initial_offset;\n-\t}\n-#else\n-#ifdef INITIAL_FRAME_POINTER_OFFSET\n-      INITIAL_FRAME_POINTER_OFFSET (reg_eliminate[0].initial_offset);\n-#else\n-      if (!FRAME_POINTER_REQUIRED)\n-\tabort ();\n-      reg_eliminate[0].initial_offset = 0;\n-#endif\n-      reg_eliminate[0].previous_offset = reg_eliminate[0].max_offset\n-\t= reg_eliminate[0].offset = reg_eliminate[0].initial_offset;\n-#endif\n-\n-      num_not_at_initial_offset = 0;\n-\n-      bzero ((char *) &offsets_known_at[get_first_label_num ()], num_labels);\n-\n-      /* Set a known offset for each forced label to be at the initial offset\n-\t of each elimination.  We do this because we assume that all\n-\t computed jumps occur from a location where each elimination is\n-\t at its initial offset.  */\n-\n-      for (x = forced_labels; x; x = XEXP (x, 1))\n-\tif (XEXP (x, 0))\n-\t  set_label_offsets (XEXP (x, 0), NULL_RTX, 1);\n-\n+      set_initial_elim_offsets ();\n+      \n       /* For each pseudo register that has an equivalent location defined,\n \t try to eliminate any eliminable registers (such as the frame pointer)\n \t assuming initial offsets for the replacement register, which\n@@ -1040,25 +969,7 @@ reload (first, global, dumpfile)\n \tsomething_changed = 1;\n \n       if (dumpfile)\n-\tfor (i = 0; i < N_REG_CLASSES; i++)\n-\t  {\n-\t    if (max_needs[i] > 0)\n-\t      fprintf (dumpfile,\n-\t\t\t \";; Need %d reg%s of class %s (for insn %d).\\n\",\n-\t\t       max_needs[i], max_needs[i] == 1 ? \"\" : \"s\",\n-\t\t       reg_class_names[i], INSN_UID (max_needs_insn[i]));\n-\t    if (max_nongroups[i] > 0)\n-\t      fprintf (dumpfile,\n-\t\t       \";; Need %d nongroup reg%s of class %s (for insn %d).\\n\",\n-\t\t       max_nongroups[i], max_nongroups[i] == 1 ? \"\" : \"s\",\n-\t\t       reg_class_names[i], INSN_UID (max_nongroups_insn[i]));\n-\t    if (max_groups[i] > 0)\n-\t      fprintf (dumpfile,\n-\t\t       \";; Need %d group%s (%smode) of class %s (for insn %d).\\n\",\n-\t\t       max_groups[i], max_groups[i] == 1 ? \"\" : \"s\",\n-\t\t       mode_name[(int) group_mode[i]],\n-\t\t       reg_class_names[i], INSN_UID (max_groups_insn[i]));\n-\t  }\n+\tdump_needs (dumpfile);\n \n       /* If we have caller-saves, set up the save areas and see if caller-save\n \t will need a spill register.  */\n@@ -1086,84 +997,17 @@ reload (first, global, dumpfile)\n \t    }\n \t}\n \n-      /* See if anything that happened changes which eliminations are valid.\n-\t For example, on the Sparc, whether or not the frame pointer can\n-\t be eliminated can depend on what registers have been used.  We need\n-\t not check some conditions again (such as flag_omit_frame_pointer)\n-\t since they can't have changed.  */\n-\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif ((ep->from == HARD_FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED)\n-#ifdef ELIMINABLE_REGS\n-\t    || ! CAN_ELIMINATE (ep->from, ep->to)\n-#endif\n-\t    )\n-\t  ep->can_eliminate = 0;\n-\n-      /* Look for the case where we have discovered that we can't replace\n-\t register A with register B and that means that we will now be\n-\t trying to replace register A with register C.  This means we can\n-\t no longer replace register C with register B and we need to disable\n-\t such an elimination, if it exists.  This occurs often with A == ap,\n-\t B == sp, and C == fp.  */\n-\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\t{\n-\t  struct elim_table *op;\n-\t  register int new_to = -1;\n-\n-\t  if (! ep->can_eliminate && ep->can_eliminate_previous)\n-\t    {\n-\t      /* Find the current elimination for ep->from, if there is a\n-\t\t new one.  */\n-\t      for (op = reg_eliminate;\n-\t\t   op < &reg_eliminate[NUM_ELIMINABLE_REGS]; op++)\n-\t\tif (op->from == ep->from && op->can_eliminate)\n-\t\t  {\n-\t\t    new_to = op->to;\n-\t\t    break;\n-\t\t  }\n-\n-\t      /* See if there is an elimination of NEW_TO -> EP->TO.  If so,\n-\t\t disable it.  */\n-\t      for (op = reg_eliminate;\n-\t\t   op < &reg_eliminate[NUM_ELIMINABLE_REGS]; op++)\n-\t\tif (op->from == new_to && op->to == ep->to)\n-\t\t  op->can_eliminate = 0;\n-\t    }\n-\t}\n-\n-      /* See if any registers that we thought we could eliminate the previous\n-\t time are no longer eliminable.  If so, something has changed and we\n-\t must spill the register.  Also, recompute the number of eliminable\n-\t registers and see if the frame pointer is needed; it is if there is\n-\t no elimination of the frame pointer that we can perform.  */\n-\n-      frame_pointer_needed = 1;\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\t{\n-\t  if (ep->can_eliminate && ep->from == FRAME_POINTER_REGNUM\n-\t      && ep->to != HARD_FRAME_POINTER_REGNUM)\n-\t    frame_pointer_needed = 0;\n-\n-\t  if (! ep->can_eliminate && ep->can_eliminate_previous)\n+      {\n+\tHARD_REG_SET to_spill;\n+\tCLEAR_HARD_REG_SET (to_spill);\n+\tupdate_eliminables (&to_spill);\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t  if (TEST_HARD_REG_BIT (to_spill, i))\n \t    {\n-\t      ep->can_eliminate_previous = 0;\n-\t      spill_hard_reg (ep->from, global, dumpfile, 1);\n+\t      spill_hard_reg (i, global, dumpfile, 1);\n \t      something_changed = 1;\n-\t      num_eliminable--;\n \t    }\n-\t}\n-\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-      /* If we didn't need a frame pointer last time, but we do now, spill\n-\t the hard frame pointer.  */\n-      if (frame_pointer_needed && ! previous_frame_pointer_needed)\n-\t{\n-\t  spill_hard_reg (HARD_FRAME_POINTER_REGNUM, global, dumpfile, 1);\n-\t  something_changed = 1;\n-\t}\n-#endif\n+      }\n \n       /* If all needs are met, we win.  */\n \n@@ -2253,6 +2097,33 @@ find_reload_regs (global, dumpfile)\n   return something_changed;\n }\n \n+static void\n+dump_needs (dumpfile)\n+     FILE *dumpfile;\n+{\n+  static char *reg_class_names[] = REG_CLASS_NAMES;\n+  int i;\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      if (max_needs[i] > 0)\n+\tfprintf (dumpfile,\n+\t\t \";; Need %d reg%s of class %s (for insn %d).\\n\",\n+\t\t max_needs[i], max_needs[i] == 1 ? \"\" : \"s\",\n+\t\t reg_class_names[i], INSN_UID (max_needs_insn[i]));\n+      if (max_nongroups[i] > 0)\n+\tfprintf (dumpfile,\n+\t\t \";; Need %d nongroup reg%s of class %s (for insn %d).\\n\",\n+\t\t max_nongroups[i], max_nongroups[i] == 1 ? \"\" : \"s\",\n+\t\t reg_class_names[i], INSN_UID (max_nongroups_insn[i]));\n+      if (max_groups[i] > 0)\n+\tfprintf (dumpfile,\n+\t\t \";; Need %d group%s (%smode) of class %s (for insn %d).\\n\",\n+\t\t max_groups[i], max_groups[i] == 1 ? \"\" : \"s\",\n+\t\t mode_name[(int) group_mode[i]],\n+\t\t reg_class_names[i], INSN_UID (max_groups_insn[i]));\n+    }\n+}\n \f\n /* Nonzero if, after spilling reg REGNO for non-groups,\n    it will still be possible to find a group if we still need one.  */\n@@ -3720,6 +3591,178 @@ mark_not_eliminable (dest, x)\n \tnum_eliminable--;\n       }\n }\n+\n+/* Reset all offsets on eliminable registers to their initial values.  */\n+static void\n+set_initial_elim_offsets ()\n+{\n+  rtx x;\n+\n+#ifdef ELIMINABLE_REGS\n+  struct elim_table *ep;\n+\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->initial_offset);\n+      ep->previous_offset = ep->offset\n+\t= ep->max_offset = ep->initial_offset;\n+    }\n+#else\n+#ifdef INITIAL_FRAME_POINTER_OFFSET\n+  INITIAL_FRAME_POINTER_OFFSET (reg_eliminate[0].initial_offset);\n+#else\n+  if (!FRAME_POINTER_REQUIRED)\n+    abort ();\n+  reg_eliminate[0].initial_offset = 0;\n+#endif\n+  reg_eliminate[0].previous_offset = reg_eliminate[0].max_offset\n+    = reg_eliminate[0].offset = reg_eliminate[0].initial_offset;\n+#endif\n+\n+  num_not_at_initial_offset = 0;\n+\n+  bzero ((char *) &offsets_known_at[get_first_label_num ()], num_labels);\n+\n+  /* Set a known offset for each forced label to be at the initial offset\n+     of each elimination.  We do this because we assume that all\n+     computed jumps occur from a location where each elimination is\n+     at its initial offset.  */\n+\n+  for (x = forced_labels; x; x = XEXP (x, 1))\n+    if (XEXP (x, 0))\n+      set_label_offsets (XEXP (x, 0), NULL_RTX, 1);\n+}\n+\n+/* See if anything that happened changes which eliminations are valid.\n+   For example, on the Sparc, whether or not the frame pointer can\n+   be eliminated can depend on what registers have been used.  We need\n+   not check some conditions again (such as flag_omit_frame_pointer)\n+   since they can't have changed.  */\n+\n+static void\n+update_eliminables (pset)\n+     HARD_REG_SET *pset;\n+{\n+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n+  int previous_frame_pointer_needed = frame_pointer_needed;\n+#endif\n+  struct elim_table *ep;\n+\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    if ((ep->from == HARD_FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED)\n+#ifdef ELIMINABLE_REGS\n+\t|| ! CAN_ELIMINATE (ep->from, ep->to)\n+#endif\n+\t)\n+      ep->can_eliminate = 0;\n+\n+  /* Look for the case where we have discovered that we can't replace\n+     register A with register B and that means that we will now be\n+     trying to replace register A with register C.  This means we can\n+     no longer replace register C with register B and we need to disable\n+     such an elimination, if it exists.  This occurs often with A == ap,\n+     B == sp, and C == fp.  */\n+\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      struct elim_table *op;\n+      register int new_to = -1;\n+\n+      if (! ep->can_eliminate && ep->can_eliminate_previous)\n+\t{\n+\t  /* Find the current elimination for ep->from, if there is a\n+\t     new one.  */\n+\t  for (op = reg_eliminate;\n+\t       op < &reg_eliminate[NUM_ELIMINABLE_REGS]; op++)\n+\t    if (op->from == ep->from && op->can_eliminate)\n+\t      {\n+\t\tnew_to = op->to;\n+\t\tbreak;\n+\t      }\n+\n+\t  /* See if there is an elimination of NEW_TO -> EP->TO.  If so,\n+\t     disable it.  */\n+\t  for (op = reg_eliminate;\n+\t       op < &reg_eliminate[NUM_ELIMINABLE_REGS]; op++)\n+\t    if (op->from == new_to && op->to == ep->to)\n+\t      op->can_eliminate = 0;\n+\t}\n+    }\n+\n+  /* See if any registers that we thought we could eliminate the previous\n+     time are no longer eliminable.  If so, something has changed and we\n+     must spill the register.  Also, recompute the number of eliminable\n+     registers and see if the frame pointer is needed; it is if there is\n+     no elimination of the frame pointer that we can perform.  */\n+\n+  frame_pointer_needed = 1;\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      if (ep->can_eliminate && ep->from == FRAME_POINTER_REGNUM\n+\t  && ep->to != HARD_FRAME_POINTER_REGNUM)\n+\tframe_pointer_needed = 0;\n+\n+      if (! ep->can_eliminate && ep->can_eliminate_previous)\n+\t{\n+\t  ep->can_eliminate_previous = 0;\n+\t  SET_HARD_REG_BIT (*pset, ep->from);\n+\t  num_eliminable--;\n+\t}\n+    }\n+\n+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n+  /* If we didn't need a frame pointer last time, but we do now, spill\n+     the hard frame pointer.  */\n+  if (frame_pointer_needed && ! previous_frame_pointer_needed)\n+    SET_HARD_REG_BIT (*pset, HARD_FRAME_POINTER_REGNUM);\n+#endif\n+}\n+\n+/* Initialize the table of registers to eliminate.  */\n+static void\n+init_elim_table ()\n+{\n+  struct elim_table *ep;\n+\n+  /* Does this function require a frame pointer?  */\n+\n+  frame_pointer_needed = (! flag_omit_frame_pointer\n+#ifdef EXIT_IGNORE_STACK\n+\t\t\t  /* ?? If EXIT_IGNORE_STACK is set, we will not save\n+\t\t\t     and restore sp for alloca.  So we can't eliminate\n+\t\t\t     the frame pointer in that case.  At some point,\n+\t\t\t     we should improve this by emitting the\n+\t\t\t     sp-adjusting insns for this case.  */\n+\t\t\t  || (current_function_calls_alloca\n+\t\t\t      && EXIT_IGNORE_STACK)\n+#endif\n+\t\t\t  || FRAME_POINTER_REQUIRED);\n+\n+  num_eliminable = 0;\n+\n+#ifdef ELIMINABLE_REGS\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      ep->can_eliminate = ep->can_eliminate_previous\n+\t= (CAN_ELIMINATE (ep->from, ep->to)\n+\t   && ! (ep->to == STACK_POINTER_REGNUM && frame_pointer_needed));\n+    }\n+#else\n+  reg_eliminate[0].can_eliminate = reg_eliminate[0].can_eliminate_previous\n+    = ! frame_pointer_needed;\n+#endif\n+\n+  /* Count the number of eliminable registers and build the FROM and TO\n+     REG rtx's.  Note that code in gen_rtx will cause, e.g.,\n+     gen_rtx (REG, Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.\n+     We depend on this.  */\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      num_eliminable += ep->can_eliminate;\n+      ep->from_rtx = gen_rtx_REG (Pmode, ep->from);\n+      ep->to_rtx = gen_rtx_REG (Pmode, ep->to);\n+    }\n+}\n \f\n /* Kick all pseudos out of hard register REGNO.\n    If GLOBAL is nonzero, try to find someplace else to put them."}]}