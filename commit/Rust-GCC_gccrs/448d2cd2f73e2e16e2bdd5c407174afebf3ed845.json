{"sha": "448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ4ZDJjZDJmNzNlMmUxNmUyYmRkNWM0MDcxNzRhZmViZjNlZDg0NQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-10-03T11:37:44Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-10-03T11:37:44Z"}, "message": "re PR fortran/33198 (Derived type in common: Default initializer not rejected)\n\nPR fortran/33198\nfortran/\n* resolve.c (has_default_initializer): Move to top.  Make bool.\n(resolve_common_blocks): Simplify logic.  Add case for derived\ntype initialization.\n(resolve_fl_variable_derived): Split out from ...\n(resolve_fl_variable): ... from here, while adapting to new h_d_i\ninterface.\ntestsuite/\n* gfortran.dg/common_errors_1.f90: New.\n\nFrom-SVN: r128980", "tree": {"sha": "198c2f8ce81370dbdbfc2a4c7df24b6dddcf0131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/198c2f8ce81370dbdbfc2a4c7df24b6dddcf0131"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a24549d472e2235a6042b96e08a1278d4856fabd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a24549d472e2235a6042b96e08a1278d4856fabd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a24549d472e2235a6042b96e08a1278d4856fabd"}], "stats": {"total": 230, "additions": 148, "deletions": 82}, "files": [{"sha": "98f1f24d07b629a8f07ab8df410053a47fb5f6d2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "patch": "@@ -1,3 +1,13 @@\n+2007-09-28  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/33198\n+\t* resolve.c (has_default_initializer): Move to top.  Make bool.\n+\t(resolve_common_blocks): Simplify logic.  Add case for derived\n+\ttype initialization.\n+\t(resolve_fl_variable_derived): Split out from ...\n+\t(resolve_fl_variable): ... here, while adapting to new h_d_i\n+\tinterface.\n+\n 2007-10-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/26682"}, {"sha": "82b50a35a76eb2c2d2cffaa059b78c83a9ec8b34", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 95, "deletions": 82, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "patch": "@@ -602,6 +602,22 @@ resolve_entries (gfc_namespace *ns)\n }\n \n \n+static bool\n+has_default_initializer (gfc_symbol *der)\n+{\n+  gfc_component *c;\n+\n+  gcc_assert (der->attr.flavor == FL_DERIVED);\n+  for (c = der->components; c; c = c->next)\n+    if ((c->ts.type != BT_DERIVED && c->initializer)\n+\t|| (c->ts.type == BT_DERIVED\n+\t    && (!c->pointer && has_default_initializer (c->ts.derived))))\n+      break;\n+\n+  return c != NULL;\n+}\n+\n+\n /* Resolve common blocks.  */\n static void\n resolve_common_blocks (gfc_symtree *common_root)\n@@ -618,23 +634,22 @@ resolve_common_blocks (gfc_symtree *common_root)\n \n   for (csym = common_root->n.common->head; csym; csym = csym->common_next)\n     {\n-      if (csym->ts.type == BT_DERIVED\n-\t  && !(csym->ts.derived->attr.sequence\n-\t       || csym->ts.derived->attr.is_bind_c))\n-\t{\n-\t    gfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n-\t\t\t   \"has neither the SEQUENCE nor the BIND(C) \"\n-\t\t\t   \"attribute\", csym->name,\n-\t\t\t   &csym->declared_at);\n-\t}\n-      else if (csym->ts.type == BT_DERIVED\n-\t       && csym->ts.derived->attr.alloc_comp)\n-\t{\n-\t    gfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n-\t\t\t   \"has an ultimate component that is \"\n-\t\t\t   \"allocatable\", csym->name,\n-\t\t\t   &csym->declared_at);\n-\t}\n+      if (csym->ts.type != BT_DERIVED)\n+\tcontinue;\n+\n+      if (!(csym->ts.derived->attr.sequence\n+\t    || csym->ts.derived->attr.is_bind_c))\n+\tgfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n+\t\t       \"has neither the SEQUENCE nor the BIND(C) \"\n+\t\t       \"attribute\", csym->name, &csym->declared_at);\n+      if (csym->ts.derived->attr.alloc_comp)\n+\tgfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n+\t\t       \"has an ultimate component that is \"\n+\t\t       \"allocatable\", csym->name, &csym->declared_at);\n+      if (has_default_initializer (csym->ts.derived))\n+\tgfc_error_now (\"Derived type variable '%s' in COMMON at %L \"\n+\t\t       \"may not have default initializer\", csym->name,\n+\t\t       &csym->declared_at);\n     }\n \n   gfc_find_symbol (common_root->name, gfc_current_ns, 0, &sym);\n@@ -5913,21 +5928,6 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n }\n \n \n-static gfc_component *\n-has_default_initializer (gfc_symbol *der)\n-{\n-  gfc_component *c;\n-  for (c = der->components; c; c = c->next)\n-    if ((c->ts.type != BT_DERIVED && c->initializer)\n-        || (c->ts.type == BT_DERIVED\n-              && !c->pointer\n-              && has_default_initializer (c->ts.derived)))\n-      break;\n-\n-  return c;\n-}\n-\n-\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -6883,6 +6883,66 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n }\n \n \n+/* Additional checks for symbols with flavor variable and derived\n+   type.  To be called from resolve_fl_variable.  */\n+\n+static try\n+resolve_fl_variable_derived (gfc_symbol *sym, int flag)\n+{\n+  gcc_assert (sym->ts.type == BT_DERIVED);\n+\n+  /* Check to see if a derived type is blocked from being host\n+     associated by the presence of another class I symbol in the same\n+     namespace.  14.6.1.3 of the standard and the discussion on\n+     comp.lang.fortran.  */\n+  if (sym->ns != sym->ts.derived->ns\n+      && sym->ns->proc_name->attr.if_source != IFSRC_IFBODY)\n+    {\n+      gfc_symbol *s;\n+      gfc_find_symbol (sym->ts.derived->name, sym->ns, 0, &s);\n+      if (s && (s->attr.flavor != FL_DERIVED\n+\t\t|| !gfc_compare_derived_types (s, sym->ts.derived)))\n+\t{\n+\t  gfc_error (\"The type '%s' cannot be host associated at %L \"\n+\t\t     \"because it is blocked by an incompatible object \"\n+\t\t     \"of the same name declared at %L\",\n+\t\t     sym->ts.derived->name, &sym->declared_at,\n+\t\t     &s->declared_at);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* 4th constraint in section 11.3: \"If an object of a type for which\n+     component-initialization is specified (R429) appears in the\n+     specification-part of a module and does not have the ALLOCATABLE\n+     or POINTER attribute, the object shall have the SAVE attribute.\"\n+\n+     The check for initializers is performed with\n+     has_default_initializer because gfc_default_initializer generates\n+     a hidden default for allocatable components.  */\n+  if (!(sym->value || flag) && sym->ns->proc_name\n+      && sym->ns->proc_name->attr.flavor == FL_MODULE\n+      && !sym->ns->save_all && !sym->attr.save\n+      && !sym->attr.pointer && !sym->attr.allocatable\n+      && has_default_initializer (sym->ts.derived))\n+    {\n+      gfc_error(\"Object '%s' at %L must have the SAVE attribute for \"\n+\t\t\"default initialization of a component\",\n+\t\tsym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n+  /* Assign default initializer.  */\n+  if (!(sym->value || sym->attr.pointer || sym->attr.allocatable)\n+      && (!flag || sym->attr.intent == INTENT_OUT))\n+    {\n+      sym->value = gfc_default_initializer (&sym->ts);\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve symbols with flavor variable.  */\n \n static try\n@@ -6891,7 +6951,6 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   int flag;\n   int i;\n   gfc_expr *e;\n-  gfc_component *c;\n   const char *auto_save_msg;\n \n   auto_save_msg = \"automatic object '%s' at %L cannot have the \"\n@@ -6985,7 +7044,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t  gfc_error (auto_save_msg, sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n-  }\n+    }\n \n   /* Reject illegal initializers.  */\n   if (!sym->mark && sym->value && flag)\n@@ -7015,54 +7074,8 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     }\n \n no_init_error:\n-  /* Check to see if a derived type is blocked from being host associated\n-     by the presence of another class I symbol in the same namespace.\n-     14.6.1.3 of the standard and the discussion on comp.lang.fortran.  */\n-  if (sym->ts.type == BT_DERIVED && sym->ns != sym->ts.derived->ns\n-\t&& sym->ns->proc_name->attr.if_source != IFSRC_IFBODY)\n-    {\n-      gfc_symbol *s;\n-      gfc_find_symbol (sym->ts.derived->name, sym->ns, 0, &s);\n-      if (s && (s->attr.flavor != FL_DERIVED\n-\t\t|| !gfc_compare_derived_types (s, sym->ts.derived)))\n-\t{\n-\t  gfc_error (\"The type %s cannot be host associated at %L because \"\n-\t\t     \"it is blocked by an incompatible object of the same \"\n-\t\t     \"name at %L\", sym->ts.derived->name, &sym->declared_at,\n-\t\t     &s->declared_at);\n-\t  return FAILURE;\n-\t}\n-    }\n-\n-  /* Do not use gfc_default_initializer to test for a default initializer\n-     in the fortran because it generates a hidden default for allocatable\n-     components.  */\n-  c = NULL;\n-  if (sym->ts.type == BT_DERIVED && !(sym->value || flag))\n-    c = has_default_initializer (sym->ts.derived);\n-\n-  /* 4th constraint in section 11.3:  \"If an object of a type for which\n-     component-initialization is specified (R429) appears in the\n-     specification-part of a module and does not have the ALLOCATABLE\n-     or POINTER attribute, the object shall have the SAVE attribute.\"  */\n-  if (c && sym->ns->proc_name\n-      && sym->ns->proc_name->attr.flavor == FL_MODULE\n-      && !sym->ns->save_all && !sym->attr.save\n-      && !sym->attr.pointer && !sym->attr.allocatable)\n-    {\n-      gfc_error(\"Object '%s' at %L must have the SAVE attribute %s\",\n- \t \tsym->name, &sym->declared_at,\n-\t\t\"for default initialization of a component\");\n-      return FAILURE;\n-    }\n-\n-  /* Assign default initializer.  */\n-  if (sym->ts.type == BT_DERIVED\n-      && !sym->value\n-      && !sym->attr.pointer\n-      && !sym->attr.allocatable\n-      && (!flag || sym->attr.intent == INTENT_OUT))\n-    sym->value = gfc_default_initializer (&sym->ts);\n+  if (sym->ts.type == BT_DERIVED)\n+    return resolve_fl_variable_derived (sym, flag);\n \n   return SUCCESS;\n }"}, {"sha": "be26f5c2525d1cf1631e8bc29c2c98734ad56aaf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "patch": "@@ -1,3 +1,8 @@\n+2007-09-28  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/33198\n+\t* gfortran.dg/common_errors_1.f90: New.\n+\n 2007-10-03  Doug Kwan  <dougkwan@google.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "0d4e1beb3bf4c70b89616cb433697b22fbe264a7", "filename": "gcc/testsuite/gfortran.dg/common_errors_1.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_errors_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448d2cd2f73e2e16e2bdd5c407174afebf3ed845/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_errors_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_errors_1.f90?ref=448d2cd2f73e2e16e2bdd5c407174afebf3ed845", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! Tests a number of error messages relating to derived type objects\n+! in common blocks.  Originally due to PR 33198\n+\n+subroutine one\n+type a\n+   sequence\n+   integer :: i = 1\n+end type a\n+type(a) :: t ! { dg-error \"Derived type variable .t. in COMMON at ... may not have default initializer\" }\n+common /c/ t\n+end\n+\n+subroutine first\n+type a\n+   integer :: i\n+   integer :: j\n+end type a\n+type(a) :: t  ! { dg-error \"Derived type variable .t. in COMMON at ... has neither the SEQUENCE nor the BIND.C. attribute\" }\n+common /c/ t\n+end\n+\n+subroutine prime\n+type a\n+   sequence\n+   integer, allocatable :: i(:)\n+   integer :: j\n+end type a\n+type(a) :: t  ! { dg-error \"Derived type variable .t. in COMMON at ... has an ultimate component that is allocatable\" }\n+common /c/ t\n+end\n+\n+subroutine source\n+parameter(x=0.) ! { dg-error \"COMMON block .x. at ... is used as PARAMETER at ...\" }\n+common /x/ i  ! { dg-error \"COMMON block .x. at ... is used as PARAMETER at ...\" }\n+intrinsic sin\n+common /sin/ j ! { dg-error \"COMMON block .sin. at ... is also an intrinsic procedure\" }\n+end subroutine source"}]}