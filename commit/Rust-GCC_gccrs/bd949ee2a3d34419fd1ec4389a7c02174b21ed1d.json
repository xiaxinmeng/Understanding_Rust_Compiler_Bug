{"sha": "bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5NDllZTJhM2QzNDQxOWZkMWVjNDM4OWE3YzAyMTc0YjIxZWQxZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-08-01T10:39:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-01T10:39:44Z"}, "message": "freeze.adb (Freeze_Entity): Don't call Check_Aspect_At_Freeze_Point here.\n\n2011-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Don't call Check_Aspect_At_Freeze_Point\n\there.\n\t(Freeze_All_Ent): Fix error in handling inherited aspects.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Skip aspect that is\n\talready analyzed, but don't skip entire processing of a declaration,\n\tthat's wrong in some cases of declarations being rewritten.\n\t(Analyze_Aspect_Specification): Set Is_Delayed_Aspect in aspects.\n\tDon't delay for integer, string literals\n\tTreat predicates in usual manner for delay, remove special case code,\n\tnot needed.\n\t(Analyze_Freeze_Entity): Make call to Check_Aspect_At_Freeze_Point\n\t(Build_Predicate_Function): Update saved expression in aspect\n\t(Build_Invariant_Procedure): Update saved expression in aspect\n\t* exp_ch4.adb (Expand_N_Selected_Component): Only do the optimization\n\tof replacement of discriminant references if the reference is simple.\n\nFrom-SVN: r177010", "tree": {"sha": "49aaa8dd4a3df803441316b3df4c9b9c806e68a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49aaa8dd4a3df803441316b3df4c9b9c806e68a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/comments", "author": null, "committer": null, "parents": [{"sha": "f1c952af5e5c09676e9e26a88b78c7138e60d3f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c952af5e5c09676e9e26a88b78c7138e60d3f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c952af5e5c09676e9e26a88b78c7138e60d3f4"}], "stats": {"total": 179, "additions": 146, "deletions": 33}, "files": [{"sha": "b8b9fbc3e2d49d9a9065a8aa0d08c42cc4594d49", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "patch": "@@ -1,3 +1,21 @@\n+2011-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Don't call Check_Aspect_At_Freeze_Point\n+\there.\n+\t(Freeze_All_Ent): Fix error in handling inherited aspects.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Skip aspect that is\n+\talready analyzed, but don't skip entire processing of a declaration,\n+\tthat's wrong in some cases of declarations being rewritten.\n+\t(Analyze_Aspect_Specification): Set Is_Delayed_Aspect in aspects.\n+\tDon't delay for integer, string literals\n+\tTreat predicates in usual manner for delay, remove special case code,\n+\tnot needed.\n+\t(Analyze_Freeze_Entity): Make call to Check_Aspect_At_Freeze_Point\n+\t(Build_Predicate_Function): Update saved expression in aspect\n+\t(Build_Invariant_Procedure): Update saved expression in aspect\n+\t* exp_ch4.adb (Expand_N_Selected_Component): Only do the optimization\n+\tof replacement of discriminant references if the reference is simple.\n+\n 2011-08-01  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads, aspects.adb: Add Static_Predicate and Dynamic_Predicate."}, {"sha": "480422b363845eba7e8404c52cd040dd6dc48ea7", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "patch": "@@ -7688,10 +7688,17 @@ package body Exp_Ch4 is\n                Discr_Loop : while Present (Dcon) loop\n                   Dval := Node (Dcon);\n \n-                  --  Check if this is the matching discriminant\n-\n-                  if Disc = Entity (Selector_Name (N)) then\n-\n+                  --  Check if this is the matching discriminant and if the\n+                  --  discriminant value is simple enough to make sense to\n+                  --  copy. We don't want to copy complex expressions, and\n+                  --  indeed to do so can cause trouble (before we put in\n+                  --  this guard, a discriminant expression containing an\n+                  --  AND THEN was copied, cause coverage problems\n+\n+                  if Disc = Entity (Selector_Name (N))\n+                    and then (Is_Entity_Name (Dval)\n+                               or else Is_Static_Expression (Dval))\n+                  then\n                      --  Here we have the matching discriminant. Check for\n                      --  the case of a discriminant of a component that is\n                      --  constrained by an outer discriminant, which cannot"}, {"sha": "56fd5c52d02d267194b52192d282b2a289ac467b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "patch": "@@ -1336,6 +1336,7 @@ package body Freeze is\n                   Ritem := First_Rep_Item (E);\n                   while Present (Ritem) loop\n                      if Nkind (Ritem) = N_Aspect_Specification\n+                       and then Entity (Ritem) = E\n                        and then Is_Delayed_Aspect (Ritem)\n                      then\n                         Check_Aspect_At_End_Of_Declarations (Ritem);\n@@ -2444,10 +2445,6 @@ package body Freeze is\n                   --  Analyze the pragma after possibly setting Aspect_Cancel\n \n                   Analyze (Aitem);\n-\n-                  --  Do visibility analysis for aspect at freeze point\n-\n-                  Check_Aspect_At_Freeze_Point (Ritem);\n                end if;\n \n                Next_Rep_Item (Ritem);"}, {"sha": "b50bbde602514044196a8f8e5d089c0955088407", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 116, "deletions": 25, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd949ee2a3d34419fd1ec4389a7c02174b21ed1d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=bd949ee2a3d34419fd1ec4389a7c02174b21ed1d", "patch": "@@ -721,13 +721,6 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n-      --  Return if already analyzed (avoids duplicate calls in some cases\n-      --  where type declarations get rewritten and processed twice).\n-\n-      if Analyzed (N) then\n-         return;\n-      end if;\n-\n       --  Loop through aspects\n \n       Aspect := First (L);\n@@ -744,6 +737,13 @@ package body Sem_Ch13 is\n             --  Source location of expression, modified when we split PPC's\n \n          begin\n+            --  Skip aspect if already analyzed (not clear if this is needed)\n+\n+            if Analyzed (Aspect) then\n+               goto Continue;\n+            end if;\n+\n+            Set_Analyzed (Aspect);\n             Set_Entity (Aspect, E);\n             Ent := New_Occurrence_Of (E, Sloc (Id));\n \n@@ -870,10 +870,16 @@ package body Sem_Ch13 is\n                       Chars      => Chars (Id),\n                       Expression => Relocate_Node (Expr));\n \n-                  --  Here a delay is required\n+                  --  A delay is required except in the common case where\n+                  --  the expression is a literal, in which case it is fine\n+                  --  to take care of it right away.\n \n-                  Delay_Required := True;\n-                  Set_Is_Delayed_Aspect (Aspect);\n+                  if Nkind_In (Expr, N_Integer_Literal, N_String_Literal) then\n+                     Delay_Required := False;\n+                  else\n+                     Delay_Required := True;\n+                     Set_Is_Delayed_Aspect (Aspect);\n+                  end if;\n \n                --  Aspects corresponding to pragmas with two arguments, where\n                --  the first argument is a local name referring to the entity,\n@@ -1050,9 +1056,7 @@ package body Sem_Ch13 is\n \n                --  Predicate aspects generate a corresponding pragma with a\n                --  first argument that is the entity, and the second argument\n-               --  is the expression. This is inserted immediately after the\n-               --  declaration, to get the required pragma placement. The\n-               --  pragma processing takes care of the required delay.\n+               --  is the expression.\n \n                when Aspect_Dynamic_Predicate |\n                     Aspect_Predicate         |\n@@ -1083,15 +1087,10 @@ package body Sem_Ch13 is\n                   --  missing in cases like subtype X is Y, and we would not\n                   --  have a place to build the predicate function).\n \n+                  Set_Has_Predicates (E);\n                   Ensure_Freeze_Node (E);\n                   Set_Is_Delayed_Aspect (Aspect);\n-\n-                  --  For Predicate case, insert immediately after the entity\n-                  --  declaration. We do not have to worry about delay issues\n-                  --  since the pragma processing takes care of this.\n-\n-                  Insert_After (N, Aitem);\n-                  goto Continue;\n+                  Delay_Required := True;\n             end case;\n \n             Set_From_Aspect_Specification (Aitem, True);\n@@ -3045,6 +3044,33 @@ package body Sem_Ch13 is\n       if Is_Type (E) and then Has_Predicates (E) then\n          Build_Predicate_Function (E, N);\n       end if;\n+\n+      --  If type has delayed aspects, this is where we do the preanalysis\n+      --  at the freeze point, as part of the consistent visibility check.\n+      --  Note that this must be done after calling Build_Predicate_Function,\n+      --  since that call marks occurrences of the subtype name in the saved\n+      --  expression so that they will not cause trouble in the preanalysis.\n+\n+      if Has_Delayed_Aspects (E) then\n+         declare\n+            Ritem : Node_Id;\n+\n+         begin\n+            --  Look for aspect specification entries for this entity\n+\n+            Ritem := First_Rep_Item (E);\n+            while Present (Ritem) loop\n+               if Nkind (Ritem) = N_Aspect_Specification\n+                 and then Entity (Ritem) = E\n+                 and then Is_Delayed_Aspect (Ritem)\n+               then\n+                  Check_Aspect_At_Freeze_Point (Ritem);\n+               end if;\n+\n+               Next_Rep_Item (Ritem);\n+            end loop;\n+         end;\n+      end if;\n    end Analyze_Freeze_Entity;\n \n    ------------------------------------------\n@@ -3619,6 +3645,35 @@ package body Sem_Ch13 is\n \n                Replace_Type_References (Exp, Chars (T));\n \n+               --  If this invariant comes from an aspect, find the aspect\n+               --  specification, and replace the saved expression because\n+               --  we need the subtype references replaced for the calls to\n+               --  Preanalyze_Spec_Expressin in Check_Aspect_At_Freeze_Point\n+               --  and Check_Aspect_At_End_Of_Declarations.\n+\n+               if From_Aspect_Specification (Ritem) then\n+                  declare\n+                     Aitem : Node_Id;\n+\n+                  begin\n+                     --  Loop to find corresponding aspect, note that this\n+                     --  must be present given the pragma is marked delayed.\n+\n+                     Aitem := Next_Rep_Item (Ritem);\n+                     while Present (Aitem) loop\n+                        if Nkind (Aitem) = N_Aspect_Specification\n+                          and then Aspect_Rep_Item (Aitem) = Ritem\n+                        then\n+                           Set_Entity\n+                             (Identifier (Aitem), New_Copy_Tree (Exp));\n+                           exit;\n+                        end if;\n+\n+                        Aitem := Next_Rep_Item (Aitem);\n+                     end loop;\n+                  end;\n+               end if;\n+\n                --  Now we need to preanalyze the expression to properly capture\n                --  the visibility in the visible part. The expression will not\n                --  be analyzed for real until the body is analyzed, but that is\n@@ -3829,6 +3884,10 @@ package body Sem_Ch13 is\n       Object_Name : constant Name_Id := New_Internal_Name ('I');\n       --  Name for argument of Predicate procedure\n \n+      Object_Entity : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc, Object_Name);\n+      --  The entity for the spec entity for the argument\n+\n       Dynamic_Predicate_Present : Boolean := False;\n       --  Set True if a dynamic predicate is present, results in the entire\n       --  predicate being considered dynamic even if it looks static\n@@ -3911,6 +3970,8 @@ package body Sem_Ch13 is\n          procedure Replace_Type_Reference (N : Node_Id) is\n          begin\n             Rewrite (N, Make_Identifier (Loc, Object_Name));\n+            Set_Entity (N, Object_Entity);\n+            Set_Etype (N, Typ);\n          end Replace_Type_Reference;\n \n       --  Start of processing for Add_Predicates\n@@ -3927,6 +3988,8 @@ package body Sem_Ch13 is\n                   Static_Predicate_Present := Ritem;\n                end if;\n \n+               --  Acquire arguments\n+\n                Arg1 := First (Pragma_Argument_Associations (Ritem));\n                Arg2 := Next (Arg1);\n \n@@ -3939,12 +4002,41 @@ package body Sem_Ch13 is\n \n                   --  We have a match, this entry is for our subtype\n \n-                  --  First We need to replace any occurrences of the name of\n-                  --  the type with references to the object.\n+                  --  We need to replace any occurrences of the name of the\n+                  --  type with references to the object.\n \n                   Replace_Type_References (Arg2, Chars (Typ));\n \n-                  --  OK, replacement complete, now we can add the expression\n+                  --  If this predicate comes from an aspect, find the aspect\n+                  --  specification, and replace the saved expression because\n+                  --  we need the subtype references replaced for the calls to\n+                  --  Preanalyze_Spec_Expressin in Check_Aspect_At_Freeze_Point\n+                  --  and Check_Aspect_At_End_Of_Declarations.\n+\n+                  if From_Aspect_Specification (Ritem) then\n+                     declare\n+                        Aitem : Node_Id;\n+\n+                     begin\n+                        --  Loop to find corresponding aspect, note that this\n+                        --  must be present given the pragma is marked delayed.\n+\n+                        Aitem := Next_Rep_Item (Ritem);\n+                        loop\n+                           if Nkind (Aitem) = N_Aspect_Specification\n+                             and then Aspect_Rep_Item (Aitem) = Ritem\n+                           then\n+                              Set_Entity\n+                                (Identifier (Aitem), New_Copy_Tree (Arg2));\n+                              exit;\n+                           end if;\n+\n+                           Aitem := Next_Rep_Item (Aitem);\n+                        end loop;\n+                     end;\n+                  end if;\n+\n+                  --  Now we can add the expression\n \n                   if No (Expr) then\n                      Expr := Relocate_Node (Arg2);\n@@ -4011,8 +4103,7 @@ package body Sem_Ch13 is\n              Defining_Unit_Name       => SId,\n              Parameter_Specifications => New_List (\n                Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc, Object_Name),\n+                 Defining_Identifier => Object_Entity,\n                  Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n              Result_Definition        =>\n                New_Occurrence_Of (Standard_Boolean, Loc));"}]}