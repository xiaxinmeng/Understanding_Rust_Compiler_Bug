{"sha": "9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNlODVlZmM2MGEyMDg5ZWUyYWE5NTBkNWQwNWJjOWFiNzNlOWM1OA==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2014-11-22T14:28:19Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2014-11-22T14:28:19Z"}, "message": "re PR tree-optimization/60770 (disappearing clobbers)\n\n2014-11-22  Marc Glisse  <marc.glisse@inria.fr>\n\n\tPR tree-optimization/60770\n\t* tree-sra.c (clobber_subtree): New function.\n\t(sra_modify_constructor_assign): Call it.\n\nFrom-SVN: r217967", "tree": {"sha": "8aa34619b1ef17308331ab6e7e65a2b4e3ba31c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aa34619b1ef17308331ab6e7e65a2b4e3ba31c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d26fda334585316dcc494aa001e8596c0569d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d26fda334585316dcc494aa001e8596c0569d2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d26fda334585316dcc494aa001e8596c0569d2f"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "08ee16aa574ec364eb17885afdf9ac45d4364f6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "patch": "@@ -1,3 +1,9 @@\n+2014-11-22  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/60770\n+\t* tree-sra.c (clobber_subtree): New function.\n+\t(sra_modify_constructor_assign): Call it.\n+\n 2014-11-21  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/63897"}, {"sha": "0d5bcef33ffc26c6ab7fac694f4bc2dc2426810b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "patch": "@@ -2729,6 +2729,37 @@ init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,\n     init_subtree_with_zero (child, gsi, insert_after, loc);\n }\n \n+/* Clobber all scalar replacements in an access subtree.  ACCESS is the the\n+   root of the subtree to be processed.  GSI is the statement iterator used\n+   for inserting statements which are added after the current statement if\n+   INSERT_AFTER is true or before it otherwise.  */\n+\n+static void\n+clobber_subtree (struct access *access, gimple_stmt_iterator *gsi,\n+\t\tbool insert_after, location_t loc)\n+\n+{\n+  struct access *child;\n+\n+  if (access->grp_to_be_replaced)\n+    {\n+      tree rep = get_access_replacement (access);\n+      tree clobber = build_constructor (access->type, NULL);\n+      TREE_THIS_VOLATILE (clobber) = 1;\n+      gimple stmt = gimple_build_assign (rep, clobber);\n+\n+      if (insert_after)\n+\tgsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n+      else\n+\tgsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+      update_stmt (stmt);\n+      gimple_set_location (stmt, loc);\n+    }\n+\n+  for (child = access->first_child; child; child = child->next_sibling)\n+    clobber_subtree (child, gsi, insert_after, loc);\n+}\n+\n /* Search for an access representative for the given expression EXPR and\n    return it or NULL if it cannot be found.  */\n \n@@ -3041,17 +3072,16 @@ static enum assignment_mod_result\n sra_modify_constructor_assign (gimple stmt, gimple_stmt_iterator *gsi)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n-  struct access *acc;\n-  location_t loc;\n-\n-  acc = get_access_for_expr (lhs);\n+  struct access *acc = get_access_for_expr (lhs);\n   if (!acc)\n     return SRA_AM_NONE;\n+  location_t loc = gimple_location (stmt);\n \n   if (gimple_clobber_p (stmt))\n     {\n-      /* Remove clobbers of fully scalarized variables, otherwise\n-\t do nothing.  */\n+      /* Clobber the replacement variable.  */\n+      clobber_subtree (acc, gsi, !acc->grp_covered, loc);\n+      /* Remove clobbers of fully scalarized variables, they are dead.  */\n       if (acc->grp_covered)\n \t{\n \t  unlink_stmt_vdef (stmt);\n@@ -3060,10 +3090,9 @@ sra_modify_constructor_assign (gimple stmt, gimple_stmt_iterator *gsi)\n \t  return SRA_AM_REMOVED;\n \t}\n       else\n-\treturn SRA_AM_NONE;\n+\treturn SRA_AM_MODIFIED;\n     }\n \n-  loc = gimple_location (stmt);\n   if (vec_safe_length (CONSTRUCTOR_ELTS (gimple_assign_rhs1 (stmt))) > 0)\n     {\n       /* I have never seen this code path trigger but if it can happen the"}]}