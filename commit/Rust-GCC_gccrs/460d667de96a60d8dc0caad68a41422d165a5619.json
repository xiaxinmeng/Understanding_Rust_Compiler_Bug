{"sha": "460d667de96a60d8dc0caad68a41422d165a5619", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYwZDY2N2RlOTZhNjBkOGRjMGNhYWQ2OGE0MTQyMmQxNjVhNTYxOQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2008-04-02T09:53:34Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2008-04-02T09:53:34Z"}, "message": "fwprop.c (PR_CAN_APPEAR, [...]): New.\n\n2008-04-02  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* fwprop.c (PR_CAN_APPEAR, PR_HANDLE_MEM): New.\n\t(propagate_rtx_1): Handle PR_HANDLE_MEM.\n\t(propagate_rtx): Pass PR_HANDLE_MEM if appropriate.\n\t(varying_mem_p): Move above propagate_rtx.\n\t(all_uses_available_at): Do not check MEMs.\n\nFrom-SVN: r133828", "tree": {"sha": "c27ceffbcdf941a1893f3e4693d2b26cb171f702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c27ceffbcdf941a1893f3e4693d2b26cb171f702"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/460d667de96a60d8dc0caad68a41422d165a5619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460d667de96a60d8dc0caad68a41422d165a5619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460d667de96a60d8dc0caad68a41422d165a5619", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460d667de96a60d8dc0caad68a41422d165a5619/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280"}], "stats": {"total": 121, "additions": 82, "deletions": 39}, "files": [{"sha": "a6754a00c297250f06fabdb67ad909a2d3395ec4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460d667de96a60d8dc0caad68a41422d165a5619/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460d667de96a60d8dc0caad68a41422d165a5619/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=460d667de96a60d8dc0caad68a41422d165a5619", "patch": "@@ -1,3 +1,11 @@\n+2008-04-02  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* fwprop.c (PR_CAN_APPEAR, PR_HANDLE_MEM): New.\n+\t(propagate_rtx_1): Handle PR_HANDLE_MEM.\n+\t(propagate_rtx): Pass PR_HANDLE_MEM if appropriate.\n+\t(varying_mem_p): Move above propagate_rtx.\n+\t(all_uses_available_at): Do not check MEMs.\n+\n 2008-04-02  Rafael Espindola  <espindola@google.com>\n \n \t* tree-vrp.c (extract_code_and_val_from_cond): Remove."}, {"sha": "2566cbbb89ec64383320fb20e6a4ed94246475bc", "filename": "gcc/fwprop.c", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460d667de96a60d8dc0caad68a41422d165a5619/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460d667de96a60d8dc0caad68a41422d165a5619/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=460d667de96a60d8dc0caad68a41422d165a5619", "patch": "@@ -208,47 +208,76 @@ should_replace_address (rtx old, rtx new, enum machine_mode mode)\n   return (gain > 0);\n }\n \n+\n+/* Flags for the last parameter of propagate_rtx_1.  */\n+\n+enum {\n+  /* If PR_CAN_APPEAR is true, propagate_rtx_1 always returns true;\n+     if it is false, propagate_rtx_1 returns false if, for at least\n+     one occurrence OLD, it failed to collapse the result to a constant.\n+     For example, (mult:M (reg:M A) (minus:M (reg:M B) (reg:M A))) may\n+     collapse to zero if replacing (reg:M B) with (reg:M A).\n+\n+     PR_CAN_APPEAR is disregarded inside MEMs: in that case,\n+     propagate_rtx_1 just tries to make cheaper and valid memory\n+     addresses.  */\n+  PR_CAN_APPEAR = 1,\n+\n+  /* If PR_HANDLE_MEM is not set, propagate_rtx_1 won't attempt any replacement\n+     outside memory addresses.  This is needed because propagate_rtx_1 does\n+     not do any analysis on memory; thus it is very conservative and in general\n+     it will fail if non-read-only MEMs are found in the source expression.\n+\n+     PR_HANDLE_MEM is set when the source of the propagation was not\n+     another MEM.  Then, it is safe not to treat non-read-only MEMs as\n+     ``opaque'' objects.  */\n+  PR_HANDLE_MEM = 2,\n+};\n+\n+\n /* Replace all occurrences of OLD in *PX with NEW and try to simplify the\n    resulting expression.  Replace *PX with a new RTL expression if an\n    occurrence of OLD was found.\n \n-   If CAN_APPEAR is true, we always return true; if it is false, we\n-   can return false if, for at least one occurrence OLD, we failed to\n-   collapse the result to a constant.  For example, (mult:M (reg:M A)\n-   (minus:M (reg:M B) (reg:M A))) may collapse to zero if replacing\n-   (reg:M B) with (reg:M A).\n-\n-   CAN_APPEAR is disregarded inside MEMs: in that case, we always return\n-   true if the simplification is a cheaper and valid memory address.\n-\n    This is only a wrapper around simplify-rtx.c: do not add any pattern\n    matching code here.  (The sole exception is the handling of LO_SUM, but\n    that is because there is no simplify_gen_* function for LO_SUM).  */\n \n static bool\n-propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n+propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n {\n   rtx x = *px, tem = NULL_RTX, op0, op1, op2;\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n   enum machine_mode op_mode;\n+  bool can_appear = (flags & PR_CAN_APPEAR) != 0;\n   bool valid_ops = true;\n \n-  /* If X is OLD_RTX, return NEW_RTX.  Otherwise, if this is an expression,\n-     try to build a new expression from recursive substitution.  */\n+  if (!(flags & PR_HANDLE_MEM) && MEM_P (x) && !MEM_READONLY_P (x))\n+    {\n+      /* If unsafe, change MEMs to CLOBBERs or SCRATCHes (to preserve whether\n+\t they have side effects or not).  */\n+      *px = (side_effects_p (x)\n+\t     ? gen_rtx_CLOBBER (GET_MODE (x), const0_rtx)\n+\t     : gen_rtx_SCRATCH (GET_MODE (x)));\n+      return false;\n+    }\n \n+  /* If X is OLD_RTX, return NEW_RTX.  But not if replacing only within an\n+     address, and we are *not* inside one.  */\n   if (x == old)\n     {\n       *px = new;\n       return can_appear;\n     }\n \n+  /* If this is an expression, try recursive substitution.  */\n   switch (GET_RTX_CLASS (code))\n     {\n     case RTX_UNARY:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, can_appear);\n+      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n       if (op0 == XEXP (x, 0))\n \treturn true;\n       tem = simplify_gen_unary (code, mode, op0, op_mode);\n@@ -258,8 +287,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n     case RTX_COMM_ARITH:\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, can_appear);\n-      valid_ops &= propagate_rtx_1 (&op1, old, new, can_appear);\n+      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn true;\n       tem = simplify_gen_binary (code, mode, op0, op1);\n@@ -270,8 +299,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n       op_mode = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, can_appear);\n-      valid_ops &= propagate_rtx_1 (&op1, old, new, can_appear);\n+      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn true;\n       tem = simplify_gen_relational (code, mode, op_mode, op0, op1);\n@@ -283,9 +312,9 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n       op1 = XEXP (x, 1);\n       op2 = XEXP (x, 2);\n       op_mode = GET_MODE (op0);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, can_appear);\n-      valid_ops &= propagate_rtx_1 (&op1, old, new, can_appear);\n-      valid_ops &= propagate_rtx_1 (&op2, old, new, can_appear);\n+      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op2, old, new, flags);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1) && op2 == XEXP (x, 2))\n \treturn true;\n       if (op_mode == VOIDmode)\n@@ -298,7 +327,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n       if (code == SUBREG)\n \t{\n           op0 = XEXP (x, 0);\n-\t  valid_ops &= propagate_rtx_1 (&op0, old, new, can_appear);\n+\t  valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n           if (op0 == XEXP (x, 0))\n \t    return true;\n \t  tem = simplify_gen_subreg (mode, op0, GET_MODE (SUBREG_REG (x)),\n@@ -317,7 +346,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n \t    return true;\n \n \t  op0 = new_op0 = targetm.delegitimize_address (op0);\n-\t  valid_ops &= propagate_rtx_1 (&new_op0, old, new, true);\n+\t  valid_ops &= propagate_rtx_1 (&new_op0, old, new,\n+\t\t\t\t\tflags | PR_CAN_APPEAR);\n \n \t  /* Dismiss transformation that we do not want to carry on.  */\n \t  if (!valid_ops\n@@ -344,8 +374,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n \t  /* The only simplification we do attempts to remove references to op0\n \t     or make it constant -- in both cases, op0's invalidity will not\n \t     make the result invalid.  */\n-\t  propagate_rtx_1 (&op0, old, new, true);\n-\t  valid_ops &= propagate_rtx_1 (&op1, old, new, can_appear);\n+\t  propagate_rtx_1 (&op0, old, new, flags | PR_CAN_APPEAR);\n+\t  valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n           if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \t    return true;\n \n@@ -387,6 +417,18 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, bool can_appear)\n   return valid_ops || can_appear || CONSTANT_P (tem);\n }\n \n+\n+/* for_each_rtx traversal function that returns 1 if BODY points to\n+   a non-constant mem.  */\n+\n+static int\n+varying_mem_p (rtx *body, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *body;\n+  return MEM_P (x) && !MEM_READONLY_P (x);\n+}\n+\n+\n /* Replace all occurrences of OLD in X with NEW and try to simplify the\n    resulting expression (in mode MODE).  Return a new expression if it is\n    a constant, otherwise X.\n@@ -400,14 +442,19 @@ propagate_rtx (rtx x, enum machine_mode mode, rtx old, rtx new)\n {\n   rtx tem;\n   bool collapsed;\n+  int flags;\n \n   if (REG_P (new) && REGNO (new) < FIRST_PSEUDO_REGISTER)\n     return NULL_RTX;\n \n-  new = copy_rtx (new);\n+  flags = 0;\n+  if (REG_P (new) || CONSTANT_P (new))\n+    flags |= PR_CAN_APPEAR;\n+  if (!for_each_rtx (&new, varying_mem_p, NULL))\n+    flags |= PR_HANDLE_MEM;\n \n   tem = x;\n-  collapsed = propagate_rtx_1 (&tem, old, new, REG_P (new) || CONSTANT_P (new));\n+  collapsed = propagate_rtx_1 (&tem, old, copy_rtx (new), flags);\n   if (tem == x || !collapsed)\n     return NULL_RTX;\n \n@@ -516,16 +563,6 @@ use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n }\n \n \n-/* for_each_rtx traversal function that returns 1 if BODY points to\n-   a non-constant mem.  */\n-\n-static int\n-varying_mem_p (rtx *body, void *data ATTRIBUTE_UNUSED)\n-{\n-  rtx x = *body;\n-  return MEM_P (x) && !MEM_READONLY_P (x);\n-}\n-\n /* Check if all uses in DEF_INSN can be used in TARGET_INSN.  This\n    would require full computation of available expressions;\n    we check only restricted conditions, see use_killed_between.  */\n@@ -577,9 +614,7 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n \t}\n     }\n \n-  /* We don't do any analysis of memories or aliasing.  Reject any\n-     instruction that involves references to non-constant memory.  */\n-  return !for_each_rtx (&SET_SRC (def_set), varying_mem_p, NULL);\n+  return true;\n }\n \n \f"}]}