{"sha": "f285d67bfe945cb4a02e3da0139aa4a171ba106a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI4NWQ2N2JmZTk0NWNiNGEwMmUzZGEwMTM5YWE0YTE3MWJhMTA2YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2003-11-14T17:28:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-11-14T17:28:25Z"}, "message": "function.c (struct epi_info): New field const_equiv.\n\n\tPR/6552\n\t* function.c (struct epi_info): New field const_equiv.\n\t(update_epilogue_consts): New function.\n\t(keep_stack_depressed): Clear new field and verify scratch register\n\tdoesn't have it set.\n\tCall new function via note_stores.\n\t(handle_epilogue_set): Allow setting SP equiv reg in different mode.\n\tAllow PLUS where second operand is register known set to constant.\n\t(emit_equiv_load): Write load using proper mode if source different.\n\t* config/mips/mips.md (return_internal): Put (return) first.\n\nFrom-SVN: r73609", "tree": {"sha": "753d9314a0fd4ae7558309808837be7aaf893eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/753d9314a0fd4ae7558309808837be7aaf893eae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f285d67bfe945cb4a02e3da0139aa4a171ba106a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f285d67bfe945cb4a02e3da0139aa4a171ba106a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f285d67bfe945cb4a02e3da0139aa4a171ba106a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f285d67bfe945cb4a02e3da0139aa4a171ba106a/comments", "author": null, "committer": null, "parents": [{"sha": "a477ab83205c208ab4e461b0af4af1abaad2ceae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a477ab83205c208ab4e461b0af4af1abaad2ceae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a477ab83205c208ab4e461b0af4af1abaad2ceae"}], "stats": {"total": 82, "additions": 69, "deletions": 13}, "files": [{"sha": "64c3dbae99c3d6b7055b85fc528b96145da56334", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f285d67bfe945cb4a02e3da0139aa4a171ba106a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f285d67bfe945cb4a02e3da0139aa4a171ba106a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f285d67bfe945cb4a02e3da0139aa4a171ba106a", "patch": "@@ -1,3 +1,16 @@\n+2003-11-14  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\tPR/6552\n+\t* function.c (struct epi_info): New field const_equiv.\n+\t(update_epilogue_consts): New function.\n+\t(keep_stack_depressed): Clear new field and verify scratch register\n+\tdoesn't have it set.\n+\tCall new function via note_stores.\n+\t(handle_epilogue_set): Allow setting SP equiv reg in different mode.\n+\tAllow PLUS where second operand is register known set to constant.\n+\t(emit_equiv_load): Write load using proper mode if source different.\n+\t* config/mips/mips.md (return_internal): Put (return) first.\n+\n 2003-11-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/lib1funcs.asm (___udivsi3): Add a comment."}, {"sha": "203ac2eb87af454594a64d66a85a7e2604e65967", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f285d67bfe945cb4a02e3da0139aa4a171ba106a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f285d67bfe945cb4a02e3da0139aa4a171ba106a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=f285d67bfe945cb4a02e3da0139aa4a171ba106a", "patch": "@@ -8249,8 +8249,8 @@ ld\\t%2,%1-%S1(%2)\\;daddu\\t%2,%2,$31\\;%*j\\t%2%/\"\n ;; Normal return.\n \n (define_insn \"return_internal\"\n-  [(use (match_operand 0 \"pmode_register_operand\" \"\"))\n-   (return)]\n+  [(return)\n+   (use (match_operand 0 \"pmode_register_operand\" \"\"))]\n   \"\"\n   \"%*j\\t%0%/\"\n   [(set_attr \"type\"\t\"jump\")"}, {"sha": "f191aecbfc4533e931acabf246bc28ae62c86d35", "filename": "gcc/function.c", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f285d67bfe945cb4a02e3da0139aa4a171ba106a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f285d67bfe945cb4a02e3da0139aa4a171ba106a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f285d67bfe945cb4a02e3da0139aa4a171ba106a", "patch": "@@ -7296,9 +7296,12 @@ struct epi_info\n   rtx equiv_reg_src;\t\t/* If nonzero, the value that SP_EQUIV_REG\n \t\t\t\t   should be set to once we no longer need\n \t\t\t\t   its value.  */\n+  rtx const_equiv[FIRST_PSEUDO_REGISTER]; /* Any known constant equivalences\n+\t\t\t\t\t     for registers.  */\n };\n \n static void handle_epilogue_set (rtx, struct epi_info *);\n+static void update_epilogue_consts PARAMS ((rtx, rtx, void *));\n static void emit_equiv_load (struct epi_info *);\n \n /* Modify INSN, a list of one or more insns that is part of the epilogue, to\n@@ -7311,8 +7314,7 @@ keep_stack_depressed (rtx insns)\n   struct epi_info info;\n   rtx insn, next;\n \n-  /* If the epilogue is just a single instruction, it ust be OK as is.  */\n-\n+  /* If the epilogue is just a single instruction, it must be OK as is.  */\n   if (NEXT_INSN (insns) == NULL_RTX)\n     return insns;\n \n@@ -7324,6 +7326,9 @@ keep_stack_depressed (rtx insns)\n   info.sp_offset = 0;\n   info.equiv_reg_src = 0;\n \n+  for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+    info.const_equiv[j] = 0;\n+\n   insn = insns;\n   next = NULL_RTX;\n   while (insn != NULL_RTX)\n@@ -7415,7 +7420,8 @@ keep_stack_depressed (rtx insns)\n \t\t    && !refers_to_regno_p (regno,\n \t\t\t\t\t   regno + HARD_REGNO_NREGS (regno,\n \t\t\t\t\t\t\t\t     Pmode),\n-\t\t\t\t\t   info.equiv_reg_src, NULL))\n+\t\t\t\t\t   info.equiv_reg_src, NULL)\n+\t\t    && info.const_equiv[regno] == 0)\n \t\t  break;\n \n \t      if (regno == FIRST_PSEUDO_REGISTER)\n@@ -7471,6 +7477,8 @@ keep_stack_depressed (rtx insns)\n       info.sp_equiv_reg = info.new_sp_equiv_reg;\n       info.sp_offset = info.new_sp_offset;\n \n+      /* Now update any constants this insn sets.  */\n+      note_stores (PATTERN (insn), update_epilogue_consts, &info);\n       insn = next;\n     }\n \n@@ -7494,11 +7502,18 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n       if (SET_DEST (set) != stack_pointer_rtx)\n \tabort ();\n \n-      if (GET_CODE (SET_SRC (set)) == PLUS\n-\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+      if (GET_CODE (SET_SRC (set)) == PLUS)\n \t{\n \t  p->new_sp_equiv_reg = XEXP (SET_SRC (set), 0);\n-\t  p->new_sp_offset = INTVAL (XEXP (SET_SRC (set), 1));\n+\t  if (GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+\t    p->new_sp_offset = INTVAL (XEXP (SET_SRC (set), 1));\n+\t  else if (GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n+\t\t   && REGNO (XEXP (SET_SRC (set), 1)) < FIRST_PSEUDO_REGISTER\n+\t\t   && p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))] != 0)\n+\t    p->new_sp_offset\n+\t      = INTVAL (p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))]);\n+\t  else\n+\t    abort ();\n \t}\n       else\n \tp->new_sp_equiv_reg = SET_SRC (set), p->new_sp_offset = 0;\n@@ -7521,11 +7536,16 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n      there seems little point in handling that case.  Note that we have\n      to allow for the case where we are setting the register set in\n      the previous part of a PARALLEL inside a single insn.  But use the\n-     old offset for any updates within this insn.  */\n+     old offset for any updates within this insn.  We must allow for the case\n+     where the register is being set in a different (usually wider) mode than\n+     Pmode).  */\n   else if (p->new_sp_equiv_reg != 0 && reg_set_p (p->new_sp_equiv_reg, set))\n     {\n-      if (!rtx_equal_p (p->new_sp_equiv_reg, SET_DEST (set))\n-\t  || p->equiv_reg_src != 0)\n+      if (p->equiv_reg_src != 0\n+\t  || GET_CODE (p->new_sp_equiv_reg) != REG\n+\t  || GET_CODE (SET_DEST (set)) != REG\n+\t  || GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) > BITS_PER_WORD\n+\t  || REGNO (p->new_sp_equiv_reg) != REGNO (SET_DEST (set)))\n \tabort ();\n       else\n \tp->equiv_reg_src\n@@ -7548,15 +7568,38 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n     }\n }\n \n+/* Update the tracking information for registers set to constants.  */\n+\n+static void\n+update_epilogue_consts (rtx dest, rtx x, void *data)\n+{\n+  struct epi_info *p = (struct epi_info *) data;\n+\n+  if (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+    return;\n+  else if (GET_CODE (x) == CLOBBER || ! rtx_equal_p (dest, SET_DEST (x))\n+\t   || GET_CODE (SET_SRC (x)) != CONST_INT)\n+    p->const_equiv[REGNO (dest)] = 0;\n+  else\n+    p->const_equiv[REGNO (dest)] = SET_SRC (x);\n+}\n+\n /* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */\n \n static void\n emit_equiv_load (struct epi_info *p)\n {\n   if (p->equiv_reg_src != 0)\n-    emit_move_insn (p->sp_equiv_reg, p->equiv_reg_src);\n+    {\n+      rtx dest = p->sp_equiv_reg;\n+\n+      if (GET_MODE (p->equiv_reg_src) != GET_MODE (dest))\n+\tdest = gen_rtx_REG (GET_MODE (p->equiv_reg_src),\n+\t\t\t    REGNO (p->sp_equiv_reg));\n \n-  p->equiv_reg_src = 0;\n+      emit_move_insn (dest, p->equiv_reg_src);\n+      p->equiv_reg_src = 0;\n+    }\n }\n #endif\n "}]}