{"sha": "96559bc5526a4914975c8e34ca05836f0bd65134", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY1NTliYzU1MjZhNDkxNDk3NWM4ZTM0Y2EwNTgzNmYwYmQ2NTEzNA==", "commit": {"author": {"name": "Gerald Pfeifer", "email": "gerald@gcc.gnu.org", "date": "1999-06-16T13:37:39Z"}, "committer": {"name": "Gerald Pfeifer", "email": "gerald@gcc.gnu.org", "date": "1999-06-16T13:37:39Z"}, "message": "Remove obsolete file, whose contents has moved to the web pages as\nprojects.html.\n\nFrom-SVN: r27552", "tree": {"sha": "7538c39f1f1d9a780aaaa1019b9860dd25f5ddaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7538c39f1f1d9a780aaaa1019b9860dd25f5ddaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96559bc5526a4914975c8e34ca05836f0bd65134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96559bc5526a4914975c8e34ca05836f0bd65134", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96559bc5526a4914975c8e34ca05836f0bd65134", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96559bc5526a4914975c8e34ca05836f0bd65134/comments", "author": null, "committer": null, "parents": [{"sha": "afe958103c4c1653030925a446643e06f86383b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe958103c4c1653030925a446643e06f86383b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe958103c4c1653030925a446643e06f86383b8"}], "stats": {"total": 431, "additions": 0, "deletions": 431}, "files": [{"sha": "80f7967522d45011e3dfae9d72d667644178dedb", "filename": "gcc/PROJECTS", "status": "removed", "additions": 0, "deletions": 431, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe958103c4c1653030925a446643e06f86383b8/gcc%2FPROJECTS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe958103c4c1653030925a446643e06f86383b8/gcc%2FPROJECTS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FPROJECTS?ref=afe958103c4c1653030925a446643e06f86383b8", "patch": "@@ -1,431 +0,0 @@\n-Haifa scheduler (haifa-sched.c, loop.[ch], unroll.[ch], genattrtab.c):\n-(contact law@cygnus.com before starting any serious haifa work)\n-\n-  * Fix all the formatting problems.  Simple, mindless work.\n-\n-  * Fix/add comments throughout the code.  Many of the comments are from\n-  the old scheduler and are out of date and misleading.  Many new hunks\n-  of code don't have sufficient comments and documentation.  Those which\n-  do have comments need to be rewritten to use complete sentences and\n-  proper formatting.\n-\n-  * Someone needs make one (or more) passes over the scheduler as a whole to\n-  just clean it up.  Try to move the machine dependent bits into the target\n-  files where they belong, avoid re-creating functions where or near\n-  equivalents already exist (ie is_conditional_branch and friends), etc., etc.\n-\n-  * Document the new scheduling options.  Remove those options which are\n-  not really useful (like reverse scheduling for example).  In general\n-  the haifa scheduler adds _way_ too many options.  I'm definitely of the\n-  opinion that gcc already has too many -foptions, and haifa doesn't help\n-  that situation.\n-\n-  * Testing and benchmarking.    We've converted a few ports to using the\n-  Haifa scheduler (hppa, sparc, ppc, alpha).  We need to continue testing\n-  and benchmarking the new scheduler on additional targets.\n-\n-  We need to have some kind of docs for how to best describe a machine to\n-  the haifa scheduler to get good performance.  Some existing ports have\n-  been tuned to deal with the old scheduler -- they may need to be tuned\n-  to generate good schedules with haifa.\n-\n-  \n-\n-Improvements to global cse and partial redundancy elimination:\n-\n-The current implementation of global cse uses a lazy code motion algorithm\n-from Muchnick's \"Advanced Compiler Design and Implementation\".\n-\n-Longer term we want to convert to an edge based LCM algorithm using the\n-new structures defined by flow.c.  This allows for better expression\n-placement and provides edge splitting \"for free\". \n-\n-lcm also provides the underlying framework for several additional optimizations\n-such as shrink wrapping, spill code motion, dead store elimination, and generic\n-load/store motion (all the other examples are subcases of load/store motion).\n-\n-It can probably also be used to improve the reg-stack pass of the compiler.\n-\n-Contact law@cygnus.com if you're interested in working on lazy code motion.\n-\n--------------\n-\n-The old PROJECTS file.  Stuff I know has been done has been deleted.\n-Stuff in progress has a contact name associated with it.\n-has been \n-\n-1. Better optimization.\n-\n-* Constants in unused inline functions\n-\n-It would be nice to delay output of string constants so that string\n-constants mentioned in unused inline functions are never generated.\n-Perhaps this would also take care of string constants in dead code.\n-\n-The difficulty is in finding a clean way for the RTL which refers\n-to the constant (currently, only by an assembler symbol name)\n-to point to the constant and cause it to be output.\n-\n-* Optimize a sequence of if statements whose conditions are exclusive.\n-\n-It is possible to optimize \n-\n-    if (x == 1) ...;\n-    if (x == 2) ...;\n-    if (x == 3) ...;\n-\n-into\n-\n-    if (x == 1) ...;\n-    else if (x == 2) ...;\n-    else if (x == 3) ...;\n-\n-provided that x is not altered by the contents of the if statements.\n-\n-It's not certain whether this is worth doing.  Perhaps programmers\n-nearly always write the else's themselves, leaving few opportunities\n-to improve anything.\n-\n-* Un-cse.\n-\n-Perhaps we should have an un-cse step right after cse, which tries to\n-replace a reg with its value if the value can be substituted for the\n-reg everywhere, if that looks like an improvement.  Which is if the\n-reg is used only a few times.  Use rtx_cost to determine if the\n-change is really an improvement.\n-\n-* Clean up how cse works.\n-\n-The scheme is that each value has just one hash entry.  The\n-first_same_value and next_same_value chains are no longer needed.\n-\n-For arithmetic, each hash table elt has the following slots:\n-\n-* Operation.  This is an rtx code.\n-* Mode.\n-* Operands 0, 1 and 2.  These point to other hash table elements.\n-\n-So, if we want to enter (PLUS:SI (REG:SI 30) (CONST_INT 104)), we\n-first enter (CONST_INT 104) and find the entry that (REG:SI 30) now\n-points to.  Then we put these elts into operands 0 and 1 of a new elt.\n-We put PLUS and SI into the new elt.\n-\n-Registers and mem refs would never be entered into the table as such.\n-However, the values they contain would be entered.  There would be a\n-table indexed by regno which points at the hash entry for the value in\n-that reg.\n-\n-The hash entry index now plays the role of a qty number.\n-We still need qty_first_reg, reg_next_eqv, etc. to record which regs\n-share a particular qty.\n-\n-When a reg is used whose contents are unknown, we need to create a\n-hash table entry whose contents say \"unknown\", as a place holder for\n-whatever the reg contains.  If that reg is added to something, then\n-the hash entry for the sum will refer to the \"unknown\" entry.  Use\n-UNKNOWN for the rtx code in this entry.  This replaces make_new_qty.\n-\n-For a constant, a unique hash entry would be made based on the\n-value of the constant.\n-\n-What about MEM?  Each time a memory address is referenced, we need a\n-qty (a hash table elt) to represent what is in it.  (Just as for a\n-register.)  If this isn't known, create one, just as for a reg whose\n-contents are unknown.\n-\n-We need a way to find all mem refs that still contain a certain value.\n-Do this with a chain of hash elts (for memory addresses) that point to\n-locations that hold the value.  The hash elt for the value itself should\n-point to the start of the chain.  It would be good for the hash elt\n-for an address to point to the hash elt for the contents of that address\n-(but this ptr can be null if the contents have never been entered).\n-\n-With this data structure, nothing need ever be invalidated except\n-the lists of which regs or mems hold a particular value.  It is easy\n-to see if there is a reg or mem that is equiv to a particular value.\n-If the value is constant, it is always explicitly constant.\n-\n-* Support more general tail-recursion among different functions.\n-\n-This might be possible under certain circumstances, such as when\n-the argument lists of the functions have the same lengths.\n-Perhaps it could be done with a special declaration.\n-\n-You would need to verify in the calling function that it does not\n-use the addresses of any local variables and does not use setjmp.\n-\n-* Put short statics vars at low addresses and use short addressing mode?\n-\n-Useful on the 68000/68020 and perhaps on the 32000 series,\n-provided one has a linker that works with the feature.\n-This is said to make a 15% speedup on the 68000.\n-\n-* Keep global variables in registers.\n-\n-Here is a scheme for doing this.  A global variable, or a local variable\n-whose address is taken, can be kept in a register for an entire function\n-if it does not use non-constant memory addresses and (for globals only)\n-does not call other functions.  If the entire function does not meet\n-this criterion, a loop may.\n-\n-The VAR_DECL for such a variable would have to have two RTL expressions:\n-the true home in memory, and the pseudo-register used temporarily. \n-It is necessary to emit insns to copy the memory location into the\n-pseudo-register at the beginning of the function or loop, and perhaps\n-back out at the end.  These insns should have REG_EQUIV notes so that,\n-if the pseudo-register does not get a hard register, it is spilled into\n-the memory location which exists in any case.\n-\n-The easiest way to set up these insns is to modify the routine\n-put_var_into_stack so that it does not apply to the entire function\n-(sparing any loops which contain nothing dangerous) and to call it at\n-the end of the function regardless of where in the function the\n-address of a local variable is taken.  It would be called\n-unconditionally at the end of the function for all relevant global\n-variables.\n-\n-For debugger output, the thing to do is to invent a new binding level\n-around the appropriate loop and define the variable name as a register\n-variable with that scope.\n-\n-* Live-range splitting.\n-\n-Currently a variable is allocated a hard register either for the full\n-extent of its use or not at all.  Sometimes it would be good to\n-allocate a variable a hard register for just part of a function; for\n-example, through a particular loop where the variable is mostly used,\n-or outside of a particular loop where the variable is not used.  (The\n-latter is nice because it might let the variable be in a register most\n-of the time even though the loop needs all the registers.)\n-\n-Contact meissner@cygnus.com before starting any work on live range\n-splitting.\n-\n-* Detect dead stores into memory?\n-\n-A store into memory is dead if it is followed by another store into\n-the same location; and, in between, there is no reference to anything\n-that might be that location (including no reference to a variable\n-address).\n-\n-This can be modeled as a partial redundancy elimination/lazy code motion\n-problem.  Contact law@cygnus.com before working on dead store elimination\n-optimizations.\n-\n-* Loop optimization.\n-\n-Strength reduction and iteration variable elimination could be\n-smarter.  They should know how to decide which iteration variables are\n-not worth making explicit because they can be computed as part of an\n-address calculation.  Based on this information, they should decide\n-when it is desirable to eliminate one iteration variable and create\n-another in its place.\n-\n-It should be possible to compute what the value of an iteration\n-variable will be at the end of the loop, and eliminate the variable\n-within the loop by computing that value at the loop end.\n-\n-When a loop has a simple increment that adds 1,\n-instead of jumping in after the increment,\n-decrement the loop count and jump to the increment.\n-This allows aob insns to be used.\n-\n-* Using constraints on values.\n-\n-Many operations could be simplified based on knowledge of the\n-minimum and maximum possible values of a register at any particular time.\n-These limits could come from the data types in the tree, via rtl generation,\n-or they can be deduced from operations that are performed.  For example,\n-the result of an `and' operation one of whose operands is 7 must be in\n-the range 0 to 7.  Compare instructions also tell something about the\n-possible values of the operand, in the code beyond the test.\n-\n-Value constraints can be used to determine the results of a further\n-comparison.  They can also indicate that certain `and' operations are\n-redundant.  Constraints might permit a decrement and branch\n-instruction that checks zeroness to be used when the user has\n-specified to exit if negative.\n-\n-* Change the type of a variable.\n-\n-Sometimes a variable is declared as `int', it is assigned only once\n-from a value of type `char', and then it is used only by comparison\n-against constants.  On many machines, better code would result if\n-the variable had type `char'.  If the compiler could detect this\n-case, it could change the declaration of the variable and change\n-all the places that use it.\n-\n-* Better handling for very sparse switches.\n-\n-There may be cases where it would be better to compile a switch\n-statement to use a fixed hash table rather than the current\n-combination of jump tables and binary search.\n-\n-* Order of subexpressions.\n-\n-It might be possible to make better code by paying attention\n-to the order in which to generate code for subexpressions of an expression.\n-\n-* More code motion.\n-\n-Consider hoisting common code up past conditional branches or tablejumps.\n-\n-Contact law@cygnus.com before working on code hoisting.\n-\n-* Trace scheduling.\n-\n-This technique is said to be able to figure out which way a jump\n-will usually go, and rearrange the code to make that path the\n-faster one.\n-\n-* Distributive law.\n-\n-The C expression *(X + 4 * (Y + C)) compiles better on certain\n-machines if rewritten as *(X + 4*C + 4*Y) because of known addressing\n-modes.  It may be tricky to determine when, and for which machines, to\n-use each alternative.\n-\n-Some work has been done on this, in combine.c.\n-\n-* Can optimize by changing if (x) y; else z; into z; if (x) y;\n-if z and x do not interfere and z has no effects not undone by y.\n-This is desirable if z is faster than jumping.\n-\n-* For a two-insn loop on the 68020, such as\n-  foo:\tmovb\ta2@+,a3@+\n-\tjne\tfoo\n-it is better to insert dbeq d0,foo before the jne.\n-d0 can be a junk register.  The challenge is to fit this into\n-a portable framework: when can you detect this situation and\n-still be able to allocate a junk register?\n-\n-2. Simpler porting.\n-\n-Right now, describing the target machine's instructions is done\n-cleanly, but describing its addressing mode is done with several\n-ad-hoc macro definitions.  Porting would be much easier if there were\n-an RTL description for addressing modes like that for instructions.\n-Tools analogous to genflags and genrecog would generate macros from\n-this description.\n-\n-There would be one pattern in the address-description file for each\n-kind of addressing, and this pattern would have:\n-\n-  * the RTL expression for the address\n-  * C code to verify its validity (since that may depend on\n-    the exact data).\n-  * C code to print the address in assembler language.\n-  * C code to convert the address into a valid one, if it is not valid.\n-    (This would replace LEGITIMIZE_ADDRESS).\n-  * Register constraints for all indeterminates that appear\n-    in the RTL expression.\n-\n-3. Other languages.\n-\n-Front ends for Pascal, Fortran, Algol, Cobol, Modula-2 and Ada are\n-desirable.\n-\n-Pascal, Modula-2 and Ada require the implementation of functions\n-within functions.  Some of the mechanisms for this already exist.\n-\n-4. More extensions.\n-\n-* Generated unique labels.  Have some way of generating distinct labels\n-for use in extended asm statements.  I don't know what a good syntax would\n-be.\n-\n-* A way of defining a structure containing a union, in which the choice of\n-union alternative is controlled by a previous structure component.\n-\n-Here is a possible syntax for this.\n-\n-struct foo {\n-  enum { INT, DOUBLE } code;\n-  auto union { case INT: int i; case DOUBLE: double d;} value : code;\n-};\n-\n-* Allow constructor expressions as lvalues, like this:\n-\n-\t(struct foo) {a, b, c} = foo();\n-\n-This would call foo, which returns a structure, and then store the\n-several components of the structure into the variables a, b, and c.\n-\n-5. Generalize the machine model.\n-\n-* Some new compiler features may be needed to do a good job on machines\n-where static data needs to be addressed using base registers.\n-\n-* Some machines have two stacks in different areas of memory, one used\n-for scalars and another for large objects.  The compiler does not\n-now have a way to understand this.\n-\n-6. Useful warnings.\n-\n-* Warn about statements that are undefined because the order of\n-evaluation of increment operators makes a big difference.  Here is an\n-example:\n-\n-    *foo++ = hack (*foo);\n-\n-7. Better documentation of how GCC works and how to port it.\n-\n-Here is an outline proposed by Allan Adler.\n-\n-I.    Overview of this document\n-II.   The machines on which GCC is implemented\n-    A. Prose description of those characteristics of target machines and\n-       their operating systems which are pertinent to the implementation\n-       of GCC.\n-\ti. target machine characteristics\n-\tii. comparison of this system of machine characteristics with\n-\t    other systems of machine specification currently in use\n-    B. Tables of the characteristics of the target machines on which\n-       GCC is implemented.\n-    C. A priori restrictions on the values of characteristics of target \n-       machines, with special reference to those parts of the source code\n-       which entail those restrictions\n-\ti. restrictions on individual characteristics \n-        ii. restrictions involving relations between various characteristics\n-    D. The use of GCC as a cross-compiler \n-\ti. cross-compilation to existing machines\n-\tii. cross-compilation to non-existent machines\n-    E. Assumptions which are made regarding the target machine\n-\ti.  assumptions regarding the architecture of the target machine\n-\tii. assumptions regarding the operating system of the target machine\n-\tiii. assumptions regarding software resident on the target machine\n-\tiv. where in the source code these assumptions are in effect made\n-III.   A systematic approach to writing the files tm.h and xm.h\n-    A. Macros which require special care or skill\n-    B. Examples, with special reference to the underlying reasoning\n-IV.    A systematic approach to writing the machine description file md\n-    A. Minimal viable sets of insn descriptions\n-    B. Examples, with special reference to the underlying reasoning\n-V.     Uses of the file aux-output.c\n-VI.    Specification of what constitutes correct performance of an \n-       implementation of GCC\n-    A. The components of GCC\n-    B. The itinerary of a C program through GCC\n-    C. A system of benchmark programs\n-    D. What your RTL and assembler should look like with these benchmarks\n-    E. Fine tuning for speed and size of compiled code\n-VII.   A systematic procedure for debugging an implementation of GCC\n-    A. Use of GDB\n-\ti. the macros in the file .gdbinit for GCC\n-\tii. obstacles to the use of GDB\n-\t    a. functions implemented as macros can't be called in GDB\n-    B. Debugging without GDB\n-\ti. How to turn off the normal operation of GCC and access specific\n-\t   parts of GCC\n-    C. Debugging tools\n-    D. Debugging the parser\n-\ti. how machine macros and insn definitions affect the parser\n-    E. Debugging the recognizer\n-\ti. how machine macros and insn definitions affect the recognizer\n-\n-ditto for other components\n-\n-VIII. Data types used by GCC, with special reference to restrictions not \n-      specified in the formal definition of the data type\n-IX.   References to the literature for the algorithms used in GCC\n-"}]}