{"sha": "fa21a761a6e3d63bfddbd722e3d754c67b49b832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEyMWE3NjFhNmUzZDYzYmZkZGJkNzIyZTNkNzU0YzY3YjQ5YjgzMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-06-01T13:01:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-06-01T13:01:23Z"}, "message": "mips.c (mips_valid_offset_p): New function.\n\ngcc/\n\t* config/mips/mips.c (mips_valid_offset_p): New function.\n\t(mips_valid_lo_sum_p): Likewise.\n\t(mips_classify_address): Use them.\n\t(mips_force_address): New function.\n\t(mips_legitimize_address): Use it.\n\t* config/mips/mips.md (MOVE128): New mode iterator.\n\t(movtf): Require TARGET_64BIT.  Remove empty strings.\n\t(*movtf_internal): Rename to...\n\t(*movtf): ...this and require !TARGET_MIPS16.  Use \"m\" instead\n\tof \"R\" and use {,fp}{load,store} attributes instead of \"multi\".\n\tUse a separate define_split.\n\t(*movtf_mips16): New pattern.\n\ngcc/testsuite/\n\t* gcc.target/mips/fpr-moves-7.c: New test.\n\t* gcc.target/mips/fpr-moves-8.c: New test.\n\nFrom-SVN: r136253", "tree": {"sha": "9c55217d47044ea577705c898f5fa55f382ce4d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c55217d47044ea577705c898f5fa55f382ce4d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa21a761a6e3d63bfddbd722e3d754c67b49b832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa21a761a6e3d63bfddbd722e3d754c67b49b832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa21a761a6e3d63bfddbd722e3d754c67b49b832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa21a761a6e3d63bfddbd722e3d754c67b49b832/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f7e2abbd1a97bcc0a8442c8e7358fb01ef7ffa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7e2abbd1a97bcc0a8442c8e7358fb01ef7ffa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7e2abbd1a97bcc0a8442c8e7358fb01ef7ffa8"}], "stats": {"total": 219, "additions": 197, "deletions": 22}, "files": [{"sha": "cd13a87e68faa9bf26500d6ea7da82cb29cd7d72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa21a761a6e3d63bfddbd722e3d754c67b49b832", "patch": "@@ -1,3 +1,18 @@\n+2008-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.c (mips_valid_offset_p): New function.\n+\t(mips_valid_lo_sum_p): Likewise.\n+\t(mips_classify_address): Use them.\n+\t(mips_force_address): New function.\n+\t(mips_legitimize_address): Use it.\n+\t* config/mips/mips.md (MOVE128): New mode iterator.\n+\t(movtf): Require TARGET_64BIT.  Remove empty strings.\n+\t(*movtf_internal): Rename to...\n+\t(*movtf): ...this and require !TARGET_MIPS16.  Use \"m\" instead\n+\tof \"R\" and use {,fp}{load,store} attributes instead of \"multi\".\n+\tUse a separate define_split.\n+\t(*movtf_mips16): New pattern.\n+\n 2008-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips-protos.h (mips_expand_before_return): Declare."}, {"sha": "551159c9e94c78ef1ad93eda3080295f16340190", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=fa21a761a6e3d63bfddbd722e3d754c67b49b832", "patch": "@@ -1809,6 +1809,51 @@ mips_valid_base_register_p (rtx x, enum machine_mode mode, bool strict_p)\n \t  && mips_regno_mode_ok_for_base_p (REGNO (x), mode, strict_p));\n }\n \n+/* Return true if, for every base register BASE_REG, (plus BASE_REG X)\n+   can address a value of mode MODE.  */\n+\n+static bool\n+mips_valid_offset_p (rtx x, enum machine_mode mode)\n+{\n+  /* Check that X is a signed 16-bit number.  */\n+  if (!const_arith_operand (x, Pmode))\n+    return false;\n+\n+  /* We may need to split multiword moves, so make sure that every word\n+     is accessible.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      && !SMALL_OPERAND (INTVAL (x) + GET_MODE_SIZE (mode) - UNITS_PER_WORD))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if a LO_SUM can address a value of mode MODE when the\n+   LO_SUM symbol has type SYMBOL_TYPE.  */\n+\n+static bool\n+mips_valid_lo_sum_p (enum mips_symbol_type symbol_type, enum machine_mode mode)\n+{\n+  /* Check that symbols of type SYMBOL_TYPE can be used to access values\n+     of mode MODE.  */\n+  if (mips_symbol_insns (symbol_type, mode) == 0)\n+    return false;\n+\n+  /* Check that there is a known low-part relocation.  */\n+  if (mips_lo_relocs[symbol_type] == NULL)\n+    return false;\n+\n+  /* We may need to split multiword moves, so make sure that each word\n+     can be accessed without inducing a carry.  This is mainly needed\n+     for o64, which has historically only guaranteed 64-bit alignment\n+     for 128-bit types.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      && GET_MODE_BITSIZE (mode) > GET_MODE_ALIGNMENT (mode))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if X is a valid address for machine mode MODE.  If it is,\n    fill in INFO appropriately.  STRICT_P is true if REG_OK_STRICT is in\n    effect.  */\n@@ -1831,7 +1876,7 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n       info->reg = XEXP (x, 0);\n       info->offset = XEXP (x, 1);\n       return (mips_valid_base_register_p (info->reg, mode, strict_p)\n-\t      && const_arith_operand (info->offset, VOIDmode));\n+\t      && mips_valid_offset_p (info->offset, mode));\n \n     case LO_SUM:\n       info->type = ADDRESS_LO_SUM;\n@@ -1849,8 +1894,7 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n       info->symbol_type\n \t= mips_classify_symbolic_expression (info->offset, SYMBOL_CONTEXT_MEM);\n       return (mips_valid_base_register_p (info->reg, mode, strict_p)\n-\t      && mips_symbol_insns (info->symbol_type, mode) > 0\n-\t      && mips_lo_relocs[info->symbol_type] != 0);\n+\t      && mips_valid_lo_sum_p (info->symbol_type, mode));\n \n     case CONST_INT:\n       /* Small-integer addresses don't occur very often, but they\n@@ -2473,6 +2517,16 @@ mips_legitimize_tls_address (rtx loc)\n   return dest;\n }\n \f\n+/* If X is not a valid address for mode MODE, force it into a register.  */\n+\n+static rtx\n+mips_force_address (rtx x, enum machine_mode mode)\n+{\n+  if (!mips_legitimate_address_p (mode, x, false))\n+    x = force_reg (Pmode, x);\n+  return x;\n+}\n+\n /* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n    be legitimized in a way that the generic machinery might not expect,\n    put the new address in *XLOC and return true.  MODE is the mode of\n@@ -2481,7 +2535,7 @@ mips_legitimize_tls_address (rtx loc)\n bool\n mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n {\n-  rtx base;\n+  rtx base, addr;\n   HOST_WIDE_INT offset;\n \n   if (mips_tls_symbol_p (*xloc))\n@@ -2491,16 +2545,20 @@ mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n     }\n \n   /* See if the address can split into a high part and a LO_SUM.  */\n-  if (mips_split_symbol (NULL, *xloc, mode, xloc))\n-    return true;\n+  if (mips_split_symbol (NULL, *xloc, mode, &addr))\n+    {\n+      *xloc = mips_force_address (addr, mode);\n+      return true;\n+    }\n \n   /* Handle BASE + OFFSET using mips_add_offset.  */\n   mips_split_plus (*xloc, &base, &offset);\n   if (offset != 0)\n     {\n       if (!mips_valid_base_register_p (base, mode, false))\n \tbase = copy_to_mode_reg (Pmode, base);\n-      *xloc = mips_add_offset (NULL, base, offset);\n+      addr = mips_add_offset (NULL, base, offset);\n+      *xloc = mips_force_address (addr, mode);\n       return true;\n     }\n   return false;"}, {"sha": "3370d9958c8925253b7a0f54741d266d96897e05", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=fa21a761a6e3d63bfddbd722e3d754c67b49b832", "patch": "@@ -496,6 +496,9 @@\n (define_mode_iterator MOVE64\n   [DI DF (V2SF \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\")])\n \n+;; 128-bit modes for which we provide move patterns on 64-bit targets.\n+(define_mode_iterator MOVE128 [TF])\n+\n ;; This mode iterator allows the QI and HI extension patterns to be\n ;; defined from the same template.\n (define_mode_iterator SHORT [QI HI])\n@@ -4064,28 +4067,36 @@\n ;; 128-bit floating point moves\n \n (define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"\")\n-\t(match_operand:TF 1 \"\"))]\n-  \"\"\n+  [(set (match_operand:TF 0)\n+\t(match_operand:TF 1))]\n+  \"TARGET_64BIT\"\n {\n   if (mips_legitimize_move (TFmode, operands[0], operands[1]))\n     DONE;\n })\n \n ;; This pattern handles both hard- and soft-float cases.\n-(define_insn_and_split \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=d,R,f,dR\")\n-\t(match_operand:TF 1 \"move_operand\" \"dGR,dG,dGR,f\"))]\n-  \"\"\n+(define_insn \"*movtf\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=d,d,m,f,d,f,m\")\n+\t(match_operand:TF 1 \"move_operand\" \"dG,m,dG,dG,f,m,f\"))]\n+  \"TARGET_64BIT\n+   && !TARGET_MIPS16\n+   && (register_operand (operands[0], TFmode)\n+       || reg_or_0_operand (operands[1], TFmode))\"\n   \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  mips_split_doubleword_move (operands[0], operands[1]);\n-  DONE;\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"16\")])\n+  [(set_attr \"type\" \"multi,load,store,multi,multi,fpload,fpstore\")\n+   (set_attr \"length\" \"8,*,*,8,8,*,*\")])\n+\n+(define_insn \"*movtf_mips16\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=d,y,d,d,m\")\n+\t(match_operand:TF 1 \"move_operand\" \"d,d,y,m,d\"))]\n+  \"TARGET_64BIT\n+   && TARGET_MIPS16\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode))\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi,multi,multi,load,store\")\n+   (set_attr \"length\" \"8,8,8,*,*\")])\n \n (define_split\n   [(set (match_operand:MOVE64 0 \"nonimmediate_operand\")\n@@ -4098,6 +4109,16 @@\n   DONE;\n })\n \n+(define_split\n+  [(set (match_operand:MOVE128 0 \"nonimmediate_operand\")\n+\t(match_operand:MOVE128 1 \"move_operand\"))]\n+  \"TARGET_64BIT && reload_completed\"\n+  [(const_int 0)]\n+{\n+  mips_split_doubleword_move (operands[0], operands[1]);\n+  DONE;\n+})\n+\n ;; When generating mips16 code, split moves of negative constants into\n ;; a positive \"li\" followed by a negation.\n (define_split"}, {"sha": "a53fdd73f9e6459516734e110d63db4184e7c58c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa21a761a6e3d63bfddbd722e3d754c67b49b832", "patch": "@@ -1,3 +1,8 @@\n+2008-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/fpr-moves-7.c: New test.\n+\t* gcc.target/mips/fpr-moves-8.c: New test.\n+\n 2008-05-30  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* gcc.target/bfin/mcpu-default.c: Adjust for recent changes: default"}, {"sha": "4736edd24ee88bfb7917c160e737bf2943da68b6", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-7.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-7.c?ref=fa21a761a6e3d63bfddbd722e3d754c67b49b832", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile { target mips16_attribute } } */\n+/* { dg-mips-options \"-mabi=64 -msoft-float -O2 -EL\" } */\n+/* { dg-add-options mips16_attribute } */\n+\n+extern long double g[16];\n+extern unsigned char gstuff[0x10000];\n+\n+NOMIPS16 long double\n+foo (long double i1, long double i2, long double i3, long double i4,\n+     long double *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = 1.0;\n+  x[3] = g[4];\n+  x[4] = *(long double *) (lstuff + 0x7fff);\n+  return *(long double *) (gstuff + 0x7fff);\n+}\n+\n+MIPS16 long double\n+bar (long double i1, long double i2, long double i3, long double i4,\n+     long double *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = 1.0;\n+  x[3] = g[4];\n+  x[4] = *(long double *) (lstuff + 0x7fff);\n+  return *(long double *) (gstuff + 0x7fff);\n+}"}, {"sha": "ade9e5e9c0a36f8c3b8d390ff16ea6cb71b01461", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-8.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa21a761a6e3d63bfddbd722e3d754c67b49b832/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-8.c?ref=fa21a761a6e3d63bfddbd722e3d754c67b49b832", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile { target mips16_attribute } } */\n+/* { dg-mips-options \"-mabi=64 -msoft-float -O2 -EB\" } */\n+/* { dg-add-options mips16_attribute } */\n+\n+extern long double g[16];\n+extern unsigned char gstuff[0x10000];\n+\n+NOMIPS16 long double\n+foo (long double i1, long double i2, long double i3, long double i4,\n+     long double *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = 1.0;\n+  x[3] = g[4];\n+  x[4] = *(long double *) (lstuff + 0x7fff);\n+  return *(long double *) (gstuff + 0x7fff);\n+}\n+\n+MIPS16 long double\n+bar (long double i1, long double i2, long double i3, long double i4,\n+     long double *x, unsigned char *lstuff)\n+{\n+  g[0] = i1;\n+  g[1] = i2;\n+  g[2] = i3;\n+  g[3] = i4;\n+  x[0] = x[4];\n+  x[1] = 0;\n+  x[2] = 1.0;\n+  x[3] = g[4];\n+  x[4] = *(long double *) (lstuff + 0x7fff);\n+  return *(long double *) (gstuff + 0x7fff);\n+}"}]}