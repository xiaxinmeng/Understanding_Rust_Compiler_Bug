{"sha": "5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1ZmU2ZDlmN2U1NjgwYmJmNmViZWNhMjExNzJiYzhlM2IzNDU0Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-19T08:47:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-19T08:47:47Z"}, "message": "mips.c (mips16_copy_fpr_return_value): New function, split out from...\n\ngcc/\n\t* config/mips/mips.c (mips16_copy_fpr_return_value): New function,\n\tsplit out from...\n\t(mips_expand_epilogue): ...here.\n\t(mips_mdebug_abi_name): New function, split out from...\n\t(mips_file_start): ...here.\n\t(mips_hard_regno_mode_ok_p): New function, split out from...\n\t(override_options): ...here.\n\t(mips_expand_builtin_1): New function, split out from...\n\t(mips_expand_buitin): ...here.  Abort if we don't recognize\n\tthe function.\n\nFrom-SVN: r129477", "tree": {"sha": "e517395cf9e4acf519c24d6dff4c71f95943ad96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e517395cf9e4acf519c24d6dff4c71f95943ad96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f/comments", "author": null, "committer": null, "parents": [{"sha": "6a68a25874dca20011eaa9c6c0a67d5d026a68e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a68a25874dca20011eaa9c6c0a67d5d026a68e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a68a25874dca20011eaa9c6c0a67d5d026a68e2"}], "stats": {"total": 324, "additions": 178, "deletions": 146}, "files": [{"sha": "8655afab779a307b12dd9fa09d69159a89d94a66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "patch": "@@ -1,3 +1,16 @@\n+2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (mips16_copy_fpr_return_value): New function,\n+\tsplit out from...\n+\t(mips_expand_epilogue): ...here.\n+\t(mips_mdebug_abi_name): New function, split out from...\n+\t(mips_file_start): ...here.\n+\t(mips_hard_regno_mode_ok_p): New function, split out from...\n+\t(override_options): ...here.\n+\t(mips_expand_builtin_1): New function, split out from...\n+\t(mips_expand_buitin): ...here.  Abort if we don't recognize\n+\tthe function.\n+\n 2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (build_mips16_function_stub): Load the"}, {"sha": "da9448e3c7a60bfeb3aac340f9b2d1122e11baf6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 165, "deletions": 146, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "patch": "@@ -5223,6 +5223,30 @@ build_mips16_function_stub (void)\n   switch_to_section (function_section (current_function_decl));\n }\n \n+/* The current function is a MIPS16 function that returns a value in an FPR.\n+   Copy the return value from its soft-float to its hard-float location.\n+   libgcc2 has special non-MIPS16 helper functions for each case.  */\n+\n+static void\n+mips16_copy_fpr_return_value (void)\n+{\n+  rtx fn, insn, arg, call;\n+  tree id, return_type;\n+  enum machine_mode return_mode;\n+\n+  return_type = DECL_RESULT (current_function_decl);\n+  return_mode = DECL_MODE (return_type);\n+\n+  id = get_identifier (ACONCAT ((\"__mips16_ret_\",\n+\t\t\t\t mips16_call_stub_mode_suffix (return_mode),\n+\t\t\t\t NULL)));\n+  fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n+  arg = gen_rtx_REG (return_mode, GP_RETURN);\n+  call = gen_call_value_internal (arg, fn, const0_rtx);\n+  insn = emit_call_insn (call);\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg);\n+}\n+\n /* Build a call stub for a mips16 call.  A stub is needed if we are\n    passing any floating point values which should go into the floating\n    point registers.  If we are, and the call turns out to be to a\n@@ -7087,6 +7111,29 @@ mips_finish_declare_object (FILE *stream, tree decl, int top_level, int at_end)\n }\n #endif\n \f\n+/* Return the FOO in the name of the \".mdebug.FOO\" section associated\n+   with the current ABI.  */\n+\n+static const char *\n+mips_mdebug_abi_name (void)\n+{\n+  switch (mips_abi)\n+    {\n+    case ABI_32:\n+      return \"abi32\";\n+    case ABI_O64:\n+      return \"abiO64\";\n+    case ABI_N32:\n+      return \"abiN32\";\n+    case ABI_64:\n+      return \"abiN64\";\n+    case ABI_EABI:\n+      return TARGET_64BIT ? \"eabi64\" : \"eabi32\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Implement TARGET_ASM_FILE_START.  */\n \n static void\n@@ -7103,24 +7150,12 @@ mips_file_start (void)\n \t debug these binaries.  See the function mips_gdbarch_init() in\n \t gdb/mips-tdep.c.  This is unnecessary for the IRIX 5/6 ABIs and\n \t causes unnecessary IRIX 6 ld warnings.  */\n-      const char * abi_string = NULL;\n-\n-      switch (mips_abi)\n-\t{\n-\tcase ABI_32:   abi_string = \"abi32\"; break;\n-\tcase ABI_N32:  abi_string = \"abiN32\"; break;\n-\tcase ABI_64:   abi_string = \"abi64\"; break;\n-\tcase ABI_O64:  abi_string = \"abiO64\"; break;\n-\tcase ABI_EABI: abi_string = TARGET_64BIT ? \"eabi64\" : \"eabi32\"; break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n       /* Note - we use fprintf directly rather than calling switch_to_section\n \t because in this way we can avoid creating an allocated section.  We\n \t do not want this section to take up any space in the running\n \t executable.  */\n       fprintf (asm_out_file, \"\\t.section .mdebug.%s\\n\\t.previous\\n\",\n-\t       abi_string);\n+\t       mips_mdebug_abi_name ());\n \n       /* There is no ELF header flag to distinguish long32 forms of the\n \t EABI from long64 forms.  Emit a special section to help tools\n@@ -8548,29 +8583,7 @@ mips_expand_epilogue (int sibcall_p)\n   /* In mips16 mode, if the return value should go into a floating-point\n      register, we need to call a helper routine to copy it over.  */\n   if (mips16_cfun_returns_in_fpr_p ())\n-    {\n-      char *name;\n-      rtx func;\n-      rtx insn;\n-      rtx retval;\n-      rtx call;\n-      tree id;\n-      tree return_type;\n-      enum machine_mode return_mode;\n-\n-      return_type = DECL_RESULT (current_function_decl);\n-      return_mode = DECL_MODE (return_type);\n-\n-      name = ACONCAT ((\"__mips16_ret_\",\n-\t\t       mips16_call_stub_mode_suffix (return_mode),\n-\t\t       NULL));\n-      id = get_identifier (name);\n-      func = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n-      retval = gen_rtx_REG (return_mode, GP_RETURN);\n-      call = gen_call_value_internal (retval, func, const0_rtx);\n-      insn = emit_call_insn (call);\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), retval);\n-    }\n+    mips16_copy_fpr_return_value ();\n \n   /* Split the frame into two.  STEP1 is the amount of stack we should\n      deallocate before restoring the registers.  STEP2 is the amount we\n@@ -8718,6 +8731,80 @@ mips_can_use_return_insn (void)\n   return cfun->machine->frame.total_size == 0;\n }\n \f\n+/* Return true if register REGNO can store a value of mode MODE.\n+   The result of this function is cached in mips_hard_regno_mode_ok.  */\n+\n+static bool\n+mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n+{\n+  unsigned int size;\n+  enum mode_class class;\n+\n+  if (mode == CCV2mode)\n+    return (ISA_HAS_8CC\n+\t    && ST_REG_P (regno)\n+\t    && (regno - ST_REG_FIRST) % 2 == 0);\n+\n+  if (mode == CCV4mode)\n+    return (ISA_HAS_8CC\n+\t    && ST_REG_P (regno)\n+\t    && (regno - ST_REG_FIRST) % 4 == 0);\n+\n+  if (mode == CCmode)\n+    {\n+      if (!ISA_HAS_8CC)\n+\treturn regno == FPSW_REGNUM;\n+\n+      return (ST_REG_P (regno)\n+\t      || GP_REG_P (regno)\n+\t      || FP_REG_P (regno));\n+    }\n+\n+  size = GET_MODE_SIZE (mode);\n+  class = GET_MODE_CLASS (mode);\n+\n+  if (GP_REG_P (regno))\n+    return ((regno - GP_REG_FIRST) & 1) == 0 || size <= UNITS_PER_WORD;\n+\n+  if (FP_REG_P (regno)\n+      && (((regno - FP_REG_FIRST) % MAX_FPRS_PER_FMT) == 0\n+\t  || (MIN_FPRS_PER_FMT == 1 && size <= UNITS_PER_FPREG)))\n+    {\n+      /* Allow TFmode for CCmode reloads.  */\n+      if (mode == TFmode && ISA_HAS_8CC)\n+\treturn true;\n+\n+      if (class == MODE_FLOAT\n+\t  || class == MODE_COMPLEX_FLOAT\n+\t  || class == MODE_VECTOR_FLOAT)\n+\treturn size <= UNITS_PER_FPVALUE;\n+\n+      /* Allow integer modes that fit into a single register.  We need\n+\t to put integers into FPRs when using instructions like CVT\n+\t and TRUNC.  There's no point allowing sizes smaller than a word,\n+\t because the FPU has no appropriate load/store instructions.  */\n+      if (class == MODE_INT)\n+\treturn size >= MIN_UNITS_PER_WORD && size <= UNITS_PER_FPREG;\n+    }\n+\n+  if (ACC_REG_P (regno)\n+      && (INTEGRAL_MODE_P (mode) || ALL_FIXED_POINT_MODE_P (mode)))\n+    {\n+      if (size <= UNITS_PER_WORD)\n+\treturn true;\n+\n+      if (size <= UNITS_PER_WORD * 2)\n+\treturn (DSP_ACC_REG_P (regno)\n+\t\t? ((regno - DSP_ACC_REG_FIRST) & 1) == 0\n+\t\t: regno == MD_REG_FIRST);\n+    }\n+\n+  if (ALL_COP_REG_P (regno))\n+    return class == MODE_INT && size <= UNITS_PER_WORD;\n+\n+  return false;\n+}\n+\n /* Implement HARD_REGNO_NREGS.  The size of FP registers is controlled\n    by UNITS_PER_FPREG.  The size of FP status registers is always 4, because\n    they only hold condition code modes, and CCmode is always considered to\n@@ -10525,18 +10612,50 @@ mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)\n \t\t\t\t       const1_rtx, const0_rtx);\n }\n \n+/* EXP is a CALL_EXPR that calls the function described by BDESC.\n+   Expand the call and return an rtx for its return value.\n+   TARGET, if nonnull, suggests a good place to put this value.  */\n+\n+static rtx\n+mips_expand_builtin_1 (const struct builtin_description *bdesc,\n+\t\t       tree exp, rtx target)\n+{\n+  switch (bdesc->builtin_type)\n+    {\n+    case MIPS_BUILTIN_DIRECT:\n+      return mips_expand_builtin_direct (bdesc->icode, target, exp, true);\n+\n+    case MIPS_BUILTIN_DIRECT_NO_TARGET:\n+      return mips_expand_builtin_direct (bdesc->icode, target, exp, false);\n+\n+    case MIPS_BUILTIN_MOVT:\n+    case MIPS_BUILTIN_MOVF:\n+      return mips_expand_builtin_movtf (bdesc->builtin_type, bdesc->icode,\n+\t\t\t\t\tbdesc->cond, target, exp);\n+\n+    case MIPS_BUILTIN_CMP_ANY:\n+    case MIPS_BUILTIN_CMP_ALL:\n+    case MIPS_BUILTIN_CMP_UPPER:\n+    case MIPS_BUILTIN_CMP_LOWER:\n+    case MIPS_BUILTIN_CMP_SINGLE:\n+      return mips_expand_builtin_compare (bdesc->builtin_type, bdesc->icode,\n+\t\t\t\t\t  bdesc->cond, target, exp);\n+\n+    case MIPS_BUILTIN_BPOSGE32:\n+      return mips_expand_builtin_bposge (bdesc->builtin_type, target);\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Expand builtin functions.  This is called from TARGET_EXPAND_BUILTIN.  */\n \n static rtx\n mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n-  enum insn_code icode;\n-  enum mips_builtin_type type;\n   tree fndecl;\n   unsigned int fcode;\n-  const struct builtin_description *bdesc;\n   const struct bdesc_map *m;\n \n   fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -10549,48 +10668,13 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return const0_rtx;\n     }\n \n-  bdesc = NULL;\n   for (m = bdesc_arrays; m < &bdesc_arrays[ARRAY_SIZE (bdesc_arrays)]; m++)\n     {\n       if (fcode < m->size)\n-\t{\n-\t  bdesc = m->bdesc;\n-\t  icode = bdesc[fcode].icode;\n-\t  type = bdesc[fcode].builtin_type;\n-\t  break;\n-\t}\n+\treturn mips_expand_builtin_1 (m->bdesc + fcode, exp, target);\n       fcode -= m->size;\n     }\n-  if (bdesc == NULL)\n-    return 0;\n-\n-  switch (type)\n-    {\n-    case MIPS_BUILTIN_DIRECT:\n-      return mips_expand_builtin_direct (icode, target, exp, true);\n-\n-    case MIPS_BUILTIN_DIRECT_NO_TARGET:\n-      return mips_expand_builtin_direct (icode, target, exp, false);\n-\n-    case MIPS_BUILTIN_MOVT:\n-    case MIPS_BUILTIN_MOVF:\n-      return mips_expand_builtin_movtf (type, icode, bdesc[fcode].cond,\n-\t\t\t\t\ttarget, exp);\n-\n-    case MIPS_BUILTIN_CMP_ANY:\n-    case MIPS_BUILTIN_CMP_ALL:\n-    case MIPS_BUILTIN_CMP_UPPER:\n-    case MIPS_BUILTIN_CMP_LOWER:\n-    case MIPS_BUILTIN_CMP_SINGLE:\n-      return mips_expand_builtin_compare (type, icode, bdesc[fcode].cond,\n-\t\t\t\t\t  target, exp);\n-\n-    case MIPS_BUILTIN_BPOSGE32:\n-      return mips_expand_builtin_bposge (type, target);\n-\n-    default:\n-      return 0;\n-    }\n+  gcc_unreachable ();\n }\n \f\n /* An entry in the mips16 constant pool.  VALUE is the pool constant,\n@@ -12071,76 +12155,11 @@ override_options (void)\n       mips_dwarf_regno[i + TARGET_BIG_ENDIAN] = i + 1;\n     }\n \n-  /* Set up array giving whether a given register can hold a given mode.  */\n-\n-  for (mode = VOIDmode;\n-       mode != MAX_MACHINE_MODE;\n-       mode = (enum machine_mode) ((int)mode + 1))\n-    {\n-      register int size\t\t     = GET_MODE_SIZE (mode);\n-      register enum mode_class class = GET_MODE_CLASS (mode);\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t{\n-\t  register int temp;\n-\n-\t  if (mode == CCV2mode)\n-\t    temp = (ISA_HAS_8CC\n-\t\t    && ST_REG_P (regno)\n-\t\t    && (regno - ST_REG_FIRST) % 2 == 0);\n-\n-\t  else if (mode == CCV4mode)\n-\t    temp = (ISA_HAS_8CC\n-\t\t    && ST_REG_P (regno)\n-\t\t    && (regno - ST_REG_FIRST) % 4 == 0);\n-\n-\t  else if (mode == CCmode)\n-\t    {\n-\t      if (! ISA_HAS_8CC)\n-\t\ttemp = (regno == FPSW_REGNUM);\n-\t      else\n-\t\ttemp = (ST_REG_P (regno) || GP_REG_P (regno)\n-\t\t\t|| FP_REG_P (regno));\n-\t    }\n-\n-\t  else if (GP_REG_P (regno))\n-\t    temp = ((regno & 1) == 0 || size <= UNITS_PER_WORD);\n-\n-\t  else if (FP_REG_P (regno))\n-\t    temp = ((((regno % MAX_FPRS_PER_FMT) == 0)\n-\t\t     || (MIN_FPRS_PER_FMT == 1\n-\t\t\t && size <= UNITS_PER_FPREG))\n-\t\t    && (((class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT\n-\t\t\t  || class == MODE_VECTOR_FLOAT)\n-\t\t\t && size <= UNITS_PER_FPVALUE)\n-\t\t\t/* Allow integer modes that fit into a single\n-\t\t\t   register.  We need to put integers into FPRs\n-\t\t\t   when using instructions like cvt and trunc.\n-\t\t\t   We can't allow sizes smaller than a word,\n-\t\t\t   the FPU has no appropriate load/store\n-\t\t\t   instructions for those.  */\n-\t\t\t|| (class == MODE_INT\n-\t\t\t    && size >= MIN_UNITS_PER_WORD\n-\t\t\t    && size <= UNITS_PER_FPREG)\n-\t\t\t/* Allow TFmode for CCmode reloads.  */\n-\t\t\t|| (ISA_HAS_8CC && mode == TFmode)));\n-\n-          else if (ACC_REG_P (regno))\n-\t    temp = ((INTEGRAL_MODE_P (mode) || ALL_FIXED_POINT_MODE_P (mode))\n-\t\t    && size <= UNITS_PER_WORD * 2\n-\t\t    && (size <= UNITS_PER_WORD\n-\t\t\t|| regno == MD_REG_FIRST\n-\t\t\t|| (DSP_ACC_REG_P (regno)\n-\t\t\t    && ((regno - DSP_ACC_REG_FIRST) & 1) == 0)));\n-\n-\t  else if (ALL_COP_REG_P (regno))\n-\t    temp = (class == MODE_INT && size <= UNITS_PER_WORD);\n-\t  else\n-\t    temp = 0;\n-\n-\t  mips_hard_regno_mode_ok[(int)mode][regno] = temp;\n-\t}\n-    }\n+  /* Set up mips_hard_regno_mode_ok.  */\n+  for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n+    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+      mips_hard_regno_mode_ok[(int)mode][regno]\n+\t= mips_hard_regno_mode_ok_p (regno, mode);\n \n   /* Save GPR registers in word_mode sized hunks.  word_mode hasn't been\n      initialized yet, so we can't use that here.  */"}]}