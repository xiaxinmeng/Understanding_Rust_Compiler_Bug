{"sha": "9ac1504be01a543e183091558f1b146a0d7ee25a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFjMTUwNGJlMDFhNTQzZTE4MzA5MTU1OGYxYjE0NmEwZDdlZTI1YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2012-02-10T18:37:18Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2012-02-10T18:37:18Z"}, "message": "re PR c/52190 (question about atomic intrinsics -- test and documentation vary -- please clarify)\n\n\n2012-02-10  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR c/52190\n\t* doc/extend.texi : Update comments for __atomic_compare_exchange and\n\t__atomic_{is,always}_lock_free.\n\nFrom-SVN: r184112", "tree": {"sha": "c56b1419ca20bae69d8b297f4dcf8e9310ee9e06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c56b1419ca20bae69d8b297f4dcf8e9310ee9e06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ac1504be01a543e183091558f1b146a0d7ee25a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac1504be01a543e183091558f1b146a0d7ee25a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ac1504be01a543e183091558f1b146a0d7ee25a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac1504be01a543e183091558f1b146a0d7ee25a/comments", "author": null, "committer": null, "parents": [{"sha": "877fb4507b254f536cbe3aa19e346092e0bf2661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/877fb4507b254f536cbe3aa19e346092e0bf2661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/877fb4507b254f536cbe3aa19e346092e0bf2661"}], "stats": {"total": 32, "additions": 23, "deletions": 9}, "files": [{"sha": "9fce97131e06337183df0c22e88a2d503199d126", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac1504be01a543e183091558f1b146a0d7ee25a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac1504be01a543e183091558f1b146a0d7ee25a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ac1504be01a543e183091558f1b146a0d7ee25a", "patch": "@@ -1,3 +1,9 @@\n+2012-02-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR c/52190\n+\t* doc/extend.texi : Update comments for __atomic_compare_exchange and\n+\t__atomic_{is,always}_lock_free.\n+\n 2012-02-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/52146"}, {"sha": "a131c918d3e70a7a2fd01ece7d4782efeef39bde", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac1504be01a543e183091558f1b146a0d7ee25a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac1504be01a543e183091558f1b146a0d7ee25a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=9ac1504be01a543e183091558f1b146a0d7ee25a", "patch": "@@ -7146,7 +7146,10 @@ This built-in function implements an atomic compare and exchange operation.\n This compares the contents of @code{*@var{ptr}} with the contents of\n @code{*@var{expected}} and if equal, writes @var{desired} into\n @code{*@var{ptr}}.  If they are not equal, the current contents of\n-@code{*@var{ptr}} is written into @code{*@var{expected}}.\n+@code{*@var{ptr}} is written into @code{*@var{expected}}.  @var{weak} is true\n+for weak compare_exchange, and false for the strong variation.  Many targets \n+only offer the strong variation and ignore the parameter.  When in doubt, use\n+the strong variation.\n \n True is returned if @code{*@var{desired}} is written into\n @code{*@var{ptr}} and the execution is considered to conform to the\n@@ -7242,27 +7245,32 @@ All memory orders are valid.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size)\n+@deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size,  void *ptr)\n \n-This built-in function returns true if objects of size bytes will always\n-generate lock free atomic instructions for the target architecture.\n-Otherwise false is returned.\n+This built-in function returns true if objects of @var{size} bytes will always\n+generate lock free atomic instructions for the target architecture.  \n+@var{size} must resolve to a compile time constant and the result also resolves to compile time constant.\n \n-size must resolve to a compile time constant.\n+@var{ptr} is an optional pointer to the object which may be used to determine\n+alignment.  A value of 0 indicates typical alignment should be used.  The \n+compiler may also ignore this parameter.\n \n @smallexample\n-if (_atomic_always_lock_free (sizeof (long long)))\n+if (_atomic_always_lock_free (sizeof (long long), 0))\n @end smallexample\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size)\n+@deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size, void *ptr)\n \n-This built-in function returns true if objects of size bytes will always\n+This built-in function returns true if objects of @var{size} bytes will always\n generate lock free atomic instructions for the target architecture.  If\n it is not known to be lock free a call is made to a runtime routine named\n @code{__atomic_is_lock_free}.\n \n+@var{ptr} is an optional pointer to the object which may be used to determine\n+alignment.  A value of 0 indicates typical alignment should be used.  The \n+compiler may also ignore this parameter.\n @end deftypefn\n \n @node Object Size Checking"}]}