{"sha": "fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQyMTU3Y2UwOTI4YTliMGZkODkxODJiMTExYWYxYzZiYjk5NDBhYg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-05-29T09:03:03Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-05-29T09:03:03Z"}, "message": "gfortran.h (gfc_generic_isym_id): Add GFC_ISYM_SIZEOF.\n\n2007-05-28  Tobias Schlter  <tobi@gcc.gnu.org>\nfortran/\n* gfortran.h (gfc_generic_isym_id): Add GFC_ISYM_SIZEOF.\n* intrinsic.c (add_functions): Add stuff for SIZEOF intrinsic.\n* intrinsic.h (gfc_check_sizeof): Add prototype of ...\n* check.c (gfc_check_sizeof): .. new function.\n* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): New function.\n(gfc_conv_intrinsic_strcmp): Whitespace fix.\n(gfc_conv_intrinsic_array_transfer): Remove double initialization,\nuse fold_build. where appropriate.\n(gfc_conv_intrinsic_function): Add case for SIZEOF.\n* intrinsic.texi: Add documentation for SIZEOF.\ntestsuite/\n* gfortran.dg/sizeof.f90: New.\n\nFrom-SVN: r125161", "tree": {"sha": "8e4549612e4d823845bf8d6edcfa17ce896c8947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e4549612e4d823845bf8d6edcfa17ce896c8947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bd196f0e35062d309320673f46722e47744b610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bd196f0e35062d309320673f46722e47744b610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bd196f0e35062d309320673f46722e47744b610"}], "stats": {"total": 286, "additions": 261, "deletions": 25}, "files": [{"sha": "65dfa5f5b965b5315a0b05a37d169334fe182e11", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -1,3 +1,16 @@\n+2007-05-28  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\t* gfortran.h (gfc_generic_isym_id): Add GFC_ISYM_SIZEOF.\n+\t* intrinsic.c (add_functions): Add stuff for SIZEOF intrinsic.\n+\t* intrinsic.h (gfc_check_sizeof): Add prototype of ...\n+\t* check.c (gfc_check_sizeof): .. new function.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): New function.\n+\t(gfc_conv_intrinsic_strcmp): Whitespace fix.\n+\t(gfc_conv_intrinsic_array_transfer): Remove double initialization,\n+\tuse fold_build. where appropriate.\n+\t(gfc_conv_intrinsic_function): Add case for SIZEOF.\n+\t* intrinsic.texi: Add documentation for SIZEOF.\n+\n 2007-05-28  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* trans-array.c (gfc_conv_expr_descriptor): Edit comment."}, {"sha": "a1966353f3000fbc8dd5d05df6ced1c3997b38ac", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -2333,6 +2333,13 @@ gfc_check_size (gfc_expr *array, gfc_expr *dim)\n }\n \n \n+try\n+gfc_check_sizeof (gfc_expr *arg __attribute__((unused)))\n+{\n+  return SUCCESS;\n+}\n+\n+\n try\n gfc_check_sleep_sub (gfc_expr *seconds)\n {"}, {"sha": "e64a99577584e104a1e4ea2b0fbac7ac96e74f92", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -446,6 +446,7 @@ enum gfc_generic_isym_id\n   GFC_ISYM_SIN,\n   GFC_ISYM_SINH,\n   GFC_ISYM_SIZE,\n+  GFC_ISYM_SIZEOF,\n   GFC_ISYM_SPACING,\n   GFC_ISYM_SPREAD,\n   GFC_ISYM_SQRT,"}, {"sha": "3a72fc5caaa9a3d2012099995769771716993b50", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -2138,6 +2138,12 @@ add_functions (void)\n \n   make_generic (\"size\", GFC_ISYM_SIZE, GFC_STD_F95);\n \n+  add_sym_1 (\"sizeof\", NOT_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di,\n+\t     GFC_STD_GNU, gfc_check_sizeof, NULL, NULL,\n+\t     i, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"sizeof\", GFC_ISYM_SIZEOF, GFC_STD_GNU);\t     \n+\n   add_sym_1 (\"spacing\", ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t     gfc_check_x, gfc_simplify_spacing, gfc_resolve_spacing,\n \t     x, BT_REAL, dr, REQUIRED);"}, {"sha": "5bc4a855971d9752bd168fc16937b006e2a6eed6", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -121,6 +121,7 @@ try gfc_check_shape (gfc_expr *);\n try gfc_check_size (gfc_expr *, gfc_expr *);\n try gfc_check_sign (gfc_expr *, gfc_expr *);\n try gfc_check_signal (gfc_expr *, gfc_expr *);\n+try gfc_check_sizeof (gfc_expr *);\n try gfc_check_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_srand (gfc_expr *);\n try gfc_check_stat (gfc_expr *, gfc_expr *);"}, {"sha": "aea18b1dc343aa023b84e42324e78b9272512901", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -222,6 +222,7 @@ Some basic guidelines for editing this document:\n * @code{SIN}:           SIN,       Sine function\n * @code{SINH}:          SINH,      Hyperbolic sine function\n * @code{SIZE}:          SIZE,      Function to determine the size of an array\n+* @code{SIZEOF}:        SIZEOF,    Determine the size in bytes of an expression\n * @code{SLEEP}:         SLEEP,     Sleep for the specified number of seconds\n * @code{SNGL}:          SNGL,      Convert double precision real to default real\n * @code{SPACING}:       SPACING,   Smallest distance between two numbers of a given type\n@@ -9012,6 +9013,49 @@ END PROGRAM\n @end table\n \n \n+@node SIZEOF\n+@section @code{SIZEOF} --- Size in bytes of an expression\n+@fnindex SIZEOF\n+@cindex expression size\n+@cindex size of an expression\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{SIZEOF(X)} calculates the number of bytes of storage the\n+expression @code{X} occupies.\n+\n+@item @emph{Standard}:\n+GNU extension\n+\n+@item @emph{Class}:\n+Intrinsic function\n+\n+@item @emph{Syntax}:\n+@code{N = SIZEOF(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The argument shall be of any type, rank or shape.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type integer.  Its value is the number of bytes\n+occupied by the argument.  If the argument has the @code{POINTER}\n+attribute, the number of bytes of the storage area pointed to is\n+returned.  If the argument is of a derived type with @code{POINTER} or\n+@code{ALLOCATABLE} components, the return value doesn't account for\n+the sizes of the data pointed to by these components.\n+\n+@item @emph{Example}:\n+@smallexample\n+   integer :: i\n+   real :: r, s(5)\n+   print *, (sizeof(s)/sizeof(r) == 5)\n+   end\n+@end smallexample\n+The example will print @code{.TRUE.} unless you are using a platform\n+where default @code{REAL} variables are unusually padded.\n+@end table\n \n @node SLEEP\n @section @code{SLEEP} --- Sleep for the specified number of seconds"}, {"sha": "4745a78f41cc538926c0a9a2257d220b98d0895b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 103, "deletions": 25, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -2745,9 +2745,83 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n }\n \n \n+static void\n+gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n+{\n+  gfc_expr *arg;\n+  gfc_ss *ss;\n+  gfc_se argse;\n+  tree source;\n+  tree source_bytes;\n+  tree type;\n+  tree tmp;\n+  tree lower;\n+  tree upper;\n+  /*tree stride;*/\n+  int n;\n+\n+  arg = expr->value.function.actual->expr;\n+\n+  gfc_init_se (&argse, NULL);\n+  ss = gfc_walk_expr (arg);\n+\n+  source_bytes = gfc_create_var (gfc_array_index_type, \"bytes\");\n+\n+  if (ss == gfc_ss_terminator)\n+    {\n+      gfc_conv_expr_reference (&argse, arg);\n+      source = argse.expr;\n+\n+      type = TREE_TYPE (build_fold_indirect_ref (argse.expr));\n+\n+      /* Obtain the source word length.  */\n+      if (arg->ts.type == BT_CHARACTER)\n+\tsource_bytes = fold_convert (gfc_array_index_type,\n+\t\t\t\t     argse.string_length);\n+      else\n+\tsource_bytes = fold_convert (gfc_array_index_type,\n+\t\t\t\t     size_in_bytes (type)); \n+    }\n+  else\n+    {\n+      argse.want_pointer = 0;\n+      gfc_conv_expr_descriptor (&argse, arg, ss);\n+      source = gfc_conv_descriptor_data_get (argse.expr);\n+      type = gfc_get_element_type (TREE_TYPE (argse.expr));\n+\n+      /* Obtain the argument's word length.  */\n+      if (arg->ts.type == BT_CHARACTER)\n+\ttmp = fold_convert (gfc_array_index_type, argse.string_length);\n+      else\n+\ttmp = fold_convert (gfc_array_index_type,\n+\t\t\t    size_in_bytes (type)); \n+      gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+\n+      /* Obtain the size of the array in bytes.  */\n+      for (n = 0; n < arg->rank; n++)\n+\t{\n+\t  tree idx;\n+\t  idx = gfc_rank_cst[n];\n+\t  lower = gfc_conv_descriptor_lbound (argse.expr, idx);\n+\t  upper = gfc_conv_descriptor_ubound (argse.expr, idx);\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     upper, lower);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, source_bytes);\n+\t  gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+\t}\n+    }\n+\n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  se->expr = source_bytes;\n+}\n+\n+\n /* Intrinsic string comparison functions.  */\n \n-  static void\n+static void\n gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n {\n   tree type;\n@@ -2850,7 +2924,6 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n     }\n   else\n     {\n-      gfc_init_se (&argse, NULL);\n       argse.want_pointer = 0;\n       gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n       source = gfc_conv_descriptor_data_get (argse.expr);\n@@ -2898,13 +2971,13 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t  stride = gfc_conv_descriptor_stride (argse.expr, idx);\n \t  lower = gfc_conv_descriptor_lbound (argse.expr, idx);\n \t  upper = gfc_conv_descriptor_ubound (argse.expr, idx);\n-\t  tmp = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\tupper, lower);\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     upper, lower);\n \t  gfc_add_modify_expr (&argse.pre, extent, tmp);\n-\t  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\textent, gfc_index_one_node);\n-\t  tmp = build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\ttmp, source_bytes);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     extent, gfc_index_one_node);\n+\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, source_bytes);\n \t}\n     }\n \n@@ -2964,17 +3037,18 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   size_bytes = gfc_create_var (gfc_array_index_type, NULL);\n   if (tmp != NULL_TREE)\n     {\n-      tmp = build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t    tmp, dest_word_len);\n-      tmp = build2 (MIN_EXPR, gfc_array_index_type, tmp, source_bytes);\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t tmp, dest_word_len);\n+      tmp = fold_build2 (MIN_EXPR, gfc_array_index_type,\n+\t\t\t tmp, source_bytes);\n     }\n   else\n     tmp = source_bytes;\n \n   gfc_add_modify_expr (&se->pre, size_bytes, tmp);\n   gfc_add_modify_expr (&se->pre, size_words,\n-\t\t       build2 (CEIL_DIV_EXPR, gfc_array_index_type,\n-\t\t\t       size_bytes, dest_word_len));\n+\t\t       fold_build2 (CEIL_DIV_EXPR, gfc_array_index_type,\n+\t\t\t\t    size_bytes, dest_word_len));\n \n   /* Evaluate the bounds of the result.  If the loop range exists, we have\n      to check if it is too large.  If so, we modify loop->to be consistent\n@@ -2985,23 +3059,23 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n     {\n       tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t se->loop->to[n], se->loop->from[n]);\n-      tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t    tmp, gfc_index_one_node);\n-      tmp = build2 (MIN_EXPR, gfc_array_index_type,\n-\t\t    tmp, size_words);\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t tmp, gfc_index_one_node);\n+      tmp = fold_build2 (MIN_EXPR, gfc_array_index_type,\n+\t\t\t tmp, size_words);\n       gfc_add_modify_expr (&se->pre, size_words, tmp);\n       gfc_add_modify_expr (&se->pre, size_bytes,\n-\t\t\t   build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t   size_words, dest_word_len));\n-      upper = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t      size_words, se->loop->from[n]);\n-      upper = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t      upper, gfc_index_one_node);\n+\t\t\t   fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t\tsize_words, dest_word_len));\n+      upper = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t   size_words, se->loop->from[n]);\n+      upper = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t   upper, gfc_index_one_node);\n     }\n   else\n     {\n-      upper = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t      size_words, gfc_index_one_node);\n+      upper = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t   size_words, gfc_index_one_node);\n       se->loop->from[n] = gfc_index_zero_node;\n     }\n \n@@ -3866,6 +3940,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_size (se, expr);\n       break;\n \n+    case GFC_ISYM_SIZEOF:\n+      gfc_conv_intrinsic_sizeof (se, expr);\n+      break;\n+\n     case GFC_ISYM_SUM:\n       gfc_conv_intrinsic_arith (se, expr, PLUS_EXPR);\n       break;"}, {"sha": "696a47840dea3c98cac1ce00c497a58c31447f69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -1,3 +1,7 @@\n+2007-05-29  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\t* gfortran.dg/sizeof.f90: New.\n+\n 2007-05-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR c/31339"}, {"sha": "35ea527ed0dff1dff9c2186a10e261350a5623c0", "filename": "gcc/testsuite/gfortran.dg/sizeof.f90", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fsizeof.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2157ce0928a9b0fd89182b111af1c6bb9940ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fsizeof.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsizeof.f90?ref=fd2157ce0928a9b0fd89182b111af1c6bb9940ab", "patch": "@@ -0,0 +1,82 @@\n+! { dg-do run }\n+! Verify that the sizeof intrinsic does as advertised\n+subroutine check_int (j)\n+  INTEGER(4) :: i, ia(5), ib(5,4), ip, ipa(:)\n+  target :: ib\n+  POINTER :: ip, ipa\n+  logical :: l(6)\n+  integer(8) :: jb(5,4)\n+\n+  if (sizeof (j) /= sizeof (i)) call abort\n+  if (sizeof (jb) /= 2*sizeof (ib)) call abort\n+\n+  ipa=>ib(2:3,1)\n+\n+  l = (/ sizeof(i) == 4, sizeof(ia) == 20, sizeof(ib) == 80, &\n+       sizeof(ip) == 4, sizeof(ipa) == 8, sizeof(ib(1:5:2,3)) == 12 /)\n+\n+  if (any(.not.l)) call abort\n+  if (sizeof(l) /= 6*sizeof(l(1))) call abort\n+end subroutine check_int\n+\n+subroutine check_real (x, y)\n+  dimension y(5)\n+  real(4) :: r(20,20,20), rp(:,:)\n+  target :: r\n+  pointer :: rp\n+  double precision :: d(5,5)\n+  complex :: c(5)\n+  \n+  if (sizeof (y) /= 5*sizeof (x)) call abort\n+\n+  if (sizeof (r) /= 8000*4) call abort\n+  rp => r(5,2:10,1:5)\n+  if (sizeof (rp) /= 45*4) call abort\n+  rp => r(1:5,1:5,1)\n+  if (sizeof (d) /= 2*sizeof (rp)) call abort\n+  if (sizeof (c(1)) /= 2*sizeof(r(1,1,1))) call abort\n+end subroutine check_real\n+\n+subroutine check_derived ()\n+  type dt\n+     integer i\n+  end type dt\n+  type (dt) :: a\n+  integer :: i\n+  type foo\n+     integer :: i(5000)\n+     real :: j(5)\n+     type(dt) :: d\n+  end type foo\n+  type bar\n+     integer :: j(5000)\n+     real :: k(5)\n+     type(dt) :: d\n+  end type bar\n+  type (foo) :: oof\n+  type (bar) :: rab\n+  integer(8) :: size_500, size_200, sizev500, sizev200\n+  type all\n+     real, allocatable :: r(:)\n+  end type all\n+  real :: r(200), s(500)\n+  type(all) :: v\n+\n+  if (sizeof(a) /= sizeof(i)) call abort\n+  if (sizeof(oof) /= sizeof(rab)) call abort\n+  allocate (v%r(500))\n+  sizev500 = sizeof (v)\n+  size_500 = sizeof (v%r)\n+  deallocate (v%r)\n+  allocate (v%r(200))\n+  sizev200 = sizeof (v)\n+  size_200 = sizeof (v%r)\n+  deallocate (v%r)\n+  if (size_500 - size_200 /= sizeof(s) - sizeof(r) .or. sizev500 /= sizev200) &\n+       call abort\n+end subroutine check_derived\n+\n+call check_int ()\n+call check_real ()\n+call check_derived ()\n+end"}]}