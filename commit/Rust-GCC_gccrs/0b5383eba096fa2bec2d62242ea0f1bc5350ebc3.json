{"sha": "0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1MzgzZWJhMDk2ZmEyYmVjMmQ2MjI0MmVhMGYxYmM1MzUwZWJjMw==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2005-03-01T02:56:35Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2005-03-01T02:56:35Z"}, "message": "Rewrite of 64-bit Darwin structure-by-value pass/return.\n\n2005-02-28  Dale Johannesen  <dalej@apple.com>\n            Stan Shebs  <shebs@apple.com>\n\n        Rewrite of 64-bit Darwin structure-by-value pass/return.\n        * config/rs6000/rs6000.h (CUMULATIVE_ARGS): New fields\n        intoffset, use_stack, named.\n        * config/rs6000/rs6000.c (rs6000_darwin64_function_arg):  Remove.\n        (rs6000_darwin64_record_arg_advance_flush):  New.\n        (rs6000_darwin64_record_arg_advance_recurse): New.\n        (rs6000_darwin64_record_arg_flush):  New.\n        (rs6000_darwin64_record_arg_recurse):  New.\n        (rs6000_darwin64_record_arg):  New.\n        (rs6000_return_in_memory):  Remove AGGREGATE_TYPE_P check.\n        (function_arg_boundary):  Handle 128-bit aligned structs.\n        (function_arg_advance):  Rewrite darwin64 struct handling.\n        (function_arg):  Call rs6000_darwin64_record_arg.\n        (function_arg_partial_nregs):  Handle darwin64 structs.\n        (rs6000_darwin64_function_value):  Remove.\n        (rs6000_function_value):  Call rs6000_darwin64_record_arg.\n\nCo-Authored-By: Stan Shebs <shebs@apple.com>\n\nFrom-SVN: r95723", "tree": {"sha": "46b25cc4e0cf6fdd8d58b935495c31cf0e99bfff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46b25cc4e0cf6fdd8d58b935495c31cf0e99bfff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/comments", "author": null, "committer": null, "parents": [{"sha": "1a9dddada346b812bafc8918d082c993c7f0a82d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a9dddada346b812bafc8918d082c993c7f0a82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a9dddada346b812bafc8918d082c993c7f0a82d"}], "stats": {"total": 626, "additions": 332, "deletions": 294}, "files": [{"sha": "18a3070fff6bd982ab1e3b09f889b0e458362ec9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "patch": "@@ -1,3 +1,23 @@\n+2005-02-28  Dale Johannesen  <dalej@apple.com>\n+\t    Stan Shebs  <shebs@apple.com>\n+\n+\tRewrite of 64-bit Darwin structure-by-value pass/return.\n+\t* config/rs6000/rs6000.h (CUMULATIVE_ARGS): New fields\n+\tintoffset, use_stack, named.\n+\t* config/rs6000/rs6000.c (rs6000_darwin64_function_arg):  Remove.\n+\t(rs6000_darwin64_record_arg_advance_flush):  New.\n+\t(rs6000_darwin64_record_arg_advance_recurse): New.\n+\t(rs6000_darwin64_record_arg_flush):  New.\n+\t(rs6000_darwin64_record_arg_recurse):  New.\n+\t(rs6000_darwin64_record_arg):  New.\n+\t(rs6000_return_in_memory):  Remove AGGREGATE_TYPE_P check.\n+\t(function_arg_boundary):  Handle 128-bit aligned structs.\n+\t(function_arg_advance):  Rewrite darwin64 struct handling.\n+\t(function_arg):  Call rs6000_darwin64_record_arg.\n+\t(function_arg_partial_nregs):  Handle darwin64 structs.\n+\t(rs6000_darwin64_function_value):  Remove.\n+\t(rs6000_function_value):  Call rs6000_darwin64_record_arg.\n+\n 2005-02-28  Roger Sayle  <roger@eyesopen.com>\n \n \tPR tree-optimization/20216"}, {"sha": "ff6d09d3ba03735c94b559081ad481c245d1c34e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 309, "deletions": 294, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "patch": "@@ -737,8 +737,17 @@ static int rs6000_get_some_local_dynamic_name_1 (rtx *, void *);\n static rtx rs6000_complex_function_value (enum machine_mode);\n static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree);\n-static rtx rs6000_darwin64_function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t\t enum machine_mode, tree, int);\n+static void rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t      HOST_WIDE_INT);\n+static void rs6000_darwin64_record_arg_advance_recurse (CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t\ttree, HOST_WIDE_INT);\n+static void rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *,\n+\t\t\t\t\t      HOST_WIDE_INT,\n+\t\t\t\t\t      rtx[], int *);\n+static void rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *,\n+\t\t\t\t\t       tree, HOST_WIDE_INT,\n+\t\t\t\t\t       rtx[], int *);\n+static rtx rs6000_darwin64_record_arg (CUMULATIVE_ARGS *, tree, int, bool);\n static rtx rs6000_mixed_function_arg (enum machine_mode, tree, int);\n static void rs6000_move_block_from_reg (int regno, rtx x, int nregs);\n static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n@@ -3833,12 +3842,23 @@ rs6000_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n {\n   /* In the darwin64 abi, try to use registers for larger structs\n      if possible.  */\n-  if (AGGREGATE_TYPE_P (type)\n-      && rs6000_darwin64_abi\n+  if (rs6000_darwin64_abi\n       && TREE_CODE (type) == RECORD_TYPE\n-      && ((unsigned HOST_WIDE_INT) int_size_in_bytes (type) <= 32)\n-      && ((unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 0))\n-    return false;\n+      && int_size_in_bytes (type) > 0)\n+    {\n+      CUMULATIVE_ARGS valcum;\n+      rtx valret;\n+\n+      valcum.words = 0;\n+      valcum.fregno = FP_ARG_MIN_REG;\n+      valcum.vregno = ALTIVEC_ARG_MIN_REG;\n+      /* Do a trial code generation as if this were going to be passed\n+\t as an argument; if any part goes in memory, we return NULL.  */\n+      valret = rs6000_darwin64_record_arg (&valcum, type, 1, true);\n+      if (valret)\n+\treturn false;\n+      /* Otherwise fall through to more conventional ABI rules.  */\n+    }\n \n   if (AGGREGATE_TYPE_P (type)\n       && (TARGET_AIX_STRUCT_RET\n@@ -4029,6 +4049,9 @@ function_arg_boundary (enum machine_mode mode, tree type)\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n \t       && int_size_in_bytes (type) >= 16))\n     return 128;\n+  else if (rs6000_darwin64_abi && mode == BLKmode\n+\t   && type && TYPE_ALIGN (type) > 64)\n+    return 128;\n   else\n     return PARM_BOUNDARY;\n }\n@@ -4051,46 +4074,84 @@ rs6000_arg_size (enum machine_mode mode, tree type)\n     return (size + 7) >> 3;\n }\n \f\n-/* The darwin64 ABI calls for us to recurse down through structs,\n-   applying the same rules to struct elements as if a reference to\n-   each were being passed directly.  */\n+/* Use this to flush pending int fields.  */\n \n static void\n-darwin64_function_arg_advance (CUMULATIVE_ARGS *cum, tree type,\n-\t\t\t       int named, int depth)\n+rs6000_darwin64_record_arg_advance_flush (CUMULATIVE_ARGS *cum,\n+\t\t\t\t\t  HOST_WIDE_INT bitpos)\n {\n-  tree f, ftype;\n-  int i, tot;\n+  unsigned int startbit, endbit;\n+  int intregs, intoffset;\n+  enum machine_mode mode;\n \n-  switch (TREE_CODE (type))\n-    {\n-    case RECORD_TYPE:\n-      for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n-\tif (TREE_CODE (f) == FIELD_DECL)\n-\t  {\n-\t    ftype = TREE_TYPE (f);\n-\t    function_arg_advance (cum, TYPE_MODE (ftype), ftype,\n-\t\t\t\t  named, depth + 1);\n-\t  }\n-      break;\n+  if (cum->intoffset == -1)\n+    return;\n \n-    case ARRAY_TYPE:\n-      tot = int_size_in_bytes (type);\n-      if (tot <= 0)\n-\treturn;\n-      ftype = TREE_TYPE (type);\n-      tot /= int_size_in_bytes (ftype);\n-      \n-      for (i = 0; i < tot; ++i)\n+  intoffset = cum->intoffset;\n+  cum->intoffset = -1;\n+\n+  if (intoffset % BITS_PER_WORD != 0)\n+    {\n+      mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n+\t\t\t    MODE_INT, 0);\n+      if (mode == BLKmode)\n \t{\n-\t  function_arg_advance (cum, TYPE_MODE (ftype), ftype,\n-\t\t\t\tnamed, depth + 1);\n+\t  /* We couldn't find an appropriate mode, which happens,\n+\t     e.g., in packed structs when there are 3 bytes to load.\n+\t     Back intoffset back to the beginning of the word in this\n+\t     case.  */\n+\t  intoffset = intoffset & -BITS_PER_WORD;\n \t}\n-      break;\n-\n-    default:\n-      abort ();\n     }\n+\n+  startbit = intoffset & -BITS_PER_WORD;\n+  endbit = (bitpos + BITS_PER_WORD - 1) & -BITS_PER_WORD;\n+  intregs = (endbit - startbit) / BITS_PER_WORD;\n+  cum->words += intregs;\n+}\n+\n+/* The darwin64 ABI calls for us to recurse down through structs,\n+   looking for elements passed in registers.  Unfortunately, we have\n+   to track int register count here also because of misalignments\n+   in powerpc alignment mode.  */\n+\n+static void\n+rs6000_darwin64_record_arg_advance_recurse (CUMULATIVE_ARGS *cum,\n+\t\t\t\t\t    tree type,\n+\t\t\t\t\t    HOST_WIDE_INT startbitpos)\n+{\n+  tree f;\n+\n+  for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+    if (TREE_CODE (f) == FIELD_DECL)\n+      {\n+\tHOST_WIDE_INT bitpos = startbitpos;\n+\ttree ftype = TREE_TYPE (f);\n+\tenum machine_mode mode = TYPE_MODE (ftype);\n+\n+\tif (DECL_SIZE (f) != 0\n+\t    && host_integerp (bit_position (f), 1))\n+\t  bitpos += int_bit_position (f);\n+\n+\t/* ??? FIXME: else assume zero offset.  */\n+\n+\tif (TREE_CODE (ftype) == RECORD_TYPE)\n+\t  rs6000_darwin64_record_arg_advance_recurse (cum, ftype, bitpos);\n+\telse if (USE_FP_FOR_ARG_P (cum, mode, ftype))\n+\t  {\n+\t    rs6000_darwin64_record_arg_advance_flush (cum, bitpos);\n+\t    cum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t    cum->words += (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t  }\n+\telse if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, 1))\n+\t  {\n+\t    rs6000_darwin64_record_arg_advance_flush (cum, bitpos);\n+\t    cum->vregno++;\n+\t    cum->words += 2;\n+\t  }\n+\telse if (cum->intoffset == -1)\n+\t  cum->intoffset = bitpos;\n+      }\n }\n \n /* Update the data in CUM to advance over an argument\n@@ -4105,6 +4166,8 @@ void\n function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t      tree type, int named, int depth)\n {\n+  int size;\n+\n   /* Only tick off an argument if we're not recursing.  */\n   if (depth == 0)\n     cum->nargs_prototype--;\n@@ -4168,10 +4231,30 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   else if (rs6000_darwin64_abi\n \t   && mode == BLKmode\n-\t   && (TREE_CODE (type) == RECORD_TYPE\n-\t       || TREE_CODE (type) == ARRAY_TYPE))\n-    darwin64_function_arg_advance (cum, type, named, depth);\n-\n+    \t   && TREE_CODE (type) == RECORD_TYPE\n+\t   && (size = int_size_in_bytes (type)) > 0)\n+    {\n+      /* Variable sized types have size == -1 and are\n+\t treated as if consisting entirely of ints.\n+\t Pad to 16 byte boundary if needed.  */\n+      if (TYPE_ALIGN (type) >= 2 * BITS_PER_WORD\n+\t  && (cum->words % 2) != 0)\n+\tcum->words++;\n+      /* For varargs, we can just go up by the size of the struct. */\n+      if (!named)\n+\tcum->words += (size + 7) / 8;\n+      else\n+\t{\n+\t  /* It is tempting to say int register count just goes up by\n+\t     sizeof(type)/8, but this is wrong in a case such as\n+\t     { int; double; int; } [powerpc alignment].  We have to\n+\t     grovel through the fields for these too.  */\n+\t  cum->intoffset = 0;\n+\t  rs6000_darwin64_record_arg_advance_recurse (cum, type, 0);\n+\t  rs6000_darwin64_record_arg_advance_flush (cum, \n+\t\t\t\t\t\t    size * BITS_PER_UNIT);\n+\t}\n+    }\n   else if (DEFAULT_ABI == ABI_V4)\n     {\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n@@ -4330,136 +4413,184 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n }\n \n-/* For the darwin64 ABI, we want to construct a PARALLEL consisting of\n-   the register(s) to be used for each field and subfield of a struct\n-   being passed by value, along with the offset of where the\n-   register's value may be found in the block.  */\n+/* A subroutine of rs6000_darwin64_record_arg.  Assign the bits of the\n+   structure between cum->intoffset and bitpos to integer registers.  */\n \n-static rtx\n-rs6000_darwin64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t      tree type, int named)\n+static void\n+rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum, \n+\t\t\t\t  HOST_WIDE_INT bitpos, rtx rvec[], int *k)\n {\n-  tree f, ftype, offset;\n-  rtx rvec[FIRST_PSEUDO_REGISTER], sub, suboff, roffset;\n-  int k = 0, i, j, bytepos, subbytepos, tot;\n-  CUMULATIVE_ARGS saved_cum = *cum;\n-  enum machine_mode submode;\n+  enum machine_mode mode;\n+  unsigned int regno;\n+  unsigned int startbit, endbit;\n+  int this_regno, intregs, intoffset;\n+  rtx reg;\n \n-  switch (TREE_CODE (type))\n+  if (cum->intoffset == -1)\n+    return;\n+\n+  intoffset = cum->intoffset;\n+  cum->intoffset = -1;\n+\n+  /* If this is the trailing part of a word, try to only load that\n+     much into the register.  Otherwise load the whole register.  Note\n+     that in the latter case we may pick up unwanted bits.  It's not a\n+     problem at the moment but may wish to revisit.  */\n+\n+  if (intoffset % BITS_PER_WORD != 0)\n     {\n-    case RECORD_TYPE:\n-      for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n-\tif (TREE_CODE (f) == FIELD_DECL)\n+      mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n+\t\t\t  MODE_INT, 0);\n+      if (mode == BLKmode)\n+\t{\n+\t  /* We couldn't find an appropriate mode, which happens,\n+\t     e.g., in packed structs when there are 3 bytes to load.\n+\t     Back intoffset back to the beginning of the word in this\n+\t     case.  */\n+\t intoffset = intoffset & -BITS_PER_WORD;\n+\t mode = word_mode;\n+\t}\n+    }\n+  else\n+    mode = word_mode;\n+\n+  startbit = intoffset & -BITS_PER_WORD;\n+  endbit = (bitpos + BITS_PER_WORD - 1) & -BITS_PER_WORD;\n+  intregs = (endbit - startbit) / BITS_PER_WORD;\n+  this_regno = cum->words + intoffset / BITS_PER_WORD;\n+\n+  if (intregs > 0 && intregs > GP_ARG_NUM_REG - this_regno)\n+    cum->use_stack = 1;\n+    \n+  intregs = MIN (intregs, GP_ARG_NUM_REG - this_regno);\n+  if (intregs <= 0)\n+    return;\n+\n+  intoffset /= BITS_PER_UNIT;\n+  do\n+    {\n+      regno = GP_ARG_MIN_REG + this_regno;\n+      reg = gen_rtx_REG (mode, regno);\n+      rvec[(*k)++] =\n+\tgen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (intoffset));\n+\n+      this_regno += 1;\n+      intoffset = (intoffset | (UNITS_PER_WORD-1)) + 1;\n+      mode = word_mode;\n+      intregs -= 1;\n+    }\n+  while (intregs > 0);\n+}\n+\n+/* Recursive workhorse for the following.  */\n+\n+static void\n+rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type, \n+\t\t\t\t    HOST_WIDE_INT startbitpos, rtx rvec[],\n+\t\t\t\t    int *k)\n+{\n+  tree f;\n+\n+  for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+    if (TREE_CODE (f) == FIELD_DECL)\n+      {\n+\tHOST_WIDE_INT bitpos = startbitpos;\n+\ttree ftype = TREE_TYPE (f);\n+\tenum machine_mode mode = TYPE_MODE (ftype);\n+\n+\tif (DECL_SIZE (f) != 0\n+\t    && host_integerp (bit_position (f), 1))\n+\t  bitpos += int_bit_position (f);\n+\n+\t/* ??? FIXME: else assume zero offset.  */\n+\n+\tif (TREE_CODE (ftype) == RECORD_TYPE)\n+\t  rs6000_darwin64_record_arg_recurse (cum, ftype, bitpos, rvec, k);\n+\telse if (cum->named && USE_FP_FOR_ARG_P (cum, mode, ftype))\n \t  {\n-\t    ftype = TREE_TYPE (f);\n-\t    offset = DECL_FIELD_OFFSET (f);\n-\t    bytepos = int_bit_position (f) / BITS_PER_UNIT;\n-\t    /* Force substructs to be handled as BLKmode even if\n-\t       they're small enough to be recorded as DImode, so we\n-\t       drill through to non-record fields.  */\n-\t    submode = TYPE_MODE (ftype);\n-\t    if (TREE_CODE (ftype) == RECORD_TYPE)\n-\t      submode = BLKmode;\n-\t    sub = function_arg (cum, submode, ftype, named);\n-\t    if (sub == NULL_RTX)\n-\t      return NULL_RTX;\n-\t    if (GET_CODE (sub) == PARALLEL)\n-\t      {\n-\t\tfor (i = 0; i < XVECLEN (sub, 0); i++)\n-\t\t  {\n-\t\t    rtx subsub = XVECEXP (sub, 0, i);\n-\t\t    suboff = XEXP (subsub, 1);\n-\t\t    subbytepos = INTVAL (suboff);\n-\t\t    subbytepos += bytepos;\n-\t\t    roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n-\t\t    subsub = XEXP (subsub, 0);\n-\t\t    rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n-\t\t  }\n-\t      }\n-\t    else\n+#if 0\n+\t    switch (mode)\n \t      {\n-\t\troffset = gen_rtx_CONST_INT (SImode, bytepos);\n-\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n+\t      case SCmode: mode = SFmode; break;\n+\t      case DCmode: mode = DFmode; break;\n+\t      case TCmode: mode = TFmode; break;\n+\t      default: break;\n \t      }\n-\t    /* Now do an arg advance to get all the cumulative arg\n-\t       stuff set correctly for the next subfield. Note that it\n-\t       has no lasting effect, because it is being done on a\n-\t       temporary copy of the cumulative arg data.  */\n-\t    function_arg_advance (cum, submode, ftype, named, 1);\n+#endif\n+\t    rs6000_darwin64_record_arg_flush (cum, bitpos, rvec, k);\n+\t    rvec[(*k)++]\n+\t      = gen_rtx_EXPR_LIST (VOIDmode, \n+\t\t\t\t   gen_rtx_REG (mode, cum->fregno++),\n+\t\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n+\t    if (mode == TFmode)\n+\t      cum->fregno++;\n \t  }\n-      break;\n+\telse if (cum->named && USE_ALTIVEC_FOR_ARG_P (cum, mode, ftype, 1))\n+\t  {\n+\t    rs6000_darwin64_record_arg_flush (cum, bitpos, rvec, k);\n+\t    rvec[(*k)++]\n+\t      = gen_rtx_EXPR_LIST (VOIDmode, \n+\t\t\t\t   gen_rtx_REG (mode, cum->vregno++), \n+\t\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n+\t  }\n+\telse if (cum->intoffset == -1)\n+\t  cum->intoffset = bitpos;\n+      }\n+}\n \n-    case UNION_TYPE:\n-      tot = rs6000_arg_size (mode, type);\n-      if (tot <= 0)\n-\treturn NULL_RTX;\n-      bytepos = 0;\n+/* For the darwin64 ABI, we want to construct a PARALLEL consisting of\n+   the register(s) to be used for each field and subfield of a struct\n+   being passed by value, along with the offset of where the\n+   register's value may be found in the block.  FP fields go in FP\n+   register, vector fields go in vector registers, and everything\n+   else goes in int registers, packed as in memory.  \n \n-      for (j = 0; j < tot; ++j)\n-\t{\n-\t  sub = gen_rtx_REG ((TARGET_64BIT ? DImode : SImode), GP_ARG_MIN_REG + cum->words++);\n-\t  roffset = gen_rtx_CONST_INT (SImode, bytepos);\n-\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n-\t  if (cum->words >= GP_ARG_NUM_REG)\n-\t    break;\n-\t  bytepos += (TARGET_64BIT ? 8 : 4);\n-\t}\n-      break;\n+   This code is also used for function return values.  RETVAL indicates\n+   whether this is the case.\n \n-    case ARRAY_TYPE:\n-      tot = int_size_in_bytes (type);\n-      if (tot <= 0)\n-\treturn NULL_RTX;\n-      ftype = TREE_TYPE (type);\n-      tot /= int_size_in_bytes (ftype);\n-      bytepos = 0;\n+   Much of this is taken from the Sparc V9 port, which has a similar\n+   calling convention.  */\n \n-      for (j = 0; j < tot; ++j)\n-\t{\n-\t  /* Force substructs to be handled as BLKmode even if\n-\t     they're small enough to be recorded as DImode, so we\n-\t     drill through to non-record fields.  */\n-\t  submode = TYPE_MODE (ftype);\n-\t  if (TREE_CODE (ftype) == RECORD_TYPE)\n-\t    submode = BLKmode;\n-\t  sub = function_arg (cum, submode, ftype, named);\n-\t  if (sub == NULL_RTX)\n-\t    return NULL_RTX;\n-\t  if (GET_CODE (sub) == PARALLEL)\n-\t    {\n-\t      for (i = 0; i < XVECLEN (sub, 0); i++)\n-\t\t{\n-\t\t  rtx subsub = XVECEXP (sub, 0, i);\n-\n-\t\t  suboff = XEXP (subsub, 1);\n-\t\t  subbytepos = INTVAL (suboff);\n-\t\t  subbytepos += bytepos;\n-\t\t  roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n-\t\t  subsub = XEXP (subsub, 0);\n-\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      roffset = gen_rtx_CONST_INT (SImode, bytepos);\n-\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n-\t    }\n-\t    /* Now do an arg advance to get all the cumulative arg\n-\t       stuff set correctly for the next subfield. Note that it\n-\t       has no lasting effect, because it is being done on a\n-\t       temporary copy of the cumulative arg data.  */\n-\t    function_arg_advance (cum, submode, ftype, named, 1);\n-\t    bytepos += int_size_in_bytes (ftype);\n-\t}\n-      break;\n-\n-    default:\n-      abort ();\n-  }\n-\n-  *cum = saved_cum;\n-  if (k > 0)\n-    return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n+static rtx\n+rs6000_darwin64_record_arg (CUMULATIVE_ARGS *orig_cum, tree type,\n+\t\t\t    int named, bool retval)\n+{\n+  rtx rvec[FIRST_PSEUDO_REGISTER];\n+  int k = 1, kbase = 1;\n+  HOST_WIDE_INT typesize = int_size_in_bytes (type);\n+  /* This is a copy; modifications are not visible to our caller.  */\n+  CUMULATIVE_ARGS copy_cum = *orig_cum;\n+  CUMULATIVE_ARGS *cum = &copy_cum;\n+\n+  /* Pad to 16 byte boundary if needed.  */\n+  if (!retval && TYPE_ALIGN (type) >= 2 * BITS_PER_WORD\n+      && (cum->words % 2) != 0)\n+    cum->words++;\n+\n+  cum->intoffset = 0;\n+  cum->use_stack = 0;\n+  cum->named = named;\n+\n+  /* Put entries into rvec[] for individual FP and vector fields, and\n+     for the chunks of memory that go in int regs.  Note we start at\n+     element 1; 0 is reserved for an indication of using memory, and\n+     may or may not be filled in below. */\n+  rs6000_darwin64_record_arg_recurse (cum, type, 0, rvec, &k);\n+  rs6000_darwin64_record_arg_flush (cum, typesize * BITS_PER_UNIT, rvec, &k);\n+\n+  /* If any part of the struct went on the stack put all of it there.\n+     This hack is because the generic code for\n+     FUNCTION_ARG_PARTIAL_NREGS cannot handle cases where the register\n+     parts of the struct are not at the beginning.  */\n+  if (cum->use_stack)\n+    {\n+      if (retval)\n+\treturn NULL_RTX;    /* doesn't go in registers at all */\n+      kbase = 0;\n+      rvec[0] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+    }\n+  if (k > 1 || cum->use_stack)\n+    return gen_rtx_PARALLEL (BLKmode, gen_rtvec_v (k - kbase, &rvec[kbase]));\n   else\n     return NULL_RTX;\n }\n@@ -4523,7 +4654,8 @@ rs6000_mixed_function_arg (enum machine_mode mode, tree type, int align_words)\n     This is null for libcalls where that information may\n     not be available.\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n+    the preceding args and about the function being called.  It is\n+    not modified in this routine.\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).\n \n@@ -4571,13 +4703,10 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       return GEN_INT (cum->call_cookie);\n     }\n \n-  if (mode == BLKmode\n-      && rs6000_darwin64_abi\n-      && (TREE_CODE (type) == RECORD_TYPE\n-\t  || TREE_CODE (type) == UNION_TYPE\n-\t  || TREE_CODE (type) == ARRAY_TYPE))\n+  if (rs6000_darwin64_abi && mode == BLKmode\n+      && TREE_CODE (type) == RECORD_TYPE)\n     {\n-      rtx rslt = rs6000_darwin64_function_arg (cum, mode, type, named);\n+      rtx rslt = rs6000_darwin64_record_arg (cum, type, named, false);\n       if (rslt != NULL_RTX)\n \treturn rslt;\n       /* Else fall through to usual handling.  */\n@@ -4818,6 +4947,12 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && cum->nargs_prototype >= 0)\n     return 0;\n \n+  /* In this complicated case we just disable the partial_nregs code.  */\n+  if (rs6000_darwin64_abi && mode == BLKmode\n+      && TREE_CODE (type) == RECORD_TYPE\n+      && int_size_in_bytes (type) > 0)\n+    return 0;\n+\n   align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n   parm_offset = TARGET_32BIT ? 2 : 0;\n   align_words = cum->words + ((parm_offset - cum->words) & align);\n@@ -17147,128 +17282,6 @@ rs6000_complex_function_value (enum machine_mode mode)\n   return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r2));\n }\n \n-/* Compose a PARALLEL for a darwin64 struct being returned by\n-   value.  */\n-\n-static rtx\n-rs6000_darwin64_function_value (CUMULATIVE_ARGS *cum, tree valtype)\n-{\n-  tree f, ftype;\n-  rtx rvec[FIRST_PSEUDO_REGISTER], sub, roffset, suboff;\n-  int k = 0, bytepos, tot, elt, i, subbytepos;\n-  enum machine_mode fmode;\n-\n-  switch (TREE_CODE (valtype))\n-    {\n-    case RECORD_TYPE:\n-      for (f = TYPE_FIELDS (valtype); f ; f = TREE_CHAIN (f))\n-\tif (TREE_CODE (f) == FIELD_DECL)\n-\t  {\n-\t    ftype = TREE_TYPE (f);\n-\t    fmode = TYPE_MODE (ftype);\n-\t    bytepos = int_bit_position (f) / BITS_PER_UNIT;\n-\t    if (USE_FP_FOR_ARG_P (cum, fmode, ftype))\n-\t      {\n-\t\tsub = gen_rtx_REG (fmode, cum->fregno++);\n-\t\tcum->sysv_gregno++;\n-\t      }\n-\t    else if (USE_ALTIVEC_FOR_ARG_P (cum, fmode, ftype, 1))\n-\t      {\n-\t\tsub = gen_rtx_REG (fmode, cum->vregno++);\n-\t\tcum->sysv_gregno++;\n-\t      }\n-\t    else if (fmode == BLKmode\n-\t\t     && (TREE_CODE (ftype) == RECORD_TYPE\n-\t\t\t || TREE_CODE (ftype) == ARRAY_TYPE))\n-\t      sub = rs6000_darwin64_function_value (cum, ftype);\n-\t    else\n-\t      sub = gen_rtx_REG (fmode, cum->sysv_gregno++);\n-\t    if (sub == NULL_RTX)\n-\t      return sub;\n-\t    else if (GET_CODE (sub) == PARALLEL)\n-\t      {\n-\t\tfor (i = 0; i < XVECLEN (sub, 0); i++)\n-\t\t  {\n-\t\t    rtx subsub = XVECEXP (sub, 0, i);\n-\n-\t\t    suboff = XEXP (subsub, 1);\n-\t\t    subbytepos = INTVAL (suboff);\n-\t\t    subbytepos += bytepos;\n-\t\t    roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n-\t\t    subsub = XEXP (subsub, 0);\n-\t\t    rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\troffset = gen_rtx_CONST_INT (SImode, bytepos);\n-\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n-\t      }\n-\t  }\n-      if (k > 0)\n-\treturn gen_rtx_PARALLEL (TYPE_MODE (valtype), gen_rtvec_v (k, rvec));\n-      else\n-\treturn NULL_RTX;\n-\n-    case ARRAY_TYPE:\n-      /* If passing by value won't work, give up.  */\n-      if (int_size_in_bytes (valtype) <= 0)\n-\treturn NULL_RTX;\n-      ftype = TREE_TYPE (valtype);\n-      fmode = TYPE_MODE (ftype);\n-      tot = int_size_in_bytes (valtype) / int_size_in_bytes (ftype);\n-      bytepos = 0;\n-      for (elt = 0; elt < tot; ++elt)\n-\t{\n-\t  if (USE_FP_FOR_ARG_P (cum, fmode, ftype))\n-\t    {\n-\t      sub = gen_rtx_REG (fmode, cum->fregno++);\n-\t      cum->sysv_gregno++;\n-\t    }\n-\t  else if (USE_ALTIVEC_FOR_ARG_P (cum, fmode, ftype, 1))\n-\t    {\n-\t      sub = gen_rtx_REG (fmode, cum->vregno++);\n-\t      cum->sysv_gregno++;\n-\t    }\n-\t  else if (fmode == BLKmode\n-\t\t   && (TREE_CODE (ftype) == RECORD_TYPE\n-\t\t       || TREE_CODE (ftype) == ARRAY_TYPE))\n-\t    sub = rs6000_darwin64_function_value (cum, ftype);\n-\t  else\n-\t    sub = gen_rtx_REG (fmode, cum->sysv_gregno++);\n-\t  if (sub == NULL_RTX)\n-\t    return sub;\n-\t  else if (GET_CODE (sub) == PARALLEL)\n-\t    {\n-\t      for (i = 0; i < XVECLEN (sub, 0); i++)\n-\t\t{\n-\t\t  rtx subsub = XVECEXP (sub, 0, i);\n-\n-\t\t  suboff = XEXP (subsub, 1);\n-\t\t  subbytepos = INTVAL (suboff);\n-\t\t  subbytepos += bytepos;\n-\t\t  roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n-\t\t  subsub = XEXP (subsub, 0);\n-\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n-\t\t}\n-\t      }\n-\t    else\n-\t      {\n-\t\troffset = gen_rtx_CONST_INT (SImode, bytepos);\n-\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n-\t      }\n-\t  bytepos += int_size_in_bytes (ftype);\n-\t}\n-      if (k > 0)\n-\treturn gen_rtx_PARALLEL (TYPE_MODE (valtype), gen_rtvec_v (k, rvec));\n-      else\n-\treturn NULL_RTX;\n-\n-    default:\n-      abort ();\n-    }\n-}\n-\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n@@ -17288,16 +17301,18 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   /* Special handling for structs in darwin64.  */\n   if (rs6000_darwin64_abi\n       && TYPE_MODE (valtype) == BLKmode\n-      && (TREE_CODE (valtype) == RECORD_TYPE\n-\t  || TREE_CODE (valtype) == ARRAY_TYPE))\n+      && TREE_CODE (valtype) == RECORD_TYPE\n+      && int_size_in_bytes (valtype) > 0)\n     {\n       CUMULATIVE_ARGS valcum;\n       rtx valret;\n \n-      valcum.sysv_gregno = GP_ARG_RETURN;\n+      valcum.words = 0;\n       valcum.fregno = FP_ARG_MIN_REG;\n       valcum.vregno = ALTIVEC_ARG_MIN_REG;\n-      valret = rs6000_darwin64_function_value (&valcum, valtype);\n+      /* Do a trial code generation as if this were going to be passed as\n+\t an argument; if any part goes in memory, we return NULL.  */\n+      valret = rs6000_darwin64_record_arg (&valcum, valtype, 1, true);\n       if (valret)\n \treturn valret;\n       /* Otherwise fall through to standard ABI rules.  */"}, {"sha": "d9c2e8e24d208cbf4243c40d84b7219dc9eaefc0", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5383eba096fa2bec2d62242ea0f1bc5350ebc3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0b5383eba096fa2bec2d62242ea0f1bc5350ebc3", "patch": "@@ -1700,6 +1700,9 @@ typedef struct rs6000_args\n   int stdarg;\t\t\t/* Whether function is a stdarg function.  */\n   int call_cookie;\t\t/* Do special things for this call */\n   int sysv_gregno;\t\t/* next available GP register */\n+  int intoffset;\t\t/* running offset in struct (darwin64) */\n+  int use_stack;\t\t/* any part of struct on stack (darwin64) */\n+  int named;\t\t\t/* false for varargs params */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}]}