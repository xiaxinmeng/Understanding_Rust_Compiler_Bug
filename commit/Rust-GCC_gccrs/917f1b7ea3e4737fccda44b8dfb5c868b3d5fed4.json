{"sha": "917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE3ZjFiN2VhM2U0NzM3ZmNjZGE0NGI4ZGZiNWM4NjhiM2Q1ZmVkNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-04-08T17:01:17Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-04-08T17:01:17Z"}, "message": "builtins.c, [...]: Fix comment typos.\n\n\t* builtins.c, config/arm/arm.c, config/i386/cygwin.h,\n\tconfig/i386/i386.c, config/ia64/ia64.c, config/s390/fixdfdi.h,\n\tconfig/sh/sh.c, config/sh/sh.h, df-scan.c, except.c,\n\thaifa-sched.c, optabs.c, rtl.h, sched-deps.c, sched-int.h,\n\tsched-rgn.c, tree-inline.h, tree-ssa-dom.c,\n\ttree-ssa-loop-prefetch.c, tree-ssa-operands.c,\n\ttree-vect-patterns.c, tree-vrp.c: Fix comment typos.  Follow\n\tspelling convensions.\n\t* config/ia64/ia64.opt, doc/contrib.texi, doc/invoke.texi,\n\tdoc/passes.texi, doc/tm.texi, doc/tree-ssa.texi: Fix comment\n\ttypos.  Follow spelling conventions.\n\nFrom-SVN: r112782", "tree": {"sha": "9a89407bf0978b32e50e4f9c4dbb294a3c14cef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a89407bf0978b32e50e4f9c4dbb294a3c14cef7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/comments", "author": null, "committer": null, "parents": [{"sha": "b82feea52fface9bc8d2addb726704da49b1d972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82feea52fface9bc8d2addb726704da49b1d972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82feea52fface9bc8d2addb726704da49b1d972"}], "stats": {"total": 174, "additions": 94, "deletions": 80}, "files": [{"sha": "8f91736fdc9b89d62a3d0074b4251f669862f4dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -1,3 +1,17 @@\n+2006-04-08  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* builtins.c, config/arm/arm.c, config/i386/cygwin.h,\n+\tconfig/i386/i386.c, config/ia64/ia64.c, config/s390/fixdfdi.h,\n+\tconfig/sh/sh.c, config/sh/sh.h, df-scan.c, except.c,\n+\thaifa-sched.c, optabs.c, rtl.h, sched-deps.c, sched-int.h,\n+\tsched-rgn.c, tree-inline.h, tree-ssa-dom.c,\n+\ttree-ssa-loop-prefetch.c, tree-ssa-operands.c,\n+\ttree-vect-patterns.c, tree-vrp.c: Fix comment typos.  Follow\n+\tspelling convensions.\n+\t* config/ia64/ia64.opt, doc/contrib.texi, doc/invoke.texi,\n+\tdoc/passes.texi, doc/tm.texi, doc/tree-ssa.texi: Fix comment\n+\ttypos.  Follow spelling conventions.\n+\n 2006-04-07  DJ Delorie  <dj@redhat.com>\n \n \t* config/m32c/m32c.c (m32c_function_arg): Structures are always"}, {"sha": "f504e311d6a5779ee718299358c7b1a8266823f6", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -278,7 +278,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \t  inner = max_align;\n \t  while (handled_component_p (exp))\n \t    {\n-\t      /* Fields in a structure can be packed, honour DECL_ALIGN\n+\t      /* Fields in a structure can be packed, honor DECL_ALIGN\n \t\t of the FIELD_DECL.  For all other references the conservative \n \t\t alignment is the element type alignment.  */\n \t      if (TREE_CODE (exp) == COMPONENT_REF)"}, {"sha": "0f46b3e8dd9397f4dfd30f9b4bbe9e6daa5bce15", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -8003,7 +8003,7 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n \n   /* If an entry requires 8-byte alignment then assume all constant pools\n      require 4 bytes of padding.  Trying to do this later on a per-pool\n-     basis is awkward becuse existing pool entries have to be modified.  */\n+     basis is awkward because existing pool entries have to be modified.  */\n   if (ARM_DOUBLEWORD_ALIGN && fix->fix_size == 8)\n     minipool_pad = 4;\n "}, {"sha": "a7d5e47cdc95b225298f60294446df4ee7fc4b97", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -235,6 +235,6 @@ while (0)\n \n /* Every program on cygwin links against cygwin1.dll which contains \n    the pthread routines.  There is no need to explicitly link them\n-   and the -pthread flag is not recognised.  */\n+   and the -pthread flag is not recognized.  */\n #undef GOMP_SELF_SPECS\n #define GOMP_SELF_SPECS \"\""}, {"sha": "907682547aa8126bc6238c2e54f67233a3a7c42c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -16372,7 +16372,7 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n   if (x == CONST0_RTX (mode))\n     return class;\n \n-  /* Force constants into memory if we are loading a (non-zero) constant into\n+  /* Force constants into memory if we are loading a (nonzero) constant into\n      an MMX or SSE register.  This is because there are no MMX/SSE instructions\n      to load from a constant.  */\n   if (CONSTANT_P (x)"}, {"sha": "65798146893648774a7fea5742444cfd1c620f90", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -8306,7 +8306,7 @@ ia64_ld_address_bypass_p (rtx producer, rtx consumer)\n   if (GET_CODE (mem) == UNSPEC && XVECLEN (mem, 0) > 0)\n     mem = XVECEXP (mem, 0, 0);\n   else if (GET_CODE (mem) == IF_THEN_ELSE)\n-    /* ??? Is this bypass neccessary for ld.c?  */\n+    /* ??? Is this bypass necessary for ld.c?  */\n     {\n       gcc_assert (XINT (XEXP (XEXP (mem, 0), 0), 1) == UNSPEC_LDCCLR);\n       mem = XEXP (mem, 1);"}, {"sha": "2ff3d5984a3cb49e6a0e10032c69bf334def75cf", "filename": "gcc/config/ia64/ia64.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fia64%2Fia64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fia64%2Fia64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.opt?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -134,11 +134,11 @@ Print information about speculative motions.\n \n msched-prefer-non-data-spec-insns\n Common Report Var(mflag_sched_prefer_non_data_spec_insns) Init(0)\n-If set, data speculative instructions will be choosen for schedule only if there are no other choices at the moment \n+If set, data speculative instructions will be chosen for schedule only if there are no other choices at the moment \n \n msched-prefer-non-control-spec-insns\n Common Report Var(mflag_sched_prefer_non_control_spec_insns) Init(0)\n-If set, control speculative instructions will be choosen for schedule only if there are no other choices at the moment \n+If set, control speculative instructions will be chosen for schedule only if there are no other choices at the moment \n \n msched-count-spec-in-critical-path\n Common Report Var(mflag_sched_count_spec_in_critical_path) Init(0)"}, {"sha": "88c2197f4c84a3607a1c28716450e1864f27a27d", "filename": "gcc/config/s390/fixdfdi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ffixdfdi.h?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -74,7 +74,7 @@ __fixunstfdi (long double a1)\n     if (exp <= -PRECISION)\n       return 0;\n \n-    /* NaN: All exponent bits set and a non-zero fraction.  */\n+    /* NaN: All exponent bits set and a nonzero fraction.  */\n     if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))\n       return 0x0ULL;\n \n@@ -146,7 +146,7 @@ __fixtfdi (long double a1)\n     if (exp <= -PRECISION)\n       return 0;\n \n-    /* NaN: All exponent bits set and a non-zero fraction.  */\n+    /* NaN: All exponent bits set and a nonzero fraction.  */\n     if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))\n       return 0x8000000000000000ULL;\n "}, {"sha": "929b60f89c893cc9bf4c1b306e8c4c1829f10a91", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -6818,7 +6818,7 @@ sh_va_start (tree valist, rtx nextarg)\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n-/* TYPE is a RECORD_TYPE.  If there is only a single non-zero-sized\n+/* TYPE is a RECORD_TYPE.  If there is only a single nonzero-sized\n    member, return it.  */\n static tree\n find_sole_member (tree type)"}, {"sha": "c61c357ec36c3f39e7aa0df44f60431af13a905a", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -507,8 +507,8 @@ enum sh_divide_strategy_e {\n   SH_DIV_INV_CALL2,\n   SH_DIV_INV_FP,\n   /* SH1 .. SH4 strategies.  Because of the small number of registers\n-     available, the compiler uses knowledge of the actual et of registers\n-     being clobbed by the different functions called.  */\n+     available, the compiler uses knowledge of the actual set of registers\n+     being clobbered by the different functions called.  */\n   SH_DIV_CALL_DIV1, /* No FPU, medium size, highest latency.  */\n   SH_DIV_CALL_FP,     /* FPU needed, small size, high latency.  */\n   SH_DIV_CALL_TABLE,  /* No FPU, large size, medium latency. */"}, {"sha": "b35c3a474e45967b0765db5ffb5a2255df1b06c0", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -1603,7 +1603,7 @@ df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n \t\t\t  DF_REF_ARTIFICIAL | DF_REF_AT_TOP);\n #endif\n \n-      /* The following code (down thru the arg_pointer seting APPEARS\n+      /* The following code (down thru the arg_pointer setting APPEARS\n \t to be necessary because there is nothing that actually\n \t describes what the exception handling code may actually need\n \t to keep alive.  */"}, {"sha": "eac0a0b53b3a47082a6aa8477ef0cb31a614f027", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -1300,7 +1300,7 @@ Ingo Proetel for @code{Image}, @code{Logger} and @code{URLClassLoader}\n updates.\n \n @item\n-Olga Rodimina for @code{MenuSelectionManager} implemenation.\n+Olga Rodimina for @code{MenuSelectionManager} implementation.\n \n @item\n Jan Roehrich for @code{BasicTreeUI} and @code{JTree} fixes.\n@@ -1324,7 +1324,7 @@ Christian Thalinger for 64-bit cleanups, Configuration and VM\n interface fixes and @code{CACAO} integration, @code{fdlibm} updates.\n \n @item\n-Gael Thomas for @code{VMClassLoader} boot packages support sugestions.\n+Gael Thomas for @code{VMClassLoader} boot packages support suggestions.\n \n @item\n Andreas Tobler for Darwin and Solaris testing and fixing, @code{Qt4}"}, {"sha": "7f561d2c753ce45389ad290eaa714191911fe315", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -9170,7 +9170,7 @@ Intel PentiumMMX CPU based on Pentium core with MMX instruction set support.\n Intel PentiumPro CPU@.\n @item i686\n Same as @code{generic}, but when used as @code{march} option, PentiumPro\n-instruction set will be used, so the code will run on all i686 familly chips.\n+instruction set will be used, so the code will run on all i686 family chips.\n @item pentium2\n Intel Pentium2 CPU based on PentiumPro core with MMX instruction set support.\n @item pentium3, pentium3m\n@@ -9844,7 +9844,7 @@ The default is 'disable'.\n @itemx -msched-prefer-non-data-spec-insns\n @opindex -mno-sched-prefer-non-data-spec-insns\n @opindex -msched-prefer-non-data-spec-insns\n-If enabled, data speculative instructions will be choosen for schedule\n+If enabled, data speculative instructions will be chosen for schedule\n only if there are no other choices at the moment.  This will make\n the use of the data speculation much more conservative.\n The default is 'disable'.\n@@ -9853,7 +9853,7 @@ The default is 'disable'.\n @itemx -msched-prefer-non-control-spec-insns\n @opindex -mno-sched-prefer-non-control-spec-insns\n @opindex -msched-prefer-non-control-spec-insns\n-If enabled, control speculative instructions will be choosen for schedule\n+If enabled, control speculative instructions will be chosen for schedule\n only if there are no other choices at the moment.  This will make\n the use of the control speculation much more conservative.\n The default is 'disable'.\n@@ -9862,7 +9862,7 @@ The default is 'disable'.\n @itemx -msched-count-spec-in-critical-path\n @opindex -mno-sched-count-spec-in-critical-path\n @opindex -msched-count-spec-in-critical-path\n-If enabled, speculative depedencies will be considered during\n+If enabled, speculative dependencies will be considered during\n computation of the instructions priorities.  This will make the use of the\n speculation a bit more conservative.\n The default is 'disable'."}, {"sha": "441a903d7df5778de77621bf6496b397519d2753", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -202,7 +202,7 @@ declarations of static variables whose lifetimes extend to the entire\n program.  The pass is located in @file{tree-mudflap.c} and is described\n by @code{pass_mudflap_1}.\n \n-@item OpenMP lowerering\n+@item OpenMP lowering\n \n If OpenMP generation (@option{-fopenmp}) is enabled, this pass lowers\n OpenMP constructs into GIMPLE."}, {"sha": "9ee6a835e8573266b3057925d772fdcb819ee865", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -4191,7 +4191,7 @@ be because the function prologue moves it to a different place.\n the context of the called function, and @code{0} in the context of\n the caller.\n \n-If @var{incoming} is non-zero and the address is to be found on the\n+If @var{incoming} is nonzero and the address is to be found on the\n stack, return a @code{mem} which refers to the frame pointer. If\n @var{incoming} is @code{2}, the result is being used to fetch the\n structure value address at the beginning of a function.  If you need \n@@ -6024,7 +6024,7 @@ This hook is a modified version of @samp{TARGET_SCHED_ADJUST_COST}.  Instead\n of passing dependence as a second parameter, it passes a type of that\n dependence.  This is useful to calculate cost of dependence between insns\n not having the corresponding link.  If @samp{TARGET_SCHED_ADJUST_COST_2} is\n-definded it is used instead of @samp{TARGET_SCHED_ADJUST_COST}.\n+defined it is used instead of @samp{TARGET_SCHED_ADJUST_COST}.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_SCHED_H_I_D_EXTENDED (void)\n@@ -6046,7 +6046,7 @@ the generated speculative pattern.\n \n @deftypefn {Target Hook} int TARGET_SCHED_NEEDS_BLOCK_P (rtx @var{insn})\n This hook is called by the insn scheduler during generation of recovery code\n-for @var{insn}.  It should return non-zero, if the corresponding check\n+for @var{insn}.  It should return nonzero, if the corresponding check\n instruction should branch to recovery code, or zero otherwise.\n @end deftypefn\n \n@@ -6056,7 +6056,7 @@ check instruction.  If @var{mutate_p} is zero, then @var{insn} is a\n speculative instruction for which the check should be generated.  \n @var{label} is either a label of a basic block, where recovery code should \n be emitted, or a null pointer, when requested check doesn't branch to \n-recovery code (a simple check).  If @var{mutate_p} is non-zero, then \n+recovery code (a simple check).  If @var{mutate_p} is nonzero, then \n a pattern for a branchy check corresponding to a simple check denoted by \n @var{insn} should be generated.  In this case @var{label} can't be null.\n @end deftypefn\n@@ -6067,7 +6067,7 @@ This hook is used as a workaround for\n called on the first instruction of the ready list.  The hook is used to\n discard speculative instruction that stand first in the ready list from\n being scheduled on the current cycle.  For non-speculative instructions, \n-the hook should always return non-zero.  For example, in the ia64 backend\n+the hook should always return nonzero.  For example, in the ia64 backend\n the hook is used to cancel data speculative insns when the ALAT table\n is nearly full.\n @end deftypefn\n@@ -6077,7 +6077,7 @@ This hook is used by the insn scheduler to find out what features should be\n enabled/used.  @var{flags} initially may have either the SCHED_RGN or SCHED_EBB\n bit set.  This denotes the scheduler pass for which the data should be \n provided.  The target backend should modify @var{flags} by modifying\n-the bits correponding to the following features: USE_DEPS_LIST, USE_GLAT,\n+the bits corresponding to the following features: USE_DEPS_LIST, USE_GLAT,\n DETACH_LIFE_INFO, and DO_SPECULATION.  For the DO_SPECULATION feature \n an additional structure @var{spec_info} should be filled by the target.  \n The structure describes speculation types that can be used in the scheduler."}, {"sha": "7149bb95bee46c75862035adbf4e556e217fde3c", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -1392,7 +1392,7 @@ mainly because the set of virtual operands for a statement may change at\n what some would consider unexpected times.  In general, any time you\n have modified a statement that has virtual operands, you should verify\n whether the list of virtual operands has changed, and if so, mark the\n-newly exposed symbols by callnig @code{mark_new_vars_to_rename}.\n+newly exposed symbols by calling @code{mark_new_vars_to_rename}.\n \n There is one additional caveat to preserving virtual SSA form.  When the\n entire set of virtual operands may be eliminated due to better"}, {"sha": "3feda0f7e5115d8ff5a2866ef423df0b3ef120d0", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -858,7 +858,7 @@ current_function_has_exception_handlers (void)\n }\n \f\n /* A subroutine of duplicate_eh_regions.  Search the region tree under O\n-   for the miniumum and maximum region numbers.  Update *MIN and *MAX.  */\n+   for the minimum and maximum region numbers.  Update *MIN and *MAX.  */\n \n static void\n duplicate_eh_regions_0 (eh_region o, int *min, int *max)\n@@ -912,7 +912,7 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n   return ret;\n }\n \n-/* Duplicate the EH regions of IFUN, rootted at COPY_REGION, into current\n+/* Duplicate the EH regions of IFUN, rooted at COPY_REGION, into current\n    function and root the tree below OUTER_REGION.  Remap labels using MAP\n    callback.  The special case of COPY_REGION of 0 means all regions.  */\n "}, {"sha": "ef4f4f709cad67b13d9662761e168f2090477078", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -217,7 +217,7 @@ static spec_info_t spec_info;\n    Used to determine, if we need to fix INSN_TICKs.  */\n static bool added_recovery_block_p;\n \n-/* Counters of different types of speculative isntructions.  */\n+/* Counters of different types of speculative instructions.  */\n static int nr_begin_data, nr_be_in_data, nr_begin_control, nr_be_in_control;\n \n /* Pointers to GLAT data.  See init_glat for more information.  */\n@@ -977,7 +977,7 @@ ready_lastpos (struct ready_list *ready)\n }\n \n /* Add an element INSN to the ready list so that it ends up with the\n-   lowest/highest priority dependending on FIRST_P.  */\n+   lowest/highest priority depending on FIRST_P.  */\n \n HAIFA_INLINE static void\n ready_add (struct ready_list *ready, rtx insn, bool first_p)\n@@ -1598,7 +1598,7 @@ find_insn_reg_weight (basic_block bb)\n     find_insn_reg_weight1 (insn);    \n }\n \n-/* Calculate INSN_REG_WEIGHT for single insntruction.\n+/* Calculate INSN_REG_WEIGHT for single instruction.\n    Separated from find_insn_reg_weight because of need\n    to initialize new instruction in generate_recovery_code.  */\n static void\n@@ -2034,7 +2034,7 @@ static int cached_issue_rate = 0;\n    make this function tries different samples of ready insns.  READY\n    is current queue `ready'.  Global array READY_TRY reflects what\n    insns are already issued in this try.  MAX_POINTS is the sum of points\n-   of all instructions in READY.  The function stops immediatelly,\n+   of all instructions in READY.  The function stops immediately,\n    if it reached the such a solution, that all instruction can be issued.\n    INDEX will contain index of the best insn in READY.  The following\n    function is used only for first cycle multipass scheduling.  */\n@@ -2463,7 +2463,7 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n \t      continue;\n \t    }\n \n-\t  /* DECISSION is made.  */\t\n+\t  /* DECISION is made.  */\t\n   \n           if (TODO_SPEC (insn) & SPECULATIVE)\n             generate_recovery_code (insn);\n@@ -2472,7 +2472,7 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n \t      /* This is used to to switch basic blocks by request\n \t\t from scheduler front-end (actually, sched-ebb.c only).\n \t\t This is used to process blocks with single fallthru\n-\t\t edge.  If successing block has jump, it [jump] will try\n+\t\t edge.  If succeeding block has jump, it [jump] will try\n \t\t move at the end of current bb, thus corrupting CFG.  */\n \t      || current_sched_info->advance_target_bb (*target_bb, insn))\n \t    {\n@@ -2869,7 +2869,7 @@ sched_finish (void)\n }\n \n /* Fix INSN_TICKs of the instructions in the current block as well as\n-   INSN_TICKs of their dependants.\n+   INSN_TICKs of their dependents.\n    HEAD and TAIL are the begin and the end of the current scheduled block.  */\n static void\n fix_inter_tick (rtx head, rtx tail)\n@@ -3116,7 +3116,7 @@ fix_tick_ready (rtx next)\n       tick = INSN_TICK (next);\n       /* if tick is not equal to INVALID_TICK, then update\n \t INSN_TICK of NEXT with the most recent resolved dependence\n-\t cost.  Overwise, recalculate from scratch.  */\n+\t cost.  Otherwise, recalculate from scratch.  */\n       full_p = tick == INVALID_TICK;\n       do\n         {        \n@@ -3163,7 +3163,7 @@ change_queue_index (rtx next, int delay)\n     /* We have nothing to do.  */\n     return;\n \n-  /* Remove NEXT from whereever it is now.  */\n+  /* Remove NEXT from wherever it is now.  */\n   if (i == QUEUE_READY)\n     ready_remove_insn (next);\n   else if (i >= 0)\n@@ -3318,7 +3318,7 @@ process_insn_depend_be_in_spec (rtx link, rtx twin, ds_t fs)\n \t{\n \t  gcc_assert (!(ds & BE_IN_SPEC));\n \n-\t  if (/* If this dep can be overcomed with 'begin speculation'.  */\n+\t  if (/* If this dep can be overcome with 'begin speculation'.  */\n \t      ds & BEGIN_SPEC)\n \t    /* Then we have a choice: keep the dep 'begin speculative'\n \t       or transform it into 'be in speculative'.  */\n@@ -3421,7 +3421,7 @@ add_to_speculative_block (rtx insn)\n \n       twins = alloc_INSN_LIST (twin, twins);\n \n-      /* Add dependences between TWIN and all apropriate\n+      /* Add dependences between TWIN and all appropriate\n \t instructions from REC.  */\n       do\n \t{\t  \n@@ -3696,7 +3696,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n   gcc_assert (ORIG_PAT (insn));\n \n-  /* Initialize TWIN (twin is a dublicate of original instruction\n+  /* Initialize TWIN (twin is a duplicate of original instruction\n      in the recovery block).  */\n   if (rec != EXIT_BLOCK_PTR)\n     {\n@@ -3896,7 +3896,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n     add_back_forw_dep (check, insn, REG_DEP_TRUE, DEP_TRUE | DEP_OUTPUT);\n \n   if (!mutate_p)\n-    /* Fix priorities.  If MUTATE_P is nonzero, this is not neccessary,\n+    /* Fix priorities.  If MUTATE_P is nonzero, this is not necessary,\n        because it'll be done later in add_to_speculative_block.  */\n     {\n       clear_priorities (twin);\n@@ -3906,7 +3906,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n /* Removes dependency between instructions in the recovery block REC\n    and usual region instructions.  It keeps inner dependences so it\n-   won't be neccessary to recompute them.  */\n+   won't be necessary to recompute them.  */\n static void\n fix_recovery_deps (basic_block rec)\n {\n@@ -4065,7 +4065,7 @@ dump_new_block_header (int i, basic_block bb, rtx head, rtx tail)\n \n /* Unlink basic block notes and labels and saves them, so they\n    can be easily restored.  We unlink basic block notes in EBB to\n-   provide back-compatability with the previous code, as target backends\n+   provide back-compatibility with the previous code, as target backends\n    assume, that there'll be only instructions between\n    current_sched_info->{head and tail}.  We restore these notes as soon\n    as we can.\n@@ -4308,8 +4308,8 @@ move_succs (VEC(edge,gc) **succsp, basic_block to)\n \n /* Initialize GLAT (global_live_at_{start, end}) structures.\n    GLAT structures are used to substitute global_live_{start, end}\n-   regsets during scheduling.  This is neccessary to use such functions as\n-   split_block (), as they assume consistancy of register live information.  */\n+   regsets during scheduling.  This is necessary to use such functions as\n+   split_block (), as they assume consistency of register live information.  */\n static void\n init_glat (void)\n {\n@@ -4530,7 +4530,7 @@ debug_spec_status (ds_t s)\n }\n \n /* Helper function for check_cfg.\n-   Return non-zero, if edge vector pointed to by EL has edge with TYPE in\n+   Return nonzero, if edge vector pointed to by EL has edge with TYPE in\n    its flags.  */\n static int\n has_edge_p (VEC(edge,gc) *el, int type)\n@@ -4631,7 +4631,7 @@ check_cfg (rtx head, rtx tail)\n   gcc_assert (bb == 0);\n }\n \n-/* Perform few consistancy checks of flags in different data structures.  */\n+/* Perform a few consistency checks of flags in different data structures.  */\n static void\n check_sched_flags (void)\n {\n@@ -4650,7 +4650,7 @@ check_sched_flags (void)\n \n /* Check global_live_at_{start, end} regsets.\n    If FATAL_P is TRUE, then abort execution at the first failure.\n-   Overwise, print diagnostics to STDERR (this mode is for calling\n+   Otherwise, print diagnostics to STDERR (this mode is for calling\n    from debugger).  */\n void\n check_reg_live (bool fatal_p)"}, {"sha": "f565579091adc7f7edc14a434abbb0bee3e76ad9", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -3710,7 +3710,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \t to the modified comparison. For signed comparisons compare the \n \t result against 1 in the biased case, and zero in the unbiased\n \t case. For unsigned comparisons always compare against 1 after\n-\t biasing the unbased result by adding 1. This gives us a way to\n+\t biasing the unbiased result by adding 1. This gives us a way to\n \t represent LTU. */\n       *px = result;\n       *pmode = word_mode;"}, {"sha": "2335bba5ff52e20639cc03361161da68b9ea311e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -361,7 +361,7 @@ struct rtvec_def GTY(()) {\n /* Predicate yielding nonzero iff X is an rtx for a memory location.  */\n #define MEM_P(X) (GET_CODE (X) == MEM)\n \n-/* Prediacte yielding nonzero iff X is an rtx for a constant integer.  */\n+/* Predicate yielding nonzero iff X is an rtx for a constant integer.  */\n #define CONST_INT_P(X) (GET_CODE (X) == CONST_INT)\n \n /* Predicate yielding nonzero iff X is a label insn.  */"}, {"sha": "a408fab070650556b9d091d7f67ac8883f33b856", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -227,7 +227,7 @@ sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n \f\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n    LOG_LINKS of INSN, if it is not already there.  DEP_TYPE indicates the\n-   type of dependence that this link represents.  DS, if non-zero,\n+   type of dependence that this link represents.  DS, if nonzero,\n    indicates speculations, through which this dependence can be overcome.\n    MEM1 and MEM2, if non-null, corresponds to memory locations in case of\n    data speculation.  The function returns a value indicating if an old entry\n@@ -2187,7 +2187,7 @@ check_dep_status (enum reg_note dt, ds_t ds, bool relaxed_p)\n \t  gcc_assert ((ds & DEP_TYPES) == DEP_TRUE);\n \t}\n           \n-      /* Check that true and anti depencies can't have other speculative \n+      /* Check that true and anti dependencies can't have other speculative \n \t statuses.  */\n       if (ds & DEP_TRUE)\n \tgcc_assert (ds & (BEGIN_DATA | BE_IN_SPEC));"}, {"sha": "5b042a0f71aa93ab379739d920f316e3e4533f42", "filename": "gcc/sched-int.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -321,7 +321,7 @@ struct haifa_insn_data\n      (e.g. add_dependence was invoked with (insn == elem)).  */\n   unsigned int has_internal_dep : 1;\n   \n-  /* What speculations are neccessary to apply to schedule the instruction.  */\n+  /* What speculations are necessary to apply to schedule the instruction.  */\n   ds_t todo_spec;\n   /* What speculations were already applied.  */\n   ds_t done_spec; \n@@ -359,7 +359,7 @@ extern regset *glat_start, *glat_end;\n #define RECOVERY_BLOCK(INSN)    (h_i_d[INSN_UID (INSN)].recovery_block)\n #define ORIG_PAT(INSN)          (h_i_d[INSN_UID (INSN)].orig_pat)\n \n-/* DEP_STATUS of the link incapsulates information, that is needed for\n+/* DEP_STATUS of the link encapsulates information, that is needed for\n    speculative scheduling.  Namely, it is 4 integers in the range\n    [0, MAX_DEP_WEAK] and 3 bits.\n    The integers correspond to the probability of the dependence to *not*\n@@ -374,7 +374,7 @@ extern regset *glat_start, *glat_end;\n    to know just the major type of all the dependence between two instructions,\n    as only true dependence can be overcome.\n    There also is the 4-th bit in the DEP_STATUS (HARD_DEP), that is reserved\n-   for using to describe instruction's status.  It is set whenever instuction\n+   for using to describe instruction's status.  It is set whenever instruction\n    has at least one dependence, that cannot be overcome.\n    See also: check_dep_status () in sched-deps.c .  */\n #define DEP_STATUS(LINK) XINT (LINK, 2)\n@@ -421,27 +421,27 @@ enum SPEC_TYPES_OFFSETS {\n /* The following defines provide numerous constants used to distinguish between\n    different types of speculative dependencies.  */\n \n-/* Dependence can be overcomed with generation of new data speculative\n+/* Dependence can be overcome with generation of new data speculative\n    instruction.  */\n #define BEGIN_DATA (((ds_t) DEP_WEAK_MASK) << BEGIN_DATA_BITS_OFFSET)\n \n /* This dependence is to the instruction in the recovery block, that was\n    formed to recover after data-speculation failure.\n-   Thus, this dependence can overcomed with generating of the copy of\n+   Thus, this dependence can overcome with generating of the copy of\n    this instruction in the recovery block.  */\n #define BE_IN_DATA (((ds_t) DEP_WEAK_MASK) << BE_IN_DATA_BITS_OFFSET)\n \n-/* Dependence can be overcomed with generation of new control speculative\n+/* Dependence can be overcome with generation of new control speculative\n    instruction.  */\n #define BEGIN_CONTROL (((ds_t) DEP_WEAK_MASK) << BEGIN_CONTROL_BITS_OFFSET)\n \n /* This dependence is to the instruction in the recovery block, that was\n    formed to recover after control-speculation failure.\n-   Thus, this dependence can overcomed with generating of the copy of\n+   Thus, this dependence can be be overcome with generating of the copy of\n    this instruction in the recovery block.  */\n #define BE_IN_CONTROL (((ds_t) DEP_WEAK_MASK) << BE_IN_CONTROL_BITS_OFFSET)\n \n-/* Few convinient combinations.  */\n+/* A few convenient combinations.  */\n #define BEGIN_SPEC (BEGIN_DATA | BEGIN_CONTROL)\n #define DATA_SPEC (BEGIN_DATA | BE_IN_DATA)\n #define CONTROL_SPEC (BEGIN_CONTROL | BE_IN_CONTROL)"}, {"sha": "612623a14b85c610a89de42cd896365862e8fe7a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -1146,7 +1146,7 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n      (We don't count single block regions here).\n \n      By default we do at most 2 iterations.\n-     This can be overriden with max-sched-extend-regions-iters parameter:\n+     This can be overridden with max-sched-extend-regions-iters parameter:\n      0 - disable region extension,\n      N > 0 - do at most N iterations.  */\n   \n@@ -2038,7 +2038,7 @@ can_schedule_ready_p (rtx insn)\n     return 1;\n }\n \n-/* Updates counter and other information.  Splitted from can_schedule_ready_p ()\n+/* Updates counter and other information.  Split from can_schedule_ready_p ()\n    because when we schedule insn speculatively then insn passed to\n    can_schedule_ready_p () differs from the one passed to\n    begin_schedule_ready ().  */\n@@ -2752,7 +2752,7 @@ schedule_region (int rgn)\n \tcompute_dom_prob_ps (bb);\n \n       /* Cleanup ->aux used for EDGE_TO_BIT mapping.  */\n-      /* We don't need them anymore.  But we want to avoid dublication of\n+      /* We don't need them anymore.  But we want to avoid duplication of\n \t aux fields in the newly created edges.  */\n       FOR_EACH_BB (block)\n \t{\n@@ -2952,7 +2952,7 @@ schedule_insns (void)\n \n   init_regions ();\n \n-  /* EBB_HEAD is a region-scope sctructure.  But we realloc it for\n+  /* EBB_HEAD is a region-scope structure.  But we realloc it for\n      each region to save time/memory/something else.  */\n   ebb_head = 0;\n   \n@@ -2996,7 +2996,7 @@ schedule_insns (void)\n      liveness.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)    \n     if (RGN_NR_BLOCKS (rgn) > 1\n-\t/* Or the only block of this region has been splitted.  */\n+\t/* Or the only block of this region has been split.  */\n \t|| RGN_HAS_REAL_EBB (rgn)\n \t/* New blocks (e.g. recovery blocks) should be processed\n \t   as parts of large regions.  */\n@@ -3159,7 +3159,7 @@ add_block1 (basic_block bb, basic_block after)\n       /* ebb_head[i] - VALID.  */\n \n       /* Source position: ebb_head[i]\n-\t Destination posistion: ebb_head[i] + 1\n+\t Destination position: ebb_head[i] + 1\n \t Last position: \n \t   RGN_BLOCKS (nr_regions) - 1\n \t Number of elements to copy: (last_position) - (source_position) + 1"}, {"sha": "818329c6db174e7424ec55949a356245e2105c78", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -64,10 +64,10 @@ typedef struct copy_body_data\n   int eh_region_offset;\n \n   /* We use the same mechanism do all sorts of different things.  Rather\n-     than enumerating the different cases, we categorize the behaviour\n+     than enumerating the different cases, we categorize the behavior\n      in the various situations.  */\n \n-  /* Indicate the desired behaviour wrt call graph edges.  We can either\n+  /* Indicate the desired behavior wrt call graph edges.  We can either\n      duplicate the edge (inlining, cloning), move the edge (versioning,\n      parallelization), or move the edges of the clones (saving).  */\n   enum copy_body_cge_which {"}, {"sha": "6f7c2ebad560cffe092f728673aca9b41b39ac1c", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -2328,7 +2328,7 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n     }\n }\n \n-/* T is either a PHI node (potentally a degenerate PHI node) or\n+/* T is either a PHI node (potentially a degenerate PHI node) or\n    a statement that is a trivial copy or constant initialization.\n \n    Attempt to eliminate T by propagating its RHS into all uses of\n@@ -2446,7 +2446,7 @@ eliminate_degenerate_phis (void)\n      time behavior with bitmaps rather than sbitmaps.  */\n   interesting_names = BITMAP_ALLOC (NULL);\n \n-  /* First phase.  Elimiante degenerate PHIs via a domiantor\n+  /* First phase.  Eliminate degenerate PHIs via a dominator\n      walk of the CFG.\n \n      Experiments have indicated that we generally get better\n@@ -2457,7 +2457,7 @@ eliminate_degenerate_phis (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n   eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR, interesting_names);\n \n-  /* Second phase.  Eliminate second order degnerate PHIs as well\n+  /* Second phase.  Eliminate second order degenerate PHIs as well\n      as trivial copies or constant initializations identified by\n      the first phase or this phase.  Basically we keep iterating\n      until our set of INTERESTING_NAMEs is empty.   */"}, {"sha": "4b63d076be961db2f5b6850dfe34078e1d84b30d", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -810,7 +810,7 @@ anything_to_prefetch_p (struct mem_ref_group *groups)\n \n /* Issue prefetches for the reference REF into loop as decided before.\n    HEAD is the number of iterations to prefetch ahead.  UNROLL_FACTOR\n-   is the factor by thet LOOP was unrolled.  */\n+   is the factor by which LOOP was unrolled.  */\n \n static void\n issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)"}, {"sha": "ff0d4d82cb6af37843aa03ec0c113bae5b4dccca", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -412,7 +412,7 @@ set_virtual_use_link (use_operand_p ptr, tree stmt)\n     } while (0)\n \n /* Initializes immediate use at USE_PTR to value VAL, and links it to the list\n-   of immeditate uses.  STMT is the current statement.  */\n+   of immediate uses.  STMT is the current statement.  */\n \n #define INITIALIZE_USE(USE_PTR, VAL, STMT)\t\t\\\n   do\t\t\t\t\t\t\t\\\n@@ -492,7 +492,7 @@ add_mustdef_op (tree stmt, tree op, mustdef_optype_p *last)\n }\n \n /* Takes elements from build_defs and turns them into def operands of STMT.\n-   TODO -- Given that def operands list is not neccessarily sorted, merging\n+   TODO -- Given that def operands list is not necessarily sorted, merging\n \t   the operands this way does not make much sense.\n \t-- Make build_defs VEC of tree *.  */\n \n@@ -579,7 +579,7 @@ finalize_ssa_defs (tree stmt)\n }\n \n /* Takes elements from build_uses and turns them into use operands of STMT.\n-   TODO -- Given that use operands list is not neccessarily sorted, merging\n+   TODO -- Given that use operands list is not necessarily sorted, merging\n \t   the operands this way does not make much sense.\n \t-- Make build_uses VEC of tree *.  */\n "}, {"sha": "b6e5ef0ccd5554ccd6bc7a5b6d28a125dcb33a7f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -357,7 +357,7 @@ vect_recog_widen_mult_pattern (tree last_stmt ATTRIBUTE_UNUSED,\n \n    where type 'TYPE' is at least double the size of type 'type', i.e - we're \n    summing elements of type 'type' into an accumulator of type 'TYPE'. This is\n-   a sepcial case of a reduction computation.\n+   a special case of a reduction computation.\n \n    Input:\n "}, {"sha": "fa419599ea6f47ab45828d4709a5fe6278e01aef", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=917f1b7ea3e4737fccda44b8dfb5c868b3d5fed4", "patch": "@@ -1116,7 +1116,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t    }\n \t  /* Case 3a, the anti-range extends into the low\n \t     part of the real range.  Thus creating a new\n-\t     low for the real reange.  */\n+\t     low for the real range.  */\n \t  else if ((compare_values (anti_max, real_min) == 1\n \t\t    || compare_values (anti_max, real_min) == 0)\n \t\t   && compare_values (anti_max, real_max) == -1)\n@@ -1129,7 +1129,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t    }\n \t  /* Case 3b, the anti-range extends into the high\n \t     part of the real range.  Thus creating a new\n-\t     higher for the real reange.  */\n+\t     higher for the real range.  */\n \t  else if (compare_values (anti_min, real_min) == 1\n \t\t   && (compare_values (anti_min, real_max) == -1\n \t\t       || compare_values (anti_min, real_max) == 0))\n@@ -2981,7 +2981,7 @@ find_assert_locations (basic_block bb)\n \t     it, create a new assertion location node for OP.  */\n \t  if (infer_value_range (stmt, op, &comp_code, &value))\n \t    {\n-\t      /* If we are able to infer a non-zero value range for OP,\n+\t      /* If we are able to infer a nonzero value range for OP,\n \t\t then walk backwards through the use-def chain to see if OP\n \t\t was set via a typecast.\n "}]}