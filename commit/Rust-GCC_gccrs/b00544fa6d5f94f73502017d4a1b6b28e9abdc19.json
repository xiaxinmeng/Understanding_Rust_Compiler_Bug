{"sha": "b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAwNTQ0ZmE2ZDVmOTRmNzM1MDIwMTdkNGExYjZiMjhlOWFiZGMxOQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-04-29T23:59:22Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-04-29T23:59:22Z"}, "message": "ira.c use DF infrastructure for combine_and_move_insns\n\nThis patch actually improves generated code, because REG_DEAD notes\nused by the old insn scan are not always present.  On x86_64, see\ngcc/wide-int-print.o:print_hex for an example of a function that is\nsmaller and uses one less callee saved reg.\n\n\t* ira.c (combine_and_move_insns): Rather than scanning insns,\n\tuse DF infrastucture to find use and def insns.\n\nFrom-SVN: r235660", "tree": {"sha": "c2be77324502170b735717d52975e6d41b0bebd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2be77324502170b735717d52975e6d41b0bebd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00544fa6d5f94f73502017d4a1b6b28e9abdc19/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10e044468a4e0599c4f52ced069d39bbef8bee62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e044468a4e0599c4f52ced069d39bbef8bee62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e044468a4e0599c4f52ced069d39bbef8bee62"}], "stats": {"total": 200, "additions": 91, "deletions": 109}, "files": [{"sha": "629b9d6be6baa43df8810d01fae5c1b319a8fea7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00544fa6d5f94f73502017d4a1b6b28e9abdc19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00544fa6d5f94f73502017d4a1b6b28e9abdc19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "patch": "@@ -1,3 +1,8 @@\n+2016-04-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* ira.c (combine_and_move_insns): Rather than scanning insns,\n+\tuse DF infrastucture to find use and def insns.\n+\n 2016-04-30  Alan Modra  <amodra@gmail.com>\n \n \tira.c (combine_and_move_insns): Move invariant conditions.."}, {"sha": "44a1ef09aa858b213906c313cd6a7e5490fc084c", "filename": "gcc/ira.c", "status": "modified", "additions": 86, "deletions": 109, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00544fa6d5f94f73502017d4a1b6b28e9abdc19/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00544fa6d5f94f73502017d4a1b6b28e9abdc19/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "patch": "@@ -3630,150 +3630,127 @@ add_store_equivs (void)\n static void\n combine_and_move_insns (void)\n {\n-  rtx_insn *insn;\n-  basic_block bb;\n-  int loop_depth;\n   bitmap cleared_regs = BITMAP_ALLOC (NULL);\n+  int max = max_reg_num ();\n \n-  FOR_EACH_BB_REVERSE_FN (bb, cfun)\n+  for (int regno = FIRST_PSEUDO_REGISTER; regno < max; regno++)\n     {\n-      loop_depth = bb_loop_depth (bb);\n-      for (insn = BB_END (bb);\n-\t   insn != PREV_INSN (BB_HEAD (bb));\n-\t   insn = PREV_INSN (insn))\n-\t{\n-\t  rtx link;\n+      if (!reg_equiv[regno].replace)\n+\tcontinue;\n \n-\t  if (! INSN_P (insn))\n-\t    continue;\n+      rtx_insn *use_insn = 0;\n+      for (df_ref use = DF_REG_USE_CHAIN (regno);\n+\t   use;\n+\t   use = DF_REF_NEXT_REG (use))\n+\tif (DF_REF_INSN_INFO (use))\n+\t  {\n+\t    if (DEBUG_INSN_P (DF_REF_INSN (use)))\n+\t      continue;\n+\t    gcc_assert (!use_insn);\n+\t    use_insn = DF_REF_INSN (use);\n+\t  }\n+      gcc_assert (use_insn);\n \n-\t  /* Don't substitute into jumps.  indirect_jump_optimize does\n-\t     this for anything we are prepared to handle.  */\n-\t  if (JUMP_P (insn))\n-\t    continue;\n+      /* Don't substitute into jumps.  indirect_jump_optimize does\n+\t this for anything we are prepared to handle.  */\n+      if (JUMP_P (use_insn))\n+\tcontinue;\n \n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    {\n-\t      if (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t  /* Make sure this insn still refers to the register.  */\n-\t\t  && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n-\t\t{\n-\t\t  int regno = REGNO (XEXP (link, 0));\n-\t\t  rtx equiv_insn;\n+      df_ref def = DF_REG_DEF_CHAIN (regno);\n+      gcc_assert (DF_REG_DEF_COUNT (regno) == 1 && DF_REF_INSN_INFO (def));\n+      rtx_insn *def_insn = DF_REF_INSN (def);\n \n-\t\t  if (! reg_equiv[regno].replace\n-\t\t      || reg_equiv[regno].loop_depth < (short) loop_depth)\n-\t\t    continue;\n+      /* We may not move instructions that can throw, since that\n+\t changes basic block boundaries and we are not prepared to\n+\t adjust the CFG to match.  */\n+      if (can_throw_internal (def_insn))\n+\tcontinue;\n \n-\t\t  /* reg_equiv[REGNO].replace gets set only when\n-\t\t     REG_N_REFS[REGNO] is 2, i.e. the register is set\n-\t\t     once and used once.  (If it were only set, but\n-\t\t     not used, flow would have deleted the setting\n-\t\t     insns.)  Hence there can only be one insn in\n-\t\t     reg_equiv[REGNO].init_insns.  */\n-\t\t  gcc_assert (reg_equiv[regno].init_insns\n-\t\t\t      && !XEXP (reg_equiv[regno].init_insns, 1));\n-\t\t  equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n-\n-\t\t  /* We may not move instructions that can throw, since\n-\t\t     that changes basic block boundaries and we are not\n-\t\t     prepared to adjust the CFG to match.  */\n-\t\t  if (can_throw_internal (equiv_insn))\n-\t\t    continue;\n+      basic_block use_bb = BLOCK_FOR_INSN (use_insn);\n+      basic_block def_bb = BLOCK_FOR_INSN (def_insn);\n+      if (bb_loop_depth (use_bb) > bb_loop_depth (def_bb))\n+\tcontinue;\n \n-\t\t  if (asm_noperands (PATTERN (equiv_insn)) < 0\n-\t\t      && validate_replace_rtx (regno_reg_rtx[regno],\n-\t\t\t\t\t       *(reg_equiv[regno].src_p), insn))\n-\t\t    {\n-\t\t      rtx equiv_link;\n-\t\t      rtx last_link;\n-\t\t      rtx note;\n-\n-\t\t      /* Find the last note.  */\n-\t\t      for (last_link = link; XEXP (last_link, 1);\n-\t\t\t   last_link = XEXP (last_link, 1))\n-\t\t\t;\n-\n-\t\t      /* Append the REG_DEAD notes from equiv_insn.  */\n-\t\t      equiv_link = REG_NOTES (equiv_insn);\n-\t\t      while (equiv_link)\n-\t\t\t{\n-\t\t\t  note = equiv_link;\n-\t\t\t  equiv_link = XEXP (equiv_link, 1);\n-\t\t\t  if (REG_NOTE_KIND (note) == REG_DEAD)\n-\t\t\t    {\n-\t\t\t      remove_note (equiv_insn, note);\n-\t\t\t      XEXP (last_link, 1) = note;\n-\t\t\t      XEXP (note, 1) = NULL_RTX;\n-\t\t\t      last_link = note;\n-\t\t\t    }\n-\t\t\t}\n+      if (asm_noperands (PATTERN (def_insn)) < 0\n+\t  && validate_replace_rtx (regno_reg_rtx[regno],\n+\t\t\t\t   *reg_equiv[regno].src_p, use_insn))\n+\t{\n+\t  rtx link;\n+\t  /* Append the REG_DEAD notes from def_insn.  */\n+\t  for (rtx *p = &REG_NOTES (def_insn); (link = *p) != 0; )\n+\t    {\n+\t      if (REG_NOTE_KIND (XEXP (link, 0)) == REG_DEAD)\n+\t\t{\n+\t\t  *p = XEXP (link, 1);\n+\t\t  XEXP (link, 1) = REG_NOTES (use_insn);\n+\t\t  REG_NOTES (use_insn) = link;\n+\t\t}\n+\t      else\n+\t\tp = &XEXP (link, 1);\n+\t    }\n \n-\t\t      remove_death (regno, insn);\n-\t\t      SET_REG_N_REFS (regno, 0);\n-\t\t      REG_FREQ (regno) = 0;\n-\t\t      delete_insn (equiv_insn);\n+\t  remove_death (regno, use_insn);\n+\t  SET_REG_N_REFS (regno, 0);\n+\t  REG_FREQ (regno) = 0;\n+\t  delete_insn (def_insn);\n \n-\t\t      reg_equiv[regno].init_insns\n-\t\t\t= reg_equiv[regno].init_insns->next ();\n+\t  reg_equiv[regno].init_insns = NULL;\n+\t  ira_reg_equiv[regno].init_insns = NULL;\n+\t  bitmap_set_bit (cleared_regs, regno);\n+\t}\n \n-\t\t      ira_reg_equiv[regno].init_insns = NULL;\n-\t\t      bitmap_set_bit (cleared_regs, regno);\n-\t\t    }\n-\t\t  /* Move the initialization of the register to just before\n-\t\t     INSN.  Update the flow information.  */\n-\t\t  else if (prev_nondebug_insn (insn) != equiv_insn)\n-\t\t    {\n-\t\t      rtx_insn *new_insn;\n+      /* Move the initialization of the register to just before\n+\t USE_INSN.  Update the flow information.  */\n+      else if (prev_nondebug_insn (use_insn) != def_insn)\n+\t{\n+\t  rtx_insn *new_insn;\n \n-\t\t      new_insn = emit_insn_before (PATTERN (equiv_insn), insn);\n-\t\t      REG_NOTES (new_insn) = REG_NOTES (equiv_insn);\n-\t\t      REG_NOTES (equiv_insn) = 0;\n-\t\t      /* Rescan it to process the notes.  */\n-\t\t      df_insn_rescan (new_insn);\n+\t  new_insn = emit_insn_before (PATTERN (def_insn), use_insn);\n+\t  REG_NOTES (new_insn) = REG_NOTES (def_insn);\n+\t  REG_NOTES (def_insn) = 0;\n+\t  /* Rescan it to process the notes.  */\n+\t  df_insn_rescan (new_insn);\n \n-\t\t      /* Make sure this insn is recognized before\n-\t\t\t reload begins, otherwise\n-\t\t\t eliminate_regs_in_insn will die.  */\n-\t\t      INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n+\t  /* Make sure this insn is recognized before reload begins,\n+\t     otherwise eliminate_regs_in_insn will die.  */\n+\t  INSN_CODE (new_insn) = INSN_CODE (def_insn);\n \n-\t\t      delete_insn (equiv_insn);\n+\t  delete_insn (def_insn);\n \n-\t\t      XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n+\t  XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n \n-\t\t      REG_BASIC_BLOCK (regno) = bb->index;\n-\t\t      REG_N_CALLS_CROSSED (regno) = 0;\n-\t\t      REG_FREQ_CALLS_CROSSED (regno) = 0;\n-\t\t      REG_N_THROWING_CALLS_CROSSED (regno) = 0;\n-\t\t      REG_LIVE_LENGTH (regno) = 2;\n+\t  REG_BASIC_BLOCK (regno) = use_bb->index;\n+\t  REG_N_CALLS_CROSSED (regno) = 0;\n+\t  REG_FREQ_CALLS_CROSSED (regno) = 0;\n+\t  REG_N_THROWING_CALLS_CROSSED (regno) = 0;\n+\t  REG_LIVE_LENGTH (regno) = 2;\n \n-\t\t      if (insn == BB_HEAD (bb))\n-\t\t\tBB_HEAD (bb) = PREV_INSN (insn);\n+\t  if (use_insn == BB_HEAD (use_bb))\n+\t    BB_HEAD (use_bb) = new_insn;\n \n-\t\t      ira_reg_equiv[regno].init_insns\n-\t\t\t= gen_rtx_INSN_LIST (VOIDmode, new_insn, NULL_RTX);\n-\t\t      bitmap_set_bit (cleared_regs, regno);\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  ira_reg_equiv[regno].init_insns\n+\t    = gen_rtx_INSN_LIST (VOIDmode, new_insn, NULL_RTX);\n+\t  bitmap_set_bit (cleared_regs, regno);\n \t}\n     }\n \n   if (!bitmap_empty_p (cleared_regs))\n     {\n+      basic_block bb;\n+\n       FOR_EACH_BB_FN (bb, cfun)\n \t{\n \t  bitmap_and_compl_into (DF_LR_IN (bb), cleared_regs);\n \t  bitmap_and_compl_into (DF_LR_OUT (bb), cleared_regs);\n-\t  if (! df_live)\n+\t  if (!df_live)\n \t    continue;\n \t  bitmap_and_compl_into (DF_LIVE_IN (bb), cleared_regs);\n \t  bitmap_and_compl_into (DF_LIVE_OUT (bb), cleared_regs);\n \t}\n \n       /* Last pass - adjust debug insns referencing cleared regs.  */\n       if (MAY_HAVE_DEBUG_INSNS)\n-\tfor (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tfor (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t  if (DEBUG_INSN_P (insn))\n \t    {\n \t      rtx old_loc = INSN_VAR_LOCATION_LOC (insn);"}]}