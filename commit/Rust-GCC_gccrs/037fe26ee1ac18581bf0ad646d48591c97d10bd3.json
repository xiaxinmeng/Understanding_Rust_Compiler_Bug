{"sha": "037fe26ee1ac18581bf0ad646d48591c97d10bd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM3ZmUyNmVlMWFjMTg1ODFiZjBhZDY0NmQ0ODU5MWM5N2QxMGJkMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-02T10:32:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-02T10:40:47Z"}, "message": "expansion: Further improve double-word modulo, division and divmod [PR97459]\n\nThe following patch implements what Thomas wrote about, in particular\nthat we can handle also double-word divison by the constants for which\nthe earlier patch optimized modulo (if it would be otherwise a library\ncall) and that we can also easily handle such constants shifted to the left.\nUnfortunately, seems CSE isn't able to optimize away the two almost\nidentical sequences (one to compute remainder, one to compute quotient),\nprobably because of the ADD_OVERFLOW introduced jumps, so the patch also\nadjusts expand_DIVMOD.\n\n2020-12-02  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/97459\n\t* optabs.h (expand_doubleword_divmod): Declare.\n\t* optabs.c (expand_doubleword_divmod): New function.\n\t(expand_binop): Use it.\n\t* internal-fn.c (expand_DIVMOD): Likewise.\n\n\t* gcc.target/i386/pr97282.c (foo): Use 123456 divisor instead of\n\t10.\n\t* gcc.dg/pr97459-1.c (TESTS): Add tests for 10, 12 and\n\t6144.\n\t* gcc.dg/pr97459-2.c (TESTS): Likewise.\n\t* gcc.dg/pr97459-3.c: New test.\n\t* gcc.dg/pr97459-4.c: New test.\n\t* gcc.dg/pr97459-5.c: New test.\n\t* gcc.dg/pr97459-6.c: New test.", "tree": {"sha": "a6f69e57d3e6391e15795c1382babe8437afd09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6f69e57d3e6391e15795c1382babe8437afd09b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/037fe26ee1ac18581bf0ad646d48591c97d10bd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037fe26ee1ac18581bf0ad646d48591c97d10bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/037fe26ee1ac18581bf0ad646d48591c97d10bd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037fe26ee1ac18581bf0ad646d48591c97d10bd3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "337d6362458ab033d3bfe287dda37f9da5577406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337d6362458ab033d3bfe287dda37f9da5577406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337d6362458ab033d3bfe287dda37f9da5577406"}], "stats": {"total": 448, "additions": 414, "deletions": 34}, "files": [{"sha": "41223ff7d82ba984f1f4e89e75b805e35e6b66b5", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 59, "deletions": 18, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -3230,27 +3230,68 @@ expand_DIVMOD (internal_fn, gcall *call_stmt)\n \t the division and modulo and if it emits any library calls or any\n \t {,U}{DIV,MOD} rtxes throw it away and use a divmod optab or\n \t divmod libcall.  */\n-      struct separate_ops ops;\n-      ops.code = TRUNC_DIV_EXPR;\n-      ops.type = type;\n-      ops.op0 = make_tree (ops.type, op0);\n-      ops.op1 = arg1;\n-      ops.op2 = NULL_TREE;\n-      ops.location = gimple_location (call_stmt);\n-      start_sequence ();\n-      quotient = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n-      if (contains_call_div_mod (get_insns ()))\n-\tquotient = NULL_RTX;\n-      else\n+      scalar_int_mode int_mode;\n+      if (remainder == NULL_RTX\n+\t  && optimize\n+\t  && CONST_INT_P (op1)\n+\t  && !pow2p_hwi (INTVAL (op1))\n+\t  && is_int_mode (TYPE_MODE (type), &int_mode)\n+\t  && GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n+\t  && optab_handler (and_optab, word_mode) != CODE_FOR_nothing\n+\t  && optab_handler (add_optab, word_mode) != CODE_FOR_nothing\n+\t  && optimize_insn_for_speed_p ())\n+\t{\n+\t  rtx_insn *last = get_last_insn ();\n+\t  remainder = NULL_RTX;\n+\t  quotient = expand_doubleword_divmod (int_mode, op0, op1, &remainder,\n+\t\t\t\t\t       TYPE_UNSIGNED (type));\n+\t  if (quotient != NULL_RTX)\n+\t    {\n+\t      if (optab_handler (mov_optab, int_mode) != CODE_FOR_nothing)\n+\t\t{\n+\t\t  rtx_insn *move = emit_move_insn (quotient, quotient);\n+\t\t  set_dst_reg_note (move, REG_EQUAL,\n+\t\t\t\t    gen_rtx_fmt_ee (TYPE_UNSIGNED (type)\n+\t\t\t\t\t\t    ? UDIV : DIV, int_mode,\n+\t\t\t\t\t\t    copy_rtx (op0), op1),\n+\t\t\t\t    quotient);\n+\t\t  move = emit_move_insn (remainder, remainder);\n+\t\t  set_dst_reg_note (move, REG_EQUAL,\n+\t\t\t\t    gen_rtx_fmt_ee (TYPE_UNSIGNED (type)\n+\t\t\t\t\t\t    ? UMOD : MOD, int_mode,\n+\t\t\t\t\t\t    copy_rtx (op0), op1),\n+\t\t\t\t    quotient);\n+\t\t}\n+\t    }\n+\t  else\n+\t    delete_insns_since (last);\n+\t}\n+\n+      if (remainder == NULL_RTX)\n \t{\n-\t  ops.code = TRUNC_MOD_EXPR;\n-\t  remainder = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  struct separate_ops ops;\n+\t  ops.code = TRUNC_DIV_EXPR;\n+\t  ops.type = type;\n+\t  ops.op0 = make_tree (ops.type, op0);\n+\t  ops.op1 = arg1;\n+\t  ops.op2 = NULL_TREE;\n+\t  ops.location = gimple_location (call_stmt);\n+\t  start_sequence ();\n+\t  quotient = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  if (contains_call_div_mod (get_insns ()))\n-\t    remainder = NULL_RTX;\n+\t    quotient = NULL_RTX;\n+\t  else\n+\t    {\n+\t      ops.code = TRUNC_MOD_EXPR;\n+\t      remainder = expand_expr_real_2 (&ops, NULL_RTX, mode,\n+\t\t\t\t\t      EXPAND_NORMAL);\n+\t      if (contains_call_div_mod (get_insns ()))\n+\t\tremainder = NULL_RTX;\n+\t    }\n+\t  if (remainder)\n+\t    insns = get_insns ();\n+\t  end_sequence ();\n \t}\n-      if (remainder)\n-\tinsns = get_insns ();\n-      end_sequence ();\n     }\n \n   if (remainder)"}, {"sha": "41daa483869f6f73ac38822e5b79aeb66b86fb0d", "filename": "gcc/optabs.c", "status": "modified", "additions": 120, "deletions": 12, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -1118,6 +1118,99 @@ expand_doubleword_mod (machine_mode mode, rtx op0, rtx op1, bool unsignedp)\n     }\n   return NULL_RTX;\n }\n+\n+/* Similarly to the above function, but compute both quotient and remainder.\n+   Quotient can be computed from the remainder as:\n+   rem = op0 % op1;  // Handled using expand_doubleword_mod\n+   quot = (op0 - rem) * inv; // inv is multiplicative inverse of op1 modulo\n+\t\t\t     // 2 * BITS_PER_WORD\n+\n+   We can also handle cases where op1 is a multiple of power of two constant\n+   and constant handled by expand_doubleword_mod.\n+   op11 = 1 << __builtin_ctz (op1);\n+   op12 = op1 / op11;\n+   rem1 = op0 % op12;  // Handled using expand_doubleword_mod\n+   quot1 = (op0 - rem1) * inv; // inv is multiplicative inverse of op12 modulo\n+\t\t\t       // 2 * BITS_PER_WORD\n+   rem = (quot1 % op11) * op12 + rem1;\n+   quot = quot1 / op11;  */\n+\n+rtx\n+expand_doubleword_divmod (machine_mode mode, rtx op0, rtx op1, rtx *rem,\n+\t\t\t  bool unsignedp)\n+{\n+  *rem = NULL_RTX;\n+\n+  /* Negative dividend should have been optimized into positive,\n+     similarly modulo by 1 and modulo by power of two is optimized\n+     differently too.  */\n+  if (INTVAL (op1) <= 1 || pow2p_hwi (INTVAL (op1)))\n+    return NULL_RTX;\n+\n+  rtx op11 = const1_rtx;\n+  rtx op12 = op1;\n+  if ((INTVAL (op1) & 1) == 0)\n+    {\n+      int bit = ctz_hwi (INTVAL (op1));\n+      op11 = GEN_INT (HOST_WIDE_INT_1 << bit);\n+      op12 = GEN_INT (INTVAL (op1) >> bit);\n+    }\n+\n+  rtx rem1 = expand_doubleword_mod (mode, op0, op12, unsignedp);\n+  if (rem1 == NULL_RTX)\n+    return NULL_RTX;\n+\n+  int prec = 2 * BITS_PER_WORD;\n+  wide_int a = wide_int::from (INTVAL (op12), prec + 1, UNSIGNED);\n+  wide_int b = wi::shifted_mask (prec, 1, false, prec + 1);\n+  wide_int m = wide_int::from (wi::mod_inv (a, b), prec, UNSIGNED);\n+  rtx inv = immed_wide_int_const (m, mode);\n+\n+  rtx_insn *last = get_last_insn ();\n+  rtx quot1 = expand_simple_binop (mode, MINUS, op0, rem1,\n+\t\t\t\t   NULL_RTX, unsignedp, OPTAB_DIRECT);\n+  if (quot1 == NULL_RTX)\n+    return NULL_RTX;\n+\n+  quot1 = expand_simple_binop (mode, MULT, quot1, inv,\n+\t\t\t       NULL_RTX, unsignedp, OPTAB_DIRECT);\n+  if (quot1 == NULL_RTX)\n+    return NULL_RTX;\n+\n+  if (op11 != const1_rtx)\n+    {\n+      rtx rem2 = expand_divmod (1, TRUNC_MOD_EXPR, mode, quot1, op11,\n+\t\t\t\tNULL_RTX, unsignedp);\n+      if (rem2 == NULL_RTX)\n+\treturn NULL_RTX;\n+\n+      rem2 = expand_simple_binop (mode, MULT, rem2, op12, NULL_RTX,\n+\t\t\t\t  unsignedp, OPTAB_DIRECT);\n+      if (rem2 == NULL_RTX)\n+\treturn NULL_RTX;\n+\n+      rem2 = expand_simple_binop (mode, PLUS, rem2, rem1, NULL_RTX,\n+\t\t\t\t  unsignedp, OPTAB_DIRECT);\n+      if (rem2 == NULL_RTX)\n+\treturn NULL_RTX;\n+\n+      rtx quot2 = expand_divmod (0, TRUNC_DIV_EXPR, mode, quot1, op11,\n+\t\t\t\t NULL_RTX, unsignedp);\n+      if (quot2 == NULL_RTX)\n+\treturn NULL_RTX;\n+\n+      rem1 = rem2;\n+      quot1 = quot2;\n+    }\n+\n+  /* Punt if we need any library calls.  */\n+  for (; last; last = NEXT_INSN (last))\n+    if (CALL_P (last))\n+      return NULL_RTX;\n+\n+  *rem = rem1;\n+  return quot1;\n+}\n \f\n /* Wrapper around expand_binop which takes an rtx code to specify\n    the operation to perform, not an optab pointer.  All other\n@@ -1999,7 +2092,10 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n     }\n \n   /* Attempt to synthetize double word modulo by constant divisor.  */\n-  if ((binoptab == umod_optab || binoptab == smod_optab)\n+  if ((binoptab == umod_optab\n+       || binoptab == smod_optab\n+       || binoptab == udiv_optab\n+       || binoptab == sdiv_optab)\n       && optimize\n       && CONST_INT_P (op1)\n       && is_int_mode (mode, &int_mode)\n@@ -2008,21 +2104,33 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && optab_handler (add_optab, word_mode) != CODE_FOR_nothing\n       && optimize_insn_for_speed_p ())\n     {\n-      rtx remainder = expand_doubleword_mod (int_mode, op0, op1,\n-\t\t\t\t\t     binoptab == umod_optab);\n-      if (remainder != NULL_RTX)\n+      rtx res = NULL_RTX;\n+      if ((binoptab == umod_optab || binoptab == smod_optab)\n+\t  && (INTVAL (op1) & 1) == 0)\n+\tres = expand_doubleword_mod (int_mode, op0, op1,\n+\t\t\t\t     binoptab == umod_optab);\n+      else\n+\t{\n+\t  rtx quot = expand_doubleword_divmod (int_mode, op0, op1, &res,\n+\t\t\t\t\t       binoptab == umod_optab\n+\t\t\t\t\t       || binoptab == udiv_optab);\n+\t  if (quot == NULL_RTX)\n+\t    res = NULL_RTX;\n+\t  else if (binoptab == udiv_optab || binoptab == sdiv_optab)\n+\t    res = quot;\n+\t}\n+      if (res != NULL_RTX)\n \t{\n \t  if (optab_handler (mov_optab, int_mode) != CODE_FOR_nothing)\n \t    {\n-\t      rtx_insn *move = emit_move_insn (target ? target : remainder,\n-\t\t\t\t\t       remainder);\n-\t      set_dst_reg_note (move,\n-\t\t\t\tREG_EQUAL,\n-\t\t\t\tgen_rtx_fmt_ee (UMOD, int_mode,\n-\t\t\t\t\t\tcopy_rtx (op0), op1),\n-\t\t\t\ttarget ? target : remainder);\n+\t      rtx_insn *move = emit_move_insn (target ? target : res,\n+\t\t\t\t\t       res);\n+\t      set_dst_reg_note (move, REG_EQUAL,\n+\t\t\t\tgen_rtx_fmt_ee (optab_to_code (binoptab),\n+\t\t\t\t\t\tint_mode, copy_rtx (op0), op1),\n+\t\t\t\ttarget ? target : res);\n \t    }\n-\t  return remainder;\n+\t  return res;\n \t}\n       else\n \tdelete_insns_since (last);"}, {"sha": "87fed90a18a008b35d7e2c7a5edfba50136387a7", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -183,6 +183,8 @@ extern bool force_expand_binop (machine_mode, optab, rtx, rtx, rtx, int,\n \t\t\t\tenum optab_methods);\n extern rtx expand_vector_broadcast (machine_mode, rtx);\n \n+extern rtx expand_doubleword_divmod (machine_mode, rtx, rtx, rtx *, bool);\n+\n /* Generate code for a simple binary or unary operation.  \"Simple\" in\n    this case means \"can be unambiguously described by a (mode, code)\n    pair and mapped to a single optab.\"  */"}, {"sha": "96c7ab6d7abb7a1b6d0c56cfb4594cebde386811", "filename": "gcc/testsuite/gcc.dg/pr97459-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-1.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -24,7 +24,7 @@ T __attribute__((noipa)) foo (T x, T n) { return x % n; }\n #define C3(n) C2(n##0) C2(n##4) C2(n##9)\n #define C4(n) C3(n##0) C3(n##3) C3(n##7)\n #endif\n-#define TESTS C4(1)\n+#define TESTS C4(1) C1(10010) C1(10012) C1(16144)\n \n TESTS\n "}, {"sha": "0e2bfbd5c102eb450f69fffa5532233bae46c7a8", "filename": "gcc/testsuite/gcc.dg/pr97459-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-2.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -26,7 +26,7 @@ T __attribute__((noipa)) foo (T x, T n) { return x % n; }\n #define C3(n) C2(n##0) C2(n##4) C2(n##9)\n #define C4(n) C3(n##0) C3(n##3) C3(n##7)\n #endif\n-#define TESTS C4(1)\n+#define TESTS C4(1) C1(10010) C1(10012) C1(16144)\n \n TESTS\n "}, {"sha": "7fbb7eec280d870cb32e29c2597993fb81f00da3", "filename": "gcc/testsuite/gcc.dg/pr97459-3.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-3.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -0,0 +1,54 @@\n+/* PR rtl-optimization/97459 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-DEXPENSIVE\" { target run_expensive_tests } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __uint128_t T;\n+#else\n+typedef unsigned long long T;\n+#endif\n+\n+T __attribute__((noipa)) foo (T x, T n) { return x / n; }\n+#define C(n) T __attribute__((noipa)) foo##n (T x) { return x / (n - 10000); }\n+\n+#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)\n+#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \\\n+\t      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)\n+#ifdef EXPENSIVE\n+#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \\\n+\t      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \\\n+\t      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)\n+#else\n+#define C3(n) C2(n##0) C2(n##4) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##3) C3(n##7)\n+#endif\n+#define TESTS C4(1) C1(10010) C1(10012) C1(16144)\n+\n+TESTS\n+\n+struct S { T x; T (*foo) (T); };\n+\n+#undef C\n+#define C(n) { n - 10000, foo##n },\n+\n+struct S tests[] = {\n+TESTS\n+  { 0, 0 }\n+};\n+\n+int\n+main ()\n+{\n+  int i, j, k;\n+  for (k = 0; tests[k].x; k++)\n+    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)\n+      for (j = -5; j <= 5; j++)\n+\t{\n+\t  T x = ((T) 1 << i) + j;\n+\t  if (foo (x, tests[k].x) != tests[k].foo (x))\n+\t    __builtin_abort ();\n+\t}\n+  return 0;\n+}"}, {"sha": "33e49a9cb5da1545791bd20b4d9d5281a64fec03", "filename": "gcc/testsuite/gcc.dg/pr97459-4.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-4.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -0,0 +1,57 @@\n+/* PR rtl-optimization/97459 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-DEXPENSIVE\" { target run_expensive_tests } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __int128_t T;\n+typedef __uint128_t U;\n+#else\n+typedef long long T;\n+typedef unsigned long long U;\n+#endif\n+\n+T __attribute__((noipa)) foo (T x, T n) { return x / n; }\n+#define C(n) T __attribute__((noipa)) foo##n (T x) { return x / (n - 10000); }\n+\n+#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)\n+#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \\\n+\t      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)\n+#ifdef EXPENSIVE\n+#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \\\n+\t      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \\\n+\t      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)\n+#else\n+#define C3(n) C2(n##0) C2(n##4) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##3) C3(n##7)\n+#endif\n+#define TESTS C4(1) C1(10010) C1(10012) C1(16144)\n+\n+TESTS\n+\n+struct S { T x; T (*foo) (T); };\n+\n+#undef C\n+#define C(n) { n - 10000, foo##n },\n+\n+struct S tests[] = {\n+TESTS\n+  { 0, 0 }\n+};\n+\n+int\n+main ()\n+{\n+  int i, j, k;\n+  for (k = 0; tests[k].x; k++)\n+    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)\n+      for (j = -5; j <= 5; j++)\n+\t{\n+\t  U x = ((U) 1 << i) + j;\n+\t  if (foo ((T) x, tests[k].x) != tests[k].foo ((T) x)\n+\t      || foo ((T) -x, tests[k].x) != tests[k].foo ((T) -x))\n+\t    __builtin_abort ();\n+\t}\n+  return 0;\n+}"}, {"sha": "f658a5a8968b6247569614165a597911fb9e7008", "filename": "gcc/testsuite/gcc.dg/pr97459-5.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-5.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -0,0 +1,56 @@\n+/* PR rtl-optimization/97459 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-DEXPENSIVE\" { target run_expensive_tests } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __uint128_t T;\n+#else\n+typedef unsigned long long T;\n+#endif\n+\n+T __attribute__((noipa)) foo (T x, T n, T *r) { *r = x % n; return x / n; }\n+#define C(n) T __attribute__((noipa)) foo##n (T x, T *r) { *r = x % (n - 10000); return x / (n - 10000); }\n+\n+#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)\n+#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \\\n+\t      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)\n+#ifdef EXPENSIVE\n+#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \\\n+\t      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \\\n+\t      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)\n+#else\n+#define C3(n) C2(n##0) C2(n##4) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##3) C3(n##7)\n+#endif\n+#define TESTS C4(1) C1(10010) C1(10012) C1(16144)\n+\n+TESTS\n+\n+struct S { T x; T (*foo) (T, T *); };\n+\n+#undef C\n+#define C(n) { n - 10000, foo##n },\n+\n+struct S tests[] = {\n+TESTS\n+  { 0, 0 }\n+};\n+\n+int\n+main ()\n+{\n+  int i, j, k;\n+  for (k = 0; tests[k].x; k++)\n+    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)\n+      for (j = -5; j <= 5; j++)\n+\t{\n+\t  T x = ((T) 1 << i) + j;\n+\t  T r1, r2;\n+\t  if (foo (x, tests[k].x, &r1) != tests[k].foo (x, &r2)\n+\t      || r1 != r2)\n+\t    __builtin_abort ();\n+\t}\n+  return 0;\n+}"}, {"sha": "d4602be57dc1a302aa2b35ac68f5fc0dd288f993", "filename": "gcc/testsuite/gcc.dg/pr97459-6.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-6.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -0,0 +1,62 @@\n+/* PR rtl-optimization/97459 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-DEXPENSIVE\" { target run_expensive_tests } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __int128_t T;\n+typedef __uint128_t U;\n+#else\n+typedef long long T;\n+typedef unsigned long long U;\n+#endif\n+\n+T __attribute__((noipa)) foo (T x, T n, T *r) { *r = x % n; return x / n; }\n+#define C(n) T __attribute__((noipa)) foo##n (T x, T *r) { *r = x % (n - 10000); return x / (n - 10000); }\n+\n+#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)\n+#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \\\n+\t      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)\n+#ifdef EXPENSIVE\n+#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \\\n+\t      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \\\n+\t      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)\n+#else\n+#define C3(n) C2(n##0) C2(n##4) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##3) C3(n##7)\n+#endif\n+#define TESTS C4(1) C1(10010) C1(10012) C1(16144)\n+\n+TESTS\n+\n+struct S { T x; T (*foo) (T, T *); };\n+\n+#undef C\n+#define C(n) { n - 10000, foo##n },\n+\n+struct S tests[] = {\n+TESTS\n+  { 0, 0 }\n+};\n+\n+int\n+main ()\n+{\n+  int i, j, k;\n+  for (k = 0; tests[k].x; k++)\n+    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)\n+      for (j = -5; j <= 5; j++)\n+\t{\n+\t  U x = ((U) 1 << i) + j;\n+\t  T r1 = 0, r2 = 0;\n+\t  if (foo ((T) x, tests[k].x, &r1) != tests[k].foo ((T) x, &r2)\n+\t      || r1 != r2)\n+\t    __builtin_abort ();\n+\t  r1 = 0; r2 = 0;\n+\t  if (foo ((T) -x, tests[k].x, &r1) != tests[k].foo ((T) -x, &r2)\n+\t      || r1 != r2)\n+\t    __builtin_abort ();\n+\t}\n+  return 0;\n+}"}, {"sha": "94ce50b6b18708b1242d3298f681a33268c165f6", "filename": "gcc/testsuite/gcc.target/i386/pr97282.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97282.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037fe26ee1ac18581bf0ad646d48591c97d10bd3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97282.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97282.c?ref=037fe26ee1ac18581bf0ad646d48591c97d10bd3", "patch": "@@ -18,8 +18,8 @@ foo (T x)\n   unsigned long ret = 0;\n   while (x > 0)\n     {\n-      ret = ret + x % 10;\n-      x = x / 10;\n+      ret = ret + x % 123456;\n+      x = x / 123456;\n     }\n   return ret;\n }"}]}