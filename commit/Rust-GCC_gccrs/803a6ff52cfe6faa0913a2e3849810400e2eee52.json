{"sha": "803a6ff52cfe6faa0913a2e3849810400e2eee52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAzYTZmZjUyY2ZlNmZhYTA5MTNhMmUzODQ5ODEwNDAwZTJlZWU1Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-09-03T19:03:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-03T19:03:43Z"}, "message": "cshift0.c (DEF_COPY_LOOP, [...]): New.\n\n        * intrinsics/cshift0.c (DEF_COPY_LOOP, copy_loop_int, copy_loop_long,\n        copy_loop_double, copy_loop_ldouble): New.\n        (__cshift0): Make shift type ssize_t.  Use % operator instead of\n        div.  Use specialized versions of copy loop depending on the shape.\n\nFrom-SVN: r87045", "tree": {"sha": "45031e40045a83813e4ccdecda3fff4a9be7cbb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45031e40045a83813e4ccdecda3fff4a9be7cbb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/803a6ff52cfe6faa0913a2e3849810400e2eee52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803a6ff52cfe6faa0913a2e3849810400e2eee52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/803a6ff52cfe6faa0913a2e3849810400e2eee52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803a6ff52cfe6faa0913a2e3849810400e2eee52/comments", "author": null, "committer": null, "parents": [{"sha": "61fec9ffac35d5cb530c9f1e757e7796d8488281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61fec9ffac35d5cb530c9f1e757e7796d8488281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61fec9ffac35d5cb530c9f1e757e7796d8488281"}], "stats": {"total": 111, "additions": 92, "deletions": 19}, "files": [{"sha": "5f29a04980ec25fc50874847a5261c917b6727d2", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/803a6ff52cfe6faa0913a2e3849810400e2eee52/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/803a6ff52cfe6faa0913a2e3849810400e2eee52/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=803a6ff52cfe6faa0913a2e3849810400e2eee52", "patch": "@@ -1,3 +1,10 @@\n+2004-09-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* intrinsics/cshift0.c (DEF_COPY_LOOP, copy_loop_int, copy_loop_long,\n+\tcopy_loop_double, copy_loop_ldouble): New.\n+\t(__cshift0): Make shift type ssize_t.  Use % operator instead of\n+\tdiv.  Use specialized versions of copy loop depending on the shape.\n+\n 2004-09-02  Paul Brook  <paul@codesourcery.com>\n \n \t* io/format.c (parse_format_list): Set repeat count for P descriptors."}, {"sha": "a988827a826e3375d28e9a1c0454087a9481229f", "filename": "libgfortran/intrinsics/cshift0.c", "status": "modified", "additions": 85, "deletions": 19, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/803a6ff52cfe6faa0913a2e3849810400e2eee52/libgfortran%2Fintrinsics%2Fcshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/803a6ff52cfe6faa0913a2e3849810400e2eee52/libgfortran%2Fintrinsics%2Fcshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcshift0.c?ref=803a6ff52cfe6faa0913a2e3849810400e2eee52", "patch": "@@ -25,25 +25,61 @@ Boston, MA 02111-1307, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n-/* TODO: make this work for large shifts when\n-   sizeof(int) < sizeof (index_type).  */\n+\n+/* \"Templatized\" helper function for the inner shift loop.  */\n+\n+#define DEF_COPY_LOOP(NAME, TYPE)\t\t\t\t\t\\\n+static inline void\t\t\t\t\t\t\t\\\n+copy_loop_##NAME (void *xdest, const void *xsrc,\t\t\t\\\n+\t\t  size_t roff, size_t soff,\t\t\t\t\\\n+\t\t  index_type len, index_type shift)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  TYPE *dest = xdest;\t\t\t\t\t\t\t\\\n+  const TYPE *src;\t\t\t\t\t\t\t\\\n+  index_type i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  roff /= sizeof (TYPE);\t\t\t\t\t\t\\\n+  soff /= sizeof (TYPE);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  src = xsrc;\t\t\t\t\t\t\t\t\\\n+  src += shift * soff;\t\t\t\t\t\t\t\\\n+  for (i = 0; i < len - shift; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      *dest = *src;\t\t\t\t\t\t\t\\\n+      dest += roff;\t\t\t\t\t\t\t\\\n+      src += soff;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  src = xsrc;\t\t\t\t\t\t\t\t\\\n+  for (i = 0; i < shift; ++i)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      *dest = *src;\t\t\t\t\t\t\t\\\n+      dest += roff;\t\t\t\t\t\t\t\\\n+      src += soff;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+DEF_COPY_LOOP(int, int)\n+DEF_COPY_LOOP(long, long)\n+DEF_COPY_LOOP(double, double)\n+DEF_COPY_LOOP(ldouble, long double)\n+\n \n static void\n __cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n-    int shift, int which)\n+\t   ssize_t shift, int which)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS - 1];\n   index_type rstride0;\n   index_type roffset;\n   char *rptr;\n-  char *dest;\n+\n   /* s.* indicates the source array.  */\n   index_type sstride[GFC_MAX_DIMENSIONS - 1];\n   index_type sstride0;\n   index_type soffset;\n   const char *sptr;\n-  const char *src;\n \n   index_type count[GFC_MAX_DIMENSIONS - 1];\n   index_type extent[GFC_MAX_DIMENSIONS - 1];\n@@ -64,7 +100,7 @@ __cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   size = GFC_DESCRIPTOR_SIZE (array);\n   n = 0;\n \n-/* Initialized for avoiding compiler warnings.  */\n+  /* Initialized for avoiding compiler warnings.  */\n   roffset = size;\n   soffset = size;\n   len = 0;\n@@ -120,24 +156,55 @@ __cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   rptr = ret->data;\n   sptr = array->data;\n \n-  shift = (div (shift, len)).rem;\n+  shift = shift % (ssize_t)len;\n   if (shift < 0)\n     shift += len;\n \n   while (rptr)\n     {\n       /* Do the shift for this dimension.  */\n-      src = &sptr[shift * soffset];\n-      dest = rptr;\n-      for (n = 0; n < len; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          if (n == len - shift - 1)\n-            src = sptr;\n-          else\n-            src += soffset;\n-        }\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t len1 = shift * size;\n+\t  size_t len2 = (len - shift) * size;\n+\t  memcpy (rptr, sptr + len1, len2);\n+\t  memcpy (rptr + len2, sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we'll have to perform the copy one element at\n+\t     a time.  We can speed this up a tad for common cases of \n+\t     fundamental types.  */\n+\t  if (size == sizeof(int))\n+\t    copy_loop_int (rptr, sptr, roffset, soffset, len, shift);\n+\t  else if (size == sizeof(long))\n+\t    copy_loop_long (rptr, sptr, roffset, soffset, len, shift);\n+\t  else if (size == sizeof(double))\n+\t    copy_loop_double (rptr, sptr, roffset, soffset, len, shift);\n+\t  else if (size == sizeof(long double))\n+\t    copy_loop_ldouble (rptr, sptr, roffset, soffset, len, shift);\n+\t  else\n+\t    {\n+\t      char *dest = rptr;\n+\t      const char *src = &sptr[shift * soffset];\n+\n+\t      for (n = 0; n < len - shift; n++)\n+\t\t{\n+\t\t  memcpy (dest, src, size);\n+\t\t  dest += roffset;\n+\t\t  src += soffset;\n+\t\t}\n+\t      for (src = sptr, n = 0; n < shift; n++)\n+\t\t{\n+\t\t  memcpy (dest, src, size);\n+\t\t  dest += roffset;\n+\t\t  src += soffset;\n+\t\t}\n+\t    }\n+\t}\n \n       /* Advance to the next section.  */\n       rptr += rstride0;\n@@ -185,4 +252,3 @@ __cshift0_8 (gfc_array_char * ret, const gfc_array_char * array,\n {\n   __cshift0 (ret, array, *pshift, pdim ? *pdim : 1);\n }\n-"}]}