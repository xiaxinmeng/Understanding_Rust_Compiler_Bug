{"sha": "79a2c4281c7dcaa6a138d24fd037c62453a12bde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhMmM0MjgxYzdkY2FhNmExMzhkMjRmZDAzN2M2MjQ1M2ExMmJkZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-11-09T17:32:52Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-11-09T17:32:52Z"}, "message": "PR middle-end/81824 - Warn for missing attributes with function aliases\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/81824\n\t* c-attribs.c (handle_copy_attribute): New function.\n\ngcc/cp/ChangeLog:\n\n\tPR middle-end/81824\n\t* pt.c (warn_spec_missing_attributes): Move code to attribs.c.\n\tCall decls_mismatched_attributes.\n\ngcc/ChangeLog:\n\n\tPR middle-end/81824\n\t* attribs.c (has_attribute): New helper function.\n\t(decls_mismatched_attributes, maybe_diag_alias_attributes): Same.\n\t* attribs.h (decls_mismatched_attributes): Declare.\n\t* cgraphunit.c (handle_alias_pairs): Call maybe_diag_alias_attributes.\n\t(maybe_diag_incompatible_alias): Use OPT_Wattribute_alias_.\n\t* common.opt (-Wattribute-alias): Take an argument.\n\t(-Wno-attribute-alias): New option.\n\t* doc/extend.texi (Common Function Attributes): Document copy.\n\t(Common Variable Attributes): Same.\n\t* doc/invoke.texi (-Wmissing-attributes): Document enhancement.\n\t(-Wattribute-alias): Document new option argument.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/81824\n\t* gcc.dg/Wattribute-alias.c: New test.\n\t* gcc.dg/Wmissing-attributes.c: New test.\n\t* gcc.dg/attr-copy.c: New test.\n\t* gcc.dg/attr-copy-2.c: New test.\n\t* gcc.dg/attr-copy-3.c: New test.\n\t* gcc.dg/attr-copy-4.c: New test.\n\nFrom-SVN: r265980", "tree": {"sha": "dff179677c863457f73ef49310ef719591c305e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dff179677c863457f73ef49310ef719591c305e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79a2c4281c7dcaa6a138d24fd037c62453a12bde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a2c4281c7dcaa6a138d24fd037c62453a12bde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a2c4281c7dcaa6a138d24fd037c62453a12bde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a2c4281c7dcaa6a138d24fd037c62453a12bde/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "900dab1338b45c8fa8d1b315dce53712b857da1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900dab1338b45c8fa8d1b315dce53712b857da1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900dab1338b45c8fa8d1b315dce53712b857da1d"}], "stats": {"total": 1565, "additions": 1451, "deletions": 114}, "files": [{"sha": "e0225c58ffb988f3b186e2a35b3dfd816e334724", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -1,3 +1,18 @@\n+2018-11-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/81824\n+\t* attribs.c (has_attribute): New helper function.\n+\t(decls_mismatched_attributes, maybe_diag_alias_attributes): Same.\n+\t* attribs.h (decls_mismatched_attributes): Declare.\n+\t* cgraphunit.c (handle_alias_pairs): Call maybe_diag_alias_attributes.\n+\t(maybe_diag_incompatible_alias): Use OPT_Wattribute_alias_.\n+\t* common.opt (-Wattribute-alias): Take an argument.\n+\t(-Wno-attribute-alias): New option.\n+\t* doc/extend.texi (Common Function Attributes): Document copy.\n+\t(Common Variable Attributes): Same.\n+\t* doc/invoke.texi (-Wmissing-attributes): Document enhancement.\n+\t(-Wattribute-alias): Document new option argument.\n+\n 2018-11-09  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/parsecpu.awk (/alias/): Tighten invisible alias"}, {"sha": "dfe13ad7a943928de2329ff1f30e95d89ac43b51", "filename": "gcc/attribs.c", "status": "modified", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -30,6 +30,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"selftest.h\"\n #include \"hash-set.h\"\n+#include \"diagnostic.h\"\n+#include \"pretty-print.h\"\n+#include \"intl.h\"\n \n /* Table of the tables of attributes (common, language, format, machine)\n    searched.  */\n@@ -1812,6 +1815,192 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n   return list;\n }\n \n+/* Return true if the function decl or type NODE has been declared\n+   with attribute ANAME among attributes ATTRS.  */\n+\n+static bool\n+has_attribute (tree node, tree attrs, const char *aname)\n+{\n+  if (!strcmp (aname, \"const\"))\n+    {\n+      if (DECL_P (node) && TREE_READONLY (node))\n+\treturn true;\n+    }\n+  else if (!strcmp (aname, \"malloc\"))\n+    {\n+      if (DECL_P (node) && DECL_IS_MALLOC (node))\n+\treturn true;\n+    }\n+  else if (!strcmp (aname, \"noreturn\"))\n+    {\n+      if (DECL_P (node) && TREE_THIS_VOLATILE (node))\n+\treturn true;\n+    }\n+  else if (!strcmp (aname, \"nothrow\"))\n+    {\n+      if (TREE_NOTHROW (node))\n+\treturn true;\n+    }\n+  else if (!strcmp (aname, \"pure\"))\n+    {\n+      if (DECL_P (node) && DECL_PURE_P (node))\n+\treturn true;\n+    }\n+\n+  return lookup_attribute (aname, attrs);\n+}\n+\n+/* Return the number of mismatched function or type attributes between\n+   the \"template\" function declaration TMPL and DECL.  The word \"template\"\n+   doesn't necessarily refer to a C++ template but rather a declaration\n+   whose attributes should be matched by those on DECL.  For a non-zero\n+   return value set *ATTRSTR to a string representation of the list of\n+   mismatched attributes with quoted names.\n+   ATTRLIST is a list of additional attributes that SPEC should be\n+   taken to ultimately be declared with.  */\n+\n+unsigned\n+decls_mismatched_attributes (tree tmpl, tree decl, tree attrlist,\n+\t\t\t     const char* const blacklist[],\n+\t\t\t     pretty_printer *attrstr)\n+{\n+  if (TREE_CODE (tmpl) != FUNCTION_DECL)\n+    return 0;\n+\n+  /* Avoid warning if either declaration or its type is deprecated.  */\n+  if (TREE_DEPRECATED (tmpl)\n+      || TREE_DEPRECATED (decl))\n+    return 0;\n+\n+  const tree tmpls[] = { tmpl, TREE_TYPE (tmpl) };\n+  const tree decls[] = { decl, TREE_TYPE (decl) };\n+\n+  if (TREE_DEPRECATED (tmpls[1])\n+      || TREE_DEPRECATED (decls[1])\n+      || TREE_DEPRECATED (TREE_TYPE (tmpls[1]))\n+      || TREE_DEPRECATED (TREE_TYPE (decls[1])))\n+    return 0;\n+\n+  tree tmpl_attrs[] = { DECL_ATTRIBUTES (tmpl), TYPE_ATTRIBUTES (tmpls[1]) };\n+  tree decl_attrs[] = { DECL_ATTRIBUTES (decl), TYPE_ATTRIBUTES (decls[1]) };\n+\n+  if (!decl_attrs[0])\n+    decl_attrs[0] = attrlist;\n+  else if (!decl_attrs[1])\n+    decl_attrs[1] = attrlist;\n+\n+  /* Avoid warning if the template has no attributes.  */\n+  if (!tmpl_attrs[0] && !tmpl_attrs[1])\n+    return 0;\n+\n+  /* Avoid warning if either declaration contains an attribute on\n+     the white list below.  */\n+  const char* const whitelist[] = {\n+    \"error\", \"warning\"\n+  };\n+\n+  for (unsigned i = 0; i != 2; ++i)\n+    for (unsigned j = 0; j != sizeof whitelist / sizeof *whitelist; ++j)\n+      if (lookup_attribute (whitelist[j], tmpl_attrs[i])\n+\t  || lookup_attribute (whitelist[j], decl_attrs[i]))\n+\treturn 0;\n+\n+  /* Put together a list of the black-listed attributes that the template\n+     is declared with and the declaration is not, in case it's not apparent\n+     from the most recent declaration of the template.  */\n+  unsigned nattrs = 0;\n+\n+  for (unsigned i = 0; blacklist[i]; ++i)\n+    {\n+      for (unsigned j = 0; j != 2; ++j)\n+\t{\n+\t  if (!has_attribute (tmpls[j], tmpl_attrs[j], blacklist[i]))\n+\t    continue;\n+\n+\t  unsigned kmax = 1 + !!decl_attrs[1];\n+\t  for (unsigned k = 0; k != kmax; ++k)\n+\t    {\n+\t      if (has_attribute (decls[k], decl_attrs[k], blacklist[i]))\n+\t\tbreak;\n+\n+\t      if (!k && kmax > 1)\n+\t\tcontinue;\n+\n+\t      if (nattrs)\n+\t\tpp_string (attrstr, \", \");\n+\t      pp_begin_quote (attrstr, pp_show_color (global_dc->printer));\n+\t      pp_string (attrstr, blacklist[i]);\n+\t      pp_end_quote (attrstr, pp_show_color (global_dc->printer));\n+\t      ++nattrs;\n+\t    }\n+\t}\n+    }\n+\n+  return nattrs;\n+}\n+\n+/* Issue a warning for the declaration ALIAS for TARGET where ALIAS\n+   specifies either attributes that are incompatible with those of\n+   TARGET, or attributes that are missing and that declaring ALIAS\n+   with would benefit.  */\n+\n+void\n+maybe_diag_alias_attributes (tree alias, tree target)\n+{\n+  /* Do not expect attributes to match between aliases and ifunc\n+     resolvers.  There is no obvious correspondence between them.  */\n+  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (alias)))\n+    return;\n+\n+  const char* const blacklist[] = {\n+    \"alloc_align\", \"alloc_size\", \"cold\", \"const\", \"hot\", \"leaf\", \"malloc\",\n+    \"nonnull\", \"noreturn\", \"nothrow\", \"pure\", \"returns_nonnull\",\n+    \"returns_twice\", NULL\n+  };\n+\n+  pretty_printer attrnames;\n+  if (warn_attribute_alias > 1)\n+    {\n+      /* With -Wattribute-alias=2 detect alias declarations that are more\n+\t restrictive than their targets first.  Those indicate potential\n+\t codegen bugs.  */\n+      if (unsigned n = decls_mismatched_attributes (alias, target, NULL_TREE,\n+\t\t\t\t\t\t    blacklist, &attrnames))\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (warning_n (DECL_SOURCE_LOCATION (alias),\n+\t\t\t OPT_Wattribute_alias_, n,\n+\t\t\t \"%qD specifies more restrictive attribute than \"\n+\t\t\t \"its target %qD: %s\",\n+\t\t\t \"%qD specifies more restrictive attributes than \"\n+\t\t\t \"its target %qD: %s\",\n+\t\t\t alias, target, pp_formatted_text (&attrnames)))\n+\t    inform (DECL_SOURCE_LOCATION (target),\n+\t\t    \"%qD target declared here\", alias);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Detect alias declarations that are less restrictive than their\n+     targets.  Those suggest potential optimization opportunities\n+     (solved by adding the missing attribute(s) to the alias).  */\n+  if (unsigned n = decls_mismatched_attributes (target, alias, NULL_TREE,\n+\t\t\t\t\t\tblacklist, &attrnames))\n+    {\n+      auto_diagnostic_group d;\n+      if (warning_n (DECL_SOURCE_LOCATION (alias),\n+\t\t     OPT_Wmissing_attributes, n,\n+\t\t     \"%qD specifies less restrictive attribute than \"\n+\t\t     \"its target %qD: %s\",\n+\t\t     \"%qD specifies less restrictive attributes than \"\n+\t\t     \"its target %qD: %s\",\n+\t\t     alias, target, pp_formatted_text (&attrnames)))\n+\tinform (DECL_SOURCE_LOCATION (target),\n+\t\t\"%qD target declared here\", alias);\n+    }\n+}\n+\n+\n #if CHECKING_P\n \n namespace selftest"}, {"sha": "5b76c4c400c8a329f579745592f5fe55a0dc6661", "filename": "gcc/attribs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -105,6 +105,12 @@ extern int attribute_list_contained (const_tree, const_tree);\n extern tree private_lookup_attribute (const char *attr_name, size_t attr_len,\n \t\t\t\t      tree list);\n \n+extern unsigned decls_mismatched_attributes (tree, tree, tree,\n+\t\t\t\t\t     const char* const[],\n+\t\t\t\t\t     pretty_printer*);\n+\n+extern void maybe_diag_alias_attributes (tree, tree);\n+\n /* For a given IDENTIFIER_NODE, strip leading and trailing '_' characters\n    so that we have a canonical form of attribute names.  */\n "}, {"sha": "6ce25c977831d60135f1fb2f08c465fcb16fc732", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -1,3 +1,8 @@\n+2018-11-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/81824\n+\t* c-attribs.c (handle_copy_attribute): New function.\n+\n 2018-11-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/87795"}, {"sha": "5e3b127b1448951a1d2c28495b0bf1352c51c86d", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 550, "deletions": 33, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -146,6 +146,7 @@ static tree handle_designated_init_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fallthrough_attribute (tree *, tree, tree, int, bool *);\n static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n \t\t\t\t\t\t       int, bool *);\n+static tree handle_copy_attribute (tree *, tree, tree, int, bool *);\n \n /* Helper to define attribute exclusions.  */\n #define ATTR_EXCL(name, function, type, variable)\t\\\n@@ -455,6 +456,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      NULL },\n   { \"nocf_check\",\t      0, 0, false, true, true, true,\n \t\t\t      handle_nocf_check_attribute, NULL },\n+  { \"copy\",                   1, 1, false, false, false, false,\n+\t\t\t      handle_copy_attribute, NULL },\n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -2137,6 +2140,151 @@ handle_alias_attribute (tree *node, tree name, tree args,\n   return handle_alias_ifunc_attribute (true, node, name, args, no_add_attrs);\n }\n \n+/* Handle the \"copy\" attribute NAME by copying the set of attributes\n+   from the symbol referenced by ARGS to the declaration of *NODE.  */\n+\n+static tree\n+handle_copy_attribute (tree *node, tree name, tree args,\n+\t\t       int flags, bool *no_add_attrs)\n+{\n+  /* Do not apply the copy attribute itself.  It serves no purpose\n+     other than to copy other attributes.  */\n+  *no_add_attrs = true;\n+\n+  tree decl = *node;\n+\n+  tree ref = TREE_VALUE (args);\n+  if (ref == error_mark_node)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (ref) == STRING_CST)\n+    {\n+      /* Explicitly handle this case since using a string literal\n+\t as an argument is a likely mistake.  */\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute argument cannot be a string\",\n+\t\tname);\n+      return NULL_TREE;\n+    }\n+\n+  if (CONSTANT_CLASS_P (ref)\n+      && (INTEGRAL_TYPE_P (TREE_TYPE (ref))\n+\t  || FLOAT_TYPE_P (TREE_TYPE (ref))))\n+    {\n+      /* Similar to the string case, since some function attributes\n+\t accept literal numbers as arguments (e.g., alloc_size or\n+\t nonnull) using one here is a likely mistake.  */\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute argument cannot be a constant arithmetic \"\n+\t\t\"expression\",\n+\t\tname);\n+      return NULL_TREE;\n+    }\n+\n+  if (ref == node[1])\n+    {\n+      /* Another possible mistake (but indirect self-references aren't\n+\t and diagnosed and shouldn't be).  */\n+      if (warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,\n+\t\t      \"%qE attribute ignored on a redeclaration \"\n+\t\t      \"of the referenced symbol\",\n+\t\t      name))\n+\tinform (DECL_SOURCE_LOCATION (node[1]),\n+\t\t\"previous declaration here\");\n+      return NULL_TREE;\n+    }\n+\n+  /* Consider address-of expressions in the attribute argument\n+     as requests to copy from the referenced entity.  For constant\n+     expressions, consider those to be requests to copy from their\n+     type, such as in:\n+       struct __attribute__ (copy ((struct T *)0)) U { ... };\n+     which copies type attributes from struct T to the declaration\n+     of struct U.  */\n+  if (TREE_CODE (ref) == ADDR_EXPR)\n+    ref = TREE_OPERAND (ref, 0);\n+  else if (CONSTANT_CLASS_P (ref))\n+    ref = TREE_TYPE (ref);\n+\n+  if (DECL_P (decl))\n+    {\n+      if ((VAR_P (decl)\n+\t   && (TREE_CODE (ref) == FUNCTION_DECL\n+\t       || (EXPR_P (ref)\n+\t\t   && POINTER_TYPE_P (TREE_TYPE (ref))\n+\t\t   && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (ref))))))\n+\t  || (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && (VAR_P (ref)\n+\t\t  || (EXPR_P (ref)\n+\t\t      && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (ref))))))\n+\t{\n+\t  /* It makes no sense to try to copy function attributes\n+\t     to a variable, or variable attributes to a function.  */\n+\t  if (warning (OPT_Wattributes,\n+\t\t       \"%qE attribute ignored on a declaration of \"\n+\t\t       \"a different kind than referenced symbol\",\n+\t\t       name)\n+\t      && DECL_P (ref))\n+\t    inform (DECL_SOURCE_LOCATION (ref),\n+\t\t    \"symbol %qD referenced by %qD declared here\", ref, decl);\n+\t  return NULL_TREE;\n+\t}\n+\n+      tree attrs = NULL_TREE;\n+      if (DECL_P (ref))\n+\tattrs = DECL_ATTRIBUTES (ref);\n+      else if (TYPE_P (ref))\n+\tattrs = TYPE_ATTRIBUTES (ref);\n+\n+      /* Copy decl attributes from REF to DECL.  */\n+      for (tree at = attrs; at; at = TREE_CHAIN (at))\n+\t{\n+\t  /* Avoid copying attributes that affect a symbol linkage or\n+\t     visibility since those in all likelihood only apply to\n+\t     the target.\n+\t     FIXME: make it possible to specify which attributes to\n+\t     copy or not to copy in the copy attribute itself.  */\n+\t  tree atname = get_attribute_name (at);\n+\t  if (is_attribute_p (\"alias\", atname)\n+\t      || is_attribute_p (\"ifunc\", atname)\n+\t      || is_attribute_p (\"visibility\", atname)\n+\t      || is_attribute_p (\"weak\", atname)\n+\t      || is_attribute_p (\"weakref\", atname))\n+\t    continue;\n+\n+\t  tree atargs = TREE_VALUE (at);\n+\t  /* Create a copy of just the one attribute ar AT, including\n+\t     its argumentsm and add it to DECL.  */\n+\t  tree attr = tree_cons (atname, copy_list (atargs), NULL_TREE);\n+\t  decl_attributes (node, attr, flags, ref);\n+\t}\n+\n+      /* Proceed to copy type attributes below.  */\n+    }\n+  else if (!TYPE_P (decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute must apply to a declaration\",\n+\t\tname);\n+      return NULL_TREE;\n+    }\n+\n+  tree reftype = ref;\n+  if (DECL_P (ref) || EXPR_P (ref))\n+    reftype = TREE_TYPE (ref);\n+\n+  if (POINTER_TYPE_P (reftype))\n+    reftype = TREE_TYPE (reftype);\n+\n+  tree attrs = TYPE_ATTRIBUTES (reftype);\n+\n+  /* Copy type attributes from REF to DECL.  */\n+  for (tree at = attrs; at; at = TREE_CHAIN (at))\n+    decl_attributes (node, at, flags, ref);\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"weakref\" attribute; arguments as in struct\n    attribute_spec.handler.  */\n \n@@ -2962,34 +3110,11 @@ handle_deprecated_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n-/* Handle a \"vector_size\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n+/* Return the \"base\" type from TYPE that is suitable to apply attribute\n+   vector_size to by stripping arrays, function types, etc.  */\n static tree\n-handle_vector_size_attribute (tree *node, tree name, tree args,\n-\t\t\t      int ARG_UNUSED (flags),\n-\t\t\t      bool *no_add_attrs)\n+type_for_vector_size (tree type)\n {\n-  unsigned HOST_WIDE_INT vecsize, nunits;\n-  machine_mode orig_mode;\n-  tree type = *node, new_type, size;\n-\n-  *no_add_attrs = true;\n-\n-  size = TREE_VALUE (args);\n-  if (size && TREE_CODE (size) != IDENTIFIER_NODE\n-      && TREE_CODE (size) != FUNCTION_DECL)\n-    size = default_conversion (size);\n-\n-  if (!tree_fits_uhwi_p (size))\n-    {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n-      return NULL_TREE;\n-    }\n-\n-  /* Get the vector size (in bytes).  */\n-  vecsize = tree_to_uhwi (size);\n-\n   /* We need to provide for vector pointers, vector arrays, and\n      functions returning vectors.  For example:\n \n@@ -3005,8 +3130,25 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \t || TREE_CODE (type) == OFFSET_TYPE)\n     type = TREE_TYPE (type);\n \n+  return type;\n+}\n+\n+/* Given TYPE, return the base type to which the vector_size attribute\n+   ATNAME with ARGS, when non-null, can be applied, if one exists.\n+   On success and when both ARGS and PTRNUNITS are non-null, set\n+   *PTRNUNINTS to the number of vector units.  When PTRNUNITS is not\n+   null, issue a warning when the attribute argument is not constant\n+   and an error if there is no such type.  Otherwise issue a warning\n+   in the latter case and return null.  */\n+\n+static tree\n+type_valid_for_vector_size (tree type, tree atname, tree args,\n+\t\t\t    unsigned HOST_WIDE_INT *ptrnunits)\n+{\n+  bool error_p = ptrnunits != NULL;\n+\n   /* Get the mode of the type being modified.  */\n-  orig_mode = TYPE_MODE (type);\n+  machine_mode orig_mode = TYPE_MODE (type);\n \n   if ((!INTEGRAL_TYPE_P (type)\n        && !SCALAR_FLOAT_TYPE_P (type)\n@@ -3017,14 +3159,38 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n       || !tree_fits_uhwi_p (TYPE_SIZE_UNIT (type))\n       || TREE_CODE (type) == BOOLEAN_TYPE)\n     {\n-      error (\"invalid vector type for attribute %qE\", name);\n+      if (error_p)\n+\terror (\"invalid vector type for attribute %qE\", atname);\n+      else\n+\twarning (OPT_Wattributes, \"invalid vector type for attribute %qE\",\n+\t\t atname);\n       return NULL_TREE;\n     }\n \n+  /* When no argument has been provided this is just a request to validate\n+     the type above.  Return TYPE to indicate success.  */\n+  if (!args)\n+    return type;\n+\n+  tree size = TREE_VALUE (args);\n+  if (size && TREE_CODE (size) != IDENTIFIER_NODE\n+      && TREE_CODE (size) != FUNCTION_DECL)\n+    size = default_conversion (size);\n+\n+  if (!tree_fits_uhwi_p (size))\n+    {\n+      /* FIXME: make the error message more informative.  */\n+      if (error_p)\n+\twarning (OPT_Wattributes, \"%qE attribute ignored\", atname);\n+      return NULL_TREE;\n+    }\n+\n+  unsigned HOST_WIDE_INT vecsize = tree_to_uhwi (size);\n   if (vecsize % tree_to_uhwi (TYPE_SIZE_UNIT (type)))\n     {\n-      error (\"vector size not an integral multiple of component size\");\n-      return NULL;\n+      if (error_p)\n+\terror (\"vector size not an integral multiple of component size\");\n+      return NULL_TREE;\n     }\n \n   if (vecsize == 0)\n@@ -3034,14 +3200,44 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n     }\n \n   /* Calculate how many units fit in the vector.  */\n-  nunits = vecsize / tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+  unsigned HOST_WIDE_INT nunits = vecsize / tree_to_uhwi (TYPE_SIZE_UNIT (type));\n   if (nunits & (nunits - 1))\n     {\n-      error (\"number of components of the vector not a power of two\");\n+      if (error_p)\n+\terror (\"number of components of the vector not a power of two\");\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"number of components of the vector not a power of two\");\n       return NULL_TREE;\n     }\n \n-  new_type = build_vector_type (type, nunits);\n+  if (ptrnunits)\n+    *ptrnunits = nunits;\n+\n+  return type;\n+}\n+\n+/* Handle a \"vector_size\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_vector_size_attribute (tree *node, tree name, tree args,\n+\t\t\t      int ARG_UNUSED (flags),\n+\t\t\t      bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+\n+  /* Determine the \"base\" type to apply the attribute to.  */\n+  tree type = type_for_vector_size (*node);\n+\n+  /* Get the vector size (in bytes) and let the function compute\n+     the number of vector units.  */\n+  unsigned HOST_WIDE_INT nunits;\n+  type = type_valid_for_vector_size (type, name, args, &nunits);\n+  if (!type)\n+    return NULL_TREE;\n+\n+  tree new_type = build_vector_type (type, nunits);\n \n   /* Build back pointers if needed.  */\n   *node = lang_hooks.types.reconstruct_complex_type (*node, new_type);\n@@ -3512,3 +3708,324 @@ handle_patchable_function_entry_attribute (tree *, tree, tree, int, bool *)\n   /* Nothing to be done here.  */\n   return NULL_TREE;\n }\n+\n+/* Attempt to partially validate a single attribute ATTR as if\n+   it were to be applied to an entity OPER.  */\n+\n+static bool\n+validate_attribute (location_t atloc, tree oper, tree attr)\n+{\n+  /* Determine whether the name of the attribute is valid\n+     and fail with an error if not.  */\n+  tree atname = get_attribute_name (attr);\n+  if (!lookup_attribute_spec (atname))\n+    {\n+      if (atloc != UNKNOWN_LOCATION)\n+\terror_at (atloc, \"unknown attribute %qE\", atname);\n+      return false;\n+    }\n+\n+  tree args = TREE_VALUE (attr);\n+  if (!args)\n+    return true;\n+\n+  /* FIXME: Do some validation.  */\n+  const char *atstr = IDENTIFIER_POINTER (atname);\n+  if (!strcmp (atstr, \"format\"))\n+    return true;\n+\n+  /* Only when attribute arguments have been provided try to validate\n+     the whole thing.  decl_attributes doesn't return an indication of\n+     success or failure so proceed regardless.  */\n+  const char tmpname[] = \"__builtin_has_attribute_tmp.\";\n+  tree tmpid = get_identifier (tmpname);\n+  tree tmpdecl;\n+  if (!strcmp (atstr, \"vector_size\"))\n+    {\n+      tree type = TYPE_P (oper) ? oper : TREE_TYPE (oper);\n+      /* Check for function type here since type_for_vector_size\n+\t strips it while looking for a function's return type.  */\n+      if (FUNC_OR_METHOD_TYPE_P (type))\n+\t{\n+\t  warning_at (atloc, OPT_Wattributes,\n+\t\t      \"invalid operand type %qT for %qs\", type, atstr);\n+\t  return false;\n+\t}\n+\n+      type = type_for_vector_size (type);\n+      if (VECTOR_TYPE_P (type))\n+\ttype = TREE_TYPE (type);\n+      /* Avoid trying to apply attribute vector_size to OPER since\n+\t it's overly restrictive.  Simply make sure it has the right\n+\t type.  */\n+      return type_valid_for_vector_size (type, atname, args, NULL);\n+    }\n+\n+  if (TYPE_P (oper))\n+    tmpdecl = build_decl (atloc, TYPE_DECL, tmpid, oper);\n+  else\n+    tmpdecl = build_decl (atloc, TREE_CODE (oper), tmpid, TREE_TYPE (oper));\n+\n+  /* Temporarily clear CURRENT_FUNCTION_DECL to make decl_attributes\n+     believe the DECL declared above is at file scope.  (See bug 87526.)  */\n+  tree save_curfunc = current_function_decl;\n+  current_function_decl = NULL_TREE;\n+  if (DECL_P (tmpdecl))\n+    {\n+      if (DECL_P (oper))\n+\t/* An alias cannot be a defintion so declare the symbol extern.  */\n+\tDECL_EXTERNAL (tmpdecl) = true;\n+      /* Attribute visibility only applies to symbols visible from other\n+\t translation units so make it \"public.\"   */\n+      TREE_PUBLIC (tmpdecl) = TREE_PUBLIC (oper);\n+    }\n+  decl_attributes (&tmpdecl, attr, 0);\n+  current_function_decl = save_curfunc;\n+\n+  /* FIXME: Change decl_attributes to indicate success or failure (and\n+     parameterize it to avoid failing with errors).  */\n+  return true;\n+}\n+\n+/* Return true if the DECL, EXPR, or TYPE t has been declared with\n+   attribute ATTR.  For DECL, consider also its type.  For EXPR,\n+   consider just its type.  */\n+\n+bool\n+has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n+{\n+  if (!attr || !t || t == error_mark_node)\n+    return false;\n+\n+  if (!validate_attribute (atloc, t, attr))\n+    return false;\n+\n+  tree type = NULL_TREE;\n+  tree expr = NULL_TREE;\n+  if (TYPE_P (t))\n+    type = t;\n+  else\n+    {\n+      do\n+\t{\n+\t  /* Determine the array element/member declaration from\n+\t     an ARRAY/COMPONENT_REF.  */\n+\t  STRIP_NOPS (t);\n+\t  tree_code code = TREE_CODE (t);\n+\t  if (code == ARRAY_REF)\n+\t    t = TREE_OPERAND (t, 0);\n+\t  else if (code == COMPONENT_REF)\n+\t    t = TREE_OPERAND (t, 1);\n+\t  else\n+\t    break;\n+\t} while (true);\n+      expr = t;\n+    }\n+\n+  /* Set to true when an attribute is found in the referenced entity\n+     that matches the specified attribute.  */\n+  bool found_match = false;\n+\n+  tree atname = get_attribute_name (attr);\n+  const char *namestr = IDENTIFIER_POINTER (atname);\n+\n+   /* Iterate once for a type and twice for a function or variable\n+     declaration: once for the DECL and the second time for its\n+     TYPE.  */\n+  for (bool done = false; !found_match && !done; )\n+    {\n+      tree atlist;\n+      if (type)\n+\t{\n+\t  if (type == error_mark_node)\n+\t    {\n+\t      /* This could be a label.  FIXME: add support for labels.  */\n+\t      warning_at (atloc, OPT_Wattributes,\n+\t\t\t  (TYPE_P (t)\n+\t\t\t   ? G_(\"%qs attribute not supported for %qT \"\n+\t\t\t\t\"in %<__builtin_has_attribute%>\")\n+\t\t\t   : G_(\"%qs attribute not supported for %qE \"\n+\t\t\t\t\"in %<__builtin_has_attribute%>\")),\n+\t\t\t  namestr, t);\n+\t      return false;\n+\t    }\n+\n+\t  /* Clear EXPR to prevent considering it again below.  */\n+\t  atlist = TYPE_ATTRIBUTES (type);\n+\t  expr = NULL_TREE;\n+\t  done = true;\n+\t}\n+      else if (DECL_P (expr))\n+\t{\n+\t  /* Set TYPE to the DECL's type to process it on the next\n+\t     iteration.  */\n+\t  atlist = DECL_ATTRIBUTES (expr);\n+\t  type = TREE_TYPE (expr);\n+\t}\n+      else\n+\t{\n+\t  atlist = TYPE_ATTRIBUTES (TREE_TYPE (expr));\n+\t  done = true;\n+\t}\n+\n+     /* True when an attribute with the sought name (though not necessarily\n+\t with the sought attributes) has been found on the attribute chain.  */\n+      bool found_attr = false;\n+\n+      /* For attribute aligned ignore the attribute list and consider\n+\t the tree node itself instead.  */\n+      if (type && !strcmp (\"aligned\", namestr))\n+\tatlist = NULL_TREE;\n+\n+      /* When clear, the first mismatched attribute argument results\n+\t in failure.  Otherwise, the first matched attribute argument\n+\t results in success.  */\n+      bool attr_nonnull = !strcmp (\"nonnull\", namestr);\n+      bool ignore_mismatches = attr_nonnull;\n+\n+      /* Iterate over the instances of the sought attribute on the DECL or\n+\t TYPE (there may be multiple instances with different arguments).  */\n+      for (; (atlist = lookup_attribute (namestr, atlist));\n+\t   found_attr = true, atlist = TREE_CHAIN (atlist))\n+\t{\n+\t  /* If there are no arguments to match the result is true except\n+\t     for nonnull where the attribute with no arguments must match.  */\n+\t  if (!TREE_VALUE (attr))\n+\t    return attr_nonnull ? !TREE_VALUE (atlist) : true;\n+\n+\t  /* Attribute nonnull with no arguments subsumes all values of\n+\t     the attribute.  FIXME: This is overly broad since it only\n+\t     applies to pointer arguments, but querying non-pointer\n+\t     arguments is diagnosed.  */\n+\t  if (!TREE_VALUE (atlist) && attr_nonnull)\n+\t    return true;\n+\n+\t  /* Iterate over the DECL or TYPE attribute argument's values.  */\n+\t  for (tree val = TREE_VALUE (atlist); val; val = TREE_CHAIN (val))\n+\t    {\n+\t      /* Iterate over the arguments in the sought attribute comparing\n+\t\t their values to those specified for the DECL or TYPE.  */\n+\t      for (tree arg = TREE_VALUE (attr); arg; arg = TREE_CHAIN (arg))\n+\t\t{\n+\t\t  tree v1 = TREE_VALUE (val);\n+\t\t  tree v2 = TREE_VALUE (arg);\n+\t\t  if (v1 == v2)\n+\t\t    return true;\n+\n+\t\t  if (!v1 || !v2)\n+\t\t    break;\n+\n+\t\t  if (TREE_CODE (v1) == IDENTIFIER_NODE\n+\t\t      || TREE_CODE (v2) == IDENTIFIER_NODE)\n+\t\t    /* Two identifiers are the same if their values are\n+\t\t       equal (that's handled above).  Otherwise ther are\n+\t\t       either not the same or oneis not an identifier.  */\n+\t\t    return false;\n+\n+\t\t  /* Convert to make them equality-comparable.  */\n+\t\t  v1 = convert (v1);\n+\t\t  v2 = convert (v2);\n+\n+\t\t  /* A positive value indicates equality, negative means\n+\t\t     \"don't know.\"  */\n+\t\t  if (simple_cst_equal (v1, v2) == 1)\n+\t\t    return true;\n+\n+\t\t  if (!ignore_mismatches)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (!found_attr)\n+\t{\n+\t  /* Some attributes are encoded directly in the tree node.  */\n+\t  if (!strcmp (\"aligned\", namestr))\n+\t    {\n+\t      if (tree arg = TREE_VALUE (attr))\n+\t\t{\n+\t\t  arg = convert (TREE_VALUE (arg));\n+\t\t  if (expr && DECL_P (expr)\n+\t\t      && DECL_USER_ALIGN (expr)\n+\t\t      && tree_fits_uhwi_p (arg))\n+\t\t    found_match = DECL_ALIGN_UNIT (expr) == tree_to_uhwi (arg);\n+\t\t  else if (type && TYPE_USER_ALIGN (type))\n+\t\t    found_match = TYPE_ALIGN_UNIT (type) == tree_to_uhwi (arg);\n+\t\t}\n+\t      else if (expr && DECL_P (expr))\n+\t\tfound_match = DECL_USER_ALIGN (expr);\n+\t      else if (type)\n+\t\tfound_match = TYPE_USER_ALIGN (type);\n+\t    }\n+\t  else if (!strcmp (\"const\", namestr))\n+\t    {\n+\t      if (expr && DECL_P (expr))\n+\t\tfound_match = TREE_READONLY (expr);\n+\t    }\n+\t  else if (!strcmp (\"const\", namestr))\n+\t    {\n+\t      if (expr && DECL_P (expr))\n+\t\tfound_match = DECL_PURE_P (expr);\n+\t    }\n+\t  else if (!strcmp (\"deprecated\", namestr))\n+\t    {\n+\t      found_match = TREE_DEPRECATED (expr ? expr : type);\n+\t      if (found_match)\n+\t\treturn true;\n+\t    }\n+\t  else if (!strcmp (\"vector_size\", namestr))\n+\t    {\n+\t      if (!type)\n+\t\tcontinue;\n+\n+\t      /* Determine the base type from arrays, pointers, and such.\n+\t\t Fail if the base type is not a vector.  */\n+\t      type = type_for_vector_size (type);\n+\t      if (!VECTOR_TYPE_P (type))\n+\t\treturn false;\n+\n+\t      if (tree arg = TREE_VALUE (attr))\n+\t\t{\n+\t\t  /* Compare the vector size argument for equality.  */\n+\t\t  arg = convert (TREE_VALUE (arg));\n+\t\t  return tree_int_cst_equal (arg, TYPE_SIZE_UNIT (type)) == 1;\n+\t\t}\n+\t      else\n+\t\treturn true;\n+\t    }\n+\t  else if (!strcmp (\"warn_if_not_aligned\", namestr))\n+\t    {\n+\t      if (tree arg = TREE_VALUE (attr))\n+\t\t{\n+\t\t  arg = convert (TREE_VALUE (arg));\n+\t\t  if (expr && DECL_P (expr))\n+\t\t    found_match = (DECL_WARN_IF_NOT_ALIGN (expr)\n+\t\t\t\t   == tree_to_uhwi (arg) * BITS_PER_UNIT);\n+\t\t  else if (type)\n+\t\t    found_match = (TYPE_WARN_IF_NOT_ALIGN (type)\n+\t\t\t\t   == tree_to_uhwi (arg) * BITS_PER_UNIT);\n+\t\t}\n+\t      else if (expr && DECL_P (expr))\n+\t\tfound_match = DECL_WARN_IF_NOT_ALIGN (expr);\n+\t      else if (type)\n+\t\tfound_match = TYPE_WARN_IF_NOT_ALIGN (type);\n+\t    }\n+\t  else if (!strcmp (\"transparent_union\", namestr))\n+\t    {\n+\t      if (type)\n+\t\tfound_match = TYPE_TRANSPARENT_AGGR (type) != 0;\n+\t    }\n+\t  else if (!strcmp (\"mode\", namestr))\n+\t    {\n+\t      /* Finally issue a warning for attributes that cannot\n+\t\t be supported in this context.  Attribute mode is not\n+\t\t added to a symbol and cannot be determined from it.  */\n+\t      warning_at (atloc, OPT_Wattributes,\n+\t\t\t  \"%qs attribute not supported in \"\n+\t\t\t  \"%<__builtin_has_attribute%>\", namestr);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return found_match;\n+}"}, {"sha": "2f0b70ff8505bae72c3192ca4a00dfe6c45771ea", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -1364,7 +1364,7 @@ maybe_diag_incompatible_alias (tree alias, tree target)\n \n \t  auto_diagnostic_group d;\n \t  if (warning_at (DECL_SOURCE_LOCATION (target),\n-\t\t\t  OPT_Wattribute_alias,\n+\t\t\t  OPT_Wattribute_alias_,\n \t\t\t  \"%<ifunc%> resolver for %qD should return %qT\",\n \t\t\t  alias, funcptr))\n \t    inform (DECL_SOURCE_LOCATION (alias),\n@@ -1374,11 +1374,11 @@ maybe_diag_incompatible_alias (tree alias, tree target)\n \t{\n \t  auto_diagnostic_group d;\n \t  if (warning_at (DECL_SOURCE_LOCATION (alias),\n-\t\t\t    OPT_Wattribute_alias,\n+\t\t\t    OPT_Wattribute_alias_,\n \t\t\t    \"%qD alias between functions of incompatible \"\n \t\t\t    \"types %qT and %qT\", alias, altype, targtype))\n \t    inform (DECL_SOURCE_LOCATION (target),\n-\t\t      \"aliased declaration here\");\n+\t\t    \"aliased declaration here\");\n \t}\n     }\n }\n@@ -1441,6 +1441,8 @@ handle_alias_pairs (void)\n \t{\n \t  maybe_diag_incompatible_alias (p->decl, target_node->decl);\n \n+\t  maybe_diag_alias_attributes (p->decl, target_node->decl);\n+\n \t  cgraph_node *src_node = cgraph_node::get (p->decl);\n \t  if (src_node && src_node->definition)\n \t    src_node->reset ();"}, {"sha": "081a9428a323701e1c98c8398fabe78ae96c57e3", "filename": "gcc/common.opt", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -550,9 +550,13 @@ Wattributes\n Common Var(warn_attributes) Init(1) Warning\n Warn about inappropriate attribute usage.\n \n-Wattribute-alias\n-Common Var(warn_attributes) Init(1) Warning\n-Warn about type safety and similar errors in attribute alias and related.\n+Wattribute-alias=\n+Common Joined RejectNegative UInteger Var(warn_attribute_alias) Init(1) Warning IntegerRange(0, 2)\n+Warn about type safety and similar errors and mismatches in attribute alias and related.\n+\n+Wno-attribute-alias\n+Common Alias(Wattribute_alias=, 0, 0) Warning\n+Disable -Wattribute-alias.\n \n Wcannot-profile\n Common Var(warn_cannot_profile) Init(1) Warning"}, {"sha": "7cb57b8bf3f7175a785cb073ec18c36d9fc739e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -1,3 +1,9 @@\n+2018-11-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/81824\n+\t* pt.c (warn_spec_missing_attributes): Move code to attribs.c.\n+\tCall decls_mismatched_attributes.\n+\n 2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* constexpr.c (potential_constant_expression_1): Handle OMP_DEPOBJ."}, {"sha": "d4ae76a89f4f4f2aeb092a3f8c9e1ca060832b23", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -2647,81 +2647,19 @@ warn_spec_missing_attributes (tree tmpl, tree spec, tree attrlist)\n   if (DECL_FUNCTION_TEMPLATE_P (tmpl))\n     tmpl = DECL_TEMPLATE_RESULT (tmpl);\n \n-  if (TREE_CODE (tmpl) != FUNCTION_DECL)\n-    return;\n-\n-  /* Avoid warning if either declaration or its type is deprecated.  */\n-  if (TREE_DEPRECATED (tmpl)\n-      || TREE_DEPRECATED (spec))\n-    return;\n-\n-  tree tmpl_type = TREE_TYPE (tmpl);\n-  tree spec_type = TREE_TYPE (spec);\n-\n-  if (TREE_DEPRECATED (tmpl_type)\n-      || TREE_DEPRECATED (spec_type)\n-      || TREE_DEPRECATED (TREE_TYPE (tmpl_type))\n-      || TREE_DEPRECATED (TREE_TYPE (spec_type)))\n-    return;\n-\n-  tree tmpl_attrs[] = { DECL_ATTRIBUTES (tmpl), TYPE_ATTRIBUTES (tmpl_type) };\n-  tree spec_attrs[] = { DECL_ATTRIBUTES (spec), TYPE_ATTRIBUTES (spec_type) };\n-\n-  if (!spec_attrs[0])\n-    spec_attrs[0] = attrlist;\n-  else if (!spec_attrs[1])\n-    spec_attrs[1] = attrlist;\n-\n-  /* Avoid warning if the primary has no attributes.  */\n-  if (!tmpl_attrs[0] && !tmpl_attrs[1])\n-    return;\n-\n-  /* Avoid warning if either declaration contains an attribute on\n-     the white list below.  */\n-  const char* const whitelist[] = {\n-    \"error\", \"warning\"\n-  };\n-\n-  for (unsigned i = 0; i != 2; ++i)\n-    for (unsigned j = 0; j != sizeof whitelist / sizeof *whitelist; ++j)\n-      if (lookup_attribute (whitelist[j], tmpl_attrs[i])\n-\t  || lookup_attribute (whitelist[j], spec_attrs[i]))\n-\treturn;\n-\n   /* Avoid warning if the difference between the primary and\n      the specialization is not in one of the attributes below.  */\n   const char* const blacklist[] = {\n     \"alloc_align\", \"alloc_size\", \"assume_aligned\", \"format\",\n-    \"format_arg\", \"malloc\", \"nonnull\"\n+    \"format_arg\", \"malloc\", \"nonnull\", NULL\n   };\n \n   /* Put together a list of the black listed attributes that the primary\n      template is declared with that the specialization is not, in case\n      it's not apparent from the most recent declaration of the primary.  */\n-  unsigned nattrs = 0;\n   pretty_printer str;\n-\n-  for (unsigned i = 0; i != sizeof blacklist / sizeof *blacklist; ++i)\n-    {\n-      for (unsigned j = 0; j != 2; ++j)\n-\t{\n-\t  if (!lookup_attribute (blacklist[i], tmpl_attrs[j]))\n-\t    continue;\n-\n-\t  for (unsigned k = 0; k != 1 + !!spec_attrs[1]; ++k)\n-\t    {\n-\t      if (lookup_attribute (blacklist[i], spec_attrs[k]))\n-\t\tbreak;\n-\n-\t      if (nattrs)\n-\t\tpp_string (&str, \", \");\n-\t      pp_begin_quote (&str, pp_show_color (global_dc->printer));\n-\t      pp_string (&str, blacklist[i]);\n-\t      pp_end_quote (&str, pp_show_color (global_dc->printer));\n-\t      ++nattrs;\n-\t    }\n-\t}\n-    }\n+  unsigned nattrs = decls_mismatched_attributes (tmpl, spec, attrlist,\n+\t\t\t\t\t\t blacklist, &str);\n \n   if (!nattrs)\n     return;"}, {"sha": "5ce506907d7de80dfc179e2370d8aaffdc9d9d1b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -2552,6 +2552,40 @@ decorated with attribute @code{constructor} are invoked is unspecified.\n In mixed declarations, attribute @code{init_priority} can be used to\n impose a specific ordering.\n \n+@item copy\n+@itemx copy (@var{function})\n+@cindex @code{copy} function attribute\n+The @code{copy} attribute applies the set of attributes with which\n+@var{function} has been declared to the declaration of the function\n+to which the attribute is applied.  The attribute is designed for\n+libraries that define aliases or function resolvers that are expected\n+to specify the same set of attributes as their targets.  The @code{copy}\n+attribute can be used with functions, variables, or types.  However,\n+the kind of symbol to which the attribute is applied (either function\n+or variable) must match the kind of symbol to which the argument refers.\n+The @code{copy} attribute copies only syntaxtic and semantic attributes\n+but attributes that affect a symbol's linkage or visibility such as\n+@code{alias}, @code{visibility}, or @code{weak}.  The @code{deprecated}\n+attribute is also not copied.  @xref{Common Type Attributes}.\n+@xref{Common Variable Attributes}.\n+\n+For example, the @var{StrongAlias} macro below makes use of the @code{alias}\n+and @code{copy} attributes to define an alias named @var{alloc} for function\n+@var{allocate} declated with attributes @var{alloc_size}, @var{malloc}, and\n+@var{nothrow}.  Thanks to the @code{__typeof__} operator the alias has\n+the same type as the target function.  As a result of the @code{copy}\n+attribute the alias also shares the same attributes as the target.\n+\n+@smallexample\n+#define StrongAlias(TagetFunc, AliasDecl)   \\\n+  extern __typeof__ (TargetFunc) AliasDecl  \\\n+    __attribute__ ((alias (#TargetFunc), copy (TargetFunc)));\n+\n+extern __attribute__ ((alloc_size (1), malloc, nothrow))\n+  void* allocate (size_t);\n+StrongAlias (allocate, alloc);\n+@end smallexample\n+\n @item deprecated\n @itemx deprecated (@var{msg})\n @cindex @code{deprecated} function attribute\n@@ -6174,6 +6208,23 @@ opposite---to allocate space for it directly.\n These attributes override the default chosen by the\n @option{-fno-common} and @option{-fcommon} flags respectively.\n \n+@item copy\n+@itemx copy (@var{variable})\n+@cindex @code{copy} variable attribute\n+The @code{copy} attribute applies the set of attributes with which\n+@var{variable} has been declared to the declaration of the variable\n+to which the attribute is applied.  The attribute is designed for\n+libraries that define aliases that are expected to specify the same\n+set of attributes as the aliased symbols.  The @code{copy} attribute\n+can be used with variables, functions or types.  However, the kind\n+of symbol to which the attribute is applied (either varible or\n+function) must match the kind of symbol to which the argument refers.\n+The @code{copy} attribute copies only syntaxtic and semantic attributes\n+but attributes that affect a symbol's linkage or visibility such as\n+@code{alias}, @code{visibility}, or @code{weak}.  The @code{deprecated}\n+attribute is also not copied.  @xref{Common Function Attributes}.\n+@xref{Common Type Attributes}.\n+\n @item deprecated\n @itemx deprecated (@var{msg})\n @cindex @code{deprecated} variable attribute\n@@ -7105,6 +7156,38 @@ struct foo\n \n This warning can be disabled by @option{-Wno-if-not-aligned}.\n \n+@item copy\n+@itemx copy (@var{expression})\n+@cindex @code{copy} type attribute\n+The @code{copy} attribute applies the set of attributes with which\n+the type of the @var{expression} has been declared to the declaration\n+of the type to which the attribute is applied.  The attribute is\n+designed for libraries that define aliases that are expected to\n+specify the same set of attributes as the aliased symbols.\n+The @code{copy} attribute can be used with types, variables, or\n+functions.  However, the kind of symbol to which the attribute is\n+applied (either varible or function) must match the kind of symbol\n+to which the argument refers.\n+The @code{copy} attribute copies only syntaxtic and semantic attributes\n+but attributes that affect a symbol's linkage or visibility such as\n+@code{alias}, @code{visibility}, or @code{weak}.  The @code{deprecated}\n+attribute is also not copied.  @xref{Common Function Attributes}.\n+@xref{Common Variable Attributes}.\n+\n+For example, suppose @code{struct A} below is defined in some third\n+partly library header to have the alignment requirement @code{N} and\n+to force a warning whenever a variable of the type is not so aligned\n+due to attribute @code{packed}.  Specifying the @code{copy} attribute\n+on the definition on the unrelated @code{struct B} has the effect of\n+copying all relevant attributes from the type referenced by the pointer\n+expression to @code{struct B}.\n+\n+@smallexample\n+struct __attribute__ ((aligned (N), warn_if_not_aligned (N)))\n+A @{ /* @r{@dots{}} */ @};\n+struct __attribute__ ((copy ( (struct A *)0)) B @{ /* @r{@dots{}} */ @};\n+@end smallexample\n+\n @item deprecated\n @itemx deprecated (@var{msg})\n @cindex @code{deprecated} type attribute"}, {"sha": "e071f125efe19d42ac0bd6d442325ad832f5f811", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -283,7 +283,8 @@ Objective-C and Objective-C++ Dialects}.\n -Walloc-zero  -Walloc-size-larger-than=@var{byte-size}\n -Walloca  -Walloca-larger-than=@var{byte-size} @gol\n -Wno-aggressive-loop-optimizations  -Warray-bounds  -Warray-bounds=@var{n} @gol\n--Wno-attributes  -Wbool-compare  -Wbool-operation @gol\n+-Wno-attributes -Wno-attribute-alias @gol\n+-Wbool-compare  -Wbool-operation @gol\n -Wno-builtin-declaration-mismatch @gol\n -Wno-builtin-macro-redefined  -Wc90-c99-compat  -Wc99-c11-compat @gol\n -Wc++-compat  -Wc++11-compat  -Wc++14-compat  -Wc++17-compat  @gol\n@@ -316,7 +317,7 @@ Objective-C and Objective-C++ Dialects}.\n -Winvalid-pch  -Wlarger-than=@var{byte-size} @gol\n -Wlogical-op  -Wlogical-not-parentheses  -Wlong-long @gol\n -Wmain  -Wmaybe-uninitialized  -Wmemset-elt-size  -Wmemset-transposed-args @gol\n--Wmisleading-indentation  -Wmissing-attributes -Wmissing-braces @gol\n+-Wmisleading-indentation  -Wno-missing-attributes -Wmissing-braces @gol\n -Wmissing-field-initializers  -Wmissing-include-dirs  -Wmissing-profile @gol\n -Wno-multichar  -Wmultistatement-macros  -Wnonnull  -Wnonnull-compare @gol\n -Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]} @gol\n@@ -4805,13 +4806,24 @@ about the layout of the file that the directive references.\n \n This warning is enabled by @option{-Wall} in C and C++.\n \n-@item -Wmissing-attributes\n+@item -Wno-missing-attributes\n @opindex Wmissing-attributes\n @opindex Wno-missing-attributes\n Warn when a declaration of a function is missing one or more attributes\n that a related function is declared with and whose absence may adversely\n-affect the correctness or efficiency of generated code.  For example, in\n-C++, the warning is issued when an explicit specialization of a primary\n+affect the correctness or efficiency of generated code.  For example,\n+the warning is issued for declarations of aliases that use attributes\n+to specify less restrictive requirements than those of their targets.\n+This typically represents a potential optimization oportunity rather\n+than a hidden bug.  The @option{-Wattribute-alias} option controls warnings\n+issued for mismatches between declarations of aliases and their targets\n+that might be indicative of code generation bugs.\n+Attributes considered include @code{alloc_align}, @code{alloc_size},\n+@code{cold}, @code{const}, @code{hot}, @code{leaf}, @code{malloc},\n+@code{nonnull}, @code{noreturn}, @code{nothrow}, @code{pure},\n+@code{returns_nonnull}, and @code{returns_twice}.\n+\n+In C++, the warning is issued when an explicit specialization of a primary\n template declared with attribute @code{alloc_align}, @code{alloc_size},\n @code{assume_aligned}, @code{format}, @code{format_arg}, @code{malloc},\n or @code{nonnull} is declared without it.  Attributes @code{deprecated},\n@@ -5831,10 +5843,28 @@ pointers. This warning level may give a larger number of\n false positives and is deactivated by default.\n @end table\n \n-@item -Wattribute-alias\n+@item -Wattribute-alias=@var{n}\n+@itemx -Wno-attribute-alias\n+@opindex -Wattribute-alias\n+@opindex -Wno-attribute-alias\n Warn about declarations using the @code{alias} and similar attributes whose\n-target is incompatible with the type of the alias.  @xref{Function Attributes,\n-,Declaring Attributes of Functions}.\n+target is incompatible with the type of the alias.\n+@xref{Function Attributes,,Declaring Attributes of Functions}.\n+The @option{-Wattribute-alias=1} is  enabled by @option{-Wall}.\n+\n+@table @gcctabopt\n+@item -Wattribute-alias=1\n+The default warning level of the @option{-Wattribute-alias} option diagnoses\n+incompatibilities between the type of the alias declaration and that of its\n+target.  Such incompatibilities are typically indicative of bugs.\n+\n+@item -Wattribute-alias=2\n+At this level @option{-Wattribute-alias} also diagnoses mismatches between\n+the set of attributes of the alias declaration and the attributes applied\n+to its target.  Although in some cases such mismatches may indicate bugs,\n+in other cases they may be benign and could be resolved simply by adding\n+the missing attribute to the target.\n+@end table\n \n @item -Wbool-compare\n @opindex Wno-bool-compare"}, {"sha": "1556e8a7d19eb6d27b8b17741ba57e57432ecf12", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -1,3 +1,13 @@\n+2018-11-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/81824\n+\t* gcc.dg/Wattribute-alias.c: New test.\n+\t* gcc.dg/Wmissing-attributes.c: New test.\n+\t* gcc.dg/attr-copy.c: New test.\n+\t* gcc.dg/attr-copy-2.c: New test.\n+\t* gcc.dg/attr-copy-3.c: New test.\n+\t* gcc.dg/attr-copy-4.c: New test.\n+\n 2018-11-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/87795"}, {"sha": "175e40b47640bfdc169c24361a2a3ac8bb71cea8", "filename": "gcc/testsuite/gcc.dg/Wattribute-alias.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2FWattribute-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2FWattribute-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWattribute-alias.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -0,0 +1,49 @@\n+/* PR middle-end/81824 - Warn for missing attributes with function aliases\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wattribute-alias=2\" } */\n+\n+#define ATTR(...)   __attribute__ ((__VA_ARGS__))\n+\n+\n+void\n+target_no_nothrow (void)        /* { dg-message \".alias_nothrow. target declared here\" } */\n+{ }\n+\n+ATTR (alias (\"target_no_nothrow\"), nothrow) void\n+alias_nothrow (void);           /* { dg-warning \".alias_nothrow. specifies more restrictive attribute than its target .target_no_nothrow.: .nothrow.\" } */\n+\n+\n+ATTR (pure) int\n+alias_pure (void);\n+\n+int\n+target_no_pure (void)           /* { dg-message \".alias_pure. target declared here\" } */\n+{ return 0; }\n+\n+ATTR (alias (\"target_no_pure\")) int\n+alias_pure (void);              /* { dg-warning \".alias_pure. specifies more restrictive attribute than its target .target_no_pure.: .pure.\" } */\n+\n+\n+ATTR (const) int\n+alias_const (void);\n+\n+int\n+target_pure (void)              /* { dg-message \".alias_const. target declared here\" } */\n+{ return 0; }\n+\n+ATTR (alias (\"target_pure\")) int\n+alias_const (void);             /* { dg-warning \".alias_const. specifies more restrictive attribute than its target .target_pure.: .const.\" } */\n+\n+\n+/* There is no obvious relationship between the attributes on an ifunc\n+   resolver and those on its aliases.  Verify that mismatches between\n+   aliases and ifunc resolvers do not trigger warnings.  */\n+\n+typedef int F (void);\n+\n+ATTR (pure, leaf) F* resolve_to_const (void)\n+{ return alias_const; }\n+\n+ATTR (ifunc (\"resolve_to_const\")) F alias_no_const_ifunc;\n+ATTR (const, ifunc (\"resolve_to_const\")) F alias_const_ifunc;\n+ATTR (ifunc (\"resolve_to_const\")) int alias_no_leaf_ifunc (void);"}, {"sha": "2a981828a29d9d05463fb5bff0f4c39e486c4a9b", "filename": "gcc/testsuite/gcc.dg/Wmissing-attributes.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-attributes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-attributes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-attributes.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -0,0 +1,95 @@\n+/* PR middle-end/81824 - Warn for missing attributes with function aliases\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define ATTR(list)   __attribute__ (list)\n+\n+\n+int alias_no_const (void);\n+\n+ATTR ((const)) int\n+target_const (void)             /* { dg-message \".alias_no_const. target declared here\" } */\n+{ return 0; }\n+\n+ATTR ((alias (\"target_const\"))) int\n+alias_no_const (void);          /* { dg-warning \".alias_no_const. specifies less restrictive attribute than its target .target_const.: .const.\" } */\n+\n+\n+ATTR ((alloc_size (1), malloc)) void*\n+target_malloc (int n)           /* { dg-message \".alias_no_malloc. target declared here\" } */\n+{ return __builtin_malloc (n); }\n+\n+ATTR ((alias (\"target_malloc\"))) void*\n+alias_no_malloc (int);          /* { dg-warning \".alias_no_malloc. specifies less restrictive attributes than its target .target_malloc.: .alloc_size., .malloc.\" } */\n+\n+\n+ATTR ((leaf)) int\n+target_leaf (void)              /* { dg-message \".alias_no_leaf. target declared here\" } */\n+{ return 0; }\n+\n+ATTR ((alias (\"target_leaf\"))) int\n+alias_no_leaf (void);           /* { dg-warning \".alias_no_leaf. specifies less restrictive attribute than its target .target_leaf.: .leaf.\" } */\n+\n+\n+/* Verify that attributes noclone, noinline, and noipa on the target\n+   don't cause a warning for aliases without the attribute.  */\n+\n+ATTR ((noclone)) int\n+target_noclone (void)\n+{ return 0; }\n+\n+ATTR ((alias (\"target_noclone\"))) int\n+alias_no_noclone (void);\n+\n+\n+ATTR ((noipa)) int\n+target_noipa (void)\n+{ return 0; }\n+\n+ATTR ((alias (\"target_noipa\"))) int\n+alias_no_noipa (void);\n+\n+\n+ATTR ((noinline)) int\n+target_noinline (void)\n+{ return 0; }\n+\n+ATTR ((alias (\"target_noinline\"))) int\n+alias_no_noinline (void);\n+\n+\n+ATTR ((nothrow)) int\n+target_nothrow (void)           /* { dg-message \".alias_no_nothrow. target declared here\" } */\n+{ return 0; }\n+\n+ATTR ((alias (\"target_nothrow\"))) int\n+alias_no_nothrow (void);        /* { dg-warning \".alias_no_nothrow. specifies less restrictive attribute than its target .target_nothrow.: .nothrow.\" } */\n+\n+\n+/* Verify that attribute weak on the target doesn't cause and isn't\n+   mentioned in a warning for aliases without the attribute.  */\n+\n+ATTR ((weak)) int\n+target_weak (void)\n+{ return 0; }\n+\n+ATTR ((alias (\"target_weak\"))) int\n+alias_no_weak (void);\n+\n+\n+ATTR ((nothrow, weak)) int\n+target_nothrow_weak (void)      /* { dg-message \".alias_nothrow_no_weak. target declared here\" } */\n+{ return 0; }\n+\n+ATTR ((alias (\"target_nothrow_weak\"))) int\n+alias_nothrow_no_weak (void);        /* { dg-warning \".alias_nothrow_no_weak. specifies less restrictive attribute than its target .target_nothrow_weak.: .nothrow.\" } */\n+\n+\n+/* Verify that __typeof__ doesn't include attributes.  */\n+\n+ATTR ((cold)) int\n+target_cold (void)\n+{ return 0; }\n+\n+__typeof__ (target_cold) ATTR ((alias (\"target_cold\")))\n+alias_cold;                   /* { dg-warning \".alias_cold. specifies less restrictive attribute than its target .target_cold.: .cold.\" } */"}, {"sha": "39e5f087dead6d6af43cd1ea1df704ad53932432", "filename": "gcc/testsuite/gcc.dg/attr-copy-2.c", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -0,0 +1,209 @@\n+/* PR middle-end/81824 - Warn for missing attributes with function aliases\n+   Exercise attribute copy for functions.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define Assert(expr)   typedef char AssertExpr[2 * !!(expr) - 1]\n+\n+#define ATTR(list)   __attribute__ (list)\n+\n+/* Verify that referencing a symbol with no attributes is accepted\n+   with no diagnostics.  */\n+\n+void ref0 (void);\n+\n+ATTR ((copy (ref0))) void\n+f0 (void);\n+\n+/* Verify that referencing a symbol using the address-of and dereferencing\n+   operators is also accepted with no diagnostics.  */\n+\n+ATTR ((copy (&ref0))) void f1 (void);\n+ATTR ((copy (*ref0))) void f2 (void);\n+\n+/* Verify that referencing a symbol of a different kind than that\n+   of the one the attribute is applied to is diagnosed.  */\n+\n+int v0;                       /* { dg-message \"symbol .v0. referenced by .f3. declared here\" } */\n+\n+ATTR ((copy (v0))) void\n+f3 (void);                    /* { dg-warning \".copy. attribute ignored on a declaration of a different kind than referenced symbol\" } */\n+\n+void f4 (void);              /* { dg-message \"symbol .f4. referenced by .v1. declared here\" } */\n+\n+ATTR ((copy (f4))) int\n+v1;                           /* { dg-warning \".copy. attribute ignored on a declaration of a different kind than referenced symbol\" } */\n+\n+\n+ATTR ((copy (v0 + 1)))\n+void f5 (void);               /* { dg-warning \".copy. attribute ignored on a declaration of a different kind than referenced symbol\" } */\n+\n+void f6 (void);\n+\n+ATTR ((copy (f6 - 1)))\n+int v1;                       /* { dg-warning \".copy. attribute ignored on a declaration of a different kind than referenced symbol\" } */\n+\n+\n+\n+/* Verify that circular references of the copy function attribute\n+   are handled gracefully (i.e., not by getting into an infinite\n+   recursion) by issuing a diagnostic.  */\n+\n+void xref1 (void);            /* { dg-message \"previous declaration here\" } */\n+ATTR ((copy (xref1))) void\n+xref1 (void);                 /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol\" } */\n+ATTR ((copy (xref1))) void\n+xref1 (void);                 /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol\" } */\n+ATTR ((copy (xref1), copy (xref1))) void\n+xref1 (void);                 /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol\" } */\n+\n+\n+/* Use attribute noreturn to verify that circular references propagate\n+   atttibutes as expected, and unlike in the self-referential instances\n+   above, without a warning.  Also use the address-of operator to make\n+   sure it doesn't change anything.  */\n+\n+ATTR ((noreturn))      void xref2 (void);\n+ATTR ((copy (xref2)))  void xref3 (void);\n+ATTR ((copy (&xref3))) void xref4 (void);\n+ATTR ((copy (xref4)))  void xref5 (void);\n+ATTR ((copy (&xref5))) void xref6 (void);\n+ATTR ((copy (xref6)))  void xref7 (void);\n+ATTR ((copy (&xref7))) void xref8 (void);\n+ATTR ((copy (xref8)))  void xref9 (void);\n+ATTR ((copy (&xref9))) void xref2 (void);\n+\n+int call_ref2 (void) { xref2 (); }\n+int call_ref3 (void) { xref3 (); }\n+int call_ref4 (void) { xref4 (); }\n+int call_ref5 (void) { xref5 (); }\n+int call_ref6 (void) { xref6 (); }\n+int call_ref7 (void) { xref7 (); }\n+int call_ref8 (void) { xref8 (); }\n+int call_ref9 (void) { xref9 (); }\n+\n+\n+/* Verify that copying attributes from multiple symbols into one works\n+   as expected.  */\n+\n+ATTR ((malloc)) void*\n+xref10 (void);\n+\n+ATTR ((alloc_size (1)))\n+void* xref11 (int);\n+\n+ATTR ((copy (xref10), copy (xref11)))\n+void* xref12 (int);\n+\n+void* call_xref12 (void)\n+{\n+  void *p = xref12 (3);\n+  __builtin___strcpy_chk (p, \"123\", __builtin_object_size (p, 0));   /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  return p;\n+}\n+\n+\n+/* Verify that attribute exclusions apply.  */\n+\n+ATTR ((const)) int\n+fconst (void);\n+\n+ATTR ((pure)) int\n+fpure (void);                 /* { dg-message \"previous declaration here\" } */\n+\n+ATTR ((copy (fconst), copy (fpure))) int\n+fconst_pure (void);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .const.\" } */\n+\n+\n+/* Also verify that the note in the exclusion warning points to\n+   the declaration from which the conflicting attribute is copied.\n+   The wording in the note could be improved but it's the same as\n+   in ordinary exclusions so making it different between the two\n+   would take some API changes.  */\n+\n+ATTR ((const)) int\n+gconst (void);                /* { dg-message \"previous declaration here\" } */\n+\n+ATTR ((pure, copy (gconst))) int\n+gpure_const (void);           /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .pure.\" } */\n+\n+\n+/* Verify that attribute deprecated isn't copied (but referencing\n+   the deprecated declaration still triggers a warning).  */\n+\n+ATTR ((deprecated)) void\n+fdeprecated (void);           /* { dg-message \"declared here\" } */\n+\n+/* Unlike in most other instance the warning below is on the line\n+   with the copy attribute that references the deprecated function.  */\n+ATTR ((copy (fdeprecated)))   /* { dg-warning \"\\\\\\[-Wdeprecated-declarations]\" } */\n+int fcurrent (void);\n+\n+ATTR ((copy (fcurrent))) int\n+fcurrent2 (void);\n+\n+int call_fcurrent (void) { return fcurrent () + fcurrent2 (); }\n+\n+\n+/* Verify that attributes are copied on a declaration using __typeof__\n+   and that -Wmissing-attributes is not issued.  */\n+\n+ATTR ((cold)) int\n+target_cold (void)\n+{ return 0; }\n+\n+__typeof__ (target_cold) ATTR ((copy (target_cold), alias (\"target_cold\")))\n+alias_cold;                   /* { dg-bogus \"\\\\\\[-Wmissing-attributes].\" } */\n+\n+\n+/* Verify that attribute alias is not copied.  This also indirectly\n+   verifies that attribute copy itself isn't copied.  */\n+\n+ATTR ((noreturn)) void fnoret (void) { __builtin_abort (); }\n+ATTR ((alias (\"fnoret\"), copy (fnoret))) void fnoret_alias (void);\n+ATTR ((copy (fnoret_alias))) void fnoret2 (void) { __builtin_exit (1); }\n+\n+/* Expect no warning below.  */\n+int call_noret (void) { fnoret2 (); }\n+\n+\n+/* Verify that attribute nonnull (which is part of a function type,\n+   even when it's specified on a function declaration) is copied to\n+   the alias from its target.  Expect no warning about the alias\n+   specifying less restrictive attributes than its target, but do\n+   verify that passing a null to the alias triggers -Wnonnull.  */\n+\n+ATTR ((nonnull))\n+void* ftarget_nonnull (void *p) { return p; }\n+\n+ATTR ((alias (\"ftarget_nonnull\"), copy (ftarget_nonnull)))\n+void* falias_nonnull (void*);\n+\n+void call_falias_nonnull (void)\n+{\n+  falias_nonnull (0);         /* { dg-warning \"-Wnonnull\" } */\n+}\n+\n+/* Same as above but for malloc.  Also verify that the attribute\n+   on the alias is used by -Wstringop-overflow.  */\n+\n+ATTR ((malloc))\n+void* ftarget_malloc (void) { return __builtin_malloc (1); }\n+\n+ATTR ((alias (\"ftarget_malloc\"), copy (ftarget_malloc)))\n+void* falias_malloc (void);\n+\n+void* call_falias_malloc (void)\n+{\n+  char *p = falias_malloc ();\n+  __builtin___strcpy_chk (p, \"123\", __builtin_object_size (p, 0));   /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  return p;\n+}\n+\n+/* Same as above but for nothrow.  */\n+\n+ATTR ((nothrow))\n+void ftarget_nothrow (void) { }\n+\n+ATTR ((alias (\"ftarget_nothrow\"), copy (ftarget_nothrow)))\n+void falias_nothrow (void);"}, {"sha": "88e5e5ed21595da1b0eef78051c53549f10225c6", "filename": "gcc/testsuite/gcc.dg/attr-copy-3.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-3.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -0,0 +1,75 @@\n+/* PR middle-end/81824 - Warn for missing attributes with function aliases\n+   Exercise attribute copy for variables.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define ATTR(list)   __attribute__ (list)\n+\n+/* Verify that referencing a symbol with no attributes is accepted\n+   with no diagnostics.  */\n+\n+int ref0;\n+\n+ATTR ((copy (ref0))) long\n+var0;\n+\n+/* Verify that referencing a symbol using the address-of and dereferencing\n+   operators is also accepted with no diagnostics.  */\n+\n+ATTR ((copy (&ref0))) void* ptr0;\n+ATTR ((copy (*&ref0))) int arr[1];\n+\n+/* Verify that referencing a symbol of a different kind than that\n+   of the one the attribute is applied to is diagnosed.  */\n+\n+int ref1;                     /* { dg-message \"previous declaration here\" } */\n+\n+ATTR ((copy (ref1))) int\n+ref1;                         /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol \" } */\n+\n+\n+/* Verify that circular references of the copy variable attribute\n+   are handled gracefully (i.e., not by getting into an infinite\n+   recursion) by issuing a diagnostic.  */\n+\n+char xref1;\n+ATTR ((copy (xref1))) char\n+xref1;                        /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol\" } */\n+ATTR ((copy (xref1))) char\n+xref1;                        /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol\" } */\n+ATTR ((copy (xref1), copy (xref1))) char\n+xref1;                        /* { dg-warning \".copy. attribute ignored on a redeclaration of the referenced symbol\" } */\n+\n+\n+/* Use attribute unused to verify that circular references propagate\n+   atttibutes as expected (expect no warnings the circular reference\n+   or for any of the unused symbols).  Also use the address-of operator\n+   to make sure it doesn't change anything.  */\n+\n+static ATTR ((unused))        int xref2;\n+static ATTR ((copy (xref2)))  int xref3;\n+static ATTR ((copy (&xref3))) int xref4;\n+static ATTR ((copy (xref4)))  int xref5;\n+static ATTR ((copy (&xref5))) int xref6;\n+static ATTR ((copy (xref6)))  int xref7;\n+static ATTR ((copy (&xref7))) int xref8;\n+static ATTR ((copy (xref8)))  int xref9;\n+static ATTR ((copy (&xref9))) int xref2;\n+\n+/* Verify that attribute exclusions apply.  */\n+\n+ATTR ((common)) int common_var;\n+ATTR ((nocommon)) double nocommon_var;\n+\n+ATTR ((copy (common_var), copy (nocommon_var))) long\n+common_copy;                  /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */\n+\n+\n+/* Verify that attribute deprecated isn't copied.  */\n+\n+ATTR ((deprecated)) char deprecated_var;\n+\n+ATTR ((copy (deprecated_var))) int current_var;  /* { dg-warning \"\\\\\\[-Wdeprecated-declarations]\" } */\n+ATTR ((copy (current_var))) int current_var_2;\n+\n+int return_current_vars (void) { return current_var + current_var_2; }"}, {"sha": "7020bad7aa9194202f9cbb5429799e34aede59c2", "filename": "gcc/testsuite/gcc.dg/attr-copy-4.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-4.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -0,0 +1,61 @@\n+/* PR middle-end/81824 - Warn for missing attributes with function aliases\n+   Exercise attribute copy for types.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define Assert(expr)   typedef char AssertExpr[2 * !!(expr) - 1]\n+\n+#define ATTR(list)   __attribute__ (list)\n+\n+/* Use attribute packed to verify that type attributes are copied\n+   from one type to another.  */\n+\n+struct ATTR ((packed)) PackedA { int i; char c; };\n+\n+Assert (__alignof (struct PackedA) == 1);\n+\n+struct ATTR ((copy ((struct PackedA*)0))) PackedB { long i; char c; };\n+\n+Assert (__alignof (struct PackedA) == __alignof (struct PackedB));\n+\n+struct PackedMember\n+{\n+  char c;\n+  ATTR ((copy ((struct PackedB*)0))) double packed_mem;\n+};\n+\n+Assert (__alignof (struct PackedMember) == 1);\n+\n+\n+extern const struct PackedA packed;\n+\n+struct Unpacked { int i; char c; };\n+Assert (__alignof (struct Unpacked) > 1);\n+\n+/* Verify that copying the packed attribute to the declaration\n+   of an object is ignored with a warning.  (There should be\n+   a way to copy just the subset of attributes from a type that\n+   aren't ignored and won't cause a warning, maybe via attribute\n+   copy_except or something like that.)  */\n+extern ATTR ((copy ((struct PackedA*)0))) const struct Unpacked\n+  unpacked;                   /* { dg-warning \".packed. attribute ignored\" } */\n+\n+Assert (__alignof (packed) == 1);\n+Assert (__alignof (unpacked) == __alignof (struct Unpacked));\n+\n+\n+\n+/* Verify that attribute deprecated isn't copied (but referencing\n+   the deprecated type in the copy attribute still triggers a warning).  */\n+\n+struct ATTR ((aligned (8), deprecated))\n+AlignedDeprecated { char c; };\n+\n+struct ATTR ((copy ((struct AlignedDeprecated *)0)))        /* { dg-warning \"\\\\\\[-Wdeprecated-declarations]\" } */\n+AlignedCopy { short s; };\n+\n+Assert (__alignof (struct AlignedCopy) == 8);\n+\n+struct AlignedCopy aligned_copy;\n+\n+Assert (__alignof (aligned_copy) == 8);"}, {"sha": "27cd7bc5be62ddfdef5ffc453d8c37cc28588bda", "filename": "gcc/testsuite/gcc.dg/attr-copy.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy.c?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -0,0 +1,33 @@\n+/* PR middle-end/81824 - Warn for missing attributes with function aliases\n+   Exercise error handling for attribute copy.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define ATTR(list)   __attribute__ (list)\n+\n+/* Verify incorrect numbers of arguments.  */\n+ATTR ((copy)) void\n+fno_args (void);              /* { dg-error \"wrong number of arguments specified for .copy. attribute\" } */\n+\n+ATTR ((copy ())) void\n+fno_args2 (void);             /* { dg-error \"wrong number of arguments specified for .copy. attribute\" } */\n+\n+ATTR ((copy (fno_args, fno_args))) void\n+fmlti_args (void);            /* { dg-error \"wrong number of arguments specified for .copy. attribute\" } */\n+\n+/* Verify that referencing an undeclared symbol is rejected with an error.  */\n+\n+ATTR ((copy (foobar)))        /* { dg-error \".foobar. undeclared\" } */\n+void fundeclared (void);\n+\n+/* Verify that using a string argument triggers a descriptive error\n+   (given attributes like alias and weakref using a string is a likely\n+   mistake).  */\n+\n+ATTR ((copy (\"foobar\")))\n+void fstring (void);          /* { dg-error \".copy. attribute argument cannot be a string\" } */\n+\n+/* Ditto for an integer.  */\n+\n+ATTR ((copy (123)))\n+void fnumber (void);          /* { dg-error \".copy. attribute argument cannot be a constant arithmetic expression\" } */"}, {"sha": "7eacb45db66e89443b837b49e1afcb5f123b15e0", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a2c4281c7dcaa6a138d24fd037c62453a12bde/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a2c4281c7dcaa6a138d24fd037c62453a12bde/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=79a2c4281c7dcaa6a138d24fd037c62453a12bde", "patch": "@@ -1149,16 +1149,26 @@ extern int gomp_test_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n # define attribute_hidden\n #endif\n \n+#if __GNUC__ >= 9\n+#  define HAVE_ATTRIBUTE_COPY\n+#endif\n+\n+#ifdef HAVE_ATTRIBUTE_COPY\n+# define attribute_copy(arg) __attribute__ ((copy (arg)))\n+#else\n+# define attribute_copy(arg)\n+#endif\n+\n #ifdef HAVE_ATTRIBUTE_ALIAS\n # define strong_alias(fn, al) \\\n-  extern __typeof (fn) al __attribute__ ((alias (#fn)));\n+  extern __typeof (fn) al __attribute__ ((alias (#fn))) attribute_copy (fn);\n \n # define ialias_ulp\tialias_str1(__USER_LABEL_PREFIX__)\n # define ialias_str1(x)\tialias_str2(x)\n # define ialias_str2(x)\t#x\n # define ialias(fn) \\\n   extern __typeof (fn) gomp_ialias_##fn \\\n-    __attribute__ ((alias (#fn))) attribute_hidden;\n+    __attribute__ ((alias (#fn))) attribute_hidden attribute_copy (fn);\n # define ialias_redirect(fn) \\\n   extern __typeof (fn) fn __asm__ (ialias_ulp \"gomp_ialias_\" #fn) attribute_hidden;\n # define ialias_call(fn) gomp_ialias_ ## fn"}]}