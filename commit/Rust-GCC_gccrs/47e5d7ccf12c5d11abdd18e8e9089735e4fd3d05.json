{"sha": "47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdlNWQ3Y2NmMTJjNWQxMWFiZGQxOGU4ZTkwODk3MzVlNGZkM2QwNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-11-15T05:22:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-15T05:22:28Z"}, "message": "Various C++17 decomposition fixes.\n\n\t* tree.c (bitfield_p): New.\n\t* cp-tree.h: Declare it.\n\t* typeck.c (cxx_sizeof_expr, cxx_alignof_expr)\n\t(cp_build_addr_expr_1): Use it instead of DECL_C_BIT_FIELD.\n\t* decl.c (cp_finish_decomp): Look through reference.  Always\n\tSET_DECL_DECOMPOSITION_P.\n\t* semantics.c (finish_decltype_type): Adjust decomposition handling.\n\nFrom-SVN: r242408", "tree": {"sha": "376f8789de74bf75a940c9583acaea031e9de6d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/376f8789de74bf75a940c9583acaea031e9de6d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a274cc11ac675686a71aef82e2e734795d18f339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a274cc11ac675686a71aef82e2e734795d18f339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a274cc11ac675686a71aef82e2e734795d18f339"}], "stats": {"total": 170, "additions": 140, "deletions": 30}, "files": [{"sha": "e9dd17c5d36ac4dbfb0d2221e45b900be9ea4c3d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -1,3 +1,13 @@\n+2016-11-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.c (bitfield_p): New.\n+\t* cp-tree.h: Declare it.\n+\t* typeck.c (cxx_sizeof_expr, cxx_alignof_expr)\n+\t(cp_build_addr_expr_1): Use it instead of DECL_C_BIT_FIELD.\n+\t* decl.c (cp_finish_decomp): Look through reference.  Always\n+\tSET_DECL_DECOMPOSITION_P.\n+\t* semantics.c (finish_decltype_type): Adjust decomposition handling.\n+\n 2016-11-13  Jakub Jelinek  <jakub@redhat.com>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "edcd3b47fa87966441c8da723f73c9c11234db9a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -6572,6 +6572,7 @@ extern cp_lvalue_kind lvalue_kind\t\t(const_tree);\n extern bool glvalue_p\t\t\t\t(const_tree);\n extern bool obvalue_p\t\t\t\t(const_tree);\n extern bool xvalue_p\t                        (const_tree);\n+extern bool bitfield_p\t\t\t\t(const_tree);\n extern tree cp_stabilize_reference\t\t(tree);\n extern bool builtin_valid_in_constant_expr_p    (const_tree);\n extern tree build_min\t\t\t\t(enum tree_code, tree, ...);"}, {"sha": "2af95a7568d1591727b7ae80b44a2ffe4413e652", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -7350,18 +7350,23 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n   for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))\n     {\n       v[count - i - 1] = d;\n-      if (processing_template_decl)\n-\t{\n-\t  retrofit_lang_decl (d);\n-\t  SET_DECL_DECOMPOSITION_P (d);\n-\t}\n+      retrofit_lang_decl (d);\n+      SET_DECL_DECOMPOSITION_P (d);\n     }\n \n   tree type = TREE_TYPE (decl);\n-  tree eltype = NULL_TREE;\n+  tree dexp = decl;\n+\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+    {\n+      /* If e is a constant reference, use the referent directly.  */\n+      if (DECL_INITIAL (decl))\n+\tdexp = DECL_INITIAL (decl);\n+      dexp = convert_from_reference (dexp);\n+      type = TREE_TYPE (type);\n+    }\n \n+  tree eltype = NULL_TREE;\n   unsigned HOST_WIDE_INT eltscnt = 0;\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -7391,7 +7396,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t{\n \t  TREE_TYPE (v[i]) = eltype;\n \t  layout_decl (v[i], 0);\n-\t  tree t = convert_from_reference (decl);\n+\t  tree t = dexp;\n \t  t = build4_loc (DECL_SOURCE_LOCATION (v[i]), ARRAY_REF,\n \t\t\t  eltype, t, size_int (i), NULL_TREE,\n \t\t\t  NULL_TREE);\n@@ -7410,7 +7415,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t{\n \t  TREE_TYPE (v[i]) = eltype;\n \t  layout_decl (v[i], 0);\n-\t  tree t = convert_from_reference (decl);\n+\t  tree t = dexp;\n \t  t = build1_loc (DECL_SOURCE_LOCATION (v[i]),\n \t\t\t  i ? IMAGPART_EXPR : REALPART_EXPR, eltype,\n \t\t\t  t);\n@@ -7428,7 +7433,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t{\n \t  TREE_TYPE (v[i]) = eltype;\n \t  layout_decl (v[i], 0);\n-\t  tree t = convert_from_reference (decl);\n+\t  tree t = dexp;\n \t  convert_vector_to_array_for_subscript (DECL_SOURCE_LOCATION (v[i]),\n \t\t\t\t\t\t &t, size_int (i));\n \t  t = build4_loc (DECL_SOURCE_LOCATION (v[i]), ARRAY_REF,\n@@ -7501,7 +7506,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t  eltscnt++;\n       if (count != eltscnt)\n \tgoto cnt_mismatch;\n-      tree t = convert_from_reference (decl);\n+      tree t = dexp;\n       if (type != btype)\n \t{\n \t  t = convert_to_base (t, btype, /*check_access*/true,"}, {"sha": "29f52333a94cf743256b8eed209215c17b64c172", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -8873,8 +8873,13 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n       if (identifier_p (expr))\n         expr = lookup_name (expr);\n \n-      if (VAR_P (expr) && DECL_HAS_VALUE_EXPR_P (expr))\n-\texpr = DECL_VALUE_EXPR (expr);\n+      /* The decltype rules for decomposition are different from the rules for\n+\t member access; in particular, the decomposition decl gets\n+\t cv-qualifiers from the aggregate object, whereas decltype of a member\n+\t access expr ignores the object.  */\n+      if (VAR_P (expr) && DECL_DECOMPOSITION_P (expr)\n+\t  && DECL_HAS_VALUE_EXPR_P (expr))\n+\treturn unlowered_expr_type (DECL_VALUE_EXPR (expr));\n \n       if (INDIRECT_REF_P (expr))\n         /* This can happen when the expression is, e.g., \"a.b\". Just"}, {"sha": "d1dd7c40680f27eff76e4a105acdcc71b0c5d19f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -305,6 +305,14 @@ xvalue_p (const_tree ref)\n   return (lvalue_kind (ref) == clk_rvalueref);\n }\n \n+/* True if REF is a bit-field.  */\n+\n+bool\n+bitfield_p (const_tree ref)\n+{\n+  return (lvalue_kind (ref) & clk_bitfield);\n+}\n+\n /* C++-specific version of stabilize_reference.  */\n \n tree"}, {"sha": "6f9ad0ed3cb66e7301e6b727c47d4dba1d416efb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -1650,9 +1650,7 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n \n   e = mark_type_use (e);\n \n-  if (TREE_CODE (e) == COMPONENT_REF\n-      && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n-      && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n+  if (bitfield_p (e))\n     {\n       if (complain & tf_error)\n         error (\"invalid application of %<sizeof%> to a bit-field\");\n@@ -1709,9 +1707,7 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n \n   if (VAR_P (e))\n     t = size_int (DECL_ALIGN_UNIT (e));\n-  else if (TREE_CODE (e) == COMPONENT_REF\n-\t   && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n-\t   && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n+  else if (bitfield_p (e))\n     {\n       if (complain & tf_error)\n         error (\"invalid application of %<__alignof%> to a bit-field\");\n@@ -5751,6 +5747,13 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n   if (argtype != error_mark_node)\n     argtype = build_pointer_type (argtype);\n \n+  if (bitfield_p (arg))\n+    {\n+      if (complain & tf_error)\n+\terror (\"attempt to take address of bit-field\");\n+      return error_mark_node;\n+    }\n+\n   /* In a template, we are processing a non-dependent expression\n      so we can just form an ADDR_EXPR with the correct type.  */\n   if (processing_template_decl || TREE_CODE (arg) != COMPONENT_REF)\n@@ -5775,13 +5778,6 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n \tval = build2 (COMPOUND_EXPR, TREE_TYPE (val),\n \t\t      TREE_OPERAND (arg, 0), val);\n     }\n-  else if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n-    {\n-      if (complain & tf_error)\n-\terror (\"attempt to take address of bit-field structure member %qD\",\n-\t       TREE_OPERAND (arg, 1));\n-      return error_mark_node;\n-    }\n   else\n     {\n       tree object = TREE_OPERAND (arg, 0);"}, {"sha": "bf218cca481b0d4377b750e8fc0face5a0e6a809", "filename": "gcc/testsuite/g++.dg/cpp0x/addressof2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Faddressof2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Faddressof2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Faddressof2.C?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -15,7 +15,7 @@ struct S { int s : 5; int t; void foo (); } s;\n \n auto c = __builtin_addressof (s);\n auto d = addressof (s);\n-auto e = __builtin_addressof (s.s);\t\t// { dg-error \"attempt to take address of bit-field structure member\" }\n+auto e = __builtin_addressof (s.s);\t\t// { dg-error \"attempt to take address of bit-field\" }\n auto f = addressof (s.s);\t\t\t// { dg-error \"cannot bind bitfield\" }\n auto g = __builtin_addressof (S{});\t\t// { dg-error \"taking address of temporary\" }\n auto h = addressof (S{});\t\t\t// { dg-error \"cannot bind non-const lvalue reference of type\" }"}, {"sha": "73edc871320a4d58adc54953bbf33b5600f929b5", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp-bitfield1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp-bitfield1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp-bitfield1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp-bitfield1.C?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -0,0 +1,19 @@\n+// Test of bit-fields.\n+// { dg-options -std=c++1z }\n+\n+struct A { long i: 2; } a;\n+\n+template <class,class> struct same_type;\n+template <class T> struct same_type<T,T> {};\n+\n+void f()\n+{\n+  auto [ x ] = a;\n+\n+  same_type<decltype(x),long>{};\n+  same_type<decltype(x+x),int>{};\n+\n+  long &r = x;\t\t\t// { dg-error \"bit\" }\n+  &x;\t\t\t\t// { dg-error \"bit\" }\n+  sizeof(x);\t\t\t// { dg-error \"bit\" }\n+}"}, {"sha": "722ff76de192a00cadb327f47609d24a1f63970d", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp-constexpr1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp-constexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp-constexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp-constexpr1.C?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -0,0 +1,18 @@\n+// Test for reference address comparison in constant expression.\n+// { dg-options -std=c++1z }\n+\n+int i[2];\n+struct A { int i, j; } a;\n+\n+void f()\n+{\n+  {\n+    auto& [ x, y ] = i;\n+    static_assert (&x == &i[0]);\n+  }\n+\n+  {\n+    auto& [ x, y ] = a;\n+    static_assert (&x == &a.i && &y != &a.i);\n+  }\n+}"}, {"sha": "2abbaaebe9a7ec4cdb6909ce0523ba59d0a81c5b", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp10.C", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp10.C?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -31,18 +31,15 @@ struct A4 {\n   template <int I> int& get() { return ar[I]; }\n } a4;\n template<> struct std::tuple_size<A4> { enum { value = 3 }; };\n-template <int I> \n void f4() { auto [ x, y, z ] = a4; }\t// { dg-error \"tuple_element\" }\n \n struct A5 { } a5;\n template <int I> int& get(A5&& a);\n template<> struct std::tuple_size<A5> { enum { value = 3 }; };\n-template <int I> \n void f5() { auto [ x, y, z ] = a5; }\t// { dg-error \"tuple_element\" }\n \n struct A6 { } a6;\n template <int I> int& get(A6&& a);\n template<> struct std::tuple_size<A6> { enum { value = 3 }; };\n template<> struct std::tuple_element<0, A6> { };\n-template <int I> \n void f6() { auto [ x, y, z ] = a6; }\t// { dg-error \"no type named .type\" }"}, {"sha": "9c8aaa48b4aae9084eaca36f9e598b422c5ffe3d", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp11.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp11.C?ref=47e5d7ccf12c5d11abdd18e8e9089735e4fd3d05", "patch": "@@ -0,0 +1,51 @@\n+// Test for decltype of direct decomposition.\n+// { dg-options -std=c++1z }\n+\n+template <class,class> struct same_type;\n+template <class T> struct same_type<T,T> {};\n+\n+struct A {\n+  int i;\n+  const int ci = 42;\n+  mutable int mi;\n+  int& r = i;\n+  const int& cr = ci;\n+} a;\n+\n+void f() {\n+  auto [i,ci,mi,r,cr] = a;\n+\n+  same_type<decltype(i),int>{};\n+  same_type<decltype(ci),const int>{};\n+  same_type<decltype(mi),int>{};\n+  same_type<decltype(r),int&>{};\n+  same_type<decltype(cr),const int&>{};\n+}\n+void frr() {\n+  auto &&[i,ci,mi,r,cr] = a;\n+\n+  same_type<decltype(i),int>{};\n+  same_type<decltype(ci),const int>{};\n+  same_type<decltype(mi),int>{};\n+  same_type<decltype(r),int&>{};\n+  same_type<decltype(cr),const int&>{};\n+}\n+void fc() {\n+  const auto [i,ci,mi,r,cr] = a;\n+\n+  same_type<decltype(i),const int>{};\n+  same_type<decltype(ci),const int>{};\n+  same_type<decltype(mi),int>{};\n+  same_type<decltype(r),int&>{};\n+  same_type<decltype(cr),const int&>{};\n+}\n+void frc() {\n+  const A ca{};\n+  auto &[i,ci,mi,r,cr] = ca;\n+\n+  same_type<decltype(i),const int>{};\n+  same_type<decltype(ci),const int>{};\n+  same_type<decltype(mi),int>{};\n+  same_type<decltype(r),int&>{};\n+  same_type<decltype(cr),const int&>{};\n+}"}]}