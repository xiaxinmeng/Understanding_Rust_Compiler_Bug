{"sha": "d0691cfba988d7e78d854ff40088df352ec09a8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA2OTFjZmJhOTg4ZDdlNzhkODU0ZmY0MDA4OGRmMzUyZWMwOWE4ZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-01-12T07:49:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-01-12T07:49:01Z"}, "message": "(macroexpand): Before concatenated empty rest arg,\n\ndo copy constant chars, but delete last run of nonwhitespace chars.\n(rescan): Handle Newline-Hyphen in expand_to_temp_buffer\nas well as when scanning a macro body.\n\n(main): If we are creating a new dependency file with -MD\nor -MMD, use \"w\" fopen mode instead of \"a\".\n\n(rescan): Prevent token pasting before macro call.\n(macroexpand): Prevent token pasting around an arg unless it's raw.\n\n(main): Implement -iwithprefix.\n\n(check_preconditions, do_error, do_warning, do_xifdef):\nDon't use signed chars to index into arrays; they might be negative.\n\nFrom-SVN: r3199", "tree": {"sha": "bb6112e18866aebc4f29bef709f03a7b763b49d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb6112e18866aebc4f29bef709f03a7b763b49d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0691cfba988d7e78d854ff40088df352ec09a8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0691cfba988d7e78d854ff40088df352ec09a8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0691cfba988d7e78d854ff40088df352ec09a8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0691cfba988d7e78d854ff40088df352ec09a8d/comments", "author": null, "committer": null, "parents": [{"sha": "df8b4049a725de5d044e13d724f9dcbf4e136058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8b4049a725de5d044e13d724f9dcbf4e136058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df8b4049a725de5d044e13d724f9dcbf4e136058"}], "stats": {"total": 155, "additions": 120, "deletions": 35}, "files": [{"sha": "d3d4727369f04ea82f9c5525d20e3d7455dd0ca9", "filename": "gcc/cccp.c", "status": "modified", "additions": 120, "deletions": 35, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0691cfba988d7e78d854ff40088df352ec09a8d/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0691cfba988d7e78d854ff40088df352ec09a8d/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=d0691cfba988d7e78d854ff40088df352ec09a8d", "patch": "@@ -963,6 +963,8 @@ main (argc, argv)\n   /* File name which deps are being written to.\n      This is 0 if deps are being written to stdout.  */\n   char *deps_file = 0;\n+  /* Fopen file mode to open deps_file with.  */\n+  char *deps_mode = \"a\";\n   /* Stream on which to print the dependency information.  */\n   FILE *deps_stream = 0;\n   /* Target-name to write with the dependency information.  */\n@@ -1035,22 +1037,45 @@ main (argc, argv)\n       case 'i':\n \tif (!strcmp (argv[i], \"-include\")) {\n \t  if (i + 1 == argc)\n-\t    fatal (\"Filename missing after -include option\");\n+\t    fatal (\"Filename missing after `-include' option\");\n \t  else\n \t    pend_includes[i] = argv[i+1], i++;\n \t}\n \tif (!strcmp (argv[i], \"-imacros\")) {\n \t  if (i + 1 == argc)\n-\t    fatal (\"Filename missing after -imacros option\");\n+\t    fatal (\"Filename missing after `-imacros' option\");\n \t  else\n \t    pend_files[i] = argv[i+1], i++;\n \t}\n \tif (!strcmp (argv[i], \"-iprefix\")) {\n \t  if (i + 1 == argc)\n-\t    fatal (\"Filename missing after -iprefix option\");\n+\t    fatal (\"Filename missing after `-iprefix' option\");\n \t  else\n \t    include_prefix = argv[++i];\n \t}\n+\t/* Add directory to end of path for includes,\n+\t   with the default prefix at the front of its name.  */\n+\tif (!strcmp (argv[i], \"-iwithprefix\")) {\n+\t  struct file_name_list *dirtmp;\n+\n+\t  dirtmp = (struct file_name_list *)\n+\t    xmalloc (sizeof (struct file_name_list));\n+\t  dirtmp->next = 0;\t/* New one goes on the end */\n+\t  dirtmp->control_macro = 0;\n+\t  if (i + 1 == argc)\n+\t    fatal (\"Directory name missing after `-iwithprefix' option\");\n+\n+\t  dirtmp->fname = (char *) xmalloc (strlen (argv[i+1])\n+\t\t\t\t\t    + strlen (include_prefix) + 1);\n+\t  strcpy (dirtmp->fname, include_prefix);\n+\t  strcat (dirtmp->fname, argv[++i]);\n+\n+\t  if (after_include == 0)\n+\t    after_include = dirtmp;\n+\t  else\n+\t    last_after_include->next = dirtmp;\n+\t  last_after_include = dirtmp; /* Tail follows the last one */\n+\t}\n \t/* Add directory to end of path for includes.  */\n \tif (!strcmp (argv[i], \"-idirafter\")) {\n \t  struct file_name_list *dirtmp;\n@@ -1060,7 +1085,7 @@ main (argc, argv)\n \t  dirtmp->next = 0;\t/* New one goes on the end */\n \t  dirtmp->control_macro = 0;\n \t  if (i + 1 == argc)\n-\t    fatal (\"Directory name missing after -idirafter option\");\n+\t    fatal (\"Directory name missing after `-idirafter' option\");\n \t  else\n \t    dirtmp->fname = argv[++i];\n \n@@ -1179,6 +1204,7 @@ main (argc, argv)\n \t    || !strcmp (argv[i], \"-MMD\")) {\n \t  i++;\n \t  deps_file = argv[i];\n+\t  deps_mode = \"w\";\n \t} else {\n \t  /* For -M and -MM, write deps on standard output\n \t     and suppress the usual output.  */\n@@ -1656,6 +1682,7 @@ main (argc, argv)\n     }\n       \n     deps_file = output_file;\n+    deps_mode = \"a\";\n   }\n \n   /* For -M, print the expected object file name\n@@ -1822,7 +1849,7 @@ main (argc, argv)\n   if (print_deps) {\n     /* Don't actually write the deps file if compilation has failed.  */\n     if (errors == 0) {\n-      if (deps_file && ! (deps_stream = fopen (deps_file, \"a\")))\n+      if (deps_file && ! (deps_stream = fopen (deps_file, deps_mode)))\n \tpfatal_with_name (deps_file);\n       fputs (deps_buffer, deps_stream);\n       putc ('\\n', deps_stream);\n@@ -2621,30 +2648,34 @@ do { ip = &instack[indepth];\t\t\\\n       break;\n \n     case '\\n':\n+      if (ip->fname == 0 && *ibp == '-') {\n+\t/* Newline - inhibits expansion of preceding token.\n+\t   If expanding a macro arg, we keep the newline -.\n+\t   In final output, it is deleted.\n+\t   We recognize Newline - in macro bodies and macro args.  */\n+\tif (! concatenated) {\n+\t  ident_length = 0;\n+\t  hash = 0;\n+\t}\n+\tibp++;\n+\tif (!output_marks) {\n+\t  obp--;\n+\t} else {\n+\t  /* If expanding a macro arg, keep the newline -.  */\n+\t  *obp++ = '-';\n+\t}\n+\tbreak;\n+      }\n+\n       /* If reprocessing a macro expansion, newline is a special marker.  */\n-      if (ip->macro != 0) {\n+      else if (ip->macro != 0) {\n \t/* Newline White is a \"funny space\" to separate tokens that are\n \t   supposed to be separate but without space between.\n \t   Here White means any whitespace character.\n \t   Newline - marks a recursive macro use that is not\n \t   supposed to be expandable.  */\n \n-\tif (*ibp == '-') {\n-\t  /* Newline - inhibits expansion of preceding token.\n-\t     If expanding a macro arg, we keep the newline -.\n-\t     In final output, it is deleted.  */\n-\t  if (! concatenated) {\n-\t    ident_length = 0;\n-\t    hash = 0;\n-\t  }\n-\t  ibp++;\n-\t  if (!output_marks) {\n-\t    obp--;\n-\t  } else {\n-\t    /* If expanding a macro arg, keep the newline -.  */\n-\t    *obp++ = '-';\n-\t  }\n-\t} else if (is_space[*ibp]) {\n+\tif (is_space[*ibp]) {\n \t  /* Newline Space does not prevent expansion of preceding token\n \t     so expand the preceding token and then come back.  */\n \t  if (ident_length > 0)\n@@ -2918,7 +2949,20 @@ do { ip = &instack[indepth];\t\t\\\n \t\t along with any following whitespace just copied.  */\n \t      obp = op->buf + obufp_before_macroname;\n \t      op->lineno = op_lineno_before_macroname;\n-\t      \n+\n+\t      /* Prevent accidental token-pasting with a character\n+\t\t before the macro call.  */\n+\t      if (!traditional && obp != op->buf\n+\t\t  && (obp[-1] == '-' || obp[1] == '+' || obp[1] == '&'\n+\t\t      || obp[-1] == '|' || obp[1] == '<' || obp[1] == '>')) {\n+\t\t/* If we are expanding a macro arg, make a newline marker\n+\t\t   to separate the tokens.  If we are making real output,\n+\t\t   a plain space will do.  */\n+\t\tif (output_marks)\n+\t\t  *obp++ = '\\n';\n+\t\t*obp++ = ' ';\n+\t      }\n+\n \t      /* Expand the macro, reading arguments as needed,\n \t\t and push the expansion on the input stack.  */\n \t      ip->bufp = ibp;\n@@ -4390,10 +4434,10 @@ check_preconditions (prec)\n       int len;\n       \n       prec += 5;\n-      while (is_hor_space[*prec])\n+      while (is_hor_space[(U_CHAR) *prec])\n \tprec++;\n       name = prec;\n-      while (is_idchar[*prec])\n+      while (is_idchar[(U_CHAR) *prec])\n \tprec++;\n       len = prec - name;\n       \n@@ -5840,7 +5884,7 @@ do_error (buf, limit, op, keyword)\n      struct directive *keyword;\n {\n   int length = limit - buf;\n-  char *copy = (char *) xmalloc (length + 1);\n+  U_CHAR *copy = (U_CHAR *) xmalloc (length + 1);\n   bcopy (buf, copy, length);\n   copy[length] = 0;\n   SKIP_WHITE_SPACE (copy);\n@@ -5863,7 +5907,7 @@ do_warning (buf, limit, op, keyword)\n      struct directive *keyword;\n {\n   int length = limit - buf;\n-  char *copy = (char *) xmalloc (length + 1);\n+  U_CHAR *copy = (U_CHAR *) xmalloc (length + 1);\n   bcopy (buf, copy, length);\n   copy[length] = 0;\n   SKIP_WHITE_SPACE (copy);\n@@ -6107,7 +6151,7 @@ do_xifdef (buf, limit, op, keyword)\n   if (ip->fname != 0 && keyword->type == T_IFNDEF) {\n     U_CHAR *p = ip->buf;\n     while (p != directive_start) {\n-      char c = *p++;\n+      U_CHAR c = *p++;\n       if (is_space[c])\n \t;\n       else if (c == '/' && p != ip->bufp && *p == '*') {\n@@ -7010,7 +7054,9 @@ macroexpand (hp, op)\n \tif (ap->stringify)\n \t  xbuf_len += args[ap->argno].stringified_length;\n \telse if (ap->raw_before || ap->raw_after || traditional)\n-\t  xbuf_len += args[ap->argno].raw_length;\n+\t  /* Add 4 for two newline-space markers to prevent\n+\t     token concatenation.  */\n+\t  xbuf_len += args[ap->argno].raw_length + 4;\n \telse {\n \t  /* We have an ordinary (expanded) occurrence of the arg.\n \t     So compute its expansion, if we have not already.  */\n@@ -7025,7 +7071,9 @@ macroexpand (hp, op)\n \t    args[ap->argno].free2 = obuf.buf;\n \t  }\n \n-\t  xbuf_len += args[ap->argno].expand_length;\n+\t  /* Add 4 for two newline-space markers to prevent\n+\t     token concatenation.  */\n+\t  xbuf_len += args[ap->argno].expand_length + 4;\n \t}\n \tif (args[ap->argno].use_count < 10)\n \t  args[ap->argno].use_count++;\n@@ -7042,13 +7090,28 @@ macroexpand (hp, op)\n       for (last_ap = NULL, ap = defn->pattern; ap != NULL;\n \t   last_ap = ap, ap = ap->next) {\n \tregister struct argdata *arg = &args[ap->argno];\n+\tint count_before = totlen;\n \n-\t/* add chars to XBUF unless rest_args was zero with concatenation */\n+\t/* Add chars to XBUF.  */\n \tfor (i = 0; i < ap->nchars; i++, offset++)\n-\t  if (! (rest_zero && ((ap->rest_args && ap->raw_before)\n-\t\t\t       || (last_ap != NULL && last_ap->rest_args\n-\t\t\t\t   && last_ap->raw_after))))\n-\t    xbuf[totlen++] = exp[offset];\n+\t  xbuf[totlen++] = exp[offset];\n+\n+\t/* If followed by an empty rest arg with concatenation,\n+\t   delete the last run of nonwhite chars.  */\n+\tif (rest_zero && totlen > count_before\n+\t    && ((ap->rest_args && ap->raw_before)\n+\t\t|| (last_ap != NULL && last_ap->rest_args\n+\t\t    && last_ap->raw_after))) {\n+\t  /* Delete final whitespace.  */\n+\t  while (totlen > count_before && is_space[xbuf[totlen - 1]]) {\n+\t    totlen--;\n+\t  }\n+\n+\t  /* Delete the nonwhites before them.  */\n+\t  while (totlen > count_before && ! is_space[xbuf[totlen - 1]]) {\n+\t    totlen--;\n+\t  }\n+\t}\n \n \tif (ap->stringify != 0) {\n \t  int arglen = arg->raw_length;\n@@ -7128,6 +7191,11 @@ macroexpand (hp, op)\n \t       if the argument is concatenated with what precedes it.  */\n \t    if (p1[0] == '\\n' && p1[1] == '-')\n \t      p1 += 2;\n+\t  } else if (!traditional) {\n+\t  /* Ordinary expanded use of the argument.\n+\t     Put in newline-space markers to prevent token pasting.  */\n+\t    xbuf[totlen++] = '\\n';\n+\t    xbuf[totlen++] = ' ';\n \t  }\n \t  if (ap->raw_after) {\n \t    /* Arg is concatenated after: delete trailing whitespace,\n@@ -7147,11 +7215,28 @@ macroexpand (hp, op)\n \t      else break;\n \t    }\n \t  }\n+\n \t  bcopy (p1, xbuf + totlen, l1 - p1);\n \t  totlen += l1 - p1;\n+\t  if (!traditional && !ap->raw_after) {\n+\t    /* Ordinary expanded use of the argument.\n+\t       Put in newline-space markers to prevent token pasting.  */\n+\t    xbuf[totlen++] = '\\n';\n+\t    xbuf[totlen++] = ' ';\n+\t  }\n \t} else {\n+\t  /* Ordinary expanded use of the argument.\n+\t     Put in newline-space markers to prevent token pasting.  */\n+\t  if (!traditional) {\n+\t    xbuf[totlen++] = '\\n';\n+\t    xbuf[totlen++] = ' ';\n+\t  }\n \t  bcopy (arg->expanded, xbuf + totlen, arg->expand_length);\n \t  totlen += arg->expand_length;\n+\t  if (!traditional) {\n+\t    xbuf[totlen++] = '\\n';\n+\t    xbuf[totlen++] = ' ';\n+\t  }\n \t  /* If a macro argument with newlines is used multiple times,\n \t     then only expand the newlines once.  This avoids creating output\n \t     lines which don't correspond to any input line, which confuses"}]}