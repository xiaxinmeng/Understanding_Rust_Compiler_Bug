{"sha": "907deb1a1e215a24985eb6b5db529feceb782d46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA3ZGViMWExZTIxNWEyNDk4NWViNmI1ZGI1MjlmZWNlYjc4MmQ0Ng==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-04-22T10:42:21Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-04-22T10:42:21Z"}, "message": "ifcvt.c (dead_or_predicable): Use df_simulate_find_defs and df_simulate_find_noclobber_defs as appropriate.\n\n\t* ifcvt.c (dead_or_predicable): Use df_simulate_find_defs and\n\tdf_simulate_find_noclobber_defs as appropriate.  Keep track of an\n\textra set merge_set_noclobber, and use it to relax the final test\n\tslightly.\n\t* df.h (df_simulate_find_noclobber_defs): Declare.\n\t* df-problems.c (df_simulate_find_defs): Don't ignore partial or\n\tconditional defs.\n\t(df_simulate_find_noclobber_defs): New function.\n\nFrom-SVN: r158639", "tree": {"sha": "9189a0396519f211744af9abcdd1e55ace0a2d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9189a0396519f211744af9abcdd1e55ace0a2d12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/907deb1a1e215a24985eb6b5db529feceb782d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907deb1a1e215a24985eb6b5db529feceb782d46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/907deb1a1e215a24985eb6b5db529feceb782d46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907deb1a1e215a24985eb6b5db529feceb782d46/comments", "author": null, "committer": null, "parents": [{"sha": "ed27799786f55ec8aed9f6dcb19852f924cc038e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed27799786f55ec8aed9f6dcb19852f924cc038e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed27799786f55ec8aed9f6dcb19852f924cc038e"}], "stats": {"total": 62, "additions": 44, "deletions": 18}, "files": [{"sha": "bf74e843e2743f459c9e608ad58237bdd6606f5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=907deb1a1e215a24985eb6b5db529feceb782d46", "patch": "@@ -1,3 +1,14 @@\n+2010-04-22  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* ifcvt.c (dead_or_predicable): Use df_simulate_find_defs and\n+\tdf_simulate_find_noclobber_defs as appropriate.  Keep track of an\n+\textra set merge_set_noclobber, and use it to relax the final test\n+\tslightly.\n+\t* df.h (df_simulate_find_noclobber_defs): Declare.\n+\t* df-problems.c (df_simulate_find_defs): Don't ignore partial or\n+\tconditional defs.\n+\t(df_simulate_find_noclobber_defs): New function.\n+\n 2010-04-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md: Use {} around multi-line preparation statements."}, {"sha": "fb899096e4986a802b3f199c809976bb89a4fa90", "filename": "gcc/df-problems.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=907deb1a1e215a24985eb6b5db529feceb782d46", "patch": "@@ -3745,9 +3745,22 @@ df_simulate_find_defs (rtx insn, bitmap defs)\n   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n-      /* If the def is to only part of the reg, it does\n-\t not kill the other defs that reach here.  */\n-      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+      bitmap_set_bit (defs, DF_REF_REGNO (def));\n+    }\n+}\n+\n+/* Find the set of real DEFs, which are not clobbers, for INSN.  */\n+\n+void\n+df_simulate_find_noclobber_defs (rtx insn, bitmap defs)\n+{\n+  df_ref *def_rec;\n+  unsigned int uid = INSN_UID (insn);\n+\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n \tbitmap_set_bit (defs, DF_REF_REGNO (def));\n     }\n }\n@@ -3939,7 +3952,7 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n      while here the scan is performed forwards!  So, first assume that the\n      def is live, and if this is not true REG_UNUSED notes will rectify the\n      situation.  */\n-  df_simulate_find_defs (insn, live);\n+  df_simulate_find_noclobber_defs (insn, live);\n \n   /* Clear all of the registers that go dead.  */\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))"}, {"sha": "c73f00fe6cebb9481173b9b803d0651dbae0f42a", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=907deb1a1e215a24985eb6b5db529feceb782d46", "patch": "@@ -978,6 +978,7 @@ extern void df_note_add_problem (void);\n extern void df_md_add_problem (void);\n extern void df_md_simulate_artificial_defs_at_top (basic_block, bitmap);\n extern void df_md_simulate_one_insn (basic_block, rtx, bitmap);\n+extern void df_simulate_find_noclobber_defs (rtx, bitmap);\n extern void df_simulate_find_defs (rtx, bitmap);\n extern void df_simulate_defs (rtx, bitmap);\n extern void df_simulate_uses (rtx, bitmap);"}, {"sha": "dcf44b8facf83f0b7b0e2391f02d22eb662c141c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907deb1a1e215a24985eb6b5db529feceb782d46/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=907deb1a1e215a24985eb6b5db529feceb782d46", "patch": "@@ -3994,7 +3994,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t that any registers modified are dead at the branch site.  */\n \n       rtx insn, cond, prev;\n-      bitmap merge_set, test_live, test_set;\n+      bitmap merge_set, merge_set_noclobber, test_live, test_set;\n       unsigned i, fail = 0;\n       bitmap_iterator bi;\n \n@@ -4030,11 +4030,14 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n       /* Collect:\n \t   MERGE_SET = set of registers set in MERGE_BB\n+\t   MERGE_SET_NOCLOBBER = like MERGE_SET, but only includes registers\n+\t     that are really set, not just clobbered.\n \t   TEST_LIVE = set of registers live at EARLIEST\n-\t   TEST_SET  = set of registers set between EARLIEST and the\n-\t\t       end of the block.  */\n+\t   TEST_SET = set of registers set between EARLIEST and the\n+\t     end of the block.  */\n \n       merge_set = BITMAP_ALLOC (&reg_obstack);\n+      merge_set_noclobber = BITMAP_ALLOC (&reg_obstack);\n       test_live = BITMAP_ALLOC (&reg_obstack);\n       test_set = BITMAP_ALLOC (&reg_obstack);\n \n@@ -4051,21 +4054,16 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t{\n \t  if (NONDEBUG_INSN_P (insn))\n \t    {\n-\t      unsigned int uid = INSN_UID (insn);\n-\t      df_ref *def_rec;\n-\t      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t\t{\n-\t\t  df_ref def = *def_rec;\n-\t\t  bitmap_set_bit (merge_set, DF_REF_REGNO (def));\n-\t\t}\n+\t      df_simulate_find_defs (insn, merge_set);\n+\t      df_simulate_find_noclobber_defs (insn, merge_set_noclobber);\n \t    }\n \t}\n \n       /* For small register class machines, don't lengthen lifetimes of\n \t hard registers before reload.  */\n       if (SMALL_REGISTER_CLASSES && ! reload_completed)\n \t{\n-          EXECUTE_IF_SET_IN_BITMAP (merge_set, 0, i, bi)\n+          EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)\n \t    {\n \t      if (i < FIRST_PSEUDO_REGISTER\n \t\t  && ! fixed_regs[i]\n@@ -4085,7 +4083,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t{\n \t  if (INSN_P (insn))\n \t    {\n-\t      df_simulate_find_defs (insn, test_set);\n+\t      df_simulate_find_noclobber_defs (insn, test_set);\n \t      df_simulate_one_insn_backwards (test_bb, insn, test_live);\n \t    }\n \t  prev = PREV_INSN (insn);\n@@ -4094,16 +4092,19 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t}\n \n       /* We can perform the transformation if\n-\t   MERGE_SET & (TEST_SET | TEST_LIVE)\n+\t   MERGE_SET_NOCLOBBER & TEST_SET\n+\t and\n+\t   MERGE_SET & TEST_LIVE)\n \t and\n \t   TEST_SET & DF_LIVE_IN (merge_bb)\n \t are empty.  */\n \n-      if (bitmap_intersect_p (test_set, merge_set)\n+      if (bitmap_intersect_p (test_set, merge_set_noclobber)\n \t  || bitmap_intersect_p (test_live, merge_set)\n \t  || bitmap_intersect_p (test_set, df_get_live_in (merge_bb)))\n \tfail = 1;\n \n+      BITMAP_FREE (merge_set_noclobber);\n       BITMAP_FREE (merge_set);\n       BITMAP_FREE (test_live);\n       BITMAP_FREE (test_set);"}]}