{"sha": "91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFjMmNiZGI2ODQ3YzljMWJiZjFjMGNlOWQ3ZTJmOWJkN2UzZTVhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T10:05:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T10:05:44Z"}, "message": "[multiple changes]\n\n2009-04-29  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taskin.adb (Initialize): Remove pragma Warnings Off and remove\n\tunused assignment.\n\n2009-04-29  Thomas Quinot  <quinot@adacore.com>\n\n\t* make.adb: Minor reformatting.\n\tMinor code reorganization throughout.\n\n2009-04-29  Matteo Bordin  <bordin@adacore.com>\n\n\t* s-stausa.ads: Changed visibility of type Task_Result: moved to\n\tpublic part to give application visibility over it.\n\tThis is for future improvement and to build a public API on top of it.\n\tChanged record components name of type Task_Result to reflect the new\n\tway of reporting. \n\n\t* s-stausa.adb: Actual_Size_Str changed to reflect the new way of\n\treporting Stack usage.\n\n\t* gnat_ugn.texi: Update doc of stack usage report.\n\n\t* g-tastus.ads, s-stusta.ads, s-stusta.adb: New files.\n\n\t* Makefile.rtl: Add new run-time files.\n\nFrom-SVN: r146942", "tree": {"sha": "e0500df5e9169f2d414cedff64d374e236571d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0500df5e9169f2d414cedff64d374e236571d13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/comments", "author": null, "committer": null, "parents": [{"sha": "6d47b1e3e982e90a53c20a3f6a7a7ed3cd78132d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d47b1e3e982e90a53c20a3f6a7a7ed3cd78132d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d47b1e3e982e90a53c20a3f6a7a7ed3cd78132d"}], "stats": {"total": 765, "additions": 571, "deletions": 194}, "files": [{"sha": "c9bd62054af8e1f92602eb65cd6106ab9fa4e43d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -1,3 +1,30 @@\n+2009-04-29  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-taskin.adb (Initialize): Remove pragma Warnings Off and remove\n+\tunused assignment.\n+\n+2009-04-29  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* make.adb: Minor reformatting.\n+\tMinor code reorganization throughout.\n+\n+2009-04-29  Matteo Bordin  <bordin@adacore.com>\n+\n+\t* s-stausa.ads: Changed visibility of type Task_Result: moved to\n+\tpublic part to give application visibility over it.\n+\tThis is for future improvement and to build a public API on top of it.\n+\tChanged record components name of type Task_Result to reflect the new\n+\tway of reporting. \n+\n+\t* s-stausa.adb: Actual_Size_Str changed to reflect the new way of\n+\treporting Stack usage.\n+\n+\t* gnat_ugn.texi: Update doc of stack usage report.\n+\n+\t* g-tastus.ads, s-stusta.ads, s-stusta.adb: New files.\n+\n+\t* Makefile.rtl: Add new run-time files.\n+\n 2009-04-29  Pascal Obry  <obry@adacore.com>\n \n \t* initialize.c: Do not expand quoted arguments."}, {"sha": "0b2bec599ef17ac254d1a209e80e9f946997a8ac", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -41,6 +41,7 @@ GNATRTL_TASKING_OBJS= \\\n   g-boumai$(objext) \\\n   g-semaph$(objext) \\\n   g-signal$(objext) \\\n+  g-tastus$(objext) \\\n   g-thread$(objext) \\\n   s-asthan$(objext) \\\n   s-inmaop$(objext) \\\n@@ -50,6 +51,7 @@ GNATRTL_TASKING_OBJS= \\\n   s-osinte$(objext) \\\n   s-proinf$(objext) \\\n   s-solita$(objext) \\\n+  s-stusta$(objext) \\\n   s-taenca$(objext) \\\n   s-taprob$(objext) \\\n   s-taprop$(objext) \\"}, {"sha": "ccfdf456bdfb9c528965d36016368d03d0a8d3a5", "filename": "gcc/ada/g-tastus.ads", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fg-tastus.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fg-tastus.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-tastus.ads?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -0,0 +1,38 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . T A S K _ S T A C K _ U S A G E                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an API to query for tasks stack usage at runtime\n+--  and during debug.\n+\n+--  See file s-stusta.ads for full documentation of the interface\n+\n+with System.Stack_Usage.Tasking;\n+\n+package GNAT.Task_Stack_Usage renames System.Stack_Usage.Tasking;"}, {"sha": "521f8a90e882080d8f5ad824ff3db21fe1c62ad6", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -20270,7 +20270,7 @@ output this info at program termination. Results are displayed in four\n columns:\n \n @noindent\n-Index | Task Name | Stack Size | Actual Use [min - max]\n+Index | Task Name | Stack Size | Stack Usage [Value +/- Variation]\n \n @noindent\n where:\n@@ -20285,11 +20285,11 @@ is the name of the task analyzed.\n @item Stack Size\n is the maximum size for the stack.\n \n-@item Actual Use\n-is the measure done by the stack analyzer. In order to prevent overflow,\n-the stack is not entirely analyzed, and it's not possible to know exactly how\n-much has actually been used. The real amount of stack used is between the min\n-and max values.\n+@item Stack Usage\n+is the measure done by the stack analyzer. In order to prevent overflow, the stack\n+is not entirely analyzed, and it's not possible to know exactly how\n+much has actually been used. The report thus contains the theoretical stack usage\n+(Value) and the possible variation (Variation) around this value.\n \n @end table\n "}, {"sha": "59f0ab145b6c798d97f92144e0a7d237563ddaf6", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 106, "deletions": 137, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -1267,8 +1267,8 @@ package body Make is\n         Unknown_Switches_To_The_Compiler;\n \n       if File_Name'Length > 0 then\n-         Name_Len := File_Name'Length;\n-         Name_Buffer (1 .. Name_Len) := File_Name;\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (File_Name);\n          Switches :=\n            Switches_Of\n              (Source_File      => Name_Find,\n@@ -2458,7 +2458,8 @@ package body Make is\n                                      (1 => new String'\n                                             (Name_Buffer (1 .. Name_Len)));\n                         Dir_Path : constant String :=\n-                          Get_Name_String (Arguments_Project.Directory.Name);\n+                                     Get_Name_String\n+                                       (Arguments_Project.Directory.Name);\n \n                      begin\n                         Test_If_Relative_Path\n@@ -2792,9 +2793,8 @@ package body Make is\n                Add_It : Boolean := True;\n \n             begin\n-               Name_Len := Standard_Library_Package_Body_Name'Length;\n-               Name_Buffer (1 .. Name_Len) :=\n-                 Standard_Library_Package_Body_Name;\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer (Standard_Library_Package_Body_Name);\n                Sfile := Name_Enter;\n \n                --  If we have a special runtime, we add the standard\n@@ -2852,7 +2852,10 @@ package body Make is\n \n          if Arguments_Project /= No_Project then\n             if not Arguments_Project.Externally_Built then\n-               Prj.Env.Set_Ada_Paths (Arguments_Project, Project_Tree, True);\n+               Prj.Env.Set_Ada_Paths\n+                 (Arguments_Project,\n+                  Project_Tree,\n+                  Including_Libraries => True);\n \n                if not Unique_Compile\n                  and then MLib.Tgt.Support_For_Libraries /= Prj.None\n@@ -2866,8 +2869,8 @@ package body Make is\n                        and then not Prj.Externally_Built\n                        and then not Prj.Need_To_Build_Lib\n                      then\n-                        --  Add to the Q all sources of the project that\n-                        --  have not been marked.\n+                        --  Add to the Q all sources of the project that have\n+                        --  not been marked.\n \n                         Insert_Project_Sources\n                           (The_Project  => Prj,\n@@ -2881,8 +2884,7 @@ package body Make is\n                   end;\n                end if;\n \n-               --  Change to the object directory of the project file,\n-               --  if necessary.\n+               --  Change to object directory of the project file, if necessary\n \n                Change_To_Object_Directory (Arguments_Project);\n \n@@ -4403,43 +4405,38 @@ package body Make is\n                                                             No_Project\n                      then\n                         Get_Name_String (Unit.Name);\n-                        Name_Buffer (Name_Len + 1 .. Name_Len + 2) := \"%b\";\n-                        Name_Len := Name_Len + 2;\n+                        Add_Str_To_Name_Buffer (\"%b\");\n                         ALI_Unit := Name_Find;\n                         ALI_Name :=\n                           Lib_File_Name\n                             (Unit.File_Names (Body_Part).Display_Name);\n-                        ALI_Project :=\n-                          Unit.File_Names (Body_Part).Project;\n+                        ALI_Project := Unit.File_Names (Body_Part).Project;\n \n-                        --  Otherwise, if there is a spec, put it\n-                        --  in the mapping.\n+                        --  Otherwise, if there is a spec, put it in the\n+                        --  mapping.\n \n                      elsif Unit.File_Names (Specification).Name /= No_File\n                        and then Unit.File_Names (Specification).Project /=\n                                                                 No_Project\n                      then\n                         Get_Name_String (Unit.Name);\n-                        Name_Buffer (Name_Len + 1 .. Name_Len + 2) := \"%s\";\n-                        Name_Len := Name_Len + 2;\n+                        Add_Str_To_Name_Buffer (\"%s\");\n                         ALI_Unit := Name_Find;\n                         ALI_Name :=\n                           Lib_File_Name\n                             (Unit.File_Names (Specification).Display_Name);\n-                        ALI_Project :=\n-                          Unit.File_Names (Specification).Project;\n+                        ALI_Project := Unit.File_Names (Specification).Project;\n \n                      else\n                         ALI_Name := No_File;\n                      end if;\n \n-                     --  If we have something to put in the mapping\n-                     --  then we do it now. However, if the project\n-                     --  is extended, we don't put anything in the\n-                     --  mapping file, because we do not know where\n-                     --  the ALI file is: it might be in the ext-\n-                     --  ended project obj dir as well as in the\n-                     --  extending project obj dir.\n+                     --  If we have something to put in the mapping then do it\n+                     --  now. However, if the project is extended, we don't put\n+                     --  anything in the mapping file, because we do not know\n+                     --  where the ALI file is: it might be in the extended\n+                     --  project obj dir as well as in the extending project\n+                     --  obj dir.\n \n                      if ALI_Name /= No_File\n                        and then ALI_Project.Extended_By = No_Project\n@@ -4449,8 +4446,7 @@ package body Make is\n                         --  do not put the unit in the mapping file.\n \n                         declare\n-                           ALI : constant String :=\n-                                   Get_Name_String (ALI_Name);\n+                           ALI : constant String := Get_Name_String (ALI_Name);\n \n                         begin\n                            --  For library projects, use the library directory,\n@@ -4464,19 +4460,13 @@ package body Make is\n                            end if;\n \n                            if Name_Buffer (Name_Len) /=\n-                             Directory_Separator\n+                                Directory_Separator\n                            then\n-                              Name_Len := Name_Len + 1;\n-                              Name_Buffer (Name_Len) :=\n-                                Directory_Separator;\n+                              Add_Char_To_Name_Buffer (Directory_Separator);\n                            end if;\n \n-                           Name_Buffer\n-                             (Name_Len + 1 ..\n-                                Name_Len + ALI'Length) := ALI;\n-                           Name_Len :=\n-                             Name_Len + ALI'Length + 1;\n-                           Name_Buffer (Name_Len) := ASCII.LF;\n+                           Add_Str_To_Name_Buffer (ALI);\n+                           Add_Char_To_Name_Buffer (ASCII.LF);\n \n                            declare\n                               ALI_Path_Name : constant String :=\n@@ -4490,8 +4480,7 @@ package body Make is\n                                  --  First line is the unit name\n \n                                  Get_Name_String (ALI_Unit);\n-                                 Name_Len := Name_Len + 1;\n-                                 Name_Buffer (Name_Len) := ASCII.LF;\n+                                 Add_Char_To_Name_Buffer (ASCII.LF);\n                                  Bytes :=\n                                    Write\n                                      (Mapping_FD,\n@@ -4504,8 +4493,7 @@ package body Make is\n                                  --  Second line it the ALI file name\n \n                                  Get_Name_String (ALI_Name);\n-                                 Name_Len := Name_Len + 1;\n-                                 Name_Buffer (Name_Len) := ASCII.LF;\n+                                 Add_Char_To_Name_Buffer (ASCII.LF);\n                                  Bytes :=\n                                    Write\n                                      (Mapping_FD,\n@@ -4745,8 +4733,7 @@ package body Make is\n \n                      while Value /= Prj.Nil_String loop\n                         Get_Name_String\n-                          (Project_Tree.String_Elements.Table\n-                             (Value).Value);\n+                          (Project_Tree.String_Elements.Table (Value).Value);\n \n                         --  To know if a main is an Ada main, get its project.\n                         --  It should be the project specified on the command\n@@ -5335,14 +5322,10 @@ package body Make is\n                      Get_Name_String (Main_Project.Exec_Directory.Name);\n \n                      if Name_Buffer (Name_Len) /= Directory_Separator then\n-                        Name_Len := Name_Len + 1;\n-                        Name_Buffer (Name_Len) := Directory_Separator;\n+                        Add_Char_To_Name_Buffer (Directory_Separator);\n                      end if;\n \n-                     Name_Buffer (Name_Len + 1 ..\n-                                    Name_Len + Exec_File_Name'Length) :=\n-                       Exec_File_Name;\n-                     Name_Len := Name_Len + Exec_File_Name'Length;\n+                     Add_Str_To_Name_Buffer (Exec_File_Name);\n                      Saved_Linker_Switches.Table (J + 1) :=\n                        new String'(Name_Buffer (1 .. Name_Len));\n                   end if;\n@@ -5387,14 +5370,14 @@ package body Make is\n             for J in 1 .. Gcc_Switches.Last loop\n                Test_If_Relative_Path\n                  (Gcc_Switches.Table (J),\n-                  Parent => Dir_Path,\n+                  Parent               => Dir_Path,\n                   Including_Non_Switch => False);\n             end loop;\n \n             for J in 1 .. Saved_Gcc_Switches.Last loop\n                Test_If_Relative_Path\n                  (Saved_Gcc_Switches.Table (J),\n-                  Parent => Current_Work_Dir.all,\n+                  Parent               => Current_Work_Dir.all,\n                   Including_Non_Switch => False);\n             end loop;\n          end;\n@@ -5425,9 +5408,7 @@ package body Make is\n       if Main_Project = No_Project then\n          for J in 1 .. Saved_Gcc_Switches.Last loop\n             Add_Switch\n-              (Saved_Gcc_Switches.Table (J),\n-               Compiler,\n-              And_Save => False);\n+              (Saved_Gcc_Switches.Table (J), Compiler, And_Save => False);\n          end loop;\n \n       else\n@@ -5444,8 +5425,7 @@ package body Make is\n \n          --  We never use gnat.adc when a project file is used\n \n-         The_Saved_Gcc_Switches (The_Saved_Gcc_Switches'Last) :=\n-           No_gnat_adc;\n+         The_Saved_Gcc_Switches (The_Saved_Gcc_Switches'Last) := No_gnat_adc;\n       end if;\n \n       --  If there was a --GCC, --GNATBIND or --GNATLINK switch on\n@@ -5476,8 +5456,8 @@ package body Make is\n          Saved_Maximum_Processes := Maximum_Processes;\n       end if;\n \n-      --  Allocate as many temporary mapping file names as the maximum\n-      --  number of compilation processed, for each possible project.\n+      --  Allocate as many temporary mapping file names as the maximum number\n+      --  of compilations processed, for each possible project.\n \n       declare\n          Data : Project_Compilation_Access;\n@@ -5486,23 +5466,25 @@ package body Make is\n          while Proj /= null loop\n             Data := new Project_Compilation_Data'\n               (Mapping_File_Names        => new Temp_Path_Names\n-                 (1 .. Saved_Maximum_Processes),\n+                                              (1 .. Saved_Maximum_Processes),\n                Last_Mapping_File_Names   => 0,\n                Free_Mapping_File_Indices => new Free_File_Indices\n-                 (1 .. Saved_Maximum_Processes),\n+                                              (1 .. Saved_Maximum_Processes),\n                Last_Free_Indices         => 0);\n+\n             Project_Compilation_Htable.Set\n               (Project_Compilation, Proj.Project, Data);\n             Proj := Proj.Next;\n          end loop;\n \n          Data := new Project_Compilation_Data'\n            (Mapping_File_Names        => new Temp_Path_Names\n-              (1 .. Saved_Maximum_Processes),\n+                                           (1 .. Saved_Maximum_Processes),\n             Last_Mapping_File_Names   => 0,\n             Free_Mapping_File_Indices => new Free_File_Indices\n-              (1 .. Saved_Maximum_Processes),\n+                                           (1 .. Saved_Maximum_Processes),\n             Last_Free_Indices         => 0);\n+\n          Project_Compilation_Htable.Set\n            (Project_Compilation, No_Project, Data);\n       end;\n@@ -5536,37 +5518,32 @@ package body Make is\n          --  Look inside the linker switches to see if the name of the final\n          --  executable program was specified.\n \n-         for\n-           J in reverse Linker_Switches.First .. Linker_Switches.Last\n-         loop\n+         for J in reverse Linker_Switches.First .. Linker_Switches.Last loop\n             if Linker_Switches.Table (J).all = Output_Flag.all then\n                pragma Assert (J < Linker_Switches.Last);\n \n-               --  We cannot specify a single executable for several\n-               --  main subprograms!\n+               --  We cannot specify a single executable for several main\n+               --  subprograms\n \n                if Osint.Number_Of_Files > 1 then\n                   Fail\n-                    (\"cannot specify a single executable \" &\n-                     \"for several mains\");\n+                    (\"cannot specify a single executable for several mains\");\n                end if;\n \n-               Name_Len := Linker_Switches.Table (J + 1)'Length;\n-               Name_Buffer (1 .. Name_Len) :=\n-                 Linker_Switches.Table (J + 1).all;\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer (Linker_Switches.Table (J + 1).all);\n                Executable := Name_Enter;\n \n                Verbose_Msg (Executable, \"final executable\");\n             end if;\n          end loop;\n \n-         --  If the name of the final executable program was not specified\n-         --  then construct it from the main input file.\n+         --  If the name of the final executable program was not specified then\n+         --  construct it from the main input file.\n \n          if Executable = No_File then\n             if Main_Project = No_Project then\n-               Executable :=\n-                 Executable_Name (Strip_Suffix (Main_Source_File));\n+               Executable := Executable_Name (Strip_Suffix (Main_Source_File));\n \n             else\n                --  If we are using a project file, we attempt to remove the\n@@ -5593,15 +5570,10 @@ package body Make is\n                   Get_Name_String (Main_Project.Exec_Directory.Display_Name);\n \n                   if Name_Buffer (Name_Len) /= Directory_Separator then\n-                     Name_Len := Name_Len + 1;\n-                     Name_Buffer (Name_Len) := Directory_Separator;\n+                     Add_Char_To_Name_Buffer (Directory_Separator);\n                   end if;\n \n-                  Name_Buffer (Name_Len + 1 ..\n-                                       Name_Len + Exec_File_Name'Length) :=\n-                    Exec_File_Name;\n-\n-                  Name_Len := Name_Len + Exec_File_Name'Length;\n+                  Add_Str_To_Name_Buffer (Exec_File_Name);\n                   Executable := Name_Find;\n                end if;\n \n@@ -5619,6 +5591,7 @@ package body Make is\n \n                Executable_Stamp : Time_Stamp_Type;\n                --  Executable is the final executable program\n+               --  ??? comment seems unrelated to declaration\n \n                Library_Rebuilt : Boolean := False;\n \n@@ -5661,6 +5634,7 @@ package body Make is\n                if Total_Compilation_Failures /= 0 then\n                   if Keep_Going then\n                      goto Next_Main;\n+\n                   else\n                      List_Bad_Compilations;\n                      Report_Compilation_Failed;\n@@ -5717,8 +5691,8 @@ package body Make is\n                   --  or probably better, break this out as a nested proc).\n \n                   begin\n-                     --  Put in Library_Projs table all library project\n-                     --  file ids when the library need to be rebuilt.\n+                     --  Put in Library_Projs table all library project file\n+                     --  ids when the library need to be rebuilt.\n \n                      Proj1 := Project_Tree.Projects;\n                      while Proj1 /= null loop\n@@ -5867,8 +5841,8 @@ package body Make is\n \n                --  If the objects were up-to-date check if the executable file\n                --  is also up-to-date. For now always bind and link on the JVM\n-               --  since there is currently no simple way to check the\n-               --  up-to-date status of objects\n+               --  since there is currently no simple way to check whether\n+               --  objects are up-to-date.\n \n                if Targparm.VM_Target /= JVM_Target\n                  and then First_Compiled_File = No_File\n@@ -5907,8 +5881,8 @@ package body Make is\n                      Executable_Obsolete := Youngest_Obj_File /= No_File;\n                   end if;\n \n-                  --  Return if the executable is up to date\n-                  --  and otherwise motivate the relink/rebind.\n+                  --  Return if the executable is up to date and otherwise\n+                  --  motivate the relink/rebind.\n \n                   if not Executable_Obsolete then\n                      if not Quiet_Output then\n@@ -5955,9 +5929,9 @@ package body Make is\n             Change_To_Object_Directory (Main_Project);\n          end if;\n \n-         --  If we are here, it means that we need to rebuilt the current\n-         --  main. So we set Executable_Obsolete to True to make sure that\n-         --  the subsequent mains will be rebuilt.\n+         --  If we are here, it means that we need to rebuilt the current main,\n+         --  so we set Executable_Obsolete to True to make sure that subsequent\n+         --  mains will be rebuilt.\n \n          Main_ALI_In_Place_Mode_Step : declare\n             ALI_File : File_Name_Type;\n@@ -7401,45 +7375,42 @@ package body Make is\n       N : Name_Id;\n       B : Byte;\n \n-   begin\n-      if On_Command_Line then\n-         declare\n-            Real_Path : constant String := Normalize_Pathname (Dir);\n+      function Base_Directory return String;\n+      --  If Dir comes from the command line, empty string (relative paths\n+      --  are resolved with respect to the current directory), else return\n+      --  the main project's directory.\n \n-         begin\n-            if Real_Path'Length = 0 then\n-               Name_Len := Dir'Length;\n-               Name_Buffer (1 .. Name_Len) := Dir;\n+      --------------------\n+      -- Base_Directory --\n+      --------------------\n \n-            else\n-               Name_Len := Real_Path'Length;\n-               Name_Buffer (1 .. Name_Len) := Real_Path;\n-            end if;\n-         end;\n+      function Base_Directory return String is\n+      begin\n+         if On_Command_Line then\n+            return \"\";\n+         else\n+            return Get_Name_String (Main_Project.Directory.Display_Name);\n+         end if;\n+      end Base_Directory;\n \n-      else\n-         declare\n-            Real_Path : constant String :=\n-              Normalize_Pathname\n-                (Dir, Get_Name_String (Main_Project.Directory.Display_Name));\n+      Real_Path : constant String := Normalize_Pathname (Dir, Base_Directory);\n \n-         begin\n-            if Real_Path'Length = 0 then\n-               Name_Len := Dir'Length;\n-               Name_Buffer (1 .. Name_Len) := Dir;\n+   --  Start of processing for Mark_Directory\n \n-            else\n-               Name_Len := Real_Path'Length;\n-               Name_Buffer (1 .. Name_Len) := Real_Path;\n-            end if;\n-         end;\n+   begin\n+      Name_Len := 0;\n+\n+      if Real_Path'Length = 0 then\n+         Add_Str_To_Name_Buffer (Dir);\n+\n+      else\n+         Add_Str_To_Name_Buffer (Real_Path);\n       end if;\n \n       --  Last character is supposed to be a directory separator\n \n       if not Is_Directory_Separator (Name_Buffer (Name_Len)) then\n-         Name_Len := Name_Len + 1;\n-         Name_Buffer (Name_Len) := Directory_Separator;\n+         Add_Char_To_Name_Buffer (Directory_Separator);\n       end if;\n \n       --  Add flags to the already existing flags\n@@ -7468,15 +7439,13 @@ package body Make is\n          Proj : Project_Id;\n \n       begin\n-         if Prj.Depth >= Depth\n-           or else Get (Seen, Prj)\n-         then\n+         if Prj.Depth >= Depth or else Get (Seen, Prj) then\n             return;\n          end if;\n \n          --  We need a test to avoid infinite recursions with limited withs:\n          --  If we have A -> B -> A, then when set level of A to n, we try and\n-         --  set level of B to n+1, and then level of A to n + 2,...\n+         --  set level of B to n+1, and then level of A to n + 2, ...\n \n          Set (Seen, Prj, True);\n \n@@ -7497,9 +7466,10 @@ package body Make is\n          Set (Seen, Prj, False);\n       end Recurse;\n \n+      Proj : Project_List;\n+\n    --  Start of processing for Recursive_Compute_Depth\n \n-      Proj : Project_List;\n    begin\n       Proj := Project_Tree.Projects;\n       while Proj /= null loop\n@@ -8188,27 +8158,26 @@ package body Make is\n             end if;\n \n             if Truncated then\n-               Name_Len := Last;\n-               Name_Buffer (1 .. Name_Len) := Name (1 .. Last);\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer (Name (1 .. Last));\n                Switches :=\n                  Prj.Util.Value_Of\n                    (Index     => Name_Find,\n                     Src_Index => 0,\n                     In_Array  => Switches_Array,\n                     In_Tree   => Project_Tree);\n \n-               if Switches = Nil_Variable_Value\n-                 and then Allow_ALI\n-               then\n+               if Switches = Nil_Variable_Value and then Allow_ALI then\n                   Last := Source_File_Name'Length;\n \n                   while Name (Last) /= '.' loop\n                      Last := Last - 1;\n                   end loop;\n \n-                  Name (Last + 1 .. Last + 3) := \"ali\";\n-                  Name_Len := Last + 3;\n-                  Name_Buffer (1 .. Name_Len) := Name (1 .. Name_Len);\n+                  Name_Len := 0;\n+                  Add_Str_To_Name_Buffer (Name (1 .. Last));\n+                  Add_Str_To_Name_Buffer (\"ali\");\n+\n                   Switches :=\n                     Prj.Util.Value_Of\n                       (Index     => Name_Find,"}, {"sha": "bf14beb468a2f7ce318e71eef73c4faee63e5e77", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -173,7 +173,7 @@ package body System.Stack_Usage is\n    Index_Str       : constant String  := \"Index\";\n    Task_Name_Str   : constant String  := \"Task Name\";\n    Stack_Size_Str  : constant String  := \"Stack Size\";\n-   Actual_Size_Str : constant String  := \"Stack usage [min - max]\";\n+   Actual_Size_Str : constant String  := \"Stack usage [Value +/- Variation]\";\n \n    function Get_Usage_Range (Result : Task_Result) return String;\n    --  Return string representing the range of possible result of stack usage\n@@ -204,8 +204,8 @@ package body System.Stack_Usage is\n       Result_Array.all :=\n         (others =>\n            (Task_Name   => (others => ASCII.NUL),\n-            Min_Measure => 0,\n-            Max_Measure => 0,\n+            Variation => 0,\n+            Value => 0,\n             Max_Size    => 0));\n \n       --  Set the Is_Enabled flag to true, so that the task wrapper knows that\n@@ -222,16 +222,16 @@ package body System.Stack_Usage is\n \n       if Stack_Size_Chars /= Null_Address then\n          declare\n-            Stack_Size : Integer;\n+            My_Stack_Size : Integer;\n \n          begin\n-            Stack_Size := System.CRTL.atoi (Stack_Size_Chars) * 1024;\n+            My_Stack_Size := System.CRTL.atoi (Stack_Size_Chars) * 1024;\n \n             Initialize_Analyzer\n               (Environment_Task_Analyzer,\n                \"ENVIRONMENT TASK\",\n-               Stack_Size,\n-               Stack_Size,\n+               My_Stack_Size,\n+               My_Stack_Size,\n                System.Storage_Elements.To_Integer (Bottom_Of_Stack'Address));\n \n             Fill_Stack (Environment_Task_Analyzer);\n@@ -318,7 +318,7 @@ package body System.Stack_Usage is\n    procedure Initialize_Analyzer\n      (Analyzer         : in out Stack_Analyzer;\n       Task_Name        : String;\n-      Stack_Size       : Natural;\n+      My_Stack_Size    : Natural;\n       Max_Pattern_Size : Natural;\n       Bottom           : Stack_Address;\n       Pattern          : Unsigned_32 := 16#DEAD_BEEF#)\n@@ -327,7 +327,7 @@ package body System.Stack_Usage is\n       --  Initialize the analyzer fields\n \n       Analyzer.Bottom_Of_Stack := Bottom;\n-      Analyzer.Stack_Size := Stack_Size;\n+      Analyzer.Stack_Size := My_Stack_Size;\n       Analyzer.Pattern_Size := Max_Pattern_Size;\n       Analyzer.Pattern := Pattern;\n       Analyzer.Result_Id := Next_Id;\n@@ -414,11 +414,11 @@ package body System.Stack_Usage is\n    ---------------------\n \n    function Get_Usage_Range (Result : Task_Result) return String is\n-      Min_Used_Str : constant String := Natural'Image (Result.Min_Measure);\n-      Max_Used_Str : constant String := Natural'Image (Result.Max_Measure);\n+      Variation_Used_Str : constant String :=\n+        Natural'Image (Result.Variation);\n+      Value_Used_Str : constant String := Natural'Image (Result.Value);\n    begin\n-      return \"[\" & Min_Used_Str (2 .. Min_Used_Str'Last) & \" -\"\n-             & Max_Used_Str & \"]\";\n+      return \"[\" & Value_Used_Str & \" +/- \" & Variation_Used_Str & \"]\";\n    end Get_Usage_Range;\n \n    ---------------------\n@@ -431,16 +431,16 @@ package body System.Stack_Usage is\n       Max_Stack_Size_Len : Natural;\n       Max_Actual_Use_Len : Natural)\n    is\n-      Result_Id_Str  : constant String := Natural'Image (Result_Id);\n-      Stack_Size_Str : constant String := Natural'Image (Result.Max_Size);\n-      Actual_Use_Str : constant String := Get_Usage_Range (Result);\n+      Result_Id_Str     : constant String := Natural'Image (Result_Id);\n+      My_Stack_Size_Str : constant String := Natural'Image (Result.Max_Size);\n+      Actual_Use_Str    : constant String := Get_Usage_Range (Result);\n \n       Result_Id_Blanks  : constant\n         String (1 .. Index_Str'Length - Result_Id_Str'Length)    :=\n           (others => ' ');\n \n       Stack_Size_Blanks : constant\n-        String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n+        String (1 .. Max_Stack_Size_Len - My_Stack_Size_Str'Length) :=\n           (others => ' ');\n \n       Actual_Use_Blanks : constant\n@@ -453,7 +453,7 @@ package body System.Stack_Usage is\n       Put (\" | \");\n       Put (Result.Task_Name);\n       Put (\" | \");\n-      Put (Stack_Size_Blanks & Stack_Size_Str);\n+      Put (Stack_Size_Blanks & My_Stack_Size_Str);\n       Put (\" | \");\n       Put (Actual_Use_Blanks & Actual_Use_Str);\n       New_Line;\n@@ -488,8 +488,8 @@ package body System.Stack_Usage is\n          for J in Result_Array'Range loop\n             exit when J >= Next_Id;\n \n-            if Result_Array (J).Max_Measure\n-              > Result_Array (Max_Actual_Use_Result_Id).Max_Measure\n+            if Result_Array (J).Value\n+              > Result_Array (Max_Actual_Use_Result_Id).Value\n             then\n                Max_Actual_Use_Result_Id := J;\n             end if;\n@@ -559,28 +559,31 @@ package body System.Stack_Usage is\n       Result  : Task_Result :=\n                   (Task_Name      => Analyzer.Task_Name,\n                    Max_Size       => Analyzer.Stack_Size,\n-                   Min_Measure    => 0,\n-                   Max_Measure    => 0);\n+                   Variation    => 0,\n+                   Value    => 0);\n \n       Overflow_Guard : constant Integer :=\n         Analyzer.Stack_Size\n           - Stack_Size (Analyzer.Top_Pattern_Mark, Analyzer.Bottom_Of_Stack);\n+      Max, Min : Positive;\n \n    begin\n       if Analyzer.Pattern_Size = 0 then\n          --  If we have that result, it means that we didn't do any computation\n          --  at all. In other words, we used at least everything (and possibly\n          --  more).\n \n-         Result.Min_Measure := Analyzer.Stack_Size - Overflow_Guard;\n-         Result.Max_Measure := Analyzer.Stack_Size;\n+         Min := Analyzer.Stack_Size - Overflow_Guard;\n+         Max := Analyzer.Stack_Size;\n       else\n-         Result.Min_Measure := Stack_Size\n-                    (Analyzer.Topmost_Touched_Mark,\n-                     Analyzer.Bottom_Of_Stack);\n-         Result.Max_Measure := Result.Min_Measure + Overflow_Guard;\n+         Min := Stack_Size\n+           (Analyzer.Topmost_Touched_Mark, Analyzer.Bottom_Of_Stack);\n+         Max := Min + Overflow_Guard;\n       end if;\n \n+      Result.Value := (Max + Min) / 2;\n+      Result.Variation := (Max - Min) / 2;\n+\n       if Analyzer.Result_Id in Result_Array'Range then\n \n          --  If the result can be stored, then store it in Result_Array"}, {"sha": "f42e37452f7c8880b14d2272dc8fbd5e2fc6dc06", "filename": "gcc/ada/s-stausa.ads", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -46,6 +46,27 @@ package System.Stack_Usage is\n      (Value : System.Address) return Stack_Address\n       renames System.Storage_Elements.To_Integer;\n \n+   Task_Name_Length : constant := 32;\n+   --  The maximum length of task name displayed.\n+   --  ??? Consider merging this variable with Max_Task_Image_Length.\n+\n+   type Task_Result is record\n+      Task_Name : String (1 .. Task_Name_Length);\n+\n+      Value : Natural;\n+      --  Amount of the stack used; the value is calculated on the basis of\n+      --  the mechanism used by GNAT to allocate it, and it is NOT a precise\n+      --  value.\n+\n+      Variation : Natural;\n+      --  Possible variation in the amount of used stack. The real stack usage\n+      --  may vary in the range Value +/- Variation\n+\n+      Max_Size : Natural;\n+   end record;\n+\n+   type Result_Array_Type is array (Positive range <>) of Task_Result;\n+\n    type Stack_Analyzer is private;\n    --  Type of the stack analyzer tool. It is used to fill a portion of the\n    --  stack with Pattern, and to compute the stack used after some execution.\n@@ -206,7 +227,7 @@ package System.Stack_Usage is\n    procedure Initialize_Analyzer\n      (Analyzer         : in out Stack_Analyzer;\n       Task_Name        : String;\n-      Stack_Size       : Natural;\n+      My_Stack_Size    : Natural;\n       Max_Pattern_Size : Natural;\n       Bottom           : Stack_Address;\n       Pattern          : Interfaces.Unsigned_32 := 16#DEAD_BEEF#);\n@@ -256,10 +277,6 @@ package System.Stack_Usage is\n \n private\n \n-   Task_Name_Length : constant := 32;\n-   --  The maximum length of task name displayed.\n-   --  ??? Consider merging this variable with Max_Task_Image_Length.\n-\n    package Unsigned_32_Addr is\n      new System.Address_To_Access_Conversions (Interfaces.Unsigned_32);\n \n@@ -308,20 +325,6 @@ private\n \n    Compute_Environment_Task  : Boolean;\n \n-   type Task_Result is record\n-      Task_Name : String (1 .. Task_Name_Length);\n-\n-      Min_Measure : Natural;\n-      --  Minimum value for the measure\n-\n-      Max_Measure : Natural;\n-      --  Maximum value for the measure, taking into account the actual size\n-      --  of the pattern filled.\n-\n-      Max_Size : Natural;\n-   end record;\n-\n-   type Result_Array_Type is array (Positive range <>) of Task_Result;\n    type Result_Array_Ptr is access all Result_Array_Type;\n \n    Result_Array : Result_Array_Ptr;"}, {"sha": "b3fa891fa7d58b29b6e9012688dbdc1bf9d28c2f", "filename": "gcc/ada/s-stusta.adb", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stusta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stusta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stusta.adb?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -0,0 +1,261 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--             S Y S T E M . S T A C K _ U S A G E . T AS K I N G           --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Stack_Usage;\n+\n+--  This is why this package is part of GNARL:\n+\n+with System.Tasking.Debug;\n+with System.Task_Primitives.Operations;\n+\n+with System.IO;\n+\n+package body System.Stack_Usage.Tasking is\n+   use System.IO;\n+\n+   procedure Report_For_Task (Id : System.Tasking.Task_Id);\n+   --  A generic procedure calculating stack usage for a given task\n+\n+   procedure Compute_All_Tasks;\n+   --  Compute the stack usage for all tasks and saves it in\n+   --  System.Stack_Usage.Result_Array\n+\n+   procedure Compute_Current_Task;\n+   --  Compute the stack usage for a given task and saves it in the a precise\n+   --  slot in System.Stack_Usage.Result_Array;\n+\n+   procedure Report_Impl (All_Tasks : Boolean; Do_Print : Boolean);\n+   --  Report the stack usage of either all tasks (All_Tasks = True) or of the\n+   --  current task (All_Task = False). If Print is True, then results are\n+   --  printed on stderr\n+\n+   procedure Convert\n+     (TS  : System.Stack_Usage.Task_Result;\n+      Res : out Stack_Usage_Result);\n+   --  Convert an object of type System.Stack_Usage in a Stack_Usage_Result\n+\n+   --------------\n+   --  Convert --\n+   --------------\n+\n+   procedure Convert\n+     (TS  : System.Stack_Usage.Task_Result;\n+      Res : out Stack_Usage_Result) is\n+   begin\n+      Res := TS;\n+   end Convert;\n+\n+   ----------------------\n+   --  Report_For_Task --\n+   ----------------------\n+\n+   procedure Report_For_Task (Id : System.Tasking.Task_Id) is\n+   begin\n+      System.Stack_Usage.Compute_Result (Id.Common.Analyzer);\n+      System.Stack_Usage.Report_Result (Id.Common.Analyzer);\n+   end Report_For_Task;\n+\n+   ------------------------\n+   --  Compute_All_Tasks --\n+   ------------------------\n+\n+   procedure Compute_All_Tasks is\n+      Id : System.Tasking.Task_Id;\n+      use type System.Tasking.Task_Id;\n+   begin\n+      if not System.Stack_Usage.Is_Enabled then\n+         Put (\"Stack Usage not enabled: bind with -uNNN switch\");\n+      else\n+\n+         --  Loop over all tasks\n+\n+         for J in System.Tasking.Debug.Known_Tasks'First + 1\n+           .. System.Tasking.Debug.Known_Tasks'Last\n+         loop\n+            Id := System.Tasking.Debug.Known_Tasks (J);\n+            exit when Id = null;\n+\n+            --  Calculate the task usage for a given task\n+\n+            Report_For_Task (Id);\n+         end loop;\n+\n+      end if;\n+   end Compute_All_Tasks;\n+\n+   ---------------------------\n+   --  Compute_Current_Task --\n+   ---------------------------\n+\n+   procedure Compute_Current_Task is\n+   begin\n+      if not System.Stack_Usage.Is_Enabled then\n+         Put (\"Stack Usage not enabled: bind with -uNNN switch\");\n+      else\n+\n+         --  The current task\n+\n+         Report_For_Task (System.Tasking.Self);\n+\n+      end if;\n+   end Compute_Current_Task;\n+\n+   ------------------\n+   --  Report_Impl --\n+   ------------------\n+\n+   procedure Report_Impl (All_Tasks : Boolean; Do_Print : Boolean) is\n+   begin\n+\n+      --  Lock the runtime\n+\n+      System.Task_Primitives.Operations.Lock_RTS;\n+\n+      --  Calculate results\n+\n+      if All_Tasks then\n+         Compute_All_Tasks;\n+      else\n+         Compute_Current_Task;\n+      end if;\n+\n+      --  Output results\n+      if Do_Print then\n+         System.Stack_Usage.Output_Results;\n+      end if;\n+\n+      --  Unlock the runtime\n+\n+      System.Task_Primitives.Operations.Unlock_RTS;\n+\n+   end Report_Impl;\n+\n+   ----------------------\n+   --  Report_All_Task --\n+   ----------------------\n+\n+   procedure Report_All_Tasks is\n+   begin\n+      Report_Impl (True, True);\n+   end Report_All_Tasks;\n+\n+   --------------------------\n+   --  Report_Current_Task --\n+   --------------------------\n+\n+   procedure Report_Current_Task is\n+      Res : Stack_Usage_Result;\n+   begin\n+      Res := Get_Current_Task_Usage;\n+      Print (Res);\n+   end Report_Current_Task;\n+\n+   --------------------------\n+   --  Get_All_Tasks_Usage --\n+   --------------------------\n+\n+   function Get_All_Tasks_Usage return Stack_Usage_Result_Array is\n+      Res : Stack_Usage_Result_Array\n+        (1 .. System.Stack_Usage.Result_Array'Length);\n+   begin\n+      Report_Impl (True, False);\n+\n+      for J in Res'Range loop\n+         Convert (System.Stack_Usage.Result_Array (J), Res (J));\n+      end loop;\n+\n+      return Res;\n+   end Get_All_Tasks_Usage;\n+\n+   -----------------------------\n+   --  Get_Current_Task_Usage --\n+   -----------------------------\n+\n+   function Get_Current_Task_Usage return Stack_Usage_Result is\n+      Res : Stack_Usage_Result;\n+      Original : System.Stack_Usage.Task_Result;\n+      Found : Boolean := False;\n+   begin\n+\n+      Report_Impl (False, False);\n+\n+      --  Look for the task info in System.Stack_Usage.Result_Array;\n+      --  the search is based on task name\n+\n+      for T in System.Stack_Usage.Result_Array'Range loop\n+         if System.Stack_Usage.Result_Array (T).Task_Name =\n+           System.Tasking.Self.Common.Analyzer.Task_Name\n+         then\n+            Original := System.Stack_Usage.Result_Array (T);\n+            Found := True;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Be sure a task has been found\n+\n+      pragma Assert (Found);\n+\n+      Convert (Original, Res);\n+      return Res;\n+   end Get_Current_Task_Usage;\n+\n+   ------------\n+   --  Print --\n+   ------------\n+\n+   procedure Print (Obj : Stack_Usage_Result) is\n+      Pos : Positive;\n+   begin\n+\n+      --  Simply trim the string containing the task name\n+\n+      for S in Obj.Task_Name'Range loop\n+         if Obj.Task_Name (S) = ' ' then\n+            Pos := S;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      declare\n+         T_Name : constant String := Obj.Task_Name\n+           (Obj.Task_Name'First .. Pos);\n+      begin\n+         Put_Line\n+           (\"| \" & T_Name & \" | \" & Natural'Image (Obj.Max_Size) & \" [\" &\n+            Natural'Image (Obj.Value) & \" +/- \" &\n+            Natural'Image (Obj.Variation) & \"]\");\n+      end;\n+   end Print;\n+\n+end System.Stack_Usage.Tasking;"}, {"sha": "cc121d5fcf667cb7a25f43d270e291b34bffd758", "filename": "gcc/ada/s-stusta.ads", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stusta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-stusta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stusta.ads?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -0,0 +1,77 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--             S Y S T E M . S T A C K _ U S A G E . T AS K I N G           --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides exported subprograms to be called at debug time to\n+--  measure stack usage at run-time.\n+\n+--  Note: this package must be a child package of System.Stack_Usage to have\n+--  visibility over its private part; it is however part of GNARL because it\n+--  needs to access tasking features via System.Tasking.Debug and\n+--  System.Task_Primitives.Operations;\n+\n+package System.Stack_Usage.Tasking is\n+\n+   procedure Report_All_Tasks;\n+   --  Print the current stack usage of all tasks on stderr. Exported to be\n+   --  called also in debug mode.\n+\n+   pragma Export\n+     (C,\n+      Report_All_Tasks,\n+      \"__gnat_tasks_stack_usage_report_all_tasks\");\n+\n+   procedure Report_Current_Task;\n+   --  Print the stack usage of current task on stderr. Exported to be called\n+   --  also in debug mode.\n+\n+   pragma Export\n+     (C,\n+      Report_Current_Task,\n+      \"__gnat_tasks_stack_usage_report_current_task\");\n+\n+   subtype Stack_Usage_Result is System.Stack_Usage.Task_Result;\n+   --  This type is a descriptor for task stack usage result.\n+\n+   type Stack_Usage_Result_Array is\n+     array (Positive range <>) of Stack_Usage_Result;\n+\n+   function Get_Current_Task_Usage return Stack_Usage_Result;\n+   --  Return the current stack usage for the invoking task\n+\n+   function Get_All_Tasks_Usage return Stack_Usage_Result_Array;\n+   --  Return an array containing the stack usage results for all tasks\n+\n+   procedure Print (Obj : Stack_Usage_Result);\n+   --  Print Obj on stderr\n+\n+end System.Stack_Usage.Tasking;"}, {"sha": "35fcbdf92a10a73629521809d96fbd79cec32510", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=91c2cbdb6847c9c1bbf1c0ce9d7e2f9bd7e3e5ab", "patch": "@@ -176,9 +176,7 @@ package body System.Tasking is\n    procedure Initialize is\n       T             : Task_Id;\n       Base_Priority : Any_Priority;\n-\n-      Success : Boolean;\n-      pragma Warnings (Off, Success);\n+      Success       : Boolean;\n \n    begin\n       if Initialized then\n@@ -195,7 +193,6 @@ package body System.Tasking is\n          Base_Priority := Priority (Main_Priority);\n       end if;\n \n-      Success := True;\n       T := STPO.New_ATCB (0);\n       Initialize_ATCB\n         (null, null, Null_Address, Null_Task, null, Base_Priority,"}]}