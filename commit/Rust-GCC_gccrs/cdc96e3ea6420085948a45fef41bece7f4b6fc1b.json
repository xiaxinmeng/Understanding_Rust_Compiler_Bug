{"sha": "cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RjOTZlM2VhNjQyMDA4NTk0OGE0NWZlZjQxYmVjZTdmNGI2ZmMxYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-30T09:21:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-30T09:21:43Z"}, "message": "[multiple changes]\n\n2012-03-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Process_Declarations): Replace\n\tthe call to Is_Null_Access_BIP_Func_Call with\n\tIs_Secondary_Stack_BIP_Func_Call. Update the related comment.\n\t* exp_util.adb (Is_Null_Access_BIP_Func_Call): Removed.\n\t(Is_Secondary_Stack_BIP_Func_Call): New routine.\n\t(Requires_Cleanup_Actions): Replace\n\tthe call to Is_Null_Access_BIP_Func_Call with\n\tIs_Secondary_Stack_BIP_Func_Call. Update the related comment.\n\t* exp_util.ads (Is_Null_Access_BIP_Func_Call): Removed.\n\t(Is_Secondary_Stack_BIP_Func_Call): New routine.\n\n2012-03-30  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-alfa.adb, lib-xref.adb: Code clean ups.\n\nFrom-SVN: r186001", "tree": {"sha": "42a3bddf21285d716c4ac51e941c4c6a9c6fed85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a3bddf21285d716c4ac51e941c4c6a9c6fed85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/comments", "author": null, "committer": null, "parents": [{"sha": "5cf01d62a8747e62fa3f40d60374679dd8212b2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf01d62a8747e62fa3f40d60374679dd8212b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cf01d62a8747e62fa3f40d60374679dd8212b2c"}], "stats": {"total": 1104, "additions": 537, "deletions": 567}, "files": [{"sha": "450239a6b0182cec94f4f3cf84325afedc902540", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "patch": "@@ -1,3 +1,20 @@\n+2012-03-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Process_Declarations): Replace\n+\tthe call to Is_Null_Access_BIP_Func_Call with\n+\tIs_Secondary_Stack_BIP_Func_Call. Update the related comment.\n+\t* exp_util.adb (Is_Null_Access_BIP_Func_Call): Removed.\n+\t(Is_Secondary_Stack_BIP_Func_Call): New routine.\n+\t(Requires_Cleanup_Actions): Replace\n+\tthe call to Is_Null_Access_BIP_Func_Call with\n+\tIs_Secondary_Stack_BIP_Func_Call. Update the related comment.\n+\t* exp_util.ads (Is_Null_Access_BIP_Func_Call): Removed.\n+\t(Is_Secondary_Stack_BIP_Func_Call): New routine.\n+\n+2012-03-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-alfa.adb, lib-xref.adb: Code clean ups.\n+\n 2012-03-30  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): For the case of a"}, {"sha": "525bae71e440961cd659a7a0c504d240718e8a5f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "patch": "@@ -1824,15 +1824,14 @@ package body Exp_Ch7 is\n                --    Obj : Access_Typ := Non_BIP_Function_Call'reference;\n \n                --    Obj : Access_Typ :=\n-               --            BIP_Function_Call\n-               --              (..., BIPaccess => null, ...)'reference;\n+               --            BIP_Function_Call (BIPalloc => 2, ...)'reference;\n \n                elsif Is_Access_Type (Obj_Typ)\n                  and then Needs_Finalization\n                             (Available_View (Designated_Type (Obj_Typ)))\n                  and then Present (Expr)\n                  and then\n-                   (Is_Null_Access_BIP_Func_Call (Expr)\n+                   (Is_Secondary_Stack_BIP_Func_Call (Expr)\n                      or else\n                        (Is_Non_BIP_Func_Call (Expr)\n                          and then not Is_Related_To_Func_Return (Obj_Id)))"}, {"sha": "f78442c566cdabae881af6eedc766cd96bf2517b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "patch": "@@ -4475,74 +4475,6 @@ package body Exp_Util is\n         and then Is_Library_Level_Entity (Typ);\n    end Is_Library_Level_Tagged_Type;\n \n-   ----------------------------------\n-   -- Is_Null_Access_BIP_Func_Call --\n-   ----------------------------------\n-\n-   function Is_Null_Access_BIP_Func_Call (Expr : Node_Id) return Boolean is\n-      Call : Node_Id := Expr;\n-\n-   begin\n-      --  Build-in-place calls usually appear in 'reference format\n-\n-      if Nkind (Call) = N_Reference then\n-         Call := Prefix (Call);\n-      end if;\n-\n-      if Nkind_In (Call, N_Qualified_Expression,\n-                         N_Unchecked_Type_Conversion)\n-      then\n-         Call := Expression (Call);\n-      end if;\n-\n-      if Is_Build_In_Place_Function_Call (Call) then\n-         declare\n-            Access_Nam : Name_Id := No_Name;\n-            Actual     : Node_Id;\n-            Param      : Node_Id;\n-            Formal     : Node_Id;\n-\n-         begin\n-            --  Examine all parameter associations of the function call\n-\n-            Param := First (Parameter_Associations (Call));\n-            while Present (Param) loop\n-               if Nkind (Param) = N_Parameter_Association\n-                 and then Nkind (Selector_Name (Param)) = N_Identifier\n-               then\n-                  Formal := Selector_Name (Param);\n-                  Actual := Explicit_Actual_Parameter (Param);\n-\n-                  --  Construct the name of formal BIPaccess. It is much easier\n-                  --  to extract the name of the function using an arbitrary\n-                  --  formal's scope rather than the Name field of Call.\n-\n-                  if Access_Nam = No_Name\n-                    and then Present (Entity (Formal))\n-                  then\n-                     Access_Nam :=\n-                       New_External_Name\n-                         (Chars (Scope (Entity (Formal))),\n-                          BIP_Formal_Suffix (BIP_Object_Access));\n-                  end if;\n-\n-                  --  A match for BIPaccess => null has been found\n-\n-                  if Chars (Formal) = Access_Nam\n-                    and then Nkind (Actual) = N_Null\n-                  then\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next (Param);\n-            end loop;\n-         end;\n-      end if;\n-\n-      return False;\n-   end Is_Null_Access_BIP_Func_Call;\n-\n    --------------------------\n    -- Is_Non_BIP_Func_Call --\n    --------------------------\n@@ -4949,6 +4881,75 @@ package body Exp_Util is\n       end if;\n    end Is_Renamed_Object;\n \n+   --------------------------------------\n+   -- Is_Secondary_Stack_BIP_Func_Call --\n+   --------------------------------------\n+\n+   function Is_Secondary_Stack_BIP_Func_Call (Expr : Node_Id) return Boolean is\n+      Call : Node_Id := Expr;\n+\n+   begin\n+      --  Build-in-place calls usually appear in 'reference format\n+\n+      if Nkind (Call) = N_Reference then\n+         Call := Prefix (Call);\n+      end if;\n+\n+      if Nkind_In (Call, N_Qualified_Expression,\n+                         N_Unchecked_Type_Conversion)\n+      then\n+         Call := Expression (Call);\n+      end if;\n+\n+      if Is_Build_In_Place_Function_Call (Call) then\n+         declare\n+            Access_Nam : Name_Id := No_Name;\n+            Actual     : Node_Id;\n+            Param      : Node_Id;\n+            Formal     : Node_Id;\n+\n+         begin\n+            --  Examine all parameter associations of the function call\n+\n+            Param := First (Parameter_Associations (Call));\n+            while Present (Param) loop\n+               if Nkind (Param) = N_Parameter_Association\n+                 and then Nkind (Selector_Name (Param)) = N_Identifier\n+               then\n+                  Formal := Selector_Name (Param);\n+                  Actual := Explicit_Actual_Parameter (Param);\n+\n+                  --  Construct the name of formal BIPalloc. It is much easier\n+                  --  to extract the name of the function using an arbitrary\n+                  --  formal's scope rather than the Name field of Call.\n+\n+                  if Access_Nam = No_Name\n+                    and then Present (Entity (Formal))\n+                  then\n+                     Access_Nam :=\n+                       New_External_Name\n+                         (Chars (Scope (Entity (Formal))),\n+                          BIP_Formal_Suffix (BIP_Alloc_Form));\n+                  end if;\n+\n+                  --  A match for BIPalloc => 2 has been found\n+\n+                  if Chars (Formal) = Access_Nam\n+                    and then Nkind (Actual) = N_Integer_Literal\n+                    and then Intval (Actual) = Uint_2\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               Next (Param);\n+            end loop;\n+         end;\n+      end if;\n+\n+      return False;\n+   end Is_Secondary_Stack_BIP_Func_Call;\n+\n    -------------------------------------\n    -- Is_Tag_To_Class_Wide_Conversion --\n    -------------------------------------\n@@ -7123,18 +7124,17 @@ package body Exp_Util is\n             --    Obj : Access_Typ := Non_BIP_Function_Call'reference;\n             --\n             --    Obj : Access_Typ :=\n-            --            BIP_Function_Call\n-            --              (..., BIPaccess => null, ...)'reference;\n+            --            BIP_Function_Call (BIPalloc => 2, ...)'reference;\n \n             elsif Is_Access_Type (Obj_Typ)\n               and then Needs_Finalization\n                          (Available_View (Designated_Type (Obj_Typ)))\n               and then Present (Expr)\n               and then\n-                (Is_Null_Access_BIP_Func_Call (Expr)\n-                   or else\n-                (Is_Non_BIP_Func_Call (Expr)\n-                   and then not Is_Related_To_Func_Return (Obj_Id)))\n+                (Is_Secondary_Stack_BIP_Func_Call (Expr)\n+                  or else\n+                    (Is_Non_BIP_Func_Call (Expr)\n+                      and then not Is_Related_To_Func_Return (Obj_Id)))\n             then\n                return True;\n "}, {"sha": "535a4ffe2fd624c3a743e72c806ae833d0d2f966", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "patch": "@@ -548,13 +548,20 @@ package Exp_Util is\n    --  Return True if Typ is a library level tagged type. Currently we use\n    --  this information to build statically allocated dispatch tables.\n \n-   function Is_Null_Access_BIP_Func_Call (Expr : Node_Id) return Boolean;\n-   --  Determine whether node Expr denotes a build-in-place function call with\n-   --  a value of \"null\" for extra formal BIPaccess.\n-\n    function Is_Non_BIP_Func_Call (Expr : Node_Id) return Boolean;\n    --  Determine whether node Expr denotes a non build-in-place function call\n \n+   function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean;\n+   --  Node N is an object reference. This function returns True if it is\n+   --  possible that the object may not be aligned according to the normal\n+   --  default alignment requirement for its type (e.g. if it appears in a\n+   --  packed record, or as part of a component that has a component clause.)\n+\n+   function Is_Possibly_Unaligned_Slice (N : Node_Id) return Boolean;\n+   --  Determine whether the node P is a slice of an array where the slice\n+   --  result may cause alignment problems because it has an alignment that\n+   --  is not compatible with the type. Return True if so.\n+\n    function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed array, i.e.\n    --  whether the designated object is a component of a bit packed array, or a\n@@ -571,17 +578,6 @@ package Exp_Util is\n    --  Determine whether object Id is related to an expanded return statement.\n    --  The case concerned is \"return Id.all;\".\n \n-   function Is_Possibly_Unaligned_Slice (N : Node_Id) return Boolean;\n-   --  Determine whether the node P is a slice of an array where the slice\n-   --  result may cause alignment problems because it has an alignment that\n-   --  is not compatible with the type. Return True if so.\n-\n-   function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean;\n-   --  Node N is an object reference. This function returns True if it is\n-   --  possible that the object may not be aligned according to the normal\n-   --  default alignment requirement for its type (e.g. if it appears in a\n-   --  packed record, or as part of a component that has a component clause.)\n-\n    function Is_Renamed_Object (N : Node_Id) return Boolean;\n    --  Returns True if the node N is a renamed object. An expression is\n    --  considered to be a renamed object if either it is the Name of an object\n@@ -593,6 +589,10 @@ package Exp_Util is\n    --  We consider that a (1 .. 2) is a renamed object since it is the prefix\n    --  of the name in the renaming declaration.\n \n+   function Is_Secondary_Stack_BIP_Func_Call (Expr : Node_Id) return Boolean;\n+   --  Determine whether Expr denotes a build-in-place function which returns\n+   --  its result on the secondary stack.\n+\n    function Is_Tag_To_Class_Wide_Conversion\n      (Obj_Id : Entity_Id) return Boolean;\n    --  Determine whether object Obj_Id is the result of a tag-to-class-wide"}, {"sha": "f454463e7c3cd2ca718b3a0f2c880382b70280d8", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 406, "deletions": 450, "changes": 856, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "patch": "@@ -40,100 +40,16 @@ package body Alfa is\n    --  Table of Alfa_Entities, True for each entity kind used in Alfa\n \n    Alfa_Entities : constant array (Entity_Kind) of Boolean :=\n-     (E_Void                                       => False,\n-      E_Variable                                   => True,\n-      E_Component                                  => False,\n-      E_Constant                                   => True,\n-      E_Discriminant                               => False,\n-\n-      E_Loop_Parameter                             => True,\n-      E_In_Parameter                               => True,\n-      E_Out_Parameter                              => True,\n-      E_In_Out_Parameter                           => True,\n-      E_Generic_In_Out_Parameter                   => False,\n-\n-      E_Generic_In_Parameter                       => False,\n-      E_Named_Integer                              => False,\n-      E_Named_Real                                 => False,\n-      E_Enumeration_Type                           => False,\n-      E_Enumeration_Subtype                        => False,\n-\n-      E_Signed_Integer_Type                        => False,\n-      E_Signed_Integer_Subtype                     => False,\n-      E_Modular_Integer_Type                       => False,\n-      E_Modular_Integer_Subtype                    => False,\n-      E_Ordinary_Fixed_Point_Type                  => False,\n-\n-      E_Ordinary_Fixed_Point_Subtype               => False,\n-      E_Decimal_Fixed_Point_Type                   => False,\n-      E_Decimal_Fixed_Point_Subtype                => False,\n-      E_Floating_Point_Type                        => False,\n-      E_Floating_Point_Subtype                     => False,\n-\n-      E_Access_Type                                => False,\n-      E_Access_Subtype                             => False,\n-      E_Access_Attribute_Type                      => False,\n-      E_Allocator_Type                             => False,\n-      E_General_Access_Type                        => False,\n-\n-      E_Access_Subprogram_Type                     => False,\n-      E_Access_Protected_Subprogram_Type           => False,\n-      E_Anonymous_Access_Subprogram_Type           => False,\n-      E_Anonymous_Access_Protected_Subprogram_Type => False,\n-      E_Anonymous_Access_Type                      => False,\n-\n-      E_Array_Type                                 => False,\n-      E_Array_Subtype                              => False,\n-      E_String_Type                                => False,\n-      E_String_Subtype                             => False,\n-      E_String_Literal_Subtype                     => False,\n-\n-      E_Class_Wide_Type                            => False,\n-      E_Class_Wide_Subtype                         => False,\n-      E_Record_Type                                => False,\n-      E_Record_Subtype                             => False,\n-      E_Record_Type_With_Private                   => False,\n-\n-      E_Record_Subtype_With_Private                => False,\n-      E_Private_Type                               => False,\n-      E_Private_Subtype                            => False,\n-      E_Limited_Private_Type                       => False,\n-      E_Limited_Private_Subtype                    => False,\n-\n-      E_Incomplete_Type                            => False,\n-      E_Incomplete_Subtype                         => False,\n-      E_Task_Type                                  => False,\n-      E_Task_Subtype                               => False,\n-      E_Protected_Type                             => False,\n-\n-      E_Protected_Subtype                          => False,\n-      E_Exception_Type                             => False,\n-      E_Subprogram_Type                            => False,\n-      E_Enumeration_Literal                        => False,\n-      E_Function                                   => True,\n-\n-      E_Operator                                   => True,\n-      E_Procedure                                  => True,\n-      E_Entry                                      => False,\n-      E_Entry_Family                               => False,\n-      E_Block                                      => False,\n-\n-      E_Entry_Index_Parameter                      => False,\n-      E_Exception                                  => False,\n-      E_Generic_Function                           => False,\n-      E_Generic_Package                            => False,\n-      E_Generic_Procedure                          => False,\n-\n-      E_Label                                      => False,\n-      E_Loop                                       => False,\n-      E_Return_Statement                           => False,\n-      E_Package                                    => False,\n-\n-      E_Package_Body                               => False,\n-      E_Protected_Object                           => False,\n-      E_Protected_Body                             => False,\n-      E_Task_Body                                  => False,\n-      E_Subprogram_Body                            => False);\n+     (E_Constant         => True,\n+      E_Function         => True,\n+      E_In_Out_Parameter => True,\n+      E_In_Parameter     => True,\n+      E_Loop_Parameter   => True,\n+      E_Operator         => True,\n+      E_Out_Parameter    => True,\n+      E_Procedure        => True,\n+      E_Variable         => True,\n+      others             => False);\n \n    --  True for each reference type used in Alfa\n    Alfa_References : constant array (Character) of Boolean :=\n@@ -149,6 +65,9 @@ package body Alfa is\n    -- Local Variables --\n    ---------------------\n \n+   Heap : Entity_Id := Empty;\n+   --  A special entity which denotes the heap object\n+\n    package Drefs is new Table.Table (\n      Table_Component_Type => Xref_Entry,\n      Table_Index_Type     => Xref_Entry_Number,\n@@ -210,8 +129,8 @@ package body Alfa is\n    -------------------\n \n    procedure Add_Alfa_File (U : Unit_Number_Type; D : Nat) is\n+      File : constant Source_File_Index := Source_Index (U);\n       From : Scope_Index;\n-      S    : constant Source_File_Index := Source_Index (U);\n \n       File_Name      : String_Ptr;\n       Unit_File_Name : String_Ptr;\n@@ -220,7 +139,7 @@ package body Alfa is\n       --  Source file could be inexistant as a result of an error, if option\n       --  gnatQ is used.\n \n-      if S = No_Source_File then\n+      if File = No_Source_File then\n          return;\n       end if;\n \n@@ -230,67 +149,64 @@ package body Alfa is\n       --  filling Sdep_Table in Write_ALI.\n \n       if Present (Cunit (U)) then\n-         Traverse_Compilation_Unit (Cunit (U),\n-                                    Detect_And_Add_Alfa_Scope'Access,\n-                                    Inside_Stubs => False);\n+         Traverse_Compilation_Unit\n+           (CU           => Cunit (U),\n+            Process      => Detect_And_Add_Alfa_Scope'Access,\n+            Inside_Stubs => False);\n       end if;\n \n       --  Update scope numbers\n \n       declare\n-         Count : Nat;\n+         Scope_Id : Int;\n \n       begin\n-         Count := 1;\n-         for S in From .. Alfa_Scope_Table.Last loop\n+         Scope_Id := 1;\n+         for Index in From .. Alfa_Scope_Table.Last loop\n             declare\n-               E : Entity_Id renames Alfa_Scope_Table.Table (S).Scope_Entity;\n+               S : Alfa_Scope_Record renames Alfa_Scope_Table.Table (Index);\n \n             begin\n-               if Lib.Get_Source_Unit (E) = U then\n-                  Alfa_Scope_Table.Table (S).Scope_Num := Count;\n-                  Alfa_Scope_Table.Table (S).File_Num  := D;\n-                  Count                                := Count + 1;\n-\n-               else\n-                  --  Mark for removal a scope S which is not located in unit\n-                  --  U, for example for scope inside generics that get\n-                  --  instantiated.\n-\n-                  Alfa_Scope_Table.Table (S).Scope_Num := 0;\n-               end if;\n+               S.Scope_Num := Scope_Id;\n+               S.File_Num  := D;\n+               Scope_Id    := Scope_Id + 1;\n             end;\n          end loop;\n       end;\n \n+      --  Remove those scopes previously marked for removal\n+\n       declare\n-         Snew : Scope_Index;\n+         Scope_Id : Scope_Index;\n \n       begin\n-         Snew := From;\n-         for S in From .. Alfa_Scope_Table.Last loop\n-            --  Remove those scopes previously marked for removal\n+         Scope_Id := From;\n+         for Index in From .. Alfa_Scope_Table.Last loop\n+            declare\n+               S : Alfa_Scope_Record renames Alfa_Scope_Table.Table (Index);\n \n-            if Alfa_Scope_Table.Table (S).Scope_Num /= 0 then\n-               Alfa_Scope_Table.Table (Snew) := Alfa_Scope_Table.Table (S);\n-               Snew := Snew + 1;\n-            end if;\n+            begin\n+               if S.Scope_Num /= 0 then\n+                  Alfa_Scope_Table.Table (Scope_Id) := S;\n+                  Scope_Id := Scope_Id + 1;\n+               end if;\n+            end;\n          end loop;\n \n-         Alfa_Scope_Table.Set_Last (Snew - 1);\n+         Alfa_Scope_Table.Set_Last (Scope_Id - 1);\n       end;\n \n       --  Make entry for new file in file table\n \n-      Get_Name_String (Reference_Name (S));\n+      Get_Name_String (Reference_Name (File));\n       File_Name := new String'(Name_Buffer (1 .. Name_Len));\n \n       --  For subunits, also retrieve the file name of the unit. Only do so if\n       --  unit U has an associated compilation unit.\n \n       if Present (Cunit (U))\n-        and then Present (Cunit (Unit (S)))\n-        and then Nkind (Unit (Cunit (Unit (S)))) = N_Subunit\n+        and then Present (Cunit (Unit (File)))\n+        and then Nkind (Unit (Cunit (Unit (File)))) = N_Subunit\n       then\n          Get_Name_String (Reference_Name (Main_Source_File));\n          Unit_File_Name := new String'(Name_Buffer (1 .. Name_Len));\n@@ -384,10 +300,44 @@ package body Alfa is\n    --------------------\n \n    procedure Add_Alfa_Xrefs is\n-      Cur_Scope_Idx   : Scope_Index;\n-      From_Xref_Idx   : Xref_Index;\n-      Cur_Entity      : Entity_Id;\n-      Cur_Entity_Name : String_Ptr;\n+      function Entity_Of_Scope (S : Scope_Index) return Entity_Id;\n+      --  Return the entity which maps to the input scope index\n+\n+      function Get_Entity_Type (E : Entity_Id) return Character;\n+      --  Return a character representing the type of entity\n+\n+      function Is_Alfa_Reference\n+        (E   : Entity_Id;\n+         Typ : Character) return Boolean;\n+      --  Return whether entity reference E meets Alfa requirements. Typ is the\n+      --  reference type.\n+\n+      function Is_Alfa_Scope (E : Entity_Id) return Boolean;\n+      --  Return whether the entity or reference scope meets requirements for\n+      --  being an Alfa scope.\n+\n+      function Is_Future_Scope_Entity\n+        (E : Entity_Id;\n+         S : Scope_Index) return Boolean;\n+      --  Check whether entity E is in Alfa_Scope_Table at index S or higher\n+\n+      function Is_Global_Constant (E : Entity_Id) return Boolean;\n+      --  Return True if E is a global constant for which we should ignore\n+      --  reads in Alfa.\n+\n+      function Lt (Op1 : Natural; Op2 : Natural) return Boolean;\n+      --  Comparison function for Sort call\n+\n+      procedure Move (From : Natural; To : Natural);\n+      --  Move procedure for Sort call\n+\n+      procedure Update_Scope_Range\n+        (S    : Scope_Index;\n+         From : Xref_Index;\n+         To   : Xref_Index);\n+      --  Update the scope which maps to S with the new range From .. To\n+\n+      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n \n       package Scopes is\n          No_Scope : constant Nat := 0;\n@@ -447,13 +397,144 @@ package body Alfa is\n       --  for the call to sort. When we sort the table, we move the entries in\n       --  Rnums around, but we do not move the original table entries.\n \n-      function Lt (Op1, Op2 : Natural) return Boolean;\n-      --  Comparison function for Sort call\n+      ---------------------\n+      -- Entity_Of_Scope --\n+      ---------------------\n \n-      procedure Move (From : Natural; To : Natural);\n-      --  Move procedure for Sort call\n+      function Entity_Of_Scope (S : Scope_Index) return Entity_Id is\n+      begin\n+         return Alfa_Scope_Table.Table (S).Scope_Entity;\n+      end Entity_Of_Scope;\n \n-      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+      ---------------------\n+      -- Get_Entity_Type --\n+      ---------------------\n+\n+      function Get_Entity_Type (E : Entity_Id) return Character is\n+         C : Character;\n+\n+      begin\n+         case Ekind (E) is\n+            when E_Out_Parameter    => C := '<';\n+            when E_In_Out_Parameter => C := '=';\n+            when E_In_Parameter     => C := '>';\n+            when others             => C := '*';\n+         end case;\n+\n+         return C;\n+      end Get_Entity_Type;\n+\n+      -----------------------\n+      -- Is_Alfa_Reference --\n+      -----------------------\n+\n+      function Is_Alfa_Reference\n+        (E   : Entity_Id;\n+         Typ : Character) return Boolean\n+      is\n+      begin\n+         --  The only references of interest on callable entities are calls. On\n+         --  non-callable entities, the only references of interest are reads\n+         --  and writes.\n+\n+         if Ekind (E) in Overloadable_Kind then\n+            return Typ = 's';\n+\n+         --  References to constant objects are not considered in Alfa section,\n+         --  as these will be translated as constants in the intermediate\n+         --  language for formal verification, and should therefore never\n+         --  appear in frame conditions.\n+\n+         elsif Is_Constant_Object (E) then\n+            return False;\n+\n+         --  Objects of Task type or protected type are not Alfa references\n+\n+         elsif Present (Etype (E))\n+           and then Ekind (Etype (E)) in Concurrent_Kind\n+         then\n+            return False;\n+\n+         --  In all other cases, result is true for reference/modify cases,\n+         --  and false for all other cases.\n+\n+         else\n+            return Typ = 'r' or else Typ = 'm';\n+         end if;\n+      end Is_Alfa_Reference;\n+\n+      -------------------\n+      -- Is_Alfa_Scope --\n+      -------------------\n+\n+      function Is_Alfa_Scope (E : Entity_Id) return Boolean is\n+      begin\n+         return Present (E)\n+           and then not Is_Generic_Unit (E)\n+           and then Renamed_Entity (E) = Empty\n+           and then Get_Scope_Num (E) /= No_Scope;\n+      end Is_Alfa_Scope;\n+\n+      ----------------------------\n+      -- Is_Future_Scope_Entity --\n+      ----------------------------\n+\n+      function Is_Future_Scope_Entity\n+        (E : Entity_Id;\n+         S : Scope_Index) return Boolean\n+      is\n+         function Is_Past_Scope_Entity return Boolean;\n+         --  Check whether entity E is in Alfa_Scope_Table at index strictly\n+         --  lower than S.\n+\n+         --------------------------\n+         -- Is_Past_Scope_Entity --\n+         --------------------------\n+\n+         function Is_Past_Scope_Entity return Boolean is\n+         begin\n+            for Index in Alfa_Scope_Table.First .. S - 1 loop\n+               if Alfa_Scope_Table.Table (Index).Scope_Entity = E then\n+                  declare\n+                     Dummy : constant Alfa_Scope_Record :=\n+                               Alfa_Scope_Table.Table (Index);\n+                     pragma Unreferenced (Dummy);\n+                  begin\n+                     return True;\n+                  end;\n+               end if;\n+            end loop;\n+\n+            return False;\n+         end Is_Past_Scope_Entity;\n+\n+      --  Start of processing for Is_Future_Scope_Entity\n+\n+      begin\n+         for Index in S .. Alfa_Scope_Table.Last loop\n+            if Alfa_Scope_Table.Table (Index).Scope_Entity = E then\n+               return True;\n+            end if;\n+         end loop;\n+\n+         --  If this assertion fails, this means that the scope which we are\n+         --  looking for has been treated already, which reveals a problem in\n+         --  the order of cross-references.\n+\n+         pragma Assert (not Is_Past_Scope_Entity);\n+\n+         return False;\n+      end Is_Future_Scope_Entity;\n+\n+      ------------------------\n+      -- Is_Global_Constant --\n+      ------------------------\n+\n+      function Is_Global_Constant (E : Entity_Id) return Boolean is\n+      begin\n+         return Ekind (E) = E_Constant\n+           and then Ekind_In (Scope (E), E_Package, E_Package_Body);\n+      end Is_Global_Constant;\n \n       --------\n       -- Lt --\n@@ -492,13 +573,13 @@ package body Alfa is\n          --  Fourth test: if reference is in same unit as entity definition,\n          --  sort first.\n \n-         elsif\n-           T1.Key.Lun /= T2.Key.Lun and then T1.Ent_Scope_File = T1.Key.Lun\n+         elsif T1.Key.Lun /= T2.Key.Lun\n+           and then T1.Ent_Scope_File = T1.Key.Lun\n          then\n             return True;\n \n-         elsif\n-           T1.Key.Lun /= T2.Key.Lun and then T2.Ent_Scope_File = T2.Key.Lun\n+         elsif T1.Key.Lun /= T2.Key.Lun\n+           and then T2.Ent_Scope_File = T2.Key.Lun\n          then\n             return False;\n \n@@ -510,6 +591,7 @@ package body Alfa is\n            and then T1.Key.Ent_Scope = T1.Key.Ref_Scope\n          then\n             return True;\n+\n          elsif T1.Ent_Scope_File = T1.Key.Lun\n            and then T1.Key.Ref_Scope /= T2.Key.Ref_Scope\n            and then T2.Key.Ent_Scope = T2.Key.Ref_Scope\n@@ -554,44 +636,52 @@ package body Alfa is\n          Rnums (Nat (To)) := Rnums (Nat (From));\n       end Move;\n \n-      Heap : Entity_Id;\n+      ------------------------\n+      -- Update_Scope_Range --\n+      ------------------------\n+\n+      procedure Update_Scope_Range\n+        (S    : Scope_Index;\n+         From : Xref_Index;\n+         To   : Xref_Index)\n+      is\n+      begin\n+         Alfa_Scope_Table.Table (S).From_Xref := From;\n+         Alfa_Scope_Table.Table (S).To_Xref := To;\n+      end Update_Scope_Range;\n+\n+      --  Local variables\n+\n+      Col        : Nat;\n+      From_Index : Xref_Index;\n+      Line       : Nat;\n+      Loc        : Source_Ptr;\n+      Prev_Typ   : Character;\n+      Ref_Count  : Nat;\n+      Ref_Id     : Entity_Id;\n+      Ref_Name   : String_Ptr;\n+      Scope_Id   : Scope_Index;\n \n    --  Start of processing for Add_Alfa_Xrefs\n \n    begin\n-      for J in Alfa_Scope_Table.First .. Alfa_Scope_Table.Last loop\n-         Set_Scope_Num (N   => Alfa_Scope_Table.Table (J).Scope_Entity,\n-                        Num => Alfa_Scope_Table.Table (J).Scope_Num);\n+      for Index in Alfa_Scope_Table.First .. Alfa_Scope_Table.Last loop\n+         declare\n+            S : Alfa_Scope_Record renames Alfa_Scope_Table.Table (Index);\n+\n+         begin\n+            Set_Scope_Num (S.Scope_Entity, S.Scope_Num);\n+         end;\n       end loop;\n \n       --  Set up the pointer vector for the sort\n \n-      for J in 1 .. Nrefs loop\n-         Rnums (J) := J;\n+      for Index in 1 .. Nrefs loop\n+         Rnums (Index) := Index;\n       end loop;\n \n-      --  Add dereferences to the set of regular references, by creating a\n-      --  special \"Heap\" variable for these special references.\n-\n-      Name_Len := Name_Of_Heap_Variable'Length;\n-      Name_Buffer (1 .. Name_Len) := Name_Of_Heap_Variable;\n-\n-      Atree.Unlock;\n-      Nlists.Unlock;\n-      Heap := Make_Defining_Identifier (Standard_Location, Name_Enter);\n-      Atree.Lock;\n-      Nlists.Lock;\n-\n-      Set_Ekind         (Heap, E_Variable);\n-      Set_Is_Internal   (Heap, True);\n-      Set_Has_Fully_Qualified_Name (Heap);\n-\n-      for J in Drefs.First .. Drefs.Last loop\n-         Xrefs.Append (Drefs.Table (J));\n-\n-         --  Set entity at this point with newly created \"Heap\" variable\n-\n-         Xrefs.Table (Xrefs.Last).Key.Ent := Heap;\n+      for Index in Drefs.First .. Drefs.Last loop\n+         Xrefs.Append (Drefs.Table (Index));\n \n          Nrefs         := Nrefs + 1;\n          Rnums (Nrefs) := Xrefs.Last;\n@@ -601,323 +691,158 @@ package body Alfa is\n       --  cross-references, as it discards useless references which do not have\n       --  a proper format for the comparison function (like no location).\n \n-      Eliminate_Before_Sort : declare\n-         NR : Nat;\n-\n-         function Is_Alfa_Reference\n-           (E   : Entity_Id;\n-            Typ : Character) return Boolean;\n-         --  Return whether entity reference E meets Alfa requirements. Typ\n-         --  is the reference type.\n-\n-         function Is_Alfa_Scope (E : Entity_Id) return Boolean;\n-         --  Return whether the entity or reference scope meets requirements\n-         --  for being an Alfa scope.\n+      Ref_Count := Nrefs;\n+      Nrefs     := 0;\n \n-         function Is_Global_Constant (E : Entity_Id) return Boolean;\n-         --  Return True if E is a global constant for which we should ignore\n-         --  reads in Alfa.\n+      for Index in 1 .. Ref_Count loop\n+         declare\n+            Ref : Xref_Key renames Xrefs.Table (Rnums (Index)).Key;\n \n-         -----------------------\n-         -- Is_Alfa_Reference --\n-         -----------------------\n-\n-         function Is_Alfa_Reference\n-           (E   : Entity_Id;\n-            Typ : Character) return Boolean\n-         is\n          begin\n-            --  The only references of interest on callable entities are calls.\n-            --  On non-callable entities, the only references of interest are\n-            --  reads and writes.\n-\n-            if Ekind (E) in Overloadable_Kind then\n-               return Typ = 's';\n-\n-            --  References to constant objects are not considered in Alfa\n-            --  section, as these will be translated as constants in the\n-            --  intermediate language for formal verification, and should\n-            --  therefore never appear in frame conditions.\n-\n-            elsif Is_Constant_Object (E) then\n-                  return False;\n-\n-            --  Objects of Task type or protected type are not Alfa references\n-\n-            elsif Present (Etype (E))\n-              and then Ekind (Etype (E)) in Concurrent_Kind\n-            then\n-               return False;\n-\n-            --  In all other cases, result is true for reference/modify cases,\n-            --  and false for all other cases.\n-\n-            else\n-               return Typ = 'r' or else Typ = 'm';\n-            end if;\n-         end Is_Alfa_Reference;\n-\n-         -------------------\n-         -- Is_Alfa_Scope --\n-         -------------------\n-\n-         function Is_Alfa_Scope (E : Entity_Id) return Boolean is\n-         begin\n-            return Present (E)\n-              and then not Is_Generic_Unit (E)\n-              and then Renamed_Entity (E) = Empty\n-              and then Get_Scope_Num (E) /= No_Scope;\n-         end Is_Alfa_Scope;\n-\n-         ------------------------\n-         -- Is_Global_Constant --\n-         ------------------------\n-\n-         function Is_Global_Constant (E : Entity_Id) return Boolean is\n-         begin\n-            return Ekind (E) = E_Constant\n-              and then Ekind_In (Scope (E), E_Package, E_Package_Body);\n-         end Is_Global_Constant;\n-\n-      --  Start of processing for Eliminate_Before_Sort\n-\n-      begin\n-         NR    := Nrefs;\n-         Nrefs := 0;\n-\n-         for J in 1 .. NR loop\n-            if Alfa_Entities (Ekind (Xrefs.Table (Rnums (J)).Key.Ent))\n-              and then Alfa_References (Xrefs.Table (Rnums (J)).Key.Typ)\n-              and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Key.Ent_Scope)\n-              and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Key.Ref_Scope)\n-              and then not Is_Global_Constant (Xrefs.Table (Rnums (J)).Key.Ent)\n-              and then Is_Alfa_Reference (Xrefs.Table (Rnums (J)).Key.Ent,\n-                                          Xrefs.Table (Rnums (J)).Key.Typ)\n+            if Alfa_Entities (Ekind (Ref.Ent))\n+              and then Alfa_References (Ref.Typ)\n+              and then Is_Alfa_Scope (Ref.Ent_Scope)\n+              and then Is_Alfa_Scope (Ref.Ref_Scope)\n+              and then not Is_Global_Constant (Ref.Ent)\n+              and then Is_Alfa_Reference (Ref.Ent, Ref.Typ)\n+\n+              --  Discard references from unknown scopes, such as generic\n+              --  scopes.\n+\n+              and then Get_Scope_Num (Ref.Ent_Scope) /= No_Scope\n+              and then Get_Scope_Num (Ref.Ref_Scope) /= No_Scope\n             then\n                Nrefs         := Nrefs + 1;\n-               Rnums (Nrefs) := Rnums (J);\n+               Rnums (Nrefs) := Rnums (Index);\n             end if;\n-         end loop;\n-      end Eliminate_Before_Sort;\n+         end;\n+      end loop;\n \n       --  Sort the references\n \n       Sorting.Sort (Integer (Nrefs));\n \n-      Eliminate_After_Sort : declare\n-         NR : Nat;\n-\n-         Crloc : Source_Ptr;\n-         --  Current reference location\n+      --  Eliminate duplicate entries\n \n-         Prevt : Character;\n-         --  reference kind of previous reference\n+      --  We need this test for Ref_Count because if we force ALI file\n+      --  generation in case of errors detected, it may be the case that\n+      --  Nrefs is 0, so we should not reset it here.\n \n-      begin\n-         --  Eliminate duplicate entries\n+      if Nrefs >= 2 then\n+         Ref_Count := Nrefs;\n+         Nrefs     := 1;\n \n-         --  We need this test for NR because if we force ALI file generation\n-         --  in case of errors detected, it may be the case that Nrefs is 0, so\n-         --  we should not reset it here\n-\n-         if Nrefs >= 2 then\n-            NR    := Nrefs;\n-            Nrefs := 1;\n+         for Index in 2 .. Ref_Count loop\n+            if Xrefs.Table (Rnums (Index)) /=\n+               Xrefs.Table (Rnums (Nrefs))\n+            then\n+               Nrefs := Nrefs + 1;\n+               Rnums (Nrefs) := Rnums (Index);\n+            end if;\n+         end loop;\n+      end if;\n \n-            for J in 2 .. NR loop\n-               if Xrefs.Table (Rnums (J)) /=\n-                 Xrefs.Table (Rnums (Nrefs))\n-               then\n-                  Nrefs := Nrefs + 1;\n-                  Rnums (Nrefs) := Rnums (J);\n-               end if;\n-            end loop;\n-         end if;\n+      --  Eliminate the reference if it is at the same location as the previous\n+      --  one, unless it is a read-reference indicating that the entity is an\n+      --  in-out actual in a call.\n \n-         --  Eliminate the reference if it is at the same location as the\n-         --  previous one, unless it is a read-reference indicating that the\n-         --  entity is an in-out actual in a call.\n+      Ref_Count := Nrefs;\n+      Nrefs     := 0;\n+      Loc       := No_Location;\n+      Prev_Typ  := 'm';\n \n-         NR    := Nrefs;\n-         Nrefs := 0;\n-         Crloc := No_Location;\n-         Prevt := 'm';\n+      for Index in 1 .. Ref_Count loop\n+         declare\n+            Ref : Xref_Key renames Xrefs.Table (Rnums (Index)).Key;\n \n-         for J in 1 .. NR loop\n-            if Xrefs.Table (Rnums (J)).Key.Loc /= Crloc\n-              or else (Prevt = 'm'\n-                        and then Xrefs.Table (Rnums (J)).Key.Typ = 'r')\n+         begin\n+            if Ref.Loc /= Loc\n+              or else (Prev_Typ = 'm'\n+                        and then Ref.Typ = 'r')\n             then\n-               Crloc         := Xrefs.Table (Rnums (J)).Key.Loc;\n-               Prevt         := Xrefs.Table (Rnums (J)).Key.Typ;\n+               Loc           := Ref.Loc;\n+               Prev_Typ      := Ref.Typ;\n                Nrefs         := Nrefs + 1;\n-               Rnums (Nrefs) := Rnums (J);\n+               Rnums (Nrefs) := Rnums (Index);\n             end if;\n-         end loop;\n-      end Eliminate_After_Sort;\n-\n-      --  Initialize loop\n+         end;\n+      end loop;\n \n-      Cur_Scope_Idx  := 1;\n-      From_Xref_Idx  := 1;\n-      Cur_Entity     := Empty;\n+      --  The two steps have eliminated all references, nothing to do\n \n       if Alfa_Scope_Table.Last = 0 then\n          return;\n       end if;\n \n+      Ref_Id     := Empty;\n+      Scope_Id   := 1;\n+      From_Index := 1;\n+\n       --  Loop to output references\n \n       for Refno in 1 .. Nrefs loop\n-         Add_One_Xref : declare\n-\n-            -----------------------\n-            -- Local Subprograms --\n-            -----------------------\n-\n-            function Cur_Scope return Node_Id;\n-            --  Return scope entity which corresponds to index Cur_Scope_Idx in\n-            --  table Alfa_Scope_Table.\n-\n-            function Get_Entity_Type (E : Entity_Id) return Character;\n-            --  Return a character representing the type of entity\n-\n-            function Is_Future_Scope_Entity (E : Entity_Id) return Boolean;\n-            --  Check whether entity E is in Alfa_Scope_Table at index\n-            --  Cur_Scope_Idx or higher.\n-\n-            function Is_Past_Scope_Entity (E : Entity_Id) return Boolean;\n-            --  Check whether entity E is in Alfa_Scope_Table at index strictly\n-            --  lower than Cur_Scope_Idx.\n-\n-            ---------------\n-            -- Cur_Scope --\n-            ---------------\n-\n-            function Cur_Scope return Node_Id is\n-            begin\n-               return Alfa_Scope_Table.Table (Cur_Scope_Idx).Scope_Entity;\n-            end Cur_Scope;\n-\n-            ---------------------\n-            -- Get_Entity_Type --\n-            ---------------------\n-\n-            function Get_Entity_Type (E : Entity_Id) return Character is\n-               C : Character;\n-            begin\n-               case Ekind (E) is\n-                  when E_Out_Parameter    => C := '<';\n-                  when E_In_Out_Parameter => C := '=';\n-                  when E_In_Parameter     => C := '>';\n-                  when others             => C := '*';\n-               end case;\n-               return C;\n-            end Get_Entity_Type;\n-\n-            ----------------------------\n-            -- Is_Future_Scope_Entity --\n-            ----------------------------\n-\n-            function Is_Future_Scope_Entity (E : Entity_Id) return Boolean is\n-            begin\n-               for J in Cur_Scope_Idx .. Alfa_Scope_Table.Last loop\n-                  if E = Alfa_Scope_Table.Table (J).Scope_Entity then\n-                     return True;\n-                  end if;\n-               end loop;\n-\n-               --  If this assertion fails, this means that the scope which we\n-               --  are looking for has been treated already, which reveals a\n-               --  problem in the order of cross-references.\n-\n-               pragma Assert (not Is_Past_Scope_Entity (E));\n-\n-               return False;\n-            end Is_Future_Scope_Entity;\n-\n-            --------------------------\n-            -- Is_Past_Scope_Entity --\n-            --------------------------\n-\n-            function Is_Past_Scope_Entity (E : Entity_Id) return Boolean is\n-            begin\n-               for J in Alfa_Scope_Table.First .. Cur_Scope_Idx - 1 loop\n-                  if E = Alfa_Scope_Table.Table (J).Scope_Entity then\n-                     return True;\n-                  end if;\n-               end loop;\n-\n-               return False;\n-            end Is_Past_Scope_Entity;\n-\n-            ---------------------\n-            -- Local Variables --\n-            ---------------------\n-\n-            XE  : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n+         declare\n+            Ref_Entry : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n+            Ref       : Xref_Key   renames Ref_Entry.Key;\n \n          begin\n             --  If this assertion fails, the scope which we are looking for is\n             --  not in Alfa scope table, which reveals either a problem in the\n             --  construction of the scope table, or an erroneous scope for the\n             --  current cross-reference.\n \n-            pragma Assert (Is_Future_Scope_Entity (XE.Key.Ent_Scope));\n+            pragma Assert\n+              (Is_Future_Scope_Entity (Ref.Ent_Scope, Scope_Id));\n \n             --  Update the range of cross references to which the current scope\n             --  refers to. This may be the empty range only for the first scope\n             --  considered.\n \n-            if XE.Key.Ent_Scope /= Cur_Scope then\n-               Alfa_Scope_Table.Table (Cur_Scope_Idx).From_Xref :=\n-                 From_Xref_Idx;\n-               Alfa_Scope_Table.Table (Cur_Scope_Idx).To_Xref :=\n-                 Alfa_Xref_Table.Last;\n-               From_Xref_Idx := Alfa_Xref_Table.Last + 1;\n+            if Ref.Ent_Scope /= Entity_Of_Scope (Scope_Id) then\n+               Update_Scope_Range\n+                 (S    => Scope_Id,\n+                  From => From_Index,\n+                  To   => Alfa_Xref_Table.Last);\n+\n+               From_Index := Alfa_Xref_Table.Last + 1;\n             end if;\n \n-            while XE.Key.Ent_Scope /= Cur_Scope loop\n-               Cur_Scope_Idx := Cur_Scope_Idx + 1;\n-               pragma Assert (Cur_Scope_Idx <= Alfa_Scope_Table.Last);\n+            while Ref.Ent_Scope /= Entity_Of_Scope (Scope_Id) loop\n+               Scope_Id := Scope_Id + 1;\n+               pragma Assert (Scope_Id <= Alfa_Scope_Table.Last);\n             end loop;\n \n-            if XE.Key.Ent /= Cur_Entity then\n-               Cur_Entity_Name :=\n-                 new String'(Unique_Name (XE.Key.Ent));\n+            if Ref.Ent /= Ref_Id then\n+               Ref_Name := new String'(Unique_Name (Ref.Ent));\n             end if;\n \n-            if XE.Key.Ent = Heap then\n-               Alfa_Xref_Table.Append (\n-                 (Entity_Name => Cur_Entity_Name,\n-                  Entity_Line => 0,\n-                  Etype       => Get_Entity_Type (XE.Key.Ent),\n-                  Entity_Col  => 0,\n-                  File_Num    => Dependency_Num (XE.Key.Lun),\n-                  Scope_Num   => Get_Scope_Num (XE.Key.Ref_Scope),\n-                  Line        => Int (Get_Logical_Line_Number (XE.Key.Loc)),\n-                  Rtype       => XE.Key.Typ,\n-                  Col         => Int (Get_Column_Number (XE.Key.Loc))));\n-\n+            if Ref.Ent = Heap then\n+               Line := 0;\n+               Col  := 0;\n             else\n-               Alfa_Xref_Table.Append (\n-                 (Entity_Name => Cur_Entity_Name,\n-                  Entity_Line => Int (Get_Logical_Line_Number (XE.Def)),\n-                  Etype       => Get_Entity_Type (XE.Key.Ent),\n-                  Entity_Col  => Int (Get_Column_Number (XE.Def)),\n-                  File_Num    => Dependency_Num (XE.Key.Lun),\n-                  Scope_Num   => Get_Scope_Num (XE.Key.Ref_Scope),\n-                  Line        => Int (Get_Logical_Line_Number (XE.Key.Loc)),\n-                  Rtype       => XE.Key.Typ,\n-                  Col         => Int (Get_Column_Number (XE.Key.Loc))));\n+               Line := Int (Get_Logical_Line_Number (Ref_Entry.Def));\n+               Col  := Int (Get_Column_Number (Ref_Entry.Def));\n             end if;\n-         end Add_One_Xref;\n+\n+            Alfa_Xref_Table.Append (\n+              (Entity_Name => Ref_Name,\n+               Entity_Line => Line,\n+               Etype       => Get_Entity_Type (Ref.Ent),\n+               Entity_Col  => Col,\n+               File_Num    => Dependency_Num (Ref.Lun),\n+               Scope_Num   => Get_Scope_Num (Ref.Ref_Scope),\n+               Line        => Int (Get_Logical_Line_Number (Ref.Loc)),\n+               Rtype       => Ref.Typ,\n+               Col         => Int (Get_Column_Number (Ref.Loc))));\n+         end;\n       end loop;\n \n       --  Update the range of cross references to which the scope refers to\n \n-      Alfa_Scope_Table.Table (Cur_Scope_Idx).From_Xref := From_Xref_Idx;\n-      Alfa_Scope_Table.Table (Cur_Scope_Idx).To_Xref   := Alfa_Xref_Table.Last;\n+      Update_Scope_Range\n+        (S    => Scope_Id,\n+         From => From_Index,\n+         To   => Alfa_Xref_Table.Last);\n    end Add_Alfa_Xrefs;\n \n    ------------------\n@@ -1028,9 +953,7 @@ package body Alfa is\n          Result := N;\n       end if;\n \n-      loop\n-         exit when No (Result);\n-\n+      while Present (Result) loop\n          case Nkind (Result) is\n             when N_Package_Specification =>\n                Result := Defining_Unit_Name (Result);\n@@ -1105,36 +1028,69 @@ package body Alfa is\n      (N   : Node_Id;\n       Typ : Character := 'r')\n    is\n-      Indx      : Nat;\n+      procedure Create_Heap;\n+      --  Create and decorate the special entity which denotes the heap\n+\n+      -----------------\n+      -- Create_Heap --\n+      -----------------\n+\n+      procedure Create_Heap is\n+      begin\n+         Name_Len := Name_Of_Heap_Variable'Length;\n+         Name_Buffer (1 .. Name_Len) := Name_Of_Heap_Variable;\n+\n+         Heap := Make_Defining_Identifier (Standard_Location, Name_Enter);\n+\n+         Set_Ekind       (Heap, E_Variable);\n+         Set_Is_Internal (Heap, True);\n+         Set_Has_Fully_Qualified_Name (Heap);\n+      end Create_Heap;\n+\n+      --  Local variables\n+\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Index     : Nat;\n       Ref       : Source_Ptr;\n       Ref_Scope : Entity_Id;\n \n+   --  Start of processing for Generate_Dereference\n+\n    begin\n-      Ref := Original_Location (Sloc (N));\n+      Ref := Original_Location (Loc);\n \n       if Ref > No_Location then\n          Drefs.Increment_Last;\n-         Indx := Drefs.Last;\n+         Index := Drefs.Last;\n+\n+         declare\n+            Deref_Entry : Xref_Entry renames Drefs.Table (Index);\n+            Deref       : Xref_Key   renames Deref_Entry.Key;\n+\n+         begin\n+            if No (Heap) then\n+               Create_Heap;\n+            end if;\n \n-         Ref_Scope := Enclosing_Subprogram_Or_Package (N);\n+            Ref_Scope := Enclosing_Subprogram_Or_Package (N);\n \n-         --  Entity is filled later on with the special \"Heap\" variable\n+            Deref.Ent := Heap;\n+            Deref.Loc := Ref;\n+            Deref.Typ := Typ;\n \n-         Drefs.Table (Indx).Key.Ent := Empty;\n+            --  It is as if the special \"Heap\" was defined in every scope where\n+            --  it is referenced.\n \n-         Drefs.Table (Indx).Def := No_Location;\n-         Drefs.Table (Indx).Key.Loc := Ref;\n-         Drefs.Table (Indx).Key.Typ := Typ;\n+            Deref.Eun := Get_Source_Unit (Ref);\n+            Deref.Lun := Get_Source_Unit (Ref);\n \n-         --  It is as if the special \"Heap\" was defined in every scope where it\n-         --  is referenced.\n+            Deref.Ref_Scope := Ref_Scope;\n+            Deref.Ent_Scope := Ref_Scope;\n \n-         Drefs.Table (Indx).Key.Eun := Get_Source_Unit (Ref);\n-         Drefs.Table (Indx).Key.Lun := Get_Source_Unit (Ref);\n+            Deref_Entry.Def := No_Location;\n \n-         Drefs.Table (Indx).Key.Ref_Scope := Ref_Scope;\n-         Drefs.Table (Indx).Key.Ent_Scope := Ref_Scope;\n-         Drefs.Table (Indx).Ent_Scope_File := Get_Source_Unit (Ref_Scope);\n+            Deref_Entry.Ent_Scope_File := Get_Source_Unit (Ref_Scope);\n+         end;\n       end if;\n    end Generate_Dereference;\n "}, {"sha": "d02420b216ad729aa0f0a79103453114ef389c74", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc96e3ea6420085948a45fef41bece7f4b6fc1b/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=cdc96e3ea6420085948a45fef41bece7f4b6fc1b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -161,6 +161,9 @@ package body Lib.Xref is\n    --  Local Subprograms --\n    ------------------------\n \n+   procedure Add_Entry (Key : Xref_Key; Ent_Scope_File : Unit_Number_Type);\n+   --  Add an entry to the tables of Xref_Entries, avoiding duplicates\n+\n    procedure Generate_Prim_Op_References (Typ : Entity_Id);\n    --  For a tagged type, generate implicit references to its primitive\n    --  operations, for source navigation. This is done right before emitting\n@@ -170,9 +173,6 @@ package body Lib.Xref is\n    function Lt (T1, T2 : Xref_Entry) return Boolean;\n    --  Order cross-references\n \n-   procedure Add_Entry (Key : Xref_Key; Ent_Scope_File : Unit_Number_Type);\n-   --  Add an entry to the tables of Xref_Entries, avoiding duplicates\n-\n    ---------------\n    -- Add_Entry --\n    ---------------\n@@ -373,23 +373,17 @@ package body Lib.Xref is\n       Set_Ref : Boolean   := True;\n       Force   : Boolean   := False)\n    is\n-      Nod : Node_Id;\n-      Ref : Source_Ptr;\n-      Def : Source_Ptr;\n-      Ent : Entity_Id;\n-\n-      Actual_Typ : Character := Typ;\n-\n-      Ref_Scope      : Entity_Id;\n+      Actual_Typ     : Character := Typ;\n+      Call           : Node_Id;\n+      Def            : Source_Ptr;\n+      Ent            : Entity_Id;\n       Ent_Scope      : Entity_Id;\n       Ent_Scope_File : Unit_Number_Type;\n-\n-      Call   : Node_Id;\n-      Formal : Entity_Id;\n-      --  Used for call to Find_Actual\n-\n-      Kind : Entity_Kind;\n-      --  If Formal is non-Empty, then its Ekind, otherwise E_Void\n+      Formal         : Entity_Id;\n+      Kind           : Entity_Kind;\n+      Nod            : Node_Id;\n+      Ref            : Source_Ptr;\n+      Ref_Scope      : Entity_Id;\n \n       function Get_Through_Renamings (E : Entity_Id) return Entity_Id;\n       --  Get the enclosing entity through renamings, which may come from\n@@ -884,11 +878,13 @@ package body Lib.Xref is\n          and then Sloc (E) > No_Location\n          and then Sloc (N) > No_Location\n \n-         --  We ignore references from within an instance, except for default\n-         --  subprograms, for which we generate an implicit reference.\n+         --  Ignore references from within an instance. The only exceptions to\n+         --  this are default subprograms, for which we generate an implicit\n+         --  reference.\n \n          and then\n-           (Instantiation_Location (Sloc (N)) = No_Location or else Typ = 'i')\n+           (Instantiation_Location (Sloc (N)) = No_Location\n+              or else Typ = 'i')\n \n          --  Ignore dummy references\n \n@@ -1003,14 +999,14 @@ package body Lib.Xref is\n          Def := Original_Location (Sloc (Ent));\n \n          if Actual_Typ = 'p'\n-           and then Is_Subprogram (N)\n-           and then Present (Overridden_Operation (N))\n+           and then Is_Subprogram (Nod)\n+           and then Present (Overridden_Operation (Nod))\n          then\n             Actual_Typ := 'P';\n          end if;\n \n          if Alfa_Mode then\n-            Ref_Scope := Alfa.Enclosing_Subprogram_Or_Package (N);\n+            Ref_Scope := Alfa.Enclosing_Subprogram_Or_Package (Nod);\n             Ent_Scope := Alfa.Enclosing_Subprogram_Or_Package (Ent);\n \n             --  Since we are reaching through renamings in Alfa mode, we may\n@@ -2434,6 +2430,8 @@ package body Lib.Xref is\n       end Output_Refs;\n    end Output_References;\n \n+--  Start of elaboration for Lib.Xref\n+\n begin\n    --  Reset is necessary because Elmt_Ptr does not default to Null_Ptr,\n    --  because it's not an access type."}]}