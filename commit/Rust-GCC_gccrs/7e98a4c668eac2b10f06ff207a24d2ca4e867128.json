{"sha": "7e98a4c668eac2b10f06ff207a24d2ca4e867128", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U5OGE0YzY2OGVhYzJiMTBmMDZmZjIwN2EyNGQyY2E0ZTg2NzEyOA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2005-03-15T15:46:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T15:46:57Z"}, "message": "mlib-tgt-tru64.adb, [...] (Library_Exist_For, [...]): Add new parameter In_Tree to specify the project tree...\n\n2005-03-08  Vincent Celier  <celier@adacore.com>\n\n\t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb,\n\tmlib-tgt-hpux.adb, mlib-tgt-linux.adb, mlib-tgt-solaris.adb,\n\tmlib-tgt-vms-alpha.adb, mlib-tgt-vms-ia64.adb, mlib-tgt-mingw.adb,\n\tmlib-tgt-vxworks.adb, mlib-tgt-lynxos.adb (Library_Exist_For,\n\tLibrary_File_Name_For): Add new parameter In_Tree\n\tto specify the project tree: needed by the project manager.\n\tAdapt to changes in project manager using new parameter In_Tree.\n\tRemove local imports, use functions in System.CRTL.\n\n\t* make.adb, clean.adb, gnatcmd.adb (Project_Tree): New constant needed\n\tto use the project manager.\n\n\t* makeutl.ads, makeutl.adb (Linker_Options_Switches): New parameter\n\tIn_Tree to designate the project tree. Adapt to changes in the project\n\tmanager, using In_Tree.\n\n\t* mlib-prj.ads, mlib-prj.adb (Build_Library, Check_Library,\n\tCopy_Interface_Sources): Add new parameter In_Tree to specify the\n\tproject tree: needed by the project manager.\n\t(Build_Library): Check that Arg'Length >= 6 before checking if it\n\tcontains \"--RTS=...\".\n\n\t* mlib-tgt.ads, mlib-tgt.adb (Library_Exist_For,\n\tLibrary_File_Name_For): Add new parameter In_Tree to specify the\n\tproject tree: needed by the project manager.\n\n\t* prj.ads, prj.adb: Major modifications to allow several project trees\n\tin memory at the same time.\n\tChange tables to dynamic tables and hash tables to dynamic hash\n\ttables. Move tables and hash tables from Prj.Com (in the visible part)\n\tand Prj.Env (in the private part). Move some constants from the visible\n\tpart to the private part. Make other constants deferred.\n\t(Project_Empty): Make it a variable, not a function\n\t(Empty_Project): Add parameter Tree. Returns the data with the default\n\tnaming data of the project tree Tree.\n\t(Initialize): After updating Std_Naming_Data, copy its value to the\n\tcomponent Naming of Project Empty.\n\t(Register_Default_Naming_Scheme): Use and update the default naming\n\tcomponent of the project tree, instead of the global variable\n\tStd_Naming_Data.\n\t(Standard_Naming_Data): Add defaulted parameter Tree. If project tree\n\tTree is not defaulted, return the default naming data of the Tree.\n\t(Initial_Buffer_Size): Constant moved from private part\n\t(Default_Ada_Spec_Suffix_Id, Default_Ada_Body_Suffix_Id, Slash_Id); new\n\tvariables initialized in procedure Initialize.\n\t(Add_To_Buffer): Add two in out parameters to replace global variables\n\tBuffer and Buffer_Last.\n\t(Default_Ada_Spec_Suffix, Default_Body_Spec_Suffix, Slash): New\n\tfunctions.\n\tAdapt to changes to use new type Project_Tree_Ref and dynamic tables and\n\thash tables.\n\t(Initialize, Reset, register-Default_Namng-Scheme): Add a new parameter\n\tfor the project tree.\n\t(Project_Tree_Data, Project_Tree_Ref, No_Project): Declare types and\n\tconstant at the beginning of the package spec, so that they cane be used\n\tin subprograms before their full declarations.\n\t(Standard_Naming_Data): Add defaulted parameter of type Project_Node_Ref\n\t(Empty_Project): Add parameter of type Project_Node_Ref\n\t(Private_Project_Tree_Data): Add component Default_Naming of type\n\tNaming_Data.\n\t(Buffer, Buffer_Last): remove global variables\n\t(Add_To_Buffer): Add two in out parameters to replace global variables\n\tBuffer and Buffer_Last.\n\t(Current_Packages_To_Check): Remove global variable\n\t(Empty_Name): Move to private part\n\t(No-Symbols): Make it a constant\n\t(Private_Project_Tree_Data): New type for the private part of the\n\tproject tree data.\n\t(Project_Tree_Data): New type for the data of a project tree\n\t(Project_Tree_Ref): New type to designate a project tree\n\t(Initialize, Reset, register-Default_Namng-Scheme): Add a new parameter\n\tfor the project tree.\n\n\t* prj-attr.ads: Add with Table; needed, as package Prj no longer\n\timports package Table.\n\n\t* prj-com.adb: Remove empty, no longer needed body\n\n\t* prj-com.ads: Move most of the content of this package to package Prj.\n\n\t* prj-dect.ads, prj-dect.adb (Parse): New parameters In_Tree to\n\tdesignate the project node tree and Packages_To_Check to replace\n\tglobal variable Current_Packages_To_Check.\n\tAdd new parameters In_Tree and Packages_To_Check to local subprograms,\n\twhen needed. Adapt to changes in project manager with project node tree\n\tIn_Tree.\n\n\t* prj-env.ads, prj-env.adb: Add new parameter In_Tree to designate the\n\tproject tree to most subprograms. Move tables and hash tables to\n\tprivate part of package Prj.\n\tAdapt to changes in project manager using project tree In_Tree.\n\n\t* prj-makr.adb (Tree): New constant to designate the project node tree\n\tAdapt to change in project manager using project node tree Tree\n\n\t* prj-nmsc.ads, prj-nmsc.adb (Check_Stand_Alone_Library): Correctly\n\tdisplay the Library_Src_Dir and the Library_Dir.\n\tAdd new parameter In_Tree to designate the project node tree to most\n\tsubprograms. Adapt to changes in the project manager, using project tree\n\tIn_Tree.\n\t(Check_Naming_Scheme): Do not alter the casing on platforms where\n\tthe casing of file names is not significant.\n\t(Check): Add new parameter In_Tree to designate the\n\n\t* prj-pars.ads, prj-pars.adb (Parse): Add new parameter In_Tree to\n\tdesignate the project tree.\n\tDeclare a project node tree to call Prj.Part.Parse and Prj.Proc.Process\n\n\t* prj-part.ads, prj-part.adb (Buffer, Buffer_Last): Global variables,\n\tto replace those that were in the private part of package Prj.\n\tAdd new parameter In__Tree to designate the project node tree to most\n\tsubprograms. Adapt to change in Prj.Tree with project node tree In_Tree.\n\t(Post_Parse_Context_Clause): When specifying the project node of a with\n\tclause, indicate that it is a limited with only if there is \"limited\"\n\tin the with clause, not necessarily when In_Limited is True.\n\t(Parse): Add new parameter In_Tree to designate the project node tree\n\n\t* prj-pp.ads, prj-pp.adb (Pretty_Print): Add new parameter In_Tree to\n\tdesignate the project node tree. Adapt to change in Prj.Tree with\n\tproject node tree In_Tree.\n\n\t* prj-proc.ads, prj-proc.adb (Recursive_Process): Specify the project\n\ttree In_Tree in the call to function Empty_Process to give its initial\n\tvalue to the project data Processed_Data.\n\tAdd new parameters In_Tree to designate the project tree and\n\tFrom_Project_Node_Tree to designate the project node tree to several\n\tsubprograms. Adapt to change in project manager with project tree\n\tIn_Tree and project node tree From_Project_Node_Tree.\n\n\t* prj-strt.ads, prj-strt.adb (Buffer, Buffer_Last): Global variables,\n\tto replace those that were in the private part of package Prj.\n\tAdd new parameter In_Tree to designate the project node tree to most\n\tsubprograms. Adapt to change in Prj.Tree with project node tree In_Tree.\n\n\t* prj-tree.ads, prj-tree.adb: Add new parameter of type\n\tProject_Node_Tree_Ref to most subprograms.\n\tUse this new parameter to store project nodes in the designated project\n\tnode tree.\n\t(Project_Node_Tree_Ref): New type to designate a project node tree\n\t(Tree_Private_Part): Change table to dynamic table and hash tables to\n\tdynamic hash tables.\n\n\t* prj-util.ads, prj-util.adb: Add new parameter In_Tree to designate\n\tthe project tree to most subprograms. Adapt to changes in project\n\tmanager using project tree In_Tree.\n\n\t* makegpr.adb (Project_Tree): New constant needed to use project\n\tmanager.\n\nFrom-SVN: r96481", "tree": {"sha": "cf1142dd403f99e75300ca6822d5c4d182a98b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1142dd403f99e75300ca6822d5c4d182a98b74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e98a4c668eac2b10f06ff207a24d2ca4e867128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98a4c668eac2b10f06ff207a24d2ca4e867128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e98a4c668eac2b10f06ff207a24d2ca4e867128", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98a4c668eac2b10f06ff207a24d2ca4e867128/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ca89db7aa51322aa15f6d89b692b20ad5898c89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca89db7aa51322aa15f6d89b692b20ad5898c89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca89db7aa51322aa15f6d89b692b20ad5898c89"}], "stats": {"total": 9064, "additions": 5507, "deletions": 3557}, "files": [{"sha": "6a53dbae6711f34b830605b4bfcb9d16adf21e1e", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -37,7 +37,6 @@ with Opt;      use Opt;\n with Osint;    use Osint;\n with Osint.M;  use Osint.M;\n with Prj;      use Prj;\n-with Prj.Com;\n with Prj.Env;\n with Prj.Ext;\n with Prj.Pars;\n@@ -92,6 +91,8 @@ package body Clean is\n \n    Project_File_Name : String_Access := null;\n \n+   Project_Tree : constant Prj.Project_Tree_Ref := new Prj.Project_Tree_Data;\n+\n    Main_Project : Prj.Project_Id := Prj.No_Project;\n \n    All_Projects : Boolean := False;\n@@ -328,7 +329,8 @@ package body Clean is\n \n    procedure Clean_Archive (Project : Project_Id) is\n       Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n-      Data        : constant Project_Data := Projects.Table (Project);\n+      Data        : constant Project_Data :=\n+                      Project_Tree.Projects.Table (Project);\n \n       Archive_Name : constant String :=\n                        \"lib\" & Get_Name_String (Data.Name) & '.' & Archive_Ext;\n@@ -560,8 +562,9 @@ package body Clean is\n       --  Name of the executable file\n \n       Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n-      Data        : constant Project_Data := Projects.Table (Project);\n-      U_Data      : Prj.Com.Unit_Data;\n+      Data        : constant Project_Data :=\n+                      Project_Tree.Projects.Table (Project);\n+      U_Data      : Unit_Data;\n       File_Name1  : Name_Id;\n       Index1      : Int;\n       File_Name2  : Name_Id;\n@@ -573,8 +576,6 @@ package body Clean is\n \n       Global_Archive : Boolean := False;\n \n-      use Prj.Com;\n-\n    begin\n       --  Check that we don't specify executable on the command line for\n       --  a main library project.\n@@ -612,8 +613,10 @@ package body Clean is\n             --  sources or inherited sources of the project.\n \n             if Data.Languages (Ada_Language_Index) then\n-               for Unit in 1 .. Prj.Com.Units.Last loop\n-                  U_Data := Prj.Com.Units.Table (Unit);\n+               for Unit in Unit_Table.First ..\n+                           Unit_Table.Last (Project_Tree.Units)\n+               loop\n+                  U_Data := Project_Tree.Units.Table (Unit);\n                   File_Name1 := No_Name;\n                   File_Name2 := No_Name;\n \n@@ -749,8 +752,12 @@ package body Clean is\n             if Project = Main_Project and then not Data.Library then\n                Global_Archive := False;\n \n-               for Proj in 1 .. Projects.Last loop\n-                  if Projects.Table (Proj).Other_Sources_Present then\n+               for Proj in Project_Table.First ..\n+                           Project_Table.Last (Project_Tree.Projects)\n+               loop\n+                  if Project_Tree.Projects.Table\n+                       (Proj).Other_Sources_Present\n+                  then\n                      Global_Archive := True;\n                      exit;\n                   end if;\n@@ -769,7 +776,8 @@ package body Clean is\n                Source_Id := Data.First_Other_Source;\n \n                while Source_Id /= No_Other_Source loop\n-                  Source := Other_Sources.Table (Source_Id);\n+                  Source :=\n+                    Project_Tree.Other_Sources.Table (Source_Id);\n \n                   if Is_Regular_File\n                        (Get_Name_String (Source.Object_Name))\n@@ -839,7 +847,7 @@ package body Clean is\n             --  has not been processed already.\n \n             while Imported /= Empty_Project_List loop\n-               Element := Project_Lists.Table (Imported);\n+               Element := Project_Tree.Project_Lists.Table (Imported);\n                Imported := Element.Next;\n                Process := True;\n \n@@ -887,6 +895,7 @@ package body Clean is\n                   Executable :=\n                     Executable_Of\n                       (Main_Project,\n+                       Project_Tree,\n                        Main_Source_File,\n                        Current_File_Index);\n \n@@ -1099,13 +1108,14 @@ package body Clean is\n          --  Set the project parsing verbosity to whatever was specified\n          --  by a possible -vP switch.\n \n-         Prj.Pars.Set_Verbosity (To => Prj.Com.Current_Verbosity);\n+         Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n \n          --  Parse the project file. If there is an error, Main_Project\n          --  will still be No_Project.\n \n          Prj.Pars.Parse\n            (Project           => Main_Project,\n+            In_Tree           => Project_Tree,\n             Project_File_Name => Project_File_Name.all,\n             Packages_To_Check => Packages_To_Check_By_Gnatmake);\n \n@@ -1121,12 +1131,10 @@ package body Clean is\n             New_Line;\n          end if;\n \n-         --  We add the source directories and the object directories\n-         --  to the search paths.\n-\n-         Add_Source_Directories (Main_Project);\n-         Add_Object_Directories (Main_Project);\n+         --  Add source directories and object directories to the search paths\n \n+         Add_Source_Directories (Main_Project, Project_Tree);\n+         Add_Object_Directories (Main_Project, Project_Tree);\n       end if;\n \n       Osint.Add_Default_Search_Dirs;\n@@ -1137,11 +1145,12 @@ package body Clean is\n \n       if Main_Project /= No_Project and then Osint.Number_Of_Files = 0 then\n          declare\n-            Value : String_List_Id := Projects.Table (Main_Project).Mains;\n+            Value : String_List_Id :=\n+                      Project_Tree.Projects.Table (Main_Project).Mains;\n             Main  : String_Element;\n          begin\n             while Value /= Prj.Nil_String loop\n-               Main := String_Elements.Table (Value);\n+               Main := Project_Tree.String_Elements.Table (Value);\n                Osint.Add_File\n                  (File_Name => Get_Name_String (Main.Value),\n                   Index     => Main.Index);\n@@ -1211,24 +1220,24 @@ package body Clean is\n          return True;\n       end if;\n \n-      Data := Projects.Table (Of_Project);\n+      Data := Project_Tree.Projects.Table (Of_Project);\n \n       while Data.Extends /= No_Project loop\n          if Data.Extends = Prj then\n             return True;\n          end if;\n \n-         Data := Projects.Table (Data.Extends);\n+         Data := Project_Tree.Projects.Table (Data.Extends);\n       end loop;\n \n-      Data := Projects.Table (Prj);\n+      Data := Project_Tree.Projects.Table (Prj);\n \n       while Data.Extends /= No_Project loop\n          if Data.Extends = Of_Project then\n             return True;\n          end if;\n \n-         Data := Projects.Table (Data.Extends);\n+         Data := Project_Tree.Projects.Table (Data.Extends);\n       end loop;\n \n       return False;\n@@ -1258,7 +1267,7 @@ package body Clean is\n          Csets.Initialize;\n          Namet.Initialize;\n          Snames.Initialize;\n-         Prj.Initialize;\n+         Prj.Initialize (Project_Tree);\n       end if;\n \n       --  Reset global variables\n@@ -1480,13 +1489,13 @@ package body Clean is\n                            Verbose_Mode := True;\n \n                         elsif Arg = \"-vP0\" then\n-                           Prj.Com.Current_Verbosity := Prj.Default;\n+                           Current_Verbosity := Prj.Default;\n \n                         elsif Arg = \"-vP1\" then\n-                           Prj.Com.Current_Verbosity := Prj.Medium;\n+                           Current_Verbosity := Prj.Medium;\n \n                         elsif Arg = \"-vP2\" then\n-                           Prj.Com.Current_Verbosity := Prj.High;\n+                           Current_Verbosity := Prj.High;\n \n                         else\n                            Bad_Argument;"}, {"sha": "31646586e592ad93d8b4fde21280a90874f40e6b", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 67, "deletions": 43, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,6 @@ with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;\n with Prj;      use Prj;\n-with Prj.Com;\n with Prj.Env;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Pars;\n@@ -57,6 +56,7 @@ with Table;\n with VMS_Conv; use VMS_Conv;\n \n procedure GNATCmd is\n+   Project_Tree      : constant Project_Tree_Ref := new Project_Tree_Data;\n    Project_File      : String_Access;\n    Project           : Prj.Project_Id;\n    Current_Verbosity : Prj.Verbosity := Prj.Default;\n@@ -244,7 +244,7 @@ procedure GNATCmd is\n \n    procedure Check_Files is\n       Add_Sources : Boolean := True;\n-      Unit_Data   : Prj.Com.Unit_Data;\n+      Unit_Data   : Prj.Unit_Data;\n       Subunit     : Boolean := False;\n \n    begin\n@@ -263,11 +263,11 @@ procedure GNATCmd is\n       if Add_Sources then\n          declare\n             Current_Last : constant Integer := Last_Switches.Last;\n-            use Prj.Com;\n-\n          begin\n-            for Unit in 1 .. Prj.Com.Units.Last loop\n-               Unit_Data := Prj.Com.Units.Table (Unit);\n+            for Unit in Unit_Table.First ..\n+                        Unit_Table.Last (Project_Tree.Units)\n+            loop\n+               Unit_Data := Project_Tree.Units.Table (Unit);\n \n                --  For gnatls, we only need to put the library units,\n                --  body or spec, but not the subunits.\n@@ -338,7 +338,7 @@ procedure GNATCmd is\n                   --  For gnatpp and gnatmetric, put all sources\n                   --  of the project.\n \n-                  for Kind in Prj.Com.Spec_Or_Body loop\n+                  for Kind in Spec_Or_Body loop\n \n                      --  Put only sources that belong to the main\n                      --  project.\n@@ -430,15 +430,16 @@ procedure GNATCmd is\n \n       elsif The_Command = Metric then\n          declare\n-            Data : Project_Data := Projects.Table (Root_Project);\n+            Data : Project_Data :=\n+                     Project_Tree.Projects.Table (Root_Project);\n \n          begin\n             while Data.Extends /= No_Project loop\n                if Project = Data.Extends then\n                   return True;\n                end if;\n \n-               Data := Projects.Table (Data.Extends);\n+               Data := Project_Tree.Projects.Table (Data.Extends);\n             end loop;\n          end;\n       end if;\n@@ -464,7 +465,7 @@ procedure GNATCmd is\n             end if;\n          end loop;\n \n-         Get_Name_String (Projects.Table\n+         Get_Name_String (Project_Tree.Projects.Table\n                             (Project).Exec_Directory);\n \n          if Name_Buffer (Name_Len) /= Directory_Separator then\n@@ -487,8 +488,8 @@ procedure GNATCmd is\n    function Configuration_Pragmas_File return Name_Id is\n    begin\n       Prj.Env.Create_Config_Pragmas_File\n-        (Project, Project, Include_Config_Files => False);\n-      return Projects.Table (Project).Config_File_Name;\n+        (Project, Project, Project_Tree, Include_Config_Files => False);\n+      return Project_Tree.Projects.Table (Project).Config_File_Name;\n    end Configuration_Pragmas_File;\n \n    ------------------------------\n@@ -501,19 +502,25 @@ procedure GNATCmd is\n    begin\n       if not Keep_Temporary_Files then\n          if Project /= No_Project then\n-            for Prj in 1 .. Projects.Last loop\n-               if Projects.Table (Prj).Config_File_Temp then\n+            for Prj in Project_Table.First ..\n+                       Project_Table.Last (Project_Tree.Projects)\n+            loop\n+               if\n+                 Project_Tree.Projects.Table (Prj).Config_File_Temp\n+               then\n                   if Verbose_Mode then\n                      Output.Write_Str (\"Deleting temp configuration file \"\"\");\n                      Output.Write_Str\n                        (Get_Name_String\n-                          (Projects.Table (Prj).Config_File_Name));\n+                          (Project_Tree.Projects.Table\n+                             (Prj).Config_File_Name));\n                      Output.Write_Line (\"\"\"\");\n                   end if;\n \n                   Delete_File\n                     (Name    => Get_Name_String\n-                       (Projects.Table (Prj).Config_File_Name),\n+                       (Project_Tree.Projects.Table\n+                          (Prj).Config_File_Name),\n                      Success => Success);\n                end if;\n             end loop;\n@@ -568,7 +575,7 @@ procedure GNATCmd is\n       --  Check if there are library project files\n \n       if MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None then\n-         Set_Libraries (Project, There_Are_Libraries);\n+         Set_Libraries (Project, Project_Tree, There_Are_Libraries);\n       end if;\n \n       --  If there are, add the necessary additional switches\n@@ -729,8 +736,8 @@ procedure GNATCmd is\n                         declare\n                            Dir : constant String :=\n                                    Get_Name_String\n-                                     (Projects.Table (Prj).\n-                                              Object_Directory);\n+                                     (Project_Tree.Projects.Table\n+                                        (Prj).Object_Directory);\n                         begin\n                            if Is_Regular_File\n                                 (Dir &\n@@ -754,7 +761,8 @@ procedure GNATCmd is\n                         --  Go to the project being extended,\n                         --  if any.\n \n-                        Prj := Projects.Table (Prj).Extends;\n+                        Prj :=\n+                          Project_Tree.Projects.Table (Prj).Extends;\n                         exit Project_Loop when Prj = No_Project;\n                      end loop Project_Loop;\n                   end if;\n@@ -811,7 +819,8 @@ procedure GNATCmd is\n                   Last_Switches.Table (Last_Switches.Last) :=\n                     new String'(\"-o\");\n                   Get_Name_String\n-                    (Projects.Table (Project).Exec_Directory);\n+                    (Project_Tree.Projects.Table\n+                       (Project).Exec_Directory);\n                   Last_Switches.Increment_Last;\n                   Last_Switches.Table (Last_Switches.Last) :=\n                     new String'(Name_Buffer (1 .. Name_Len) &\n@@ -839,7 +848,7 @@ procedure GNATCmd is\n    begin\n       --  Case of library project\n \n-      if Projects.Table (Project).Library then\n+      if Project_Tree.Projects.Table (Project).Library then\n          There_Are_Libraries := True;\n \n          --  Add the -L switch\n@@ -848,26 +857,30 @@ procedure GNATCmd is\n          Last_Switches.Table (Last_Switches.Last) :=\n            new String'(\"-L\" &\n                        Get_Name_String\n-                       (Projects.Table (Project).Library_Dir));\n+                         (Project_Tree.Projects.Table\n+                            (Project).Library_Dir));\n \n          --  Add the -l switch\n \n          Last_Switches.Increment_Last;\n          Last_Switches.Table (Last_Switches.Last) :=\n            new String'(\"-l\" &\n                        Get_Name_String\n-                       (Projects.Table (Project).Library_Name));\n+                         (Project_Tree.Projects.Table\n+                            (Project).Library_Name));\n \n          --  Add the directory to table Library_Paths, to be processed later\n          --  if library is not static and if Path_Option is not null.\n \n-         if Projects.Table (Project).Library_Kind /= Static\n+         if Project_Tree.Projects.Table (Project).Library_Kind /=\n+              Static\n            and then Path_Option /= null\n          then\n             Library_Paths.Increment_Last;\n             Library_Paths.Table (Library_Paths.Last) :=\n               new String'(Get_Name_String\n-                            (Projects.Table (Project).Library_Dir));\n+                            (Project_Tree.Projects.Table\n+                               (Project).Library_Dir));\n          end if;\n       end if;\n    end Set_Library_For;\n@@ -988,7 +1001,7 @@ begin\n \n    Snames.Initialize;\n \n-   Prj.Initialize;\n+   Prj.Initialize (Project_Tree);\n \n    Last_Switches.Init;\n    Last_Switches.Set_Last (0);\n@@ -1297,6 +1310,7 @@ begin\n \n             Prj.Pars.Parse\n               (Project           => Project,\n+               In_Tree           => Project_Tree,\n                Project_File_Name => Project_File.all,\n                Packages_To_Check => All_Packages);\n \n@@ -1531,6 +1545,7 @@ begin\n \n          Prj.Pars.Parse\n            (Project           => Project,\n+            In_Tree           => Project_Tree,\n             Project_File_Name => Project_File.all,\n             Packages_To_Check => Packages_To_Check);\n \n@@ -1543,12 +1558,13 @@ begin\n \n          declare\n             Data : constant Prj.Project_Data :=\n-                     Prj.Projects.Table (Project);\n+                     Project_Tree.Projects.Table (Project);\n \n             Pkg : constant Prj.Package_Id :=\n                     Prj.Util.Value_Of\n                       (Name        => Tool_Package_Name,\n-                       In_Packages => Data.Decl.Packages);\n+                       In_Packages => Data.Decl.Packages,\n+                       In_Tree     => Project_Tree);\n \n             Element : Package_Element;\n \n@@ -1560,7 +1576,7 @@ begin\n \n          begin\n             if Pkg /= No_Package then\n-               Element := Packages.Table (Pkg);\n+               Element := Project_Tree.Packages.Table (Pkg);\n \n                --  Packages Gnatls has a single attribute Switches, that is\n                --  not an associative array.\n@@ -1569,7 +1585,8 @@ begin\n                   The_Switches :=\n                     Prj.Util.Value_Of\n                     (Variable_Name => Snames.Name_Switches,\n-                     In_Variables => Element.Decl.Attributes);\n+                     In_Variables  => Element.Decl.Attributes,\n+                     In_Tree       => Project_Tree);\n \n                --  Packages Binder (for gnatbind), Cross_Reference (for\n                --  gnatxref), Linker (for gnatlink) Finder (for gnatfind),\n@@ -1584,12 +1601,14 @@ begin\n                   if The_Switches.Kind = Prj.Undefined then\n                      Default_Switches_Array :=\n                        Prj.Util.Value_Of\n-                         (Name => Name_Default_Switches,\n-                          In_Arrays => Element.Decl.Arrays);\n+                         (Name      => Name_Default_Switches,\n+                          In_Arrays => Element.Decl.Arrays,\n+                          In_Tree   => Project_Tree);\n                      The_Switches := Prj.Util.Value_Of\n                        (Index     => Name_Ada,\n                         Src_Index => 0,\n-                        In_Array  => Default_Switches_Array);\n+                        In_Array  => Default_Switches_Array,\n+                        In_Tree   => Project_Tree);\n                   end if;\n                end if;\n \n@@ -1616,7 +1635,8 @@ begin\n                   when Prj.List =>\n                      Current := The_Switches.Values;\n                      while Current /= Prj.Nil_String loop\n-                        The_String := String_Elements.Table (Current);\n+                        The_String := Project_Tree.String_Elements.\n+                                        Table (Current);\n \n                         declare\n                            Switch : constant String :=\n@@ -1642,12 +1662,14 @@ begin\n          then\n             Change_Dir\n               (Get_Name_String\n-                 (Projects.Table (Project).Object_Directory));\n+                 (Project_Tree.Projects.Table\n+                    (Project).Object_Directory));\n          end if;\n \n          --  Set up the env vars for project path files\n \n-         Prj.Env.Set_Ada_Paths (Project, Including_Libraries => False);\n+         Prj.Env.Set_Ada_Paths\n+           (Project, Project_Tree, Including_Libraries => False);\n \n          --  For gnatstub, gnatmetric, gnatpp and gnatelim, create\n          --  a configuration pragmas file, if necessary.\n@@ -1714,7 +1736,8 @@ begin\n                  (Last_Switches.Table (J), Current_Work_Dir);\n             end loop;\n \n-            Get_Name_String (Projects.Table (Project).Directory);\n+            Get_Name_String\n+              (Project_Tree.Projects.Table (Project).Directory);\n \n             declare\n                Project_Dir : constant String := Name_Buffer (1 .. Name_Len);\n@@ -1729,7 +1752,7 @@ begin\n          elsif The_Command = Stub then\n             declare\n                Data : constant Prj.Project_Data :=\n-                        Prj.Projects.Table (Project);\n+                        Project_Tree.Projects.Table (Project);\n                File_Index : Integer := 0;\n                Dir_Index  : Integer := 0;\n                Last       : constant Integer := Last_Switches.Last;\n@@ -1815,7 +1838,8 @@ begin\n             First_Switches.Table (1) :=\n               new String'(\"-d=\" &\n                           Get_Name_String\n-                            (Projects.Table (Project).Object_Directory));\n+                            (Project_Tree.Projects.Table\n+                               (Project).Object_Directory));\n          end if;\n \n          --  For gnat pretty and gnat metric, if no file has been put on the\n@@ -1890,12 +1914,12 @@ begin\n \n exception\n    when Error_Exit =>\n-      Prj.Env.Delete_All_Path_Files;\n+      Prj.Env.Delete_All_Path_Files (Project_Tree);\n       Delete_Temp_Config_Files;\n       Set_Exit_Status (Failure);\n \n    when Normal_Exit =>\n-      Prj.Env.Delete_All_Path_Files;\n+      Prj.Env.Delete_All_Path_Files (Project_Tree);\n       Delete_Temp_Config_Files;\n \n       --  Since GNATCmd is normally called from DCL (the VMS shell),"}, {"sha": "71f95c495ca2da4ef15b95810602cd1fd977595c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 311, "deletions": 180, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -275,6 +275,8 @@ package body Make is\n    Current_Verbosity : Prj.Verbosity  := Prj.Default;\n    --  Verbosity to parse the project files\n \n+   Project_Tree : constant Project_Tree_Ref := new Project_Tree_Data;\n+\n    Main_Project : Prj.Project_Id := No_Project;\n    --  The project id of the main project file, if any\n \n@@ -943,7 +945,8 @@ package body Make is\n            (Source_File      => Name_Find,\n             Source_File_Name => File_Name,\n             Source_Index     => Index,\n-            Naming           => Projects.Table (Main_Project).Naming,\n+            Naming           => Project_Tree.Projects.Table\n+                                  (Main_Project).Naming,\n             In_Package       => The_Package,\n             Allow_ALI        =>\n               Program = Binder or else Program = Linker);\n@@ -958,7 +961,8 @@ package body Make is\n                Switch_List := Switches.Values;\n \n                while Switch_List /= Nil_String loop\n-                  Element := String_Elements.Table (Switch_List);\n+                  Element :=\n+                    Project_Tree.String_Elements.Table (Switch_List);\n                   Get_Name_String (Element.Value);\n \n                   if Name_Len > 0 then\n@@ -1073,15 +1077,18 @@ package body Make is\n \n          if Project /= No_Project then\n             Change_Dir\n-              (Get_Name_String (Projects.Table (Project).Object_Directory));\n+              (Get_Name_String\n+                 (Project_Tree.Projects.Table\n+                    (Project).Object_Directory));\n \n          --  Otherwise, for sources outside of any project, set the working\n          --  directory to the object directory of the main project.\n \n          elsif Main_Project /= No_Project then\n             Change_Dir\n               (Get_Name_String\n-                 (Projects.Table (Main_Project).Object_Directory));\n+                 (Project_Tree.Projects.Table\n+                    (Main_Project).Object_Directory));\n          end if;\n       end if;\n    end Change_To_Object_Directory;\n@@ -1716,7 +1723,8 @@ package body Make is\n               Get_Reference\n               (Source_File_Name => Source_File_Name,\n                Project          => Arguments_Project,\n-               Path             => Arguments_Path_Name);\n+               Path             => Arguments_Path_Name,\n+               In_Tree          => Project_Tree);\n \n             --  If the source is not a source of a project file, check if\n             --  this is allowed.\n@@ -1736,14 +1744,15 @@ package body Make is\n                --  We get the project directory for the relative path\n                --  switches and arguments.\n \n-               Data := Projects.Table (Arguments_Project);\n+               Data := Project_Tree.Projects.Table (Arguments_Project);\n \n                --  If the source is in an extended project, we go to\n                --  the ultimate extending project.\n \n                while Data.Extended_By /= No_Project loop\n                   Arguments_Project := Data.Extended_By;\n-                  Data := Projects.Table (Arguments_Project);\n+                  Data :=\n+                    Project_Tree.Projects.Table (Arguments_Project);\n                end loop;\n \n                --  If building a dynamic or relocatable library, compile with\n@@ -1763,7 +1772,8 @@ package body Make is\n                if Data.Dir_Path = null then\n                   Data.Dir_Path :=\n                     new String'(Get_Name_String (Data.Display_Directory));\n-                  Projects.Table (Arguments_Project) := Data;\n+                  Project_Tree.Projects.Table (Arguments_Project) :=\n+                    Data;\n                end if;\n \n                --  We now look for package Compiler\n@@ -1772,7 +1782,8 @@ package body Make is\n                Compiler_Package :=\n                  Prj.Util.Value_Of\n                    (Name        => Name_Compiler,\n-                    In_Packages => Data.Decl.Packages);\n+                    In_Packages => Data.Decl.Packages,\n+                    In_Tree     => Project_Tree);\n \n                if Compiler_Package /= No_Package then\n \n@@ -1804,7 +1815,8 @@ package body Make is\n \n                      begin\n                         while Current /= Nil_String loop\n-                           Element := String_Elements.Table (Current);\n+                           Element := Project_Tree.String_Elements.\n+                                        Table (Current);\n                            Number  := Number + 1;\n                            Current := Element.Next;\n                         end loop;\n@@ -1816,7 +1828,8 @@ package body Make is\n                            Current := Switches.Values;\n \n                            for Index in New_Args'Range loop\n-                              Element := String_Elements.Table (Current);\n+                              Element := Project_Tree.String_Elements.\n+                                           Table (Current);\n                               Get_Name_String (Element.Value);\n                               New_Args (Index) :=\n                                 new String'(Name_Buffer (1 .. Name_Len));\n@@ -2221,22 +2234,26 @@ package body Make is\n          --  check for an eventual library project, and use the full path.\n \n          if Arguments_Project /= No_Project then\n-            if not Projects.Table (Arguments_Project).Externally_Built then\n-               Prj.Env.Set_Ada_Paths (Arguments_Project, True);\n+            if not Project_Tree.Projects.Table\n+                     (Arguments_Project).Externally_Built\n+            then\n+               Prj.Env.Set_Ada_Paths\n+                 (Arguments_Project, Project_Tree, True);\n \n                if not Unique_Compile\n                  and then MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None\n                then\n                   declare\n                      The_Data : Project_Data :=\n-                                  Projects.Table (Arguments_Project);\n+                                  Project_Tree.Projects.Table\n+                                    (Arguments_Project);\n \n                      Prj : Project_Id := Arguments_Project;\n \n                   begin\n                      while The_Data.Extended_By /= No_Project loop\n                         Prj := The_Data.Extended_By;\n-                        The_Data := Projects.Table (Prj);\n+                        The_Data := Project_Tree.Projects.Table (Prj);\n                      end loop;\n \n                      if The_Data.Library\n@@ -2252,7 +2269,8 @@ package body Make is\n \n                         --  Now mark the project as processed\n \n-                        Projects.Table (Prj).Need_To_Build_Lib := True;\n+                        Project_Tree.Projects.Table\n+                          (Prj).Need_To_Build_Lib := True;\n                      end if;\n                   end;\n                end if;\n@@ -3006,7 +3024,9 @@ package body Make is\n             else\n                declare\n                   Parent_Directory : constant String :=\n-                    Get_Name_String (Projects.Table (Project).Directory);\n+                    Get_Name_String\n+                      (Project_Tree.Projects.Table\n+                           (Project).Directory);\n \n                begin\n                   if Parent_Directory (Parent_Directory'Last) =\n@@ -3025,34 +3045,42 @@ package body Make is\n    --  Start of processing for Configuration_Pragmas_Switch\n \n    begin\n-      Prj.Env.Create_Config_Pragmas_File (For_Project, Main_Project);\n+      Prj.Env.Create_Config_Pragmas_File\n+        (For_Project, Main_Project, Project_Tree);\n \n-      if Projects.Table (For_Project).Config_File_Name /= No_Name then\n+      if Project_Tree.Projects.Table\n+           (For_Project).Config_File_Name /= No_Name\n+      then\n          Temporary_Config_File :=\n-           Projects.Table (For_Project).Config_File_Temp;\n+           Project_Tree.Projects.Table (For_Project).Config_File_Temp;\n          Last := 1;\n          Result (1) :=\n            new String'\n                  (\"-gnatec=\" &\n                   Get_Name_String\n-                    (Projects.Table (For_Project).Config_File_Name));\n+                    (Project_Tree.Projects.Table\n+                       (For_Project).Config_File_Name));\n \n       else\n          Temporary_Config_File := False;\n       end if;\n \n       --  Check for attribute Builder'Global_Configuration_Pragmas\n \n-      The_Packages := Projects.Table (Main_Project).Decl.Packages;\n+      The_Packages := Project_Tree.Projects.Table\n+                        (Main_Project).Decl.Packages;\n       Gnatmake :=\n         Prj.Util.Value_Of\n           (Name        => Name_Builder,\n-           In_Packages => The_Packages);\n+           In_Packages => The_Packages,\n+           In_Tree     => Project_Tree);\n \n       if Gnatmake /= No_Package then\n          Global_Attribute := Prj.Util.Value_Of\n            (Variable_Name => Name_Global_Configuration_Pragmas,\n-            In_Variables => Packages.Table (Gnatmake).Decl.Attributes);\n+            In_Variables  => Project_Tree.Packages.Table\n+                               (Gnatmake).Decl.Attributes,\n+            In_Tree       => Project_Tree);\n          Global_Attribute_Present :=\n            Global_Attribute /= Nil_Variable_Value\n            and then Get_Name_String (Global_Attribute.Value) /= \"\";\n@@ -3076,16 +3104,20 @@ package body Make is\n \n       --  Check for attribute Compiler'Local_Configuration_Pragmas\n \n-      The_Packages := Projects.Table (For_Project).Decl.Packages;\n+      The_Packages :=\n+        Project_Tree.Projects.Table (For_Project).Decl.Packages;\n       Compiler :=\n         Prj.Util.Value_Of\n           (Name        => Name_Compiler,\n-           In_Packages => The_Packages);\n+           In_Packages => The_Packages,\n+           In_Tree     => Project_Tree);\n \n       if Compiler /= No_Package then\n          Local_Attribute := Prj.Util.Value_Of\n            (Variable_Name => Name_Local_Configuration_Pragmas,\n-            In_Variables => Packages.Table (Compiler).Decl.Attributes);\n+            In_Variables  => Project_Tree.Packages.Table\n+                               (Compiler).Decl.Attributes,\n+            In_Tree       => Project_Tree);\n          Local_Attribute_Present :=\n            Local_Attribute /= Nil_Variable_Value\n            and then Get_Name_String (Local_Attribute.Value) /= \"\";\n@@ -3134,7 +3166,7 @@ package body Make is\n       if Gnatmake_Called and not Debug.Debug_Flag_N then\n          Delete_Mapping_Files;\n          Delete_Temp_Config_Files;\n-         Prj.Env.Delete_All_Path_Files;\n+         Prj.Env.Delete_All_Path_Files (Project_Tree);\n       end if;\n    end Delete_All_Temp_Files;\n \n@@ -3167,28 +3199,37 @@ package body Make is\n       Success : Boolean;\n    begin\n       if (not Debug.Debug_Flag_N) and Main_Project /= No_Project then\n-         for Project in 1 .. Projects.Last loop\n-            if Projects.Table (Project).Config_File_Temp then\n+         for Project in Project_Table.First ..\n+                        Project_Table.Last (Project_Tree.Projects)\n+         loop\n+            if\n+              Project_Tree.Projects.Table (Project).Config_File_Temp\n+            then\n                if Verbose_Mode then\n                   Write_Str (\"Deleting temp configuration file \"\"\");\n                   Write_Str (Get_Name_String\n-                             (Projects.Table (Project).Config_File_Name));\n+                               (Project_Tree.Projects.Table\n+                                  (Project).Config_File_Name));\n                   Write_Line (\"\"\"\");\n                end if;\n \n                Delete_File\n                  (Name    => Get_Name_String\n-                  (Projects.Table (Project).Config_File_Name),\n+                               (Project_Tree.Projects.Table\n+                                  (Project).Config_File_Name),\n                   Success => Success);\n \n                --  Make sure that we don't have a config file for this\n                --  project, in case when there are several mains.\n                --  In this case, we will recreate another config file:\n                --  we cannot reuse the one that we just deleted!\n \n-               Projects.Table (Project).Config_Checked   := False;\n-               Projects.Table (Project).Config_File_Name := No_Name;\n-               Projects.Table (Project).Config_File_Temp := False;\n+               Project_Tree.Projects.Table (Project).\n+                 Config_Checked := False;\n+               Project_Tree.Projects.Table (Project).\n+                 Config_File_Name := No_Name;\n+               Project_Tree.Projects.Table (Project).\n+                 Config_File_Temp := False;\n             end if;\n          end loop;\n       end if;\n@@ -3446,7 +3487,8 @@ package body Make is\n \n                --  Get the project of the current main\n \n-               Proj := Prj.Env.Project_Of (File_Name, Main_Project);\n+               Proj := Prj.Env.Project_Of\n+                         (File_Name, Main_Project, Project_Tree);\n \n                --  Fail if the current main is not a source of a\n                --  project.\n@@ -3462,7 +3504,8 @@ package body Make is\n                   --  is the actual path of a source of a project.\n \n                   if Main /= File_Name then\n-                     Data := Projects.Table (Main_Project);\n+                     Data :=\n+                       Project_Tree.Projects.Table (Main_Project);\n \n                      Real_Path :=\n                        Locate_Regular_File\n@@ -3496,6 +3539,7 @@ package body Make is\n                                          Prj.Env.File_Name_Of_Library_Unit_Body\n                                            (Name              => File_Name,\n                                             Project           => Main_Project,\n+                                            In_Tree           => Project_Tree,\n                                             Main_Project_Only => False,\n                                             Full_Path         => True);\n                         Normed_Path  : constant String :=\n@@ -3542,7 +3586,7 @@ package body Make is\n                           (\"\"\"\" & Main &\n                            \"\"\" is not a source of project \" &\n                            Get_Name_String\n-                             (Projects.Table\n+                             (Project_Tree.Projects.Table\n                                 (Real_Main_Project).Name));\n                      end if;\n                   end if;\n@@ -3591,12 +3635,12 @@ package body Make is\n \n             --  Traverse all units\n \n-            for J in Prj.Com.Units.First .. Prj.Com.Units.Last loop\n+            for J in Unit_Table.First ..\n+                     Unit_Table.Last (Project_Tree.Units)\n+            loop\n                declare\n-                  Unit : constant Prj.Com.Unit_Data :=\n-                           Prj.Com.Units.Table (J);\n-                  use Prj.Com;\n-\n+                  Unit : constant Unit_Data :=\n+                           Project_Tree.Units.Table (J);\n                begin\n                   if Unit.Name /= No_Name then\n \n@@ -3650,9 +3694,11 @@ package body Make is\n \n                      if ALI_Name /= No_Name\n                        and then\n-                         Projects.Table (ALI_Project).Extended_By = No_Project\n+                         Project_Tree.Projects.Table\n+                           (ALI_Project).Extended_By = No_Project\n                        and then\n-                         Projects.Table (ALI_Project).Extends = No_Project\n+                         Project_Tree.Projects.Table\n+                           (ALI_Project).Extends = No_Project\n                      then\n                         --  First line is the unit name\n \n@@ -3691,8 +3737,8 @@ package body Make is\n                                    Get_Name_String (ALI_Name);\n                         begin\n                            Get_Name_String\n-                             (Projects.Table (ALI_Project).\n-                                Object_Directory);\n+                             (Project_Tree.Projects.Table\n+                                (ALI_Project).Object_Directory);\n \n                            if Name_Buffer (Name_Len) /=\n                              Directory_Separator\n@@ -3792,7 +3838,7 @@ package body Make is\n \n          --  And the project file cannot be a library project file\n \n-         elsif Projects.Table (Main_Project).Library then\n+         elsif Project_Tree.Projects.Table (Main_Project).Library then\n             Make_Failed (\"-B cannot be used for a library project file\");\n \n          else\n@@ -3832,7 +3878,7 @@ package body Make is\n          --  cannot be specified on the command line.\n \n          if Osint.Number_Of_Files /= 0 then\n-            if Projects.Table (Main_Project).Library\n+            if Project_Tree.Projects.Table (Main_Project).Library\n               and then not Unique_Compile\n               and then ((not Make_Steps) or else Bind_Only or else Link_Only)\n             then\n@@ -3859,7 +3905,8 @@ package body Make is\n             end if;\n \n             declare\n-               Value : String_List_Id := Projects.Table (Main_Project).Mains;\n+               Value : String_List_Id :=\n+                 Project_Tree.Projects.Table (Main_Project).Mains;\n \n             begin\n                --  The attribute Main is an empty list or not specified,\n@@ -3868,7 +3915,8 @@ package body Make is\n                if Value = Prj.Nil_String or else Unique_Compile then\n \n                   if (not Make_Steps) or else Compile_Only\n-                    or else not Projects.Table (Main_Project).Library\n+                    or else not Project_Tree.Projects.Table\n+                                  (Main_Project).Library\n                   then\n                      --  First make sure that the binder and the linker\n                      --  will not be invoked.\n@@ -3900,11 +3948,13 @@ package body Make is\n \n                   declare\n                      Data : constant Project_Data :=\n-                              Projects.Table (Main_Project);\n+                           Project_Tree.Projects.Table (Main_Project);\n \n                      Languages : constant Variable_Value :=\n                                    Prj.Util.Value_Of\n-                                     (Name_Languages, Data.Decl.Attributes);\n+                                    (Name_Languages,\n+                                     Data.Decl.Attributes,\n+                                     Project_Tree);\n \n                      Current : String_List_Id;\n                      Element : String_Element;\n@@ -3921,7 +3971,8 @@ package body Make is\n \n                         Look_For_Foreign :\n                         while Current /= Nil_String loop\n-                           Element := String_Elements.Table (Current);\n+                           Element := Project_Tree.String_Elements.\n+                                        Table (Current);\n                            Get_Name_String (Element.Value);\n                            To_Lower (Name_Buffer (1 .. Name_Len));\n \n@@ -3938,25 +3989,33 @@ package body Make is\n                      --  language, all the Ada mains.\n \n                      while Value /= Prj.Nil_String loop\n-                        Get_Name_String (String_Elements.Table (Value).Value);\n+                        Get_Name_String\n+                          (Project_Tree.String_Elements.Table\n+                             (Value).Value);\n \n                         --  To know if a main is an Ada main, get its project.\n                         --  It should be the project specified on the command\n                         --  line.\n \n                         if (not Foreign_Language) or else\n                             Prj.Env.Project_Of\n-                              (Name_Buffer (1 .. Name_Len), Main_Project) =\n+                              (Name_Buffer (1 .. Name_Len),\n+                               Main_Project,\n+                               Project_Tree) =\n                              Main_Project\n                         then\n                            At_Least_One_Main := True;\n                            Osint.Add_File\n                              (Get_Name_String\n-                                (String_Elements.Table (Value).Value),\n-                              Index => String_Elements.Table (Value).Index);\n+                                (Project_Tree.String_Elements.Table\n+                                   (Value).Value),\n+                              Index =>\n+                                Project_Tree.String_Elements.Table\n+                                  (Value).Index);\n                         end if;\n \n-                        Value := String_Elements.Table (Value).Next;\n+                        Value := Project_Tree.String_Elements.Table\n+                                   (Value).Next;\n                      end loop;\n \n                      --  If we did not get any main, it means that all mains\n@@ -3984,18 +4043,20 @@ package body Make is\n       end if;\n \n       if Main_Project /= No_Project\n-        and then Projects.Table (Main_Project).Externally_Built\n+        and then Project_Tree.Projects.Table\n+                   (Main_Project).Externally_Built\n       then\n          Make_Failed\n            (\"nothing to do for a main project that is externally built\");\n       end if;\n \n       if Osint.Number_Of_Files = 0 then\n          if Main_Project /= No_Project\n-           and then Projects.Table (Main_Project).Library\n+           and then Project_Tree.Projects.Table (Main_Project).Library\n          then\n             if Do_Bind_Step\n-              and then not Projects.Table (Main_Project).Standalone_Library\n+              and then not Project_Tree.Projects.Table\n+                             (Main_Project).Standalone_Library\n             then\n                Make_Failed (\"only stand-alone libraries may be bound\");\n             end if;\n@@ -4008,6 +4069,7 @@ package body Make is\n \n             MLib.Prj.Build_Library\n               (For_Project   => Main_Project,\n+               In_Tree       => Project_Tree,\n                Gnatbind      => Gnatbind.all,\n                Gnatbind_Path => Gnatbind_Path,\n                Gcc           => Gcc.all,\n@@ -4079,10 +4141,10 @@ package body Make is\n \n       if Main_Project /= No_Project then\n \n-         if Projects.Table (Main_Project).Object_Directory /= No_Name then\n-\n-            --  Change the current directory to the object directory of\n-            --  the main project.\n+         if Project_Tree.Projects.Table\n+              (Main_Project).Object_Directory /= No_Name\n+         then\n+            --  Change current directory to object directory of main project\n \n             begin\n                Project_Object_Directory := No_Project;\n@@ -4098,7 +4160,7 @@ package body Make is\n                      Parent : constant Dir_Name_Str :=\n                                 Dir_Name\n                                   (Get_Name_String\n-                                     (Projects.Table\n+                                     (Project_Tree.Projects.Table\n                                         (Main_Project).Object_Directory));\n \n                      Dir  : Dir_Type;\n@@ -4134,7 +4196,8 @@ package body Make is\n                   Make_Failed\n                     (\"unable to change working directory to \"\"\",\n                      Get_Name_String\n-                       (Projects.Table (Main_Project).Object_Directory),\n+                       (Project_Tree.Projects.Table\n+                          (Main_Project).Object_Directory),\n                      \"\"\"\");\n             end;\n          end if;\n@@ -4153,26 +4216,30 @@ package body Make is\n                                       Prj.Env.File_Name_Of_Library_Unit_Body\n                                         (Name    => Main_Source_File_Name,\n                                          Project => Main_Project,\n+                                         In_Tree => Project_Tree,\n                                          Main_Project_Only =>\n                                            not Unique_Compile);\n \n             The_Packages : constant Package_Id :=\n-              Projects.Table (Main_Project).Decl.Packages;\n+              Project_Tree.Projects.Table (Main_Project).Decl.Packages;\n \n             Builder_Package : constant Prj.Package_Id :=\n                          Prj.Util.Value_Of\n                            (Name        => Name_Builder,\n-                            In_Packages => The_Packages);\n+                            In_Packages => The_Packages,\n+                            In_Tree     => Project_Tree);\n \n             Binder_Package : constant Prj.Package_Id :=\n                          Prj.Util.Value_Of\n                            (Name        => Name_Binder,\n-                            In_Packages => The_Packages);\n+                            In_Packages => The_Packages,\n+                            In_Tree     => Project_Tree);\n \n             Linker_Package : constant Prj.Package_Id :=\n                          Prj.Util.Value_Of\n-                           (Name       => Name_Linker,\n-                            In_Packages => The_Packages);\n+                           (Name        => Name_Linker,\n+                            In_Packages => The_Packages,\n+                            In_Tree     => Project_Tree);\n \n          begin\n             --  We fail if we cannot find the main source file\n@@ -4250,13 +4317,16 @@ package body Make is\n                          (Name                    => Name_Ada,\n                           Index                   => 0,\n                           Attribute_Or_Array_Name => Name_Default_Switches,\n-                          In_Package              => Builder_Package);\n+                          In_Package              => Builder_Package,\n+                          In_Tree                 => Project_Tree);\n \n                      Switches : constant Array_Element_Id :=\n                           Prj.Util.Value_Of\n                              (Name      => Name_Switches,\n                               In_Arrays =>\n-                                Packages.Table (Builder_Package).Decl.Arrays);\n+                                Project_Tree.Packages.Table\n+                                  (Builder_Package).Decl.Arrays,\n+                              In_Tree   => Project_Tree);\n \n                   begin\n                      if Defaults /= Nil_Variable_Value then\n@@ -4359,30 +4429,41 @@ package body Make is\n          if not Unique_Compile\n            and then MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None\n          then\n-            for Proj in Projects.First .. Projects.Last loop\n-               if Projects.Table (Proj).Library then\n-                  Projects.Table (Proj).Need_To_Build_Lib :=\n-                    (not MLib.Tgt.Library_Exists_For (Proj))\n-                    and then (not Projects.Table (Proj).Externally_Built);\n-\n-                  if Projects.Table (Proj).Need_To_Build_Lib then\n-\n+            for Proj in Project_Table.First ..\n+                        Project_Table.Last (Project_Tree.Projects)\n+            loop\n+               if Project_Tree.Projects.Table (Proj).Library then\n+                  Project_Tree.Projects.Table\n+                    (Proj).Need_To_Build_Lib :=\n+                      (not MLib.Tgt.Library_Exists_For (Proj, Project_Tree))\n+                    and then (not Project_Tree.Projects.Table\n+                                (Proj).Externally_Built);\n+\n+                  if Project_Tree.Projects.Table\n+                       (Proj).Need_To_Build_Lib\n+                  then\n                      --  If there is no object directory, then it will be\n                      --  impossible to build the library. So fail immediately.\n \n-                     if Projects.Table (Proj).Object_Directory = No_Name then\n+                     if Project_Tree.Projects.Table\n+                       (Proj).Object_Directory = No_Name\n+                     then\n                         Make_Failed\n                           (\"no object files to build library for project \"\"\",\n-                           Get_Name_String (Projects.Table (Proj).Name),\n+                           Get_Name_String\n+                             (Project_Tree.Projects.Table (Proj).Name),\n                            \"\"\"\");\n-                        Projects.Table (Proj).Need_To_Build_Lib := False;\n+                        Project_Tree.Projects.Table\n+                          (Proj).Need_To_Build_Lib := False;\n \n                      else\n                         if Verbose_Mode then\n                            Write_Str\n                              (\"Library file does not exist for project \"\"\");\n                            Write_Str\n-                             (Get_Name_String (Projects.Table (Proj).Name));\n+                             (Get_Name_String\n+                                (Project_Tree.Projects.Table\n+                                   (Proj).Name));\n                            Write_Line (\"\"\"\");\n                         end if;\n \n@@ -4416,8 +4497,9 @@ package body Make is\n                         end if;\n                      end loop;\n \n-                     Get_Name_String (Projects.Table\n-                                        (Main_Project).Exec_Directory);\n+                     Get_Name_String\n+                       (Project_Tree.Projects.Table\n+                          (Main_Project).Exec_Directory);\n \n                      if Name_Buffer (Name_Len) /= Directory_Separator then\n                         Name_Len := Name_Len + 1;\n@@ -4445,7 +4527,8 @@ package body Make is\n          declare\n             Dir_Path : constant String_Access :=\n               new String'(Get_Name_String\n-                            (Projects.Table (Main_Project).Directory));\n+                            (Project_Tree.Projects.Table\n+                               (Main_Project).Directory));\n          begin\n             for J in 1 .. Binder_Switches.Last loop\n                Test_If_Relative_Path\n@@ -4481,10 +4564,10 @@ package body Make is\n          end;\n       end if;\n \n-      --  We now put in the Binder_Switches and Linker_Switches tables,\n-      --  the binder and linker switches of the command line that have been\n-      --  put in the Saved_ tables. If a project file was used, then the\n-      --  command line switches will follow the project file switches.\n+      --  We now put in the Binder_Switches and Linker_Switches tables, the\n+      --  binder and linker switches of the command line that have been put in\n+      --  the Saved_ tables. If a project file was used, then the command line\n+      --  switches will follow the project file switches.\n \n       for J in 1 .. Saved_Binder_Switches.Last loop\n          Add_Switch\n@@ -4563,15 +4646,20 @@ package body Make is\n \n       The_Mapping_File_Names :=\n         new Temp_File_Names\n-              (No_Project .. Projects.Last, 1 .. Saved_Maximum_Processes);\n+          (No_Project .. Project_Table.Last (Project_Tree.Projects),\n+           1 .. Saved_Maximum_Processes);\n       Last_Mapping_File_Names :=\n-        new Indices'(No_Project .. Projects.Last => 0);\n+        new Indices'\n+          (No_Project .. Project_Table.Last (Project_Tree.Projects)\n+            => 0);\n \n       The_Free_Mapping_File_Indices :=\n         new Free_File_Indices\n-              (No_Project .. Projects.Last, 1 .. Saved_Maximum_Processes);\n+          (No_Project .. Project_Table.Last (Project_Tree.Projects),\n+           1 .. Saved_Maximum_Processes);\n       Last_Free_Indices :=\n-        new Indices'(No_Project .. Projects.Last => 0);\n+        new Indices'(No_Project .. Project_Table.Last\n+                                     (Project_Tree.Projects) => 0);\n \n       Bad_Compilation.Init;\n \n@@ -4632,8 +4720,9 @@ package body Make is\n                --  executable \"main.2\" for a main subprogram\n                --  \"main.2.ada\", when the body termination is \".2.ada\".\n \n-               Executable := Prj.Util.Executable_Of\n-                               (Main_Project, Main_Source_File, Main_Index);\n+               Executable :=\n+                 Prj.Util.Executable_Of\n+                   (Main_Project, Project_Tree, Main_Source_File, Main_Index);\n             end if;\n          end if;\n \n@@ -4653,7 +4742,7 @@ package body Make is\n                      end if;\n                   end loop;\n \n-                  Get_Name_String (Projects.Table\n+                  Get_Name_String (Project_Tree.Projects.Table\n                                            (Main_Project).Exec_Directory);\n \n                   if\n@@ -4752,37 +4841,47 @@ package body Make is\n                      --  Put in Library_Projs table all library project\n                      --  file ids when the library need to be rebuilt.\n \n-                     for Proj1 in Projects.First .. Projects.Last loop\n-\n-                        if Projects.Table (Proj1).Standalone_Library then\n+                     for Proj1 in Project_Table.First ..\n+                                  Project_Table.Last (Project_Tree.Projects)\n+                     loop\n+                        if Project_Tree.Projects.Table\n+                          (Proj1).Standalone_Library\n+                        then\n                            There_Are_Stand_Alone_Libraries := True;\n                         end if;\n \n-                        if Projects.Table (Proj1).Library\n-                          and then not Projects.Table (Proj1).Need_To_Build_Lib\n-                          and then not Projects.Table (Proj1).Externally_Built\n+                        if Project_Tree.Projects.Table (Proj1).Library\n+                          and then not Project_Tree.Projects.Table\n+                                         (Proj1).Need_To_Build_Lib\n+                          and then not Project_Tree.Projects.Table\n+                                         (Proj1).Externally_Built\n                         then\n-                           MLib.Prj.Check_Library (Proj1);\n+                           MLib.Prj.Check_Library (Proj1, Project_Tree);\n                         end if;\n \n-                        if Projects.Table (Proj1).Need_To_Build_Lib then\n+                        if Project_Tree.Projects.Table\n+                             (Proj1).Need_To_Build_Lib\n+                        then\n                            Library_Projs.Increment_Last;\n                            Current := Library_Projs.Last;\n-                           Depth := Projects.Table (Proj1).Depth;\n+                           Depth := Project_Tree.Projects.Table\n+                                      (Proj1).Depth;\n \n                            --  Put the projects in decreasing depth order,\n                            --  so that if libA depends on libB, libB is first\n                            --  in order.\n \n                            while Current > 1 loop\n                               Proj2 := Library_Projs.Table (Current - 1);\n-                              exit when Projects.Table (Proj2).Depth >= Depth;\n+                              exit when Project_Tree.Projects.Table\n+                                          (Proj2).Depth >= Depth;\n                               Library_Projs.Table (Current) := Proj2;\n                               Current := Current - 1;\n                            end loop;\n \n                            Library_Projs.Table (Current) := Proj1;\n-                           Projects.Table (Proj1).Need_To_Build_Lib := False;\n+                           Project_Tree.Projects.Table\n+                             (Proj1).Need_To_Build_Lib := False;\n                         end if;\n                      end loop;\n                   end;\n@@ -4793,6 +4892,7 @@ package body Make is\n                      Library_Rebuilt := True;\n                      MLib.Prj.Build_Library\n                        (For_Project   => Library_Projs.Table (J),\n+                        In_Tree       => Project_Tree,\n                         Gnatbind      => Gnatbind.all,\n                         Gnatbind_Path => Gnatbind_Path,\n                         Gcc           => Gcc.all,\n@@ -4994,9 +5094,12 @@ package body Make is\n                if Main_Project /= No_Project\n                  and then MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None\n                then\n-                  for Proj in Projects.First .. Projects.Last loop\n-                     if Projects.Table (Proj).Library and then\n-                       Projects.Table (Proj).Library_Kind /= Static\n+                  for Proj in Project_Table.First ..\n+                        Project_Table.Last (Project_Tree.Projects)\n+                  loop\n+                     if Project_Tree.Projects.Table (Proj).Library\n+                       and then Project_Tree.Projects.Table\n+                                  (Proj).Library_Kind /= Static\n                      then\n                         Shared_Libs := True;\n                         Bind_Shared := Shared_Switch'Access;\n@@ -5039,7 +5142,7 @@ package body Make is\n                   --  Put all the source directories in ADA_INCLUDE_PATH,\n                   --  and all the object directories in ADA_OBJECTS_PATH\n \n-                  Prj.Env.Set_Ada_Paths (Main_Project, False);\n+                  Prj.Env.Set_Ada_Paths (Main_Project, Project_Tree, False);\n \n                   --  If switch -C was specified, create a binder mapping file\n \n@@ -5103,14 +5206,18 @@ package body Make is\n                   if MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None then\n                      --  Check for library projects\n \n-                     for Proj1 in 1 .. Projects.Last loop\n+                     for Proj1 in Project_Table.First ..\n+                           Project_Table.Last (Project_Tree.Projects)\n+                     loop\n                         if Proj1 /= Main_Project\n-                          and then Projects.Table (Proj1).Library\n+                          and then\n+                            Project_Tree.Projects.Table (Proj1).Library\n                         then\n                            --  Add this project to table Library_Projs\n \n                            There_Are_Libraries := True;\n-                           Depth := Projects.Table (Proj1).Depth;\n+                           Depth :=\n+                             Project_Tree.Projects.Table (Proj1).Depth;\n                            Library_Projs.Increment_Last;\n                            Current := Library_Projs.Last;\n \n@@ -5119,7 +5226,8 @@ package body Make is\n \n                            while Current > 1 loop\n                               Proj2 := Library_Projs.Table (Current - 1);\n-                              exit when Projects.Table (Proj2).Depth <= Depth;\n+                              exit when Project_Tree.Projects.Table\n+                                          (Proj2).Depth <= Depth;\n                               Library_Projs.Table (Current) := Proj2;\n                               Current := Current - 1;\n                            end loop;\n@@ -5129,14 +5237,16 @@ package body Make is\n                            --  If it is not a static library and path option\n                            --  is set, add it to the Library_Paths table.\n \n-                           if Projects.Table (Proj1).Library_Kind /= Static\n+                           if Project_Tree.Projects.Table\n+                                (Proj1).Library_Kind /= Static\n                              and then Path_Option /= null\n                            then\n                               Library_Paths.Increment_Last;\n                               Library_Paths.Table (Library_Paths.Last) :=\n                                 new String'\n                                   (Get_Name_String\n-                                       (Projects.Table (Proj1).Library_Dir));\n+                                       (Project_Tree.Projects.Table\n+                                            (Proj1).Library_Dir));\n                            end if;\n                         end if;\n                      end loop;\n@@ -5148,7 +5258,7 @@ package body Make is\n                         Linker_Switches.Table (Linker_Switches.Last) :=\n                           new String'(\"-L\" &\n                                       Get_Name_String\n-                                        (Projects.Table\n+                                        (Project_Tree.Projects.Table\n                                            (Library_Projs.Table (Index)).\n                                               Library_Dir));\n \n@@ -5158,7 +5268,7 @@ package body Make is\n                         Linker_Switches.Table (Linker_Switches.Last) :=\n                           new String'(\"-l\" &\n                                       Get_Name_String\n-                                        (Projects.Table\n+                                        (Project_Tree.Projects.Table\n                                            (Library_Projs.Table (Index)).\n                                               Library_Name));\n                      end loop;\n@@ -5233,15 +5343,15 @@ package body Make is\n \n                   --  Put the object directories in ADA_OBJECTS_PATH\n \n-                  Prj.Env.Set_Ada_Paths (Main_Project, False);\n+                  Prj.Env.Set_Ada_Paths (Main_Project, Project_Tree, False);\n \n                   --  Check for attributes Linker'Linker_Options in projects\n                   --  other than the main project\n \n                   declare\n                      Linker_Options : constant String_List :=\n-                       Linker_Options_Switches (Main_Project);\n-\n+                                        Linker_Options_Switches\n+                                          (Main_Project, Project_Tree);\n                   begin\n                      for Option in Linker_Options'Range loop\n                         Linker_Switches.Increment_Last;\n@@ -5340,21 +5450,25 @@ package body Make is\n                                             File_Name_Of_Library_Unit_Body\n                                               (Name => Main_Source_File_Name,\n                                                Project => Main_Project,\n+                                               In_Tree => Project_Tree,\n                                                Main_Project_Only =>\n                                                  not Unique_Compile);\n \n                   The_Packages : constant Package_Id :=\n-                    Projects.Table (Main_Project).Decl.Packages;\n+                    Project_Tree.Projects.Table\n+                      (Main_Project).Decl.Packages;\n \n                   Binder_Package : constant Prj.Package_Id :=\n                                Prj.Util.Value_Of\n                                  (Name        => Name_Binder,\n-                                  In_Packages => The_Packages);\n+                                  In_Packages => The_Packages,\n+                                  In_Tree     => Project_Tree);\n \n                   Linker_Package : constant Prj.Package_Id :=\n                                Prj.Util.Value_Of\n-                                 (Name       => Name_Linker,\n-                                 In_Packages => The_Packages);\n+                                 (Name        => Name_Linker,\n+                                  In_Packages => The_Packages,\n+                                  In_Tree     => Project_Tree);\n \n                begin\n                   --  We fail if we cannot find the main source file\n@@ -5442,7 +5556,8 @@ package body Make is\n                   declare\n                      Dir_Path : constant String_Access :=\n                        new String'(Get_Name_String\n-                                    (Projects.Table (Main_Project).Directory));\n+                                     (Project_Tree.Projects.Table\n+                                        (Main_Project).Directory));\n                   begin\n                      for\n                        J in Last_Binder_Switch + 1 .. Binder_Switches.Last\n@@ -5516,7 +5631,7 @@ package body Make is\n \n       if not Debug.Debug_Flag_N then\n          Delete_Mapping_Files;\n-         Prj.Env.Delete_All_Path_Files;\n+         Prj.Env.Delete_All_Path_Files (Project_Tree);\n       end if;\n \n       Exit_Program (E_Success);\n@@ -5528,7 +5643,7 @@ package body Make is\n       when Compilation_Failed =>\n          if not Debug.Debug_Flag_N then\n             Delete_Mapping_Files;\n-            Prj.Env.Delete_All_Path_Files;\n+            Prj.Env.Delete_All_Path_Files (Project_Tree);\n          end if;\n \n          Exit_Program (E_Fatal);\n@@ -5605,7 +5720,7 @@ package body Make is\n \n       if Project /= No_Project then\n          Prj.Env.Create_Mapping_File\n-           (Project,\n+           (Project, Project_Tree,\n             The_Mapping_File_Names\n               (Project, Last_Mapping_File_Names (Project)));\n \n@@ -5669,7 +5784,7 @@ package body Make is\n \n       Snames.Initialize;\n \n-      Prj.Initialize;\n+      Prj.Initialize (Project_Tree);\n \n       Dependencies.Init;\n \n@@ -5789,6 +5904,7 @@ package body Make is\n \n          Prj.Pars.Parse\n            (Project           => Main_Project,\n+            In_Tree           => Project_Tree,\n             Project_File_Name => Project_File_Name.all,\n             Packages_To_Check => Packages_To_Check_By_Gnatmake);\n \n@@ -5807,14 +5923,16 @@ package body Make is\n          --  We add the source directories and the object directories\n          --  to the search paths.\n \n-         Add_Source_Directories (Main_Project);\n-         Add_Object_Directories (Main_Project);\n+         Add_Source_Directories (Main_Project, Project_Tree);\n+         Add_Object_Directories (Main_Project, Project_Tree);\n \n          --  Compute depth of each project\n \n-         for Proj in 1 .. Projects.Last loop\n-            Projects.Table (Proj).Seen := False;\n-            Projects.Table (Proj).Depth := 0;\n+         for Proj in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+         loop\n+            Project_Tree.Projects.Table (Proj).Seen := False;\n+            Project_Tree.Projects.Table (Proj).Depth := 0;\n          end loop;\n \n          Recursive_Compute_Depth\n@@ -5860,11 +5978,12 @@ package body Make is\n       Into_Q       : Boolean)\n    is\n       Put_In_Q : Boolean := Into_Q;\n-      Unit     : Com.Unit_Data;\n+      Unit     : Unit_Data;\n       Sfile    : Name_Id;\n \n       Extending : constant Boolean :=\n-                    Projects.Table (The_Project).Extends /= No_Project;\n+                    Project_Tree.Projects.Table\n+                      (The_Project).Extends /= No_Project;\n \n       function Check_Project (P : Project_Id) return Boolean;\n       --  Returns True if P is The_Project or a project extended by\n@@ -5880,15 +5999,16 @@ package body Make is\n             return True;\n          elsif Extending then\n             declare\n-               Data : Project_Data := Projects.Table (The_Project);\n+               Data : Project_Data :=\n+                        Project_Tree.Projects.Table (The_Project);\n \n             begin\n                loop\n                   if P = Data.Extends then\n                      return True;\n                   end if;\n \n-                  Data := Projects.Table (Data.Extends);\n+                  Data := Project_Tree.Projects.Table (Data.Extends);\n                   exit when Data.Extends = No_Project;\n                end loop;\n             end;\n@@ -5897,30 +6017,31 @@ package body Make is\n          return False;\n       end Check_Project;\n \n-   --  Start of processing of Insert_Project_Sources\n+   --  Start of processing for Insert_Project_Sources\n \n    begin\n       --  For all the sources in the project files,\n \n-      for Id in Com.Units.First .. Com.Units.Last loop\n-         Unit  := Com.Units.Table (Id);\n+      for Id in Unit_Table.First ..\n+                Unit_Table.Last (Project_Tree.Units)\n+      loop\n+         Unit  := Project_Tree.Units.Table (Id);\n          Sfile := No_Name;\n \n          --  If there is a source for the body, and the body has not been\n          --  locally removed,\n \n-         if Unit.File_Names (Com.Body_Part).Name /= No_Name\n-           and then Unit.File_Names (Com.Body_Part).Path /= Slash\n+         if Unit.File_Names (Body_Part).Name /= No_Name\n+           and then Unit.File_Names (Body_Part).Path /= Slash\n          then\n-\n             --  And it is a source for the specified project\n \n-            if Check_Project (Unit.File_Names (Com.Body_Part).Project) then\n+            if Check_Project (Unit.File_Names (Body_Part).Project) then\n \n                --  If we don't have a spec, we cannot consider the source\n                --  if it is a subunit\n \n-               if Unit.File_Names (Com.Specification).Name = No_Name then\n+               if Unit.File_Names (Specification).Name = No_Name then\n                   declare\n                      Src_Ind : Source_File_Index;\n \n@@ -5937,32 +6058,32 @@ package body Make is\n                   begin\n                      Src_Ind := Sinput.P.Load_Project_File\n                                   (Get_Name_String\n-                                     (Unit.File_Names (Com.Body_Part).Path));\n+                                     (Unit.File_Names (Body_Part).Path));\n \n                      --  If it is a subunit, discard it\n \n                      if Sinput.P.Source_File_Is_Subunit (Src_Ind) then\n                         Sfile := No_Name;\n \n                      else\n-                        Sfile := Unit.File_Names (Com.Body_Part).Name;\n+                        Sfile := Unit.File_Names (Body_Part).Name;\n                      end if;\n                   end;\n \n                else\n-                  Sfile := Unit.File_Names (Com.Body_Part).Name;\n+                  Sfile := Unit.File_Names (Body_Part).Name;\n                end if;\n             end if;\n \n-         elsif Unit.File_Names (Com.Specification).Name /= No_Name\n-           and then Unit.File_Names (Com.Specification).Path /= Slash\n-           and then Check_Project (Unit.File_Names (Com.Specification).Project)\n+         elsif Unit.File_Names (Specification).Name /= No_Name\n+           and then Unit.File_Names (Specification).Path /= Slash\n+           and then Check_Project (Unit.File_Names (Specification).Project)\n          then\n             --  If there is no source for the body, but there is a source\n             --  for the spec which has not been locally removed, then we take\n             --  this one.\n \n-            Sfile := Unit.File_Names (Com.Specification).Name;\n+            Sfile := Unit.File_Names (Specification).Name;\n          end if;\n \n          --  If Put_In_Q is True, we insert into the Q\n@@ -6090,7 +6211,7 @@ package body Make is\n          declare\n             Source_File_Name : constant String :=\n                                  Get_Name_String (Source_File);\n-            Saved_Verbosity  : constant Verbosity := Prj.Com.Current_Verbosity;\n+            Saved_Verbosity  : constant Verbosity := Current_Verbosity;\n             Project          : Project_Id := No_Project;\n             Path_Name        : Name_Id := No_Name;\n             Data             : Project_Data;\n@@ -6100,13 +6221,14 @@ package body Make is\n             --  the source. Call it with verbosity default to avoid verbose\n             --  messages.\n \n-            Prj.Com.Current_Verbosity := Default;\n+            Current_Verbosity := Default;\n             Prj.Env.\n               Get_Reference\n               (Source_File_Name => Source_File_Name,\n                Project          => Project,\n+               In_Tree          => Project_Tree,\n                Path             => Path_Name);\n-            Prj.Com.Current_Verbosity := Saved_Verbosity;\n+            Current_Verbosity := Saved_Verbosity;\n \n             --  If this source is in a project, check that the ALI file is\n             --  in its object directory. If it is not, return False, so that\n@@ -6116,9 +6238,10 @@ package body Make is\n             --  the general case and return True at the end of the function.\n \n             if Project /= No_Project\n-              and then Projects.Table (Project).Extends /= No_Project\n+              and then Project_Tree.Projects.Table\n+                         (Project).Extends /= No_Project\n             then\n-               Data := Projects.Table (Project);\n+               Data := Project_Tree.Projects.Table (Project);\n \n                declare\n                   Object_Directory : constant String :=\n@@ -6328,26 +6451,26 @@ package body Make is\n       --  been seen or if the depth is large enough.\n \n       if Project = No_Project\n-        or else Projects.Table (Project).Seen\n-        or else Projects.Table (Project).Depth >= Depth\n+        or else Project_Tree.Projects.Table (Project).Seen\n+        or else Project_Tree.Projects.Table (Project).Depth >= Depth\n       then\n          return;\n       end if;\n \n-      Projects.Table (Project).Depth := Depth;\n+      Project_Tree.Projects.Table (Project).Depth := Depth;\n \n       --  Mark the project as Seen to avoid endless loop caused by limited\n       --  withs.\n \n-      Projects.Table (Project).Seen := True;\n+      Project_Tree.Projects.Table (Project).Seen := True;\n \n-      List := Projects.Table (Project).Imported_Projects;\n+      List := Project_Tree.Projects.Table (Project).Imported_Projects;\n \n       --  Visit each imported project\n \n       while List /= Empty_Project_List loop\n-         Proj := Project_Lists.Table (List).Project;\n-         List := Project_Lists.Table (List).Next;\n+         Proj := Project_Tree.Project_Lists.Table (List).Project;\n+         List := Project_Tree.Project_Lists.Table (List).Next;\n          Recursive_Compute_Depth\n            (Project => Proj,\n             Depth => Depth + 1);\n@@ -6356,12 +6479,12 @@ package body Make is\n       --  Visit a project being extended, if any\n \n       Recursive_Compute_Depth\n-        (Project => Projects.Table (Project).Extends,\n+        (Project => Project_Tree.Projects.Table (Project).Extends,\n          Depth   => Depth + 1);\n \n       --  Reset the Seen flag, as we leave this project\n \n-      Projects.Table (Project).Seen := False;\n+      Project_Tree.Projects.Table (Project).Seen := False;\n    end Recursive_Compute_Depth;\n \n    -----------------------\n@@ -6976,20 +7099,25 @@ package body Make is\n                    Prj.Util.Value_Of\n                      (Name      => Name_Default_Switches,\n                       In_Arrays =>\n-                      Packages.Table (In_Package).Decl.Arrays);\n+                        Project_Tree.Packages.Table\n+                          (In_Package).Decl.Arrays,\n+                      In_Tree   => Project_Tree);\n \n       Switches_Array : constant Array_Element_Id :=\n                          Prj.Util.Value_Of\n                            (Name      => Name_Switches,\n                             In_Arrays =>\n-                              Packages.Table (In_Package).Decl.Arrays);\n+                              Project_Tree.Packages.Table\n+                                (In_Package).Decl.Arrays,\n+                            In_Tree   => Project_Tree);\n \n    begin\n       Switches :=\n         Prj.Util.Value_Of\n           (Index     => Source_File,\n            Src_Index => Source_Index,\n-           In_Array  => Switches_Array);\n+           In_Array  => Switches_Array,\n+           In_Tree   => Project_Tree);\n \n       if Switches = Nil_Variable_Value then\n          declare\n@@ -7028,7 +7156,8 @@ package body Make is\n                  Prj.Util.Value_Of\n                    (Index     => Name_Find,\n                     Src_Index => 0,\n-                    In_Array  => Switches_Array);\n+                    In_Array  => Switches_Array,\n+                    In_Tree   => Project_Tree);\n \n                if Switches = Nil_Variable_Value\n                  and then Allow_ALI\n@@ -7046,7 +7175,8 @@ package body Make is\n                     Prj.Util.Value_Of\n                       (Index     => Name_Find,\n                        Src_Index => 0,\n-                       In_Array  => Switches_Array);\n+                       In_Array  => Switches_Array,\n+                       In_Tree   => Project_Tree);\n                end if;\n             end if;\n          end;\n@@ -7057,7 +7187,8 @@ package body Make is\n            Prj.Util.Value_Of\n              (Index     => Name_Ada,\n               Src_Index => 0,\n-              In_Array  => Defaults);\n+              In_Array  => Defaults,\n+              In_Tree   => Project_Tree);\n       end if;\n \n       return Switches;"}, {"sha": "3cc8ad5e1734410d994e2338a93d1d074cfbf2a2", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 154, "deletions": 85, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--       Copyright (C) 2004-2005 Free Software Foundation, Inc.             --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,7 +46,6 @@ with Output;           use Output;\n with Opt;              use Opt;\n with Osint;            use Osint;\n with Prj;              use Prj;\n-with Prj.Com;          use Prj.Com;\n with Prj.Pars;\n with Prj.Util;         use Prj.Util;\n with Snames;           use Snames;\n@@ -168,6 +167,8 @@ package body Makegpr is\n    Packages_To_Check : constant String_List_Access := List_Of_Packages'Access;\n    --  List of the packages to be checked when parsing/processing project files\n \n+   Project_Tree : constant Project_Tree_Ref := new Project_Tree_Data;\n+\n    Main_Project : Project_Id;\n    --  The project id of the main project\n \n@@ -617,15 +618,15 @@ package body Makegpr is\n          --  Nothing to do when there is no project specified\n \n          if Project /= No_Project then\n-            Data := Projects.Table (Project);\n+            Data := Project_Tree.Projects.Table (Project);\n \n             --  Nothing to do if the project has already been processed\n \n             if not Data.Seen then\n \n                --  Mark the project as processed, to avoid processing it again\n \n-               Projects.Table (Project).Seen := True;\n+               Project_Tree.Projects.Table (Project).Seen := True;\n \n                Recursive_Add_Archives (Data.Extends);\n \n@@ -634,17 +635,22 @@ package body Makegpr is\n                --  Call itself recursively for all imported projects\n \n                while Imported /= Empty_Project_List loop\n-                  Prj := Project_Lists.Table (Imported).Project;\n+                  Prj := Project_Tree.Project_Lists.Table\n+                           (Imported).Project;\n \n                   if Prj /= No_Project then\n-                     while Projects.Table (Prj).Extended_By /= No_Project loop\n-                        Prj := Projects.Table (Prj).Extended_By;\n+                     while Project_Tree.Projects.Table\n+                             (Prj).Extended_By /= No_Project\n+                     loop\n+                        Prj := Project_Tree.Projects.Table\n+                                 (Prj).Extended_By;\n                      end loop;\n \n                      Recursive_Add_Archives (Prj);\n                   end if;\n \n-                  Imported := Project_Lists.Table (Imported).Next;\n+                  Imported := Project_Tree.Project_Lists.Table\n+                                (Imported).Next;\n                end loop;\n \n                --  If there is sources of language other than Ada in this\n@@ -664,8 +670,10 @@ package body Makegpr is\n    begin\n       --  First, mark all projects as not processed\n \n-      for Project in 1 .. Projects.Last loop\n-         Projects.Table (Project).Seen := False;\n+      for Project in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+      loop\n+         Project_Tree.Projects.Table (Project).Seen := False;\n       end loop;\n \n       --  Take care of the run path option\n@@ -939,43 +947,50 @@ package body Makegpr is\n             raise Program_Error;\n \n          when Linker =>\n-            Pkg := Value_Of (Name_Linker, Data.Decl.Packages);\n+            Pkg := Value_Of (Name_Linker, Data.Decl.Packages, Project_Tree);\n \n          when Compiler =>\n-            Pkg := Value_Of (Name_Compiler, Data.Decl.Packages);\n+            Pkg := Value_Of (Name_Compiler, Data.Decl.Packages, Project_Tree);\n       end case;\n \n       if Pkg /= No_Package then\n          --  Get the Switches (\"file name\"), if they exist\n \n          Switches_Array := Prj.Util.Value_Of\n            (Name      => Name_Switches,\n-            In_Arrays => Packages.Table (Pkg).Decl.Arrays);\n+            In_Arrays => Project_Tree.Packages.Table\n+                          (Pkg).Decl.Arrays,\n+            In_Tree   => Project_Tree);\n \n          Switches :=\n            Prj.Util.Value_Of\n              (Index     => File_Name,\n               Src_Index => 0,\n-              In_Array  => Switches_Array);\n+              In_Array  => Switches_Array,\n+              In_Tree   => Project_Tree);\n \n          --  Otherwise, get the Default_Switches (\"language\"), if they exist\n \n          if Switches = Nil_Variable_Value then\n             Defaults := Prj.Util.Value_Of\n               (Name      => Name_Default_Switches,\n-               In_Arrays => Packages.Table (Pkg).Decl.Arrays);\n+               In_Arrays => Project_Tree.Packages.Table\n+                              (Pkg).Decl.Arrays,\n+               In_Tree   => Project_Tree);\n             Switches := Prj.Util.Value_Of\n               (Index     => Language_Names.Table (Language),\n                Src_Index => 0,\n-               In_Array  => Defaults);\n+               In_Array  => Defaults,\n+               In_Tree   => Project_Tree);\n          end if;\n \n          --  If there are switches, add them to Arguments\n \n          if Switches /= Nil_Variable_Value then\n             Element_Id := Switches.Values;\n             while Element_Id /= Nil_String loop\n-               Element := String_Elements.Table (Element_Id);\n+               Element := Project_Tree.String_Elements.Table\n+                            (Element_Id);\n \n                if Element.Value /= No_Name then\n                   Get_Name_String (Element.Value);\n@@ -1003,7 +1018,8 @@ package body Makegpr is\n    --------------------------\n \n    procedure Build_Global_Archive is\n-      Data      : Project_Data := Projects.Table (Main_Project);\n+      Data      : Project_Data :=\n+                    Project_Tree.Projects.Table (Main_Project);\n       Source_Id : Other_Source_Id;\n       Source    : Other_Source;\n       Success   : Boolean;\n@@ -1072,16 +1088,19 @@ package body Makegpr is\n                --  Put all sources of language other than Ada in\n                --  Source_Indexes.\n \n-               for Proj in 1 .. Projects.Last loop\n-                  Data := Projects.Table (Proj);\n+               for Proj in Project_Table.First ..\n+                           Project_Table.Last (Project_Tree.Projects)\n+               loop\n+                  Data := Project_Tree.Projects.Table (Proj);\n \n                   if not Data.Library then\n                      Last_Source := 0;\n                      Source_Id := Data.First_Other_Source;\n \n                      while Source_Id /= No_Other_Source loop\n                         Add_Source_Id (Proj, Source_Id);\n-                        Source_Id := Other_Sources.Table (Source_Id).Next;\n+                        Source_Id := Project_Tree.Other_Sources.Table\n+                                       (Source_Id).Next;\n                      end loop;\n                   end if;\n                end loop;\n@@ -1100,7 +1119,8 @@ package body Makegpr is\n \n                   for S in 1 .. Last_Source loop\n                      Source_Id := Source_Indexes (S).Id;\n-                     Source := Other_Sources.Table (Source_Id);\n+                     Source := Project_Tree.Other_Sources.Table\n+                                 (Source_Id);\n \n                      if (not Source_Indexes (S).Found)\n                        and then Source.Object_Path = Object_Path\n@@ -1219,14 +1239,17 @@ package body Makegpr is\n \n          --  Followed by all the object files of the non library projects\n \n-         for Proj in 1 .. Projects.Last loop\n-            Data := Projects.Table (Proj);\n+         for Proj in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+         loop\n+            Data := Project_Tree.Projects.Table (Proj);\n \n             if not Data.Library then\n                Source_Id := Data.First_Other_Source;\n \n                while Source_Id /= No_Other_Source loop\n-                  Source := Other_Sources.Table (Source_Id);\n+                  Source :=\n+                    Project_Tree.Other_Sources.Table (Source_Id);\n \n                   --  Only include object file name that have not been\n                   --  overriden in extending projects.\n@@ -1345,7 +1368,8 @@ package body Makegpr is\n    -------------------\n \n    procedure Build_Library (Project : Project_Id; Unconditionally : Boolean) is\n-      Data      : constant Project_Data := Projects.Table (Project);\n+      Data      : constant Project_Data :=\n+                    Project_Tree.Projects.Table (Project);\n       Source_Id : Other_Source_Id;\n       Source    : Other_Source;\n \n@@ -1366,7 +1390,7 @@ package body Makegpr is\n       Time_Stamp  : Time_Stamp_Type;\n       Driver_Name : Name_Id := No_Name;\n \n-      Lib_Opts : Argument_List_Access := No_Argument'Unrestricted_Access;\n+      Lib_Opts : Argument_List_Access := No_Argument'Access;\n    begin\n       Check_Archive_Builder;\n \n@@ -1414,7 +1438,8 @@ package body Makegpr is\n \n                while Source_Id /= No_Other_Source loop\n                   Add_Source_Id (Project, Source_Id);\n-                  Source_Id := Other_Sources.Table (Source_Id).Next;\n+                  Source_Id := Project_Tree.Other_Sources.Table\n+                                 (Source_Id).Next;\n                end loop;\n \n                --  Read the dependency file, line by line\n@@ -1430,16 +1455,17 @@ package body Makegpr is\n                   --  Check if this object file is for a source of this project\n \n                   for S in 1 .. Last_Source loop\n-                     if (not Source_Indexes (S).Found) and then\n-                       Other_Sources.Table\n-                         (Source_Indexes (S).Id).Object_Name =\n-                       Object_Name\n+                     if (not Source_Indexes (S).Found)\n+                       and then\n+                         Project_Tree.Other_Sources.Table\n+                           (Source_Indexes (S).Id).Object_Name = Object_Name\n                      then\n                         --  We have found the object file: get the source\n                         --  data, and mark it as found.\n \n                         Source_Id := Source_Indexes (S).Id;\n-                        Source := Other_Sources.Table (Source_Id);\n+                        Source := Project_Tree.Other_Sources.Table\n+                                    (Source_Id);\n                         Source_Indexes (S).Found := True;\n                         exit;\n                      end if;\n@@ -1526,7 +1552,8 @@ package body Makegpr is\n \n                         if Verbose_Mode then\n                            Source_Id := Source_Indexes (Index).Id;\n-                           Source := Other_Sources.Table (Source_Id);\n+                           Source := Project_Tree.Other_Sources.Table\n+                                       (Source_Id);\n                            Write_Str  (\"      -> \");\n                            Write_Str  (Get_Name_String (Source.Object_Name));\n                            Write_Str  (\" is not in the archive \");\n@@ -1566,7 +1593,7 @@ package body Makegpr is\n             Source_Id := Data.First_Other_Source;\n \n             while Source_Id /= No_Other_Source loop\n-               Source := Other_Sources.Table (Source_Id);\n+               Source := Project_Tree.Other_Sources.Table (Source_Id);\n                Add_Argument\n                  (Get_Name_String (Source.Object_Name), Verbose_Mode);\n                Source_Id := Source.Next;\n@@ -1605,7 +1632,8 @@ package body Makegpr is\n                   Library_Options : constant Variable_Value :=\n                                       Value_Of\n                                         (Name_Library_Options,\n-                                         Data.Decl.Attributes);\n+                                         Data.Decl.Attributes,\n+                                         Project_Tree);\n \n                begin\n                   if not Library_Options.Default then\n@@ -1615,7 +1643,8 @@ package body Makegpr is\n \n                      begin\n                         while Current /= Nil_String loop\n-                           Element := String_Elements.Table (Current);\n+                           Element := Project_Tree.String_Elements.\n+                                        Table (Current);\n                            Get_Name_String (Element.Value);\n \n                            if Name_Len /= 0 then\n@@ -2034,9 +2063,12 @@ package body Makegpr is\n    begin\n       C_Plus_Plus_Is_Used := False;\n \n-      for Project in 1 .. Projects.Last loop\n+      for Project in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+      loop\n          if\n-           Projects.Table (Project).Languages (C_Plus_Plus_Language_Index)\n+           Project_Tree.Projects.Table (Project).Languages\n+                                           (C_Plus_Plus_Language_Index)\n          then\n             C_Plus_Plus_Is_Used := True;\n             exit;\n@@ -2053,7 +2085,8 @@ package body Makegpr is\n       Data         : in Project_Data;\n       Local_Errors : in out Boolean)\n    is\n-      Source  : Other_Source := Other_Sources.Table (Source_Id);\n+      Source  : Other_Source :=\n+        Project_Tree.Other_Sources.Table (Source_Id);\n       Success : Boolean;\n       CPATH   : String_Access := null;\n \n@@ -2283,7 +2316,7 @@ package body Makegpr is\n          else\n             --  Everything looks fine, update the Other_Sources table\n \n-            Other_Sources.Table (Source_Id) := Source;\n+            Project_Tree.Other_Sources.Table (Source_Id) := Source;\n          end if;\n \n       --  Compilation failed\n@@ -2302,7 +2335,8 @@ package body Makegpr is\n    --------------------------------\n \n    procedure Compile_Individual_Sources is\n-      Data         : Project_Data := Projects.Table (Main_Project);\n+      Data         : Project_Data :=\n+                       Project_Tree.Projects.Table (Main_Project);\n       Source_Id    : Other_Source_Id;\n       Source       : Other_Source;\n       Source_Name  : Name_Id;\n@@ -2318,7 +2352,7 @@ package body Makegpr is\n       Compile_Only := True;\n \n       Get_Imported_Directories (Main_Project, Data);\n-      Projects.Table (Main_Project) := Data;\n+      Project_Tree.Projects.Table (Main_Project) := Data;\n \n       --  Compilation will occur in the object directory\n \n@@ -2361,7 +2395,8 @@ package body Makegpr is\n                   Source_Id := Data.First_Other_Source;\n \n                   while Source_Id /= No_Other_Source loop\n-                     Source := Other_Sources.Table (Source_Id);\n+                     Source :=\n+                       Project_Tree.Other_Sources.Table (Source_Id);\n                      exit when Source.File_Name = Source_Name;\n                      Source_Id := Source.Next;\n                   end loop;\n@@ -2406,7 +2441,8 @@ package body Makegpr is\n    --------------------------------\n \n    procedure Compile_Link_With_Gnatmake (Mains_Specified : Boolean) is\n-      Data    : constant Project_Data := Projects.Table (Main_Project);\n+      Data    : constant Project_Data :=\n+                  Project_Tree.Projects.Table (Main_Project);\n       Success : Boolean;\n \n    begin\n@@ -2571,9 +2607,11 @@ package body Makegpr is\n    begin\n       --  Loop through project files\n \n-      for Project in 1 .. Projects.Last loop\n+      for Project in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+      loop\n          Local_Errors := False;\n-         Data := Projects.Table (Project);\n+         Data := Project_Tree.Projects.Table (Project);\n \n          --  Nothing to do when no sources of language other than Ada\n \n@@ -2584,7 +2622,7 @@ package body Makegpr is\n             if not Data.Include_Data_Set then\n                Get_Imported_Directories (Project, Data);\n                Data.Include_Data_Set := True;\n-               Projects.Table (Project) := Data;\n+               Project_Tree.Projects.Table (Project) := Data;\n             end if;\n \n             Need_To_Rebuild_Archive := Force_Compilations;\n@@ -2598,7 +2636,7 @@ package body Makegpr is\n             --  Process each source one by one\n \n             while Source_Id /= No_Other_Source loop\n-               Source := Other_Sources.Table (Source_Id);\n+               Source := Project_Tree.Other_Sources.Table (Source_Id);\n                Need_To_Compile := Force_Compilations;\n \n                --  Check if compilation is needed\n@@ -2679,7 +2717,7 @@ package body Makegpr is\n       Create (Dep_File, Append_File, Name);\n \n       while Source_Id /= No_Other_Source loop\n-         Source := Other_Sources.Table (Source_Id);\n+         Source := Project_Tree.Other_Sources.Table (Source_Id);\n          Put_Line (Dep_File, Get_Name_String (Source.Object_Name));\n          Put_Line (Dep_File, String (Source.Object_TS));\n          Source_Id := Source.Next;\n@@ -2713,12 +2751,15 @@ package body Makegpr is\n \n       --  Get all the object files of non-Ada sources in non-library projects\n \n-      for Project in 1 .. Projects.Last loop\n-         if not Projects.Table (Project).Library then\n-            Source_Id := Projects.Table (Project).First_Other_Source;\n+      for Project in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+      loop\n+         if not Project_Tree.Projects.Table (Project).Library then\n+            Source_Id :=\n+              Project_Tree.Projects.Table (Project).First_Other_Source;\n \n             while Source_Id /= No_Other_Source loop\n-               Source := Other_Sources.Table (Source_Id);\n+               Source := Project_Tree.Other_Sources.Table (Source_Id);\n \n                --  Put only those object files that are in the global archive\n \n@@ -2791,18 +2832,23 @@ package body Makegpr is\n    ------------------\n \n    procedure Get_Compiler (For_Language : First_Language_Indexes) is\n-      Data : constant Project_Data := Projects.Table (Main_Project);\n+      Data : constant Project_Data :=\n+               Project_Tree.Projects.Table (Main_Project);\n \n       Ide : constant Package_Id :=\n-        Value_Of (Name_Ide, In_Packages => Data.Decl.Packages);\n+        Value_Of\n+          (Name_Ide,\n+           In_Packages => Data.Decl.Packages,\n+           In_Tree     => Project_Tree);\n       --  The id of the package IDE in the project file\n \n       Compiler : constant Variable_Value :=\n         Value_Of\n           (Name                    => Language_Names.Table (For_Language),\n            Index                   => 0,\n            Attribute_Or_Array_Name => Name_Compiler_Command,\n-           In_Package              => Ide);\n+           In_Package              => Ide,\n+           In_Tree                 => Project_Tree);\n       --  The value of Compiler_Command (\"language\") in package IDE, if defined\n \n    begin\n@@ -2902,7 +2948,7 @@ package body Makegpr is\n          --  Add each source directory path name, preceded by \"-I\" to Arguments\n \n          while Element_Id /= Nil_String loop\n-            Element := String_Elements.Table (Element_Id);\n+            Element := Project_Tree.String_Elements.Table (Element_Id);\n \n             if Element.Value /= No_Name then\n                Get_Name_String (Element.Value);\n@@ -2960,7 +3006,7 @@ package body Makegpr is\n          --  Nothing to do if project is undefined\n \n          if Prj /= No_Project then\n-            Data := Projects.Table (Prj);\n+            Data := Project_Tree.Projects.Table (Prj);\n \n             --  Nothing to do if project has already been processed\n \n@@ -2969,7 +3015,7 @@ package body Makegpr is\n                --  Mark the project as processed, to avoid multiple processing\n                --  of the same project.\n \n-               Projects.Table (Prj).Seen := True;\n+               Project_Tree.Projects.Table (Prj).Seen := True;\n \n                --  Add the source directories of this project\n \n@@ -2984,8 +3030,11 @@ package body Makegpr is\n                --  Call itself for all imported projects, if any\n \n                while Imported /= Empty_Project_List loop\n-                  Recursive_Get_Dirs (Project_Lists.Table (Imported).Project);\n-                  Imported := Project_Lists.Table (Imported).Next;\n+                  Recursive_Get_Dirs\n+                    (Project_Tree.Project_Lists.Table\n+                       (Imported).Project);\n+                  Imported :=\n+                    Project_Tree.Project_Lists.Table (Imported).Next;\n                end loop;\n             end if;\n          end if;\n@@ -2996,8 +3045,10 @@ package body Makegpr is\n    begin\n       --  First, mark all project as not processed\n \n-      for J in 1 .. Projects.Last loop\n-         Projects.Table (J).Seen := False;\n+      for J in Project_Table.First ..\n+               Project_Table.Last (Project_Tree.Projects)\n+      loop\n+         Project_Tree.Projects.Table (J).Seen := False;\n       end loop;\n \n       --  Empty Arguments\n@@ -3006,15 +3057,18 @@ package body Makegpr is\n \n       --  Process this project individually, project data are already known\n \n-      Projects.Table (Project).Seen := True;\n+      Project_Tree.Projects.Table (Project).Seen := True;\n \n       Add (Data.Source_Dirs);\n \n       Recursive_Get_Dirs (Data.Extends);\n \n       while Imported_Projects /= Empty_Project_List loop\n-         Recursive_Get_Dirs (Project_Lists.Table (Imported_Projects).Project);\n-         Imported_Projects := Project_Lists.Table (Imported_Projects).Next;\n+         Recursive_Get_Dirs\n+           (Project_Tree.Project_Lists.Table\n+              (Imported_Projects).Project);\n+         Imported_Projects := Project_Tree.Project_Lists.Table\n+                                (Imported_Projects).Next;\n       end loop;\n \n       Data.Imported_Directories_Switches :=\n@@ -3059,6 +3113,7 @@ package body Makegpr is\n \n       Prj.Pars.Parse\n         (Project           => Main_Project,\n+         In_Tree           => Project_Tree,\n          Project_File_Name => Project_File_Name.all,\n          Packages_To_Check => Packages_To_Check);\n \n@@ -3092,7 +3147,8 @@ package body Makegpr is\n \n       else\n          declare\n-            Data : constant Prj.Project_Data := Projects.Table (Main_Project);\n+            Data : constant Prj.Project_Data :=\n+                     Project_Tree.Projects.Table (Main_Project);\n          begin\n             if Data.Library and then Mains.Number_Of_Mains /= 0 then\n                Osint.Fail\n@@ -3143,7 +3199,7 @@ package body Makegpr is\n       Csets.Initialize;\n       Namet.Initialize;\n       Snames.Initialize;\n-      Prj.Initialize;\n+      Prj.Initialize (Project_Tree);\n       Mains.Delete;\n \n       --  Set Name_Ide and Name_Compiler_Command\n@@ -3198,19 +3254,22 @@ package body Makegpr is\n      (Object_Name : Name_Id;\n       Project     : Project_Id) return Boolean\n    is\n-      Data   : Project_Data := Projects.Table (Project);\n+      Data   : Project_Data := Project_Tree.Projects.Table (Project);\n       Source : Other_Source_Id;\n \n    begin\n       while Data.Extended_By /= No_Project loop\n-         Data := Projects.Table (Data.Extended_By);\n-         Source := Data.First_Other_Source;\n+         Data := Project_Tree.Projects.Table (Data.Extended_By);\n \n+         Source := Data.First_Other_Source;\n          while Source /= No_Other_Source loop\n-            if Other_Sources.Table (Source).Object_Name = Object_Name then\n+            if Project_Tree.Other_Sources.Table (Source).Object_Name =\n+                 Object_Name\n+            then\n                return False;\n             else\n-               Source := Other_Sources.Table (Source).Next;\n+               Source :=\n+                 Project_Tree.Other_Sources.Table (Source).Next;\n             end if;\n          end loop;\n       end loop;\n@@ -3223,7 +3282,8 @@ package body Makegpr is\n    ----------------------\n \n    procedure Link_Executables is\n-      Data : constant Project_Data := Projects.Table (Main_Project);\n+      Data : constant Project_Data :=\n+               Project_Tree.Projects.Table (Main_Project);\n \n       Mains_Specified : constant Boolean := Mains.Number_Of_Mains /= 0;\n       --  True if main sources were specified on the command line\n@@ -3288,8 +3348,10 @@ package body Makegpr is\n          Prj_Data : Project_Data;\n \n       begin\n-         for Prj in 1 .. Projects.Last loop\n-            Prj_Data := Projects.Table (Prj);\n+         for Prj in Project_Table.First ..\n+                    Project_Table.Last (Project_Tree.Projects)\n+         loop\n+            Prj_Data := Project_Tree.Projects.Table (Prj);\n \n             --  There is an archive only in project\n             --  files with sources other than Ada\n@@ -3381,10 +3443,11 @@ package body Makegpr is\n          Executable_Name : constant String :=\n                              Get_Name_String\n                                (Executable_Of\n-                                  (Project  => Main_Project,\n-                                   Main     => Main_Id,\n-                                   Index    => 0,\n-                                   Ada_Main => False));\n+                                    (Project  => Main_Project,\n+                                     In_Tree  => Project_Tree,\n+                                     Main     => Main_Id,\n+                                     Index    => 0,\n+                                     Ada_Main => False));\n          --  File name of the executable\n \n          Executable_Path : constant String :=\n@@ -3453,6 +3516,7 @@ package body Makegpr is\n                Get_Name_String\n                  (Executable_Of\n                     (Project  => Main_Project,\n+                     In_Tree  => Project_Tree,\n                      Main     => Main_Id,\n                      Index    => 0,\n                      Ada_Main => False)),\n@@ -3484,7 +3548,7 @@ package body Makegpr is\n             if Link_Options_Switches = null then\n                Link_Options_Switches :=\n                  new Argument_List'\n-                   (Linker_Options_Switches (Main_Project));\n+                   (Linker_Options_Switches (Main_Project, Project_Tree));\n             end if;\n \n             Add_Arguments (Link_Options_Switches.all, True);\n@@ -3532,7 +3596,8 @@ package body Makegpr is\n \n          begin\n             while Element_Id /= Nil_String loop\n-               Element := String_Elements.Table (Element_Id);\n+               Element := Project_Tree.String_Elements.Table\n+                            (Element_Id);\n \n                if Element.Value /= No_Name then\n                   Mains.Add_Main (Get_Name_String (Element.Value));\n@@ -3629,7 +3694,8 @@ package body Makegpr is\n                   --  Check if it is a source of a language other than Ada\n \n                   while Source_Id /= No_Other_Source loop\n-                     Source := Other_Sources.Table (Source_Id);\n+                     Source :=\n+                       Project_Tree.Other_Sources.Table (Source_Id);\n                      exit when Source.File_Name = Main_Id;\n                      Source_Id := Source.Next;\n                   end loop;\n@@ -3674,6 +3740,7 @@ package body Makegpr is\n                        (Get_Name_String\n                           (Executable_Of\n                              (Project  => Main_Project,\n+                              In_Tree  => Project_Tree,\n                               Main     => Other_Mains.Table (Main).File_Name,\n                               Index    => 0,\n                               Ada_Main => False)),\n@@ -3774,7 +3841,8 @@ package body Makegpr is\n                   --  Check if it is a source of the main project file\n \n                   while Source_Id /= No_Other_Source loop\n-                     Source := Other_Sources.Table (Source_Id);\n+                     Source :=\n+                       Project_Tree.Other_Sources.Table (Source_Id);\n                      exit when Source.File_Name = Main_Id;\n                      Source_Id := Source.Next;\n                   end loop;\n@@ -3815,6 +3883,7 @@ package body Makegpr is\n                        (Get_Name_String\n                           (Executable_Of\n                              (Project  => Main_Project,\n+                              In_Tree  => Project_Tree,\n                               Main     => Main_Id,\n                               Index    => 0,\n                               Ada_Main => False)));"}, {"sha": "de81c52674b4da07f5d2ab50d64340f22fcc42d4", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -185,7 +185,8 @@ package body Makeutl is\n    -----------------------------\n \n    function Linker_Options_Switches\n-     (Project  : Project_Id) return String_List\n+     (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref) return String_List\n    is\n       procedure Recursive_Add_Linker_Options (Proj : Project_Id);\n       --  The recursive routine used to add linker options\n@@ -202,29 +203,33 @@ package body Makeutl is\n \n       begin\n          if Proj /= No_Project then\n-            Data := Projects.Table (Proj);\n+            Data := In_Tree.Projects.Table (Proj);\n \n             if not Data.Seen then\n-               Projects.Table (Proj).Seen := True;\n+               In_Tree.Projects.Table (Proj).Seen := True;\n                Imported := Data.Imported_Projects;\n \n                while Imported /= Empty_Project_List loop\n                   Recursive_Add_Linker_Options\n-                    (Project_Lists.Table (Imported).Project);\n-                  Imported := Project_Lists.Table (Imported).Next;\n+                    (In_Tree.Project_Lists.Table\n+                       (Imported).Project);\n+                  Imported := In_Tree.Project_Lists.Table\n+                                (Imported).Next;\n                end loop;\n \n                if Proj /= Project then\n                   Linker_Package :=\n                     Prj.Util.Value_Of\n-                      (Name => Name_Linker,\n-                       In_Packages => Data.Decl.Packages);\n+                      (Name        => Name_Linker,\n+                       In_Packages => Data.Decl.Packages,\n+                       In_Tree     => In_Tree);\n                   Options :=\n                     Prj.Util.Value_Of\n-                      (Name => Name_Ada,\n-                       Index => 0,\n+                      (Name                    => Name_Ada,\n+                       Index                   => 0,\n                        Attribute_Or_Array_Name => Name_Linker_Options,\n-                       In_Package => Linker_Package);\n+                       In_Package              => Linker_Package,\n+                       In_Tree                 => In_Tree);\n \n                   --  If attribute is present, add the project with\n                   --  the attribute to table Linker_Opts.\n@@ -244,8 +249,10 @@ package body Makeutl is\n    begin\n       Linker_Opts.Init;\n \n-      for Index in 1 .. Projects.Last loop\n-         Projects.Table (Index).Seen := False;\n+      for Index in Project_Table.First ..\n+                   Project_Table.Last (In_Tree.Projects)\n+      loop\n+         In_Tree.Projects.Table (Index).Seen := False;\n       end loop;\n \n       Recursive_Add_Linker_Options (Project);\n@@ -262,15 +269,19 @@ package body Makeutl is\n          begin\n             --  If Dir_Path has not been computed for this project, do it now\n \n-            if Projects.Table (Proj).Dir_Path = null then\n-               Projects.Table (Proj).Dir_Path :=\n+            if In_Tree.Projects.Table (Proj).Dir_Path = null then\n+               In_Tree.Projects.Table (Proj).Dir_Path :=\n                  new String'\n-                   (Get_Name_String (Projects.Table (Proj). Directory));\n+                   (Get_Name_String\n+                        (In_Tree.Projects.Table\n+                             (Proj). Directory));\n             end if;\n \n             while Options /= Nil_String loop\n-               Option := String_Elements.Table (Options).Value;\n-               Options := String_Elements.Table (Options).Next;\n+               Option :=\n+                 In_Tree.String_Elements.Table (Options).Value;\n+               Options :=\n+                 In_Tree.String_Elements.Table (Options).Next;\n                Add_Linker_Option (Get_Name_String (Option));\n \n                --  Object files and -L switches specified with\n@@ -280,7 +291,8 @@ package body Makeutl is\n                Test_If_Relative_Path\n                  (Switch =>\n                     Linker_Options_Buffer (Last_Linker_Option),\n-                  Parent => Projects.Table (Proj).Dir_Path,\n+                  Parent =>\n+                    In_Tree.Projects.Table (Proj).Dir_Path,\n                   Including_L_Switch => True);\n             end loop;\n          end;\n@@ -326,7 +338,7 @@ package body Makeutl is\n       procedure Delete is\n       begin\n          Names.Set_Last (0);\n-         Reset;\n+         Mains.Reset;\n       end Delete;\n \n       ---------------"}, {"sha": "2053e3ea3ca3cbd2bb6918a21b3d20a76f6eed13", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,8 +56,13 @@ package Makeutl is\n    --  been entered by a call to Prj.Ext.Add, so that in a project\n    --  file, External (\"name\") will return \"value\".\n \n-   function Linker_Options_Switches (Project  : Project_Id) return String_List;\n-   --  Comment required ???\n+   function Linker_Options_Switches\n+     (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref) return String_List;\n+   --  Collect the options specified in the Linker'Linker_Options attributes\n+   --  of project Project, in project tree In_Tree, and in the projects that\n+   --  it imports directly or indirectly, and returns the result.\n+\n \n    --  Package Mains is used to store the mains specified on the command line\n    --  and to retrieve them when a project file is used, to verify that the"}, {"sha": "541f485665b103e469a1b611b6a1494c97afc3cc", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 83, "deletions": 43, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -224,6 +224,7 @@ package body MLib.Prj is\n \n    procedure Copy_Interface_Sources\n      (For_Project : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n       Interfaces  : Argument_List;\n       To_Dir      : Name_Id);\n    --  Copy the interface sources of a SAL to directory To_Dir\n@@ -294,6 +295,7 @@ package body MLib.Prj is\n \n    procedure Build_Library\n      (For_Project   : Project_Id;\n+      In_Tree       : Project_Tree_Ref;\n       Gnatbind      : String;\n       Gnatbind_Path : String_Access;\n       Gcc           : String;\n@@ -315,7 +317,7 @@ package body MLib.Prj is\n       --  On OpenVMS, set to True if library needs to be linked with\n       --  g-trasym.obj.\n \n-      Data : Project_Data := Projects.Table (For_Project);\n+      Data : Project_Data := In_Tree.Projects.Table (For_Project);\n \n       Object_Directory_Path : constant String :=\n                           Get_Name_String (Data.Object_Directory);\n@@ -484,15 +486,15 @@ package body MLib.Prj is\n \n          elsif P /= No_Project then\n             declare\n-               Data : Project_Data := Projects.Table (For_Project);\n-\n+               Data : Project_Data :=\n+                        In_Tree.Projects.Table (For_Project);\n             begin\n                while Data.Extends /= No_Project loop\n                   if P = Data.Extends then\n                      return True;\n                   end if;\n \n-                  Data := Projects.Table (Data.Extends);\n+                  Data := In_Tree.Projects.Table (Data.Extends);\n                end loop;\n             end;\n          end if;\n@@ -668,7 +670,8 @@ package body MLib.Prj is\n          ---------------------\n \n          procedure Process_Project (Project : Project_Id) is\n-            Data     : constant Project_Data := Projects.Table (Project);\n+            Data     : constant Project_Data :=\n+                         In_Tree.Projects.Table (Project);\n             Imported : Project_List := Data.Imported_Projects;\n             Element  : Project_Element;\n \n@@ -683,7 +686,8 @@ package body MLib.Prj is\n                --  we have a proper reverse order for the libraries.\n \n                while Imported /= Empty_Project_List loop\n-                  Element := Project_Lists.Table (Imported);\n+                  Element :=\n+                    In_Tree.Project_Lists.Table (Imported);\n \n                   if Element.Project /= No_Project then\n                      Process_Project (Element.Project);\n@@ -718,7 +722,8 @@ package body MLib.Prj is\n          for Index in reverse 1 .. Library_Projs.Last loop\n             Current := Library_Projs.Table (Index);\n \n-            Get_Name_String (Projects.Table (Current).Library_Dir);\n+            Get_Name_String\n+              (In_Tree.Projects.Table (Current).Library_Dir);\n             Opts.Increment_Last;\n             Opts.Table (Opts.Last) :=\n               new String'(\"-L\" & Name_Buffer (1 .. Name_Len));\n@@ -732,7 +737,8 @@ package body MLib.Prj is\n               new String'\n                 (\"-l\" &\n                  Get_Name_String\n-                   (Projects.Table (Current).Library_Name));\n+                   (In_Tree.Projects.Table\n+                      (Current).Library_Name));\n          end loop;\n       end Process_Imported_Libraries;\n \n@@ -812,7 +818,8 @@ package body MLib.Prj is\n                Binder_Package : constant Package_Id :=\n                                   Value_Of\n                                     (Name        => Name_Binder,\n-                                     In_Packages => Data.Decl.Packages);\n+                                     In_Packages => Data.Decl.Packages,\n+                                     In_Tree     => In_Tree);\n \n             begin\n                if Binder_Package /= No_Package then\n@@ -821,8 +828,9 @@ package body MLib.Prj is\n                                   Value_Of\n                                     (Name      => Name_Default_Switches,\n                                      In_Arrays =>\n-                                       Packages.Table\n-                                         (Binder_Package).Decl.Arrays);\n+                                       In_Tree.Packages.Table\n+                                         (Binder_Package).Decl.Arrays,\n+                                     In_Tree   => In_Tree);\n                      Switches : Variable_Value := Nil_Variable_Value;\n \n                      Switch : String_List_Id := Nil_String;\n@@ -833,16 +841,19 @@ package body MLib.Prj is\n                           Value_Of\n                             (Index     => Name_Ada,\n                              Src_Index => 0,\n-                             In_Array  => Defaults);\n+                             In_Array  => Defaults,\n+                             In_Tree   => In_Tree);\n \n                         if not Switches.Default then\n                            Switch := Switches.Values;\n \n                            while Switch /= Nil_String loop\n                               Add_Argument\n                                 (Get_Name_String\n-                                   (String_Elements.Table (Switch).Value));\n-                              Switch := String_Elements.Table (Switch).Next;\n+                                   (In_Tree.String_Elements.Table\n+                                      (Switch).Value));\n+                              Switch := In_Tree.String_Elements.\n+                                          Table (Switch).Next;\n                            end loop;\n                         end if;\n                      end if;\n@@ -862,8 +873,10 @@ package body MLib.Prj is\n             Interface_ALIs.Reset;\n             Processed_ALIs.Reset;\n \n-            for Source in 1 .. Com.Units.Last loop\n-               Unit := Com.Units.Table (Source);\n+            for Source in Unit_Table.First ..\n+                          Unit_Table.Last (In_Tree.Units)\n+            loop\n+               Unit := In_Tree.Units.Table (Source);\n \n                if Unit.File_Names (Body_Part).Name /= No_Name\n                  and then Unit.File_Names (Body_Part).Path /= Slash\n@@ -944,8 +957,8 @@ package body MLib.Prj is\n                         declare\n                            Arg : String_Ptr renames Args.Table (Index);\n                         begin\n-                           if\n-                             Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n+                           if Arg'Length >= 6 and then\n+                              Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n                            then\n                               Add_Argument (Arg.all);\n                               exit;\n@@ -959,7 +972,9 @@ package body MLib.Prj is\n             --  Set the paths\n \n             Set_Ada_Paths\n-              (Project => For_Project, Including_Libraries => True);\n+              (Project             => For_Project,\n+               In_Tree             => In_Tree,\n+               Including_Libraries => True);\n \n             --  Display the gnatbind command, if not in quiet output\n \n@@ -982,7 +997,9 @@ package body MLib.Prj is\n             --  Set the paths\n \n             Set_Ada_Paths\n-              (Project => For_Project, Including_Libraries => True);\n+              (Project             => For_Project,\n+               In_Tree             => In_Tree,\n+               Including_Libraries => True);\n \n             --  Invoke <gcc> -c b$$<lib>.adb\n \n@@ -1076,7 +1093,8 @@ package body MLib.Prj is\n       if Link then\n          --  If attribute Library_GCC was specified, get the driver name\n \n-         Library_GCC := Value_Of (Name_Library_GCC, Data.Decl.Attributes);\n+         Library_GCC :=\n+           Value_Of (Name_Library_GCC, Data.Decl.Attributes, In_Tree);\n \n          if not Library_GCC.Default then\n             Driver_Name := Library_GCC.Value;\n@@ -1086,7 +1104,7 @@ package body MLib.Prj is\n          --  options.\n \n          Library_Options :=\n-           Value_Of (Name_Library_Options, Data.Decl.Attributes);\n+           Value_Of (Name_Library_Options, Data.Decl.Attributes, In_Tree);\n \n          if not Library_Options.Default then\n             declare\n@@ -1095,7 +1113,8 @@ package body MLib.Prj is\n \n             begin\n                while Current /= Nil_String loop\n-                  Element := String_Elements.Table (Current);\n+                  Element :=\n+                    In_Tree.String_Elements.Table (Current);\n                   Get_Name_String (Element.Value);\n \n                   if Name_Len /= 0 then\n@@ -1240,7 +1259,7 @@ package body MLib.Prj is\n             exit when Data.Extends = No_Project;\n \n             In_Main_Object_Directory  := False;\n-            Data := Projects.Table (Data.Extends);\n+            Data := In_Tree.Projects.Table (Data.Extends);\n          end loop;\n \n          --  Add the -L and -l switches for the imported Library Project Files,\n@@ -1416,19 +1435,22 @@ package body MLib.Prj is\n          --  the library directory (by Copy_ALI_Files, below).\n \n          if Standalone then\n-            Data := Projects.Table (For_Project);\n+            Data := In_Tree.Projects.Table (For_Project);\n \n             declare\n                Iface : String_List_Id := Data.Lib_Interface_ALIs;\n                ALI   : File_Name_Type;\n \n             begin\n                while Iface /= Nil_String loop\n-                  ALI := String_Elements.Table (Iface).Value;\n+                  ALI :=\n+                    In_Tree.String_Elements.Table (Iface).Value;\n                   Interface_ALIs.Set (ALI, True);\n-                  Get_Name_String (String_Elements.Table (Iface).Value);\n+                  Get_Name_String\n+                    (In_Tree.String_Elements.Table (Iface).Value);\n                   Add_Argument (Name_Buffer (1 .. Name_Len));\n-                  Iface := String_Elements.Table (Iface).Next;\n+                  Iface :=\n+                    In_Tree.String_Elements.Table (Iface).Next;\n                end loop;\n \n                Iface := Data.Lib_Interface_ALIs;\n@@ -1440,9 +1462,11 @@ package body MLib.Prj is\n                   --  interface. If it is not the case, output a warning.\n \n                   while Iface /= Nil_String loop\n-                     ALI := String_Elements.Table (Iface).Value;\n+                     ALI := In_Tree.String_Elements.Table\n+                              (Iface).Value;\n                      Process (ALI);\n-                     Iface := String_Elements.Table (Iface).Next;\n+                     Iface :=\n+                       In_Tree.String_Elements.Table (Iface).Next;\n                   end loop;\n                end if;\n             end;\n@@ -1453,7 +1477,8 @@ package body MLib.Prj is\n          --  copy directory or because the interface copy directory is the\n          --  same as the library directory.\n \n-         Copy_Dir := Projects.Table (For_Project).Library_Dir;\n+         Copy_Dir :=\n+           In_Tree.Projects.Table (For_Project).Library_Dir;\n          Clean (Copy_Dir);\n \n          --  Call procedure to build the library, depending on the build mode\n@@ -1502,21 +1527,26 @@ package body MLib.Prj is\n          --  Copy interface sources if Library_Src_Dir specified\n \n          if Standalone\n-           and then Projects.Table (For_Project).Library_Src_Dir /= No_Name\n+           and then In_Tree.Projects.Table\n+                      (For_Project).Library_Src_Dir /= No_Name\n          then\n             --  Clean the interface copy directory, if it is not also the\n             --  library directory. If it is also the library directory, it\n             --  has already been cleaned before generation of the library.\n \n-            if Projects.Table (For_Project).Library_Src_Dir /= Copy_Dir then\n-               Copy_Dir := Projects.Table (For_Project).Library_Src_Dir;\n+            if In_Tree.Projects.Table\n+              (For_Project).Library_Src_Dir /= Copy_Dir\n+            then\n+               Copy_Dir := In_Tree.Projects.Table\n+                             (For_Project).Library_Src_Dir;\n                Clean (Copy_Dir);\n             end if;\n \n             Copy_Interface_Sources\n               (For_Project => For_Project,\n-               Interfaces => Arguments (1 .. Argument_Number),\n-               To_Dir => Copy_Dir);\n+               In_Tree     => In_Tree,\n+               Interfaces  => Arguments (1 .. Argument_Number),\n+               To_Dir      => Copy_Dir);\n          end if;\n       end if;\n \n@@ -1553,8 +1583,11 @@ package body MLib.Prj is\n    -- Check_Library --\n    -------------------\n \n-   procedure Check_Library (For_Project : Project_Id) is\n-      Data : constant Project_Data := Projects.Table (For_Project);\n+   procedure Check_Library\n+     (For_Project : Project_Id; In_Tree : Project_Tree_Ref)\n+   is\n+      Data : constant Project_Data :=\n+               In_Tree.Projects.Table (For_Project);\n \n    begin\n       --  No need to build the library if there is no object directory,\n@@ -1566,7 +1599,8 @@ package body MLib.Prj is\n       then\n          declare\n             Current  : constant Dir_Name_Str := Get_Current_Dir;\n-            Lib_Name : constant Name_Id := Library_File_Name_For (For_Project);\n+            Lib_Name : constant Name_Id :=\n+                         Library_File_Name_For (For_Project, In_Tree);\n             Lib_TS   : Time_Stamp_Type;\n             Obj_TS   : Time_Stamp_Type;\n \n@@ -1613,7 +1647,8 @@ package body MLib.Prj is\n \n                      --  Library must be rebuilt\n \n-                     Projects.Table (For_Project).Need_To_Build_Lib := True;\n+                     In_Tree.Projects.Table\n+                       (For_Project).Need_To_Build_Lib := True;\n                      exit;\n                   end if;\n                end if;\n@@ -1682,6 +1717,7 @@ package body MLib.Prj is\n \n    procedure Copy_Interface_Sources\n      (For_Project : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n       Interfaces  : Argument_List;\n       To_Dir      : Name_Id)\n    is\n@@ -1711,8 +1747,10 @@ package body MLib.Prj is\n \n       begin\n          Unit_Loop :\n-         for Index in 1 .. Com.Units.Last loop\n-            Data := Com.Units.Table (Index);\n+         for Index in Unit_Table.First ..\n+                      Unit_Table.Last (In_Tree.Units)\n+         loop\n+            Data := In_Tree.Units.Table (Index);\n \n             for J in Data.File_Names'Range loop\n                if Data.File_Names (J).Project = For_Project\n@@ -1738,7 +1776,9 @@ package body MLib.Prj is\n       --  Change the working directory to the object directory\n \n       Change_Dir\n-        (Get_Name_String (Projects.Table (For_Project).Object_Directory));\n+        (Get_Name_String\n+           (In_Tree.Projects.Table\n+              (For_Project).Object_Directory));\n \n       for Index in Interfaces'Range loop\n "}, {"sha": "dac5df9cc069e8642404990c7654f0e6bb6c0d5a", "filename": "gcc/ada/mlib-prj.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-prj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-prj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---              Copyright (C) 2001-2003, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2005, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,7 @@ package MLib.Prj is\n \n    procedure Build_Library\n      (For_Project   : Project_Id;\n+      In_Tree       : Project_Tree_Ref;\n       Gnatbind      : String;\n       Gnatbind_Path : String_Access;\n       Gcc           : String;\n@@ -45,7 +46,8 @@ package MLib.Prj is\n    --  files. If Bind is False the binding of a stand-alone library is skipped.\n    --  If Link is False, the library is not linked/built.\n \n-   procedure Check_Library (For_Project : Project_Id);\n+   procedure Check_Library\n+     (For_Project : Project_Id; In_Tree : Project_Tree_Ref);\n    --  Check if the library of a library project needs to be rebuilt,\n    --  because its time-stamp is earlier than the time stamp of one of its\n    --  object files."}, {"sha": "6c2d443b75646872577f47c048def382a79b08d4", "filename": "gcc/ada/mlib-tgt-aix.adb", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-aix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-aix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-aix.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2003-2004, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 2003-2005, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -286,24 +286,29 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir  : constant String :=\n-                         Get_Name_String\n-                           (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n+\n             Lib_Name : constant String :=\n-                         Get_Name_String\n-                           (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -321,23 +326,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else\n@@ -382,7 +393,7 @@ package body MLib.Tgt is\n \n    function Support_For_Libraries return Library_Support is\n    begin\n-      return Full;\n+      return Static_Only;\n    end Support_For_Libraries;\n \n end MLib.Tgt;"}, {"sha": "ce4b2615b428411dfcc0d47e5a9dc04a30f14880", "filename": "gcc/ada/mlib-tgt-hpux.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-hpux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-hpux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-hpux.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2003-2004, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 2003-2005, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -269,22 +269,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -302,23 +308,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "b3b103e502d586f3073a50b7d89340d84bedaccd", "filename": "gcc/ada/mlib-tgt-irix.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-irix.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2003-2004, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 2003-2005, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -309,22 +309,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -342,23 +348,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "762d1362810b837d9fee38c25e7c54c22f1353b0", "filename": "gcc/ada/mlib-tgt-linux.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-linux.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2004, Free Software Foundation, Inc.     --\n+--              Copyright (C) 2001-2005, Free Software Foundation, Inc.     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -266,22 +266,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+                 Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -299,23 +305,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+                 Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "4827e6a18bf696c93fd6e26cc0c478e776e62ea5", "filename": "gcc/ada/mlib-tgt-lynxos.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-lynxos.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2003-2004 Free Software Foundation, Inc.         --\n+--           Copyright (C) 2003-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -174,22 +174,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -207,23 +213,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "9bd970ba701a6e6769fb56ea2ef3a174a470ecff", "filename": "gcc/ada/mlib-tgt-mingw.adb", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-mingw.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -194,24 +194,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-                        Get_Name_String\n-                          (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-                         Get_Name_String\n-                           (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   MLib.Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -229,20 +233,26 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Name_Len := 3;\n                Name_Buffer (1 .. Name_Len) := \"lib\";\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));"}, {"sha": "dd942b74e9492097ceefd93feb181f3e370d4efa", "filename": "gcc/ada/mlib-tgt-solaris.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-solaris.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2002-2004 Free Software Foundation, Inc.      --\n+--              Copyright (C) 2002-2005 Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -263,22 +263,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -296,23 +302,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "699f022c50457d50824943704691ea3b687f5b1a", "filename": "gcc/ada/mlib-tgt-tru64.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-tru64.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2002-2004 Free Software Foundation, Inc.      --\n+--              Copyright (C) 2002-2005 Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -280,22 +280,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -313,23 +319,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "ca7596b22f9b79a641f8b21723aef32a8b63d28b", "filename": "gcc/ada/mlib-tgt-vms-alpha.adb", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vms-alpha.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,17 +29,19 @@\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n \n-with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n-with GNAT.OS_Lib;                use GNAT.OS_Lib;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n with MLib.Fil;\n with MLib.Utl;\n-with Namet;             use Namet;\n-with Opt;               use Opt;\n-with Output;            use Output;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Output;   use Output;\n with Prj.Com;\n-with System;            use System;\n-with System.Case_Util;  use System.Case_Util;\n+\n+with System;           use System;\n+with System.Case_Util; use System.Case_Util;\n+with System.CRTL;      use System.CRTL;\n \n package body MLib.Tgt is\n \n@@ -50,7 +52,7 @@ package body MLib.Tgt is\n    --  Used to add the generated auto-init object files for auto-initializing\n    --  stand-alone libraries.\n \n-   Macro_Name   : constant String := \"mcr gnu:[bin]gcc -c -x assembler\";\n+   Macro_Name : constant String := \"mcr gnu:[bin]gcc -c -x assembler\";\n    --  The name of the command to invoke the macro-assembler\n \n    VMS_Options : Argument_List := (1 .. 1 => null);\n@@ -72,16 +74,6 @@ package body MLib.Tgt is\n    Link_With_Shared_Libgcc : Argument_List_Access :=\n                                No_Shared_Libgcc_Switch'Access;\n \n-   ------------------------------\n-   -- Target dependent section --\n-   ------------------------------\n-\n-   function Popen (Command, Mode : System.Address) return System.Address;\n-   pragma Import (C, Popen);\n-\n-   function Pclose (File : System.Address) return Integer;\n-   pragma Import (C, Pclose);\n-\n    ---------------------\n    -- Archive_Builder --\n    ---------------------\n@@ -302,12 +294,12 @@ package body MLib.Tgt is\n             Len             : Natural;\n             OK              : Boolean := True;\n \n-            Command  : constant String :=\n+            command  : constant String :=\n                          Macro_Name & \" \" & Macro_File_Name & ASCII.NUL;\n             --  The command to invoke the assembler on the generated auto-init\n             --  assembly file.\n \n-            Mode : constant String := \"r\" & ASCII.NUL;\n+            mode : constant String := \"r\" & ASCII.NUL;\n             --  The mode for the invocation of Popen\n \n          begin\n@@ -365,8 +357,8 @@ package body MLib.Tgt is\n                Write_Line (\"\"\"\");\n             end if;\n \n-            Popen_Result := Popen (Command (Command'First)'Address,\n-                                   Mode (Mode'First)'Address);\n+            Popen_Result := popen (command (command'First)'Address,\n+                                   mode (mode'First)'Address);\n \n             if Popen_Result = Null_Address then\n                Fail (\"assembly of auto-init assembly file \"\"\",\n@@ -375,7 +367,7 @@ package body MLib.Tgt is\n \n             --  Wait for the end of execution of the macro-assembler\n \n-            Pclose_Result := Pclose (Popen_Result);\n+            Pclose_Result := pclose (Popen_Result);\n \n             if Pclose_Result < 0 then\n                Fail (\"assembly of auto init assembly file \"\"\",\n@@ -604,22 +596,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -637,23 +635,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "d3fba7e708f4ea77e28866b8f56322776b23442e", "filename": "gcc/ada/mlib-tgt-vms-ia64.adb", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vms-ia64.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -29,17 +29,19 @@\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n \n-with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n-with GNAT.OS_Lib;                use GNAT.OS_Lib;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n with MLib.Fil;\n with MLib.Utl;\n-with Namet;             use Namet;\n-with Opt;               use Opt;\n-with Output;            use Output;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Output;   use Output;\n with Prj.Com;\n-with System;            use System;\n-with System.Case_Util;  use System.Case_Util;\n+\n+with System;           use System;\n+with System.Case_Util; use System.Case_Util;\n+with System.CRTL;      use System.CRTL;\n \n package body MLib.Tgt is\n \n@@ -72,16 +74,6 @@ package body MLib.Tgt is\n    Link_With_Shared_Libgcc : Argument_List_Access :=\n                                No_Shared_Libgcc_Switch'Access;\n \n-   ------------------------------\n-   -- Target dependent section --\n-   ------------------------------\n-\n-   function Popen (Command, Mode : System.Address) return System.Address;\n-   pragma Import (C, Popen, \"decc$popen\");\n-\n-   function Pclose (File : System.Address) return Integer;\n-   pragma Import (C, Pclose, \"decc$pclose\");\n-\n    ---------------------\n    -- Archive_Builder --\n    ---------------------\n@@ -300,12 +292,12 @@ package body MLib.Tgt is\n             Len             : Natural;\n             OK              : Boolean := True;\n \n-            Command  : constant String :=\n+            command  : constant String :=\n                          Macro_Name & \" \" & Macro_File_Name & ASCII.NUL;\n             --  The command to invoke the assembler on the generated auto-init\n             --  assembly file.\n \n-            Mode : constant String := \"r\" & ASCII.NUL;\n+            mode : constant String := \"r\" & ASCII.NUL;\n             --  The mode for the invocation of Popen\n \n          begin\n@@ -398,8 +390,8 @@ package body MLib.Tgt is\n                Write_Line (\"\"\"\");\n             end if;\n \n-            Popen_Result := Popen (Command (Command'First)'Address,\n-                                   Mode (Mode'First)'Address);\n+            Popen_Result := popen (command (command'First)'Address,\n+                                   mode (mode'First)'Address);\n \n             if Popen_Result = Null_Address then\n                Fail (\"assembly of auto-init assembly file \"\"\",\n@@ -408,7 +400,7 @@ package body MLib.Tgt is\n \n             --  Wait for the end of execution of the macro-assembler\n \n-            Pclose_Result := Pclose (Popen_Result);\n+            Pclose_Result := pclose (Popen_Result);\n \n             if Pclose_Result < 0 then\n                Fail (\"assembly of auto init assembly file \"\"\",\n@@ -637,22 +629,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -670,23 +668,28 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "21c47995640f6ae6d38c1e5a56bbfc1644c79800", "filename": "gcc/ada/mlib-tgt-vxworks.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vxworks.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2003-2004 Free Software Foundation, Inc.         --\n+--           Copyright (C) 2003-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -215,22 +215,28 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Ext_To (Lib_Name, Archive_Ext));\n@@ -248,23 +254,29 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n    begin\n-      if not Projects.Table (Project).Library then\n+      if not In_Tree.Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_Name;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+              Get_Name_String\n+                (In_Tree.Projects.Table (Project).Library_Name);\n \n          begin\n             Name_Len := 3;\n             Name_Buffer (1 .. Name_Len) := \"lib\";\n \n-            if Projects.Table (Project).Library_Kind = Static then\n+            if In_Tree.Projects.Table (Project).Library_Kind =\n+              Static\n+            then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else"}, {"sha": "0f278105e13dfda2eb01acd67850d93370cb73b3", "filename": "gcc/ada/mlib-tgt.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2004, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2005, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -172,8 +172,11 @@ package body MLib.Tgt is\n    -- Library_Exists_For --\n    ------------------------\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean is\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n+   is\n       pragma Unreferenced (Project);\n+      pragma Unreferenced (In_Tree);\n    begin\n       return False;\n    end Library_Exists_For;\n@@ -182,8 +185,12 @@ package body MLib.Tgt is\n    -- Library_File_Name_For --\n    ---------------------------\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id is\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id\n+   is\n       pragma Unreferenced (Project);\n+      pragma Unreferenced (In_Tree);\n    begin\n       return No_Name;\n    end Library_File_Name_For;"}, {"sha": "b4c656ef25b7c4beb8fb169e05f2550ac59aed8a", "filename": "gcc/ada/mlib-tgt.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---              Copyright (C) 2001-2004, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2005, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -147,11 +147,14 @@ package MLib.Tgt is\n    --  into account. For example, on Linux, Foreign, Afiles Lib_Address and\n    --  Relocatable are ignored.\n \n-   function Library_Exists_For (Project : Project_Id) return Boolean;\n+   function Library_Exists_For\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean;\n    --  Return True if the library file for a library project already exists.\n    --  This function can only be called for library projects.\n \n-   function Library_File_Name_For (Project : Project_Id) return Name_Id;\n+   function Library_File_Name_For\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return Name_Id;\n    --  Returns the file name of the library file of a library project.\n    --  This function can only be called for library projects.\n "}, {"sha": "94d73c06a771b92f1cb7f4884368b52cea1097f2", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@\n --  There are predefined packages and attributes.\n --  It is also possible to define new packages with their attributes.\n \n+with Table;\n with Types; use Types;\n \n package Prj.Attr is"}, {"sha": "bc2583fc007baff482181e5963cea59d37d3751f", "filename": "gcc/ada/prj-com.adb", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca89db7aa51322aa15f6d89b692b20ad5898c89/gcc%2Fada%2Fprj-com.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca89db7aa51322aa15f6d89b692b20ad5898c89/gcc%2Fada%2Fprj-com.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.adb?ref=0ca89db7aa51322aa15f6d89b692b20ad5898c89", "patch": "@@ -1,42 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              P R J . C O M                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---             Copyright (C) 2000-2004 Free Software Foundation, Inc.       --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Namet;   use Namet;\n-with Stringt; use Stringt;\n-\n-package body Prj.Com is\n-\n-   ----------\n-   -- Hash --\n-   ----------\n-\n-   function Hash (Name : String_Id) return Header_Num is\n-   begin\n-      String_To_Name_Buffer (Name);\n-      return Hash (Name_Buffer (1 .. Name_Len));\n-   end Hash;\n-\n-end Prj.Com;"}, {"sha": "11b7c5af85c9d202cff5da8f5897a4f1d5ad2f55", "filename": "gcc/ada/prj-com.ads", "status": "modified", "additions": 7, "deletions": 77, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-com.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-com.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,88 +27,18 @@\n --  The following package declares data types for GNAT project.\n --  These data types are used in the bodies of the Prj hierarchy.\n \n-with GNAT.HTable;\n with Osint;\n-with Table;\n-with Types; use Types;\n \n package Prj.Com is\n \n-   --  At one point, this package was private.\n-   --  It cannot be private, because it is used outside of\n-   --  the Prj hierarchy.\n-\n    type Fail_Proc is access procedure\n-     (S1 : String; S2 : String := \"\"; S3 : String := \"\");\n+     (S1 : String;\n+      S2 : String := \"\";\n+      S3 : String := \"\");\n \n    Fail : Fail_Proc := Osint.Fail'Access;\n-   --  This procedure is used in the project facility, instead of\n-   --  directly calling Osint.Fail.\n-   --  It may be specified by tools to do clean up before calling\n-   --  Osint.Fail, or to simply report an error and return.\n-\n-   Tool_Name : Name_Id := No_Name;\n-\n-   Current_Verbosity : Verbosity := Default;\n-\n-   type Spec_Or_Body is\n-     (Specification, Body_Part);\n-\n-   type File_Name_Data is record\n-      Name         : Name_Id := No_Name;\n-      Index        : Int     := 0;\n-      Display_Name : Name_Id := No_Name;\n-      Path         : Name_Id := No_Name;\n-      Display_Path : Name_Id := No_Name;\n-      Project      : Project_Id := No_Project;\n-      Needs_Pragma : Boolean := False;\n-   end record;\n-   --  File and Path name of a spec or body.\n-\n-   type File_Names_Data is array (Spec_Or_Body) of File_Name_Data;\n-\n-   type Unit_Id is new Nat;\n-   No_Unit : constant Unit_Id := 0;\n-   type Unit_Data is record\n-      Name       : Name_Id    := No_Name;\n-      File_Names : File_Names_Data;\n-   end record;\n-   --  File and Path names of a unit, with a reference to its\n-   --  GNAT Project File.\n-\n-   package Units is new Table.Table\n-     (Table_Component_Type => Unit_Data,\n-      Table_Index_Type     => Unit_Id,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 100,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Com.Units\");\n-\n-   function Hash (Name : String_Id) return Header_Num;\n-\n-   package Units_Htable is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Unit_Id,\n-      No_Element => No_Unit,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  Mapping of unit names to indexes in the Units table\n-\n-   type Unit_Project is record\n-      Unit    : Unit_Id    := No_Unit;\n-      Project : Project_Id := No_Project;\n-   end record;\n-\n-   No_Unit_Project : constant Unit_Project := (No_Unit, No_Project);\n-\n-   package Files_Htable is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Unit_Project,\n-      No_Element => No_Unit_Project,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  Mapping of file names to indexes in the Units table\n+   --  This procedure is used in the project facility, instead of directly\n+   --  calling Osint.Fail. It may be specified by tools to do clean up before\n+   --  calling Osint.Fail, or to simply report an error and return.\n \n end Prj.Com;"}, {"sha": "0b64d9b4b2c8337b9328b47f2ef3c139915e8d5a", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 328, "deletions": 242, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2001-2004 Free Software Foundation, Inc          --\n+--           Copyright (C) 2001-2005 Free Software Foundation, Inc          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,40 +45,50 @@ package body Prj.Dect is\n    --  (In_Project).\n \n    procedure Parse_Attribute_Declaration\n-     (Attribute         : out Project_Node_Id;\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Attribute         : out Project_Node_Id;\n       First_Attribute   : Attribute_Node_Id;\n       Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id);\n+      Current_Package   : Project_Node_Id;\n+      Packages_To_Check : String_List_Access);\n    --  Parse an attribute declaration.\n \n    procedure Parse_Case_Construction\n-     (Case_Construction : out Project_Node_Id;\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Case_Construction : out Project_Node_Id;\n       First_Attribute   : Attribute_Node_Id;\n       Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id);\n+      Current_Package   : Project_Node_Id;\n+      Packages_To_Check : String_List_Access);\n    --  Parse a case construction\n \n    procedure Parse_Declarative_Items\n-     (Declarations      : out Project_Node_Id;\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Declarations      : out Project_Node_Id;\n       In_Zone           : Zone;\n       First_Attribute   : Attribute_Node_Id;\n       Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id);\n+      Current_Package   : Project_Node_Id;\n+      Packages_To_Check : String_List_Access);\n    --  Parse declarative items. Depending on In_Zone, some declarative\n    --  items may be forbiden.\n \n    procedure Parse_Package_Declaration\n-     (Package_Declaration : out Project_Node_Id;\n-      Current_Project     : Project_Node_Id);\n+     (In_Tree             : Project_Node_Tree_Ref;\n+      Package_Declaration : out Project_Node_Id;\n+      Current_Project     : Project_Node_Id;\n+      Packages_To_Check   : String_List_Access);\n    --  Parse a package declaration\n \n    procedure Parse_String_Type_Declaration\n-     (String_Type     : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      String_Type     : out Project_Node_Id;\n       Current_Project : Project_Node_Id);\n    --  type <name> is ( <literal_string> { , <literal_string> } ) ;\n \n    procedure Parse_Variable_Declaration\n-     (Variable        : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Variable        : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id);\n    --  Parse a variable assignment\n@@ -90,36 +100,44 @@ package body Prj.Dect is\n    -----------\n \n    procedure Parse\n-     (Declarations    : out Project_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Extends         : Project_Node_Id)\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Declarations      : out Project_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Extends           : Project_Node_Id;\n+      Packages_To_Check : String_List_Access)\n    is\n       First_Declarative_Item : Project_Node_Id := Empty_Node;\n \n    begin\n-      Declarations := Default_Project_Node (Of_Kind => N_Project_Declaration);\n-      Set_Location_Of (Declarations, To => Token_Ptr);\n-      Set_Extended_Project_Of (Declarations, To => Extends);\n-      Set_Project_Declaration_Of (Current_Project, Declarations);\n+      Declarations :=\n+        Default_Project_Node\n+          (Of_Kind => N_Project_Declaration, In_Tree => In_Tree);\n+      Set_Location_Of (Declarations, In_Tree, To => Token_Ptr);\n+      Set_Extended_Project_Of (Declarations, In_Tree, To => Extends);\n+      Set_Project_Declaration_Of (Current_Project, In_Tree, Declarations);\n       Parse_Declarative_Items\n-        (Declarations    => First_Declarative_Item,\n-         In_Zone         => In_Project,\n-         First_Attribute => Prj.Attr.Attribute_First,\n-         Current_Project => Current_Project,\n-         Current_Package => Empty_Node);\n+        (Declarations      => First_Declarative_Item,\n+         In_Tree           => In_Tree,\n+         In_Zone           => In_Project,\n+         First_Attribute   => Prj.Attr.Attribute_First,\n+         Current_Project   => Current_Project,\n+         Current_Package   => Empty_Node,\n+         Packages_To_Check => Packages_To_Check);\n       Set_First_Declarative_Item_Of\n-        (Declarations, To => First_Declarative_Item);\n+        (Declarations, In_Tree, To => First_Declarative_Item);\n    end Parse;\n \n    ---------------------------------\n    -- Parse_Attribute_Declaration --\n    ---------------------------------\n \n    procedure Parse_Attribute_Declaration\n-     (Attribute       : out Project_Node_Id;\n-      First_Attribute : Attribute_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id)\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Attribute         : out Project_Node_Id;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id;\n+      Packages_To_Check : String_List_Access)\n    is\n       Current_Attribute      : Attribute_Node_Id := First_Attribute;\n       Full_Associative_Array : Boolean           := False;\n@@ -129,13 +147,15 @@ package body Prj.Dect is\n       Warning                : Boolean           := False;\n \n    begin\n-      Attribute := Default_Project_Node (Of_Kind => N_Attribute_Declaration);\n-      Set_Location_Of (Attribute, To => Token_Ptr);\n+      Attribute :=\n+        Default_Project_Node\n+          (Of_Kind => N_Attribute_Declaration, In_Tree => In_Tree);\n+      Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n       Set_Previous_Line_Node (Attribute);\n \n       --  Scan past \"for\"\n \n-      Scan;\n+      Scan (In_Tree);\n \n       --  Body may be an attribute name\n \n@@ -148,8 +168,8 @@ package body Prj.Dect is\n \n       if Token = Tok_Identifier then\n          Attribute_Name := Token_Name;\n-         Set_Name_Of (Attribute, To => Token_Name);\n-         Set_Location_Of (Attribute, To => Token_Ptr);\n+         Set_Name_Of (Attribute, In_Tree, To => Token_Name);\n+         Set_Location_Of (Attribute, In_Tree, To => Token_Ptr);\n \n          --  Find the attribute\n \n@@ -161,9 +181,9 @@ package body Prj.Dect is\n \n          if Current_Attribute = Empty_Attribute then\n             if Current_Package /= Empty_Node\n-              and then Expression_Kind_Of (Current_Package) = Ignored\n+              and then Expression_Kind_Of (Current_Package, In_Tree) = Ignored\n             then\n-               Pkg_Id := Package_Id_Of (Current_Package);\n+               Pkg_Id := Package_Id_Of (Current_Package, In_Tree);\n                Add_Attribute (Pkg_Id, Token_Name, Current_Attribute);\n                Error_Msg_Name_1 := Token_Name;\n                Error_Msg (\"?unknown attribute {\", Token_Ptr);\n@@ -173,17 +193,17 @@ package body Prj.Dect is\n                --  if inside a package that does not need to be checked.\n \n                Warning := Current_Package /= Empty_Node and then\n-                          Current_Packages_To_Check /= All_Packages;\n+                          Packages_To_Check /= All_Packages;\n \n                if Warning then\n \n                   --  Check that we are not in a package to check\n \n-                  Get_Name_String (Name_Of (Current_Package));\n+                  Get_Name_String (Name_Of (Current_Package, In_Tree));\n \n-                  for Index in Current_Packages_To_Check'Range loop\n+                  for Index in Packages_To_Check'Range loop\n                      if Name_Buffer (1 .. Name_Len) =\n-                       Current_Packages_To_Check (Index).all\n+                       Packages_To_Check (Index).all\n                      then\n                         Warning := False;\n                         exit;\n@@ -207,29 +227,29 @@ package body Prj.Dect is\n                  Case_Insensitive_Associative_Array ..\n                  Optional_Index_Case_Insensitive_Associative_Array\n          then\n-            Set_Case_Insensitive (Attribute, To => True);\n+            Set_Case_Insensitive (Attribute, In_Tree, To => True);\n          end if;\n \n-         Scan; --  past the attribute name\n+         Scan (In_Tree); --  past the attribute name\n       end if;\n \n       --  Change obsolete names of attributes to the new names\n \n       if Current_Package /= Empty_Node\n-        and then Expression_Kind_Of (Current_Package) /= Ignored\n+        and then Expression_Kind_Of (Current_Package, In_Tree) /= Ignored\n       then\n-         case Name_Of (Attribute) is\n+         case Name_Of (Attribute, In_Tree) is\n          when Snames.Name_Specification =>\n-            Set_Name_Of (Attribute, To => Snames.Name_Spec);\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec);\n \n          when Snames.Name_Specification_Suffix =>\n-            Set_Name_Of (Attribute, To => Snames.Name_Spec_Suffix);\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Spec_Suffix);\n \n          when Snames.Name_Implementation =>\n-            Set_Name_Of (Attribute, To => Snames.Name_Body);\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body);\n \n          when Snames.Name_Implementation_Suffix =>\n-            Set_Name_Of (Attribute, To => Snames.Name_Body_Suffix);\n+            Set_Name_Of (Attribute, In_Tree, To => Snames.Name_Body_Suffix);\n \n          when others =>\n             null;\n@@ -251,24 +271,24 @@ package body Prj.Dect is\n                        Get_Name_String\n                           (Attribute_Name_Of (Current_Attribute)) &\n                        \"\"\" cannot be an associative array\",\n-                       Location_Of (Attribute));\n+                       Location_Of (Attribute, In_Tree));\n \n          elsif Attribute_Kind_Of (Current_Attribute) = Unknown then\n             Set_Attribute_Kind_Of (Current_Attribute, To => Associative_Array);\n          end if;\n \n-         Scan; --  past the left parenthesis\n+         Scan (In_Tree); --  past the left parenthesis\n          Expect (Tok_String_Literal, \"literal string\");\n \n          if Token = Tok_String_Literal then\n-            Set_Associative_Array_Index_Of (Attribute, Token_Name);\n-            Scan; --  past the literal string index\n+            Set_Associative_Array_Index_Of (Attribute, In_Tree, Token_Name);\n+            Scan (In_Tree); --  past the literal string index\n \n             if Token = Tok_At then\n                case Attribute_Kind_Of (Current_Attribute) is\n                   when Optional_Index_Associative_Array |\n                        Optional_Index_Case_Insensitive_Associative_Array =>\n-                     Scan;\n+                     Scan (In_Tree);\n                      Expect (Tok_Integer_Literal, \"integer literal\");\n \n                      if Token = Tok_Integer_Literal then\n@@ -282,19 +302,20 @@ package body Prj.Dect is\n                            if Index = 0 then\n                               Error_Msg (\"index cannot be zero\", Token_Ptr);\n                            else\n-                              Set_Source_Index_Of (Attribute, To => Index);\n+                              Set_Source_Index_Of\n+                                (Attribute, In_Tree, To => Index);\n                            end if;\n                         end;\n \n-                        Scan;\n+                        Scan (In_Tree);\n                      end if;\n \n                   when others =>\n                      Error_Msg (\"index not allowed here\", Token_Ptr);\n-                     Scan;\n+                     Scan (In_Tree);\n \n                      if Token = Tok_Integer_Literal then\n-                        Scan;\n+                        Scan (In_Tree);\n                      end if;\n                end case;\n             end if;\n@@ -303,7 +324,7 @@ package body Prj.Dect is\n          Expect (Tok_Right_Paren, \"`)`\");\n \n          if Token = Tok_Right_Paren then\n-            Scan; --  past the right parenthesis\n+            Scan (In_Tree); --  past the right parenthesis\n          end if;\n \n       else\n@@ -328,14 +349,14 @@ package body Prj.Dect is\n \n       if Current_Attribute /= Empty_Attribute then\n          Set_Expression_Kind_Of\n-           (Attribute, To => Variable_Kind_Of (Current_Attribute));\n+           (Attribute, In_Tree, To => Variable_Kind_Of (Current_Attribute));\n          Optional_Index := Optional_Index_Of (Current_Attribute);\n       end if;\n \n       Expect (Tok_Use, \"USE\");\n \n       if Token = Tok_Use then\n-         Scan;\n+         Scan (In_Tree);\n \n          if Full_Associative_Array then\n \n@@ -368,15 +389,15 @@ package body Prj.Dect is\n                   --  in the project being extended.\n \n                   The_Project := Imported_Or_Extended_Project_Of\n-                                   (Current_Project, Token_Name);\n+                                   (Current_Project, In_Tree, Token_Name);\n \n                   if The_Project = Empty_Node then\n                      Error_Msg (\"unknown project\", Location);\n-                     Scan; --  past the project name\n+                     Scan (In_Tree); --  past the project name\n \n                   else\n                      Project_Name := Token_Name;\n-                     Scan; --  past the project name\n+                     Scan (In_Tree); --  past the project name\n \n                      --  If this is inside a package, a dot followed by the\n                      --  name of the package must followed the project name.\n@@ -388,31 +409,37 @@ package body Prj.Dect is\n                            The_Project := Empty_Node;\n \n                         else\n-                           Scan; --  past the dot\n+                           Scan (In_Tree); --  past the dot\n                            Expect (Tok_Identifier, \"identifier\");\n \n                            if Token /= Tok_Identifier then\n                               The_Project := Empty_Node;\n \n                            --  If it is not the same package name, issue error\n \n-                           elsif Token_Name /= Name_Of (Current_Package) then\n+                           elsif\n+                             Token_Name /= Name_Of (Current_Package, In_Tree)\n+                           then\n                               The_Project := Empty_Node;\n                               Error_Msg\n                                 (\"not the same package as \" &\n-                                 Get_Name_String (Name_Of (Current_Package)),\n+                                 Get_Name_String\n+                                   (Name_Of (Current_Package, In_Tree)),\n                                  Token_Ptr);\n \n                            else\n-                              The_Package := First_Package_Of (The_Project);\n+                              The_Package :=\n+                                First_Package_Of (The_Project, In_Tree);\n \n                               --  Look for the package node\n \n                               while The_Package /= Empty_Node\n-                                and then Name_Of (The_Package) /= Token_Name\n+                                and then\n+                                Name_Of (The_Package, In_Tree) /= Token_Name\n                               loop\n                                  The_Package :=\n-                                   Next_Package_In_Project (The_Package);\n+                                   Next_Package_In_Project\n+                                     (The_Package, In_Tree);\n                               end loop;\n \n                               --  If the package cannot be found in the\n@@ -427,7 +454,7 @@ package body Prj.Dect is\n                                    Token_Ptr);\n                               end if;\n \n-                              Scan; --  past the package name\n+                              Scan (In_Tree); --  past the package name\n                            end if;\n                         end if;\n                      end if;\n@@ -444,7 +471,7 @@ package body Prj.Dect is\n                      The_Project := Empty_Node;\n \n                   else\n-                     Scan; --  past the apostrophe\n+                     Scan (In_Tree); --  past the apostrophe\n                      Expect (Tok_Identifier, \"identifier\");\n \n                      if Token /= Tok_Identifier then\n@@ -459,7 +486,7 @@ package body Prj.Dect is\n                            Error_Msg (\"invalid name, should be %\", Token_Ptr);\n                         end if;\n \n-                        Scan; --  past the attribute name\n+                        Scan (In_Tree); --  past the attribute name\n                      end if;\n                   end if;\n                end if;\n@@ -477,8 +504,8 @@ package body Prj.Dect is\n                   --  characterizes full associative array attribute\n                   --  declarations.\n \n-                  Set_Associative_Project_Of (Attribute, The_Project);\n-                  Set_Associative_Package_Of (Attribute, The_Package);\n+                  Set_Associative_Project_Of (Attribute, In_Tree, The_Project);\n+                  Set_Associative_Package_Of (Attribute, In_Tree, The_Package);\n                end if;\n             end;\n \n@@ -496,24 +523,25 @@ package body Prj.Dect is\n                --  Get the expression value and set it in the attribute node\n \n                Parse_Expression\n-                 (Expression      => Expression,\n+                 (In_Tree         => In_Tree,\n+                  Expression      => Expression,\n                   Current_Project => Current_Project,\n                   Current_Package => Current_Package,\n                   Optional_Index  => Optional_Index);\n-               Set_Expression_Of (Attribute, To => Expression);\n+               Set_Expression_Of (Attribute, In_Tree, To => Expression);\n \n                --  If the expression is legal, but not of the right kind\n                --  for the attribute, issue an error.\n \n                if Current_Attribute /= Empty_Attribute\n                  and then Expression /= Empty_Node\n                  and then Variable_Kind_Of (Current_Attribute) /=\n-                 Expression_Kind_Of (Expression)\n+                 Expression_Kind_Of (Expression, In_Tree)\n                then\n                   if  Variable_Kind_Of (Current_Attribute) = Undefined then\n                      Set_Variable_Kind_Of\n                        (Current_Attribute,\n-                        To => Expression_Kind_Of (Expression));\n+                        To => Expression_Kind_Of (Expression, In_Tree));\n \n                   else\n                      Error_Msg\n@@ -545,10 +573,12 @@ package body Prj.Dect is\n    -----------------------------\n \n    procedure Parse_Case_Construction\n-     (Case_Construction : out Project_Node_Id;\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Case_Construction : out Project_Node_Id;\n       First_Attribute   : Attribute_Node_Id;\n       Current_Project   : Project_Node_Id;\n-      Current_Package   : Project_Node_Id)\n+      Current_Package   : Project_Node_Id;\n+      Packages_To_Check : String_List_Access)\n    is\n       Current_Item    : Project_Node_Id := Empty_Node;\n       Next_Item       : Project_Node_Id := Empty_Node;\n@@ -569,12 +599,13 @@ package body Prj.Dect is\n \n    begin\n       Case_Construction  :=\n-        Default_Project_Node (Of_Kind => N_Case_Construction);\n-      Set_Location_Of (Case_Construction, To => Token_Ptr);\n+        Default_Project_Node\n+          (Of_Kind => N_Case_Construction, In_Tree => In_Tree);\n+      Set_Location_Of (Case_Construction, In_Tree, To => Token_Ptr);\n \n       --  Scan past \"case\"\n \n-      Scan;\n+      Scan (In_Tree);\n \n       --  Get the switch variable\n \n@@ -583,24 +614,25 @@ package body Prj.Dect is\n       if Token = Tok_Identifier then\n          Variable_Location := Token_Ptr;\n          Parse_Variable_Reference\n-           (Variable        => Case_Variable,\n+           (In_Tree         => In_Tree,\n+            Variable        => Case_Variable,\n             Current_Project => Current_Project,\n             Current_Package => Current_Package);\n          Set_Case_Variable_Reference_Of\n-           (Case_Construction, To => Case_Variable);\n+           (Case_Construction, In_Tree, To => Case_Variable);\n \n       else\n          if Token /= Tok_Is then\n-            Scan;\n+            Scan (In_Tree);\n          end if;\n       end if;\n \n       if Case_Variable /= Empty_Node then\n-         String_Type := String_Type_Of (Case_Variable);\n+         String_Type := String_Type_Of (Case_Variable, In_Tree);\n \n          if String_Type = Empty_Node then\n             Error_Msg (\"variable \"\"\" &\n-                       Get_Name_String (Name_Of (Case_Variable)) &\n+                       Get_Name_String (Name_Of (Case_Variable, In_Tree)) &\n                        \"\"\" is not typed\",\n                        Variable_Location);\n          end if;\n@@ -615,38 +647,43 @@ package body Prj.Dect is\n \n          --  Scan past \"is\"\n \n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n-      Start_New_Case_Construction (String_Type);\n+      Start_New_Case_Construction (In_Tree, String_Type);\n \n       When_Loop :\n \n       while Token = Tok_When loop\n \n          if First_Case_Item then\n-            Current_Item := Default_Project_Node (Of_Kind => N_Case_Item);\n-            Set_First_Case_Item_Of (Case_Construction, To => Current_Item);\n+            Current_Item :=\n+              Default_Project_Node\n+                (Of_Kind => N_Case_Item, In_Tree => In_Tree);\n+            Set_First_Case_Item_Of\n+              (Case_Construction, In_Tree, To => Current_Item);\n             First_Case_Item := False;\n \n          else\n-            Next_Item := Default_Project_Node (Of_Kind => N_Case_Item);\n-            Set_Next_Case_Item (Current_Item, To => Next_Item);\n+            Next_Item :=\n+              Default_Project_Node\n+                (Of_Kind => N_Case_Item, In_Tree => In_Tree);\n+            Set_Next_Case_Item (Current_Item, In_Tree, To => Next_Item);\n             Current_Item := Next_Item;\n          end if;\n \n-         Set_Location_Of (Current_Item, To => Token_Ptr);\n+         Set_Location_Of (Current_Item, In_Tree, To => Token_Ptr);\n \n          --  Scan past \"when\"\n \n-         Scan;\n+         Scan (In_Tree);\n \n          if Token = Tok_Others then\n             When_Others := True;\n \n             --  Scan past \"others\"\n \n-            Scan;\n+            Scan (In_Tree);\n \n             Expect (Tok_Arrow, \"`=>`\");\n             Set_End_Of_Line (Current_Item);\n@@ -655,46 +692,52 @@ package body Prj.Dect is\n             --  Empty_Node in Field1 of a Case_Item indicates\n             --  the \"when others =>\" branch.\n \n-            Set_First_Choice_Of (Current_Item, To => Empty_Node);\n+            Set_First_Choice_Of (Current_Item, In_Tree, To => Empty_Node);\n \n             Parse_Declarative_Items\n-              (Declarations    => First_Declarative_Item,\n-               In_Zone         => In_Case_Construction,\n-               First_Attribute => First_Attribute,\n-               Current_Project => Current_Project,\n-               Current_Package => Current_Package);\n+              (In_Tree           => In_Tree,\n+               Declarations      => First_Declarative_Item,\n+               In_Zone           => In_Case_Construction,\n+               First_Attribute   => First_Attribute,\n+               Current_Project   => Current_Project,\n+               Current_Package   => Current_Package,\n+               Packages_To_Check => Packages_To_Check);\n \n             --  \"when others =>\" must be the last branch, so save the\n             --  Case_Item and exit\n \n             Set_First_Declarative_Item_Of\n-              (Current_Item, To => First_Declarative_Item);\n+              (Current_Item, In_Tree, To => First_Declarative_Item);\n             exit When_Loop;\n \n          else\n-            Parse_Choice_List (First_Choice => First_Choice);\n-            Set_First_Choice_Of (Current_Item, To => First_Choice);\n+            Parse_Choice_List\n+              (In_Tree      => In_Tree,\n+               First_Choice => First_Choice);\n+            Set_First_Choice_Of (Current_Item, In_Tree, To => First_Choice);\n \n             Expect (Tok_Arrow, \"`=>`\");\n             Set_End_Of_Line (Current_Item);\n             Set_Previous_Line_Node (Current_Item);\n \n             Parse_Declarative_Items\n-              (Declarations    => First_Declarative_Item,\n-               In_Zone         => In_Case_Construction,\n-               First_Attribute => First_Attribute,\n-               Current_Project => Current_Project,\n-               Current_Package => Current_Package);\n+              (In_Tree           => In_Tree,\n+               Declarations      => First_Declarative_Item,\n+               In_Zone           => In_Case_Construction,\n+               First_Attribute   => First_Attribute,\n+               Current_Project   => Current_Project,\n+               Current_Package   => Current_Package,\n+               Packages_To_Check => Packages_To_Check);\n \n             Set_First_Declarative_Item_Of\n-              (Current_Item, To => First_Declarative_Item);\n+              (Current_Item, In_Tree, To => First_Declarative_Item);\n \n          end if;\n       end loop When_Loop;\n \n       End_Case_Construction\n         (Check_All_Labels => not When_Others and not Quiet_Output,\n-         Case_Location    => Location_Of (Case_Construction));\n+         Case_Location    => Location_Of (Case_Construction, In_Tree));\n \n       Expect (Tok_End, \"`END CASE`\");\n       Remove_Next_End_Node;\n@@ -703,15 +746,15 @@ package body Prj.Dect is\n \n          --  Scan past \"end\"\n \n-         Scan;\n+         Scan (In_Tree);\n \n          Expect (Tok_Case, \"CASE\");\n \n       end if;\n \n       --  Scan past \"case\"\n \n-      Scan;\n+      Scan (In_Tree);\n \n       Expect (Tok_Semicolon, \"`;`\");\n       Set_Previous_End_Node (Case_Construction);\n@@ -723,11 +766,13 @@ package body Prj.Dect is\n    -----------------------------\n \n    procedure Parse_Declarative_Items\n-     (Declarations    : out Project_Node_Id;\n-      In_Zone         : Zone;\n-      First_Attribute : Attribute_Node_Id;\n-      Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id)\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Declarations      : out Project_Node_Id;\n+      In_Zone           : Zone;\n+      First_Attribute   : Attribute_Node_Id;\n+      Current_Project   : Project_Node_Id;\n+      Current_Package   : Project_Node_Id;\n+      Packages_To_Check : String_List_Access)\n    is\n       Current_Declarative_Item : Project_Node_Id := Empty_Node;\n       Next_Declarative_Item    : Project_Node_Id := Empty_Node;\n@@ -742,7 +787,7 @@ package body Prj.Dect is\n          --  the first token of the declarative element.\n          --  Scan past it\n \n-         Scan;\n+         Scan (In_Tree);\n \n          Item_Location := Token_Ptr;\n \n@@ -755,7 +800,8 @@ package body Prj.Dect is\n                end if;\n \n                Parse_Variable_Declaration\n-                 (Current_Declaration,\n+                 (In_Tree,\n+                  Current_Declaration,\n                   Current_Project => Current_Project,\n                   Current_Package => Current_Package);\n \n@@ -765,17 +811,19 @@ package body Prj.Dect is\n             when Tok_For =>\n \n                Parse_Attribute_Declaration\n-                 (Attribute       => Current_Declaration,\n-                  First_Attribute => First_Attribute,\n-                  Current_Project => Current_Project,\n-                  Current_Package => Current_Package);\n+                 (In_Tree           => In_Tree,\n+                  Attribute         => Current_Declaration,\n+                  First_Attribute   => First_Attribute,\n+                  Current_Project   => Current_Project,\n+                  Current_Package   => Current_Package,\n+                  Packages_To_Check => Packages_To_Check);\n \n                Set_End_Of_Line (Current_Declaration);\n                Set_Previous_Line_Node (Current_Declaration);\n \n             when Tok_Null =>\n \n-               Scan; --  past \"null\"\n+               Scan (In_Tree); --  past \"null\"\n \n             when Tok_Package =>\n \n@@ -786,8 +834,10 @@ package body Prj.Dect is\n                end if;\n \n                Parse_Package_Declaration\n-                 (Package_Declaration => Current_Declaration,\n-                  Current_Project     => Current_Project);\n+                 (In_Tree             => In_Tree,\n+                  Package_Declaration => Current_Declaration,\n+                  Current_Project     => Current_Project,\n+                  Packages_To_Check   => Packages_To_Check);\n \n                Set_Previous_End_Node (Current_Declaration);\n \n@@ -801,7 +851,8 @@ package body Prj.Dect is\n                end if;\n \n                Parse_String_Type_Declaration\n-                 (String_Type     => Current_Declaration,\n+                 (In_Tree         => In_Tree,\n+                  String_Type     => Current_Declaration,\n                   Current_Project => Current_Project);\n \n                Set_End_Of_Line (Current_Declaration);\n@@ -812,10 +863,12 @@ package body Prj.Dect is\n                --  Case construction\n \n                Parse_Case_Construction\n-                 (Case_Construction => Current_Declaration,\n+                 (In_Tree           => In_Tree,\n+                  Case_Construction => Current_Declaration,\n                   First_Attribute   => First_Attribute,\n                   Current_Project   => Current_Project,\n-                  Current_Package   => Current_Package);\n+                  Current_Package   => Current_Package,\n+                  Packages_To_Check => Packages_To_Check);\n \n                Set_Previous_End_Node (Current_Declaration);\n \n@@ -837,51 +890,56 @@ package body Prj.Dect is\n          if Current_Declaration /= Empty_Node then\n             if Current_Declarative_Item = Empty_Node then\n                Current_Declarative_Item :=\n-                 Default_Project_Node (Of_Kind => N_Declarative_Item);\n+                 Default_Project_Node\n+                   (Of_Kind => N_Declarative_Item, In_Tree => In_Tree);\n                Declarations  := Current_Declarative_Item;\n \n             else\n                Next_Declarative_Item :=\n-                 Default_Project_Node (Of_Kind => N_Declarative_Item);\n+                 Default_Project_Node\n+                   (Of_Kind => N_Declarative_Item, In_Tree => In_Tree);\n                Set_Next_Declarative_Item\n-                 (Current_Declarative_Item, To => Next_Declarative_Item);\n+                 (Current_Declarative_Item, In_Tree,\n+                  To => Next_Declarative_Item);\n                Current_Declarative_Item := Next_Declarative_Item;\n             end if;\n \n             Set_Current_Item_Node\n-              (Current_Declarative_Item, To => Current_Declaration);\n-            Set_Location_Of (Current_Declarative_Item, To => Item_Location);\n+              (Current_Declarative_Item, In_Tree,\n+               To => Current_Declaration);\n+            Set_Location_Of\n+              (Current_Declarative_Item, In_Tree, To => Item_Location);\n          end if;\n-\n       end loop;\n-\n    end Parse_Declarative_Items;\n \n    -------------------------------\n    -- Parse_Package_Declaration --\n    -------------------------------\n \n    procedure Parse_Package_Declaration\n-     (Package_Declaration : out Project_Node_Id;\n-      Current_Project     : Project_Node_Id)\n+     (In_Tree             : Project_Node_Tree_Ref;\n+      Package_Declaration : out Project_Node_Id;\n+      Current_Project     : Project_Node_Id;\n+      Packages_To_Check   : String_List_Access)\n    is\n       First_Attribute        : Attribute_Node_Id := Empty_Attribute;\n       Current_Package        : Package_Node_Id   := Empty_Package;\n       First_Declarative_Item : Project_Node_Id   := Empty_Node;\n \n    begin\n       Package_Declaration :=\n-        Default_Project_Node (Of_Kind => N_Package_Declaration);\n-      Set_Location_Of (Package_Declaration, To => Token_Ptr);\n+        Default_Project_Node\n+          (Of_Kind => N_Package_Declaration, In_Tree => In_Tree);\n+      Set_Location_Of (Package_Declaration, In_Tree, To => Token_Ptr);\n \n       --  Scan past \"package\"\n \n-      Scan;\n+      Scan (In_Tree);\n       Expect (Tok_Identifier, \"identifier\");\n \n       if Token = Tok_Identifier then\n-\n-         Set_Name_Of (Package_Declaration, To => Token_Name);\n+         Set_Name_Of (Package_Declaration, In_Tree, To => Token_Name);\n \n          Current_Package := Package_Node_Id_Of (Token_Name);\n \n@@ -890,127 +948,136 @@ package body Prj.Dect is\n \n          else\n             Error_Msg (\"?\"\"\" &\n-                       Get_Name_String (Name_Of (Package_Declaration)) &\n+                       Get_Name_String\n+                         (Name_Of (Package_Declaration, In_Tree)) &\n                        \"\"\" is not a known package name\",\n                        Token_Ptr);\n \n             --  Set the package declaration to \"ignored\" so that it is not\n             --  processed by Prj.Proc.Process.\n \n-            Set_Expression_Kind_Of (Package_Declaration, Ignored);\n+            Set_Expression_Kind_Of (Package_Declaration, In_Tree, Ignored);\n \n             --  Add the unknown package in the list of packages\n \n             Add_Unknown_Package (Token_Name, Current_Package);\n          end if;\n \n-         Set_Package_Id_Of (Package_Declaration, To => Current_Package);\n+         Set_Package_Id_Of\n+           (Package_Declaration, In_Tree, To => Current_Package);\n \n          declare\n-            Current : Project_Node_Id := First_Package_Of (Current_Project);\n+            Current : Project_Node_Id :=\n+                        First_Package_Of (Current_Project, In_Tree);\n \n          begin\n             while Current /= Empty_Node\n-              and then Name_Of (Current) /= Token_Name\n+              and then Name_Of (Current, In_Tree) /= Token_Name\n             loop\n-               Current := Next_Package_In_Project (Current);\n+               Current := Next_Package_In_Project (Current, In_Tree);\n             end loop;\n \n             if Current /= Empty_Node then\n                Error_Msg\n                  (\"package \"\"\" &\n-                  Get_Name_String (Name_Of (Package_Declaration)) &\n+                  Get_Name_String (Name_Of (Package_Declaration, In_Tree)) &\n                   \"\"\" is declared twice in the same project\",\n                   Token_Ptr);\n \n             else\n                --  Add the package to the project list\n \n                Set_Next_Package_In_Project\n-                 (Package_Declaration,\n-                  To => First_Package_Of (Current_Project));\n+                 (Package_Declaration, In_Tree,\n+                  To => First_Package_Of (Current_Project, In_Tree));\n                Set_First_Package_Of\n-                 (Current_Project, To => Package_Declaration);\n+                 (Current_Project, In_Tree, To => Package_Declaration);\n             end if;\n          end;\n \n          --  Scan past the package name\n \n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n       if Token = Tok_Renames then\n \n          --  Scan past \"renames\"\n \n-         Scan;\n+         Scan (In_Tree);\n \n          Expect (Tok_Identifier, \"identifier\");\n \n          if Token = Tok_Identifier then\n             declare\n                Project_Name : constant Name_Id := Token_Name;\n                Clause       : Project_Node_Id :=\n-                                First_With_Clause_Of (Current_Project);\n+                              First_With_Clause_Of (Current_Project, In_Tree);\n                The_Project  : Project_Node_Id := Empty_Node;\n                Extended     : constant Project_Node_Id :=\n                                 Extended_Project_Of\n-                                  (Project_Declaration_Of (Current_Project));\n+                                  (Project_Declaration_Of\n+                                    (Current_Project, In_Tree),\n+                                   In_Tree);\n             begin\n                while Clause /= Empty_Node loop\n-                  --  Only non limited imported projects may be used\n-                  --  in a renames declaration.\n+                  --  Only non limited imported projects may be used in a\n+                  --  renames declaration.\n \n-                  The_Project := Non_Limited_Project_Node_Of (Clause);\n+                  The_Project :=\n+                    Non_Limited_Project_Node_Of (Clause, In_Tree);\n                   exit when The_Project /= Empty_Node\n-                    and then Name_Of (The_Project) = Project_Name;\n-                  Clause := Next_With_Clause_Of (Clause);\n+                    and then Name_Of (The_Project, In_Tree) = Project_Name;\n+                  Clause := Next_With_Clause_Of (Clause, In_Tree);\n                end loop;\n \n                if Clause = Empty_Node then\n                   --  As we have not found the project in the imports, we check\n                   --  if it's the name of an eventual extended project.\n \n                   if Extended /= Empty_Node\n-                    and then Name_Of (Extended) = Project_Name then\n+                    and then Name_Of (Extended, In_Tree) = Project_Name\n+                  then\n                      Set_Project_Of_Renamed_Package_Of\n-                       (Package_Declaration, To => Extended);\n+                       (Package_Declaration, In_Tree, To => Extended);\n                   else\n                      Error_Msg_Name_1 := Project_Name;\n                      Error_Msg\n                        (\"% is not an imported or extended project\", Token_Ptr);\n                   end if;\n                else\n                   Set_Project_Of_Renamed_Package_Of\n-                    (Package_Declaration, To => The_Project);\n+                    (Package_Declaration, In_Tree, To => The_Project);\n                end if;\n             end;\n \n-            Scan;\n+            Scan (In_Tree);\n             Expect (Tok_Dot, \"`.`\");\n \n             if Token = Tok_Dot then\n-               Scan;\n+               Scan (In_Tree);\n                Expect (Tok_Identifier, \"identifier\");\n \n                if Token = Tok_Identifier then\n-                  if Name_Of (Package_Declaration) /= Token_Name then\n+                  if Name_Of (Package_Declaration, In_Tree) /= Token_Name then\n                      Error_Msg (\"not the same package name\", Token_Ptr);\n                   elsif\n-                    Project_Of_Renamed_Package_Of (Package_Declaration)\n-                                                              /= Empty_Node\n+                    Project_Of_Renamed_Package_Of\n+                      (Package_Declaration, In_Tree) /= Empty_Node\n                   then\n                      declare\n                         Current : Project_Node_Id :=\n                                     First_Package_Of\n                                       (Project_Of_Renamed_Package_Of\n-                                         (Package_Declaration));\n+                                           (Package_Declaration, In_Tree),\n+                                       In_Tree);\n \n                      begin\n                         while Current /= Empty_Node\n-                          and then Name_Of (Current) /= Token_Name\n+                          and then Name_Of (Current, In_Tree) /= Token_Name\n                         loop\n-                           Current := Next_Package_In_Project (Current);\n+                           Current :=\n+                             Next_Package_In_Project (Current, In_Tree);\n                         end loop;\n \n                         if Current = Empty_Node then\n@@ -1023,7 +1090,7 @@ package body Prj.Dect is\n                      end;\n                   end if;\n \n-                  Scan;\n+                  Scan (In_Tree);\n                end if;\n             end if;\n          end if;\n@@ -1038,41 +1105,43 @@ package body Prj.Dect is\n          Set_Next_End_Node (Package_Declaration);\n \n          Parse_Declarative_Items\n-           (Declarations    => First_Declarative_Item,\n-            In_Zone         => In_Package,\n-            First_Attribute => First_Attribute,\n-            Current_Project => Current_Project,\n-            Current_Package => Package_Declaration);\n+           (In_Tree           => In_Tree,\n+            Declarations      => First_Declarative_Item,\n+            In_Zone           => In_Package,\n+            First_Attribute   => First_Attribute,\n+            Current_Project   => Current_Project,\n+            Current_Package   => Package_Declaration,\n+            Packages_To_Check => Packages_To_Check);\n \n          Set_First_Declarative_Item_Of\n-           (Package_Declaration, To => First_Declarative_Item);\n+           (Package_Declaration, In_Tree, To => First_Declarative_Item);\n \n          Expect (Tok_End, \"END\");\n \n          if Token = Tok_End then\n \n             --  Scan past \"end\"\n \n-            Scan;\n+            Scan (In_Tree);\n          end if;\n \n          --  We should have the name of the package after \"end\"\n \n          Expect (Tok_Identifier, \"identifier\");\n \n          if Token = Tok_Identifier\n-           and then Name_Of (Package_Declaration) /= No_Name\n-           and then Token_Name /= Name_Of (Package_Declaration)\n+           and then Name_Of (Package_Declaration, In_Tree) /= No_Name\n+           and then Token_Name /= Name_Of (Package_Declaration, In_Tree)\n          then\n-            Error_Msg_Name_1 := Name_Of (Package_Declaration);\n+            Error_Msg_Name_1 := Name_Of (Package_Declaration, In_Tree);\n             Error_Msg (\"expected {\", Token_Ptr);\n          end if;\n \n          if Token /= Tok_Semicolon then\n \n             --  Scan past the package name\n \n-            Scan;\n+            Scan (In_Tree);\n          end if;\n \n          Expect (Tok_Semicolon, \"`;`\");\n@@ -1089,33 +1158,35 @@ package body Prj.Dect is\n    -----------------------------------\n \n    procedure Parse_String_Type_Declaration\n-     (String_Type     : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      String_Type     : out Project_Node_Id;\n       Current_Project : Project_Node_Id)\n    is\n       Current      : Project_Node_Id := Empty_Node;\n       First_String : Project_Node_Id := Empty_Node;\n \n    begin\n       String_Type :=\n-        Default_Project_Node (Of_Kind => N_String_Type_Declaration);\n+        Default_Project_Node\n+          (Of_Kind => N_String_Type_Declaration, In_Tree => In_Tree);\n \n-      Set_Location_Of (String_Type, To => Token_Ptr);\n+      Set_Location_Of (String_Type, In_Tree, To => Token_Ptr);\n \n       --  Scan past \"type\"\n \n-      Scan;\n+      Scan (In_Tree);\n \n       Expect (Tok_Identifier, \"identifier\");\n \n       if Token = Tok_Identifier then\n-         Set_Name_Of (String_Type, To => Token_Name);\n+         Set_Name_Of (String_Type, In_Tree, To => Token_Name);\n \n-         Current := First_String_Type_Of (Current_Project);\n+         Current := First_String_Type_Of (Current_Project, In_Tree);\n          while Current /= Empty_Node\n            and then\n-           Name_Of (Current) /= Token_Name\n+           Name_Of (Current, In_Tree) /= Token_Name\n          loop\n-            Current := Next_String_Type (Current);\n+            Current := Next_String_Type (Current, In_Tree);\n          end loop;\n \n          if Current /= Empty_Node then\n@@ -1124,11 +1195,11 @@ package body Prj.Dect is\n                        \"\"\"\",\n                        Token_Ptr);\n          else\n-            Current := First_Variable_Of (Current_Project);\n+            Current := First_Variable_Of (Current_Project, In_Tree);\n             while Current /= Empty_Node\n-              and then Name_Of (Current) /= Token_Name\n+              and then Name_Of (Current, In_Tree) /= Token_Name\n             loop\n-               Current := Next_Variable (Current);\n+               Current := Next_Variable (Current, In_Tree);\n             end loop;\n \n             if Current /= Empty_Node then\n@@ -1137,35 +1208,38 @@ package body Prj.Dect is\n                           \"\"\" is already a variable name\", Token_Ptr);\n             else\n                Set_Next_String_Type\n-                 (String_Type, To => First_String_Type_Of (Current_Project));\n-               Set_First_String_Type_Of (Current_Project, To => String_Type);\n+                 (String_Type, In_Tree,\n+                  To => First_String_Type_Of (Current_Project, In_Tree));\n+               Set_First_String_Type_Of\n+                 (Current_Project, In_Tree, To => String_Type);\n             end if;\n          end if;\n \n          --  Scan past the name\n \n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n       Expect (Tok_Is, \"IS\");\n \n       if Token = Tok_Is then\n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n       Expect (Tok_Left_Paren, \"`(`\");\n \n       if Token = Tok_Left_Paren then\n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n-      Parse_String_Type_List (First_String => First_String);\n-      Set_First_Literal_String (String_Type, To => First_String);\n+      Parse_String_Type_List\n+        (In_Tree => In_Tree, First_String => First_String);\n+      Set_First_Literal_String (String_Type, In_Tree, To => First_String);\n \n       Expect (Tok_Right_Paren, \"`)`\");\n \n       if Token = Tok_Right_Paren then\n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n    end Parse_String_Type_Declaration;\n@@ -1175,7 +1249,8 @@ package body Prj.Dect is\n    --------------------------------\n \n    procedure Parse_Variable_Declaration\n-     (Variable        : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Variable        : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id)\n    is\n@@ -1190,42 +1265,43 @@ package body Prj.Dect is\n \n    begin\n       Variable :=\n-        Default_Project_Node (Of_Kind => N_Variable_Declaration);\n-      Set_Name_Of (Variable, To => Variable_Name);\n-      Set_Location_Of (Variable, To => Token_Ptr);\n+        Default_Project_Node\n+          (Of_Kind => N_Variable_Declaration, In_Tree => In_Tree);\n+      Set_Name_Of (Variable, In_Tree, To => Variable_Name);\n+      Set_Location_Of (Variable, In_Tree, To => Token_Ptr);\n \n       --  Scan past the variable name\n \n-      Scan;\n+      Scan (In_Tree);\n \n       if Token = Tok_Colon then\n \n          --  Typed string variable declaration\n \n-         Scan;\n-         Set_Kind_Of (Variable, N_Typed_Variable_Declaration);\n+         Scan (In_Tree);\n+         Set_Kind_Of (Variable, In_Tree, N_Typed_Variable_Declaration);\n          Expect (Tok_Identifier, \"identifier\");\n \n          OK := Token = Tok_Identifier;\n \n          if OK then\n             String_Type_Name := Token_Name;\n             Type_Location := Token_Ptr;\n-            Scan;\n+            Scan (In_Tree);\n \n             if Token = Tok_Dot then\n                Project_String_Type_Name := String_Type_Name;\n                Project_Location := Type_Location;\n \n                --  Scan past the dot\n \n-               Scan;\n+               Scan (In_Tree);\n                Expect (Tok_Identifier, \"identifier\");\n \n                if Token = Tok_Identifier then\n                   String_Type_Name := Token_Name;\n                   Type_Location := Token_Ptr;\n-                  Scan;\n+                  Scan (In_Tree);\n                else\n                   OK := False;\n                end if;\n@@ -1234,15 +1310,15 @@ package body Prj.Dect is\n             if OK then\n                declare\n                   Current : Project_Node_Id :=\n-                              First_String_Type_Of (Current_Project);\n+                              First_String_Type_Of (Current_Project, In_Tree);\n \n                begin\n                   if Project_String_Type_Name /= No_Name then\n                      declare\n                         The_Project_Name_And_Node : constant\n                           Tree_Private_Part.Project_Name_And_Node :=\n                           Tree_Private_Part.Projects_Htable.Get\n-                                                    (Project_String_Type_Name);\n+                            (In_Tree.Projects_HT, Project_String_Type_Name);\n \n                         use Tree_Private_Part;\n \n@@ -1259,15 +1335,15 @@ package body Prj.Dect is\n                         else\n                            Current :=\n                              First_String_Type_Of\n-                                         (The_Project_Name_And_Node.Node);\n+                               (The_Project_Name_And_Node.Node, In_Tree);\n                         end if;\n                      end;\n                   end if;\n \n                   while Current /= Empty_Node\n-                    and then Name_Of (Current) /= String_Type_Name\n+                    and then Name_Of (Current, In_Tree) /= String_Type_Name\n                   loop\n-                     Current := Next_String_Type (Current);\n+                     Current := Next_String_Type (Current, In_Tree);\n                   end loop;\n \n                   if Current = Empty_Node then\n@@ -1278,7 +1354,7 @@ package body Prj.Dect is\n                      OK := False;\n                   else\n                      Set_String_Type_Of\n-                       (Variable, To => Current);\n+                       (Variable, In_Tree, To => Current);\n                   end if;\n                end;\n             end if;\n@@ -1290,32 +1366,34 @@ package body Prj.Dect is\n       OK := OK and (Token = Tok_Colon_Equal);\n \n       if Token = Tok_Colon_Equal then\n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n       --  Get the single string or string list value\n \n       Expression_Location := Token_Ptr;\n \n       Parse_Expression\n-        (Expression      => Expression,\n+        (In_Tree         => In_Tree,\n+         Expression      => Expression,\n          Current_Project => Current_Project,\n          Current_Package => Current_Package,\n          Optional_Index  => False);\n-      Set_Expression_Of (Variable, To => Expression);\n+      Set_Expression_Of (Variable, In_Tree, To => Expression);\n \n       if Expression /= Empty_Node then\n          --  A typed string must have a single string value, not a list\n \n-         if Kind_Of (Variable) = N_Typed_Variable_Declaration\n-           and then Expression_Kind_Of (Expression) = List\n+         if Kind_Of (Variable, In_Tree) = N_Typed_Variable_Declaration\n+           and then Expression_Kind_Of (Expression, In_Tree) = List\n          then\n             Error_Msg\n               (\"expression must be a single string\", Expression_Location);\n          end if;\n \n          Set_Expression_Kind_Of\n-           (Variable, To => Expression_Kind_Of (Expression));\n+           (Variable, In_Tree,\n+            To => Expression_Kind_Of (Expression, In_Tree));\n       end if;\n \n       if OK then\n@@ -1324,41 +1402,49 @@ package body Prj.Dect is\n \n          begin\n             if Current_Package /= Empty_Node then\n-               The_Variable :=  First_Variable_Of (Current_Package);\n+               The_Variable := First_Variable_Of (Current_Package, In_Tree);\n             elsif Current_Project /= Empty_Node then\n-               The_Variable :=  First_Variable_Of (Current_Project);\n+               The_Variable :=  First_Variable_Of (Current_Project, In_Tree);\n             end if;\n \n             while The_Variable /= Empty_Node\n-              and then Name_Of (The_Variable) /= Variable_Name\n+              and then Name_Of (The_Variable, In_Tree) /= Variable_Name\n             loop\n-               The_Variable := Next_Variable (The_Variable);\n+               The_Variable := Next_Variable (The_Variable, In_Tree);\n             end loop;\n \n             if The_Variable = Empty_Node then\n                if Current_Package /= Empty_Node then\n                   Set_Next_Variable\n-                    (Variable, To => First_Variable_Of (Current_Package));\n-                  Set_First_Variable_Of (Current_Package, To => Variable);\n+                    (Variable, In_Tree,\n+                     To => First_Variable_Of (Current_Package, In_Tree));\n+                  Set_First_Variable_Of\n+                    (Current_Package, In_Tree, To => Variable);\n \n                elsif Current_Project /= Empty_Node then\n                   Set_Next_Variable\n-                    (Variable, To => First_Variable_Of (Current_Project));\n-                  Set_First_Variable_Of (Current_Project, To => Variable);\n+                    (Variable, In_Tree,\n+                     To => First_Variable_Of (Current_Project, In_Tree));\n+                  Set_First_Variable_Of\n+                    (Current_Project, In_Tree, To => Variable);\n                end if;\n \n             else\n-               if Expression_Kind_Of (Variable) /= Undefined then\n-                  if Expression_Kind_Of (The_Variable) = Undefined then\n+               if Expression_Kind_Of (Variable, In_Tree) /= Undefined then\n+                  if\n+                    Expression_Kind_Of (The_Variable, In_Tree) = Undefined\n+                  then\n                      Set_Expression_Kind_Of\n-                       (The_Variable, To => Expression_Kind_Of (Variable));\n+                       (The_Variable, In_Tree,\n+                        To => Expression_Kind_Of (Variable, In_Tree));\n \n                   else\n-                     if Expression_Kind_Of (The_Variable) /=\n-                       Expression_Kind_Of (Variable)\n+                     if Expression_Kind_Of (The_Variable, In_Tree) /=\n+                       Expression_Kind_Of (Variable, In_Tree)\n                      then\n                         Error_Msg (\"wrong expression kind for variable \"\"\" &\n-                                     Get_Name_String (Name_Of (The_Variable)) &\n+                                   Get_Name_String\n+                                     (Name_Of (The_Variable, In_Tree)) &\n                                      \"\"\"\",\n                                    Expression_Location);\n                      end if;"}, {"sha": "ade2e43bc94ea335fbf97ce6b47d9fbdfceedad8", "filename": "gcc/ada/prj-dect.ads", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-dect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-dect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,27 @@ with Prj.Tree;\n private package Prj.Dect is\n \n    procedure Parse\n-     (Declarations    : out Prj.Tree.Project_Node_Id;\n-      Current_Project : Prj.Tree.Project_Node_Id;\n-      Extends         : Prj.Tree.Project_Node_Id);\n-   --  Parse project declarative items. What are parameters ???\n+     (In_Tree           : Prj.Tree.Project_Node_Tree_Ref;\n+      Declarations      : out Prj.Tree.Project_Node_Id;\n+      Current_Project   : Prj.Tree.Project_Node_Id;\n+      Extends           : Prj.Tree.Project_Node_Id;\n+      Packages_To_Check : String_List_Access);\n+   --  Parse project declarative items\n+   --\n+   --  In_Tree is the project node tree\n+   --\n+   --  Declarations is the resulting project node\n+   --\n+   --  Current_Project is the project node of the project for which the\n+   --  declarative items are parsed.\n+   --\n+   --  Extends is the project node of the project that project Current_Project\n+   --  extends. If project Current-Project does not extend any project,\n+   --  Extends has the value Empty_Node.\n+   --\n+   --  Packages_To_Check is the list of packages that needs to be checked.\n+   --  For legal packages declared in project Current_Project that are not in\n+   --  Packages_To_Check, only the syntax of the declarations are checked, not\n+   --  the attribute names and kinds.\n \n end Prj.Dect;"}, {"sha": "02a602e1e56b10d4af3338b614246ebd559e348b", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 376, "deletions": 245, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,16 +29,13 @@ with Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n with Prj.Com;  use Prj.Com;\n-with Table;\n with Tempdir;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n package body Prj.Env is\n \n-   type Naming_Id is new Nat;\n-\n    Current_Source_Path_File : Name_Id := No_Name;\n    --  Current value of project source path file env var.\n    --  Used to avoid setting the env var to the same value.\n@@ -62,63 +59,33 @@ package body Prj.Env is\n    --  platforms, except on VMS where the logical names are deassigned, thus\n    --  avoiding the pollution of the environment of the caller.\n \n-   package Namings is new Table.Table\n-     (Table_Component_Type => Naming_Data,\n-      Table_Index_Type     => Naming_Id,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 5,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Env.Namings\");\n-\n-   Default_Naming : constant Naming_Id := Namings.First;\n+   Default_Naming : constant Naming_Id := Naming_Table.First;\n \n    Fill_Mapping_File : Boolean := True;\n \n-   package Path_Files is new Table.Table\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 50,\n-      Table_Name           => \"Prj.Env.Path_Files\");\n-   --  Table storing all the temp path file names.\n-   --  Used by Delete_All_Path_Files.\n-\n    type Project_Flags is array (Project_Id range <>) of Boolean;\n    --  A Boolean array type used in Create_Mapping_File to select the projects\n    --  in the closure of a specific project.\n \n-   package Source_Paths is new Table.Table\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 50,\n-      Table_Name           => \"Prj.Env.Source_Paths\");\n-   --  A table to store the source dirs before creating the source path file\n-\n-   package Object_Paths is new Table.Table\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 50,\n-      Table_Name           => \"Prj.Env.Source_Paths\");\n-   --  A table to store the object dirs, before creating the object path file\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Body_Path_Name_Of (Unit : Unit_Id) return String;\n+   function Body_Path_Name_Of\n+     (Unit    : Unit_Id;\n+      In_Tree : Project_Tree_Ref) return String;\n    --  Returns the path name of the body of a unit.\n    --  Compute it first, if necessary.\n \n-   function Spec_Path_Name_Of (Unit : Unit_Id) return String;\n+   function Spec_Path_Name_Of\n+     (Unit    : Unit_Id;\n+      In_Tree : Project_Tree_Ref) return String;\n    --  Returns the path name of the spec of a unit.\n    --  Compute it first, if necessary.\n \n-   procedure Add_To_Path (Source_Dirs : String_List_Id);\n+   procedure Add_To_Path\n+     (Source_Dirs : String_List_Id;\n+      In_Tree     : Project_Tree_Ref);\n    --  Add to Ada_Path_Buffer all the source directories in string list\n    --  Source_Dirs, if any. Increment Ada_Path_Length.\n \n@@ -128,19 +95,23 @@ package body Prj.Env is\n    --  If Ada_Path_Length /= 0, prepend a Path_Separator character to\n    --  Path.\n \n-   procedure Add_To_Source_Path (Source_Dirs : String_List_Id);\n+   procedure Add_To_Source_Path\n+     (Source_Dirs : String_List_Id; In_Tree : Project_Tree_Ref);\n    --  Add to Ada_Path_B all the source directories in string list\n    --  Source_Dirs, if any. Increment Ada_Path_Length.\n \n-   procedure Add_To_Object_Path (Object_Dir : Name_Id);\n+   procedure Add_To_Object_Path\n+     (Object_Dir : Name_Id;\n+      In_Tree    : Project_Tree_Ref);\n    --  Add Object_Dir to object path table. Make sure it is not duplicate\n    --  and it is the last one in the current table.\n \n    function Contains_ALI_Files (Dir : Name_Id) return Boolean;\n    --  Return True if there is at least one ALI file in the directory Dir\n \n    procedure Create_New_Path_File\n-     (Path_FD   : out File_Descriptor;\n+     (In_Tree   : Project_Tree_Ref;\n+      Path_FD   : out File_Descriptor;\n       Path_Name : out Name_Id);\n    --  Create a new temporary path file. Get the file name in Path_Name.\n    --  The name is normally obtained by increasing the number in\n@@ -149,15 +120,18 @@ package body Prj.Env is\n    procedure Set_Path_File_Var (Name : String; Value : String);\n    --  Call Setenv, after calling To_Host_File_Spec\n \n-   function Ultimate_Extension_Of (Project : in Project_Id) return Project_Id;\n+   function Ultimate_Extension_Of\n+     (Project : in Project_Id; In_Tree : Project_Tree_Ref) return Project_Id;\n    --  Return a project that is either Project or an extended ancestor of\n    --  Project that itself is not extended.\n \n    ----------------------\n    -- Ada_Include_Path --\n    ----------------------\n \n-   function Ada_Include_Path (Project : Project_Id) return String_Access is\n+   function Ada_Include_Path\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return String_Access is\n \n       procedure Add (Project : Project_Id);\n       --  Add all the source directories of a project to the path only if\n@@ -173,17 +147,18 @@ package body Prj.Env is\n       begin\n          --  If Seen is empty, then the project cannot have been visited\n \n-         if not Projects.Table (Project).Seen then\n-            Projects.Table (Project).Seen := True;\n+         if not In_Tree.Projects.Table (Project).Seen then\n+            In_Tree.Projects.Table (Project).Seen := True;\n \n             declare\n-               Data : constant Project_Data := Projects.Table (Project);\n+               Data : constant Project_Data :=\n+                        In_Tree.Projects.Table (Project);\n                List : Project_List := Data.Imported_Projects;\n \n             begin\n                --  Add to path all source directories of this project\n \n-               Add_To_Path (Data.Source_Dirs);\n+               Add_To_Path (Data.Source_Dirs, In_Tree);\n \n                --  Call Add to the project being extended, if any\n \n@@ -194,8 +169,9 @@ package body Prj.Env is\n                --  Call Add for each imported project, if any\n \n                while List /= Empty_Project_List loop\n-                  Add (Project_Lists.Table (List).Project);\n-                  List := Project_Lists.Table (List).Next;\n+                  Add\n+                    (In_Tree.Project_Lists.Table (List).Project);\n+                  List := In_Tree.Project_Lists.Table (List).Next;\n                end loop;\n             end;\n          end if;\n@@ -207,19 +183,23 @@ package body Prj.Env is\n       --  If it is the first time we call this function for\n       --  this project, compute the source path\n \n-      if Projects.Table (Project).Ada_Include_Path = null then\n+      if\n+        In_Tree.Projects.Table (Project).Ada_Include_Path = null\n+      then\n          Ada_Path_Length := 0;\n \n-         for Index in 1 .. Projects.Last loop\n-            Projects.Table (Index).Seen := False;\n+         for Index in Project_Table.First ..\n+                      Project_Table.Last (In_Tree.Projects)\n+         loop\n+            In_Tree.Projects.Table (Index).Seen := False;\n          end loop;\n \n          Add (Project);\n-         Projects.Table (Project).Ada_Include_Path :=\n+         In_Tree.Projects.Table (Project).Ada_Include_Path :=\n            new String'(Ada_Path_Buffer (1 .. Ada_Path_Length));\n       end if;\n \n-      return Projects.Table (Project).Ada_Include_Path;\n+      return In_Tree.Projects.Table (Project).Ada_Include_Path;\n    end Ada_Include_Path;\n \n    ----------------------\n@@ -228,14 +208,16 @@ package body Prj.Env is\n \n    function Ada_Include_Path\n      (Project   : Project_Id;\n+      In_Tree   : Project_Tree_Ref;\n       Recursive : Boolean) return String\n    is\n    begin\n       if Recursive then\n-         return Ada_Include_Path (Project).all;\n+         return Ada_Include_Path (Project, In_Tree).all;\n       else\n          Ada_Path_Length := 0;\n-         Add_To_Path (Projects.Table (Project).Source_Dirs);\n+         Add_To_Path\n+           (In_Tree.Projects.Table (Project).Source_Dirs, In_Tree);\n          return Ada_Path_Buffer (1 .. Ada_Path_Length);\n       end if;\n    end Ada_Include_Path;\n@@ -246,6 +228,7 @@ package body Prj.Env is\n \n    function Ada_Objects_Path\n      (Project             : Project_Id;\n+      In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean := True) return String_Access\n    is\n       procedure Add (Project : Project_Id);\n@@ -262,11 +245,12 @@ package body Prj.Env is\n       begin\n          --  If this project has not been seen yet\n \n-         if not Projects.Table (Project).Seen then\n-            Projects.Table (Project).Seen := True;\n+         if not In_Tree.Projects.Table (Project).Seen then\n+            In_Tree.Projects.Table (Project).Seen := True;\n \n             declare\n-               Data : constant Project_Data := Projects.Table (Project);\n+               Data : constant Project_Data :=\n+                 In_Tree.Projects.Table (Project);\n                List : Project_List := Data.Imported_Projects;\n \n             begin\n@@ -286,7 +270,8 @@ package body Prj.Env is\n \n                   if Data.Library then\n                      if Data.Object_Directory = No_Name\n-                       or else Contains_ALI_Files (Data.Library_Dir)\n+                       or else\n+                         Contains_ALI_Files (Data.Library_Dir)\n                      then\n                         Add_To_Path (Get_Name_String (Data.Library_Dir));\n                      else\n@@ -309,8 +294,9 @@ package body Prj.Env is\n                --  Call Add for each imported project, if any\n \n                while List /= Empty_Project_List loop\n-                  Add (Project_Lists.Table (List).Project);\n-                  List := Project_Lists.Table (List).Next;\n+                  Add\n+                    (In_Tree.Project_Lists.Table (List).Project);\n+                  List := In_Tree.Project_Lists.Table (List).Next;\n                end loop;\n             end;\n \n@@ -323,60 +309,78 @@ package body Prj.Env is\n       --  If it is the first time we call this function for\n       --  this project, compute the objects path\n \n-      if Projects.Table (Project).Ada_Objects_Path = null then\n+      if\n+        In_Tree.Projects.Table (Project).Ada_Objects_Path = null\n+      then\n          Ada_Path_Length := 0;\n \n-         for Index in 1 .. Projects.Last loop\n-            Projects.Table (Index).Seen := False;\n+         for Index in Project_Table.First ..\n+                      Project_Table.Last (In_Tree.Projects)\n+         loop\n+            In_Tree.Projects.Table (Index).Seen := False;\n          end loop;\n \n          Add (Project);\n-         Projects.Table (Project).Ada_Objects_Path :=\n+         In_Tree.Projects.Table (Project).Ada_Objects_Path :=\n            new String'(Ada_Path_Buffer (1 .. Ada_Path_Length));\n       end if;\n \n-      return Projects.Table (Project).Ada_Objects_Path;\n+      return In_Tree.Projects.Table (Project).Ada_Objects_Path;\n    end Ada_Objects_Path;\n \n    ------------------------\n    -- Add_To_Object_Path --\n    ------------------------\n \n-   procedure Add_To_Object_Path (Object_Dir : Name_Id) is\n+   procedure Add_To_Object_Path\n+     (Object_Dir : Name_Id; In_Tree : Project_Tree_Ref)\n+   is\n    begin\n       --  Check if the directory is already in the table\n \n-      for Index in 1 .. Object_Paths.Last loop\n+      for Index in Object_Path_Table.First ..\n+                   Object_Path_Table.Last (In_Tree.Private_Part.Object_Paths)\n+      loop\n \n          --  If it is, remove it, and add it as the last one\n \n-         if Object_Paths.Table (Index) = Object_Dir then\n-            for Index2 in Index + 1 .. Object_Paths.Last loop\n-               Object_Paths.Table (Index2 - 1) :=\n-                 Object_Paths.Table (Index2);\n+         if In_Tree.Private_Part.Object_Paths.Table (Index) = Object_Dir then\n+            for Index2 in Index + 1 ..\n+                          Object_Path_Table.Last\n+                            (In_Tree.Private_Part.Object_Paths)\n+            loop\n+               In_Tree.Private_Part.Object_Paths.Table (Index2 - 1) :=\n+                 In_Tree.Private_Part.Object_Paths.Table (Index2);\n             end loop;\n \n-            Object_Paths.Table (Object_Paths.Last) := Object_Dir;\n+            In_Tree.Private_Part.Object_Paths.Table\n+              (Object_Path_Table.Last (In_Tree.Private_Part.Object_Paths)) :=\n+                 Object_Dir;\n             return;\n          end if;\n       end loop;\n \n       --  The directory is not already in the table, add it\n \n-      Object_Paths.Increment_Last;\n-      Object_Paths.Table (Object_Paths.Last) := Object_Dir;\n+      Object_Path_Table.Increment_Last (In_Tree.Private_Part.Object_Paths);\n+      In_Tree.Private_Part.Object_Paths.Table\n+        (Object_Path_Table.Last (In_Tree.Private_Part.Object_Paths)) :=\n+           Object_Dir;\n    end Add_To_Object_Path;\n \n    -----------------\n    -- Add_To_Path --\n    -----------------\n \n-   procedure Add_To_Path (Source_Dirs : String_List_Id) is\n+   procedure Add_To_Path\n+     (Source_Dirs : String_List_Id;\n+      In_Tree     : Project_Tree_Ref)\n+   is\n       Current    : String_List_Id := Source_Dirs;\n       Source_Dir : String_Element;\n    begin\n       while Current /= Nil_String loop\n-         Source_Dir := String_Elements.Table (Current);\n+         Source_Dir := In_Tree.String_Elements.Table (Current);\n          Add_To_Path (Get_Name_String (Source_Dir.Display_Value));\n          Current := Source_Dir.Next;\n       end loop;\n@@ -467,7 +471,9 @@ package body Prj.Env is\n    -- Add_To_Source_Path --\n    ------------------------\n \n-   procedure Add_To_Source_Path (Source_Dirs : String_List_Id) is\n+   procedure Add_To_Source_Path\n+     (Source_Dirs : String_List_Id; In_Tree : Project_Tree_Ref)\n+   is\n       Current    : String_List_Id := Source_Dirs;\n       Source_Dir : String_Element;\n       Add_It     : Boolean;\n@@ -476,23 +482,31 @@ package body Prj.Env is\n       --  Add each source directory\n \n       while Current /= Nil_String loop\n-         Source_Dir := String_Elements.Table (Current);\n+         Source_Dir := In_Tree.String_Elements.Table (Current);\n          Add_It := True;\n \n          --  Check if the source directory is already in the table\n \n-         for Index in 1 .. Source_Paths.Last loop\n+         for Index in Source_Path_Table.First ..\n+                      Source_Path_Table.Last\n+                                          (In_Tree.Private_Part.Source_Paths)\n+         loop\n             --  If it is already, no need to add it\n \n-            if Source_Paths.Table (Index) = Source_Dir.Value then\n+            if In_Tree.Private_Part.Source_Paths.Table (Index) =\n+                        Source_Dir.Value\n+            then\n                Add_It := False;\n                exit;\n             end if;\n          end loop;\n \n          if Add_It then\n-            Source_Paths.Increment_Last;\n-            Source_Paths.Table (Source_Paths.Last) := Source_Dir.Value;\n+            Source_Path_Table.Increment_Last\n+              (In_Tree.Private_Part.Source_Paths);\n+            In_Tree.Private_Part.Source_Paths.Table\n+              (Source_Path_Table.Last (In_Tree.Private_Part.Source_Paths)) :=\n+              Source_Dir.Value;\n          end if;\n \n          --  Next source directory\n@@ -505,8 +519,10 @@ package body Prj.Env is\n    -- Body_Path_Name_Of --\n    -----------------------\n \n-   function Body_Path_Name_Of (Unit : Unit_Id) return String is\n-      Data : Unit_Data := Units.Table (Unit);\n+   function Body_Path_Name_Of\n+     (Unit : Unit_Id; In_Tree : Project_Tree_Ref) return String\n+   is\n+      Data : Unit_Data := In_Tree.Units.Table (Unit);\n \n    begin\n       --  If we don't know the path name of the body of this unit,\n@@ -515,7 +531,8 @@ package body Prj.Env is\n       if Data.File_Names (Body_Part).Path = No_Name then\n          declare\n             Current_Source : String_List_Id :=\n-              Projects.Table (Data.File_Names (Body_Part).Project).Sources;\n+              In_Tree.Projects.Table\n+                (Data.File_Names (Body_Part).Project).Sources;\n             Path : GNAT.OS_Lib.String_Access;\n \n          begin\n@@ -532,10 +549,11 @@ package body Prj.Env is\n                    (Namet.Get_Name_String\n                       (Data.File_Names (Body_Part).Name),\n                     Namet.Get_Name_String\n-                       (String_Elements.Table (Current_Source).Value));\n+                      (In_Tree.String_Elements.Table\n+                         (Current_Source).Value));\n \n-               --  If the file is in this directory,\n-               --  then we store the path, and we are done.\n+               --  If the file is in this directory, then we store the path,\n+               --  and we are done.\n \n                if Path /= null then\n                   Name_Len := Path'Length;\n@@ -545,11 +563,12 @@ package body Prj.Env is\n \n                else\n                   Current_Source :=\n-                    String_Elements.Table (Current_Source).Next;\n+                    In_Tree.String_Elements.Table\n+                      (Current_Source).Next;\n                end if;\n             end loop;\n \n-            Units.Table (Unit) := Data;\n+            In_Tree.Units.Table (Unit) := Data;\n          end;\n       end if;\n \n@@ -604,6 +623,7 @@ package body Prj.Env is\n    procedure Create_Config_Pragmas_File\n      (For_Project          : Project_Id;\n       Main_Project         : Project_Id;\n+      In_Tree              : Project_Tree_Ref;\n       Include_Config_Files : Boolean := True)\n    is\n       pragma Unreferenced (Main_Project);\n@@ -612,7 +632,7 @@ package body Prj.Env is\n       File_Name : Name_Id         := No_Name;\n       File      : File_Descriptor := Invalid_FD;\n \n-      Current_Unit : Unit_Id := Units.First;\n+      Current_Unit : Unit_Id := Unit_Table.First;\n \n       First_Project : Project_List := Empty_Project_List;\n \n@@ -648,7 +668,8 @@ package body Prj.Env is\n       -----------\n \n       procedure Check (Project : Project_Id) is\n-         Data : constant Project_Data := Projects.Table (Project);\n+         Data : constant Project_Data :=\n+           In_Tree.Projects.Table (Project);\n \n       begin\n          if Current_Verbosity = High then\n@@ -662,34 +683,44 @@ package body Prj.Env is\n \n          Current_Project := First_Project;\n          while Current_Project /= Empty_Project_List\n-           and then Project_Lists.Table (Current_Project).Project /= Project\n+           and then In_Tree.Project_Lists.Table\n+                      (Current_Project).Project /= Project\n          loop\n-            Current_Project := Project_Lists.Table (Current_Project).Next;\n+            Current_Project :=\n+              In_Tree.Project_Lists.Table (Current_Project).Next;\n          end loop;\n \n          --  If it is not, put it in the list, and visit it\n \n          if Current_Project = Empty_Project_List then\n-            Project_Lists.Increment_Last;\n-            Project_Lists.Table (Project_Lists.Last) :=\n-              (Project => Project, Next => First_Project);\n-            First_Project := Project_Lists.Last;\n+            Project_List_Table.Increment_Last\n+              (In_Tree.Project_Lists);\n+            In_Tree.Project_Lists.Table\n+              (Project_List_Table.Last (In_Tree.Project_Lists)) :=\n+                 (Project => Project, Next => First_Project);\n+               First_Project :=\n+                 Project_List_Table.Last (In_Tree.Project_Lists);\n \n             --  Is the naming scheme of this project one that we know?\n \n             Current_Naming := Default_Naming;\n-            while Current_Naming <= Namings.Last and then\n-              not Same_Naming_Scheme\n-              (Left => Namings.Table (Current_Naming),\n+            while Current_Naming <=\n+                    Naming_Table.Last (In_Tree.Private_Part.Namings)\n+              and then not Same_Naming_Scheme\n+              (Left => In_Tree.Private_Part.Namings.Table (Current_Naming),\n                Right => Data.Naming) loop\n                Current_Naming := Current_Naming + 1;\n             end loop;\n \n             --  If we don't know it, add it\n \n-            if Current_Naming > Namings.Last then\n-               Namings.Increment_Last;\n-               Namings.Table (Namings.Last) := Data.Naming;\n+            if Current_Naming >\n+                 Naming_Table.Last (In_Tree.Private_Part.Namings)\n+            then\n+               Naming_Table.Increment_Last (In_Tree.Private_Part.Namings);\n+               In_Tree.Private_Part.Namings.Table\n+                 (Naming_Table.Last (In_Tree.Private_Part.Namings)) :=\n+                    Data.Naming;\n \n                --  We need a temporary file to be created\n \n@@ -760,8 +791,11 @@ package body Prj.Env is\n \n             begin\n                while Current /= Empty_Project_List loop\n-                  Check (Project_Lists.Table (Current).Project);\n-                  Current := Project_Lists.Table (Current).Next;\n+                  Check\n+                    (In_Tree.Project_Lists.Table\n+                       (Current).Project);\n+                  Current := In_Tree.Project_Lists.Table\n+                               (Current).Next;\n                end loop;\n             end;\n          end if;\n@@ -870,22 +904,26 @@ package body Prj.Env is\n    --  Start of processing for Create_Config_Pragmas_File\n \n    begin\n-      if not Projects.Table (For_Project).Config_Checked then\n+      if not\n+        In_Tree.Projects.Table (For_Project).Config_Checked\n+      then\n \n          --  Remove any memory of processed naming schemes, if any\n \n-         Namings.Set_Last (Default_Naming);\n+         Naming_Table.Set_Last (In_Tree.Private_Part.Namings, Default_Naming);\n \n          --  Check the naming schemes\n \n          Check (For_Project);\n \n          --  Visit all the units and process those that need an SFN pragma\n \n-         while Current_Unit <= Units.Last loop\n+         while\n+           Current_Unit <= Unit_Table.Last (In_Tree.Units)\n+         loop\n             declare\n                Unit : constant Unit_Data :=\n-                 Units.Table (Current_Unit);\n+                 In_Tree.Units.Table (Current_Unit);\n \n             begin\n                if Unit.File_Names (Specification).Needs_Pragma then\n@@ -938,10 +976,13 @@ package body Prj.Env is\n             Write_Line (\"\"\"\");\n          end if;\n \n-         Projects.Table (For_Project).Config_File_Name := File_Name;\n-         Projects.Table (For_Project).Config_File_Temp := True;\n+         In_Tree.Projects.Table (For_Project).Config_File_Name :=\n+           File_Name;\n+         In_Tree.Projects.Table (For_Project).Config_File_Temp :=\n+           True;\n \n-         Projects.Table (For_Project).Config_Checked := True;\n+         In_Tree.Projects.Table (For_Project).Config_Checked :=\n+           True;\n       end if;\n    end Create_Config_Pragmas_File;\n \n@@ -951,6 +992,7 @@ package body Prj.Env is\n \n    procedure Create_Mapping_File\n      (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref;\n       Name    : out Name_Id)\n    is\n       File          : File_Descriptor := Invalid_FD;\n@@ -960,7 +1002,8 @@ package body Prj.Env is\n       Status : Boolean;\n       --  For call to Close\n \n-      Present : Project_Flags (No_Project .. Projects.Last) :=\n+      Present       : Project_Flags\n+        (No_Project .. Project_Table.Last (In_Tree.Projects)) :=\n         (others => False);\n       --  For each project in the closure of Project, the corresponding flag\n       --  will be set to True;\n@@ -1045,19 +1088,22 @@ package body Prj.Env is\n          --  Flag the current project\n \n          Present (Prj) := True;\n-         Imported := Projects.Table (Prj).Imported_Projects;\n+         Imported :=\n+           In_Tree.Projects.Table (Prj).Imported_Projects;\n \n          --  Call itself for each project directly imported\n \n          while Imported /= Empty_Project_List loop\n-            Proj := Project_Lists.Table (Imported).Project;\n-            Imported := Project_Lists.Table (Imported).Next;\n+            Proj :=\n+              In_Tree.Project_Lists.Table (Imported).Project;\n+            Imported :=\n+              In_Tree.Project_Lists.Table (Imported).Next;\n             Recursive_Flag (Proj);\n          end loop;\n \n          --  Call itself for an eventual project being extended\n \n-         Recursive_Flag (Projects.Table (Prj).Extends);\n+         Recursive_Flag (In_Tree.Projects.Table (Prj).Extends);\n       end Recursive_Flag;\n \n    --  Start of processing for Create_Mapping_File\n@@ -1081,10 +1127,11 @@ package body Prj.Env is\n       end if;\n \n       if Fill_Mapping_File then\n+\n          --  For all units in table Units\n \n-         for Unit in 1 .. Units.Last loop\n-            The_Unit_Data := Units.Table (Unit);\n+         for Unit in 1 .. Unit_Table.Last (In_Tree.Units) loop\n+            The_Unit_Data := In_Tree.Units.Table (Unit);\n \n             --  If the unit has a valid name\n \n@@ -1123,7 +1170,8 @@ package body Prj.Env is\n    --------------------------\n \n    procedure Create_New_Path_File\n-     (Path_FD   : out File_Descriptor;\n+     (In_Tree   : Project_Tree_Ref;\n+      Path_FD   : out File_Descriptor;\n       Path_Name : out Name_Id)\n    is\n    begin\n@@ -1134,23 +1182,29 @@ package body Prj.Env is\n          --  Record the name, so that the temp path file will be deleted\n          --  at the end of the program.\n \n-         Path_Files.Increment_Last;\n-         Path_Files.Table (Path_Files.Last) := Path_Name;\n+         Path_File_Table.Increment_Last (In_Tree.Private_Part.Path_Files);\n+         In_Tree.Private_Part.Path_Files.Table\n+           (Path_File_Table.Last (In_Tree.Private_Part.Path_Files)) :=\n+              Path_Name;\n       end if;\n    end Create_New_Path_File;\n \n    ---------------------------\n    -- Delete_All_Path_Files --\n    ---------------------------\n \n-   procedure Delete_All_Path_Files is\n+   procedure Delete_All_Path_Files (In_Tree : Project_Tree_Ref) is\n       Disregard : Boolean := True;\n \n    begin\n-      for Index in 1 .. Path_Files.Last loop\n-         if Path_Files.Table (Index) /= No_Name then\n+      for Index in Path_File_Table.First ..\n+                   Path_File_Table.Last (In_Tree.Private_Part.Path_Files)\n+      loop\n+         if In_Tree.Private_Part.Path_Files.Table (Index) /= No_Name then\n             Delete_File\n-              (Get_Name_String (Path_Files.Table (Index)), Disregard);\n+              (Get_Name_String\n+                 (In_Tree.Private_Part.Path_Files.Table (Index)),\n+               Disregard);\n          end if;\n       end loop;\n \n@@ -1177,11 +1231,13 @@ package body Prj.Env is\n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;\n+      In_Tree           : Project_Tree_Ref;\n       Main_Project_Only : Boolean := True;\n       Full_Path         : Boolean := False) return String\n    is\n       The_Project   : Project_Id := Project;\n-      Data          : Project_Data := Projects.Table (Project);\n+      Data          : Project_Data :=\n+                        In_Tree.Projects.Table (Project);\n       Original_Name : String := Name;\n \n       Extended_Spec_Name : String :=\n@@ -1236,8 +1292,10 @@ package body Prj.Env is\n          --  Loop through units\n          --  Should have comment explaining reverse ???\n \n-         for Current in reverse Units.First .. Units.Last loop\n-            Unit := Units.Table (Current);\n+         for Current in reverse Unit_Table.First ..\n+                                Unit_Table.Last (In_Tree.Units)\n+         loop\n+            Unit := In_Tree.Units.Table (Current);\n \n             --  Check for body\n \n@@ -1370,7 +1428,7 @@ package body Prj.Env is\n          --  Otherwise, look in the project we are extending\n \n          The_Project := Data.Extends;\n-         Data := Projects.Table (The_Project);\n+         Data := In_Tree.Projects.Table (The_Project);\n       end loop;\n \n       --  We don't know this file name, return an empty string\n@@ -1382,7 +1440,10 @@ package body Prj.Env is\n    -- For_All_Object_Dirs --\n    -------------------------\n \n-   procedure For_All_Object_Dirs (Project : Project_Id) is\n+   procedure For_All_Object_Dirs\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref)\n+   is\n       Seen : Project_List := Empty_Project_List;\n \n       procedure Add (Project : Project_Id);\n@@ -1395,17 +1456,20 @@ package body Prj.Env is\n       ---------\n \n       procedure Add (Project : Project_Id) is\n-         Data : constant Project_Data := Projects.Table (Project);\n+         Data : constant Project_Data :=\n+                  In_Tree.Projects.Table (Project);\n          List : Project_List := Data.Imported_Projects;\n \n       begin\n          --  If the list of visited project is empty, then\n          --  for sure we never visited this project.\n \n          if Seen = Empty_Project_List then\n-            Project_Lists.Increment_Last;\n-            Seen := Project_Lists.Last;\n-            Project_Lists.Table (Seen) :=\n+            Project_List_Table.Increment_Last\n+              (In_Tree.Project_Lists);\n+            Seen :=\n+              Project_List_Table.Last (In_Tree.Project_Lists);\n+            In_Tree.Project_Lists.Table (Seen) :=\n               (Project => Project, Next => Empty_Project_List);\n \n          else\n@@ -1418,21 +1482,29 @@ package body Prj.Env is\n                loop\n                   --  If it is, then there is nothing else to do\n \n-                  if Project_Lists.Table (Current).Project = Project then\n+                  if In_Tree.Project_Lists.Table\n+                                           (Current).Project = Project\n+                  then\n                      return;\n                   end if;\n \n-                  exit when Project_Lists.Table (Current).Next =\n-                    Empty_Project_List;\n-                  Current := Project_Lists.Table (Current).Next;\n+                  exit when\n+                    In_Tree.Project_Lists.Table (Current).Next =\n+                      Empty_Project_List;\n+                  Current :=\n+                    In_Tree.Project_Lists.Table (Current).Next;\n                end loop;\n \n                --  This project has never been visited, add it\n                --  to the list.\n \n-               Project_Lists.Increment_Last;\n-               Project_Lists.Table (Current).Next := Project_Lists.Last;\n-               Project_Lists.Table (Project_Lists.Last) :=\n+               Project_List_Table.Increment_Last\n+                 (In_Tree.Project_Lists);\n+               In_Tree.Project_Lists.Table (Current).Next :=\n+                 Project_List_Table.Last (In_Tree.Project_Lists);\n+               In_Tree.Project_Lists.Table\n+                 (Project_List_Table.Last\n+                    (In_Tree.Project_Lists)) :=\n                  (Project => Project, Next => Empty_Project_List);\n             end;\n          end if;\n@@ -1454,8 +1526,8 @@ package body Prj.Env is\n          --  And visit all imported projects\n \n          while List /= Empty_Project_List loop\n-            Add (Project_Lists.Table (List).Project);\n-            List := Project_Lists.Table (List).Next;\n+            Add (In_Tree.Project_Lists.Table (List).Project);\n+            List := In_Tree.Project_Lists.Table (List).Next;\n          end loop;\n       end Add;\n \n@@ -1472,7 +1544,10 @@ package body Prj.Env is\n    -- For_All_Source_Dirs --\n    -------------------------\n \n-   procedure For_All_Source_Dirs (Project : Project_Id) is\n+   procedure For_All_Source_Dirs\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref)\n+   is\n       Seen : Project_List := Empty_Project_List;\n \n       procedure Add (Project : Project_Id);\n@@ -1485,17 +1560,20 @@ package body Prj.Env is\n       ---------\n \n       procedure Add (Project : Project_Id) is\n-         Data : constant Project_Data := Projects.Table (Project);\n+         Data : constant Project_Data :=\n+                  In_Tree.Projects.Table (Project);\n          List : Project_List := Data.Imported_Projects;\n \n       begin\n          --  If the list of visited project is empty, then\n          --  for sure we never visited this project.\n \n          if Seen = Empty_Project_List then\n-            Project_Lists.Increment_Last;\n-            Seen := Project_Lists.Last;\n-            Project_Lists.Table (Seen) :=\n+            Project_List_Table.Increment_Last\n+              (In_Tree.Project_Lists);\n+            Seen := Project_List_Table.Last\n+                                         (In_Tree.Project_Lists);\n+            In_Tree.Project_Lists.Table (Seen) :=\n               (Project => Project, Next => Empty_Project_List);\n \n          else\n@@ -1508,21 +1586,29 @@ package body Prj.Env is\n                loop\n                   --  If it is, then there is nothing else to do\n \n-                  if Project_Lists.Table (Current).Project = Project then\n+                  if In_Tree.Project_Lists.Table\n+                                           (Current).Project = Project\n+                  then\n                      return;\n                   end if;\n \n-                  exit when Project_Lists.Table (Current).Next =\n-                    Empty_Project_List;\n-                  Current := Project_Lists.Table (Current).Next;\n+                  exit when\n+                    In_Tree.Project_Lists.Table (Current).Next =\n+                      Empty_Project_List;\n+                  Current :=\n+                    In_Tree.Project_Lists.Table (Current).Next;\n                end loop;\n \n                --  This project has never been visited, add it\n                --  to the list.\n \n-               Project_Lists.Increment_Last;\n-               Project_Lists.Table (Current).Next := Project_Lists.Last;\n-               Project_Lists.Table (Project_Lists.Last) :=\n+               Project_List_Table.Increment_Last\n+                 (In_Tree.Project_Lists);\n+               In_Tree.Project_Lists.Table (Current).Next :=\n+                 Project_List_Table.Last (In_Tree.Project_Lists);\n+               In_Tree.Project_Lists.Table\n+                 (Project_List_Table.Last\n+                    (In_Tree.Project_Lists)) :=\n                  (Project => Project, Next => Empty_Project_List);\n             end;\n          end if;\n@@ -1535,9 +1621,12 @@ package body Prj.Env is\n             --  If there are Ada sources, call action with the name of every\n             --  source directory.\n \n-            if Projects.Table (Project).Ada_Sources_Present then\n+            if\n+              In_Tree.Projects.Table (Project).Ada_Sources_Present\n+            then\n                while Current /= Nil_String loop\n-                  The_String := String_Elements.Table (Current);\n+                  The_String :=\n+                    In_Tree.String_Elements.Table (Current);\n                   Action (Get_Name_String (The_String.Value));\n                   Current := The_String.Next;\n                end loop;\n@@ -1553,8 +1642,8 @@ package body Prj.Env is\n          --  And visit all imported projects\n \n          while List /= Empty_Project_List loop\n-            Add (Project_Lists.Table (List).Project);\n-            List := Project_Lists.Table (List).Next;\n+            Add (In_Tree.Project_Lists.Table (List).Project);\n+            List := In_Tree.Project_Lists.Table (List).Next;\n          end loop;\n       end Add;\n \n@@ -1572,6 +1661,7 @@ package body Prj.Env is\n \n    procedure Get_Reference\n      (Source_File_Name : String;\n+      In_Tree          : Project_Tree_Ref;\n       Project          : out Project_Id;\n       Path             : out Name_Id)\n    is\n@@ -1591,8 +1681,10 @@ package body Prj.Env is\n       begin\n          Canonical_Case_File_Name (Original_Name);\n \n-         for Id in Units.First .. Units.Last loop\n-            Unit := Units.Table (Id);\n+         for Id in Unit_Table.First ..\n+                   Unit_Table.Last (In_Tree.Units)\n+         loop\n+            Unit := In_Tree.Units.Table (Id);\n \n             if (Unit.File_Names (Specification).Name /= No_Name\n                  and then\n@@ -1605,7 +1697,8 @@ package body Prj.Env is\n                                                               Original_Name)\n             then\n                Project := Ultimate_Extension_Of\n-                            (Unit.File_Names (Specification).Project);\n+                           (Project => Unit.File_Names (Specification).Project,\n+                            In_Tree => In_Tree);\n                Path := Unit.File_Names (Specification).Display_Path;\n \n                if Current_Verbosity > Default then\n@@ -1625,7 +1718,8 @@ package body Prj.Env is\n                                                              Original_Name)\n             then\n                Project := Ultimate_Extension_Of\n-                            (Unit.File_Names (Body_Part).Project);\n+                            (Project => Unit.File_Names (Body_Part).Project,\n+                             In_Tree => In_Tree);\n                Path := Unit.File_Names (Body_Part).Display_Path;\n \n                if Current_Verbosity > Default then\n@@ -1651,12 +1745,9 @@ package body Prj.Env is\n    -- Initialize --\n    ----------------\n \n-   --  This is a place holder for possible required initialization in\n-   --  the future. In the current version no initialization is required.\n-\n    procedure Initialize is\n    begin\n-      null;\n+      Fill_Mapping_File := True;\n    end Initialize;\n \n    ------------------------------------\n@@ -1667,9 +1758,11 @@ package body Prj.Env is\n \n    function Path_Name_Of_Library_Unit_Body\n      (Name    : String;\n-      Project : Project_Id) return String\n+      Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return String\n    is\n-      Data          : constant Project_Data := Projects.Table (Project);\n+      Data          : constant Project_Data :=\n+                        In_Tree.Projects.Table (Project);\n       Original_Name : String := Name;\n \n       Extended_Spec_Name : String :=\n@@ -1679,7 +1772,7 @@ package body Prj.Env is\n                              Name & Namet.Get_Name_String\n                                      (Data.Naming.Ada_Body_Suffix);\n \n-      First   : Unit_Id := Units.First;\n+      First   : Unit_Id := Unit_Table.First;\n       Current : Unit_Id;\n       Unit    : Unit_Data;\n \n@@ -1703,15 +1796,16 @@ package body Prj.Env is\n          Write_Eol;\n       end if;\n \n-      while First <= Units.Last\n-        and then Units.Table (First).File_Names (Body_Part).Project /= Project\n+      while First <= Unit_Table.Last (In_Tree.Units)\n+        and then In_Tree.Units.Table\n+                   (First).File_Names (Body_Part).Project /= Project\n       loop\n          First := First + 1;\n       end loop;\n \n       Current := First;\n-      while Current <= Units.Last loop\n-         Unit := Units.Table (Current);\n+      while Current <= Unit_Table.Last (In_Tree.Units) loop\n+         Unit := In_Tree.Units.Table (Current);\n \n          if Unit.File_Names (Body_Part).Project = Project\n            and then Unit.File_Names (Body_Part).Name /= No_Name\n@@ -1732,14 +1826,14 @@ package body Prj.Env is\n                      Write_Line (\"   OK\");\n                   end if;\n \n-                  return Body_Path_Name_Of (Current);\n+                  return Body_Path_Name_Of (Current, In_Tree);\n \n                elsif Current_Name = Extended_Body_Name then\n                   if Current_Verbosity = High then\n                      Write_Line (\"   OK\");\n                   end if;\n \n-                  return Body_Path_Name_Of (Current);\n+                  return Body_Path_Name_Of (Current, In_Tree);\n \n                else\n                   if Current_Verbosity = High then\n@@ -1767,14 +1861,14 @@ package body Prj.Env is\n                      Write_Line (\"   OK\");\n                   end if;\n \n-                  return Spec_Path_Name_Of (Current);\n+                  return Spec_Path_Name_Of (Current, In_Tree);\n \n                elsif Current_Name = Extended_Spec_Name then\n                   if Current_Verbosity = High then\n                      Write_Line (\"   OK\");\n                   end if;\n \n-                  return Spec_Path_Name_Of (Current);\n+                  return Spec_Path_Name_Of (Current, In_Tree);\n \n                else\n                   if Current_Verbosity = High then\n@@ -1795,14 +1889,16 @@ package body Prj.Env is\n \n    --  Could use some comments in this body ???\n \n-   procedure Print_Sources is\n+   procedure Print_Sources (In_Tree : Project_Tree_Ref) is\n       Unit : Unit_Data;\n \n    begin\n       Write_Line (\"List of Sources:\");\n \n-      for Id in Units.First .. Units.Last loop\n-         Unit := Units.Table (Id);\n+      for Id in Unit_Table.First ..\n+                Unit_Table.Last (In_Tree.Units)\n+      loop\n+         Unit := In_Tree.Units.Table (Id);\n          Write_Str  (\"   \");\n          Write_Line (Namet.Get_Name_String (Unit.Name));\n \n@@ -1813,7 +1909,7 @@ package body Prj.Env is\n             else\n                Write_Str  (\"   Project: \");\n                Get_Name_String\n-                 (Projects.Table\n+                 (In_Tree.Projects.Table\n                    (Unit.File_Names (Specification).Project).Path_Name);\n                Write_Line (Name_Buffer (1 .. Name_Len));\n             end if;\n@@ -1831,7 +1927,7 @@ package body Prj.Env is\n             else\n                Write_Str  (\"   Project: \");\n                Get_Name_String\n-                 (Projects.Table\n+                 (In_Tree.Projects.Table\n                    (Unit.File_Names (Body_Part).Project).Path_Name);\n                Write_Line (Name_Buffer (1 .. Name_Len));\n             end if;\n@@ -1852,13 +1948,15 @@ package body Prj.Env is\n \n    function Project_Of\n      (Name         : String;\n-      Main_Project : Project_Id) return Project_Id\n+      Main_Project : Project_Id;\n+      In_Tree      : Project_Tree_Ref) return Project_Id\n    is\n       Result : Project_Id := No_Project;\n \n       Original_Name : String := Name;\n \n-      Data : constant Project_Data := Projects.Table (Main_Project);\n+      Data   : constant Project_Data :=\n+        In_Tree.Projects.Table (Main_Project);\n \n       Extended_Spec_Name : String :=\n                              Name & Namet.Get_Name_String\n@@ -1891,8 +1989,10 @@ package body Prj.Env is\n       Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n       The_Body_Name := Name_Find;\n \n-      for Current in reverse Units.First .. Units.Last loop\n-         Unit := Units.Table (Current);\n+      for Current in reverse Unit_Table.First ..\n+                             Unit_Table.Last (In_Tree.Units)\n+      loop\n+         Unit := In_Tree.Units.Table (Current);\n \n          --  Check for body\n \n@@ -1936,8 +2036,10 @@ package body Prj.Env is\n       --  Get the ultimate extending project\n \n       if Result /= No_Project then\n-         while Projects.Table (Result).Extended_By /= No_Project loop\n-            Result := Projects.Table (Result).Extended_By;\n+         while In_Tree.Projects.Table (Result).Extended_By /=\n+           No_Project\n+         loop\n+            Result := In_Tree.Projects.Table (Result).Extended_By;\n          end loop;\n       end if;\n \n@@ -1950,6 +2052,7 @@ package body Prj.Env is\n \n    procedure Set_Ada_Paths\n      (Project             : Project_Id;\n+      In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean)\n    is\n       Source_FD : File_Descriptor := Invalid_FD;\n@@ -1986,11 +2089,12 @@ package body Prj.Env is\n          begin\n             --  If Seen is False, then the project has not yet been visited\n \n-            if not Projects.Table (Project).Seen then\n-               Projects.Table (Project).Seen := True;\n+            if not In_Tree.Projects.Table (Project).Seen then\n+               In_Tree.Projects.Table (Project).Seen := True;\n \n                declare\n-                  Data : constant Project_Data := Projects.Table (Project);\n+                  Data : constant Project_Data :=\n+                    In_Tree.Projects.Table (Project);\n                   List : Project_List := Data.Imported_Projects;\n \n                begin\n@@ -1999,8 +2103,10 @@ package body Prj.Env is\n                      --  Add to path all source directories of this project\n                      --  if there are Ada sources.\n \n-                     if Projects.Table (Project).Ada_Sources_Present then\n-                        Add_To_Source_Path (Data.Source_Dirs);\n+                     if In_Tree.Projects.Table\n+                          (Project).Ada_Sources_Present\n+                     then\n+                        Add_To_Source_Path (Data.Source_Dirs, In_Tree);\n                      end if;\n                   end if;\n \n@@ -2025,16 +2131,18 @@ package body Prj.Env is\n                            if Data.Object_Directory = No_Name\n                              or else Contains_ALI_Files (Data.Library_Dir)\n                            then\n-                              Add_To_Object_Path (Data.Library_Dir);\n+                              Add_To_Object_Path (Data.Library_Dir, In_Tree);\n                            else\n-                              Add_To_Object_Path (Data.Object_Directory);\n+                              Add_To_Object_Path\n+                                (Data.Object_Directory, In_Tree);\n                            end if;\n \n                         --  For a non-library project, add the object\n                         --  directory, if it is not a virtual project.\n \n                         elsif not Data.Virtual then\n-                           Add_To_Object_Path (Data.Object_Directory);\n+                           Add_To_Object_Path\n+                             (Data.Object_Directory, In_Tree);\n                         end if;\n                      end if;\n                   end if;\n@@ -2048,19 +2156,24 @@ package body Prj.Env is\n                   --  Call Add for each imported project, if any\n \n                   while List /= Empty_Project_List loop\n-                     Recursive_Add (Project_Lists.Table (List).Project);\n-                     List := Project_Lists.Table (List).Next;\n+                     Recursive_Add\n+                       (In_Tree.Project_Lists.Table\n+                          (List).Project);\n+                     List :=\n+                       In_Tree.Project_Lists.Table (List).Next;\n                   end loop;\n                end;\n             end if;\n          end Recursive_Add;\n \n       begin\n-         Source_Paths.Set_Last (0);\n-         Object_Paths.Set_Last (0);\n+         Source_Path_Table.Set_Last (In_Tree.Private_Part.Source_Paths, 0);\n+         Object_Path_Table.Set_Last (In_Tree.Private_Part.Object_Paths, 0);\n \n-         for Index in 1 .. Projects.Last loop\n-            Projects.Table (Index).Seen := False;\n+         for Index in Project_Table.First ..\n+                      Project_Table.Last (In_Tree.Projects)\n+         loop\n+            In_Tree.Projects.Table (Index).Seen := False;\n          end loop;\n \n          Recursive_Add (Proj);\n@@ -2072,30 +2185,35 @@ package body Prj.Env is\n       --  If it is the first time we call this procedure for\n       --  this project, compute the source path and/or the object path.\n \n-      if Projects.Table (Project).Include_Path_File = No_Name then\n+      if In_Tree.Projects.Table (Project).Include_Path_File =\n+        No_Name\n+      then\n          Process_Source_Dirs := True;\n          Create_New_Path_File\n-           (Source_FD, Projects.Table (Project).Include_Path_File);\n+           (In_Tree, Source_FD,\n+            In_Tree.Projects.Table (Project).Include_Path_File);\n       end if;\n \n       --  For the object path, we make a distinction depending on\n       --  Including_Libraries.\n \n       if Including_Libraries then\n-         if Projects.Table (Project).Objects_Path_File_With_Libs = No_Name then\n+         if In_Tree.Projects.Table\n+           (Project).Objects_Path_File_With_Libs = No_Name\n+         then\n             Process_Object_Dirs := True;\n             Create_New_Path_File\n-              (Object_FD, Projects.Table (Project).\n+              (In_Tree, Object_FD, In_Tree.Projects.Table (Project).\n                                            Objects_Path_File_With_Libs);\n          end if;\n \n       else\n-         if\n-           Projects.Table (Project).Objects_Path_File_Without_Libs = No_Name\n+         if In_Tree.Projects.Table\n+              (Project).Objects_Path_File_Without_Libs = No_Name\n          then\n             Process_Object_Dirs := True;\n             Create_New_Path_File\n-              (Object_FD, Projects.Table (Project).\n+              (In_Tree, Object_FD, In_Tree.Projects.Table (Project).\n                                            Objects_Path_File_Without_Libs);\n          end if;\n       end if;\n@@ -2110,8 +2228,11 @@ package body Prj.Env is\n       --  Write and close any file that has been created.\n \n       if Source_FD /= Invalid_FD then\n-         for Index in 1 .. Source_Paths.Last loop\n-            Get_Name_String (Source_Paths.Table (Index));\n+         for Index in Source_Path_Table.First ..\n+                      Source_Path_Table.Last\n+                        (In_Tree.Private_Part.Source_Paths)\n+         loop\n+            Get_Name_String (In_Tree.Private_Part.Source_Paths.Table (Index));\n             Name_Len := Name_Len + 1;\n             Name_Buffer (Name_Len) := ASCII.LF;\n             Len := Write (Source_FD, Name_Buffer (1)'Address, Name_Len);\n@@ -2129,8 +2250,11 @@ package body Prj.Env is\n       end if;\n \n       if Object_FD /= Invalid_FD then\n-         for Index in 1 .. Object_Paths.Last loop\n-            Get_Name_String (Object_Paths.Table (Index));\n+         for Index in Object_Path_Table.First ..\n+                      Object_Path_Table.Last\n+                        (In_Tree.Private_Part.Object_Paths)\n+         loop\n+            Get_Name_String (In_Tree.Private_Part.Object_Paths.Table (Index));\n             Name_Len := Name_Len + 1;\n             Name_Buffer (Name_Len) := ASCII.LF;\n             Len := Write (Object_FD, Name_Buffer (1)'Address, Name_Len);\n@@ -2151,10 +2275,10 @@ package body Prj.Env is\n       --  corresponding flags.\n \n       if Current_Source_Path_File /=\n-           Projects.Table (Project).Include_Path_File\n+           In_Tree.Projects.Table (Project).Include_Path_File\n       then\n          Current_Source_Path_File :=\n-           Projects.Table (Project).Include_Path_File;\n+           In_Tree.Projects.Table (Project).Include_Path_File;\n          Set_Path_File_Var\n            (Project_Include_Path_File,\n             Get_Name_String (Current_Source_Path_File));\n@@ -2163,22 +2287,26 @@ package body Prj.Env is\n \n       if Including_Libraries then\n          if Current_Object_Path_File\n-              /= Projects.Table (Project).Objects_Path_File_With_Libs\n+           /= In_Tree.Projects.Table\n+                (Project).Objects_Path_File_With_Libs\n          then\n             Current_Object_Path_File :=\n-              Projects.Table (Project).Objects_Path_File_With_Libs;\n+              In_Tree.Projects.Table\n+                (Project).Objects_Path_File_With_Libs;\n             Set_Path_File_Var\n               (Project_Objects_Path_File,\n                Get_Name_String (Current_Object_Path_File));\n             Ada_Prj_Objects_File_Set := True;\n          end if;\n \n       else\n-         if Current_Object_Path_File\n-              /= Projects.Table (Project).Objects_Path_File_Without_Libs\n+         if Current_Object_Path_File /=\n+           In_Tree.Projects.Table\n+             (Project).Objects_Path_File_Without_Libs\n          then\n             Current_Object_Path_File :=\n-              Projects.Table (Project).Objects_Path_File_Without_Libs;\n+              In_Tree.Projects.Table\n+                (Project).Objects_Path_File_Without_Libs;\n             Set_Path_File_Var\n               (Project_Objects_Path_File,\n                Get_Name_String (Current_Object_Path_File));\n@@ -2217,14 +2345,17 @@ package body Prj.Env is\n    -- Spec_Path_Name_Of --\n    -----------------------\n \n-   function Spec_Path_Name_Of (Unit : Unit_Id) return String is\n-      Data : Unit_Data := Units.Table (Unit);\n+   function Spec_Path_Name_Of\n+     (Unit : Unit_Id; In_Tree : Project_Tree_Ref) return String\n+   is\n+      Data : Unit_Data := In_Tree.Units.Table (Unit);\n \n    begin\n       if Data.File_Names (Specification).Path = No_Name then\n          declare\n             Current_Source : String_List_Id :=\n-              Projects.Table (Data.File_Names (Specification).Project).Sources;\n+              In_Tree.Projects.Table\n+                (Data.File_Names (Specification).Project).Sources;\n             Path : GNAT.OS_Lib.String_Access;\n \n          begin\n@@ -2236,7 +2367,8 @@ package body Prj.Env is\n                  (Namet.Get_Name_String\n                   (Data.File_Names (Specification).Name),\n                   Namet.Get_Name_String\n-                   (String_Elements.Table (Current_Source).Value));\n+                    (In_Tree.String_Elements.Table\n+                       (Current_Source).Value));\n \n                if Path /= null then\n                   Name_Len := Path'Length;\n@@ -2245,11 +2377,12 @@ package body Prj.Env is\n                   exit;\n                else\n                   Current_Source :=\n-                    String_Elements.Table (Current_Source).Next;\n+                    In_Tree.String_Elements.Table\n+                      (Current_Source).Next;\n                end if;\n             end loop;\n \n-            Units.Table (Unit) := Data;\n+            In_Tree.Units.Table (Unit) := Data;\n          end;\n       end if;\n \n@@ -2260,21 +2393,19 @@ package body Prj.Env is\n    -- Ultimate_Extension_Of --\n    ---------------------------\n \n-   function Ultimate_Extension_Of (Project : in Project_Id) return Project_Id\n+   function Ultimate_Extension_Of\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return Project_Id\n    is\n       Result : Project_Id := Project;\n \n    begin\n-      while Projects.Table (Result).Extended_By /= No_Project loop\n-         Result := Projects.Table (Result).Extended_By;\n+      while In_Tree.Projects.Table (Result).Extended_By /=\n+        No_Project\n+      loop\n+         Result := In_Tree.Projects.Table (Result).Extended_By;\n       end loop;\n \n       return Result;\n    end Ultimate_Extension_Of;\n \n---  Package initialization\n---  What is relationshiop to procedure Initialize\n-\n-begin\n-   Path_Files.Set_Last (0);\n end Prj.Env;"}, {"sha": "905e8d0d1ca8d11cdc63e85a88384e32277705e1", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc        --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,14 +32,15 @@ with GNAT.OS_Lib; use GNAT.OS_Lib;\n package Prj.Env is\n \n    procedure Initialize;\n-   --  Called by Prj.Initialize to perform required initialization\n-   --  steps for this package.\n+   --  Called by Prj.Initialize to perform required initialization steps for\n+   --  this package.\n \n-   procedure Print_Sources;\n+   procedure Print_Sources (In_Tree : Project_Tree_Ref);\n    --  Output the list of sources, after Project files have been scanned\n \n    procedure Create_Mapping_File\n      (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref;\n       Name    : out Name_Id);\n    --  Create a temporary mapping file for project Project. For each unit\n    --  in the closure of immediate sources of Project, put the mapping of\n@@ -52,6 +53,7 @@ package Prj.Env is\n    procedure Create_Config_Pragmas_File\n      (For_Project          : Project_Id;\n       Main_Project         : Project_Id;\n+      In_Tree              : Project_Tree_Ref;\n       Include_Config_Files : Boolean := True);\n    --  If there needs to have SFN pragmas, either for non standard naming\n    --  schemes or for individual units, or (when Include_Config_Files is True)\n@@ -61,12 +63,15 @@ package Prj.Env is\n    --  a temporary file that contains all configuration pragmas, and specify\n    --  the configuration pragmas file in the project data.\n \n-   function Ada_Include_Path (Project : Project_Id) return String_Access;\n+   function Ada_Include_Path\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return String_Access;\n    --  Get the ADA_INCLUDE_PATH of a Project file. For the first call, compute\n    --  it and cache it.\n \n    function Ada_Include_Path\n      (Project   : Project_Id;\n+      In_Tree   : Project_Tree_Ref;\n       Recursive : Boolean) return String;\n    --  Get the ADA_INCLUDE_PATH of a Project file. If Recursive it True,\n    --  get all the source directories of the imported and modified project\n@@ -76,29 +81,33 @@ package Prj.Env is\n \n    function Ada_Objects_Path\n      (Project             : Project_Id;\n+      In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean := True) return String_Access;\n    --  Get the ADA_OBJECTS_PATH of a Project file. For the first call, compute\n    --  it and cache it. When Including_Libraries is False, do not include the\n    --  object directories of the library projects, and do not cache the result.\n \n    procedure Set_Ada_Paths\n      (Project             : Project_Id;\n+      In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean);\n    --  Set the env vars for additional project path files, after\n    --  creating the path files if necessary.\n \n-   procedure Delete_All_Path_Files;\n+   procedure Delete_All_Path_Files (In_Tree : Project_Tree_Ref);\n    --  Delete all temporary path files that have been created by\n    --  calls to Set_Ada_Paths.\n \n    function Path_Name_Of_Library_Unit_Body\n      (Name    : String;\n-      Project : Project_Id) return String;\n+      Project : Project_Id;\n+      In_Tree : Project_Tree_Ref) return String;\n    --  Returns the Path of a library unit\n \n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;\n+      In_Tree           : Project_Tree_Ref;\n       Main_Project_Only : Boolean := True;\n       Full_Path         : Boolean := False) return String;\n    --  Returns the file name of a library unit, in canonical case. Name may or\n@@ -117,28 +126,34 @@ package Prj.Env is\n \n    function Project_Of\n      (Name         : String;\n-      Main_Project : Project_Id) return Project_Id;\n+      Main_Project : Project_Id;\n+      In_Tree      : Project_Tree_Ref) return Project_Id;\n    --  Get the project of a source. The source file name may be truncated\n    --  (\".adb\" or \".ads\" may be missing). If the source is in a project being\n    --  extended, return the ultimate extending project. If it is not a source\n    --  of any project, return No_Project.\n \n    procedure Get_Reference\n      (Source_File_Name : String;\n+      In_Tree          : Project_Tree_Ref;\n       Project          : out Project_Id;\n       Path             : out Name_Id);\n    --  Returns the project of a source and its path in displayable form\n \n    generic\n       with procedure Action (Path : String);\n-   procedure For_All_Source_Dirs (Project : Project_Id);\n-   --  Iterate through all the source directories of a project,\n-   --  including those of imported or modified projects.\n+   procedure For_All_Source_Dirs\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref);\n+   --  Iterate through all the source directories of a project, including\n+   --  those of imported or modified projects.\n \n    generic\n       with procedure Action (Path : String);\n-   procedure For_All_Object_Dirs (Project : Project_Id);\n-   --  Iterate through all the object directories of a project,\n-   --  including those of imported or modified projects.\n+   procedure For_All_Object_Dirs\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref);\n+   --  Iterate through all the object directories of a project, including\n+   --  those of imported or modified projects.\n \n end Prj.Env;"}, {"sha": "d04ab20bd6f6371605fb700be0737e93b9169772", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 211, "deletions": 152, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -117,6 +117,10 @@ package body Prj.Makr is\n       Preproc_Switches  : Argument_List;\n       Very_Verbose      : Boolean)\n    is\n+      Tree : constant Project_Node_Tree_Ref := new Project_Node_Tree_Data;\n+\n+\n+\n       Path_Name : String (1 .. File_Path'Length +\n                             Project_File_Extension'Length);\n       Path_Last : Natural := File_Path'Length;\n@@ -475,46 +479,57 @@ package body Prj.Makr is\n                                        Decl_Item : constant Project_Node_Id :=\n                                          Default_Project_Node\n                                            (Of_Kind =>\n-                                                N_Declarative_Item);\n+                                                N_Declarative_Item,\n+                                            In_Tree => Tree);\n \n                                        Attribute : constant Project_Node_Id :=\n                                          Default_Project_Node\n                                            (Of_Kind =>\n-                                                N_Attribute_Declaration);\n+                                                N_Attribute_Declaration,\n+                                            In_Tree => Tree);\n \n                                        Expression : constant Project_Node_Id :=\n                                          Default_Project_Node\n                                            (Of_Kind => N_Expression,\n-                                            And_Expr_Kind => Single);\n+                                            And_Expr_Kind => Single,\n+                                            In_Tree => Tree);\n \n                                        Term : constant Project_Node_Id :=\n                                          Default_Project_Node\n                                            (Of_Kind => N_Term,\n-                                            And_Expr_Kind => Single);\n+                                            And_Expr_Kind => Single,\n+                                            In_Tree => Tree);\n \n                                        Value : constant Project_Node_Id :=\n                                          Default_Project_Node\n-                                           (Of_Kind => N_Literal_String,\n-                                            And_Expr_Kind => Single);\n+                                           (Of_Kind       => N_Literal_String,\n+                                            And_Expr_Kind => Single,\n+                                            In_Tree       => Tree);\n \n                                     begin\n                                        Set_Next_Declarative_Item\n                                          (Decl_Item,\n                                           To => First_Declarative_Item_Of\n-                                            (Naming_Package));\n+                                            (Naming_Package, Tree),\n+                                          In_Tree => Tree);\n                                        Set_First_Declarative_Item_Of\n-                                         (Naming_Package, To => Decl_Item);\n+                                         (Naming_Package,\n+                                          To => Decl_Item,\n+                                          In_Tree => Tree);\n                                        Set_Current_Item_Node\n-                                         (Decl_Item, To => Attribute);\n+                                         (Decl_Item,\n+                                          To => Attribute,\n+                                          In_Tree => Tree);\n \n                                        --  Is it a spec or a body?\n \n                                        if SFN_Prag.Spec then\n                                           Set_Name_Of\n-                                            (Attribute, To => Name_Spec);\n+                                            (Attribute, Tree,\n+                                             To => Name_Spec);\n                                        else\n                                           Set_Name_Of\n-                                            (Attribute,\n+                                            (Attribute, Tree,\n                                              To => Name_Body);\n                                        end if;\n \n@@ -523,20 +538,21 @@ package body Prj.Makr is\n                                        Get_Name_String (SFN_Prag.Unit);\n                                        To_Lower (Name_Buffer (1 .. Name_Len));\n                                        Set_Associative_Array_Index_Of\n-                                         (Attribute, To => Name_Find);\n+                                         (Attribute, Tree, To => Name_Find);\n \n                                        Set_Expression_Of\n-                                         (Attribute, To => Expression);\n+                                         (Attribute, Tree, To => Expression);\n                                        Set_First_Term\n-                                         (Expression, To => Term);\n-                                       Set_Current_Term (Term, To => Value);\n+                                         (Expression, Tree, To => Term);\n+                                       Set_Current_Term\n+                                         (Term, Tree, To => Value);\n \n                                        --  And set the name of the file\n \n                                        Set_String_Value_Of\n-                                         (Value, To => File_Name_Id);\n+                                         (Value, Tree, To => File_Name_Id);\n                                        Set_Source_Index_Of\n-                                         (Value, To => SFN_Prag.Index);\n+                                         (Value, Tree, To => SFN_Prag.Index);\n                                     end;\n                                  end if;\n                               end loop;\n@@ -649,7 +665,8 @@ package body Prj.Makr is\n       Csets.Initialize;\n       Namet.Initialize;\n       Snames.Initialize;\n-      Prj.Initialize;\n+      Prj.Initialize (No_Project_Tree);\n+      Prj.Tree.Initialize (Tree);\n \n       SFN_Pragmas.Set_Last (0);\n \n@@ -707,7 +724,8 @@ package body Prj.Makr is\n             end if;\n \n             Part.Parse\n-              (Project                => Project_Node,\n+              (In_Tree                => Tree,\n+               Project                => Project_Node,\n                Project_File_Name      => Output_Name (1 .. Output_Name_Last),\n                Always_Errout_Finalize => False);\n \n@@ -725,27 +743,29 @@ package body Prj.Makr is\n \n                declare\n                   With_Clause : Project_Node_Id :=\n-                                  First_With_Clause_Of (Project_Node);\n+                                  First_With_Clause_Of (Project_Node, Tree);\n                   Previous    : Project_Node_Id := Empty_Node;\n \n                begin\n                   while With_Clause /= Empty_Node loop\n-                     if Tree.Name_Of (With_Clause) = Project_Naming_Id then\n+                     if Prj.Tree.Name_Of (With_Clause, Tree) =\n+                          Project_Naming_Id\n+                     then\n                         if Previous = Empty_Node then\n                            Set_First_With_Clause_Of\n-                             (Project_Node,\n-                              To => Next_With_Clause_Of (With_Clause));\n+                             (Project_Node, Tree,\n+                              To => Next_With_Clause_Of (With_Clause, Tree));\n                         else\n                            Set_Next_With_Clause_Of\n-                             (Previous,\n-                              To => Next_With_Clause_Of (With_Clause));\n+                             (Previous, Tree,\n+                              To => Next_With_Clause_Of (With_Clause, Tree));\n                         end if;\n \n                         exit;\n                      end if;\n \n                      Previous := With_Clause;\n-                     With_Clause := Next_With_Clause_Of (With_Clause);\n+                     With_Clause := Next_With_Clause_Of (With_Clause, Tree);\n                   end loop;\n                end;\n \n@@ -757,41 +777,45 @@ package body Prj.Makr is\n                   Declaration  : Project_Node_Id :=\n                                    First_Declarative_Item_Of\n                                      (Project_Declaration_Of\n-                                       (Project_Node));\n+                                        (Project_Node, Tree),\n+                                      Tree);\n                   Previous     : Project_Node_Id := Empty_Node;\n                   Current_Node : Project_Node_Id := Empty_Node;\n \n                begin\n                   while Declaration /= Empty_Node loop\n-                     Current_Node := Current_Item_Node (Declaration);\n+                     Current_Node := Current_Item_Node (Declaration, Tree);\n \n-                     if (Kind_Of (Current_Node) = N_Attribute_Declaration\n+                     if (Kind_Of (Current_Node, Tree) = N_Attribute_Declaration\n                            and then\n-                            (Tree.Name_Of (Current_Node) = Name_Source_Files\n-                               or else Tree.Name_Of (Current_Node) =\n-                                                 Name_Source_List_File\n-                               or else Tree.Name_Of (Current_Node) =\n-                                                 Name_Source_Dirs))\n+                           (Prj.Tree.Name_Of (Current_Node, Tree) =\n+                              Name_Source_Files\n+                             or else Prj.Tree.Name_Of (Current_Node, Tree) =\n+                                               Name_Source_List_File\n+                             or else Prj.Tree.Name_Of (Current_Node, Tree) =\n+                                               Name_Source_Dirs))\n                        or else\n-                       (Kind_Of (Current_Node) = N_Package_Declaration\n-                          and then Tree.Name_Of (Current_Node) = Name_Naming)\n+                       (Kind_Of (Current_Node, Tree) = N_Package_Declaration\n+                        and then Prj.Tree.Name_Of (Current_Node, Tree) =\n+                                   Name_Naming)\n                      then\n                         if Previous = Empty_Node then\n                            Set_First_Declarative_Item_Of\n-                             (Project_Declaration_Of (Project_Node),\n-                              To => Next_Declarative_Item (Declaration));\n+                             (Project_Declaration_Of (Project_Node, Tree),\n+                              Tree,\n+                              To => Next_Declarative_Item (Declaration, Tree));\n \n                         else\n                            Set_Next_Declarative_Item\n-                             (Previous,\n-                              To => Next_Declarative_Item (Declaration));\n+                             (Previous, Tree,\n+                              To => Next_Declarative_Item (Declaration, Tree));\n                         end if;\n \n                      else\n                         Previous := Declaration;\n                      end if;\n \n-                     Declaration := Next_Declarative_Item (Declaration);\n+                     Declaration := Next_Declarative_Item (Declaration, Tree);\n                   end loop;\n                end;\n             end if;\n@@ -971,105 +995,123 @@ package body Prj.Makr is\n          --  name and its project declaration node.\n \n          if Project_Node = Empty_Node then\n-            Project_Node := Default_Project_Node (Of_Kind => N_Project);\n-            Set_Name_Of (Project_Node, To => Output_Name_Id);\n+            Project_Node :=\n+              Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n+            Set_Name_Of (Project_Node, Tree, To => Output_Name_Id);\n             Set_Project_Declaration_Of\n-              (Project_Node,\n-               To => Default_Project_Node (Of_Kind => N_Project_Declaration));\n+              (Project_Node, Tree,\n+               To => Default_Project_Node\n+                 (Of_Kind => N_Project_Declaration, In_Tree => Tree));\n \n          end if;\n \n          --  Create the naming project node, and add an attribute declaration\n          --  for Source_Files as an empty list, to indicate there are no\n          --  sources in the naming project.\n \n-         Project_Naming_Node := Default_Project_Node (Of_Kind => N_Project);\n-         Set_Name_Of (Project_Naming_Node, To => Project_Naming_Id);\n+         Project_Naming_Node :=\n+           Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n+         Set_Name_Of (Project_Naming_Node, Tree, To => Project_Naming_Id);\n          Project_Naming_Decl :=\n-           Default_Project_Node (Of_Kind => N_Project_Declaration);\n-         Set_Project_Declaration_Of (Project_Naming_Node, Project_Naming_Decl);\n+           Default_Project_Node\n+             (Of_Kind => N_Project_Declaration, In_Tree => Tree);\n+         Set_Project_Declaration_Of\n+           (Project_Naming_Node, Tree, Project_Naming_Decl);\n          Naming_Package :=\n-           Default_Project_Node (Of_Kind => N_Package_Declaration);\n-         Set_Name_Of (Naming_Package, To => Name_Naming);\n+           Default_Project_Node\n+             (Of_Kind => N_Package_Declaration, In_Tree => Tree);\n+         Set_Name_Of (Naming_Package, Tree, To => Name_Naming);\n \n          declare\n             Decl_Item : constant Project_Node_Id :=\n-              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+                          Default_Project_Node\n+                            (Of_Kind => N_Declarative_Item, In_Tree => Tree);\n \n             Attribute : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Attribute_Declaration,\n-               And_Expr_Kind => List);\n+                          Default_Project_Node\n+                            (Of_Kind       => N_Attribute_Declaration,\n+                             In_Tree       => Tree,\n+                             And_Expr_Kind => List);\n \n             Expression : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Expression,\n-               And_Expr_Kind => List);\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Expression,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => List);\n \n-            Term  : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Term,\n-               And_Expr_Kind => List);\n+            Term      : constant Project_Node_Id :=\n+                          Default_Project_Node\n+                            (Of_Kind       => N_Term,\n+                             In_Tree       => Tree,\n+                             And_Expr_Kind => List);\n \n             Empty_List : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Literal_String_List);\n+                           Default_Project_Node\n+                             (Of_Kind => N_Literal_String_List,\n+                              In_Tree => Tree);\n \n          begin\n             Set_First_Declarative_Item_Of\n-              (Project_Naming_Decl, To => Decl_Item);\n-            Set_Next_Declarative_Item (Decl_Item, Naming_Package);\n-            Set_Current_Item_Node (Decl_Item, To => Attribute);\n-            Set_Name_Of (Attribute, To => Name_Source_Files);\n-            Set_Expression_Of (Attribute, To => Expression);\n-            Set_First_Term (Expression, To => Term);\n-            Set_Current_Term (Term, To => Empty_List);\n+              (Project_Naming_Decl, Tree, To => Decl_Item);\n+            Set_Next_Declarative_Item (Decl_Item, Tree, Naming_Package);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n+            Set_Name_Of (Attribute, Tree, To => Name_Source_Files);\n+            Set_Expression_Of (Attribute, Tree, To => Expression);\n+            Set_First_Term (Expression, Tree, To => Term);\n+            Set_Current_Term (Term, Tree, To => Empty_List);\n          end;\n \n          --  Add a with clause on the naming project in the main project\n \n          declare\n             With_Clause : constant Project_Node_Id :=\n-              Default_Project_Node (Of_Kind => N_With_Clause);\n+                            Default_Project_Node\n+                              (Of_Kind => N_With_Clause, In_Tree => Tree);\n \n          begin\n             Set_Next_With_Clause_Of\n-              (With_Clause, To => First_With_Clause_Of (Project_Node));\n-            Set_First_With_Clause_Of (Project_Node, To => With_Clause);\n-            Set_Name_Of (With_Clause, To => Project_Naming_Id);\n+              (With_Clause, Tree,\n+               To => First_With_Clause_Of (Project_Node, Tree));\n+            Set_First_With_Clause_Of (Project_Node, Tree, To => With_Clause);\n+            Set_Name_Of (With_Clause, Tree, To => Project_Naming_Id);\n \n             --  We set the project node to something different than\n             --  Empty_Node, so that Prj.PP does not generate a limited\n             --  with clause.\n \n-            Set_Project_Node_Of (With_Clause, Non_Empty_Node);\n+            Set_Project_Node_Of (With_Clause, Tree, Non_Empty_Node);\n \n             Name_Len := Project_Naming_Last;\n             Name_Buffer (1 .. Name_Len) :=\n               Project_Naming_File_Name (1 .. Project_Naming_Last);\n-            Set_String_Value_Of (With_Clause, To => Name_Find);\n+            Set_String_Value_Of (With_Clause, Tree, To => Name_Find);\n          end;\n \n-         Project_Declaration := Project_Declaration_Of (Project_Node);\n+         Project_Declaration := Project_Declaration_Of (Project_Node, Tree);\n \n          --  Add a renaming declaration for package Naming in the main project\n \n          declare\n             Decl_Item  : constant Project_Node_Id :=\n-              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+                           Default_Project_Node\n+                             (Of_Kind => N_Declarative_Item,\n+                              In_Tree => Tree);\n \n             Naming : constant Project_Node_Id :=\n-              Default_Project_Node (Of_Kind => N_Package_Declaration);\n+                           Default_Project_Node\n+                             (Of_Kind => N_Package_Declaration,\n+                              In_Tree => Tree);\n+\n          begin\n             Set_Next_Declarative_Item\n-              (Decl_Item,\n-               To => First_Declarative_Item_Of (Project_Declaration));\n+              (Decl_Item, Tree,\n+               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n             Set_First_Declarative_Item_Of\n-              (Project_Declaration, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, To => Naming);\n-            Set_Name_Of (Naming, To => Name_Naming);\n+              (Project_Declaration, Tree, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Naming);\n+            Set_Name_Of (Naming, Tree, To => Name_Naming);\n             Set_Project_Of_Renamed_Package_Of\n-              (Naming, To => Project_Naming_Node);\n+              (Naming, Tree, To => Project_Naming_Node);\n          end;\n \n          --  Add an attribute declaration for Source_Dirs, initialized as an\n@@ -1078,80 +1120,93 @@ package body Prj.Makr is\n \n          declare\n             Decl_Item  : constant Project_Node_Id :=\n-              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+                           Default_Project_Node\n+                             (Of_Kind => N_Declarative_Item,\n+                              In_Tree => Tree);\n \n             Attribute : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Attribute_Declaration,\n-               And_Expr_Kind => List);\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Attribute_Declaration,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => List);\n \n             Expression : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Expression,\n-               And_Expr_Kind => List);\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Expression,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => List);\n \n             Term  : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Term, And_Expr_Kind => List);\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Term, In_Tree => Tree,\n+                              And_Expr_Kind => List);\n \n          begin\n             Set_Next_Declarative_Item\n-              (Decl_Item,\n-               To => First_Declarative_Item_Of (Project_Declaration));\n+              (Decl_Item, Tree,\n+               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n             Set_First_Declarative_Item_Of\n-              (Project_Declaration, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, To => Attribute);\n-            Set_Name_Of (Attribute, To => Name_Source_Dirs);\n-            Set_Expression_Of (Attribute, To => Expression);\n-            Set_First_Term (Expression, To => Term);\n+              (Project_Declaration, Tree, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n+            Set_Name_Of (Attribute, Tree, To => Name_Source_Dirs);\n+            Set_Expression_Of (Attribute, Tree, To => Expression);\n+            Set_First_Term (Expression, Tree, To => Term);\n             Source_Dirs_List :=\n-              Default_Project_Node (Of_Kind => N_Literal_String_List,\n-                                    And_Expr_Kind => List);\n-            Set_Current_Term (Term, To => Source_Dirs_List);\n+              Default_Project_Node\n+                (Of_Kind       => N_Literal_String_List,\n+                 In_Tree       => Tree,\n+                 And_Expr_Kind => List);\n+            Set_Current_Term (Term, Tree, To => Source_Dirs_List);\n          end;\n \n          --  Add an attribute declaration for Source_List_File with the\n          --  source list file name that will be created.\n \n          declare\n             Decl_Item  : constant Project_Node_Id :=\n-              Default_Project_Node (Of_Kind => N_Declarative_Item);\n+                           Default_Project_Node\n+                             (Of_Kind => N_Declarative_Item,\n+                              In_Tree => Tree);\n \n-            Attribute : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Attribute_Declaration,\n-               And_Expr_Kind => Single);\n+            Attribute  : constant Project_Node_Id :=\n+                            Default_Project_Node\n+                              (Of_Kind       => N_Attribute_Declaration,\n+                               In_Tree       => Tree,\n+                               And_Expr_Kind => Single);\n \n             Expression : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Expression,\n-               And_Expr_Kind => Single);\n-\n-            Term  : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Term,\n-               And_Expr_Kind => Single);\n-\n-            Value : constant Project_Node_Id :=\n-              Default_Project_Node\n-              (Of_Kind => N_Literal_String,\n-               And_Expr_Kind => Single);\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Expression,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => Single);\n+\n+            Term       : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Term,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => Single);\n+\n+            Value      : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Literal_String,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => Single);\n \n          begin\n             Set_Next_Declarative_Item\n-              (Decl_Item,\n-               To => First_Declarative_Item_Of (Project_Declaration));\n+              (Decl_Item, Tree,\n+               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n             Set_First_Declarative_Item_Of\n-              (Project_Declaration, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, To => Attribute);\n-            Set_Name_Of (Attribute, To => Name_Source_List_File);\n-            Set_Expression_Of (Attribute, To => Expression);\n-            Set_First_Term (Expression, To => Term);\n-            Set_Current_Term (Term, To => Value);\n+              (Project_Declaration, Tree, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n+            Set_Name_Of (Attribute, Tree, To => Name_Source_List_File);\n+            Set_Expression_Of (Attribute, Tree, To => Expression);\n+            Set_First_Term (Expression, Tree, To => Term);\n+            Set_Current_Term (Term, Tree, To => Value);\n             Name_Len := Source_List_Last;\n             Name_Buffer (1 .. Name_Len) :=\n               Source_List_Path (1 .. Source_List_Last);\n-            Set_String_Value_Of (Value, To => Name_Find);\n+            Set_String_Value_Of (Value, Tree, To => Name_Find);\n          end;\n       end if;\n \n@@ -1163,6 +1218,7 @@ package body Prj.Makr is\n             Dir_Name    : constant String := Directories (Index).all;\n             Last        : Natural := Dir_Name'Last;\n             Recursively : Boolean := False;\n+\n          begin\n             if Dir_Name'Length >= 4\n               and then (Dir_Name (Last - 2 .. Last) = \"/**\")\n@@ -1177,35 +1233,38 @@ package body Prj.Makr is\n \n                declare\n                   Expression : constant Project_Node_Id :=\n-                    Default_Project_Node\n-                    (Of_Kind => N_Expression,\n-                     And_Expr_Kind => Single);\n-\n-                  Term : constant Project_Node_Id :=\n-                    Default_Project_Node\n-                    (Of_Kind => N_Term,\n-                     And_Expr_Kind => Single);\n-\n-                  Value : constant Project_Node_Id :=\n-                    Default_Project_Node\n-                    (Of_Kind => N_Literal_String,\n-                     And_Expr_Kind => Single);\n+                                 Default_Project_Node\n+                                   (Of_Kind       => N_Expression,\n+                                    In_Tree       => Tree,\n+                                    And_Expr_Kind => Single);\n+\n+                  Term       : constant Project_Node_Id :=\n+                                 Default_Project_Node\n+                                   (Of_Kind       => N_Term,\n+                                    In_Tree       => Tree,\n+                                    And_Expr_Kind => Single);\n+\n+                  Value      : constant Project_Node_Id :=\n+                                 Default_Project_Node\n+                                   (Of_Kind       => N_Literal_String,\n+                                    In_Tree       => Tree,\n+                                    And_Expr_Kind => Single);\n \n                begin\n                   if Current_Source_Dir = Empty_Node then\n                      Set_First_Expression_In_List\n-                       (Source_Dirs_List, To => Expression);\n+                       (Source_Dirs_List, Tree, To => Expression);\n                   else\n                      Set_Next_Expression_In_List\n-                       (Current_Source_Dir, To => Expression);\n+                       (Current_Source_Dir, Tree, To => Expression);\n                   end if;\n \n                   Current_Source_Dir := Expression;\n-                  Set_First_Term (Expression, To => Term);\n-                  Set_Current_Term (Term, To => Value);\n+                  Set_First_Term (Expression, Tree, To => Term);\n+                  Set_Current_Term (Term, Tree, To => Value);\n                   Name_Len := Dir_Name'Length;\n                   Name_Buffer (1 .. Name_Len) := Dir_Name;\n-                  Set_String_Value_Of (Value, To => Name_Find);\n+                  Set_String_Value_Of (Value, Tree, To => Name_Find);\n                end;\n             end if;\n \n@@ -1252,7 +1311,7 @@ package body Prj.Makr is\n             --  Output the project file\n \n             Prj.PP.Pretty_Print\n-              (Project_Node,\n+              (Project_Node, Tree,\n                W_Char => Write_A_Char'Access,\n                W_Eol  => Write_Eol'Access,\n                W_Str  => Write_A_String'Access,\n@@ -1290,7 +1349,7 @@ package body Prj.Makr is\n             --  Output the naming project file\n \n             Prj.PP.Pretty_Print\n-              (Project_Naming_Node,\n+              (Project_Naming_Node, Tree,\n                W_Char => Write_A_Char'Access,\n                W_Eol  => Write_Eol'Access,\n                W_Str  => Write_A_String'Access,"}, {"sha": "c51fbd5efab7744f4bc1103afbfec58188c40fd4", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 536, "deletions": 335, "changes": 871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128"}, {"sha": "b7e356b3f28af2362383c23f3cbdcd1f100c53ad", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2000-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2000-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,7 @@ private package Prj.Nmsc is\n \n    procedure Check\n      (Project      : Project_Id;\n+      In_Tree      : Project_Tree_Ref;\n       Report_Error : Put_Line_Access;\n       Follow_Links : Boolean);\n    --  Check the object directory and the source directories"}, {"sha": "05bb50f1ed8e41068f89358b06bffdb98778cd1a", "filename": "gcc/ada/prj-pars.adb", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,7 +28,6 @@ with Ada.Exceptions; use Ada.Exceptions;\n \n with Opt;\n with Output;   use Output;\n-with Prj.Com;  use Prj.Com;\n with Prj.Err;  use Prj.Err;\n with Prj.Part;\n with Prj.Proc;\n@@ -41,32 +40,40 @@ package body Prj.Pars is\n    -----------\n \n    procedure Parse\n-     (Project           : out Project_Id;\n+     (In_Tree           : Project_Tree_Ref;\n+      Project           : out Project_Id;\n       Project_File_Name : String;\n       Packages_To_Check : String_List_Access := All_Packages)\n    is\n-      Project_Tree      : Project_Node_Id := Empty_Node;\n+      Project_Node_Tree : constant Project_Node_Tree_Ref :=\n+                            new Project_Node_Tree_Data;\n+      Project_Node      : Project_Node_Id := Empty_Node;\n       The_Project       : Project_Id      := No_Project;\n       Success           : Boolean         := True;\n \n    begin\n+      Prj.Tree.Initialize (Project_Node_Tree);\n+\n       --  Parse the main project file into a tree\n \n       Prj.Part.Parse\n-        (Project                => Project_Tree,\n+        (In_Tree                => Project_Node_Tree,\n+         Project                => Project_Node,\n          Project_File_Name      => Project_File_Name,\n          Always_Errout_Finalize => False,\n          Packages_To_Check      => Packages_To_Check);\n \n       --  If there were no error, process the tree\n \n-      if Project_Tree /= Empty_Node then\n+      if Project_Node /= Empty_Node then\n          Prj.Proc.Process\n-           (Project           => The_Project,\n-            Success           => Success,\n-            From_Project_Node => Project_Tree,\n-            Report_Error      => null,\n-            Follow_Links      => Opt.Follow_Links);\n+           (In_Tree                => In_Tree,\n+            Project                => The_Project,\n+            Success                => Success,\n+            From_Project_Node      => Project_Node,\n+            From_Project_Node_Tree => Project_Node_Tree,\n+            Report_Error           => null,\n+            Follow_Links           => Opt.Follow_Links);\n          Prj.Err.Finalize;\n \n          if not Success then"}, {"sha": "97e1e835512fb04ef19a4c4359909ce7594b5dfd", "filename": "gcc/ada/prj-pars.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,10 +34,12 @@ package Prj.Pars is\n    --  Set the verbosity when parsing the project files\n \n    procedure Parse\n-     (Project           : out Project_Id;\n+     (In_Tree           : Project_Tree_Ref;\n+      Project           : out Project_Id;\n       Project_File_Name : String;\n       Packages_To_Check : String_List_Access := All_Packages);\n-   --  Parse a project files and all its imported project files.\n+   --  Parse a project files and all its imported project files, in the\n+   --  project tree In_Tree.\n    --\n    --  If parsing is successful, Project_Id is the project ID\n    --  of the main project file; otherwise, Project_Id is set"}, {"sha": "54d2812d7a6cb7e78c6a64284317bf229afdab80", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 246, "deletions": 179, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,6 +52,9 @@ pragma Elaborate_All (GNAT.OS_Lib);\n \n package body Prj.Part is\n \n+   Buffer      : String_Access;\n+   Buffer_Last : Natural := 0;\n+\n    Dir_Sep  : Character renames GNAT.OS_Lib.Directory_Separator;\n \n    type Extension_Origin is (None, Extending_Simple, Extending_All);\n@@ -104,7 +107,7 @@ package body Prj.Part is\n    --  limited imported projects when there is a circularity with at least\n    --  one limited imported project file.\n \n-   package Virtual_Hash is new Simple_HTable\n+   package Virtual_Hash is new System.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => Project_Node_Id,\n       No_Element => Empty_Node,\n@@ -114,7 +117,7 @@ package body Prj.Part is\n    --  Hash table to store the node id of the project for which a virtual\n    --  extending project need to be created.\n \n-   package Processed_Hash is new Simple_HTable\n+   package Processed_Hash is new System.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => Boolean,\n       No_Element => False,\n@@ -127,43 +130,51 @@ package body Prj.Part is\n \n    procedure Create_Virtual_Extending_Project\n      (For_Project  : Project_Node_Id;\n-      Main_Project : Project_Node_Id);\n+      Main_Project : Project_Node_Id;\n+      In_Tree      : Project_Node_Tree_Ref);\n    --  Create a virtual extending project of For_Project. Main_Project is\n    --  the extending all project.\n \n    procedure Look_For_Virtual_Projects_For\n      (Proj                : Project_Node_Id;\n+      In_Tree             : Project_Node_Tree_Ref;\n       Potentially_Virtual : Boolean);\n    --  Look for projects that need to have a virtual extending project.\n    --  This procedure is recursive. If called with Potentially_Virtual set to\n    --  True, then Proj may need an virtual extending project; otherwise it\n    --  does not (because it is already extended), but other projects that it\n    --  imports may need to be virtually extended.\n \n-   procedure Pre_Parse_Context_Clause (Context_Clause : out With_Id);\n+   procedure Pre_Parse_Context_Clause\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      Context_Clause : out With_Id);\n    --  Parse the context clause of a project.\n    --  Store the paths and locations of the imported projects in table Withs.\n    --  Does nothing if there is no context clause (if the current\n    --  token is not \"with\" or \"limited\" followed by \"with\").\n \n    procedure Post_Parse_Context_Clause\n      (Context_Clause    : With_Id;\n+      In_Tree           : Project_Node_Tree_Ref;\n       Imported_Projects : out Project_Node_Id;\n       Project_Directory : Name_Id;\n       From_Extended     : Extension_Origin;\n-      In_Limited        : Boolean);\n+      In_Limited        : Boolean;\n+      Packages_To_Check : String_List_Access);\n    --  Parse the imported projects that have been stored in table Withs,\n    --  if any. From_Extended is used for the call to Parse_Single_Project\n    --  below. When In_Limited is True, the importing path includes at least\n    --  one \"limited with\".\n \n    procedure Parse_Single_Project\n-     (Project       : out Project_Node_Id;\n-      Extends_All   : out Boolean;\n-      Path_Name     : String;\n-      Extended      : Boolean;\n-      From_Extended : Extension_Origin;\n-      In_Limited    : Boolean);\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Project           : out Project_Node_Id;\n+      Extends_All       : out Boolean;\n+      Path_Name         : String;\n+      Extended          : Boolean;\n+      From_Extended     : Extension_Origin;\n+      In_Limited        : Boolean;\n+      Packages_To_Check : String_List_Access);\n    --  Parse a project file.\n    --  Recursive procedure: it calls itself for imported and extended\n    --  projects. When From_Extended is not None, if the project has already\n@@ -193,12 +204,13 @@ package body Prj.Part is\n \n    procedure Create_Virtual_Extending_Project\n      (For_Project  : Project_Node_Id;\n-      Main_Project : Project_Node_Id)\n+      Main_Project : Project_Node_Id;\n+      In_Tree      : Project_Node_Tree_Ref)\n    is\n \n       Virtual_Name : constant String :=\n                        Virtual_Prefix &\n-                         Get_Name_String (Name_Of (For_Project));\n+                         Get_Name_String (Name_Of (For_Project, In_Tree));\n       --  The name of the virtual extending project\n \n       Virtual_Name_Id : Name_Id;\n@@ -209,7 +221,7 @@ package body Prj.Part is\n       --  the same directory as the extending all project.\n \n       Virtual_Dir_Id  : constant Name_Id :=\n-                          Immediate_Directory_Of (Path_Name_Of (Main_Project));\n+        Immediate_Directory_Of (Path_Name_Of (Main_Project, In_Tree));\n       --  The directory of the extending all project\n \n       --  The source of the virtual extending project is something like:\n@@ -226,23 +238,29 @@ package body Prj.Part is\n       --  Nodes that made up the virtual extending project\n \n       Virtual_Project         : constant Project_Node_Id :=\n-                                  Default_Project_Node (N_Project);\n+                                  Default_Project_Node\n+                                    (In_Tree, N_Project);\n       With_Clause             : constant Project_Node_Id :=\n-                                  Default_Project_Node (N_With_Clause);\n+                                  Default_Project_Node\n+                                    (In_Tree, N_With_Clause);\n       Project_Declaration     : constant Project_Node_Id :=\n-                                  Default_Project_Node (N_Project_Declaration);\n+                                  Default_Project_Node\n+                                    (In_Tree, N_Project_Declaration);\n       Source_Dirs_Declaration : constant Project_Node_Id :=\n-                                  Default_Project_Node (N_Declarative_Item);\n+                                  Default_Project_Node\n+                                    (In_Tree, N_Declarative_Item);\n       Source_Dirs_Attribute   : constant Project_Node_Id :=\n                                   Default_Project_Node\n-                                    (N_Attribute_Declaration, List);\n+                                    (In_Tree, N_Attribute_Declaration, List);\n       Source_Dirs_Expression  : constant Project_Node_Id :=\n-                                  Default_Project_Node (N_Expression, List);\n+                                  Default_Project_Node\n+                                    (In_Tree, N_Expression, List);\n       Source_Dirs_Term        : constant Project_Node_Id :=\n-                                  Default_Project_Node (N_Term, List);\n+                                  Default_Project_Node\n+                                    (In_Tree, N_Term, List);\n       Source_Dirs_List        : constant Project_Node_Id :=\n                                   Default_Project_Node\n-                                    (N_Literal_String_List, List);\n+                                    (In_Tree, N_Literal_String_List, List);\n \n    begin\n       --  Get the virtual name id\n@@ -253,7 +271,7 @@ package body Prj.Part is\n \n       --  Get the virtual path name\n \n-      Get_Name_String (Path_Name_Of (Main_Project));\n+      Get_Name_String (Path_Name_Of (Main_Project, In_Tree));\n \n       while Name_Len > 0\n         and then Name_Buffer (Name_Len) /= Directory_Separator\n@@ -269,45 +287,49 @@ package body Prj.Part is\n \n       --  With clause\n \n-      Set_Name_Of (With_Clause, Virtual_Name_Id);\n-      Set_Path_Name_Of (With_Clause, Virtual_Path_Id);\n-      Set_Project_Node_Of (With_Clause, Virtual_Project);\n+      Set_Name_Of (With_Clause, In_Tree, Virtual_Name_Id);\n+      Set_Path_Name_Of (With_Clause, In_Tree, Virtual_Path_Id);\n+      Set_Project_Node_Of (With_Clause, In_Tree, Virtual_Project);\n       Set_Next_With_Clause_Of\n-        (With_Clause, First_With_Clause_Of (Main_Project));\n-      Set_First_With_Clause_Of (Main_Project, With_Clause);\n+        (With_Clause, In_Tree, First_With_Clause_Of (Main_Project, In_Tree));\n+      Set_First_With_Clause_Of (Main_Project, In_Tree, With_Clause);\n \n       --  Virtual project node\n \n-      Set_Name_Of (Virtual_Project, Virtual_Name_Id);\n-      Set_Path_Name_Of (Virtual_Project, Virtual_Path_Id);\n-      Set_Location_Of (Virtual_Project, Location_Of (Main_Project));\n-      Set_Directory_Of (Virtual_Project, Virtual_Dir_Id);\n-      Set_Project_Declaration_Of (Virtual_Project, Project_Declaration);\n+      Set_Name_Of (Virtual_Project, In_Tree, Virtual_Name_Id);\n+      Set_Path_Name_Of (Virtual_Project, In_Tree, Virtual_Path_Id);\n+      Set_Location_Of\n+        (Virtual_Project, In_Tree, Location_Of (Main_Project, In_Tree));\n+      Set_Directory_Of (Virtual_Project, In_Tree, Virtual_Dir_Id);\n+      Set_Project_Declaration_Of\n+        (Virtual_Project, In_Tree, Project_Declaration);\n       Set_Extended_Project_Path_Of\n-        (Virtual_Project, Path_Name_Of (For_Project));\n+        (Virtual_Project, In_Tree, Path_Name_Of (For_Project, In_Tree));\n \n       --  Project declaration\n \n       Set_First_Declarative_Item_Of\n-        (Project_Declaration, Source_Dirs_Declaration);\n-      Set_Extended_Project_Of (Project_Declaration, For_Project);\n+        (Project_Declaration, In_Tree, Source_Dirs_Declaration);\n+      Set_Extended_Project_Of (Project_Declaration, In_Tree, For_Project);\n \n       --  Source_Dirs declaration\n \n-      Set_Current_Item_Node (Source_Dirs_Declaration, Source_Dirs_Attribute);\n+      Set_Current_Item_Node\n+        (Source_Dirs_Declaration, In_Tree, Source_Dirs_Attribute);\n \n       --  Source_Dirs attribute\n \n-      Set_Name_Of (Source_Dirs_Attribute, Snames.Name_Source_Dirs);\n-      Set_Expression_Of (Source_Dirs_Attribute, Source_Dirs_Expression);\n+      Set_Name_Of (Source_Dirs_Attribute, In_Tree, Snames.Name_Source_Dirs);\n+      Set_Expression_Of\n+        (Source_Dirs_Attribute, In_Tree, Source_Dirs_Expression);\n \n       --  Source_Dirs expression\n \n-      Set_First_Term (Source_Dirs_Expression, Source_Dirs_Term);\n+      Set_First_Term (Source_Dirs_Expression, In_Tree, Source_Dirs_Term);\n \n       --  Source_Dirs term\n \n-      Set_Current_Term (Source_Dirs_Term, Source_Dirs_List);\n+      Set_Current_Term (Source_Dirs_Term, In_Tree, Source_Dirs_List);\n \n       --  Source_Dirs empty list: nothing to do\n \n@@ -352,6 +374,7 @@ package body Prj.Part is\n \n    procedure Look_For_Virtual_Projects_For\n      (Proj                : Project_Node_Id;\n+      In_Tree             : Project_Node_Tree_Ref;\n       Potentially_Virtual : Boolean)\n \n    is\n@@ -376,10 +399,10 @@ package body Prj.Part is\n \n          Processed_Hash.Set (Proj, True);\n \n-         Declaration := Project_Declaration_Of (Proj);\n+         Declaration := Project_Declaration_Of (Proj, In_Tree);\n \n          if Declaration /= Empty_Node then\n-            Extended := Extended_Project_Of (Declaration);\n+            Extended := Extended_Project_Of (Declaration, In_Tree);\n          end if;\n \n          --  If this is a project that may need a virtual extending project\n@@ -391,25 +414,25 @@ package body Prj.Part is\n \n          --  Now check the projects it imports\n \n-         With_Clause := First_With_Clause_Of (Proj);\n+         With_Clause := First_With_Clause_Of (Proj, In_Tree);\n \n          while With_Clause /= Empty_Node loop\n-            Imported := Project_Node_Of (With_Clause);\n+            Imported := Project_Node_Of (With_Clause, In_Tree);\n \n             if Imported /= Empty_Node then\n                Look_For_Virtual_Projects_For\n-                 (Imported, Potentially_Virtual => True);\n+                 (Imported, In_Tree, Potentially_Virtual => True);\n             end if;\n \n-            With_Clause := Next_With_Clause_Of (With_Clause);\n+            With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n          end loop;\n \n          --  Check also the eventual project extended by Proj. As this project\n          --  is already extended, call recursively with Potentially_Virtual\n          --  being False.\n \n          Look_For_Virtual_Projects_For\n-           (Extended, Potentially_Virtual => False);\n+           (Extended, In_Tree, Potentially_Virtual => False);\n       end if;\n    end Look_For_Virtual_Projects_For;\n \n@@ -418,7 +441,8 @@ package body Prj.Part is\n    -----------\n \n    procedure Parse\n-     (Project                : out Project_Node_Id;\n+     (In_Tree                : Project_Node_Tree_Ref;\n+      Project                : out Project_Node_Id;\n       Project_File_Name      : String;\n       Always_Errout_Finalize : Boolean;\n       Packages_To_Check      : String_List_Access := All_Packages;\n@@ -428,11 +452,6 @@ package body Prj.Part is\n       Dummy : Boolean;\n \n    begin\n-      --  Save the Packages_To_Check in Prj, so that it is visible from\n-      --  Prj.Dect.\n-\n-      Current_Packages_To_Check := Packages_To_Check;\n-\n       Project := Empty_Node;\n \n       if Current_Verbosity >= Medium then\n@@ -461,18 +480,22 @@ package body Prj.Part is\n          end if;\n \n          Parse_Single_Project\n-           (Project       => Project,\n-            Extends_All   => Dummy,\n-            Path_Name     => Path_Name,\n-            Extended      => False,\n-            From_Extended => None,\n-            In_Limited    => False);\n+           (In_Tree           => In_Tree,\n+            Project           => Project,\n+            Extends_All       => Dummy,\n+            Path_Name         => Path_Name,\n+            Extended          => False,\n+            From_Extended     => None,\n+            In_Limited        => False,\n+            Packages_To_Check => Packages_To_Check);\n \n          --  If Project is an extending-all project, create the eventual\n          --  virtual extending projects and check that there are no illegally\n          --  imported projects.\n \n-         if Project /= Empty_Node and then Is_Extending_All (Project) then\n+         if Project /= Empty_Node\n+           and then Is_Extending_All (Project, In_Tree)\n+         then\n             --  First look for projects that potentially need a virtual\n             --  extending project.\n \n@@ -487,10 +510,10 @@ package body Prj.Part is\n \n             declare\n                Declaration : constant Project_Node_Id :=\n-                 Project_Declaration_Of (Project);\n+                               Project_Declaration_Of (Project, In_Tree);\n             begin\n                Look_For_Virtual_Projects_For\n-                 (Extended_Project_Of (Declaration),\n+                 (Extended_Project_Of (Declaration, In_Tree), In_Tree,\n                   Potentially_Virtual => False);\n             end;\n \n@@ -501,30 +524,33 @@ package body Prj.Part is\n             --  the project being \"extended-all\" by the main project.\n \n             declare\n-               With_Clause : Project_Node_Id :=\n-                 First_With_Clause_Of (Project);\n+               With_Clause : Project_Node_Id;\n                Imported    : Project_Node_Id := Empty_Node;\n                Declaration : Project_Node_Id := Empty_Node;\n \n             begin\n+               With_Clause := First_With_Clause_Of (Project, In_Tree);\n                while With_Clause /= Empty_Node loop\n-                  Imported := Project_Node_Of (With_Clause);\n+                  Imported := Project_Node_Of (With_Clause, In_Tree);\n \n                   if Imported /= Empty_Node then\n-                     Declaration := Project_Declaration_Of (Imported);\n+                     Declaration := Project_Declaration_Of (Imported, In_Tree);\n \n-                     if Extended_Project_Of (Declaration) /= Empty_Node then\n+                     if Extended_Project_Of (Declaration, In_Tree) /=\n+                               Empty_Node\n+                     then\n                         loop\n-                           Imported := Extended_Project_Of (Declaration);\n+                           Imported :=\n+                             Extended_Project_Of (Declaration, In_Tree);\n                            exit when Imported = Empty_Node;\n                            Virtual_Hash.Remove (Imported);\n-                           Declaration := Project_Declaration_Of (Imported);\n+                           Declaration :=\n+                             Project_Declaration_Of (Imported, In_Tree);\n                         end loop;\n                      end if;\n-\n                   end if;\n \n-                  With_Clause := Next_With_Clause_Of (With_Clause);\n+                  With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n                end loop;\n             end;\n \n@@ -534,7 +560,7 @@ package body Prj.Part is\n                Proj : Project_Node_Id := Virtual_Hash.Get_First;\n             begin\n                while Proj /= Empty_Node loop\n-                  Create_Virtual_Extending_Project (Proj, Project);\n+                  Create_Virtual_Extending_Project (Proj, Project, In_Tree);\n                   Proj := Virtual_Hash.Get_Next;\n                end loop;\n             end;\n@@ -568,7 +594,10 @@ package body Prj.Part is\n    -- Pre_Parse_Context_Clause --\n    ------------------------------\n \n-   procedure Pre_Parse_Context_Clause (Context_Clause : out With_Id) is\n+   procedure Pre_Parse_Context_Clause\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      Context_Clause : out With_Id)\n+   is\n       Current_With_Clause    : With_Id := No_With;\n       Limited_With           : Boolean         := False;\n \n@@ -582,22 +611,23 @@ package body Prj.Part is\n       Context_Clause := No_With;\n       With_Loop :\n \n-      --  If Token is not WITH or LIMITED, there is no context clause,\n-      --  or we have exhausted the with clauses.\n+      --  If Token is not WITH or LIMITED, there is no context clause, or we\n+      --  have exhausted the with clauses.\n \n       while Token = Tok_With or else Token = Tok_Limited loop\n-         Current_With_Node := Default_Project_Node (Of_Kind => N_With_Clause);\n+         Current_With_Node :=\n+           Default_Project_Node (Of_Kind => N_With_Clause, In_Tree => In_Tree);\n          Limited_With := Token = Tok_Limited;\n \n          if Limited_With then\n-            Scan;  --  scan past LIMITED\n+            Scan (In_Tree);  --  scan past LIMITED\n             Expect (Tok_With, \"WITH\");\n             exit With_Loop when Token /= Tok_With;\n          end if;\n \n          Comma_Loop :\n          loop\n-            Scan; -- scan past WITH or \",\"\n+            Scan (In_Tree); -- scan past WITH or \",\"\n \n             Expect (Tok_String_Literal, \"literal string\");\n \n@@ -626,15 +656,15 @@ package body Prj.Part is\n \n             Current_With_Clause := Withs.Last;\n \n-            Scan;\n+            Scan (In_Tree);\n \n             if Token = Tok_Semicolon then\n                Set_End_Of_Line (Current_With_Node);\n                Set_Previous_Line_Node (Current_With_Node);\n \n                --  End of (possibly multiple) with clause;\n \n-               Scan; -- scan past the semicolon.\n+               Scan (In_Tree); -- scan past the semicolon.\n                exit Comma_Loop;\n \n             elsif Token /= Tok_Comma then\n@@ -643,7 +673,8 @@ package body Prj.Part is\n             end if;\n \n             Current_With_Node :=\n-              Default_Project_Node (Of_Kind => N_With_Clause);\n+              Default_Project_Node\n+                (Of_Kind => N_With_Clause, In_Tree => In_Tree);\n          end loop Comma_Loop;\n       end loop With_Loop;\n    end Pre_Parse_Context_Clause;\n@@ -655,10 +686,12 @@ package body Prj.Part is\n \n    procedure Post_Parse_Context_Clause\n      (Context_Clause    : With_Id;\n+      In_Tree           : Project_Node_Tree_Ref;\n       Imported_Projects : out Project_Node_Id;\n       Project_Directory : Name_Id;\n       From_Extended     : Extension_Origin;\n-      In_Limited        : Boolean)\n+      In_Limited        : Boolean;\n+      Packages_To_Check : String_List_Access)\n    is\n       Current_With_Clause : With_Id := Context_Clause;\n \n@@ -684,12 +717,11 @@ package body Prj.Part is\n \n          declare\n             Original_Path : constant String :=\n-                                 Get_Name_String (Current_With.Path);\n+                              Get_Name_String (Current_With.Path);\n \n             Imported_Path_Name : constant String :=\n                                    Project_Path_Name_Of\n-                                     (Original_Path,\n-                                      Project_Directory_Path);\n+                                     (Original_Path, Project_Directory_Path);\n \n             Resolved_Path : constant String :=\n                               Normalize_Pathname\n@@ -732,13 +764,15 @@ package body Prj.Part is\n \n                else\n                   Next_Project := Current_With.Node;\n-                  Set_Next_With_Clause_Of (Current_Project, Next_Project);\n+                  Set_Next_With_Clause_Of\n+                    (Current_Project, In_Tree, Next_Project);\n                   Current_Project := Next_Project;\n                end if;\n \n                Set_String_Value_Of\n-                 (Current_Project, Current_With.Path);\n-               Set_Location_Of (Current_Project, Current_With.Location);\n+                 (Current_Project, In_Tree, Current_With.Path);\n+               Set_Location_Of\n+                 (Current_Project, In_Tree, Current_With.Location);\n \n                --  If this is a \"limited with\", check if we have a circularity.\n                --  If we have one, get the project id of the limited imported\n@@ -772,15 +806,17 @@ package body Prj.Part is\n \n                if Withed_Project = Empty_Node then\n                   Parse_Single_Project\n-                    (Project       => Withed_Project,\n-                     Extends_All   => Extends_All,\n-                     Path_Name     => Imported_Path_Name,\n-                     Extended      => False,\n-                     From_Extended => From_Extended,\n-                     In_Limited    => Limited_With);\n+                    (In_Tree           => In_Tree,\n+                     Project           => Withed_Project,\n+                     Extends_All       => Extends_All,\n+                     Path_Name         => Imported_Path_Name,\n+                     Extended          => False,\n+                     From_Extended     => From_Extended,\n+                     In_Limited        => Limited_With,\n+                     Packages_To_Check => Packages_To_Check);\n \n                else\n-                  Extends_All := Is_Extending_All (Withed_Project);\n+                  Extends_All := Is_Extending_All (Withed_Project, In_Tree);\n                end if;\n \n                if Withed_Project = Empty_Node then\n@@ -794,24 +830,28 @@ package body Prj.Part is\n \n                   else\n                      Set_Next_With_Clause_Of\n-                       (Current_Project, Empty_Node);\n+                       (Current_Project, In_Tree, Empty_Node);\n                   end if;\n                else\n                   --  If parsing was successful, record project name\n                   --  and path name in with clause\n \n                   Set_Project_Node_Of\n                     (Node         => Current_Project,\n+                     In_Tree      => In_Tree,\n                      To           => Withed_Project,\n-                     Limited_With => Limited_With);\n-                  Set_Name_Of (Current_Project, Name_Of (Withed_Project));\n+                     Limited_With => Current_With.Limited_With);\n+                  Set_Name_Of\n+                    (Current_Project,\n+                     In_Tree,\n+                     Name_Of (Withed_Project, In_Tree));\n \n                   Name_Len := Resolved_Path'Length;\n                   Name_Buffer (1 .. Name_Len) := Resolved_Path;\n-                  Set_Path_Name_Of (Current_Project, Name_Find);\n+                  Set_Path_Name_Of (Current_Project, In_Tree, Name_Find);\n \n                   if Extends_All then\n-                     Set_Is_Extending_All (Current_Project);\n+                     Set_Is_Extending_All (Current_Project, In_Tree);\n                   end if;\n                end if;\n             end if;\n@@ -824,12 +864,14 @@ package body Prj.Part is\n    --------------------------\n \n    procedure Parse_Single_Project\n-     (Project       : out Project_Node_Id;\n-      Extends_All   : out Boolean;\n-      Path_Name     : String;\n-      Extended      : Boolean;\n-      From_Extended : Extension_Origin;\n-      In_Limited    : Boolean)\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Project           : out Project_Node_Id;\n+      Extends_All       : out Boolean;\n+      Path_Name         : String;\n+      Extended          : Boolean;\n+      From_Extended     : Extension_Origin;\n+      In_Limited        : Boolean;\n+      Packages_To_Check : String_List_Access)\n    is\n       Normed_Path_Name    : Name_Id;\n       Canonical_Path_Name : Name_Id;\n@@ -842,7 +884,8 @@ package body Prj.Part is\n       Extended_Project    : Project_Node_Id := Empty_Node;\n \n       A_Project_Name_And_Node : Tree_Private_Part.Project_Name_And_Node :=\n-                                  Tree_Private_Part.Projects_Htable.Get_First;\n+                                  Tree_Private_Part.Projects_Htable.Get_First\n+                                    (In_Tree.Projects_HT);\n \n       Name_From_Path : constant Name_Id := Project_Name_From (Path_Name);\n \n@@ -931,7 +974,7 @@ package body Prj.Part is\n \n             elsif A_Project_Name_And_Node.Extended then\n                Extends_All :=\n-                 Is_Extending_All (A_Project_Name_And_Node.Node);\n+                 Is_Extending_All (A_Project_Name_And_Node.Node, In_Tree);\n \n                --  If the imported project is an extended project A,\n                --  and we are in an extended project, replace A with the\n@@ -941,15 +984,17 @@ package body Prj.Part is\n                   declare\n                      Decl : Project_Node_Id :=\n                               Project_Declaration_Of\n-                                (A_Project_Name_And_Node.Node);\n+                                (A_Project_Name_And_Node.Node, In_Tree);\n \n-                     Prj  : Project_Node_Id := Extending_Project_Of (Decl);\n+                     Prj  : Project_Node_Id :=\n+                              Extending_Project_Of (Decl, In_Tree);\n \n                   begin\n                      loop\n-                        Decl := Project_Declaration_Of (Prj);\n-                        exit when Extending_Project_Of (Decl) = Empty_Node;\n-                        Prj := Extending_Project_Of (Decl);\n+                        Decl := Project_Declaration_Of (Prj, In_Tree);\n+                        exit when Extending_Project_Of (Decl, In_Tree) =\n+                          Empty_Node;\n+                        Prj := Extending_Project_Of (Decl, In_Tree);\n                      end loop;\n \n                      A_Project_Name_And_Node.Node := Prj;\n@@ -966,7 +1011,8 @@ package body Prj.Part is\n             return;\n          end if;\n \n-         A_Project_Name_And_Node := Tree_Private_Part.Projects_Htable.Get_Next;\n+         A_Project_Name_And_Node :=\n+           Tree_Private_Part.Projects_Htable.Get_Next (In_Tree.Projects_HT);\n       end loop;\n \n       --  We never encountered this project file\n@@ -986,7 +1032,7 @@ package body Prj.Part is\n \n       Prj.Err.Scanner.Initialize_Scanner (Types.No_Unit, Source_Index);\n       Tree.Reset_State;\n-      Scan;\n+      Scan (In_Tree);\n \n       if Name_From_Path = No_Name then\n \n@@ -1007,22 +1053,23 @@ package body Prj.Part is\n \n       --  Is there any imported project?\n \n-      Pre_Parse_Context_Clause (First_With);\n+      Pre_Parse_Context_Clause (In_Tree, First_With);\n \n       Project_Directory := Immediate_Directory_Of (Normed_Path_Name);\n-      Project := Default_Project_Node (Of_Kind => N_Project);\n+      Project := Default_Project_Node\n+                   (Of_Kind => N_Project, In_Tree => In_Tree);\n       Project_Stack.Table (Project_Stack.Last).Id := Project;\n-      Set_Directory_Of (Project, Project_Directory);\n-      Set_Path_Name_Of (Project, Normed_Path_Name);\n-      Set_Location_Of (Project, Token_Ptr);\n+      Set_Directory_Of (Project, In_Tree, Project_Directory);\n+      Set_Path_Name_Of (Project, In_Tree,  Normed_Path_Name);\n+      Set_Location_Of (Project, In_Tree, Token_Ptr);\n \n       Expect (Tok_Project, \"PROJECT\");\n \n       --  Mark location of PROJECT token if present\n \n       if Token = Tok_Project then\n-         Set_Location_Of (Project, Token_Ptr);\n-         Scan; -- scan past project\n+         Set_Location_Of (Project, In_Tree, Token_Ptr);\n+         Scan (In_Tree); -- scan past project\n       end if;\n \n       --  Clear the Buffer\n@@ -1042,21 +1089,21 @@ package body Prj.Part is\n          --  Add the identifier name to the buffer\n \n          Get_Name_String (Token_Name);\n-         Add_To_Buffer (Name_Buffer (1 .. Name_Len));\n+         Add_To_Buffer (Name_Buffer (1 .. Name_Len), Buffer, Buffer_Last);\n \n          --  Scan past the identifier\n \n-         Scan;\n+         Scan (In_Tree);\n \n          --  If we have a dot, add a dot the the Buffer and look for the next\n          --  identifier.\n \n          exit when Token /= Tok_Dot;\n-         Add_To_Buffer (\".\");\n+         Add_To_Buffer (\".\", Buffer, Buffer_Last);\n \n          --  Scan past the dot\n \n-         Scan;\n+         Scan (In_Tree);\n       end loop;\n \n       --  See if this is an extending project\n@@ -1071,12 +1118,12 @@ package body Prj.Part is\n \n          Extending := True;\n \n-         Scan; -- scan past EXTENDS\n+         Scan (In_Tree); -- scan past EXTENDS\n \n          if Token = Tok_All then\n             Extends_All := True;\n-            Set_Is_Extending_All (Project);\n-            Scan; --  scan past ALL\n+            Set_Is_Extending_All (Project, In_Tree);\n+            Scan (In_Tree); --  scan past ALL\n          end if;\n       end if;\n \n@@ -1089,7 +1136,7 @@ package body Prj.Part is\n          Name_Len := Buffer_Last;\n          Name_Buffer (1 .. Name_Len) := Buffer (1 .. Buffer_Last);\n          Name_Of_Project := Name_Find;\n-         Set_Name_Of (Project, Name_Of_Project);\n+         Set_Name_Of (Project, In_Tree, Name_Of_Project);\n \n          --  To get expected name of the project file, replace dots by dashes\n \n@@ -1138,17 +1185,20 @@ package body Prj.Part is\n             end if;\n \n             Post_Parse_Context_Clause\n-              (Context_Clause    => First_With,\n+              (In_Tree           => In_Tree,\n+               Context_Clause    => First_With,\n                Imported_Projects => Imported_Projects,\n                Project_Directory => Project_Directory,\n                From_Extended     => From_Ext,\n-               In_Limited        => In_Limited);\n-            Set_First_With_Clause_Of (Project, Imported_Projects);\n+               In_Limited        => In_Limited,\n+               Packages_To_Check => Packages_To_Check);\n+            Set_First_With_Clause_Of (Project, In_Tree, Imported_Projects);\n          end;\n \n          declare\n             Name_And_Node : Tree_Private_Part.Project_Name_And_Node :=\n-                              Tree_Private_Part.Projects_Htable.Get_First;\n+              Tree_Private_Part.Projects_Htable.Get_First\n+                (In_Tree.Projects_HT);\n             Project_Name : Name_Id := Name_And_Node.Name;\n \n          begin\n@@ -1157,25 +1207,31 @@ package body Prj.Part is\n             while Project_Name /= No_Name\n               and then Project_Name /= Name_Of_Project\n             loop\n-               Name_And_Node := Tree_Private_Part.Projects_Htable.Get_Next;\n+               Name_And_Node :=\n+                 Tree_Private_Part.Projects_Htable.Get_Next\n+                   (In_Tree.Projects_HT);\n                Project_Name := Name_And_Node.Name;\n             end loop;\n \n             --  Report an error if we already have a project with this name\n \n             if Project_Name /= No_Name then\n                Error_Msg_Name_1 := Project_Name;\n-               Error_Msg (\"duplicate project name {\", Location_Of (Project));\n-               Error_Msg_Name_1 := Path_Name_Of (Name_And_Node.Node);\n-               Error_Msg (\"\\already in {\", Location_Of (Project));\n+               Error_Msg\n+                 (\"duplicate project name {\", Location_Of (Project, In_Tree));\n+               Error_Msg_Name_1 :=\n+                 Path_Name_Of (Name_And_Node.Node, In_Tree);\n+               Error_Msg\n+                 (\"\\already in {\", Location_Of (Project, In_Tree));\n \n             else\n                --  Otherwise, add the name of the project to the hash table, so\n                --  that we can check that no other subsequent project will have\n                --  the same name.\n \n                Tree_Private_Part.Projects_Htable.Set\n-                 (K => Name_Of_Project,\n+                 (T => In_Tree.Projects_HT,\n+                  K => Name_Of_Project,\n                   E => (Name           => Name_Of_Project,\n                         Node           => Project,\n                         Canonical_Path => Canonical_Path_Name,\n@@ -1189,7 +1245,7 @@ package body Prj.Part is\n          Expect (Tok_String_Literal, \"literal string\");\n \n          if Token = Tok_String_Literal then\n-            Set_Extended_Project_Path_Of (Project, Token_Name);\n+            Set_Extended_Project_Path_Of (Project, In_Tree, Token_Name);\n \n             declare\n                Original_Path_Name : constant String :=\n@@ -1198,8 +1254,8 @@ package body Prj.Part is\n                Extended_Project_Path_Name : constant String :=\n                                               Project_Path_Name_Of\n                                                 (Original_Path_Name,\n-                                                   Get_Name_String\n-                                                     (Project_Directory));\n+                                                 Get_Name_String\n+                                                   (Project_Directory));\n \n             begin\n                if Extended_Project_Path_Name = \"\" then\n@@ -1235,50 +1291,53 @@ package body Prj.Part is\n                      end if;\n \n                      Parse_Single_Project\n-                       (Project       => Extended_Project,\n-                        Extends_All   => Extends_All,\n-                        Path_Name     => Extended_Project_Path_Name,\n-                        Extended      => True,\n-                        From_Extended => From_Ext,\n-                        In_Limited    => In_Limited);\n+                       (In_Tree           => In_Tree,\n+                        Project           => Extended_Project,\n+                        Extends_All       => Extends_All,\n+                        Path_Name         => Extended_Project_Path_Name,\n+                        Extended          => True,\n+                        From_Extended     => From_Ext,\n+                        In_Limited        => In_Limited,\n+                        Packages_To_Check => Packages_To_Check);\n                   end;\n \n                   --  A project that extends an extending-all project is also\n                   --  an extending-all project.\n \n                   if Extended_Project /= Empty_Node\n-                    and then Is_Extending_All (Extended_Project)\n+                    and then Is_Extending_All (Extended_Project, In_Tree)\n                   then\n-                     Set_Is_Extending_All (Project);\n+                     Set_Is_Extending_All (Project, In_Tree);\n                   end if;\n                end if;\n             end;\n \n-            Scan; -- scan past the extended project path\n+            Scan (In_Tree); -- scan past the extended project path\n          end if;\n       end if;\n \n       --  Check that a non extending-all project does not import an\n       --  extending-all project.\n \n-      if not Is_Extending_All (Project) then\n+      if not Is_Extending_All (Project, In_Tree) then\n          declare\n-            With_Clause : Project_Node_Id := First_With_Clause_Of (Project);\n+            With_Clause : Project_Node_Id :=\n+                            First_With_Clause_Of (Project, In_Tree);\n             Imported    : Project_Node_Id := Empty_Node;\n \n          begin\n             With_Clause_Loop :\n             while With_Clause /= Empty_Node loop\n-               Imported := Project_Node_Of (With_Clause);\n+               Imported := Project_Node_Of (With_Clause, In_Tree);\n \n-               if Is_Extending_All (With_Clause) then\n-                  Error_Msg_Name_1 := Name_Of (Imported);\n+               if Is_Extending_All (With_Clause, In_Tree) then\n+                  Error_Msg_Name_1 := Name_Of (Imported, In_Tree);\n                   Error_Msg (\"cannot import extending-all project {\",\n                              Token_Ptr);\n                   exit With_Clause_Loop;\n                end if;\n \n-               With_Clause := Next_With_Clause_Of (With_Clause);\n+               With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n             end loop With_Clause_Loop;\n          end;\n       end if;\n@@ -1308,22 +1367,25 @@ package body Prj.Part is\n          declare\n             Parent_Name  : constant Name_Id := Name_Find;\n             Parent_Found : Boolean := False;\n-            With_Clause  : Project_Node_Id := First_With_Clause_Of (Project);\n+            With_Clause  : Project_Node_Id :=\n+                             First_With_Clause_Of (Project, In_Tree);\n \n          begin\n             --  If there is an extended project, check its name\n \n             if Extended_Project /= Empty_Node then\n-               Parent_Found := Name_Of (Extended_Project) = Parent_Name;\n+               Parent_Found :=\n+                 Name_Of (Extended_Project, In_Tree) = Parent_Name;\n             end if;\n \n             --  If the parent project is not the extended project,\n             --  check each imported project until we find the parent project.\n \n             while not Parent_Found and then With_Clause /= Empty_Node loop\n-               Parent_Found := Name_Of (Project_Node_Of (With_Clause))\n-                 = Parent_Name;\n-               With_Clause := Next_With_Clause_Of (With_Clause);\n+               Parent_Found :=\n+                 Name_Of (Project_Node_Of (With_Clause, In_Tree), In_Tree) =\n+                    Parent_Name;\n+               With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n             end loop;\n \n             --  If the parent project was not found, report an error\n@@ -1332,7 +1394,7 @@ package body Prj.Part is\n                Error_Msg_Name_1 := Name_Of_Project;\n                Error_Msg_Name_2 := Parent_Name;\n                Error_Msg (\"project { does not import or extend project {\",\n-                          Location_Of (Project));\n+                          Location_Of (Project, In_Tree));\n             end if;\n          end;\n       end if;\n@@ -1349,14 +1411,17 @@ package body Prj.Part is\n          --  No need to Scan past \"is\", Prj.Dect.Parse will do it\n \n          Prj.Dect.Parse\n-           (Declarations    => Project_Declaration,\n-            Current_Project => Project,\n-            Extends         => Extended_Project);\n-         Set_Project_Declaration_Of (Project, Project_Declaration);\n+           (In_Tree           => In_Tree,\n+            Declarations      => Project_Declaration,\n+            Current_Project   => Project,\n+            Extends           => Extended_Project,\n+            Packages_To_Check => Packages_To_Check);\n+         Set_Project_Declaration_Of (Project, In_Tree, Project_Declaration);\n \n          if Extended_Project /= Empty_Node then\n             Set_Extending_Project_Of\n-              (Project_Declaration_Of (Extended_Project), To => Project);\n+              (Project_Declaration_Of (Extended_Project, In_Tree), In_Tree,\n+               To => Project);\n          end if;\n       end;\n \n@@ -1366,7 +1431,7 @@ package body Prj.Part is\n       --  Skip \"end\" if present\n \n       if Token = Tok_End then\n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n       --  Clear the Buffer\n@@ -1389,26 +1454,26 @@ package body Prj.Part is\n \n          --  Add the identifier to the Buffer\n          Get_Name_String (Token_Name);\n-         Add_To_Buffer (Name_Buffer (1 .. Name_Len));\n+         Add_To_Buffer (Name_Buffer (1 .. Name_Len), Buffer, Buffer_Last);\n \n          --  Scan past the identifier\n \n-         Scan;\n+         Scan (In_Tree);\n          exit when Token /= Tok_Dot;\n-         Add_To_Buffer (\".\");\n-         Scan;\n+         Add_To_Buffer (\".\", Buffer, Buffer_Last);\n+         Scan (In_Tree);\n       end loop;\n \n       --  If we have a valid name, check if it is the name of the project\n \n       if Name_Of_Project /= No_Name and then Buffer_Last > 0 then\n          if To_Lower (Buffer (1 .. Buffer_Last)) /=\n-            Get_Name_String (Name_Of (Project))\n+            Get_Name_String (Name_Of (Project, In_Tree))\n          then\n             --  Invalid name: report an error\n \n             Error_Msg (\"Expected \"\"\" &\n-                       Get_Name_String (Name_Of (Project)) & \"\"\"\",\n+                       Get_Name_String (Name_Of (Project, In_Tree)) & \"\"\"\",\n                        Token_Ptr);\n          end if;\n       end if;\n@@ -1420,7 +1485,7 @@ package body Prj.Part is\n \n       if Token = Tok_Semicolon then\n          Set_Previous_End_Node (Project);\n-         Scan;\n+         Scan (In_Tree);\n \n          if Token /= Tok_EOF then\n             Error_Msg\n@@ -1439,7 +1504,9 @@ package body Prj.Part is\n       --  Indicate if there are unkept comments\n \n       Tree.Set_Project_File_Includes_Unkept_Comments\n-        (Node => Project, To => Tree.There_Are_Unkept_Comments);\n+        (Node    => Project,\n+         In_Tree => In_Tree,\n+         To      => Tree.There_Are_Unkept_Comments);\n \n       --  And restore the comment state that was saved\n "}, {"sha": "05b089250c1de2bd2e0028d628507003dda52e22", "filename": "gcc/ada/prj-part.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,8 @@ with Prj.Tree;  use Prj.Tree;\n package Prj.Part is\n \n    procedure Parse\n-     (Project                : out Project_Node_Id;\n+     (In_Tree                : Project_Node_Tree_Ref;\n+      Project                : out Project_Node_Id;\n       Project_File_Name      : String;\n       Always_Errout_Finalize : Boolean;\n       Packages_To_Check      : String_List_Access := All_Packages;"}, {"sha": "b1ef31e16f010f6bf47e2006796e55f29372c768", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 144, "deletions": 110, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,6 +63,7 @@ package body Prj.PP is\n \n    procedure Pretty_Print\n      (Project                            : Prj.Tree.Project_Node_Id;\n+      In_Tree                            : Prj.Tree.Project_Node_Tree_Ref;\n       Increment                          : Positive      := 3;\n       Eliminate_Empty_Case_Constructions : Boolean       := False;\n       Minimize_Empty_Lines               : Boolean       := False;\n@@ -254,7 +255,7 @@ package body Prj.PP is\n       -------------------------------\n \n       procedure Write_End_Of_Line_Comment (Node : Project_Node_Id) is\n-         Value : constant Name_Id := End_Of_Line_Comment (Node);\n+         Value : constant Name_Id := End_Of_Line_Comment (Node, In_Tree);\n \n       begin\n          if Value /= No_Name then\n@@ -309,136 +310,152 @@ package body Prj.PP is\n       begin\n          if Node /= Empty_Node then\n \n-            case Kind_Of (Node) is\n+            case Kind_Of (Node, In_Tree) is\n \n                when N_Project  =>\n                   pragma Debug (Indicate_Tested (N_Project));\n-                  if First_With_Clause_Of (Node) /= Empty_Node then\n+                  if First_With_Clause_Of (Node, In_Tree) /= Empty_Node then\n \n                      --  with clause(s)\n \n-                     Print (First_With_Clause_Of (Node), Indent);\n+                     Print (First_With_Clause_Of (Node, In_Tree), Indent);\n                      Write_Empty_Line (Always => True);\n                   end if;\n \n-                  Print (First_Comment_Before (Node), Indent);\n+                  Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"project \");\n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n \n                   --  Check if this project extends another project\n \n-                  if Extended_Project_Path_Of (Node) /= No_Name then\n+                  if Extended_Project_Path_Of (Node, In_Tree) /= No_Name then\n                      Write_String (\" extends \");\n-                     Output_String (Extended_Project_Path_Of (Node));\n+                     Output_String (Extended_Project_Path_Of (Node, In_Tree));\n                   end if;\n \n                   Write_String (\" is\");\n                   Write_End_Of_Line_Comment (Node);\n-                  Print (First_Comment_After (Node), Indent + Increment);\n+                  Print\n+                    (First_Comment_After (Node, In_Tree), Indent + Increment);\n                   Write_Empty_Line (Always => True);\n \n                   --  Output all of the declarations in the project\n \n-                  Print (Project_Declaration_Of (Node), Indent);\n-                  Print (First_Comment_Before_End (Node), Indent + Increment);\n+                  Print (Project_Declaration_Of (Node, In_Tree), Indent);\n+                  Print\n+                    (First_Comment_Before_End (Node, In_Tree),\n+                     Indent + Increment);\n                   Start_Line (Indent);\n                   Write_String (\"end \");\n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n                   Write_Line (\";\");\n-                  Print (First_Comment_After_End (Node), Indent);\n+                  Print (First_Comment_After_End (Node, In_Tree), Indent);\n \n                when N_With_Clause =>\n                   pragma Debug (Indicate_Tested (N_With_Clause));\n \n-                  if Name_Of (Node) /= No_Name then\n-                     Print (First_Comment_Before (Node), Indent);\n+                  if Name_Of (Node, In_Tree) /= No_Name then\n+                     Print (First_Comment_Before (Node, In_Tree), Indent);\n                      Start_Line (Indent);\n \n-                     if Non_Limited_Project_Node_Of (Node) = Empty_Node then\n+                     if Non_Limited_Project_Node_Of (Node, In_Tree) =\n+                          Empty_Node\n+                     then\n                         Write_String (\"limited \");\n                      end if;\n \n                      Write_String (\"with \");\n-                     Output_String (String_Value_Of (Node));\n+                     Output_String (String_Value_Of (Node, In_Tree));\n                      Write_String (\";\");\n                      Write_End_Of_Line_Comment (Node);\n-                     Print (First_Comment_After (Node), Indent);\n+                     Print (First_Comment_After (Node, In_Tree), Indent);\n                   end if;\n \n-                  Print (Next_With_Clause_Of (Node), Indent);\n+                  Print (Next_With_Clause_Of (Node, In_Tree), Indent);\n \n                when N_Project_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Project_Declaration));\n \n-                  if First_Declarative_Item_Of (Node) /= Empty_Node then\n+                  if\n+                    First_Declarative_Item_Of (Node, In_Tree) /= Empty_Node\n+                  then\n                      Print\n-                       (First_Declarative_Item_Of (Node), Indent + Increment);\n+                       (First_Declarative_Item_Of (Node, In_Tree),\n+                        Indent + Increment);\n                      Write_Empty_Line (Always => True);\n                   end if;\n \n                when N_Declarative_Item =>\n                   pragma Debug (Indicate_Tested (N_Declarative_Item));\n-                  Print (Current_Item_Node (Node), Indent);\n-                  Print (Next_Declarative_Item (Node), Indent);\n+                  Print (Current_Item_Node (Node, In_Tree), Indent);\n+                  Print (Next_Declarative_Item (Node, In_Tree), Indent);\n \n                when N_Package_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Package_Declaration));\n                   Write_Empty_Line (Always => True);\n-                  Print (First_Comment_Before (Node), Indent);\n+                  Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"package \");\n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n \n-                  if Project_Of_Renamed_Package_Of (Node) /= Empty_Node then\n+                  if Project_Of_Renamed_Package_Of (Node, In_Tree) /=\n+                       Empty_Node\n+                  then\n                      Write_String (\" renames \");\n                      Output_Name\n-                       (Name_Of (Project_Of_Renamed_Package_Of (Node)));\n+                       (Name_Of\n+                          (Project_Of_Renamed_Package_Of (Node, In_Tree),\n+                           In_Tree));\n                      Write_String (\".\");\n-                     Output_Name (Name_Of (Node));\n+                     Output_Name (Name_Of (Node, In_Tree));\n                      Write_String (\";\");\n                      Write_End_Of_Line_Comment (Node);\n-                     Print (First_Comment_After_End (Node), Indent);\n+                     Print (First_Comment_After_End (Node, In_Tree), Indent);\n \n                   else\n                      Write_String (\" is\");\n                      Write_End_Of_Line_Comment (Node);\n-                     Print (First_Comment_After (Node), Indent + Increment);\n+                     Print (First_Comment_After (Node, In_Tree),\n+                            Indent + Increment);\n \n-                     if First_Declarative_Item_Of (Node) /= Empty_Node then\n+                     if First_Declarative_Item_Of (Node, In_Tree) /=\n+                          Empty_Node\n+                     then\n                         Print\n-                          (First_Declarative_Item_Of (Node),\n+                          (First_Declarative_Item_Of (Node, In_Tree),\n                            Indent + Increment);\n                      end if;\n \n-                     Print (First_Comment_Before_End (Node),\n+                     Print (First_Comment_Before_End (Node, In_Tree),\n                             Indent + Increment);\n                      Start_Line (Indent);\n                      Write_String (\"end \");\n-                     Output_Name (Name_Of (Node));\n+                     Output_Name (Name_Of (Node, In_Tree));\n                      Write_Line (\";\");\n-                     Print (First_Comment_After_End (Node), Indent);\n+                     Print (First_Comment_After_End (Node, In_Tree), Indent);\n                      Write_Empty_Line;\n                   end if;\n \n                when N_String_Type_Declaration =>\n                   pragma Debug (Indicate_Tested (N_String_Type_Declaration));\n-                  Print (First_Comment_Before (Node), Indent);\n+                  Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"type \");\n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n                   Write_Line (\" is\");\n                   Start_Line (Indent + Increment);\n                   Write_String (\"(\");\n \n                   declare\n                      String_Node : Project_Node_Id :=\n-                       First_Literal_String (Node);\n+                       First_Literal_String (Node, In_Tree);\n \n                   begin\n                      while String_Node /= Empty_Node loop\n-                        Output_String (String_Value_Of (String_Node));\n-                        String_Node := Next_Literal_String (String_Node);\n+                        Output_String (String_Value_Of (String_Node, In_Tree));\n+                        String_Node :=\n+                          Next_Literal_String (String_Node, In_Tree);\n \n                         if String_Node /= Empty_Node then\n                            Write_String (\", \");\n@@ -448,76 +465,78 @@ package body Prj.PP is\n \n                   Write_String (\");\");\n                   Write_End_Of_Line_Comment (Node);\n-                  Print (First_Comment_After (Node), Indent);\n+                  Print (First_Comment_After (Node, In_Tree), Indent);\n \n                when N_Literal_String =>\n                   pragma Debug (Indicate_Tested (N_Literal_String));\n-                  Output_String (String_Value_Of (Node));\n+                  Output_String (String_Value_Of (Node, In_Tree));\n \n-                  if Source_Index_Of (Node) /= 0 then\n+                  if Source_Index_Of (Node, In_Tree) /= 0 then\n                      Write_String (\" at \");\n-                     Write_String (Source_Index_Of (Node)'Img);\n+                     Write_String (Source_Index_Of (Node, In_Tree)'Img);\n                   end if;\n \n                when N_Attribute_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Declaration));\n-                  Print (First_Comment_Before (Node), Indent);\n+                  Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"for \");\n-                  Output_Attribute_Name (Name_Of (Node));\n+                  Output_Attribute_Name (Name_Of (Node, In_Tree));\n \n-                  if Associative_Array_Index_Of (Node) /= No_Name then\n+                  if Associative_Array_Index_Of (Node, In_Tree) /= No_Name then\n                      Write_String (\" (\");\n-                     Output_String (Associative_Array_Index_Of (Node));\n+                     Output_String\n+                       (Associative_Array_Index_Of (Node, In_Tree));\n \n-                     if Source_Index_Of (Node) /= 0 then\n+                     if Source_Index_Of (Node, In_Tree) /= 0 then\n                         Write_String (\" at \");\n-                        Write_String (Source_Index_Of (Node)'Img);\n+                        Write_String (Source_Index_Of (Node, In_Tree)'Img);\n                      end if;\n \n                      Write_String (\")\");\n                   end if;\n \n                   Write_String (\" use \");\n-                  Print (Expression_Of (Node), Indent);\n+                  Print (Expression_Of (Node, In_Tree), Indent);\n                   Write_String (\";\");\n                   Write_End_Of_Line_Comment (Node);\n-                  Print (First_Comment_After (Node), Indent);\n+                  Print (First_Comment_After (Node, In_Tree), Indent);\n \n                when N_Typed_Variable_Declaration =>\n                   pragma Debug\n                     (Indicate_Tested (N_Typed_Variable_Declaration));\n-                  Print (First_Comment_Before (Node), Indent);\n+                  Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n                   Write_String (\" : \");\n-                  Output_Name (Name_Of (String_Type_Of (Node)));\n+                  Output_Name\n+                    (Name_Of (String_Type_Of (Node, In_Tree), In_Tree));\n                   Write_String (\" := \");\n-                  Print (Expression_Of (Node), Indent);\n+                  Print (Expression_Of (Node, In_Tree), Indent);\n                   Write_String (\";\");\n                   Write_End_Of_Line_Comment (Node);\n-                  Print (First_Comment_After (Node), Indent);\n+                  Print (First_Comment_After (Node, In_Tree), Indent);\n \n                when N_Variable_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Variable_Declaration));\n-                  Print (First_Comment_Before (Node), Indent);\n+                  Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n                   Write_String (\" := \");\n-                  Print (Expression_Of (Node), Indent);\n+                  Print (Expression_Of (Node, In_Tree), Indent);\n                   Write_String (\";\");\n                   Write_End_Of_Line_Comment (Node);\n-                  Print (First_Comment_After (Node), Indent);\n+                  Print (First_Comment_After (Node, In_Tree), Indent);\n \n                when N_Expression =>\n                   pragma Debug (Indicate_Tested (N_Expression));\n                   declare\n-                     Term : Project_Node_Id := First_Term (Node);\n+                     Term : Project_Node_Id := First_Term (Node, In_Tree);\n \n                   begin\n                      while Term /= Empty_Node loop\n                         Print (Term, Indent);\n-                        Term := Next_Term (Term);\n+                        Term := Next_Term (Term, In_Tree);\n \n                         if Term /= Empty_Node then\n                            Write_String (\" & \");\n@@ -527,20 +546,21 @@ package body Prj.PP is\n \n                when N_Term =>\n                   pragma Debug (Indicate_Tested (N_Term));\n-                  Print (Current_Term (Node), Indent);\n+                  Print (Current_Term (Node, In_Tree), Indent);\n \n                when N_Literal_String_List =>\n                   pragma Debug (Indicate_Tested (N_Literal_String_List));\n                   Write_String (\"(\");\n \n                   declare\n                      Expression : Project_Node_Id :=\n-                       First_Expression_In_List (Node);\n+                       First_Expression_In_List (Node, In_Tree);\n \n                   begin\n                      while Expression /= Empty_Node loop\n                         Print (Expression, Indent);\n-                        Expression := Next_Expression_In_List (Expression);\n+                        Expression :=\n+                          Next_Expression_In_List (Expression, In_Tree);\n \n                         if Expression /= Empty_Node then\n                            Write_String (\", \");\n@@ -552,56 +572,61 @@ package body Prj.PP is\n \n                when N_Variable_Reference =>\n                   pragma Debug (Indicate_Tested (N_Variable_Reference));\n-                  if Project_Node_Of (Node) /= Empty_Node then\n-                     Output_Name (Name_Of (Project_Node_Of (Node)));\n+                  if Project_Node_Of (Node, In_Tree) /= Empty_Node then\n+                     Output_Name\n+                       (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree));\n                      Write_String (\".\");\n                   end if;\n \n-                  if Package_Node_Of (Node) /= Empty_Node then\n-                     Output_Name (Name_Of (Package_Node_Of (Node)));\n+                  if Package_Node_Of (Node, In_Tree) /= Empty_Node then\n+                     Output_Name\n+                       (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n                      Write_String (\".\");\n                   end if;\n \n-                  Output_Name (Name_Of (Node));\n+                  Output_Name (Name_Of (Node, In_Tree));\n \n                when N_External_Value =>\n                   pragma Debug (Indicate_Tested (N_External_Value));\n                   Write_String (\"external (\");\n-                  Print (External_Reference_Of (Node), Indent);\n+                  Print (External_Reference_Of (Node, In_Tree), Indent);\n \n-                  if External_Default_Of (Node) /= Empty_Node then\n+                  if External_Default_Of (Node, In_Tree) /= Empty_Node then\n                      Write_String (\", \");\n-                     Print (External_Default_Of (Node), Indent);\n+                     Print (External_Default_Of (Node, In_Tree), Indent);\n                   end if;\n \n                   Write_String (\")\");\n \n                when N_Attribute_Reference =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Reference));\n \n-                  if Project_Node_Of (Node) /= Empty_Node\n-                    and then Project_Node_Of (Node) /= Project\n+                  if Project_Node_Of (Node, In_Tree) /= Empty_Node\n+                    and then Project_Node_Of (Node, In_Tree) /= Project\n                   then\n-                     Output_Name (Name_Of (Project_Node_Of (Node)));\n+                     Output_Name\n+                       (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree));\n \n-                     if Package_Node_Of (Node) /= Empty_Node then\n+                     if Package_Node_Of (Node, In_Tree) /= Empty_Node then\n                         Write_String (\".\");\n-                        Output_Name (Name_Of (Package_Node_Of (Node)));\n+                        Output_Name\n+                          (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n                      end if;\n \n-                  elsif Package_Node_Of (Node) /= Empty_Node then\n-                     Output_Name (Name_Of (Package_Node_Of (Node)));\n+                  elsif Package_Node_Of (Node, In_Tree) /= Empty_Node then\n+                     Output_Name\n+                       (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n \n                   else\n                      Write_String (\"project\");\n                   end if;\n \n                   Write_String (\"'\");\n-                  Output_Attribute_Name (Name_Of (Node));\n+                  Output_Attribute_Name (Name_Of (Node, In_Tree));\n \n                   declare\n                      Index : constant Name_Id :=\n-                       Associative_Array_Index_Of (Node);\n+                               Associative_Array_Index_Of (Node, In_Tree);\n \n                   begin\n                      if Index /= No_Name then\n@@ -615,72 +640,81 @@ package body Prj.PP is\n                   pragma Debug (Indicate_Tested (N_Case_Construction));\n \n                   declare\n-                     Case_Item : Project_Node_Id := First_Case_Item_Of (Node);\n+                     Case_Item    : Project_Node_Id;\n                      Is_Non_Empty : Boolean := False;\n+\n                   begin\n+                     Case_Item := First_Case_Item_Of (Node, In_Tree);\n                      while Case_Item /= Empty_Node loop\n-                        if First_Declarative_Item_Of (Case_Item) /= Empty_Node\n+                        if First_Declarative_Item_Of (Case_Item, In_Tree) /=\n+                             Empty_Node\n                           or else not Eliminate_Empty_Case_Constructions\n                         then\n                            Is_Non_Empty := True;\n                            exit;\n                         end if;\n-                        Case_Item := Next_Case_Item (Case_Item);\n+\n+                        Case_Item := Next_Case_Item (Case_Item, In_Tree);\n                      end loop;\n \n                      if Is_Non_Empty then\n                         Write_Empty_Line;\n-                        Print (First_Comment_Before (Node), Indent);\n+                        Print (First_Comment_Before (Node, In_Tree), Indent);\n                         Start_Line (Indent);\n                         Write_String (\"case \");\n-                        Print (Case_Variable_Reference_Of (Node), Indent);\n+                        Print\n+                          (Case_Variable_Reference_Of (Node, In_Tree),\n+                           Indent);\n                         Write_String (\" is\");\n                         Write_End_Of_Line_Comment (Node);\n-                        Print (First_Comment_After (Node), Indent + Increment);\n+                        Print\n+                          (First_Comment_After (Node, In_Tree),\n+                           Indent + Increment);\n \n                         declare\n                            Case_Item : Project_Node_Id :=\n-                             First_Case_Item_Of (Node);\n-\n+                                         First_Case_Item_Of (Node, In_Tree);\n                         begin\n                            while Case_Item /= Empty_Node loop\n                               pragma Assert\n-                                (Kind_Of (Case_Item) = N_Case_Item);\n+                                (Kind_Of (Case_Item, In_Tree) = N_Case_Item);\n                               Print (Case_Item, Indent + Increment);\n-                              Case_Item := Next_Case_Item (Case_Item);\n+                              Case_Item :=\n+                                Next_Case_Item (Case_Item, In_Tree);\n                            end loop;\n                         end;\n \n-                        Print (First_Comment_Before_End (Node),\n+                        Print (First_Comment_Before_End (Node, In_Tree),\n                                Indent + Increment);\n                         Start_Line (Indent);\n                         Write_Line (\"end case;\");\n-                        Print (First_Comment_After_End (Node), Indent);\n+                        Print\n+                          (First_Comment_After_End (Node, In_Tree), Indent);\n                      end if;\n                   end;\n \n                when N_Case_Item =>\n                   pragma Debug (Indicate_Tested (N_Case_Item));\n \n-                  if First_Declarative_Item_Of (Node) /= Empty_Node\n+                  if First_Declarative_Item_Of (Node, In_Tree) /= Empty_Node\n                     or else not Eliminate_Empty_Case_Constructions\n                   then\n                      Write_Empty_Line;\n-                     Print (First_Comment_Before (Node), Indent);\n+                     Print (First_Comment_Before (Node, In_Tree), Indent);\n                      Start_Line (Indent);\n                      Write_String (\"when \");\n \n-                     if First_Choice_Of (Node) = Empty_Node then\n+                     if First_Choice_Of (Node, In_Tree) = Empty_Node then\n                         Write_String (\"others\");\n \n                      else\n                         declare\n-                           Label : Project_Node_Id := First_Choice_Of (Node);\n-\n+                           Label : Project_Node_Id :=\n+                                     First_Choice_Of (Node, In_Tree);\n                         begin\n                            while Label /= Empty_Node loop\n                               Print (Label, Indent);\n-                              Label := Next_Literal_String (Label);\n+                              Label := Next_Literal_String (Label, In_Tree);\n \n                               if Label /= Empty_Node then\n                                  Write_String (\" | \");\n@@ -691,16 +725,16 @@ package body Prj.PP is\n \n                      Write_String (\" =>\");\n                      Write_End_Of_Line_Comment (Node);\n-                     Print (First_Comment_After (Node), Indent + Increment);\n+                     Print\n+                       (First_Comment_After (Node, In_Tree),\n+                        Indent + Increment);\n \n                      declare\n                         First : constant Project_Node_Id :=\n-                                  First_Declarative_Item_Of (Node);\n-\n+                                  First_Declarative_Item_Of (Node, In_Tree);\n                      begin\n                         if First = Empty_Node then\n                            Write_Empty_Line;\n-\n                         else\n                            Print (First, Indent + Increment);\n                         end if;\n@@ -716,22 +750,22 @@ package body Prj.PP is\n                when N_Comment =>\n                   pragma Debug (Indicate_Tested (N_Comment));\n \n-                  if Follows_Empty_Line (Node) then\n+                  if Follows_Empty_Line (Node, In_Tree) then\n                      Write_Empty_Line;\n                   end if;\n \n                   Start_Line (Indent);\n                   Write_String (\"--\");\n                   Write_String\n-                    (Get_Name_String (String_Value_Of (Node)),\n+                    (Get_Name_String (String_Value_Of (Node, In_Tree)),\n                      Truncated => True);\n                   Write_Line (\"\");\n \n-                  if Is_Followed_By_Empty_Line (Node) then\n+                  if Is_Followed_By_Empty_Line (Node, In_Tree) then\n                      Write_Empty_Line;\n                   end if;\n \n-                  Print (Next_Comment (Node), Indent);\n+                  Print (Next_Comment (Node, In_Tree), Indent);\n             end case;\n          end if;\n       end Print;"}, {"sha": "37e47fa6acb3226bdb0af2e252b570c53c287646", "filename": "gcc/ada/prj-pp.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-pp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,7 +27,7 @@\n --  This package is the Project File Pretty Printer.\n --  It is used to output a project file from a project file tree.\n --  It is used by gnatname to update or create project files.\n---  It is also used GLIDE2 to display project file trees.\n+--  It is also used GPS to display project file trees.\n --  It can also be used for debugging purposes for tools that create project\n --  file trees.\n \n@@ -46,6 +46,7 @@ package Prj.PP is\n \n    procedure Pretty_Print\n      (Project                            : Prj.Tree.Project_Node_Id;\n+      In_Tree                            : Prj.Tree.Project_Node_Tree_Ref;\n       Increment                          : Positive      := 3;\n       Eliminate_Empty_Case_Constructions : Boolean       := False;\n       Minimize_Empty_Lines               : Boolean       := False;"}, {"sha": "c67f2a3305fa3560ac5471ebb7b22e8f2010393d", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 793, "deletions": 466, "changes": 1259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128"}, {"sha": "74b16fa0c4b5188415f9054b87ba083470d5a508", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,11 +33,13 @@ with Prj.Tree;  use Prj.Tree;\n package Prj.Proc is\n \n    procedure Process\n-     (Project           : out Project_Id;\n-      Success           : out Boolean;\n-      From_Project_Node : Project_Node_Id;\n-      Report_Error      : Put_Line_Access;\n-      Follow_Links      : Boolean := True);\n+     (In_Tree                : Project_Tree_Ref;\n+      Project                : out Project_Id;\n+      Success                : out Boolean;\n+      From_Project_Node      : Project_Node_Id;\n+      From_Project_Node_Tree : Project_Node_Tree_Ref;\n+      Report_Error           : Put_Line_Access;\n+      Follow_Links           : Boolean := True);\n    --  Process a project file tree into project file data structures.\n    --  If Report_Error is null, use the error reporting mechanism.\n    --  Otherwise, report errors using Report_Error."}, {"sha": "ae7941c203b1154a70541f554b6bdd31d26cb36a", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 250, "deletions": 173, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,9 @@ with Uintp;     use Uintp;\n \n package body Prj.Strt is\n \n+   Buffer      : String_Access;\n+   Buffer_Last : Natural := 0;\n+\n    type Choice_String is record\n       The_String   : Name_Id;\n       Already_Used : Boolean := False;\n@@ -102,18 +105,22 @@ package body Prj.Strt is\n    procedure Add_To_Names (NL : Name_Location);\n    --  Add one single names to table Names\n \n-   procedure External_Reference (External_Value : out Project_Node_Id);\n+   procedure External_Reference\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      External_Value : out Project_Node_Id);\n    --  Parse an external reference. Current token is \"external\".\n \n    procedure Attribute_Reference\n-     (Reference       : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Reference       : out Project_Node_Id;\n       First_Attribute : Attribute_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id);\n    --  Parse an attribute reference. Current token is an apostrophe.\n \n    procedure Terms\n-     (Term            : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Term            : out Project_Node_Id;\n       Expr_Kind       : in out Variable_Kind;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id;\n@@ -148,7 +155,8 @@ package body Prj.Strt is\n    -------------------------\n \n    procedure Attribute_Reference\n-     (Reference       : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Reference       : out Project_Node_Id;\n       First_Attribute : Attribute_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id)\n@@ -158,9 +166,11 @@ package body Prj.Strt is\n    begin\n       --  Declare the node of the attribute reference\n \n-      Reference :=  Default_Project_Node (Of_Kind => N_Attribute_Reference);\n-      Set_Location_Of (Reference, To => Token_Ptr);\n-      Scan; --  past apostrophe\n+      Reference :=\n+        Default_Project_Node\n+          (Of_Kind => N_Attribute_Reference, In_Tree => In_Tree);\n+      Set_Location_Of (Reference, In_Tree, To => Token_Ptr);\n+      Scan (In_Tree); --  past apostrophe\n \n       --  Body may be an attribute name\n \n@@ -172,7 +182,7 @@ package body Prj.Strt is\n       Expect (Tok_Identifier, \"identifier\");\n \n       if Token = Tok_Identifier then\n-         Set_Name_Of (Reference, To => Token_Name);\n+         Set_Name_Of (Reference, In_Tree, To => Token_Name);\n \n          --  Check if the identifier is one of the attribute identifiers in the\n          --  context (package or project level attributes).\n@@ -189,40 +199,41 @@ package body Prj.Strt is\n \n             --  Scan past the attribute name\n \n-            Scan;\n+            Scan (In_Tree);\n \n          else\n             --  Give its characteristics to this attribute reference\n \n-            Set_Project_Node_Of (Reference, To => Current_Project);\n-            Set_Package_Node_Of (Reference, To => Current_Package);\n+            Set_Project_Node_Of (Reference, In_Tree, To => Current_Project);\n+            Set_Package_Node_Of (Reference, In_Tree, To => Current_Package);\n             Set_Expression_Kind_Of\n-              (Reference, To => Variable_Kind_Of (Current_Attribute));\n+              (Reference, In_Tree, To => Variable_Kind_Of (Current_Attribute));\n             Set_Case_Insensitive\n-              (Reference, To => Attribute_Kind_Of (Current_Attribute) =\n-                                          Case_Insensitive_Associative_Array);\n+              (Reference, In_Tree,\n+               To => Attribute_Kind_Of (Current_Attribute) =\n+                       Case_Insensitive_Associative_Array);\n \n             --  Scan past the attribute name\n \n-            Scan;\n+            Scan (In_Tree);\n \n             --  If the attribute is an associative array, get the index\n \n             if Attribute_Kind_Of (Current_Attribute) /= Single then\n                Expect (Tok_Left_Paren, \"`(`\");\n \n                if Token = Tok_Left_Paren then\n-                  Scan;\n+                  Scan (In_Tree);\n                   Expect (Tok_String_Literal, \"literal string\");\n \n                   if Token = Tok_String_Literal then\n                      Set_Associative_Array_Index_Of\n-                       (Reference, To => Token_Name);\n-                     Scan;\n+                       (Reference, In_Tree, To => Token_Name);\n+                     Scan (In_Tree);\n                      Expect (Tok_Right_Paren, \"`)`\");\n \n                      if Token = Tok_Right_Paren then\n-                        Scan;\n+                        Scan (In_Tree);\n                      end if;\n                   end if;\n                end if;\n@@ -232,18 +243,20 @@ package body Prj.Strt is\n          --  Change name of obsolete attributes\n \n          if Reference /= Empty_Node then\n-            case Name_Of (Reference) is\n+            case Name_Of (Reference, In_Tree) is\n                when Snames.Name_Specification =>\n-                  Set_Name_Of (Reference, To => Snames.Name_Spec);\n+                  Set_Name_Of (Reference, In_Tree, To => Snames.Name_Spec);\n \n                when Snames.Name_Specification_Suffix =>\n-                  Set_Name_Of (Reference, To => Snames.Name_Spec_Suffix);\n+                  Set_Name_Of\n+                    (Reference, In_Tree, To => Snames.Name_Spec_Suffix);\n \n                when Snames.Name_Implementation =>\n-                  Set_Name_Of (Reference, To => Snames.Name_Body);\n+                  Set_Name_Of (Reference, In_Tree, To => Snames.Name_Body);\n \n                when Snames.Name_Implementation_Suffix =>\n-                  Set_Name_Of (Reference, To => Snames.Name_Body_Suffix);\n+                  Set_Name_Of\n+                    (Reference, In_Tree, To => Snames.Name_Body_Suffix);\n \n                when others =>\n                   null;\n@@ -327,26 +340,31 @@ package body Prj.Strt is\n    -- External_Reference --\n    ------------------------\n \n-   procedure External_Reference (External_Value : out Project_Node_Id) is\n+   procedure External_Reference\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      External_Value : out Project_Node_Id)\n+   is\n       Field_Id : Project_Node_Id := Empty_Node;\n \n    begin\n       External_Value :=\n-        Default_Project_Node (Of_Kind       => N_External_Value,\n-                              And_Expr_Kind => Single);\n-      Set_Location_Of (External_Value, To => Token_Ptr);\n+        Default_Project_Node\n+          (Of_Kind       => N_External_Value,\n+           In_Tree       => In_Tree,\n+           And_Expr_Kind => Single);\n+      Set_Location_Of (External_Value, In_Tree, To => Token_Ptr);\n \n       --  The current token is External\n \n       --  Get the left parenthesis\n \n-      Scan;\n+      Scan (In_Tree);\n       Expect (Tok_Left_Paren, \"`(`\");\n \n       --  Scan past the left parenthesis\n \n       if Token = Tok_Left_Paren then\n-         Scan;\n+         Scan (In_Tree);\n       end if;\n \n       --  Get the name of the external reference\n@@ -355,45 +373,50 @@ package body Prj.Strt is\n \n       if Token = Tok_String_Literal then\n          Field_Id :=\n-           Default_Project_Node (Of_Kind       => N_Literal_String,\n-                                 And_Expr_Kind => Single);\n-         Set_String_Value_Of (Field_Id, To => Token_Name);\n-         Set_External_Reference_Of (External_Value, To => Field_Id);\n+           Default_Project_Node\n+             (Of_Kind       => N_Literal_String,\n+              In_Tree       => In_Tree,\n+              And_Expr_Kind => Single);\n+         Set_String_Value_Of (Field_Id, In_Tree, To => Token_Name);\n+         Set_External_Reference_Of (External_Value, In_Tree, To => Field_Id);\n \n          --  Scan past the first argument\n \n-         Scan;\n+         Scan (In_Tree);\n \n          case Token is\n \n             when Tok_Right_Paren =>\n \n                --  Scan past the right parenthesis\n-               Scan;\n+               Scan (In_Tree);\n \n             when Tok_Comma =>\n \n                --  Scan past the comma\n \n-               Scan;\n+               Scan (In_Tree);\n \n                Expect (Tok_String_Literal, \"literal string\");\n \n                --  Get the default\n \n                if Token = Tok_String_Literal then\n                   Field_Id :=\n-                    Default_Project_Node (Of_Kind       => N_Literal_String,\n-                                          And_Expr_Kind => Single);\n-                  Set_String_Value_Of (Field_Id, To => Token_Name);\n-                  Set_External_Default_Of (External_Value, To => Field_Id);\n-                  Scan;\n+                    Default_Project_Node\n+                      (Of_Kind       => N_Literal_String,\n+                       In_Tree       => In_Tree,\n+                       And_Expr_Kind => Single);\n+                  Set_String_Value_Of (Field_Id, In_Tree, To => Token_Name);\n+                  Set_External_Default_Of\n+                    (External_Value, In_Tree, To => Field_Id);\n+                  Scan (In_Tree);\n                   Expect (Tok_Right_Paren, \"`)`\");\n                end if;\n \n                --  Scan past the right parenthesis\n                if Token = Tok_Right_Paren then\n-                  Scan;\n+                  Scan (In_Tree);\n                end if;\n \n             when others =>\n@@ -406,7 +429,10 @@ package body Prj.Strt is\n    -- Parse_Choice_List --\n    -----------------------\n \n-   procedure Parse_Choice_List (First_Choice : out Project_Node_Id) is\n+   procedure Parse_Choice_List\n+     (In_Tree      : Project_Node_Tree_Ref;\n+      First_Choice : out Project_Node_Id)\n+   is\n       Current_Choice : Project_Node_Id := Empty_Node;\n       Next_Choice    : Project_Node_Id := Empty_Node;\n       Choice_String  : Name_Id         := No_Name;\n@@ -416,8 +442,10 @@ package body Prj.Strt is\n       --  Declare the node of the first choice\n \n       First_Choice :=\n-        Default_Project_Node (Of_Kind       => N_Literal_String,\n-                              And_Expr_Kind => Single);\n+        Default_Project_Node\n+          (Of_Kind       => N_Literal_String,\n+           In_Tree       => In_Tree,\n+           And_Expr_Kind => Single);\n \n       --  Initially Current_Choice is the same as First_Choice\n \n@@ -426,12 +454,12 @@ package body Prj.Strt is\n       loop\n          Expect (Tok_String_Literal, \"literal string\");\n          exit when Token /= Tok_String_Literal;\n-         Set_Location_Of (Current_Choice, To => Token_Ptr);\n+         Set_Location_Of (Current_Choice, In_Tree, To => Token_Ptr);\n          Choice_String := Token_Name;\n \n          --  Give the string value to the current choice\n \n-         Set_String_Value_Of (Current_Choice, To => Choice_String);\n+         Set_String_Value_Of (Current_Choice, In_Tree, To => Choice_String);\n \n          --  Check if the label is part of the string type and if it has not\n          --  been already used.\n@@ -466,7 +494,7 @@ package body Prj.Strt is\n \n          --  Scan past the label\n \n-         Scan;\n+         Scan (In_Tree);\n \n          --  If there is no '|', we are done\n \n@@ -475,11 +503,14 @@ package body Prj.Strt is\n             --  Current_Choice and set Current_Choice to this new node.\n \n             Next_Choice :=\n-              Default_Project_Node (Of_Kind       => N_Literal_String,\n-                                    And_Expr_Kind => Single);\n-            Set_Next_Literal_String (Current_Choice, To => Next_Choice);\n+              Default_Project_Node\n+                (Of_Kind       => N_Literal_String,\n+                 In_Tree       => In_Tree,\n+                 And_Expr_Kind => Single);\n+            Set_Next_Literal_String\n+              (Current_Choice, In_Tree, To => Next_Choice);\n             Current_Choice := Next_Choice;\n-            Scan;\n+            Scan (In_Tree);\n          else\n             exit;\n          end if;\n@@ -491,7 +522,8 @@ package body Prj.Strt is\n    ----------------------\n \n    procedure Parse_Expression\n-     (Expression      : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Expression      : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id;\n       Optional_Index  : Boolean)\n@@ -502,28 +534,33 @@ package body Prj.Strt is\n    begin\n       --  Declare the node of the expression\n \n-      Expression := Default_Project_Node (Of_Kind => N_Expression);\n-      Set_Location_Of (Expression, To => Token_Ptr);\n+      Expression :=\n+        Default_Project_Node (Of_Kind => N_Expression, In_Tree => In_Tree);\n+      Set_Location_Of (Expression, In_Tree, To => Token_Ptr);\n \n       --  Parse the term or terms of the expression\n \n-      Terms (Term            => First_Term,\n+      Terms (In_Tree         => In_Tree,\n+             Term            => First_Term,\n              Expr_Kind       => Expression_Kind,\n              Current_Project => Current_Project,\n              Current_Package => Current_Package,\n              Optional_Index  => Optional_Index);\n \n       --  Set the first term and the expression kind\n \n-      Set_First_Term (Expression, To => First_Term);\n-      Set_Expression_Kind_Of (Expression, To => Expression_Kind);\n+      Set_First_Term (Expression, In_Tree, To => First_Term);\n+      Set_Expression_Kind_Of (Expression, In_Tree, To => Expression_Kind);\n    end Parse_Expression;\n \n    ----------------------------\n    -- Parse_String_Type_List --\n    ----------------------------\n \n-   procedure Parse_String_Type_List (First_String : out Project_Node_Id) is\n+   procedure Parse_String_Type_List\n+     (In_Tree      : Project_Node_Tree_Ref;\n+      First_String : out Project_Node_Id)\n+   is\n       Last_String  : Project_Node_Id := Empty_Node;\n       Next_String  : Project_Node_Id := Empty_Node;\n       String_Value : Name_Id         := No_Name;\n@@ -532,8 +569,10 @@ package body Prj.Strt is\n       --  Declare the node of the first string\n \n       First_String :=\n-        Default_Project_Node (Of_Kind       => N_Literal_String,\n-                              And_Expr_Kind => Single);\n+        Default_Project_Node\n+          (Of_Kind       => N_Literal_String,\n+           In_Tree       => In_Tree,\n+           And_Expr_Kind => Single);\n \n       --  Initially, Last_String is the same as First_String\n \n@@ -546,8 +585,8 @@ package body Prj.Strt is\n \n          --  Give its string value to Last_String\n \n-         Set_String_Value_Of (Last_String, To => String_Value);\n-         Set_Location_Of (Last_String, To => Token_Ptr);\n+         Set_String_Value_Of (Last_String, In_Tree, To => String_Value);\n+         Set_Location_Of (Last_String, In_Tree, To => Token_Ptr);\n \n          --  Now, check if the string is already part of the string type\n \n@@ -556,21 +595,21 @@ package body Prj.Strt is\n \n          begin\n             while Current /= Last_String loop\n-               if String_Value_Of (Current) = String_Value then\n+               if String_Value_Of (Current, In_Tree) = String_Value then\n                   --  This is a repetition, report an error\n \n                   Error_Msg_Name_1 := String_Value;\n                   Error_Msg (\"duplicate value { in type\", Token_Ptr);\n                   exit;\n                end if;\n \n-               Current := Next_Literal_String (Current);\n+               Current := Next_Literal_String (Current, In_Tree);\n             end loop;\n          end;\n \n          --  Scan past the literal string\n \n-         Scan;\n+         Scan (In_Tree);\n \n          --  If there is no comma following the literal string, we are done\n \n@@ -582,11 +621,13 @@ package body Prj.Strt is\n             --  Last_String to its node.\n \n             Next_String :=\n-              Default_Project_Node (Of_Kind       => N_Literal_String,\n-                                    And_Expr_Kind => Single);\n-            Set_Next_Literal_String (Last_String, To => Next_String);\n+              Default_Project_Node\n+                (Of_Kind       => N_Literal_String,\n+                 In_Tree       => In_Tree,\n+                 And_Expr_Kind => Single);\n+            Set_Next_Literal_String (Last_String, In_Tree, To => Next_String);\n             Last_String := Next_String;\n-            Scan;\n+            Scan (In_Tree);\n          end if;\n       end loop;\n    end Parse_String_Type_List;\n@@ -596,7 +637,8 @@ package body Prj.Strt is\n    ------------------------------\n \n    procedure Parse_Variable_Reference\n-     (Variable        : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Variable        : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id)\n    is\n@@ -623,9 +665,9 @@ package body Prj.Strt is\n          end if;\n \n          Add_To_Names (NL => (Name => Token_Name, Location => Token_Ptr));\n-         Scan;\n+         Scan (In_Tree);\n          exit when Token /= Tok_Dot;\n-         Scan;\n+         Scan (In_Tree);\n       end loop;\n \n       if Look_For_Variable then\n@@ -654,7 +696,7 @@ package body Prj.Strt is\n                   --  Now, look if it can be a project name\n \n                   The_Project := Imported_Or_Extended_Project_Of\n-                    (Current_Project, Names.Table (1).Name);\n+                    (Current_Project, In_Tree, Names.Table (1).Name);\n \n                   if The_Project = Empty_Node then\n                      --  If it is neither a project name nor a package name,\n@@ -670,14 +712,15 @@ package body Prj.Strt is\n                         --  If it is a package name, check if the package\n                         --  has already been declared in the current project.\n \n-                        The_Package := First_Package_Of (Current_Project);\n+                        The_Package :=\n+                          First_Package_Of (Current_Project, In_Tree);\n \n                         while The_Package /= Empty_Node\n-                          and then Name_Of (The_Package) /=\n+                          and then Name_Of (The_Package, In_Tree) /=\n                           Names.Table (1).Name\n                         loop\n                            The_Package :=\n-                             Next_Package_In_Project (The_Package);\n+                             Next_Package_In_Project (The_Package, In_Tree);\n                         end loop;\n \n                         --  If it has not been already declared, report an\n@@ -717,10 +760,11 @@ package body Prj.Strt is\n \n                      for Index in 1 .. Names.Last - 1 loop\n                         Add_To_Buffer\n-                          (Get_Name_String (Names.Table (Index).Name));\n+                          (Get_Name_String (Names.Table (Index).Name),\n+                           Buffer, Buffer_Last);\n \n                         if Index /= Names.Last - 1 then\n-                           Add_To_Buffer (\".\");\n+                           Add_To_Buffer (\".\", Buffer, Buffer_Last);\n                         end if;\n                      end loop;\n \n@@ -732,9 +776,10 @@ package body Prj.Strt is\n                      --  Now, add the last simple name to get the name of the\n                      --  long project.\n \n-                     Add_To_Buffer (\".\");\n+                     Add_To_Buffer (\".\", Buffer, Buffer_Last);\n                      Add_To_Buffer\n-                       (Get_Name_String (Names.Table (Names.Last).Name));\n+                       (Get_Name_String (Names.Table (Names.Last).Name),\n+                        Buffer, Buffer_Last);\n                      Name_Len := Buffer_Last;\n                      Name_Buffer (1 .. Buffer_Last) :=\n                        Buffer (1 .. Buffer_Last);\n@@ -743,7 +788,7 @@ package body Prj.Strt is\n                      --  Check if the long project is imported or extended\n \n                      The_Project := Imported_Or_Extended_Project_Of\n-                                      (Current_Project, Long_Project);\n+                                      (Current_Project, In_Tree, Long_Project);\n \n                      --  If the long project exists, then this is the prefix\n                      --  of the attribute.\n@@ -757,7 +802,8 @@ package body Prj.Strt is\n                         --  or extended.\n \n                         The_Project := Imported_Or_Extended_Project_Of\n-                                         (Current_Project, Short_Project);\n+                                         (Current_Project, In_Tree,\n+                                          Short_Project);\n \n                         --  If the short project does not exist, we report an\n                         --  error.\n@@ -774,13 +820,14 @@ package body Prj.Strt is\n                            --  Now, we check if the package has been declared\n                            --  in this project.\n \n-                           The_Package := First_Package_Of (The_Project);\n+                           The_Package :=\n+                             First_Package_Of (The_Project, In_Tree);\n                            while The_Package /= Empty_Node\n-                             and then Name_Of (The_Package) /=\n+                             and then Name_Of (The_Package, In_Tree) /=\n                              Names.Table (Names.Last).Name\n                            loop\n                               The_Package :=\n-                                Next_Package_In_Project (The_Package);\n+                                Next_Package_In_Project (The_Package, In_Tree);\n                            end loop;\n \n                            --  If it has not, then we report an error\n@@ -799,15 +846,16 @@ package body Prj.Strt is\n \n                               First_Attribute :=\n                                 First_Attribute_Of\n-                                  (Package_Id_Of (The_Package));\n+                                  (Package_Id_Of (The_Package, In_Tree));\n                            end if;\n                         end if;\n                      end if;\n                   end;\n             end case;\n \n             Attribute_Reference\n-              (Variable,\n+              (In_Tree,\n+               Variable,\n                Current_Project => The_Project,\n                Current_Package => The_Package,\n                First_Attribute => First_Attribute);\n@@ -816,7 +864,8 @@ package body Prj.Strt is\n       end if;\n \n       Variable :=\n-        Default_Project_Node (Of_Kind => N_Variable_Reference);\n+        Default_Project_Node\n+          (Of_Kind => N_Variable_Reference, In_Tree => In_Tree);\n \n       if Look_For_Variable then\n          case Names.Last is\n@@ -830,30 +879,32 @@ package body Prj.Strt is\n \n                --  Simple variable name\n \n-               Set_Name_Of (Variable, To => Names.Table (1).Name);\n+               Set_Name_Of (Variable, In_Tree, To => Names.Table (1).Name);\n \n             when 2 =>\n \n                --  Variable name with a simple name prefix that can be\n                --  a project name or a package name. Project names have\n                --  priority over package names.\n \n-               Set_Name_Of (Variable, To => Names.Table (2).Name);\n+               Set_Name_Of (Variable, In_Tree, To => Names.Table (2).Name);\n \n                --  Check if it can be a package name\n \n-               The_Package := First_Package_Of (Current_Project);\n+               The_Package := First_Package_Of (Current_Project, In_Tree);\n \n                while The_Package /= Empty_Node\n-                 and then Name_Of (The_Package) /= Names.Table (1).Name\n+                 and then Name_Of (The_Package, In_Tree) /=\n+                            Names.Table (1).Name\n                loop\n-                  The_Package := Next_Package_In_Project (The_Package);\n+                  The_Package :=\n+                    Next_Package_In_Project (The_Package, In_Tree);\n                end loop;\n \n                --  Now look for a possible project name\n \n                The_Project := Imported_Or_Extended_Project_Of\n-                                (Current_Project, Names.Table (1).Name);\n+                              (Current_Project, In_Tree, Names.Table (1).Name);\n \n                if The_Project /= Empty_Node then\n                   Specified_Project := The_Project;\n@@ -874,7 +925,8 @@ package body Prj.Strt is\n                --  made of several simple names, or a project name followed\n                --  by a package name.\n \n-               Set_Name_Of (Variable, To => Names.Table (Names.Last).Name);\n+               Set_Name_Of\n+                 (Variable, In_Tree, To => Names.Table (Names.Last).Name);\n \n                declare\n                   Short_Project : Name_Id;\n@@ -891,10 +943,11 @@ package body Prj.Strt is\n \n                   for Index in 1 .. Names.Last - 2 loop\n                      Add_To_Buffer\n-                       (Get_Name_String (Names.Table (Index).Name));\n+                       (Get_Name_String (Names.Table (Index).Name),\n+                        Buffer, Buffer_Last);\n \n                      if Index /= Names.Last - 2 then\n-                        Add_To_Buffer (\".\");\n+                        Add_To_Buffer (\".\", Buffer, Buffer_Last);\n                      end if;\n                   end loop;\n \n@@ -904,9 +957,10 @@ package body Prj.Strt is\n \n                   --  Add the simple name before the name of the variable\n \n-                  Add_To_Buffer (\".\");\n+                  Add_To_Buffer (\".\", Buffer, Buffer_Last);\n                   Add_To_Buffer\n-                    (Get_Name_String (Names.Table (Names.Last - 1).Name));\n+                    (Get_Name_String (Names.Table (Names.Last - 1).Name),\n+                     Buffer, Buffer_Last);\n                   Name_Len := Buffer_Last;\n                   Name_Buffer (1 .. Name_Len) := Buffer (1 .. Buffer_Last);\n                   Long_Project := Name_Find;\n@@ -915,7 +969,7 @@ package body Prj.Strt is\n                   --  extended project.\n \n                   The_Project := Imported_Or_Extended_Project_Of\n-                                   (Current_Project, Long_Project);\n+                                   (Current_Project, In_Tree, Long_Project);\n \n                   if The_Project /= Empty_Node then\n                      Specified_Project := The_Project;\n@@ -927,7 +981,7 @@ package body Prj.Strt is\n                      --  First check for a possible project name\n \n                      The_Project := Imported_Or_Extended_Project_Of\n-                                   (Current_Project, Short_Project);\n+                                   (Current_Project, In_Tree, Short_Project);\n \n                      if The_Project = Empty_Node then\n                         --  Unknown prefix, report an error\n@@ -943,14 +997,14 @@ package body Prj.Strt is\n \n                         --  Now look for the package in this project\n \n-                        The_Package := First_Package_Of (The_Project);\n+                        The_Package := First_Package_Of (The_Project, In_Tree);\n \n                         while The_Package /= Empty_Node\n-                          and then Name_Of (The_Package) /=\n+                          and then Name_Of (The_Package, In_Tree) /=\n                                               Names.Table (Names.Last - 1).Name\n                         loop\n                            The_Package :=\n-                             Next_Package_In_Project (The_Package);\n+                             Next_Package_In_Project (The_Package, In_Tree);\n                         end loop;\n \n                         if The_Package = Empty_Node then\n@@ -971,9 +1025,9 @@ package body Prj.Strt is\n       end if;\n \n       if Look_For_Variable then\n-         Variable_Name := Name_Of (Variable);\n-         Set_Project_Node_Of (Variable, To => Specified_Project);\n-         Set_Package_Node_Of (Variable, To => Specified_Package);\n+         Variable_Name := Name_Of (Variable, In_Tree);\n+         Set_Project_Node_Of (Variable, In_Tree, To => Specified_Project);\n+         Set_Package_Node_Of (Variable, In_Tree, To => Specified_Package);\n \n          if Specified_Project /= Empty_Node then\n             The_Project := Specified_Project;\n@@ -990,13 +1044,14 @@ package body Prj.Strt is\n          --  declared in this package.\n \n          if Specified_Package /= Empty_Node then\n-            Current_Variable := First_Variable_Of (Specified_Package);\n+            Current_Variable :=\n+              First_Variable_Of (Specified_Package, In_Tree);\n \n             while Current_Variable /= Empty_Node\n               and then\n-              Name_Of (Current_Variable) /= Variable_Name\n+              Name_Of (Current_Variable, In_Tree) /= Variable_Name\n             loop\n-               Current_Variable := Next_Variable (Current_Variable);\n+               Current_Variable := Next_Variable (Current_Variable, In_Tree);\n             end loop;\n \n          else\n@@ -1007,25 +1062,28 @@ package body Prj.Strt is\n             if Specified_Project = Empty_Node\n               and then Current_Package /= Empty_Node\n             then\n-               Current_Variable := First_Variable_Of (Current_Package);\n+               Current_Variable :=\n+                 First_Variable_Of (Current_Package, In_Tree);\n \n                while Current_Variable /= Empty_Node\n-                 and then Name_Of (Current_Variable) /= Variable_Name\n+                 and then Name_Of (Current_Variable, In_Tree) /= Variable_Name\n                loop\n-                  Current_Variable := Next_Variable (Current_Variable);\n+                  Current_Variable :=\n+                    Next_Variable (Current_Variable, In_Tree);\n                end loop;\n             end if;\n \n             --  If we have not found the variable in the package, check if the\n             --  variable has been declared in the project.\n \n             if Current_Variable = Empty_Node then\n-               Current_Variable := First_Variable_Of (The_Project);\n+               Current_Variable := First_Variable_Of (The_Project, In_Tree);\n \n                while Current_Variable /= Empty_Node\n-                 and then Name_Of (Current_Variable) /= Variable_Name\n+                 and then Name_Of (Current_Variable, In_Tree) /= Variable_Name\n                loop\n-                  Current_Variable := Next_Variable (Current_Variable);\n+                  Current_Variable :=\n+                    Next_Variable (Current_Variable, In_Tree);\n                end loop;\n             end if;\n          end if;\n@@ -1041,11 +1099,15 @@ package body Prj.Strt is\n \n       if Current_Variable /= Empty_Node then\n          Set_Expression_Kind_Of\n-           (Variable, To => Expression_Kind_Of (Current_Variable));\n+           (Variable, In_Tree,\n+            To => Expression_Kind_Of (Current_Variable, In_Tree));\n \n-         if Kind_Of (Current_Variable) = N_Typed_Variable_Declaration then\n+         if\n+           Kind_Of (Current_Variable, In_Tree) = N_Typed_Variable_Declaration\n+         then\n             Set_String_Type_Of\n-              (Variable, To => String_Type_Of (Current_Variable));\n+              (Variable, In_Tree,\n+               To => String_Type_Of (Current_Variable, In_Tree));\n          end if;\n       end if;\n \n@@ -1054,15 +1116,15 @@ package body Prj.Strt is\n \n       if Token = Tok_Left_Paren then\n          Error_Msg (\"\\variables cannot be associative arrays\", Token_Ptr);\n-         Scan;\n+         Scan (In_Tree);\n          Expect (Tok_String_Literal, \"literal string\");\n \n          if Token = Tok_String_Literal then\n-            Scan;\n+            Scan (In_Tree);\n             Expect (Tok_Right_Paren, \"`)`\");\n \n             if Token = Tok_Right_Paren then\n-               Scan;\n+               Scan (In_Tree);\n             end if;\n          end if;\n       end if;\n@@ -1072,7 +1134,10 @@ package body Prj.Strt is\n    -- Start_New_Case_Construction --\n    ---------------------------------\n \n-   procedure Start_New_Case_Construction (String_Type  : Project_Node_Id) is\n+   procedure Start_New_Case_Construction\n+     (In_Tree      : Project_Node_Tree_Ref;\n+      String_Type  : Project_Node_Id)\n+   is\n       Current_String : Project_Node_Id;\n \n    begin\n@@ -1089,11 +1154,11 @@ package body Prj.Strt is\n       --  Add to table Choices the literal of the string type\n \n       if String_Type /= Empty_Node then\n-         Current_String := First_Literal_String (String_Type);\n+         Current_String := First_Literal_String (String_Type, In_Tree);\n \n          while Current_String /= Empty_Node loop\n-            Add (This_String => String_Value_Of (Current_String));\n-            Current_String := Next_Literal_String (Current_String);\n+            Add (This_String => String_Value_Of (Current_String, In_Tree));\n+            Current_String := Next_Literal_String (Current_String, In_Tree);\n          end loop;\n       end if;\n \n@@ -1109,7 +1174,8 @@ package body Prj.Strt is\n    -----------\n \n    procedure Terms\n-     (Term            : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Term            : out Project_Node_Id;\n       Expr_Kind       : in out Variable_Kind;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id;\n@@ -1125,8 +1191,8 @@ package body Prj.Strt is\n    begin\n       --  Declare a new node for the term\n \n-      Term := Default_Project_Node (Of_Kind => N_Term);\n-      Set_Location_Of (Term, To => Token_Ptr);\n+      Term := Default_Project_Node (Of_Kind => N_Term, In_Tree => In_Tree);\n+      Set_Location_Of (Term, In_Tree, To => Token_Ptr);\n \n       case Token is\n          when Tok_Left_Paren =>\n@@ -1156,35 +1222,38 @@ package body Prj.Strt is\n             --  Declare a new node for this literal string list\n \n             Term_Id := Default_Project_Node\n-              (Of_Kind => N_Literal_String_List,\n+              (Of_Kind       => N_Literal_String_List,\n+               In_Tree       => In_Tree,\n                And_Expr_Kind => List);\n-            Set_Current_Term (Term, To => Term_Id);\n-            Set_Location_Of (Term, To => Token_Ptr);\n+            Set_Current_Term (Term, In_Tree, To => Term_Id);\n+            Set_Location_Of  (Term, In_Tree, To => Token_Ptr);\n \n             --  Scan past the left parenthesis\n \n-            Scan;\n+            Scan (In_Tree);\n \n             --  If the left parenthesis is immediately followed by a right\n             --  parenthesis, the literal string list is empty.\n \n             if Token = Tok_Right_Paren then\n-               Scan;\n+               Scan (In_Tree);\n \n             else\n                --  Otherwise, we parse the expression(s) in the literal string\n                --  list.\n \n                loop\n                   Current_Location := Token_Ptr;\n-                  Parse_Expression (Expression      => Next_Expression,\n-                                    Current_Project => Current_Project,\n-                                    Current_Package => Current_Package,\n-                                    Optional_Index  => Optional_Index);\n+                  Parse_Expression\n+                    (In_Tree         => In_Tree,\n+                     Expression      => Next_Expression,\n+                     Current_Project => Current_Project,\n+                     Current_Package => Current_Package,\n+                     Optional_Index  => Optional_Index);\n \n                   --  The expression kind is String list, report an error\n \n-                  if Expression_Kind_Of (Next_Expression) = List then\n+                  if Expression_Kind_Of (Next_Expression, In_Tree) = List then\n                      Error_Msg (\"single expression expected\",\n                                 Current_Location);\n                   end if;\n@@ -1194,26 +1263,26 @@ package body Prj.Strt is\n \n                   if Current_Expression = Empty_Node then\n                      Set_First_Expression_In_List\n-                       (Term_Id, To => Next_Expression);\n+                       (Term_Id, In_Tree, To => Next_Expression);\n                   else\n                      Set_Next_Expression_In_List\n-                       (Current_Expression, To => Next_Expression);\n+                       (Current_Expression, In_Tree, To => Next_Expression);\n                   end if;\n \n                   Current_Expression := Next_Expression;\n \n                   --  If there is a comma, continue with the next expression\n \n                   exit when Token /= Tok_Comma;\n-                  Scan; -- past the comma\n+                  Scan (In_Tree); -- past the comma\n                end loop;\n \n                --  We expect a closing right parenthesis\n \n                Expect (Tok_Right_Paren, \"`)`\");\n \n                if Token = Tok_Right_Paren then\n-                  Scan;\n+                  Scan (In_Tree);\n                end if;\n             end if;\n \n@@ -1228,29 +1297,31 @@ package body Prj.Strt is\n \n             --  Declare a new node for the string literal\n \n-            Term_Id := Default_Project_Node (Of_Kind => N_Literal_String);\n-            Set_Current_Term (Term, To => Term_Id);\n-            Set_String_Value_Of (Term_Id, To => Token_Name);\n+            Term_Id :=\n+              Default_Project_Node\n+                (Of_Kind => N_Literal_String, In_Tree => In_Tree);\n+            Set_Current_Term (Term, In_Tree, To => Term_Id);\n+            Set_String_Value_Of (Term_Id, In_Tree, To => Token_Name);\n \n             --  Scan past the string literal\n \n-            Scan;\n+            Scan (In_Tree);\n \n             --  Check for possible index expression\n \n             if Token = Tok_At then\n                if not Optional_Index then\n                   Error_Msg (\"index not allowed here\", Token_Ptr);\n-                  Scan;\n+                  Scan (In_Tree);\n \n                   if Token = Tok_Integer_Literal then\n-                     Scan;\n+                     Scan (In_Tree);\n                   end if;\n \n                --  Set the index value\n \n                else\n-                  Scan;\n+                  Scan (In_Tree);\n                   Expect (Tok_Integer_Literal, \"integer literal\");\n \n                   if Token = Tok_Integer_Literal then\n@@ -1260,11 +1331,12 @@ package body Prj.Strt is\n                         if Index = 0 then\n                            Error_Msg (\"index cannot be zero\", Token_Ptr);\n                         else\n-                           Set_Source_Index_Of (Term_Id, To => Index);\n+                           Set_Source_Index_Of\n+                             (Term_Id, In_Tree, To => Index);\n                         end if;\n                      end;\n \n-                     Scan;\n+                     Scan (In_Tree);\n                   end if;\n                end if;\n             end if;\n@@ -1275,21 +1347,22 @@ package body Prj.Strt is\n             --  Get the variable or attribute reference\n \n             Parse_Variable_Reference\n-              (Variable        => Reference,\n+              (In_Tree         => In_Tree,\n+               Variable        => Reference,\n                Current_Project => Current_Project,\n                Current_Package => Current_Package);\n-            Set_Current_Term (Term, To => Reference);\n+            Set_Current_Term (Term, In_Tree, To => Reference);\n \n             if Reference /= Empty_Node then\n \n                --  If we don't know the expression kind (first term), then it\n                --  has the kind of the variable or attribute reference.\n \n                if Expr_Kind = Undefined then\n-                  Expr_Kind := Expression_Kind_Of (Reference);\n+                  Expr_Kind := Expression_Kind_Of (Reference, In_Tree);\n \n                elsif Expr_Kind = Single\n-                 and then Expression_Kind_Of (Reference) = List\n+                 and then Expression_Kind_Of (Reference, In_Tree) = List\n                then\n                   --  If the expression is a single list, and the reference is\n                   --  a string list, report an error, and set the expression\n@@ -1308,26 +1381,27 @@ package body Prj.Strt is\n             --  attribute reference of the current project.\n \n             Current_Location := Token_Ptr;\n-            Scan;\n+            Scan (In_Tree);\n             Expect (Tok_Apostrophe, \"`'`\");\n \n             if Token = Tok_Apostrophe then\n                Attribute_Reference\n-                 (Reference       => Reference,\n+                 (In_Tree         => In_Tree,\n+                  Reference       => Reference,\n                   First_Attribute => Prj.Attr.Attribute_First,\n                   Current_Project => Current_Project,\n                   Current_Package => Empty_Node);\n-               Set_Current_Term (Term, To => Reference);\n+               Set_Current_Term (Term, In_Tree, To => Reference);\n             end if;\n \n             --  Same checks as above for the expression kind\n \n             if Reference /= Empty_Node then\n                if Expr_Kind = Undefined then\n-                  Expr_Kind := Expression_Kind_Of (Reference);\n+                  Expr_Kind := Expression_Kind_Of (Reference, In_Tree);\n \n                elsif Expr_Kind = Single\n-                 and then Expression_Kind_Of (Reference) = List\n+                 and then Expression_Kind_Of (Reference, In_Tree) = List\n                then\n                   Error_Msg\n                     (\"lists cannot appear in single string expression\",\n@@ -1342,8 +1416,9 @@ package body Prj.Strt is\n                Expr_Kind := Single;\n             end if;\n \n-            External_Reference (External_Value => Reference);\n-            Set_Current_Term (Term, To => Reference);\n+            External_Reference\n+              (In_Tree => In_Tree, External_Value => Reference);\n+            Set_Current_Term (Term, In_Tree, To => Reference);\n \n          when others =>\n             Error_Msg (\"cannot be part of an expression\", Token_Ptr);\n@@ -1357,17 +1432,19 @@ package body Prj.Strt is\n \n          --  Scan past the '&'\n \n-         Scan;\n+         Scan (In_Tree);\n \n-         Terms (Term            => Next_Term,\n-                Expr_Kind       => Expr_Kind,\n-                Current_Project => Current_Project,\n-                Current_Package => Current_Package,\n-                Optional_Index  => Optional_Index);\n+         Terms\n+           (In_Tree         => In_Tree,\n+            Term            => Next_Term,\n+            Expr_Kind       => Expr_Kind,\n+            Current_Project => Current_Project,\n+            Current_Package => Current_Package,\n+            Optional_Index  => Optional_Index);\n \n          --  And link the next term to this term\n \n-         Set_Next_Term (Term, To => Next_Term);\n+         Set_Next_Term (Term, In_Tree, To => Next_Term);\n       end if;\n    end Terms;\n "}, {"sha": "623c5bf16f6cad199096510b47f721f515610fdf", "filename": "gcc/ada/prj-strt.ads", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-strt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-strt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,9 @@ with Prj.Tree;  use Prj.Tree;\n \n private package Prj.Strt is\n \n-   procedure Parse_String_Type_List (First_String : out Project_Node_Id);\n+   procedure Parse_String_Type_List\n+     (In_Tree      : Project_Node_Tree_Ref;\n+      First_String : out Project_Node_Id);\n    --  Get the list of literal strings that are allowed for a typed string.\n    --  On entry, the current token is the first literal string following\n    --  a left parenthesis in a string type declaration such as:\n@@ -45,7 +47,9 @@ private package Prj.Strt is\n    --      or after a comma\n    --    - two literal strings in the list are equal\n \n-   procedure Start_New_Case_Construction (String_Type : Project_Node_Id);\n+   procedure Start_New_Case_Construction\n+     (In_Tree     : Project_Node_Tree_Ref;\n+      String_Type : Project_Node_Id);\n    --  This procedure is called at the beginning of a case construction\n    --  The parameter String_Type is the node for the string type\n    --  of the case label variable.\n@@ -65,15 +69,17 @@ private package Prj.Strt is\n    --  not been specified.\n \n    procedure Parse_Choice_List\n-     (First_Choice : out Project_Node_Id);\n+     (In_Tree      : Project_Node_Tree_Ref;\n+      First_Choice : out Project_Node_Id);\n    --  Get the label for a choice list.\n    --  Report an error if\n    --    - a case label is not a literal string\n    --    - a case label is not in the typed string list\n    --    - the same case label is repeated in the same case construction\n \n    procedure Parse_Expression\n-     (Expression      : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Expression      : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id;\n       Optional_Index  : Boolean);\n@@ -85,7 +91,8 @@ private package Prj.Strt is\n    --  been parsed.\n \n    procedure Parse_Variable_Reference\n-     (Variable        : out Project_Node_Id;\n+     (In_Tree         : Project_Node_Tree_Ref;\n+      Variable        : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n       Current_Package : Project_Node_Id);\n    --  Parse a variable or attribute reference."}, {"sha": "de210e1edb7b4e38ca1d5f2c2c23dfff598429b7", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 682, "deletions": 493, "changes": 1175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -76,7 +76,8 @@ package body Prj.Tree is\n    --  Set to True when some comments may not be associated with any node\n \n    function Comment_Zones_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    --  Returns the ID of the N_Comment_Zones node associated with node Node.\n    --  If there is not already an N_Comment_Zones node, create one and\n    --  associate it with node Node.\n@@ -85,24 +86,28 @@ package body Prj.Tree is\n    -- Add_Comments --\n    ------------------\n \n-   procedure Add_Comments (To : Project_Node_Id; Where : Comment_Location) is\n+   procedure Add_Comments\n+     (To       : Project_Node_Id;\n+      In_Tree  : Project_Node_Tree_Ref;\n+      Where    : Comment_Location) is\n       Zone     : Project_Node_Id := Empty_Node;\n       Previous : Project_Node_Id := Empty_Node;\n \n    begin\n       pragma Assert\n         (To /= Empty_Node\n           and then\n-         Project_Nodes.Table (To).Kind /= N_Comment);\n+         In_Tree.Project_Nodes.Table (To).Kind /= N_Comment);\n \n-      Zone := Project_Nodes.Table (To).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (To).Comments;\n \n       if Zone = Empty_Node then\n \n          --  Create new N_Comment_Zones node\n \n-         Project_Nodes.Increment_Last;\n-         Project_Nodes.Table (Project_Nodes.Last) :=\n+         Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n+         In_Tree.Project_Nodes.Table\n+           (Project_Node_Table.Last (In_Tree.Project_Nodes)) :=\n            (Kind             => N_Comment_Zones,\n             Expr_Kind        => Undefined,\n             Location         => No_Location,\n@@ -121,12 +126,12 @@ package body Prj.Tree is\n             Flag2            => False,\n             Comments         => Empty_Node);\n \n-         Zone := Project_Nodes.Last;\n-         Project_Nodes.Table (To).Comments := Zone;\n+         Zone := Project_Node_Table.Last (In_Tree.Project_Nodes);\n+         In_Tree.Project_Nodes.Table (To).Comments := Zone;\n       end if;\n \n       if Where = End_Of_Line then\n-         Project_Nodes.Table (Zone).Value := Comments.Table (1).Value;\n+         In_Tree.Project_Nodes.Table (Zone).Value := Comments.Table (1).Value;\n \n       else\n          --  Get each comments in the Comments table and link them to node To\n@@ -145,8 +150,9 @@ package body Prj.Tree is\n                return;\n             end if;\n \n-            Project_Nodes.Increment_Last;\n-            Project_Nodes.Table (Project_Nodes.Last) :=\n+            Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n+            In_Tree.Project_Nodes.Table\n+              (Project_Node_Table.Last (In_Tree.Project_Nodes)) :=\n               (Kind             => N_Comment,\n                Expr_Kind        => Undefined,\n                Flag1            => Comments.Table (J).Follows_Empty_Line,\n@@ -172,16 +178,20 @@ package body Prj.Tree is\n             if Previous = Empty_Node then\n                case Where is\n                   when Before =>\n-                     Project_Nodes.Table (Zone).Field1 := Project_Nodes.Last;\n+                     In_Tree.Project_Nodes.Table (Zone).Field1 :=\n+                       Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n                   when After =>\n-                     Project_Nodes.Table (Zone).Field2 := Project_Nodes.Last;\n+                     In_Tree.Project_Nodes.Table (Zone).Field2 :=\n+                       Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n                   when Before_End =>\n-                     Project_Nodes.Table (Zone).Field3 := Project_Nodes.Last;\n+                     In_Tree.Project_Nodes.Table (Zone).Field3 :=\n+                       Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n                   when After_End =>\n-                     Project_Nodes.Table (Zone).Comments := Project_Nodes.Last;\n+                     In_Tree.Project_Nodes.Table (Zone).Comments :=\n+                       Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n                   when End_Of_Line =>\n                      null;\n@@ -190,13 +200,14 @@ package body Prj.Tree is\n             else\n                --  When it is not the first, link it to the previous one\n \n-               Project_Nodes.Table (Previous).Comments := Project_Nodes.Last;\n+               In_Tree.Project_Nodes.Table (Previous).Comments :=\n+                 Project_Node_Table.Last (In_Tree.Project_Nodes);\n             end if;\n \n             --  This node becomes the previous one for the next comment, if\n             --  there is one.\n \n-            Previous := Project_Nodes.Last;\n+            Previous := Project_Node_Table.Last (In_Tree.Project_Nodes);\n          end loop;\n       end if;\n \n@@ -211,98 +222,105 @@ package body Prj.Tree is\n    --------------------------------\n \n    function Associative_Array_Index_Of\n-     (Node : Project_Node_Id) return Name_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      return Project_Nodes.Table (Node).Value;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      return In_Tree.Project_Nodes.Table (Node).Value;\n    end Associative_Array_Index_Of;\n \n    ----------------------------\n    -- Associative_Package_Of --\n    ----------------------------\n \n    function Associative_Package_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n-      return Project_Nodes.Table (Node).Field3;\n+          (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Associative_Package_Of;\n \n    ----------------------------\n    -- Associative_Project_Of --\n    ----------------------------\n \n    function Associative_Project_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n-      return Project_Nodes.Table (Node).Field2;\n+          (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Associative_Project_Of;\n \n    ----------------------\n    -- Case_Insensitive --\n    ----------------------\n \n-   function Case_Insensitive (Node : Project_Node_Id) return Boolean is\n+   function Case_Insensitive\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      return Project_Nodes.Table (Node).Flag1;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      return In_Tree.Project_Nodes.Table (Node).Flag1;\n    end Case_Insensitive;\n \n    --------------------------------\n    -- Case_Variable_Reference_Of --\n    --------------------------------\n \n    function Case_Variable_Reference_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Construction);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Case_Variable_Reference_Of;\n \n    ----------------------\n    -- Comment_Zones_Of --\n    ----------------------\n \n    function Comment_Zones_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n       Zone : Project_Node_Id;\n \n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Zone := Project_Nodes.Table (Node).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       --  If there is not already an N_Comment_Zones associated, create a new\n       --  one and associate it with node Node.\n \n       if Zone = Empty_Node then\n-         Project_Nodes.Increment_Last;\n-         Zone := Project_Nodes.Last;\n-         Project_Nodes.Table (Zone) :=\n+         Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n+         Zone := Project_Node_Table.Last (In_Tree.Project_Nodes);\n+         In_Tree.Project_Nodes.Table (Zone) :=\n         (Kind             => N_Comment_Zones,\n          Location         => No_Location,\n          Directory        => No_Name,\n@@ -320,7 +338,7 @@ package body Prj.Tree is\n          Flag1            => False,\n          Flag2            => False,\n          Comments         => Empty_Node);\n-         Project_Nodes.Table (Node).Comments := Zone;\n+         In_Tree.Project_Nodes.Table (Node).Comments := Zone;\n       end if;\n \n       return Zone;\n@@ -331,37 +349,40 @@ package body Prj.Tree is\n    -----------------------\n \n    function Current_Item_Node\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Current_Item_Node;\n \n    ------------------\n    -- Current_Term --\n    ------------------\n \n    function Current_Term\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Term);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Current_Term;\n \n    --------------------------\n    -- Default_Project_Node --\n    --------------------------\n \n    function Default_Project_Node\n-     (Of_Kind       : Project_Node_Kind;\n+     (In_Tree       : Project_Node_Tree_Ref;\n+      Of_Kind       : Project_Node_Kind;\n       And_Expr_Kind : Variable_Kind := Undefined) return Project_Node_Id\n    is\n       Result   : Project_Node_Id;\n@@ -371,8 +392,9 @@ package body Prj.Tree is\n    begin\n       --  Create new node with specified kind and expression kind\n \n-      Project_Nodes.Increment_Last;\n-      Project_Nodes.Table (Project_Nodes.Last) :=\n+      Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n+      In_Tree.Project_Nodes.Table\n+        (Project_Node_Table.Last (In_Tree.Project_Nodes)) :=\n         (Kind             => Of_Kind,\n          Location         => No_Location,\n          Directory        => No_Name,\n@@ -393,7 +415,7 @@ package body Prj.Tree is\n \n       --  Save the new node for the returned value\n \n-      Result := Project_Nodes.Last;\n+      Result := Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n       if Comments.Last > 0 then\n \n@@ -404,8 +426,9 @@ package body Prj.Tree is\n \n          elsif Of_Kind /= N_Comment and then Of_Kind /= N_Comment_Zones then\n \n-            Project_Nodes.Increment_Last;\n-            Project_Nodes.Table (Project_Nodes.Last) :=\n+            Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n+            In_Tree.Project_Nodes.Table\n+              (Project_Node_Table.Last (In_Tree.Project_Nodes)) :=\n               (Kind             => N_Comment_Zones,\n                Expr_Kind        => Undefined,\n                Location         => No_Location,\n@@ -424,16 +447,17 @@ package body Prj.Tree is\n                Flag2            => False,\n                Comments         => Empty_Node);\n \n-            Zone := Project_Nodes.Last;\n-            Project_Nodes.Table (Result).Comments := Zone;\n+            Zone := Project_Node_Table.Last (In_Tree.Project_Nodes);\n+            In_Tree.Project_Nodes.Table (Result).Comments := Zone;\n             Previous := Empty_Node;\n \n             for J in 1 .. Comments.Last loop\n \n                --  Create a new N_Comment node\n \n-               Project_Nodes.Increment_Last;\n-               Project_Nodes.Table (Project_Nodes.Last) :=\n+               Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n+               In_Tree.Project_Nodes.Table\n+                 (Project_Node_Table.Last (In_Tree.Project_Nodes)) :=\n                  (Kind             => N_Comment,\n                   Expr_Kind        => Undefined,\n                   Flag1            => Comments.Table (J).Follows_Empty_Line,\n@@ -457,17 +481,18 @@ package body Prj.Tree is\n                --  otherwise to the previous one.\n \n                if Previous = Empty_Node then\n-                  Project_Nodes.Table (Zone).Field1 := Project_Nodes.Last;\n+                  In_Tree.Project_Nodes.Table (Zone).Field1 :=\n+                    Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n                else\n-                  Project_Nodes.Table (Previous).Comments :=\n-                    Project_Nodes.Last;\n+                  In_Tree.Project_Nodes.Table (Previous).Comments :=\n+                    Project_Node_Table.Last (In_Tree.Project_Nodes);\n                end if;\n \n                --  This new node will be the previous one for the next\n                --  N_Comment node, if there is one.\n \n-               Previous := Project_Nodes.Last;\n+               Previous := Project_Node_Table.Last (In_Tree.Project_Nodes);\n             end loop;\n \n             --  Empty the Comments table after all comments have been processed\n@@ -483,206 +508,226 @@ package body Prj.Tree is\n    -- Directory_Of --\n    ------------------\n \n-   function Directory_Of (Node : Project_Node_Id) return Name_Id is\n+   function Directory_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Directory;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Directory;\n    end Directory_Of;\n \n    -------------------------\n    -- End_Of_Line_Comment --\n    -------------------------\n \n-   function End_Of_Line_Comment (Node : Project_Node_Id) return Name_Id is\n+   function End_Of_Line_Comment\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Zone := Project_Nodes.Table (Node).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       if Zone = Empty_Node then\n          return No_Name;\n       else\n-         return Project_Nodes.Table (Zone).Value;\n+         return In_Tree.Project_Nodes.Table (Zone).Value;\n       end if;\n    end End_Of_Line_Comment;\n \n    ------------------------\n    -- Expression_Kind_Of --\n    ------------------------\n \n-   function Expression_Kind_Of (Node : Project_Node_Id) return Variable_Kind is\n+   function Expression_Kind_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Variable_Kind is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n            and then\n-             (Project_Nodes.Table (Node).Kind = N_Literal_String\n+             (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Variable_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind =\n+                       N_Typed_Variable_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Package_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Expression\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Expression\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Term\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Term\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+              In_Tree.Project_Nodes.Table (Node).Kind =\n+                        N_Attribute_Reference));\n \n-      return Project_Nodes.Table (Node).Expr_Kind;\n+      return In_Tree.Project_Nodes.Table (Node).Expr_Kind;\n    end Expression_Kind_Of;\n \n    -------------------\n    -- Expression_Of --\n    -------------------\n \n    function Expression_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Attribute_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Typed_Variable_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Variable_Declaration));\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Variable_Declaration));\n \n-      return Project_Nodes.Table (Node).Field1;\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Expression_Of;\n \n    -------------------------\n    -- Extended_Project_Of --\n    -------------------------\n \n    function Extended_Project_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Extended_Project_Of;\n \n    ------------------------------\n    -- Extended_Project_Path_Of --\n    ------------------------------\n \n    function Extended_Project_Path_Of\n-     (Node : Project_Node_Id) return Name_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Value;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Value;\n    end Extended_Project_Path_Of;\n \n    --------------------------\n    -- Extending_Project_Of --\n    --------------------------\n    function Extending_Project_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n-      return Project_Nodes.Table (Node).Field3;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Extending_Project_Of;\n \n    ---------------------------\n    -- External_Reference_Of --\n    ---------------------------\n \n    function External_Reference_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_External_Value);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end External_Reference_Of;\n \n    -------------------------\n    -- External_Default_Of --\n    -------------------------\n \n    function External_Default_Of\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_External_Value);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end External_Default_Of;\n \n    ------------------------\n    -- First_Case_Item_Of --\n    ------------------------\n \n    function First_Case_Item_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Construction);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end First_Case_Item_Of;\n \n    ---------------------\n    -- First_Choice_Of --\n    ---------------------\n \n    function First_Choice_Of\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Item);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end First_Choice_Of;\n \n    -------------------------\n    -- First_Comment_After --\n    -------------------------\n \n    function First_Comment_After\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n       Zone : Project_Node_Id := Empty_Node;\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Zone := Project_Nodes.Table (Node).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       if Zone = Empty_Node then\n          return Empty_Node;\n \n       else\n-         return Project_Nodes.Table (Zone).Field2;\n+         return In_Tree.Project_Nodes.Table (Zone).Field2;\n       end if;\n    end First_Comment_After;\n \n@@ -691,20 +736,21 @@ package body Prj.Tree is\n    -----------------------------\n \n    function First_Comment_After_End\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Project_Node_Id\n    is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Zone := Project_Nodes.Table (Node).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       if Zone = Empty_Node then\n          return Empty_Node;\n \n       else\n-         return Project_Nodes.Table (Zone).Comments;\n+         return In_Tree.Project_Nodes.Table (Zone).Comments;\n       end if;\n    end First_Comment_After_End;\n \n@@ -713,19 +759,20 @@ package body Prj.Tree is\n    --------------------------\n \n    function First_Comment_Before\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Zone := Project_Nodes.Table (Node).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       if Zone = Empty_Node then\n          return Empty_Node;\n \n       else\n-         return Project_Nodes.Table (Zone).Field1;\n+         return In_Tree.Project_Nodes.Table (Zone).Field1;\n       end if;\n    end First_Comment_Before;\n \n@@ -734,19 +781,20 @@ package body Prj.Tree is\n    ------------------------------\n \n    function First_Comment_Before_End\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Zone := Project_Nodes.Table (Node).Comments;\n+      Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       if Zone = Empty_Node then\n          return Empty_Node;\n \n       else\n-         return Project_Nodes.Table (Zone).Field3;\n+         return In_Tree.Project_Nodes.Table (Zone).Field3;\n       end if;\n    end First_Comment_Before_End;\n \n@@ -755,22 +803,23 @@ package body Prj.Tree is\n    -------------------------------\n \n    function First_Declarative_Item_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project_Declaration\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Case_Item\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n \n-      if Project_Nodes.Table (Node).Kind = N_Project_Declaration then\n-         return Project_Nodes.Table (Node).Field1;\n+      if In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration then\n+         return In_Tree.Project_Nodes.Table (Node).Field1;\n       else\n-         return Project_Nodes.Table (Node).Field2;\n+         return In_Tree.Project_Nodes.Table (Node).Field2;\n       end if;\n    end First_Declarative_Item_Of;\n \n@@ -779,120 +828,130 @@ package body Prj.Tree is\n    ------------------------------\n \n    function First_Expression_In_List\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Literal_String_List);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String_List);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end First_Expression_In_List;\n \n    --------------------------\n    -- First_Literal_String --\n    --------------------------\n \n    function First_Literal_String\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_String_Type_Declaration);\n-      return Project_Nodes.Table (Node).Field1;\n+         In_Tree.Project_Nodes.Table (Node).Kind =\n+           N_String_Type_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end First_Literal_String;\n \n    ----------------------\n    -- First_Package_Of --\n    ----------------------\n \n    function First_Package_Of\n-     (Node : Project_Node_Id) return Package_Declaration_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Package_Declaration_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Packages;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Packages;\n    end First_Package_Of;\n \n    --------------------------\n    -- First_String_Type_Of --\n    --------------------------\n \n    function First_String_Type_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Field3;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end First_String_Type_Of;\n \n    ----------------\n    -- First_Term --\n    ----------------\n \n    function First_Term\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Expression);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end First_Term;\n \n    -----------------------\n    -- First_Variable_Of --\n    -----------------------\n \n    function First_Variable_Of\n-     (Node : Project_Node_Id) return Variable_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Variable_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n \n-      return Project_Nodes.Table (Node).Variables;\n+      return In_Tree.Project_Nodes.Table (Node).Variables;\n    end First_Variable_Of;\n \n    --------------------------\n    -- First_With_Clause_Of --\n    --------------------------\n \n    function First_With_Clause_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end First_With_Clause_Of;\n \n    ------------------------\n    -- Follows_Empty_Line --\n    ------------------------\n \n-   function Follows_Empty_Line (Node : Project_Node_Id) return Boolean is\n+   function Follows_Empty_Line\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n          and then\n-         Project_Nodes.Table (Node).Kind = N_Comment);\n-      return Project_Nodes.Table (Node).Flag1;\n+         In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n+      return In_Tree.Project_Nodes.Table (Node).Flag1;\n    end Follows_Empty_Line;\n \n    ----------\n@@ -908,40 +967,43 @@ package body Prj.Tree is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize is\n+   procedure Initialize (Tree : Project_Node_Tree_Ref) is\n    begin\n-      Project_Nodes.Set_Last (Empty_Node);\n-      Projects_Htable.Reset;\n+      Project_Node_Table.Init (Tree.Project_Nodes);\n+      Projects_Htable.Reset (Tree.Projects_HT);\n    end Initialize;\n \n    -------------------------------\n    -- Is_Followed_By_Empty_Line --\n    -------------------------------\n \n    function Is_Followed_By_Empty_Line\n-     (Node : Project_Node_Id) return Boolean\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Comment);\n-      return Project_Nodes.Table (Node).Flag2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n+      return In_Tree.Project_Nodes.Table (Node).Flag2;\n    end Is_Followed_By_Empty_Line;\n \n    ----------------------\n    -- Is_Extending_All --\n    ----------------------\n \n-   function Is_Extending_All (Node  : Project_Node_Id) return Boolean is\n+   function Is_Extending_All\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-           (Project_Nodes.Table (Node).Kind = N_Project\n+           (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n               or else\n-            Project_Nodes.Table (Node).Kind = N_With_Clause));\n-      return Project_Nodes.Table (Node).Flag2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n+      return In_Tree.Project_Nodes.Table (Node).Flag2;\n    end Is_Extending_All;\n \n    -------------------------------------\n@@ -950,9 +1012,11 @@ package body Prj.Tree is\n \n    function Imported_Or_Extended_Project_Of\n      (Project   : Project_Node_Id;\n+      In_Tree   : Project_Node_Tree_Ref;\n       With_Name : Name_Id) return Project_Node_Id\n    is\n-      With_Clause : Project_Node_Id := First_With_Clause_Of (Project);\n+      With_Clause : Project_Node_Id :=\n+        First_With_Clause_Of (Project, In_Tree);\n       Result      : Project_Node_Id := Empty_Node;\n \n    begin\n@@ -963,18 +1027,21 @@ package body Prj.Tree is\n          --  Only non limited imported project may be used as prefix\n          --  of variable or attributes.\n \n-         Result := Non_Limited_Project_Node_Of (With_Clause);\n-         exit when Result /= Empty_Node and then Name_Of (Result) = With_Name;\n-         With_Clause := Next_With_Clause_Of (With_Clause);\n+         Result := Non_Limited_Project_Node_Of (With_Clause, In_Tree);\n+         exit when Result /= Empty_Node\n+           and then Name_Of (Result, In_Tree) = With_Name;\n+         With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n       end loop;\n \n       --  If it is not an imported project, it might be the imported project\n \n       if With_Clause = Empty_Node then\n-         Result := Extended_Project_Of (Project_Declaration_Of (Project));\n+         Result :=\n+           Extended_Project_Of\n+             (Project_Declaration_Of (Project, In_Tree), In_Tree);\n \n          if Result /= Empty_Node\n-           and then Name_Of (Result) /= With_Name\n+           and then Name_Of (Result, In_Tree) /= With_Name\n          then\n             Result := Empty_Node;\n          end if;\n@@ -987,305 +1054,338 @@ package body Prj.Tree is\n    -- Kind_Of --\n    -------------\n \n-   function Kind_Of (Node : Project_Node_Id) return Project_Node_Kind is\n+   function Kind_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Kind is\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      return Project_Nodes.Table (Node).Kind;\n+      return In_Tree.Project_Nodes.Table (Node).Kind;\n    end Kind_Of;\n \n    -----------------\n    -- Location_Of --\n    -----------------\n \n-   function Location_Of (Node : Project_Node_Id) return Source_Ptr is\n+   function Location_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Source_Ptr is\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      return Project_Nodes.Table (Node).Location;\n+      return In_Tree.Project_Nodes.Table (Node).Location;\n    end Location_Of;\n \n    -------------\n    -- Name_Of --\n    -------------\n \n-   function Name_Of (Node : Project_Node_Id) return Name_Id is\n+   function Name_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id is\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      return Project_Nodes.Table (Node).Name;\n+      return In_Tree.Project_Nodes.Table (Node).Name;\n    end Name_Of;\n \n    --------------------\n    -- Next_Case_Item --\n    --------------------\n \n    function Next_Case_Item\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Item);\n-      return Project_Nodes.Table (Node).Field3;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Next_Case_Item;\n \n    ------------------\n    -- Next_Comment --\n    ------------------\n \n-   function Next_Comment (Node : Project_Node_Id) return Project_Node_Id is\n+   function Next_Comment\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Comment);\n-      return Project_Nodes.Table (Node).Comments;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n+      return In_Tree.Project_Nodes.Table (Node).Comments;\n    end Next_Comment;\n \n    ---------------------------\n    -- Next_Declarative_Item --\n    ---------------------------\n \n    function Next_Declarative_Item\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_Declarative_Item;\n \n    -----------------------------\n    -- Next_Expression_In_List --\n    -----------------------------\n \n    function Next_Expression_In_List\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Expression);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_Expression_In_List;\n \n    -------------------------\n    -- Next_Literal_String --\n    -------------------------\n \n    function Next_Literal_String\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Literal_String);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Next_Literal_String;\n \n    -----------------------------\n    -- Next_Package_In_Project --\n    -----------------------------\n \n    function Next_Package_In_Project\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n-      return Project_Nodes.Table (Node).Field3;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Next_Package_In_Project;\n \n    ----------------------\n    -- Next_String_Type --\n    ----------------------\n \n    function Next_String_Type\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_String_Type_Declaration);\n-      return Project_Nodes.Table (Node).Field2;\n+         In_Tree.Project_Nodes.Table (Node).Kind =\n+           N_String_Type_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_String_Type;\n \n    ---------------\n    -- Next_Term --\n    ---------------\n \n    function Next_Term\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Term);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_Term;\n \n    -------------------\n    -- Next_Variable --\n    -------------------\n \n    function Next_Variable\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Typed_Variable_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Variable_Declaration));\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Variable_Declaration));\n \n-      return Project_Nodes.Table (Node).Field3;\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Next_Variable;\n \n    -------------------------\n    -- Next_With_Clause_Of --\n    -------------------------\n \n    function Next_With_Clause_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_With_Clause);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_With_Clause_Of;\n \n    ---------------------------------\n    -- Non_Limited_Project_Node_Of --\n    ---------------------------------\n \n    function Non_Limited_Project_Node_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-           (Project_Nodes.Table (Node).Kind = N_With_Clause));\n-      return Project_Nodes.Table (Node).Field3;\n+           (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n+      return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Non_Limited_Project_Node_Of;\n \n    -------------------\n    -- Package_Id_Of --\n    -------------------\n \n-   function Package_Id_Of (Node : Project_Node_Id) return Package_Node_Id is\n+   function Package_Id_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Package_Node_Id\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n-      return Project_Nodes.Table (Node).Pkg_Id;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Pkg_Id;\n    end Package_Id_Of;\n \n    ---------------------\n    -- Package_Node_Of --\n    ---------------------\n \n    function Package_Node_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      return Project_Nodes.Table (Node).Field2;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Package_Node_Of;\n \n    ------------------\n    -- Path_Name_Of --\n    ------------------\n \n-   function Path_Name_Of (Node : Project_Node_Id) return Name_Id is\n+   function Path_Name_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n-             Project_Nodes.Table (Node).Kind = N_With_Clause));\n-      return Project_Nodes.Table (Node).Path_Name;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n+      return In_Tree.Project_Nodes.Table (Node).Path_Name;\n    end Path_Name_Of;\n \n    ----------------------------\n    -- Project_Declaration_Of --\n    ----------------------------\n \n    function Project_Declaration_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Field2;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Project_Declaration_Of;\n \n    -------------------------------------------\n    -- Project_File_Includes_Unkept_Comments --\n    -------------------------------------------\n \n    function Project_File_Includes_Unkept_Comments\n-     (Node : Project_Node_Id) return Boolean\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean\n    is\n-      Declaration : constant Project_Node_Id := Project_Declaration_Of (Node);\n+      Declaration : constant Project_Node_Id :=\n+                      Project_Declaration_Of (Node, In_Tree);\n    begin\n-      return Project_Nodes.Table (Declaration).Flag1;\n+      return In_Tree.Project_Nodes.Table (Declaration).Flag1;\n    end Project_File_Includes_Unkept_Comments;\n \n    ---------------------\n    -- Project_Node_Of --\n    ---------------------\n \n    function Project_Node_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-           (Project_Nodes.Table (Node).Kind = N_With_Clause\n+           (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n               or else\n-            Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n               or else\n-            Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Project_Node_Of;\n \n    -----------------------------------\n    -- Project_Of_Renamed_Package_Of --\n    -----------------------------------\n \n    function Project_Of_Renamed_Package_Of\n-     (Node : Project_Node_Id) return Project_Node_Id\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n-      return Project_Nodes.Table (Node).Field1;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n+      return In_Tree.Project_Nodes.Table (Node).Field1;\n    end Project_Of_Renamed_Package_Of;\n \n    --------------------------\n@@ -1354,8 +1454,9 @@ package body Prj.Tree is\n    -- Scan --\n    ----------\n \n-   procedure Scan is\n+   procedure Scan (In_Tree : Project_Node_Tree_Ref) is\n       Empty_Line : Boolean := False;\n+\n    begin\n       --  If there are comments, then they will not be kept. Set the flag and\n       --  clear the comments.\n@@ -1400,9 +1501,9 @@ package body Prj.Tree is\n                elsif End_Of_Line_Node /= Empty_Node then\n                   declare\n                      Zones : constant Project_Node_Id :=\n-                               Comment_Zones_Of (End_Of_Line_Node);\n+                               Comment_Zones_Of (End_Of_Line_Node, In_Tree);\n                   begin\n-                     Project_Nodes.Table (Zones).Value := Comment_Id;\n+                     In_Tree.Project_Nodes.Table (Zones).Value := Comment_Id;\n                   end;\n \n                --  Otherwise, this end of line node cannot be kept\n@@ -1424,11 +1525,15 @@ package body Prj.Tree is\n                  not Comments.Table (1).Follows_Empty_Line then\n                   if Previous_Line_Node /= Empty_Node then\n                      Add_Comments\n-                       (To => Previous_Line_Node, Where => After);\n+                       (To      => Previous_Line_Node,\n+                        Where   => After,\n+                        In_Tree => In_Tree);\n \n                   elsif Previous_End_Node /= Empty_Node then\n                      Add_Comments\n-                       (To => Previous_End_Node, Where => After_End);\n+                       (To      => Previous_End_Node,\n+                        Where   => After_End,\n+                        In_Tree => In_Tree);\n                   end if;\n                end if;\n \n@@ -1440,8 +1545,9 @@ package body Prj.Tree is\n                if Comments.Last > 0 and then Token = Tok_End then\n                   if Next_End_Nodes.Last > 0 then\n                      Add_Comments\n-                       (To => Next_End_Nodes.Table (Next_End_Nodes.Last),\n-                        Where => Before_End);\n+                       (To      => Next_End_Nodes.Table (Next_End_Nodes.Last),\n+                        Where   => Before_End,\n+                        In_Tree => In_Tree);\n \n                   else\n                      Unkept_Comments := True;\n@@ -1469,131 +1575,140 @@ package body Prj.Tree is\n    ------------------------------------\n \n    procedure Set_Associative_Array_Index_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      Project_Nodes.Table (Node).Value := To;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      In_Tree.Project_Nodes.Table (Node).Value := To;\n    end Set_Associative_Array_Index_Of;\n \n    --------------------------------\n    -- Set_Associative_Package_Of --\n    --------------------------------\n \n    procedure Set_Associative_Package_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n          (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Attribute_Declaration);\n-      Project_Nodes.Table (Node).Field3 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field3 := To;\n    end Set_Associative_Package_Of;\n \n    --------------------------------\n    -- Set_Associative_Project_Of --\n    --------------------------------\n \n    procedure Set_Associative_Project_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n-      Project_Nodes.Table (Node).Field2 := To;\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Attribute_Declaration));\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Associative_Project_Of;\n \n    --------------------------\n    -- Set_Case_Insensitive --\n    --------------------------\n \n    procedure Set_Case_Insensitive\n-     (Node : Project_Node_Id;\n-      To   : Boolean)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Boolean)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-           (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+           (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n-            Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      Project_Nodes.Table (Node).Flag1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      In_Tree.Project_Nodes.Table (Node).Flag1 := To;\n    end Set_Case_Insensitive;\n \n    ------------------------------------\n    -- Set_Case_Variable_Reference_Of --\n    ------------------------------------\n \n    procedure Set_Case_Variable_Reference_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Construction);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_Case_Variable_Reference_Of;\n \n    ---------------------------\n    -- Set_Current_Item_Node --\n    ---------------------------\n \n    procedure Set_Current_Item_Node\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_Current_Item_Node;\n \n    ----------------------\n    -- Set_Current_Term --\n    ----------------------\n \n    procedure Set_Current_Term\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Term);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_Current_Term;\n \n    ----------------------\n    -- Set_Directory_Of --\n    ----------------------\n \n    procedure Set_Directory_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Directory := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Directory := To;\n    end Set_Directory_Of;\n \n    ---------------------\n@@ -1610,224 +1725,242 @@ package body Prj.Tree is\n    ----------------------------\n \n    procedure Set_Expression_Kind_Of\n-     (Node : Project_Node_Id;\n-      To   : Variable_Kind)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Variable_Kind)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n            and then\n-             (Project_Nodes.Table (Node).Kind = N_Literal_String\n+             (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Variable_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind =\n+                N_Typed_Variable_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Package_Declaration\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Expression\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Expression\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Term\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Term\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+              In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                 or else\n-              Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      Project_Nodes.Table (Node).Expr_Kind := To;\n+              In_Tree.Project_Nodes.Table (Node).Kind =\n+                N_Attribute_Reference));\n+      In_Tree.Project_Nodes.Table (Node).Expr_Kind := To;\n    end Set_Expression_Kind_Of;\n \n    -----------------------\n    -- Set_Expression_Of --\n    -----------------------\n \n    procedure Set_Expression_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Attribute_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Typed_Variable_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Variable_Declaration));\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Variable_Declaration));\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_Expression_Of;\n \n    -------------------------------\n    -- Set_External_Reference_Of --\n    -------------------------------\n \n    procedure Set_External_Reference_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_External_Value);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_External_Reference_Of;\n \n    -----------------------------\n    -- Set_External_Default_Of --\n    -----------------------------\n \n    procedure Set_External_Default_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_External_Value);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_External_Default_Of;\n \n    ----------------------------\n    -- Set_First_Case_Item_Of --\n    ----------------------------\n \n    procedure Set_First_Case_Item_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Construction);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_First_Case_Item_Of;\n \n    -------------------------\n    -- Set_First_Choice_Of --\n    -------------------------\n \n    procedure Set_First_Choice_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Item);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_Choice_Of;\n \n    -----------------------------\n    -- Set_First_Comment_After --\n    -----------------------------\n \n    procedure Set_First_Comment_After\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n-      Zone : constant Project_Node_Id := Comment_Zones_Of (Node);\n+      Zone : constant Project_Node_Id := Comment_Zones_Of (Node, In_Tree);\n    begin\n-      Project_Nodes.Table (Zone).Field2 := To;\n+      In_Tree.Project_Nodes.Table (Zone).Field2 := To;\n    end Set_First_Comment_After;\n \n    ---------------------------------\n    -- Set_First_Comment_After_End --\n    ---------------------------------\n \n    procedure Set_First_Comment_After_End\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n-      Zone : constant Project_Node_Id := Comment_Zones_Of (Node);\n+      Zone : constant Project_Node_Id := Comment_Zones_Of (Node, In_Tree);\n    begin\n-      Project_Nodes.Table (Zone).Comments := To;\n+      In_Tree.Project_Nodes.Table (Zone).Comments := To;\n    end Set_First_Comment_After_End;\n \n    ------------------------------\n    -- Set_First_Comment_Before --\n    ------------------------------\n \n    procedure Set_First_Comment_Before\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n \n    is\n-      Zone : constant Project_Node_Id := Comment_Zones_Of (Node);\n+      Zone : constant Project_Node_Id := Comment_Zones_Of (Node, In_Tree);\n    begin\n-      Project_Nodes.Table (Zone).Field1 := To;\n+      In_Tree.Project_Nodes.Table (Zone).Field1 := To;\n    end Set_First_Comment_Before;\n \n    ----------------------------------\n    -- Set_First_Comment_Before_End --\n    ----------------------------------\n \n    procedure Set_First_Comment_Before_End\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n-      Zone : constant Project_Node_Id := Comment_Zones_Of (Node);\n+      Zone : constant Project_Node_Id := Comment_Zones_Of (Node, In_Tree);\n    begin\n-      Project_Nodes.Table (Zone).Field2 := To;\n+      In_Tree.Project_Nodes.Table (Zone).Field2 := To;\n    end Set_First_Comment_Before_End;\n \n    ------------------------\n    -- Set_Next_Case_Item --\n    ------------------------\n \n    procedure Set_Next_Case_Item\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Case_Item);\n-      Project_Nodes.Table (Node).Field3 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n+      In_Tree.Project_Nodes.Table (Node).Field3 := To;\n    end Set_Next_Case_Item;\n \n    ----------------------\n    -- Set_Next_Comment --\n    ----------------------\n \n    procedure Set_Next_Comment\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Comment);\n-      Project_Nodes.Table (Node).Comments := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n+      In_Tree.Project_Nodes.Table (Node).Comments := To;\n    end Set_Next_Comment;\n \n    -----------------------------------\n    -- Set_First_Declarative_Item_Of --\n    -----------------------------------\n \n    procedure Set_First_Declarative_Item_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project_Declaration\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Case_Item\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n \n-      if Project_Nodes.Table (Node).Kind = N_Project_Declaration then\n-         Project_Nodes.Table (Node).Field1 := To;\n+      if In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration then\n+         In_Tree.Project_Nodes.Table (Node).Field1 := To;\n       else\n-         Project_Nodes.Table (Node).Field2 := To;\n+         In_Tree.Project_Nodes.Table (Node).Field2 := To;\n       end if;\n    end Set_First_Declarative_Item_Of;\n \n@@ -1836,231 +1969,249 @@ package body Prj.Tree is\n    ----------------------------------\n \n    procedure Set_First_Expression_In_List\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Literal_String_List);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String_List);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_Expression_In_List;\n \n    ------------------------------\n    -- Set_First_Literal_String --\n    ------------------------------\n \n    procedure Set_First_Literal_String\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_String_Type_Declaration);\n-      Project_Nodes.Table (Node).Field1 := To;\n+         In_Tree.Project_Nodes.Table (Node).Kind =\n+           N_String_Type_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_Literal_String;\n \n    --------------------------\n    -- Set_First_Package_Of --\n    --------------------------\n \n    procedure Set_First_Package_Of\n-     (Node : Project_Node_Id;\n-      To   : Package_Declaration_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Package_Declaration_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Packages := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Packages := To;\n    end Set_First_Package_Of;\n \n    ------------------------------\n    -- Set_First_String_Type_Of --\n    ------------------------------\n \n    procedure Set_First_String_Type_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Field3 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Field3 := To;\n    end Set_First_String_Type_Of;\n \n    --------------------\n    -- Set_First_Term --\n    --------------------\n \n    procedure Set_First_Term\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Expression);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_Term;\n \n    ---------------------------\n    -- Set_First_Variable_Of --\n    ---------------------------\n \n    procedure Set_First_Variable_Of\n-     (Node : Project_Node_Id;\n-      To   : Variable_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Variable_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n-      Project_Nodes.Table (Node).Variables := To;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration));\n+      In_Tree.Project_Nodes.Table (Node).Variables := To;\n    end Set_First_Variable_Of;\n \n    ------------------------------\n    -- Set_First_With_Clause_Of --\n    ------------------------------\n \n    procedure Set_First_With_Clause_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_With_Clause_Of;\n \n    --------------------------\n    -- Set_Is_Extending_All --\n    --------------------------\n \n-   procedure Set_Is_Extending_All (Node  : Project_Node_Id) is\n+   procedure Set_Is_Extending_All\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n-             Project_Nodes.Table (Node).Kind = N_With_Clause));\n-      Project_Nodes.Table (Node).Flag2 := True;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n+      In_Tree.Project_Nodes.Table (Node).Flag2 := True;\n    end Set_Is_Extending_All;\n \n    -----------------\n    -- Set_Kind_Of --\n    -----------------\n \n    procedure Set_Kind_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Kind)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Kind)\n    is\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Project_Nodes.Table (Node).Kind := To;\n+      In_Tree.Project_Nodes.Table (Node).Kind := To;\n    end Set_Kind_Of;\n \n    ---------------------\n    -- Set_Location_Of --\n    ---------------------\n \n    procedure Set_Location_Of\n-     (Node : Project_Node_Id;\n-      To   : Source_Ptr)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Source_Ptr)\n    is\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Project_Nodes.Table (Node).Location := To;\n+      In_Tree.Project_Nodes.Table (Node).Location := To;\n    end Set_Location_Of;\n \n    -----------------------------\n    -- Set_Extended_Project_Of --\n    -----------------------------\n \n    procedure Set_Extended_Project_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Extended_Project_Of;\n \n    ----------------------------------\n    -- Set_Extended_Project_Path_Of --\n    ----------------------------------\n \n    procedure Set_Extended_Project_Path_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Value := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Value := To;\n    end Set_Extended_Project_Path_Of;\n \n    ------------------------------\n    -- Set_Extending_Project_Of --\n    ------------------------------\n \n    procedure Set_Extending_Project_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n-      Project_Nodes.Table (Node).Field3 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field3 := To;\n    end Set_Extending_Project_Of;\n \n    -----------------\n    -- Set_Name_Of --\n    -----------------\n \n    procedure Set_Name_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id)\n    is\n    begin\n       pragma Assert (Node /= Empty_Node);\n-      Project_Nodes.Table (Node).Name := To;\n+      In_Tree.Project_Nodes.Table (Node).Name := To;\n    end Set_Name_Of;\n \n    -------------------------------\n    -- Set_Next_Declarative_Item --\n    -------------------------------\n \n    procedure Set_Next_Declarative_Item\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Next_Declarative_Item;\n \n    -----------------------\n@@ -2078,165 +2229,178 @@ package body Prj.Tree is\n    ---------------------------------\n \n    procedure Set_Next_Expression_In_List\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Expression);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Next_Expression_In_List;\n \n    -----------------------------\n    -- Set_Next_Literal_String --\n    -----------------------------\n \n    procedure Set_Next_Literal_String\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Literal_String);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_Next_Literal_String;\n \n    ---------------------------------\n    -- Set_Next_Package_In_Project --\n    ---------------------------------\n \n    procedure Set_Next_Package_In_Project\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n-      Project_Nodes.Table (Node).Field3 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field3 := To;\n    end Set_Next_Package_In_Project;\n \n    --------------------------\n    -- Set_Next_String_Type --\n    --------------------------\n \n    procedure Set_Next_String_Type\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_String_Type_Declaration);\n-      Project_Nodes.Table (Node).Field2 := To;\n+         In_Tree.Project_Nodes.Table (Node).Kind =\n+           N_String_Type_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Next_String_Type;\n \n    -------------------\n    -- Set_Next_Term --\n    -------------------\n \n    procedure Set_Next_Term\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Term);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Next_Term;\n \n    -----------------------\n    -- Set_Next_Variable --\n    -----------------------\n \n    procedure Set_Next_Variable\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Typed_Variable_Declaration\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Variable_Declaration));\n-      Project_Nodes.Table (Node).Field3 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Variable_Declaration));\n+      In_Tree.Project_Nodes.Table (Node).Field3 := To;\n    end Set_Next_Variable;\n \n    -----------------------------\n    -- Set_Next_With_Clause_Of --\n    -----------------------------\n \n    procedure Set_Next_With_Clause_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_With_Clause);\n-      Project_Nodes.Table (Node).Field2 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Next_With_Clause_Of;\n \n    -----------------------\n    -- Set_Package_Id_Of --\n    -----------------------\n \n    procedure Set_Package_Id_Of\n-     (Node : Project_Node_Id;\n-      To   : Package_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Package_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n-      Project_Nodes.Table (Node).Pkg_Id := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Pkg_Id := To;\n    end Set_Package_Id_Of;\n \n    -------------------------\n    -- Set_Package_Node_Of --\n    -------------------------\n \n    procedure Set_Package_Node_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      Project_Nodes.Table (Node).Field2 := To;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Package_Node_Of;\n \n    ----------------------\n    -- Set_Path_Name_Of --\n    ----------------------\n \n    procedure Set_Path_Name_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Project\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n-             Project_Nodes.Table (Node).Kind = N_With_Clause));\n-      Project_Nodes.Table (Node).Path_Name := To;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n+      In_Tree.Project_Nodes.Table (Node).Path_Name := To;\n    end Set_Path_Name_Of;\n \n    ---------------------------\n@@ -2261,28 +2425,31 @@ package body Prj.Tree is\n    --------------------------------\n \n    procedure Set_Project_Declaration_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n          and then\n-           Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Field2 := To;\n+           In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Field2 := To;\n    end Set_Project_Declaration_Of;\n \n    -----------------------------------------------\n    -- Set_Project_File_Includes_Unkept_Comments --\n    -----------------------------------------------\n \n    procedure Set_Project_File_Includes_Unkept_Comments\n-     (Node : Project_Node_Id;\n-      To   : Boolean)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Boolean)\n    is\n-      Declaration : constant Project_Node_Id := Project_Declaration_Of (Node);\n+      Declaration : constant Project_Node_Id :=\n+                      Project_Declaration_Of (Node, In_Tree);\n    begin\n-      Project_Nodes.Table (Declaration).Flag1 := To;\n+      In_Tree.Project_Nodes.Table (Declaration).Flag1 := To;\n    end Set_Project_File_Includes_Unkept_Comments;\n \n    -------------------------\n@@ -2291,24 +2458,25 @@ package body Prj.Tree is\n \n    procedure Set_Project_Node_Of\n      (Node         : Project_Node_Id;\n+      In_Tree      : Project_Node_Tree_Ref;\n       To           : Project_Node_Id;\n       Limited_With : Boolean := False)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_With_Clause\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      Project_Nodes.Table (Node).Field1 := To;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n \n-      if Project_Nodes.Table (Node).Kind = N_With_Clause\n+      if In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n         and then not Limited_With\n       then\n-         Project_Nodes.Table (Node).Field3 := To;\n+         In_Tree.Project_Nodes.Table (Node).Field3 := To;\n       end if;\n    end Set_Project_Node_Of;\n \n@@ -2317,57 +2485,63 @@ package body Prj.Tree is\n    ---------------------------------------\n \n    procedure Set_Project_Of_Renamed_Package_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n-      Project_Nodes.Table (Node).Field1 := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n+      In_Tree.Project_Nodes.Table (Node).Field1 := To;\n    end Set_Project_Of_Renamed_Package_Of;\n \n    -------------------------\n    -- Set_Source_Index_Of --\n    -------------------------\n \n    procedure Set_Source_Index_Of\n-     (Node : Project_Node_Id;\n-      To   : Int)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Int)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-           (Project_Nodes.Table (Node).Kind = N_Literal_String\n+           (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n             or else\n-            Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n-      Project_Nodes.Table (Node).Src_Index := To;\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Attribute_Declaration));\n+      In_Tree.Project_Nodes.Table (Node).Src_Index := To;\n    end Set_Source_Index_Of;\n \n    ------------------------\n    -- Set_String_Type_Of --\n    ------------------------\n \n    procedure Set_String_Type_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Variable_Reference\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration)\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Typed_Variable_Declaration)\n           and then\n-            Project_Nodes.Table (To).Kind = N_String_Type_Declaration);\n+            In_Tree.Project_Nodes.Table (To).Kind = N_String_Type_Declaration);\n \n-      if Project_Nodes.Table (Node).Kind = N_Variable_Reference then\n-         Project_Nodes.Table (Node).Field3 := To;\n+      if In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference then\n+         In_Tree.Project_Nodes.Table (Node).Field3 := To;\n       else\n-         Project_Nodes.Table (Node).Field2 := To;\n+         In_Tree.Project_Nodes.Table (Node).Field2 := To;\n       end if;\n    end Set_String_Type_Of;\n \n@@ -2376,71 +2550,84 @@ package body Prj.Tree is\n    -------------------------\n \n    procedure Set_String_Value_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id)\n    is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_With_Clause\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Comment\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Comment\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Literal_String));\n-      Project_Nodes.Table (Node).Value := To;\n+             In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String));\n+      In_Tree.Project_Nodes.Table (Node).Value := To;\n    end Set_String_Value_Of;\n \n    ---------------------\n    -- Source_Index_Of --\n    ---------------------\n \n-   function Source_Index_Of (Node : Project_Node_Id) return Int is\n+   function Source_Index_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Int\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Literal_String\n+            (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n               or else\n-             Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n-      return Project_Nodes.Table (Node).Src_Index;\n+             In_Tree.Project_Nodes.Table (Node).Kind =\n+               N_Attribute_Declaration));\n+      return In_Tree.Project_Nodes.Table (Node).Src_Index;\n    end Source_Index_Of;\n \n    --------------------\n    -- String_Type_Of --\n    --------------------\n \n-   function String_Type_Of (Node : Project_Node_Id) return Project_Node_Id is\n+   function String_Type_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-            (Project_Nodes.Table (Node).Kind = N_Variable_Reference\n+           (In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Variable_Reference\n                or else\n-             Project_Nodes.Table (Node).Kind = N_Typed_Variable_Declaration));\n+            In_Tree.Project_Nodes.Table (Node).Kind =\n+              N_Typed_Variable_Declaration));\n \n-      if Project_Nodes.Table (Node).Kind = N_Variable_Reference then\n-         return Project_Nodes.Table (Node).Field3;\n+      if In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference then\n+         return In_Tree.Project_Nodes.Table (Node).Field3;\n       else\n-         return Project_Nodes.Table (Node).Field2;\n+         return In_Tree.Project_Nodes.Table (Node).Field2;\n       end if;\n    end String_Type_Of;\n \n    ---------------------\n    -- String_Value_Of --\n    ---------------------\n \n-   function String_Value_Of (Node : Project_Node_Id) return Name_Id is\n+   function String_Value_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n           and then\n-           (Project_Nodes.Table (Node).Kind = N_With_Clause\n+           (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n               or else\n-            Project_Nodes.Table (Node).Kind = N_Comment\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Comment\n                or else\n-            Project_Nodes.Table (Node).Kind = N_Literal_String));\n-      return Project_Nodes.Table (Node).Value;\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String));\n+      return In_Tree.Project_Nodes.Table (Node).Value;\n    end String_Value_Of;\n \n    --------------------\n@@ -2449,27 +2636,29 @@ package body Prj.Tree is\n \n    function Value_Is_Valid\n      (For_Typed_Variable : Project_Node_Id;\n+      In_Tree            : Project_Node_Tree_Ref;\n       Value              : Name_Id) return Boolean\n    is\n    begin\n       pragma Assert\n         (For_Typed_Variable /= Empty_Node\n           and then\n-           (Project_Nodes.Table (For_Typed_Variable).Kind =\n+           (In_Tree.Project_Nodes.Table (For_Typed_Variable).Kind =\n                                      N_Typed_Variable_Declaration));\n \n       declare\n          Current_String : Project_Node_Id :=\n                             First_Literal_String\n-                              (String_Type_Of (For_Typed_Variable));\n+                              (String_Type_Of (For_Typed_Variable, In_Tree),\n+                               In_Tree);\n \n       begin\n          while Current_String /= Empty_Node\n            and then\n-             String_Value_Of (Current_String) /= Value\n+             String_Value_Of (Current_String, In_Tree) /= Value\n          loop\n             Current_String :=\n-              Next_Literal_String (Current_String);\n+              Next_Literal_String (Current_String, In_Tree);\n          end loop;\n \n          return Current_String /= Empty_Node;"}, {"sha": "692b3b6097c85bb8b701ed2c4b12c8e7586bc42a", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 318, "deletions": 175, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,14 +26,19 @@\n \n --  This package defines the structure of the Project File tree\n \n-with GNAT.HTable;\n+with GNAT.Dynamic_HTables;\n+with GNAT.Dynamic_Tables;\n \n with Prj.Attr; use Prj.Attr;\n-with Table;    use Table;\n with Types;    use Types;\n \n package Prj.Tree is\n \n+   type Project_Node_Tree_Data;\n+   type Project_Node_Tree_Ref is access all Project_Node_Tree_Data;\n+   --  Type to designate a project node tree, so that several project node\n+   --  trees can coexist in memory.\n+\n    Project_Nodes_Initial   : constant := 1_000;\n    Project_Nodes_Increment : constant := 100;\n    --  Allocation parameters for initializing and extending number\n@@ -85,12 +90,13 @@ package Prj.Tree is\n    --  For the signification of the fields in each node of a\n    --  Project_Node_Kind, look at package Tree_Private_Part.\n \n-   procedure Initialize;\n+   procedure Initialize (Tree : Project_Node_Tree_Ref);\n    --  Initialize the Project File tree: empty the Project_Nodes table\n    --  and reset the Projects_Htable.\n \n    function Default_Project_Node\n-     (Of_Kind       : Project_Node_Kind;\n+     (In_Tree       : Project_Node_Tree_Ref;\n+      Of_Kind       : Project_Node_Kind;\n       And_Expr_Kind : Variable_Kind := Undefined) return Project_Node_Id;\n    --  Returns a Project_Node_Record with the specified Kind and\n    --  Expr_Kind; all the other components have default nil values.\n@@ -100,6 +106,7 @@ package Prj.Tree is\n \n    function Imported_Or_Extended_Project_Of\n      (Project   : Project_Node_Id;\n+      In_Tree   : Project_Node_Tree_Ref;\n       With_Name : Name_Id) return Project_Node_Id;\n    --  Return the node of a project imported or extended by project Project and\n    --  whose name is With_Name. Return Empty_Node if there is no such project.\n@@ -170,13 +177,16 @@ package Prj.Tree is\n       Table_Name           => \"Prj.Tree.Comments\");\n    --  A table to store the comments that may be stored is the tree\n \n-   procedure Scan;\n+   procedure Scan (In_Tree : Project_Node_Tree_Ref);\n    --  Scan the tokens and accumulate comments\n \n    type Comment_Location is\n      (Before, After, Before_End, After_End, End_Of_Line);\n \n-   procedure Add_Comments (To : Project_Node_Id; Where : Comment_Location);\n+   procedure Add_Comments\n+     (To      : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      Where   : Comment_Location);\n    --  Add comments to this node\n \n    ----------------------\n@@ -186,287 +196,360 @@ package Prj.Tree is\n    --  The following query functions are part of the abstract interface\n    --  of the Project File tree\n \n-   function Name_Of (Node : Project_Node_Id) return Name_Id;\n+   function Name_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    pragma Inline (Name_Of);\n    --  Valid for all non empty nodes. May return No_Name for nodes that have\n    --  no names.\n \n-   function Kind_Of (Node : Project_Node_Id) return Project_Node_Kind;\n+   function Kind_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Kind;\n    pragma Inline (Kind_Of);\n    --  Valid for all non empty nodes\n \n-   function Location_Of (Node : Project_Node_Id) return Source_Ptr;\n+   function Location_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Source_Ptr;\n    pragma Inline (Location_Of);\n    --  Valid for all non empty nodes\n \n    function First_Comment_After\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    --  Valid only for N_Comment_Zones nodes\n \n    function First_Comment_After_End\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    --  Valid only for N_Comment_Zones nodes\n \n    function First_Comment_Before\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    --  Valid only for N_Comment_Zones nodes\n \n    function First_Comment_Before_End\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    --  Valid only for N_Comment_Zones nodes\n \n-   function Next_Comment (Node : Project_Node_Id) return Project_Node_Id;\n+   function Next_Comment\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    --  Valid only for N_Comment nodes\n \n-   function End_Of_Line_Comment (Node : Project_Node_Id) return Name_Id;\n+   function End_Of_Line_Comment\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    --  Valid only for non empty nodes\n \n-   function Follows_Empty_Line (Node : Project_Node_Id) return Boolean;\n+   function Follows_Empty_Line\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean;\n    --  Valid only for N_Comment nodes\n \n-   function Is_Followed_By_Empty_Line (Node : Project_Node_Id) return Boolean;\n+   function Is_Followed_By_Empty_Line\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean;\n    --  Valid only for N_Comment nodes\n \n    function Project_File_Includes_Unkept_Comments\n-     (Node : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return Boolean;\n    --  Valid only for N_Project nodes\n \n-   function Directory_Of (Node : Project_Node_Id) return Name_Id;\n+   function Directory_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    pragma Inline (Directory_Of);\n    --  Only valid for N_Project nodes\n \n-   function Expression_Kind_Of (Node : Project_Node_Id) return Variable_Kind;\n+   function Expression_Kind_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Variable_Kind;\n    pragma Inline (Expression_Kind_Of);\n    --  Only valid for N_Literal_String, N_Attribute_Declaration,\n    --  N_Variable_Declaration, N_Typed_Variable_Declaration, N_Expression,\n    --  N_Term, N_Variable_Reference or N_Attribute_Reference nodes.\n \n-   function Is_Extending_All (Node  : Project_Node_Id) return Boolean;\n+   function Is_Extending_All\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean;\n    pragma Inline (Is_Extending_All);\n    --  Only valid for N_Project and N_With_Clause\n \n    function First_Variable_Of\n-     (Node : Project_Node_Id) return Variable_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Variable_Node_Id;\n    pragma Inline (First_Variable_Of);\n    --  Only valid for N_Project or N_Package_Declaration nodes\n \n    function First_Package_Of\n-     (Node : Project_Node_Id) return Package_Declaration_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Package_Declaration_Id;\n    pragma Inline (First_Package_Of);\n    --  Only valid for N_Project nodes\n \n-   function Package_Id_Of (Node  : Project_Node_Id) return Package_Node_Id;\n+   function Package_Id_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Package_Node_Id;\n    pragma Inline (Package_Id_Of);\n    --  Only valid for N_Package_Declaration nodes\n \n-   function Path_Name_Of (Node : Project_Node_Id) return Name_Id;\n+   function Path_Name_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    pragma Inline (Path_Name_Of);\n    --  Only valid for N_Project and N_With_Clause nodes\n \n-   function String_Value_Of (Node : Project_Node_Id) return Name_Id;\n+   function String_Value_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    pragma Inline (String_Value_Of);\n    --  Only valid for N_With_Clause, N_Literal_String nodes or N_Comment\n \n-   function Source_Index_Of (Node : Project_Node_Id) return Int;\n+   function Source_Index_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Int;\n    pragma Inline (Source_Index_Of);\n    --  Only valid for N_Literal_String and N_Attribute_Declaration nodes\n \n    function First_With_Clause_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_With_Clause_Of);\n    --  Only valid for N_Project nodes\n \n    function Project_Declaration_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Project_Declaration_Of);\n    --  Only valid for N_Project nodes\n \n    function Extending_Project_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Extending_Project_Of);\n    --  Only valid for N_Project_Declaration nodes\n \n    function First_String_Type_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_String_Type_Of);\n    --  Only valid for N_Project nodes\n \n    function Extended_Project_Path_Of\n-     (Node : Project_Node_Id) return Name_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    pragma Inline (Extended_Project_Path_Of);\n    --  Only valid for N_With_Clause nodes\n \n    function Project_Node_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Project_Node_Of);\n    --  Only valid for N_With_Clause, N_Variable_Reference and\n    --  N_Attribute_Reference nodes.\n \n    function Non_Limited_Project_Node_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Non_Limited_Project_Node_Of);\n    --  Only valid for N_With_Clause nodes. Returns Empty_Node for limited\n    --  imported project files, otherwise returns the same result as\n    --  Project_Node_Of.\n \n    function Next_With_Clause_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_With_Clause_Of);\n    --  Only valid for N_With_Clause nodes\n \n    function First_Declarative_Item_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_Declarative_Item_Of);\n    --  Only valid for N_With_Clause nodes\n \n    function Extended_Project_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Extended_Project_Of);\n    --  Only valid for N_Project_Declaration nodes\n \n    function Current_Item_Node\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Current_Item_Node);\n    --  Only valid for N_Declarative_Item nodes\n \n    function Next_Declarative_Item\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Declarative_Item);\n    --  Only valid for N_Declarative_Item node\n \n    function Project_Of_Renamed_Package_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Project_Of_Renamed_Package_Of);\n    --  Only valid for N_Package_Declaration nodes.\n    --  May return Empty_Node.\n \n    function Next_Package_In_Project\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Package_In_Project);\n    --  Only valid for N_Package_Declaration nodes\n \n    function First_Literal_String\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_Literal_String);\n    --  Only valid for N_String_Type_Declaration nodes\n \n    function Next_String_Type\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_String_Type);\n    --  Only valid for N_String_Type_Declaration nodes\n \n    function Next_Literal_String\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Literal_String);\n    --  Only valid for N_Literal_String nodes\n \n    function Expression_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Expression_Of);\n    --  Only valid for N_Attribute_Declaration, N_Typed_Variable_Declaration\n    --  or N_Variable_Declaration nodes\n \n    function Associative_Project_Of\n-     (Node  : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return  Project_Node_Id;\n    pragma Inline (Associative_Project_Of);\n    --  Only valid for N_Attribute_Declaration nodes\n \n    function Associative_Package_Of\n-     (Node  : Project_Node_Id)\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref)\n       return  Project_Node_Id;\n    pragma Inline (Associative_Package_Of);\n    --  Only valid for N_Attribute_Declaration nodes\n \n    function Value_Is_Valid\n      (For_Typed_Variable : Project_Node_Id;\n+      In_Tree            : Project_Node_Tree_Ref;\n       Value              : Name_Id) return Boolean;\n    pragma Inline (Value_Is_Valid);\n    --  Only valid for N_Typed_Variable_Declaration. Returns True if Value is\n    --  in the list of allowed strings for For_Typed_Variable. False otherwise.\n \n    function Associative_Array_Index_Of\n-     (Node : Project_Node_Id) return Name_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Name_Id;\n    pragma Inline (Associative_Array_Index_Of);\n    --  Only valid for N_Attribute_Declaration and N_Attribute_Reference.\n    --  Returns No_String for non associative array attributes.\n \n    function Next_Variable\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Variable);\n    --  Only valid for N_Typed_Variable_Declaration or N_Variable_Declaration\n    --  nodes.\n \n    function First_Term\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_Term);\n    --  Only valid for N_Expression nodes\n \n    function Next_Expression_In_List\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Expression_In_List);\n    --  Only valid for N_Expression nodes\n \n    function Current_Term\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Current_Term);\n    --  Only valid for N_Term nodes\n \n    function Next_Term\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Term);\n    --  Only valid for N_Term nodes\n \n    function First_Expression_In_List\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_Expression_In_List);\n    --  Only valid for N_Literal_String_List nodes\n \n    function Package_Node_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Package_Node_Of);\n    --  Only valid for N_Variable_Reference or N_Attribute_Reference nodes.\n    --  May return Empty_Node.\n \n    function String_Type_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (String_Type_Of);\n    --  Only valid for N_Variable_Reference or N_Typed_Variable_Declaration\n    --  nodes.\n \n    function External_Reference_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (External_Reference_Of);\n    --  Only valid for N_External_Value nodes\n \n    function External_Default_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (External_Default_Of);\n    --  Only valid for N_External_Value nodes\n \n    function Case_Variable_Reference_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Case_Variable_Reference_Of);\n    --  Only valid for N_Case_Construction nodes\n \n    function First_Case_Item_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_Case_Item_Of);\n    --  Only valid for N_Case_Construction nodes\n \n    function First_Choice_Of\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (First_Choice_Of);\n    --  Return the first choice in a N_Case_Item, or Empty_Node if\n    --  this is when others.\n \n    function Next_Case_Item\n-     (Node : Project_Node_Id) return Project_Node_Id;\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n    pragma Inline (Next_Case_Item);\n    --  Only valid for N_Case_Item nodes\n \n-   function Case_Insensitive (Node : Project_Node_Id) return Boolean;\n+   function Case_Insensitive\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean;\n    --  Only valid for N_Attribute_Declaration and N_Attribute_Reference nodes\n \n    --------------------\n@@ -480,266 +563,320 @@ package Prj.Tree is\n    --  nodes as the corresponding query function above.\n \n    procedure Set_Name_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id);\n    pragma Inline (Set_Name_Of);\n \n    procedure Set_Kind_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Kind);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Kind);\n    pragma Inline (Set_Kind_Of);\n \n    procedure Set_Location_Of\n-     (Node : Project_Node_Id;\n-      To   : Source_Ptr);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Source_Ptr);\n    pragma Inline (Set_Location_Of);\n \n    procedure Set_First_Comment_After\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Comment_After);\n \n    procedure Set_First_Comment_After_End\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Comment_After_End);\n \n    procedure Set_First_Comment_Before\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Comment_Before);\n \n    procedure Set_First_Comment_Before_End\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Comment_Before_End);\n \n    procedure Set_Next_Comment\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Comment);\n \n    procedure Set_Project_File_Includes_Unkept_Comments\n-     (Node : Project_Node_Id;\n-      To   : Boolean);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Boolean);\n \n    procedure Set_Directory_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id);\n    pragma Inline (Set_Directory_Of);\n \n    procedure Set_Expression_Kind_Of\n-     (Node : Project_Node_Id;\n-      To   : Variable_Kind);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Variable_Kind);\n    pragma Inline (Set_Expression_Kind_Of);\n \n-   procedure Set_Is_Extending_All (Node  : Project_Node_Id);\n+   procedure Set_Is_Extending_All\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref);\n    pragma Inline (Set_Is_Extending_All);\n \n    procedure Set_First_Variable_Of\n-     (Node : Project_Node_Id;\n-      To   : Variable_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Variable_Node_Id);\n    pragma Inline (Set_First_Variable_Of);\n \n    procedure Set_First_Package_Of\n-     (Node : Project_Node_Id;\n-      To   : Package_Declaration_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Package_Declaration_Id);\n    pragma Inline (Set_First_Package_Of);\n \n    procedure Set_Package_Id_Of\n-     (Node : Project_Node_Id;\n-      To   : Package_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Package_Node_Id);\n    pragma Inline (Set_Package_Id_Of);\n \n    procedure Set_Path_Name_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id);\n    pragma Inline (Set_Path_Name_Of);\n \n    procedure Set_String_Value_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id);\n    pragma Inline (Set_String_Value_Of);\n \n    procedure Set_First_With_Clause_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_With_Clause_Of);\n \n    procedure Set_Project_Declaration_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Project_Declaration_Of);\n \n    procedure Set_Extending_Project_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Extending_Project_Of);\n \n    procedure Set_First_String_Type_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_String_Type_Of);\n \n    procedure Set_Extended_Project_Path_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id);\n    pragma Inline (Set_Extended_Project_Path_Of);\n \n    procedure Set_Project_Node_Of\n      (Node         : Project_Node_Id;\n+      In_Tree      : Project_Node_Tree_Ref;\n       To           : Project_Node_Id;\n       Limited_With : Boolean := False);\n    pragma Inline (Set_Project_Node_Of);\n \n    procedure Set_Next_With_Clause_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_With_Clause_Of);\n \n    procedure Set_First_Declarative_Item_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Declarative_Item_Of);\n \n    procedure Set_Extended_Project_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Extended_Project_Of);\n \n    procedure Set_Current_Item_Node\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Current_Item_Node);\n \n    procedure Set_Next_Declarative_Item\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Declarative_Item);\n \n    procedure Set_Project_Of_Renamed_Package_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Project_Of_Renamed_Package_Of);\n \n    procedure Set_Next_Package_In_Project\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Package_In_Project);\n \n    procedure Set_First_Literal_String\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Literal_String);\n \n    procedure Set_Next_String_Type\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_String_Type);\n \n    procedure Set_Next_Literal_String\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Literal_String);\n \n    procedure Set_Expression_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Expression_Of);\n \n    procedure Set_Associative_Project_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Associative_Project_Of);\n \n    procedure Set_Associative_Package_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Associative_Package_Of);\n \n    procedure Set_Associative_Array_Index_Of\n-     (Node : Project_Node_Id;\n-      To   : Name_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Name_Id);\n    pragma Inline (Set_Associative_Array_Index_Of);\n \n    procedure Set_Next_Variable\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Variable);\n \n    procedure Set_First_Term\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Term);\n \n    procedure Set_Next_Expression_In_List\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Expression_In_List);\n \n    procedure Set_Current_Term\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Current_Term);\n \n    procedure Set_Next_Term\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Term);\n \n    procedure Set_First_Expression_In_List\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Expression_In_List);\n \n    procedure Set_Package_Node_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Package_Node_Of);\n \n    procedure Set_Source_Index_Of\n-     (Node : Project_Node_Id;\n-      To   : Int);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Int);\n    pragma Inline (Set_Source_Index_Of);\n \n    procedure Set_String_Type_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_String_Type_Of);\n \n    procedure Set_External_Reference_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_External_Reference_Of);\n \n    procedure Set_External_Default_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_External_Default_Of);\n \n    procedure Set_Case_Variable_Reference_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Case_Variable_Reference_Of);\n \n    procedure Set_First_Case_Item_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Case_Item_Of);\n \n    procedure Set_First_Choice_Of\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_First_Choice_Of);\n \n    procedure Set_Next_Case_Item\n-     (Node : Project_Node_Id;\n-      To   : Project_Node_Id);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n    pragma Inline (Set_Next_Case_Item);\n \n    procedure Set_Case_Insensitive\n-     (Node : Project_Node_Id;\n-      To   : Boolean);\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Boolean);\n \n    -------------------------------\n    -- Restricted Access Section --\n@@ -1028,13 +1165,13 @@ package Prj.Tree is\n       --    --  Flag2:     comment is followed by an empty line\n       --    --  Comments:  next comment\n \n-      package Project_Nodes is\n-         new Table.Table (Table_Component_Type => Project_Node_Record,\n-                          Table_Index_Type     => Project_Node_Id,\n-                          Table_Low_Bound      => First_Node_Id,\n-                          Table_Initial        => Project_Nodes_Initial,\n-                          Table_Increment      => Project_Nodes_Increment,\n-                          Table_Name           => \"Project_Nodes\");\n+      package Project_Node_Table is\n+        new GNAT.Dynamic_Tables\n+          (Table_Component_Type => Project_Node_Record,\n+           Table_Index_Type     => Project_Node_Id,\n+           Table_Low_Bound      => First_Node_Id,\n+           Table_Initial        => Project_Nodes_Initial,\n+           Table_Increment      => Project_Nodes_Increment);\n       --  This table contains the syntactic tree of project data\n       --  from project files.\n \n@@ -1058,7 +1195,7 @@ package Prj.Tree is\n          Canonical_Path => No_Name,\n          Extended       => True);\n \n-      package Projects_Htable is new GNAT.HTable.Simple_HTable\n+      package Projects_Htable is new GNAT.Dynamic_HTables.Simple_HTable\n         (Header_Num => Header_Num,\n          Element    => Project_Name_And_Node,\n          No_Element => No_Project_Name_And_Node,\n@@ -1073,6 +1210,12 @@ package Prj.Tree is\n \n    end Tree_Private_Part;\n \n+   type Project_Node_Tree_Data is record\n+      Project_Nodes : Tree_Private_Part.Project_Node_Table.Instance;\n+      Projects_HT   : Tree_Private_Part.Projects_Htable.Instance;\n+   end record;\n+   --  The data for a project node tree\n+\n private\n    type Comment_Array is array (Positive range <>) of Comment_Data;\n    type Comments_Ptr is access Comment_Array;"}, {"sha": "054aa15bdf107ee033663c95f8b351013597479d", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,42 +75,46 @@ package body Prj.Util is\n \n    function Executable_Of\n      (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n       Main     : Name_Id;\n       Index    : Int;\n       Ada_Main : Boolean := True) return Name_Id\n    is\n       pragma Assert (Project /= No_Project);\n \n       The_Packages : constant Package_Id :=\n-                       Projects.Table (Project).Decl.Packages;\n+                       In_Tree.Projects.Table (Project).Decl.Packages;\n \n       Builder_Package : constant Prj.Package_Id :=\n                           Prj.Util.Value_Of\n                             (Name        => Name_Builder,\n-                             In_Packages => The_Packages);\n+                             In_Packages => The_Packages,\n+                             In_Tree     => In_Tree);\n \n       Executable : Variable_Value :=\n                      Prj.Util.Value_Of\n                        (Name                    => Main,\n                         Index                   => Index,\n                         Attribute_Or_Array_Name => Name_Executable,\n-                        In_Package              => Builder_Package);\n+                        In_Package              => Builder_Package,\n+                        In_Tree                 => In_Tree);\n \n       Executable_Suffix : constant Variable_Value :=\n                             Prj.Util.Value_Of\n                               (Name                    => Main,\n                                Index                   => 0,\n                                Attribute_Or_Array_Name =>\n                                  Name_Executable_Suffix,\n-                               In_Package              => Builder_Package);\n+                               In_Package              => Builder_Package,\n+                               In_Tree                 => In_Tree);\n \n       Body_Append : constant String := Get_Name_String\n-                                          (Projects.Table\n+                                          (In_Tree.Projects.Table\n                                             (Project).\n                                               Naming.Ada_Body_Suffix);\n \n       Spec_Append : constant String := Get_Name_String\n-                                          (Projects.Table\n+                                          (In_Tree.Projects.Table\n                                             (Project).\n                                                Naming.Ada_Spec_Suffix);\n \n@@ -128,7 +132,7 @@ package body Prj.Util is\n                Last : Positive := Name_Len;\n \n                Naming : constant Naming_Data :=\n-                          Projects.Table (Project).Naming;\n+                          In_Tree.Projects.Table (Project).Naming;\n \n                Spec_Suffix : constant String :=\n                                Get_Name_String (Naming.Ada_Spec_Suffix);\n@@ -163,7 +167,8 @@ package body Prj.Util is\n                       (Name                    => Name_Find,\n                        Index                   => 0,\n                        Attribute_Or_Array_Name => Name_Executable,\n-                       In_Package              => Builder_Package);\n+                       In_Package              => Builder_Package,\n+                       In_Tree                 => In_Tree);\n                end if;\n             end;\n          end if;\n@@ -400,7 +405,8 @@ package body Prj.Util is\n \n    function Value_Of\n      (Index     : Name_Id;\n-      In_Array  : Array_Element_Id) return Name_Id\n+      In_Array  : Array_Element_Id;\n+      In_Tree   : Project_Tree_Ref) return Name_Id\n    is\n       Current    : Array_Element_Id := In_Array;\n       Element    : Array_Element;\n@@ -411,7 +417,7 @@ package body Prj.Util is\n          return No_Name;\n       end if;\n \n-      Element := Array_Elements.Table (Current);\n+      Element := In_Tree.Array_Elements.Table (Current);\n \n       if not Element.Index_Case_Sensitive then\n          Get_Name_String (Index);\n@@ -420,7 +426,7 @@ package body Prj.Util is\n       end if;\n \n       while Current /= No_Array_Element loop\n-         Element := Array_Elements.Table (Current);\n+         Element := In_Tree.Array_Elements.Table (Current);\n \n          if Real_Index = Element.Index then\n             exit when Element.Value.Kind /= Single;\n@@ -437,7 +443,8 @@ package body Prj.Util is\n    function Value_Of\n      (Index     : Name_Id;\n       Src_Index : Int := 0;\n-      In_Array  : Array_Element_Id) return Variable_Value\n+      In_Array  : Array_Element_Id;\n+      In_Tree   : Project_Tree_Ref) return Variable_Value\n    is\n       Current : Array_Element_Id := In_Array;\n       Element : Array_Element;\n@@ -448,7 +455,7 @@ package body Prj.Util is\n          return Nil_Variable_Value;\n       end if;\n \n-      Element := Array_Elements.Table (Current);\n+      Element := In_Tree.Array_Elements.Table (Current);\n \n       if not Element.Index_Case_Sensitive then\n          Get_Name_String (Index);\n@@ -457,7 +464,7 @@ package body Prj.Util is\n       end if;\n \n       while Current /= No_Array_Element loop\n-         Element := Array_Elements.Table (Current);\n+         Element := In_Tree.Array_Elements.Table (Current);\n \n          if Real_Index = Element.Index and then\n            Src_Index = Element.Src_Index\n@@ -475,7 +482,8 @@ package body Prj.Util is\n      (Name                    : Name_Id;\n       Index                   : Int := 0;\n       Attribute_Or_Array_Name : Name_Id;\n-      In_Package              : Package_Id) return Variable_Value\n+      In_Package              : Package_Id;\n+      In_Tree                 : Project_Tree_Ref) return Variable_Value\n    is\n       The_Array     : Array_Element_Id;\n       The_Attribute : Variable_Value := Nil_Variable_Value;\n@@ -488,20 +496,24 @@ package body Prj.Util is\n          The_Array :=\n            Value_Of\n              (Name      => Attribute_Or_Array_Name,\n-              In_Arrays => Packages.Table (In_Package).Decl.Arrays);\n+              In_Arrays => In_Tree.Packages.Table (In_Package).Decl.Arrays,\n+              In_Tree   => In_Tree);\n          The_Attribute :=\n            Value_Of\n              (Index     => Name,\n               Src_Index => Index,\n-              In_Array  => The_Array);\n+              In_Array  => The_Array,\n+              In_Tree   => In_Tree);\n \n          --  If there is no array element, look for a variable\n \n          if The_Attribute = Nil_Variable_Value then\n             The_Attribute :=\n               Value_Of\n                 (Variable_Name => Attribute_Or_Array_Name,\n-                 In_Variables  => Packages.Table (In_Package).Decl.Attributes);\n+                 In_Variables  => In_Tree.Packages.Table\n+                                    (In_Package).Decl.Attributes,\n+                 In_Tree       => In_Tree);\n          end if;\n       end if;\n \n@@ -511,16 +523,18 @@ package body Prj.Util is\n    function Value_Of\n      (Index     : Name_Id;\n       In_Array  : Name_Id;\n-      In_Arrays : Array_Id) return Name_Id\n+      In_Arrays : Array_Id;\n+      In_Tree   : Project_Tree_Ref) return Name_Id\n    is\n       Current : Array_Id := In_Arrays;\n       The_Array : Array_Data;\n \n    begin\n       while Current /= No_Array loop\n-         The_Array := Arrays.Table (Current);\n+         The_Array := In_Tree.Arrays.Table (Current);\n          if The_Array.Name = In_Array then\n-            return Value_Of (Index, In_Array => The_Array.Value);\n+            return Value_Of\n+              (Index, In_Array => The_Array.Value, In_Tree => In_Tree);\n          else\n             Current := The_Array.Next;\n          end if;\n@@ -531,14 +545,15 @@ package body Prj.Util is\n \n    function Value_Of\n      (Name      : Name_Id;\n-      In_Arrays : Array_Id) return Array_Element_Id\n+      In_Arrays : Array_Id;\n+      In_Tree   : Project_Tree_Ref) return Array_Element_Id\n    is\n       Current    : Array_Id := In_Arrays;\n       The_Array  : Array_Data;\n \n    begin\n       while Current /= No_Array loop\n-         The_Array := Arrays.Table (Current);\n+         The_Array := In_Tree.Arrays.Table (Current);\n \n          if The_Array.Name = Name then\n             return The_Array.Value;\n@@ -552,14 +567,15 @@ package body Prj.Util is\n \n    function Value_Of\n      (Name        : Name_Id;\n-      In_Packages : Package_Id) return Package_Id\n+      In_Packages : Package_Id;\n+      In_Tree     : Project_Tree_Ref) return Package_Id\n    is\n       Current : Package_Id := In_Packages;\n       The_Package : Package_Element;\n \n    begin\n       while Current /= No_Package loop\n-         The_Package := Packages.Table (Current);\n+         The_Package := In_Tree.Packages.Table (Current);\n          exit when The_Package.Name /= No_Name\n            and then The_Package.Name = Name;\n          Current := The_Package.Next;\n@@ -570,14 +586,16 @@ package body Prj.Util is\n \n    function Value_Of\n      (Variable_Name : Name_Id;\n-      In_Variables  : Variable_Id) return Variable_Value\n+      In_Variables  : Variable_Id;\n+      In_Tree       : Project_Tree_Ref) return Variable_Value\n    is\n       Current      : Variable_Id := In_Variables;\n       The_Variable : Variable;\n \n    begin\n       while Current /= No_Variable loop\n-         The_Variable := Variable_Elements.Table (Current);\n+         The_Variable :=\n+           In_Tree.Variable_Elements.Table (Current);\n \n          if Variable_Name = The_Variable.Name then\n             return The_Variable.Value;"}, {"sha": "894acd82f07080ac2cfb4f06ce66768139e46cea", "filename": "gcc/ada/prj-util.ads", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,7 @@ package Prj.Util is\n \n    function Executable_Of\n      (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n       Main     : Name_Id;\n       Index    : Int;\n       Ada_Main : Boolean := True) return Name_Id;\n@@ -51,7 +52,8 @@ package Prj.Util is\n \n    function Value_Of\n      (Index    : Name_Id;\n-      In_Array : Array_Element_Id) return Name_Id;\n+      In_Array : Array_Element_Id;\n+      In_Tree  : Project_Tree_Ref) return Name_Id;\n    --  Get a single string array component. Returns No_Name if there is no\n    --  component Index, if In_Array is null, or if the component is a String\n    --  list. Depending on the attribute (only attributes may be associative\n@@ -62,7 +64,8 @@ package Prj.Util is\n    function Value_Of\n      (Index     : Name_Id;\n       Src_Index : Int := 0;\n-      In_Array  : Array_Element_Id) return Variable_Value;\n+      In_Array  : Array_Element_Id;\n+      In_Tree   : Project_Tree_Ref) return Variable_Value;\n    --  Get a string array component (single String or String list).\n    --  Returns Nil_Variable_Value if there is no component Index\n    --  or if In_Array is null.\n@@ -76,7 +79,8 @@ package Prj.Util is\n      (Name                    : Name_Id;\n       Index                   : Int := 0;\n       Attribute_Or_Array_Name : Name_Id;\n-      In_Package              : Package_Id) return Variable_Value;\n+      In_Package              : Package_Id;\n+      In_Tree                 : Project_Tree_Ref) return Variable_Value;\n    --  In a specific package,\n    --   - if there exists an array Attribute_Or_Array_Name with an index\n    --     Name, returns the corresponding component (depending on the\n@@ -90,28 +94,32 @@ package Prj.Util is\n    function Value_Of\n      (Index     : Name_Id;\n       In_Array  : Name_Id;\n-      In_Arrays : Array_Id) return Name_Id;\n+      In_Arrays : Array_Id;\n+      In_Tree   : Project_Tree_Ref) return Name_Id;\n    --  Get a string array component in an array of an array list.\n    --  Returns No_Name if there is no component Index, if In_Arrays is null, if\n    --  In_Array is not found in In_Arrays or if the component is a String list.\n \n    function Value_Of\n      (Name      : Name_Id;\n-      In_Arrays : Array_Id) return Array_Element_Id;\n+      In_Arrays : Array_Id;\n+      In_Tree   : Project_Tree_Ref) return Array_Element_Id;\n    --  Returns a specified array in an array list. Returns No_Array_Element\n    --  if In_Arrays is null or if Name is not the name of an array in\n    --  In_Arrays. The caller must ensure that Name is in lower case.\n \n    function Value_Of\n      (Name        : Name_Id;\n-      In_Packages : Package_Id) return Package_Id;\n+      In_Packages : Package_Id;\n+      In_Tree     : Project_Tree_Ref) return Package_Id;\n    --  Returns a specified package in a package list. Returns No_Package\n    --  if In_Packages is null or if Name is not the name of a package in\n    --  Package_List. The caller must ensure that Name is in lower case.\n \n    function Value_Of\n      (Variable_Name : Name_Id;\n-      In_Variables  : Variable_Id) return Variable_Value;\n+      In_Variables  : Variable_Id;\n+      In_Tree       : Project_Tree_Ref) return Variable_Value;\n    --  Returns a specified variable in a variable list. Returns null if\n    --  In_Variables is null or if Variable_Name is not the name of a\n    --  variable in In_Variables. Caller must ensure that Name is lower case."}, {"sha": "8158de78dc50f8a51a86cec6e44f4f7c9b844948", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 192, "deletions": 92, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2005 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,6 @@ with Namet;    use Namet;\n with Output;   use Output;\n with Osint;    use Osint;\n with Prj.Attr;\n-with Prj.Com;\n with Prj.Env;\n with Prj.Err;  use Prj.Err;\n with Scans;    use Scans;\n@@ -42,10 +41,18 @@ with GNAT.OS_Lib;    use GNAT.OS_Lib;\n \n package body Prj is\n \n+   Initial_Buffer_Size : constant := 100;\n+   --  Initial size for extensible buffer used in Add_To_Buffer\n+\n    The_Empty_String : Name_Id;\n \n    Name_C_Plus_Plus : Name_Id;\n \n+   Default_Ada_Spec_Suffix_Id : Name_Id;\n+   Default_Ada_Body_Suffix_Id : Name_Id;\n+   Slash_Id                   : Name_Id;\n+   --  Initialized in Prj.Initialized, then never modified\n+\n    subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n \n    The_Casing_Images : constant array (Known_Casing) of String_Access :=\n@@ -77,7 +84,7 @@ package body Prj is\n       Specification_Exceptions  => No_Array_Element,\n       Implementation_Exceptions => No_Array_Element);\n \n-   Project_Empty : constant Project_Data :=\n+   Project_Empty : Project_Data :=\n      (Externally_Built               => False,\n       Languages                      => No_Languages,\n       Supp_Languages                 => No_Supp_Language_Index,\n@@ -157,26 +164,53 @@ package body Prj is\n    -- Add_To_Buffer --\n    -------------------\n \n-   procedure Add_To_Buffer (S : String) is\n+   procedure Add_To_Buffer\n+     (S    : String;\n+      To   : in out String_Access;\n+      Last : in out Natural)\n+   is\n    begin\n+      if To = null then\n+         To := new String (1 .. Initial_Buffer_Size);\n+         Last := 0;\n+      end if;\n+\n       --  If Buffer is too small, double its size\n \n-      if Buffer_Last + S'Length > Buffer'Last then\n+      while Last + S'Length > To'Last loop\n          declare\n             New_Buffer : constant  String_Access :=\n-                           new String (1 .. 2 * Buffer'Last);\n+                           new String (1 .. 2 * Last);\n \n          begin\n-            New_Buffer (1 .. Buffer_Last) := Buffer (1 .. Buffer_Last);\n-            Free (Buffer);\n-            Buffer := New_Buffer;\n+            New_Buffer (1 .. Last) := To (1 .. Last);\n+            Free (To);\n+            To := New_Buffer;\n          end;\n-      end if;\n+      end loop;\n \n-      Buffer (Buffer_Last + 1 .. Buffer_Last + S'Length) := S;\n-      Buffer_Last := Buffer_Last + S'Length;\n+      To (Last + 1 .. Last + S'Length) := S;\n+      Last := Last + S'Length;\n    end Add_To_Buffer;\n \n+   -----------------------------\n+   -- Default_Ada_Body_Suffix --\n+   -----------------------------\n+\n+   function Default_Ada_Body_Suffix return Name_Id is\n+   begin\n+      return Default_Ada_Body_Suffix_Id;\n+   end Default_Ada_Body_Suffix;\n+\n+   -----------------------------\n+   -- Default_Ada_Spec_Suffix --\n+   -----------------------------\n+\n+   function Default_Ada_Spec_Suffix return Name_Id is\n+   begin\n+      return Default_Ada_Spec_Suffix_Id;\n+   end Default_Ada_Spec_Suffix;\n+\n    ---------------------------\n    -- Display_Language_Name --\n    ---------------------------\n@@ -192,10 +226,12 @@ package body Prj is\n    -- Empty_Project --\n    -------------------\n \n-   function Empty_Project return Project_Data is\n+   function Empty_Project (Tree : Project_Tree_Ref)  return Project_Data is\n+      Value : Project_Data := Project_Empty;\n    begin\n-      Prj.Initialize;\n-      return Project_Empty;\n+      Prj.Initialize (Tree => No_Project_Tree);\n+      Value.Naming := Tree.Private_Part.Default_Naming;\n+      return Value;\n    end Empty_Project;\n \n    ------------------\n@@ -224,41 +260,45 @@ package body Prj is\n \n    procedure For_Every_Project_Imported\n      (By         : Project_Id;\n+      In_Tree    : Project_Tree_Ref;\n       With_State : in out State)\n    is\n \n-      procedure Check (Project : Project_Id);\n+      procedure Recursive_Check (Project : Project_Id);\n       --  Check if a project has already been seen. If not seen, mark it as\n       --  Seen, Call Action, and check all its imported projects.\n \n-      -----------\n-      -- Check --\n-      -----------\n+      ---------------------\n+      -- Recursive_Check --\n+      ---------------------\n \n-      procedure Check (Project : Project_Id) is\n+      procedure Recursive_Check (Project : Project_Id) is\n          List : Project_List;\n \n       begin\n-         if not Projects.Table (Project).Seen then\n-            Projects.Table (Project).Seen := True;\n+         if not In_Tree.Projects.Table (Project).Seen then\n+            In_Tree.Projects.Table (Project).Seen := True;\n             Action (Project, With_State);\n \n-            List := Projects.Table (Project).Imported_Projects;\n+            List :=\n+              In_Tree.Projects.Table (Project).Imported_Projects;\n             while List /= Empty_Project_List loop\n-               Check (Project_Lists.Table (List).Project);\n-               List := Project_Lists.Table (List).Next;\n+               Recursive_Check (In_Tree.Project_Lists.Table (List).Project);\n+               List := In_Tree.Project_Lists.Table (List).Next;\n             end loop;\n          end if;\n-      end Check;\n+      end Recursive_Check;\n \n-   --  Start of procecessing for For_Every_Project_Imported\n+   --  Start of processing for For_Every_Project_Imported\n \n    begin\n-      for Project in Projects.First .. Projects.Last loop\n-         Projects.Table (Project).Seen := False;\n+      for Project in Project_Table.First ..\n+                     Project_Table.Last (In_Tree.Projects)\n+      loop\n+         In_Tree.Projects.Table (Project).Seen := False;\n       end loop;\n \n-      Check (Project => By);\n+      Recursive_Check (Project => By);\n    end For_Every_Project_Imported;\n \n    ----------\n@@ -283,7 +323,7 @@ package body Prj is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize is\n+   procedure Initialize (Tree : Project_Tree_Ref) is\n    begin\n       if not Initialized then\n          Initialized := True;\n@@ -293,24 +333,21 @@ package body Prj is\n          Empty_Name := The_Empty_String;\n          Name_Len := 4;\n          Name_Buffer (1 .. 4) := \".ads\";\n-         Default_Ada_Spec_Suffix := Name_Find;\n+         Default_Ada_Spec_Suffix_Id := Name_Find;\n          Name_Len := 4;\n          Name_Buffer (1 .. 4) := \".adb\";\n-         Default_Ada_Body_Suffix := Name_Find;\n+         Default_Ada_Body_Suffix_Id := Name_Find;\n          Name_Len := 1;\n          Name_Buffer (1) := '/';\n-         Slash := Name_Find;\n+         Slash_Id := Name_Find;\n          Name_Len := 3;\n          Name_Buffer (1 .. 3) := \"c++\";\n          Name_C_Plus_Plus := Name_Find;\n \n          Std_Naming_Data.Ada_Spec_Suffix := Default_Ada_Spec_Suffix;\n          Std_Naming_Data.Ada_Body_Suffix := Default_Ada_Body_Suffix;\n-         Std_Naming_Data.Separate_Suffix     := Default_Ada_Body_Suffix;\n-         Register_Default_Naming_Scheme\n-           (Language            => Name_Ada,\n-            Default_Spec_Suffix => Default_Ada_Spec_Suffix,\n-            Default_Body_Suffix => Default_Ada_Body_Suffix);\n+         Std_Naming_Data.Separate_Suffix := Default_Ada_Body_Suffix;\n+         Project_Empty.Naming := Std_Naming_Data;\n          Prj.Env.Initialize;\n          Prj.Attr.Initialize;\n          Set_Name_Table_Byte (Name_Project,  Token_Type'Pos (Tok_Project));\n@@ -324,6 +361,10 @@ package body Prj is\n          Add_Language_Name (Name_C);\n          Add_Language_Name (Name_C_Plus_Plus);\n       end if;\n+\n+      if Tree /= No_Project_Tree then\n+         Reset (Tree);\n+      end if;\n    end Initialize;\n \n    ----------------\n@@ -332,7 +373,8 @@ package body Prj is\n \n    function Is_Present\n      (Language   : Language_Index;\n-      In_Project : Project_Data) return Boolean\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return Boolean\n    is\n    begin\n       case Language is\n@@ -349,7 +391,7 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := Present_Languages.Table (Supp_Index);\n+                  Supp := In_Tree.Present_Languages.Table (Supp_Index);\n \n                   if Supp.Index = Language then\n                      return Supp.Present;\n@@ -369,7 +411,8 @@ package body Prj is\n \n    function Language_Processing_Data_Of\n      (Language   : Language_Index;\n-      In_Project : Project_Data) return Language_Processing_Data\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return Language_Processing_Data\n    is\n    begin\n       case Language is\n@@ -387,7 +430,7 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := Supp_Languages.Table (Supp_Index);\n+                  Supp := In_Tree.Supp_Languages.Table (Supp_Index);\n \n                   if Supp.Index = Language then\n                      return Supp.Data;\n@@ -408,7 +451,8 @@ package body Prj is\n    procedure Register_Default_Naming_Scheme\n      (Language            : Name_Id;\n       Default_Spec_Suffix : Name_Id;\n-      Default_Body_Suffix : Name_Id)\n+      Default_Body_Suffix : Name_Id;\n+      In_Tree             : Project_Tree_Ref)\n    is\n       Lang : Name_Id;\n       Suffix : Array_Element_Id;\n@@ -422,19 +466,19 @@ package body Prj is\n       Name_Buffer (1 .. Name_Len) := To_Lower (Name_Buffer (1 .. Name_Len));\n       Lang := Name_Find;\n \n-      Suffix := Std_Naming_Data.Spec_Suffix;\n+      Suffix := In_Tree.Private_Part.Default_Naming.Spec_Suffix;\n       Found := False;\n \n       --  Look for an element of the spec sufix array indexed by the language\n       --  name. If one is found, put the default value.\n \n       while Suffix /= No_Array_Element and then not Found loop\n-         Element := Array_Elements.Table (Suffix);\n+         Element := In_Tree.Array_Elements.Table (Suffix);\n \n          if Element.Index = Lang then\n             Found := True;\n             Element.Value.Value := Default_Spec_Suffix;\n-            Array_Elements.Table (Suffix) := Element;\n+            In_Tree.Array_Elements.Table (Suffix) := Element;\n \n          else\n             Suffix := Element.Next;\n@@ -454,25 +498,28 @@ package body Prj is\n                       Default  => False,\n                       Value    => Default_Spec_Suffix,\n                       Index    => 0),\n-            Next  => Std_Naming_Data.Spec_Suffix);\n-         Array_Elements.Increment_Last;\n-         Array_Elements.Table (Array_Elements.Last) := Element;\n-         Std_Naming_Data.Spec_Suffix := Array_Elements.Last;\n+            Next  => In_Tree.Private_Part.Default_Naming.Spec_Suffix);\n+         Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n+         In_Tree.Array_Elements.Table\n+           (Array_Element_Table.Last (In_Tree.Array_Elements)) :=\n+            Element;\n+         In_Tree.Private_Part.Default_Naming.Spec_Suffix :=\n+           Array_Element_Table.Last (In_Tree.Array_Elements);\n       end if;\n \n-      Suffix := Std_Naming_Data.Body_Suffix;\n+      Suffix := In_Tree.Private_Part.Default_Naming.Body_Suffix;\n       Found := False;\n \n       --  Look for an element of the body sufix array indexed by the language\n       --  name. If one is found, put the default value.\n \n       while Suffix /= No_Array_Element and then not Found loop\n-         Element := Array_Elements.Table (Suffix);\n+         Element := In_Tree.Array_Elements.Table (Suffix);\n \n          if Element.Index = Lang then\n             Found := True;\n             Element.Value.Value := Default_Body_Suffix;\n-            Array_Elements.Table (Suffix) := Element;\n+            In_Tree.Array_Elements.Table (Suffix) := Element;\n \n          else\n             Suffix := Element.Next;\n@@ -492,28 +539,49 @@ package body Prj is\n                       Default  => False,\n                       Value    => Default_Body_Suffix,\n                       Index    => 0),\n-            Next  => Std_Naming_Data.Body_Suffix);\n-         Array_Elements.Increment_Last;\n-         Array_Elements.Table (Array_Elements.Last) := Element;\n-         Std_Naming_Data.Body_Suffix := Array_Elements.Last;\n+            Next  => In_Tree.Private_Part.Default_Naming.Body_Suffix);\n+         Array_Element_Table.Increment_Last\n+           (In_Tree.Array_Elements);\n+         In_Tree.Array_Elements.Table\n+           (Array_Element_Table.Last (In_Tree.Array_Elements))\n+             := Element;\n+         In_Tree.Private_Part.Default_Naming.Body_Suffix :=\n+           Array_Element_Table.Last (In_Tree.Array_Elements);\n       end if;\n    end Register_Default_Naming_Scheme;\n \n    -----------\n    -- Reset --\n    -----------\n \n-   procedure Reset is\n+   procedure Reset (Tree : Project_Tree_Ref) is\n    begin\n-      Projects.Init;\n-      Project_Lists.Init;\n-      Packages.Init;\n-      Arrays.Init;\n-      Variable_Elements.Init;\n-      String_Elements.Init;\n-      Prj.Com.Units.Init;\n-      Prj.Com.Units_Htable.Reset;\n-      Prj.Com.Files_Htable.Reset;\n+      Prj.Env.Initialize;\n+      Present_Language_Table.Init (Tree.Present_Languages);\n+      Supp_Suffix_Table.Init      (Tree.Supp_Suffixes);\n+      Name_List_Table.Init        (Tree.Name_Lists);\n+      Supp_Language_Table.Init    (Tree.Supp_Languages);\n+      Other_Source_Table.Init     (Tree.Other_Sources);\n+      String_Element_Table.Init   (Tree.String_Elements);\n+      Variable_Element_Table.Init (Tree.Variable_Elements);\n+      Array_Element_Table.Init    (Tree.Array_Elements);\n+      Array_Table.Init            (Tree.Arrays);\n+      Package_Table.Init          (Tree.Packages);\n+      Project_List_Table.Init     (Tree.Project_Lists);\n+      Project_Table.Init          (Tree.Projects);\n+      Unit_Table.Init             (Tree.Units);\n+      Units_Htable.Reset          (Tree.Units_HT);\n+      Files_Htable.Reset          (Tree.Files_HT);\n+      Naming_Table.Init           (Tree.Private_Part.Namings);\n+      Path_File_Table.Init        (Tree.Private_Part.Path_Files);\n+      Source_Path_Table.Init      (Tree.Private_Part.Source_Paths);\n+      Object_Path_Table.Init      (Tree.Private_Part.Object_Paths);\n+      Tree.Private_Part.Default_Naming := Std_Naming_Data;\n+      Register_Default_Naming_Scheme\n+        (Language            => Name_Ada,\n+         Default_Spec_Suffix => Default_Ada_Spec_Suffix,\n+         Default_Body_Suffix => Default_Ada_Body_Suffix,\n+         In_Tree             => Tree);\n    end Reset;\n \n    ------------------------\n@@ -538,7 +606,8 @@ package body Prj is\n    procedure Set\n      (Language   : Language_Index;\n       Present    : Boolean;\n-      In_Project : in out Project_Data)\n+      In_Project : in out Project_Data;\n+      In_Tree    : Project_Tree_Ref)\n    is\n    begin\n       case Language is\n@@ -555,10 +624,12 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := Present_Languages.Table (Supp_Index);\n+                  Supp := In_Tree.Present_Languages.Table\n+                                                                (Supp_Index);\n \n                   if Supp.Index = Language then\n-                     Present_Languages.Table (Supp_Index).Present := Present;\n+                     In_Tree.Present_Languages.Table\n+                                            (Supp_Index).Present := Present;\n                      return;\n                   end if;\n \n@@ -567,9 +638,12 @@ package body Prj is\n \n                Supp := (Index => Language, Present => Present,\n                         Next  => In_Project.Supp_Languages);\n-               Present_Languages.Increment_Last;\n-               Supp_Index := Present_Languages.Last;\n-               Present_Languages.Table (Supp_Index) := Supp;\n+               Present_Language_Table.Increment_Last\n+                 (In_Tree.Present_Languages);\n+               Supp_Index := Present_Language_Table.Last\n+                 (In_Tree.Present_Languages);\n+               In_Tree.Present_Languages.Table (Supp_Index) :=\n+                 Supp;\n                In_Project.Supp_Languages := Supp_Index;\n             end;\n       end case;\n@@ -578,7 +652,8 @@ package body Prj is\n    procedure Set\n      (Language_Processing : in Language_Processing_Data;\n       For_Language        : Language_Index;\n-      In_Project          : in out Project_Data)\n+      In_Project          : in out Project_Data;\n+      In_Tree             : Project_Tree_Ref)\n    is\n    begin\n       case For_Language is\n@@ -597,11 +672,12 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := Supp_Languages.Table (Supp_Index);\n+                  Supp := In_Tree.Supp_Languages.Table\n+                                                                (Supp_Index);\n \n                   if Supp.Index = For_Language then\n-                     Supp_Languages.Table (Supp_Index).Data :=\n-                       Language_Processing;\n+                     In_Tree.Supp_Languages.Table\n+                       (Supp_Index).Data := Language_Processing;\n                      return;\n                   end if;\n \n@@ -610,9 +686,11 @@ package body Prj is\n \n                Supp := (Index => For_Language, Data => Language_Processing,\n                         Next  => In_Project.Supp_Language_Processing);\n-               Supp_Languages.Increment_Last;\n-               Supp_Index := Supp_Languages.Last;\n-               Supp_Languages.Table (Supp_Index) := Supp;\n+               Supp_Language_Table.Increment_Last\n+                 (In_Tree.Supp_Languages);\n+               Supp_Index := Supp_Language_Table.Last\n+                               (In_Tree.Supp_Languages);\n+               In_Tree.Supp_Languages.Table (Supp_Index) := Supp;\n                In_Project.Supp_Language_Processing := Supp_Index;\n             end;\n       end case;\n@@ -621,7 +699,8 @@ package body Prj is\n    procedure Set\n      (Suffix       : Name_Id;\n       For_Language : Language_Index;\n-      In_Project   : in out Project_Data)\n+      In_Project   : in out Project_Data;\n+      In_Tree      : Project_Tree_Ref)\n    is\n    begin\n       case For_Language is\n@@ -639,10 +718,12 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := Supp_Suffix_Table.Table (Supp_Index);\n+                  Supp := In_Tree.Supp_Suffixes.Table\n+                                                            (Supp_Index);\n \n                   if Supp.Index = For_Language then\n-                     Supp_Suffix_Table.Table (Supp_Index).Suffix := Suffix;\n+                     In_Tree.Supp_Suffixes.Table\n+                       (Supp_Index).Suffix := Suffix;\n                      return;\n                   end if;\n \n@@ -651,23 +732,40 @@ package body Prj is\n \n                Supp := (Index => For_Language, Suffix => Suffix,\n                         Next  => In_Project.Naming.Supp_Suffixes);\n-               Supp_Suffix_Table.Increment_Last;\n-               Supp_Index := Supp_Suffix_Table.Last;\n-               Supp_Suffix_Table.Table (Supp_Index) := Supp;\n+               Supp_Suffix_Table.Increment_Last\n+                 (In_Tree.Supp_Suffixes);\n+               Supp_Index := Supp_Suffix_Table.Last\n+                 (In_Tree.Supp_Suffixes);\n+               In_Tree.Supp_Suffixes.Table (Supp_Index) := Supp;\n                In_Project.Naming.Supp_Suffixes := Supp_Index;\n             end;\n       end case;\n    end Set;\n \n+   -----------\n+   -- Slash --\n+   -----------\n+\n+   function Slash return Name_Id is\n+   begin\n+      return Slash_Id;\n+   end Slash;\n \n    --------------------------\n    -- Standard_Naming_Data --\n    --------------------------\n \n-   function Standard_Naming_Data return Naming_Data is\n+   function Standard_Naming_Data (Tree : Project_Tree_Ref := No_Project_Tree)\n+                                  return Naming_Data\n+   is\n    begin\n-      Prj.Initialize;\n-      return Std_Naming_Data;\n+      if Tree = No_Project_Tree then\n+         Prj.Initialize (Tree => No_Project_Tree);\n+         return Std_Naming_Data;\n+\n+      else\n+         return Tree.Private_Part.Default_Naming;\n+      end if;\n    end Standard_Naming_Data;\n \n    ---------------\n@@ -676,7 +774,8 @@ package body Prj is\n \n    function Suffix_Of\n      (Language   : Language_Index;\n-      In_Project : Project_Data) return Name_Id\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return Name_Id\n    is\n    begin\n       case Language is\n@@ -694,7 +793,8 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := Supp_Suffix_Table.Table (Supp_Index);\n+                  Supp := In_Tree.Supp_Suffixes.Table\n+                                                             (Supp_Index);\n \n                   if Supp.Index = Language then\n                      return Supp.Suffix;"}, {"sha": "a1b685e153d91722215e2e704918000c5b55c5f8", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 273, "deletions": 120, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98a4c668eac2b10f06ff207a24d2ca4e867128/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=7e98a4c668eac2b10f06ff207a24d2ca4e867128", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,39 +35,47 @@ with Scans;  use Scans;\n with Table;\n with Types;  use Types;\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n+with GNAT.Dynamic_Tables;\n+with GNAT.OS_Lib;           use GNAT.OS_Lib;\n \n-with System.HTable; use System.HTable;\n+with System.HTable;\n \n package Prj is\n \n-   Empty_Name : Name_Id;\n-   --  Name_Id for an empty name (no characters). Initialized by the call\n-   --  to procedure Initialize.\n-\n-   All_Packages : constant String_List_Access := null;\n+   All_Packages : constant String_List_Access;\n    --  Default value of parameter Packages of procedures Parse, in Prj.Pars and\n    --  Prj.Part, indicating that all packages should be checked.\n \n-   Virtual_Prefix : constant String := \"v$\";\n-   --  The prefix for virtual extending projects. Because of the '$', which is\n-   --  normally forbidden for project names, there cannot be any name clash.\n+   type Project_Tree_Data;\n+   type Project_Tree_Ref is access all Project_Tree_Data;\n+   --  Reference to a project tree.\n+   --  Several project trees may exist in memory at the same time.\n \n-   Project_File_Extension : String := \".gpr\";\n-   --  The standard project file name extension. It is not a constant, because\n-   --  Canonical_Case_File_Name is called on this variable in the body of Prj.\n+   No_Project_Tree : constant Project_Tree_Ref;\n \n-   Default_Ada_Spec_Suffix : Name_Id;\n+   function Default_Ada_Spec_Suffix return Name_Id;\n+   pragma Inline (Default_Ada_Spec_Suffix);\n    --  The Name_Id for the standard GNAT suffix for Ada spec source file\n    --  name \".ads\". Initialized by Prj.Initialize.\n \n-   Default_Ada_Body_Suffix : Name_Id;\n+   function Default_Ada_Body_Suffix return Name_Id;\n+   pragma Inline (Default_Ada_Body_Suffix);\n    --  The Name_Id for the standard GNAT suffix for Ada body source file\n    --  name \".adb\". Initialized by Prj.Initialize.\n \n-   Slash : Name_Id;\n+   function Slash return Name_Id;\n+   pragma Inline (Slash);\n    --  \"/\", used as the path of locally removed files\n \n+   Project_File_Extension : String := \".gpr\";\n+   --  The standard project file name extension. It is not a constant, because\n+   --  Canonical_Case_File_Name is called on this variable in the body of Prj.\n+\n+   -----------------------------------------------------\n+   -- Multi-language stuff that will be modified soon --\n+   -----------------------------------------------------\n+\n    type Language_Index is new Nat;\n \n    No_Language_Index           : constant Language_Index := 0;\n@@ -129,13 +137,12 @@ package Prj is\n       Next    : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n \n-   package Present_Languages is new Table.Table\n+   package Present_Language_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Supp_Language,\n       Table_Index_Type     => Supp_Language_Index,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 4,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Present_Languages\");\n+      Table_Increment      => 100);\n    --  The table for the presence of languages with an index that is outside\n    --  of First_Language_Indexes.\n \n@@ -152,13 +159,12 @@ package Prj is\n       Next    : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n \n-   package Supp_Suffix_Table is new Table.Table\n+   package Supp_Suffix_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Supp_Suffix,\n       Table_Index_Type     => Supp_Language_Index,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 4,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Supp_Suffix_Table\");\n+      Table_Increment      => 100);\n    --  The table for the presence of languages with an index that is outside\n    --  of First_Language_Indexes.\n \n@@ -172,13 +178,12 @@ package Prj is\n       Next : Name_List_Index := No_Name_List;\n    end record;\n \n-   package Name_Lists is new Table.Table\n+   package Name_List_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Name_Node,\n       Table_Index_Type     => Name_List_Index,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Name_Lists\");\n+      Table_Increment      => 100);\n    --  The table for lists of names used in package Language_Processing\n \n    type Language_Processing_Data is record\n@@ -206,22 +211,22 @@ package Prj is\n    type First_Language_Processing_Data is\n      array (First_Language_Indexes) of Language_Processing_Data;\n \n-   Default_First_Language_Processing_Data : First_Language_Processing_Data :=\n-     (others => Default_Language_Processing_Data);\n+   Default_First_Language_Processing_Data :\n+      constant First_Language_Processing_Data :=\n+                 (others => Default_Language_Processing_Data);\n \n    type Supp_Language_Data is record\n       Index : Language_Index := No_Language_Index;\n       Data  : Language_Processing_Data := Default_Language_Processing_Data;\n       Next  : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n \n-   package Supp_Languages is new Table.Table\n+   package Supp_Language_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Supp_Language_Data,\n       Table_Index_Type     => Supp_Language_Index,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 4,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Supp_Languages\");\n+      Table_Increment      => 100);\n    --  The table for language data when there are more languages than\n    --  in First_Language_Indexes.\n \n@@ -243,21 +248,27 @@ package Prj is\n    end record;\n    --  Data for a source in a language other than Ada\n \n-   package Other_Sources is new Table.Table\n+   package Other_Source_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Other_Source,\n       Table_Index_Type     => Other_Source_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Other_Sources\");\n+      Table_Increment      => 100);\n    --  The table for sources of languages other than Ada\n \n+   ----------------------------------\n+   --  End of multi-language stuff --\n+   ----------------------------------\n+\n    type Verbosity is (Default, Medium, High);\n    --  Verbosity when parsing GNAT Project Files\n    --    Default is default (very quiet, if no errors).\n    --    Medium is more verbose.\n    --    High is extremely verbose.\n \n+   Current_Verbosity : Verbosity := Default;\n+   --  The current value of the verbosity the project files are parsed with\n+\n    type Lib_Kind is (Static, Dynamic, Relocatable);\n    type Policy is (Autonomous, Compliant, Controlled, Restricted);\n    --  Type to specify the symbol policy, when symbol control is supported.\n@@ -274,7 +285,7 @@ package Prj is\n    end record;\n    --  Type to keep the symbol data to be used when building a shared library\n \n-   No_Symbols : Symbol_Record :=\n+   No_Symbols : constant Symbol_Record :=\n      (Symbol_File   => No_Name,\n       Reference     => No_Name,\n       Symbol_Policy => Autonomous);\n@@ -301,13 +312,12 @@ package Prj is\n    --  Component Flag may be used for various purposes. For source\n    --  directories, it indicates if the directory contains Ada source(s).\n \n-   package String_Elements is new Table.Table\n+   package String_Element_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => String_Element,\n       Table_Index_Type     => String_List_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.String_Elements\");\n+      Table_Increment      => 100);\n    --  The table for string elements in string lists\n \n    type Variable_Kind is (Undefined, List, Single);\n@@ -316,7 +326,7 @@ package Prj is\n    subtype Defined_Variable_Kind is Variable_Kind range List .. Single;\n    --  The defined kinds of variables\n \n-   Ignored : constant Variable_Kind := Single;\n+   Ignored : constant Variable_Kind;\n    --  Used to indicate that a package declaration must be ignored\n    --  while processing the project tree (unknown package name).\n \n@@ -337,11 +347,7 @@ package Prj is\n    --  Values for variables and array elements. Default is True if the\n    --  current value is the default one for the variable\n \n-   Nil_Variable_Value : constant Variable_Value :=\n-     (Project  => No_Project,\n-      Kind     => Undefined,\n-      Location => No_Location,\n-      Default  => False);\n+   Nil_Variable_Value : constant Variable_Value;\n    --  Value of a non existing variable or array element\n \n    type Variable_Id is new Nat;\n@@ -353,13 +359,12 @@ package Prj is\n    end record;\n    --  To hold the list of variables in a project file and in packages\n \n-   package Variable_Elements is new Table.Table\n+   package Variable_Element_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Variable,\n       Table_Index_Type     => Variable_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Variable_Elements\");\n+      Table_Increment      => 100);\n    --  The table of variable in list of variables\n \n    type Array_Element_Id is new Nat;\n@@ -374,13 +379,12 @@ package Prj is\n    --  Each Array_Element represents an array element and is linked (Next)\n    --  to the next array element, if any, in the array.\n \n-   package Array_Elements is new Table.Table\n+   package Array_Element_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Array_Element,\n       Table_Index_Type     => Array_Element_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Array_Elements\");\n+      Table_Increment      => 100);\n    --  The table that contains all array elements\n \n    type Array_Id is new Nat;\n@@ -394,13 +398,12 @@ package Prj is\n    --  Value is the id of the first element.\n    --  Next is the id of the next array in the project file or package.\n \n-   package Arrays is new Table.Table\n+   package Array_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Array_Data,\n       Table_Index_Type     => Array_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 200,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Arrays\");\n+      Table_Increment      => 100);\n    --  The table that contains all arrays\n \n    type Package_Id is new Nat;\n@@ -429,13 +432,12 @@ package Prj is\n    end record;\n    --  A package. Includes declarations that may include other packages.\n \n-   package Packages is new Table.Table\n+   package Package_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Package_Element,\n       Table_Index_Type     => Package_Id,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 100,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Packages\");\n+      Table_Increment      => 100);\n    --  The table that contains all packages.\n \n    function Image (Casing : Casing_Type) return String;\n@@ -511,9 +513,12 @@ package Prj is\n \n    end record;\n \n-   function Standard_Naming_Data return Naming_Data;\n+   function Standard_Naming_Data (Tree : Project_Tree_Ref := No_Project_Tree)\n+                                  return Naming_Data;\n    pragma Inline (Standard_Naming_Data);\n-   --  The standard GNAT naming scheme\n+   --  The standard GNAT naming scheme when Tree is No_Project_Tree.\n+   --  Otherwise, return the default naming scheme for the project tree Tree,\n+   --  which must have been Initialized.\n \n    function Same_Naming_Scheme\n      (Left, Right : Naming_Data) return Boolean;\n@@ -531,13 +536,12 @@ package Prj is\n    --  Element in a list of project files. Next is the id of the next\n    --  project file in the list.\n \n-   package Project_Lists is new Table.Table\n+   package Project_List_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Project_Element,\n       Table_Index_Type     => Project_List,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 100,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Project_Lists\");\n+      Table_Increment      => 100);\n    --  The table that contains the lists of project files\n \n    --  The following record describes a project file representation\n@@ -782,80 +786,126 @@ package Prj is\n \n    end record;\n \n-   function Is_Present\n-     (Language   : Language_Index;\n-      In_Project : Project_Data) return Boolean;\n-   --  Return True when Language is one of the languages used in\n-   --  project Project.\n-\n-   procedure Set\n-     (Language   : Language_Index;\n-      Present    : Boolean;\n-      In_Project : in out Project_Data);\n-   --  Indicate if Language is or not a language used in project Project\n-\n-   function Language_Processing_Data_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data) return Language_Processing_Data;\n-   --  Return the Language_Processing_Data for language Language in project\n-   --  In_Project. Return the default when no Language_Processing_Data are\n-   --  defined for the language.\n-\n-   procedure Set\n-     (Language_Processing : Language_Processing_Data;\n-      For_Language        : Language_Index;\n-      In_Project          : in out Project_Data);\n-   --  Set the Language_Processing_Data for language Language in project\n-   --  In_Project.\n-\n-   function Suffix_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data) return Name_Id;\n-   --  Return the suffix for language Language in project In_Project. Return\n-   --  No_Name when no suffix is defined for the language.\n-\n-   procedure Set\n-     (Suffix       : Name_Id;\n-      For_Language : Language_Index;\n-      In_Project   : in out Project_Data);\n-   --  Set the suffix for language Language in project In_Project\n+   function Empty_Project (Tree : Project_Tree_Ref) return Project_Data;\n+   --  Return the representation of an empty project in project Tree tree.\n+   --  The project tree Tree must have been Initialized and/or Reset.\n \n    Project_Error : exception;\n    --  Raised by some subprograms in Prj.Attr.\n \n-   function Empty_Project return Project_Data;\n-   --  Return the representation of an empty project\n-\n-   package Projects is new Table.Table (\n+   package Project_Table is new GNAT.Dynamic_Tables (\n      Table_Component_Type => Project_Data,\n      Table_Index_Type     => Project_Id,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 100,\n-     Table_Increment      => 100,\n-     Table_Name           => \"Prj.Projects\");\n+     Table_Increment      => 100);\n    --  The set of all project files\n \n+   type Spec_Or_Body is\n+     (Specification, Body_Part);\n+\n+   type File_Name_Data is record\n+      Name         : Name_Id := No_Name;\n+      Index        : Int     := 0;\n+      Display_Name : Name_Id := No_Name;\n+      Path         : Name_Id := No_Name;\n+      Display_Path : Name_Id := No_Name;\n+      Project      : Project_Id := No_Project;\n+      Needs_Pragma : Boolean := False;\n+   end record;\n+   --  File and Path name of a spec or body.\n+\n+   type File_Names_Data is array (Spec_Or_Body) of File_Name_Data;\n+\n+   type Unit_Id is new Nat;\n+   No_Unit : constant Unit_Id := 0;\n+   type Unit_Data is record\n+      Name       : Name_Id    := No_Name;\n+      File_Names : File_Names_Data;\n+   end record;\n+   --  Name and File and Path names of a unit, with a reference to its\n+   --  GNAT Project File(s).\n+\n+   package Unit_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Unit_Data,\n+      Table_Index_Type     => Unit_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 100,\n+      Table_Increment      => 100);\n+   --  Table of all units in a project tree\n+\n+   package Units_Htable is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Unit_Id,\n+      No_Element => No_Unit,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  Mapping of unit names to indexes in the Units table\n+\n+   type Unit_Project is record\n+      Unit    : Unit_Id    := No_Unit;\n+      Project : Project_Id := No_Project;\n+   end record;\n+\n+   No_Unit_Project : constant Unit_Project := (No_Unit, No_Project);\n+\n+   package Files_Htable is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Unit_Project,\n+      No_Element => No_Unit_Project,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  Mapping of file names to indexes in the Units table\n+\n+   type Private_Project_Tree_Data is private;\n+   --  Data for a project tree that is used only by the Project Manager\n+\n+   type Project_Tree_Data is\n+      record\n+         Present_Languages : Present_Language_Table.Instance;\n+         Supp_Suffixes     : Supp_Suffix_Table.Instance;\n+         Name_Lists        : Name_List_Table.Instance;\n+         Supp_Languages    : Supp_Language_Table.Instance;\n+         Other_Sources     : Other_Source_Table.Instance;\n+         String_Elements   : String_Element_Table.Instance;\n+         Variable_Elements : Variable_Element_Table.Instance;\n+         Array_Elements    : Array_Element_Table.Instance;\n+         Arrays            : Array_Table.Instance;\n+         Packages          : Package_Table.Instance;\n+         Project_Lists     : Project_List_Table.Instance;\n+         Projects          : Project_Table.Instance;\n+         Units             : Unit_Table.Instance;\n+         Units_HT          : Units_Htable.Instance;\n+         Files_HT          : Files_Htable.Instance;\n+         Private_Part      : Private_Project_Tree_Data;\n+      end record;\n+   --  Data for a project tree\n+\n    type Put_Line_Access is access procedure\n      (Line    : String;\n-      Project : Project_Id);\n+      Project : Project_Id;\n+      In_Tree : Project_Tree_Ref);\n    --  Use to customize error reporting in Prj.Proc and Prj.Nmsc\n \n    procedure Expect (The_Token : Token_Type; Token_Image : String);\n    --  Check that the current token is The_Token. If it is not, then\n    --  output an error message.\n \n-   procedure Initialize;\n+   procedure Initialize (Tree : Project_Tree_Ref);\n    --  This procedure must be called before using any services from the Prj\n    --  hierarchy. Namet.Initialize must be called before Prj.Initialize.\n \n-   procedure Reset;\n+   procedure Reset (Tree : Project_Tree_Ref);\n    --  This procedure resets all the tables that are used when processing a\n    --  project file tree. Initialize must be called before the call to Reset.\n \n    procedure Register_Default_Naming_Scheme\n      (Language            : Name_Id;\n       Default_Spec_Suffix : Name_Id;\n-      Default_Body_Suffix : Name_Id);\n+      Default_Body_Suffix : Name_Id;\n+      In_Tree             : Project_Tree_Ref);\n    --  Register the default suffixes for a given language. These extensions\n    --  will be ignored if the user has specified a new naming scheme in a\n    --  project file.\n@@ -870,29 +920,132 @@ package Prj is\n          With_State : in out State);\n    procedure For_Every_Project_Imported\n      (By         : Project_Id;\n+      In_Tree    : Project_Tree_Ref;\n       With_State : in out State);\n    --  Call Action for each project imported directly or indirectly by project\n    --  By. Action is called according to the order of importation: if A\n    --  imports B, directly or indirectly, Action will be called for A before\n-   --  it is called for B. With_State may be used by Action to choose a\n-   --  behavior or to report some global result.\n+   --  it is called for B. If two projects import each other directly or\n+   --  indirectly (using at least one \"limited with\"), it is not specified\n+   --  for which of these two projects Action will be called first. Projects\n+   --  that are extended by other projects are not considered. With_State may\n+   --  be used by Action to choose a behavior or to report some global result.\n+\n+   ----------------------------------------------------------\n+   -- Other multi-language stuff that may be modified soon --\n+   ----------------------------------------------------------\n+\n+   function Is_Present\n+     (Language   : Language_Index;\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return Boolean;\n+   --  Return True when Language is one of the languages used in\n+   --  project Project.\n+\n+   procedure Set\n+     (Language   : Language_Index;\n+      Present    : Boolean;\n+      In_Project : in out Project_Data;\n+      In_Tree    : Project_Tree_Ref);\n+   --  Indicate if Language is or not a language used in project Project\n+\n+   function Language_Processing_Data_Of\n+     (Language   : Language_Index;\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return Language_Processing_Data;\n+   --  Return the Language_Processing_Data for language Language in project\n+   --  In_Project. Return the default when no Language_Processing_Data are\n+   --  defined for the language.\n+\n+   procedure Set\n+     (Language_Processing : Language_Processing_Data;\n+      For_Language        : Language_Index;\n+      In_Project          : in out Project_Data;\n+      In_Tree             : Project_Tree_Ref);\n+   --  Set the Language_Processing_Data for language Language in project\n+   --  In_Project.\n+\n+   function Suffix_Of\n+     (Language   : Language_Index;\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return Name_Id;\n+   --  Return the suffix for language Language in project In_Project. Return\n+   --  No_Name when no suffix is defined for the language.\n+\n+   procedure Set\n+     (Suffix       : Name_Id;\n+      For_Language : Language_Index;\n+      In_Project   : in out Project_Data;\n+      In_Tree      : Project_Tree_Ref);\n+   --  Set the suffix for language Language in project In_Project\n \n private\n \n-   Initial_Buffer_Size : constant := 100;\n-   --  Initial size for extensible buffer used below\n+   All_Packages : constant String_List_Access := null;\n \n-   Buffer : String_Access := new String (1 .. Initial_Buffer_Size);\n-   --  An extensible character buffer to store names. Used in Prj.Part and\n-   --  Prj.Strt.\n+   No_Project_Tree : constant Project_Tree_Ref := null;\n \n-   Buffer_Last : Natural := 0;\n-   --  The index of the last character in the Buffer\n+   Ignored : constant Variable_Kind := Single;\n \n-   Current_Packages_To_Check : String_List_Access := All_Packages;\n-   --  Global variable, set by Prj.Part.Parse, used by Prj.Dect.\n+   Nil_Variable_Value : constant Variable_Value :=\n+     (Project  => No_Project,\n+      Kind     => Undefined,\n+      Location => No_Location,\n+      Default  => False);\n \n-   procedure Add_To_Buffer (S : String);\n+   Virtual_Prefix : constant String := \"v$\";\n+   --  The prefix for virtual extending projects. Because of the '$', which is\n+   --  normally forbidden for project names, there cannot be any name clash.\n+\n+   Empty_Name : Name_Id;\n+   --  Name_Id for an empty name (no characters). Initialized by the call\n+   --  to procedure Initialize.\n+\n+   procedure Add_To_Buffer\n+     (S    : String;\n+      To   : in out String_Access;\n+      Last : in out Natural);\n    --  Append a String to the Buffer\n \n+   type Naming_Id is new Nat;\n+\n+   package Naming_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Naming_Data,\n+      Table_Index_Type     => Naming_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 5,\n+      Table_Increment      => 100);\n+\n+   package Path_File_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 50);\n+   --  Table storing all the temp path file names.\n+   --  Used by Delete_All_Path_Files.\n+\n+   package Source_Path_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 50);\n+   --  A table to store the source dirs before creating the source path file\n+\n+   package Object_Path_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 50);\n+   --  A table to store the object dirs, before creating the object path file\n+\n+   type Private_Project_Tree_Data is record\n+      Namings           : Naming_Table.Instance;\n+      Path_Files        : Path_File_Table.Instance;\n+      Source_Paths      : Source_Path_Table.Instance;\n+      Object_Paths      : Object_Path_Table.Instance;\n+      Default_Naming    : Naming_Data;\n+   end record;\n end Prj;"}]}