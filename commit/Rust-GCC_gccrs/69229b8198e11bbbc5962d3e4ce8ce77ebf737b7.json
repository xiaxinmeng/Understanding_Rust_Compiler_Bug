{"sha": "69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyMjliODE5OGUxMWJiYmM1OTYyZDNlNGNlOGNlNzdlYmY3MzdiNw==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2005-03-13T18:03:25Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2005-03-13T18:03:25Z"}, "message": "configure.ac: Check for MIPS TLS.\n\n\t* configure.ac: Check for MIPS TLS.\n\t* configure: Regenerated.\n\t* config/mips/mips-protos.h (enum mips_symbol_type): Add\n\tSYMBOL_TLS, SYMBOL_TLSGD, SYMBOL_TLSLDM, SYMBOL_DTPREL,\n\tSYMBOL_GOTTPREL, and SYMBOL_TPREL.\n\t* config/mips/mips.c (mips_regno_to_class): Handle V1_REG.\n\t(TARGET_HAVE_TLS, TARGET_CANNOT_FORCE_CONST_MEM): Define.\n\t(mips_classify_symbol, mips_symbolic_constant_p)\n\t(mips_symbolic_address_p, mips_symbol_insns): Handle TLS symbols.\n\t(mips_tls_operand_p, mips_call_tls_get_addr)\n\t(mips_legitimize_tls_address, mips_cannot_force_const_mem)\n\t(mips_tls_symbol_ref_1): New functions.\n\t(mips_legitimize_address, mips_legitimize_const_move): Call\n\tmips_legitimize_tls_address.\n\t(override_options): Handle V1_REG and TLS symbols.  Disable TLS\n\tfor MIPS16.\n\t* config/mips/mips.h (enum reg_class, REG_CLASS_NAMES)\n\t(REG_CLASS_CONTENTS, GR_REG_CLASS_P): Include V1_REG.\n\t(mips_char_to_class): Document V1_REG.\n\t(HAVE_AS_TLS): Provide default.\n\t* config/mips/mips.md (UNSPEC_TLS_LDM, UNSPEC_TLS_GET_TP): New\n\tconstants.\n\t(load_got<mode>): Renamed from *load_got<mode>.  Allow when\n\t!TARGET_ABICALLS.\n\t(tls_get_tp_<mode>): New instruction.\n\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\n\nFrom-SVN: r96380", "tree": {"sha": "6f57ba94026b1caf579525022e6276fe3adcf97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f57ba94026b1caf579525022e6276fe3adcf97b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/comments", "author": null, "committer": null, "parents": [{"sha": "b095fe2cd9510347db6bc8842562255a78fa6bd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b095fe2cd9510347db6bc8842562255a78fa6bd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b095fe2cd9510347db6bc8842562255a78fa6bd4"}], "stats": {"total": 321, "additions": 316, "deletions": 5}, "files": [{"sha": "6489c3c438fb6748bc0b5b9333932da3d4acf5af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -1,3 +1,32 @@\n+2005-03-13  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* configure.ac: Check for MIPS TLS.\n+\t* configure: Regenerated.\n+\t* config/mips/mips-protos.h (enum mips_symbol_type): Add\n+\tSYMBOL_TLS, SYMBOL_TLSGD, SYMBOL_TLSLDM, SYMBOL_DTPREL,\n+\tSYMBOL_GOTTPREL, and SYMBOL_TPREL.\n+\t* config/mips/mips.c (mips_regno_to_class): Handle V1_REG.\n+\t(TARGET_HAVE_TLS, TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\t(mips_classify_symbol, mips_symbolic_constant_p)\n+\t(mips_symbolic_address_p, mips_symbol_insns): Handle TLS symbols.\n+\t(mips_tls_operand_p, mips_call_tls_get_addr)\n+\t(mips_legitimize_tls_address, mips_cannot_force_const_mem)\n+\t(mips_tls_symbol_ref_1): New functions.\n+\t(mips_legitimize_address, mips_legitimize_const_move): Call\n+\tmips_legitimize_tls_address.\n+\t(override_options): Handle V1_REG and TLS symbols.  Disable TLS\n+\tfor MIPS16.\n+\t* config/mips/mips.h (enum reg_class, REG_CLASS_NAMES)\n+\t(REG_CLASS_CONTENTS, GR_REG_CLASS_P): Include V1_REG.\n+\t(mips_char_to_class): Document V1_REG.\n+\t(HAVE_AS_TLS): Provide default.\n+\t* config/mips/mips.md (UNSPEC_TLS_LDM, UNSPEC_TLS_GET_TP): New\n+\tconstants.\n+\t(load_got<mode>): Renamed from *load_got<mode>.  Allow when\n+\t!TARGET_ABICALLS.\n+\t(tls_get_tp_<mode>): New instruction.\n+\n 2005-03-13  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* configure.ac: Update checks for target tools."}, {"sha": "4b0b53d1091816600cea7ae6d82797cac565f128", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -61,6 +61,17 @@ Boston, MA 02111-1307, USA.  */\n        An UNSPEC wrapper around a function's address.  It represents the\n        offset of _gp from the start of the function.\n \n+   SYMBOL_TLS\n+       A thread-local symbol.\n+\n+   SYMBOL_TLSGD\n+   SYMBOL_TLSLDM\n+   SYMBOL_DTPREL\n+   SYMBOL_GOTTPREL\n+   SYMBOL_TPREL\n+       UNSPEC wrappers around SYMBOL_TLS, corresponding to the\n+       thread-local storage relocation operators.\n+\n    SYMBOL_64_HIGH\n        For a 64-bit symbolic address X, this is the value of\n        (%highest(X) << 16) + %higher(X).\n@@ -82,6 +93,12 @@ enum mips_symbol_type {\n   SYMBOL_GOTOFF_GLOBAL,\n   SYMBOL_GOTOFF_CALL,\n   SYMBOL_GOTOFF_LOADGP,\n+  SYMBOL_TLS,\n+  SYMBOL_TLSGD,\n+  SYMBOL_TLSLDM,\n+  SYMBOL_DTPREL,\n+  SYMBOL_GOTTPREL,\n+  SYMBOL_TPREL,\n   SYMBOL_64_HIGH,\n   SYMBOL_64_MID,\n   SYMBOL_64_LOW"}, {"sha": "59fd616b7f5024191c7f73975d079c1c7c535226", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 203, "deletions": 2, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -236,6 +236,7 @@ static bool mips_valid_base_register_p (rtx, enum machine_mode, int);\n static bool mips_symbolic_address_p (enum mips_symbol_type, enum machine_mode);\n static bool mips_classify_address (struct mips_address_info *, rtx,\n \t\t\t\t   enum machine_mode, int);\n+static bool mips_cannot_force_const_mem (rtx);\n static int mips_symbol_insns (enum mips_symbol_type);\n static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n static rtx mips_force_temporary (rtx, rtx);\n@@ -601,7 +602,7 @@ static const char *mips_hi_relocs[NUM_SYMBOL_TYPES];\n /* Map hard register number to register class */\n const enum reg_class mips_regno_to_class[] =\n {\n-  LEA_REGS,\tLEA_REGS,\tM16_NA_REGS,\tM16_NA_REGS,\n+  LEA_REGS,\tLEA_REGS,\tM16_NA_REGS,\tV1_REG,\n   M16_REGS,\tM16_REGS,\tM16_REGS,\tM16_REGS,\n   LEA_REGS,\tLEA_REGS,\tLEA_REGS,\tLEA_REGS,\n   LEA_REGS,\tLEA_REGS,\tLEA_REGS,\tLEA_REGS,\n@@ -817,6 +818,12 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN mips_expand_builtin\n \n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS HAVE_AS_TLS\n+\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM mips_cannot_force_const_mem\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n@@ -835,6 +842,9 @@ mips_classify_symbol (rtx x)\n \n   gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n+  if (SYMBOL_REF_TLS_MODEL (x))\n+    return SYMBOL_TLS;\n+\n   if (CONSTANT_POOL_ADDRESS_P (x))\n     {\n       if (TARGET_MIPS16)\n@@ -943,7 +953,11 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n   if (UNSPEC_ADDRESS_P (x))\n     *symbol_type = UNSPEC_ADDRESS_TYPE (x);\n   else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n-    *symbol_type = mips_classify_symbol (x);\n+    {\n+      *symbol_type = mips_classify_symbol (x);\n+      if (*symbol_type == SYMBOL_TLS)\n+\treturn false;\n+    }\n   else\n     return false;\n \n@@ -993,6 +1007,12 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n     case SYMBOL_GOTOFF_GLOBAL:\n     case SYMBOL_GOTOFF_CALL:\n     case SYMBOL_GOTOFF_LOADGP:\n+    case SYMBOL_TLSGD:\n+    case SYMBOL_TLSLDM:\n+    case SYMBOL_DTPREL:\n+    case SYMBOL_TPREL:\n+    case SYMBOL_GOTTPREL:\n+    case SYMBOL_TLS:\n       return false;\n     }\n   gcc_unreachable ();\n@@ -1090,6 +1110,14 @@ mips_symbolic_address_p (enum mips_symbol_type symbol_type,\n       /* The address will have to be loaded from the GOT first.  */\n       return false;\n \n+    case SYMBOL_TLSGD:\n+    case SYMBOL_TLSLDM:\n+    case SYMBOL_DTPREL:\n+    case SYMBOL_TPREL:\n+    case SYMBOL_GOTTPREL:\n+    case SYMBOL_TLS:\n+      return false;\n+\n     case SYMBOL_GOTOFF_PAGE:\n     case SYMBOL_GOTOFF_GLOBAL:\n     case SYMBOL_GOTOFF_CALL:\n@@ -1154,6 +1182,33 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n       return false;\n     }\n }\n+\n+/* Return true if X is a thread-local symbol.  */\n+\n+static bool\n+mips_tls_operand_p (rtx x)\n+{\n+  return GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x) != 0;\n+}\n+\n+/* Return true if X can not be forced into a constant pool.  */\n+\n+static int\n+mips_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  return mips_tls_operand_p (*x);\n+}\n+\n+/* Return true if X can not be forced into a constant pool.  */\n+\n+static bool\n+mips_cannot_force_const_mem (rtx x)\n+{\n+  if (! TARGET_HAVE_TLS)\n+    return false;\n+\n+  return for_each_rtx (&x, &mips_tls_symbol_ref_1, 0);\n+}\n \f\n /* Return the number of instructions needed to load a symbol of the\n    given type into a register.  If valid in an address, the same number\n@@ -1223,8 +1278,17 @@ mips_symbol_insns (enum mips_symbol_type type)\n     case SYMBOL_64_HIGH:\n     case SYMBOL_64_MID:\n     case SYMBOL_64_LOW:\n+    case SYMBOL_TLSGD:\n+    case SYMBOL_TLSLDM:\n+    case SYMBOL_DTPREL:\n+    case SYMBOL_GOTTPREL:\n+    case SYMBOL_TPREL:\n       /* Check whether the offset is a 16- or 32-bit value.  */\n       return mips_split_p[type] ? 2 : 1;\n+\n+    case SYMBOL_TLS:\n+      /* We don't treat a bare TLS symbol as a constant.  */\n+      return 0;\n     }\n   gcc_unreachable ();\n }\n@@ -1521,6 +1585,114 @@ mips_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)\n   return plus_constant (reg, offset);\n }\n \n+/* Emit a call to __tls_get_addr.  SYM is the TLS symbol we are\n+   referencing, and TYPE is the symbol type to use (either global\n+   dynamic or local dynamic).  V0 is an RTX for the return value\n+   location.  The entire insn sequence is returned.  */\n+\n+static GTY(()) rtx mips_tls_symbol;\n+\n+static rtx\n+mips_call_tls_get_addr (rtx sym, enum mips_symbol_type type, rtx v0)\n+{\n+  rtx insn, loc, tga, a0;\n+\n+  a0 = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n+\n+  if (!mips_tls_symbol)\n+    mips_tls_symbol = init_one_libfunc (\"__tls_get_addr\");\n+\n+  loc = mips_unspec_address (sym, type);\n+\n+  start_sequence ();\n+\n+  emit_insn (gen_rtx_SET (Pmode, a0,\n+\t\t\t  gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, loc)));\n+  tga = gen_rtx_MEM (Pmode, mips_tls_symbol);\n+  insn = emit_call_insn (gen_call_value (v0, tga, const0_rtx, const0_rtx));\n+  CONST_OR_PURE_CALL_P (insn) = 1;\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), v0);\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), a0);\n+  insn = get_insns ();\n+\n+  end_sequence ();\n+\n+  return insn;\n+}\n+\n+/* Generate the code to access LOC, a thread local SYMBOL_REF.  The\n+   return value will be a valid address and move_operand (either a REG\n+   or a LO_SUM).  */\n+\n+static rtx\n+mips_legitimize_tls_address (rtx loc)\n+{\n+  rtx dest, insn, v0, v1, tmp1, tmp2, eqv;\n+  enum tls_model model;\n+\n+  v0 = gen_rtx_REG (Pmode, GP_RETURN);\n+  v1 = gen_rtx_REG (Pmode, GP_RETURN + 1);\n+\n+  model = SYMBOL_REF_TLS_MODEL (loc);\n+\n+  switch (model)\n+    {\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      insn = mips_call_tls_get_addr (loc, SYMBOL_TLSGD, v0);\n+      dest = gen_reg_rtx (Pmode);\n+      emit_libcall_block (insn, dest, v0, loc);\n+      break;\n+\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      insn = mips_call_tls_get_addr (loc, SYMBOL_TLSLDM, v0);\n+      tmp1 = gen_reg_rtx (Pmode);\n+\n+      /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n+\t share the LDM result with other LD model accesses.  */\n+      eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t    UNSPEC_TLS_LDM);\n+      emit_libcall_block (insn, tmp1, v0, eqv);\n+\n+      tmp2 = mips_unspec_offset_high (NULL, tmp1, loc, SYMBOL_DTPREL);\n+      dest = gen_rtx_LO_SUM (Pmode, tmp2,\n+\t\t\t     mips_unspec_address (loc, SYMBOL_DTPREL));\n+      break;\n+\n+    case TLS_MODEL_INITIAL_EXEC:\n+      tmp1 = gen_reg_rtx (Pmode);\n+      tmp2 = mips_unspec_address (loc, SYMBOL_GOTTPREL);\n+      if (Pmode == DImode)\n+\t{\n+\t  emit_insn (gen_tls_get_tp_di (v1));\n+\t  emit_insn (gen_load_gotdi (tmp1, pic_offset_table_rtx, tmp2));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_tls_get_tp_si (v1));\n+\t  emit_insn (gen_load_gotsi (tmp1, pic_offset_table_rtx, tmp2));\n+\t}\n+      dest = gen_reg_rtx (Pmode);\n+      emit_insn (gen_add3_insn (dest, tmp1, v1));\n+      break;\n+\n+    case TLS_MODEL_LOCAL_EXEC:\n+\n+      if (Pmode == DImode)\n+\temit_insn (gen_tls_get_tp_di (v1));\n+      else\n+\temit_insn (gen_tls_get_tp_si (v1));\n+\n+      tmp1 = mips_unspec_offset_high (NULL, v1, loc, SYMBOL_TPREL);\n+      dest = gen_rtx_LO_SUM (Pmode, tmp1,\n+\t\t\t     mips_unspec_address (loc, SYMBOL_TPREL));\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return dest;\n+}\n \n /* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n    be legitimized in a way that the generic machinery might not expect,\n@@ -1532,6 +1704,12 @@ mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n {\n   enum mips_symbol_type symbol_type;\n \n+  if (mips_tls_operand_p (*xloc))\n+    {\n+      *xloc = mips_legitimize_tls_address (*xloc);\n+      return true;\n+    }\n+\n   /* See if the address can split into a high part and a LO_SUM.  */\n   if (mips_symbolic_constant_p (*xloc, &symbol_type)\n       && mips_symbolic_address_p (symbol_type, mode)\n@@ -1707,6 +1885,12 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n       return;\n     }\n \n+  if (mips_tls_operand_p (src))\n+    {\n+      emit_move_insn (dest, mips_legitimize_tls_address (src));\n+      return;\n+    }\n+\n   /* See if the symbol can be split.  For mips16, this is often worse than\n      forcing it in the constant pool since it needs the single-register form\n      of addiu or daddiu.  */\n@@ -4323,6 +4507,7 @@ override_options (void)\n \t\t\t     GR_REGS);\n   mips_char_to_class['e'] = LEA_REGS;\n   mips_char_to_class['j'] = PIC_FN_ADDR_REG;\n+  mips_char_to_class['v'] = V1_REG;\n   mips_char_to_class['y'] = GR_REGS;\n   mips_char_to_class['z'] = ST_REGS;\n   mips_char_to_class['B'] = COP0_REGS;\n@@ -4511,6 +4696,22 @@ override_options (void)\n       mips_lo_relocs[SYMBOL_GOTOFF_LOADGP] = \"%lo(%neg(%gp_rel(\";\n     }\n \n+  /* Thread-local relocation operators.  */\n+  mips_lo_relocs[SYMBOL_TLSGD] = \"%tlsgd(\";\n+  mips_lo_relocs[SYMBOL_TLSLDM] = \"%tlsldm(\";\n+  mips_split_p[SYMBOL_DTPREL] = 1;\n+  mips_hi_relocs[SYMBOL_DTPREL] = \"%dtprel_hi(\";\n+  mips_lo_relocs[SYMBOL_DTPREL] = \"%dtprel_lo(\";\n+  mips_lo_relocs[SYMBOL_GOTTPREL] = \"%gottprel(\";\n+  mips_split_p[SYMBOL_TPREL] = 1;\n+  mips_hi_relocs[SYMBOL_TPREL] = \"%tprel_hi(\";\n+  mips_lo_relocs[SYMBOL_TPREL] = \"%tprel_lo(\";\n+\n+  /* We don't have a thread pointer access instruction on MIPS16, or\n+     appropriate TLS relocations.  */\n+  if (TARGET_MIPS16)\n+    targetm.have_tls = false;\n+\n   /* Default to working around R4000 errata only if the processor\n      was selected explicitly.  */\n   if ((target_flags_explicit & MASK_FIX_R4000) == 0"}, {"sha": "2d8695e2e5783fc1714f02ebe271333f799de604", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -1714,6 +1714,7 @@ enum reg_class\n   T_REG,\t\t\t/* mips16 T register ($24) */\n   M16_T_REGS,\t\t\t/* mips16 registers plus T register */\n   PIC_FN_ADDR_REG,\t\t/* SVR4 PIC function address register */\n+  V1_REG,\t\t\t/* Register $v1 ($3) used for TLS access.  */\n   LEA_REGS,\t\t\t/* Every GPR except $25 */\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating point registers */\n@@ -1752,6 +1753,7 @@ enum reg_class\n   \"T_REG\",\t\t\t\t\t\t\t\t\\\n   \"M16_T_REGS\",\t\t\t\t\t\t\t\t\\\n   \"PIC_FN_ADDR_REG\",\t\t\t\t\t\t\t\\\n+  \"V1_REG\",\t\t\t\t\t\t\t\t\\\n   \"LEA_REGS\",\t\t\t\t\t\t\t\t\\\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n@@ -1793,7 +1795,8 @@ enum reg_class\n   { 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n   { 0x010300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n   { 0x02000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* SVR4 PIC function address register */ \\\n-  { 0xfdffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* Every other GPR */   \\\n+  { 0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* only $v1 */ \\\n+  { 0xfdffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* Every other GPR except $25 */   \\\n   { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* integer registers */\t\\\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* floating registers*/\t\\\n   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* hi register */\t\\\n@@ -1849,6 +1852,7 @@ extern const enum reg_class mips_regno_to_class[];\n #define GR_REG_CLASS_P(CLASS)\t\t\t\t\t\t\\\n   ((CLASS) == GR_REGS || (CLASS) == M16_REGS || (CLASS) == T_REG\t\\\n    || (CLASS) == M16_T_REGS || (CLASS) == M16_NA_REGS\t\t\t\\\n+   || (CLASS) == V1_REG\t\t\t\t\t\t\t\\\n    || (CLASS) == PIC_FN_ADDR_REG || (CLASS) == LEA_REGS)\n \n /* This macro is also used later on in the file.  */\n@@ -1896,6 +1900,7 @@ extern const enum reg_class mips_regno_to_class[];\n    'f'\tFloating point registers\n    'h'\tHi register\n    'l'\tLo register\n+   'v'\t$v1 only\n    'x'\tMultiply/divide registers\n    'z'\tFP Status register\n    'B'  Cop0 register\n@@ -3031,3 +3036,7 @@ while (0)\n \t\" TEXT_SECTION_ASM_OP);\n #endif\n #endif\n+\n+#ifndef HAVE_AS_TLS\n+#define HAVE_AS_TLS 0\n+#endif"}, {"sha": "9948e0627cd7e970a0b34b9831a0f2a589820a1a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -45,6 +45,8 @@\n    (UNSPEC_LOAD_GOT\t\t24)\n    (UNSPEC_GP\t\t\t25)\n    (UNSPEC_MFHILO\t\t26)\n+   (UNSPEC_TLS_LDM\t\t27)\n+   (UNSPEC_TLS_GET_TP\t\t28)\n \n    (UNSPEC_ADDRESS_FIRST\t100)\n \n@@ -3017,12 +3019,12 @@ beq\\t%2,%.,1b\\;\\\n ;; We could use MEMs, but an unspec gives more optimization\n ;; opportunities.\n \n-(define_insn \"*load_got<mode>\"\n+(define_insn \"load_got<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n \t(unspec:P [(match_operand:P 1 \"register_operand\" \"d\")\n \t\t   (match_operand:P 2 \"immediate_operand\" \"\")]\n \t\t  UNSPEC_LOAD_GOT))]\n-  \"TARGET_ABICALLS\"\n+  \"\"\n   \"<load>\\t%0,%R2(%1)\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")\n@@ -5295,6 +5297,25 @@ beq\\t%2,%.,1b\\;\\\n   [(match_dup 0)]\n   { operands[0] = mips_rewrite_small_data (operands[0]); })\n \f\n+; Thread-Local Storage\n+\n+; The TLS base pointer is acessed via \"rdhwr $v1, $29\".  No current\n+; MIPS architecture defines this register, and no current\n+; implementation provides it; instead, any OS which supports TLS is\n+; expected to trap and emulate this instruction.  rdhwr is part of the\n+; MIPS 32r2 specification, but we use it on any architecture because\n+; we expect it to be emulated.  Use .set to force the assembler to\n+; accept it.\n+\n+(define_insn \"tls_get_tp_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=v\")\n+\t(unspec:P [(const_int 0)]\n+\t\t  UNSPEC_TLS_GET_TP))]\n+  \"HAVE_AS_TLS && !TARGET_MIPS16\"\n+  \".set\\tpush\\;.set\\tmips32r2\\t\\;rdhwr\\t%0,$29\\;.set\\tpop\"\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\f\n ; The MIPS Paired-Single Floating Point and MIPS-3D Instructions.\n \n (include \"mips-ps-3d.md\")"}, {"sha": "10ff30583bee37cadf0747725936f7ba2679aed7", "filename": "gcc/configure", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -13670,6 +13670,23 @@ foo:\tdata8\t25\n \ttls_first_minor=13\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  mips*-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\n+\t.word 2\n+\t.text\n+\taddiu $4, $28, %tlsgd(x)\n+\taddiu $4, $28, %tlsldm(x)\n+\tlui $4, %dtprel_hi(x)\n+\taddiu $4, $4, %dtprel_lo(x)\n+\tlw $4, %gottprel(x)($28)\n+\tlui $4, %tprel_hi(x)\n+\taddiu $4, $4, %tprel_lo(x)'\n+\ttls_first_major=2\n+\ttls_first_minor=16\n+\ttls_as_opt='-32 --fatal-warnings'\n+\t;;\n   powerpc-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "b076ad201295b4182f20d59e5e69193a1f2cf8c3", "filename": "gcc/configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69229b8198e11bbbc5962d3e4ce8ce77ebf737b7/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=69229b8198e11bbbc5962d3e4ce8ce77ebf737b7", "patch": "@@ -2353,6 +2353,23 @@ foo:\tdata8\t25\n \ttls_first_minor=13\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  mips*-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\n+\t.word 2\n+\t.text\n+\taddiu $4, $28, %tlsgd(x)\n+\taddiu $4, $28, %tlsldm(x)\n+\tlui $4, %dtprel_hi(x)\n+\taddiu $4, $4, %dtprel_lo(x)\n+\tlw $4, %gottprel(x)($28)\n+\tlui $4, %tprel_hi(x)\n+\taddiu $4, $4, %tprel_lo(x)'\n+\ttls_first_major=2\n+\ttls_first_minor=16\n+\ttls_as_opt='-32 --fatal-warnings'\n+\t;;\n   powerpc-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}]}