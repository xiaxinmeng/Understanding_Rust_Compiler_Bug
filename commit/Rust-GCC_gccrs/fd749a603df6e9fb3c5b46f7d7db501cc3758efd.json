{"sha": "fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3NDlhNjAzZGY2ZTlmYjNjNWI0NmY3ZDdkYjUwMWNjMzc1OGVmZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-21T17:28:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-21T17:28:35Z"}, "message": "re PR c++/18975 (Copying objects with mutable non-static data members)\n\ncp:\n\tPR c++/18975\n\t* method.c (do_build_copy_constructor): Refactor. Don't const\n\tqualify a mutable field.\n\t(do_build_assign_ref): Likewise.\ntestsuite:\n\tPR c++/18975\n\t* g++.dg/other/synth1.C: New.\n\nFrom-SVN: r92461", "tree": {"sha": "3fb71da4f415c1c54ec5075034908eef2bbeca8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fb71da4f415c1c54ec5075034908eef2bbeca8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/comments", "author": null, "committer": null, "parents": [{"sha": "ebef4d30443353b9cf4b2b559b2429273b60065b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebef4d30443353b9cf4b2b559b2429273b60065b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebef4d30443353b9cf4b2b559b2429273b60065b"}], "stats": {"total": 109, "additions": 80, "deletions": 29}, "files": [{"sha": "cb5d4ae7ece5dddc914e0c023015426eea732cc8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "patch": "@@ -1,7 +1,15 @@\n+2004-12-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18975\n+\t* method.c (do_build_copy_constructor): Refactor. Don't const\n+\tqualify a mutable field.\n+\t(do_build_assign_ref): Likewise.\n+\n 2004-12-20  Matt Austern <austern@apple.com>\n \n \tPR c++/19044\n-\t* decl.c (make_rtl_for_nonlocal_decl): Use set_builtin_user_assembler_name\n+\t* decl.c (make_rtl_for_nonlocal_decl): Use\n+\tset_builtin_user_assembler_name.\n \t\n 2004-12-19  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "6716a8f5afe131d981da5c656eda0be3a39617c8", "filename": "gcc/cp/method.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "patch": "@@ -497,7 +497,6 @@ static void\n do_build_copy_constructor (tree fndecl)\n {\n   tree parm = FUNCTION_FIRST_USER_PARM (fndecl);\n-  tree t;\n \n   parm = convert_from_reference (parm);\n \n@@ -507,7 +506,7 @@ do_build_copy_constructor (tree fndecl)\n        if *this is a base subobject.  */;\n   else if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type))\n     {\n-      t = build2 (INIT_EXPR, void_type_node, current_class_ref, parm);\n+      tree t = build2 (INIT_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n     }\n   else\n@@ -551,22 +550,20 @@ do_build_copy_constructor (tree fndecl)\n \n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n-\t  tree init;\n+\t  tree init = parm;\n \t  tree field = fields;\n \t  tree expr_type;\n \n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n \n-\t  init = parm;\n+\t  expr_type = TREE_TYPE (field);\n \t  if (DECL_NAME (field))\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n \t    }\n-\t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t   && ANON_AGGR_TYPE_P (t)\n-\t\t   && TYPE_FIELDS (t) != NULL_TREE)\n+\t  else if (ANON_AGGR_TYPE_P (expr_type) && TYPE_FIELDS (expr_type))\n \t    /* Just use the field; anonymous types can't have\n \t       nontrivial copy ctors or assignment ops.  */;\n \t  else\n@@ -577,14 +574,19 @@ do_build_copy_constructor (tree fndecl)\n \t     the field is \"T\", then the type will usually be \"const\n \t     T\".  (There are no cv-qualified variants of reference\n \t     types.)  */\n-\t  expr_type = TREE_TYPE (field);\n \t  if (TREE_CODE (expr_type) != REFERENCE_TYPE)\n-\t    expr_type = cp_build_qualified_type (expr_type, cvquals);\n+\t    {\n+\t      int quals = cvquals;\n+\t      \n+\t      if (DECL_MUTABLE_P (field))\n+\t\tquals &= ~TYPE_QUAL_CONST;\n+\t      expr_type = cp_build_qualified_type (expr_type, quals);\n+\t    }\n+\t  \n \t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \t  init = build_tree_list (NULL_TREE, init);\n \n-\t  member_init_list\n-\t    = tree_cons (field, init, member_init_list);\n+\t  member_init_list = tree_cons (field, init, member_init_list);\n \t}\n       finish_mem_initializers (member_init_list);\n     }\n@@ -639,52 +641,57 @@ do_build_assign_ref (tree fndecl)\n \t   fields; \n \t   fields = TREE_CHAIN (fields))\n \t{\n-\t  tree comp, init, t;\n+\t  tree comp = current_class_ref;\n+\t  tree init = parm;\n \t  tree field = fields;\n+\t  tree expr_type;\n+\t  int quals;\n \n \t  if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n \t    continue;\n \n-\t  if (CP_TYPE_CONST_P (TREE_TYPE (field)))\n+\t  expr_type = TREE_TYPE (field);\n+\t  \n+\t  if (CP_TYPE_CONST_P (expr_type))\n \t    {\n               error (\"non-static const member %q#D, can't use default \"\n                      \"assignment operator\", field);\n \t      continue;\n \t    }\n-\t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n+\t  else if (TREE_CODE (expr_type) == REFERENCE_TYPE)\n \t    {\n \t      error (\"non-static reference member %q#D, can't use \"\n                      \"default assignment operator\", field);\n \t      continue;\n \t    }\n \n-\t  comp = current_class_ref;\n-\t  init = parm;\n-\n \t  if (DECL_NAME (field))\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n \t    }\n-\t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t   && ANON_AGGR_TYPE_P (t)\n-\t\t   && TYPE_FIELDS (t) != NULL_TREE)\n+\t  else if (ANON_AGGR_TYPE_P (expr_type)\n+\t\t   && TYPE_FIELDS (expr_type) != NULL_TREE)\n \t    /* Just use the field; anonymous types can't have\n \t       nontrivial copy ctors or assignment ops.  */;\n \t  else\n \t    continue;\n \n-\t  comp = build3 (COMPONENT_REF, TREE_TYPE (field), comp, field,\n-\t\t\t NULL_TREE);\n-\t  init = build3 (COMPONENT_REF,\n-\t\t\t cp_build_qualified_type (TREE_TYPE (field), cvquals),\n-\t\t\t init, field, NULL_TREE);\n+\t  comp = build3 (COMPONENT_REF, expr_type, comp, field, NULL_TREE);\n+\t  \n+\t  /* Compute the type of init->field  */\n+\t  quals = cvquals;\n+\t  if (DECL_MUTABLE_P (field))\n+\t    quals &= ~TYPE_QUAL_CONST;\n+\t  expr_type = cp_build_qualified_type (expr_type, quals);\n+\t  \n+\t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \n \t  if (DECL_NAME (field))\n-\t    finish_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n+\t    init = build_modify_expr (comp, NOP_EXPR, init);\n \t  else\n-\t    finish_expr_stmt (build2 (MODIFY_EXPR, TREE_TYPE (comp), comp,\n-\t\t\t\t      init));\n+\t    init = build2 (MODIFY_EXPR, TREE_TYPE (comp), comp, init);\n+\t  finish_expr_stmt (init);\n \t}\n     }\n   finish_return_stmt (current_class_ref);"}, {"sha": "2633376c828dc3fcc66e8d42e398f67fad4e153e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "patch": "@@ -1,3 +1,8 @@\n+2004-12-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18975\n+\t* g++.dg/other/synth1.C: New.\n+\n 2004-12-21  James A. Morrison  <phython@gcc.gnu.org>\n \n \tPR c/18963"}, {"sha": "5829c6c78620aede867d84f4efd0b9c5f6d8e3b5", "filename": "gcc/testsuite/g++.dg/other/synth1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fsynth1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd749a603df6e9fb3c5b46f7d7db501cc3758efd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fsynth1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fsynth1.C?ref=fd749a603df6e9fb3c5b46f7d7db501cc3758efd", "patch": "@@ -0,0 +1,31 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 17 Dec 2004 <nathan@codesourcery.com>\n+\n+// PR 18975: Rejects legal\n+// Origin:   Wolfgang Roehrl <wolfgang.roehrl@de.gi-de.com>\n+\n+struct PTR\n+{\n+  PTR ();\n+  PTR (PTR&);\n+  PTR& operator= (PTR&);\n+  \n+private:\n+  PTR (const PTR&);\n+  PTR& operator= (const PTR&);\n+};\n+\n+\n+struct XYZ\n+{\n+  XYZ (PTR& p) : ptr(p) {}\n+\n+  mutable PTR ptr;\n+};\n+\n+\n+XYZ f1 ();\n+\n+\n+XYZ f2 (void) { return f1(); }\n+void f3 (XYZ& dst, const XYZ& src) { dst = src; }"}]}