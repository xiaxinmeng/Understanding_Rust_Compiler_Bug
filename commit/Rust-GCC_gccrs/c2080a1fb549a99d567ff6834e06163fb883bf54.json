{"sha": "c2080a1fb549a99d567ff6834e06163fb883bf54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIwODBhMWZiNTQ5YTk5ZDU2N2ZmNjgzNGUwNjE2M2ZiODgzYmY1NA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2019-05-22T18:53:37Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2019-05-22T18:53:37Z"}, "message": "x86: Don't allocate stack frame nor align stack if not needed\n\nget_frame_size () returns used stack slots during compilation, which\nmay be optimized out later.  This patch does the followings:\n\n1. Add stack_frame_required to machine_function to indicate that the\nfunction needs a stack frame.\n2. Change ix86_find_max_used_stack_alignment to set stack_frame_required.\n3. Always call ix86_find_max_used_stack_alignment to check if stack\nframe is needed.\n\nTested on i686 and x86-64 with\n\n--with-arch=native --with-cpu=native\n\nTested on AVX512 machine configured with\n\n--with-arch=native --with-cpu=native\n\ngcc/\n\n\tPR target/88483\n\t* config/i386/i386-options.c (ix86_init_machine_status): Set\n\tstack_frame_required to true.\n\t* config/i386/i386.c (ix86_get_frame_size): New function.\n\t(ix86_frame_pointer_required): Replace get_frame_size with\n\tix86_get_frame_size.\n\t(ix86_compute_frame_layout): Likewise.\n\t(ix86_find_max_used_stack_alignment): Changed to void.  Set\n\tstack_frame_required.\n\t(ix86_finalize_stack_frame_flags): Always call\n\tix86_find_max_used_stack_alignment.  Replace get_frame_size with\n\tix86_get_frame_size.\n\t* config/i386/i386.h (machine_function): Add stack_frame_required.\n\ngcc/testsuite/\n\n\tPR target/88483\n\t* gcc.target/i386/stackalign/pr88483-1.c: New test.\n\t* gcc.target/i386/stackalign/pr88483-2.c: Likewise.\n\nFrom-SVN: r271517", "tree": {"sha": "d22718b9405e0484f17f6470ef6f978b020b76bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d22718b9405e0484f17f6470ef6f978b020b76bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2080a1fb549a99d567ff6834e06163fb883bf54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2080a1fb549a99d567ff6834e06163fb883bf54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2080a1fb549a99d567ff6834e06163fb883bf54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2080a1fb549a99d567ff6834e06163fb883bf54/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "586e53e269d04c2806f0f6bb6a1aa5db81efc0d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586e53e269d04c2806f0f6bb6a1aa5db81efc0d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586e53e269d04c2806f0f6bb6a1aa5db81efc0d4"}], "stats": {"total": 115, "additions": 97, "deletions": 18}, "files": [{"sha": "5ee574683fc1f47eb66dce27dd9e79540ffc16ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -1,3 +1,19 @@\n+2019-05-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/88483\n+\t* config/i386/i386-options.c (ix86_init_machine_status): Set\n+\tstack_frame_required to true.\n+\t* config/i386/i386.c (ix86_get_frame_size): New function.\n+\t(ix86_frame_pointer_required): Replace get_frame_size with\n+\tix86_get_frame_size.\n+\t(ix86_compute_frame_layout): Likewise.\n+\t(ix86_find_max_used_stack_alignment): Changed to void.  Set\n+\tstack_frame_required.\n+\t(ix86_finalize_stack_frame_flags): Always call\n+\tix86_find_max_used_stack_alignment.  Replace get_frame_size with\n+\tix86_get_frame_size.\n+\t* config/i386/i386.h (machine_function): Add stack_frame_required.\n+\n 2019-05-22  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (sse_cvtpi2ps): Use TARGET_MMX in insn condition."}, {"sha": "0f2366260055b4a87b95cc42a9002b0bfe4dd515", "filename": "gcc/config/i386/i386-options.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Fconfig%2Fi386%2Fi386-options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Fconfig%2Fi386%2Fi386-options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.c?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -1537,6 +1537,7 @@ ix86_init_machine_status (void)\n \n   f = ggc_cleared_alloc<machine_function> ();\n   f->call_abi = ix86_abi;\n+  f->stack_frame_required = true;\n \n   return f;\n }"}, {"sha": "463e78112f061d014ee5479f9d04809f767b32e0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -5012,6 +5012,19 @@ ix86_can_use_return_insn_p (void)\n \t  && (frame.nregs + frame.nsseregs) == 0);\n }\n \f\n+/* Return stack frame size.  get_frame_size () returns used stack slots\n+   during compilation, which may be optimized out later.  If stack frame\n+   is needed, stack_frame_required should be true.  */\n+\n+static HOST_WIDE_INT\n+ix86_get_frame_size (void)\n+{\n+  if (cfun->machine->stack_frame_required)\n+    return get_frame_size ();\n+  else\n+    return 0;\n+}\n+\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may\n    be accessed via the stack pointer) in functions that seem suitable.  */\n@@ -5035,7 +5048,7 @@ ix86_frame_pointer_required (void)\n \n   /* Win64 SEH, very large frames need a frame-pointer as maximum stack\n      allocation is 4GB.  */\n-  if (TARGET_64BIT_MS_ABI && get_frame_size () > SEH_MAX_FRAME_SIZE)\n+  if (TARGET_64BIT_MS_ABI && ix86_get_frame_size () > SEH_MAX_FRAME_SIZE)\n     return true;\n \n   /* SSE saves require frame-pointer when stack is misaligned.  */\n@@ -5842,7 +5855,7 @@ ix86_compute_frame_layout (void)\n   unsigned HOST_WIDE_INT stack_alignment_needed;\n   HOST_WIDE_INT offset;\n   unsigned HOST_WIDE_INT preferred_alignment;\n-  HOST_WIDE_INT size = get_frame_size ();\n+  HOST_WIDE_INT size = ix86_get_frame_size ();\n   HOST_WIDE_INT to_allocate;\n \n   /* m->call_ms2sysv is initially enabled in ix86_expand_call for all 64-bit\n@@ -7436,11 +7449,11 @@ output_probe_stack_range (rtx reg, rtx end)\n   return \"\";\n }\n \n-/* Return true if stack frame is required.  Update STACK_ALIGNMENT\n-   to the largest alignment, in bits, of stack slot used if stack\n-   frame is required and CHECK_STACK_SLOT is true.  */\n+/* Set stack_frame_required to false if stack frame isn't required.\n+   Update STACK_ALIGNMENT to the largest alignment, in bits, of stack\n+   slot used if stack frame is required and CHECK_STACK_SLOT is true.  */\n \n-static bool\n+static void\n ix86_find_max_used_stack_alignment (unsigned int &stack_alignment,\n \t\t\t\t    bool check_stack_slot)\n {\n@@ -7489,7 +7502,7 @@ ix86_find_max_used_stack_alignment (unsigned int &stack_alignment,\n \t  }\n     }\n \n-  return require_stack_frame;\n+  cfun->machine->stack_frame_required = require_stack_frame;\n }\n \n /* Finalize stack_realign_needed and frame_pointer_needed flags, which\n@@ -7519,6 +7532,14 @@ ix86_finalize_stack_frame_flags (void)\n       return;\n     }\n \n+  /* It is always safe to compute max_used_stack_alignment.  We\n+     compute it only if 128-bit aligned load/store may be generated\n+     on misaligned stack slot which will lead to segfault. */\n+  bool check_stack_slot\n+    = (stack_realign || crtl->max_used_stack_slot_alignment >= 128);\n+  ix86_find_max_used_stack_alignment (stack_alignment,\n+\t\t\t\t      check_stack_slot);\n+\n   /* If the only reason for frame_pointer_needed is that we conservatively\n      assumed stack realignment might be needed or -fno-omit-frame-pointer\n      is used, but in the end nothing that needed the stack alignment had\n@@ -7538,12 +7559,11 @@ ix86_finalize_stack_frame_flags (void)\n \t   && flag_exceptions\n \t   && cfun->can_throw_non_call_exceptions)\n       && !ix86_frame_pointer_required ()\n-      && get_frame_size () == 0\n+      && ix86_get_frame_size () == 0\n       && ix86_nsaved_sseregs () == 0\n       && ix86_varargs_gpr_size + ix86_varargs_fpr_size == 0)\n     {\n-      if (ix86_find_max_used_stack_alignment (stack_alignment,\n-\t\t\t\t\t      stack_realign))\n+      if (cfun->machine->stack_frame_required)\n \t{\n \t  /* Stack frame is required.  If stack alignment needed is less\n \t     than incoming stack boundary, don't realign stack.  */\n@@ -7631,17 +7651,14 @@ ix86_finalize_stack_frame_flags (void)\n \t  recompute_frame_layout_p = true;\n \t}\n     }\n-  else if (crtl->max_used_stack_slot_alignment >= 128)\n+  else if (crtl->max_used_stack_slot_alignment >= 128\n+\t   && cfun->machine->stack_frame_required)\n     {\n       /* We don't need to realign stack.  max_used_stack_alignment is\n \t used to decide how stack frame should be aligned.  This is\n-\t independent of any psABIs nor 32-bit vs 64-bit.  It is always\n-\t safe to compute max_used_stack_alignment.  We compute it only\n-\t if 128-bit aligned load/store may be generated on misaligned\n-\t stack slot which will lead to segfault.   */\n-      if (ix86_find_max_used_stack_alignment (stack_alignment, true))\n-\tcfun->machine->max_used_stack_alignment\n-\t  = stack_alignment / BITS_PER_UNIT;\n+\t independent of any psABIs nor 32-bit vs 64-bit.  */\n+      cfun->machine->max_used_stack_alignment\n+\t= stack_alignment / BITS_PER_UNIT;\n     }\n \n   if (crtl->stack_realign_needed != stack_realign)"}, {"sha": "7852c766f7707ff3fc7b6240297923c3185cd1f1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -2754,6 +2754,9 @@ struct GTY(()) machine_function {\n   /* If true, ENDBR is queued at function entrance.  */\n   BOOL_BITFIELD endbr_queued_at_entrance : 1;\n \n+  /* True if the function needs a stack frame.  */\n+  BOOL_BITFIELD stack_frame_required : 1;\n+\n   /* The largest alignment, in bytes, of stack slot actually used.  */\n   unsigned int max_used_stack_alignment;\n "}, {"sha": "86ef3b608863b2821b86ab3deceecdfc23967a14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -1,3 +1,9 @@\n+2019-05-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/88483\n+\t* gcc.target/i386/stackalign/pr88483-1.c: New test.\n+\t* gcc.target/i386/stackalign/pr88483-2.c: Likewise.\n+\n 2019-05-22  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* gfortran.dg/coarray_lock_7.f90: Fix output patterns."}, {"sha": "c8bb0832fe26d359582239c16770e219b64f6ccb", "filename": "gcc/testsuite/gcc.target/i386/stackalign/pr88483-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Fpr88483-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Fpr88483-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Fpr88483-1.c?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx2\" } */\n+\n+struct B\n+{\n+  char a[12];\n+  int b;\n+};\n+\n+struct B\n+f2 (void)\n+{\n+  struct B x = {};\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"(sub|add)(l|q)\\[\\\\t \\]*\\\\$\\[0-9\\]*,\\[\\\\t \\]*%\\[re\\]?sp\" } } */\n+/* { dg-final { scan-assembler-not \"and\\[lq\\]?\\[^\\\\n\\]*-\\[0-9\\]+,\\[^\\\\n\\]*sp\" } } */"}, {"sha": "e94fa1d18fad5f04e9c80714e8bfb3a32f72fde6", "filename": "gcc/testsuite/gcc.target/i386/stackalign/pr88483-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Fpr88483-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2080a1fb549a99d567ff6834e06163fb883bf54/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Fpr88483-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstackalign%2Fpr88483-2.c?ref=c2080a1fb549a99d567ff6834e06163fb883bf54", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx512f\" } */\n+\n+struct B\n+{\n+  char a[12];\n+  int b;\n+};\n+\n+struct B\n+f2 (void)\n+{\n+  struct B x = {};\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"(sub|add)(l|q)\\[\\\\t \\]*\\\\$\\[0-9\\]*,\\[\\\\t \\]*%\\[re\\]?sp\" } } */\n+/* { dg-final { scan-assembler-not \"and\\[lq\\]?\\[^\\\\n\\]*-\\[0-9\\]+,\\[^\\\\n\\]*sp\" } } */"}]}