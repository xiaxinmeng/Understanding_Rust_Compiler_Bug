{"sha": "7a0a1f09c46d945c469b5830a74a7ac6369b673b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EwYTFmMDljNDZkOTQ1YzQ2OWI1ODMwYTc0YTdhYzYzNjliNjczYg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "1998-02-14T05:14:13Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "1998-02-14T05:14:13Z"}, "message": "arm.md (movsfcc): Also validate operands[3] when compiling hard float.\n\n* arm.md (movsfcc): Also validate operands[3] when compiling hard float.\n(movdfcc): Only accept fpu_add_operand for operands[3].\n\nFrom-SVN: r17974", "tree": {"sha": "944554f4e70a508a8bc5df8610840a9f0fe169f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/944554f4e70a508a8bc5df8610840a9f0fe169f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a0a1f09c46d945c469b5830a74a7ac6369b673b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0a1f09c46d945c469b5830a74a7ac6369b673b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a0a1f09c46d945c469b5830a74a7ac6369b673b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0a1f09c46d945c469b5830a74a7ac6369b673b/comments", "author": null, "committer": null, "parents": [{"sha": "29a820586a2920fa8a8197a456ce7134e6fa6c89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a820586a2920fa8a8197a456ce7134e6fa6c89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a820586a2920fa8a8197a456ce7134e6fa6c89"}], "stats": {"total": 245, "additions": 169, "deletions": 76}, "files": [{"sha": "df8af471a5ce2d4588454bba3797f2c8865ae5c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0a1f09c46d945c469b5830a74a7ac6369b673b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0a1f09c46d945c469b5830a74a7ac6369b673b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a0a1f09c46d945c469b5830a74a7ac6369b673b", "patch": "@@ -1,3 +1,9 @@\n+Sat Feb 14 05:08:21 1998  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.md (movsfcc): Also validate operands[3] when compiling hard\n+\tfloat.\n+\t(movdfcc): Only accept fpu_add_operand for operands[3].\n+\n Sat Feb 14 02:02:41 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* varasm.c (output_constant_pool): Bring back 'done' label inside"}, {"sha": "ec70983d6eeb49e87fd9c51159236e92aa6a33be", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 163, "deletions": 76, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0a1f09c46d945c469b5830a74a7ac6369b673b/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0a1f09c46d945c469b5830a74a7ac6369b673b/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=7a0a1f09c46d945c469b5830a74a7ac6369b673b", "patch": "@@ -1,7 +1,7 @@\n ;;- Machine description for Advanced RISC Machines' ARM for GNU compiler\n ;;  Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n ;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n-;;             and Martin Simmons (@harleqn.co.uk).\n+;;  and Martin Simmons (@harleqn.co.uk).\n ;;  More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n \n ;; This file is part of GNU CC.\n@@ -859,6 +859,34 @@\n   \"umull%?\\\\t%Q0, %R0, %1, %2\"\n [(set_attr \"type\" \"mult\")])\n \n+(define_insn \"smulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r,&r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (sign_extend:DI\n+\t\t    (match_operand:SI 1 \"s_register_operand\" \"%r,0\"))\n+\t\t   (sign_extend:DI\n+\t\t    (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n+\t  (const_int 32))))\n+   (clobber (match_scratch:SI 3 \"=&r,&r\"))]\n+  \"arm_fast_multiply\"\n+  \"smull%?\\\\t%3, %0, %2, %1\"\n+[(set_attr \"type\" \"mult\")])\n+\n+(define_insn \"umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r,&r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (zero_extend:DI\n+\t\t    (match_operand:SI 1 \"s_register_operand\" \"%r,0\"))\n+\t\t   (zero_extend:DI\n+\t\t    (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n+\t  (const_int 32))))\n+   (clobber (match_scratch:SI 3 \"=&r,&r\"))]\n+  \"arm_fast_multiply\"\n+  \"umull%?\\\\t%3, %0, %2, %1\"\n+[(set_attr \"type\" \"mult\")])\n+\n (define_insn \"mulsf3\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"f\")\n@@ -1180,7 +1208,21 @@\n   \"\n {\n   HOST_WIDE_INT mask = (((HOST_WIDE_INT)1) << INTVAL (operands[1])) - 1;\n+  rtx target, subtarget;\n \n+  target = operands[0];\n+  /* Avoid using a subreg as a subtarget, and avoid writing a paradoxical \n+     subreg as the final target.  */\n+  if (GET_CODE (target) == SUBREG)\n+    {\n+      subtarget = gen_reg_rtx (SImode);\n+      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (target)))\n+\t  < GET_MODE_SIZE (SImode))\n+        target = SUBREG_REG (target);\n+    }\n+  else\n+    subtarget = target;    \n+    \n   if (GET_CODE (operands[3]) == CONST_INT)\n     {\n       /* Since we are inserting a known constant, we may be able to\n@@ -1191,7 +1233,7 @@\n \t\t\t     << INTVAL (operands[2]));\n \n       emit_insn (gen_andsi3 (op1, operands[0], GEN_INT (~mask2)));\n-      emit_insn (gen_iorsi3 (operands[0], op1,\n+      emit_insn (gen_iorsi3 (subtarget, op1,\n \t\t\t     GEN_INT (INTVAL (operands[3])\n \t\t\t\t      << INTVAL (operands[2]))));\n     }\n@@ -1212,7 +1254,7 @@\n       emit_insn (gen_iorsi3 (op1, gen_rtx (LSHIFTRT, SImode, operands[0],\n \t\t\t\t\t   operands[1]),\n \t\t\t     op0));\n-      emit_insn (gen_rotlsi3 (operands[0], op1, operands[1]));\n+      emit_insn (gen_rotlsi3 (subtarget, op1, operands[1]));\n     }\n   else if ((INTVAL (operands[1]) + INTVAL (operands[2]) == 32)\n \t   && ! (const_ok_for_arm (mask)\n@@ -1226,8 +1268,9 @@\n       emit_insn (gen_ashlsi3 (op0, operands[3],\n \t\t\t      GEN_INT (32 - INTVAL (operands[1]))));\n       emit_insn (gen_ashlsi3 (op1, operands[0], operands[1]));\n-      emit_insn (gen_iorsi3 (operands[0], gen_rtx (LSHIFTRT, SImode, op1,\n-\t\t\t\t\t\t   operands[1]), op0));\n+      emit_insn (gen_iorsi3 (subtarget,\n+\t\t\t     gen_rtx (LSHIFTRT, SImode, op1,\n+\t\t\t\t      operands[1]), op0));\n     }\n   else\n     {\n@@ -1270,7 +1313,17 @@\n       if (INTVAL (operands[2]) != 0)\n \top1 = gen_rtx (ASHIFT, SImode, op1, operands[2]);\n \n-      emit_insn (gen_iorsi3 (operands[0], op1, op2));\n+      emit_insn (gen_iorsi3 (subtarget, op1, op2));\n+    }\n+\n+  if (subtarget != target)\n+    {\n+      /* If TARGET is still a SUBREG, then it must be wider than a word,\n+\t so we must be careful only to set the subword we were asked to. */\n+      if (GET_CODE (target) == SUBREG)\n+\temit_move_insn (target, subtarget);\n+      else\n+\temit_move_insn (target, gen_lowpart (GET_MODE (target), subtarget));\n     }\n \n   DONE;\n@@ -2551,45 +2604,47 @@\n \n (define_expand \"storehi\"\n   [;; store the low byte\n-   (set (mem:QI (match_operand:SI 1 \"\" \"\")) (match_dup 3))\n+   (set (match_operand 1 \"\" \"\") (match_dup 3))\n    ;; extract the high byte\n    (set (match_dup 2)\n \t(ashiftrt:SI (match_operand 0 \"\" \"\") (const_int 8)))\n    ;; store the high byte\n-   (set (mem:QI (match_dup 4))\n-\t(subreg:QI (match_dup 2) 0))]\t;explicit subreg safe\n+   (set (match_dup 4) (subreg:QI (match_dup 2) 0))]\t;explicit subreg safe\n   \"\"\n   \"\n {\n-  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx addr = XEXP (operands[1], 0);\n+  enum rtx_code code = GET_CODE (addr);\n \n-  if ((code == PLUS || code == MINUS)\n-      && (GET_CODE (XEXP (operands[1], 1)) == REG\n-\t  || GET_CODE (XEXP (operands[1], 0)) != REG))\n-    operands[1] = force_reg (SImode, operands[1]);\n-  operands[4] = plus_constant (operands[1], 1);\n+  if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+      || code == MINUS)\n+    addr = force_reg (SImode, addr);\n+\n+  operands[4] = change_address (operands[1], QImode, plus_constant (addr, 1));\n+  operands[1] = change_address (operands[1], QImode, NULL_RTX);\n   operands[3] = gen_lowpart (QImode, operands[0]);\n   operands[0] = gen_lowpart (SImode, operands[0]);\n   operands[2] = gen_reg_rtx (SImode); \n }\n \")\n \n (define_expand \"storehi_bigend\"\n-  [(set (mem:QI (match_dup 4)) (match_dup 3))\n+  [(set (match_dup 4) (match_dup 3))\n    (set (match_dup 2)\n \t(ashiftrt:SI (match_operand 0 \"\" \"\") (const_int 8)))\n-   (set (mem:QI (match_operand 1 \"\" \"\"))\n-\t(subreg:QI (match_dup 2) 0))]\n+   (set (match_operand 1 \"\" \"\")\t(subreg:QI (match_dup 2) 0))]\n   \"\"\n   \"\n {\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  if ((code == PLUS || code == MINUS)\n-      && (GET_CODE (XEXP (operands[1], 1)) == REG\n-\t  || GET_CODE (XEXP (operands[1], 0)) != REG))\n-    operands[1] = force_reg (SImode, operands[1]);\n+  rtx addr = XEXP (operands[1], 0);\n+  enum rtx_code code = GET_CODE (addr);\n+\n+  if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+      || code == MINUS)\n+    addr = force_reg (SImode, addr);\n \n-  operands[4] = plus_constant (operands[1], 1);\n+  operands[4] = change_address (operands[1], QImode, plus_constant (addr, 1));\n+  operands[1] = change_address (operands[1], QImode, NULL_RTX);\n   operands[3] = gen_lowpart (QImode, operands[0]);\n   operands[0] = gen_lowpart (SImode, operands[0]);\n   operands[2] = gen_reg_rtx (SImode);\n@@ -2598,19 +2653,19 @@\n \n ;; Subroutine to store a half word integer constant into memory.\n (define_expand \"storeinthi\"\n-  [(set (mem:QI (match_operand:SI 0 \"\" \"\"))\n+  [(set (match_operand 0 \"\" \"\")\n \t(subreg:QI (match_operand 1 \"\" \"\") 0))\n-   (set (mem:QI (match_dup 3)) (subreg:QI (match_dup 2) 0))]\n+   (set (match_dup 3) (subreg:QI (match_dup 2) 0))]\n   \"\"\n   \"\n {\n   HOST_WIDE_INT value = INTVAL (operands[1]);\n-  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx addr = XEXP (operands[0], 0);\n+  enum rtx_code code = GET_CODE (addr);\n \n-  if ((code == PLUS || code == MINUS)\n-      && (GET_CODE (XEXP (operands[0], 1)) == REG\n-\t  || GET_CODE (XEXP (operands[0], 0)) != REG))\n-  operands[0] = force_reg (SImode, operands[0]);\n+  if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+      || code == MINUS)\n+    addr = force_reg (SImode, addr);\n \n   operands[1] = gen_reg_rtx (SImode);\n   if (BYTES_BIG_ENDIAN)\n@@ -2636,7 +2691,8 @@\n \t}\n     }\n \n-  operands[3] = plus_constant (operands[0], 1);\n+  operands[3] = change_address (operands[0], QImode, plus_constant (addr, 1));\n+  operands[0] = change_address (operands[0], QImode, NULL_RTX);\n }\n \")\n \n@@ -2667,16 +2723,15 @@\n \t      DONE;\n \t    }\n \t  if (GET_CODE (operands[1]) == CONST_INT)\n-\t    emit_insn (gen_storeinthi (XEXP (operands[0], 0), operands[1]));\n+\t    emit_insn (gen_storeinthi (operands[0], operands[1]));\n \t  else\n \t    {\n \t      if (GET_CODE (operands[1]) == MEM)\n \t\toperands[1] = force_reg (HImode, operands[1]);\n \t      if (BYTES_BIG_ENDIAN)\n-\t\temit_insn (gen_storehi_bigend (operands[1],\n-\t\t\t\t\t       XEXP (operands[0], 0)));\n+\t\temit_insn (gen_storehi_bigend (operands[1], operands[0]));\n \t      else\n-\t\temit_insn (gen_storehi (operands[1], XEXP (operands[0], 0)));\n+\t\temit_insn (gen_storehi (operands[1], operands[0]));\n \t    }\n \t  DONE;\n \t}\n@@ -3152,9 +3207,10 @@\n     FAIL;\n \n   operands[3]\n-            = arm_gen_load_multiple (REGNO (operands[0]), INTVAL (operands[2]),\n-                                     force_reg (SImode, XEXP (operands[1], 0)),\n-                                     TRUE, FALSE);\n+    = arm_gen_load_multiple (REGNO (operands[0]), INTVAL (operands[2]),\n+\t\t\t     force_reg (SImode, XEXP (operands[1], 0)),\n+\t\t\t     TRUE, FALSE, RTX_UNCHANGING_P(operands[1]),\n+\t\t\t     MEM_IN_STRUCT_P(operands[1]));\n \")\n \n ;; Load multiple with write-back\n@@ -3221,9 +3277,10 @@\n     FAIL;\n \n   operands[3]\n-           = arm_gen_store_multiple (REGNO (operands[1]), INTVAL (operands[2]),\n-                                     force_reg (SImode, XEXP (operands[0], 0)),\n-                                     TRUE, FALSE);\n+    = arm_gen_store_multiple (REGNO (operands[1]), INTVAL (operands[2]),\n+\t\t\t      force_reg (SImode, XEXP (operands[0], 0)),\n+\t\t\t      TRUE, FALSE, RTX_UNCHANGING_P (operands[0]),\n+\t\t\t      MEM_IN_STRUCT_P(operands[0]));\n \")\n \n ;; Store multiple with write-back\n@@ -3859,8 +3916,16 @@\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx ccreg = gen_compare_reg (code, arm_compare_op0, arm_compare_op1,\n-\t\t\t       arm_compare_fp);\n+  rtx ccreg;\n+\n+  /* When compiling for SOFT_FLOAT, ensure both arms are in registers. \n+     Otherwise, ensure it is a valid FP add operand */\n+  if ((! TARGET_HARD_FLOAT)\n+      || (! fpu_add_operand (operands[3], SFmode)))\n+    operands[3] = force_reg (SFmode, operands[3]);\n+\n+  ccreg = gen_compare_reg (code, arm_compare_op0, arm_compare_op1,\n+\t\t\t   arm_compare_fp);\n \n   operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n }\")\n@@ -3869,7 +3934,7 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n \t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:DF 2 \"s_register_operand\" \"\")\n-\t\t\t (match_operand:DF 3 \"nonmemory_operand\" \"\")))]\n+\t\t\t (match_operand:DF 3 \"fpu_add_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -3881,57 +3946,77 @@\n }\")\n \n (define_insn \"*movsicc_insn\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r,r,r\")\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r,r,r,r,r\")\n \t(if_then_else:SI\n \t (match_operator 3 \"comparison_operator\"\n \t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t (match_operand:SI 1 \"arm_not_operand\" \"0,0,?rI,?rI,K,K\")\n-\t (match_operand:SI 2 \"arm_not_operand\" \"rI,K,rI,K,rI,K\")))]\n+\t (match_operand:SI 1 \"arm_not_operand\" \"0,0,rI,K,rI,rI,K,K\")\n+\t (match_operand:SI 2 \"arm_not_operand\" \"rI,K,0,0,rI,K,rI,K\")))]\n   \"\"\n   \"@\n    mov%D3\\\\t%0, %2\n    mvn%D3\\\\t%0, #%B2\n+   mov%d3\\\\t%0, %1\n+   mvn%d3\\\\t%0, #%B1\n    mov%d3\\\\t%0, %1\\;mov%D3\\\\t%0, %2\n    mov%d3\\\\t%0, %1\\;mvn%D3\\\\t%0, #%B2\n    mvn%d3\\\\t%0, #%B1\\;mov%D3\\\\t%0, %2\n    mvn%d3\\\\t%0, #%B1\\;mvn%D3\\\\t%0, #%B2\"\n-  [(set_attr \"length\" \"4,4,8,8,8,8\")\n+  [(set_attr \"length\" \"4,4,4,4,8,8,8,8\")\n    (set_attr \"conds\" \"use\")])\n \n (define_insn \"*movsfcc_hard_insn\"\n-  [(set (match_operand:SF 0 \"s_register_operand\" \"=f,f\")\n-\t(if_then_else:SF (match_operator 3 \"comparison_operator\" \n-\t\t\t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t\t\t (match_operand:SF 1 \"s_register_operand\" \"0,0\")\n-\t\t\t (match_operand:SF 2 \"fpu_add_operand\" \"fG,H\")))]\n+  [(set (match_operand:SF 0 \"s_register_operand\" \"=f,f,f,f,f,f,f,f\")\n+\t(if_then_else:SF\n+\t (match_operator 3 \"comparison_operator\" \n+\t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n+\t (match_operand:SF 1 \"fpu_add_operand\" \"0,0,fG,H,fG,fG,H,H\")\n+\t (match_operand:SF 2 \"fpu_add_operand\" \"fG,H,0,0,fG,H,fG,H\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    mvf%D3s\\\\t%0, %2\n-   mnf%D3s\\\\t%0, #%N2\"\n-  [(set_attr \"type\" \"ffarith\")\n+   mnf%D3s\\\\t%0, #%N2\n+   mvf%d3s\\\\t%0, %1\n+   mnf%d3s\\\\t%0, #%N1\n+   mvf%d3s\\\\t%0, %1\\;mvf%D3s\\\\t%0, %2\n+   mvf%d3s\\\\t%0, %1\\;mnf%D3s\\\\t%0, #%N2\n+   mnf%d3s\\\\t%0, #%N1\\;mvf%D3s\\\\t%0, %2\n+   mnf%d3s\\\\t%0, #%N1\\;mnf%D3s\\\\t%0, #%N2\"\n+  [(set_attr \"length\" \"4,4,4,4,8,8,8,8\")\n+   (set_attr \"type\" \"ffarith\")\n    (set_attr \"conds\" \"use\")])\n \n (define_insn \"*movsfcc_soft_insn\"\n-  [(set (match_operand:SF 0 \"s_register_operand\" \"=r\")\n+  [(set (match_operand:SF 0 \"s_register_operand\" \"=r,r\")\n \t(if_then_else:SF (match_operator 3 \"comparison_operator\"\n \t\t\t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t\t\t (match_operand:SF 1 \"s_register_operand\" \"0\")\n-\t\t\t (match_operand:SF 2 \"s_register_operand\" \"r\")))]\n+\t\t\t (match_operand:SF 1 \"s_register_operand\" \"0,r\")\n+\t\t\t (match_operand:SF 2 \"s_register_operand\" \"r,0\")))]\n   \"TARGET_SOFT_FLOAT\"\n-  \"mov%D3\\\\t%0, %2\"\n+  \"@\n+   mov%D3\\\\t%0, %2\n+   mov%d3\\\\t%0, %1\"\n   [(set_attr \"conds\" \"use\")])\n \n (define_insn \"*movdfcc_insn\"\n-  [(set (match_operand:DF 0 \"s_register_operand\" \"=f,f\")\n-\t(if_then_else:DF (match_operator 3 \"comparison_operator\"\n-\t\t\t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n-\t\t\t (match_operand:DF 1 \"s_register_operand\" \"0,0\")\n-\t\t\t (match_operand:DF 2 \"fpu_add_operand\" \"fG,H\")))]\n+  [(set (match_operand:DF 0 \"s_register_operand\" \"=f,f,f,f,f,f,f,f\")\n+\t(if_then_else:DF\n+\t (match_operator 3 \"comparison_operator\"\n+\t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n+\t (match_operand:DF 1 \"fpu_add_operand\" \"0,0,fG,H,fG,fG,H,H\")\n+\t (match_operand:DF 2 \"fpu_add_operand\" \"fG,H,0,0,fG,H,fG,H\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    mvf%D3d\\\\t%0, %2\n-   mnf%D3d\\\\t%0, #%N2\"\n-  [(set_attr \"type\" \"ffarith\")\n+   mnf%D3d\\\\t%0, #%N2\n+   mvf%d3d\\\\t%0, %1\n+   mnf%d3d\\\\t%0, #%N1\n+   mvf%d3d\\\\t%0, %1\\;mvf%D3d\\\\t%0, %2\n+   mvf%d3d\\\\t%0, %1\\;mnf%D3d\\\\t%0, #%N2\n+   mnf%d3d\\\\t%0, #%N1\\;mvf%D3d\\\\t%0, %2\n+   mnf%d3d\\\\t%0, #%N1\\;mnf%D3d\\\\t%0, #%N2\"\n+  [(set_attr \"length\" \"4,4,4,4,8,8,8,8\")\n+   (set_attr \"type\" \"ffarith\")\n    (set_attr \"conds\" \"use\")])\n \f\n ;; Jump and linkage insns\n@@ -4158,14 +4243,17 @@\n   DONE;\n }\")\n \n+;; The USE in this pattern is needed to tell flow analysis that this is\n+;; a CASESI insn.  It has no other purpose.\n (define_insn \"casesi_internal\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (leu (match_operand:SI 0 \"s_register_operand\" \"r\")\n-\t      (match_operand:SI 1 \"arm_rhs_operand\" \"rI\"))\n-\t (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))\n-\t\t\t  (label_ref (match_operand 2 \"\" \"\"))))\n-\t (label_ref (match_operand 3 \"\" \"\"))))]\n+  [(parallel [(set (pc)\n+\t       (if_then_else\n+\t\t(leu (match_operand:SI 0 \"s_register_operand\" \"r\")\n+\t\t     (match_operand:SI 1 \"arm_rhs_operand\" \"rI\"))\n+\t\t(mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))\n+\t\t\t\t (label_ref (match_operand 2 \"\" \"\"))))\n+\t\t(label_ref (match_operand 3 \"\" \"\"))))\n+\t      (use (label_ref (match_dup 2)))])]\n   \"\"\n   \"*\n   if (flag_pic)\n@@ -5663,8 +5751,7 @@\n   \"sub%?s\\\\t%0, %1, #0\"\n [(set_attr \"conds\" \"set\")])\n \n-; Peepholes to spot possible load- and store-multiples, if the ordering is\n-; reversed, check that the memory references aren't volatile.\n+; Peepholes to spot possible load- and store-multiples.\n \n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")"}]}