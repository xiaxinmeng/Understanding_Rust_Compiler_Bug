{"sha": "dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNlMmIyZjZjYjM0YTRmNTNmZjViZWRhYzY3MmIzYTExMzU1MmI1NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-08-29T11:43:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-08-29T11:43:22Z"}, "message": "common.opt (ftree-store-ccp): Mark as preserved for backward compatibility.\n\n2008-08-29  Richard Guenther  <rguenther@suse.de>\n\n\t* common.opt (ftree-store-ccp): Mark as preserved for\n\tbackward compatibility.\n\t* doc/invoke.texi (-ftree-store-ccp): Remove documentation.\n\t* tree-pass.h (pass_store_ccp): Remove.\n\t* tree-ssa-propagate.h (struct prop_value_d): Remove mem_ref field.\n\t(first_vdef): Remove declaration.\n\t(get_value_loaded_by): Likewise.\n\t* tree-ssa-ccp.c (do_store_ccp): Remove.\n\t(get_default_value): Simplify as do_store_ccp is always false\n\tnow.  Do not initialize mem_ref.\n\t(set_value_varying): Likewise.\n\t(canonicalize_float_value): Likewise.\n\t(set_lattice_value): Likewise.\n\t(likely_value): Likewise.\n\t(surely_varying_stmt_p): Likewise.\n\t(ccp_initialize): Likewise.\n\t(ccp_lattice_meet): Likewise.\n\t(ccp_visit_phi_node): Likewise.\n\t(ccp_fold): Likewise.\n\t(evaluate_stmt): Likewise.\n\t(visit_assignment): Likewise.\n\t(ccp_visit_stmt): Likewise.\n\t(execute_ssa_ccp): Fold into ...\n\t(do_ssa_ccp): ... this.\n\t(do_ssa_store_ccp): Remove.\n\t(gate_store_ccp): Likewise.\n\t(pass_store_ccp): Likewise.\n\t* tree-ssa-copy.c (copy_prop_visit_phi_node): Do not\n\tinitialize mem_ref.\n\t* tree-ssa-propagate.c (first_vdef): Remove.\n\t(get_value_loaded_by): Likewise.\n\t(replace_vuses_in): Likewise.\n\t(substitute_and_fold): Do not call replace_vuses_in.\n\t* opts.c (decode_options): Do not set flag_tree_store_ccp.\n\nFrom-SVN: r139764", "tree": {"sha": "e8b45c160b843a80f4ad20003cdaef3857a01573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8b45c160b843a80f4ad20003cdaef3857a01573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "443aa7d5764a1786880bf6d10f522f5e3cfe2795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/443aa7d5764a1786880bf6d10f522f5e3cfe2795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/443aa7d5764a1786880bf6d10f522f5e3cfe2795"}], "stats": {"total": 412, "additions": 56, "deletions": 356}, "files": [{"sha": "1321645e9e00447fb25b11983965ceda07bb521b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -1,3 +1,40 @@\n+2008-08-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* common.opt (ftree-store-ccp): Mark as preserved for\n+\tbackward compatibility.\n+\t* doc/invoke.texi (-ftree-store-ccp): Remove documentation.\n+\t* tree-pass.h (pass_store_ccp): Remove.\n+\t* tree-ssa-propagate.h (struct prop_value_d): Remove mem_ref field.\n+\t(first_vdef): Remove declaration.\n+\t(get_value_loaded_by): Likewise.\n+\t* tree-ssa-ccp.c (do_store_ccp): Remove.\n+\t(get_default_value): Simplify as do_store_ccp is always false\n+\tnow.  Do not initialize mem_ref.\n+\t(set_value_varying): Likewise.\n+\t(canonicalize_float_value): Likewise.\n+\t(set_lattice_value): Likewise.\n+\t(likely_value): Likewise.\n+\t(surely_varying_stmt_p): Likewise.\n+\t(ccp_initialize): Likewise.\n+\t(ccp_lattice_meet): Likewise.\n+\t(ccp_visit_phi_node): Likewise.\n+\t(ccp_fold): Likewise.\n+\t(evaluate_stmt): Likewise.\n+\t(visit_assignment): Likewise.\n+\t(ccp_visit_stmt): Likewise.\n+\t(execute_ssa_ccp): Fold into ...\n+\t(do_ssa_ccp): ... this.\n+\t(do_ssa_store_ccp): Remove.\n+\t(gate_store_ccp): Likewise.\n+\t(pass_store_ccp): Likewise.\n+\t* tree-ssa-copy.c (copy_prop_visit_phi_node): Do not\n+\tinitialize mem_ref.\n+\t* tree-ssa-propagate.c (first_vdef): Remove.\n+\t(get_value_loaded_by): Likewise.\n+\t(replace_vuses_in): Likewise.\n+\t(substitute_and_fold): Do not call replace_vuses_in.\n+\t* opts.c (decode_options): Do not set flag_tree_store_ccp.\n+\n 2008-08-29  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/37236"}, {"sha": "b2c66433f562783df6997829cde268df0115a22a", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -1111,8 +1111,8 @@ Common Report Var(flag_tree_ccp) Optimization\n Enable SSA-CCP optimization on trees\n \n ftree-store-ccp\n-Common Report Var(flag_tree_store_ccp) Optimization\n-Enable SSA-CCP optimization for stores and loads\n+Common\n+Does nothing.  Preserved for backward compatibility.\n \n ftree-ch\n Common Report Var(flag_tree_ch) Optimization"}, {"sha": "64b6a40f6c1cdc5fbec27c08c1e2c843ecb9df8b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -365,7 +365,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-loop-distribution @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-reassoc @gol\n--ftree-sink -ftree-sra -ftree-store-ccp -ftree-switch-conversion @gol\n+-ftree-sink -ftree-sra -ftree-switch-conversion @gol\n -ftree-ter -ftree-vect-loop-version -ftree-vectorize -ftree-vrp @gol\n -funit-at-a-time -funroll-all-loops -funroll-loops @gol\n -funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol\n@@ -5938,13 +5938,6 @@ Perform sparse conditional constant propagation (CCP) on trees.  This\n pass only operates on local scalar variables and is enabled by default\n at @option{-O} and higher.\n \n-@item -ftree-store-ccp\n-@opindex ftree-store-ccp\n-Perform sparse conditional constant propagation (CCP) on trees.  This\n-pass operates on both local scalar variables and memory stores and\n-loads (global variables, structures, arrays, etc).  This flag is\n-enabled by default at @option{-O2} and higher.\n-\n @item -ftree-switch-conversion\n Perform conversion of simple initializations in a switch to\n initializations from a scalar array.  This flag is enabled by default"}, {"sha": "898f1fbad7346e8f1ccd14a897b5236ec4d79908", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -951,14 +951,13 @@ decode_options (unsigned int argc, const char **argv)\n   flag_delete_null_pointer_checks = opt2;\n   flag_reorder_blocks = opt2;\n   flag_reorder_functions = opt2;\n-  flag_tree_store_ccp = opt2;\n   flag_tree_vrp = opt2;\n   flag_tree_builtin_call_dce = opt2;\n   flag_tree_pre = opt2;\n   flag_tree_switch_conversion = 1;\n   flag_ipa_cp = opt2;\n \n-      /* Allow more virtual operators to increase alias precision.  */\n+  /* Allow more virtual operators to increase alias precision.  */\n \n   set_param_value (\"max-aliased-vops\",\n \t\t   (opt2) ? 500 : initial_max_aliased_vops);"}, {"sha": "a3c9b26813f9c484425ebbfd42287cbc705ef90c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -380,7 +380,6 @@ extern struct gimple_opt_pass pass_fre;\n extern struct gimple_opt_pass pass_linear_transform;\n extern struct gimple_opt_pass pass_check_data_deps;\n extern struct gimple_opt_pass pass_copy_prop;\n-extern struct gimple_opt_pass pass_store_ccp;\n extern struct gimple_opt_pass pass_vrp;\n extern struct gimple_opt_pass pass_uncprop;\n extern struct gimple_opt_pass pass_return_slot;"}, {"sha": "870a244ac6dcb38bd47fe2f1b4fc459d27cade87", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 9, "deletions": 154, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -227,9 +227,6 @@ typedef enum\n    doing the store).  */\n static prop_value_t *const_val;\n \n-/* True if we are also propagating constants in stores and loads.  */\n-static bool do_store_ccp;\n-\n /* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */\n \n static void\n@@ -321,10 +318,10 @@ static prop_value_t\n get_default_value (tree var)\n {\n   tree sym = SSA_NAME_VAR (var);\n-  prop_value_t val = { UNINITIALIZED, NULL_TREE, NULL_TREE };\n+  prop_value_t val = { UNINITIALIZED, NULL_TREE };\n   tree cst_val;\n   \n-  if (!do_store_ccp && !is_gimple_reg (var))\n+  if (!is_gimple_reg (var))\n     {\n       /* Short circuit for regular CCP.  We are not interested in any\n \t non-register when DO_STORE_CCP is false.  */\n@@ -336,7 +333,6 @@ get_default_value (tree var)\n \t initial value.  */\n       val.lattice_val = CONSTANT;\n       val.value = cst_val;\n-      val.mem_ref = sym;\n     }\n   else\n     {\n@@ -401,7 +397,6 @@ set_value_varying (tree var)\n \n   val->lattice_val = VARYING;\n   val->value = NULL_TREE;\n-  val->mem_ref = NULL_TREE;\n }\n \n /* For float types, modify the value of VAL to make ccp work correctly\n@@ -447,7 +442,6 @@ canonicalize_float_value (prop_value_t *val)\n     {\n       val->lattice_val = UNDEFINED;\n       val->value = NULL;\n-      val->mem_ref = NULL;\n       return;\n     }\n }\n@@ -469,8 +463,7 @@ set_lattice_value (tree var, prop_value_t new_val)\n   gcc_assert (old_val->lattice_val < new_val.lattice_val\n               || (old_val->lattice_val == new_val.lattice_val\n \t\t  && ((!old_val->value && !new_val.value)\n-\t\t      || operand_equal_p (old_val->value, new_val.value, 0))\n-\t\t  && old_val->mem_ref == new_val.mem_ref));\n+\t\t      || operand_equal_p (old_val->value, new_val.value, 0))));\n \n   if (old_val->lattice_val != new_val.lattice_val)\n     {\n@@ -524,8 +517,7 @@ likely_value (gimple stmt)\n \n   /* If we are not doing store-ccp, statements with loads\n      and/or stores will never fold into a constant.  */\n-  if (!do_store_ccp\n-      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return VARYING;\n \n   /* Note that only a GIMPLE_SINGLE_RHS assignment can satisfy\n@@ -613,15 +605,7 @@ surely_varying_stmt_p (gimple stmt)\n     return true;\n \n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n-    {\n-      if (!do_store_ccp)\n-\treturn true;\n-\n-      /* We can only handle simple loads and stores.  */\n-      if (!stmt_makes_single_load (stmt)\n-\t  && !stmt_makes_single_store (stmt))\n-\treturn true;\n-    }\n+    return true;\n \n   /* If it is a call and does not return a value or is not a\n      builtin and not an indirect call, it is varying.  */\n@@ -692,7 +676,7 @@ ccp_initialize (void)\n         {\n           gimple phi = gsi_stmt (i);\n \n-\t  if (!do_store_ccp && !is_gimple_reg (gimple_phi_result (phi)))\n+\t  if (!is_gimple_reg (gimple_phi_result (phi)))\n             prop_set_simulate_again (phi, false);\n \t  else\n             prop_set_simulate_again (phi, true);\n@@ -747,14 +731,10 @@ ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n       /* any M VARYING = VARYING.  */\n       val1->lattice_val = VARYING;\n       val1->value = NULL_TREE;\n-      val1->mem_ref = NULL_TREE;\n     }\n   else if (val1->lattice_val == CONSTANT\n \t   && val2->lattice_val == CONSTANT\n-\t   && simple_cst_equal (val1->value, val2->value) == 1\n-\t   && (!do_store_ccp\n-\t       || (val1->mem_ref && val2->mem_ref\n-\t\t   && operand_equal_p (val1->mem_ref, val2->mem_ref, 0))))\n+\t   && simple_cst_equal (val1->value, val2->value) == 1)\n     {\n       /* Ci M Cj = Ci\t\tif (i == j)\n \t Ci M Cj = VARYING\tif (i != j)\n@@ -763,14 +743,12 @@ ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n \t they come from the same memory reference.  */\n       val1->lattice_val = CONSTANT;\n       val1->value = val1->value;\n-      val1->mem_ref = val1->mem_ref;\n     }\n   else\n     {\n       /* Any other combination is VARYING.  */\n       val1->lattice_val = VARYING;\n       val1->value = NULL_TREE;\n-      val1->mem_ref = NULL_TREE;\n     }\n }\n \n@@ -805,7 +783,6 @@ ccp_visit_phi_node (gimple phi)\n     case UNDEFINED:\n       new_val.lattice_val = UNDEFINED;\n       new_val.value = NULL_TREE;\n-      new_val.mem_ref = NULL_TREE;\n       break;\n \n     default:\n@@ -837,7 +814,6 @@ ccp_visit_phi_node (gimple phi)\n \t    {\n \t      arg_val.lattice_val = CONSTANT;\n \t      arg_val.value = arg;\n-\t      arg_val.mem_ref = NULL_TREE;\n \t    }\n \t  else\n \t    arg_val = *(get_value (arg));\n@@ -941,25 +917,6 @@ ccp_fold (gimple stmt)\n \t\t    }\n \t\t}\n \n-              else if (do_store_ccp && stmt_makes_single_load (stmt))\n-                {\n-                  /* If the RHS is a memory load, see if the VUSEs associated with\n-                     it are a valid constant for that memory load.  */\n-                  prop_value_t *val = get_value_loaded_by (stmt, const_val);\n-                  if (val && val->mem_ref)\n-                    {\n-                      if (operand_equal_p (val->mem_ref, rhs, 0))\n-                        return val->value;\n-\n-                      /* If RHS is extracting REALPART_EXPR or IMAGPART_EXPR of a\n-                         complex type with a known constant value, return it.  */\n-                      if ((TREE_CODE (rhs) == REALPART_EXPR\n-                           || TREE_CODE (rhs) == IMAGPART_EXPR)\n-                          && operand_equal_p (val->mem_ref, TREE_OPERAND (rhs, 0), 0))\n-                        return fold_build1 (TREE_CODE (rhs), TREE_TYPE (rhs), val->value);\n-                    }\n-                }\n-\n               if (kind == tcc_reference)\n \t\t{\n \t\t  if (TREE_CODE (rhs) == VIEW_CONVERT_EXPR\n@@ -1324,8 +1281,6 @@ evaluate_stmt (gimple stmt)\n   ccp_lattice_t likelyvalue = likely_value (stmt);\n   bool is_constant;\n \n-  val.mem_ref = NULL_TREE;\n-\n   fold_defer_overflow_warnings ();\n \n   /* If the statement is likely to have a CONSTANT result, then try\n@@ -1429,21 +1384,6 @@ visit_assignment (gimple stmt, tree *output_p)\n           prop_value_t *nval = get_value (rhs);\n           val = *nval;\n         }\n-      else if (do_store_ccp && stmt_makes_single_load (stmt))\n-        {\n-          /* Same as above, but the RHS is not a gimple register and yet\n-             has a known VUSE.  If STMT is loading from the same memory\n-             location that created the SSA_NAMEs for the virtual operands,\n-             we can propagate the value on the RHS.  */\n-          prop_value_t *nval = get_value_loaded_by (stmt, const_val);\n-\n-          if (nval\n-              && nval->mem_ref\n-              && operand_equal_p (nval->mem_ref, rhs, 0))\n-            val = *nval;\n-          else\n-            val = evaluate_stmt (stmt);\n-        }\n       else\n         val = evaluate_stmt (stmt);\n     }\n@@ -1468,46 +1408,6 @@ visit_assignment (gimple stmt, tree *output_p)\n \t    retval = SSA_PROP_INTERESTING;\n \t}\n     }\n-  else if (do_store_ccp && stmt_makes_single_store (stmt))\n-    {\n-      /* Otherwise, set the names in VDEF operands to the new\n-\t constant value and mark the LHS as the memory reference\n-\t associated with VAL.  */\n-      ssa_op_iter i;\n-      tree vdef;\n-      bool changed;\n-\n-      /* Mark VAL as stored in the LHS of this assignment.  */\n-      if (val.lattice_val == CONSTANT)\n-\tval.mem_ref = lhs;\n-\n-      /* Set the value of every VDEF to VAL.  */\n-      changed = false;\n-      FOR_EACH_SSA_TREE_OPERAND (vdef, stmt, i, SSA_OP_VIRTUAL_DEFS)\n-\t{\n-\t  /* See PR 29801.  We may have VDEFs for read-only variables\n-\t     (see the handling of unmodifiable variables in\n-\t     add_virtual_operand); do not attempt to change their value.  */\n-\t  if (get_symbol_constant_value (SSA_NAME_VAR (vdef)) != NULL_TREE)\n-\t    continue;\n-\n-\t  changed |= set_lattice_value (vdef, val);\n-\t}\n-      \n-      /* Note that for propagation purposes, we are only interested in\n-\t visiting statements that load the exact same memory reference\n-\t stored here.  Those statements will have the exact same list\n-\t of virtual uses, so it is enough to set the output of this\n-\t statement to be its first virtual definition.  */\n-      *output_p = first_vdef (stmt);\n-      if (changed)\n-\t{\n-\t  if (val.lattice_val == VARYING)\n-\t    retval = SSA_PROP_VARYING;\n-\t  else \n-\t    retval = SSA_PROP_INTERESTING;\n-\t}\n-    }\n \n   return retval;\n }\n@@ -1595,7 +1495,7 @@ ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n      Mark them VARYING.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      prop_value_t v = { VARYING, NULL_TREE, NULL_TREE };\n+      prop_value_t v = { VARYING, NULL_TREE };\n       set_lattice_value (def, v);\n     }\n \n@@ -1606,9 +1506,8 @@ ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n /* Main entry point for SSA Conditional Constant Propagation.  */\n \n static unsigned int\n-execute_ssa_ccp (bool store_ccp)\n+do_ssa_ccp (void)\n {\n-  do_store_ccp = store_ccp;\n   ccp_initialize ();\n   ssa_propagate (ccp_visit_stmt, ccp_visit_phi_node);\n   if (ccp_finalize ())\n@@ -1618,13 +1517,6 @@ execute_ssa_ccp (bool store_ccp)\n }\n \n \n-static unsigned int\n-do_ssa_ccp (void)\n-{\n-  return execute_ssa_ccp (false);\n-}\n-\n-\n static bool\n gate_ccp (void)\n {\n@@ -1653,43 +1545,6 @@ struct gimple_opt_pass pass_ccp =\n };\n \n \n-static unsigned int\n-do_ssa_store_ccp (void)\n-{\n-  /* If STORE-CCP is not enabled, we just run regular CCP.  */\n-  return execute_ssa_ccp (flag_tree_store_ccp != 0);\n-}\n-\n-static bool\n-gate_store_ccp (void)\n-{\n-  /* STORE-CCP is enabled only with -ftree-store-ccp, but when\n-     -fno-tree-store-ccp is specified, we should run regular CCP.\n-     That's why the pass is enabled with either flag.  */\n-  return flag_tree_store_ccp != 0 || flag_tree_ccp != 0;\n-}\n-\n-\n-struct gimple_opt_pass pass_store_ccp = \n-{\n- {\n-  GIMPLE_PASS,\n-  \"store_ccp\",\t\t\t\t/* name */\n-  gate_store_ccp,\t\t\t/* gate */\n-  do_ssa_store_ccp,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_STORE_CCP,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_verify_ssa\n-  | TODO_verify_stmts | TODO_ggc_collect/* todo_flags_finish */\n- }\n-};\n-\n /* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].\n    BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE\n    is the desired result type.  */"}, {"sha": "654ba950228cefb481fe90f7790976a4e2483e8e", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -829,7 +829,7 @@ copy_prop_visit_phi_node (gimple phi)\n {\n   enum ssa_prop_result retval;\n   unsigned i;\n-  prop_value_t phi_val = { 0, NULL_TREE, NULL_TREE };\n+  prop_value_t phi_val = { 0, NULL_TREE };\n \n   tree lhs = gimple_phi_result (phi);\n "}, {"sha": "4c246e679fe336704d08c420c58b69064746d870", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 5, "deletions": 176, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -823,22 +823,6 @@ ssa_propagate (ssa_prop_visit_stmt_fn visit_stmt,\n }\n \n \n-/* Return the first VDEF operand for STMT.  */\n-\n-tree\n-first_vdef (gimple stmt)\n-{\n-  ssa_op_iter iter;\n-  tree op;\n-\n-  /* Simply return the first operand we arrive at.  */\n-  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n-    return (op);\n-\n-  gcc_unreachable ();\n-}\n-\n-\n /* Return true if STMT is of the form 'LHS = mem_ref', where 'mem_ref'\n    is a non-volatile pointer dereference, a structure reference or a\n    reference to a single _DECL.  Ignore volatile memory references\n@@ -898,30 +882,6 @@ stmt_makes_single_store (gimple stmt)\n }\n \n \n-/* If STMT makes a single memory load and all the virtual use operands\n-   have the same value in array VALUES, return it.  Otherwise, return\n-   NULL.  */\n-\n-prop_value_t *\n-get_value_loaded_by (gimple stmt, prop_value_t *values)\n-{\n-  ssa_op_iter i;\n-  tree vuse;\n-  prop_value_t *prev_val = NULL;\n-  prop_value_t *val = NULL;\n-\n-  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i, SSA_OP_VIRTUAL_USES)\n-    {\n-      val = &values[SSA_NAME_VERSION (vuse)];\n-      if (prev_val && prev_val->value != val->value)\n-\treturn NULL;\n-      prev_val = val;\n-    }\n-\n-  return val;\n-}\n-\n-\n /* Propagation statistics.  */\n struct prop_stats_d\n {\n@@ -972,131 +932,6 @@ replace_uses_in (gimple stmt, prop_value_t *prop_value)\n }\n \n \n-/* Replace the VUSE references in statement STMT with the values\n-   stored in PROP_VALUE.  Return true if a reference was replaced.\n-\n-   Replacing VUSE operands is slightly more complex than replacing\n-   regular USEs.  We are only interested in two types of replacements\n-   here:\n-   \n-   1- If the value to be replaced is a constant or an SSA name for a\n-      GIMPLE register, then we are making a copy/constant propagation\n-      from a memory store.  For instance,\n-\n-      \t# a_3 = VDEF <a_2>\n-\ta.b = x_1;\n-\t...\n- \t# VUSE <a_3>\n-\ty_4 = a.b;\n-\n-      This replacement is only possible iff STMT is an assignment\n-      whose RHS is identical to the LHS of the statement that created\n-      the VUSE(s) that we are replacing.  Otherwise, we may do the\n-      wrong replacement:\n-\n-      \t# a_3 = VDEF <a_2>\n-\t# b_5 = VDEF <b_4>\n-\t*p = 10;\n-\t...\n-\t# VUSE <b_5>\n-\tx_8 = b;\n-\n-      Even though 'b_5' acquires the value '10' during propagation,\n-      there is no way for the propagator to tell whether the\n-      replacement is correct in every reached use, because values are\n-      computed at definition sites.  Therefore, when doing final\n-      substitution of propagated values, we have to check each use\n-      site.  Since the RHS of STMT ('b') is different from the LHS of\n-      the originating statement ('*p'), we cannot replace 'b' with\n-      '10'.\n-\n-      Similarly, when merging values from PHI node arguments,\n-      propagators need to take care not to merge the same values\n-      stored in different locations:\n-\n-     \t\tif (...)\n-\t\t  # a_3 = VDEF <a_2>\n-\t\t  a.b = 3;\n-\t\telse\n-\t\t  # a_4 = VDEF <a_2>\n-\t\t  a.c = 3;\n-\t\t# a_5 = PHI <a_3, a_4>\n-\n-      It would be wrong to propagate '3' into 'a_5' because that\n-      operation merges two stores to different memory locations.\n-\n-\n-   2- If the value to be replaced is an SSA name for a virtual\n-      register, then we simply replace each VUSE operand with its\n-      value from PROP_VALUE.  This is the same replacement done by\n-      replace_uses_in.  */\n-\n-static bool\n-replace_vuses_in (gimple stmt, prop_value_t *prop_value)\n-{\n-  bool replaced = false;\n-  ssa_op_iter iter;\n-  use_operand_p vuse;\n-\n-  if (stmt_makes_single_load (stmt))\n-    {\n-      /* If STMT is an assignment whose RHS is a single memory load,\n-\t see if we are trying to propagate a constant or a GIMPLE\n-\t register (case #1 above).  */\n-      prop_value_t *val = get_value_loaded_by (stmt, prop_value);\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-      if (val\n-\t  && val->value\n-\t  && (is_gimple_reg (val->value)\n-\t      || is_gimple_min_invariant (val->value))\n-\t  && simple_cst_equal (rhs, val->mem_ref) == 1)\n-\t{\n-\t  /* We can only perform the substitution if the load is done\n-\t     from the same memory location as the original store.\n-\t     Since we already know that there are no intervening\n-\t     stores between DEF_STMT and STMT, we only need to check\n-\t     that the RHS of STMT is the same as the memory reference\n-\t     propagated together with the value.  */\n-\t  gimple_assign_set_rhs1 (stmt, val->value);\n-\n-\t  if (TREE_CODE (val->value) != SSA_NAME)\n-\t    prop_stats.num_const_prop++;\n-\t  else\n-\t    prop_stats.num_copy_prop++;\n-\n-\t  /* Since we have replaced the whole RHS of STMT, there\n-\t     is no point in checking the other VUSEs, as they will\n-\t     all have the same value.  */\n-\t  return true;\n-\t}\n-    }\n-\n-  /* Otherwise, the values for every VUSE operand must be other\n-     SSA_NAMEs that can be propagated into STMT.  */\n-  FOR_EACH_SSA_USE_OPERAND (vuse, stmt, iter, SSA_OP_VIRTUAL_USES)\n-    {\n-      tree var = USE_FROM_PTR (vuse);\n-      tree val = prop_value[SSA_NAME_VERSION (var)].value;\n-\n-      if (val == NULL_TREE || var == val)\n-\tcontinue;\n-\n-      /* Constants and copies propagated between real and virtual\n-\t operands are only possible in the cases handled above.  They\n-\t should be ignored in any other context.  */\n-      if (is_gimple_min_invariant (val) || is_gimple_reg (val))\n-\tcontinue;\n-\n-      propagate_value (vuse, val);\n-      prop_stats.num_copy_prop++;\n-      replaced = true;\n-    }\n-\n-  return replaced;\n-}\n-\n-\n /* Replace propagated values into all the arguments for PHI using the\n    values from PROP_VALUE.  */\n \n@@ -1321,17 +1156,11 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t      gcc_assert (gsi_stmt (i) == stmt);\n \t    }\n \n-\t  if (prop_value)\n-\t    {\n-\t      /* Only replace real uses if we couldn't fold the\n-\t\t statement using value range information (value range\n-\t\t information is not collected on virtuals, so we only\n-\t\t need to check this for real uses).  */\n-\t      if (!did_replace)\n-\t\tdid_replace |= replace_uses_in (stmt, prop_value);\n-\n-\t      did_replace |= replace_vuses_in (stmt, prop_value);\n-\t    }\n+\t  /* Only replace real uses if we couldn't fold the\n+\t     statement using value range information.  */\n+\t  if (prop_value\n+\t      && !did_replace)\n+\t    did_replace |= replace_uses_in (stmt, prop_value);\n \n \t  /* If we made a replacement, fold and cleanup the statement.  */\n \t  if (did_replace)"}, {"sha": "3922f7d7cc52f9818cbbe9f33368e07649da3de1", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce2b2f6cb34a4f53ff5bedac672b3a113552b54/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=dce2b2f6cb34a4f53ff5bedac672b3a113552b54", "patch": "@@ -69,16 +69,6 @@ struct prop_value_d {\n \n     /* Propagated value.  */\n     tree value;\n-\n-    /* If this value is held in an SSA name for a non-register\n-       variable, this field holds the actual memory reference\n-       associated with this value.  This field is taken from \n-       the LHS of the assignment that generated the associated SSA\n-       name.  However, in the case of PHI nodes, this field is copied\n-       from the PHI arguments (assuming that all the arguments have\n-       the same memory reference).  See replace_vuses_in for a more\n-       detailed description.  */\n-    tree mem_ref;\n };\n \n typedef struct prop_value_d prop_value_t;\n@@ -128,10 +118,8 @@ bool valid_gimple_rhs_p (tree);\n bool valid_gimple_call_p (tree);\n void move_ssa_defining_stmt_for_defs (gimple, gimple);\n bool update_call_from_tree (gimple_stmt_iterator *, tree);\n-tree first_vdef (gimple);\n bool stmt_makes_single_load (gimple);\n bool stmt_makes_single_store (gimple);\n-prop_value_t *get_value_loaded_by (gimple, prop_value_t *);\n bool substitute_and_fold (prop_value_t *, bool);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}]}