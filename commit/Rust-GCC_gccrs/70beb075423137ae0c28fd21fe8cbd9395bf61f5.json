{"sha": "70beb075423137ae0c28fd21fe8cbd9395bf61f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBiZWIwNzU0MjMxMzdhZTBjMjhmZDIxZmU4Y2JkOTM5NWJmNjFmNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-20T06:29:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-20T06:29:14Z"}, "message": "Initial revision\n\nFrom-SVN: r222", "tree": {"sha": "cde7d7f053918a8e12f232479dd2f4bc0a6eb369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cde7d7f053918a8e12f232479dd2f4bc0a6eb369"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70beb075423137ae0c28fd21fe8cbd9395bf61f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70beb075423137ae0c28fd21fe8cbd9395bf61f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70beb075423137ae0c28fd21fe8cbd9395bf61f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70beb075423137ae0c28fd21fe8cbd9395bf61f5/comments", "author": null, "committer": null, "parents": [{"sha": "e0c17b2d5a1d72b2620e8707676c2d9a8d2a1532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c17b2d5a1d72b2620e8707676c2d9a8d2a1532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c17b2d5a1d72b2620e8707676c2d9a8d2a1532"}], "stats": {"total": 118, "additions": 118, "deletions": 0}, "files": [{"sha": "b35511c348b35fec8a4953308d2a8fefa06f65d4", "filename": "gcc/config/m68k/amix.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70beb075423137ae0c28fd21fe8cbd9395bf61f5/gcc%2Fconfig%2Fm68k%2Famix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70beb075423137ae0c28fd21fe8cbd9395bf61f5/gcc%2Fconfig%2Fm68k%2Famix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Famix.h?ref=70beb075423137ae0c28fd21fe8cbd9395bf61f5", "patch": "@@ -0,0 +1,118 @@\n+/* Definitions of target machine for GNU compiler.\n+   Commodore Amiga A3000UX version.\n+\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"m68kv4.h\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  For the\n+   Amiga, these definitions match those of the native AT&T compiler.  Note\n+   that we override the definition in m68kv4.h, where SVR4 is defined and\n+   AMIX isn't. */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+  \"-Dm68k -Dunix -DAMIX -Amachine(m68k) -Acpu(m68k) -Asystem(unix) -Alint(off)\"\n+\n+/* This is the library routine that is used to transfer control from\n+   the trampoline to the actual nested function.  FIXME:  This needs to\n+   be implemented still.  -fnf */\n+\n+#undef TRANSFER_FROM_TRAMPOLINE\n+\n+/* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n+   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n+   fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n+   we want.  This difference can be accommodated by using an assembler\n+   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n+   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n+   macro. (the Amiga assembler has this bug) */\n+\n+#undef ASM_OUTPUT_CASE_END\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (RTX_INTEGRATED_P (TABLE))\t\t\t\t\t\t\\\n+    asm_fprintf ((FILE), \"%s %LLD%d,%LL%d\\n\", SET_ASM_OP, (NUM), (NUM));\\\n+} while (0)\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized external linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.\n+   [This macro overrides the one in svr4.h because the amix assembler\n+    has a minimum default alignment of 4, and will not accept any\n+    explicit alignment smaller than this.  -fnf] */\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\t.comm\\t\", (FILE));\t\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), MAX ((ALIGN) / BITS_PER_UNIT, 4)); \\\n+} while (0)\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized internal linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.\n+   [This macro overrides the one in svr4.h because the amix assembler\n+    has a minimum default alignment of 4, and will not accept any\n+    explicit alignment smaller than this.  -fnf] */\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"%s\\t%s,%u,%u\\n\",\t\t\t\t\t\\\n+\t   BSS_ASM_OP, (NAME), (SIZE), MAX ((ALIGN) / BITS_PER_UNIT, 4)); \\\n+} while (0)\n+\n+/* This definition of ASM_OUTPUT_ASCII is the same as the one in m68ksgs.h,\n+   which has been overridden by the one in svr4.h.  However, we can't use\n+   the one in svr4.h because the amix assembler croaks on some of the\n+   strings that it emits (such as .string \"\\\"%s\\\"\\n\"). */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  register int sp = 0, lp = 0, ch;\t\t\t\t\\\n+  fprintf ((FILE), \"%s \", BYTE_ASM_OP);\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    ch = (PTR)[sp];\t\t\t\t\t\t\\\n+    if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"'%c\", ch);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"0x%x\", ch);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (++sp < (LEN))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tif ((sp % 10) == 0)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf ((FILE), \"\\n%s \", BYTE_ASM_OP);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    putc (',', (FILE));\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (sp < (LEN));\t\t\t\t\t\t\\\n+  putc ('\\n', (FILE));\t\t\t\t\t\t\\\n+}"}]}