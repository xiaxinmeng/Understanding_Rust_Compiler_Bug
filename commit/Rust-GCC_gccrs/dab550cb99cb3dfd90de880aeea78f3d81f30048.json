{"sha": "dab550cb99cb3dfd90de880aeea78f3d81f30048", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFiNTUwY2I5OWNiM2RmZDkwZGU4ODBhZWVhNzhmM2Q4MWYzMDA0OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2002-04-10T21:49:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2002-04-10T21:49:26Z"}, "message": "re PR middle-end/6247 (Konqueror miscompilation on IA-32)\n\n\tPR middle-end/6247\n\t* g++.dg/opt/cleanup1.C: New test.\n\n\t* g++.dg/opt/const1.C: New test.\n\nFrom-SVN: r52146", "tree": {"sha": "c45c43bbb25a617c5efcfcaa4068775be885c726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c45c43bbb25a617c5efcfcaa4068775be885c726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dab550cb99cb3dfd90de880aeea78f3d81f30048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab550cb99cb3dfd90de880aeea78f3d81f30048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dab550cb99cb3dfd90de880aeea78f3d81f30048", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab550cb99cb3dfd90de880aeea78f3d81f30048/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "880f8c16ad60e5c3536101de2e860ba90147f1e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880f8c16ad60e5c3536101de2e860ba90147f1e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880f8c16ad60e5c3536101de2e860ba90147f1e3"}], "stats": {"total": 306, "additions": 306, "deletions": 0}, "files": [{"sha": "001802fc8c2da075b0cac04769b8933c3b218dd6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab550cb99cb3dfd90de880aeea78f3d81f30048/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab550cb99cb3dfd90de880aeea78f3d81f30048/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dab550cb99cb3dfd90de880aeea78f3d81f30048", "patch": "@@ -1,3 +1,10 @@\n+2002-04-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/6247\n+\t* g++.dg/opt/cleanup1.C: New test.\n+\n+\t* g++.dg/opt/const1.C: New test.\n+\n 2002-04-10  Lars Brinkhoff  <lars@nocrew.org>\n  \n \t* gcc.c-torture/execute/20020406-1.c: Declare malloc."}, {"sha": "f34c7cf1a2d412a2b4e76bbd8cf234d7bc0f137a", "filename": "gcc/testsuite/g++.dg/opt/cleanup1.C", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab550cb99cb3dfd90de880aeea78f3d81f30048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcleanup1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab550cb99cb3dfd90de880aeea78f3d81f30048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcleanup1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcleanup1.C?ref=dab550cb99cb3dfd90de880aeea78f3d81f30048", "patch": "@@ -0,0 +1,170 @@\n+// PR middle-end/6247\n+// This testcase was miscompiled on IA-32 because a single stack slot\n+// was used for 2 different variables at the same time.\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+extern \"C\" void abort (void);\n+extern \"C\" void exit (int);\n+\n+struct A\n+{\n+  A () { a = 1; }\n+  void a1 () { a++; }\n+  bool a2 () { return !--a; }\n+  unsigned int a;\n+};\n+\n+struct B : public A\n+{\n+  B () : b (0) { a1 (); }\n+  void b1 ();\n+  const char *b;\n+};\n+\n+struct C\n+{\n+  C ();\n+  C (const C &);\n+  ~C () { if (c->a2 ()) { if (c == c0) c0 = 0; c->b1 (); } }\n+  C &operator= (const C &);\n+  static C c1 (const char *x, int y = -1);\n+  C (int, bool);\n+  void a2 ();\n+  B *c;\n+  static B *c0;\n+};\n+\n+B *C::c0 = __null;\n+\n+template <class T> struct D\n+{\n+  D (const T& t) : d (t) {}\n+  D () {}\n+  D<T> *next, *prev;\n+  T d;\n+};\n+\n+template<class T> struct E\n+{\n+  D<T> *e;\n+  E () : e (0) {}\n+  E (D<T> *p) : e (p) {}\n+  E (const E<T>& x) : e (x.e) {}\n+  const T& operator* () const { return e->d; }\n+  T& operator* () { return e->d; }\n+  bool operator== (const E<T>& x) const { return e == x.e; }\n+  bool operator!= (const E<T>& x) const { return e != x.e; }\n+  E<T> operator++ (int) { E<T> x = *this; e = e->next; return x; }\n+};\n+\n+template <class T> struct F : public A\n+{\n+  F () { f = new D<T>; f->next = f->prev = f; f0 = 0; }\n+  ~F () {}\n+  D<T> *f;\n+  unsigned int f0;\n+\n+  F (const F<T>& x) : A ()\n+  {\n+    f = new D<T>; f->next = f->prev = f; f0 = 0;\n+    E<T> b (x.f->next);\n+    E<T> e (x.f);\n+    E<T> i (f);\n+    while (b != e)\n+      f1 (i, *b++);\n+  }\n+\n+  E<T> f1 (E<T> x, const T& y)\n+  {\n+    D<T> *p = new D<T> (y);\n+    p->next = x.e;\n+    p->prev = x.e->prev;\n+    x.e->prev->next = p;\n+    x.e->prev = p;\n+    f0++;\n+    return p;\n+  }\n+};\n+\n+template <class T> struct G\n+{\n+  E<T> g1 () { g3 (); return E<T> (g->f); }\n+  E<T> g2 (const T& x) { g3 (); return g->f1 (g1 (), x); }\n+  void g3 () { if (g->a > 1) { g->a2 (); g = new F<T> (*g); } }\n+  F<T>* g;\n+};\n+\n+struct H\n+{\n+  virtual ~H () {};\n+  virtual void h1 ();\n+  struct I\n+  {\n+    I () {}\n+    I (C r, C p) : i1 (r), i2 (p) {}\n+    C i1, i2;\n+  };\n+  G<I> h;\n+};\n+\n+void H::h1 ()\n+{\n+  h.g2 (I (C::c1 (\"s1\"), C::c1 (\"t\")));\n+  h.g2 (I (C::c1 (\"s2\"), C::c1 (\"t\")));\n+  h.g2 (I (C::c1 (\"s3\"), C::c1 (\"t\")));\n+}\n+\n+void B::b1 ()\n+{\n+}\n+\n+C C::c1 (const char *x, int y)\n+{\n+  C z;\n+\n+  if (y != -1)\n+    abort ();\n+  z.c = new B;\n+  z.c->b = x;\n+  return z;\n+}\n+\n+C::C ()\n+{\n+}\n+\n+C::C (const C &x)\n+{\n+  c = x.c;\n+  c->a1 ();\n+}\n+\n+int main ()\n+{\n+  H h;\n+  h.h.g = new F<H::I> ();\n+  h.h1 ();\n+  if (h.h.g->f0 != 3)\n+    abort ();\n+  D<H::I> *p;\n+  int i;\n+  for (i = 0, p = h.h.g->f; i < 4; i++, p = p->next)\n+    {\n+      if (i == 0 && (p->d.i1.c != __null || p->d.i2.c != __null))\n+\tabort ();\n+      if (i > 0\n+\t  && (p->d.i1.c->b[0] != 's'\n+\t      || p->d.i1.c->b[1] != '0' + i\n+\t      || p->d.i1.c->b[2] != '\\0'\n+\t      || __builtin_strcmp (p->d.i2.c->b, \"t\")))\n+\tabort ();\n+      if (p->prev->next != p)\n+\tabort ();\n+      if (p->next->prev != p)\n+\tabort ();\n+      if (i == 3 && p->next != h.h.g->f)\n+\tabort ();\n+    }\n+  exit (0);\n+}"}, {"sha": "834cfd5e258ca8b7b9ae9d9fe3cca71fffbb8170", "filename": "gcc/testsuite/g++.dg/opt/const1.C", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab550cb99cb3dfd90de880aeea78f3d81f30048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab550cb99cb3dfd90de880aeea78f3d81f30048/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst1.C?ref=dab550cb99cb3dfd90de880aeea78f3d81f30048", "patch": "@@ -0,0 +1,129 @@\n+// This testcase was miscompiled on IA-64 to read from unitialized memory\n+// and dereference it.\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+struct A\n+{\n+  A () { a = 1; }\n+  void a1 () { a++; }\n+  bool a2 () { return !--a; }\n+  unsigned int a;\n+};\n+\n+struct B {};\n+\n+template <class T> struct C\n+{\n+  C () {}\n+  C (const T& t) : c (t) {}\n+  C<T> *next, *prev;\n+  T c;\n+};\n+\n+template <class T> struct D\n+{\n+  C<T> *d;\n+  D () : d (0) {}\n+  D (C<T> *x) : d (x) {}\n+  D (const D<T>& x) : d (x.d) {}\n+  bool operator!= (const D<T>& x) const { return d != x.d; }\n+  const T& operator* () const { return d->c; }\n+  D<T> operator++ (int) { D<T> t = *this; d = d->next; return t; }\n+};\n+\n+template <class T> struct E\n+{\n+  C<T> *e;\n+  E () : e (0) {}\n+  E (C<T> *p) : e (p) {}\n+  E (const E<T>& x) : e (x.e) {}\n+  E (const D<T>& x) : e (x.e) {}\n+  bool operator!= (const E<T>& x) const { return e != x.e; }\n+  const T& operator* () const { return e->c; }\n+  E<T>& operator++ () { e = e->next; return *this; }\n+};\n+\n+template <class T> struct F : public A\n+{\n+  C<T> *f;\n+  unsigned long f0;\n+  F () { f = new C<T>; f->next = f->prev = f; f0 = 0; }\n+  F (const F<T>& x) : A ()\n+  {\n+    f = new C<T>; f->next = f->prev = f; f0 = 0;\n+    D<T> b (x.f->next), e (x.f), i (f);\n+    while (b != e)\n+      f1 (i, *b++);\n+  }\n+\n+  ~F ()\n+  {\n+    C<T> *p = f->next;\n+    while (p != f)\n+      {\n+\tC<T> *x = p->next;\n+\tdelete p;\n+\tp = x;\n+      }\n+    delete f;\n+  }\n+\n+  D<T> f1 (D<T> x, const T& y)\n+  {\n+    C<T> *p = new C<T> (y);\n+    p->next = x.d;\n+    p->prev = x.d->prev;\n+    x.d->prev->next = p;\n+    x.d->prev = p;\n+    f0++;\n+    return p;\n+  }\n+};\n+\n+template <class T> struct G\n+{\n+  F<T> *g;\n+  G () { g = new F<T>; }\n+  G (const G<T>& x) { g = x.g; g->a1 (); }\n+  ~G () {}\n+  G<T>& operator= (const G<T>& x) { x.g->a1 (); g = x.g; return *this; }\n+  D<T> g1 () { g4 (); return D<T> (g->f); }\n+  E<T> g1 () const { return E<T> (g->f); }\n+  E<T> g2 () const { return E<T> (g->f->next); }\n+  D<T> g3 (const T& x) { g4 (); return g->f1 (g1 (), x); }\n+  void g4 () { if (g->a > 1) { g->a2 (); g = new F<T> (*g); } }\n+\n+  G<T> operator+ (const G<T>& x) const\n+  {\n+    G<T> x2 (*this);\n+    for (E<T> i = x.g2 (); i != x.g1 (); ++i)\n+      x2.g3 (*i);\n+    return x2;\n+  }\n+\n+  G<T>& operator+= (const G<T>& x)\n+  {\n+    for (E<T> i = x.g2 (); i != x.g1 (); ++i)\n+      g3 (*i);\n+    return *this;\n+  }\n+};\n+\n+struct H : public G<B>\n+{\n+  H () {}\n+  H (const H& x) : G<B> (x) {}\n+  H (const G<B>& x) : G<B> (x) {}\n+};\n+\n+void foo ();\n+\n+int\n+main ()\n+{\n+  H a = H () + H ();\n+  a += H ();\n+  H b;\n+  b = H () + H ();\n+}"}]}