{"sha": "01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkOGJmMDcwYTJjYTZhMTBjNjZhODFmMWI1ZTFjMDA4NTZiNWJjNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-04-19T13:37:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-19T13:37:12Z"}, "message": "re PR tree-optimization/56270 (loop over array of struct float causes compiler error: segmentation fault)\n\n2013-04-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct _slp_instance): Move load_permutation\n\tmember ...\n\t(struct _slp_tree): ... here.  Make it a vector of unsigned ints.\n\t(SLP_INSTANCE_LOAD_PERMUTATION): Remove.\n\t(SLP_TREE_LOAD_PERMUTATION): Add.\n\t(vect_transform_slp_perm_load): Adjust prototype.\n\t* tree-vect-slp.c (vect_free_slp_tree): Adjust.\n\t(vect_free_slp_instance): Likewise.\n\t(vect_create_new_slp_node): Likewise.\n\t(vect_supported_slp_permutation_p): Remove.\n\t(vect_slp_rearrange_stmts): Adjust.\n\t(vect_supported_load_permutation_p): Likewise.  Inline\n\tvect_supported_slp_permutation_p here.\n\t(vect_analyze_slp_instance): Compute load permutations per\n\tslp node instead of per instance.\n\t(vect_get_slp_defs): Adjust.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Remove redundant code.\n\t(vect_schedule_slp): Remove hack for PR56270, add it ...\n\t* tree-vect-stmts.c (vectorizable_load): ... here, do not\n\tCSE loads for SLP.  Adjust.\n\nFrom-SVN: r198095", "tree": {"sha": "296dc78a662c0699454b4483380a99d413a514d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/296dc78a662c0699454b4483380a99d413a514d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ede22fc330f055810555d867de5a8e3d3f94ad63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede22fc330f055810555d867de5a8e3d3f94ad63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede22fc330f055810555d867de5a8e3d3f94ad63"}], "stats": {"total": 495, "additions": 199, "deletions": 296}, "files": [{"sha": "8bdf2a9cf76b74487c734aea580040ca6f51e16d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "patch": "@@ -1,3 +1,27 @@\n+2013-04-19  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (struct _slp_instance): Move load_permutation\n+\tmember ...\n+\t(struct _slp_tree): ... here.  Make it a vector of unsigned ints.\n+\t(SLP_INSTANCE_LOAD_PERMUTATION): Remove.\n+\t(SLP_TREE_LOAD_PERMUTATION): Add.\n+\t(vect_transform_slp_perm_load): Adjust prototype.\n+\t* tree-vect-slp.c (vect_free_slp_tree): Adjust.\n+\t(vect_free_slp_instance): Likewise.\n+\t(vect_create_new_slp_node): Likewise.\n+\t(vect_supported_slp_permutation_p): Remove.\n+\t(vect_slp_rearrange_stmts): Adjust.\n+\t(vect_supported_load_permutation_p): Likewise.  Inline\n+\tvect_supported_slp_permutation_p here.\n+\t(vect_analyze_slp_instance): Compute load permutations per\n+\tslp node instead of per instance.\n+\t(vect_get_slp_defs): Adjust.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t(vect_schedule_slp_instance): Remove redundant code.\n+\t(vect_schedule_slp): Remove hack for PR56270, add it ...\n+\t* tree-vect-stmts.c (vectorizable_load): ... here, do not\n+\tCSE loads for SLP.  Adjust.\n+\n 2013-04-19  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.c (load_multiple_sequence, ldm_stm_operation_p): Fix"}, {"sha": "b83e64041308a9b71965143f091dd7c9a6a9c63f", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 157, "deletions": 286, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "patch": "@@ -78,6 +78,7 @@ vect_free_slp_tree (slp_tree node)\n   SLP_TREE_CHILDREN (node).release ();\n   SLP_TREE_SCALAR_STMTS (node).release ();\n   SLP_TREE_VEC_STMTS (node).release ();\n+  SLP_TREE_LOAD_PERMUTATION (node).release ();\n \n   free (node);\n }\n@@ -89,7 +90,6 @@ void\n vect_free_slp_instance (slp_instance instance)\n {\n   vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n-  SLP_INSTANCE_LOAD_PERMUTATION (instance).release ();\n   SLP_INSTANCE_LOADS (instance).release ();\n   SLP_INSTANCE_BODY_COST_VEC (instance).release ();\n   free (instance);\n@@ -120,6 +120,7 @@ vect_create_new_slp_node (vec<gimple> scalar_stmts)\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_VEC_STMTS (node).create (0);\n   SLP_TREE_CHILDREN (node).create (nops);\n+  SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n \n   return node;\n }\n@@ -1026,73 +1027,11 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n }\n \n \n-/* Check if the permutation required by the SLP INSTANCE is supported.\n-   Reorganize the SLP nodes stored in SLP_INSTANCE_LOADS if needed.  */\n-\n-static bool\n-vect_supported_slp_permutation_p (slp_instance instance)\n-{\n-  slp_tree node = SLP_INSTANCE_LOADS (instance)[0];\n-  gimple stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  gimple first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n-  vec<slp_tree> sorted_loads = vNULL;\n-  int index;\n-  slp_tree *tmp_loads = NULL;\n-  int group_size = SLP_INSTANCE_GROUP_SIZE (instance), i, j;\n-  slp_tree load;\n-\n-  /* FORNOW: The only supported loads permutation is loads from the same\n-     location in all the loads in the node, when the data-refs in\n-     nodes of LOADS constitute an interleaving chain.\n-     Sort the nodes according to the order of accesses in the chain.  */\n-  tmp_loads = (slp_tree *) xmalloc (sizeof (slp_tree) * group_size);\n-  for (i = 0, j = 0;\n-       SLP_INSTANCE_LOAD_PERMUTATION (instance).iterate (i, &index)\n-       && SLP_INSTANCE_LOADS (instance).iterate (j, &load);\n-       i += group_size, j++)\n-    {\n-      gimple scalar_stmt = SLP_TREE_SCALAR_STMTS (load)[0];\n-      /* Check that the loads are all in the same interleaving chain.  */\n-      if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (scalar_stmt)) != first_load)\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: unsupported data \"\n-\t\t\t       \"permutation \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\tscalar_stmt, 0);\n-            }\n-\n-          free (tmp_loads);\n-          return false;\n-        }\n-\n-      tmp_loads[index] = load;\n-    }\n-\n-  sorted_loads.create (group_size);\n-  for (i = 0; i < group_size; i++)\n-     sorted_loads.safe_push (tmp_loads[i]);\n-\n-  SLP_INSTANCE_LOADS (instance).release ();\n-  SLP_INSTANCE_LOADS (instance) = sorted_loads;\n-  free (tmp_loads);\n-\n-  if (!vect_transform_slp_perm_load (stmt, vNULL, NULL,\n-                                     SLP_INSTANCE_UNROLLING_FACTOR (instance),\n-                                     instance, true))\n-    return false;\n-\n-  return true;\n-}\n-\n-\n /* Rearrange the statements of NODE according to PERMUTATION.  */\n \n static void\n vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n-                          vec<int> permutation)\n+                          vec<unsigned> permutation)\n {\n   gimple stmt;\n   vec<gimple> tmp_stmts;\n@@ -1114,32 +1053,29 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n }\n \n \n-/* Check if the required load permutation is supported.\n-   LOAD_PERMUTATION contains a list of indices of the loads.\n-   In SLP this permutation is relative to the order of grouped stores that are\n-   the base of the SLP instance.  */\n+/* Check if the required load permutations in the SLP instance\n+   SLP_INSTN are supported.  */\n \n static bool\n-vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n-                                   vec<int> load_permutation)\n+vect_supported_load_permutation_p (slp_instance slp_instn)\n {\n-  int i = 0, j, prev = -1, next, k, number_of_groups;\n-  bool supported, bad_permutation = false;\n+  unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n+  unsigned int i, j, k, next;\n   sbitmap load_index;\n   slp_tree node;\n   gimple stmt, load, next_load, first_load;\n   struct data_reference *dr;\n-  bb_vec_info bb_vinfo;\n-\n-  /* FORNOW: permutations are only supported in SLP.  */\n-  if (!slp_instn)\n-    return false;\n \n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"Load permutation \");\n-      FOR_EACH_VEC_ELT (load_permutation, i, next)\n-        dump_printf (MSG_NOTE, \"%d \", next);\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+\tif (node->load_permutation.exists ())\n+\t  FOR_EACH_VEC_ELT (node->load_permutation, j, next)\n+\t    dump_printf (MSG_NOTE, \"%d \", next);\n+\telse\n+\t  for (i = 0; i < group_size; ++i)\n+\t    dump_printf (MSG_NOTE, \"%d \", i);\n     }\n \n   /* In case of reduction every load permutation is allowed, since the order\n@@ -1150,209 +1086,161 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n      permutation).  */\n \n   /* Check that all the load nodes are of the same size.  */\n+  /* ???  Can't we assert this? */\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     if (SLP_TREE_SCALAR_STMTS (node).length () != (unsigned) group_size)\n       return false;\n \n   node = SLP_INSTANCE_TREE (slp_instn);\n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  /* LOAD_PERMUTATION is a list of indices of all the loads of the SLP\n-     instance, not all the loads belong to the same node or interleaving\n-     group.  Hence, we need to divide them into groups according to\n-     GROUP_SIZE.  */\n-  number_of_groups = load_permutation.length () / group_size;\n \n   /* Reduction (there are no data-refs in the root).\n      In reduction chain the order of the loads is important.  */\n   if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))\n       && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n-      int first_group_load_index;\n-\n-      /* Compare all the permutation sequences to the first one.  */\n-      for (i = 1; i < number_of_groups; i++)\n-        {\n-          k = 0;\n-          for (j = i * group_size; j < i * group_size + group_size; j++)\n-            {\n-              next = load_permutation[j];\n-              first_group_load_index = load_permutation[k];\n+      slp_tree load;\n+      unsigned int lidx;\n \n-              if (next != first_group_load_index)\n-                {\n-                  bad_permutation = true;\n-                  break;\n-                }\n-\n-              k++;\n-            }\n-\n-          if (bad_permutation)\n-            break;\n-        }\n-\n-      if (!bad_permutation)\n-        {\n-          /* Check that the loads in the first sequence are different and there\n-             are no gaps between them.  */\n-          load_index = sbitmap_alloc (group_size);\n-          bitmap_clear (load_index);\n-          for (k = 0; k < group_size; k++)\n-            {\n-              first_group_load_index = load_permutation[k];\n-              if (bitmap_bit_p (load_index, first_group_load_index))\n-                {\n-                  bad_permutation = true;\n-                  break;\n-                }\n-\n-              bitmap_set_bit (load_index, first_group_load_index);\n-            }\n-\n-          if (!bad_permutation)\n-            for (k = 0; k < group_size; k++)\n-              if (!bitmap_bit_p (load_index, k))\n-                {\n-                  bad_permutation = true;\n-                  break;\n-                }\n-\n-          sbitmap_free (load_index);\n-        }\n+      /* Compare all the permutation sequences to the first one.  We know\n+         that at least one load is permuted.  */\n+      node = SLP_INSTANCE_LOADS (slp_instn)[0];\n+      if (!node->load_permutation.exists ())\n+\treturn false;\n+      for (i = 1; SLP_INSTANCE_LOADS (slp_instn).iterate (i, &load); ++i)\n+\t{\n+\t  if (!load->load_permutation.exists ())\n+\t    return false;\n+\t  FOR_EACH_VEC_ELT (load->load_permutation, j, lidx)\n+\t    if (lidx != node->load_permutation[j])\n+\t      return false;\n+\t}\n \n-      if (!bad_permutation)\n-        {\n-          /* This permutation is valid for reduction.  Since the order of the\n-             statements in the nodes is not important unless they are memory\n-             accesses, we can rearrange the statements in all the nodes \n-             according to the order of the loads.  */\n-          vect_slp_rearrange_stmts (SLP_INSTANCE_TREE (slp_instn), group_size,\n-                                    load_permutation);\n-          SLP_INSTANCE_LOAD_PERMUTATION (slp_instn).release ();\n-          return true;\n-        }\n+      /* Check that the loads in the first sequence are different and there\n+\t are no gaps between them.  */\n+      load_index = sbitmap_alloc (group_size);\n+      bitmap_clear (load_index);\n+      FOR_EACH_VEC_ELT (node->load_permutation, i, lidx)\n+\t{\n+\t  if (bitmap_bit_p (load_index, lidx))\n+\t    {\n+\t      sbitmap_free (load_index);\n+\t      return false;\n+\t    }\n+\t  bitmap_set_bit (load_index, lidx);\n+\t}\n+      for (i = 0; i < group_size; i++)\n+\tif (!bitmap_bit_p (load_index, i))\n+\t  {\n+\t    sbitmap_free (load_index);\n+\t    return false;\n+\t  }\n+      sbitmap_free (load_index);\n+\n+      /* This permutation is valid for reduction.  Since the order of the\n+\t statements in the nodes is not important unless they are memory\n+\t accesses, we can rearrange the statements in all the nodes\n+\t according to the order of the loads.  */\n+      vect_slp_rearrange_stmts (SLP_INSTANCE_TREE (slp_instn), group_size,\n+\t\t\t\tnode->load_permutation);\n+\n+      /* We are done, no actual permutations need to be generated.  */\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+\tSLP_TREE_LOAD_PERMUTATION (node).release ();\n+      return true;\n     }\n \n   /* In basic block vectorization we allow any subchain of an interleaving\n      chain.\n      FORNOW: not supported in loop SLP because of realignment compications.  */\n-  bb_vinfo = STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt));\n-  bad_permutation = false;\n-  /* Check that for every node in the instance the loads form a subchain.  */\n-  if (bb_vinfo)\n+  if (STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt)))\n     {\n+      /* Check that for every node in the instance the loads\n+\t form a subchain.  */\n       FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n         {\n           next_load = NULL;\n-          first_load = NULL;\n           FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load)\n             {\n-              if (!first_load)\n-                first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (load));\n-              else if (first_load\n-                         != GROUP_FIRST_ELEMENT (vinfo_for_stmt (load)))\n-                {\n-                  bad_permutation = true;\n-\t          break;\n-\t        }\n-\n               if (j != 0 && next_load != load)\n-                {\n-                  bad_permutation = true;\n-                  break;\n-                }\n-\n+\t\treturn false;\n               next_load = GROUP_NEXT_ELEMENT (vinfo_for_stmt (load));\n             }\n-\n-          if (bad_permutation)\n-            break;\n         }\n \n       /* Check that the alignment of the first load in every subchain, i.e.,\n-         the first statement in every load node, is supported.  */\n-      if (!bad_permutation)\n-        {\n-          FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-            {\n-              first_load = SLP_TREE_SCALAR_STMTS (node)[0];\n-              if (first_load\n-                    != GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_load)))\n-                {\n-                  dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_load));\n-                  if (vect_supportable_dr_alignment (dr, false)\n- \t               == dr_unaligned_unsupported)\n-                    {\n-   \t\t      if (dump_enabled_p ())\n-\t\t        {\n-  \t                  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t\t   vect_location, \n-\t\t\t\t\t   \"unsupported unaligned load \");\n-                          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\t    first_load, 0);\n-                        }\n-  \t\t      bad_permutation = true;\n-                      break;\n-                    }\n-\t        }\n-            }\n+         the first statement in every load node, is supported.\n+\t ???  This belongs in alignment checking.  */\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+\t{\n+\t  first_load = SLP_TREE_SCALAR_STMTS (node)[0];\n+\t  if (first_load != GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_load)))\n+\t    {\n+\t      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_load));\n+\t      if (vect_supportable_dr_alignment (dr, false)\n+\t\t  == dr_unaligned_unsupported)\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t       vect_location,\n+\t\t\t\t       \"unsupported unaligned load \");\n+\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\tfirst_load, 0);\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n \n-          if (!bad_permutation)\n-            {\n-              SLP_INSTANCE_LOAD_PERMUTATION (slp_instn).release ();\n-              return true;\n-    \t    }\n-        }\n+      /* We are done, no actual permutations need to be generated.  */\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+\tSLP_TREE_LOAD_PERMUTATION (node).release ();\n+      return true;\n     }\n \n   /* FORNOW: the only supported permutation is 0..01..1.. of length equal to\n      GROUP_SIZE and where each sequence of same drs is of GROUP_SIZE length as\n      well (unless it's reduction).  */\n-  if (load_permutation.length ()\n-      != (unsigned int) (group_size * group_size))\n+  if (SLP_INSTANCE_LOADS (slp_instn).length () != group_size)\n     return false;\n+  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+    if (!node->load_permutation.exists ())\n+      return false;\n \n-  supported = true;\n   load_index = sbitmap_alloc (group_size);\n   bitmap_clear (load_index);\n-  for (j = 0; j < group_size; j++)\n-    {\n-      for (i = j * group_size, k = 0;\n-           load_permutation.iterate (i, &next) && k < group_size;\n-           i++, k++)\n-       {\n-         if (i != j * group_size && next != prev)\n-          {\n-            supported = false;\n-            break;\n-          }\n-\n-         prev = next;\n-       }\n-\n-      if (bitmap_bit_p (load_index, prev))\n-        {\n-          supported = false;\n-          break;\n-        }\n-\n-      bitmap_set_bit (load_index, prev);\n+  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+    {\n+      unsigned int lidx = node->load_permutation[0];\n+      if (bitmap_bit_p (load_index, lidx))\n+\t{\n+\t  sbitmap_free (load_index);\n+\t  return false;\n+\t}\n+      bitmap_set_bit (load_index, lidx);\n+      FOR_EACH_VEC_ELT (node->load_permutation, j, k)\n+\tif (k != lidx)\n+\t  {\n+\t    sbitmap_free (load_index);\n+\t    return false;\n+\t  }\n     }\n- \n-  for (j = 0; j < group_size; j++)\n-    if (!bitmap_bit_p (load_index, j))\n+  for (i = 0; i < group_size; i++)\n+    if (!bitmap_bit_p (load_index, i))\n       {\n \tsbitmap_free (load_index);\n \treturn false;\n       }\n-\n   sbitmap_free (load_index);\n \n-  if (supported && i == group_size * group_size\n-      && vect_supported_slp_permutation_p (slp_instn))\n-    return true;\n-\n-  return false;\n+  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n+    if (node->load_permutation.exists ()\n+\t&& !vect_transform_slp_perm_load\n+\t      (node, vNULL, NULL,\n+\t       SLP_INSTANCE_UNROLLING_FACTOR (slp_instn), slp_instn, true))\n+      return false;\n+  return true;\n }\n \n \n@@ -1642,17 +1530,17 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_BODY_COST_VEC (new_instance) = vNULL;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n       SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n-      SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = vNULL;\n \n       /* Compute the load permutation.  */\n       slp_tree load_node;\n       bool loads_permuted = false;\n-      vec<int> load_permutation;\n-      load_permutation.create (group_size * group_size);\n       FOR_EACH_VEC_ELT (loads, i, load_node)\n \t{\n+\t  vec<unsigned> load_permutation;\n \t  int j;\n \t  gimple load, first_stmt;\n+\t  bool this_load_permuted = false;\n+\t  load_permutation.create (group_size);\n \t  first_stmt = GROUP_FIRST_ELEMENT\n \t      (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n \t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n@@ -1661,16 +1549,21 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t= vect_get_place_in_interleaving_chain (load, first_stmt);\n \t      gcc_assert (load_place != -1);\n \t      if (load_place != j)\n-\t\tloads_permuted = true;\n+\t\tthis_load_permuted = true;\n \t      load_permutation.safe_push (load_place);\n \t    }\n+\t  if (!this_load_permuted)\n+\t    {\n+\t      load_permutation.release ();\n+\t      continue;\n+\t    }\n+\t  SLP_TREE_LOAD_PERMUTATION (load_node) = load_permutation;\n+\t  loads_permuted = true;\n \t}\n \n       if (loads_permuted)\n         {\n-\t  SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n-          if (!vect_supported_load_permutation_p (new_instance, group_size,\n-                                                  load_permutation))\n+          if (!vect_supported_load_permutation_p (new_instance))\n             {\n               if (dump_enabled_p ())\n                 {\n@@ -1679,16 +1572,13 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"permutation \");\n                   dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n                 }\n-\n               vect_free_slp_instance (new_instance);\n               return false;\n             }\n \n           SLP_INSTANCE_FIRST_LOAD_STMT (new_instance)\n-             = vect_find_first_load_in_slp_instance (new_instance);\n+\t    = vect_find_first_load_in_slp_instance (new_instance);\n         }\n-      else\n-        load_permutation.release ();\n \n       /* Compute the costs of this SLP instance.  */\n       vect_analyze_slp_cost (loop_vinfo, bb_vinfo,\n@@ -2653,7 +2543,7 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n       vectorized_defs = false;\n       if (SLP_TREE_CHILDREN (slp_node).length () > child_index)\n         {\n-          child = (slp_tree) SLP_TREE_CHILDREN (slp_node)[child_index];\n+          child = SLP_TREE_CHILDREN (slp_node)[child_index];\n \n \t  /* We have to check both pattern and original def, if available.  */\n \t  gimple first_def = SLP_TREE_SCALAR_STMTS (child)[0];\n@@ -2854,16 +2744,18 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n \n /* Generate vector permute statements from a list of loads in DR_CHAIN.\n    If ANALYZE_ONLY is TRUE, only check that it is possible to create valid\n-   permute statements for SLP_NODE_INSTANCE.  */\n+   permute statements for the SLP node NODE of the SLP instance\n+   SLP_NODE_INSTANCE.  */\n+\n bool\n-vect_transform_slp_perm_load (gimple stmt, vec<tree> dr_chain,\n+vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n                               gimple_stmt_iterator *gsi, int vf,\n                               slp_instance slp_node_instance, bool analyze_only)\n {\n+  gimple stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree mask_element_type = NULL_TREE, mask_type;\n   int i, j, k, nunits, vec_index = 0, scalar_index;\n-  slp_tree node;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   gimple next_scalar_stmt;\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n@@ -2910,6 +2802,9 @@ vect_transform_slp_perm_load (gimple stmt, vec<tree> dr_chain,\n      relatively to SLP_NODE_INSTANCE unrolling factor.  */\n   ncopies = vf / SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n \n+  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    return false;\n+\n   /* Generate permutation masks for every NODE. Number of masks for each NODE\n      is equal to GROUP_SIZE.\n      E.g., we have a group of three nodes with three loads from the same\n@@ -2928,7 +2823,6 @@ vect_transform_slp_perm_load (gimple stmt, vec<tree> dr_chain,\n      we need the second and the third vectors: {b1,c1,a2,b2} and\n      {c2,a3,b3,c3}.  */\n \n-  FOR_EACH_VEC_ELT  (SLP_INSTANCE_LOADS (slp_node_instance), i, node)\n     {\n       scalar_index = 0;\n       index = 0;\n@@ -2944,6 +2838,7 @@ vect_transform_slp_perm_load (gimple stmt, vec<tree> dr_chain,\n         {\n           for (k = 0; k < group_size; k++)\n             {\n+\t      i = SLP_TREE_LOAD_PERMUTATION (node)[k];\n               first_mask_element = i + j * group_size;\n               if (!vect_get_mask_element (stmt, first_mask_element, 0,\n \t\t\t\t\t  nunits, only_one_vec, index,\n@@ -2956,9 +2851,7 @@ vect_transform_slp_perm_load (gimple stmt, vec<tree> dr_chain,\n \n               if (index == nunits)\n                 {\n-\t\t  tree mask_vec, *mask_elts;\n-\t\t  int l;\n-\n+\t\t  index = 0;\n \t\t  if (!can_vec_perm_p (mode, false, mask))\n \t\t    {\n \t\t      if (dump_enabled_p ())\n@@ -2974,15 +2867,17 @@ vect_transform_slp_perm_load (gimple stmt, vec<tree> dr_chain,\n \t\t      return false;\n \t\t    }\n \n-\t\t  mask_elts = XALLOCAVEC (tree, nunits);\n-\t\t  for (l = 0; l < nunits; ++l)\n-\t\t    mask_elts[l] = build_int_cst (mask_element_type, mask[l]);\n-\t\t  mask_vec = build_vector (mask_type, mask_elts);\n-\t\t  index = 0;\n-\n                   if (!analyze_only)\n                     {\n-                      if (need_next_vector)\n+\t\t      int l;\n+\t\t      tree mask_vec, *mask_elts;\n+\t\t      mask_elts = XALLOCAVEC (tree, nunits);\n+\t\t      for (l = 0; l < nunits; ++l)\n+\t\t\tmask_elts[l] = build_int_cst (mask_element_type,\n+\t\t\t\t\t\t      mask[l]);\n+\t\t      mask_vec = build_vector (mask_type, mask_elts);\n+\n+\t\t      if (need_next_vector)\n                         {\n                           first_vec_index = second_vec_index;\n                           second_vec_index = vec_index;\n@@ -3019,7 +2914,6 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   unsigned int vec_stmts_size, nunits, group_size;\n   tree vectype;\n   int i;\n-  slp_tree loads_node;\n   slp_tree child;\n \n   if (!node)\n@@ -3043,20 +2937,6 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n      size.  */\n   vec_stmts_size = (vectorization_factor * group_size) / nunits;\n \n-  /* In case of load permutation we have to allocate vectorized statements for\n-     all the nodes that participate in that permutation.  */\n-  if (SLP_INSTANCE_LOAD_PERMUTATION (instance).exists ())\n-    {\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, loads_node)\n-        {\n-          if (!SLP_TREE_VEC_STMTS (loads_node).exists ())\n-            {\n-              SLP_TREE_VEC_STMTS (loads_node).create (vec_stmts_size);\n-              SLP_TREE_NUMBER_OF_VEC_STMTS (loads_node) = vec_stmts_size;\n-            }\n-        }\n-    }\n-\n   if (!SLP_TREE_VEC_STMTS (node).exists ())\n     {\n       SLP_TREE_VEC_STMTS (node).create (vec_stmts_size);\n@@ -3074,7 +2954,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   if (SLP_INSTANCE_FIRST_LOAD_STMT (instance)\n       && STMT_VINFO_GROUPED_ACCESS (stmt_info)\n       && !REFERENCE_CLASS_P (gimple_get_lhs (stmt))\n-      && SLP_INSTANCE_LOAD_PERMUTATION (instance).exists ())\n+      && SLP_TREE_LOAD_PERMUTATION (node).exists ())\n     si = gsi_for_stmt (SLP_INSTANCE_FIRST_LOAD_STMT (instance));\n   else if (is_pattern_stmt_p (stmt_info))\n     si = gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n@@ -3153,8 +3033,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n   vec<slp_instance> slp_instances;\n   slp_instance instance;\n-  slp_tree loads_node;\n-  unsigned int i, j, vf;\n+  unsigned int i, vf;\n   bool is_store = false;\n \n   if (loop_vinfo)\n@@ -3173,14 +3052,6 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n                                              instance, vf);\n-\n-      /* Clear STMT_VINFO_VEC_STMT of all loads.  With shared loads\n-         between SLP instances we fail to properly initialize the\n-\t vectorized SLP stmts and confuse different load permutations.  */\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, loads_node)\n-\tSTMT_VINFO_VEC_STMT\n-\t  (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (loads_node)[0])) = NULL;\n-\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"vectorizing stmts using SLP.\");"}, {"sha": "28b80bbe8bcb83c4cd2024d9920fecdeb6d440ce", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "patch": "@@ -4754,12 +4754,21 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       if (slp\n-          && !SLP_INSTANCE_LOAD_PERMUTATION (slp_node_instance).exists ()\n+          && !SLP_TREE_LOAD_PERMUTATION (slp_node).exists ()\n \t  && first_stmt != SLP_TREE_SCALAR_STMTS (slp_node)[0])\n         first_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n \n       /* Check if the chain of loads is already vectorized.  */\n-      if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt)))\n+      if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt))\n+\t  /* For SLP we would need to copy over SLP_TREE_VEC_STMTS.\n+\t     ???  But we can only do so if there is exactly one\n+\t     as we have no way to get at the rest.  Leave the CSE\n+\t     opportunity alone.\n+\t     ???  With the group load eventually participating\n+\t     in multiple different permutations (having multiple\n+\t     slp nodes which refer to the same group) the CSE\n+\t     is even wrong code.  See PR56270.  */\n+\t  && !slp)\n \t{\n \t  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t  return true;\n@@ -4772,7 +4781,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  grouped_load = false;\n \t  vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-          if (SLP_INSTANCE_LOAD_PERMUTATION (slp_node_instance).exists ())\n+          if (SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n             slp_perm = true;\n \t  group_gap = GROUP_GAP (vinfo_for_stmt (first_stmt));\n     \t}\n@@ -5163,7 +5172,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n       if (slp_perm)\n         {\n-          if (!vect_transform_slp_perm_load (stmt, dr_chain, gsi, vf,\n+          if (!vect_transform_slp_perm_load (slp_node, dr_chain, gsi, vf,\n                                              slp_node_instance, false))\n             {\n               dr_chain.release ();"}, {"sha": "2f0374d760c9a8cafc94ebd7ae243fdb58175f29", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=01d8bf070a2ca6a10c66a81f1b5e1c00856b5bc4", "patch": "@@ -106,6 +106,9 @@ struct _slp_tree {\n   vec<slp_tree> children;\n   /* A group of scalar stmts to be vectorized together.  */\n   vec<gimple> stmts;\n+  /* Load permutation relative to the stores, NULL if there is no\n+     permutation.  */\n+  vec<unsigned> load_permutation;\n   /* Vectorized stmt/s.  */\n   vec<gimple> vec_stmts;\n   /* Number of vector stmts that are created to replace the group of scalar\n@@ -131,10 +134,6 @@ typedef struct _slp_instance {\n   /* Vectorization costs associated with SLP instance.  */\n   stmt_vector_for_cost body_cost_vec;\n \n-  /* Loads permutation relatively to the stores, NULL if there is no\n-     permutation.  */\n-  vec<int> load_permutation;\n-\n   /* The group of nodes that contain loads of this SLP instance.  */\n   vec<slp_tree> loads;\n \n@@ -149,14 +148,14 @@ typedef struct _slp_instance {\n #define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_BODY_COST_VEC(S)            (S)->body_cost_vec\n-#define SLP_INSTANCE_LOAD_PERMUTATION(S)         (S)->load_permutation\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n #define SLP_INSTANCE_FIRST_LOAD_STMT(S)          (S)->first_load\n \n #define SLP_TREE_CHILDREN(S)                     (S)->children\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n+#define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n \n /* This structure is used in creation of an SLP tree.  Each instance\n    corresponds to the same operand in a group of scalar stmts in an SLP\n@@ -961,7 +960,7 @@ extern int vect_get_single_scalar_iteration_cost (loop_vec_info);\n \n /* In tree-vect-slp.c.  */\n extern void vect_free_slp_instance (slp_instance);\n-extern bool vect_transform_slp_perm_load (gimple, vec<tree> ,\n+extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n                                           gimple_stmt_iterator *, int,\n                                           slp_instance, bool);\n extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);"}]}