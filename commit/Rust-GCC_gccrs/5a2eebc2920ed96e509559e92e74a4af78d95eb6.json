{"sha": "5a2eebc2920ed96e509559e92e74a4af78d95eb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyZWViYzI5MjBlZDk2ZTUwOTU1OWU5MmU3NGE0YWY3OGQ5NWViNg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-04-17T06:50:21Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T17:04:31Z"}, "message": "Cleanup and fixes to retain desired behaviour", "tree": {"sha": "f6b47c46ed28b73ccf44f9150868feb6ca17f18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6b47c46ed28b73ccf44f9150868feb6ca17f18b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a2eebc2920ed96e509559e92e74a4af78d95eb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2eebc2920ed96e509559e92e74a4af78d95eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2eebc2920ed96e509559e92e74a4af78d95eb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2eebc2920ed96e509559e92e74a4af78d95eb6/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff5f98ee698fc4443c33254bc79fc3baab0d3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff5f98ee698fc4443c33254bc79fc3baab0d3cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff5f98ee698fc4443c33254bc79fc3baab0d3cf"}], "stats": {"total": 552, "additions": 321, "deletions": 231}, "files": [{"sha": "77f1153bd6caeecf5a02f1538f94dc5702983e9f", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -2128,7 +2128,7 @@ namespace Rust {\n             // kind of a HACK to get locus depending on opening scope resolution\n             Location locus = Linemap::unknown_location();\n             if (with_opening_scope_resolution) {\n-                locus = simple_segments[0].get_locus()/* - 2*/; // minus 2 chars for ::\n+                locus = simple_segments[0].get_locus() - 2; // minus 2 chars for ::\n             } else {\n                 locus = simple_segments[0].get_locus();\n             }\n@@ -3455,7 +3455,8 @@ namespace Rust {\n                         return parse_path_meta_item();\n                     }\n                     default:\n-                        rust_error_at(peek_token()->get_locus(), \"unrecognised token '%s' in meta item\",\n+                        rust_error_at(peek_token()->get_locus(),\n+                          \"unrecognised token '%s' in meta item\",\n                           get_token_description(peek_token()->get_id()));\n                         return NULL;\n                 }\n@@ -3578,7 +3579,8 @@ namespace Rust {\n                     Location locus = peek_token()->get_locus();\n                     Literal lit = parse_literal();\n                     if (lit.is_error()) {\n-                        rust_error_at(peek_token()->get_locus(), \"failed to parse literal in attribute\");\n+                        rust_error_at(\n+                          peek_token()->get_locus(), \"failed to parse literal in attribute\");\n                         return NULL;\n                     }\n                     LiteralExpr expr(::std::move(lit), locus);\n@@ -3916,25 +3918,11 @@ namespace Rust {\n         }\n \n         bool MetaNameValueStr::check_cfg_predicate(const Session& session) const {\n-            auto it = session.options.target_data.features.find(ident);\n-            if (it != session.options.target_data.features.end()) {\n-                // value must also be the same, not just the name existing\n-                if (it->second.find(str) != it->second.end()) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return session.options.target_data.has_key_value_pair(ident, str);\n         }\n \n         bool MetaItemPathLit::check_cfg_predicate(const Session& session) const {\n-            auto it = session.options.target_data.features.find(path.as_string());\n-            if (it != session.options.target_data.features.end()) {\n-                // value must also be the same, not just the name existing\n-                if (it->second.find(lit.as_string()) != it->second.end()) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return session.options.target_data.has_key_value_pair(path.as_string(), lit.as_string());\n         }\n \n         ::std::vector< ::std::unique_ptr<Token> > Token::to_token_stream() const {"}, {"sha": "54634efa638cb13792cec75b66bdab87d629f030", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -9,10 +9,13 @@\n #include \"system.h\"\n #include \"coretypes.h\" // order: config, INCLUDE, system, coretypes\n \n-// STL imports\n #include \"rust-system.h\"\n+\n+// STL imports\n // with C++11, now can use actual std::unique_ptr\n #include <memory>\n+#include <string>\n+#include <vector>\n \n // gccrs imports\n // required for AST::Token\n@@ -156,10 +159,8 @@ namespace Rust {\n             }\n \n             // constructor from general text - avoid using if lexer const_TokenPtr is available\n-            Token(\n-              TokenId token_id, Location locus, ::std::string str, PrimitiveCoreType type_hint) :\n-              token_id(token_id),\n-              locus(locus), str(::std::move(str)), type_hint(type_hint) {}\n+            Token(TokenId token_id, Location locus, ::std::string str, PrimitiveCoreType type_hint) :\n+              token_id(token_id), locus(locus), str(::std::move(str)), type_hint(type_hint) {}\n \n             // Constructor from lexer const_TokenPtr\n             /* TODO: find workaround for std::string being NULL - probably have to introduce new\n@@ -276,11 +277,11 @@ namespace Rust {\n             // reference - will be cleaner Parse a meta item inner.\n             //::std::unique_ptr<MetaItemInner> parse_meta_item_inner(const ::std::vector<\n             //::std::unique_ptr<Token> >& token_stream, int& i) const; SimplePath\n-            // parse_simple_path(const ::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i)\n-            // const; SimplePathSegment parse_simple_path_segment(const ::std::vector<\n+            // parse_simple_path(const ::std::vector< ::std::unique_ptr<Token> >& token_stream, int&\n+            // i) const; SimplePathSegment parse_simple_path_segment(const ::std::vector<\n             // ::std::unique_ptr<Token> >& token_stream, int& i) const;\n             //::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit(const ::std::unique_ptr<Token>&\n-            //tok) const;\n+            // tok) const;\n             //::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq(const\n             //::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i) const; Literal\n             // parse_literal(const ::std::unique_ptr<Token>& tok) const;\n@@ -301,12 +302,12 @@ namespace Rust {\n \n           public:\n             DelimTokenTree(DelimType delim_type,\n-                           ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n-                           = ::std::vector< ::std::unique_ptr<TokenTree> >(),\n-                           Location locus = Location()) :\n-                delim_type(delim_type),\n-                token_trees(::std::move(token_trees)), locus(locus) {}\n-            \n+              ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n+              = ::std::vector< ::std::unique_ptr<TokenTree> >(),\n+              Location locus = Location()) :\n+              delim_type(delim_type),\n+              token_trees(::std::move(token_trees)), locus(locus) {}\n+\n             // Copy constructor with vector clone\n             DelimTokenTree(DelimTokenTree const& other) :\n               delim_type(other.delim_type), locus(other.locus) {\n@@ -468,8 +469,8 @@ namespace Rust {\n             }\n \n             // Constructor has pointer AttrInput for polymorphism reasons\n-            Attribute(SimplePath path, ::std::unique_ptr<AttrInput> input,\n-              Location locus = Location()) :\n+            Attribute(\n+              SimplePath path, ::std::unique_ptr<AttrInput> input, Location locus = Location()) :\n               path(::std::move(path)),\n               attr_input(::std::move(input)), locus(locus) {}\n \n@@ -1000,8 +1001,8 @@ namespace Rust {\n \n           public:\n             // Constructor\n-            Lifetime(LifetimeType type, ::std::string name = ::std::string(),\n-              Location locus = Location()) :\n+            Lifetime(\n+              LifetimeType type, ::std::string name = ::std::string(), Location locus = Location()) :\n               lifetime_type(type),\n               lifetime_name(::std::move(name)), locus(locus) {}\n "}, {"sha": "02353d36ec52ea67ba79a42e3fc2f7155bcf3e7b", "filename": "gcc/rust/ast/rust-cond-compilation.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-cond-compilation.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -116,11 +116,11 @@ namespace Rust {\n                 return *this;\n             }\n \n-            // move constructors \n+            // move constructors\n             ConfigurationNot(ConfigurationNot&& other) = default;\n             ConfigurationNot& operator=(ConfigurationNot&& other) = default;\n \n-          virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -150,13 +150,14 @@ namespace Rust {\n                 return *this;\n             }\n \n-            // move constructors \n+            // move constructors\n             CfgAttribute(CfgAttribute&& other) = default;\n             CfgAttribute& operator=(CfgAttribute&& other) = default;\n         };\n-        /* TODO: ok, best thing to do would be eliminating this class, making Attribute has a \"is_cfg()\"\n-         * method, and having attribute path as \"cfg\" and AttrInput as ConfigurationPredicate (so make\n-         * ConfigurationPredicate a subclass of AttrInput?). Would need special handling in parser, however. */\n+        /* TODO: ok, best thing to do would be eliminating this class, making Attribute has a\n+         * \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n+         * ConfigurationPredicate (so make ConfigurationPredicate a subclass of AttrInput?). Would\n+         * need special handling in parser, however. */\n \n         // TODO: inline\n         struct CfgAttrs {\n@@ -189,7 +190,7 @@ namespace Rust {\n                 return *this;\n             }\n \n-            // move constructors \n+            // move constructors\n             CfgAttrAttribute(CfgAttrAttribute&& other) = default;\n             CfgAttrAttribute& operator=(CfgAttrAttribute&& other) = default;\n         };"}, {"sha": "992801f6b45fbc0fa0fa7092bc37b75cfa134172", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -198,7 +198,8 @@ namespace Rust {\n             virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n             virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-            // TODO: return true if \"ident\" is defined and value of it is \"lit\", return false otherwise\n+            // TODO: return true if \"ident\" is defined and value of it is \"lit\", return false\n+            // otherwise\n \n           protected:\n             // Use covariance to implement clone function as returning this type\n@@ -1865,8 +1866,8 @@ namespace Rust {\n                 // return struct_name.as_string();\n             }\n \n-            StructExprUnit(PathInExpression struct_path, ::std::vector<Attribute> outer_attribs,\n-              Location locus) :\n+            StructExprUnit(\n+              PathInExpression struct_path, ::std::vector<Attribute> outer_attribs, Location locus) :\n               StructExpr(::std::move(struct_path), ::std::move(outer_attribs)),\n               locus(locus) {}\n \n@@ -2893,8 +2894,7 @@ namespace Rust {\n \n           protected:\n             // outer attributes not allowed before range expressions\n-            RangeExpr(Location locus) :\n-              ExprWithoutBlock(::std::vector<Attribute>()), locus(locus) {}\n+            RangeExpr(Location locus) : ExprWithoutBlock(::std::vector<Attribute>()), locus(locus) {}\n \n           public:\n             Location get_locus() const {\n@@ -2922,8 +2922,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            RangeFromToExpr(::std::unique_ptr<Expr> range_from, ::std::unique_ptr<Expr> range_to,\n-              Location locus) :\n+            RangeFromToExpr(\n+              ::std::unique_ptr<Expr> range_from, ::std::unique_ptr<Expr> range_to, Location locus) :\n               RangeExpr(locus),\n               from(::std::move(range_from)), to(::std::move(range_to)) {}\n \n@@ -3095,8 +3095,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            RangeFromToInclExpr(::std::unique_ptr<Expr> range_from, ::std::unique_ptr<Expr> range_to,\n-              Location locus) :\n+            RangeFromToInclExpr(\n+              ::std::unique_ptr<Expr> range_from, ::std::unique_ptr<Expr> range_to, Location locus) :\n               RangeExpr(locus),\n               from(::std::move(range_from)), to(::std::move(range_to)) {}\n             // outer attributes not allowed\n@@ -3860,8 +3860,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             IfLetExpr(::std::vector< ::std::unique_ptr<Pattern> > match_arm_patterns,\n-              ::std::unique_ptr<Expr> value, ::std::unique_ptr<BlockExpr> if_block,\n-              Location locus) :\n+              ::std::unique_ptr<Expr> value, ::std::unique_ptr<BlockExpr> if_block, Location locus) :\n               ExprWithBlock(::std::vector<Attribute>()),\n               match_arm_patterns(::std::move(match_arm_patterns)), value(::std::move(value)),\n               if_block(::std::move(if_block)), locus(locus) {}"}, {"sha": "8d732a7bade969a5d486b5e2f2d3614765a5595f", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -1697,10 +1697,9 @@ namespace Rust {\n                 return !outer_attrs.empty();\n             }\n \n-            EnumItem(\n-              Identifier variant_name, ::std::vector<Attribute> outer_attrs, Location locus) :\n-              outer_attrs(::std::move(outer_attrs)),\n-              variant_name(::std::move(variant_name)), locus(locus) {}\n+            EnumItem(Identifier variant_name, ::std::vector<Attribute> outer_attrs, Location locus) :\n+              outer_attrs(::std::move(outer_attrs)), variant_name(::std::move(variant_name)),\n+              locus(locus) {}\n \n             // Unique pointer custom clone function\n             ::std::unique_ptr<EnumItem> clone_enum_item() const {"}, {"sha": "727b195be59fc045a0d667981c8cbc54135435bd", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -288,8 +288,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             MacroRulesDefinition(Identifier rule_name, DelimType delim_type,\n-              ::std::vector<MacroRule> rules, ::std::vector<Attribute> outer_attrs,\n-              Location locus) :\n+              ::std::vector<MacroRule> rules, ::std::vector<Attribute> outer_attrs, Location locus) :\n               MacroItem(::std::move(outer_attrs)),\n               rule_name(::std::move(rule_name)), delim_type(delim_type), rules(::std::move(rules)),\n               locus(locus) {}\n@@ -377,7 +376,7 @@ namespace Rust {\n                 return path;\n             }\n \n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE; \n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this type\n@@ -451,7 +450,7 @@ namespace Rust {\n \n             virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE; \n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this type\n@@ -480,7 +479,7 @@ namespace Rust {\n                 return clone_meta_item_inner_impl();\n             }\n \n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE; \n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this type"}, {"sha": "6845603f142a41458ed04ebb0011930eeb16f486", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -29,7 +29,8 @@ namespace Rust {\n             /* TODO: insert check in constructor for this? Or is this a semantic error best handled\n              * then? */\n \n-            // TODO: does this require visitor. pretty sure this isn't polymorphic, but not entirely sure\n+            // TODO: does this require visitor. pretty sure this isn't polymorphic, but not entirely\n+            // sure\n \n             // Creates an error PathIdentSegment.\n             static PathIdentSegment create_error() {\n@@ -67,8 +68,8 @@ namespace Rust {\n             }\n \n             // Pointer type for type in constructor to enable polymorphism\n-            GenericArgsBinding(Identifier ident, ::std::unique_ptr<Type> type_ptr,\n-              Location locus = Location()) :\n+            GenericArgsBinding(\n+              Identifier ident, ::std::unique_ptr<Type> type_ptr, Location locus = Location()) :\n               identifier(::std::move(ident)),\n               type(::std::move(type_ptr)), locus(locus) {}\n \n@@ -326,8 +327,8 @@ namespace Rust {\n                 return ::std::unique_ptr<TypePathSegment>(clone_type_path_segment_impl());\n             }\n \n-            TypePathSegment(PathIdentSegment ident_segment, bool has_separating_scope_resolution,\n-              Location locus) :\n+            TypePathSegment(\n+              PathIdentSegment ident_segment, bool has_separating_scope_resolution, Location locus) :\n               ident_segment(::std::move(ident_segment)),\n               locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n \n@@ -496,8 +497,7 @@ namespace Rust {\n           public:\n             // Constructor with PathIdentSegment and TypePathFn\n             TypePathSegmentFunction(PathIdentSegment ident_segment,\n-              bool has_separating_scope_resolution, TypePathFunction function_path,\n-              Location locus) :\n+              bool has_separating_scope_resolution, TypePathFunction function_path, Location locus) :\n               TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n               function_path(::std::move(function_path)) {}\n \n@@ -554,16 +554,12 @@ namespace Rust {\n \n             // Creates an error state TypePath.\n             static TypePath create_error() {\n-                return TypePath(\n-                    ::std::vector< ::std::unique_ptr<TypePathSegment> >(),\n-                    Linemap::unknown_location(),\n-                    false);\n+                return TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> >(), Location());\n             }\n \n             // Constructor\n-            TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> > segments,\n-                     Location locus,\n-                     bool has_opening_scope_resolution = false) :\n+            TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> > segments, Location locus,\n+              bool has_opening_scope_resolution = false) :\n               has_opening_scope_resolution(has_opening_scope_resolution),\n               segments(::std::move(segments)), locus(locus) {}\n \n@@ -625,8 +621,8 @@ namespace Rust {\n \n           public:\n             // Constructor\n-            QualifiedPathType(::std::unique_ptr<Type> invoke_on_type,\n-              Location locus = Location(), TypePath trait_path = TypePath::create_error()) :\n+            QualifiedPathType(::std::unique_ptr<Type> invoke_on_type, Location locus = Location(),\n+              TypePath trait_path = TypePath::create_error()) :\n               type_to_invoke_on(::std::move(invoke_on_type)),\n               trait_path(::std::move(trait_path)), locus(locus) {}\n "}, {"sha": "2ca973ab182d972c2b0d3f81b0149074013f703b", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -68,8 +68,8 @@ namespace Rust {\n             }\n \n           public:\n-            ImplTraitType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n-              Location locus) :\n+            ImplTraitType(\n+              ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds, Location locus) :\n               type_param_bounds(::std::move(type_param_bounds)),\n               locus(locus) {}\n \n@@ -480,8 +480,8 @@ namespace Rust {\n             }\n \n             // Constructor\n-            ReferenceType(bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n-              Location locus, Lifetime lifetime = Lifetime::error()) :\n+            ReferenceType(bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus,\n+              Lifetime lifetime = Lifetime::error()) :\n               lifetime(::std::move(lifetime)),\n               has_mut(is_mut), type(::std::move(type_no_bounds)), locus(locus) {}\n "}, {"sha": "8454847de264c0136e63d5928cde94f43035f851", "filename": "gcc/rust/backend.h", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -1,18 +1,14 @@\n-// backend.h -- Rust frontend interface to backend  -*- C++ -*-\n-\n-// Copyright 2011 The Rust Authors. All rights reserved.\n-// Use of this source code is rustverned by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#ifndef RUST_BACKEND_H\n-#define RUST_BACKEND_H\n+#pragma once\n \n #include <gmp.h>\n #include <mpfr.h>\n #include <mpc.h>\n \n #include \"operator.h\"\n \n+// TODO: Will have to be significantly modified to work with Rust and current\n+// setup of gccrs\n+\n // Pointers to these types are created by the backend, passed to the\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n@@ -95,7 +91,7 @@ class Backend\n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n   // is provided so that the names are available.  This should return\n-  // not the type of a Rust function (which is a pointer to a struct)\n+  // not the type of a Go function (which is a pointer to a struct)\n   // but the type of a C function pointer (which will be used as the\n   // type of the first field of the struct).  If there is more than\n   // one result, RESULT_STRUCT is a struct type to hold the results,\n@@ -115,12 +111,12 @@ class Backend\n   virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n \n   // Create a placeholder pointer type.  This is used for a named\n-  // pointer type, since in Rust a pointer type may refer to itself.\n+  // pointer type, since in Go a pointer type may refer to itself.\n   // NAME is the name of the type, and the location is where the named\n   // type is defined.  This function is also used for unnamed function\n   // types with multiple results, in which case the type has no name\n   // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n-  // pointer to function type.  A Rust func type is represented as a\n+  // pointer to function type.  A Go func type is represented as a\n   // pointer to a struct, and the first field of the struct is a C\n   // pointer to function.  The return value will later be passed as\n   // the first parameter to set_placeholder_pointer_type or\n@@ -139,7 +135,7 @@ class Backend\n \n   // Fill in a placeholder pointer type as a function.  This takes a\n   // type returned by placeholder_pointer_type and arranges for it to\n-  // become a real Rust function type (which corresponds to a C/C++\n+  // become a real Go function type (which corresponds to a C/C++\n   // pointer to function type).  FT will be something returned by the\n   // function_type method.  Returns true on success, false on failure.\n   virtual bool set_placeholder_function_type (Btype *placeholder, Btype *ft)\n@@ -181,7 +177,7 @@ class Backend\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n   virtual Btype *named_type (const std::string &name, Btype *, Location) = 0;\n \n-  // Create a marker for a circular pointer type.  Rust pointer and\n+  // Create a marker for a circular pointer type.  Go pointer and\n   // function types can refer to themselves in ways that are not\n   // permitted in C/C++.  When a circular type is found, this function\n   // is called for the circular reference.  This permits the backend\n@@ -228,7 +224,7 @@ class Backend\n \n   // Create an error expression. This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // rusting without crashing.\n+  // going without crashing.\n   virtual Bexpression *error_expression () = 0;\n \n   // Create a nil pointer expression.\n@@ -367,7 +363,7 @@ class Backend\n \n   // Create an error statement.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // rusting without crashing.\n+  // going without crashing.\n   virtual Bstatement *error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n@@ -419,7 +415,7 @@ class Backend\n   // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n   // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n   // if not NULL, it will always be executed.  This is used for handling defers\n-  // in Rust functions.  In C++, the resulting code is of this form:\n+  // in Go functions.  In C++, the resulting code is of this form:\n   //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n   virtual Bstatement *\n   exception_handler_statement (Bstatement *bstat, Bstatement *except_stmt,\n@@ -459,7 +455,7 @@ class Backend\n \n   // Create an error variable.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // rusting without crashing.\n+  // going without crashing.\n   virtual Bvariable *error_variable () = 0;\n \n   // Create a global variable. NAME is the package-qualified name of\n@@ -672,7 +668,7 @@ class Backend\n \n   // Create an error function.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // rusting without crashing.\n+  // going without crashing.\n   virtual Bfunction *error_function () = 0;\n \n   // Bit flags to pass to the function method.\n@@ -710,7 +706,7 @@ class Backend\n   static const unsigned int function_only_inline = 1 << 6;\n \n   // Declare or define a function of FNTYPE.\n-  // NAME is the Rust name of the function.  ASM_NAME, if not the empty\n+  // NAME is the Go name of the function.  ASM_NAME, if not the empty\n   // string, is the name that should be used in the symbol table; this\n   // will be non-empty if a magic extern comment is used.  FLAGS is\n   // bit flags described above.\n@@ -760,5 +756,3 @@ class Backend\n   // section in the output object file.\n   virtual void write_export_data (const char *bytes, unsigned int size) = 0;\n };\n-\n-#endif // !defined(RUST_BACKEND_H)"}, {"sha": "8b2a05821e5d50b8b46fb50acc81264b94e63142", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -95,8 +95,21 @@ namespace Rust {\n     }\n \n     Lexer::~Lexer() {\n+        /* ok apparently stop (which is equivalent of original code in destructor) is meant to be\n+         * called after all files have finished parsing, for cleanup. On the other hand, actual code\n+         * that it calls to leave a certain line map is mentioned in GCC docs as being useful for\n+         * \"just leaving an included header\" and stuff like that, so this line mapping functionality\n+         * may need fixing.\n+         * FIXME: find out whether this occurs. */\n+        // line_map->stop();\n     }\n \n+    // TODO: need to optimise somehow to avoid the virtual function call in the tight loop.\n+    // Best idea at the moment is CRTP, but that might make lexer implementation annoying when storing\n+    // the \"base class\" (i.e. would need template parameter everywhere), although in practice it would\n+    // mostly just look ugly and make enclosing classes like Parser also require a type parameter.\n+    // At this point a macro might be better.\n+    // OK I guess macros can be replaced by constexpr if or something if possible.\n     Location Lexer::get_current_location() {\n         return line_map->get_location(current_column);\n     }\n@@ -186,7 +199,7 @@ namespace Rust {\n             }\n \n             // detect shebang\n-            if (current_line == 1 && current_char == '#') {\n+            if (loc == 1 && current_line == 1 && current_char == '#') {\n                 current_char = peek_input();\n \n                 if (current_char == '!') {\n@@ -1549,7 +1562,8 @@ namespace Rust {\n                 // ensure closing brace\n                 if (need_close_brace && current_char != '}') {\n                     // actually an error\n-                    rust_error_at(get_current_location(), \"expected terminating '}' in unicode escape\");\n+                    rust_error_at(\n+                      get_current_location(), \"expected terminating '}' in unicode escape\");\n                     return false;\n                 }\n "}, {"sha": "a70536707bf1b6a943a7a445e716b5980c23f1d9", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -30,20 +30,22 @@ namespace Rust {\n         // ok maybe all these may mean the lexer structure needs to be rethought\n         /* separated into functions because main method was too long, but they rely on and change\n          * state in the lexer, so variables must be passed by reference. */\n-        inline void parse_in_decimal(/*char& current_char, */std::string& str, int& length);\n-        inline void parse_in_exponent_part(/*char& current_char, */std::string& str, int& length);\n+        inline void parse_in_decimal(/*char& current_char, */ std::string& str, int& length);\n+        inline void parse_in_exponent_part(/*char& current_char, */ std::string& str, int& length);\n         inline bool parse_in_type_suffix(\n-          /*char& current_char, */PrimitiveCoreType& type_hint, int& length);\n-        inline bool parse_ascii_escape(/*char& current_char, */int& length, char& output_char);\n-        inline bool parse_quote_escape(/*char& current_char, */int& length, char& output_char);\n-        inline bool parse_unicode_escape(/*char& current_char, */int& length, Codepoint& output_char);\n-        inline bool parse_byte_escape(/*char& current_char, */int& length, char& output_char);\n+          /*char& current_char, */ PrimitiveCoreType& type_hint, int& length);\n+        inline bool parse_ascii_escape(/*char& current_char, */ int& length, char& output_char);\n+        inline bool parse_quote_escape(/*char& current_char, */ int& length, char& output_char);\n+        inline bool parse_unicode_escape(\n+          /*char& current_char, */ int& length, Codepoint& output_char);\n+        inline bool parse_byte_escape(/*char& current_char, */ int& length, char& output_char);\n         inline bool parse_escape(int& length, char& output_char, char opening_char);\n         inline bool parse_utf8_escape(int& length, Codepoint& output_char, char opening_char);\n         inline int test_get_input_codepoint_length();\n         inline int test_get_input_codepoint_n_length(int n_start_offset);\n         inline Codepoint test_peek_codepoint_input();\n-        inline Codepoint test_peek_codepoint_input(int n); // maybe can use get_input_codepoint_length to get starting index\n+        inline Codepoint test_peek_codepoint_input(\n+          int n); // maybe can use get_input_codepoint_length to get starting index\n         inline void test_skip_codepoint_input();\n \n       public:\n@@ -64,7 +66,9 @@ namespace Rust {\n         // Replaces the current token with a specified token.\n         void replace_current_token(TokenPtr replacement);\n \n-        Linemap* get_line_map() { return line_map; }\n+        Linemap* get_line_map() {\n+            return line_map;\n+        }\n \n       private:\n         // File for use as input."}, {"sha": "560f4bbe528494777c0a6ebd49a4bd1436be0ea8", "filename": "gcc/rust/operator.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Foperator.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -9,6 +9,8 @@\n \n // The operators.\n \n+// TODO: Will have to be significantly modified to work with Rust and current setup of gccrs\n+\n enum Operator\n {\n   OPERATOR_INVALID,"}, {"sha": "cef28f72d1ff90bcbe455b18653645f364763ffa", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 136, "deletions": 100, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -2,6 +2,29 @@\n #include \"rust-linemap.h\"\n #include \"rust-diagnostics.h\"\n \n+#if 0\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"input.h\"\n+#include \"diagnostic.h\"\n+#include \"stringpool.h\"\n+#include \"cgraph.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-expr.h\"\n+#include \"convert.h\"\n+#include \"print-tree.h\"\n+#include \"stor-layout.h\"\n+#include \"fold-const.h\"\n+/* order: config, system, coretypes, target, tree, tree-iterator, input, diagnostic, stringpool,\n+ * cgraph, gimplify, gimple-expr, convert, print-tree, stor-layout, fold-const  */\n+// probably don't need all these\n+#endif\n+// maybe put these back in if compiling no longer works\n+\n #include <algorithm> // for std::find\n \n namespace Rust {\n@@ -159,7 +182,7 @@ namespace Rust {\n                 /* shit. preferred HACK would be to replace this token in stream with '>', but may not\n                  * be possible at this point. */\n                 // FIXME: ensure locations aren't messed up\n-                TokenPtr right_angle = Token::make(RIGHT_ANGLE, tok->get_locus());\n+                TokenPtr right_angle = Token::make(RIGHT_ANGLE, tok->get_locus() + 1);\n                 lexer.replace_current_token(right_angle);\n                 return true;\n             }\n@@ -168,20 +191,21 @@ namespace Rust {\n                 /* FIXME: is this even required? how many people wouldn't leave a space? - apparently\n                  * rustc has this feature */\n                 // FIXME: ensure locations aren't messed up\n-                TokenPtr equal = Token::make(EQUAL, tok->get_locus());\n+                TokenPtr equal = Token::make(EQUAL, tok->get_locus() + 1);\n                 lexer.replace_current_token(equal);\n                 return true;\n             }\n             case RIGHT_SHIFT_EQ: {\n                 // another HACK - replace with greater or equal\n                 // FIXME: again, is this really required? rustc has the feature, though\n                 // FIXME: ensure locations aren't messed up\n-                TokenPtr greater_equal = Token::make(GREATER_OR_EQUAL, tok->get_locus());\n+                TokenPtr greater_equal = Token::make(GREATER_OR_EQUAL, tok->get_locus() + 1);\n                 lexer.replace_current_token(greater_equal);\n                 return true;\n             }\n             default:\n-                rust_error_at(tok->get_locus(), \"expected '>' at end of generic argument - found '%s'\",\n+                rust_error_at(tok->get_locus(),\n+                  \"expected '>' at end of generic argument - found '%s'\",\n                   tok->get_token_description());\n                 return false;\n         }\n@@ -329,7 +353,6 @@ namespace Rust {\n         return (t->get_id() == END_OF_FILE);\n     }\n \n-\n     // Parses a crate (compilation unit) - entry point\n     AST::Crate Parser::parse_crate() {\n         /* TODO: determine if has utf8bom and shebang. Currently, they are eliminated by the lexing\n@@ -516,8 +539,8 @@ namespace Rust {\n                 gcc_fallthrough();\n             default:\n                 // do nothing but inactivates warning from gcc when compiling\n-                // could put the rust_error_at thing here but fallthrough (from failing $crate condition)\n-                // isn't completely obvious if it is.\n+                // could put the rust_error_at thing here but fallthrough (from failing $crate\n+                // condition) isn't completely obvious if it is.\n \n                 // test prevent error\n                 return AST::SimplePathSegment::create_error();\n@@ -1406,7 +1429,8 @@ namespace Rust {\n             ::std::unique_ptr<AST::MacroMatch> match = parse_macro_match();\n \n             if (match == NULL) {\n-                rust_error_at(t->get_locus(), \"failed to parse macro match for macro matcher - found '%s'\",\n+                rust_error_at(t->get_locus(),\n+                  \"failed to parse macro match for macro matcher - found '%s'\",\n                   t->get_token_description());\n                 return AST::MacroMatcher::create_error();\n             }\n@@ -1499,7 +1523,8 @@ namespace Rust {\n \n         const_TokenPtr ident_tok = expect_token(IDENTIFIER);\n         if (ident_tok == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"missing identifier in macro match fragment\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"missing identifier in macro match fragment\");\n             return NULL;\n         }\n         Identifier ident = ident_tok->get_str();\n@@ -1825,7 +1850,8 @@ namespace Rust {\n         // parse use tree, which is required\n         ::std::unique_ptr<AST::UseTree> use_tree = parse_use_tree();\n         if (use_tree == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"could not parse use tree in use declaration\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"could not parse use tree in use declaration\");\n             skip_after_semicolon();\n             return NULL;\n         }\n@@ -2828,7 +2854,8 @@ namespace Rust {\n         // TODO: use this token for identifier when finished that\n         const_TokenPtr alias_name_tok = expect_token(IDENTIFIER);\n         if (alias_name_tok == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"could not parse identifier in type alias\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"could not parse identifier in type alias\");\n             skip_after_semicolon();\n             return NULL;\n         }\n@@ -3089,7 +3116,8 @@ namespace Rust {\n         ::std::unique_ptr<AST::Type> field_type = parse_type();\n         if (field_type == NULL) {\n             // error if null\n-            rust_error_at(lexer.peek_token()->get_locus(), \"could not parse type in tuple struct field\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"could not parse type in tuple struct field\");\n             // skip after something\n             return AST::TupleField::create_error();\n         }\n@@ -3675,7 +3703,8 @@ namespace Rust {\n             }\n             // Type is required, so error if null\n             if (type == NULL) {\n-                rust_error_at(lexer.peek_token()->get_locus(), \"could not parse type in inherent impl\");\n+                rust_error_at(\n+                  lexer.peek_token()->get_locus(), \"could not parse type in inherent impl\");\n                 skip_after_next_block();\n                 return NULL;\n             }\n@@ -3841,7 +3870,8 @@ namespace Rust {\n                                 return NULL;\n                         }\n                     default:\n-                        rust_error_at(t->get_locus(), \"unrecognised token '%s' for item in inherent impl\",\n+                        rust_error_at(t->get_locus(),\n+                          \"unrecognised token '%s' for item in inherent impl\",\n                           t->get_token_description());\n                         // skip?\n                         return NULL;\n@@ -3886,8 +3916,8 @@ namespace Rust {\n     /* For internal use only by parse_inherent_impl_item() - splits giant method into smaller ones\n      * and prevents duplication of logic. Strictly, this parses a function or method item inside an\n      * inherent impl item block. */\n-    // TODO: make this a templated function with \"return type\" as type param - InherentImplItem is this \n-    // specialisation of the template while TraitImplItem will be the other.\n+    // TODO: make this a templated function with \"return type\" as type param - InherentImplItem is\n+    // this specialisation of the template while TraitImplItem will be the other.\n     ::std::unique_ptr<AST::InherentImplItem> Parser::parse_inherent_impl_function_or_method(\n       AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs) {\n         Location locus = lexer.peek_token()->get_locus();\n@@ -4022,7 +4052,8 @@ namespace Rust {\n                                 return NULL;\n                         }\n                     default:\n-                        rust_error_at(t->get_locus(), \"unrecognised token '%s' for item in trait impl\",\n+                        rust_error_at(t->get_locus(),\n+                          \"unrecognised token '%s' for item in trait impl\",\n                           t->get_token_description());\n                         // skip?\n                         return NULL;\n@@ -4379,7 +4410,8 @@ namespace Rust {\n             }\n             default:\n                 // error\n-                rust_error_at(t->get_locus(), \"unrecognised token '%s' in extern block item declaration\",\n+                rust_error_at(t->get_locus(),\n+                  \"unrecognised token '%s' in extern block item declaration\",\n                   t->get_token_description());\n                 skip_after_semicolon();\n                 return NULL;\n@@ -4505,7 +4537,8 @@ namespace Rust {\n         // parse pattern (required)\n         ::std::unique_ptr<AST::Pattern> pattern = parse_pattern();\n         if (pattern == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse pattern in let statement\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"failed to parse pattern in let statement\");\n             skip_after_semicolon();\n             return NULL;\n         }\n@@ -4518,7 +4551,8 @@ namespace Rust {\n \n             type = parse_type();\n             if (type == NULL) {\n-                rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse type in let statement\");\n+                rust_error_at(\n+                  lexer.peek_token()->get_locus(), \"failed to parse type in let statement\");\n                 skip_after_semicolon();\n                 return NULL;\n             }\n@@ -4589,9 +4623,8 @@ namespace Rust {\n             t = lexer.peek_token();\n         }\n \n-         return AST::TypePath(::std::move(segments),\n-                              Linemap::unknown_location(),\n-                              has_opening_scope_resolution);\n+        return AST::TypePath(\n+          ::std::move(segments), Linemap::unknown_location(), has_opening_scope_resolution);\n     }\n \n     // Parses the generic arguments in each path segment.\n@@ -4963,13 +4996,14 @@ namespace Rust {\n             }\n         } else {\n             // move back by 1 if pratt parsing due to skipping '<'\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 1;\n         }\n \n         // parse type (required)\n         ::std::unique_ptr<AST::Type> type = parse_type();\n         if (type == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"could not parse type in qualified path type\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"could not parse type in qualified path type\");\n             // skip somewhere?\n             return AST::QualifiedPathType::create_error();\n         }\n@@ -5183,7 +5217,8 @@ namespace Rust {\n         // parse block expression\n         ::std::unique_ptr<AST::BlockExpr> block_expr = parse_block_expr();\n         if (block_expr == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"method declaration missing block expression\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"method declaration missing block expression\");\n             skip_after_end_block();\n             return AST::Method::create_error();\n         }\n@@ -5319,7 +5354,8 @@ namespace Rust {\n \n         // ensure expr parsed exists\n         if (expr_parsed == NULL) {\n-            rust_error_at(t->get_locus(), \"failed to parse expr with block in parsing expr statement\");\n+            rust_error_at(\n+              t->get_locus(), \"failed to parse expr with block in parsing expr statement\");\n             skip_after_end_block();\n             return NULL;\n         }\n@@ -5437,7 +5473,7 @@ namespace Rust {\n \n                 if (expr == NULL) {\n                     rust_error_at(t->get_locus(), \"failed to parse expression for expression without \"\n-                                             \"block (pratt-parsed expression is null)\");\n+                                                  \"block (pratt-parsed expression is null)\");\n                     return NULL;\n                 }\n \n@@ -5474,7 +5510,7 @@ namespace Rust {\n                 return NULL;\n             }\n         } else {\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 1;\n         }\n \n         ::std::vector<AST::Attribute> inner_attrs = parse_inner_attributes();\n@@ -5506,7 +5542,7 @@ namespace Rust {\n \n         if (!skip_token(RIGHT_CURLY)) {\n             rust_error_at(t->get_locus(), \"error may be from having an expression (as opposed to \"\n-                                     \"statement) in the body of the function but not last\");\n+                                          \"statement) in the body of the function but not last\");\n             skip_after_end_block();\n             return NULL;\n         }\n@@ -5621,7 +5657,8 @@ namespace Rust {\n             ::std::unique_ptr<AST::BlockExpr> block = parse_block_expr();\n             if (block == NULL) {\n                 // error\n-                rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse block expr in closure\");\n+                rust_error_at(\n+                  lexer.peek_token()->get_locus(), \"failed to parse block expr in closure\");\n                 // skip somewhere?\n                 return NULL;\n             }\n@@ -5725,7 +5762,7 @@ namespace Rust {\n         } else {\n             // minus 7 chars for 6 in return and a space\n             // or just TODO: pass in location data\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 7;\n         }\n \n         // parse expression to return, if it exists\n@@ -5747,7 +5784,7 @@ namespace Rust {\n         } else {\n             // minus 6 chars for 5 in return and a space\n             // or just TODO: pass in location data\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 6;\n         }\n \n         // parse label (lifetime) if it exists - create dummy first\n@@ -5774,7 +5811,7 @@ namespace Rust {\n         } else {\n             // minus 9 chars for 8 in return and a space\n             // or just TODO: pass in location data\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 9;\n         }\n \n         // parse label (lifetime) if it exists - create dummy first\n@@ -6034,7 +6071,8 @@ namespace Rust {\n                 }\n                 default:\n                     // error - invalid token\n-                    rust_error_at(t->get_locus(), \"unexpected token '%s' after else in if let expression\",\n+                    rust_error_at(t->get_locus(),\n+                      \"unexpected token '%s' after else in if let expression\",\n                       t->get_token_description());\n                     // skip somewhere?\n                     return NULL;\n@@ -6190,7 +6228,8 @@ namespace Rust {\n         // parse pattern, which is required\n         ::std::unique_ptr<AST::Pattern> pattern = parse_pattern();\n         if (pattern == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse iterator pattern in for loop\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"failed to parse iterator pattern in for loop\");\n             // skip somewhere?\n             return NULL;\n         }\n@@ -6283,7 +6322,7 @@ namespace Rust {\n         } else {\n             // TODO: probably just pass in location data as param\n             // get current pos then move back 6 - 5 for match, 1 for space\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 6;\n         }\n \n         // parse scrutinee expression, which is required (and HACK to prevent struct expr)\n@@ -6409,7 +6448,8 @@ namespace Rust {\n         ::std::vector< ::std::unique_ptr<AST::Pattern> > match_arm_patterns\n           = parse_match_arm_patterns(RIGHT_CURLY);\n         if (match_arm_patterns.empty()) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse any patterns in match arm\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"failed to parse any patterns in match arm\");\n             // skip somewhere?\n             return AST::MatchArm::create_error();\n         }\n@@ -6552,7 +6592,7 @@ namespace Rust {\n \n             skip_token(LEFT_SQUARE);\n         } else {\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 1;\n         }\n \n         // parse optional inner attributes\n@@ -6665,7 +6705,8 @@ namespace Rust {\n             // parse type, which is now required\n             type = parse_type();\n             if (type == NULL) {\n-                rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse type in closure parameter\");\n+                rust_error_at(\n+                  lexer.peek_token()->get_locus(), \"failed to parse type in closure parameter\");\n                 // skip somewhere?\n                 return AST::ClosureParam::create_error();\n             }\n@@ -6684,7 +6725,7 @@ namespace Rust {\n \n             skip_token(LEFT_PAREN);\n         } else {\n-            locus = lexer.peek_token()->get_locus();\n+            locus = lexer.peek_token()->get_locus() - 1;\n         }\n \n         // parse optional inner attributes\n@@ -6735,7 +6776,8 @@ namespace Rust {\n                 // parse expr, which is now required\n                 ::std::unique_ptr<AST::Expr> expr = parse_expr();\n                 if (expr == NULL) {\n-                    rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse expr in tuple expr\");\n+                    rust_error_at(\n+                      lexer.peek_token()->get_locus(), \"failed to parse expr in tuple expr\");\n                     // skip somewhere?\n                     return NULL;\n                 }\n@@ -7255,7 +7297,8 @@ namespace Rust {\n         // parse type (required)\n         ::std::unique_ptr<AST::Type> type = parse_type();\n         if (type == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse type in maybe named param\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"failed to parse type in maybe named param\");\n             return AST::MaybeNamedParam::create_error();\n         }\n \n@@ -7300,7 +7343,8 @@ namespace Rust {\n             // parse required param\n             AST::MaybeNamedParam param = parse_maybe_named_param();\n             if (param.is_error()) {\n-                rust_error_at(t->get_locus(), \"failed to parse maybe named param in bare function type\");\n+                rust_error_at(\n+                  t->get_locus(), \"failed to parse maybe named param in bare function type\");\n                 return NULL;\n             }\n             params.push_back(::std::move(param));\n@@ -7491,7 +7535,7 @@ namespace Rust {\n                 // probably a lifetime bound, so probably type param bounds in TraitObjectType\n                 // this is not allowed, but detection here for error message\n                 rust_error_at(t->get_locus(), \"lifetime bounds (i.e. in type param bounds, in \"\n-                                         \"TraitObjectType) are not allowed as TypeNoBounds\");\n+                                              \"TraitObjectType) are not allowed as TypeNoBounds\");\n                 return NULL;\n             }\n             case IDENTIFIER:\n@@ -7586,8 +7630,9 @@ namespace Rust {\n                     // ensure not a trait with multiple bounds\n                     t = lexer.peek_token();\n                     if (t->get_id() == PLUS) {\n-                        rust_error_at(t->get_locus(), \"plus after trait bound means an ImplTraitType, \"\n-                                                 \"which is not allowed as a TypeNoBounds\");\n+                        rust_error_at(t->get_locus(),\n+                          \"plus after trait bound means an ImplTraitType, \"\n+                          \"which is not allowed as a TypeNoBounds\");\n                         return NULL;\n                     }\n \n@@ -7631,7 +7676,7 @@ namespace Rust {\n                 t = lexer.peek_token();\n                 if (t->get_id() == PLUS) {\n                     rust_error_at(t->get_locus(), \"plus after trait bound means a TraitObjectType, \"\n-                                             \"which is not allowed as a TypeNoBounds\");\n+                                                  \"which is not allowed as a TypeNoBounds\");\n                     return NULL;\n                 }\n \n@@ -7698,8 +7743,8 @@ namespace Rust {\n             if (lexer.peek_token()->get_id() == PLUS) {\n                 // error - this is not allowed for type no bounds\n                 rust_error_at(lexer.peek_token()->get_locus(),\n-                              \"plus (implying TraitObjectType as type param \"\n-                              \"bounds) is not allowed in type no bounds\");\n+                  \"plus (implying TraitObjectType as type param \"\n+                  \"bounds) is not allowed in type no bounds\");\n                 return NULL;\n             } else {\n                 // release vector pointer\n@@ -7794,17 +7839,13 @@ namespace Rust {\n         if (next->get_id() == DOT_DOT_EQ || next->get_id() == ELLIPSIS) {\n             // range pattern\n             lexer.skip_token();\n-            ::std::unique_ptr<AST::RangePatternBound> lower(\n-                new AST::RangePatternBoundLiteral(\n-                    AST::Literal(range_lower->get_str(), type),\n-                    range_lower->get_locus(),\n-                    has_minus)\n-                );\n+            ::std::unique_ptr<AST::RangePatternBound> lower(new AST::RangePatternBoundLiteral(\n+              AST::Literal(range_lower->get_str(), type), range_lower->get_locus(), has_minus));\n \n             ::std::unique_ptr<AST::RangePatternBound> upper = parse_range_pattern_bound();\n             if (upper == NULL) {\n-                rust_error_at(next->get_locus(),\n-                              \"failed to parse range pattern bound in range pattern\");\n+                rust_error_at(\n+                  next->get_locus(), \"failed to parse range pattern bound in range pattern\");\n                 return NULL;\n             }\n \n@@ -8010,12 +8051,8 @@ namespace Rust {\n                           = parse_range_pattern_bound();\n \n                         return ::std::unique_ptr<AST::RangePattern>(\n-                            new AST::RangePattern(\n-                                ::std::move(lower_bound),\n-                                ::std::move(upper_bound),\n-                                Linemap::unknown_location(),\n-                                has_ellipsis_syntax)\n-                            );\n+                          new AST::RangePattern(::std::move(lower_bound), ::std::move(upper_bound),\n+                            Linemap::unknown_location(), has_ellipsis_syntax));\n                     }\n                     case EXCLAM:\n                         return parse_macro_invocation_partial(\n@@ -8096,7 +8133,8 @@ namespace Rust {\n         // parse pattern to get reference of (required)\n         ::std::unique_ptr<AST::Pattern> pattern = parse_pattern();\n         if (pattern == NULL) {\n-            rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse pattern in reference pattern\");\n+            rust_error_at(\n+              lexer.peek_token()->get_locus(), \"failed to parse pattern in reference pattern\");\n             // skip somewhere?\n             return NULL;\n         }\n@@ -8284,7 +8322,8 @@ namespace Rust {\n             // parse pattern (required)\n             ::std::unique_ptr<AST::Pattern> pattern = parse_pattern();\n             if (pattern == NULL) {\n-                rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse pattern in slice pattern\");\n+                rust_error_at(\n+                  lexer.peek_token()->get_locus(), \"failed to parse pattern in slice pattern\");\n                 return NULL;\n             }\n             patterns.push_back(::std::move(pattern));\n@@ -8383,7 +8422,8 @@ namespace Rust {\n                 // parse items\n                 ::std::unique_ptr<AST::TupleStructItems> items = parse_tuple_struct_items();\n                 if (items == NULL) {\n-                    rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse tuple struct items\");\n+                    rust_error_at(\n+                      lexer.peek_token()->get_locus(), \"failed to parse tuple struct items\");\n                     return NULL;\n                 }\n \n@@ -8429,12 +8469,8 @@ namespace Rust {\n                 ::std::unique_ptr<AST::RangePatternBound> upper_bound = parse_range_pattern_bound();\n \n                 return ::std::unique_ptr<AST::RangePattern>(\n-                    new AST::RangePattern(\n-                        ::std::move(lower_bound),\n-                        ::std::move(upper_bound),\n-                        Linemap::unknown_location(),\n-                        has_ellipsis_syntax)\n-                    );\n+                  new AST::RangePattern(::std::move(lower_bound), ::std::move(upper_bound),\n+                    Linemap::unknown_location(), has_ellipsis_syntax));\n             }\n             case PATTERN_BIND: {\n                 // only allow on single-segment paths\n@@ -8452,7 +8488,8 @@ namespace Rust {\n                       new AST::IdentifierPattern(::std::move(initial_ident), initial_tok->get_locus(),\n                         false, false, ::std::move(bind_pattern)));\n                 }\n-                rust_error_at(t->get_locus(), \"failed to parse pattern bind to a path, not an identifier\");\n+                rust_error_at(\n+                  t->get_locus(), \"failed to parse pattern bind to a path, not an identifier\");\n                 return NULL;\n             }\n             default:\n@@ -8694,7 +8731,8 @@ namespace Rust {\n                     }\n                     default:\n                         // error\n-                        rust_error_at(t->get_locus(), \"unrecognised token '%s' in struct pattern field\",\n+                        rust_error_at(t->get_locus(),\n+                          \"unrecognised token '%s' in struct pattern field\",\n                           t->get_token_description());\n                         return NULL;\n                 }\n@@ -8958,7 +8996,7 @@ namespace Rust {\n                 AST::SimplePath macro_path = path.as_simple_path();\n                 if (macro_path.is_empty()) {\n                     rust_error_at(t2->get_locus(), \"failed to convert parsed path to simple \"\n-                                              \"path (for macro invocation or semi)\");\n+                                                   \"path (for macro invocation or semi)\");\n                     return ExprOrStmt::create_error();\n                 }\n \n@@ -9058,9 +9096,9 @@ namespace Rust {\n                 bool not_a_block\n                   = lexer.peek_token(1)->get_id() == IDENTIFIER\n                     && (lexer.peek_token(2)->get_id() == COMMA\n-                         || (lexer.peek_token(2)->get_id() == COLON\n-                              && (lexer.peek_token(4)->get_id() == COMMA\n-                                   || !can_tok_start_type(lexer.peek_token(3)->get_id()))));\n+                        || (lexer.peek_token(2)->get_id() == COLON\n+                            && (lexer.peek_token(4)->get_id() == COMMA\n+                                || !can_tok_start_type(lexer.peek_token(3)->get_id()))));\n                 ::std::unique_ptr<AST::ExprWithoutBlock> expr = NULL;\n \n                 if (not_a_block) {\n@@ -9349,14 +9387,13 @@ namespace Rust {\n             lexer.skip_token();\n             return t;\n         } else {\n-            rust_error_at(t->get_locus(), \"expecting %s but %s found!\\n\", get_token_description(token_id),\n-              t->get_token_description());\n+            rust_error_at(t->get_locus(), \"expecting %s but %s found!\\n\",\n+              get_token_description(token_id), t->get_token_description());\n \n             return const_TokenPtr();\n         }\n     }\n \n-\n     // Skips all tokens until EOF or }. Don't use.\n     void Parser::skip_after_end() {\n         const_TokenPtr t = lexer.peek_token();\n@@ -9497,8 +9534,6 @@ namespace Rust {\n         return parse_expr(LBP_LOWEST, ::std::move(outer_attrs), restrictions);\n     }\n \n-\n-\n     /* Determines action to take when finding token at beginning of expression.\n      * FIXME: this may only apply to precedence-capable expressions (which are all expressions without\n      * blocks), so make return type ExprWithoutBlock? It would simplify stuff. */\n@@ -9548,9 +9583,9 @@ namespace Rust {\n                         bool not_a_block\n                           = lexer.peek_token(1)->get_id() == IDENTIFIER\n                             && (lexer.peek_token(2)->get_id() == COMMA\n-                                 || (lexer.peek_token(2)->get_id() == COLON\n-                                      && (lexer.peek_token(4)->get_id() == COMMA\n-                                           || !can_tok_start_type(lexer.peek_token(3)->get_id()))));\n+                                || (lexer.peek_token(2)->get_id() == COLON\n+                                    && (lexer.peek_token(4)->get_id() == COMMA\n+                                        || !can_tok_start_type(lexer.peek_token(3)->get_id()))));\n \n                         /* definitely not a block:\n                          *  path '{' ident ','\n@@ -9790,8 +9825,9 @@ namespace Rust {\n             }\n             case SCOPE_RESOLUTION: {\n                 // TODO: fix: this is for global paths, i.e. ::std::string::whatever\n-                rust_error_at(tok->get_locus(), \"found null denotation scope resolution operator, and \"\n-                                           \"haven't written handling for it.\");\n+                rust_error_at(tok->get_locus(),\n+                  \"found null denotation scope resolution operator, and \"\n+                  \"haven't written handling for it.\");\n                 return NULL;\n             }\n             case SELF:\n@@ -9835,9 +9871,9 @@ namespace Rust {\n                         bool not_a_block\n                           = lexer.peek_token(1)->get_id() == IDENTIFIER\n                             && (lexer.peek_token(2)->get_id() == COMMA\n-                                 || (lexer.peek_token(2)->get_id() == COLON\n-                                      && (lexer.peek_token(4)->get_id() == COMMA\n-                                           || !can_tok_start_type(lexer.peek_token(3)->get_id()))));\n+                                || (lexer.peek_token(2)->get_id() == COLON\n+                                    && (lexer.peek_token(4)->get_id() == COMMA\n+                                        || !can_tok_start_type(lexer.peek_token(3)->get_id()))));\n \n                         if (!restrictions.can_be_struct_expr && !not_a_block) {\n                             // assume path is returned\n@@ -10061,8 +10097,9 @@ namespace Rust {\n                   tok, ::std::move(left), ::std::move(outer_attrs), restrictions);\n             case SCOPE_RESOLUTION:\n                 // path expression - binary infix? FIXME should this even be parsed here?\n-                rust_error_at(tok->get_locus(), \"found scope resolution operator in left denotation \"\n-                                           \"function - this should probably be handled elsewhere.\");\n+                rust_error_at(tok->get_locus(),\n+                  \"found scope resolution operator in left denotation \"\n+                  \"function - this should probably be handled elsewhere.\");\n                 return NULL;\n             case DOT: {\n                 // field expression or method call - relies on parentheses after next identifier\n@@ -11020,7 +11057,7 @@ namespace Rust {\n             ::std::unique_ptr<AST::Expr> expr = parse_expr();\n             if (expr == NULL) {\n                 rust_error_at(t->get_locus(), \"failed to parse expression in struct \"\n-                                         \"(or enum) expression tuple\");\n+                                              \"(or enum) expression tuple\");\n                 return NULL;\n             }\n             exprs.push_back(::std::move(expr));\n@@ -11214,7 +11251,8 @@ namespace Rust {\n             ::std::unique_ptr<AST::BlockExpr> block = parse_block_expr();\n             if (block == NULL) {\n                 // error\n-                rust_error_at(lexer.peek_token()->get_locus(), \"failed to parse block expr in closure\");\n+                rust_error_at(\n+                  lexer.peek_token()->get_locus(), \"failed to parse block expr in closure\");\n                 // skip somewhere?\n                 return NULL;\n             }\n@@ -11291,10 +11329,10 @@ namespace Rust {\n \n             fprintf(stderr, \"<id=%s%s, %s\\n\", tok->token_id_to_str(),\n               has_text ? (std::string(\", text=\") + tok->get_str() + std::string(\", typehint=\")\n-                           + std::string(tok->get_type_hint_str()))\n+                          + std::string(tok->get_type_hint_str()))\n                            .c_str()\n                        : \"\",\n-                    lexer.get_line_map()->to_string(loc).c_str());\n+              lexer.get_line_map()->to_string(loc).c_str());\n \n             if (tok->get_id() == Rust::END_OF_FILE)\n                 break;\n@@ -11312,5 +11350,3 @@ namespace Rust {\n         fprintf(stderr, \"%s\", crate.as_string().c_str());\n     }\n }\n-\n-    "}, {"sha": "fb701ce656b3d78c3328b5a815c17b790f0c4ef3", "filename": "gcc/rust/rust-backend.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-backend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-backend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.c?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -30,7 +30,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"output.h\"\t/* for assemble_string */\n #include \"common/common-target.h\"\n-#include \"rust-c.h\"\n+//#include \"rust-c.h\" // import no longer exists, so hopefully not broken\n+\n+// satisfy intellisense\n+#include \"options.h\"\n \n /* The segment name we pass to simple_object_start_read to find Rust\n    export data.  */\n@@ -84,7 +87,7 @@ rust_field_alignment (tree t)\n /* This is called by the Rust frontend proper if the unsafe package was\n    imported.  When that happens we cannot do type-based alias\n    analysis.  */\n-\n+// TODO: this should be removed, as it only pertains to Go, not Rust\n void\n rust_imported_unsafe (void)\n {"}, {"sha": "47c3657415dd48ee5c5201bd1427b12f8961e0fb", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -49,6 +49,8 @@\n #include \"backend.h\"\n #include \"rust-object-export.h\"\n \n+// TODO: this will have to be significantly modified to work with Rust\n+\n // A class wrapping a tree.\n \n class Gcc_tree"}, {"sha": "d82e6d85e83dc05fa55b5ea2e0192538aa63aa7e", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -265,9 +265,9 @@ static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n static int grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED,\n   gimple_seq* pre_p ATTRIBUTE_UNUSED, gimple_seq* post_p ATTRIBUTE_UNUSED) {\n     if (TREE_CODE (*expr_p) == CALL_EXPR\n-        && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n+      && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n         gimplify_expr (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p, post_p,\n-                       is_gimple_val, fb_rvalue);\n+          is_gimple_val, fb_rvalue);\n     return GS_UNHANDLED;\n }\n "}, {"sha": "03c60f566aabe9d81723ca4cabcc543d78dd9743", "filename": "gcc/rust/rust-linemap.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -22,6 +22,11 @@\n // The Linemap class is a pure abstract interface, plus some static\n // convenience functions.  The backend must implement the interface.\n \n+/* TODO: probably better to replace linemap implementation as pure abstract interface with some sort of \n+ * compile-time switch (macros or maybe templates if doable without too much extra annoyance) as to the\n+ * definition of the methods or whatever. This is to improve performance, as virtual function calls would\n+ * otherwise have to be made in tight loops like in the lexer. */\n+\n class Linemap\n {\n  public:"}, {"sha": "0515f68c80198deff52ba43256e9fc92dbb78a7a", "filename": "gcc/rust/rust-location.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-location.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -20,7 +20,24 @@ class Location\n \n   location_t\n   gcc_location() const\n-  { return this->gcc_loc_; }\n+  { return gcc_loc_; }\n+\n+  Location \n+  operator+=(location_t rhs) {\n+    gcc_loc_ += rhs;\n+    return *this;\n+  }\n+\n+  Location \n+  operator-=(location_t rhs) {\n+    gcc_loc_ -= rhs;\n+    return *this;\n+  }\n+\n+  bool \n+  operator==(location_t rhs) {\n+    return rhs == gcc_loc_;\n+  }\n \n  private:\n   location_t gcc_loc_;\n@@ -40,4 +57,18 @@ operator==(Location loca, Location locb)\n   return loca.gcc_location() == locb.gcc_location();\n }\n \n+inline Location \n+operator+(Location lhs, location_t rhs) \n+{\n+  lhs += rhs;\n+  return lhs;\n+}\n+\n+inline Location \n+operator-(Location lhs, location_t rhs) \n+{\n+  lhs -= rhs;\n+  return lhs;\n+}\n+\n #endif // !defined(RUST_LOCATION_H)"}, {"sha": "c98503578803a5acd7bf4d41dc6170a323a120eb", "filename": "gcc/rust/rust-object-export.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-object-export.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-object-export.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.c?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -17,6 +17,8 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+// FIXME: doesn't this duplicate lots of code from rust-backend.c? Is one meant to be a replacement?\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -31,6 +33,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\t/* for assemble_string */\n #include \"common/common-target.h\"\n \n+// satisfy intellisense\n+#include \"options.h\"\n+\n /* The segment name we pass to simple_object_start_read to find Rust\n    export data.  */\n \n@@ -83,7 +88,7 @@ rust_field_alignment (tree t)\n /* This is called by the Rust frontend proper if the unsafe package was\n    imported.  When that happens we cannot do type-based alias\n    analysis.  */\n-\n+// TODO: this should be removed, as it only pertains to Go, not Rust\n void\n rust_imported_unsafe (void)\n {"}, {"sha": "d5110787c54a7b247b912062d12b18721caabf9e", "filename": "gcc/rust/rust-object-export.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-object-export.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-object-export.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -1,4 +1,5 @@\n-#pragma once\n+#ifndef RUST_OBJECT_EXPORT_H\n+#define RUST_OBJECT_EXPORT_H\n \n extern unsigned int rust_field_alignment (tree t);\n \n@@ -7,3 +8,5 @@ rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n                        int *perr);\n extern void\n rust_write_export_data (const char *bytes, unsigned int size);\n+\n+#endif // RUST_OBJECT_EXPORT_H\n\\ No newline at end of file"}, {"sha": "471a7faaaf2b2b92ccc1d341ba62761e4b6bae3e", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -518,12 +518,8 @@ namespace Rust {\n \n             // create \"extern crate\" item with the name\n             ::std::unique_ptr<AST::ExternCrate> extern_crate(\n-                new AST::ExternCrate(\n-                    *it,\n-                    AST::Visibility::create_error(),\n-                    { ::std::move(attr) },\n-                    Linemap::unknown_location())\n-                );\n+              new AST::ExternCrate(*it, AST::Visibility::create_error(), { ::std::move(attr) },\n+              Linemap::unknown_location()));\n \n             // insert at beginning\n             crate.items.insert(crate.items.begin(), ::std::move(extern_crate));\n@@ -536,10 +532,10 @@ namespace Rust {\n                 AST::SimplePathSegment(\"v1\") };\n         // create use tree and decl\n         ::std::unique_ptr<AST::UseTreeGlob> use_tree(new AST::UseTreeGlob(\n-          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), Linemap::unknown_location()));\n+          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), Location()));\n         AST::Attribute prelude_attr(AST::SimplePath::from_str(\"prelude_import\"), NULL);\n         ::std::unique_ptr<AST::UseDeclaration> use_decl(new AST::UseDeclaration(::std::move(use_tree),\n-          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, Linemap::unknown_location()));\n+          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, Location()));\n \n         crate.items.insert(crate.items.begin(), ::std::move(use_decl));\n "}, {"sha": "84b55469b74e04e932d43d0ab6739d64f1cfd192", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -11,6 +11,10 @@\n #include \"rust-linemap.h\"\n #include \"backend.h\"\n \n+#include <string>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n #include <utility>\n \n namespace Rust {\n@@ -145,6 +149,8 @@ namespace Rust {\n         // backend linemap\n         Linemap* linemap;\n \n+        // TODO: replace raw pointers with smart pointers?\n+\n       public:\n         /* Initialise compiler session. Corresponds to langhook grs_langhook_init(). Note that this is\n          * called after option handling. */"}, {"sha": "84e66aa1594e49ed9bfa83c23061f170d2279888", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -41,6 +41,9 @@\n #include <deque>\n #include <functional>\n \n+/* TODO: strictly speaking, as AST move semantics make frontend C++11-and-up only, unordered map should\n+ * always be definable (i.e. don't have to resort to tr1 like in C++03), so don't need to have this\n+ * macro switch - just include <unordered_map> and <unordered_set>. */\n #if defined(HAVE_UNORDERED_MAP)\n \n # include <unordered_map>"}, {"sha": "b61114f5c2811a66c91e86c7f2dc2a3f6b2592cb", "filename": "gcc/rust/rustspec.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frustspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2eebc2920ed96e509559e92e74a4af78d95eb6/gcc%2Frust%2Frustspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustspec.cc?ref=5a2eebc2920ed96e509559e92e74a4af78d95eb6", "patch": "@@ -23,6 +23,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"opts.h\"\n \n+// satisfy intellisense\n+#include \"options.h\"\n+\n /* This bit is set if we saw a `-xfoo' language specification.  */\n #define LANGSPEC (1 << 1)\n /* This bit is set if they did `-lm' or `-lmath'.  */"}]}