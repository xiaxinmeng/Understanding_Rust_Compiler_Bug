{"sha": "1773cd776ad33ff4688ff29437ec716eda0e58e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc3M2NkNzc2YWQzM2ZmNDY4OGZmMjk0MzdlYzcxNmVkYTBlNThlNg==", "commit": {"author": {"name": "Walter Lee", "email": "walt@tilera.com", "date": "2012-08-28T05:25:35Z"}, "committer": {"name": "Walter Lee", "email": "walt@gcc.gnu.org", "date": "2012-08-28T05:25:35Z"}, "message": "Add support for the -mcmodel=MODEL flag on TILE-Gx.\n\nAdd support for the -mcmodel=MODEL flag on TILE-Gx.  The models\nsupported are small and large.  In the small model (default), distance\nfor direct calls is limited to 500M in either direction.  PC-relative\naddresses are 32 bits.  Absolute addresses support the full address\nrange.  In the large model, there is no limiation on call distance,\npc-relative addresses, or absolute addresses.\n\t* doc/invoke.texi: Document -mcmodel=small, -mcmodel=large.\n\t* config/tilegx/tilegx.h: Include config/tilegx/tilegx-opts.h.\n\t(CRT_CALL_STATIC_FUNCTION): Define.\n\t* config/tilegx/predicates.md (const_last_symbolic_operand):\n\tHandle UNSPEC_HW2_LAST_PCREL, UNSPEC_HW1_LAST_PLT_PCREL, and\n\tUNSPEC_HW2_LAST_PLT_PCREL.\n\t(const_symbolic_operand): Handle UNSPEC_HW1_PCREL,\n\tUNSPEC_HW0_PLT_PCREL, and UNSPEC_HW1_PLT_PCREL.\n\t* config/tilegx/tilegx.md (UNSPEC_MOV_LARGE_PCREL_STEP4): Define,\n\tand renumber the constants that follow.\n\t(UNSPEC_HW1_PCREL): Define, and renumber the constants that\n\tfollow.\n\t(UNSPEC_HW0_PLT_PCREL): Define.\n\t(UNSPEC_HW1_PLT_PCREL): Define.\n\t(UNSPEC_HW1_LAST_PLT_PCREL): Define.\n\t(UNSPEC_HW2_LAST_PLT_PCREL): Define.\n\t(mov_large_pcrel_step1): Define.\n\t(mov_large_pcrel_step2): Define.\n\t(mov_large_pcrel_step3): Define.\n\t(mov_large_pcrel_step4): Define.\n\t(mov_plt_pcrel_step1): Define.\n\t(mov_plt_pcrel_step2): Define.\n\t(mov_plt_pcrel_step3): Define.\n\t(mov_plt_pcrel_step1_32bit): Define.\n\t(mov_plt_pcrel_step2_32bit): Define.\n\t(call): Handle tilegx_cmodel == CM_LARGE, CM_LARGE_PIC.\n\t(call_value): Ditto.\n\t* config/tilegx/tilegx.opt: Include config/tilegx/tilegx-opts.h.\n\t(mcmodel): New option.\n\t(enum cmodel): Define.\n\t(CM_SMALL): Define.\n\t(CM_LARGE): Define.\n\t* config/tilegx/tilegx-protos.h (tilegx_compute_pcrel_address):\n\tDeclare.\n\t(tilegx_compute_pcrel_plt_address): Declare.\n\t* config/tilegx/tilegx.c (tilegx_option_override): Handle\n\ttilegx_cmodel.\n\t(tilegx_function_ok_for_sibcall): Ditto.\n\t(compute_pcrel_address): Rename to tilegx_compute_pcrel_address,\n\tand don't declare static.  Handle tilegx_cmodel.\n\t(tilegx_compute_pcrel_plt_address): Define.\n\t(tilegx_legitimize_pic_address): Rename calls to\n\tcompute_pcrel_address.\n\t(tilegx_delegitimize_address): Handle UNSPEC_HW1_PCREL,\n\tUNSPEC_HW2_LAST_PCREL, UNSPEC_HW0_PLT_PCREL, UNSPEC_HW1_PLT_PCREL,\n\tUNSPEC_HW1_LAST_PLT_PCREL, UNSPEC_HW2_LAST_PLT_PCREL.\n\t(load_pic_register): Rename call to compute_pcrel_address.\n\t(tilegx_print_operand): Handle UNSPEC_HW1_PCREL,\n\tUNSPEC_HW2_LAST_PCREL, UNSPEC_HW0_PLT_PCREL, UNSPEC_HW1_PLT_PCREL,\n\tUNSPEC_HW1_LAST_PLT_PCREL, UNSPEC_HW2_LAST_PLT_PCREL.\n\nFrom-SVN: r190737", "tree": {"sha": "3e7d11fa496c2071981a5edd482d7156296ae74a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e7d11fa496c2071981a5edd482d7156296ae74a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1773cd776ad33ff4688ff29437ec716eda0e58e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1773cd776ad33ff4688ff29437ec716eda0e58e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1773cd776ad33ff4688ff29437ec716eda0e58e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1773cd776ad33ff4688ff29437ec716eda0e58e6/comments", "author": {"login": "walt-tilera", "id": 6602917, "node_id": "MDQ6VXNlcjY2MDI5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/6602917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/walt-tilera", "html_url": "https://github.com/walt-tilera", "followers_url": "https://api.github.com/users/walt-tilera/followers", "following_url": "https://api.github.com/users/walt-tilera/following{/other_user}", "gists_url": "https://api.github.com/users/walt-tilera/gists{/gist_id}", "starred_url": "https://api.github.com/users/walt-tilera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/walt-tilera/subscriptions", "organizations_url": "https://api.github.com/users/walt-tilera/orgs", "repos_url": "https://api.github.com/users/walt-tilera/repos", "events_url": "https://api.github.com/users/walt-tilera/events{/privacy}", "received_events_url": "https://api.github.com/users/walt-tilera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bebfb71bf4e1baae9761f1473ca35914f09dd8e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebfb71bf4e1baae9761f1473ca35914f09dd8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebfb71bf4e1baae9761f1473ca35914f09dd8e3"}], "stats": {"total": 479, "additions": 433, "deletions": 46}, "files": [{"sha": "2d7a901c769b84134488ca3b51958f4c64d88f3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -1,3 +1,57 @@\n+2012-08-28  Walter Lee  <walt@tilera.com>\n+\n+\t* doc/invoke.texi: Document -mcmodel=small, -mcmodel=large.\n+\t* config/tilegx/tilegx.h: Include config/tilegx/tilegx-opts.h.\n+\t(CRT_CALL_STATIC_FUNCTION): Define.\n+\t* config/tilegx/predicates.md (const_last_symbolic_operand):\n+\tHandle UNSPEC_HW2_LAST_PCREL, UNSPEC_HW1_LAST_PLT_PCREL, and\n+\tUNSPEC_HW2_LAST_PLT_PCREL.\n+\t(const_symbolic_operand): Handle UNSPEC_HW1_PCREL,\n+\tUNSPEC_HW0_PLT_PCREL, and UNSPEC_HW1_PLT_PCREL.\n+\t* config/tilegx/tilegx.md (UNSPEC_MOV_LARGE_PCREL_STEP4): Define,\n+\tand renumber the constants that follow.\n+\t(UNSPEC_HW1_PCREL): Ditto.\n+\t(UNSPEC_HW2_LAST_PCREL): Ditto.\n+\t(UNSPEC_HW0_PLT_PCREL): Define.\n+\t(UNSPEC_HW1_PLT_PCREL): Define.\n+\t(UNSPEC_HW1_LAST_PLT_PCREL): Define.\n+\t(UNSPEC_HW2_LAST_PLT_PCREL): Define.\n+\t(mov_large_pcrel_step1): Define.\n+\t(mov_large_pcrel_step2): Define.\n+\t(mov_large_pcrel_step3): Define.\n+\t(mov_large_pcrel_step4): Define.\n+\t(mov_plt_pcrel_step1): Define.\n+\t(mov_plt_pcrel_step2): Define.\n+\t(mov_plt_pcrel_step3): Define.\n+\t(mov_plt_pcrel_step1_32bit): Define.\n+\t(mov_plt_pcrel_step2_32bit): Define.\n+\t(call): Handle tilegx_cmodel == CM_LARGE, CM_LARGE_PIC.\n+\t(call_value): Ditto.\n+\t* config/tilegx/tilegx.opt: Include config/tilegx/tilegx-opts.h.\n+\t(mcmodel): New option.\n+\t(enum cmodel): Define.\n+\t(CM_SMALL): Define.\n+\t(CM_LARGE): Define.\n+\t* config/tilegx/tilegx-opts.h: New file.\n+\t* config/tilegx/tilegx-protos.h (tilegx_compute_pcrel_address):\n+\tDeclare.\n+\t(tilegx_compute_pcrel_plt_address): Declare.\n+\t* config/tilegx/tilegx.c (tilegx_option_override): Handle\n+\ttilegx_cmodel.\n+\t(tilegx_function_ok_for_sibcall): Ditto.\n+\t(compute_pcrel_address): Rename to tilegx_compute_pcrel_address,\n+\tand don't declare static.  Handle tilegx_cmodel.\n+\t(tilegx_compute_pcrel_plt_address): Define.\n+\t(tilegx_legitimize_pic_address): Rename calls to\n+\tcompute_pcrel_address.\n+\t(tilegx_delegitimize_address): Handle UNSPEC_HW1_PCREL,\n+\tUNSPEC_HW2_LAST_PCREL, UNSPEC_HW0_PLT_PCREL, UNSPEC_HW1_PLT_PCREL,\n+\tUNSPEC_HW1_LAST_PLT_PCREL, UNSPEC_HW2_LAST_PLT_PCREL.\n+\t(load_pic_register): Rename call to compute_pcrel_address.\n+\t(tilegx_print_operand): Handle UNSPEC_HW1_PCREL,\n+\tUNSPEC_HW2_LAST_PCREL, UNSPEC_HW0_PLT_PCREL, UNSPEC_HW1_PLT_PCREL,\n+\tUNSPEC_HW1_LAST_PLT_PCREL, UNSPEC_HW2_LAST_PLT_PCREL.\n+\n 2012-08-27  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* sched-deps.c (add_dependence_list_and_free): Simplify."}, {"sha": "4b385c3700ad8213e2d2da023df11e6485f4dbd3", "filename": "gcc/config/tilegx/predicates.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fpredicates.md?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -80,11 +80,14 @@\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_PCREL\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST_PCREL\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_LAST_GOT\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_GOT\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_GD\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_IE\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_LE\"))))\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_TLS_LE\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_LAST_PLT_PCREL\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2_LAST_PLT_PCREL\"))))\n \n ;; Returns 1 if OP is an unspec wrapper for a symbol, got, or tls\n ;; reference.\n@@ -96,10 +99,13 @@\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW2\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW3\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_PCREL\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_PCREL\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_GOT\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_GD\")\n \t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_IE\")\n-\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_LE\"))))\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_TLS_LE\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW0_PLT_PCREL\")\n+\t    (match_test \"XINT (XEXP (op,0), 1) == UNSPEC_HW1_PLT_PCREL\"))))\n \n ;; Return 1 if OP is a 8-element vector constant with identical signed\n ;; 8-bit elements or any register."}, {"sha": "77c292edd8e799ce71757cbccd817420f045ec91", "filename": "gcc/config/tilegx/tilegx-opts.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-opts.h?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -0,0 +1,34 @@\n+/* Definitions for option handling for TILE-Gx.\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Walter Lee (walt@tilera.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TILEGX_OPTS_H\n+#define TILEGX_OPTS_H\n+\n+enum cmodel {\n+  CM_SMALL,\t/* Makes various assumpation about sizes of code and\n+\t\t   data fits.  */\n+  CM_LARGE,\t/* No assumptions.  */\n+  CM_SMALL_PIC,\t/* Makes various assumpation about sizes of code and\n+\t\t   data fits.  */\n+  CM_LARGE_PIC\t/* No assumptions.  */\n+};\n+\n+#endif"}, {"sha": "cf56af431d801809dffc57b80c640a1f31a043cf", "filename": "gcc/config/tilegx/tilegx-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -23,6 +23,8 @@\n #define GCC_TILEGX_PROTOS_H\n \n extern void tilegx_init_expanders (void);\n+extern void tilegx_compute_pcrel_address (rtx, rtx);\n+extern void tilegx_compute_pcrel_plt_address (rtx, rtx);\n extern bool tilegx_legitimate_pic_operand_p (rtx);\n extern rtx tilegx_simd_int (rtx, enum machine_mode);\n "}, {"sha": "c3f0b751f03fd8fe80811392cb5db22fd7f04c05", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -67,6 +67,29 @@ static bool output_memory_autoinc_first;\n static void\n tilegx_option_override (void)\n {\n+  if (global_options_set.x_tilegx_cmodel)\n+    {\n+      switch (tilegx_cmodel)\n+\t{\n+\tcase CM_SMALL:\n+\tcase CM_SMALL_PIC:\n+\t  if (flag_pic)\n+\t    tilegx_cmodel = CM_SMALL_PIC;\n+\t  break;\n+\n+\tcase CM_LARGE:\n+\tcase CM_LARGE_PIC:\n+\t  if (flag_pic)\n+\t    tilegx_cmodel = CM_LARGE_PIC;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    tilegx_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n+\n   /* When modulo scheduling is enabled, we still rely on regular\n      scheduler for bundling.  */\n   if (flag_modulo_sched)\n@@ -119,7 +142,8 @@ tilegx_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED,\n static bool\n tilegx_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n-  return decl != NULL;\n+  return (tilegx_cmodel != CM_LARGE && tilegx_cmodel != CM_LARGE_PIC\n+\t  && (decl != NULL));\n }\n \n \n@@ -1024,12 +1048,12 @@ tilegx_legitimize_tls_address (rtx addr)\n \n /* Returns a register that points to ADDR, a symbolic address, by\n    computing its address relative to tilegx_text_label_symbol.  */\n-static void\n-compute_pcrel_address (rtx result, rtx addr)\n+void\n+tilegx_compute_pcrel_address (rtx result, rtx addr)\n {\n   rtx text_label_symbol = tilegx_text_label_symbol ();\n   rtx text_label_rtx = tilegx_text_label_rtx ();\n-  rtx temp, temp2;\n+  rtx temp, temp2, temp3;\n \n   temp = create_temp_reg_if_possible (Pmode, result);\n   temp2 = create_temp_reg_if_possible (Pmode, result);\n@@ -1043,6 +1067,18 @@ compute_pcrel_address (rtx result, rtx addr)\n \t\t\t\t\t    text_label_rtx,\n \t\t\t\t\t    addr, text_label_symbol));\n     }\n+  else if (tilegx_cmodel == CM_LARGE_PIC)\n+    {\n+      temp3 = create_temp_reg_if_possible (Pmode, result);\n+      emit_insn (gen_mov_large_pcrel_step1 (temp, addr, text_label_symbol));\n+      emit_insn (gen_mov_large_pcrel_step2 (temp2, temp, addr,\n+\t\t\t\t\t    text_label_symbol));\n+      emit_insn (gen_mov_large_pcrel_step3 (temp3, temp2, addr,\n+\t\t\t\t\t    text_label_symbol));\n+      emit_insn (gen_mov_large_pcrel_step4 (result, temp3,\n+\t\t\t\t\t    text_label_rtx,\n+\t\t\t\t\t    addr, text_label_symbol));\n+    }\n   else\n     {\n       emit_insn (gen_mov_pcrel_step1 (temp, addr, text_label_symbol));\n@@ -1054,6 +1090,41 @@ compute_pcrel_address (rtx result, rtx addr)\n }\n \n \n+/* Returns a register that points to the plt entry of ADDR, a symbolic\n+   address, by computing its address relative to\n+   tilegx_text_label_symbol. */\n+void\n+tilegx_compute_pcrel_plt_address (rtx result, rtx addr)\n+{\n+  rtx text_label_symbol = tilegx_text_label_symbol ();\n+  rtx text_label_rtx = tilegx_text_label_rtx ();\n+  rtx temp, temp2, temp3;\n+\n+  temp = create_temp_reg_if_possible (Pmode, result);\n+  temp2 = create_temp_reg_if_possible (Pmode, result);\n+\n+  if (TARGET_32BIT)\n+    {\n+      emit_insn (gen_mov_plt_pcrel_step1_32bit (temp, addr,\n+\t\t\t\t\t\ttext_label_symbol));\n+      emit_insn (gen_mov_plt_pcrel_step2_32bit (temp2, temp, addr,\n+\t\t\t\t\t\ttext_label_symbol));\n+      emit_move_insn (result, gen_rtx_PLUS (Pmode, temp2, text_label_rtx));\n+    }\n+  else\n+    {\n+      temp3 = create_temp_reg_if_possible (Pmode, result);\n+\n+      emit_insn (gen_mov_plt_pcrel_step1 (temp, addr, text_label_symbol));\n+      emit_insn (gen_mov_plt_pcrel_step2 (temp2, temp, addr,\n+\t\t\t\t\t  text_label_symbol));\n+      emit_insn (gen_mov_plt_pcrel_step3 (temp3, temp2, addr,\n+\t\t\t\t\t  text_label_symbol));\n+      emit_move_insn (result, gen_rtx_PLUS (Pmode, temp3, text_label_rtx));\n+    }\n+}\n+\n+\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n    position-independent addresses go into a reg.  This is REG if\n@@ -1079,7 +1150,7 @@ tilegx_legitimize_pic_address (rtx orig,\n \t     loading in the address, so that these instructions can be\n \t     optimized properly.  */\n \t  rtx temp_reg = create_temp_reg_if_possible (Pmode, reg);\n-\t  compute_pcrel_address (temp_reg, orig);\n+\t  tilegx_compute_pcrel_address (temp_reg, orig);\n \n \t  /* Note: this is conservative.  We use the text_label but we\n \t     don't use the pic_offset_table.  However, in some cases\n@@ -1196,7 +1267,7 @@ tilegx_legitimize_pic_address (rtx orig,\n          loading in the address, so that these instructions can be\n          optimized properly.  */\n       temp_reg = create_temp_reg_if_possible (Pmode, reg);\n-      compute_pcrel_address (temp_reg, orig);\n+      tilegx_compute_pcrel_address (temp_reg, orig);\n \n       /* Note: this is conservative.  We use the text_label but we\n          don't use the pic_offset_table.  */\n@@ -1250,7 +1321,13 @@ tilegx_delegitimize_address (rtx x)\n \t  case UNSPEC_HW1_LAST:\n \t  case UNSPEC_HW2_LAST:\n \t  case UNSPEC_HW0_PCREL:\n+\t  case UNSPEC_HW1_PCREL:\n \t  case UNSPEC_HW1_LAST_PCREL:\n+\t  case UNSPEC_HW2_LAST_PCREL:\n+\t  case UNSPEC_HW0_PLT_PCREL:\n+\t  case UNSPEC_HW1_PLT_PCREL:\n+\t  case UNSPEC_HW1_LAST_PLT_PCREL:\n+\t  case UNSPEC_HW2_LAST_PLT_PCREL:\n \t  case UNSPEC_HW0_GOT:\n \t  case UNSPEC_HW0_LAST_GOT:\n   \t  case UNSPEC_HW1_LAST_GOT:\n@@ -1290,7 +1367,7 @@ load_pic_register (bool delay_pic_helper ATTRIBUTE_UNUSED)\n       emit_insn (gen_insn_lnk_and_label (text_label_rtx, text_label_symbol));\n     }\n \n-  compute_pcrel_address (tilegx_got_rtx (), got_symbol);\n+  tilegx_compute_pcrel_address (tilegx_got_rtx (), got_symbol);\n \n   flag_pic = orig_flag_pic;\n \n@@ -2577,7 +2654,7 @@ tilegx_expand_tablejump (rtx op0, rtx op1)\n       rtx temp = gen_reg_rtx (Pmode);\n       rtx temp2 = gen_reg_rtx (Pmode);\n \n-      compute_pcrel_address (temp, gen_rtx_LABEL_REF (Pmode, op1));\n+      tilegx_compute_pcrel_address (temp, gen_rtx_LABEL_REF (Pmode, op1));\n       emit_move_insn (temp2,\n \t\t      gen_rtx_PLUS (Pmode,\n \t\t\t\t    convert_to_mode (Pmode, op0, false),\n@@ -4961,6 +5038,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \t      opstr = \"hw0\";\n \t      break;\n \t    case UNSPEC_HW1:\n+\t    case UNSPEC_HW1_PCREL:\n \t      opstr = \"hw1\";\n \t      break;\n \t    case UNSPEC_HW2:\n@@ -4977,6 +5055,7 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \t      opstr = \"hw1_last\";\n \t      break;\n \t    case UNSPEC_HW2_LAST:\n+\t    case UNSPEC_HW2_LAST_PCREL:\n \t      opstr = \"hw2_last\";\n \t      break;\n \t    case UNSPEC_HW0_GOT:\n@@ -5006,6 +5085,18 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \t    case UNSPEC_HW1_LAST_TLS_LE:\n \t      opstr = \"hw1_last_tls_le\";\n \t      break;\n+\t    case UNSPEC_HW0_PLT_PCREL:\n+\t      opstr = \"hw0_plt\";\n+\t      break;\n+\t    case UNSPEC_HW1_PLT_PCREL:\n+\t      opstr = \"hw1_plt\";\n+\t      break;\n+\t    case UNSPEC_HW1_LAST_PLT_PCREL:\n+\t      opstr = \"hw1_last_plt\";\n+\t      break;\n+\t    case UNSPEC_HW2_LAST_PLT_PCREL:\n+\t      opstr = \"hw2_last_plt\";\n+\t      break;\n \t    default:\n \t      output_operand_lossage (\"invalid %%H specifier\");\n \t    }\n@@ -5015,7 +5106,13 @@ tilegx_print_operand (FILE *file, rtx x, int code)\n \t  output_addr_const (file, addr);\n \n \t  if (unspec == UNSPEC_HW0_PCREL\n-\t      || unspec == UNSPEC_HW1_LAST_PCREL)\n+\t      || unspec == UNSPEC_HW1_PCREL\n+\t      || unspec == UNSPEC_HW1_LAST_PCREL\n+\t      || unspec == UNSPEC_HW2_LAST_PCREL\n+\t      || unspec == UNSPEC_HW0_PLT_PCREL\n+\t      || unspec == UNSPEC_HW1_PLT_PCREL\n+\t      || unspec == UNSPEC_HW1_LAST_PLT_PCREL\n+\t      || unspec == UNSPEC_HW2_LAST_PLT_PCREL)\n \t    {\n \t      rtx addr2 = XVECEXP (XEXP (x, 0), 0, 1);\n \t      fputs (\" - \" , file);"}, {"sha": "061008ff42d52f1feb4c80a6378e0bfe9599dfef", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -31,6 +31,8 @@\n     }\t\t\t\t\t\t\\\n   while (0)\n \n+#include \"config/tilegx/tilegx-opts.h\"\n+\n \n /* Target CPU builtins.  */\n #define TARGET_CPU_CPP_BUILTINS() \\\n@@ -480,6 +482,19 @@ enum reg_class\n     assemble_name ((FILE), (NAME)),\t\t\t\\\n     fprintf ((FILE), \",%u\\n\", (unsigned int)(ROUNDED)))\n \n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)\t\t\\\n+static void __attribute__((__used__))\t\t\t\t\\\n+call_ ## FUNC (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  asm (SECTION_OP);\t\t\t\t\t\t\\\n+  asm (\"{ moveli r0, hw2_last(\" #FUNC \" - . - 8); lnk r1 }\\n\");\t\\\n+  asm (\"shl16insli r0, r0, hw1(\" #FUNC \" - .)\\n\");\t\t\\\n+  asm (\"shl16insli r0, r0, hw0(\" #FUNC \" - . + 8)\\n\");\t\t\\\n+  asm (\"add r0, r1, r0\\n\");\t\t\t\t\t\\\n+  asm (\"jalr r0\\n\");\t\t\t\t\t\t\\\n+  asm (TEXT_SECTION_ASM_OP);\t\t\t\t\t\\\n+}\n+\n \f\n \n #define INIT_EXPANDERS tilegx_init_expanders ()"}, {"sha": "23c47f8d264120b2ca6a9d11a0768a2213dffa86", "filename": "gcc/config/tilegx/tilegx.md", "status": "modified", "additions": 186, "deletions": 34, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -150,42 +150,43 @@\n \n   ;; Insns generating difference of two labels\n   (UNSPEC_MOV_PCREL_STEP3              204)\n+  (UNSPEC_MOV_LARGE_PCREL_STEP4        205)\n \n   ;; Latency specifying loads.\n-  (UNSPEC_LATENCY_L2                   205)\n-  (UNSPEC_LATENCY_MISS                 206)\n+  (UNSPEC_LATENCY_L2                   206)\n+  (UNSPEC_LATENCY_MISS                 207)\n \n   ;; A pseudo-op that prevents network operations from being ordered.\n-  (UNSPEC_NETWORK_BARRIER              207)\n+  (UNSPEC_NETWORK_BARRIER              208)\n \n   ;; Operations that access network registers.\n-  (UNSPEC_NETWORK_RECEIVE              208)\n-  (UNSPEC_NETWORK_SEND                 209)\n+  (UNSPEC_NETWORK_RECEIVE              209)\n+  (UNSPEC_NETWORK_SEND                 210)\n \n   ;; Stack protector operations\n-  (UNSPEC_SP_SET                       210)\n-  (UNSPEC_SP_TEST                      211)\n+  (UNSPEC_SP_SET                       211)\n+  (UNSPEC_SP_TEST                      212)\n \n   ;; This is used to move a value to a SPR.\n-  (UNSPEC_SPR_MOVE                     212)\n+  (UNSPEC_SPR_MOVE                     213)\n \n   ;; A call to __tls_get_addr\n-  (UNSPEC_TLS_GD_CALL                  213)\n+  (UNSPEC_TLS_GD_CALL                  214)\n \n   ;; An opaque TLS \"add\" operation for TLS general dynamic model\n   ;; access.\n-  (UNSPEC_TLS_GD_ADD                   214)\n+  (UNSPEC_TLS_GD_ADD                   215)\n \n   ;; An opaque TLS \"load\" operation for TLS initial exec model access.\n-  (UNSPEC_TLS_IE_LOAD                  215)\n+  (UNSPEC_TLS_IE_LOAD                  216)\n \n   ;; An opaque TLS \"add\" operation for TLS access.\n-  (UNSPEC_TLS_ADD                      216)\n+  (UNSPEC_TLS_ADD                      217)\n \n   ;; Atomics\n-  (UNSPEC_ATOMIC                       217)\n-  (UNSPEC_CMPXCHG                      218)\n-  (UNSPEC_XCHG                         219)\n+  (UNSPEC_ATOMIC                       218)\n+  (UNSPEC_CMPXCHG                      219)\n+  (UNSPEC_XCHG                         220)\n \n   ;;\n   ;; The following are operands.\n@@ -199,24 +200,32 @@\n   (UNSPEC_HW2_LAST                     306)\n \n   (UNSPEC_HW0_PCREL                    307)\n-  (UNSPEC_HW1_LAST_PCREL               308)\n+  (UNSPEC_HW1_PCREL                    308)\n+  (UNSPEC_HW1_LAST_PCREL               309)\n+  (UNSPEC_HW2_LAST_PCREL               310)\n \n-  (UNSPEC_HW0_GOT                      309)\n-  (UNSPEC_HW0_LAST_GOT                 310)\n-  (UNSPEC_HW1_LAST_GOT                 311)\n+  (UNSPEC_HW0_GOT                      311)\n+  (UNSPEC_HW0_LAST_GOT                 312)\n+  (UNSPEC_HW1_LAST_GOT                 313)\n \n-  (UNSPEC_HW0_TLS_GD                   312)\n-  (UNSPEC_HW1_LAST_TLS_GD              313)\n+  (UNSPEC_HW0_TLS_GD                   314)\n+  (UNSPEC_HW1_LAST_TLS_GD              315)\n \n-  (UNSPEC_HW0_TLS_IE                   314)\n-  (UNSPEC_HW1_LAST_TLS_IE              315)\n+  (UNSPEC_HW0_TLS_IE                   316)\n+  (UNSPEC_HW1_LAST_TLS_IE              317)\n \n-  (UNSPEC_HW0_TLS_LE                   316)\n-  (UNSPEC_HW1_LAST_TLS_LE              317)\n+  (UNSPEC_HW0_TLS_LE                   318)\n+  (UNSPEC_HW1_LAST_TLS_LE              319)\n+\n+  (UNSPEC_HW0_PLT_PCREL                320)\n+  (UNSPEC_HW1_PLT_PCREL                321)\n+\n+  (UNSPEC_HW1_LAST_PLT_PCREL           322)\n+  (UNSPEC_HW2_LAST_PLT_PCREL           323)\n \n   ;; This is used to wrap around the addresses of non-temporal load/store\n   ;; intrinsics.\n-  (UNSPEC_NON_TEMPORAL                 318)\n+  (UNSPEC_NON_TEMPORAL                 324)\n ])\n \n ;; Mark the last instruction of various latencies, used to\n@@ -885,15 +894,15 @@\n ;; Addresses\n ;;\n \n-;; First step of the 3-insn sequence to materialize a symbolic\n-;; address.\n+;; The next three patterns are used to to materialize a position\n+;; independent address by adding the difference of two labels to a base\n+;; label in the text segment, assuming that the difference fits in 32\n+;; signed bits.\n (define_expand \"mov_address_step1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(const:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n \t\t\t     UNSPEC_HW2_LAST)))])\n   \n-;; Second step of the 3-insn sequence to materialize a symbolic\n-;; address.\n (define_expand \"mov_address_step2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(unspec:DI\n@@ -902,8 +911,6 @@\n \t\t\t       UNSPEC_HW1))]\n \t UNSPEC_INSN_ADDR_SHL16INSLI))])\n   \n-;; Third step of the 3-insn sequence to materialize a symbolic\n-;; address.\n (define_expand \"mov_address_step3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(unspec:DI\n@@ -988,6 +995,106 @@\n   \"flag_pic\"\n   \"add<x>\\t%0, %r1, %r2\")\n \n+;; The next three patterns are used to to materialize a position\n+;; independent 64-bit address by adding the difference of two labels to\n+;; a base label in the text segment, without any limitation on the size\n+;; of the difference.\n+(define_expand \"mov_large_pcrel_step1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(const:DI (unspec:DI\n+\t\t   [(match_operand:DI 1 \"symbolic_operand\" \"\")\n+\t\t    (match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_HW2_LAST_PCREL)))]\n+  \"flag_pic\")\n+  \n+(define_expand \"mov_large_pcrel_step2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unspec:DI\n+\t [(match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+\t  (const:DI\n+\t   (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")\n+\t\t       (match_operand:DI 3 \"symbolic_operand\" \"\")]\n+\t\t      UNSPEC_HW1_PCREL))]\n+\t UNSPEC_INSN_ADDR_SHL16INSLI))]\n+  \"flag_pic\")\n+\n+;; Note: step 3 is same as move_pcrel_step2.\n+(define_expand \"mov_large_pcrel_step3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unspec:DI\n+\t [(match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+\t  (const:DI\n+\t   (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")\n+\t\t       (match_operand:DI 3 \"symbolic_operand\" \"\")]\n+\t\t      UNSPEC_HW0_PCREL))]\n+\t UNSPEC_INSN_ADDR_SHL16INSLI))]\n+  \"flag_pic\")\n+\n+(define_insn \"mov_large_pcrel_step4\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (unspec:DI [(match_operand:DI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t    (match_operand:DI 2 \"reg_or_0_operand\" \"rO\")\n+\t\t\t (match_operand:DI 3 \"symbolic_operand\" \"in\")\n+\t\t\t (match_operand:DI 4 \"symbolic_operand\" \"in\")]\n+\t\t   UNSPEC_MOV_LARGE_PCREL_STEP4))]\n+  \"flag_pic\"\n+  \"add\\t%0, %r1, %r2\")\n+\n+;; The next three patterns are used to materialize a position\n+;; independent 64-bit plt address by adding the difference of two\n+;; labels to a base label in the text segment.\n+(define_expand \"mov_plt_pcrel_step1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(const:DI (unspec:DI\n+\t\t\t[(match_operand:DI 1 \"symbolic_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"symbolic_operand\" \"\")]\n+                        UNSPEC_HW2_LAST_PLT_PCREL)))]\n+  \"flag_pic\")\n+  \n+(define_expand \"mov_plt_pcrel_step2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unspec:DI\n+\t [(match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+\t  (const:DI\n+\t   (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")\n+\t\t\t    (match_operand:DI 3 \"symbolic_operand\" \"\")]\n+\t\t      UNSPEC_HW1_PLT_PCREL))]\n+\t UNSPEC_INSN_ADDR_SHL16INSLI))]\n+  \"flag_pic\")\n+\n+(define_expand \"mov_plt_pcrel_step3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unspec:DI\n+\t [(match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+\t  (const:DI\n+\t   (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")\n+\t\t\t    (match_operand:DI 3 \"symbolic_operand\" \"\")]\n+\t\t      UNSPEC_HW0_PLT_PCREL))]\n+\t UNSPEC_INSN_ADDR_SHL16INSLI))]\n+  \"flag_pic\")\n+\n+;; The next two patterns are used to materialize a position independent\n+;; 32-bit plt address by adding the difference of two labels to a base\n+;; label in the text segment.\n+(define_expand \"mov_plt_pcrel_step1_32bit\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(const:SI (unspec:SI\n+\t\t\t[(match_operand:SI 1 \"symbolic_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"symbolic_operand\" \"\")]\n+                        UNSPEC_HW1_LAST_PLT_PCREL)))]\n+  \"flag_pic\")\n+  \n+(define_expand \"mov_plt_pcrel_step2_32bit\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(unspec:SI\n+\t [(match_operand:SI 1 \"reg_or_0_operand\" \"\")\n+\t  (const:SI\n+\t   (unspec:SI [(match_operand:SI 2 \"symbolic_operand\" \"\")\n+\t\t\t    (match_operand:SI 3 \"symbolic_operand\" \"\")]\n+\t\t      UNSPEC_HW0_PLT_PCREL))]\n+\t UNSPEC_INSN_ADDR_SHL16INSLI))]\n+  \"flag_pic\")\n+\n (define_expand \"add_got16<bitsuffix>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"\")\n         (plus:I48MODE\n@@ -2300,7 +2407,29 @@\n               (use (reg:DI 54))\n \t      (clobber (reg:DI 55))])]\n   \"\"\n-  \"\")\n+{\n+  rtx orig_addr = XEXP (operands[0], 0);\n+  rtx addr;\n+  if (GET_CODE (orig_addr) == SYMBOL_REF)\n+    {\n+      if (tilegx_cmodel == CM_LARGE)\n+        {\n+          addr = gen_reg_rtx (Pmode);\n+          tilegx_expand_set_const64 (addr, orig_addr);\n+          operands[0] = gen_rtx_MEM (DImode, addr);\n+        }\n+      else if (tilegx_cmodel == CM_LARGE_PIC)\n+        {\n+          crtl->uses_pic_offset_table = 1;\n+          addr = gen_reg_rtx (Pmode);\n+\t  if (SYMBOL_REF_LOCAL_P (orig_addr))\n+\t    tilegx_compute_pcrel_address (addr, orig_addr);\n+\t  else\n+\t    tilegx_compute_pcrel_plt_address (addr, orig_addr);\n+          operands[0] = gen_rtx_MEM (DImode, addr);\n+        }\n+    }\n+})\n \n (define_insn \"*call_insn\"\n   [(call (mem:DI (match_operand:I48MODE 0 \"call_address_operand\" \"rO,i\"))\n@@ -2319,7 +2448,30 @@\n \t\t\t (match_operand 2 \"\" \"\")))\n               (use (reg:DI 54))\n \t      (clobber (reg:DI 55))])]\n-  \"\")\n+  \"\"\n+{\n+  rtx orig_addr = XEXP (operands[1], 0);\n+  rtx addr;\n+  if (GET_CODE (orig_addr) == SYMBOL_REF)\n+    {\n+      if (tilegx_cmodel == CM_LARGE)\n+        {\n+          addr = gen_reg_rtx (Pmode);\n+          tilegx_expand_set_const64 (addr, orig_addr);\n+          operands[1] = gen_rtx_MEM (DImode, addr);\n+        }\n+      else if (tilegx_cmodel == CM_LARGE_PIC)\n+        {\n+          crtl->uses_pic_offset_table = 1;\n+          addr = gen_reg_rtx (Pmode);\n+\t  if (SYMBOL_REF_LOCAL_P (orig_addr))\n+\t    tilegx_compute_pcrel_address (addr, orig_addr);\n+\t  else\n+\t    tilegx_compute_pcrel_plt_address (addr, orig_addr);\n+          operands[1] = gen_rtx_MEM (DImode, addr);\n+        }\n+      }\n+})\n \n (define_insn \"*call_value_insn\"\n   [(set (match_operand 0 \"register_operand\" \"=r,r\")"}, {"sha": "932f4842f8a59781bdee800b62510d47376d1652", "filename": "gcc/config/tilegx/tilegx.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -19,6 +19,9 @@\n ; along with GCC; see the file COPYING3.  If not see\n ; <http://www.gnu.org/licenses/>.\n \n+HeaderInclude\n+config/tilegx/tilegx-opts.h\n+\n mcpu=\n Target RejectNegative Joined Enum(tilegx_cpu) Var(tilegx_cpu) Init(0)\n -mcpu=CPU\tUse features of and schedule code for given CPU\n@@ -38,3 +41,16 @@ m64\n Target Report RejectNegative Negative(m32) InverseMask(32BIT, 64BIT)\n Compile with 64 bit longs and pointers.\n \n+mcmodel=\n+Target RejectNegative Joined Enum(cmodel) Var(tilegx_cmodel) Init(CM_SMALL)\n+Use given TILE-Gx code model\n+\n+Enum\n+Name(cmodel) Type(enum cmodel)\n+Known code models (for use with the -mcmodel= option):\n+\n+EnumValue\n+Enum(cmodel) String(small) Value(CM_SMALL)\n+\n+EnumValue\n+Enum(cmodel) String(large) Value(CM_LARGE)"}, {"sha": "bf7844ded29d6d9bae70ccf1fc1265ddbd8bbccb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1773cd776ad33ff4688ff29437ec716eda0e58e6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1773cd776ad33ff4688ff29437ec716eda0e58e6", "patch": "@@ -929,7 +929,7 @@ See RS/6000 and PowerPC Options.\n @gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}\n \n @emph{TILE-Gx Options}\n-@gccoptlist{-mcpu=CPU -m32 -m64}\n+@gccoptlist{-mcpu=CPU -m32 -m64 -mcmodel=@var{code-model}}\n \n @emph{TILEPro Options}\n @gccoptlist{-mcpu=CPU -m32}\n@@ -18937,6 +18937,17 @@ The assembler uses this option.\n These @samp{-m} options are supported on the TILE-Gx:\n \n @table @gcctabopt\n+@item -mcmodel=small\n+@opindex mcmodel=small\n+Generate code for the small model.  Distance for direct calls is\n+limited to 500M in either direction.  PC-relative addresses are 32\n+bits.  Absolute addresses support the full address range.\n+\n+@item -mcmodel=large\n+@opindex mcmodel=large\n+Generate code for the large model.  There is no limiation on call\n+distance, pc-relative addresses, or absolute addresses.\n+\n @item -mcpu=@var{name}\n @opindex mcpu\n Selects the type of CPU to be targeted.  Currently the only supported"}]}