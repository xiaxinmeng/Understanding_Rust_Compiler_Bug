{"sha": "cf4ed945eab57de7fe5b2f736cc773659a966a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y0ZWQ5NDVlYWI1N2RlN2ZlNWIyZjczNmNjNzczNjU5YTk2NmEwYw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-02-10T23:47:04Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-02-10T23:47:04Z"}, "message": "cppexp.c: Don't include cpphash.h.\n\n\t* cppexp.c: Don't include cpphash.h.\n\t(parse_charconst, cpp_lex): Use cpp_defined.\n\t(cpp_lex): Use get_directive_token throughout.  Remove\n\tunnecessary cases from switch.  Move assertion-handling code\n\tdown to OTHER case.\n\t(cpp_parse_expr): If we see '+' or '-', check the context to\n\tdetermine if they are unary or binary operators.  Streamline\n\tthe jumps a bit.  Do not call skip_rest_of_line.\n\n\t* cpplib.c: Make skip_rest_of_line and cpp_skip_hspace\n\tstatic.  Export get_directive_token.  Update commentary.\n\t(cpp_defined): New function.\n\t(do_define): Remove reference to T_PCSTRING.  Call\n\tfree_definition to release memory for old definition, when\n\tredefining a macro.\n\t(eval_if_expression): Set only_seen_white to 0 before calling\n\tcpp_parse_expr.  Call skip_rest_of_line after it returns.\n\t(cpp_read_check_assertion): Don't preserve a pointer into the\n\ttoken buffer across a call to cpp_get_token.\n\n\t* Makefile.in (cppexp.o): Don't depend on cpphash.h.\n\t* cppfiles.c (redundant_include_p): Use cpp_defined.\n\t* cpphash.c (free_definition): New function.\n\t(delete_macro): Use it.  Update commentary.\n\t* cpphash.h: Typedef HASHNODE here.  Prototype cpp_lookup and\n\tfree_definition.\n\t* cpplib.h: Don't typedef HASHNODE here. Delete T_PCSTRING\n\tfrom enum node_type.  Prototype cpp_defined and get_directive_token.\n\tDon't prototype cpp_lookup, skip_rest_of_line, or cpp_skip_hspace.\n\n\t* fix-header.c (check_macro_names): Use cpp_defined.\n\t(read_scan_file): Set inhibit_warnings and inhibit_errors in\n\tthe options structure.\n\nFrom-SVN: r31908", "tree": {"sha": "62eef5d947b8384b8147ec6d6b0b4aecba2485ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62eef5d947b8384b8147ec6d6b0b4aecba2485ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf4ed945eab57de7fe5b2f736cc773659a966a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4ed945eab57de7fe5b2f736cc773659a966a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf4ed945eab57de7fe5b2f736cc773659a966a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4ed945eab57de7fe5b2f736cc773659a966a0c/comments", "author": null, "committer": null, "parents": [{"sha": "26439cc59cd34989b7a98d676a5e210302da15c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26439cc59cd34989b7a98d676a5e210302da15c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26439cc59cd34989b7a98d676a5e210302da15c0"}], "stats": {"total": 309, "additions": 184, "deletions": 125}, "files": [{"sha": "255ab22a96ded7fa765ebb5610bcbb8ba25708e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -1,3 +1,39 @@\n+2000-02-10  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppexp.c: Don't include cpphash.h.\n+\t(parse_charconst, cpp_lex): Use cpp_defined.\n+\t(cpp_lex): Use get_directive_token throughout.  Remove\n+\tunnecessary cases from switch.  Move assertion-handling code\n+\tdown to OTHER case.\n+\t(cpp_parse_expr): If we see '+' or '-', check the context to\n+\tdetermine if they are unary or binary operators.  Streamline\n+\tthe jumps a bit.  Do not call skip_rest_of_line.\n+\n+\t* cpplib.c: Make skip_rest_of_line and cpp_skip_hspace\n+\tstatic.  Export get_directive_token.  Update commentary.\n+\t(cpp_defined): New function.\n+\t(do_define): Remove reference to T_PCSTRING.  Call\n+\tfree_definition to release memory for old definition, when\n+\tredefining a macro.\n+\t(eval_if_expression): Set only_seen_white to 0 before calling\n+\tcpp_parse_expr.  Call skip_rest_of_line after it returns.\n+\t(cpp_read_check_assertion): Don't preserve a pointer into the\n+\ttoken buffer across a call to cpp_get_token.\n+\n+\t* Makefile.in (cppexp.o): Don't depend on cpphash.h.\n+\t* cppfiles.c (redundant_include_p): Use cpp_defined.\n+\t* cpphash.c (free_definition): New function.\n+\t(delete_macro): Use it.  Update commentary.\n+\t* cpphash.h: Typedef HASHNODE here.  Prototype cpp_lookup and\n+\tfree_definition.\n+\t* cpplib.h: Don't typedef HASHNODE here. Delete T_PCSTRING\n+\tfrom enum node_type.  Prototype cpp_defined and get_directive_token.\n+\tDon't prototype cpp_lookup, skip_rest_of_line, or cpp_skip_hspace.\n+\n+\t* fix-header.c (check_macro_names): Use cpp_defined.\n+\t(read_scan_file): Set inhibit_warnings and inhibit_errors in\n+\tthe options structure.\n+\n 2000-02-10  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* c-pragma.c (maximum_field_alignment): Remove duplicate declaration."}, {"sha": "31a0173f73f8e1ade458c39b74eb5158aff5c367", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -2043,7 +2043,7 @@ cpplib.o:  cpplib.c  $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n cpphash.o: cpphash.c $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h intl.h system.h\n cpperror.o: cpperror.c $(CONFIG_H) cpplib.h intl.h system.h\n-cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n+cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h system.h\n cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h intl.h system.h\n \n cppinit.o:  cppinit.c $(CONFIG_H) cpplib.h intl.h system.h \\"}, {"sha": "a7db2ce899a670b03b290482223f646f4902c31f", "filename": "gcc/cppexp.c", "status": "modified", "additions": 42, "deletions": 69, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -27,7 +27,6 @@ Written by Per Bothner 1994.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n-#include \"cpphash.h\"\n \n #ifdef MULTIBYTE_CHARS\n #include <locale.h>\n@@ -331,8 +330,8 @@ parse_charconst (pfile, start, end)\n   /* If char type is signed, sign-extend the constant.  */\n   num_bits = num_chars * width;\n       \n-  if (cpp_lookup (pfile, (const U_CHAR *)\"__CHAR_UNSIGNED__\",\n-\t\t  sizeof (\"__CHAR_UNSIGNED__\")-1)\n+  if (cpp_defined (pfile, (const U_CHAR *)\"__CHAR_UNSIGNED__\",\n+\t\t   sizeof (\"__CHAR_UNSIGNED__\")-1)\n       || ((result >> (num_bits - 1)) & 1) == 0)\n     op.value = result & ((unsigned HOST_WIDEST_INT) ~0\n \t\t\t >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n@@ -377,56 +376,28 @@ cpp_lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n      int skip_evaluation;\n {\n-  U_CHAR c;\n   struct token *toktab;\n   enum cpp_token token;\n   struct operation op;\n   U_CHAR *tok_start, *tok_end;\n-  int old_written;\n-\n- retry:\n+  long old_written;\n \n   old_written = CPP_WRITTEN (pfile);\n-  cpp_skip_hspace (pfile);\n-  c = CPP_BUF_PEEK (CPP_BUFFER (pfile));\n-  if (c == '#')\n-    {\n-      op.op = INT;\n-      op.value = cpp_read_check_assertion (pfile);\n-      return op;\n-    }\n-\n-  if (c == '\\n')\n-    {\n-      op.op = 0;\n-      return op;\n-    }\n+  token = get_directive_token (pfile);\n \n-  token = cpp_get_token (pfile);\n   tok_start = pfile->token_buffer + old_written;\n   tok_end = CPP_PWRITTEN (pfile);\n-  pfile->limit = tok_start;\n+  CPP_SET_WRITTEN (pfile, old_written);\n   switch (token)\n   {\n     case CPP_EOF: /* Should not happen ...  */\n     case CPP_VSPACE:\n       op.op = 0;\n       return op;\n-    case CPP_POP:\n-      if (CPP_BUFFER (pfile)->fname != NULL)\n-\t{\n-\t  op.op = 0;\n-\t  return op;\n-\t}\n-      cpp_pop_buffer (pfile);\n-      goto retry;\n-    case CPP_HSPACE:\n-    case CPP_COMMENT: \n-      goto retry;\n     case CPP_NUMBER:\n       return parse_number (pfile, tok_start, tok_end);\n     case CPP_STRING:\n-      cpp_error (pfile, \"string constants not allowed in #if expressions\");\n+      cpp_error (pfile, \"string constants are not allowed in #if expressions\");\n       op.op = ERROR;\n       return op;\n     case CPP_CHAR:\n@@ -445,45 +416,38 @@ cpp_lex (pfile, skip_evaluation)\n       else\n \t{\n \t  int paren = 0, len;\n-\t  cpp_buffer *ip = CPP_BUFFER (pfile);\n \t  U_CHAR *tok;\n-\t  HASHNODE *hp;\n \n-\t  cpp_skip_hspace (pfile);\n-\t  if (*ip->cur == '(')\n+\t  pfile->no_macro_expand++;\n+\t  token = get_directive_token (pfile);\n+\t  if (token == CPP_LPAREN)\n \t    {\n \t      paren++;\n-\t      ip->cur++;\t\t\t/* Skip over the paren */\n-\t      cpp_skip_hspace (pfile);\n+\t      CPP_SET_WRITTEN (pfile, old_written);\n+\t      token = get_directive_token (pfile);\n \t    }\n \n-\t  if (!is_idstart(*ip->cur))\n-\t    goto oops;\n-\t  if (ip->cur[0] == 'L' && (ip->cur[1] == '\\'' || ip->cur[1] == '\"'))\n+\t  if (token != CPP_NAME)\n \t    goto oops;\n-\t  tok = ip->cur;\n-\t  while (is_idchar(*ip->cur))\n-\t    ++ip->cur;\n-\t  len = ip->cur - tok;\n-\t  cpp_skip_hspace (pfile);\n+\n+\t  tok = pfile->token_buffer + old_written;\n+\t  len = CPP_PWRITTEN (pfile) - tok;\n+\t  if (cpp_defined (pfile, tok, len))\n+\t    op.value = 1;\n+\n \t  if (paren)\n \t    {\n-\t      if (*ip->cur != ')')\n+\t      if (get_directive_token (pfile) != CPP_RPAREN)\n \t\tgoto oops;\n-\t      ++ip->cur;\n-\t    }\n-\t  hp = cpp_lookup (pfile, tok, len);\n-\t  if (hp != NULL)\n-\t    {\n-\t      if (hp->type == T_POISON)\n-\t\tcpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n-\t      else\n-\t\top.value = 1;\n \t    }\n+\t  CPP_SET_WRITTEN (pfile, old_written);\n+\t  pfile->no_macro_expand--;\n \t}\n       return op;\n \n     oops:\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      pfile->no_macro_expand--;\n       cpp_error (pfile, \"`defined' without an identifier\");\n       return op;\n \n@@ -501,6 +465,13 @@ cpp_lex (pfile, skip_evaluation)\n \t  op.op = toktab->token; \n \t  return op;\n \t}\n+      else if (tok_start + 1 == tok_end && *tok_start == '#')\n+\t{\n+\t  CPP_FORWARD (CPP_BUFFER (pfile), -1);\n+\t  op.op = INT;\n+\t  op.value = cpp_read_check_assertion (pfile);\n+\t  return op;\n+\t}\n       /* fall through */\n     default:\n       op.op = *tok_start;\n@@ -736,15 +707,16 @@ cpp_parse_expr (pfile)\n \t  cpp_ice (pfile, \"cpp_lex returns a NAME\");\n \t  goto syntax_error;\n \tcase INT:  case CHAR:\n-\t  top->value = op.value;\n-\t  top->unsignedp = op.unsignedp;\n \t  goto set_value;\n \tcase 0:\n \t  lprio = 0;  goto maybe_reduce;\n \tcase '+':  case '-':\n-\t  /* Is this correct if unary ? FIXME */\n-\t  flags = RIGHT_OPERAND_REQUIRED;\n-\t  lprio = PLUS_PRIO;  rprio = lprio + 1;  goto maybe_reduce;\n+\t  if (top->flags & HAVE_VALUE)\n+\t    {\n+\t      lprio = PLUS_PRIO;\n+\t      goto binop;\n+\t    }\n+\t  /* else fall through */\n \tcase '!':  case '~':\n \t  flags = RIGHT_OPERAND_REQUIRED;\n \t  rprio = UNARY_PRIO;  lprio = rprio + 1;  goto maybe_reduce;\n@@ -777,10 +749,6 @@ cpp_parse_expr (pfile)\n \t  goto maybe_reduce;\n \tcase ERROR:\n \t  goto syntax_error;\n-\tbinop:\n-\t  flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n-\t  rprio = lprio + 1;\n-\t  goto maybe_reduce;\n \tdefault:\n \t  cpp_error (pfile, \"invalid character in #if\");\n \t  goto syntax_error;\n@@ -793,9 +761,15 @@ cpp_parse_expr (pfile)\n \t  cpp_error (pfile, \"syntax error in #if\");\n \t  goto syntax_error;\n \t}\n+      top->value = op.value;\n+      top->unsignedp = op.unsignedp;\n       top->flags |= HAVE_VALUE;\n       continue;\n \n+    binop:\n+      flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n+      rprio = lprio + 1;\n+\n     maybe_reduce:\n       /* Push an operator, and check if we can reduce now.  */\n       while (top->rprio > lprio)\n@@ -1065,6 +1039,5 @@ cpp_parse_expr (pfile)\n  syntax_error:\n   if (stack != init_stack)\n     free (stack);\n-  skip_rest_of_line (pfile);\n   return 0;\n }"}, {"sha": "a00fb89e395c671fa391688f75d8ade61e4ad678", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -286,7 +286,7 @@ redundant_include_p (pfile, ihash, ilist)\n \t    included again if the string is the name of a defined macro. */\n \t return (i->control_macro\n \t\t && (i->control_macro[0] == '\\0'\n-\t\t     || cpp_lookup (pfile, i->control_macro, -1)))\n+\t\t     || cpp_defined (pfile, i->control_macro, -1)))\n \t     ? (struct include_hash *)-1 : i;\n \n   return 0;"}, {"sha": "7b0bea23f174a93a88ac91dec15ab828e0e7fc71", "filename": "gcc/cpphash.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -140,20 +140,31 @@ cpp_lookup (pfile, name, len)\n   return (HASHNODE *) 0;\n }\n \n+/* Free a DEFINITION structure.  Used by delete_macro, and by\n+   do_define when redefining macros.  */\n+\n+void\n+free_definition (d)\n+     DEFINITION *d;\n+{\n+  struct reflist *ap, *nextap;\n+\n+  for (ap = d->pattern; ap != NULL; ap = nextap)\n+    {\n+      nextap = ap->next;\n+      free (ap);\n+    }\n+  if (d->nargs >= 0)\n+    free (d->argnames);\n+  free (d);\n+}\n+\n /*\n  * Delete a hash node.  Some weirdness to free junk from macros.\n  * More such weirdness will have to be added if you define more hash\n  * types that need it.\n  */\n \n-/* Note that the DEFINITION of a macro is removed from the hash table\n-   but its storage is not freed.  This would be a storage leak\n-   except that it is not reasonable to keep undefining and redefining\n-   large numbers of macros many times.\n-   In any case, this is necessary, because a macro can be #undef'd\n-   in the middle of reading the arguments to a call to it.\n-   If #undef freed the DEFINITION, that would crash.  */\n-\n void\n delete_macro (hp)\n      HASHNODE *hp;\n@@ -170,19 +181,7 @@ delete_macro (hp)\n     *hp->bucket_hdr = hp->next;\n \n   if (hp->type == T_MACRO)\n-    {\n-      DEFINITION *d = hp->value.defn;\n-      struct reflist *ap, *nextap;\n-\n-      for (ap = d->pattern; ap != NULL; ap = nextap)\n-\t{\n-\t  nextap = ap->next;\n-\t  free (ap);\n-\t}\n-      if (d->nargs >= 0)\n-\tfree (d->argnames);\n-      free (d);\n-    }\n+    free_definition (hp->value.defn);\n \n   free (hp);\n }"}, {"sha": "b9742843ed9536c0770c749b7404b6908101608d", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -83,6 +83,7 @@ union hashval\n   struct hashnode *aschain;\t/* #assert */\n };\n \n+typedef struct hashnode HASHNODE;\n struct hashnode {\n   struct hashnode *next;\t/* double links for easy deletion */\n   struct hashnode *prev;\n@@ -97,6 +98,8 @@ struct hashnode {\n \n extern HASHNODE *cpp_install\t  PARAMS ((cpp_reader *, const U_CHAR *, int,\n \t\t\t\t\t   enum node_type, const char *));\n+extern HASHNODE *cpp_lookup\t  PARAMS ((cpp_reader *, const U_CHAR *, int));\n+extern void free_definition\t  PARAMS ((DEFINITION *));\n extern void delete_macro\t  PARAMS ((HASHNODE *));\n \n extern MACRODEF create_definition PARAMS ((U_CHAR *, U_CHAR *,"}, {"sha": "c64e682f8881e158cc61bd035d3f0eef6a6050dc", "filename": "gcc/cpplib.c", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -93,11 +93,12 @@ static int null_cleanup\t\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static int skip_comment\t\t\tPARAMS ((cpp_reader *, int));\n static int copy_comment\t\t\tPARAMS ((cpp_reader *, int));\n static void copy_rest_of_line\t\tPARAMS ((cpp_reader *));\n+static void skip_rest_of_line\t\tPARAMS ((cpp_reader *));\n+static void cpp_skip_hspace\t\tPARAMS ((cpp_reader *));\n static int handle_directive\t\tPARAMS ((cpp_reader *));\n static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t cpp_reader *,\n \t\t\t\t\t\t const struct directive *));\n-static enum cpp_token get_directive_token PARAMS ((cpp_reader *));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n static int consider_directive_while_skipping PARAMS ((cpp_reader *,\n@@ -192,12 +193,7 @@ cpp_grow_buffer (pfile, n)\n   CPP_SET_WRITTEN (pfile, old_written);\n }\n \n-/* Process the string STR as if it appeared as the body of a #define\n-   If STR is just an identifier, define it with value 1.\n-   If STR has anything after the identifier, then it should\n-   be identifier=definition. */\n-\n-/* Process the string STR as if it appeared as the body of a #define\n+/* Process the string STR as if it appeared as the body of a #define.\n    If STR is just an identifier, define it with value 1.\n    If STR has anything after the identifier, then it should\n    be identifier=definition. */\n@@ -252,6 +248,21 @@ cpp_assert (pfile, str)\n     }\n }\n \n+/* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n+int\n+cpp_defined (pfile, id, len)\n+     cpp_reader *pfile;\n+     const U_CHAR *id;\n+     int len;\n+{\n+  HASHNODE *hp = cpp_lookup (pfile, id, len);\n+  if (hp && hp->type == T_POISON)\n+    {\n+      cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n+      return 0;\n+    }\n+  return (hp != NULL);\n+}\n \n static enum cpp_token\n null_underflow (pfile)\n@@ -407,7 +418,7 @@ copy_comment (pfile, m)\n \n /* Skip whitespace \\-newline and comments.  Does not macro-expand.  */\n \n-void\n+static void\n cpp_skip_hspace (pfile)\n      cpp_reader *pfile;\n {\n@@ -508,7 +519,7 @@ copy_rest_of_line (pfile)\n    the scan itself.  >75% of calls to copy_r_o_l are from here or\n    skip_if_group, which means the common case is to copy stuff into the\n    token_buffer only to discard it.  */\n-void\n+static void\n skip_rest_of_line (pfile)\n      cpp_reader *pfile;\n {\n@@ -684,11 +695,8 @@ do_define (pfile, keyword)\n   if ((hp = cpp_lookup (pfile, mdef.symnam, mdef.symlen)) != NULL)\n     {\n       int ok = 0;\n-      /* Redefining a precompiled key is ok.  */\n-      if (hp->type == T_PCSTRING)\n-\tok = 1;\n       /* Redefining a poisoned identifier is even worse than `not ok'.  */\n-      else if (hp->type == T_POISON)\n+      if (hp->type == T_POISON)\n \tok = -1;\n       /* Redefining a macro is ok if the definitions are the same.  */\n       else if (hp->type == T_MACRO)\n@@ -713,6 +721,7 @@ do_define (pfile, keyword)\n \t{\n \t  /* Replace the old definition.  */\n \t  hp->type = new_type;\n+\t  free_definition (hp->value.defn);\n \t  hp->value.defn = mdef.defn;\n \t}\n     }\n@@ -986,7 +995,7 @@ output_line_command (pfile, file_change)\n /* Like cpp_get_token, except that it does not read past end-of-line.\n    Also, horizontal space is skipped, and macros are popped.  */\n \n-static enum cpp_token\n+enum cpp_token\n get_directive_token (pfile)\n      cpp_reader *pfile;\n {\n@@ -1872,8 +1881,13 @@ eval_if_expression (pfile)\n   HOST_WIDEST_INT value;\n   long old_written = CPP_WRITTEN (pfile);\n \n+  /* Work around bug in cpp_get_token where it may mistake an\n+     assertion for a directive.  */\n+  pfile->only_seen_white = 0;\n+\n   value = cpp_parse_expr (pfile);\n \n+  skip_rest_of_line (pfile);\n   CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n \n   return value;\n@@ -2631,10 +2645,7 @@ cpp_get_token (pfile)\n \t\treturn CPP_NAME;\n \t      }\n \n-\t    /* If macro wants an arglist, verify that a '(' follows.\n-\t       first skip all whitespace, copying it to the output\n-\t       after the macro name.  Then, if there is no '(',\n-\t       decide this is not a macro call and leave things that way.  */\n+\t    /* If macro wants an arglist, verify that a '(' follows.  */\n \t    if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n \t    {\n \t      int macbuf_whitespace = 0;\n@@ -3130,25 +3141,31 @@ int\n cpp_read_check_assertion (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *name = CPP_PWRITTEN (pfile);\n+  U_CHAR *name;\n   int result;\n-  HASHNODE *hp;\n+  long written = CPP_WRITTEN (pfile);\n   \n   FORWARD (1);  /* Skip '#' */\n   cpp_skip_hspace (pfile);\n   if (! parse_assertion (pfile))\n     result = 0;\n   else\n     {\n-      hp = cpp_lookup (pfile, name, CPP_PWRITTEN (pfile) - name);\n-      result = (hp != 0);\n+      name = pfile->token_buffer + written;\n+      result = cpp_defined (pfile, name, CPP_PWRITTEN (pfile) - name);\n     }\n \n-  pfile->limit = name;\n+  CPP_SET_WRITTEN (pfile, written);\n   return result;\n }\n \n-/* Remember the current position of PFILE.  */\n+/* Remember the current position of PFILE so it may be returned to\n+   after looking ahead a bit.\n+\n+   Note that when you set a mark, you _must_ return to that mark.  You\n+   may not forget about it and continue parsing.  You may not pop a\n+   buffer with an active mark.  You may not call CPP_BUMP_LINE while a\n+   mark is active.  */\n \n static void\n parse_set_mark (pfile)"}, {"sha": "82eb55c44b9dfb19756ce0256f9937de148c87ef", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -61,8 +61,8 @@ typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n-extern void cpp_skip_hspace PARAMS((cpp_reader *));\n extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n+extern enum cpp_token get_directive_token PARAMS ((cpp_reader *));\n \n /* This frees resources used by PFILE. */\n extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n@@ -139,9 +139,6 @@ struct file_name_map_list;\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n    tokens.  Usually, there is only one cpp_reader object active. */\n \n-struct hashnode;\n-typedef struct hashnode HASHNODE;\n-\n struct cpp_reader\n {\n   parse_underflow_t get_token;\n@@ -169,7 +166,7 @@ struct cpp_reader\n \n   /* Hash table of macros and assertions.  See cpphash.c */\n #define HASHSIZE 1403\n-  HASHNODE **hashtab;\n+  struct hashnode **hashtab;\n \n   /* Hash table of other included files.  See cppfiles.c */\n #define ALL_INCLUDE_HASHSIZE 71\n@@ -600,7 +597,6 @@ enum node_type {\n  T_CONST,\t/* Constant string, used by `__SIZE_TYPE__' etc */\n  T_MACRO,\t/* macro defined by `#define' */\n  T_DISABLED,\t/* macro temporarily turned off for rescan */\n- T_PCSTRING,\t/* precompiled string (hashval is KEYDEF *) */\n  T_POISON,\t/* defined with `#pragma poison' */\n  T_UNUSED\t/* Used for something not defined.  */\n  };\n@@ -686,13 +682,12 @@ extern void cpp_grow_buffer PARAMS ((cpp_reader *, long));\n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    unsigned char *, long));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n-extern HASHNODE *cpp_lookup PARAMS ((cpp_reader *, const U_CHAR *, int));\n+extern int cpp_defined PARAMS ((cpp_reader *, const U_CHAR *, int));\n \n extern void cpp_reader_init PARAMS ((cpp_reader *));\n extern void cpp_options_init PARAMS ((cpp_options *));\n extern int cpp_start_read PARAMS ((cpp_reader *, char *));\n extern int cpp_read_check_assertion PARAMS ((cpp_reader *));\n-extern void skip_rest_of_line PARAMS ((cpp_reader *));\n extern void cpp_finish PARAMS ((cpp_reader *));\n \n extern void quote_string\t\tPARAMS ((cpp_reader *, const char *));"}, {"sha": "6b1c56f575c2f9d37645454b41acb9df376f8ea6", "filename": "gcc/fix-header.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -603,7 +603,7 @@ check_macro_names (pfile, names)\n {\n   while (*names)\n     {\n-      if (cpp_lookup (pfile, names, -1))\n+      if (cpp_defined (pfile, names, -1))\n \trecognized_macro (names);\n       names += strlen (names) + 1;\n     }\n@@ -626,6 +626,10 @@ read_scan_file (in_fname, argc, argv)\n   cpp_reader_init (&scan_in);\n   scan_in.opts = &scan_options;\n   cpp_options_init (&scan_options);\n+  /* We are going to be scanning a header file out of its proper context,\n+     so ignore warnings and errors.  */\n+  scan_options.inhibit_warnings = 1;\n+  scan_options.inhibit_errors = 1;\n   i = cpp_handle_options (&scan_in, argc, argv);\n   if (i < argc && ! CPP_FATAL_ERRORS (&scan_in))\n     cpp_fatal (&scan_in, \"Invalid option `%s'\", argv[i]);"}, {"sha": "931cc0d47844c84c980505b343afbeccf98874cd", "filename": "gcc/testsuite/gcc.dg/20000207-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Ftestsuite%2Fgcc.dg%2F20000207-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Ftestsuite%2Fgcc.dg%2F20000207-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20000207-1.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do preprocess } */\n+\n+/* Test for proper handling of unary minus in #if.  */\n+\n+#if !(-1)\n+#error Error\t/* { dg-bogus \"Error\" \"case !(-1)\" } */\n+#endif\n+\n+#if !-1\n+#error Error\t/* { dg-bogus \"Error\" \"case !-1\" } */\n+#endif\n+\n+#if -1\n+#else\n+#error Error\t/* { dg-bogus \"Error\" \"case -1\" } */\n+#endif"}, {"sha": "fbdf39e14260493614100a95486f6c774c5365de", "filename": "gcc/testsuite/gcc.dg/20000207-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Ftestsuite%2Fgcc.dg%2F20000207-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf4ed945eab57de7fe5b2f736cc773659a966a0c/gcc%2Ftestsuite%2Fgcc.dg%2F20000207-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20000207-2.c?ref=cf4ed945eab57de7fe5b2f736cc773659a966a0c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do preprocess } */\n+\n+/* Test for proper handling of unary plus in #if.  */\n+\n+#if !(+1)\n+#error Error\t/* { dg-bogus \"Error\" \"case !(+1)\" } */\n+#endif\n+\n+#if !+1\n+#error Error\t/* { dg-bogus \"Error\" \"case !+1\" } */\n+#endif\n+\n+#if +1\n+#else\n+#error Error\t/* { dg-bogus \"Error\" \"case +1\" } */\n+#endif"}]}