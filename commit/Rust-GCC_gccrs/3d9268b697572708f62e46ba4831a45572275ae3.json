{"sha": "3d9268b697572708f62e46ba4831a45572275ae3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q5MjY4YjY5NzU3MjcwOGY2MmU0NmJhNDgzMWE0NTU3MjI3NWFlMw==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-04-12T02:30:52Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-04-12T02:30:52Z"}, "message": "pa.c (pa_output_function_prologue): Don't accumulate the total number of code bytes when using TARGET_64BIT...\n\n\t* pa.c (pa_output_function_prologue): Don't accumulate the total\n\tnumber of code bytes when using TARGET_64BIT, or gas, SOM and not\n\tthe portable runtime.\n\t(output_deferred_plabels): Handle 64bit plabels.\n\t(output_cbranch): Use $PIC_pcrel$0 for pc relative relocations when\n\tgenerating pic code using the GAS assembler for object formats that\n\tare not SOM (ie., ELF32 and ELF64).\n\t(output_millicode_call): Check attribute type if attribute length is 28.\n\tLikewise use $PIC_pcrel$0.  Only call get_attr_length and\n\tdbr_sequence_length once.\n\t(output_call): Likewise use $PIC_pcrel$0, and call get_attr_length and\n\tdbr_sequence_length once.\n\t* pa.h (TARGET_SOM): Define if not defined.\n\t* pa.md (pattern to load address of label): Likewise use $PIC_pcrel$0\n\twith GAS and not SOM.\n\t(jump, call_internal_reg, call_value_internal_reg): Likewise.\n\t* som.h (OBJ_SOM): Rename to TARGET_SOM.  Undefine before defining.\n\nFrom-SVN: r52196", "tree": {"sha": "7a10663402c19be018e2ebb8b1769fd677f2e5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a10663402c19be018e2ebb8b1769fd677f2e5da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d9268b697572708f62e46ba4831a45572275ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9268b697572708f62e46ba4831a45572275ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d9268b697572708f62e46ba4831a45572275ae3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9268b697572708f62e46ba4831a45572275ae3/comments", "author": null, "committer": null, "parents": [{"sha": "d360fd186232a2f9b9bf9745b05dabb547e61b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d360fd186232a2f9b9bf9745b05dabb547e61b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d360fd186232a2f9b9bf9745b05dabb547e61b0e"}], "stats": {"total": 239, "additions": 173, "deletions": 66}, "files": [{"sha": "1eb5798cefead0e304314dc96530198da9201a0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d9268b697572708f62e46ba4831a45572275ae3", "patch": "@@ -1,3 +1,23 @@\n+2002-04-11  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* pa.c (pa_output_function_prologue): Don't accumulate the total\n+\tnumber of code bytes when using TARGET_64BIT, or gas, SOM and not\n+\tthe portable runtime.\n+\t(output_deferred_plabels): Handle 64bit plabels.\n+\t(output_cbranch): Use $PIC_pcrel$0 for pc relative relocations when\n+\tgenerating pic code using the GAS assembler for object formats that\n+\tare not SOM (ie., ELF32 and ELF64).\n+\t(output_millicode_call): Check attribute type if attribute length is 28.\n+\tLikewise use $PIC_pcrel$0.  Only call get_attr_length and\n+\tdbr_sequence_length once.\n+\t(output_call): Likewise use $PIC_pcrel$0, and call get_attr_length and\n+\tdbr_sequence_length once.\n+\t* pa.h (TARGET_SOM): Define if not defined.\n+\t* pa.md (pattern to load address of label): Likewise use $PIC_pcrel$0\n+\twith GAS and not SOM.\n+\t(jump, call_internal_reg, call_value_internal_reg): Likewise.\n+\t* som.h (OBJ_SOM): Rename to TARGET_SOM.  Undefine before defining.\n+\n 2002-04-11  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config/freebsd.h (NO_IMPLICIT_EXTERN_C, SCCS_DIRECTIVE): Give value."}, {"sha": "17d81fa884c616aaa8e87263b8fc0a07e689e528", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=3d9268b697572708f62e46ba4831a45572275ae3", "patch": "@@ -3129,9 +3129,11 @@ pa_output_function_prologue (file, size)\n       current_function_number++;\n     }\n \n-  /* If we're using GAS and not using the portable runtime model, then\n-     we don't need to accumulate the total number of code bytes.  */\n-  if (TARGET_GAS && ! TARGET_PORTABLE_RUNTIME)\n+  /* If we're using GAS and SOM, and not using the portable runtime model,\n+     then we don't need to accumulate the total number of code bytes.  */\n+  if ((TARGET_GAS && TARGET_SOM && ! TARGET_PORTABLE_RUNTIME)\n+      /* FIXME: we can't handle long calls for TARGET_64BIT.  */\n+      || TARGET_64BIT)\n     total_code_bytes = 0;\n   else if (INSN_ADDRESSES_SET_P ())\n     {\n@@ -4740,7 +4742,7 @@ output_deferred_plabels (file)\n     {\n       ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (deferred_plabels[i].internal_label));\n       assemble_integer (gen_rtx_SYMBOL_REF (Pmode, deferred_plabels[i].name),\n-\t\t\t4, 32, 1);\n+\t\t\tTARGET_64BIT ? 8 : 4, TARGET_64BIT ? 64 : 32, 1);\n     }\n }\n \n@@ -5458,14 +5460,24 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  xoperands[1] = operands[1];\n \t  xoperands[2] = operands[2];\n \t  xoperands[3] = operands[3];\n-\t  xoperands[4] = gen_label_rtx ();\n-\n-\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\\n\\taddil L'%l0-%l4,%%r1\",\n-\t\t\t   xoperands);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t     CODE_LABEL_NUMBER (xoperands[4]));\n-\t  output_asm_insn (\"ldo R'%l0-%l4(%%r1),%%r1\\n\\tbv %%r0(%%r1)\",\n-\t\t\t   xoperands);\n+\t  if (TARGET_SOM || ! TARGET_GAS)\n+\t    xoperands[4] = gen_label_rtx ();\n+\n+\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t  if (TARGET_SOM || ! TARGET_GAS)\n+\t    {\n+\t      output_asm_insn (\"addil L'%l0-%l4,%%r1\", xoperands);\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[4]));\n+\t      output_asm_insn (\"ldo R'%l0-%l4(%%r1),%%r1\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"addil L'%l0-$PIC_pcrel$0+4,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldo R'%l0-$PIC_pcrel$0+8(%%r1),%%r1\",\n+\t\t\t       xoperands);\n+\t    }\n+\t  output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n \t}\n \n \t/* Now restore the value of %r1 in the delay slot.  We're not\n@@ -6003,6 +6015,8 @@ output_millicode_call (insn, call_dest)\n   rtx insn;\n   rtx call_dest;\n {\n+  int attr_length = get_attr_length (insn);\n+  int seq_length = dbr_sequence_length ();\n   int distance;\n   rtx xoperands[4];\n   rtx seq_insn;\n@@ -6011,25 +6025,28 @@ output_millicode_call (insn, call_dest)\n \n   /* Handle common case -- empty delay slot or no jump in the delay slot,\n      and we're sure that the branch will reach the beginning of the $CODE$\n-     subspace.  */\n-  if ((dbr_sequence_length () == 0\n-       && (get_attr_length (insn) == 8 || get_attr_length (insn) == 28))\n-      || (dbr_sequence_length () != 0\n+     subspace.  The within reach form of the $$sh_func_adrs call has\n+     a length of 28 and attribute type of multi.  This length is the\n+     same as the maximum length of an out of reach PIC call to $$div.  */\n+  if ((seq_length == 0\n+       && (attr_length == 8\n+\t   || (attr_length == 28 && get_attr_type (insn) == TYPE_MULTI)))\n+      || (seq_length != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n-\t  && get_attr_length (insn) == 4))\n+\t  && attr_length == 4))\n     {\n       xoperands[0] = call_dest;\n       output_asm_insn (\"{bl|b,l} %0,%3%#\", xoperands);\n       return \"\";\n     }\n \n   /* This call may not reach the beginning of the $CODE$ subspace.  */\n-  if (get_attr_length (insn) > 4)\n+  if (attr_length > 8)\n     {\n       int delay_insn_deleted = 0;\n \n       /* We need to emit an inline long-call branch.  */\n-      if (dbr_sequence_length () != 0\n+      if (seq_length != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n \t{\n \t  /* A non-jump insn in the delay slot.  By definition we can\n@@ -6047,15 +6064,26 @@ output_millicode_call (insn, call_dest)\n       if (flag_pic)\n \t{\n \t  xoperands[0] = call_dest;\n-\t  xoperands[1] = gen_label_rtx ();\n+\t  if (TARGET_SOM || ! TARGET_GAS)\n+\t    xoperands[1] = gen_label_rtx ();\n+\n \t  /* Get our address + 8 into %r1.  */\n \t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n \n-\t  /* Add %r1 to the offset of our target from the next insn.  */\n-\t  output_asm_insn (\"addil L%%%0-%1,%%r1\", xoperands);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-\t  output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n+\t  if (TARGET_SOM || ! TARGET_GAS)\n+\t    {\n+\t      /* Add %r1 to the offset of our target from the next insn.  */\n+\t      output_asm_insn (\"addil L%%%0-%1,%%r1\", xoperands);\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+\t      output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"addil L%%%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldo R%%%0-$PIC_pcrel$0+8(%%r1),%%r1\",\n+\t\t\t       xoperands);\n+\t    }\n \n \t  /* Get the return address into %r31.  */\n \t  output_asm_insn (\"blr 0,%3\", xoperands);\n@@ -6097,8 +6125,7 @@ output_millicode_call (insn, call_dest)\n \t}\n \n       /* If we had a jump in the call's delay slot, output it now.  */\n-      if (dbr_sequence_length () != 0\n-\t  && !delay_insn_deleted)\n+      if (seq_length != 0 && !delay_insn_deleted)\n \t{\n \t  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n \t  output_asm_insn (\"b,n %0\", xoperands);\n@@ -6160,18 +6187,19 @@ output_call (insn, call_dest, sibcall)\n   rtx call_dest;\n   int sibcall;\n {\n+  int attr_length = get_attr_length (insn);\n+  int seq_length = dbr_sequence_length ();\n   int distance;\n   rtx xoperands[4];\n   rtx seq_insn;\n \n   /* Handle common case -- empty delay slot or no jump in the delay slot,\n      and we're sure that the branch will reach the beginning of the $CODE$\n      subspace.  */\n-  if ((dbr_sequence_length () == 0\n-       && get_attr_length (insn) == 12)\n-      || (dbr_sequence_length () != 0\n+  if ((seq_length == 0 && attr_length == 12)\n+      || (seq_length != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n-\t  && get_attr_length (insn) == 8))\n+\t  && attr_length == 8))\n     {\n       xoperands[0] = call_dest;\n       xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n@@ -6180,7 +6208,7 @@ output_call (insn, call_dest, sibcall)\n     }\n \n   /* This call may not reach the beginning of the $CODE$ subspace.  */\n-  if (get_attr_length (insn) > 12)\n+  if (attr_length > 12)\n     {\n       int delay_insn_deleted = 0;\n       rtx xoperands[2];\n@@ -6193,7 +6221,7 @@ output_call (insn, call_dest, sibcall)\n \t and FP registers.  Also, we need move any delay slot insn\n \t out of the delay slot.  And finally, we can't rely on the linker\n \t being able to fix the call to $$dyncall!  -- Yuk!.  */\n-      if (dbr_sequence_length () != 0\n+      if (seq_length != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n \t{\n \t  /* A non-jump insn in the delay slot.  By definition we can\n@@ -6293,7 +6321,8 @@ output_call (insn, call_dest, sibcall)\n \t  if (flag_pic)\n \t    {\n \t      xoperands[0] = deferred_plabels[i].internal_label;\n-\t      xoperands[1] = gen_label_rtx ();\n+\t      if (TARGET_SOM || ! TARGET_GAS)\n+\t\txoperands[1] = gen_label_rtx ();\n \n \t      output_asm_insn (\"addil LT%%%0,%%r19\", xoperands);\n \t      output_asm_insn (\"ldw RT%%%0(%%r1),%%r22\", xoperands);\n@@ -6302,11 +6331,21 @@ output_call (insn, call_dest, sibcall)\n \t      /* Get our address + 8 into %r1.  */\n \t      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n \n-\t      /* Add %r1 to the offset of dyncall from the next insn.  */\n-\t      output_asm_insn (\"addil L%%$$dyncall-%1,%%r1\", xoperands);\n-\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n-\t      output_asm_insn (\"ldo R%%$$dyncall-%1(%%r1),%%r1\", xoperands);\n+\t      if (TARGET_SOM || ! TARGET_GAS)\n+\t\t{\n+\t\t  /* Add %r1 to the offset of dyncall from the next insn.  */\n+\t\t  output_asm_insn (\"addil L%%$$dyncall-%1,%%r1\", xoperands);\n+\t\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t\t  output_asm_insn (\"ldo R%%$$dyncall-%1(%%r1),%%r1\", xoperands);\n+\t        }\n+\t      else\n+\t\t{\n+\t\t  output_asm_insn (\"addil L%%$$dyncall-$PIC_pcrel$0+4,%%r1\",\n+\t\t\t\t   xoperands);\n+\t\t  output_asm_insn (\"ldo R%%$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\",\n+\t\t\t\t   xoperands);\n+\t\t}\n \n \t      /* Get the return address into %r31.  */\n \t      output_asm_insn (\"blr %%r0,%%r31\", xoperands);\n@@ -6355,8 +6394,7 @@ output_call (insn, call_dest, sibcall)\n \t}\n \n       /* If we had a jump in the call's delay slot, output it now.  */\n-      if (dbr_sequence_length () != 0\n-\t  && !delay_insn_deleted)\n+      if (seq_length != 0 && !delay_insn_deleted)\n \t{\n \t  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n \t  output_asm_insn (\"b,n %0\", xoperands);"}, {"sha": "6977752c083ea6f1aa37b021ead02526a854fd03", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3d9268b697572708f62e46ba4831a45572275ae3", "patch": "@@ -159,6 +159,11 @@ extern int target_flags;\n #define TARGET_ELF32 0\n #endif\n \n+/* Generate code for SOM 32bit ABI.  */\n+#ifndef TARGET_SOM\n+#define TARGET_SOM 0\n+#endif\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }"}, {"sha": "c80edcc2e2b6eccdb81642abbc3ad23c60d7f09e", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=3d9268b697572708f62e46ba4831a45572275ae3", "patch": "@@ -2281,17 +2281,19 @@\n   \"\"\n   \"*\n {\n-  rtx label_rtx = gen_label_rtx ();\n   rtx xoperands[3];\n   extern FILE *asm_out_file;\n \n   xoperands[0] = operands[0];\n   xoperands[1] = operands[1];\n-  xoperands[2] = label_rtx;\n+  if (TARGET_SOM || ! TARGET_GAS)\n+    xoperands[2] = gen_label_rtx ();\n+\n   output_asm_insn (\\\"{bl|b,l} .+8,%0\\\", xoperands);\n   output_asm_insn (\\\"{depi|depwi} 0,31,2,%0\\\", xoperands);\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n-\t\t\t     CODE_LABEL_NUMBER (label_rtx));\n+  if (TARGET_SOM || ! TARGET_GAS)\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t       CODE_LABEL_NUMBER (xoperands[2]));\n \n   /* If we're trying to load the address of a label that happens to be\n      close, then we can use a shorter sequence.  */\n@@ -2302,12 +2304,24 @@\n     {\n       /* Prefixing with R% here is wrong, it extracts just 11 bits and is\n \t always non-negative.  */\n-      output_asm_insn (\\\"ldo %1-%2(%0),%0\\\", xoperands);\n+      if (TARGET_SOM || ! TARGET_GAS)\n+\toutput_asm_insn (\\\"ldo %1-%2(%0),%0\\\", xoperands);\n+      else\n+\toutput_asm_insn (\\\"ldo %1-$PIC_pcrel$0+8(%0),%0\\\", xoperands);\n     }\n   else\n     {\n-      output_asm_insn (\\\"addil L%%%1-%2,%0\\\", xoperands);\n-      output_asm_insn (\\\"ldo R%%%1-%2(%0),%0\\\", xoperands);\n+      if (TARGET_SOM || ! TARGET_GAS)\n+\t{\n+\t  output_asm_insn (\\\"addil L%%%1-%2,%0\\\", xoperands);\n+\t  output_asm_insn (\\\"ldo R%%%1-%2(%0),%0\\\", xoperands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\\\"addil L%%%1-$PIC_pcrel$0+8,%0\\\", xoperands);\n+\t  output_asm_insn (\\\"ldo R%%%1-$PIC_pcrel$0+12(%0),%0\\\",\n+\t  \t\t   xoperands);\n+\t}\n     }\n   return \\\"\\\";\n }\"\n@@ -5711,14 +5725,23 @@\n     {\n       rtx xoperands[2];\n       xoperands[0] = operands[0];\n-      xoperands[1] = gen_label_rtx ();\n+      if (TARGET_SOM || ! TARGET_GAS)\n+\t{\n+\t  xoperands[1] = gen_label_rtx ();\n \n-      output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\\n\\\\taddil L'%l0-%l1,%%r1\\\",\n-\t\t       xoperands);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n-                                 CODE_LABEL_NUMBER (xoperands[1]));\n-      output_asm_insn (\\\"ldo R'%l0-%l1(%%r1),%%r1\\\\n\\\\tbv %%r0(%%r1)\\\",\n-\t\t       xoperands);\n+\t  output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\\n\\\\taddil L'%l0-%l1,%%r1\\\",\n+\t\t\t   xoperands);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t  output_asm_insn (\\\"ldo R'%l0-%l1(%%r1),%%r1\\\", xoperands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\", xoperands);\n+\t  output_asm_insn (\\\"addil L'%l0-$PIC_pcrel$0+4,%%r1\\\", xoperands);\n+\t  output_asm_insn (\\\"ldo R'%l0-$PIC_pcrel$0+8(%%r1),%%r1\\\", xoperands);\n+\t}\n+      output_asm_insn (\\\"bv %%r0(%%r1)\\\", xoperands);\n     }\n   else\n     output_asm_insn (\\\"ldil L'%l0,%%r1\\\\n\\\\tbe R'%l0(%%sr4,%%r1)\\\", operands);;\n@@ -5942,12 +5965,22 @@\n \n   /* If we're generating PIC code.  */\n   xoperands[0] = operands[0];\n-  xoperands[1] = gen_label_rtx ();\n+  if (TARGET_SOM || ! TARGET_GAS)\n+    xoperands[1] = gen_label_rtx ();\n   output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\", xoperands);\n-  output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n-\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-  output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n+  if (TARGET_SOM || ! TARGET_GAS)\n+    {\n+      output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+      output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"addil L%%$$dyncall-$PIC_pcrel$0+4,%%r1\\\", xoperands);\n+      output_asm_insn (\\\"ldo R%%$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\\\",\n+      \t\t       xoperands);\n+    }\n   output_asm_insn (\\\"blr %%r0,%%r2\\\", xoperands);\n   output_asm_insn (\\\"bv,n %%r0(%%r1)\\\\n\\\\tnop\\\", xoperands);\n   return \\\"\\\";\n@@ -6118,12 +6151,22 @@\n \n   /* If we're generating PIC code.  */\n   xoperands[0] = operands[1];\n-  xoperands[1] = gen_label_rtx ();\n+  if (TARGET_SOM || ! TARGET_GAS)\n+    xoperands[1] = gen_label_rtx ();\n   output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\", xoperands);\n-  output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n-\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-  output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n+  if (TARGET_SOM || ! TARGET_GAS)\n+    {\n+      output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+      output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"addil L%%$$dyncall-$PIC_pcrel$0+4,%%r1\\\", xoperands);\n+      output_asm_insn (\\\"ldo R%%$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\\\",\n+      \t\t       xoperands);\n+    }\n   output_asm_insn (\\\"blr %%r0,%%r2\\\", xoperands);\n   output_asm_insn (\\\"bv,n %%r0(%%r1)\\\\n\\\\tnop\\\", xoperands);\n   return \\\"\\\";"}, {"sha": "f20a5a8d04e75b890f5bb5f3b8360e1ab4623a41", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9268b697572708f62e46ba4831a45572275ae3/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=3d9268b697572708f62e46ba4831a45572275ae3", "patch": "@@ -19,7 +19,8 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* So we can conditionalize small amounts of code in pa.c or pa.md.  */\n-#define OBJ_SOM\n+#undef TARGET_SOM\n+#define TARGET_SOM 1\n \n /* We do not use BINCL stabs in SOM.\n    ??? If it does not hurt, we probably should to avoid useless divergence"}]}