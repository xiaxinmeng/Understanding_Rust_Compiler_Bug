{"sha": "1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmOWVkNmZiMjgyYWI4YTZmMWIyYWExNjU1YjU3N2NkYzJmMGU0MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2015-11-25T23:05:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-25T23:05:07Z"}, "message": "re PR lto/67548 (LTO drops weak binding with \"ld -r\")\n\n\n\tPR lto/67548\n\t* lto-plugin.c (linker_output, linker_output_set): New statics.\n\t(all_symbols_read_handler): Add -flinker-output option.\n\t(onload): Record linker_output info.\n\n\t* ipa-visibility.c (cgraph_externally_visible_p,\n\tvarpool_node::externally_visible_p): When doing incremental linking,\n\thidden symbols may be still used later.\n\t(update_visibility_by_resolution_info): Do not drop weak during\n\tincremental link.\n\t(function_and_variable_visibility): Fix formating.\n\t* flag-types.h (lto_linker_output): Declare.\n\t* common.opt 9flag_incremental_link): New flag.\n\n\t* lto-lang.c (lto_post_options): Process flag_lto_linker_output.\n\t* lang.opt (lto_linker_output): New enum.\n\t(flinker_output): New flag.\n\nFrom-SVN: r230915", "tree": {"sha": "695e737710e979a37c3a6c8eac41f4786c766cad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/695e737710e979a37c3a6c8eac41f4786c766cad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/comments", "author": null, "committer": null, "parents": [{"sha": "c9d82fb023ac0bfb69a3835491ddb47268bef09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d82fb023ac0bfb69a3835491ddb47268bef09b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9d82fb023ac0bfb69a3835491ddb47268bef09b"}], "stats": {"total": 165, "additions": 151, "deletions": 14}, "files": [{"sha": "eae18834bd06cfb240a9061005db7454e6ac1216", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -1,3 +1,14 @@\n+2015-11-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-visibility.c (cgraph_externally_visible_p,\n+\tvarpool_node::externally_visible_p): When doing incremental linking,\n+\thidden symbols may be still used later.\n+\t(update_visibility_by_resolution_info): Do not drop weak during\n+\tincremental link.\n+\t(function_and_variable_visibility): Fix formating.\n+\t* flag-types.h (lto_linker_output): Declare.\n+\t* common.opt 9flag_incremental_link): New flag.\n+\n 2015-11-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/constraints.md (wb constraint): New constraint for"}, {"sha": "e1617c41bd819451e41819030d2369e53796b2d3", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -46,6 +46,12 @@ int optimize_fast\n Variable\n bool in_lto_p = false\n \n+; This variable is set to non-0 only by LTO front-end.  1 indicates that\n+; the output produced will be used for incrmeental linking (thus weak symbols\n+; can still be bound).\n+Variable\n+int flag_incremental_link = 0\n+\n ; 0 means straightforward implementation of complex divide acceptable.\n ; 1 means wide ranges of inputs must work for complex divide.\n ; 2 means C99-like requirements for complex multiply and divide."}, {"sha": "b130fc5806a53251bc31dad9b1152fd995a5c543", "filename": "gcc/flag-types.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -265,6 +265,14 @@ enum lto_partition_model {\n   LTO_PARTITION_MAX = 4\n };\n \n+/* flag_lto_linker_output initialization values.  */\n+enum lto_linker_output {\n+  LTO_LINKER_OUTPUT_UNKNOWN,\n+  LTO_LINKER_OUTPUT_REL,\n+  LTO_LINKER_OUTPUT_DYN,\n+  LTO_LINKER_OUTPUT_PIE,\n+  LTO_LINKER_OUTPUT_EXEC\n+};\n \n /* gfortran -finit-real= values.  */\n "}, {"sha": "41ed4db67459d4fcc0ededa4b8ed3ab3929d7719", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -217,13 +217,13 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n      This improves code quality and we know we will duplicate them at most twice\n      (in the case that we are not using plugin and link with object file\n       implementing same COMDAT)  */\n-  if ((in_lto_p || whole_program)\n+  if (((in_lto_p || whole_program) && !flag_incremental_link)\n       && DECL_COMDAT (node->decl)\n       && comdat_can_be_unshared_p (node))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n-  if (in_lto_p\n+  if ((in_lto_p && !flag_incremental_link)\n       && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n \t  || DECL_VISIBILITY (node->decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n@@ -293,13 +293,13 @@ varpool_node::externally_visible_p (void)\n      so this does not enable more optimization, but referring static var\n      is faster for dynamic linking.  Also this match logic hidding vtables\n      from LTO symbol tables.  */\n-  if ((in_lto_p || flag_whole_program)\n+  if (((in_lto_p || flag_whole_program) && !flag_incremental_link)\n       && DECL_COMDAT (decl)\n       && comdat_can_be_unshared_p (this))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n-  if (in_lto_p\n+  if (in_lto_p && !flag_incremental_link\n       && (DECL_VISIBILITY (decl) == VISIBILITY_HIDDEN\n \t  || DECL_VISIBILITY (decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n@@ -405,17 +405,36 @@ update_visibility_by_resolution_info (symtab_node * node)\n     for (symtab_node *next = node->same_comdat_group;\n \t next != node; next = next->same_comdat_group)\n       {\n-\tnext->set_comdat_group (NULL);\n-\tDECL_WEAK (next->decl) = false;\n+\t/* During incremental linking we need to keep symbol weak for future\n+\t   linking.  We can still drop definition if we know non-LTO world\n+\t   prevails.  */\n+\tif (!flag_incremental_link)\n+\t  {\n+\t    DECL_WEAK (next->decl) = false;\n+\t    next->set_comdat_group (NULL);\n+\t  }\n \tif (next->externally_visible\n \t    && !define)\n-\t  DECL_EXTERNAL (next->decl) = true;\n+\t  {\n+\t    DECL_EXTERNAL (next->decl) = true;\n+\t    next->set_comdat_group (NULL);\n+\t  }\n       }\n-  node->set_comdat_group (NULL);\n-  DECL_WEAK (node->decl) = false;\n+\n+  /* During incremental linking we need to keep symbol weak for future\n+     linking.  We can still drop definition if we know non-LTO world prevails.  */\n+  if (!flag_incremental_link)\n+    {\n+      DECL_WEAK (node->decl) = false;\n+      node->set_comdat_group (NULL);\n+      node->dissolve_same_comdat_group_list ();\n+    }\n   if (!define)\n-    DECL_EXTERNAL (node->decl) = true;\n-  node->dissolve_same_comdat_group_list ();\n+    {\n+      DECL_EXTERNAL (node->decl) = true;\n+      node->set_comdat_group (NULL);\n+      node->dissolve_same_comdat_group_list ();\n+    }\n }\n \n /* Decide on visibility of all symbols.  */\n@@ -639,8 +658,9 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n \t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t       || vnode->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (vnode->decl));\n+\t\t\t         || vnode->resolution\n+\t\t\t\t      == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t        && TREE_PUBLIC (vnode->decl));\n \t  if (vnode->same_comdat_group && TREE_PUBLIC (vnode->decl))\n \t    {\n \t      symtab_node *next = vnode;"}, {"sha": "1ddacfa158f802126512d13590a2bfa63bdc1a46", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -1,3 +1,9 @@\n+2015-11-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-lang.c (lto_post_options): Process flag_lto_linker_output.\n+\t* lang.opt (lto_linker_output): New enum.\n+\t(flinker_output): New flag.\n+\n 2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c: Include alias.h"}, {"sha": "c4216b350d0a24b29936fbf12b33bfd884d8fb35", "filename": "gcc/lto/lang.opt", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Flto%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Flto%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flang.opt?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -24,6 +24,29 @@\n Language\n LTO\n \n+Enum\n+Name(lto_linker_output) Type(enum lto_linker_output) UnknownError(unknown linker output %qs)\n+\n+EnumValue\n+Enum(lto_linker_output) String(unknown) Value(LTO_LINKER_OUTPUT_UNKNOWN)\n+\n+EnumValue\n+Enum(lto_linker_output) String(rel) Value(LTO_LINKER_OUTPUT_REL)\n+\n+EnumValue\n+Enum(lto_linker_output) String(dyn) Value(LTO_LINKER_OUTPUT_DYN)\n+\n+EnumValue\n+Enum(lto_linker_output) String(pie) Value(LTO_LINKER_OUTPUT_PIE)\n+\n+EnumValue\n+Enum(lto_linker_output) String(exec) Value(LTO_LINKER_OUTPUT_EXEC)\n+\n+flinker-output=\n+LTO Report Driver Joined RejectNegative Enum(lto_linker_output) Var(flag_lto_linker_output) Init(LTO_LINKER_OUTPUT_UNKNOWN)\n+Set linker output type (used internally during LTO optimization)\n+\n+\n fltrans\n LTO Report Var(flag_ltrans)\n Run the link-time optimizer in local transformation (LTRANS) mode."}, {"sha": "90bacde7eb5b4961e69064fe190c1df4a54c3f1f", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -819,6 +819,35 @@ lto_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n   if (flag_wpa)\n     flag_generate_lto = 1;\n \n+  /* Initialize the codegen flags according to the output type.  */\n+  switch (flag_lto_linker_output)\n+    {\n+    case LTO_LINKER_OUTPUT_REL: /* .o: incremental link producing LTO IL  */\n+      flag_whole_program = 0;\n+      flag_incremental_link = 1;\n+      break;\n+\n+    case LTO_LINKER_OUTPUT_DYN: /* .so: PID library */\n+      /* On some targets, like i386 it makes sense to build PIC library wihout\n+\t -fpic for performance reasons.  So no need to adjust flags.  */\n+      break;\n+\n+    case LTO_LINKER_OUTPUT_PIE: /* PIE binary */\n+      /* If -fPIC or -fPIE was used at compile time, be sure that\n+         flag_pie is 2.  */\n+      flag_pie = MAX (flag_pie, flag_pic);\n+      flag_pic = 0;\n+      break;\n+\n+    case LTO_LINKER_OUTPUT_EXEC: /* Normal executable */\n+      flag_pic = 0;\n+      flag_pie = 0;\n+      break;\n+\n+    case LTO_LINKER_OUTPUT_UNKNOWN:\n+      break;\n+    }\n+\n   /* Excess precision other than \"fast\" requires front-end\n      support.  */\n   flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;"}, {"sha": "59f21f52c9447ec11582d184b8452591f6b5c84f", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -1,3 +1,10 @@\n+2015-11-25  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/67548\n+\t* lto-plugin.c (linker_output, linker_output_set): New statics.\n+\t(all_symbols_read_handler): Add -flinker-output option.\n+\t(onload): Record linker_output info.\n+\n 2015-07-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* configure.ac: Add AC_USE_SYSTEM_EXTENSIONS."}, {"sha": "0a6a767c08deb67a0bbd099cab15d3332757d7b3", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=1ff9ed6fb282ab8a6f1b2aa1655b577cdc2f0e41", "patch": "@@ -167,6 +167,8 @@ static unsigned int num_pass_through_items;\n static char debug;\n static char nop;\n static char *resolution_file = NULL;\n+static enum ld_plugin_output_file_type linker_output;\n+static int linker_output_set;\n \n /* The version of gold being used, or -1 if not gold.  The number is\n    MAJOR * 100 + MINOR.  */\n@@ -624,8 +626,9 @@ all_symbols_read_handler (void)\n {\n   unsigned i;\n   unsigned num_lto_args\n-    = num_claimed_files + num_offload_files + lto_wrapper_num_args + 1;\n+    = num_claimed_files + num_offload_files + lto_wrapper_num_args + 2;\n   char **lto_argv;\n+  const char *linker_output_str;\n   const char **lto_arg_ptr;\n   if (num_claimed_files + num_offload_files == 0)\n     return LDPS_OK;\n@@ -648,6 +651,26 @@ all_symbols_read_handler (void)\n   for (i = 0; i < lto_wrapper_num_args; i++)\n     *lto_arg_ptr++ = lto_wrapper_argv[i];\n \n+  assert (linker_output_set);\n+  switch (linker_output)\n+    {\n+    case LDPO_REL:\n+      linker_output_str = \"-flinker-output=rel\";\n+      break;\n+    case LDPO_DYN:\n+      linker_output_str = \"-flinker-output=dyn\";\n+      break;\n+    case LDPO_PIE:\n+      linker_output_str = \"-flinker-output=pie\";\n+      break;\n+    case LDPO_EXEC:\n+      linker_output_str = \"-flinker-output=exec\";\n+      break;\n+    default:\n+      message (LDPL_FATAL, \"unsupported linker output %i\", linker_output);\n+      break;\n+    }\n+  *lto_arg_ptr++ = xstrdup (linker_output_str);\n   for (i = 0; i < num_claimed_files; i++)\n     {\n       struct plugin_file_info *info = &claimed_files[i];\n@@ -1100,6 +1123,10 @@ onload (struct ld_plugin_tv *tv)\n \tcase LDPT_GOLD_VERSION:\n \t  gold_version = p->tv_u.tv_val;\n \t  break;\n+\tcase LDPT_LINKER_OUTPUT:\n+\t  linker_output = (enum ld_plugin_output_file_type) p->tv_u.tv_val;\n+\t  linker_output_set = 1;\n+\t  break;\n \tdefault:\n \t  break;\n \t}"}]}