{"sha": "b357f682db35f4431e3011e7486a0ac865686e3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1N2Y2ODJkYjM1ZjQ0MzFlMzAxMWU3NDg2YTBhYzg2NTY4NmUzZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-06-27T19:42:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-06-27T19:42:32Z"}, "message": "re PR debug/36617 (Debug info for OpenMP code is almost non-existent)\n\n\tPR debug/36617\n\t* tree-cfg.c (struct move_stmt_d): Replace block field with\n\torig_block and new_block fields.\n\t(move_stmt_r): Only set TREE_BLOCK to p->new_block if\n\tif it used to be NULL, p->orig_block or if p->orig_block is NULL.\n\t(move_block_to_fn): Replace vars_map and new_label_map arguments\n\twith struct move_stmt_d pointer.\n\t(replace_block_vars_by_duplicates): New function.\n\t(move_sese_region_to_fn): Add ORIG_BLOCK argument.  Adjust\n\tmove_block_to_fn caller.  If ORIG_BLOCK is non-NULL, move over\n\tall subblocks of ORIG_BLOCK to the new function.  Call\n\treplace_block_vars_by_duplicates.\n\t* tree-flow.h (move_sese_region_to_fn): Adjust prototype.\n\t* omp-low.c (expand_omp_taskreg): Set TREE_USED on DECL_INITIAL\n\tBLOCK of the new function.  Adjust move_sese_region_to_fn caller.\n\tPrune vars with original DECL_CONTEXT from child_cfun->local_decls.\n\t(expand_omp): Temporarily set input_location to the location of\n\tregion's controlling stmt.\n\t(lower_omp_sections, lower_omp_for): Add a BLOCK into outermost\n\tBIND_EXPR, push ctx->block_vars and gimplification vars into\n\tthe BIND_EXPR and its block's BLOCK_VARS instead of directly\n\tinto dest function.\n\t(lower_omp_single): Set TREE_USED on the BIND_EXPR's BLOCK if\n\tthere are any BLOCK_VARS.\n\t(lower_omp_taskreg): Set BLOCK on a BIND_EXPR containing the\n\tOMP_PARALLEL or OMP_TASK stmt.\n\t(lower_omp): Save and restore input_location around the lower_omp_1\n\tcall.\n\n\t* testsuite/libgomp.c/debug-1.c: New test.\n\nFrom-SVN: r137198", "tree": {"sha": "a8494079b03846dcc069ae2703770a7aed24d215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8494079b03846dcc069ae2703770a7aed24d215"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b357f682db35f4431e3011e7486a0ac865686e3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b357f682db35f4431e3011e7486a0ac865686e3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b357f682db35f4431e3011e7486a0ac865686e3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b357f682db35f4431e3011e7486a0ac865686e3e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7091901cd984928b3599dc62507045dee1754d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7091901cd984928b3599dc62507045dee1754d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7091901cd984928b3599dc62507045dee1754d6"}], "stats": {"total": 396, "additions": 349, "deletions": 47}, "files": [{"sha": "38ce1cff59452b3265e2c271ab3d96503528f334", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b357f682db35f4431e3011e7486a0ac865686e3e", "patch": "@@ -1,3 +1,34 @@\n+2008-06-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/36617\n+\t* tree-cfg.c (struct move_stmt_d): Replace block field with\n+\torig_block and new_block fields.\n+\t(move_stmt_r): Only set TREE_BLOCK to p->new_block if\n+\tif it used to be NULL, p->orig_block or if p->orig_block is NULL.\n+\t(move_block_to_fn): Replace vars_map and new_label_map arguments\n+\twith struct move_stmt_d pointer.\n+\t(replace_block_vars_by_duplicates): New function.\n+\t(move_sese_region_to_fn): Add ORIG_BLOCK argument.  Adjust\n+\tmove_block_to_fn caller.  If ORIG_BLOCK is non-NULL, move over\n+\tall subblocks of ORIG_BLOCK to the new function.  Call\n+\treplace_block_vars_by_duplicates.\n+\t* tree-flow.h (move_sese_region_to_fn): Adjust prototype.\n+\t* omp-low.c (expand_omp_taskreg): Set TREE_USED on DECL_INITIAL\n+\tBLOCK of the new function.  Adjust move_sese_region_to_fn caller.\n+\tPrune vars with original DECL_CONTEXT from child_cfun->local_decls.\n+\t(expand_omp): Temporarily set input_location to the location of\n+\tregion's controlling stmt.\n+\t(lower_omp_sections, lower_omp_for): Add a BLOCK into outermost\n+\tBIND_EXPR, push ctx->block_vars and gimplification vars into\n+\tthe BIND_EXPR and its block's BLOCK_VARS instead of directly\n+\tinto dest function.\n+\t(lower_omp_single): Set TREE_USED on the BIND_EXPR's BLOCK if\n+\tthere are any BLOCK_VARS.\n+\t(lower_omp_taskreg): Set BLOCK on a BIND_EXPR containing the\n+\tOMP_PARALLEL or OMP_TASK stmt.\n+\t(lower_omp): Save and restore input_location around the lower_omp_1\n+\tcall.\n+\n 2008-06-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36400"}, {"sha": "e5680077bd0a4c9dda6acdba6f048c2f3908832f", "filename": "gcc/omp-low.c", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b357f682db35f4431e3011e7486a0ac865686e3e", "patch": "@@ -3140,7 +3140,7 @@ expand_omp_taskreg (struct omp_region *region)\n {\n   basic_block entry_bb, exit_bb, new_bb;\n   struct function *child_cfun;\n-  tree child_fn, block, t, ws_args;\n+  tree child_fn, block, t, ws_args, *tp;\n   block_stmt_iterator si;\n   tree entry_stmt;\n   edge e;\n@@ -3251,6 +3251,7 @@ expand_omp_taskreg (struct omp_region *region)\n       block = DECL_INITIAL (child_fn);\n       BLOCK_VARS (block) = list2chain (child_cfun->local_decls);\n       DECL_SAVED_TREE (child_fn) = bb_stmt_list (single_succ (entry_bb));\n+      TREE_USED (block) = 1;\n \n       /* Reset DECL_CONTEXT on function arguments.  */\n       for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))\n@@ -3287,11 +3288,22 @@ expand_omp_taskreg (struct omp_region *region)\n \t  init_ssa_operands ();\n \t  cfun->gimple_df->in_ssa_p = true;\n \t  pop_cfun ();\n+\t  block = NULL_TREE;\n \t}\n-      new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb);\n+      else\n+\tblock = TREE_BLOCK (entry_stmt);\n+\n+      new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb, block);\n       if (exit_bb)\n \tsingle_succ_edge (new_bb)->flags = EDGE_FALLTHRU;\n \n+      /* Remove non-local VAR_DECLs from child_cfun->local_decls list.  */\n+      for (tp = &child_cfun->local_decls; *tp; )\n+\tif (DECL_CONTEXT (TREE_VALUE (*tp)) != cfun->decl)\n+\t  tp = &TREE_CHAIN (*tp);\n+\telse\n+\t  *tp = TREE_CHAIN (*tp);\n+\n       /* Inform the callgraph about the new function.  */\n       DECL_STRUCT_FUNCTION (child_fn)->curr_properties\n \t= cfun->curr_properties;\n@@ -5030,6 +5042,8 @@ expand_omp (struct omp_region *region)\n {\n   while (region)\n     {\n+      location_t saved_location;\n+\n       /* First, determine whether this is a combined parallel+workshare\n        \t region.  */\n       if (region->type == OMP_PARALLEL)\n@@ -5038,6 +5052,10 @@ expand_omp (struct omp_region *region)\n       if (region->inner)\n \texpand_omp (region->inner);\n \n+      saved_location = input_location;\n+      if (EXPR_HAS_LOCATION (last_stmt (region->entry)))\n+\tinput_location = EXPR_LOCATION (last_stmt (region->entry));\n+\n       switch (region->type)\n \t{\n \tcase OMP_PARALLEL:\n@@ -5075,11 +5093,11 @@ expand_omp (struct omp_region *region)\n \t  expand_omp_atomic (region);\n \t  break;\n \n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n+      input_location = saved_location;\n       region = region->next;\n     }\n }\n@@ -5312,12 +5330,18 @@ lower_omp_sections (tree *stmt_p, omp_context *ctx)\n   olist = NULL_TREE;\n   lower_reduction_clauses (OMP_SECTIONS_CLAUSES (stmt), &olist, ctx);\n \n-  pop_gimplify_context (NULL_TREE);\n-  record_vars_into (ctx->block_vars, ctx->cb.dst_fn);\n-\n-  new_stmt = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+  block = make_node (BLOCK);\n+  new_stmt = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n   TREE_SIDE_EFFECTS (new_stmt) = 1;\n \n+  pop_gimplify_context (new_stmt);\n+\n+  BIND_EXPR_VARS (new_stmt)\n+    = chainon (BIND_EXPR_VARS (new_stmt), ctx->block_vars);\n+  BLOCK_VARS (block) = BIND_EXPR_VARS (new_stmt);\n+  if (BLOCK_VARS (block))\n+    TREE_USED (block) = 1;\n+\n   new_body = alloc_stmt_list ();\n   append_to_statement_list (ilist, &new_body);\n   append_to_statement_list (stmt, &new_body);\n@@ -5491,6 +5515,8 @@ lower_omp_single (tree *stmt_p, omp_context *ctx)\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n   BLOCK_VARS (block) = BIND_EXPR_VARS (bind);\n+  if (BLOCK_VARS (block))\n+    TREE_USED (block) = 1;\n }\n \n \n@@ -5714,7 +5740,7 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, tree *body_p,\n static void\n lower_omp_for (tree *stmt_p, omp_context *ctx)\n {\n-  tree t, stmt, ilist, dlist, new_stmt, *body_p, *rhs_p;\n+  tree t, stmt, ilist, dlist, new_stmt, block, *body_p, *rhs_p;\n   struct omp_for_data fd;\n   int i;\n \n@@ -5725,14 +5751,17 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n   lower_omp (&OMP_FOR_PRE_BODY (stmt), ctx);\n   lower_omp (&OMP_FOR_BODY (stmt), ctx);\n \n+  block = make_node (BLOCK);\n+  new_stmt = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n+  TREE_SIDE_EFFECTS (new_stmt) = 1;\n+  body_p = &BIND_EXPR_BODY (new_stmt);\n+\n   /* Move declaration of temporaries in the loop body before we make\n      it go away.  */\n   if (TREE_CODE (OMP_FOR_BODY (stmt)) == BIND_EXPR)\n-    record_vars_into (BIND_EXPR_VARS (OMP_FOR_BODY (stmt)), ctx->cb.dst_fn);\n-\n-  new_stmt = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-  TREE_SIDE_EFFECTS (new_stmt) = 1;\n-  body_p = &BIND_EXPR_BODY (new_stmt);\n+    BIND_EXPR_VARS (new_stmt)\n+      = chainon (BIND_EXPR_VARS (new_stmt),\n+\t\t BIND_EXPR_VARS (OMP_FOR_BODY (stmt)));\n \n   /* The pre-body and input clauses go before the lowered OMP_FOR.  */\n   ilist = NULL;\n@@ -5786,8 +5815,12 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n   OMP_RETURN_NOWAIT (t) = fd.have_nowait;\n   append_to_statement_list (t, body_p);\n \n-  pop_gimplify_context (NULL_TREE);\n-  record_vars_into (ctx->block_vars, ctx->cb.dst_fn);\n+  pop_gimplify_context (new_stmt);\n+  BIND_EXPR_VARS (new_stmt)\n+    = chainon (BIND_EXPR_VARS (new_stmt), ctx->block_vars);\n+  BLOCK_VARS (block) = BIND_EXPR_VARS (new_stmt);\n+  if (BLOCK_VARS (block))\n+    TREE_USED (block) = 1;\n \n   OMP_FOR_BODY (stmt) = NULL_TREE;\n   OMP_FOR_PRE_BODY (stmt) = NULL_TREE;\n@@ -6157,8 +6190,9 @@ lower_omp_taskreg (tree *stmt_p, omp_context *ctx)\n \n   /* Once all the expansions are done, sequence all the different\n      fragments inside OMP_TASKREG_BODY.  */\n-  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-  append_to_statement_list (ilist, &BIND_EXPR_BODY (bind));\n+  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL,\n+\t\t BIND_EXPR_BLOCK (par_bind));\n+  TREE_SIDE_EFFECTS (bind) = 1;\n \n   new_body = alloc_stmt_list ();\n \n@@ -6180,7 +6214,14 @@ lower_omp_taskreg (tree *stmt_p, omp_context *ctx)\n   OMP_TASKREG_BODY (stmt) = new_body;\n \n   append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));\n-  append_to_statement_list (olist, &BIND_EXPR_BODY (bind));\n+  if (ilist || olist)\n+    {\n+      append_to_statement_list (bind, &ilist);\n+      append_to_statement_list (olist, &ilist);\n+      bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+      TREE_SIDE_EFFECTS (bind) = 1;\n+      append_to_statement_list (ilist, &BIND_EXPR_BODY (bind));\n+    }\n \n   *stmt_p = bind;\n \n@@ -6363,7 +6404,9 @@ lower_omp_1 (tree *tp, omp_context *ctx, tree_stmt_iterator *tsi)\n static void\n lower_omp (tree *stmt_p, omp_context *ctx)\n {\n+  location_t saved_location = input_location;\n   lower_omp_1 (stmt_p, ctx, NULL);\n+  input_location = saved_location;\n }\n \f\n /* Main entry point.  */"}, {"sha": "341a1de749d91ff23afd41e2adf8fc28c149506a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 88, "deletions": 27, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b357f682db35f4431e3011e7486a0ac865686e3e", "patch": "@@ -5665,7 +5665,8 @@ replace_ssa_name (tree name, struct pointer_map_t *vars_map,\n \n struct move_stmt_d\n {\n-  tree block;\n+  tree orig_block;\n+  tree new_block;\n   tree from_context;\n   tree to_context;\n   struct pointer_map_t *vars_map;\n@@ -5674,18 +5675,31 @@ struct move_stmt_d\n };\n \n /* Helper for move_block_to_fn.  Set TREE_BLOCK in every expression\n-   contained in *TP and change the DECL_CONTEXT of every local\n-   variable referenced in *TP.  */\n+   contained in *TP if it has been ORIG_BLOCK previously and change the\n+   DECL_CONTEXT of every local variable referenced in *TP.  */\n \n static tree\n move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n {\n   struct move_stmt_d *p = (struct move_stmt_d *) data;\n   tree t = *tp;\n \n-  if (p->block\n-      && (EXPR_P (t) || GIMPLE_STMT_P (t)))\n-    TREE_BLOCK (t) = p->block;\n+  if (EXPR_P (t) || GIMPLE_STMT_P (t))\n+    {\n+      tree block = TREE_BLOCK (t);\n+      if (p->orig_block == NULL_TREE\n+\t  || block == p->orig_block\n+\t  || block == NULL_TREE)\n+\tTREE_BLOCK (t) = p->new_block;\n+#ifdef ENABLE_CHECKING\n+      else if (block != p->new_block)\n+\t{\n+\t  while (block && block != p->orig_block)\n+\t    block = BLOCK_SUPERCONTEXT (block);\n+\t  gcc_assert (block);\n+\t}\n+#endif\n+    }\n \n   if (OMP_DIRECTIVE_P (t)\n       && TREE_CODE (t) != OMP_RETURN\n@@ -5792,14 +5806,12 @@ mark_virtual_ops_in_region (VEC (basic_block,heap) *bbs)\n static void\n move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t\t  basic_block after, bool update_edge_count_p,\n-\t\t  struct pointer_map_t *vars_map, htab_t new_label_map,\n-\t\t  int eh_offset)\n+\t\t  struct move_stmt_d *d, int eh_offset)\n {\n   struct control_flow_graph *cfg;\n   edge_iterator ei;\n   edge e;\n   block_stmt_iterator si;\n-  struct move_stmt_d d;\n   unsigned old_len, new_len;\n   tree phi, next_phi;\n \n@@ -5856,33 +5868,22 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t  continue;\n \t}\n \n-      SET_PHI_RESULT (phi, replace_ssa_name (op, vars_map, dest_cfun->decl));\n+      SET_PHI_RESULT (phi,\n+\t\t      replace_ssa_name (op, d->vars_map, dest_cfun->decl));\n       FOR_EACH_PHI_ARG (use, phi, oi, SSA_OP_USE)\n \t{\n \t  op = USE_FROM_PTR (use);\n \t  if (TREE_CODE (op) == SSA_NAME)\n-\t    SET_USE (use, replace_ssa_name (op, vars_map, dest_cfun->decl));\n+\t    SET_USE (use, replace_ssa_name (op, d->vars_map, dest_cfun->decl));\n \t}\n     }\n \n-  /* The statements in BB need to be associated with a new TREE_BLOCK.\n-     Labels need to be associated with a new label-to-block map.  */\n-  memset (&d, 0, sizeof (d));\n-  d.vars_map = vars_map;\n-  d.from_context = cfun->decl;\n-  d.to_context = dest_cfun->decl;\n-  d.new_label_map = new_label_map;\n-\n   for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n     {\n       tree stmt = bsi_stmt (si);\n       int region;\n \n-      d.remap_decls_p = true;\n-      if (TREE_BLOCK (stmt))\n-\td.block = DECL_INITIAL (dest_cfun->decl);\n-\n-      walk_tree (&stmt, move_stmt_r, &d, NULL);\n+      walk_tree (&stmt, move_stmt_r, d, NULL);\n \n       if (TREE_CODE (stmt) == LABEL_EXPR)\n \t{\n@@ -5989,6 +5990,35 @@ new_label_mapper (tree decl, void *data)\n   return m->to;\n }\n \n+/* Change DECL_CONTEXT of all BLOCK_VARS in block, including\n+   subblocks.  */\n+\n+static void\n+replace_block_vars_by_duplicates (tree block, struct pointer_map_t *vars_map,\n+\t\t\t\t  tree to_context)\n+{\n+  tree *tp, t;\n+\n+  for (tp = &BLOCK_VARS (block); *tp; tp = &TREE_CHAIN (*tp))\n+    {\n+      t = *tp;\n+      replace_by_duplicate_decl (&t, vars_map, to_context);\n+      if (t != *tp)\n+\t{\n+\t  if (TREE_CODE (*tp) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (*tp))\n+\t    {\n+\t      SET_DECL_VALUE_EXPR (t, DECL_VALUE_EXPR (*tp));\n+\t      DECL_HAS_VALUE_EXPR_P (t) = 1;\n+\t    }\n+\t  TREE_CHAIN (t) = TREE_CHAIN (*tp);\n+\t  *tp = t;\n+\t}\n+    }\n+\n+  for (block = BLOCK_SUBBLOCKS (block); block; block = BLOCK_CHAIN (block))\n+    replace_block_vars_by_duplicates (block, vars_map, to_context);\n+}\n+\n /* Move a single-entry, single-exit region delimited by ENTRY_BB and\n    EXIT_BB to function DEST_CFUN.  The whole region is replaced by a\n    single basic block in the original CFG and the new basic block is\n@@ -5999,13 +6029,17 @@ new_label_mapper (tree decl, void *data)\n    is that ENTRY_BB should be the only entry point and it must\n    dominate EXIT_BB.\n \n+   Change TREE_BLOCK of all statements in ORIG_BLOCK to the new\n+   functions outermost BLOCK, move all subblocks of ORIG_BLOCK\n+   to the new function.\n+\n    All local variables referenced in the region are assumed to be in\n    the corresponding BLOCK_VARS and unexpanded variable lists\n    associated with DEST_CFUN.  */\n \n basic_block\n move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n-\t\t        basic_block exit_bb)\n+\t\t        basic_block exit_bb, tree orig_block)\n {\n   VEC(basic_block,heap) *bbs, *dom_bbs;\n   basic_block dom_entry = get_immediate_dominator (CDI_DOMINATORS, entry_bb);\n@@ -6019,6 +6053,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   htab_t new_label_map;\n   struct pointer_map_t *vars_map;\n   struct loop *loop = entry_bb->loop_father;\n+  struct move_stmt_d d;\n \n   /* If ENTRY does not strictly dominate EXIT, this cannot be an SESE\n      region.  */\n@@ -6115,16 +6150,42 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   gcc_assert (VEC_length (basic_block, bbs) >= 2);\n   after = dest_cfun->cfg->x_entry_block_ptr;\n   vars_map = pointer_map_create ();\n+\n+  memset (&d, 0, sizeof (d));\n+  d.vars_map = vars_map;\n+  d.from_context = cfun->decl;\n+  d.to_context = dest_cfun->decl;\n+  d.new_label_map = new_label_map;\n+  d.remap_decls_p = true;\n+  d.orig_block = orig_block;\n+  d.new_block = DECL_INITIAL (dest_cfun->decl);\n+\n   for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n     {\n       /* No need to update edge counts on the last block.  It has\n \t already been updated earlier when we detached the region from\n \t the original CFG.  */\n-      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, vars_map,\n-\t                new_label_map, eh_offset);\n+      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, &d, eh_offset);\n       after = bb;\n     }\n \n+  /* Rewire BLOCK_SUBBLOCKS of orig_block.  */\n+  if (orig_block)\n+    {\n+      tree block;\n+      gcc_assert (BLOCK_SUBBLOCKS (DECL_INITIAL (dest_cfun->decl))\n+\t\t  == NULL_TREE);\n+      BLOCK_SUBBLOCKS (DECL_INITIAL (dest_cfun->decl))\n+\t= BLOCK_SUBBLOCKS (orig_block);\n+      for (block = BLOCK_SUBBLOCKS (orig_block);\n+\t   block; block = BLOCK_CHAIN (block))\n+\tBLOCK_SUPERCONTEXT (block) = DECL_INITIAL (dest_cfun->decl);\n+      BLOCK_SUBBLOCKS (orig_block) = NULL_TREE;\n+    }\n+\n+  replace_block_vars_by_duplicates (DECL_INITIAL (dest_cfun->decl),\n+\t\t\t\t    vars_map, dest_cfun->decl);\n+\n   if (new_label_map)\n     htab_delete (new_label_map);\n   pointer_map_destroy (vars_map);"}, {"sha": "ded7687b75ebf7a572b7e97e0521fc0551d41879", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b357f682db35f4431e3011e7486a0ac865686e3e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b357f682db35f4431e3011e7486a0ac865686e3e", "patch": "@@ -1,5 +1,5 @@\n /* Data and Control Flow Analysis for Trees.\n-   Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n@@ -788,7 +788,7 @@ extern void replace_uses_by (tree, tree);\n extern void start_recording_case_labels (void);\n extern void end_recording_case_labels (void);\n extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n-\t\t\t\t           basic_block);\n+\t\t\t\t           basic_block, tree);\n void remove_edge_and_dominated_blocks (edge);\n void mark_virtual_ops_in_bb (basic_block);\n "}, {"sha": "18e1bf7c43a055bf1c7818c438e475414d782e77", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b357f682db35f4431e3011e7486a0ac865686e3e/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b357f682db35f4431e3011e7486a0ac865686e3e/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b357f682db35f4431e3011e7486a0ac865686e3e", "patch": "@@ -1,3 +1,8 @@\n+2008-06-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/36617\n+\t* testsuite/libgomp.c/debug-1.c: New test.\n+\n 2008-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c/nqueens-1.c: New test."}, {"sha": "09bcf7f3cc1b58ab9dafe8d7d382ea2c15827b23", "filename": "libgomp/testsuite/libgomp.c/debug-1.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b357f682db35f4431e3011e7486a0ac865686e3e/libgomp%2Ftestsuite%2Flibgomp.c%2Fdebug-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b357f682db35f4431e3011e7486a0ac865686e3e/libgomp%2Ftestsuite%2Flibgomp.c%2Fdebug-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdebug-1.c?ref=b357f682db35f4431e3011e7486a0ac865686e3e", "patch": "@@ -0,0 +1,162 @@\n+/* PR debug/36617 */\n+/* { dg-do run } */\n+/* { dg-options \"-g -fopenmp -O0\" } */\n+\n+int\n+f1 (void)\n+{\n+  int v1i, v1j, v1k, v1l = 0;\n+  v1i = 6;\n+  v1j = 8;\n+  #pragma omp parallel private (v1k) firstprivate (v1j) shared (v1i) reduction (+:v1l)\n+  {\n+    v1k = v1i + v1j;\n+    {\n+      int v1m = 1;\n+      v1l = v1m;\n+    }\n+  }\n+  return v1l;\n+}\n+\n+int v2k = 9;\n+\n+int\n+f2 (void)\n+{\n+  int v2i = 6, v2j = 7;\n+  #pragma omp single private (v2i) firstprivate (v2k)\n+  {\n+    int v2l = v2j + v2k;\n+    v2i = 8;\n+    v2k = 10;\n+    v2j = v2l + v2i;\n+  }\n+  return v2i + v2j;\n+}\n+\n+int\n+f3 (void)\n+{\n+  int v3i = 6, v3j = 7, v3k = 9;\n+  #pragma omp parallel\n+  {\n+    #pragma omp master\n+      v3i++;\n+    #pragma omp single private (v3i) firstprivate (v3k)\n+    {\n+      int v3l = v3j + v3k;\n+      v3i = 8;\n+      v3k = 10;\n+      v3j = v3l + v3i;\n+    }\n+    #pragma omp atomic\n+      v3k++;\n+  }\n+  return v3i + v3j;\n+}\n+\n+int v4k = 9, v4l = 0;\n+\n+int\n+f4 (void)\n+{\n+  int v4i = 6, v4j = 7, v4n = 0;\n+  #pragma omp sections private (v4i) firstprivate (v4k) reduction (+:v4l)\n+  {\n+    #pragma omp section\n+    {\n+      int v4m = v4j + v4k;\n+      v4i = 8;\n+      v4k = 10;\n+      v4l++;\n+      v4n = v4m + v4i;\n+    }\n+    #pragma omp section\n+    {\n+      int v4o = v4j + v4k;\n+      v4i = 10;\n+      v4k = 11;\n+      v4l++;\n+    }\n+  }\n+  return v4i + v4j + v4l + v4n;\n+}\n+\n+int\n+f5 (void)\n+{\n+  int v5i = 6, v5j = 7, v5k = 9, v5l = 0, v5n = 0, v5p = 0;\n+  #pragma omp parallel\n+  {\n+    #pragma omp master\n+      v5p++;\n+    #pragma omp sections private (v5i) firstprivate (v5k) reduction (+:v5l)\n+    {\n+      #pragma omp section\n+      {\n+\tint v5m = v5j + v5k;\n+\tv5i = 8;\n+\tv5k = 10;\n+\tv5l++;\n+\tv5n = v5m + v5i;\n+      }\n+      #pragma omp section\n+      {\n+\tint v5o = v5j + v5k;\n+\tv5i = 10;\n+\tv5k = 11;\n+\tv5l++;\n+      }\n+    }\n+  }\n+  return v5i + v5j + v5l + v5n + v5p;\n+}\n+\n+int v6k = 9, v6l = 0;\n+\n+int\n+f6 (void)\n+{\n+  int v6i = 6, v6j = 7, v6n = 0;\n+  #pragma omp for private (v6i) firstprivate (v6k) reduction (+:v6l)\n+  for (v6n = 0; v6n < 3; v6n++)\n+    {\n+      int v6m = v6j + v6k;\n+      v6i = 8;\n+      v6l++;\n+    }\n+  return v6i + v6j + v6k + v6l + v6n;\n+}\n+\n+int\n+f7 (void)\n+{\n+  int v7i = 6, v7j = 7, v7k = 9, v7l = 0, v7n = 0, v7o = 1;\n+  #pragma omp parallel\n+  {\n+    #pragma omp master\n+      v7o++;\n+    #pragma omp for private (v7i) firstprivate (v7k) reduction (+:v7l)\n+    for (v7n = 0; v7n < 3; v7n++)\n+      {\n+\tint v7m = v7j + v7k;\n+\tv7i = 8;\n+\tv7l++;\n+      }\n+  }\n+  return v7i + v7j + v7k + v7l + v7n;\n+}\n+\n+int\n+main (void)\n+{\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f4 ();\n+  f5 ();\n+  f6 ();\n+  f7 ();\n+  return 0;\n+}"}]}