{"sha": "946e1bc7575f0676faf87b8f9937e3a2a8b828af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ2ZTFiYzc1NzVmMDY3NmZhZjg3YjhmOTkzN2UzYTJhOGI4MjhhZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-11-12T19:58:05Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-12T19:58:05Z"}, "message": "Makefile.in (tree-data-ref.o): Add langhooks.h dependency.\n\n\t* Makefile.in (tree-data-ref.o): Add langhooks.h dependency.\n\t* tree-ssa-loop-niter.c (derive_constant_upper_bound):  Follow\n\tud-chains.  Handle AND_EXPR.\n\t(record_estimate): Record whether the estimate is realistic\n\tand whether it is derived from a loop exit.\n\t(record_nonwrapping_iv, idx_infer_loop_bounds, infer_loop_bounds_from_ref,\n\tinfer_loop_bounds_from_array, infer_loop_bounds_from_signedness): New\n\tfunctions.\n\t(compute_estimated_nb_iterations): Take only realistic bounds into\n\taccount.  Set estimate_state.  Use double_ints.\n\t(infer_loop_bounds_from_undefined): Call infer_loop_bounds_from_array\n\tand infer_loop_bounds_from_signedness.  Do not consider basic blocks\n\tthat do not have to be always executed.\n\t(estimate_numbers_of_iterations_loop): Set estimate_state, and use it\n\tto determine whether to call infer_loop_bounds_from_undefined\n\tand compute_estimated_nb_iterations.\n\t(n_of_executions_at_most): Use double_ints.\n\t(free_numbers_of_iterations_estimates_loop): Set estimate_state.\n\t(substitute_in_loop_info): Do not replace in estimated_nb_iterations.\n\t* double-int.c (double_int_to_tree): Improve comment.\n\t(double_int_fits_to_tree_p): New function.\n\t* double-int.h (double_int_fits_to_tree_p): Declare.\n\t* tree-data-ref.c: Include langhooks.h.\n\t(estimate_niter_from_size_of_data, estimate_iters_using_array): Removed.\n\t(analyze_array_indexes): Do not call estimate_niter_from_size_of_data.\n\t(analyze_array): Do not pass estimate_only argument to\n\tanalyze_array_indexes.\n\t(get_number_of_iters_for_loop): Build tree from the stored double_int\n\tvalue.\n\t(get_references_in_stmt, find_data_references_in_stmt): New functions.\n\t(find_data_references_in_loop): Use find_data_references_in_stmt.\n\t* tree-data-ref.h (struct data_ref_loc_d): New.\n\t(get_references_in_stmt): Declare.\n\t(estimate_iters_using_array): Declaration removed.\n\t* cfgloop.h (struct nb_iter_bound): Change type of bound to\n\tdouble_int.  Improve comments.  Add is_exit and realistic\n\tfields.\n\t(struct loop): Changed type of estimated_nb_iterations to double_int.\n\tAdded estimate_state field.\n\t(record_estimate): Declaration removed.\n\nFrom-SVN: r118729", "tree": {"sha": "cbab0d80fb90aa9c79c2f4bb40c468f14e9b8cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbab0d80fb90aa9c79c2f4bb40c468f14e9b8cb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/946e1bc7575f0676faf87b8f9937e3a2a8b828af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946e1bc7575f0676faf87b8f9937e3a2a8b828af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/946e1bc7575f0676faf87b8f9937e3a2a8b828af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946e1bc7575f0676faf87b8f9937e3a2a8b828af/comments", "author": null, "committer": null, "parents": [{"sha": "47eb5b329bf8e6ab2e939a4cedf5533d02a6c7f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47eb5b329bf8e6ab2e939a4cedf5533d02a6c7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47eb5b329bf8e6ab2e939a4cedf5533d02a6c7f1"}], "stats": {"total": 917, "additions": 579, "deletions": 338}, "files": [{"sha": "845e2353ef5813e02c704a59dd99130c9dd7b76e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -1,3 +1,46 @@\n+2006-11-12  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* Makefile.in (tree-data-ref.o): Add langhooks.h dependency.\n+\t* tree-ssa-loop-niter.c (derive_constant_upper_bound):  Follow\n+\tud-chains.  Handle AND_EXPR.\n+\t(record_estimate): Record whether the estimate is realistic\n+\tand whether it is derived from a loop exit.\n+\t(record_nonwrapping_iv, idx_infer_loop_bounds, infer_loop_bounds_from_ref,\n+\tinfer_loop_bounds_from_array, infer_loop_bounds_from_signedness): New\n+\tfunctions.\n+\t(compute_estimated_nb_iterations): Take only realistic bounds into\n+\taccount.  Set estimate_state.  Use double_ints.\n+\t(infer_loop_bounds_from_undefined): Call infer_loop_bounds_from_array\n+\tand infer_loop_bounds_from_signedness.  Do not consider basic blocks\n+\tthat do not have to be always executed.\n+\t(estimate_numbers_of_iterations_loop): Set estimate_state, and use it\n+\tto determine whether to call infer_loop_bounds_from_undefined\n+\tand compute_estimated_nb_iterations.\n+\t(n_of_executions_at_most): Use double_ints.\n+\t(free_numbers_of_iterations_estimates_loop): Set estimate_state.\n+\t(substitute_in_loop_info): Do not replace in estimated_nb_iterations.\n+\t* double-int.c (double_int_to_tree): Improve comment.\n+\t(double_int_fits_to_tree_p): New function.\n+\t* double-int.h (double_int_fits_to_tree_p): Declare.\n+\t* tree-data-ref.c: Include langhooks.h.\n+\t(estimate_niter_from_size_of_data, estimate_iters_using_array): Removed.\n+\t(analyze_array_indexes): Do not call estimate_niter_from_size_of_data.\n+\t(analyze_array): Do not pass estimate_only argument to\n+\tanalyze_array_indexes.\n+\t(get_number_of_iters_for_loop): Build tree from the stored double_int\n+\tvalue.\n+\t(get_references_in_stmt, find_data_references_in_stmt): New functions.\n+\t(find_data_references_in_loop): Use find_data_references_in_stmt.\n+\t* tree-data-ref.h (struct data_ref_loc_d): New.\n+\t(get_references_in_stmt): Declare.\n+\t(estimate_iters_using_array): Declaration removed.\n+\t* cfgloop.h (struct nb_iter_bound): Change type of bound to\n+\tdouble_int.  Improve comments.  Add is_exit and realistic\n+\tfields.\n+\t(struct loop): Changed type of estimated_nb_iterations to double_int.\n+\tAdded estimate_state field.\n+\t(record_estimate): Declaration removed.\n+\n 2006-11-12  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* params.c (set_param_value): Initialize the \"set\" field."}, {"sha": "7e4c16a5e6a9b348b699642003b9c9e8fd3a6ce9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -2080,7 +2080,7 @@ tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n-   $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h\n+   $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h langhooks.h\n tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\"}, {"sha": "311c43ea9226e3f353d00ae5472068dcfd15d10b", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -47,12 +47,31 @@ struct lpt_decision\n \n struct nb_iter_bound\n {\n-  tree bound;\t\t/* The constant expression whose value is an upper\n-\t\t\t   bound on the number of executions of ...  */\n-  tree at_stmt;\t\t/* ... this statement during one execution of\n-\t\t\t   a loop.  */\n+  /* The statement STMT is executed at most ...  */\n+  tree stmt;\n+\n+  /* ... BOUND + 1 times (BOUND must be an unsigned constant).\n+     The + 1 is added for the following reasons:\n+\n+     a) 0 would otherwise be unused, while we would need to care more about\n+        overflows (as MAX + 1 is sometimes produced as the estimate on number\n+\tof executions of STMT).\n+     b) it is consistent with the result of number_of_iterations_exit.  */\n+  double_int bound;\n+\n+  /* True if the statement will cause the loop to be leaved the (at most) \n+     BOUND + 1-st time it is executed, that is, all the statements after it\n+     are executed at most BOUND times.  */\n+  bool is_exit;\n+\n+  /* True if the bound is \"realistic\" -- i.e., most likely the loop really has\n+     number of iterations close to the bound.  Exact bounds (if the number of\n+     iterations of a loop is a constant) and bounds derived from the size of\n+     data accessed in the loop are considered realistic.  */\n+  bool realistic;\n+\n+  /* The next bound in the list.  */\n   struct nb_iter_bound *next;\n-\t\t\t/* The next bound in a list.  */\n };\n \n /* Structure to hold information for each natural loop.  */\n@@ -111,9 +130,18 @@ struct loop\n      information in this field.  */\n   tree nb_iterations;\n \n-  /* An INTEGER_CST estimation of the number of iterations.  NULL_TREE\n-     if there is no estimation.  */\n-  tree estimated_nb_iterations;\n+  /* An integer estimation of the number of iterations.  Estimate_state\n+     describes what is the state of the estimation.  */\n+  enum\n+    {\n+      /* Estimate was not computed yet.  */\n+      EST_NOT_COMPUTED,\n+      /* Estimate was computed, but we could derive no useful bound.  */\n+      EST_NOT_AVAILABLE,\n+      /* Estimate is ready.  */\n+      EST_AVAILABLE\n+    } estimate_state;\n+  double_int estimated_nb_iterations;\n \n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n@@ -398,6 +426,5 @@ enum\n extern void unroll_and_peel_loops (struct loops *, int);\n extern void doloop_optimize_loops (struct loops *);\n extern void move_loop_invariants (struct loops *);\n-extern void record_estimate (struct loop *, tree, tree, tree);\n \n #endif /* GCC_CFGLOOP_H */"}, {"sha": "f1824da8ff4d3fdd0a3b445234055fa428f68896", "filename": "gcc/double-int.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -290,7 +290,8 @@ double_int_umod (double_int a, double_int b, unsigned code)\n   return double_int_mod (a, b, true, code);\n }\n \n-/* Constructs tree in type TYPE from with value given by CST.  */\n+/* Constructs tree in type TYPE from with value given by CST.  Signedness of CST\n+   is assumed to be the same as the signedness of TYPE.  */\n \n tree\n double_int_to_tree (tree type, double_int cst)\n@@ -300,6 +301,19 @@ double_int_to_tree (tree type, double_int cst)\n   return build_int_cst_wide (type, cst.low, cst.high);\n }\n \n+/* Returns true if CST fits into range of TYPE.  Signedness of CST is assumed\n+   to be the same as the signedness of TYPE.  */\n+\n+bool\n+double_int_fits_to_tree_p (tree type, double_int cst)\n+{\n+  double_int ext = double_int_ext (cst,\n+\t\t\t\t   TYPE_PRECISION (type),\n+\t\t\t\t   TYPE_UNSIGNED (type));\n+\n+  return double_int_equal_p (cst, ext);\n+}\n+\n /* Returns true if CST is negative.  Of course, CST is considered to\n    be signed.  */\n "}, {"sha": "6ecfa48f7876a5e3a6d59a4bb137b8b8c4cb7dfd", "filename": "gcc/double-int.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -58,7 +58,8 @@ union tree_node;\n /* Constructors and conversions.  */\n \n union tree_node *double_int_to_tree (union tree_node *, double_int);\n-double_int tree_to_double_int (union tree_node *tree);\n+bool double_int_fits_to_tree_p (union tree_node *, double_int);\n+double_int tree_to_double_int (union tree_node *);\n \n /* Constructs double_int from integer CST.  The bits over the precision of\n    HOST_WIDE_INT are filled with the sign bit.  */"}, {"sha": "3734058bbbf163ac7ee9e6486a4dd5e7db167476", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 141, "deletions": 186, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -93,6 +93,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n+#include \"langhooks.h\"\n \n static struct datadep_stats\n {\n@@ -888,75 +889,16 @@ dump_ddrs (FILE *file, VEC (ddr_p, heap) *ddrs)\n \n \f\n \n-/* Estimate the number of iterations from the size of the data and the\n-   access functions.  */\n-\n-static void\n-estimate_niter_from_size_of_data (struct loop *loop, \n-\t\t\t\t  tree opnd0, \n-\t\t\t\t  tree access_fn, \n-\t\t\t\t  tree stmt)\n-{\n-  tree estimation = NULL_TREE;\n-  tree array_size, data_size, element_size;\n-  tree init, step;\n-\n-  init = initial_condition (access_fn);\n-  step = evolution_part_in_loop_num (access_fn, loop->num);\n-\n-  array_size = TYPE_SIZE (TREE_TYPE (opnd0));\n-  element_size = TYPE_SIZE (TREE_TYPE (TREE_TYPE (opnd0)));\n-  if (array_size == NULL_TREE \n-      || TREE_CODE (array_size) != INTEGER_CST\n-      || TREE_CODE (element_size) != INTEGER_CST)\n-    return;\n-\n-  data_size = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n-\t\t\t   array_size, element_size);\n-\n-  if (init != NULL_TREE\n-      && step != NULL_TREE\n-      && TREE_CODE (init) == INTEGER_CST\n-      && TREE_CODE (step) == INTEGER_CST)\n-    {\n-      tree i_plus_s = fold_build2 (PLUS_EXPR, integer_type_node, init, step);\n-      tree sign = fold_binary (GT_EXPR, boolean_type_node, i_plus_s, init);\n-\n-      if (sign == boolean_true_node)\n-\testimation = fold_build2 (CEIL_DIV_EXPR, integer_type_node,\n-\t\t\t\t  fold_build2 (MINUS_EXPR, integer_type_node,\n-\t\t\t\t\t       data_size, init), step);\n-\n-      /* When the step is negative, as in PR23386: (init = 3, step =\n-\t 0ffffffff, data_size = 100), we have to compute the\n-\t estimation as ceil_div (init, 0 - step) + 1.  */\n-      else if (sign == boolean_false_node)\n-\testimation = \n-\t  fold_build2 (PLUS_EXPR, integer_type_node,\n-\t\t       fold_build2 (CEIL_DIV_EXPR, integer_type_node,\n-\t\t\t\t    init,\n-\t\t\t\t    fold_build2 (MINUS_EXPR, unsigned_type_node,\n-\t\t\t\t\t\t integer_zero_node, step)),\n-\t\t       integer_one_node);\n-\n-      if (estimation)\n-\trecord_estimate (loop, estimation, boolean_true_node, stmt);\n-    }\n-}\n-\n /* Given an ARRAY_REF node REF, records its access functions.\n    Example: given A[i][3], record in ACCESS_FNS the opnd1 function,\n    i.e. the constant \"3\", then recursively call the function on opnd0,\n    i.e. the ARRAY_REF \"A[i]\".  \n-   If ESTIMATE_ONLY is true, we just set the estimated number of loop\n-   iterations, we don't store the access function.\n    The function returns the base name: \"A\".  */\n \n static tree\n analyze_array_indexes (struct loop *loop,\n \t\t       VEC(tree,heap) **access_fns, \n-\t\t       tree ref, tree stmt,\n-\t\t       bool estimate_only)\n+\t\t       tree ref, tree stmt)\n {\n   tree opnd0, opnd1;\n   tree access_fn;\n@@ -971,32 +913,17 @@ analyze_array_indexes (struct loop *loop,\n   access_fn = instantiate_parameters\n     (loop, analyze_scalar_evolution (loop, opnd1));\n \n-  if (estimate_only \n-      && chrec_contains_undetermined (loop->estimated_nb_iterations))\n-    estimate_niter_from_size_of_data (loop, opnd0, access_fn, stmt);\n-\n-  if (!estimate_only)\n-    VEC_safe_push (tree, heap, *access_fns, access_fn);\n+  VEC_safe_push (tree, heap, *access_fns, access_fn);\n   \n   /* Recursively record other array access functions.  */\n   if (TREE_CODE (opnd0) == ARRAY_REF)\n-    return analyze_array_indexes (loop, access_fns, opnd0, stmt, estimate_only);\n+    return analyze_array_indexes (loop, access_fns, opnd0, stmt);\n \n   /* Return the base name of the data access.  */\n   else\n     return opnd0;\n }\n \n-/* For an array reference REF contained in STMT, attempt to bound the\n-   number of iterations in the loop containing STMT  */\n-\n-void \n-estimate_iters_using_array (tree stmt, tree ref)\n-{\n-  analyze_array_indexes (loop_containing_stmt (stmt), NULL, ref, stmt, \n-\t\t\t true);\n-}\n-  \n /* For a data reference REF contained in the statement STMT, initialize\n    a DATA_REFERENCE structure, and return it.  IS_READ flag has to be\n    set to true when REF is in the right hand side of an\n@@ -1022,7 +949,7 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   DR_REF (res) = ref;\n   acc_fns = VEC_alloc (tree, heap, 3);\n   DR_BASE_OBJECT (res) = analyze_array_indexes\n-    (loop_containing_stmt (stmt), &acc_fns, ref, stmt, false);\n+    (loop_containing_stmt (stmt), &acc_fns, ref, stmt);\n   DR_TYPE (res) = ARRAY_REF_TYPE;\n   DR_SET_ACCESS_FNS (res, acc_fns);\n   DR_IS_READ (res) = is_read;\n@@ -2377,13 +2304,20 @@ analyze_ziv_subscript (tree chrec_a,\n static tree\n get_number_of_iters_for_loop (int loopnum)\n {\n-  tree numiter = number_of_iterations_in_loop (current_loops->parray[loopnum]);\n+  struct loop *loop = current_loops->parray[loopnum];\n+  tree numiter = number_of_iterations_in_loop (loop);\n+\n+  if (TREE_CODE (numiter) == INTEGER_CST)\n+    return numiter;\n \n-  if (TREE_CODE (numiter) != INTEGER_CST)\n-    numiter = current_loops->parray[loopnum]->estimated_nb_iterations;\n-  if (chrec_contains_undetermined (numiter))\n-    return NULL_TREE;\n-  return numiter;\n+  if (loop->estimate_state == EST_AVAILABLE)\n+    {\n+      tree type = lang_hooks.types.type_for_size (INT_TYPE_SIZE, true);\n+      if (double_int_fits_to_tree_p (type, loop->estimated_nb_iterations))\n+\treturn double_int_to_tree (type, loop->estimated_nb_iterations);\n+    }\n+\n+  return NULL_TREE;\n }\n     \n /* Analyze a SIV (Single Index Variable) subscript where CHREC_A is a\n@@ -4060,6 +3994,105 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n       }\n }\n \n+/* Stores the locations of memory references in STMT to REFERENCES.  Returns\n+   true if STMT clobbers memory, false otherwise.  */\n+\n+bool\n+get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n+{\n+  bool clobbers_memory = false;\n+  data_ref_loc *ref;\n+  tree *op0, *op1, args, call;\n+\n+  *references = NULL;\n+\n+  /* ASM_EXPR and CALL_EXPR may embed arbitrary side effects.\n+     Calls have side-effects, except those to const or pure\n+     functions.  */\n+  call = get_call_expr_in (stmt);\n+  if ((call\n+       && !(call_expr_flags (call) & (ECF_CONST | ECF_PURE)))\n+      || (TREE_CODE (stmt) == ASM_EXPR\n+\t  && ASM_VOLATILE_P (stmt)))\n+    clobbers_memory = true;\n+\n+  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+    return clobbers_memory;\n+\n+  if (TREE_CODE (stmt) ==  MODIFY_EXPR)\n+    {\n+      op0 = &TREE_OPERAND (stmt, 0);\n+      op1 = &TREE_OPERAND (stmt, 1);\n+\t\t\n+      if (DECL_P (*op1)\n+\t  || REFERENCE_CLASS_P (*op1))\n+\t{\n+\t  ref = VEC_safe_push (data_ref_loc, heap, *references, NULL);\n+\t  ref->pos = op1;\n+\t  ref->is_read = true;\n+\t}\n+\n+      if (DECL_P (*op0)\n+\t  || REFERENCE_CLASS_P (*op0))\n+\t{\n+\t  ref = VEC_safe_push (data_ref_loc, heap, *references, NULL);\n+\t  ref->pos = op0;\n+\t  ref->is_read = false;\n+\t}\n+    }\n+\n+  if (call)\n+    {\n+      for (args = TREE_OPERAND (call, 1); args; args = TREE_CHAIN (args))\n+\t{\n+\t  op0 = &TREE_VALUE (args);\n+\t  if (DECL_P (*op0)\n+\t      || REFERENCE_CLASS_P (*op0))\n+\t    {\n+\t      ref = VEC_safe_push (data_ref_loc, heap, *references, NULL);\n+\t      ref->pos = op0;\n+\t      ref->is_read = true;\n+\t    }\n+\t}\n+    }\n+\n+  return clobbers_memory;\n+}\n+\n+/* Stores the data references in STMT to DATAREFS.  If there is an unanalyzable\n+   reference, returns false, otherwise returns true.  */\n+\n+static bool\n+find_data_references_in_stmt (tree stmt,\n+\t\t\t      VEC (data_reference_p, heap) **datarefs)\n+{\n+  unsigned i;\n+  VEC (data_ref_loc, heap) *references;\n+  data_ref_loc *ref;\n+  bool ret = true;\n+  data_reference_p dr;\n+\n+  if (get_references_in_stmt (stmt, &references))\n+    {\n+      VEC_free (data_ref_loc, heap, references);\n+      return false;\n+    }\n+\n+  for (i = 0; VEC_iterate (data_ref_loc, references, i, ref); i++)\n+    {\n+      dr = create_data_ref (*ref->pos, stmt, ref->is_read);\n+      if (dr)\n+\tVEC_safe_push (data_reference_p, heap, *datarefs, dr);\n+      else\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+    }\n+  VEC_free (data_ref_loc, heap, references);\n+  return ret;\n+}\n+\n /* Search the data references in LOOP, and record the information into\n    DATAREFS.  Returns chrec_dont_know when failing to analyze a\n    difficult case, returns NULL_TREE otherwise.\n@@ -4074,126 +4107,48 @@ find_data_references_in_loop (struct loop *loop,\n   basic_block bb, *bbs;\n   unsigned int i;\n   block_stmt_iterator bsi;\n-  struct data_reference *dr;\n \n   bbs = get_loop_body (loop);\n+  loop->parallel_p = true;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       bb = bbs[i];\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-        {\n+\t{\n \t  tree stmt = bsi_stmt (bsi);\n \n-\t  /* ASM_EXPR and CALL_EXPR may embed arbitrary side effects.\n-\t     Calls have side-effects, except those to const or pure\n-\t     functions.  */\n-\t  if ((TREE_CODE (stmt) == CALL_EXPR\n-\t       && !(call_expr_flags (stmt) & (ECF_CONST | ECF_PURE)))\n-\t      || (TREE_CODE (stmt) == ASM_EXPR\n-\t\t  && ASM_VOLATILE_P (stmt)))\n-\t    goto insert_dont_know_node;\n-\n-\t  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n-\t    continue;\n-\n-\t  switch (TREE_CODE (stmt))\n+\t  if (!find_data_references_in_stmt (stmt, datarefs))\n \t    {\n-\t    case MODIFY_EXPR:\n-\t      {\n-\t\tbool one_inserted = false;\n-\t\ttree opnd0 = TREE_OPERAND (stmt, 0);\n-\t\ttree opnd1 = TREE_OPERAND (stmt, 1);\n-\t\t\n-\t\tif (TREE_CODE (opnd0) == ARRAY_REF \n-\t\t    || TREE_CODE (opnd0) == INDIRECT_REF\n-                    || TREE_CODE (opnd0) == COMPONENT_REF)\n-\t\t  {\n-\t\t    dr = create_data_ref (opnd0, stmt, false);\n-\t\t    if (dr) \n-\t\t      {\n-\t\t\tVEC_safe_push (data_reference_p, heap, *datarefs, dr);\n-\t\t\tone_inserted = true;\n-\t\t      }\n-\t\t  }\n-\n-\t\tif (TREE_CODE (opnd1) == ARRAY_REF \n-\t\t    || TREE_CODE (opnd1) == INDIRECT_REF\n-\t\t    || TREE_CODE (opnd1) == COMPONENT_REF)\n-\t\t  {\n-\t\t    dr = create_data_ref (opnd1, stmt, true);\n-\t\t    if (dr) \n-\t\t      {\n-\t\t\tVEC_safe_push (data_reference_p, heap, *datarefs, dr);\n-\t\t\tone_inserted = true;\n-\t\t      }\n-\t\t  }\n-\n-\t\tif (!one_inserted)\n-\t\t  goto insert_dont_know_node;\n-\n-\t\tbreak;\n-\t      }\n-\n-\t    case CALL_EXPR:\n-\t      {\n-\t\ttree args;\n-\t\tbool one_inserted = false;\n-\n-\t\tfor (args = TREE_OPERAND (stmt, 1); args; \n-\t\t     args = TREE_CHAIN (args))\n-\t\t  if (TREE_CODE (TREE_VALUE (args)) == ARRAY_REF\n-\t\t      || TREE_CODE (TREE_VALUE (args)) == INDIRECT_REF\n-\t\t      || TREE_CODE (TREE_VALUE (args)) == COMPONENT_REF)\n-\t\t    {\n-\t\t      dr = create_data_ref (TREE_VALUE (args), stmt, true);\n-\t\t      if (dr)\n-\t\t\t{\n-\t\t\t  VEC_safe_push (data_reference_p, heap, *datarefs, dr);\n-\t\t\t  one_inserted = true;\n-\t\t\t}\n-\t\t    }\n-\n-\t\tif (!one_inserted)\n-\t\t  goto insert_dont_know_node;\n-\n-\t\tbreak;\n-\t      }\n-\n-\t    default:\n-\t\t{\n-\t\t  struct data_reference *res;\n-\n-\t\tinsert_dont_know_node:;\n-\t\t  res = XNEW (struct data_reference);\n-\t\t  DR_STMT (res) = NULL_TREE;\n-\t\t  DR_REF (res) = NULL_TREE;\n-\t\t  DR_BASE_OBJECT (res) = NULL;\n-\t\t  DR_TYPE (res) = ARRAY_REF_TYPE;\n-\t\t  DR_SET_ACCESS_FNS (res, NULL);\n-\t\t  DR_BASE_OBJECT (res) = NULL;\n-\t\t  DR_IS_READ (res) = false;\n-\t\t  DR_BASE_ADDRESS (res) = NULL_TREE;\n-\t\t  DR_OFFSET (res) = NULL_TREE;\n-\t\t  DR_INIT (res) = NULL_TREE;\n-\t\t  DR_STEP (res) = NULL_TREE;\n-\t\t  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n-\t\t  DR_MEMTAG (res) = NULL_TREE;\n-\t\t  DR_PTR_INFO (res) = NULL;\n-\t\t  VEC_safe_push (data_reference_p, heap, *datarefs, res);\n-\n-\t\t  free (bbs);\n-\t\t  return chrec_dont_know;\n-\t\t}\n+\t      struct data_reference *res;\n+\t      res = XNEW (struct data_reference);\n+\t      DR_STMT (res) = NULL_TREE;\n+\t      DR_REF (res) = NULL_TREE;\n+\t      DR_BASE_OBJECT (res) = NULL;\n+\t      DR_TYPE (res) = ARRAY_REF_TYPE;\n+\t      DR_SET_ACCESS_FNS (res, NULL);\n+\t      DR_BASE_OBJECT (res) = NULL;\n+\t      DR_IS_READ (res) = false;\n+\t      DR_BASE_ADDRESS (res) = NULL_TREE;\n+\t      DR_OFFSET (res) = NULL_TREE;\n+\t      DR_INIT (res) = NULL_TREE;\n+\t      DR_STEP (res) = NULL_TREE;\n+\t      DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n+\t      DR_MEMTAG (res) = NULL_TREE;\n+\t      DR_PTR_INFO (res) = NULL;\n+\t      loop->parallel_p = false;\n+\t      VEC_safe_push (data_reference_p, heap, *datarefs, res);\n+\n+\t      free (bbs);\n+\t      return chrec_dont_know;\n \t    }\n \n \t  /* When there are no defs in the loop, the loop is parallel.  */\n \t  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n \t    loop->parallel_p = false;\n \t}\n     }\n-\n   free (bbs);\n \n   return NULL_TREE;"}, {"sha": "7d6f9f94cb4ad83d4077bc05ee981d4e8781d911", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -269,6 +269,21 @@ DEF_VEC_ALLOC_P(ddr_p,heap);\n \n \f\n \n+/* Describes a location of a memory reference.  */\n+\n+typedef struct data_ref_loc_d\n+{\n+  /* Position of the memory reference.  */\n+  tree *pos;\n+\n+  /* True if the memory reference is read.  */\n+  bool is_read;\n+} data_ref_loc;\n+\n+DEF_VEC_O (data_ref_loc);\n+DEF_VEC_ALLOC_O (data_ref_loc, heap);\n+\n+bool get_references_in_stmt (tree, VEC (data_ref_loc, heap) **);\n extern tree find_data_references_in_loop (struct loop *,\n \t\t\t\t\t  VEC (data_reference_p, heap) **);\n extern void compute_data_dependences_for_loop (struct loop *, bool,\n@@ -292,7 +307,6 @@ extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (VEC (ddr_p, heap) *);\n extern void free_data_refs (VEC (data_reference_p, heap) *);\n extern struct data_reference *analyze_array (tree, tree, bool);\n-extern void estimate_iters_using_array (tree, tree);\n \n \n /* Return the index of the variable VAR in the LOOP_NEST array.  */"}, {"sha": "487a08d8dd670a5c9110fdc0c5066442ce4180ab", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 326, "deletions": 139, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946e1bc7575f0676faf87b8f9937e3a2a8b828af/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=946e1bc7575f0676faf87b8f9937e3a2a8b828af", "patch": "@@ -1533,6 +1533,7 @@ derive_constant_upper_bound (tree val, tree additional)\n   tree type = TREE_TYPE (val);\n   tree op0, op1, subtype, maxt;\n   double_int bnd, max, mmax, cst;\n+  tree stmt;\n \n   if (INTEGRAL_TYPE_P (type))\n     maxt = TYPE_MAX_VALUE (type);\n@@ -1647,60 +1648,298 @@ derive_constant_upper_bound (tree val, tree additional)\n       bnd = derive_constant_upper_bound (op0, additional);\n       return double_int_udiv (bnd, tree_to_double_int (op1), FLOOR_DIV_EXPR);\n \n+    case BIT_AND_EXPR:\n+      op1 = TREE_OPERAND (val, 1);\n+      if (TREE_CODE (op1) != INTEGER_CST\n+\t  || tree_int_cst_sign_bit (op1))\n+\treturn max;\n+      return tree_to_double_int (op1);\n+\n+    case SSA_NAME:\n+      stmt = SSA_NAME_DEF_STMT (val);\n+      if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t  || TREE_OPERAND (stmt, 0) != val)\n+\treturn max;\n+      return derive_constant_upper_bound (TREE_OPERAND (stmt, 1), additional);\n+\n     default: \n       return max;\n     }\n }\n \n-/* Records that AT_STMT is executed at most BOUND times in LOOP.  The\n-   additional condition ADDITIONAL is recorded with the bound.  */\n+/* Records that AT_STMT is executed at most BOUND + 1 times in LOOP.  The\n+   additional condition ADDITIONAL is recorded with the bound.  IS_EXIT\n+   is true if the loop is exited immediately after STMT, and this exit\n+   is taken at last when the STMT is executed BOUND + 1 times.\n+   REALISTIC is true if the estimate comes from a reliable source\n+   (number of iterations analysis, or size of data accessed in the loop).  */\n \n-void\n-record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt)\n+static void\n+record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt,\n+\t\t bool is_exit, bool realistic)\n {\n   struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n   double_int i_bound = derive_constant_upper_bound (bound, additional);\n-  tree c_bound = double_int_to_tree (unsigned_type_for (TREE_TYPE (bound)),\n-\t\t\t\t     i_bound);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Statements after \");\n+      fprintf (dump_file, \"Statement %s\", is_exit ? \"(exit)\" : \"\");\n       print_generic_expr (dump_file, at_stmt, TDF_SLIM);\n-      fprintf (dump_file, \" are executed at most \");\n+      fprintf (dump_file, \" is executed at most \");\n       print_generic_expr (dump_file, bound, TDF_SLIM);\n       fprintf (dump_file, \" (bounded by \");\n-      print_generic_expr (dump_file, c_bound, TDF_SLIM);\n-      fprintf (dump_file, \") times in loop %d.\\n\", loop->num);\n+      dump_double_int (dump_file, i_bound, true);\n+      fprintf (dump_file, \") + 1 times in loop %d.\\n\", loop->num);\n     }\n \n-  elt->bound = c_bound;\n-  elt->at_stmt = at_stmt;\n+  elt->bound = i_bound;\n+  elt->stmt = at_stmt;\n+  elt->is_exit = is_exit;\n+  elt->realistic = realistic && TREE_CODE (bound) == INTEGER_CST;\n   elt->next = loop->bounds;\n   loop->bounds = elt;\n }\n \n+/* Record the estimate on number of iterations of LOOP based on the fact that\n+   the induction variable BASE + STEP * i evaluated in STMT does not wrap and\n+   its values belong to the range <LOW, HIGH>.  DATA_SIZE_BOUNDS_P is true if\n+   LOW and HIGH are derived from the size of data.  */\n+\n+static void\n+record_nonwrapping_iv (struct loop *loop, tree base, tree step, tree stmt,\n+\t\t       tree low, tree high, bool data_size_bounds_p)\n+{\n+  tree niter_bound, extreme, delta;\n+  tree type = TREE_TYPE (base), unsigned_type;\n+\n+  if (TREE_CODE (step) != INTEGER_CST || zero_p (step))\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Induction variable (\");\n+      print_generic_expr (dump_file, TREE_TYPE (base), TDF_SLIM);\n+      fprintf (dump_file, \") \");\n+      print_generic_expr (dump_file, base, TDF_SLIM);\n+      fprintf (dump_file, \" + \");\n+      print_generic_expr (dump_file, step, TDF_SLIM);\n+      fprintf (dump_file, \" * iteration does not wrap in statement \");\n+      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \" in loop %d.\\n\", loop->num);\n+    }\n+\n+  unsigned_type = unsigned_type_for (type);\n+  base = fold_convert (unsigned_type, base);\n+  step = fold_convert (unsigned_type, step);\n+\n+  if (tree_int_cst_sign_bit (step))\n+    {\n+      extreme = fold_convert (unsigned_type, low);\n+      if (TREE_CODE (base) != INTEGER_CST)\n+\tbase = fold_convert (unsigned_type, high);\n+      delta = fold_build2 (MINUS_EXPR, unsigned_type, base, extreme);\n+      step = fold_build1 (NEGATE_EXPR, unsigned_type, step);\n+    }\n+  else\n+    {\n+      extreme = fold_convert (unsigned_type, high);\n+      if (TREE_CODE (base) != INTEGER_CST)\n+\tbase = fold_convert (unsigned_type, low);\n+      delta = fold_build2 (MINUS_EXPR, unsigned_type, extreme, base);\n+    }\n+\n+  /* STMT is executed at most NITER_BOUND + 1 times, since otherwise the value\n+     would get out of the range.  */\n+  niter_bound = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step);\n+  record_estimate (loop, niter_bound, boolean_true_node, stmt,\n+\t\t   false, data_size_bounds_p);\n+}\n+\n /* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe\n    approximation of the number of iterations for LOOP.  */\n \n static void\n compute_estimated_nb_iterations (struct loop *loop)\n {\n   struct nb_iter_bound *bound;\n-  \n+ \n+  gcc_assert (loop->estimate_state == EST_NOT_AVAILABLE);\n+\n   for (bound = loop->bounds; bound; bound = bound->next)\n     {\n-      if (TREE_CODE (bound->bound) != INTEGER_CST)\n+      if (!bound->realistic)\n \tcontinue;\n \n       /* Update only when there is no previous estimation, or when the current\n \t estimation is smaller.  */\n-      if (chrec_contains_undetermined (loop->estimated_nb_iterations)\n-\t  || tree_int_cst_lt (bound->bound, loop->estimated_nb_iterations))\n-\tloop->estimated_nb_iterations = bound->bound;\n+      if (loop->estimate_state == EST_NOT_AVAILABLE\n+\t  || double_int_ucmp (bound->bound, loop->estimated_nb_iterations) < 0)\n+\t{\n+\t  loop->estimate_state = EST_AVAILABLE;\n+\t  loop->estimated_nb_iterations = bound->bound;\n+\t}\n     }\n }\n \n+/* Determine information about number of iterations a LOOP from the index\n+   IDX of a data reference accessed in STMT.  Callback for for_each_index.  */\n+\n+struct ilb_data\n+{\n+  struct loop *loop;\n+  tree stmt;\n+};\n+\n+static bool\n+idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n+{\n+  struct ilb_data *data = dta;\n+  tree ev, init, step;\n+  tree low, high, type, next;\n+  bool sign;\n+  struct loop *loop = data->loop;\n+\n+  if (TREE_CODE (base) != ARRAY_REF)\n+    return true;\n+\n+  ev = instantiate_parameters (loop, analyze_scalar_evolution (loop, *idx));\n+  init = initial_condition (ev);\n+  step = evolution_part_in_loop_num (ev, loop->num);\n+\n+  if (!init\n+      || !step\n+      || TREE_CODE (step) != INTEGER_CST\n+      || zero_p (step)\n+      || tree_contains_chrecs (init, NULL)\n+      || chrec_contains_symbols_defined_in_loop (init, loop->num))\n+    return true;\n+\n+  low = array_ref_low_bound (base);\n+  high = array_ref_up_bound (base);\n+  \n+  /* The case of nonconstant bounds could be handled, but it would be\n+     complicated.  */\n+  if (TREE_CODE (low) != INTEGER_CST\n+      || !high\n+      || TREE_CODE (high) != INTEGER_CST)\n+    return true;\n+  sign = tree_int_cst_sign_bit (step);\n+  type = TREE_TYPE (step);\n+  \n+  /* In case the relevant bound of the array does not fit in type, or\n+     it does, but bound + step (in type) still belongs into the range of the\n+     array, the index may wrap and still stay within the range of the array\n+     (consider e.g. if the array is indexed by the full range of\n+     unsigned char).\n+\n+     To make things simpler, we require both bounds to fit into type, although\n+     there are cases where this would not be strightly necessary.  */\n+  if (!int_fits_type_p (high, type)\n+      || !int_fits_type_p (low, type))\n+    return true;\n+  low = fold_convert (type, low);\n+  high = fold_convert (type, high);\n+\n+  if (sign)\n+    next = fold_binary (PLUS_EXPR, type, low, step);\n+  else\n+    next = fold_binary (PLUS_EXPR, type, high, step);\n+  \n+  if (tree_int_cst_compare (low, next) <= 0\n+      && tree_int_cst_compare (next, high) <= 0)\n+    return true;\n+\n+  record_nonwrapping_iv (loop, init, step, data->stmt, low, high, true);\n+  return true;\n+}\n+\n+/* Determine information about number of iterations a LOOP from the bounds\n+   of arrays in the data reference REF accessed in STMT.  */\n+\n+static void\n+infer_loop_bounds_from_ref (struct loop *loop, tree stmt, tree ref)\n+{\n+  struct ilb_data data;\n+\n+  data.loop = loop;\n+  data.stmt = stmt;\n+  for_each_index (&ref, idx_infer_loop_bounds, &data);\n+}\n+\n+/* Determine information about number of iterations of a LOOP from the way\n+   arrays are used in STMT.  */\n+\n+static void\n+infer_loop_bounds_from_array (struct loop *loop, tree stmt)\n+{\n+  tree call;\n+\n+  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+    {\n+      tree op0 = TREE_OPERAND (stmt, 0);\n+      tree op1 = TREE_OPERAND (stmt, 1);\n+\n+      /* For each memory access, analyze its access function\n+\t and record a bound on the loop iteration domain.  */\n+      if (REFERENCE_CLASS_P (op0))\n+\tinfer_loop_bounds_from_ref (loop, stmt, op0);\n+\n+      if (REFERENCE_CLASS_P (op1))\n+\tinfer_loop_bounds_from_ref (loop, stmt, op1);\n+    }\n+  \n+  \n+  call = get_call_expr_in (stmt);\n+  if (call)\n+    {\n+      tree args;\n+\n+      for (args = TREE_OPERAND (call, 1); args; args = TREE_CHAIN (args))\n+\tif (REFERENCE_CLASS_P (TREE_VALUE (args)))\n+\t  infer_loop_bounds_from_ref (loop, stmt, TREE_VALUE (args));\n+    }\n+}\n+\n+/* Determine information about number of iterations of a LOOP from the fact\n+   that signed arithmetics in STMT does not overflow.  */\n+\n+static void\n+infer_loop_bounds_from_signedness (struct loop *loop, tree stmt)\n+{\n+  tree def, base, step, scev, type, low, high;\n+\n+  if (flag_wrapv || TREE_CODE (stmt) != MODIFY_EXPR)\n+    return;\n+\n+  def = TREE_OPERAND (stmt, 0);\n+\n+  if (TREE_CODE (def) != SSA_NAME)\n+    return;\n+\n+  type = TREE_TYPE (def);\n+  if (!INTEGRAL_TYPE_P (type)\n+      || TYPE_UNSIGNED (type))\n+    return;\n+\n+  scev = instantiate_parameters (loop, analyze_scalar_evolution (loop, def));\n+  if (chrec_contains_undetermined (scev))\n+    return;\n+\n+  base = initial_condition_in_loop_num (scev, loop->num);\n+  step = evolution_part_in_loop_num (scev, loop->num);\n+\n+  if (!base || !step\n+      || TREE_CODE (step) != INTEGER_CST\n+      || tree_contains_chrecs (base, NULL)\n+      || chrec_contains_symbols_defined_in_loop (base, loop->num))\n+    return;\n+\n+  low = lower_bound_in_type (type, type);\n+  high = upper_bound_in_type (type, type);\n+\n+  record_nonwrapping_iv (loop, base, step, stmt, low, high, false);\n+}\n+\n /* The following analyzers are extracting informations on the bounds\n    of LOOP from the following undefined behaviors:\n \n@@ -1714,104 +1953,31 @@ static void\n infer_loop_bounds_from_undefined (struct loop *loop)\n {\n   unsigned i;\n-  basic_block bb, *bbs;\n+  basic_block *bbs;\n   block_stmt_iterator bsi;\n+  basic_block bb;\n   \n   bbs = get_loop_body (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       bb = bbs[i];\n \n+      /* If BB is not executed in each iteration of the loop, we cannot\n+\t use it to infer any information about # of iterations of the loop.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\tcontinue;\n+\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-        {\n+\t{\n \t  tree stmt = bsi_stmt (bsi);\n \n-\t  switch (TREE_CODE (stmt))\n-\t    {\n-\t    case MODIFY_EXPR:\n-\t      {\n-\t\ttree op0 = TREE_OPERAND (stmt, 0);\n-\t\ttree op1 = TREE_OPERAND (stmt, 1);\n-\n-\t\t/* For each array access, analyze its access function\n-\t\t   and record a bound on the loop iteration domain.  */\n-\t\tif (TREE_CODE (op1) == ARRAY_REF \n-\t\t    && !array_ref_contains_indirect_ref (op1))\n-\t\t  estimate_iters_using_array (stmt, op1);\n-\n-\t\tif (TREE_CODE (op0) == ARRAY_REF \n-\t\t    && !array_ref_contains_indirect_ref (op0))\n-\t\t  estimate_iters_using_array (stmt, op0);\n-\n-\t\t/* For each signed type variable in LOOP, analyze its\n-\t\t   scalar evolution and record a bound of the loop\n-\t\t   based on the type's ranges.  */\n-\t\telse if (!flag_wrapv && TREE_CODE (op0) == SSA_NAME)\n-\t\t  {\n-\t\t    tree init, step, diff, estimation;\n-\t\t    tree scev = instantiate_parameters \n-\t\t      (loop, analyze_scalar_evolution (loop, op0));\n-\t\t    tree type = chrec_type (scev);\n-\n-\t\t    if (chrec_contains_undetermined (scev)\n-\t\t\t|| TYPE_UNSIGNED (type))\n-\t\t      break;\n-\n-\t\t    init = initial_condition_in_loop_num (scev, loop->num);\n-\t\t    step = evolution_part_in_loop_num (scev, loop->num);\n-\n-\t\t    if (init == NULL_TREE\n-\t\t\t|| step == NULL_TREE\n-\t\t\t|| TREE_CODE (init) != INTEGER_CST\n-\t\t\t|| TREE_CODE (step) != INTEGER_CST\n-\t\t\t|| TYPE_MIN_VALUE (type) == NULL_TREE\n-\t\t\t|| TYPE_MAX_VALUE (type) == NULL_TREE)\n-\t\t      break;\n-\n-\t\t    if (integer_nonzerop (step))\n-\t\t      {\n-\t\t\ttree utype;\n-\n-\t\t\tif (tree_int_cst_lt (step, integer_zero_node))\n-\t\t\t  diff = fold_build2 (MINUS_EXPR, type, init,\n-\t\t\t\t\t      TYPE_MIN_VALUE (type));\n-\t\t\telse\n-\t\t\t  diff = fold_build2 (MINUS_EXPR, type,\n-\t\t\t\t\t      TYPE_MAX_VALUE (type), init);\n-\n-\t\t\tutype = unsigned_type_for (type);\n-\t\t\testimation = fold_build2 (CEIL_DIV_EXPR, type, diff,\n-\t\t\t\t\t\t  step);\n-\t\t\trecord_estimate (loop,\n-\t\t\t\t\t fold_convert (utype, estimation),\n-\t\t\t\t\t boolean_true_node, stmt);\n-\t\t      }\n-\t\t  }\n-\n-\t\tbreak;\n-\t      }\n-\n-\t    case CALL_EXPR:\n-\t      {\n-\t\ttree args;\n-\n-\t\tfor (args = TREE_OPERAND (stmt, 1); args;\n-\t\t     args = TREE_CHAIN (args))\n-\t\t  if (TREE_CODE (TREE_VALUE (args)) == ARRAY_REF\n-\t\t      && !array_ref_contains_indirect_ref (TREE_VALUE (args)))\n-\t\t    estimate_iters_using_array (stmt, TREE_VALUE (args));\n-\n-\t\tbreak;\n-\t      }\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n+\t  infer_loop_bounds_from_array (loop, stmt);\n+\t  infer_loop_bounds_from_signedness (loop, stmt);\n+  \t}\n+\n     }\n \n-  compute_estimated_nb_iterations (loop);\n   free (bbs);\n }\n \n@@ -1826,13 +1992,9 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n   struct tree_niter_desc niter_desc;\n \n   /* Give up if we already have tried to compute an estimation.  */\n-  if (loop->estimated_nb_iterations == chrec_dont_know\n-      /* Or when we already have an estimation.  */\n-      || (loop->estimated_nb_iterations != NULL_TREE\n-\t  && TREE_CODE (loop->estimated_nb_iterations) == INTEGER_CST))\n+  if (loop->estimate_state != EST_NOT_COMPUTED)\n     return;\n-  else\n-    loop->estimated_nb_iterations = chrec_dont_know;\n+  loop->estimate_state = EST_NOT_AVAILABLE;\n \n   exits = get_loop_exit_edges (loop, &n_exits);\n   for (i = 0; i < n_exits; i++)\n@@ -1842,19 +2004,19 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \n       niter = niter_desc.niter;\n       type = TREE_TYPE (niter);\n-      if (!zero_p (niter_desc.may_be_zero)\n-\t  && !nonzero_p (niter_desc.may_be_zero))\n+      if (TREE_CODE (niter_desc.may_be_zero) != INTEGER_CST)\n \tniter = build3 (COND_EXPR, type, niter_desc.may_be_zero,\n \t\t\tbuild_int_cst (type, 0),\n \t\t\tniter);\n       record_estimate (loop, niter,\n \t\t       niter_desc.additional_info,\n-\t\t       last_stmt (exits[i]->src));\n+\t\t       last_stmt (exits[i]->src),\n+\t\t       true, true);\n     }\n   free (exits);\n   \n-  if (chrec_contains_undetermined (loop->estimated_nb_iterations))\n-    infer_loop_bounds_from_undefined (loop);\n+  infer_loop_bounds_from_undefined (loop);\n+  compute_estimated_nb_iterations (loop);\n }\n \n /* Records estimates on numbers of iterations of LOOPS.  */\n@@ -1899,40 +2061,67 @@ stmt_dominates_stmt_p (tree s1, tree s2)\n }\n \n /* Returns true when we can prove that the number of executions of\n-   STMT in the loop is at most NITER, according to the fact\n-   that the statement NITER_BOUND->at_stmt is executed at most\n-   NITER_BOUND->bound times.  */\n+   STMT in the loop is at most NITER, according to the bound on\n+   the number of executions of the statement NITER_BOUND->stmt recorded in\n+   NITER_BOUND.  If STMT is NULL, we must prove this bound for all\n+   statements in the loop.  */\n \n static bool\n n_of_executions_at_most (tree stmt,\n \t\t\t struct nb_iter_bound *niter_bound, \n \t\t\t tree niter)\n {\n-  tree cond;\n-  tree bound = niter_bound->bound;\n-  tree bound_type = TREE_TYPE (bound);\n+  double_int bound = niter_bound->bound;\n   tree nit_type = TREE_TYPE (niter);\n   enum tree_code cmp;\n \n-  gcc_assert (TYPE_UNSIGNED (bound_type)\n-\t      && TYPE_UNSIGNED (nit_type)\n-\t      && is_gimple_min_invariant (bound));\n-  if (TYPE_PRECISION (nit_type) > TYPE_PRECISION (bound_type))\n-    bound = fold_convert (nit_type, bound);\n-  else\n-    niter = fold_convert (bound_type, niter);\n-\n-  /* After the statement niter_bound->at_stmt we know that anything is\n-     executed at most BOUND times.  */\n-  if (stmt && stmt_dominates_stmt_p (niter_bound->at_stmt, stmt))\n-    cmp = GE_EXPR;\n-  /* Before the statement niter_bound->at_stmt we know that anything\n-     is executed at most BOUND + 1 times.  */\n+  gcc_assert (TYPE_UNSIGNED (nit_type));\n+\n+  /* If the bound does not even fit into NIT_TYPE, it cannot tell us that\n+     the number of iterations is small.  */\n+  if (!double_int_fits_to_tree_p (nit_type, bound))\n+    return false;\n+\n+  /* We know that NITER_BOUND->stmt is executed at most NITER_BOUND->bound + 1\n+     times.  This means that:\n+     \n+     -- if NITER_BOUND->is_exit is true, then everything before\n+        NITER_BOUND->stmt is executed at most NITER_BOUND->bound + 1\n+\ttimes, and everyting after it at most NITER_BOUND->bound times.\n+\n+     -- If NITER_BOUND->is_exit is false, then if we can prove that when STMT\n+\tis executed, then NITER_BOUND->stmt is executed as well in the same\n+\titeration (we conclude that if both statements belong to the same\n+\tbasic block, or if STMT is after NITER_BOUND->stmt), then STMT\n+\tis executed at most NITER_BOUND->bound + 1 times.  Otherwise STMT is\n+\texecuted at most NITER_BOUND->bound + 2 times.  */\n+\n+  if (niter_bound->is_exit)\n+    {\n+      if (stmt\n+\t  && stmt != niter_bound->stmt\n+\t  && stmt_dominates_stmt_p (niter_bound->stmt, stmt))\n+\tcmp = GE_EXPR;\n+      else\n+\tcmp = GT_EXPR;\n+    }\n   else\n-    cmp = GT_EXPR;\n+    {\n+      if (!stmt\n+\t  || (bb_for_stmt (stmt) != bb_for_stmt (niter_bound->stmt)\n+\t      && !stmt_dominates_stmt_p (niter_bound->stmt, stmt)))\n+\t{\n+\t  bound = double_int_add (bound, double_int_one);\n+\t  if (double_int_zero_p (bound)\n+\t      || !double_int_fits_to_tree_p (nit_type, bound))\n+\t    return false;\n+\t}\n+      cmp = GT_EXPR;\n+    }\n \n-  cond = fold_binary (cmp, boolean_type_node, niter, bound);\n-  return nonzero_p (cond);\n+  return nonzero_p (fold_binary (cmp, boolean_type_node,\n+\t\t\t\t niter,\n+\t\t\t\t double_int_to_tree (nit_type, bound)));\n }\n \n /* Returns true if the arithmetics in TYPE can be assumed not to wrap.  */\n@@ -2042,7 +2231,7 @@ free_numbers_of_iterations_estimates_loop (struct loop *loop)\n   struct nb_iter_bound *bound, *next;\n \n   loop->nb_iterations = NULL;\n-  loop->estimated_nb_iterations = NULL;\n+  loop->estimate_state = EST_NOT_COMPUTED;\n   for (bound = loop->bounds; bound; bound = next)\n     {\n       next = bound->next;\n@@ -2075,6 +2264,4 @@ void\n substitute_in_loop_info (struct loop *loop, tree name, tree val)\n {\n   loop->nb_iterations = simplify_replace_tree (loop->nb_iterations, name, val);\n-  loop->estimated_nb_iterations\n-\t  = simplify_replace_tree (loop->estimated_nb_iterations, name, val);\n }"}]}