{"sha": "f590cca17451068b993f1202bf3167a36d131fdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU5MGNjYTE3NDUxMDY4Yjk5M2YxMjAyYmYzMTY3YTM2ZDEzMWZkYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-29T01:56:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-29T01:56:04Z"}, "message": "rtl.h: Redistribute enum reg_note documentation.\n\n        * rtl.h: Redistribute enum reg_note documentation.\n        Kill trailing whitespace.\n        * rtl.c (reg_note_name): Adjust to match enum reg_note tweeks.\n        Kill trailing whitespace.\n\nFrom-SVN: r32795", "tree": {"sha": "15e5aa70478814008fb443b15234dd54801a7977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e5aa70478814008fb443b15234dd54801a7977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f590cca17451068b993f1202bf3167a36d131fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f590cca17451068b993f1202bf3167a36d131fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f590cca17451068b993f1202bf3167a36d131fdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f590cca17451068b993f1202bf3167a36d131fdb/comments", "author": null, "committer": null, "parents": [{"sha": "867580ce463bb435a5f05bf9c1fcabf0ab0ddf73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867580ce463bb435a5f05bf9c1fcabf0ab0ddf73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867580ce463bb435a5f05bf9c1fcabf0ab0ddf73"}], "stats": {"total": 303, "additions": 177, "deletions": 126}, "files": [{"sha": "217f91d514693fa663890fe3b0393eb7c04bf017", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f590cca17451068b993f1202bf3167a36d131fdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f590cca17451068b993f1202bf3167a36d131fdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f590cca17451068b993f1202bf3167a36d131fdb", "patch": "@@ -1,3 +1,10 @@\n+2000-03-28  Richard Henderson  <rth@cygnus.com>\n+\n+\t* rtl.h: Redistribute enum reg_note documentation. \n+\tKill trailing whitespace.\n+\t* rtl.c (reg_note_name): Adjust to match enum reg_note tweeks.\n+\tKill trailing whitespace.\n+\n 2000-03-28  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppfiles.c (hash_IHASH): Just return i->hash."}, {"sha": "5f0073ddaa2b5dfccc70de8675ae2a000ab0d7c5", "filename": "gcc/rtl.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f590cca17451068b993f1202bf3167a36d131fdb/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f590cca17451068b993f1202bf3167a36d131fdb/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=f590cca17451068b993f1202bf3167a36d131fdb", "patch": "@@ -188,7 +188,7 @@ const enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS] = {\n     /* MODE_COMPLEX_INT */\tCQImode,\n     /* MODE_COMPLEX_FLOAT */\tQCmode\n };\n-\t\t\t\n+\n \n /* Indexed by rtx code, gives a sequence of operand-types for\n    rtx's of that code.  The sequence is a C string in which\n@@ -228,34 +228,38 @@ const char * const rtx_format[] = {\n    that rtx code.  See rtl.def for documentation on the defined classes.  */\n \n const char rtx_class[] = {\n-#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   CLASS, \n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   CLASS,\n #include \"rtl.def\"\t\t/* rtl expressions are defined here */\n #undef DEF_RTL_EXPR\n };\n \n /* Names for kinds of NOTEs and REG_NOTEs.  */\n \n-const char * const note_insn_name[] = { 0       , \"NOTE_INSN_DELETED\",\n-\t\t\t   \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n-\t\t\t   \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n-\t\t\t   \"NOTE_INSN_FUNCTION_END\", \"NOTE_INSN_SETJMP\",\n-\t\t\t   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\",\n-\t\t\t   \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\",\n-\t\t\t   \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n-\t\t\t   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n-\t\t\t   \"NOTE_REPEATED_LINE_NUMBER\", \"NOTE_INSN_RANGE_START\",\n-\t\t\t   \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\",\n-\t\t\t   \"NOTE_INSN_BASIC_BLOCK\" };\n-\n-const char * const reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n-\t\t\t  \"REG_EQUAL\", \"REG_RETVAL\", \"REG_LIBCALL\",\n-\t\t\t  \"REG_NONNEG\", \"REG_NO_CONFLICT\", \"REG_UNUSED\",\n-\t\t\t  \"REG_CC_SETTER\", \"REG_CC_USER\", \"REG_LABEL\",\n-\t\t\t  \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\", \"REG_BR_PROB\",\n-\t\t\t  \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\",\n-\t\t\t  \"REG_BR_PRED\", \"REG_EH_CONTEXT\",\n-\t\t\t  \"REG_FRAME_RELATED_EXPR\", \"REG_EH_REGION\",\n-\t\t\t  \"REG_EH_RETHROW\", \"REG_SAVE_NOTE\" };\n+const char * const note_insn_name[] =\n+{\n+  0, \"NOTE_INSN_DELETED\",\n+  \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n+  \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n+  \"NOTE_INSN_FUNCTION_END\", \"NOTE_INSN_SETJMP\",\n+  \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\",\n+  \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\",\n+  \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n+  \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n+  \"NOTE_REPEATED_LINE_NUMBER\", \"NOTE_INSN_RANGE_START\",\n+  \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\",\n+  \"NOTE_INSN_BASIC_BLOCK\"\n+};\n+\n+const char * const reg_note_name[] =\n+{\n+  \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_EQUAL\",\n+  \"REG_WAS_0\", \"REG_RETVAL\", \"REG_LIBCALL\", \"REG_NONNEG\",\n+  \"REG_NO_CONFLICT\", \"REG_UNUSED\", \"REG_CC_SETTER\", \"REG_CC_USER\",\n+  \"REG_LABEL\", \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\", \"REG_BR_PROB\",\n+  \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\", \"REG_BR_PRED\",\n+  \"REG_FRAME_RELATED_EXPR\", \"REG_EH_CONTEXT\", \"REG_EH_REGION\",\n+  \"REG_EH_RETHROW\", \"REG_SAVE_NOTE\"\n+};\n \n static void fatal_with_file_and_line PARAMS ((FILE *, const char *, ...))\n   ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n@@ -271,7 +275,7 @@ rtvec_alloc (n)\n      int n;\n {\n   rtvec rt;\n- \n+\n   if (ggc_p)\n     rt = ggc_alloc_rtvec (n);\n   else\n@@ -311,7 +315,7 @@ rtx_alloc (code)\n \n       /* This function is called more than any other in GCC, so we\n \t manipulate the obstack directly.\n-       \n+\n \t Even though rtx objects are word aligned, we may be sharing\n \t an obstack with tree nodes, which may have to be double-word\n \t aligned.  So align our length to the alignment mask in the\n@@ -451,7 +455,7 @@ copy_rtx (orig)\n \tcase '0':\n \t  /* These are left unchanged.  */\n \t  break;\n-\t  \n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -498,7 +502,7 @@ copy_most_rtx (orig, may_share)\n   copy->volatil = orig->volatil;\n   copy->unchanging = orig->unchanging;\n   copy->integrated = orig->integrated;\n-  \n+\n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n   for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n@@ -771,7 +775,7 @@ read_skip_spaces (infile)\n \t  break;\n \n \tcase ';':\n-\t  do \n+\t  do\n \t    c = getc (infile);\n \t  while (c != '\\n' && c != EOF);\n \t  read_rtx_lineno++;\n@@ -783,7 +787,7 @@ read_skip_spaces (infile)\n \t    c = getc (infile);\n \t    if (c != '*')\n \t      fatal_expected_char (infile, '*', c);\n-\t  \n+\n \t    prevc = 0;\n \t    while ((c = getc (infile)) && c != EOF)\n \t      {\n@@ -977,7 +981,7 @@ read_rtx (infile)\n \t    break;\n  \t  }\n \t/* Now process the vector.  */\n-  \n+\n       case 'E':\n \t{\n \t  register struct rtx_list *next_rtx, *rtx_list_link;\n@@ -1088,7 +1092,7 @@ read_rtx (infile)\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n \ttmp_wide = atol (tmp_char);\n #else\n-\t/* Prefer atoll over atoq, since the former is in the ISO C9X draft. \n+\t/* Prefer atoll over atoq, since the former is in the ISO C9X draft.\n \t   But prefer not to use our hand-rolled function above either.  */\n #if defined(HAVE_ATOLL) || !defined(HAVE_ATOQ)\n \ttmp_wide = atoll (tmp_char);"}, {"sha": "27b2a8901364caee19abc667956f2608a278eba6", "filename": "gcc/rtl.h", "status": "modified", "additions": 135, "deletions": 95, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f590cca17451068b993f1202bf3167a36d131fdb/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f590cca17451068b993f1202bf3167a36d131fdb/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f590cca17451068b993f1202bf3167a36d131fdb", "patch": "@@ -149,7 +149,7 @@ typedef struct rtx_def\n      0 if the MEM was a variable or the result of a * operator in C;\n      1 if it was the result of a . or -> operator (on a struct) in C.\n      1 in a REG if the register is used only in exit code a loop.\n-     1 in a SUBREG expression if was generated from a variable with a \n+     1 in a SUBREG expression if was generated from a variable with a\n      promoted mode.\n      1 in a CODE_LABEL if the label is used for nonlocal gotos\n      and must not be deleted even if its count is zero.\n@@ -163,7 +163,7 @@ typedef struct rtx_def\n   unsigned int in_struct : 1;\n   /* 1 if this rtx is used.  This is used for copying shared structure.\n      See `unshare_all_rtl'.\n-     In a REG, this is not needed for that purpose, and used instead \n+     In a REG, this is not needed for that purpose, and used instead\n      in `leaf_renumber_regs_insn'.\n      In a SYMBOL_REF, means that emit_library_call\n      has used it as the function.  */\n@@ -174,7 +174,7 @@ typedef struct rtx_def\n   unsigned integrated : 1;\n   /* 1 in an INSN or a SET if this rtx is related to the call frame,\n      either changing how we compute the frame address or saving and\n-     restoring registers in the prologue and epilogue.  \n+     restoring registers in the prologue and epilogue.\n      1 in a MEM if the MEM refers to a scalar, rather than a member of\n      an aggregate.  */\n   unsigned frame_related : 1;\n@@ -398,101 +398,141 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n    clear, the insn should be executed only if the branch is not taken.  */\n #define INSN_FROM_TARGET_P(INSN) ((INSN)->in_struct)\n \n+#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n+\n+#define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n+\n /* Holds a list of notes on what this insn does to various REGs.\n-   It is a chain of EXPR_LIST rtx's, where the second operand\n-   is the chain pointer and the first operand is the REG being described.\n+   It is a chain of EXPR_LIST rtx's, where the second operand is the\n+   chain pointer and the first operand is the REG being described.\n    The mode field of the EXPR_LIST contains not a real machine mode\n-   but a value that says what this note says about the REG:\n-     REG_DEAD means that the value in REG dies in this insn (i.e., it is\n-   not needed past this insn).  If REG is set in this insn, the REG_DEAD\n-   note may, but need not, be omitted.\n-     REG_INC means that the REG is autoincremented or autodecremented.\n-     REG_EQUIV describes the insn as a whole; it says that the insn\n-   sets a register to a constant value or to be equivalent to a memory\n-   address.  If the register is spilled to the stack then the constant\n-   value should be substituted for it.  The contents of the REG_EQUIV\n-   is the constant value or memory address, which may be different\n-   from the source of the SET although it has the same value.  A\n-   REG_EQUIV note may also appear on an insn which copies a register\n-   parameter to a pseudo-register, if there is a memory address which\n-   could be used to hold that pseudo-register throughout the function.\n-     REG_EQUAL is like REG_EQUIV except that the destination\n-   is only momentarily equal to the specified rtx.  Therefore, it\n-   cannot be used for substitution; but it can be used for cse.\n-     REG_RETVAL means that this insn copies the return-value of\n-   a library call out of the hard reg for return values.  This note\n-   is actually an INSN_LIST and it points to the first insn involved\n-   in setting up arguments for the call.  flow.c uses this to delete\n-   the entire library call when its result is dead.\n-     REG_LIBCALL is the inverse of REG_RETVAL: it goes on the first insn\n-   of the library call and points at the one that has the REG_RETVAL.\n-     REG_WAS_0 says that the register set in this insn held 0 before the insn.\n-   The contents of the note is the insn that stored the 0.\n-   If that insn is deleted or patched to a NOTE, the REG_WAS_0 is inoperative.\n-   The REG_WAS_0 note is actually an INSN_LIST, not an EXPR_LIST.\n-     REG_NONNEG means that the register is always nonnegative during\n-   the containing loop.  This is used in branches so that decrement and\n-   branch instructions terminating on zero can be matched.  There must be\n-   an insn pattern in the md file named `decrement_and_branch_until_zero'\n-   or else this will never be added to any instructions.\n-     REG_NO_CONFLICT means there is no conflict *after this insn*\n-   between the register in the note and the destination of this insn.\n-     REG_UNUSED identifies a register set in this insn and never used.\n-     REG_CC_SETTER and REG_CC_USER link a pair of insns that set and use\n-   CC0, respectively.  Normally, these are required to be consecutive insns,\n-   but we permit putting a cc0-setting insn in the delay slot of a branch\n-   as long as only one copy of the insn exists.  In that case, these notes\n-   point from one to the other to allow code generation to determine what\n-   any require information and to properly update CC_STATUS.\n-     REG_LABEL points to a CODE_LABEL.  Used by non-JUMP_INSNs to\n-   say that the CODE_LABEL contained in the REG_LABEL note is used\n-   by the insn.\n-     REG_DEP_ANTI is used in LOG_LINKS which represent anti (write after read)\n-   dependencies.  REG_DEP_OUTPUT is used in LOG_LINKS which represent output\n-   (write after write) dependencies.  Data dependencies, which are the only\n-   type of LOG_LINK created by flow, are represented by a 0 reg note kind.  */\n-/*   REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs when the flag\n-   -fbranch-probabilities is given.  It has an integer value.  For jumps,\n-   it is the probability that this is a taken branch.  For calls, it is the\n-   probability that this call won't return.\n-     REG_EXEC_COUNT is attached to the first insn of each basic block, and\n-   the first insn after each CALL_INSN.  It indicates how many times this\n-   block was executed.\n-     REG_SAVE_AREA is used to optimize rtl generated by dynamic stack\n-   allocations for targets where SETJMP_VIA_SAVE_AREA is true.\n-     REG_BR_PRED is attached to JUMP_INSNs only, it holds the branch prediction\n-   flags computed by get_jump_flags() after dbr scheduling is complete.\n-     REG_FRAME_RELATED_EXPR is attached to insns that are RTX_FRAME_RELATED_P,\n-   but are too complex for DWARF to interpret what they imply.  The attached\n-   rtx is used instead of intuition.\n-     REG_EH_REGION is used to indicate what exception region an INSN\n-   belongs in.  This can be used to indicate what region a call may throw\n-   to. a REGION of 0 indicates that a call cannot throw at all.\n-   a REGION  of -1 indicates that it cannot throw, nor will it execute\n-   a non-local goto.\n-     REG_EH_RETHROW is used to indicate that a call is actually a\n-   call to rethrow, and specifies the rethrow symbol for the region \n-   the rethrow is targetting.  This provides a way to generate the \n-   non standard flow edges required for a rethrow.\n-     REG_SAVE_NOTE is used by haifa-sched to save NOTE_INSN notes \n-   across scheduling.  */\n+   but a value from enum reg_note.  */\n \n #define REG_NOTES(INSN)\tXEXP(INSN, 6)\n \n-#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n-\n-#define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n-\n /* Don't forget to change reg_note_name in rtl.c.  */\n-enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n-\t\tREG_EQUAL = 5, REG_RETVAL = 6, REG_LIBCALL = 7,\n-\t\tREG_NONNEG = 8, REG_NO_CONFLICT = 9, REG_UNUSED = 10,\n-\t\tREG_CC_SETTER = 11, REG_CC_USER = 12, REG_LABEL = 13,\n-\t\tREG_DEP_ANTI = 14, REG_DEP_OUTPUT = 15, REG_BR_PROB = 16,\n-\t\tREG_EXEC_COUNT = 17, REG_NOALIAS = 18, REG_SAVE_AREA = 19,\n-\t\tREG_BR_PRED = 20, REG_EH_CONTEXT = 21,\n-\t\tREG_FRAME_RELATED_EXPR = 22, REG_EH_REGION = 23,\n-\t\tREG_EH_RETHROW = 24, REG_SAVE_NOTE = 25 };\n+enum reg_note\n+{\n+  /* The value in REG dies in this insn (i.e., it is not needed past\n+     this insn).  If REG is set in this insn, the REG_DEAD note may,\n+     but need not, be omitted.  */\n+  REG_DEAD = 1,\n+\n+  /* The REG is autoincremented or autodecremented.  */\n+  REG_INC,\n+\n+  /* Describes the insn as a whole; it says that the insn sets a register\n+     to a constant value or to be equivalent to a memory address.  If the\n+     register is spilled to the stack then the constant value should be\n+     substituted for it.  The contents of the REG_EQUIV is the constant\n+     value or memory address, which may be different from the source of\n+     the SET although it has the same value.  A REG_EQUIV note may also\n+     appear on an insn which copies a register parameter to a pseudo-register,\n+     if there is a memory address which could be used to hold that\n+     pseudo-register throughout the function.  */\n+   REG_EQUIV,\n+\n+  /* Like REG_EQUIV except that the destination is only momentarily equal\n+     to the specified rtx.  Therefore, it cannot be used for substitution;\n+     but it can be used for cse.  */\n+  REG_EQUAL,\n+\n+  /* The register set in this insn held 0 before the insn.  The contents of\n+     the note is the insn that stored the 0.  If that insn is deleted or\n+     patched to a NOTE, the REG_WAS_0 is inoperative.  The REG_WAS_0 note\n+     is actually an INSN_LIST, not an EXPR_LIST.  */\n+  REG_WAS_0,\n+\n+  /* This insn copies the return-value of a library call out of the hard reg\n+     for return values.  This note is actually an INSN_LIST and it points to\n+     the first insn involved in setting up arguments for the call.  flow.c\n+     uses this to delete the entire library call when its result is dead.  */\n+  REG_RETVAL,\n+\n+  /* The inverse of REG_RETVAL: it goes on the first insn of the library call\n+     and points at the one that has the REG_RETVAL.  */\n+  REG_LIBCALL,\n+\n+  /* The register is always nonnegative during the containing loop.  This is\n+     used in branches so that decrement and branch instructions terminating\n+     on zero can be matched.  There must be an insn pattern in the md file\n+     named `decrement_and_branch_until_zero' or else this will never be added\n+     to any instructions.  */\n+  REG_NONNEG,\n+\n+  /* There is no conflict *after this insn* between the register in the note\n+     and the destination of this insn.  */\n+  REG_NO_CONFLICT,\n+\n+  /* Identifies a register set in this insn and never used.  */\n+  REG_UNUSED,\n+\n+  /* REG_CC_SETTER and REG_CC_USER link a pair of insns that set and use CC0,\n+     respectively.  Normally, these are required to be consecutive insns, but\n+     we permit putting a cc0-setting insn in the delay slot of a branch as\n+     long as only one copy of the insn exists.  In that case, these notes\n+     point from one to the other to allow code generation to determine what\n+     any require information and to properly update CC_STATUS.  */\n+  REG_CC_SETTER, REG_CC_USER,\n+\n+  /* Points to a CODE_LABEL.  Used by non-JUMP_INSNs to say that the\n+     CODE_LABEL contained in the REG_LABEL note is used by the insn.  */\n+  REG_LABEL,\n+\n+  /* REG_DEP_ANTI and REG_DEP_OUTPUT are used in LOG_LINKS to represent\n+     write-after-read and write-after-write dependencies respectively.\n+     Data dependencies, which are the only type of LOG_LINK created by\n+     flow, are represented by a 0 reg note kind.  */\n+  REG_DEP_ANTI, REG_DEP_OUTPUT,\n+\n+  /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs when the flag\n+     -fbranch-probabilities is given.  It has an integer value.  For jumps,\n+     it is the probability that this is a taken branch.  For calls, it is\n+     the probability that this call won't return.  */\n+  REG_BR_PROB,\n+\n+  /* REG_EXEC_COUNT is attached to the first insn of each basic block, and\n+     the first insn after each CALL_INSN.  It indicates how many times this\n+     block was executed.  */\n+  REG_EXEC_COUNT,\n+\n+  /* Attached to a call insn; indicates that the call is malloc-like and\n+     that the pointer returned cannot alias anything else.  */\n+  REG_NOALIAS,\n+\n+  /* Used to optimize rtl generated by dynamic stack allocations for targets\n+     where SETJMP_VIA_SAVE_AREA is true.  */\n+  REG_SAVE_AREA,\n+\n+  /* Attached to JUMP_INSNs only, it holds the branch prediction flags\n+     computed by get_jump_flags() after dbr scheduling is complete.  */\n+  REG_BR_PRED,\n+\n+  /* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n+     for DWARF to interpret what they imply.  The attached rtx is used\n+     instead of intuition.  */\n+  REG_FRAME_RELATED_EXPR,\n+\n+  /* Indicates that REG holds the exception context for the function.\n+     This context is shared by inline functions, so the code to acquire\n+     the real exception context is delayed until after inlining.  */\n+  REG_EH_CONTEXT,\n+\n+  /* Indicates what exception region an INSN belongs in.  This is used to\n+     indicate what region to which a call may throw.  REGION 0 indicates\n+     that a call cannot throw at all.  REGION -1 indicates that it cannot\n+     throw, nor will it execute a non-local goto.  */\n+  REG_EH_REGION,\n+\n+  /* Indicates that a call is actually a call to rethrow, and specifies the\n+     rethrow symbol for the region the rethrow is targetting.  This provides\n+     a way to generate the non standard flow edges required for a rethrow.  */\n+  REG_EH_RETHROW,\n+\n+  /* Used by haifa-sched to save NOTE_INSN notes across scheduling.  */\n+  REG_SAVE_NOTE\n+};\n+\n /* The base value for branch probability notes.  */\n #define REG_BR_PROB_BASE  10000\n \n@@ -667,7 +707,7 @@ extern const char * const note_insn_name[];\n /* 1 if the REG contained in SUBREG_REG is already known to be\n    sign- or zero-extended from the mode of the SUBREG to the mode of\n    the reg.  SUBREG_PROMOTED_UNSIGNED_P gives the signedness of the\n-   extension.  \n+   extension.\n \n    When used as a LHS, is means that this extension must be done\n    when assigning to SUBREG_REG.  */\n@@ -1211,7 +1251,7 @@ extern rtx const_true_rtx;\n \n extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n \n-/* Returns a constant 0 rtx in mode MODE.  Integer modes are treated the \n+/* Returns a constant 0 rtx in mode MODE.  Integer modes are treated the\n    same as VOIDmode.  */\n \n #define CONST0_RTX(MODE) (const_tiny_rtx[0][(int) (MODE)])\n@@ -1351,7 +1391,7 @@ extern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n /* This points to the Canonical Frame Address of the function.  This\n    should corrospond to the CFA produced by INCOMING_FRAME_SP_OFFSET,\n    but is calculated relative to the arg pointer for simplicity; the\n-   frame pointer nor stack pointer are necessarily fixed relative to \n+   frame pointer nor stack pointer are necessarily fixed relative to\n    the CFA until after reload.  */\n \n #define virtual_cfa_rtx\t\t\t(global_rtl[GR_VIRTUAL_CFA])"}]}