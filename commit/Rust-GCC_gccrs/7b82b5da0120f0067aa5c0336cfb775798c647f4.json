{"sha": "7b82b5da0120f0067aa5c0336cfb775798c647f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I4MmI1ZGEwMTIwZjAwNjdhYTVjMDMzNmNmYjc3NTc5OGM2NDdmNA==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "2000-04-05T00:32:45Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "2000-04-05T00:32:45Z"}, "message": "Makefile.in: Add rules for regrename.o\n\n\t* Makefile.in: Add rules for regrename.o\n\t* regrename.c: New file.\n\t* rtl.h (regrename_optimize): Add prototype.\n\t* toplev.c (rename_registers_dump, flag_rename_registers): New variables\n\t(compile_file, decode_d_option): Add support for -frename-registers.\n\t(rest_of_compilation): Call regrename_optimize.\n\t* config/ia64/ia64.h (HARD_REGNO_RENAME_OK, RENAME_EXTENDED_BLOCKS):\n\tNew macros.\n\nFrom-SVN: r32916", "tree": {"sha": "3b440c8f91e2f3a86ca5106dfeec068cceaf1350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b440c8f91e2f3a86ca5106dfeec068cceaf1350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b82b5da0120f0067aa5c0336cfb775798c647f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b82b5da0120f0067aa5c0336cfb775798c647f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b82b5da0120f0067aa5c0336cfb775798c647f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b82b5da0120f0067aa5c0336cfb775798c647f4/comments", "author": null, "committer": null, "parents": [{"sha": "501a481953e55fabdc06e43dcab9972b7113bd15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501a481953e55fabdc06e43dcab9972b7113bd15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/501a481953e55fabdc06e43dcab9972b7113bd15"}], "stats": {"total": 1110, "additions": 1109, "deletions": 1}, "files": [{"sha": "c6bd4dcd59516677c6a2a8ae3048c8475d4cfede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b82b5da0120f0067aa5c0336cfb775798c647f4", "patch": "@@ -1,3 +1,14 @@\n+2000-04-04  Stan Cox  <scox@cygnus.com>\t\n+\n+\t* Makefile.in: Add rules for regrename.o\n+\t* regrename.c: New file.\n+\t* rtl.h (regrename_optimize): Add prototype.\n+\t* toplev.c (rename_registers_dump, flag_rename_registers): New variables\n+\t(compile_file, decode_d_option): Add support for -frename-registers.\n+\t(rest_of_compilation): Call regrename_optimize.\n+\t* config/ia64/ia64.h (HARD_REGNO_RENAME_OK, RENAME_EXTENDED_BLOCKS):\n+\tNew macros.\t\n+\t\n 2000-04-04  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* Makefile (gccbug): New target."}, {"sha": "17271fde601790738b056eaa04fe39fb60084fa8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7b82b5da0120f0067aa5c0336cfb775798c647f4", "patch": "@@ -675,7 +675,7 @@ OBJS = diagnostic.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o combine.o varray.o \\\n  regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n- insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o \\\n+ insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o regrename.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n@@ -1653,6 +1653,10 @@ bb-reorder.o : bb-reorder.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) insn-flags.h function.h except.h $(EXPR_H)\n \n+regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n+   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h \\\n+   $(RECOG_H) function.h resource.h\n+\n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) ggc.h \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\\n    insn-flags.h output.h insn-attr.h insn-codes.h system.h toplev.h function.h"}, {"sha": "dca777477b15b034e8dc422551cc3fd3d3002d44", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=7b82b5da0120f0067aa5c0336cfb775798c647f4", "patch": "@@ -2589,6 +2589,25 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Define to enable software floating point emulation. */\n #define REAL_ARITHMETIC\n \n+\f\n+/* Register Renaming Parameters.  */\n+\n+/* A C expression that is nonzero if hard register number REGNO2 can be\n+   considered for use as a rename register for REGNO1 */\n+\n+#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) \\\n+  ((! PR_REGNO_P (REGNO1) && ! PR_REGNO_P (REGNO2)) \t\t\t\\\n+    ? (!call_fixed_regs [REGNO1] && !call_fixed_regs [REGNO2])\t\t\\\n+      ? 1 : 0    \t\t\t\t\t\t\t\\\n+    : ((REGNO2) > 256 && ((REGNO2 & 1) == 0))\t\t\t\t\\\n+      ? 1 : 0)\n+\n+/* Define this macro if the compiler should use extended basic blocks\n+   when renaming registers.  Define this macro if the target has predicate\n+   registers.  */\n+\n+#define RENAME_EXTENDED_BLOCKS\n+\n \f\n /* Miscellaneous Parameters.  */\n "}, {"sha": "816a5d262d10012bd7ca144a275d74e3c70fb134", "filename": "gcc/regrename.c", "status": "added", "additions": 1050, "deletions": 0, "changes": 1050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=7b82b5da0120f0067aa5c0336cfb775798c647f4", "patch": "@@ -0,0 +1,1050 @@\n+/* Register renaming for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include \"resource.h\"\n+\n+static const char *const reg_class_names[] = REG_CLASS_NAMES;\n+\n+/* ??? Consider a more sparse data structure? */\n+typedef struct def_uses\n+  {\n+    /* high bound of defs and uses */\n+    int high_bound;\n+\n+    /* 1 if insn y defines a reg whose use crosses a call \n+       y is the ordinal position of the insn within the block */\n+    sbitmap require_call_save_reg;\n+\n+    /* REGNO x INSN y  1 if insn y sets reg x */\n+    sbitmap *defs;\n+\n+    /* REGNO x INSN y  The register class for this def */\n+    enum reg_class *def_class;\n+\n+    /* REGNO x INSN y  1 if insn y uses reg x */\n+    sbitmap *uses;\n+\n+    /* REGNO x INSN y  The register class for this use */\n+    enum reg_class *use_class;\n+  }\n+def_uses;\n+\n+#define DU_REG_CLASS(rc,r,high_bound,i) (rc[r * high_bound + i])\n+\n+typedef struct ext_basic_blocks\n+  {\n+    /* n_basic_blocks x n_basic_blocks y  1 if bb y is in extended bb\n+       having entry x */\n+    sbitmap *basic_block;\n+\n+    /* n_basic_blocks x n_basic_blocks y  1 if bb y is an exit block */\n+    sbitmap *exit;\n+  }\n+ext_basic_blocks;\n+\n+#define UID_RUID_HIGH_BOUND 64\n+#define DESTINATION 1\n+#define SOURCE 2\n+\n+static void build_def_use PARAMS ((int, ext_basic_blocks *, HARD_REG_SET *,\n+\t\t\t\t   def_uses *, sbitmap *));\n+static int replace_reg_in_block\n+  PARAMS ((def_uses *, varray_type *, int, rtx, int));\n+static int consider_def PARAMS ((rtx, int, def_uses *, int));\n+static int consider_available PARAMS ((rtx, int, HARD_REG_SET *, int, def_uses *, int));\n+static rtx rr_replace_reg PARAMS ((rtx, rtx, rtx, int, rtx, int *));\n+static int consider_use PARAMS ((rtx, int, int, int));\n+static int condmove_p PARAMS ((rtx));\n+static void dump_def_use_chain PARAMS ((HARD_REG_SET *, def_uses *,\n+\t\t\t\t\tvarray_type *));\n+static void dump_ext_bb_info PARAMS ((int, ext_basic_blocks *));\n+static void find_ext_basic_blocks PARAMS ((ext_basic_blocks *));\n+static void find_one_ext_basic_block PARAMS ((int, basic_block, sbitmap *,\n+\t\t\t\t\t      ext_basic_blocks *));\n+static enum reg_class get_reg_class PARAMS ((rtx, rtx, int, enum reg_class));\n+static rtx regno_first_use_in (int, rtx);\n+\n+void\n+regrename_optimize ()\n+{\n+  int b, eb, i, inum, r, rc, replace_ok;\n+  rtx insn;\n+  def_uses def_uses;\n+  ext_basic_blocks ext_basic_blocks;\n+\n+\n+  /* Registers used in a given class */\n+  HARD_REG_SET class_regs;\n+\n+  /* Registers available for use as renaming registers */\n+  HARD_REG_SET avail_regs;\n+\n+  /* Registers used in the block */\n+  HARD_REG_SET regs_used;\n+\n+  /* Registers which have been used as renaming registers */\n+  HARD_REG_SET renamed_regs;\n+\n+  HARD_REG_SET global_live_at_end, global_live_at_start;\n+\n+  HARD_REG_SET null_bitmap, tmp_bitmap;\n+\n+  /* 1 if insn y sets a register which is live at the end of the block */\n+  sbitmap defs_live_exit;\n+\n+  /* Mapping from insn y (ordinal position in block) to INSN_UID */\n+  varray_type uid_ruid;\n+\n+  /* Mapping from insn y (ordinal position in block) to block id */\n+  varray_type uid_rbid;\n+\n+  /* Ordinal position in block of defining insn */\n+  int *def_idx;\n+\n+  VARRAY_RTX_INIT (uid_ruid, UID_RUID_HIGH_BOUND + 1, \"uid_ruid\");\n+  VARRAY_LONG_INIT (uid_rbid, UID_RUID_HIGH_BOUND + 1, \"uid_rbid\");\n+\n+  ext_basic_blocks.basic_block =\n+    sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  sbitmap_vector_zero (ext_basic_blocks.basic_block, n_basic_blocks);\n+  ext_basic_blocks.exit =\n+    sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  sbitmap_vector_zero (ext_basic_blocks.exit, n_basic_blocks);\n+\n+  find_ext_basic_blocks (&ext_basic_blocks);\n+\n+  def_uses.def_class = def_uses.use_class = 0;\n+\n+  /* Build uid_ruid and uid_rbid for this extended basic block */\n+  for (b = 0; b < n_basic_blocks; b++)\n+    if (TEST_BIT (ext_basic_blocks.basic_block[b], b))\n+      {\n+\tfor (eb = def_uses.high_bound = 0; eb < n_basic_blocks; eb++)\n+\t  {\n+\t    if (TEST_BIT (ext_basic_blocks.basic_block[b], eb))\n+\t      {\n+\t\tbasic_block bb = BASIC_BLOCK (eb);\n+\t\t/* Calculate high bound for uid_ruid and allocate if necessary */\n+\t\tfor (insn = bb->head;\n+\t\t     insn != NEXT_INSN (bb->end);\n+\t\t     def_uses.high_bound++, insn = NEXT_INSN (insn))\n+\t\t  {\n+\t\t    int uid_ruid_high_bound = VARRAY_SIZE (uid_ruid);\n+\t\t    if (def_uses.high_bound + 4 >= uid_ruid_high_bound)\n+\t\t      {\n+\t\t\tVARRAY_GROW (uid_ruid, uid_ruid_high_bound * 2);\n+\t\t\tVARRAY_GROW (uid_rbid, uid_ruid_high_bound * 2);\n+\t\t      }\n+\t\t    VARRAY_RTX (uid_ruid, def_uses.high_bound) = insn;\n+\t\t    VARRAY_LONG (uid_rbid, def_uses.high_bound) = eb;\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tCLEAR_HARD_REG_SET (null_bitmap);\n+\tCLEAR_HARD_REG_SET (class_regs);\n+\tCLEAR_HARD_REG_SET (regs_used);\n+\tCLEAR_HARD_REG_SET (avail_regs);\n+\tCLEAR_HARD_REG_SET (tmp_bitmap);\n+\tCLEAR_HARD_REG_SET (renamed_regs);\n+\n+\tdef_uses.defs =\n+\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, def_uses.high_bound + 1);\n+\tsbitmap_vector_zero (def_uses.defs, FIRST_PSEUDO_REGISTER);\n+\tdef_uses.uses =\n+\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, def_uses.high_bound + 1);\n+\tsbitmap_vector_zero (def_uses.uses, FIRST_PSEUDO_REGISTER);\n+\tdef_uses.require_call_save_reg = sbitmap_alloc (def_uses.high_bound + 1);\n+\tsbitmap_zero (def_uses.require_call_save_reg);\n+\tdefs_live_exit = sbitmap_alloc (def_uses.high_bound + 1);\n+\tsbitmap_zero (defs_live_exit);\n+\n+\tdef_uses.def_class = xrealloc\n+\t  (def_uses.def_class,\n+\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * def_uses.high_bound);\n+\n+\tdef_uses.use_class = xrealloc\n+\t  (def_uses.use_class,\n+\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * def_uses.high_bound);\n+\n+\tbuild_def_use (b, &ext_basic_blocks, &regs_used, &def_uses,\n+\t\t       &defs_live_exit);\n+\n+\tif (rtl_dump_file)\n+\t  {\n+\t    dump_ext_bb_info (b, &ext_basic_blocks);\n+\t    dump_def_use_chain (&global_live_at_end, &def_uses, &uid_ruid);\n+\t  }\n+\n+\t/* Available registers are not: used in the block, live at the start,\n+\t   live at the end, a register we've renamed to. */\n+\t/* ??? The current algorithm is pessimistic for extended basic blocks\n+\t   as it just treats them as a big basic block. */\n+\n+\tCOPY_HARD_REG_SET (tmp_bitmap, regs_used);\n+\tREG_SET_TO_HARD_REG_SET (global_live_at_start, BASIC_BLOCK (b)->global_live_at_start);\n+\tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_start);\n+\tfor (eb = 0; eb < n_basic_blocks; eb++)\n+\t  {\n+\t    if (TEST_BIT (ext_basic_blocks.basic_block[b], eb))\n+\t      {\n+\t\tbasic_block bb = BASIC_BLOCK (eb);\n+\t\tREG_SET_TO_HARD_REG_SET (global_live_at_end, bb->global_live_at_end);\n+\t\tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_end);\n+\t      }\n+\t  }\n+\n+\tdef_idx = xcalloc (def_uses.high_bound, sizeof (int));\n+\n+\t/* Only consider registers in this extended block and in this class\n+\t   that are defined more than once.  Replace them if permissible. */\n+\tfor (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t  {\n+\t    int avail_reg, ar_idx, def, def_cnt = 0, use_idx, call_idx;\n+\n+\t    if (!TEST_HARD_REG_BIT (regs_used, r)\n+\t\t|| fixed_regs[r]\n+\t\t|| r == FRAME_POINTER_REGNUM)\n+\t      continue;\n+\n+\t    /* Find def_idx[N] where hbound of N is the number of \n+\t       definitions of this register in this block. and def_idx\n+\t       is the ordinal position of this insn in the block. */\n+\t    for (i = 0, def_idx[def_cnt] = 0;\n+\t\t i < def_uses.high_bound;\n+\t\t i++)\n+\t      {\n+\t\tif (TEST_BIT (def_uses.defs[r], i)\n+\t\t    && consider_def (VARRAY_RTX (uid_ruid, i), r,\n+\t\t\t\t     &def_uses, i))\n+\t\t  {\n+\t\t    int first_use = 1;\n+\t\t    def_idx[def_cnt] = i;\n+\n+\t\t    /* Only consider definitions that have a use. */\n+\t\t    for (use_idx = i + 1; use_idx < def_uses.high_bound;\n+\t\t\t use_idx++)\n+\t\t      {\n+\t\t\tif (TEST_BIT (def_uses.uses[r], use_idx))\n+\t\t\t  {\n+\t\t\t    if (consider_use (VARRAY_RTX (uid_ruid, use_idx), r,\n+\t\t\t\t\t      VARRAY_LONG (uid_rbid, i),\n+\t\t\t\t\t   VARRAY_LONG (uid_rbid, use_idx)))\n+\t\t\t      {\n+\t\t\t\tif (first_use)\n+\t\t\t\t  {\n+\t\t\t\t    first_use = 0;\n+\t\t\t\t    def_cnt++;\n+\t\t\t\t  }\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\t/* Don't consider def if we don't want this use */\n+\t\t\t\tif (!first_use)\n+\t\t\t\t  def_cnt--;\n+\t\t\t\tbreak;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\tif (TEST_BIT (def_uses.defs[r], use_idx))\n+\t\t\t  break;\n+\t\t      }\n+\t\t    /* Scan until the next def to avoid renaming\n+\t\t       parameter registers. */\n+\t\t    /* ??? consider using CALL_INSN_FUNCTION_USAGE */\n+\t\t    for (call_idx = i; call_idx <= use_idx; call_idx++)\n+\t\t      if (VARRAY_RTX (uid_ruid, call_idx)\n+\t\t\t  && GET_CODE (VARRAY_RTX (uid_ruid, call_idx))\n+\t\t\t  == CALL_INSN)\n+\t\t\t{\n+\t\t\t  SET_BIT (def_uses.require_call_save_reg, i);\n+\t\t\t}\n+\t\t  }\n+\t      }\n+\t    if (def_cnt < 2)\n+\t      continue;\n+\n+\t    /* We have more than one def so rename until we exhaust\n+\t       renaming registers. */\n+\t    /* ??? Should we continue renaming round robin when we exhaust\n+\t       renaming registers? */\n+\t    for (def = 0; def < def_cnt - 1; def++)\n+\t      {\n+\t\tif (!TEST_BIT (defs_live_exit, def_idx[def])\n+\t\t    && (GET_RTX_CLASS\n+\t\t\t(GET_CODE (VARRAY_RTX (uid_ruid,\n+\t\t\t\t\t       def_idx[def]))) == 'i'))\n+\t\t  {\n+\t\t    rtx reg_use = regno_first_use_in\n+\t\t    (r, PATTERN (VARRAY_RTX (uid_ruid, def_idx[def])));\n+\n+\t\t    if (!reg_use)\n+\t\t      break;\n+#ifdef STACK_REGS\n+\t\t    /* Don't bother with stacked float registers */\n+\t\t    if (GET_MODE_CLASS (GET_MODE (reg_use)) == MODE_FLOAT)\n+\t\t      break;\n+#endif\n+\t\t    rc = (int) DU_REG_CLASS (def_uses.def_class,\n+\t\t\t\t      r, def_uses.high_bound, def_idx[def]);\n+\t\t    COPY_HARD_REG_SET (avail_regs,\n+\t\t\t\t   reg_class_contents[(enum reg_class) rc]);\n+\t\t    AND_COMPL_HARD_REG_SET (avail_regs, tmp_bitmap);\n+\t\t    AND_COMPL_HARD_REG_SET (avail_regs, renamed_regs);\n+\n+\t\t    /* No available registers in this class */\n+\t\t    GO_IF_HARD_REG_EQUAL (avail_regs, null_bitmap,\n+\t\t\t\t\t  no_available_regs);\n+\t\t    for (ar_idx = 0; ar_idx < FIRST_PSEUDO_REGISTER\n+\t\t\t && TEST_HARD_REG_BIT (avail_regs, ar_idx); ar_idx++)\n+\t\t      ;\n+\t\t    if (ar_idx == FIRST_PSEUDO_REGISTER)\n+\t\t      goto no_available_regs;\n+\n+\t\t    /* Only try register renaming if there is an available\n+\t\t       register in this class. */\n+\t\t    for (ar_idx = 0;\n+\t\t\t ar_idx < FIRST_PSEUDO_REGISTER;\n+\t\t\t ar_idx++)\n+\t\t      {\n+\t\t\tavail_reg = reg_alloc_order[ar_idx];\n+\t\t\tif (consider_available (reg_use, avail_reg, &avail_regs,\n+\t\t\t\t\t\trc, &def_uses, def_idx[def]))\n+\t\t\t  break;\n+\t\t      }\n+\n+\t\t    if (ar_idx == FIRST_PSEUDO_REGISTER)\n+\t\t      {\n+\t\t\tif (rtl_dump_file)\n+\t\t\t  {\n+\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t\t     \"Register %s in class %s\",\n+\t\t\t\t     reg_names[r], reg_class_names[rc]);\n+\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t\t     \" in insn %d\",\n+\t\t\t\t     INSN_UID (VARRAY_RTX (uid_ruid,\n+\t\t\t\t\t\t\t   def_idx[def])));\n+\n+\t\t\t    if (TEST_BIT (def_uses.require_call_save_reg,\n+\t\t\t\t\t  def_idx[def]))\n+\t\t\t      fprintf (rtl_dump_file, \" crosses a call\");\n+\t\t\t    fprintf (rtl_dump_file, \". No available registers\\n\");\n+\t\t\t  }\n+\t\t\tgoto try_next_def;\n+\t\t      }\n+\n+\t\t    SET_HARD_REG_BIT (renamed_regs, avail_reg);\n+\t\t    CLEAR_HARD_REG_BIT (avail_regs, avail_reg);\n+\n+\t\t    /* Replace in destination.  Replace in source for\n+\t\t       remainder of block until new register is defined\n+\t\t       again */\n+\t\t    replace_ok = replace_reg_in_block\n+\t\t      (&def_uses, &uid_ruid, def_idx[def], reg_use, avail_reg);\n+\t\t    /* Replace failed, so restore previous register */\n+\t\t    if (!replace_ok)\n+\t\t      {\n+\t\t\treplace_reg_in_block (&def_uses, &uid_ruid, def_idx[def],\n+\t\t\t\t\t    gen_rtx_REG (GET_MODE (reg_use),\n+\t\t\t\t\t\t\t avail_reg),\n+\t\t\t\t\t      REGNO (reg_use));\n+\t\t\tif (rtl_dump_file)\n+\t\t\t  fprintf (rtl_dump_file,\n+\t\t\t\t   \"Register %s in class %s Renaming as %s would not satisfy constraints\\n\",\n+\t\t\t\t   reg_names[r], reg_class_names[rc],\n+\t\t\t\t   reg_names[avail_reg]);\n+\t\t      }\n+\t\t    else if (rtl_dump_file)\n+\t\t      fprintf (rtl_dump_file,\n+\t\t       \"Register %s in class %s Renamed as %s at insn %d\\n\",\n+\t\t\t       reg_names[r], reg_class_names[rc],\n+\t\t\t       reg_names[avail_reg],\n+\t\t\t    INSN_UID (VARRAY_RTX (uid_ruid, def_idx[def])));\n+\t\t  }\n+\t      try_next_def:\n+\t\tcontinue;\n+\t      }\n+\t    sbitmap_zero (def_uses.defs[r]);\n+\t  no_available_regs:\n+\t    continue;\n+\t  }\n+\tfree (def_idx);\n+\tsbitmap_vector_free (def_uses.defs);\n+\tsbitmap_vector_free (def_uses.uses);\n+\tsbitmap_free (def_uses.require_call_save_reg);\n+\tsbitmap_free (defs_live_exit);\n+\tCLEAR_HARD_REG_SET (regs_used);\n+\tCLEAR_HARD_REG_SET (renamed_regs);\n+\n+\tfor (inum = 0; inum < (int) VARRAY_SIZE (uid_ruid); inum++)\n+\t  VARRAY_RTX (uid_ruid, inum) = (rtx) 0;\n+      }\n+\n+  sbitmap_vector_free (ext_basic_blocks.basic_block);\n+  sbitmap_vector_free (ext_basic_blocks.exit);\n+}\n+\n+/* Build def/use chain DU for extended basic block EBB having root B.\n+   Also determine which regs are used, REGS_USED, and which insns define\n+   a live at exit def, DEFS_LIVE_EXIT */\n+\n+static void\n+build_def_use (b, ebb, regs_used, du, defs_live_exit)\n+     int b;\n+     ext_basic_blocks *ebb;\n+     HARD_REG_SET *regs_used;\n+     def_uses *du;\n+     sbitmap *defs_live_exit;\n+{\n+  rtx insn;\n+  int eb, inum, r;\n+\n+  inum = 0;\n+  for (eb = 0; eb < n_basic_blocks; eb++)\n+    {\n+      basic_block bb = BASIC_BLOCK (eb);\n+\n+      if (!TEST_BIT (ebb->basic_block[b], eb))\n+\tcontinue;\n+\n+      for (insn = bb->head;\n+\t   insn != NEXT_INSN (bb->end);\n+\t   inum++, insn = NEXT_INSN (insn))\n+\t{\n+\t  struct resources insn_res;\n+\t  struct resources insn_sets;\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\t    continue;\n+\n+\t  CLEAR_RESOURCE (&insn_sets);\n+\t  mark_set_resources (insn, &insn_sets, 0, MARK_DEST);\n+\n+\t  for (r = 0;\n+\t       r < FIRST_PSEUDO_REGISTER;\n+\t       r++)\n+\t    {\n+\t      if (!TEST_HARD_REG_BIT (insn_sets.regs, r))\n+\t\tcontinue;\n+\n+\t      SET_HARD_REG_BIT (*regs_used, r);\n+\t      if (REGNO_REG_SET_P (bb->global_live_at_end, r))\n+\t\tSET_BIT (*defs_live_exit, inum);\n+\t      if (!insn_sets.memory)\n+\t\tSET_BIT (du->defs[r], inum);\n+\t      DU_REG_CLASS (du->def_class, r, du->high_bound, inum) = get_reg_class\n+\t\t(insn, regno_first_use_in (r, PATTERN (insn)),\n+\t\t DESTINATION, NO_REGS);\n+\t    }\n+\n+\t  CLEAR_RESOURCE (&insn_res);\n+\t  mark_referenced_resources (insn, &insn_res, 0);\n+\n+\t  for (r = 0;\n+\t       r < FIRST_PSEUDO_REGISTER;\n+\t       r++)\n+\t    {\n+\t      if (!TEST_HARD_REG_BIT (insn_res.regs, r))\n+\t\tcontinue;\n+\n+\t      SET_HARD_REG_BIT (*regs_used, r);\n+\t      SET_BIT (du->uses[r], inum);\n+\t      DU_REG_CLASS (du->use_class, r, du->high_bound, inum) = get_reg_class\n+\t\t(insn, regno_use_in (r, PATTERN (insn)),\n+\t\t SOURCE, NO_REGS);\n+\t    }\n+\t}\n+    }\n+  free_resource_info ();\n+}\n+\n+/* Return nonzero if regno AVAIL_REG can replace REG_DEF for insns in UID_RUID\n+   starting at insn DEF in def/use chain DU. */\n+\n+static int\n+replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n+     def_uses *du;\n+     varray_type *uid_ruid;\n+     int def;\n+     rtx reg_def;\n+     int avail_reg;\n+{\n+  int du_idx, status = 1;\n+  int r = REGNO (reg_def);\n+  rtx death_note;\n+  rtx new_reg = gen_rtx_REG (GET_MODE (reg_def), avail_reg);\n+\n+\n+  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, def)), reg_def,\n+\t\t  new_reg, DESTINATION, VARRAY_RTX (*uid_ruid, def),\n+\t\t  &status);\n+  if (!status)\n+    return status;\n+\n+  death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_DEAD, reg_def);\n+  if (!death_note)\n+    death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_UNUSED, reg_def);\n+  if (death_note)\n+    rr_replace_reg (death_note, reg_def, new_reg, 0,\n+\t\t    VARRAY_RTX (*uid_ruid, def), &status);\n+\n+  for (du_idx = def + 1; du_idx < du->high_bound; du_idx++)\n+    {\n+      rtx reg_use;\n+      rtx new_reg;\n+      if (GET_RTX_CLASS (GET_CODE (VARRAY_RTX (*uid_ruid, du_idx))) != 'i')\n+\tcontinue;\n+      reg_use = regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, du_idx)));\n+\n+      if (reg_use && TEST_BIT (du->uses[r], du_idx))\n+\t{\n+\t  new_reg = gen_rtx_REG (GET_MODE (reg_use), avail_reg);\n+\t  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, du_idx)), reg_use,\n+\t\t\t  new_reg, SOURCE, VARRAY_RTX (*uid_ruid, du_idx),\n+\t\t\t  &status);\n+\t  death_note = find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n+\t\t\t\t      REG_DEAD, reg_use);\n+\t  if (!death_note)\n+\t    death_note = find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n+\t\t\t\t\tREG_UNUSED, reg_use);\n+\t  if (death_note)\n+\t    rr_replace_reg (death_note, reg_use, new_reg, 0,\n+\t\t\t    VARRAY_RTX (*uid_ruid, def), &status);\n+\t  SET_BIT (du->uses[avail_reg], du_idx);\n+\t  RESET_BIT (du->uses[r], du_idx);\n+\t  if (!status)\n+\t    return status;\n+\t}\n+      if (TEST_BIT (du->defs[r], du_idx))\n+\tbreak;\n+    }\n+  return status;\n+}\n+\n+/* Try to replace REG_USE in X with REG_SUB if INSN has a REPLACE_TYPE.\n+   STATUS is zero if the resulting pattern is not valid. */\n+\n+static rtx\n+rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n+     rtx x;\n+     rtx reg_use;\n+     rtx reg_sub;\n+     int replace_type;\n+     rtx insn;\n+     int *status;\n+{\n+  enum rtx_code code;\n+  int i;\n+  const char *fmt;\n+  int n;\n+\n+  if (x == 0)\n+    return x;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case REG:\n+      if (REGNO (x) == REGNO (reg_use))\n+\t{\n+\t  if (GET_MODE (x) == GET_MODE (reg_use))\n+\t    return reg_sub;\n+\t  else\n+\t    return gen_rtx_REG (GET_MODE (x), REGNO (reg_use));\n+\t}\n+      return x;\n+\n+    case SET:\n+      if (replace_type == DESTINATION)\n+\tSET_DEST (x) = rr_replace_reg (SET_DEST (x), reg_use, reg_sub,\n+\t\t\t\t       replace_type, insn, status);\n+      else if (replace_type == SOURCE)\n+\t{\n+\t  int dest_subregno;\n+\n+\t  if (GET_CODE (SET_DEST (x)) == SUBREG)\n+\t    dest_subregno = REGNO (XEXP (SET_DEST (x), 0));\n+\t  else\n+\t    dest_subregno = 0;\n+\n+\t  SET_SRC (x) = rr_replace_reg (SET_SRC (x), reg_use, reg_sub,\n+\t\t\t\t\treplace_type, insn, status);\n+\t  /* If the replacement register is not part of the source\n+\t     then it may be part of a source mem operand. */\n+\t  if (GET_CODE (SET_DEST (x)) == MEM\n+\t      || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n+\t      || GET_CODE (SET_DEST (x)) == SIGN_EXTRACT\n+\t      || GET_CODE (SET_DEST (x)) == STRICT_LOW_PART)\n+\t    SET_DEST (x) = rr_replace_reg (SET_DEST (x), reg_use, reg_sub,\n+\t\t\t\t\t   replace_type, insn, status);\n+\t  /* shared rtl sanity check */\n+\t  if (dest_subregno\n+\t      && dest_subregno != REGNO (XEXP (SET_DEST (x), 0)))\n+\t    {\n+\t      *status = 0;\n+\t      return x;\n+\t    }\n+\t}\n+\n+      n = recog_memoized (insn);\n+      if (n >= 0)\n+\t{\n+\t  int id;\n+\t  extract_insn (insn);\n+\n+\t  /* Any MATCH_DUP's which are REGs must still match */\n+\t  for (id = insn_data[n].n_dups - 1; id >= 0; id--)\n+\t    {\n+\t      int opno = recog_data.dup_num[id];\n+\t      if (GET_CODE (*recog_data.dup_loc[id]) == REG\n+\t\t  && GET_CODE (*recog_data.operand_loc[opno]) == REG\n+\t\t  && (REGNO (*recog_data.dup_loc[id]) !=\n+\t\t      REGNO (*recog_data.operand_loc[opno])))\n+\t\t*status = 0;\n+\t    }\n+\n+\t  if (!constrain_operands (1))\n+\t    {\n+\t      *status = 0;\n+\t      validate_replace_rtx (reg_sub, reg_use, insn);\n+\t    }\n+\t}\n+      else\n+\t*status = 0;\n+\n+      return x;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tXEXP (x, i) = rr_replace_reg (XEXP (x, i), reg_use, reg_sub,\n+\t\t\t\t      replace_type, insn, status);\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int xv;\n+\t  for (xv = 0; xv < XVECLEN (x, i); xv++)\n+\t    {\n+\t      XVECEXP (x, i, xv) = rr_replace_reg (XVECEXP (x, i, xv), reg_use,\n+\t\t\t\t\t\treg_sub, replace_type, insn,\n+\t\t\t\t\t\t   status);\n+\t      n = recog_memoized (insn);\n+\t      if (n >= 0)\n+\t\t{\n+\t\t  extract_insn (insn);\n+\t\t  if (!constrain_operands (1))\n+\t\t    {\n+\t\t      *status = 0;\n+\t\t      validate_replace_rtx (reg_sub, reg_use, insn);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t*status = 0;\n+\t    }\n+\t}\n+    }\n+  return x;\n+}\n+\n+/* Can REGNO in INSN be considered for renaming, given def INUM in d/u\n+   chain DU? */\n+\n+static int\n+consider_def (insn, regno, du, inum)\n+     rtx insn;\n+     int regno;\n+     def_uses *du;\n+     int inum;\n+{\n+  /* Don't rename windowed registers across a call */\n+#ifdef INCOMING_REGNO\n+  if (TEST_BIT (du->require_call_save_reg, inum)\n+      && INCOMING_REGNO (regno) != regno)\n+    return 0;\n+#endif\n+\n+  /* Don't consider conditional moves.  Predicate architectures may\n+     use two complementary conditional moves and the regno shouldn't change */\n+  if (condmove_p (insn))\n+    return 0;\n+\n+  /* Don't rename call used registers across a call */\n+  if (!(GET_CODE (insn) == CALL_INSN\n+\t&& TEST_HARD_REG_BIT (call_used_reg_set, regno)))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Can the use of REGNO in INSN of block USE_BLOCK be considered for renaming\n+   for a def in def_block? */\n+\n+static int\n+consider_use (insn, regno, def_block, use_block)\n+     rtx insn;\n+     int regno;\n+     int def_block;\n+     int use_block;\n+{\n+  rtx reg_use;\n+  edge e;\n+  basic_block ub = BASIC_BLOCK (use_block);\n+\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    return 0;\n+\n+  /* If a use's basic block is different than the def's basic block, \n+     then insure another predecessor does not also define this register */\n+  if (def_block != use_block)\n+    for (e = ub->pred; e; e = e->pred_next)\n+      {\n+\tif (e->src->index != def_block\n+\t    && e->src->index != -1\n+\t    && REGNO_REG_SET_P (BASIC_BLOCK (e->src->index)->global_live_at_end, regno))\n+\t  return 0;\n+      }\n+\n+  /* Don't consider conditional moves.  Predicate architectures may\n+     use two complementary conditional moves and the regno shouldn't change */\n+\n+  if (condmove_p (insn))\n+    return 0;\n+\n+  reg_use = regno_first_use_in (regno, PATTERN (insn));\n+  if (reg_use)\n+    {\n+      /* Don't consider multi-reg values. */\n+      if (HARD_REGNO_NREGS (regno, GET_MODE (reg_use)) != 1\n+\t  && GET_MODE (reg_use) != CCmode)\n+\treturn 0;\n+\n+      /* Don't consider register if the only use is in a USE */\n+      if (reg_mentioned_p (gen_rtx_USE (VOIDmode, reg_use),\n+\t\t\t   PATTERN (insn)))\n+\treturn 0;\n+      else\n+\treturn 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Can REG_USE be replaced by regno AVAIL_REG if it is in AVAIL_REGS\n+   and it is in regclass RC, given insn INUM of def/use chain DU? */\n+\n+static int\n+consider_available (reg_use, avail_reg, avail_regs, rc, du, inum)\n+     rtx reg_use;\n+     int avail_reg;\n+     HARD_REG_SET *avail_regs;\n+     int rc;\n+     def_uses *du;\n+     int inum;\n+{\n+  if (!TEST_HARD_REG_BIT (*avail_regs, avail_reg))\n+    return 0;\n+\n+#ifdef HARD_REGNO_RENAME_OK\n+  if (!HARD_REGNO_RENAME_OK (REGNO (reg_use), avail_reg))\n+    return 0;\n+#endif\n+\n+  /* Don't consider windowed leaf registers which will be renamed by\n+     leaf_renumber_regs */\n+#ifdef LEAF_REG_REMAP\n+  if (current_function_uses_only_leaf_regs)\n+    if (LEAF_REG_REMAP (avail_reg) < 0)\n+      return 0;\n+#endif\n+\n+  /* A register is considered available if it is available at the beginning of\n+     the basic block.  We may want to refine this to when a register becomes\n+     available within the block.  We don't consider multi-reg values. */\n+  /* ??? Consider a representation that would allow multi-reg support? */\n+  if (!TEST_HARD_REG_BIT (reg_class_contents[(enum reg_class) rc], avail_reg)\n+      || !HARD_REGNO_MODE_OK (avail_reg, GET_MODE (reg_use))\n+      || (HARD_REGNO_NREGS (avail_reg, GET_MODE (reg_use)) != 1\n+\t  && GET_MODE (reg_use) != CCmode)\n+      || (call_fixed_regs[avail_reg]\n+#ifdef HARD_REGNO_RENAME_OK\n+\t  && !HARD_REGNO_RENAME_OK (REGNO (reg_use), avail_reg)\n+#endif\n+      )\n+      || (TEST_BIT (du->require_call_save_reg, inum)\n+\t  && (call_used_regs[avail_reg] || call_used_regs[REGNO (reg_use)]\n+\t  )))\n+    return 0;\n+\n+  /* If register is a callee-saved register it must be saved in the frame. \n+     call saved registers can not be added to regs_ever_live after reload,\n+     as it would invalidate most elimination offsets */\n+  if (regs_ever_live[avail_reg] || call_used_regs[avail_reg]\n+      || (avail_reg == PIC_OFFSET_TABLE_REGNUM\n+\t  && flag_pic && (current_function_uses_pic_offset_table)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return 1 if INSN is a conditional move */\n+\n+static int\n+condmove_p (insn)\n+     rtx insn;\n+{\n+  if (GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Searches X for the first reference to REGNO, returning the rtx of the\n+   reference found if any.  Otherwise, returns NULL_RTX.  */\n+\n+static rtx\n+regno_first_use_in (regno, x)\n+     int regno;\n+     rtx x;\n+{\n+  register const char *fmt;\n+  int i, j;\n+  rtx tem;\n+\n+  if (GET_CODE (x) == REG && REGNO (x) == regno)\n+    return x;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = 0; i <= GET_RTX_LENGTH (GET_CODE (x)) - 1; i++)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if ((tem = regno_first_use_in (regno, XEXP (x, i))))\n+\t    return tem;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if ((tem = regno_first_use_in (regno, XVECEXP (x, i, j))))\n+\t    return tem;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Dump def/use chain DU to RTL_DUMP_FILE, given insns in UID_RUID and\n+   which regs are live at end, GLOBAL_LIVE_AT_END */\n+\n+static void\n+dump_def_use_chain (global_live_at_end, du, uid_ruid)\n+     HARD_REG_SET *global_live_at_end;\n+     def_uses *du;\n+     varray_type *uid_ruid;\n+{\n+  int r, inum;\n+\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+    {\n+      int set = 0;\n+      for (inum = 0;\n+\t   inum <= du->high_bound;\n+\t   inum++)\n+\t{\n+\t  rtx insn = VARRAY_RTX (*uid_ruid, inum);\n+#if 0\n+\t  if (!insn\n+\t      || GET_RTX_CLASS (GET_CODE\n+\t\t\t\t(insn)) != 'i')\n+\t    continue;\n+\t  reg_use = regno_first_use_in (r, PATTERN (insn));\n+\t  if (!reg_use)\n+\t    continue;\n+#endif\n+\t  if (!set && (TEST_BIT (du->defs[r], inum)\n+\t\t       || TEST_BIT (du->uses[r], inum)))\n+\t    {\n+\t      fprintf (rtl_dump_file, \"Register %s: \", reg_names[r]);\n+\t      if (fixed_regs[r])\n+\t\tfprintf (rtl_dump_file, \"Fixed \");\n+\t      else if (call_fixed_regs[r])\n+\t\tfprintf (rtl_dump_file, \"Call Fixed \");\n+\t      if (TEST_HARD_REG_BIT (*global_live_at_end, r))\n+\t\tfprintf (rtl_dump_file, \"Live at Exit \");\n+\t      set = 1;\n+\t    }\n+\t  if (TEST_BIT (du->defs[r], inum))\n+\t    fprintf (rtl_dump_file, \"=%d \", INSN_UID (insn));\n+\t  if (TEST_BIT (du->uses[r], inum))\n+\t    fprintf (rtl_dump_file, \"%d \", INSN_UID (insn));\n+\t}\n+      if (set)\n+\tfprintf (rtl_dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Dump info for extended basic block EBB having root EB */\n+\n+static void\n+dump_ext_bb_info (eb, ebb)\n+     int eb;\n+     ext_basic_blocks *ebb;\n+{\n+  int b;\n+\n+  {\n+    int have_ebb = 0;\n+    for (b = 0; b < n_basic_blocks; b++)\n+      {\n+\tif (TEST_BIT (ebb->basic_block[eb], b))\n+\t  {\n+\t    if (!have_ebb)\n+\t      {\n+#ifndef RENAME_EXTENDED_BLOCKS\n+\t\tfprintf (rtl_dump_file, \"\\nBasic block %d: \", b);\n+#else\n+\t\tfprintf (rtl_dump_file, \"\\nExtended basic block %d: \", b);\n+#endif\n+\t\thave_ebb = 1;\n+\t      }\n+\t    fprintf (rtl_dump_file, \"%d \", b);\n+\t  }\n+\tif (TEST_BIT (ebb->exit[eb], b))\n+\t  fprintf (rtl_dump_file, \"(exit) \");\n+      }\n+    if (have_ebb)\n+      fprintf (rtl_dump_file, \"\\n\");\n+  }\n+}\n+\n+/* Initialize EBB with extended basic block info if RENAME_EXTENDED_BLOCKS is\n+   defined.  Otherwise just use basic blocks */\n+\n+static void\n+find_ext_basic_blocks (ebb)\n+     ext_basic_blocks *ebb;\n+{\n+  sbitmap bb_processed;\n+  int b;\n+\n+  bb_processed = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (bb_processed);\n+\n+#ifndef RENAME_EXTENDED_BLOCKS\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      basic_block bb = BASIC_BLOCK (b);\n+      SET_BIT (ebb->basic_block[bb->index], bb->index);\n+    }\n+#else\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      basic_block bb = BASIC_BLOCK (b);\n+      if (!TEST_BIT (bb_processed, b))\n+\t{\n+\t  find_one_ext_basic_block (bb->index, bb, &bb_processed, ebb);\n+\t}\n+    }\n+#endif\n+  sbitmap_free (bb_processed);\n+}\n+\n+/* Find one extended basic block EBB having root ENTRY containing block\n+   BB */\n+\n+static void\n+find_one_ext_basic_block (entry, bb, bb_processed, ebb)\n+     int entry;\n+     basic_block bb;\n+     sbitmap *bb_processed;\n+     ext_basic_blocks *ebb;\n+{\n+  edge e;\n+\n+  if (!TEST_BIT (*bb_processed, bb->index))\n+    {\n+      SET_BIT (ebb->basic_block[entry], bb->index);\n+      SET_BIT (*bb_processed, bb->index);\n+    }\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (!TEST_BIT (*bb_processed, e->dest->index))\n+      {\n+\tif (!e->dest->pred->pred_next\n+\t    && (!TEST_BIT (*bb_processed, e->dest->index)))\n+\t  {\n+\t    find_one_ext_basic_block (entry, e->dest, bb_processed, ebb);\n+\t  }\n+\telse\n+\t  {\n+\t    SET_BIT (ebb->exit[entry], bb->index);\n+\t  }\n+      }\n+}\n+\n+/* Find the register class for register REG_USE having TYPE (DESTINATION or\n+   SOURCE) in INSN.  Use DEFAULT_CLASS if we cannot determine a class. */\n+\n+static enum reg_class\n+get_reg_class (insn, reg_use, type, default_class)\n+     rtx insn;\n+     rtx reg_use;\n+     int type;\n+     enum reg_class default_class;\n+{\n+  int alt, id = 0;\n+\n+  extract_insn (insn);\n+  constrain_operands (1);\n+  alt = which_alternative;\n+\n+  preprocess_constraints ();\n+\n+  if (type == DESTINATION)\n+    for (id = 0; id < recog_data.n_operands; id++)\n+      {\n+\tif (rtx_equal_p (recog_data.operand[id], reg_use))\n+\t  break;\n+      }\n+  else if (type == SOURCE)\n+    for (id = recog_data.n_operands - 1; id >= 0; id--)\n+      {\n+\tif (rtx_equal_p (recog_data.operand[id], reg_use))\n+\t  break;\n+      }\n+\n+  if (id == -1 || id == recog_data.n_operands)\n+    return default_class;\n+\n+  return recog_op_alt[id][alt].class;\n+}"}, {"sha": "263de4e44167aca3c4e1779750709b3ce6dd2297", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7b82b5da0120f0067aa5c0336cfb775798c647f4", "patch": "@@ -1798,4 +1798,8 @@ extern void convert_from_ssa\t\tPARAMS ((void));\n \n extern rtx stack_limit_rtx;\n \n+/* In regrename.c */\n+\n+extern void regrename_optimize\t\tPARAMS ((void));\n+\n #endif /* _RTL_H */"}, {"sha": "920dba5df55c6e10aa27b5c91db2566b399d3425", "filename": "gcc/toplev.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b82b5da0120f0067aa5c0336cfb775798c647f4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7b82b5da0120f0067aa5c0336cfb775798c647f4", "patch": "@@ -270,6 +270,7 @@ enum dump_file_index\n   DFI_peephole2,\n   DFI_sched2,\n   DFI_bbro,\n+  DFI_rnreg,\n   DFI_jump2,\n   DFI_mach,\n   DFI_dbr,\n@@ -302,6 +303,7 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"peephole2\", 'z', 1, 0, 0 },\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"bbro\",\t'B', 1, 0, 0 },\n+  { \"rnreg\",\t'n', 1, 0, 0 },\n   { \"jump2\",\t'J', 1, 0, 0 },\n   { \"mach\",\t'M', 1, 0, 0 },\n   { \"dbr\",\t'd', 0, 0, 0 },\n@@ -423,6 +425,10 @@ int flag_branch_probabilities = 0;\n \n int flag_reorder_blocks = 0;\n \n+/* Nonzero if registers should be renamed */\n+\n+int flag_rename_registers = 0;\n+\n /* Nonzero for -pedantic switch: warn about anything\n    that standard spec forbids.  */\n \n@@ -1019,6 +1025,8 @@ lang_independent_options f_options[] =\n    \"Use profiling information for branch probabilities\" },\n   {\"reorder-blocks\", &flag_reorder_blocks, 1,\n    \"Reorder basic blocks to improve code placement\" },\n+  {\"rename-registers\", &flag_rename_registers, 1,\n+   \"Do the register renaming optimization pass\"},\n   {\"fast-math\", &flag_fast_math, 1,\n    \"Improve FP speed by violating ANSI & IEEE rules\" },\n   {\"common\", &flag_no_common, 0,\n@@ -1415,6 +1423,7 @@ int peephole2_time;\n int sched2_time;\n int dbr_sched_time;\n int reorder_blocks_time;\n+int rename_registers_time;\n int shorten_branch_time;\n int stack_reg_time;\n int final_time;\n@@ -2164,6 +2173,7 @@ compile_file (name)\n   sched2_time = 0;\n   dbr_sched_time = 0;\n   reorder_blocks_time = 0;\n+  rename_registers_time = 0;\n   shorten_branch_time = 0;\n   stack_reg_time = 0;\n   final_time = 0;\n@@ -2572,6 +2582,7 @@ compile_file (name)\n       print_time (\"dbranch\", dbr_sched_time);\n #endif\n       print_time (\"bbro\", reorder_blocks_time);\n+      print_time (\"rnreg\", rename_registers_time);\n       print_time (\"shorten-branch\", shorten_branch_time);\n #ifdef STACK_REGS\n       print_time (\"stack-reg\", stack_reg_time);\n@@ -3421,6 +3432,15 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n     }    \n \n+  if (optimize > 0 && flag_rename_registers)\n+    {\n+      open_dump_file (DFI_rnreg, decl);\n+\n+      TIMEVAR (rename_registers_time, regrename_optimize ());\n+\n+      close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n+    }    \n+\n   /* One more attempt to remove jumps to .+1 left by dead-store elimination. \n      Also do cross-jumping this time and delete no-op move insns.  */\n "}]}