{"sha": "0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI5MmZmMzNiODZkNDY5Y2I0ZmNmYWE2NDVlMGQzOWE3YTI2NmRlNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-10T08:01:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-10T08:01:57Z"}, "message": "predict.def (PRED_CALL, [...]): New.\n\n\t* predict.def (PRED_CALL, PRED_ERROR_RETURN): New.\n\t* predict.c (estimate_probability): Calculate dominance\n\tinformation; improve detection of NORETURN heuristics;\n\tadd call/error_return heuiristics; tweak comparison heuristics\n\tto recognize -1.\n\nFrom-SVN: r43130", "tree": {"sha": "85be21b7941eb12af078af9b59979abfebe2ecf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85be21b7941eb12af078af9b59979abfebe2ecf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/comments", "author": null, "committer": null, "parents": [{"sha": "680cd9ed7be2e8bef6a37d41b1078ebac782b70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/680cd9ed7be2e8bef6a37d41b1078ebac782b70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/680cd9ed7be2e8bef6a37d41b1078ebac782b70e"}], "stats": {"total": 80, "additions": 72, "deletions": 8}, "files": [{"sha": "954d6a5abe906f23b39e528a4326ba04f71e456d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "patch": "@@ -1,3 +1,11 @@\n+Sun Jun 10 10:00:17 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.def (PRED_CALL, PRED_ERROR_RETURN): New.\n+\t* predict.c (estimate_probability): Calculate dominance\n+\tinformation; improve detection of NORETURN heuristics;\n+\tadd call/error_return heuiristics; tweak comparison heuristics\n+\tto recognize -1.\n+\n 2001-06-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* doc/invoke.texi (C Dialect Options): Document -aux-info."}, {"sha": "21c7149070f17d7fa68c15501caf4c90d9af1b2b", "filename": "gcc/predict.c", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "patch": "@@ -240,8 +240,14 @@ void\n estimate_probability (loops_info)\n      struct loops *loops_info;\n {\n+  sbitmap *dominators, *post_dominators;\n   int i;\n \n+  dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  calculate_dominance_info (NULL, dominators, 0);\n+  calculate_dominance_info (NULL, post_dominators, 1);\n+\n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n   for (i = 0; i < loops_info->num; i++)\n@@ -282,23 +288,67 @@ estimate_probability (loops_info)\n      is used as the prediction for the branch.  */\n   for (i = 0; i < n_basic_blocks - 1; i++)\n     {\n-      rtx last_insn = BLOCK_END (i);\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx last_insn = bb->end;\n       rtx cond, earliest;\n       edge e;\n \n+      /* If block has no sucessor, predict all possible paths to\n+         it as improbable, as the block contains a call to a noreturn\n+\t function and thus can be executed only once.  */\n+      if (bb->succ == NULL)\n+\t{\n+\t  int y;\n+\t  for (y = 0; y < n_basic_blocks; y++)\n+\t    if (!TEST_BIT (post_dominators[y], i))\n+\t      {\n+\t\tfor (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n+\t\tif (e->dest->index >= 0\n+\t\t    && TEST_BIT (post_dominators[e->dest->index], i))\n+\t\t  predict_edge_def (e, PRED_NORETURN, NOT_TAKEN);\n+\t      }\n+\t}\n+\n       if (GET_CODE (last_insn) != JUMP_INSN\n \t  || ! any_condjump_p (last_insn))\n \tcontinue;\n \n       if (find_reg_note (last_insn, REG_BR_PROB, 0))\n \tcontinue;\n \n-      /* If one of the successor blocks has no successors, predict\n-\t that side not taken.  */\n-      /* ??? Ought to do the same for any subgraph with no exit.  */\n-      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n-\tif (e->dest->succ == NULL)\n-\t  predict_edge_def (e, PRED_NORETURN, NOT_TAKEN);\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  /* Predict edges to blocks that return immediately to be\n+\t     improbable.  These are usually used to signal error states.  */\n+\t  if (e->dest == EXIT_BLOCK_PTR\n+\t      || (e->dest->succ && !e->dest->succ->succ_next\n+\t\t  && e->dest->succ->dest == EXIT_BLOCK_PTR))\n+\t    predict_edge_def (e, PRED_ERROR_RETURN, NOT_TAKEN);\n+\n+\t  /* Look for block we are guarding (ie we dominate it,\n+\t     but it doesn't postdominate us).  */\n+\t  if (e->dest != EXIT_BLOCK_PTR\n+\t      && e->dest != bb\n+\t      && TEST_BIT (dominators[e->dest->index], e->src->index)\n+\t      && !TEST_BIT (post_dominators[e->src->index], e->dest->index))\n+\t    {\n+\t      rtx insn;\n+\t      /* The call heuristic claims that a guarded function call\n+\t\t is improbable.  This is because such calls are often used\n+\t\t to signal exceptional situations such as printing error\n+\t\t messages.  */\n+\t      for (insn = e->dest->head; insn != NEXT_INSN (e->dest->end);\n+\t\t   insn = NEXT_INSN (insn))\n+\t\tif (GET_CODE (insn) == CALL_INSN\n+\t\t    /* Constant and pure calls are hardly used to signalize\n+\t\t       something exceptional.  */\n+\t\t    && ! CONST_CALL_P (insn))\n+\t\t  {\n+\t\t    predict_edge_def (e, PRED_CALL, NOT_TAKEN);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n \n       cond = get_condition (last_insn, &earliest);\n       if (! cond)\n@@ -359,7 +409,9 @@ estimate_probability (loops_info)\n \t  break;\n \tcase LE:\n \tcase LT:\n-\t  if (XEXP (cond, 1) == const0_rtx)\n+\t  if (XEXP (cond, 1) == const0_rtx\n+\t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n+\t\t  && INTVAL (XEXP (cond, 1)) == -1))\n \t    predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n \t  break;\n \tcase GE:\n@@ -385,6 +437,8 @@ estimate_probability (loops_info)\n \tcontinue;\n       combine_predictions_for_insn (last_insn, BASIC_BLOCK (i));\n     }\n+  sbitmap_vector_free (post_dominators);\n+  sbitmap_vector_free (dominators);\n }\n \f\n /* __builtin_expect dropped tokens into the insn stream describing"}, {"sha": "9f000b95ca85c187e7a66a16737f3d710e81faf3", "filename": "gcc/predict.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b92ff33b86d469cb4fcfaa645e0d39a7a266de6/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=0b92ff33b86d469cb4fcfaa645e0d39a7a266de6", "patch": "@@ -44,4 +44,6 @@ DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", PROB_VERY_LIKELY)\n DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", PROB_LIKELY)\n DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", PROB_LIKELY)\n DEF_PREDICTOR (PRED_POINTER, \"pointer\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_CALL, \"call\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", PROB_LIKELY)\n DEF_PREDICTOR (PRED_OPCODE, \"opcode\", PROB_LIKELY)"}]}