{"sha": "bbf5a54d985232333942f49ff89d35e6debd7e8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJmNWE1NGQ5ODUyMzIzMzM5NDJmNDlmZjg5ZDM1ZTZkZWJkN2U4Yw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2004-01-21T17:26:08Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2004-01-21T17:26:08Z"}, "message": "extend.texi (Extended Asm): Clarify memory clobber.\n\n2004-01-21  Andreas Jaeger  <aj@suse.de>\n\t    Michael Matz  <matz@suse.de>\n\n\t* doc/extend.texi (Extended Asm): Clarify memory clobber.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\n\nFrom-SVN: r76288", "tree": {"sha": "057b9f125772c207a2ba0f4d03de52e7e037ea67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/057b9f125772c207a2ba0f4d03de52e7e037ea67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbf5a54d985232333942f49ff89d35e6debd7e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf5a54d985232333942f49ff89d35e6debd7e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf5a54d985232333942f49ff89d35e6debd7e8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf5a54d985232333942f49ff89d35e6debd7e8c/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bfccaa6f7006c6f1a56f6b8e4194583e8cddd2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfccaa6f7006c6f1a56f6b8e4194583e8cddd2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfccaa6f7006c6f1a56f6b8e4194583e8cddd2f4"}], "stats": {"total": 39, "additions": 33, "deletions": 6}, "files": [{"sha": "2cdc83e1b0636d8297464cb0bb8c087994fa4f24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf5a54d985232333942f49ff89d35e6debd7e8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf5a54d985232333942f49ff89d35e6debd7e8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbf5a54d985232333942f49ff89d35e6debd7e8c", "patch": "@@ -1,3 +1,8 @@\n+2004-01-21  Andreas Jaeger  <aj@suse.de>\n+\t    Michael Matz  <matz@suse.de>\n+\n+\t* doc/extend.texi (Extended Asm): Clarify memory clobber.\n+\n 2004-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* crtstuff.c (frame_dummy, __do_global_ctors_1): Call"}, {"sha": "e2bfd9348dfdfe9fbcc1603871c197805c7c5b8f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf5a54d985232333942f49ff89d35e6debd7e8c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf5a54d985232333942f49ff89d35e6debd7e8c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=bbf5a54d985232333942f49ff89d35e6debd7e8c", "patch": "@@ -3917,13 +3917,35 @@ represents the condition codes as a specific hardware register;\n condition code is handled differently, and specifying @samp{cc} has no\n effect.  But it is valid no matter what the machine.\n \n-If your assembler instruction modifies memory in an unpredictable\n+If your assembler instructions access memory in an unpredictable\n fashion, add @samp{memory} to the list of clobbered registers.  This\n-will cause GCC to not keep memory values cached in registers across\n-the assembler instruction.  You will also want to add the\n-@code{volatile} keyword if the memory affected is not listed in the\n-inputs or outputs of the @code{asm}, as the @samp{memory} clobber does\n-not count as a side-effect of the @code{asm}.\n+will cause GCC to not keep memory values cached in registers across the\n+assembler instruction and not optimize stores or loads to that memory.\n+You will also want to add the @code{volatile} keyword if the memory\n+affected is not listed in the inputs or outputs of the @code{asm}, as\n+the @samp{memory} clobber does not count as a side-effect of the\n+@code{asm}.  If you know how large the accessed memory is, you can add\n+it as input or output but if this is not known, you should add\n+@samp{memory}.  As an example, if you access ten bytes of a string, you\n+can use a memory input like:\n+\n+@example\n+@{\"m\"( (@{ struct @{ char x[10]; @} *p = (void *)ptr ; *p; @}) )@}.\n+@end example\n+\n+Note that in the following example the memory input is necessary,\n+otherwise GCC might optimize the store to @code{x} away:\n+@example\n+int foo ()\n+@{\n+  int x = 42;\n+  int *y = &x;\n+  int result;\n+  asm (\"magic stuff accessing an 'int' pointed to by '%1'\"\n+        \"=&d\" (r) : \"a\" (y), \"m\" (*y));\n+  return result;     \n+@}\n+@end example\n \n You can put multiple assembler instructions together in a single\n @code{asm} template, separated by the characters normally used in assembly"}]}