{"sha": "e693cc28bbfeb1c1728bec4392505d2eba2b1090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY5M2NjMjhiYmZlYjFjMTcyOGJlYzQzOTI1MDVkMmViYTJiMTA5MA==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@cygnus.com", "date": "1997-09-16T16:01:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-16T16:01:55Z"}, "message": "Uli's libio/libstdc++ patches.\n\nFrom-SVN: r15486", "tree": {"sha": "6f133200943f818cad1e94da16393eadfe8dd250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f133200943f818cad1e94da16393eadfe8dd250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e693cc28bbfeb1c1728bec4392505d2eba2b1090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e693cc28bbfeb1c1728bec4392505d2eba2b1090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e693cc28bbfeb1c1728bec4392505d2eba2b1090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e693cc28bbfeb1c1728bec4392505d2eba2b1090/comments", "author": null, "committer": null, "parents": [{"sha": "610ce97e654a9f2ed5e103bddd936988c5768538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610ce97e654a9f2ed5e103bddd936988c5768538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610ce97e654a9f2ed5e103bddd936988c5768538"}], "stats": {"total": 1751, "additions": 1132, "deletions": 619}, "files": [{"sha": "1ae28e365983a06e211d0b272a8c2e2bcc98aa88", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,3 +1,12 @@\n+1997-09-15 02:37  Ulrich Drepper  <drepper@cygnus.com>\n+\n+\t* config/mt-linux: Define CXXFLAGS to make sure -fvtable-thunks is\n+\tused.\n+\t* configure.in: Name Linux target fragment.\n+\n+\t* configure: Rewrite so that project Makefile fragment is inserted\n+\tfirst and appears last in the resulting Makefile.\n+\n Thu Sep 11 16:40:46 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)\n \n \t* Makefile.in (local-distclean): Also remove mh-frag mt-frag."}, {"sha": "d8b8087be284620c66689ef7af73313007006692", "filename": "configure", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -81,7 +81,7 @@ subdirs=\n target_alias=NOTARGET\n target_makefile_frag=\n undefs=NOUNDEFS\n-version=\"$Revision: 1.244 $\"\n+version=\"$Revision: 1.1.1.1 $\"\n x11=default\n \n ### we might need to use some other shell than /bin/sh for running subshells\n@@ -1045,78 +1045,77 @@ EOF\n \n         if [ -f ${srcdir}/${subdir}/${Makefile_in} ] ; then\n \n-            # Conditionalize for this site from \"Makefile.in\" (or whatever it's called) into Makefile.tem\n-            rm -f ${subdir}/Makefile.tem\n-              case \"${site}\" in\n+            # Conditionalize the makefile for this package from \"Makefile.in\" (or whatever it's called) into Makefile.tem.\n+            rm -f ${subdir}/${Makefile}.tem\n+            case \"${package_makefile_frag}\" in\n               \"\") cp ${srcdir}/${subdir}/${Makefile_in} ${subdir}/Makefile.tem ;;\n+              *)\n+                      if [ ! -f ${package_makefile_frag} ] ; then\n+                              package_makefile_frag=${srcdir}/${package_makefile_frag}\n+                      fi\n+                      if [ -f ${package_makefile_frag} ] ; then\n+                              sed -e \"/^####/  r ${package_makefile_frag}\" ${srcdir}/${subdir}/${Makefile_in} > ${Makefile}.tem\n+                      else\n+                              echo '***' Expected package makefile fragment \\\"${package_makefile_frag}\\\" 1>&2\n+                              echo '***' is missing in ${PWD=`pwd`}. 1>&2\n+                              cp ${srcdir}/${subdir}/${Makefile_in} ${subdir}/Makefile.tem\n+                      fi\n+            esac\n+            # working copy now in ${Makefile}.tem\n+\n+            # Conditionalize for this site.\n+            rm -f ${Makefile}\n+              case \"${site}\" in\n+              \"\") mv ${subdir}/Makefile.tem ${Makefile} ;;\n               *)\n                       site_makefile_frag=${srcdir}/config/ms-${site}\n \n                       if [ -f ${site_makefile_frag} ] ; then\n-                              sed -e \"/^####/  r ${site_makefile_frag}\" ${srcdir}/${subdir}/${Makefile_in} \\\n-                                      > ${subdir}/Makefile.tem\n+                              sed -e \"/^####/  r ${site_makefile_frag}\" ${subdir}/Makefile.tem \\\n+                                      > ${Makefile}\n                       else\n-                              cp ${srcdir}/${subdir}/${Makefile_in} ${subdir}/Makefile.tem\n+                              mv ${subdir}/Makefile.tem ${Makefile}\n                               site_makefile_frag=\n                       fi\n                       ;;\n             esac\n-            # working copy now in ${subdir}/Makefile.tem\n+            # working copy now in ${Makefile}\n \n             # Conditionalize the makefile for this host.\n-            rm -f ${Makefile}\n+            rm -f ${subdir}/Makefile.tem\n             case \"${host_makefile_frag}\" in\n-              \"\") mv ${subdir}/Makefile.tem ${Makefile} ;;\n+              \"\") mv ${Makefile} ${subdir}/Makefile.tem ;;\n               *)\n                       if [ ! -f ${host_makefile_frag} ] ; then\n                               host_makefile_frag=${srcdir}/${host_makefile_frag}\n                       fi\n                       if [ -f ${host_makefile_frag} ] ; then\n-                              sed -e \"/^####/  r ${host_makefile_frag}\" ${subdir}/Makefile.tem > ${Makefile}\n+                              sed -e \"/^####/  r ${host_makefile_frag}\" ${Makefile} > ${subdir}/Makefile.tem\n                       else\n                               echo '***' Expected host makefile fragment \\\"${host_makefile_frag}\\\" 1>&2\n                               echo '***' is missing in ${PWD=`pwd`}. 1>&2\n-                              mv ${subdir}/Makefile.tem ${Makefile}\n+                              mv ${Makefile} ${subdir}/Makefile.tem\n                       fi\n             esac\n-            # working copy now in ${Makefile}\n+            # working copy now in ${subdir)/Makefile.tem\n \n             # Conditionalize the makefile for this target.\n-            rm -f ${subdir}/Makefile.tem\n+            rm -f ${Makefile}\n             case \"${target_makefile_frag}\" in\n-              \"\") mv ${Makefile} ${subdir}/Makefile.tem ;;\n+              \"\") mv ${subdir}/Makefile.tem ${Makefile} ;;\n               *)\n                       if [ ! -f ${target_makefile_frag} ] ; then\n                               target_makefile_frag=${srcdir}/${target_makefile_frag}\n                       fi\n                       if [ -f ${target_makefile_frag} ] ; then\n-                              sed -e \"/^####/  r ${target_makefile_frag}\" ${Makefile} > ${subdir}/Makefile.tem\n+                              sed -e \"/^####/  r ${target_makefile_frag}\" ${subdir}/Makefile.tem > ${Makefile}\n                       else\n-                              mv ${Makefile} ${subdir}/Makefile.tem\n+                              mv ${subdir}/Makefile.tem ${Makefile}\n                               target_makefile_frag=\n                       fi\n                       ;;\n             esac\n-            # real copy now in ${subdir}/Makefile.tem\n-\n-            # Conditionalize the makefile for this package.\n-            rm -f ${Makefile}\n-            case \"${package_makefile_frag}\" in\n-              \"\") mv ${subdir}/Makefile.tem ${Makefile} ;;\n-              *)\n-                      if [ ! -f ${package_makefile_frag} ] ; then\n-                              package_makefile_frag=${srcdir}/${package_makefile_frag}\n-                      fi\n-                      if [ -f ${package_makefile_frag} ] ; then\n-                              sed -e \"/^####/  r ${package_makefile_frag}\" ${subdir}/Makefile.tem > ${Makefile}\n-\t\t\t      rm -f ${subdir}/Makefile.tem\n-                      else\n-                              echo '***' Expected package makefile fragment \\\"${package_makefile_frag}\\\" 1>&2\n-                              echo '***' is missing in ${PWD=`pwd`}. 1>&2\n-                              mv ${subdir}/Makefile.tem ${Makefile}\n-                      fi\n-            esac\n-            # working copy now in ${Makefile}\n+            # real copy now in ${Makefile}\n \n             mv ${Makefile} ${subdir}/Makefile.tem\n "}, {"sha": "c768e6f64408ed0fcc6978e3576f933514affff3", "filename": "configure.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -212,6 +212,7 @@ case \"${target}\" in\n   v810*)\t\ttarget_makefile_frag=config/mt-v810 ;;\n   i[3456]86-*-netware*) target_makefile_frag=config/mt-netware ;;\n   powerpc-*-netware*)   target_makefile_frag=config/mt-netware ;;\n+  *-*-linux-gnu)        target_makefile_frag=config/mt-linux ;;\n esac\n \n skipdirs="}, {"sha": "cb3409ac9962281da6813d1f7c22d8fa9e08604f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,6 +1,7 @@\n-Tue Sep 16 00:40:23 1997  Jeffrey A Law  (law@cygnus.com)\n+Tue Sep 16 09:18:52 1997  Jason Merrill  (jason@cygnus.com)\n \n-\t* version.c: Bump for snapshot.\n+\t* expr.c (expand_expr, case TARGET_EXPR): Call mark_addressable\n+\tagain for the slot after we give it RTL.\n \n Tue Sep 16 00:13:20 1997  Nick Clifton  <nickc@cygnus.com>\n "}, {"sha": "b05d4ea94da2a7ef2c769aedb69dc4cda455fa85", "filename": "libio/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FChangeLog?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,3 +1,65 @@\n+1997-09-15 02:37  Ulrich Drepper  <drepper@cygnus.com>\n+\n+\t* config/linux.mt: Rewrite for use with glibc 2.\n+\t* config/linuxlibc1.mt: Old content of linux.mt, fir libc4 and\n+\tlibc5.\n+\n+\t* config.shared (COMPILE.c): Allow new flags in MT_CFLAGS be\n+\tpassed.\n+\t(COMPILE.cc): Likewise.\n+\n+\t* configure.in (*-linux*): Remove goal.  We now have...\n+\t(*-linux-gnulibc1): For libc4 and libc5.  Emit warning.\n+\t(*-linux-gnu)): For glibc 2.\n+\tCreate links to find headers for multi-threading if necessary.\n+\n+\t* fileops.c: Make thread-safe by using _IO_cleanup_region_start\n+\tetc to handle cancelation.  Acquire locks in functions which are\n+\tcalled directly.\n+\t(_IO_file_read, _IO_file_write): Remove dead code.\n+\n+\t* include/empty.h: Define stub macros for locking.\n+\n+\t* iolibio.h: Add prototypes for obstack printing functions.\n+\n+\t* ioseekoff.c (_IO_seekoff): Lock stream before working.\n+\t* ioseekpos.c (_IO_seekpos): Likewise.\n+\n+\t* iostream.cc: Add support for long double I/O.\n+\tUse __printf_fp from glibc is available.\n+\tUse _IO_cleanup_region_start to handle cancelation correctly.\n+\t* iostream.h (class ostream): Change opfx and osfx to lock/unlock\n+\tstream\n+\t(class istream): Likewise for ipfx, ipfx0, ipfx1, and isfx.\n+\tDeclare new function lock and unlock for ostream and istream.\n+\t* osform.cc: Use _IO_cleanup_region_start to handle cancelation\n+\tcorrectly.\n+\n+\t* libio.h: Update from glibc version.  Pretty printing.\n+\t* libioP.h: Likewise.\n+\n+\t* outfloat.c: Only compile if _IO_USE_DTOA is defined.\n+\n+\t* stdio/feof.c: Make thread safe.\n+\t* stdio/ferror.c: Likewise.\n+\t* stdio/getc.c : Likewise.\n+\t* stdio/putc.c : Likewise.\n+\t* stdio/stdio.h: Declare function of thread-safe API.\n+\n+\t* stdio/obprintf.c: New file.\n+\t* stdio/vasprintf.c: New file.\n+\n+\t* stdio-lock.h: Removed.\n+\n+\t* stdstrbufs.c: Add definitions for thread-safe streams.\n+\n+\t* streambuf.cc: Initialize lock.\n+\n+\t* strops.c (_IO_str_count): Undo last change.\n+\n+\t* tests/tFile.cc: Support parallel builds by avoiding fixed\n+\tname for test file.\n+\n Thu Sep 11 18:43:56 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* Makefile.in (iostream.list): Remove STDIO_WRAP_OBJECTS."}, {"sha": "691fa838b26ab9cb7553f29a8e3965bf7782bb45", "filename": "libio/cleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fcleanup.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -5,7 +5,7 @@\n typedef void (*voidfunc) __P((void));\n \n static void\n-DEFUN_VOID(_IO_register_cleanup)\n+_IO_register_cleanup ()\n {\n   atexit ((voidfunc)_IO_cleanup);\n   _IO_cleanup_registration_needed = 0;"}, {"sha": "009381a4c081877e89b49533c91c72bd07e410eb", "filename": "libio/config.shared", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fconfig.shared", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fconfig.shared", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig.shared?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -254,15 +254,15 @@ else\n fi\n \n echo '.SUFFIXES: .o .C .cc .c'\n-echo 'COMPILE.c = $(CC) -c $(XCFLAGS) $(CINCLUDES)'\n+echo 'COMPILE.c = $(CC) -c $(XCFLAGS) $(CINCLUDES) $(MT_CFLAGS)'\n echo '.c.o:'\n if [ \"${LIBDIR}\" = \"yes\" ]; then\n echo '\ttest -z \"$(PICFLAG)\" ||\\'\n echo '\t  $(COMPILE.c) $(PICFLAG) $< -o pic/$@'\n fi\n echo '\t$(COMPILE.c) $<'\n [ \"${TOUCH_ON_COMPILE}\" = \"yes\" ] && echo '\t@touch stamp'\n-echo 'COMPILE.cc = $(CXX) -c $(XCXXFLAGS) $(CXXINCLUDES)'\n+echo 'COMPILE.cc = $(CXX) -c $(XCXXFLAGS) $(CXXINCLUDES) $(MT_CFLAGS)'\n echo '.C.o:'\n if [ \"${LIBDIR}\" = \"yes\" ]; then\n echo '\ttest -z \"$(PICFLAG)\" ||\\'\n@@ -466,6 +466,7 @@ depend.new:\n \t  >depend.new\n \t$(CXX) -M $(CXXINCLUDES) $(DEPEND_SOURCES) \\\n \t| sed -e 's|$(srcdir)/|$$(srcdir)/|g' \\\n+\t      -e 's| [^ ]_G_config.h| $$(_G_CONFIG_H)|g \\\n \t      -e 's| /[^ ]*||g' \\\n \t      -e '/^[ \t]*\\\\$$/d' -e 's/^[ \t]*$$//' \\\n \t| sed -e 's|$$(srcdir)/[.][.]|$$(srcdir)/$$(MULTISRCTOP)..|g' \\"}, {"sha": "4bb92b76b2e90c168a5e89c49c500b53573dc37f", "filename": "libio/config/linux.mt", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fconfig%2Flinux.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fconfig%2Flinux.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinux.mt?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,26 +1,30 @@\n-# Since the Linux C library has libio, we have to be very careful.\n+# Use the libio which comes with the local libc.\n \n-# By default, we build libio and use it.  If someone wants to not\n-# build it, let them go to extra work.  The reason is that the user\n-# may want a newer, bug fixed libio, also on a linux 1.0.8 system\n-# things just won't build with the bottom section uncommented.\n+# That is where we keep the g++ header files.\n+gxx_includedir =$(prefix)/include/g++\n \n # Comment this out to avoid including the stdio functions in libiostream.a:\n-LIBIOSTREAM_OBJECTS = $(IO_OBJECTS) $(IOSTREAM_OBJECTS) $(STDIO_WRAP_OBJECTS) $(OSPRIM_OBJECTS)\n-LIBIOSTREAM_DEP = $(LIBIOSTREAM_OBJECTS) stmp-stdio\n-LIBIOSTREAM_USE = $(LIBIOSTREAM_OBJECTS) `cat stdio.list`\n+# LIBIOSTREAM_OBJECTS = $(IO_OBJECTS) $(IOSTREAM_OBJECTS) $(STDIO_WRAP_OBJECTS) $(OSPRIM_OBJECTS)\n+# LIBIOSTREAM_DEP = $(LIBIOSTREAM_OBJECTS) stdio.list\n+# LIBIOSTREAM_USE = $(LIBIOSTREAM_OBJECTS) `cat stdio.list`\n \n # Comment the above and uncomment the below to use the code in the Linux libc:\n # We have _G_config.h in /usr/include.\n-# _G_CONFIG_H=\n+_G_CONFIG_H=\n+\n+# We must not see the libio.h file from this library.\n+LIBIO_INCLUDE=\n \n # We have those in libc.a.\n-# IO_OBJECTS=\n-# STDIO_WRAP_OBJECTS=\n-# OSPRIM_OBJECTS=\n+IO_OBJECTS=\n+STDIO_WRAP_OBJECTS=\n+OSPRIM_OBJECTS=\n \n # We have the rest in /usr/include.\n-# USER_INCLUDES=PlotFile.h SFile.h builtinbuf.h editbuf.h fstream.h \\\n-# \tindstream.h iomanip.h iostream.h istream.h ostream.h \\\n-# \tparsestream.h pfstream.h procbuf.h stdiostream.h stream.h \\\n-# \tstreambuf.h strfile.h strstream.h\n+USER_INCLUDES=PlotFile.h SFile.h builtinbuf.h editbuf.h fstream.h \\\n+\tindstream.h iomanip.h iostream.h istream.h ostream.h \\\n+\tparsestream.h pfstream.h procbuf.h stdiostream.h stream.h \\\n+\tstreambuf.h strfile.h strstream.h\n+\n+# tell we want the mt-safe version\n+MT_CFLAGS = -D_IO_MTSAFE_IO"}, {"sha": "06c6fdabea5adb8e071047b93dfebd15d0587044", "filename": "libio/configure.in", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfigure.in?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -16,12 +16,13 @@ frags=\n \n case \"${target}\" in\n   *-hpux*)       frags=hpux.mt ;;\n-  *-linux*)      \n+  *-linux-gnulibc1)\n \techo \"WARNING:  The I/O implementation in FSF libg++ 2.8.x is not\"\n \techo \"  compatible with Linux libc through 5.2.x.\"\n \techo \"  See libg++/README for more information.\"\n \techo \"  YOU ARE ON YOUR OWN!\"\n-\t\t frags=linux.mt ;;\n+\t\t frags=linuxlibc1.mt ;;\n+  *-linux-gnu)   frags=linux.mt ;;\n   *-sco3.2v[45]*)   frags=sco4.mt ;;\n   *-isc*)        frags=isc.mt ;;\n   *-netware*)    frags=netware.mt ;;\n@@ -43,6 +44,28 @@ if [ \"${shared}\" = \"yes\" ]; then\n   esac\n fi\n \n+# Make a link for the correct stdio-lock.h file.\n+case \"${target}\" in\n+  *-linux-gnu)\n+    # We have a correct file in glibc but the libioP.h file is written\n+    # with glibc 2.1 in mind which has the internals headers in special\n+    # directory while glibc 2.0 has them in /usr/include.  Create a wrapper\n+    # if necessary.\n+    (echo \"#include <bits/libc-lock.h>\" | ${CC-cc} -E -) >/dev/null 2>&1 ||\n+      {\n+\trm -fr bits\n+        mkdir bits\n+        echo \"#include <libc-lock.h>\" > bits/libc-lock.h\n+        echo \"#include <stdio-lock.h>\" > bits/stdio-lock.h\n+      }\n+    ;;\n+  *)\n+    rm -fr bits\n+    mkdir bits\n+    ln -s ${srcdir}/include/empty.h bits/stdio-lock.h\n+    ;;\n+esac\n+\n for frag in ${frags}; do\n   frag=${srcdir}/config/$frag\n   if [ -f ${frag} ]; then"}, {"sha": "b7335fdb1abb0f215d730d2ec651a1633aef7dc2", "filename": "libio/depend", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fdepend", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fdepend", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fdepend?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -5,103 +5,103 @@ PlotFile.o: PlotFile.cc \\\n  $(srcdir)/fstream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n SFile.o: SFile.cc \\\n  $(srcdir)/SFile.h \\\n  $(srcdir)/fstream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n builtinbuf.o: builtinbuf.cc \\\n  $(srcdir)/builtinbuf.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/iostreamP.h \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h\n editbuf.o: editbuf.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/editbuf.h \\\n  $(srcdir)/fstream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \n filebuf.o: filebuf.cc \\\n  $(srcdir)/iostreamP.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n  $(srcdir)/builtinbuf.h\n fstream.o: fstream.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/fstream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h\n indstream.o: indstream.cc \\\n  $(srcdir)/indstream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioassign.o: ioassign.cc \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h\n ioextend.o: ioextend.cc \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iomanip.o: iomanip.cc \\\n  $(srcdir)/iomanip.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iostream.o: iostream.cc \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n  $(srcdir)/floatio.h\n isgetline.o: isgetline.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \n isgetsb.o: isgetsb.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \n isscan.o: isscan.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h\n osform.o: osform.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h\n parsestream.o: parsestream.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/parsestream.h \\\n  $(srcdir)/streambuf.h \n pfstream.o: pfstream.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/pfstream.h \\\n  $(srcdir)/fstream.h \\\n  $(srcdir)/iostream.h \\\n@@ -110,45 +110,45 @@ pfstream.o: pfstream.cc \\\n procbuf.o: procbuf.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/procbuf.h \\\n  $(srcdir)/streambuf.h\n sbform.o: sbform.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/streambuf.h\n sbgetline.o: sbgetline.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/streambuf.h\n sbscan.o: sbscan.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/streambuf.h\n stdiostream.o: stdiostream.cc \\\n  $(srcdir)/stdiostream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h\n stdstrbufs.o: stdstrbufs.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n stdstreams.o: stdstreams.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/streambuf.h \\\n  $(srcdir)/iostream.h\n stream.o: stream.cc \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/stream.h \\\n  $(srcdir)/iostream.h \\\n  $(srcdir)/streambuf.h \\\n@@ -157,13 +157,13 @@ stream.o: stream.cc \\\n streambuf.o: streambuf.cc \\\n  $(srcdir)/iostreamP.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \n strstream.o: strstream.cc \\\n  $(srcdir)/iostreamP.h \\\n  $(srcdir)/streambuf.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n  $(srcdir)/strstream.h \\\n@@ -172,181 +172,181 @@ strstream.o: strstream.cc \\\n cleanup.o: cleanup.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n filedoalloc.o: filedoalloc.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n fileops.o: fileops.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n floatconv.o: floatconv.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n genops.o: genops.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofclose.o: iofclose.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofdopen.o: iofdopen.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofflush.o: iofflush.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofgetpos.o: iofgetpos.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofgets.o: iofgets.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofopen.o: iofopen.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofprintf.o: iofprintf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofputs.o: iofputs.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofread.o: iofread.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofscanf.o: iofscanf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofsetpos.o: iofsetpos.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioftell.o: ioftell.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iofwrite.o: iofwrite.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iogetdelim.o: iogetdelim.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iogetline.o: iogetline.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iogets.o: iogets.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioignore.o: ioignore.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iopadn.o: iopadn.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioperror.o: ioperror.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iopopen.o: iopopen.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioprims.o: ioprims.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioprintf.o: ioprintf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioputs.o: ioputs.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioscanf.o: ioscanf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioseekoff.o: ioseekoff.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioseekpos.o: ioseekpos.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iosetbuffer.o: iosetbuffer.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iosetvbuf.o: iosetvbuf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iosprintf.o: iosprintf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iosscanf.o: iosscanf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iostrerror.o: iostrerror.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n ioungetc.o: ioungetc.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n iovfprintf.o: iovfprintf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/floatio.h\n iovfscanf.o: iovfscanf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/floatio.h\n iovsprintf.o: iovsprintf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/strfile.h\n iovsscanf.o: iovsscanf.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/strfile.h\n outfloat.o: outfloat.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n stdfiles.o: stdfiles.c \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h \\\n- $(srcdir)/libio.h _G_config.h \n+ $(srcdir)/libio.h $(_G_CONFIG_H) \n strops.o: strops.c \\\n  $(srcdir)/strfile.h \\\n- $(srcdir)/libio.h _G_config.h \\\n+ $(srcdir)/libio.h $(_G_CONFIG_H) \\\n  $(srcdir)/libioP.h \\\n  $(srcdir)/iolibio.h "}, {"sha": "001794d05a7561801c8c4d49138c988e47b18f28", "filename": "libio/fileops.c", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Ffileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Ffileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffileops.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -40,7 +40,12 @@ extern int errno;\n \n \n #ifdef _LIBC\n-# define open(Name, Flags, Prot) __open ((Name), (Flags), (Prot))\n+# define open(Name, Flags, Prot) __open (Name, Flags, Prot)\n+# define close(FD) __close (FD)\n+# define fstat(FD, Statbuf) __fstat (FD, Statbuf)\n+# define lseek(FD, Offset, Whence) __lseek (FD, Offset, Whence)\n+# define read(FD, Buf, NBytes) __read (FD, Buf, NBytes)\n+# define write(FD, Buf, NBytes) __write (FD, Buf, NBytes)\n #endif\n \n /* An fstream can be in at most one of put mode, get mode, or putback mode.\n@@ -384,6 +389,10 @@ _IO_file_sync (fp)\n      _IO_FILE *fp;\n {\n   _IO_size_t delta;\n+  int retval = 0;\n+\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n   /*    char* ptr = cur_ptr(); */\n   if (fp->_IO_write_ptr > fp->_IO_write_base)\n     if (_IO_do_flush(fp)) return EOF;\n@@ -402,12 +411,14 @@ _IO_file_sync (fp)\n \t; /* Ignore error from unseekable devices. */\n #endif\n       else\n-\treturn EOF;\n+\tretval = EOF;\n     }\n-  fp->_offset = _IO_pos_BAD;\n+  if (retval != EOF)\n+    fp->_offset = _IO_pos_BAD;\n   /* FIXME: Cleanup - can this be shared? */\n   /*    setg(base(), ptr, ptr); */\n-  return 0;\n+  _IO_cleanup_region_end (1);\n+  return retval;\n }\n \n _IO_pos_t\n@@ -575,19 +586,7 @@ _IO_file_read (fp, buf, size)\n      void *buf;\n      _IO_ssize_t size;\n {\n-  for (;;)\n-    {\n-      _IO_ssize_t count = _IO_read (fp->_fileno, buf, size);\n-#if 0 && defined EINTR\n-      /* We must not do this optimization since POSIX.1 explicitly\n-\t requests that the stream operations must return with the\n-\t error EINTR if this happens.  There must be the possibility\n-\t that stream operations time out.  --drepper  */\n-      if (count == -1 && errno == EINTR)\n-\tcontinue;\n-#endif\n-      return count;\n-    }\n+  return read (fp->_fileno, buf, size);\n }\n \n _IO_pos_t\n@@ -596,22 +595,22 @@ _IO_file_seek (fp, offset, dir)\n      _IO_off_t offset;\n      int dir;\n {\n-  return _IO_lseek (fp->_fileno, offset, dir);\n+  return lseek (fp->_fileno, offset, dir);\n }\n \n int\n _IO_file_stat (fp, st)\n      _IO_FILE *fp;\n      void *st;\n {\n-  return _IO_fstat (fp->_fileno, (struct stat *) st);\n+  return fstat (fp->_fileno, (struct stat *) st);\n }\n \n int\n _IO_file_close (fp)\n      _IO_FILE *fp;\n {\n-  return _IO_close (fp->_fileno);\n+  return close (fp->_fileno);\n }\n \n _IO_ssize_t\n@@ -623,22 +622,11 @@ _IO_file_write (f, data, n)\n   _IO_ssize_t to_do = n;\n   while (to_do > 0)\n     {\n-      _IO_ssize_t count = _IO_write (f->_fileno, data, to_do);\n+      _IO_ssize_t count = write (f->_fileno, data, to_do);\n       if (count == EOF)\n \t{\n-#if 0 && defined EINTR\n-\t  /* We must not do this optimization since POSIX.1 explicitly\n-\t     requests that the stream operations must return with the\n-\t     error EINTR if this happens.  There must be the\n-\t     possibility that stream operations time out.  --drepper  */\n-\t  if (errno == EINTR)\n-\t    continue;\n-\t  else\n-#endif\n-\t    {\n-\t      f->_flags |= _IO_ERR_SEEN;\n-\t      break;\n-            }\n+\t  f->_flags |= _IO_ERR_SEEN;\n+\t  break;\n         }\n       to_do -= count;\n       data = (void *) ((char *) data + count);"}, {"sha": "dcbf758df9c7ce83753c29bd251fbffb66af5272", "filename": "libio/include/empty.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Finclude%2Fempty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Finclude%2Fempty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Finclude%2Fempty.h?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1 +1,37 @@\n+/* Thread package specific definitions of stream lock type.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _LIBIO_LOCK_H\n+#define _LIBIO_LOCK_H\t1\n+\n+typedef void *_IO_lock_t;\n+\n+/* We need recursive (counting) mutexes.  */\n+#define _IO_lock_initializer NULL\n+\n+\n+#define _IO_cleanup_region_start(_fct, _fp)\n+#define _IO_cleanup_region_end(_doit)\n+#define _IO_lock_init(_name)\n+#define _IO_lock_fini(_name)\n+#define _IO_lock_lock(_name)\n+#define _IO_lock_unlock(_name)\n+\n+#endif /* libio-lock.h */\n /* this will be used later*/"}, {"sha": "ac0678ed7b9948ac78b698e1e4983d786dc3cd07", "filename": "libio/ioignore.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioignore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioignore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioignore.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -25,8 +25,9 @@ the executable file might be covered by the GNU General Public License. */\n #include \"libioP.h\"\n \n int\n-DEFUN(_IO_ignore, (fp, n),\n-      register _IO_FILE *fp AND _IO_size_t n)\n+_IO_ignore (fp, n)\n+     _IO_FILE *fp;\n+     _IO_size_t n;\n {\n   register _IO_size_t more = n;\n   for (;;)"}, {"sha": "63896780fc0cd9cfa1df15f592289f08be117ac4", "filename": "libio/iolibio.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiolibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiolibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiolibio.h?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -32,6 +32,11 @@ extern int _IO_sprintf __P((char *, const char*, ...));\n extern int _IO_ungetc __P((int, _IO_FILE*));\n extern int _IO_vsscanf __P((const char *, const char *, _IO_va_list));\n extern int _IO_vsprintf __P((char*, const char*, _IO_va_list));\n+\n+struct obstack;\n+extern int _IO_obstack_vprintf __P ((struct obstack *, const char *,\n+                                    _IO_va_list));\n+extern int _IO_obstack_printf __P ((struct obstack *, const char *, ...));\n #ifndef _IO_pos_BAD\n #define _IO_pos_BAD ((_IO_fpos_t)(-1))\n #endif"}, {"sha": "7ca72b0bb60b18fd053583d49f63806ba63cd532", "filename": "libio/ioperror.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioperror.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -10,8 +10,8 @@ extern char* _IO_strerror __P((int));\n #endif\n \n void\n-DEFUN(_IO_perror, (s),\n-      const char *s)\n+_IO_perror (s)\n+     const char *s;\n {\n   char *error = _IO_strerror (errno);\n "}, {"sha": "59d4fc3f0ed2f3603712cbc2c0ac7dfd44c8805f", "filename": "libio/iopopen.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiopopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiopopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiopopen.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -68,6 +68,10 @@ extern int _IO_dup2 __P ((int fd, int fd2));\n #define _IO__exit _exit\n #endif\n \n+#ifndef _IO_close\n+#define _IO_close close\n+#endif\n+\n struct _IO_proc_file\n {\n   struct _IO_FILE_plus file;"}, {"sha": "5d31e070d9a21a01fbc74a99d1e2815ea96499f7", "filename": "libio/ioprims.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioprims.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioprims.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioprims.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -37,36 +37,43 @@ the executable file might be covered by the GNU General Public License. */\n #endif\n \n _IO_ssize_t\n-DEFUN(_IO_read, (fildes, buf, nbyte),\n-      int fildes AND void *buf AND _IO_size_t nbyte)\n+_IO_read (fildes, buf, nbyte)\n+     int fildes;\n+     void *buf;\n+     _IO_size_t nbyte;\n {\n   return read (fildes, buf, nbyte);\n }\n \n _IO_ssize_t\n-DEFUN(_IO_write, (fildes, buf, nbyte),\n-      int fildes AND const void *buf AND _IO_size_t nbyte)\n+_IO_write (fildes, buf, nbyte)\n+     int fildes;\n+     const void *buf;\n+     _IO_size_t nbyte;\n {\n   return write (fildes, buf, nbyte);\n }\n \n _IO_off_t\n-DEFUN(_IO_lseek, (fildes, offset, whence),\n-      int fildes AND _IO_off_t offset AND int whence)\n+_IO_lseek (fildes, offset, whence)\n+     int fildes;\n+     _IO_off_t offset;\n+     int whence;\n {\n   return lseek (fildes, offset, whence);\n }\n \n int\n-DEFUN(_IO_close, (fildes),\n-      int fildes)\n+_IO_close (fildes)\n+     int fildes;\n {\n   return close (fildes);\n }\n \n int\n-DEFUN(_IO_fstat, (fildes, buf),\n-      int fildes AND struct stat *buf)\n+_IO_fstat (fildes, buf)\n+     int fildes;\n+     struct stat *buf;\n {\n   return fstat (fildes, buf);\n }"}, {"sha": "b1c4729b3d1df3532f33c1617f26022a1b09b64f", "filename": "libio/ioseekoff.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioseekoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioseekoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioseekoff.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -32,16 +32,23 @@ _IO_seekoff (fp, offset, dir, mode)\n      int dir;\n      int mode;\n {\n+  _IO_pos_t retval;\n+\n   /* If we have a backup buffer, get rid of it, since the __seekoff\n      callback may not know to do the right thing about it.\n      This may be over-kill, but it'll do for now. TODO */\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+\n \n   if (_IO_have_backup (fp))\n     {\n       if (dir == _IO_seek_cur && _IO_in_backup (fp))\n \toffset -= fp->_IO_read_end - fp->_IO_read_ptr;\n       _IO_free_backup_area (fp);\n     }\n+  retval = _IO_SEEKOFF (fp, offset, dir, mode);\n \n-  return _IO_SEEKOFF (fp, offset, dir, mode);\n+  _IO_cleanup_region_end (1);\n+  return retval;\n }"}, {"sha": "2ce0c2224ec77f0468892715d093f31036418e14", "filename": "libio/ioseekpos.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioseekpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fioseekpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioseekpos.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -31,12 +31,18 @@ _IO_seekpos (fp, pos, mode)\n      _IO_pos_t pos;\n      int mode;\n {\n+  _IO_pos_t retval;\n+\n   /* If we have a backup buffer, get rid of it, since the __seekoff\n      callback may not know to do the right thing about it.\n      This may be over-kill, but it'll do for now. TODO */\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n \n   if (_IO_have_backup (fp))\n     _IO_free_backup_area (fp);\n+  retval = _IO_SEEKPOS (fp, pos, mode);\n \n-  return _IO_SEEKPOS (fp, pos, mode);\n+  _IO_cleanup_region_end (1);\n+  return retval;\n }"}, {"sha": "217b2e29b9f71939b7fcbcb62d0385e0e5e38645", "filename": "libio/iostream.cc", "status": "modified", "additions": 193, "deletions": 44, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.cc?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,26 +1,27 @@\n /* This is part of libio/iostream, providing -*- C++ -*- input/output.\n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU IO Library.  This library is free\n+   software; you can redistribute it and/or modify it under the\n+   terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n+   USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License. */\n \n /* Written by Per Bothner (bothner@cygnus.com). */\n \n@@ -34,7 +35,14 @@ the executable file might be covered by the GNU General Public License. */\n #include <ctype.h>\n #include <string.h>\n #include <limits.h>\n+\n+#if _G_HAVE_PRINTF_FP\n+#include <printf.h>\n+extern \"C\" int __printf_fp (_IO_FILE *, const struct printf_info *,\n+\t\t\t    const void *const *);\n+#else\n #include \"floatio.h\"\n+#endif\n \n #define\tBUF\t\t(MAXEXP+MAXFRACT+1)\t/* + decimal point */\n \n@@ -133,7 +141,7 @@ istream::sync ()\n   if (sb == NULL)\n     return EOF;\n   if (sb->sync ()) // Later: pubsync\n-    { \n+    {\n       setstate (ios::badbit);\n       return EOF;\n     }\n@@ -321,7 +329,11 @@ READ_INT(bool)\n istream& istream::operator>>(long double& x)\n {\n     if (ipfx0())\n+#if _G_HAVE_LONG_DOUBLE_IO\n+\tscan(\"%Lg\", &x);\n+#else\n \tscan(\"%lg\", &x);\n+#endif\n     return *this;\n }\n \n@@ -362,32 +374,38 @@ istream& istream::operator>>(register streambuf* sbuf)\n ostream& ostream::operator<<(char c)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n #if 1\n \t// This is what the cfront implementation does.\n-\tif (_strbuf->sputc(c) == EOF)\n-\t  goto failed;\n+\tif (_strbuf->sputc(c) == EOF) {\n+\t    set(ios::badbit);\n+\t    goto failed;\n+\t}\n #else\n \t// This is what cfront documentation and current ANSI drafts say.\n \tint w = width(0);\n \tchar fill_char = fill();\n \tregister int padding = w > 0 ? w - 1 : 0;\n \tregister streambuf *sb = _strbuf;\n \tif (!(flags() & ios::left) && padding) // Default adjustment.\n-\t    if (_IO_padn(sb, fill_char, padding) < padding)\n+\t    if (_IO_padn(sb, fill_char, padding) < padding) {\n+\t      set(ios::badbit);\n \t      goto failed;\n-\tif (sb->sputc(c) == EOF)\n+\t    }\n+\tif (sb->sputc(c) == EOF) {\n+\t  set(ios::badbit);\n \t  goto failed;\n+        }\n \tif (flags() & ios::left && padding) // Left adjustment.\n \t    if (_IO_padn(sb, fill_char, padding) < padding)\n-\t      goto failed;\n+\t      set(ios::badbit);\n #endif\n+       failed:\n \tosfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n-  failed:\n-    set(ios::badbit);\n-    osfx();\n-    return *this;\n }\n \n /* Write VAL on STREAM.\n@@ -493,67 +511,90 @@ static void write_int(ostream& stream, unsigned LONGEST val, int sign)\n ostream& ostream::operator<<(int n)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tint sign = 1;\n \tunsigned int abs_n = (unsigned)n;\n \tif (n < 0 && (flags() & (ios::oct|ios::hex)) == 0)\n \t    abs_n = -((unsigned)n), sign = -1;\n \twrite_int(*this, abs_n, sign);\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n ostream& ostream::operator<<(unsigned int n)\n {\n-    if (opfx())\n+    if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \twrite_int(*this, n, 0);\n+\t_IO_cleanup_region_end (0);\n+    }\n     return *this;\n }\n \n \n ostream& ostream::operator<<(long n)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tint sign = 1;\n \tunsigned long abs_n = (unsigned long)n;\n \tif (n < 0 && (flags() & (ios::oct|ios::hex)) == 0)\n \t    abs_n = -((unsigned long)n), sign = -1;\n \twrite_int(*this, abs_n, sign);\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n ostream& ostream::operator<<(unsigned long n)\n {\n-    if (opfx())\n+    if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \twrite_int(*this, n, 0);\n+\t_IO_cleanup_region_end (0);\n+    }\n     return *this;\n }\n \n #if defined(__GNUC__) && !defined(__STRICT_ANSI__)\n ostream& ostream::operator<<(long long n)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tint sign = 1;\n \tunsigned long long abs_n = (unsigned long long)n;\n \tif (n < 0 && (flags() & (ios::oct|ios::hex)) == 0)\n \t    abs_n = -((unsigned long long)n), sign = -1;\n \twrite_int(*this, abs_n, sign);\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n \n ostream& ostream::operator<<(unsigned long long n)\n {\n-    if (opfx())\n+    if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \twrite_int(*this, n, 0);\n+\t_IO_cleanup_region_end (0);\n+    }\n     return *this;\n }\n #endif /*__GNUC__*/\n \n ostream& ostream::operator<<(double n)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \t// Uses __cvt_double (renamed from static cvt), in Chris Torek's\n \t// stdio implementation.  The setup code uses the same logic\n \t// as in __vsbprintf.C (also based on Torek's code).\n@@ -570,7 +611,26 @@ ostream& ostream::operator<<(double n)\n \t  prec = 6; /* default */\n \n \t// Do actual conversion.\n-#ifdef _IO_USE_DTOA\n+#ifdef _G_HAVE_PRINTF_FP\n+\t{\n+\t  struct printf_info info = { prec: prec,\n+\t\t\t\t      width: width(0),\n+\t\t\t\t      spec: format_char,\n+\t\t\t\t      is_long_double: 0,\n+\t\t\t\t      is_short: 0,\n+\t\t\t\t      is_long: 0,\n+\t\t\t\t      alt: flags() & ios::showpoint,\n+\t\t\t\t      space: 0,\n+\t\t\t\t      left: ios::left,\n+\t\t\t\t      showsign: flags() & ios::showpos,\n+\t\t\t\t      group: 0,\n+\t\t\t\t      pad: fill(),\n+\t\t\t\t      extra: 0};\n+\t  const void *ptr = &n;\n+\t  if (__printf_fp (rdbuf(), &info, &ptr) < 0)\n+\t    set(ios::badbit|ios::failbit);\n+\t}\n+#elif defined  _IO_USE_DTOA\n \tif (_IO_outfloat(n, rdbuf(), format_char, width(0),\n \t\t\t prec, flags(),\n \t\t\t flags() & ios::showpos ? '+' : 0,\n@@ -618,7 +678,7 @@ ostream& ostream::operator<<(double n)\n \t    sbuf->sputc(sign);\n \tif (pad_kind == (ios::fmtflags)ios::internal)\n \t    for (i = padding; --i >= 0; ) sbuf->sputc(fill_char);\n-\t\n+\n \t// Emit the actual concented field, followed by extra zeros.\n \t_IO_sputn (sbuf, cp, size);\n \tfor (i = fpprec; --i >= 0; ) sbuf->sputc('0');\n@@ -627,14 +687,66 @@ ostream& ostream::operator<<(double n)\n \t    for (i = padding; --i >= 0; ) sbuf->sputc(fill_char);\n #endif\n \tosfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n+#if _G_HAVE_LONG_DOUBLE_IO\n+ostream& ostream::operator<<(long double n)\n+{\n+  if (opfx())\n+    {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n+      int format_char;\n+      if ((flags() & ios::floatfield) == ios::fixed)\n+\tformat_char = 'f';\n+      else if ((flags() & ios::floatfield) == ios::scientific)\n+\tformat_char = flags() & ios::uppercase ? 'E' : 'e';\n+      else\n+\tformat_char = flags() & ios::uppercase ? 'G' : 'g';\n+\n+      int prec = precision();\n+      if (prec <= 0 && !(flags() & ios::fixed))\n+\tprec = 6; /* default */\n+\n+#ifdef _G_HAVE_PRINTF_FP\n+      // Do actual conversion.\n+      struct printf_info info = { prec: prec,\n+\t\t\t\t  width: width(0),\n+\t\t\t\t  spec: format_char,\n+\t\t\t\t  is_long_double: 1,\n+\t\t\t\t  is_short: 0,\n+\t\t\t\t  is_long: 0,\n+\t\t\t\t  alt: flags() & ios::showpoint,\n+\t\t\t\t  space: 0,\n+\t\t\t\t  left: ios::left,\n+\t\t\t\t  showsign: flags() & ios::showpos,\n+\t\t\t\t  group: 0,\n+\t\t\t\t  pad: fill(),\n+\t\t\t\t  extra: 0};\n+\n+      const void *ptr = &n;\n+\n+      if (__printf_fp (rdbuf(), &info, &ptr) < 0)\n+\tset (ios::badbit|ios::failbit);\n+#else\n+# error \"long double I/O using dtoa or cvt_double is not implemented\"\n+#endif\n+      osfx();\n+      _IO_cleanup_region_end (0);\n+    }\n+  return *this;\n+}\n+#endif\n+\n ostream& ostream::operator<<(const char *s)\n {\n   if (opfx())\n     {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n       if (s == NULL)\n \ts = \"(null)\";\n       int len = strlen(s);\n@@ -645,19 +757,23 @@ ostream& ostream::operator<<(const char *s)\n       register int padding = w > len ? w - len : 0;\n       if (!(flags() & ios::left) && padding > 0) // Default adjustment.\n \tif (_IO_padn(sbuf, fill_char, padding) != padding)\n-\t  goto failed;\n+\t  {\n+\t    set(ios::badbit);\n+\t    goto failed;\n+\t  }\n       if (_IO_sputn (sbuf, s, len) != len)\n-\tgoto failed;\n+\t{\n+\t  set(ios::badbit);\n+\t  goto failed;\n+\t}\n       if (flags() & ios::left && padding > 0) // Left adjustment.\n \tif (_IO_padn(sbuf, fill_char, padding) != padding)\n-\t  goto failed;\n+\t  set(ios::badbit);\n       osfx();\n+     failed:\n+      _IO_cleanup_region_end (0);\n     }\n   return *this;\n- failed:\n-  set(ios::badbit);\n-  osfx();\n-  return *this;\n }\n \n #if 0\n@@ -669,6 +785,8 @@ ostream& ostream::operator<<(register streambuf* sbuf)\n {\n   if (opfx())\n     {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n       char buffer[_IO_BUFSIZ];\n       register streambuf* outbuf = _strbuf;\n       for (;;)\n@@ -683,6 +801,7 @@ ostream& ostream::operator<<(register streambuf* sbuf)\n \t    }\n \t}\n       osfx();\n+      _IO_cleanup_region_end (0);\n     }\n   return *this;\n }\n@@ -735,11 +854,15 @@ ostream& flush(ostream& outs)\n istream& ws(istream& ins)\n {\n     if (ins.ipfx1()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  ins._strbuf);\n \tint ch = skip_ws(ins._strbuf);\n \tif (ch == EOF)\n \t    ins.set(ios::eofbit);\n \telse\n \t    ins._strbuf->sputbackc(ch);\n+\tins.isfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return ins;\n }\n@@ -772,11 +895,37 @@ ostream& endl(ostream& outs)\n     return flush(outs.put('\\n'));\n }\n \n+istream& lock(istream& ins)\n+{\n+  _IO_flockfile (ins._strbuf);\n+  return ins;\n+}\n+istream& unlock(istream& ins)\n+{\n+  _IO_funlockfile (ins._strbuf);\n+  return ins;\n+}\n+ostream& lock(ostream& outs)\n+{\n+  _IO_flockfile (outs._strbuf);\n+  return outs;\n+}\n+ostream& unlock(ostream& outs)\n+{\n+  _IO_funlockfile (outs._strbuf);\n+  return outs;\n+}\n+\n+\n ostream& ostream::write(const char *s, streamsize n)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tif (_IO_sputn(_strbuf, s, n) != n)\n \t    set(ios::failbit);\n+\tosfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }"}, {"sha": "f3de3639906a576e3eb8327edee1fcac3e498df5", "filename": "libio/iostream.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.h?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -49,8 +49,10 @@ class ostream : virtual public ios\n     ostream() { }\n     ostream(streambuf* sb, ostream* tied=NULL);\n     int opfx() {\n-\tif (!good()) return 0; else { if (_tie) _tie->flush(); return 1;} }\n-    void osfx() { if (flags() & (ios::unitbuf|ios::stdio))\n+\tif (!good()) return 0;\n+\telse { if (_tie) _tie->flush(); _IO_flockfile(_strbuf); return 1;} }\n+    void osfx() { _IO_funlockfile(_strbuf);\n+\t\t  if (flags() & (ios::unitbuf|ios::stdio))\n \t\t      do_osfx(); }\n     ostream& flush();\n     ostream& put(char c) { _strbuf->sputc(c); return *this; }\n@@ -144,6 +146,7 @@ class istream : virtual public ios\n     int ipfx(int need = 0) {\n \tif (!good()) { set(ios::failbit); return 0; }\n \telse {\n+\t  _IO_flockfile(_strbuf);\n \t  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();\n \t  if (!need && (flags() & ios::skipws)) return _skip_ws();\n \t  else return 1;\n@@ -152,6 +155,7 @@ class istream : virtual public ios\n     int ipfx0() { // Optimized version of ipfx(0).\n \tif (!good()) { set(ios::failbit); return 0; }\n \telse {\n+\t  _IO_flockfile(_strbuf);\n \t  if (_tie) _tie->flush();\n \t  if (flags() & ios::skipws) return _skip_ws();\n \t  else return 1;\n@@ -160,11 +164,12 @@ class istream : virtual public ios\n     int ipfx1() { // Optimized version of ipfx(1).\n \tif (!good()) { set(ios::failbit); return 0; }\n \telse {\n+\t  _IO_flockfile(_strbuf);\n \t  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();\n \t  return 1;\n \t}\n     }\n-    void isfx() { }\n+    void isfx() { _IO_funlockfile(_strbuf); }\n     int get() { if (!ipfx1()) return EOF;\n \t\telse { int ch = _strbuf->sbumpc();\n \t\t       if (ch == EOF) set(ios::eofbit);\n@@ -249,6 +254,11 @@ __asm__ (\"__IO_clog\")\n #endif\n ;\n \n+extern istream& lock(istream& ins);\n+extern istream& unlock(istream& ins);\n+extern ostream& lock(ostream& outs);\n+extern ostream& unlock(ostream& outs);\n+\n struct Iostream_init { } ;  // Compatibility hack for AT&T library.\n \n inline ios& dec(ios& i)"}, {"sha": "348e0956d70f5c461fcf88e0b3bdc1d15c37f255", "filename": "libio/iostrerror.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiostrerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiostrerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostrerror.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -5,8 +5,8 @@\n extern char *strerror __P ((int));\n \n char *\n-DEFUN(_IO_strerror, (errnum),\n-      int errnum)\n+_IO_strerror (errnum)\n+     int errnum;\n {\n   return strerror(errnum);\n }"}, {"sha": "755334c2bf2333e917b34fb2b5f2762bb92fb100", "filename": "libio/iovfprintf.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiovfprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiovfprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovfprintf.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -84,8 +84,9 @@ struct helper_file\n };\n \n static int\n-DEFUN(_IO_helper_overflow, (fp, c),\n-      _IO_FILE *fp AND int c)\n+_IO_helper_overflow (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   _IO_FILE *target = ((struct helper_file*)fp)->_put_stream;\n   int used = fp->_IO_write_ptr - fp->_IO_write_base;\n@@ -119,8 +120,10 @@ static struct _IO_jump_t _IO_helper_jumps = {\n };\n \n static int\n-DEFUN(helper_vfprintf, (fp, fmt0, ap),\n-      register _IO_FILE* fp AND char const *fmt0 AND _IO_va_list ap)\n+helper_vfprintf (fp, fmt0, ap)\n+     _IO_FILE *fp;\n+     char const *fmt0;\n+     _IO_va_list ap;\n {\n   char buf[_IO_BUFSIZ];\n   struct helper_file helper;\n@@ -180,8 +183,10 @@ extern double modf __P((double, double*));\n #define\tHEXPREFIX\t0x40\t\t/* add 0x or 0X prefix */\n \n int\n-DEFUN(_IO_vfprintf, (fp, fmt0, ap),\n-      register _IO_FILE* fp AND char const *fmt0 AND _IO_va_list ap)\n+_IO_vfprintf (fp, fmt0, ap)\n+     _IO_FILE *fp;\n+     char const *fmt0;\n+     _IO_va_list ap;\n {\n \tregister const char *fmt; /* format string */\n \tregister int ch;\t/* character from fmt */"}, {"sha": "0631458f21ec6d9cedc562ddb51409bc10b4a5d5", "filename": "libio/iovfscanf.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiovfscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fiovfscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovfscanf.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -119,9 +119,11 @@ extern double atof();\n    *errp|=2 if we an invalid character. */\n \n int\n-DEFUN(_IO_vfscanf, (fp, fmt0, ap, errp),\n-      register _IO_FILE *fp AND char const *fmt0\n-      AND _IO_va_list ap AND int *errp)\n+_IO_vfscanf (fp, fmt0, ap, errp)\n+     _IO_FILE *fp;\n+     char const *fmt0;\n+     _IO_va_list ap;\n+     int *errp;\n {\n \tregister const u_char *fmt = (const u_char *)fmt0;\n \tregister int c;\t\t/* character from format, or conversion */\n@@ -696,8 +698,9 @@ again:\t\tc = *fmt++;\n  * considered part of the scanset.\n  */\n static const u_char *\n-DEFUN(__sccl, (tab, fmt),\n-      register char *tab AND register const u_char *fmt)\n+__sccl (tab, fmt)\n+     char *tab;\n+     const u_char *fmt;\n {\n \tregister int c, n, v;\n "}, {"sha": "10fcfed230d8fb2447e8dd7f032fbb2b7938027d", "filename": "libio/libio.h", "status": "modified", "additions": 79, "deletions": 84, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Flibio.h?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,28 +1,28 @@\n-/*\n-Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/* This is part of the iostream library.  Written by Per Bothner. */\n+/* Copyright (C) 1991, 92, 93, 94, 95, 97 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+   Written by Per Bothner <bothner@cygnus.com>.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #ifndef _IO_STDIO_H\n #define _IO_STDIO_H\n@@ -42,60 +42,56 @@ the executable file might be covered by the GNU General Public License. */\n \n #ifdef _G_NEED_STDARG_H\n /* This define avoids name pollution if we're using GNU stdarg.h */\n-#define __need___va_list\n-#include <stdarg.h>\n-#ifdef __GNUC_VA_LIST\n-#undef _IO_va_list\n-#define _IO_va_list __gnuc_va_list\n-#endif /* __GNUC_VA_LIST */\n+# define __need___va_list\n+# include <stdarg.h>\n+# ifdef __GNUC_VA_LIST\n+#  undef _IO_va_list\n+#  define _IO_va_list __gnuc_va_list\n+# endif /* __GNUC_VA_LIST */\n #endif\n \n #ifndef __P\n-#if _G_HAVE_SYS_CDEFS\n-#include <sys/cdefs.h>\n-#else\n-#ifdef __STDC__\n-#define __P(protos) protos\n-#else\n-#define __P(protos) ()\n-#endif\n-#endif\n+# if _G_HAVE_SYS_CDEFS\n+#  include <sys/cdefs.h>\n+# else\n+#  ifdef __STDC__\n+#   define __P(protos) protos\n+#  else\n+#   define __P(protos) ()\n+#  endif\n+# endif\n #endif /*!__P*/\n \n /* For backward compatibility */\n #ifndef _PARAMS\n-#define _PARAMS(protos) __P(protos)\n+# define _PARAMS(protos) __P(protos)\n #endif /*!_PARAMS*/\n \n #ifndef __STDC__\n-#define const\n-#endif\n-#ifndef _G_NO_USE_DTOA\n-#define _IO_USE_DTOA\n-#else\n-#undef _IO_USE_DTOA\n+# define const\n #endif\n #define _IO_UNIFIED_JUMPTABLES 1\n \n #if 0\n-#ifdef _IO_NEED_STDARG_H\n-#include <stdarg.h>\n-#endif\n+# ifdef _IO_NEED_STDARG_H\n+#  include <stdarg.h>\n+# endif\n #endif\n \n #ifndef EOF\n-#define EOF (-1)\n+# define EOF (-1)\n #endif\n #ifndef NULL\n-#ifdef __GNUG__\n-#define NULL (__null)\n-#else\n-#if !defined(__cplusplus)\n-#define NULL ((void*)0)\n-#else\n-#define NULL (0)\n-#endif\n-#endif\n+# if defined __GNUG__ && \\\n+    (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))\n+#  define NULL (__null)\n+# else\n+#  if !defined(__cplusplus)\n+#   define NULL ((void*)0)\n+#  else\n+#   define NULL (0)\n+#  endif\n+# endif\n #endif\n \n #define _IOS_INPUT\t1\n@@ -109,7 +105,7 @@ the executable file might be covered by the GNU General Public License. */\n \n /* Magic numbers and bits for the _flags field.\n    The magic numbers use the high-order bits of _flags;\n-   the remaining bits are abailable for variable flags.\n+   the remaining bits are available for variable flags.\n    Note: The magic numbers must all be negative if stdio\n    emulation is desired. */\n \n@@ -130,6 +126,7 @@ the executable file might be covered by the GNU General Public License. */\n #define _IO_CURRENTLY_PUTTING 0x800\n #define _IO_IS_APPENDING 0x1000\n #define _IO_IS_FILEBUF 0x2000\n+#define _IO_BAD_SEEN 0x4000\n \n /* These are \"formatting flags\" matching the iostream fmtflags enum values. */\n #define _IO_SKIPWS 01\n@@ -148,19 +145,21 @@ the executable file might be covered by the GNU General Public License. */\n #define _IO_UNITBUF 020000\n #define _IO_STDIO 040000\n #define _IO_DONT_CLOSE 0100000\n+#define _IO_BOOLALPHA 0200000\n \n-/* A streammarker remembers a position in a buffer. */\n \n struct _IO_jump_t;  struct _IO_FILE;\n \n /* Handle lock.  */\n #ifdef _IO_MTSAFE_IO\n-# include <stdio-lock.h>\n+# include <bits/stdio-lock.h>\n #else\n typedef void _IO_lock_t;\n #endif\n \n \n+/* A streammarker remembers a position in a buffer. */\n+\n struct _IO_marker {\n   struct _IO_marker *_next;\n   struct _IO_FILE *_sbuf;\n@@ -181,11 +180,7 @@ struct _IO_marker {\n };\n \n struct _IO_FILE {\n-#if _G_USE_INT32_FLAGS\n-  _G_int32_t _flags;\t/* High-order word is _IO_MAGIC; rest is flags. */\n-#else\n-  int\t     _flags;\n-#endif\n+  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */\n #define _IO_file_flags _flags\n \n   /* The following pointers correspond to the C++ streambuf protocol. */\n@@ -256,22 +251,22 @@ struct _IO_cookie_file\n extern \"C\" {\n #endif\n \n-extern int __underflow __P((_IO_FILE*));\n-extern int __uflow __P((_IO_FILE*));\n-extern int __overflow __P((_IO_FILE*, int));\n+extern int __underflow __P ((_IO_FILE *));\n+extern int __uflow __P ((_IO_FILE *));\n+extern int __overflow __P ((_IO_FILE *, int));\n \n #define _IO_getc_unlocked(_fp) \\\n-       ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end ? __uflow(_fp) \\\n-\t: *(unsigned char*)(_fp)->_IO_read_ptr++)\n+       ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end ? __uflow (_fp) \\\n+\t: *(unsigned char *) (_fp)->_IO_read_ptr++)\n #define _IO_peekc_unlocked(_fp) \\\n        ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end \\\n-\t  && __underflow(_fp) == EOF ? EOF \\\n-\t: *(unsigned char*)(_fp)->_IO_read_ptr)\n+\t  && __underflow (_fp) == EOF ? EOF \\\n+\t: *(unsigned char *) (_fp)->_IO_read_ptr)\n \n #define _IO_putc_unlocked(_ch, _fp) \\\n    (((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) \\\n-    ? __overflow(_fp, (unsigned char)(_ch)) \\\n-    : (unsigned char)(*(_fp)->_IO_write_ptr++ = (_ch)))\n+    ? __overflow (_fp, (unsigned char) (_ch)) \\\n+    : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))\n \n #define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)\n #define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)\n@@ -301,15 +296,15 @@ extern int _IO_ftrylockfile __P ((_IO_FILE *));\n \n #define _IO_peekc(_fp) _IO_peekc_locked (_fp)\n \n-extern int _IO_vfscanf __P((_IO_FILE*, const char*, _IO_va_list, int*));\n-extern int _IO_vfprintf __P((_IO_FILE*, const char*, _IO_va_list));\n-extern _IO_ssize_t _IO_padn __P((_IO_FILE *, int, _IO_ssize_t));\n-extern _IO_size_t _IO_sgetn __P((_IO_FILE *, void*, _IO_size_t));\n+extern int _IO_vfscanf __P ((_IO_FILE *, const char *, _IO_va_list, int *));\n+extern int _IO_vfprintf __P ((_IO_FILE *, const char *, _IO_va_list));\n+extern _IO_ssize_t _IO_padn __P ((_IO_FILE *, int, _IO_ssize_t));\n+extern _IO_size_t _IO_sgetn __P ((_IO_FILE *, void *, _IO_size_t));\n \n-extern _IO_fpos_t _IO_seekoff __P((_IO_FILE*, _IO_off_t, int, int));\n-extern _IO_fpos_t _IO_seekpos __P((_IO_FILE*, _IO_fpos_t, int));\n+extern _IO_fpos_t _IO_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n+extern _IO_fpos_t _IO_seekpos __P ((_IO_FILE *, _IO_fpos_t, int));\n \n-extern void _IO_free_backup_area __P((_IO_FILE*));\n+extern void _IO_free_backup_area __P ((_IO_FILE *));\n \n #ifdef __cplusplus\n }"}, {"sha": "8ea67defbe23975309ec69b464d744da262f3cf3", "filename": "libio/libioP.h", "status": "modified", "additions": 228, "deletions": 234, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FlibioP.h?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -24,36 +24,16 @@\n    General Public License.  */\n \n #include <errno.h>\n-#ifndef errno\n-extern int errno;\n-#endif\n-#ifndef __set_errno\n-/* This is a GNU libc special.  Simply set errno to the  given value here.  */\n+/* This is a hack until Uli gets me the real fix.  */\n #define __set_errno(Val) (errno = (Val))\n+#if defined __GLIBC__ && __GLIBC__ >= 2\n+# include <bits/libc-lock.h>\n+#else\n+/*# include <comthread.h>*/\n #endif\n-#include <stdio-lock.h>\n \n #include \"iolibio.h\"\n \n-#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(__cplusplus)\n-/* All known AIX compilers implement these things (but don't always\n-   define __STDC__).  The RISC/OS MIPS compiler defines these things\n-   in SVR4 mode, but does not define __STDC__.  */\n-\n-#define\tAND\t\t,\n-#define\tDEFUN(name, arglist, args)\tname(args)\n-#define\tDEFUN_VOID(name)\t\tname(void)\n-\n-#else\t/* Not ANSI C.  */\n-\n-#define\tAND\t\t;\n-#ifndef const /* some systems define it in header files for non-ansi mode */\n-#define\tconst\n-#endif\n-#define\tDEFUN(name, arglist, args)\tname arglist args;\n-#define\tDEFUN_VOID(name)\t\tname()\n-#endif\t/* ANSI C.  */\n-\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -71,119 +51,120 @@ extern \"C\" {\n  * a jump table (of pointers to functions).  The pointer is accessed\n  * with the _IO_JUMPS macro.  The jump table has a eccentric format,\n  * so as to be compatible with the layout of a C++ virtual function table.\n- * (as implemented by g++).  When a pointer to a steambuf object is\n+ * (as implemented by g++).  When a pointer to a streambuf object is\n  * coerced to an (_IO_FILE*), then _IO_JUMPS on the result just\n  * happens to point to the virtual function table of the streambuf.\n  * Thus the _IO_JUMPS function table used for C stdio/libio does\n- * double duty as the virtual functiuon table for C++ streambuf.\n+ * double duty as the virtual function table for C++ streambuf.\n  *\n  * The entries in the _IO_JUMPS function table (and hence also the\n  * virtual functions of a streambuf) are described below.\n  * The first parameter of each function entry is the _IO_FILE/streambuf\n  * object being acted on (i.e. the 'this' parameter).\n  */\n \n-#define _IO_JUMPS(THIS) ((struct _IO_FILE_plus*)(THIS))->vtable\n+#define _IO_JUMPS(THIS) ((struct _IO_FILE_plus *) (THIS))->vtable\n #ifdef _G_USING_THUNKS\n-#define JUMP_FIELD(TYPE, NAME) TYPE NAME\n-#define JUMP0(FUNC, THIS) _IO_JUMPS(THIS)->FUNC(THIS)\n-#define JUMP1(FUNC, THIS, X1) _IO_JUMPS(THIS)->FUNC(THIS, X1)\n-#define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS(THIS)->FUNC(THIS, X1, X2)\n-#define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS(THIS)->FUNC(THIS, X1,X2, X3)\n-#define JUMP_INIT(NAME, VALUE) VALUE\n-#define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0), JUMP_INIT(dummy2, 0)\n+# define JUMP_FIELD(TYPE, NAME) TYPE NAME\n+# define JUMP0(FUNC, THIS) _IO_JUMPS(THIS)->FUNC (THIS)\n+# define JUMP1(FUNC, THIS, X1) _IO_JUMPS(THIS)->FUNC (THIS, X1)\n+# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS(THIS)->FUNC (THIS, X1, X2)\n+# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS(THIS)->FUNC (THIS, X1,X2, X3)\n+# define JUMP_INIT(NAME, VALUE) VALUE\n+# define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)\n #else\n /* These macros will change when we re-implement vtables to use \"thunks\"! */\n-#define JUMP_FIELD(TYPE, NAME) struct { short delta1, delta2; TYPE pfn; } NAME\n-#define JUMP0(FUNC, THIS) _IO_JUMPS(THIS)->FUNC.pfn(THIS)\n-#define JUMP1(FUNC, THIS, X1) _IO_JUMPS(THIS)->FUNC.pfn(THIS, X1)\n-#define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS(THIS)->FUNC.pfn(THIS, X1, X2)\n-#define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS(THIS)->FUNC.pfn(THIS, X1,X2, X3)\n-#define JUMP_INIT(NAME, VALUE) {0, 0, VALUE}\n-#define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0)\n+# define JUMP_FIELD(TYPE, NAME) struct { short delta1, delta2; TYPE pfn; } NAME\n+# define JUMP0(FUNC, THIS) _IO_JUMPS(THIS)->FUNC.pfn (THIS)\n+# define JUMP1(FUNC, THIS, X1) _IO_JUMPS(THIS)->FUNC.pfn (THIS, X1)\n+# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS(THIS)->FUNC.pfn (THIS, X1, X2)\n+# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS(THIS)->FUNC.pfn (THIS, X1,X2,X3)\n+# define JUMP_INIT(NAME, VALUE) {0, 0, VALUE}\n+# define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0)\n #endif\n \n /* The 'finish' function does any final cleaning up of an _IO_FILE object.\n    It does not delete (free) it, but does everything else to finalize it/\n    It matches the streambuf::~streambuf virtual destructor.  */\n-typedef void (*_IO_finish_t) __P((_IO_FILE*, int)); /* finalize */\n-#define _IO_FINISH(FP) JUMP1(__finish, FP, 0)\n+typedef void (*_IO_finish_t) __P ((_IO_FILE *, int)); /* finalize */\n+#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)\n \n /* The 'overflow' hook flushes the buffer.\n    The second argument is a character, or EOF.\n    It matches the streambuf::overflow virtual function. */\n-typedef int (*_IO_overflow_t) __P((_IO_FILE*, int));\n-#define _IO_OVERFLOW(FP, CH) JUMP1(__overflow, FP, CH)\n+typedef int (*_IO_overflow_t) __P ((_IO_FILE *, int));\n+#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n \n /* The 'underflow' hook tries to fills the get buffer.\n    It returns the next character (as an unsigned char) or EOF.  The next\n-   character remains in the get buffer, and the get postion is not changed.\n+   character remains in the get buffer, and the get position is not changed.\n    It matches the streambuf::underflow virtual function. */\n-typedef int (*_IO_underflow_t) __P((_IO_FILE*));\n-#define _IO_UNDERFLOW(FP) JUMP0(__underflow, FP)\n+typedef int (*_IO_underflow_t) __P ((_IO_FILE *));\n+#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)\n \n /* The 'uflow' hook returns the next character in the input stream\n    (cast to unsigned char), and increments the read position;\n    EOF is returned on failure.\n    It matches the streambuf::uflow virtual function, which is not in the\n    cfront implementation, but was added to C++ by the ANSI/ISO committee. */\n-#define _IO_UFLOW(FP) JUMP0(__uflow, FP)\n+#define _IO_UFLOW(FP) JUMP0 (__uflow, FP)\n \n /* The 'pbackfail' hook handles backing up.\n    It matches the streambuf::pbackfail virtual function. */\n-typedef int (*_IO_pbackfail_t) __P((_IO_FILE*, int));\n-#define _IO_PBACKFAIL(FP, CH) JUMP1(__pbackfail, FP, CH)\n+typedef int (*_IO_pbackfail_t) __P ((_IO_FILE *, int));\n+#define _IO_PBACKFAIL(FP, CH) JUMP1 (__pbackfail, FP, CH)\n \n /* The 'xsputn' hook writes upto N characters from buffer DATA.\n    Returns the number of character actually written.\n    It matches the streambuf::xsputn virtual function. */\n-typedef _IO_size_t (*_IO_xsputn_t)\n-  __P((_IO_FILE *FP, const void *DATA, _IO_size_t N));\n-#define _IO_XSPUTN(FP, DATA, N) JUMP2(__xsputn, FP, DATA, N)\n+typedef _IO_size_t (*_IO_xsputn_t) __P ((_IO_FILE *FP, const void *DATA,\n+\t\t\t\t\t _IO_size_t N));\n+#define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)\n \n /* The 'xsgetn' hook reads upto N characters into buffer DATA.\n    Returns the number of character actually read.\n    It matches the streambuf::xsgetn virtual function. */\n-typedef _IO_size_t (*_IO_xsgetn_t) __P((_IO_FILE*FP, void*DATA, _IO_size_t N));\n-#define _IO_XSGETN(FP, DATA, N) JUMP2(__xsgetn, FP, DATA, N)\n+typedef _IO_size_t (*_IO_xsgetn_t) __P ((_IO_FILE *FP, void *DATA,\n+\t\t\t\t\t _IO_size_t N));\n+#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)\n \n /* The 'seekoff' hook moves the stream position to a new position\n    relative to the start of the file (if DIR==0), the current position\n    (MODE==1), or the end of the file (MODE==2).\n    It matches the streambuf::seekoff virtual function.\n    It is also used for the ANSI fseek function. */\n-typedef _IO_fpos_t (*_IO_seekoff_t)\n-  __P((_IO_FILE* FP, _IO_off_t OFF, int DIR, int MODE));\n-#define _IO_SEEKOFF(FP, OFF, DIR, MODE) JUMP3(__seekoff, FP, OFF, DIR, MODE)\n+typedef _IO_fpos_t (*_IO_seekoff_t) __P ((_IO_FILE *FP, _IO_off_t OFF,\n+\t\t\t\t\t  int DIR, int MODE));\n+#define _IO_SEEKOFF(FP, OFF, DIR, MODE) JUMP3 (__seekoff, FP, OFF, DIR, MODE)\n \n /* The 'seekpos' hook also moves the stream position,\n    but to an absolute position given by a fpos_t (seekpos).\n    It matches the streambuf::seekpos virtual function.\n    It is also used for the ANSI fgetpos and fsetpos functions.  */\n /* The _IO_seek_cur and _IO_seek_end options are not allowed. */\n-typedef _IO_fpos_t (*_IO_seekpos_t) __P((_IO_FILE*, _IO_fpos_t, int));\n-#define _IO_SEEKPOS(FP, POS, FLAGS) JUMP2(__seekpos, FP, POS, FLAGS)\n+typedef _IO_fpos_t (*_IO_seekpos_t) __P ((_IO_FILE *, _IO_fpos_t, int));\n+#define _IO_SEEKPOS(FP, POS, FLAGS) JUMP2 (__seekpos, FP, POS, FLAGS)\n \n /* The 'setbuf' hook gives a buffer to the file.\n    It matches the streambuf::setbuf virtual function. */\n-typedef _IO_FILE* (*_IO_setbuf_t) __P((_IO_FILE*, char *, _IO_ssize_t));\n-#define _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2(__setbuf, FP, BUFFER, LENGTH)\n+typedef _IO_FILE* (*_IO_setbuf_t) __P ((_IO_FILE *, char *, _IO_ssize_t));\n+#define _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2 (__setbuf, FP, BUFFER, LENGTH)\n \n /* The 'sync' hook attempts to synchronize the internal data structures\n    of the file with the external state.\n    It matches the streambuf::sync virtual function. */\n-typedef int (*_IO_sync_t) __P((_IO_FILE*));\n-#define _IO_SYNC(FP) JUMP0(__sync, FP)\n+typedef int (*_IO_sync_t) __P ((_IO_FILE *));\n+#define _IO_SYNC(FP) JUMP0 (__sync, FP)\n \n /* The 'doallocate' hook is used to tell the file to allocate a buffer.\n    It matches the streambuf::doallocate virtual function, which is not\n    in the ANSI/ISO C++ standard, but is part traditional implementations. */\n-typedef int (*_IO_doallocate_t) __P((_IO_FILE*));\n-#define _IO_DOALLOCATE(FP) JUMP0(__doallocate, FP)\n+typedef int (*_IO_doallocate_t) __P ((_IO_FILE *));\n+#define _IO_DOALLOCATE(FP) JUMP0 (__doallocate, FP)\n \n /* The following four hooks (sysread, syswrite, sysclose, sysseek, and\n    sysstat) are low-level hooks specific to this implementation.\n-   There is no correspondance in the ANSI/ISO C++ standard library.\n+   There is no correspondence in the ANSI/ISO C++ standard library.\n    The hooks basically correspond to the Unix system functions\n    (read, write, close, lseek, and stat) except that a _IO_FILE*\n    parameter is used instead of a integer file descriptor;  the default\n@@ -195,43 +176,44 @@ typedef int (*_IO_doallocate_t) __P((_IO_FILE*));\n /* The 'sysread' hook is used to read data from the external file into\n    an existing buffer.  It generalizes the Unix read(2) function.\n    It matches the streambuf::sys_read virtual function, which is\n-   specific to this implementaion. */\n-typedef _IO_ssize_t (*_IO_read_t) __P((_IO_FILE*, void*, _IO_ssize_t));\n-#define _IO_SYSREAD(FP, DATA, LEN) JUMP2(__read, FP, DATA, LEN)\n+   specific to this implementation. */\n+typedef _IO_ssize_t (*_IO_read_t) __P ((_IO_FILE *, void *, _IO_ssize_t));\n+#define _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)\n \n /* The 'syswrite' hook is used to write data from an existing buffer\n    to an external file.  It generalizes the Unix write(2) function.\n    It matches the streambuf::sys_write virtual function, which is\n-   specific to this implementaion. */\n-typedef _IO_ssize_t (*_IO_write_t) __P((_IO_FILE*,const void*,_IO_ssize_t));\n-#define _IO_SYSWRITE(FP, DATA, LEN) JUMP2(__write, FP, DATA, LEN)\n+   specific to this implementation. */\n+typedef _IO_ssize_t (*_IO_write_t) __P ((_IO_FILE *,const void *,_IO_ssize_t));\n+#define _IO_SYSWRITE(FP, DATA, LEN) JUMP2 (__write, FP, DATA, LEN)\n \n /* The 'sysseek' hook is used to re-position an external file.\n    It generalizes the Unix lseek(2) function.\n    It matches the streambuf::sys_seek virtual function, which is\n-   specific to this implementaion. */\n-typedef _IO_fpos_t (*_IO_seek_t) __P((_IO_FILE*, _IO_off_t, int));\n-#define _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2(__seek, FP, OFFSET, MODE)\n+   specific to this implementation. */\n+typedef _IO_fpos_t (*_IO_seek_t) __P ((_IO_FILE *, _IO_off_t, int));\n+#define _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2 (__seek, FP, OFFSET, MODE)\n \n /* The 'sysclose' hook is used to finalize (close, finish up) an\n    external file.  It generalizes the Unix close(2) function.\n    It matches the streambuf::sys_close virtual function, which is\n    specific to this implementation. */\n-typedef int (*_IO_close_t) __P((_IO_FILE*)); /* finalize */\n-#define _IO_SYSCLOSE(FP) JUMP0(__close, FP)\n+typedef int (*_IO_close_t) __P ((_IO_FILE *)); /* finalize */\n+#define _IO_SYSCLOSE(FP) JUMP0 (__close, FP)\n \n /* The 'sysstat' hook is used to get information about an external file\n    into a struct stat buffer.  It generalizes the Unix fstat(2) call.\n    It matches the streambuf::sys_stat virtual function, which is\n-   specific to this implementaion. */\n-typedef int (*_IO_stat_t) __P((_IO_FILE*, void*));\n-#define _IO_SYSSTAT(FP, BUF) JUMP1(__stat, FP, BUF)\n+   specific to this implementation. */\n+typedef int (*_IO_stat_t) __P ((_IO_FILE *, void *));\n+#define _IO_SYSSTAT(FP, BUF) JUMP1 (__stat, FP, BUF)\n \n \n #define _IO_CHAR_TYPE char /* unsigned char ? */\n #define _IO_INT_TYPE int\n \n-struct _IO_jump_t {\n+struct _IO_jump_t\n+{\n     JUMP_FIELD(_G_size_t, __dummy);\n #ifdef _G_USING_THUNKS\n     JUMP_FIELD(_G_size_t, __dummy2);\n@@ -265,63 +247,69 @@ struct _IO_jump_t {\n    This is for compatibility with C++ streambuf; the word can\n    be used to smash to a pointer to a virtual function table. */\n \n-struct _IO_FILE_plus {\n+struct _IO_FILE_plus\n+{\n   _IO_FILE file;\n   const struct _IO_jump_t *vtable;\n };\n \n /* Generic functions */\n \n-extern _IO_fpos_t _IO_seekoff __P((_IO_FILE*, _IO_off_t, int, int));\n-extern _IO_fpos_t _IO_seekpos __P((_IO_FILE*, _IO_fpos_t, int));\n-\n-extern int _IO_switch_to_get_mode __P((_IO_FILE*));\n-extern void _IO_init __P((_IO_FILE*, int));\n-extern int _IO_sputbackc __P((_IO_FILE*, int));\n-extern int _IO_sungetc __P((_IO_FILE*));\n-extern void _IO_un_link __P((_IO_FILE*));\n-extern void _IO_link_in __P((_IO_FILE *));\n-extern void _IO_doallocbuf __P((_IO_FILE*));\n-extern void _IO_unsave_markers __P((_IO_FILE*));\n-extern void _IO_setb __P((_IO_FILE*, char*, char*, int));\n-extern unsigned _IO_adjust_column __P((unsigned, const char *, int));\n-#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN(__fp, __s, __n)\n+extern _IO_fpos_t _IO_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n+extern _IO_fpos_t _IO_seekpos __P ((_IO_FILE *, _IO_fpos_t, int));\n+\n+extern void _IO_switch_to_main_get_area __P ((_IO_FILE *));\n+extern void _IO_switch_to_backup_area __P ((_IO_FILE *));\n+extern int _IO_switch_to_get_mode __P ((_IO_FILE *));\n+extern void _IO_init __P ((_IO_FILE *, int));\n+extern int _IO_sputbackc __P ((_IO_FILE *, int));\n+extern int _IO_sungetc __P ((_IO_FILE *));\n+extern void _IO_un_link __P ((_IO_FILE *));\n+extern void _IO_link_in __P ((_IO_FILE *));\n+extern void _IO_doallocbuf __P ((_IO_FILE *));\n+extern void _IO_unsave_markers __P ((_IO_FILE *));\n+extern void _IO_setb __P ((_IO_FILE *, char *, char *, int));\n+extern unsigned _IO_adjust_column __P ((unsigned, const char *, int));\n+#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)\n \n /* Marker-related function. */\n \n-extern void _IO_init_marker __P((struct _IO_marker *, _IO_FILE *));\n-extern void _IO_remove_marker __P((struct _IO_marker*));\n-extern int _IO_marker_difference __P((struct _IO_marker *, struct _IO_marker *));\n-extern int _IO_marker_delta __P((struct _IO_marker *));\n-extern int _IO_seekmark __P((_IO_FILE *, struct _IO_marker *, int));\n+extern void _IO_init_marker __P ((struct _IO_marker *, _IO_FILE *));\n+extern void _IO_remove_marker __P ((struct _IO_marker *));\n+extern int _IO_marker_difference __P ((struct _IO_marker *,\n+\t\t\t\t       struct _IO_marker *));\n+extern int _IO_marker_delta __P ((struct _IO_marker *));\n+extern int _IO_seekmark __P ((_IO_FILE *, struct _IO_marker *, int));\n \n /* Default jumptable functions. */\n \n-extern int _IO_default_underflow __P((_IO_FILE*));\n-extern int _IO_default_uflow __P((_IO_FILE*));\n-extern int _IO_default_doallocate __P((_IO_FILE*));\n-extern void _IO_default_finish __P((_IO_FILE *, int));\n-extern int _IO_default_pbackfail __P((_IO_FILE*, int));\n-extern _IO_FILE* _IO_default_setbuf __P((_IO_FILE *, char*, _IO_ssize_t));\n-extern _IO_size_t _IO_default_xsputn __P((_IO_FILE *, const void*, _IO_size_t));\n-extern _IO_size_t _IO_default_xsgetn __P((_IO_FILE *, void*, _IO_size_t));\n-extern _IO_fpos_t _IO_default_seekoff __P((_IO_FILE*, _IO_off_t, int, int));\n-extern _IO_fpos_t _IO_default_seekpos __P((_IO_FILE*, _IO_fpos_t, int));\n-extern _IO_ssize_t _IO_default_write __P((_IO_FILE*,const void*,_IO_ssize_t));\n-extern _IO_ssize_t _IO_default_read __P((_IO_FILE*, void*, _IO_ssize_t));\n-extern int _IO_default_stat __P((_IO_FILE*, void*));\n-extern _IO_fpos_t _IO_default_seek __P((_IO_FILE*, _IO_off_t, int));\n-extern int _IO_default_sync __P((_IO_FILE*));\n-#define _IO_default_close ((_IO_close_t)_IO_default_sync)\n+extern int _IO_default_underflow __P ((_IO_FILE *));\n+extern int _IO_default_uflow __P ((_IO_FILE *));\n+extern int _IO_default_doallocate __P ((_IO_FILE *));\n+extern void _IO_default_finish __P ((_IO_FILE *, int));\n+extern int _IO_default_pbackfail __P ((_IO_FILE *, int));\n+extern _IO_FILE* _IO_default_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n+extern _IO_size_t _IO_default_xsputn __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t   _IO_size_t));\n+extern _IO_size_t _IO_default_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n+extern _IO_fpos_t _IO_default_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n+extern _IO_fpos_t _IO_default_seekpos __P ((_IO_FILE *, _IO_fpos_t, int));\n+extern _IO_ssize_t _IO_default_write __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t   _IO_ssize_t));\n+extern _IO_ssize_t _IO_default_read __P ((_IO_FILE *, void *, _IO_ssize_t));\n+extern int _IO_default_stat __P ((_IO_FILE *, void *));\n+extern _IO_fpos_t _IO_default_seek __P ((_IO_FILE *, _IO_off_t, int));\n+extern int _IO_default_sync __P ((_IO_FILE *));\n+#define _IO_default_close ((_IO_close_t) _IO_default_sync)\n \n extern struct _IO_jump_t _IO_file_jumps;\n extern struct _IO_jump_t _IO_streambuf_jumps;\n extern struct _IO_jump_t _IO_proc_jumps;\n extern struct _IO_jump_t _IO_str_jumps;\n-extern int _IO_do_write __P((_IO_FILE*, const char*, _IO_size_t));\n-extern int _IO_flush_all __P((void));\n-extern void _IO_cleanup __P((void));\n-extern void _IO_flush_all_linebuffered __P((void));\n+extern int _IO_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n+extern int _IO_flush_all __P ((void));\n+extern void _IO_cleanup __P ((void));\n+extern void _IO_flush_all_linebuffered __P ((void));\n \n #define _IO_do_flush(_f) \\\n   _IO_do_write(_f, (_f)->_IO_write_base, \\\n@@ -340,42 +328,41 @@ extern void _IO_flush_all_linebuffered __P((void));\n \n /* Jumptable functions for files. */\n \n-extern int _IO_file_doallocate __P((_IO_FILE*));\n-extern _IO_FILE* _IO_file_setbuf __P((_IO_FILE *, char*, _IO_ssize_t));\n-extern _IO_fpos_t _IO_file_seekoff __P((_IO_FILE*, _IO_off_t, int, int));\n-extern _IO_size_t _IO_file_xsputn __P((_IO_FILE*,const void*,_IO_size_t));\n-extern int _IO_file_stat __P((_IO_FILE*, void*));\n-extern int _IO_file_close __P((_IO_FILE*));\n-extern int _IO_file_underflow __P((_IO_FILE *));\n-extern int _IO_file_overflow __P((_IO_FILE *, int));\n+extern int _IO_file_doallocate __P ((_IO_FILE *));\n+extern _IO_FILE* _IO_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n+extern _IO_fpos_t _IO_file_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n+extern _IO_size_t _IO_file_xsputn __P ((_IO_FILE *, const void *, _IO_size_t));\n+extern int _IO_file_stat __P ((_IO_FILE *, void *));\n+extern int _IO_file_close __P ((_IO_FILE *));\n+extern int _IO_file_underflow __P ((_IO_FILE *));\n+extern int _IO_file_overflow __P ((_IO_FILE *, int));\n #define _IO_file_is_open(__fp) ((__fp)->_fileno >= 0)\n-extern void _IO_file_init __P((_IO_FILE*));\n-extern _IO_FILE* _IO_file_fopen __P((_IO_FILE*, const char*, const char*));\n-extern _IO_ssize_t _IO_file_write __P((_IO_FILE*,const void*,_IO_ssize_t));\n-extern _IO_ssize_t _IO_file_read __P((_IO_FILE*, void*, _IO_ssize_t));\n-extern int _IO_file_sync __P((_IO_FILE*));\n-extern int _IO_file_close_it __P((_IO_FILE*));\n-extern _IO_fpos_t _IO_file_seek __P((_IO_FILE *, _IO_off_t, int));\n-extern void _IO_file_finish __P((_IO_FILE*, int));\n-\n-/* Other file functions. */\n-extern _IO_FILE* _IO_file_attach __P((_IO_FILE *, int));\n+extern void _IO_file_init __P ((_IO_FILE *));\n+extern _IO_FILE* _IO_file_attach __P ((_IO_FILE *, int));\n+extern _IO_FILE* _IO_file_fopen __P ((_IO_FILE *, const char *, const char *));\n+extern _IO_ssize_t _IO_file_write __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t_IO_ssize_t));\n+extern _IO_ssize_t _IO_file_read __P ((_IO_FILE *, void *, _IO_ssize_t));\n+extern int _IO_file_sync __P ((_IO_FILE *));\n+extern int _IO_file_close_it __P ((_IO_FILE *));\n+extern _IO_fpos_t _IO_file_seek __P ((_IO_FILE *, _IO_off_t, int));\n+extern void _IO_file_finish __P ((_IO_FILE *, int));\n \n /* Jumptable functions for proc_files. */\n-extern _IO_FILE* _IO_proc_open __P((_IO_FILE*, const char*, const char *));\n-extern int _IO_proc_close __P((_IO_FILE*));\n+extern _IO_FILE* _IO_proc_open __P ((_IO_FILE *, const char *, const char *));\n+extern int _IO_proc_close __P ((_IO_FILE *));\n \n /* Jumptable functions for strfiles. */\n-extern int _IO_str_underflow __P((_IO_FILE*));\n-extern int _IO_str_overflow __P((_IO_FILE *, int));\n-extern int _IO_str_pbackfail __P((_IO_FILE*, int));\n-extern _IO_fpos_t _IO_str_seekoff __P((_IO_FILE*,_IO_off_t,int,int));\n-extern void _IO_str_finish __P ((_IO_FILE*, int));\n+extern int _IO_str_underflow __P ((_IO_FILE *));\n+extern int _IO_str_overflow __P ((_IO_FILE *, int));\n+extern int _IO_str_pbackfail __P ((_IO_FILE *, int));\n+extern _IO_fpos_t _IO_str_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n+extern void _IO_str_finish __P ((_IO_FILE *, int));\n \n /* Other strfile functions */\n-extern void _IO_str_init_static __P((_IO_FILE *, char*, int, char*));\n-extern void _IO_str_init_readonly __P((_IO_FILE *, const char*, int));\n-extern _IO_ssize_t _IO_str_count __P ((_IO_FILE*));\n+extern void _IO_str_init_static __P ((_IO_FILE *, char *, int, char *));\n+extern void _IO_str_init_readonly __P ((_IO_FILE *, const char *, int));\n+extern _IO_ssize_t _IO_str_count __P ((_IO_FILE *));\n \n extern int _IO_vasprintf __P ((char **result_ptr, __const char *format,\n \t\t\t       _IO_va_list args));\n@@ -384,89 +371,97 @@ extern int _IO_vsnprintf __P ((char *string, _IO_size_t maxlen,\n \t\t\t       __const char *format, _IO_va_list args));\n \n \n-extern _IO_size_t _IO_getline __P((_IO_FILE*,char*,_IO_size_t,int,int));\n-extern _IO_ssize_t _IO_getdelim __P((char**, _IO_size_t*, int, _IO_FILE*));\n-extern double _IO_strtod __P((const char *, char **));\n-extern char * _IO_dtoa __P((double __d, int __mode, int __ndigits,\n-\t\t\t\tint *__decpt, int *__sign, char **__rve));\n-extern int _IO_outfloat __P((double __value, _IO_FILE *__sb, int __type,\n-\t\t\t\t int __width, int __precision, int __flags,\n-\t\t\t\t int __sign_mode, int __fill));\n+extern _IO_size_t _IO_getline __P ((_IO_FILE *,char *, _IO_size_t, int, int));\n+extern _IO_ssize_t _IO_getdelim __P ((char **, _IO_size_t *, int, _IO_FILE *));\n+extern double _IO_strtod __P ((const char *, char **));\n+extern char *_IO_dtoa __P ((double __d, int __mode, int __ndigits,\n+\t\t\t    int *__decpt, int *__sign, char **__rve));\n+extern int _IO_outfloat __P ((double __value, _IO_FILE *__sb, int __type,\n+\t\t\t      int __width, int __precision, int __flags,\n+\t\t\t      int __sign_mode, int __fill));\n \n extern _IO_FILE *_IO_list_all;\n extern void (*_IO_cleanup_registration_needed) __P ((void));\n \n #ifndef EOF\n-#define EOF (-1)\n+# define EOF (-1)\n #endif\n #ifndef NULL\n-#ifdef __GNUG__\n-#define NULL (__null)\n-#else\n-#if !defined(__cplusplus)\n-#define NULL ((void*)0)\n-#else\n-#define NULL (0)\n-#endif\n-#endif\n+# if defined __GNUG__ && \\\n+    (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))\n+#  define NULL (__null)\n+# else\n+#  if !defined(__cplusplus)\n+#   define NULL ((void*)0)\n+#  else\n+#   define NULL (0)\n+#  endif\n+# endif\n #endif\n \n #if _G_HAVE_MMAP\n \n-#include <unistd.h>\n-#include <fcntl.h>\n-#include <sys/mman.h>\n-#include <sys/param.h>\n+# include <unistd.h>\n+# include <fcntl.h>\n+# include <sys/mman.h>\n+# include <sys/param.h>\n \n-#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n-#define MAP_ANONYMOUS MAP_ANON\n-#endif\n+# if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n+#  define MAP_ANONYMOUS MAP_ANON\n+# endif\n \n-#if !defined(MAP_ANONYMOUS) || !defined(EXEC_PAGESIZE)\n-#undef _G_HAVE_MMAP\n-#define _G_HAVE_MMAP 0\n-#endif\n+# if !defined(MAP_ANONYMOUS) || !defined(EXEC_PAGESIZE)\n+#  undef _G_HAVE_MMAP\n+#  define _G_HAVE_MMAP 0\n+# endif\n \n #endif /* _G_HAVE_MMAP */\n \n #if _G_HAVE_MMAP\n \n-#define ROUND_TO_PAGE(_S) \\\n+# ifdef _LIBC\n+/* When using this code in the GNU libc we must not pollute the name space.  */\n+#  define mmap __mmap\n+#  define munmap __munmap\n+# endif\n+\n+# define ROUND_TO_PAGE(_S) \\\n        (((_S) + EXEC_PAGESIZE - 1) & ~(EXEC_PAGESIZE - 1))\n \n-#define FREE_BUF(_B, _S) \\\n+# define FREE_BUF(_B, _S) \\\n        munmap ((_B), ROUND_TO_PAGE (_S))\n-#define ALLOC_BUF(_B, _S, _R) \\\n+# define ALLOC_BUF(_B, _S, _R) \\\n        do {\t\t\t\t\t\t\t\t      \\\n-         (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),\t\t\t      \\\n-                               PROT_READ | PROT_WRITE,\t\t\t      \\\n-                               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n-         if ((_B) == (char *) -1)\t\t\t\t\t      \\\n-           return _R;\t\t\t\t\t\t\t      \\\n+\t  (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),\t\t\t      \\\n+\t\t\t\tPROT_READ | PROT_WRITE,\t\t\t      \\\n+\t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n+\t  if ((_B) == (char *) -1)\t\t\t\t\t      \\\n+\t    return (_R);\t\t\t\t\t\t      \\\n        } while (0)\n \n #else /* _G_HAVE_MMAP */\n \n-#define FREE_BUF(_B, _S) \\\n+# define FREE_BUF(_B, _S) \\\n        free(_B)\n-#define ALLOC_BUF(_B, _S, _R) \\\n+# define ALLOC_BUF(_B, _S, _R) \\\n        do {\t\t\t\t\t\t\t\t      \\\n-         (_B) = (char*)malloc(_S);\t\t\t\t\t      \\\n-         if ((_B) == NULL)\t\t\t\t\t\t      \\\n-           return _R;\t\t\t\t\t\t\t      \\\n+\t  (_B) = (char*)malloc(_S);\t\t\t\t\t      \\\n+\t  if ((_B) == NULL)\t\t\t\t\t\t      \\\n+\t    return (_R);\t\t\t\t\t\t      \\\n        } while (0)\n \n #endif /* _G_HAVE_MMAP */\n \n #ifndef OS_FSTAT\n-#define OS_FSTAT fstat\n+# define OS_FSTAT fstat\n #endif\n struct stat;\n-extern _IO_ssize_t _IO_read __P((int, void*, _IO_size_t));\n-extern _IO_ssize_t _IO_write __P((int, const void*, _IO_size_t));\n-extern _IO_off_t _IO_lseek __P((int, _IO_off_t, int));\n-extern int _IO_close __P((int));\n-extern int _IO_fstat __P((int, struct stat *));\n+extern _IO_ssize_t _IO_read __P ((int, void *, _IO_size_t));\n+extern _IO_ssize_t _IO_write __P ((int, const void *, _IO_size_t));\n+extern _IO_off_t _IO_lseek __P ((int, _IO_off_t, int));\n+extern int _IO_close __P ((int));\n+extern int _IO_fstat __P ((int, struct stat *));\n+extern int _IO_vscanf __P ((const char *, _IO_va_list));\n \n /* Operations on _IO_fpos_t.\n    Normally, these are trivial, but we provide hooks for configurations\n@@ -475,19 +470,19 @@ extern int _IO_fstat __P((int, struct stat *));\n \n /* _IO_pos_BAD is an _IO_fpos_t value indicating error, unknown, or EOF. */\n #ifndef _IO_pos_BAD\n-#define _IO_pos_BAD ((_IO_fpos_t)(-1))\n+# define _IO_pos_BAD ((_IO_fpos_t) -1)\n #endif\n /* _IO_pos_as_off converts an _IO_fpos_t value to an _IO_off_t value. */\n #ifndef _IO_pos_as_off\n-#define _IO_pos_as_off(__pos) ((_IO_off_t)(__pos))\n+# define _IO_pos_as_off(__pos) ((_IO_off_t) (__pos))\n #endif\n /* _IO_pos_adjust adjust an _IO_fpos_t by some number of bytes. */\n #ifndef _IO_pos_adjust\n-#define _IO_pos_adjust(__pos, __delta) ((__pos) += (__delta))\n+# define _IO_pos_adjust(__pos, __delta) ((__pos) += (__delta))\n #endif\n /* _IO_pos_0 is an _IO_fpos_t value indicating beginning of file. */\n #ifndef _IO_pos_0\n-#define _IO_pos_0 ((_IO_fpos_t)0)\n+# define _IO_pos_0 ((_IO_fpos_t) 0)\n #endif\n \n #ifdef __cplusplus\n@@ -496,71 +491,70 @@ extern int _IO_fstat __P((int, struct stat *));\n \n #ifdef _IO_MTSAFE_IO\n /* check following! */\n-#define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n-\t{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n-\t  0, 0, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock }\n+# define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n+       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n+         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t   0, 0, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock }\n #else\n /* check following! */\n-#define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n+# define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n        { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD}\n+\t   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD }\n #endif\n \n /* VTABLE_LABEL defines NAME as of the CLASS class.\n    CNLENGTH is strlen(#CLASS).  */\n #ifdef __GNUC__\n-#if _G_VTABLE_LABEL_HAS_LENGTH\n-#define VTABLE_LABEL(NAME, CLASS, CNLENGTH) \\\n+# if _G_VTABLE_LABEL_HAS_LENGTH\n+#  define VTABLE_LABEL(NAME, CLASS, CNLENGTH) \\\n   extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CNLENGTH #CLASS);\n-#else\n-#define VTABLE_LABEL(NAME, CLASS, CNLENGTH) \\\n+# else\n+#  define VTABLE_LABEL(NAME, CLASS, CNLENGTH) \\\n   extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CLASS);\n-#endif\n+# endif\n #endif /* __GNUC__ */\n \n #if !defined(builtinbuf_vtable) && defined(__cplusplus)\n-#ifdef __GNUC__\n+# ifdef __GNUC__\n VTABLE_LABEL(builtinbuf_vtable, builtinbuf, 10)\n-#else\n-#if _G_VTABLE_LABEL_HAS_LENGTH\n-#define builtinbuf_vtable _G_VTABLE_LABEL_PREFIX_ID##10builtinbuf\n-#else\n-#define builtinbuf_vtable _G_VTABLE_LABEL_PREFIX_ID##builtinbuf\n-#endif\n-#endif\n+# else\n+#  if _G_VTABLE_LABEL_HAS_LENGTH\n+#   define builtinbuf_vtable _G_VTABLE_LABEL_PREFIX_ID##10builtinbuf\n+#  else\n+#   define builtinbuf_vtable _G_VTABLE_LABEL_PREFIX_ID##builtinbuf\n+#  endif\n+# endif\n #endif /* !defined(builtinbuf_vtable) && defined(__cplusplus) */\n \n #if defined(__STDC__) || defined(__cplusplus)\n-#define _IO_va_start(args, last) va_start(args, last)\n+# define _IO_va_start(args, last) va_start(args, last)\n #else\n-#define _IO_va_start(args, last) va_start(args)\n+# define _IO_va_start(args, last) va_start(args)\n #endif\n \n extern struct _IO_fake_stdiobuf _IO_stdin_buf, _IO_stdout_buf, _IO_stderr_buf;\n \n #if 1\n-#define COERCE_FILE(FILE) /* Nothing */\n+# define COERCE_FILE(FILE) /* Nothing */\n #else\n /* This is part of the kludge for binary compatibility with old stdio. */\n-#define COERCE_FILE(FILE) \\\n+# define COERCE_FILE(FILE) \\\n   (((FILE)->_IO_file_flags & _IO_MAGIC_MASK) == _OLD_MAGIC_MASK \\\n     && (FILE) = *(FILE**)&((int*)fp)[1])\n #endif\n \n #ifdef EINVAL\n-#define MAYBE_SET_EINVAL __set_errno (EINVAL)\n+# define MAYBE_SET_EINVAL __set_errno (EINVAL)\n #else\n-#define MAYBE_SET_EINVAL /* nothing */\n+# define MAYBE_SET_EINVAL /* nothing */\n #endif\n \n-#ifdef DEBUG\n-#define CHECK_FILE(FILE,RET) \\\n+#ifdef IO_DEBUG\n+# define CHECK_FILE(FILE, RET) \\\n \tif ((FILE) == NULL) { MAYBE_SET_EINVAL; return RET; } \\\n \telse { COERCE_FILE(FILE); \\\n \t       if (((FILE)->_IO_file_flags & _IO_MAGIC_MASK) != _IO_MAGIC) \\\n \t  { MAYBE_SET_EINVAL; return RET; }}\n #else\n-#define CHECK_FILE(FILE,RET) \\\n-\tCOERCE_FILE(FILE)\n+# define CHECK_FILE(FILE, RET) COERCE_FILE (FILE)\n #endif"}, {"sha": "f08f2efaa39e0e0934eeba57c4270673b8292a78", "filename": "libio/osform.cc", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fosform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fosform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fosform.cc?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -29,26 +29,38 @@ the executable file might be covered by the GNU General Public License. */\n ostream& ostream::form(const char *format ...)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tva_list ap;\n \tva_start(ap, format);\n \t_IO_vfprintf(rdbuf(), format, ap);\n \tva_end(ap);\n+\tosfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n ostream& ostream::vform(const char *format, _IO_va_list args)\n {\n-    if (opfx())\n+    if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \t_IO_vfprintf(rdbuf(), format, args);\n+\tosfx();\n+\t_IO_cleanup_region_end (0);\n+    }\n     return *this;\n }\n \n ostream& ostream::operator<<(const void *p)\n {\n     if (opfx()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tform(\"%p\", p);\n \tosfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }"}, {"sha": "5cbb6c925982a978baa4975c1fcde2146c281d96", "filename": "libio/outfloat.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Foutfloat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Foutfloat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Foutfloat.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -24,6 +24,7 @@ the executable file might be covered by the GNU General Public License. */\n \n #include \"libioP.h\"\n \n+#ifdef _IO_USE_DTOA\n /* Format floating-point number and print them.\n    Return number of chars printed, or EOF on error.\n \n@@ -33,10 +34,15 @@ the executable file might be covered by the GNU General Public License. */\n */\n \n int\n-DEFUN(_IO_outfloat, (value, sb, type, width, precision, flags,\n-\t\t     sign_mode, fill),\n-      double value AND _IO_FILE *sb AND int type AND int width\n-      AND int precision AND int flags AND int sign_mode AND int fill)\n+_IO_outfloat (value, sb, type, width, precision, flags, sign_mode, fill)\n+     double value;\n+     _IO_FILE *sb;\n+     int type;\n+     int width;\n+     int precision;\n+     int flags;\n+     int sign_mode;\n+     int fill;\n {\n   int count = 0;\n #define PUT(x) do {if (_IO_putc(x, sb) < 0) goto error; count++;} while (0)\n@@ -202,3 +208,4 @@ DEFUN(_IO_outfloat, (value, sb, type, width, precision, flags,\n  error:\n   return EOF;\n }\n+#endif"}, {"sha": "42dc21883360a87978adc317913a83ec8255fb54", "filename": "libio/stdio-lock.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610ce97e654a9f2ed5e103bddd936988c5768538/libio%2Fstdio-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610ce97e654a9f2ed5e103bddd936988c5768538/libio%2Fstdio-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio-lock.h?ref=610ce97e654a9f2ed5e103bddd936988c5768538", "patch": "@@ -1 +0,0 @@\n-/* this will be used later*/"}, {"sha": "f98baec0955bd87d962faa767558d460c30efe06", "filename": "libio/stdio/ChangeLog", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2FChangeLog?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -65,7 +65,7 @@ Wed May 10 03:05:53 1995  Jason Merrill  <jason@python.cygnus.com>\n Tue Oct 18 17:15:09 1994  Per Bothner  <bothner@kalessin.cygnus.com>\n \n \t* getline.c, snprintf.c, vsnprintf.c:  New files, providing\n-\tfunctionality of the GNU C C library.\n+\tfunctionality of the GNU C library.\n \t* Makefile.in (STDIO_OBJECTS), configure.in:  Add new files.\n \t* stdio.h:  Add new functions.\n \n@@ -131,4 +131,3 @@ Fri Aug 20 00:28:28 1993  Per Bothner  (bothner@kalessin.cygnus.com)\n \t* configure.in (stdio_renamed):  Removed feof.\n \tAdded sprintf sscanf vsscanf.\n \t* ChangeLog.old:  Copy of old libg++/iostream/stdio/ChangeLog.\n-"}, {"sha": "d06de044fba5f8b36e5a0ab17e826dc05de336f2", "filename": "libio/stdio/feof.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Ffeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Ffeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffeof.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,34 +1,43 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include \"stdio.h\"\n \n int\n-feof(fp)\n+_IO_feof (fp)\n      _IO_FILE* fp;\n {\n-  CHECK_FILE(fp, EOF);\n-  return _IO_feof(fp);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_flockfile (fp);\n+  result = _IO_feof_unlocked (fp);\n+  _IO_funlockfile (fp);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_feof, feof)\n+#endif"}, {"sha": "855627ade66d987e08c3acf905918751bad23b8e", "filename": "libio/stdio/ferror.c", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fferror.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,10 +1,43 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n int\n-ferror(fp)\n-     FILE* fp;\n+_IO_ferror (fp)\n+     _IO_FILE* fp;\n {\n-  CHECK_FILE(fp, EOF);\n-  return _IO_ferror(fp);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_flockfile (fp);\n+  result = _IO_ferror_unlocked (fp);\n+  _IO_funlockfile (fp);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_ferror, ferror)\n+#endif"}, {"sha": "1dc53b5ed65138806a7f222cd5477b1ce80d8a56", "filename": "libio/stdio/getc.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fgetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fgetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetc.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,11 +1,48 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n-#undef getc\n+#undef _IO_getc\n \n int\n-getc(stream)\n-  FILE *stream;\n+_IO_getc (fp)\n+     FILE *fp;\n {\n-  return _IO_getc (stream);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_getc_unlocked (fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#undef getc\n+\n+#ifdef weak_alias\n+weak_alias (_IO_getc, getc)\n+#endif"}, {"sha": "3c35c365f07a53417f1473ece3f2d9ecd6d3577d", "filename": "libio/stdio/putc.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fputc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fputc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputc.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,12 +1,42 @@\n+/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n-#undef putc\n+#undef _IO_putc\n \n int\n-putc(c, stream)\n+_IO_putc (c, fp)\n      int c;\n-     FILE *stream;\n+     _IO_FILE *fp;\n {\n-  return _IO_putc(c, stream);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_putc_unlocked (c, fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#undef putc\n+\n+#ifdef weak_alias\n+weak_alias (_IO_putc, putc)\n+#endif"}, {"sha": "1e1dd137626713f9d17cc6fa6f4a9d1798199d73", "filename": "libio/stdio/putchar.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fputchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fputchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputchar.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -27,7 +27,7 @@ putchar (c)\n {\n   int result;\n   _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n-\t\t\t    _IO_stdout);\n+\t\t\t       _IO_stdout);\n   _IO_flockfile (_IO_stdout);\n   result = _IO_putc_unlocked (c, _IO_stdout);\n   _IO_cleanup_region_end (1);"}, {"sha": "30065ac8714913b1b06050002c62a276698b89be", "filename": "libio/stdio/stdio.h", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdio%2Fstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fstdio.h?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -169,10 +169,48 @@ extern int vsnprintf __P ((char *, size_t, const char *, _IO_va_list));\n extern int __underflow __P((struct _IO_FILE*));\n extern int __overflow __P((struct _IO_FILE*, int));\n \n+/* Handle locking of streams.  */\n+#if defined _REENTRANT || defined _THREAD_SAFE\n+extern void clearerr_locked __P ((FILE *));\n+extern void clearerr_unlocked __P ((FILE *));\n+extern int feof_locked __P ((FILE *));\n+extern int feof_unlocked __P ((FILE *));\n+extern int ferror_locked __P ((FILE*));\n+extern int ferror_unlocked __P ((FILE*));\n+extern int fileno_locked __P ((FILE *));\n+extern int fileno_unlocked __P ((FILE *));\n+extern void flockfile __P ((FILE *));\n+extern void funlockfile __P ((FILE *));\n+extern int ftrylockfile __P ((FILE *));\n+extern int fclose_unlocked __P ((FILE *));\n+extern int fflush_locked __P ((FILE *));\n+extern int fflush_unlocked __P ((FILE *));\n+extern size_t fread_unlocked __P ((void *, size_t, size_t, FILE *));\n+extern size_t fwrite_unlocked __P ((const void *, size_t, size_t, FILE *));\n+\n+extern int fputc_locked __P ((int, FILE*));\n+extern int fputc_unlocked __P ((int, FILE*));\n+extern int getc_locked __P ((FILE *));\n+extern int getc_unlocked __P ((FILE *));\n+extern int getchar_locked __P ((void));\n+extern int getchar_unlocked __P ((void));\n+extern int putc_locked __P ((int, FILE *));\n+extern int putc_unlocked __P ((int, FILE *));\n+extern int putchar_locked __P ((int));\n+extern int putchar_unlocked __P ((int));\n+\n+# define getc_unlocked(fp) _IO_getc_unlocked (fp)\n+# define getc_locked(fp) _IO_getc (fp)\n+# define getchar_unlocked() _IO_getc_unlocked (stdin)\n+# define getchar_locked() _IO_getc (stdin)\n+# define putchar_unlocked(c) _IO_putc_unlocked (c, stdout)\n+# define putchar_locked(c) _IO_putc (c, stdout)\n+#endif /* __USE_REENTRANT */\n+\n #define getc(fp) _IO_getc(fp)\n #define putc(c, fp) _IO_putc(c, fp)\n-#define putchar(c) putc(c, stdout)\n-#define getchar() getc(stdin)\n+#define putchar(c) _IO_putc(c, stdout)\n+#define getchar() _IO_getc(stdin)\n \n #ifdef __cplusplus\n }"}, {"sha": "3f8102f4653b52f5392868c5d02347c7f54b5ecb", "filename": "libio/stdstrbufs.cc", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdstrbufs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstdstrbufs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdstrbufs.cc?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,4 +1,4 @@\n-/* \n+/*\n Copyright (C) 1994 Free Software Foundation\n \n This file is part of the GNU IO Library.  This library is free\n@@ -54,8 +54,15 @@ extern char filebuf_vtable[];\n #define STD_VTABLE (const struct _IO_jump_t *)filebuf_vtable\n #endif\n \n+#ifdef _IO_MTSAFE_IO\n+#define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n+  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n+  struct _IO_FILE_plus NAME \\\n+    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD), &_IO_file_jumps}\n+#else\n #define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n   struct _IO_FILE_plus NAME = {FILEBUF_LITERAL(CHAIN, FLAGS, FD), STD_VTABLE}\n+#endif\n \n DEF_STDFILE(_IO_stdin_, 0, 0, _IO_NO_WRITES);\n DEF_STDFILE(_IO_stdout_, 1, &_IO_stdin_.file, _IO_NO_READS);\n@@ -95,17 +102,21 @@ extern struct _IO_jump_t stdiobuf_vtable;\n #endif /* !__GNUC__ */\n #endif /* !stdiobuf_vtable */\n \n-#if  _IO_UNIFIED_JUMPTABLES\n-#define JUMP_PTR /* Nothing */\n+#ifdef _IO_MTSAFE_IO\n+#define DEF_STDIOFILE(NAME, FD, FILE, FLAGS, CHAIN) \\\n+  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n+  struct _IO_fake_stdiobuf NAME = \\\n+      {{{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+_IO_UNBUFFERED+FLAGS, \\\n+         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t 0, 0, 0, 0, { 0 }, _IO_stdfile_##FD##_lock},\\\n+         &stdiobuf_vtable}, FILE}\n #else\n-#define JUMP_PTR &_IO_streambuf_jumps,\n-#endif\n-\n #define DEF_STDIOFILE(NAME, FD, FILE, FLAGS, CHAIN) \\\n   struct _IO_fake_stdiobuf NAME = \\\n       {{{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+_IO_UNBUFFERED+FLAGS, \\\n-         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, JUMP_PTR FD},\\\n+\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD}, \\\n          &stdiobuf_vtable}, FILE}\n+#endif\n \n DEF_STDIOFILE(_IO_stdin_buf, 0, stdin, _IO_NO_WRITES, &_IO_stderr_.file);\n DEF_STDIOFILE(_IO_stdout_buf, 1, stdout, _IO_NO_READS, &_IO_stdin_buf.s.file);"}, {"sha": "e87590f86d126cff6df96d74e4694898e112ebf0", "filename": "libio/streambuf.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstreambuf.cc?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -162,7 +162,7 @@ static _IO_pos_t _IO_sb_seekpos(_IO_FILE *fp, _IO_pos_t pos, int mode)\n \n static int _IO_sb_pbackfail(_IO_FILE *fp, int ch)\n { return ((streambuf*)fp)->pbackfail(ch); }\n-static void _IO_sb_finish(_IO_FILE *fp)\n+static void _IO_sb_finish(_IO_FILE *fp, int)\n { ((streambuf*)fp)->~streambuf(); }\n static _IO_ssize_t _IO_sb_read(_IO_FILE *fp, void *buf, _IO_ssize_t n)\n { return ((streambuf*)fp)->sys_read((char*)buf, n); }\n@@ -207,13 +207,22 @@ struct _IO_jump_t _IO_streambuf_jumps = {\n \n streambuf::streambuf(int flags)\n {\n+#ifdef _IO_MTSAFE_IO\n+  _lock = new _IO_lock_t;\n+#endif\n   _IO_init(this, flags);\n #if !_IO_UNIFIED_JUMPTABLES\n   _jumps = &_IO_streambuf_jumps;\n #endif\n }\n \n-streambuf::~streambuf() { _IO_default_finish(this,0); }\n+streambuf::~streambuf()\n+{\n+  _IO_default_finish(this,0);\n+#ifdef _IO_MTSAFE_IO\n+  delete _lock;\n+#endif\n+}\n \n streampos\n streambuf::seekoff(streamoff, _seek_dir, int /*=ios::in|ios::out*/)"}, {"sha": "f7c22627e7197b0cc0b568381e9cd7e6729f1fbb", "filename": "libio/strops.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstrops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Fstrops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrops.c?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -200,8 +200,8 @@ _IO_ssize_t\n _IO_str_count (fp)\n      _IO_FILE *fp;\n {\n-  return ((fp->_IO_write_ptr > fp->_IO_read_end\n-\t   ? fp->_IO_write_ptr : fp->_IO_read_end)\n+  return ((fp->_IO_write_end > fp->_IO_read_end\n+\t   ? fp->_IO_write_end : fp->_IO_read_end)\n \t  - fp->_IO_read_base);\n }\n "}, {"sha": "df82104fafe9f61cb6bddff5c695afdff6718164", "filename": "libio/tests/tFile.cc", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Ftests%2FtFile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libio%2Ftests%2FtFile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ftests%2FtFile.cc?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -43,6 +43,8 @@ the executable file might be covered by the GNU General Public License. */\n #include <string.h>\n #include <assert.h>\n \n+const char *tempfile;\n+\n class record\n {\n public:\n@@ -160,9 +162,9 @@ void t4()\n \n   cout << \"\\nMaking File tf ... \"; \n #ifdef _OLD_STREAMS\n-  File tf(\"tempfile\", io_readwrite, a_create);\n+  File tf(tempfile, io_readwrite, a_create);\n #else\n-  fstream tf(\"tempfile\", ios::in|ios::out|ios::trunc);\n+  fstream tf(tempfile, ios::in|ios::out|ios::trunc);\n #endif\n   assert(tf.good());\n   assert(tf.is_open());\n@@ -190,7 +192,7 @@ void t4()\n   tf.open(tf.name(), io_appendonly, a_use);\n #else\n   tf.close();\n-  tf.open(\"tempfile\", ios::app);\n+  tf.open(tempfile, ios::app);\n #endif\n   assert(tf.good());\n   assert(tf.is_open());\n@@ -204,7 +206,7 @@ void t4()\n   tf << s;\n   assert(tf.good());\n   tf.close();\n-  tf.open(\"tempfile\", ios::in);\n+  tf.open(tempfile, ios::in);\n #endif\n   tf.raw();\n   assert(tf.good());\n@@ -512,6 +514,8 @@ t12 ()\n \n main(int argc, char **argv)\n {\n+ char temp [1024] = \"tempfile\";\n+\n  if (argc > 1 && strncmp(argv[1], \"-b\", 2) == 0) {\n      streambuf *sb = cout.rdbuf();\n      streambuf *ret;\n@@ -522,7 +526,11 @@ main(int argc, char **argv)\n \t ret = sb->setbuf(new char[buffer_size], buffer_size);\n      if (ret != sb)\n \t cerr << \"Warning: cout.rdbuf()->setbuf failed!\\n\";\n+\n+     strncpy (&temp [8], &argv[1][2], 1000);\n+     temp [1008] = '\\0';\n   }\n+  tempfile = temp;\n   t1();\n   t2();\n   t3();"}, {"sha": "868f61d0ce54db2d400a65fa8ccb820c995567ad", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -1,3 +1,9 @@\n+1997-09-15 02:37  Ulrich Drepper  <drepper@cygnus.com>\n+\n+\t* config/linux.mt: New file.  Make sure _PTHREADS is defined\n+\tif necessary.\n+\t* configure.in: Find linux.mt file.\n+\n Thu Sep 11 15:03:20 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* std/bastring.h (class basic_string): Add global scope to"}, {"sha": "b67cef564b1a9bb45ff915776bb8fd1b143b433d", "filename": "libstdc++/configure.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libstdc%2B%2B%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e693cc28bbfeb1c1728bec4392505d2eba2b1090/libstdc%2B%2B%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fconfigure.in?ref=e693cc28bbfeb1c1728bec4392505d2eba2b1090", "patch": "@@ -41,6 +41,11 @@ if [ \"${shared}\" = \"yes\" ]; then\n   esac\n fi\n \n+# Make sure the right flags are defined for multi-threading.\n+case \"${target}\" in\n+  *-*-linux-gnu)\tfrags=\"${frags} linux.mt\" ;;\n+esac\n+\n for frag in ${frags}; do\n   frag=${srcdir}/config/$frag\n   if [ -f ${frag} ]; then"}]}