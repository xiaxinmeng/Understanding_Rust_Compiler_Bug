{"sha": "34d9d74996badd2b9ee315903f916ebb7a8d422f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkOWQ3NDk5NmJhZGQyYjllZTMxNTkwM2Y5MTZlYmI3YThkNDIyZg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-03-24T10:28:48Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-03-24T10:28:48Z"}, "message": "re PR fortran/64787 (Invalid code on sourced allocation of class(*) character string)\n\ngcc/fortran/ChangeLog\n\n2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/64787\n\tPR fortran/57456\n\tPR fortran/63230\n\t* class.c (gfc_add_component_ref):  Free no longer needed\n\tref-chains to prevent memory loss.\n\t(find_intrinsic_vtab): For deferred length char arrays or\n\tunlimited polymorphic objects, store the size in bytes of one\n\tcharacter in the size component of the vtab.\n\t* gfortran.h: Added gfc_add_len_component () define.\n\t* trans-array.c (gfc_trans_create_temp_array): Switched to new\n\tfunction name for getting a class' vtab's field.\n\t(build_class_array_ref): Likewise.\n\t(gfc_array_init_size): Using the size information from allocate\n\tmore consequently now, i.e., the typespec of the entity to\n\tallocate is no longer needed.  This is to address the last open\n\tcomment in PR fortran/57456.\n\t(gfc_array_allocate): Likewise.\n\t(structure_alloc_comps): gfc_copy_class_to_class () needs to\n\tknow whether the class is unlimited polymorphic.\n\t* trans-array.h: Changed interface of gfc_array_allocate () to\n\treflect the no longer needed typespec.\n\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): New.\n\t(gfc_reset_len): New.\n\t(gfc_get_class_array_ref): Switch to new function name for\n\tgetting a class' vtab's field.\n\t(gfc_copy_class_to_class):  Added flag to know whether the class\n\tto copy is unlimited polymorphic.  Adding _len dependent code\n\tthen, which calls ->vptr->copy () with four arguments adding\n\tthe length information ->vptr->copy(from, to, from_len, to_cap).\n\t(gfc_conv_procedure_call): Switch to new function name for\n\tgetting a class' vtab's field.\n\t(alloc_scalar_allocatable_for_assignment): Use the string_length\n\tas computed by gfc_conv_expr and not the statically backend_decl\n\twhich may be incorrect when ref-ing.\n\t(gfc_trans_assignment_1): Use the string_length variable and\n\tnot the rse.string_length.  The former has been computed more\n\tgenerally.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Switch to new\n\tfunction name for getting a class' vtab's field.\n\t(gfc_conv_intrinsic_storage_size): Likewise.\n\t(gfc_conv_intrinsic_transfer): Likewise.\n\t* trans-stmt.c (gfc_trans_allocate): Restructured to evaluate\n\tsource=expr3 only once before the loop over the objects to\n\tallocate, when the objects are not arrays. Doing correct _len\n\tinitialization and calling of vptr->copy () fixing PR 64787.\n\t(gfc_trans_deallocate): Reseting _len to 0, preventing future\n\terrors.\n\t* trans.c (gfc_build_array_ref): Switch to new function name\n\tfor getting a class' vtab's field.\n\t(gfc_add_comp_finalizer_call): Likewise.\n\t* trans.h: Define the prototypes for the gfc_class_vtab_*_get ()\n\tand gfc_vptr_*_get () functions.\n\tAdded gfc_find_and_cut_at_last_class_ref () and\n\tgfc_reset_len () routine prototype.  Added flag to\n\tgfc_copy_class_to_class () prototype to signal an unlimited\n\tpolymorphic entity to copy.\n\ngcc/testsuite/ChangeLog\n\n2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n\n\t* gfortran.dg/allocate_alloc_opt_13.f90: Added tests for\n\tsource= and mold= expressions functionality.\n\t* gfortran.dg/allocate_class_4.f90: New test.\n\t* gfortran.dg/unlimited_polymorphic_20.f90: Added test whether\n\tcopying an unlimited polymorhpic object containing a char array\n\tto another unlimited polymorphic object respects the _len\n\tcomponent.\n\t* gfortran.dg/unlimited_polymorphic_22.f90: Extended to check\n\twhether deferred length char array allocate works, unlimited\n\tpolymorphic object allocation from a string works and if\n\tallocating an array of deferred length strings works.\n\t* gfortran.dg/unlimited_polymorphic_24.f03: New test.\n\nFrom-SVN: r221621", "tree": {"sha": "4cda0798b6bf5a397dc8dfb57c00dd489206a269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cda0798b6bf5a397dc8dfb57c00dd489206a269"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34d9d74996badd2b9ee315903f916ebb7a8d422f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d9d74996badd2b9ee315903f916ebb7a8d422f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d9d74996badd2b9ee315903f916ebb7a8d422f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d9d74996badd2b9ee315903f916ebb7a8d422f/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9272fd04204ce8e1287a94b2d4fdacd32ef90a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9272fd04204ce8e1287a94b2d4fdacd32ef90a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9272fd04204ce8e1287a94b2d4fdacd32ef90a1"}], "stats": {"total": 1707, "additions": 1291, "deletions": 416}, "files": [{"sha": "ef4abc22a1c8f6f57d349e17a4bffb252888df1a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -1,3 +1,62 @@\n+2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/64787\n+\tPR fortran/57456\n+\tPR fortran/63230\n+\t* class.c (gfc_add_component_ref):  Free no longer needed\n+\tref-chains to prevent memory loss.\n+\t(find_intrinsic_vtab): For deferred length char arrays or\n+\tunlimited polymorphic objects, store the size in bytes of one\n+\tcharacter in the size component of the vtab.\n+\t* gfortran.h: Added gfc_add_len_component () define.\n+\t* trans-array.c (gfc_trans_create_temp_array): Switched to new\n+\tfunction name for getting a class' vtab's field.\n+\t(build_class_array_ref): Likewise.\n+\t(gfc_array_init_size): Using the size information from allocate\n+\tmore consequently now, i.e., the typespec of the entity to\n+\tallocate is no longer needed.  This is to address the last open\n+\tcomment in PR fortran/57456.\n+\t(gfc_array_allocate): Likewise.\n+\t(structure_alloc_comps): gfc_copy_class_to_class () needs to\n+\tknow whether the class is unlimited polymorphic.\n+\t* trans-array.h: Changed interface of gfc_array_allocate () to\n+\treflect the no longer needed typespec.\n+\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): New.\n+\t(gfc_reset_len): New.\n+\t(gfc_get_class_array_ref): Switch to new function name for\n+\tgetting a class' vtab's field.\n+\t(gfc_copy_class_to_class):  Added flag to know whether the class\n+\tto copy is unlimited polymorphic.  Adding _len dependent code\n+\tthen, which calls ->vptr->copy () with four arguments adding\n+\tthe length information ->vptr->copy(from, to, from_len, to_cap).\n+\t(gfc_conv_procedure_call): Switch to new function name for\n+\tgetting a class' vtab's field. \n+\t(alloc_scalar_allocatable_for_assignment): Use the string_length\n+\tas computed by gfc_conv_expr and not the statically backend_decl\n+\twhich may be incorrect when ref-ing.\n+\t(gfc_trans_assignment_1): Use the string_length variable and\n+\tnot the rse.string_length.  The former has been computed more\n+\tgenerally.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Switch to new\n+\tfunction name for getting a class' vtab's field.\n+\t(gfc_conv_intrinsic_storage_size): Likewise.\n+\t(gfc_conv_intrinsic_transfer): Likewise.\n+\t* trans-stmt.c (gfc_trans_allocate): Restructured to evaluate\n+\tsource=expr3 only once before the loop over the objects to\n+\tallocate, when the objects are not arrays. Doing correct _len\n+\tinitialization and calling of vptr->copy () fixing PR 64787.\n+\t(gfc_trans_deallocate): Reseting _len to 0, preventing future\n+\terrors.\n+\t* trans.c (gfc_build_array_ref): Switch to new function name\n+\tfor getting a class' vtab's field.\n+\t(gfc_add_comp_finalizer_call): Likewise.\n+\t* trans.h: Define the prototypes for the gfc_class_vtab_*_get ()\n+\tand gfc_vptr_*_get () functions.\n+\tAdded gfc_find_and_cut_at_last_class_ref () and\n+\tgfc_reset_len () routine prototype.  Added flag to\n+\tgfc_copy_class_to_class () prototype to signal an unlimited\n+\tpolymorphic entity to copy.    \n+\n 2015-03-24  Iain Sandoe  <iain@codesourcery.com>\n \t    Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "799039999db4b4a80ac111e70342182d5c3f38d9", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -234,6 +234,9 @@ gfc_add_component_ref (gfc_expr *e, const char *name)\n     }\n   if (*tail != NULL && strcmp (name, \"_data\") == 0)\n     next = *tail;\n+  else\n+    /* Avoid losing memory.  */\n+    gfc_free_ref_list (*tail);\n   (*tail) = gfc_get_ref();\n   (*tail)->next = next;\n   (*tail)->type = REF_COMPONENT;\n@@ -2562,13 +2565,19 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      c->attr.access = ACCESS_PRIVATE;\n \n \t      /* Build a minimal expression to make use of\n-\t\t target-memory.c/gfc_element_size for 'size'.  */\n+\t\t target-memory.c/gfc_element_size for 'size'.  Special handling\n+\t\t for character arrays, that are not constant sized: to support\n+\t\t len (str) * kind, only the kind information is stored in the\n+\t\t vtab.  */\n \t      e = gfc_get_expr ();\n \t      e->ts = *ts;\n \t      e->expr_type = EXPR_VARIABLE;\n \t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\t NULL,\n-\t\t\t\t\t\t (int)gfc_element_size (e));\n+\t\t\t\t\t\t ts->type == BT_CHARACTER\n+\t\t\t\t\t\t && charlen == 0 ?\n+\t\t\t\t\t\t   ts->kind :\n+\t\t\t\t\t\t   (int)gfc_element_size (e));\n \t      gfc_free_expr (e);\n \n \t      /* Add component _extends.  */"}, {"sha": "8e6595f1cc4f03ba9cf68be4335646bd768fd244", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -3175,6 +3175,7 @@ void gfc_add_component_ref (gfc_expr *, const char *);\n void gfc_add_class_array_ref (gfc_expr *);\n #define gfc_add_data_component(e)     gfc_add_component_ref(e,\"_data\")\n #define gfc_add_vptr_component(e)     gfc_add_component_ref(e,\"_vptr\")\n+#define gfc_add_len_component(e)      gfc_add_component_ref(e,\"_len\")\n #define gfc_add_hash_component(e)     gfc_add_component_ref(e,\"_hash\")\n #define gfc_add_size_component(e)     gfc_add_component_ref(e,\"_size\")\n #define gfc_add_def_init_component(e) gfc_add_component_ref(e,\"_def_init\")"}, {"sha": "17689748eafa825a19092efb3f72d303fa764dd6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -1196,7 +1196,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \telemsize = fold_convert (gfc_array_index_type,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n       else\n-\telemsize = gfc_vtable_size_get (class_expr);\n+\telemsize = gfc_class_vtab_size_get (class_expr);\n \n       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t      size, elemsize);\n@@ -3066,7 +3066,7 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n   if (!GFC_CLASS_TYPE_P (TREE_TYPE (decl)))\n     return false;\n \n-  size = gfc_vtable_size_get (decl);\n+  size = gfc_class_vtab_size_get (decl);\n \n   /* Build the address of the element.  */\n   type = TREE_TYPE (TREE_TYPE (base));\n@@ -4956,8 +4956,7 @@ static tree\n gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n \t\t     stmtblock_t * descriptor_block, tree * overflow,\n-\t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3,\n-\t\t     gfc_typespec *ts)\n+\t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3)\n {\n   tree type;\n   tree tmp;\n@@ -4983,7 +4982,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n   /* Set the dtype.  */\n   tmp = gfc_conv_descriptor_dtype (descriptor);\n-  gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (TREE_TYPE (descriptor)));\n+  gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (type));\n \n   or_expr = boolean_false_node;\n \n@@ -5137,9 +5136,6 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t  tmp = TYPE_SIZE_UNIT (tmp);\n \t}\n     }\n-  else if (ts->type != BT_UNKNOWN && ts->type != BT_CHARACTER)\n-    /* FIXME: Properly handle characters.  See PR 57456.  */\n-    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (ts));\n   else\n     tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n \n@@ -5211,7 +5207,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n bool\n gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t\t    tree errlen, tree label_finish, tree expr3_elem_size,\n-\t\t    tree *nelems, gfc_expr *expr3, gfc_typespec *ts)\n+\t\t    tree *nelems, gfc_expr *expr3)\n {\n   tree tmp;\n   tree pointer;\n@@ -5296,7 +5292,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n \t\t\t      &se->pre, &set_descriptor_block, &overflow,\n-\t\t\t      expr3_elem_size, nelems, expr3, ts);\n+\t\t\t      expr3_elem_size, nelems, expr3);\n \n   if (dimension)\n     {\n@@ -7942,7 +7938,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t      dst_data = gfc_class_data_get (dcmp);\n \t      src_data = gfc_class_data_get (comp);\n-\t      size = fold_convert (size_type_node, gfc_vtable_size_get (comp));\n+\t      size = fold_convert (size_type_node,\n+\t\t\t\t   gfc_class_vtab_size_get (comp));\n \n \t      if (CLASS_DATA (c)->attr.dimension)\n \t\t{\n@@ -7977,7 +7974,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t  fold_convert (TREE_TYPE (dst_data), tmp));\n \t\t}\n \n-\t      tmp = gfc_copy_class_to_class (comp, dcmp, nelems);\n+\t      tmp = gfc_copy_class_to_class (comp, dcmp, nelems,\n+\t\t\t\t\t     UNLIMITED_POLY (c));\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t      tmp = gfc_finish_block (&tmpblock);\n "}, {"sha": "854453490aa39fde1957609cbf0b9eee0f39d14c", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -24,7 +24,7 @@ tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*);\n /* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, tree,\n-\t\t\t tree, tree *, gfc_expr *, gfc_typespec *);\n+\t\t\t tree, tree *, gfc_expr *);\n \n /* Allow the bounds of a loop to be set from a callee's array spec.  */\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,"}, {"sha": "9bf976a128e466880dbb9d13df263a3b3f276956", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 207, "deletions": 58, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -166,72 +166,85 @@ gfc_class_len_get (tree decl)\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n     decl = build_fold_indirect_ref_loc (input_location, decl);\n   len = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n-\t\t\t    CLASS_LEN_FIELD);\n+\t\t\t   CLASS_LEN_FIELD);\n   return fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t  TREE_TYPE (len), decl, len,\n \t\t\t  NULL_TREE);\n }\n \n \n+/* Get the specified FIELD from the VPTR.  */\n+\n static tree\n-gfc_vtable_field_get (tree decl, int field)\n+vptr_field_get (tree vptr, int fieldno)\n {\n-  tree size;\n-  tree vptr;\n-  vptr = gfc_class_vptr_get (decl);\n+  tree field;\n   vptr = build_fold_indirect_ref_loc (input_location, vptr);\n-  size = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (vptr)),\n-\t\t\t    field);\n-  size = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t  TREE_TYPE (size), vptr, size,\n-\t\t\t  NULL_TREE);\n-  /* Always return size as an array index type.  */\n-  if (field == VTABLE_SIZE_FIELD)\n-    size = fold_convert (gfc_array_index_type, size);\n-  gcc_assert (size);\n-  return size;\n+  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (vptr)),\n+\t\t\t     fieldno);\n+  field = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   TREE_TYPE (field), vptr, field,\n+\t\t\t   NULL_TREE);\n+  gcc_assert (field);\n+  return field;\n }\n \n \n-tree\n-gfc_vtable_hash_get (tree decl)\n-{\n-  return gfc_vtable_field_get (decl, VTABLE_HASH_FIELD);\n-}\n-\n+/* Get the field from the class' vptr.  */\n \n-tree\n-gfc_vtable_size_get (tree decl)\n+static tree\n+class_vtab_field_get (tree decl, int fieldno)\n {\n-  return gfc_vtable_field_get (decl, VTABLE_SIZE_FIELD);\n+  tree vptr;\n+  vptr = gfc_class_vptr_get (decl);\n+  return vptr_field_get (vptr, fieldno);\n }\n \n \n-tree\n-gfc_vtable_extends_get (tree decl)\n-{\n-  return gfc_vtable_field_get (decl, VTABLE_EXTENDS_FIELD);\n+/* Define a macro for creating the class_vtab_* and vptr_* accessors in\n+   unison.  */\n+#define VTAB_GET_FIELD_GEN(name, field) tree \\\n+gfc_class_vtab_## name ##_get (tree cl) \\\n+{ \\\n+  return class_vtab_field_get (cl, field); \\\n+} \\\n+ \\\n+tree \\\n+gfc_vptr_## name ##_get (tree vptr) \\\n+{ \\\n+  return vptr_field_get (vptr, field); \\\n }\n \n+VTAB_GET_FIELD_GEN (hash, VTABLE_HASH_FIELD)\n+VTAB_GET_FIELD_GEN (extends, VTABLE_EXTENDS_FIELD)\n+VTAB_GET_FIELD_GEN (def_init, VTABLE_DEF_INIT_FIELD)\n+VTAB_GET_FIELD_GEN (copy, VTABLE_COPY_FIELD)\n+VTAB_GET_FIELD_GEN (final, VTABLE_FINAL_FIELD)\n \n-tree\n-gfc_vtable_def_init_get (tree decl)\n-{\n-  return gfc_vtable_field_get (decl, VTABLE_DEF_INIT_FIELD);\n-}\n \n+/* The size field is returned as an array index type.  Therefore treat\n+   it and only it specially.  */\n \n tree\n-gfc_vtable_copy_get (tree decl)\n+gfc_class_vtab_size_get (tree cl)\n {\n-  return gfc_vtable_field_get (decl, VTABLE_COPY_FIELD);\n+  tree size;\n+  size = class_vtab_field_get (cl, VTABLE_SIZE_FIELD);\n+  /* Always return size as an array index type.  */\n+  size = fold_convert (gfc_array_index_type, size);\n+  gcc_assert (size);\n+  return size;\n }\n \n-\n tree\n-gfc_vtable_final_get (tree decl)\n+gfc_vptr_size_get (tree vptr)\n {\n-  return gfc_vtable_field_get (decl, VTABLE_FINAL_FIELD);\n+  tree size;\n+  size = vptr_field_get (vptr, VTABLE_SIZE_FIELD);\n+  /* Always return size as an array index type.  */\n+  size = fold_convert (gfc_array_index_type, size);\n+  gcc_assert (size);\n+  return size;\n }\n \n \n@@ -245,6 +258,61 @@ gfc_vtable_final_get (tree decl)\n #undef VTABLE_FINAL_FIELD\n \n \n+/* Search for the last _class ref in the chain of references of this\n+   expression and cut the chain there.  Albeit this routine is similiar\n+   to class.c::gfc_add_component_ref (), is there a significant\n+   difference: gfc_add_component_ref () concentrates on an array ref to\n+   be the last ref in the chain.  This routine is oblivious to the kind\n+   of refs following.  */\n+\n+gfc_expr *\n+gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n+{\n+  gfc_expr *base_expr;\n+  gfc_ref *ref, *class_ref, *tail;\n+\n+  /* Find the last class reference.  */\n+  class_ref = NULL;\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t  && ref->u.c.component->ts.type == BT_CLASS)\n+\tclass_ref = ref;\n+\n+      if (ref->next == NULL)\n+\tbreak;\n+    }\n+\n+  /* Remove and store all subsequent references after the\n+     CLASS reference.  */\n+  if (class_ref)\n+    {\n+      tail = class_ref->next;\n+      class_ref->next = NULL;\n+    }\n+  else\n+    {\n+      tail = e->ref;\n+      e->ref = NULL;\n+    }\n+\n+  base_expr = gfc_expr_to_initialize (e);\n+\n+  /* Restore the original tail expression.  */\n+  if (class_ref)\n+    {\n+      gfc_free_ref_list (class_ref->next);\n+      class_ref->next = tail;\n+    }\n+  else\n+    {\n+      gfc_free_ref_list (e->ref);\n+      e->ref = tail;\n+    }\n+  return base_expr;\n+}\n+\n+\n /* Reset the vptr to the declared type, e.g. after deallocation.  */\n \n void\n@@ -294,6 +362,23 @@ gfc_reset_vptr (stmtblock_t *block, gfc_expr *e)\n }\n \n \n+/* Reset the len for unlimited polymorphic objects.  */\n+\n+void\n+gfc_reset_len (stmtblock_t *block, gfc_expr *expr)\n+{\n+  gfc_expr *e;\n+  gfc_se se_len;\n+  e = gfc_find_and_cut_at_last_class_ref (expr);\n+  gfc_add_len_component (e);\n+  gfc_init_se (&se_len, NULL);\n+  gfc_conv_expr (&se_len, e);\n+  gfc_add_modify (block, se_len.expr,\n+\t\t  fold_convert (TREE_TYPE (se_len.expr), integer_zero_node));\n+  gfc_free_expr (e);\n+}\n+\n+\n /* Obtain the vptr of the last class reference in an expression.\n    Return NULL_TREE if no class reference is found.  */\n \n@@ -873,7 +958,7 @@ tree\n gfc_get_class_array_ref (tree index, tree class_decl)\n {\n   tree data = gfc_class_data_get (class_decl);\n-  tree size = gfc_vtable_size_get (class_decl);\n+  tree size = gfc_class_vtab_size_get (class_decl);\n   tree offset = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t gfc_array_index_type,\n \t\t\t\t index, size);\n@@ -891,39 +976,57 @@ gfc_get_class_array_ref (tree index, tree class_decl)\n    that the _vptr is set.  */\n \n tree\n-gfc_copy_class_to_class (tree from, tree to, tree nelems)\n+gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n {\n   tree fcn;\n   tree fcn_type;\n   tree from_data;\n+  tree from_len;\n   tree to_data;\n+  tree to_len;\n   tree to_ref;\n   tree from_ref;\n   vec<tree, va_gc> *args;\n   tree tmp;\n+  tree stdcopy;\n+  tree extcopy;\n   tree index;\n-  stmtblock_t loopbody;\n-  stmtblock_t body;\n-  gfc_loopinfo loop;\n \n   args = NULL;\n+  /* To prevent warnings on uninitialized variables.  */\n+  from_len = to_len = NULL_TREE;\n \n   if (from != NULL_TREE)\n-    fcn = gfc_vtable_copy_get (from);\n+    fcn = gfc_class_vtab_copy_get (from);\n   else\n-    fcn = gfc_vtable_copy_get (to);\n+    fcn = gfc_class_vtab_copy_get (to);\n \n   fcn_type = TREE_TYPE (TREE_TYPE (fcn));\n \n   if (from != NULL_TREE)\n-    from_data = gfc_class_data_get (from);\n+      from_data = gfc_class_data_get (from);\n   else\n-    from_data = gfc_vtable_def_init_get (to);\n+    from_data = gfc_class_vtab_def_init_get (to);\n+\n+  if (unlimited)\n+    {\n+      if (from != NULL_TREE && unlimited)\n+\tfrom_len = gfc_class_len_get (from);\n+      else\n+\tfrom_len = integer_zero_node;\n+    }\n \n   to_data = gfc_class_data_get (to);\n+  if (unlimited)\n+    to_len = gfc_class_len_get (to);\n \n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (to_data)))\n     {\n+      stmtblock_t loopbody;\n+      stmtblock_t body;\n+      stmtblock_t ifbody;\n+      gfc_loopinfo loop;\n+\n       gfc_init_block (&body);\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t     gfc_array_index_type, nelems,\n@@ -955,21 +1058,70 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems)\n       loop.loopvar[0] = index;\n       loop.to[0] = nelems;\n       gfc_trans_scalarizing_loops (&loop, &loopbody);\n-      gfc_add_block_to_block (&body, &loop.pre);\n-      tmp = gfc_finish_block (&body);\n+      gfc_init_block (&ifbody);\n+      gfc_add_block_to_block (&ifbody, &loop.pre);\n+      stdcopy = gfc_finish_block (&ifbody);\n+      if (unlimited)\n+\t{\n+\t  vec_safe_push (args, from_len);\n+\t  vec_safe_push (args, to_len);\n+\t  tmp = build_call_vec (fcn_type, fcn, args);\n+\t  /* Build the body of the loop.  */\n+\t  gfc_init_block (&loopbody);\n+\t  gfc_add_expr_to_block (&loopbody, tmp);\n+\n+\t  /* Build the loop and return.  */\n+\t  gfc_init_loopinfo (&loop);\n+\t  loop.dimen = 1;\n+\t  loop.from[0] = gfc_index_zero_node;\n+\t  loop.loopvar[0] = index;\n+\t  loop.to[0] = nelems;\n+\t  gfc_trans_scalarizing_loops (&loop, &loopbody);\n+\t  gfc_init_block (&ifbody);\n+\t  gfc_add_block_to_block (&ifbody, &loop.pre);\n+\t  extcopy = gfc_finish_block (&ifbody);\n+\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t boolean_type_node, from_len,\n+\t\t\t\t integer_zero_node);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\t  tmp = gfc_finish_block (&body);\n+\t}\n+      else\n+\t{\n+\t  gfc_add_expr_to_block (&body, stdcopy);\n+\t  tmp = gfc_finish_block (&body);\n+\t}\n       gfc_cleanup_loop (&loop);\n     }\n   else\n     {\n       gcc_assert (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)));\n       vec_safe_push (args, from_data);\n       vec_safe_push (args, to_data);\n-      tmp = build_call_vec (fcn_type, fcn, args);\n+      stdcopy = build_call_vec (fcn_type, fcn, args);\n+\n+      if (unlimited)\n+\t{\n+\t  vec_safe_push (args, from_len);\n+\t  vec_safe_push (args, to_len);\n+\t  extcopy = build_call_vec (fcn_type, fcn, args);\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t boolean_type_node, from_len,\n+\t\t\t\t integer_zero_node);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n+\t}\n+      else\n+\ttmp = stdcopy;\n     }\n \n   return tmp;\n }\n \n+\n static tree\n gfc_trans_class_array_init_assign (gfc_expr *rhs, gfc_expr *lhs, gfc_expr *obj)\n {\n@@ -5693,7 +5845,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\tCLASS_DATA (expr->value.function.esym->result)->attr);\n \t    }\n \n-\t  final_fndecl = gfc_vtable_final_get (se->expr);\n+\t  final_fndecl = gfc_class_vtab_final_get (se->expr);\n \t  is_final = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t      boolean_type_node,\n  \t\t\t    \t      final_fndecl,\n@@ -5704,7 +5856,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n  \t  tmp = build_call_expr_loc (input_location,\n \t\t\t\t     final_fndecl, 3,\n \t\t\t\t     gfc_build_addr_expr (NULL, tmp),\n-\t\t\t\t     gfc_vtable_size_get (se->expr),\n+\t\t\t\t     gfc_class_vtab_size_get (se->expr),\n \t\t\t\t     boolean_false_node);\n  \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, is_final, tmp,\n@@ -8529,7 +8681,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     {\n       cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t      expr1->ts.u.cl->backend_decl, size);\n+\t\t\t      lse.string_length, size);\n       /* Jump past the realloc if the lengths are the same.  */\n       tmp = build3_v (COND_EXPR, cond,\n \t\t      build1_v (GOTO_EXPR, jump_label2),\n@@ -8546,10 +8698,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n \n       /* Update the lhs character length.  */\n       size = string_length;\n-      if (TREE_CODE (expr1->ts.u.cl->backend_decl) == VAR_DECL)\n-\tgfc_add_modify (block, expr1->ts.u.cl->backend_decl, size);\n-      else\n-\tgfc_add_modify (block, lse.string_length, size);\n+      gfc_add_modify (block, lse.string_length, size);\n     }\n }\n \n@@ -8839,7 +8988,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n     {\n       /* F2003: Add the code for reallocation on assignment.  */\n       if (flag_realloc_lhs && is_scalar_reallocatable_lhs (expr1))\n-\talloc_scalar_allocatable_for_assignment (&block, rse.string_length,\n+\talloc_scalar_allocatable_for_assignment (&block, string_length,\n \t\t\t\t\t\t expr1, expr2);\n \n       /* Use the scalar assignment as is.  */"}, {"sha": "c4ccb7b77c88602e9f24fc73c194dbf6b7fc3a60", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -2755,7 +2755,7 @@ if (least <= 2)\n \targ3 ? gfc_build_addr_expr (NULL_TREE, arg3)\n \t       : null_pointer_node;\n       }\n-  \n+\n     if (least == 2)\n       {\n \targ1 ? gfc_build_addr_expr (NULL_TREE, arg1)\n@@ -5922,9 +5922,9 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n   else if (arg->ts.type == BT_CLASS)\n     {\n       if (arg->rank)\n-\tbyte_size = gfc_vtable_size_get (TREE_OPERAND (argse.expr, 0));\n+\tbyte_size = gfc_class_vtab_size_get (TREE_OPERAND (argse.expr, 0));\n       else\n-\tbyte_size = gfc_vtable_size_get (argse.expr);\n+\tbyte_size = gfc_class_vtab_size_get (argse.expr);\n     }\n   else\n     {\n@@ -6053,7 +6053,7 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n       gfc_conv_expr_descriptor (&argse, arg);\n       if (arg->ts.type == BT_CLASS)\n \t{\n-\t  tmp = gfc_vtable_size_get (TREE_OPERAND (argse.expr, 0));\n+\t  tmp = gfc_class_vtab_size_get (TREE_OPERAND (argse.expr, 0));\n \t  tmp = fold_convert (result_type, tmp);\n \t  goto done;\n \t}\n@@ -6198,7 +6198,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\t\t\t argse.string_length);\n \t  break;\n \tcase BT_CLASS:\n-\t  tmp = gfc_vtable_size_get (argse.expr);\n+\t  tmp = gfc_class_vtab_size_get (argse.expr);\n \t  break;\n \tdefault:\n \t  source_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n@@ -6322,7 +6322,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       mold_type = gfc_get_character_type_len (arg->expr->ts.kind, tmp);\n       break;\n     case BT_CLASS:\n-      tmp = gfc_vtable_size_get (argse.expr);\n+      tmp = gfc_class_vtab_size_get (argse.expr);\n       break;\n     default:\n       tmp = fold_convert (gfc_array_index_type, size_in_bytes (mold_type));"}, {"sha": "a6fb52c51e19b67f1ad3009905da8e411163e017", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 516, "deletions": 298, "changes": 814, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -4932,9 +4932,8 @@ tree\n gfc_trans_allocate (gfc_code * code)\n {\n   gfc_alloc *al;\n-  gfc_expr *e;\n   gfc_expr *expr;\n-  gfc_se se;\n+  gfc_se se, se_sz;\n   tree tmp;\n   tree parm;\n   tree stat;\n@@ -4943,21 +4942,23 @@ gfc_trans_allocate (gfc_code * code)\n   tree label_errmsg;\n   tree label_finish;\n   tree memsz;\n-  tree expr3;\n-  tree slen3;\n+  tree al_vptr, al_len;\n+  /* If an expr3 is present, then store the tree for accessing its\n+     _vptr, and _len components in the variables, respectively.  The\n+     element size, i.e. _vptr%size, is stored in expr3_esize.  Any of\n+     the trees may be the NULL_TREE indicating that this is not\n+     available for expr3's type.  */\n+  tree expr3, expr3_vptr, expr3_len, expr3_esize;\n   stmtblock_t block;\n   stmtblock_t post;\n-  gfc_expr *sz;\n-  gfc_se se_sz;\n-  tree class_expr;\n   tree nelems;\n-  tree memsize = NULL_TREE;\n-  tree classexpr = NULL_TREE;\n+  bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n \n-  stat = tmp = memsz = NULL_TREE;\n+  stat = tmp = memsz = al_vptr = al_len = NULL_TREE;\n+  expr3 = expr3_vptr = expr3_len = expr3_esize = NULL_TREE;\n   label_errmsg = label_finish = errmsg = errlen = NULL_TREE;\n \n   gfc_init_block (&block);\n@@ -4991,206 +4992,364 @@ gfc_trans_allocate (gfc_code * code)\n       TREE_USED (label_finish) = 0;\n     }\n \n-  expr3 = NULL_TREE;\n-  slen3 = NULL_TREE;\n+  /* When an expr3 is present, try to evaluate it only once.  In most\n+     cases expr3 is invariant for all elements of the allocation list.\n+     Only exceptions are arrays.  Furthermore the standards prevent a\n+     dependency of expr3 on the objects in the allocate list.  Therefore\n+     it is safe to pre-evaluate expr3 for complicated expressions, i.e.\n+     everything not a variable or constant.  When an array allocation\n+     is wanted, then the following block nevertheless evaluates the\n+     _vptr, _len and element_size for expr3.  */\n+  if (code->expr3)\n+    {\n+      bool vtab_needed = false;\n+      /* expr3_tmp gets the tree when code->expr3.mold is set, i.e.,\n+\t the expression is only needed to get the _vptr, _len a.s.o.  */\n+      tree expr3_tmp = NULL_TREE;\n+\n+      /* Figure whether we need the vtab from expr3.  */\n+      for (al = code->ext.alloc.list; !vtab_needed && al != NULL;\n+\t   al = al->next)\n+\tvtab_needed = (al->expr->ts.type == BT_CLASS);\n+\n+      /* A array expr3 needs the scalarizer, therefore do not process it\n+\t here.  */\n+      if (code->expr3->expr_type != EXPR_ARRAY\n+\t  && (code->expr3->rank == 0\n+\t      || code->expr3->expr_type == EXPR_FUNCTION)\n+\t  && (!code->expr3->symtree\n+\t      || !code->expr3->symtree->n.sym->as)\n+\t  && !gfc_is_class_array_ref (code->expr3, NULL))\n+\t{\n+\t  /* When expr3 is a variable, i.e., a very simple expression,\n+\t     then convert it once here.  */\n+\t  if ((code->expr3->expr_type == EXPR_VARIABLE)\n+\t      || code->expr3->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      if (!code->expr3->mold\n+\t\t  || code->expr3->ts.type == BT_CHARACTER\n+\t\t  || vtab_needed)\n+\t\t{\n+\t\t  /* Convert expr3 to a tree.  */\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  se.want_pointer = 1;\n+\t\t  gfc_conv_expr (&se, code->expr3);\n+\t\t  if (!code->expr3->mold)\n+\t\t    expr3 = se.expr;\n+\t\t  else\n+\t\t    expr3_tmp = se.expr;\n+\t\t  expr3_len = se.string_length;\n+\t\t  gfc_add_block_to_block (&block, &se.pre);\n+\t\t  gfc_add_block_to_block (&post, &se.post);\n+\t\t}\n+\t      /* else expr3 = NULL_TREE set above.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      /* In all other cases evaluate the expr3 and create a\n+\t\t temporary.  */\n+\t      gfc_init_se (&se, NULL);\n+\t      gfc_conv_expr_reference (&se, code->expr3);\n+\t      if (code->expr3->ts.type == BT_CLASS)\n+\t\tgfc_conv_class_to_class (&se, code->expr3,\n+\t\t\t\t\t code->expr3->ts,\n+\t\t\t\t\t false, true,\n+\t\t\t\t\t  false,false);\n+\t      gfc_add_block_to_block (&block, &se.pre);\n+\t      gfc_add_block_to_block (&post, &se.post);\n+\t      /* Prevent aliasing, i.e., se.expr may be already a\n+\t\t variable declaration.  */\n+\t      if (!VAR_P (se.expr))\n+\t\t{\n+\t\t  tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t     se.expr);\n+\t\t  tmp = gfc_evaluate_now (tmp, &block);\n+\t\t}\n+\t      else\n+\t\ttmp = se.expr;\n+\t      if (!code->expr3->mold)\n+\t\texpr3 = tmp;\n+\t      else\n+\t\texpr3_tmp = tmp;\n+\t      /* When he length of a char array is easily available\n+\t\t here, fix it for future use.  */\n+\t      if (se.string_length)\n+\t\texpr3_len = gfc_evaluate_now (se.string_length, &block);\n+\t    }\n+\t}\n+\n+      /* Figure how to get the _vtab entry.  This also obtains the tree\n+\t expression for accessing the _len component, because only\n+\t unlimited polymorphic objects, which are a subcategory of class\n+\t types, have a _len component.  */\n+      if (code->expr3->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_expr *rhs;\n+\t  /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n+\t  if (expr3 != NULL_TREE && (VAR_P (expr3) || !code->expr3->ref))\n+\t    tmp = gfc_class_vptr_get (expr3);\n+\t  else if (expr3_tmp != NULL_TREE\n+\t\t   && (VAR_P (expr3_tmp) ||!code->expr3->ref))\n+\t    tmp = gfc_class_vptr_get (expr3_tmp);\n+\t  else\n+\t    {\n+\t      rhs = gfc_find_and_cut_at_last_class_ref (code->expr3);\n+\t      gfc_add_vptr_component (rhs);\n+\t      gfc_init_se (&se, NULL);\n+\t      se.want_pointer = 1;\n+\t      gfc_conv_expr (&se, rhs);\n+\t      tmp = se.expr;\n+\t      gfc_free_expr (rhs);\n+\t    }\n+\t  /* Set the element size.  */\n+\t  expr3_esize = gfc_vptr_size_get (tmp);\n+\t  if (vtab_needed)\n+\t    expr3_vptr = tmp;\n+\t  /* Initialize the ref to the _len component.  */\n+\t  if (expr3_len == NULL_TREE && UNLIMITED_POLY (code->expr3))\n+\t    {\n+\t      /* Same like for retrieving the _vptr.  */\n+\t      if (expr3 != NULL_TREE && !code->expr3->ref)\n+\t\texpr3_len  = gfc_class_len_get (expr3);\n+\t      else if (expr3_tmp != NULL_TREE && !code->expr3->ref)\n+\t\texpr3_len  = gfc_class_len_get (expr3_tmp);\n+\t      else\n+\t\t{\n+\t\t  rhs = gfc_find_and_cut_at_last_class_ref (code->expr3);\n+\t\t  gfc_add_len_component (rhs);\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  gfc_conv_expr (&se, rhs);\n+\t\t  expr3_len = se.expr;\n+\t\t  gfc_free_expr (rhs);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* When the object to allocate is polymorphic type, then it\n+\t     needs its vtab set correctly, so deduce the required _vtab\n+\t     and _len from the source expression.  */\n+\t  if (vtab_needed)\n+\t    {\n+\t      /* VPTR is fixed at compile time.  */\n+\t      gfc_symbol *vtab;\n+\n+\t      vtab = gfc_find_vtab (&code->expr3->ts);\n+\t      gcc_assert (vtab);\n+\t      expr3_vptr = gfc_get_symbol_decl (vtab);\n+\t      expr3_vptr = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t\texpr3_vptr);\n+\t    }\n+\t  /* _len component needs to be set, when ts is a character\n+\t     array.  */\n+\t  if (expr3_len == NULL_TREE\n+\t      && code->expr3->ts.type == BT_CHARACTER)\n+\t    {\n+\t      if (code->expr3->ts.u.cl\n+\t\t  && code->expr3->ts.u.cl->length)\n+\t\t{\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  gfc_conv_expr (&se, code->expr3->ts.u.cl->length);\n+\t\t  gfc_add_block_to_block (&block, &se.pre);\n+\t\t  expr3_len = gfc_evaluate_now (se.expr, &block);\n+\t\t}\n+\t      gcc_assert (expr3_len);\n+\t    }\n+\t  /* For character arrays only the kind's size is needed, because\n+\t     the array mem_size is _len * (elem_size = kind_size).\n+\t     For all other get the element size in the normal way.  */\n+\t  if (code->expr3->ts.type == BT_CHARACTER)\n+\t    expr3_esize = TYPE_SIZE_UNIT (\n+\t\t  gfc_get_char_type (code->expr3->ts.kind));\n+\t  else\n+\t    expr3_esize = TYPE_SIZE_UNIT (\n+\t\t  gfc_typenode_for_spec (&code->expr3->ts));\n+\t}\n+      gcc_assert (expr3_esize);\n+      expr3_esize = fold_convert (sizetype, expr3_esize);\n+    }\n+  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n+    {\n+      /* Compute the explicit typespec given only once for all objects\n+\t to allocate.  */\n+      if (code->ext.alloc.ts.type != BT_CHARACTER)\n+\texpr3_esize = TYPE_SIZE_UNIT (\n+\t      gfc_typenode_for_spec (&code->ext.alloc.ts));\n+      else\n+\t{\n+\t  gfc_expr *sz;\n+\t  gcc_assert (code->ext.alloc.ts.u.cl->length != NULL);\n+\t  sz = gfc_copy_expr (code->ext.alloc.ts.u.cl->length);\n+\t  gfc_init_se (&se_sz, NULL);\n+\t  gfc_conv_expr (&se_sz, sz);\n+\t  gfc_free_expr (sz);\n+\t  tmp = gfc_get_char_type (code->ext.alloc.ts.kind);\n+\t  tmp = TYPE_SIZE_UNIT (tmp);\n+\t  tmp = fold_convert (TREE_TYPE (se_sz.expr), tmp);\n+\t  expr3_esize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t TREE_TYPE (se_sz.expr),\n+\t\t\t\t\t tmp, se_sz.expr);\n+\t}\n+    }\n \n+  /* Loop over all objects to allocate.  */\n   for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n       expr = gfc_copy_expr (al->expr);\n+      /* UNLIMITED_POLY () needs the _data component to be set, when\n+\t expr is a unlimited polymorphic object.  But the _data component\n+\t has not been set yet, so check the derived type's attr for the\n+\t unlimited polymorphic flag to be safe.  */\n+      upoly_expr = UNLIMITED_POLY (expr)\n+\t\t    || (expr->ts.type == BT_DERIVED\n+\t\t\t&& expr->ts.u.derived->attr.unlimited_polymorphic);\n+      gfc_init_se (&se, NULL);\n \n+      /* For class types prepare the expressions to ref the _vptr\n+\t and the _len component.  The latter for unlimited polymorphic\n+\t types only.  */\n       if (expr->ts.type == BT_CLASS)\n-\tgfc_add_data_component (expr);\n-\n-      gfc_init_se (&se, NULL);\n+\t{\n+\t  gfc_expr *expr_ref_vptr, *expr_ref_len;\n+\t  gfc_add_data_component (expr);\n+\t  /* Prep the vptr handle.  */\n+\t  expr_ref_vptr = gfc_copy_expr (al->expr);\n+\t  gfc_add_vptr_component (expr_ref_vptr);\n+\t  se.want_pointer = 1;\n+\t  gfc_conv_expr (&se, expr_ref_vptr);\n+\t  al_vptr = se.expr;\n+\t  se.want_pointer = 0;\n+\t  gfc_free_expr (expr_ref_vptr);\n+\t  /* Allocated unlimited polymorphic objects always have a _len\n+\t     component.  */\n+\t  if (upoly_expr)\n+\t    {\n+\t      expr_ref_len = gfc_copy_expr (al->expr);\n+\t      gfc_add_len_component (expr_ref_len);\n+\t      gfc_conv_expr (&se, expr_ref_len);\n+\t      al_len = se.expr;\n+\t      gfc_free_expr (expr_ref_len);\n+\t    }\n+\t  else\n+\t    /* In a loop ensure that all loop variable dependent variables\n+\t       are initialized at the same spot in all execution paths.  */\n+\t    al_len = NULL_TREE;\n+\t}\n+      else\n+\tal_vptr = al_len = NULL_TREE;\n \n       se.want_pointer = 1;\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n-\n-      /* Evaluate expr3 just once if not a variable.  */\n-      if (al == code->ext.alloc.list\n-\t    && al->expr->ts.type == BT_CLASS\n-\t    && code->expr3\n-\t    && code->expr3->ts.type == BT_CLASS\n-\t    && code->expr3->expr_type != EXPR_VARIABLE)\n-\t{\n-\t  gfc_init_se (&se_sz, NULL);\n-\t  gfc_conv_expr_reference (&se_sz, code->expr3);\n-\t  gfc_conv_class_to_class (&se_sz, code->expr3,\n-\t\t\t\t   code->expr3->ts, false, true, false, false);\n-\t  gfc_add_block_to_block (&se.pre, &se_sz.pre);\n-\t  gfc_add_block_to_block (&se.post, &se_sz.post);\n-\t  classexpr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t   se_sz.expr);\n-\t  classexpr = gfc_evaluate_now (classexpr, &se.pre);\n-\t  memsize = gfc_vtable_size_get (classexpr);\n-\t  memsize = fold_convert (sizetype, memsize);\n-\t}\n-\n-      memsz = memsize;\n-      class_expr = classexpr;\n-\n+      if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)\n+\t/* se.string_length now stores the .string_length variable of expr\n+\t   needed to allocate character(len=:) arrays.  */\n+\tal_len = se.string_length;\n+\n+      al_len_needs_set = al_len != NULL_TREE;\n+      /* When allocating an array one can not use much of the\n+\t pre-evaluated expr3 expressions, because for most of them the\n+\t scalarizer is needed which is not available in the pre-evaluation\n+\t step.  Therefore gfc_array_allocate () is responsible (and able)\n+\t to handle the complete array allocation.  Only the element size\n+\t needs to be provided, which is done most of the time by the\n+\t pre-evaluation step.  */\n       nelems = NULL_TREE;\n-      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen, label_finish,\n-\t\t\t       memsz, &nelems, code->expr3, &code->ext.alloc.ts))\n+      if (expr3_len && code->expr3->ts.type == BT_CHARACTER)\n+\t/* When al is an array, then the element size for each element\n+\t   in the array is needed, which is the product of the len and\n+\t   esize for char arrays.  */\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       TREE_TYPE (expr3_esize), expr3_esize,\n+\t\t\t       fold_convert (TREE_TYPE (expr3_esize),\n+\t\t\t\t\t     expr3_len));\n+      else\n+\ttmp = expr3_esize;\n+      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen,\n+\t\t\t       label_finish, tmp, &nelems, code->expr3))\n \t{\n-\t  bool unlimited_char;\n-\n-\t  unlimited_char = UNLIMITED_POLY (al->expr)\n-\t\t\t   && ((code->expr3 && code->expr3->ts.type == BT_CHARACTER)\n-\t\t\t      || (code->ext.alloc.ts.type == BT_CHARACTER\n-\t\t\t\t  && code->ext.alloc.ts.u.cl\n-\t\t\t\t  && code->ext.alloc.ts.u.cl->length));\n+\t  /* A scalar or derived type.  First compute the size to\n+\t     allocate.\n \n-\t  /* A scalar or derived type.  */\n-\n-\t  /* Determine allocate size.  */\n-\t  if (al->expr->ts.type == BT_CLASS\n-\t\t&& !unlimited_char\n-\t\t&& code->expr3\n-\t\t&& memsz == NULL_TREE)\n+\t     expr3_len is set when expr3 is an unlimited polymorphic\n+\t     object or a deferred length string.  */\n+\t  if (expr3_len != NULL_TREE)\n \t    {\n-\t      if (code->expr3->ts.type == BT_CLASS)\n-\t\t{\n-\t\t  sz = gfc_copy_expr (code->expr3);\n-\t\t  gfc_add_vptr_component (sz);\n-\t\t  gfc_add_size_component (sz);\n-\t\t  gfc_init_se (&se_sz, NULL);\n-\t\t  gfc_conv_expr (&se_sz, sz);\n-\t\t  gfc_free_expr (sz);\n-\t\t  memsz = se_sz.expr;\n-\t\t}\n-\t      else\n-\t\tmemsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n-\t    }\n-\t  else if (((al->expr->ts.type == BT_CHARACTER && al->expr->ts.deferred)\n-\t\t   || unlimited_char) && code->expr3)\n-\t    {\n-\t      if (!code->expr3->ts.u.cl->backend_decl)\n-\t\t{\n-\t\t  /* Convert and use the length expression.  */\n-\t\t  gfc_init_se (&se_sz, NULL);\n-\t\t  if (code->expr3->expr_type == EXPR_VARIABLE\n-\t\t\t|| code->expr3->expr_type == EXPR_CONSTANT)\n-\t\t    {\n-\t\t      gfc_conv_expr (&se_sz, code->expr3);\n-\t\t      gfc_add_block_to_block (&se.pre, &se_sz.pre);\n-\t\t      se_sz.string_length\n-\t\t\t= gfc_evaluate_now (se_sz.string_length, &se.pre);\n-\t\t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n-\t\t      memsz = se_sz.string_length;\n-\t\t    }\n-\t\t  else if (code->expr3->mold\n-\t\t\t     && code->expr3->ts.u.cl\n-\t\t\t     && code->expr3->ts.u.cl->length)\n-\t\t    {\n-\t\t      gfc_conv_expr (&se_sz, code->expr3->ts.u.cl->length);\n-\t\t      gfc_add_block_to_block (&se.pre, &se_sz.pre);\n-\t\t      se_sz.expr = gfc_evaluate_now (se_sz.expr, &se.pre);\n-\t\t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n-\t\t      memsz = se_sz.expr;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* This is would be inefficient and possibly could\n-\t\t\t generate wrong code if the result were not stored\n-\t\t\t in expr3/slen3.  */\n-\t\t      if (slen3 == NULL_TREE)\n-\t\t\t{\n-\t\t\t  gfc_conv_expr (&se_sz, code->expr3);\n-\t\t\t  gfc_add_block_to_block (&se.pre, &se_sz.pre);\n-\t\t\t  expr3 = gfc_evaluate_now (se_sz.expr, &se.pre);\n-\t\t\t  gfc_add_block_to_block (&post, &se_sz.post);\n-\t\t\t  slen3 = gfc_evaluate_now (se_sz.string_length,\n-\t\t\t\t\t\t    &se.pre);\n-\t\t\t}\n-\t\t      memsz = slen3;\n-\t\t    }\n-\t\t}\n+\t      tmp = fold_convert (TREE_TYPE (expr3_esize), expr3_len);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     TREE_TYPE (expr3_esize),\n+\t\t\t\t      expr3_esize, tmp);\n+\t      if (code->expr3->ts.type != BT_CLASS)\n+\t\t/* expr3 is a deferred length string, i.e., we are\n+\t\t   done.  */\n+\t\tmemsz = tmp;\n \t      else\n-\t\t/* Otherwise use the stored string length.  */\n-\t\tmemsz = code->expr3->ts.u.cl->backend_decl;\n-\t      tmp = al->expr->ts.u.cl->backend_decl;\n-\n-\t      /* Store the string length.  */\n-\t      if (tmp && TREE_CODE (tmp) == VAR_DECL)\n-\t\tgfc_add_modify (&se.pre, tmp, fold_convert (TREE_TYPE (tmp),\n-\t\t\t\tmemsz));\n-\t      else if (al->expr->ts.type == BT_CHARACTER\n-\t\t       && al->expr->ts.deferred && se.string_length)\n-\t\tgfc_add_modify (&se.pre, se.string_length,\n-\t\t\t\tfold_convert (TREE_TYPE (se.string_length),\n-\t\t\t\tmemsz));\n-\t      else if ((al->expr->ts.type == BT_DERIVED\n-\t\t\t|| al->expr->ts.type == BT_CLASS)\n-\t\t       && expr->ts.u.derived->attr.unlimited_polymorphic)\n \t\t{\n-\t\t  tmp = gfc_class_len_get (al->expr->symtree->n.sym->backend_decl);\n-\t\t  gfc_add_modify (&se.pre, tmp,\n-\t\t\t\t  fold_convert (TREE_TYPE (tmp),\n-\t\t\t\t\t\tmemsz));\n+\t\t  /* For unlimited polymorphic enties build\n+\t\t\t  (len > 0) ? element_size * len : element_size\n+\t\t     to compute the number of bytes to allocate.\n+\t\t     This allows the allocation of unlimited polymorphic\n+\t\t     objects from an expr3 that is also unlimited\n+\t\t     polymorphic and stores a _len dependent object,\n+\t\t     e.g., a string.  */\n+\t\t  memsz = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\t   boolean_type_node, expr3_len,\n+\t\t\t\t\t   integer_zero_node);\n+\t\t  memsz = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t TREE_TYPE (expr3_esize),\n+\t\t\t\t\t memsz, tmp, expr3_esize);\n \t\t}\n-\n-\t      /* Convert to size in bytes, using the character KIND.  */\n-\t      if (unlimited_char)\n-\t\ttmp = TREE_TYPE (gfc_typenode_for_spec (&code->expr3->ts));\n-\t      else\n-\t\ttmp = TREE_TYPE (gfc_typenode_for_spec (&al->expr->ts));\n-\t      tmp = TYPE_SIZE_UNIT (tmp);\n-\t      memsz = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t       TREE_TYPE (tmp), tmp,\n-\t\t\t\t       fold_convert (TREE_TYPE (tmp), memsz));\n \t    }\n-          else if ((al->expr->ts.type == BT_CHARACTER && al->expr->ts.deferred)\n-\t\t    || unlimited_char)\n+\t  else if (expr3_esize != NULL_TREE)\n+\t    /* Any other object in expr3 just needs element size in\n+\t       bytes.  */\n+\t    memsz = expr3_esize;\n+\t  else if ((expr->ts.type == BT_CHARACTER && expr->ts.deferred)\n+\t\t   || (upoly_expr\n+\t\t       && code->ext.alloc.ts.type == BT_CHARACTER))\n \t    {\n-\t      gcc_assert (code->ext.alloc.ts.u.cl && code->ext.alloc.ts.u.cl->length);\n+\t      /* Allocating deferred length char arrays need the length\n+\t\t to allocate in the alloc_type_spec.  But also unlimited\n+\t\t polymorphic objects may be allocated as char arrays.\n+\t\t Both are handled here.  */\n \t      gfc_init_se (&se_sz, NULL);\n \t      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n \t      gfc_add_block_to_block (&se.pre, &se_sz.pre);\n \t      se_sz.expr = gfc_evaluate_now (se_sz.expr, &se.pre);\n \t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n-\t      /* Store the string length.  */\n-\t      if ((expr->symtree->n.sym->ts.type == BT_CLASS\n-\t\t  || expr->symtree->n.sym->ts.type == BT_DERIVED)\n-\t\t  && expr->ts.u.derived->attr.unlimited_polymorphic)\n-\t\t/* For unlimited polymorphic entities get the backend_decl of\n-\t\t   the _len component for that.  */\n-\t\ttmp = gfc_class_len_get (gfc_get_symbol_decl (\n-\t\t\t\t\t   expr->symtree->n.sym));\n-\t      else\n-\t\t/* Else use what is stored in the charlen->backend_decl.  */\n-\t\ttmp = al->expr->ts.u.cl->backend_decl;\n-\t      gfc_add_modify (&se.pre, tmp, fold_convert (TREE_TYPE (tmp),\n-\t\t\t      se_sz.expr));\n-              tmp = TREE_TYPE (gfc_typenode_for_spec (&code->ext.alloc.ts));\n-              tmp = TYPE_SIZE_UNIT (tmp);\n+\t      expr3_len = se_sz.expr;\n+\t      tmp_expr3_len_flag = true;\n+\t      tmp = TYPE_SIZE_UNIT (\n+\t\t    gfc_get_char_type (code->ext.alloc.ts.kind));\n \t      memsz = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t       TREE_TYPE (tmp), tmp,\n-\t\t\t\t       fold_convert (TREE_TYPE (se_sz.expr),\n-\t\t\t\t\t\t     se_sz.expr));\n+\t\t\t\t       TREE_TYPE (tmp),\n+\t\t\t\t       fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t     expr3_len),\n+\t\t\t\t       tmp);\n \t    }\n-\t  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n-\t    memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n-\t  else if (memsz == NULL_TREE)\n-\t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n-\n-\t  if (expr->ts.type == BT_CHARACTER && memsz == NULL_TREE)\n+\t  else if (expr->ts.type == BT_CHARACTER)\n \t    {\n-\t      memsz = se.string_length;\n-\n-\t      /* Convert to size in bytes, using the character KIND.  */\n-\t      tmp = TREE_TYPE (gfc_typenode_for_spec (&code->ext.alloc.ts));\n-\t      tmp = TYPE_SIZE_UNIT (tmp);\n+\t      /* Compute the number of bytes needed to allocate a fixed\n+\t\t length char array.  */\n+\t      gcc_assert (se.string_length != NULL_TREE);\n+\t      tmp = TYPE_SIZE_UNIT (gfc_get_char_type (expr->ts.kind));\n \t      memsz = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t       TREE_TYPE (tmp), tmp,\n-\t\t\t\t       fold_convert (TREE_TYPE (tmp), memsz));\n+\t\t\t\t       fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t     se.string_length));\n \t    }\n+\t  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n+\t    /* Handle all types, where the alloc_type_spec is set.  */\n+\t    memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n+\t  else\n+\t    /* Handle size computation of the type declared to alloc.  */\n+\t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));;\n \n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n \t  if (gfc_expr_attr (expr).allocatable)\n \t    gfc_allocate_allocatable (&se.pre, se.expr, memsz, NULL_TREE,\n-\t\t\t\t      stat, errmsg, errlen, label_finish, expr);\n+\t\t\t\t      stat, errmsg, errlen, label_finish,\n+\t\t\t\t      expr);\n \t  else\n \t    gfc_allocate_using_malloc (&se.pre, se.expr, memsz, stat);\n \n@@ -5202,6 +5361,19 @@ gfc_trans_allocate (gfc_code * code)\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \t}\n+      else\n+\t{\n+\t  if (expr->ts.type == BT_CHARACTER && al_len != NULL_TREE\n+\t      && expr3_len != NULL_TREE)\n+\t    {\n+\t      /* Arrays need to have a _len set before the array\n+\t\t descriptor is filled.  */\n+\t      gfc_add_modify (&block, al_len,\n+\t\t\t      fold_convert (TREE_TYPE (al_len), expr3_len));\n+\t      /* Prevent setting the length twice.  */\n+\t      al_len_needs_set = false;\n+\t    }\n+\t}\n \n       gfc_add_block_to_block (&block, &se.pre);\n \n@@ -5218,124 +5390,114 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n-      /* We need the vptr of CLASS objects to be initialized.  */\n-      e = gfc_copy_expr (al->expr);\n-      if (e->ts.type == BT_CLASS)\n+      /* Set the vptr.  */\n+      if (al_vptr != NULL_TREE)\n \t{\n-\t  gfc_expr *lhs, *rhs;\n-\t  gfc_se lse;\n-\t  gfc_ref *ref, *class_ref, *tail;\n-\n-\t  /* Find the last class reference.  */\n-\t  class_ref = NULL;\n-\t  for (ref = e->ref; ref; ref = ref->next)\n-\t    {\n-\t      if (ref->type == REF_COMPONENT\n-\t\t  && ref->u.c.component->ts.type == BT_CLASS)\n-\t\tclass_ref = ref;\n-\n-\t      if (ref->next == NULL)\n-\t\tbreak;\n-\t    }\n-\n-\t  /* Remove and store all subsequent references after the\n-\t     CLASS reference.  */\n-\t  if (class_ref)\n-\t    {\n-\t      tail = class_ref->next;\n-\t      class_ref->next = NULL;\n-\t    }\n-\t  else\n-\t    {\n-\t      tail = e->ref;\n-\t      e->ref = NULL;\n-\t    }\n-\n-\t  lhs = gfc_expr_to_initialize (e);\n-\t  gfc_add_vptr_component (lhs);\n-\n-\t  /* Remove the _vptr component and restore the original tail\n-\t     references.  */\n-\t  if (class_ref)\n-\t    {\n-\t      gfc_free_ref_list (class_ref->next);\n-\t      class_ref->next = tail;\n-\t    }\n-\t  else\n-\t    {\n-\t      gfc_free_ref_list (e->ref);\n-\t      e->ref = tail;\n-\t    }\n-\n-\t  if (class_expr != NULL_TREE)\n-\t    {\n-\t      /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n-\t      gfc_init_se (&lse, NULL);\n-\t      lse.want_pointer = 1;\n-\t      gfc_conv_expr (&lse, lhs);\n-\t      tmp = gfc_class_vptr_get (class_expr);\n-\t      gfc_add_modify (&block, lse.expr,\n-\t\t\tfold_convert (TREE_TYPE (lse.expr), tmp));\n-\t    }\n-\t  else if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n-\t    {\n-\t      /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n-\t      rhs = gfc_copy_expr (code->expr3);\n-\t      gfc_add_vptr_component (rhs);\n-\t      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-\t      gfc_add_expr_to_block (&block, tmp);\n-\t      gfc_free_expr (rhs);\n-\t      rhs = gfc_expr_to_initialize (e);\n-\t    }\n+\t  if (expr3_vptr != NULL_TREE)\n+\t    /* The vtab is already known, so just assign it.  */\n+\t    gfc_add_modify (&block, al_vptr,\n+\t\t\t    fold_convert (TREE_TYPE (al_vptr), expr3_vptr));\n \t  else\n \t    {\n \t      /* VPTR is fixed at compile time.  */\n \t      gfc_symbol *vtab;\n \t      gfc_typespec *ts;\n+\n \t      if (code->expr3)\n+\t\t/* Although expr3 is pre-evaluated above, it may happen,\n+\t\t   that for arrays or in mold= cases the pre-evaluation\n+\t\t   was not successful.  In these rare cases take the vtab\n+\t\t   from the typespec of expr3 here.  */\n \t\tts = &code->expr3->ts;\n-\t      else if (e->ts.type == BT_DERIVED)\n-\t\tts = &e->ts;\n-\t      else if (code->ext.alloc.ts.type == BT_DERIVED || UNLIMITED_POLY (al->expr))\n+\t      else if (code->ext.alloc.ts.type == BT_DERIVED || upoly_expr)\n+\t\t/* The alloc_type_spec gives the type to allocate or the\n+\t\t   al is unlimited polymorphic, which enforces the use of\n+\t\t   an alloc_type_spec that is not necessarily a BT_DERIVED.  */\n \t\tts = &code->ext.alloc.ts;\n-\t      else if (e->ts.type == BT_CLASS)\n-\t\tts = &CLASS_DATA (e)->ts;\n \t      else\n-\t\tts = &e->ts;\n-\n-\t      if (ts->type == BT_DERIVED || UNLIMITED_POLY (e))\n-\t\t{\n-\t\t  vtab = gfc_find_vtab (ts);\n-\t\t  gcc_assert (vtab);\n-\t\t  gfc_init_se (&lse, NULL);\n-\t\t  lse.want_pointer = 1;\n-\t\t  gfc_conv_expr (&lse, lhs);\n-\t\t  tmp = gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t\t     gfc_get_symbol_decl (vtab));\n-\t\t  gfc_add_modify (&block, lse.expr,\n-\t\t\tfold_convert (TREE_TYPE (lse.expr), tmp));\n-\t\t}\n+\t\t/* Prepare for setting the vtab as declared.  */\n+\t\tts = &expr->ts;\n+\n+\t      vtab = gfc_find_vtab (ts);\n+\t      gcc_assert (vtab);\n+\t      tmp = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t gfc_get_symbol_decl (vtab));\n+\t      gfc_add_modify (&block, al_vptr,\n+\t\t\t      fold_convert (TREE_TYPE (al_vptr), tmp));\n \t    }\n-\t  gfc_free_expr (lhs);\n \t}\n \n-      gfc_free_expr (e);\n-\n+      /* Add assignment for string length.  */\n+      if (al_len != NULL_TREE && al_len_needs_set)\n+\t{\n+\t  if (expr3_len != NULL_TREE)\n+\t    {\n+\t      gfc_add_modify (&block, al_len,\n+\t\t\t      fold_convert (TREE_TYPE (al_len),\n+\t\t\t\t\t    expr3_len));\n+\t      /* When tmp_expr3_len_flag is set, then expr3_len is\n+\t\t abused to carry the length information from the\n+\t\t alloc_type.  Clear it to prevent setting incorrect len\n+\t\t information in future loop iterations.  */\n+\t      if (tmp_expr3_len_flag)\n+\t\t/* No need to reset tmp_expr3_len_flag, because the\n+\t\t   presence of an expr3 can not change within in the\n+\t\t   loop.  */\n+\t\texpr3_len = NULL_TREE;\n+\t    }\n+\t  else if (code->ext.alloc.ts.type == BT_CHARACTER\n+\t\t   && code->ext.alloc.ts.u.cl->length)\n+\t    {\n+\t      /* Cover the cases where a string length is explicitly\n+\t\t specified by a type spec for deferred length character\n+\t\t arrays or unlimited polymorphic objects without a\n+\t\t source= or mold= expression.  */\n+\t      gfc_init_se (&se_sz, NULL);\n+\t      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n+\t      gfc_add_modify (&block, al_len,\n+\t\t\t      fold_convert (TREE_TYPE (al_len),\n+\t\t\t\t\t    se_sz.expr));\n+\t    }\n+\t  else\n+\t    /* No length information needed, because type to allocate\n+\t       has no length.  Set _len to 0.  */\n+\t    gfc_add_modify (&block, al_len,\n+\t\t\t    fold_convert (TREE_TYPE (al_len),\n+\t\t\t\t\t  integer_zero_node));\n+\t}\n       if (code->expr3 && !code->expr3->mold)\n \t{\n \t  /* Initialization via SOURCE block\n \t     (or static default initializer).  */\n \t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n-\t  if (class_expr != NULL_TREE)\n+\t  if (expr3 != NULL_TREE\n+\t      && ((POINTER_TYPE_P (TREE_TYPE (expr3))\n+\t\t   && TREE_CODE (expr3) != POINTER_PLUS_EXPR)\n+\t\t  || VAR_P (expr3))\n+\t      && code->expr3->ts.type == BT_CLASS\n+\t      && (expr->ts.type == BT_CLASS\n+\t\t  || expr->ts.type == BT_DERIVED))\n \t    {\n \t      tree to;\n-\t      to = TREE_OPERAND (se.expr, 0);\n-\n-\t      tmp = gfc_copy_class_to_class (class_expr, to, nelems);\n+\t      to = VAR_P (se.expr) ? se.expr : TREE_OPERAND (se.expr, 0);\n+\t      tmp = gfc_copy_class_to_class (expr3, to,\n+\t\t\t\t\t     nelems, upoly_expr);\n+\t    }\n+\t  else if (code->expr3->ts.type == BT_CHARACTER)\n+\t    {\n+\t      tmp = INDIRECT_REF_P (se.expr) ?\n+\t\t\tse.expr :\n+\t\t\tbuild_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t     se.expr);\n+\t      gfc_trans_string_copy (&block, al_len, tmp,\n+\t\t\t\t     code->expr3->ts.kind,\n+\t\t\t\t     expr3_len, expr3,\n+\t\t\t\t     code->expr3->ts.kind);\n+\t      tmp = NULL_TREE;\n \t    }\n \t  else if (al->expr->ts.type == BT_CLASS)\n \t    {\n-\t      gfc_actual_arglist *actual;\n+\t      gfc_actual_arglist *actual, *last_arg;\n \t      gfc_expr *ppc;\n \t      gfc_code *ppc_code;\n \t      gfc_ref *ref, *dataref;\n@@ -5345,15 +5507,15 @@ gfc_trans_allocate (gfc_code * code)\n \t      actual->expr = gfc_copy_expr (rhs);\n \t      if (rhs->ts.type == BT_CLASS)\n \t\tgfc_add_data_component (actual->expr);\n-\t      actual->next = gfc_get_actual_arglist ();\n-\t      actual->next->expr = gfc_copy_expr (al->expr);\n-\t      actual->next->expr->ts.type = BT_CLASS;\n-\t      gfc_add_data_component (actual->next->expr);\n+\t      last_arg = actual->next = gfc_get_actual_arglist ();\n+\t      last_arg->expr = gfc_copy_expr (al->expr);\n+\t      last_arg->expr->ts.type = BT_CLASS;\n+\t      gfc_add_data_component (last_arg->expr);\n \n \t      dataref = NULL;\n \t      /* Make sure we go up through the reference chain to\n \t\t the _data reference, where the arrayspec is found.  */\n-\t      for (ref = actual->next->expr->ref; ref; ref = ref->next)\n+\t      for (ref = last_arg->expr->ref; ref; ref = ref->next)\n \t\tif (ref->type == REF_COMPONENT\n \t\t    && strcmp (ref->u.c.component->name, \"_data\") == 0)\n \t\t  dataref = ref;\n@@ -5387,7 +5549,10 @@ gfc_trans_allocate (gfc_code * code)\n \t\t}\n \t      if (rhs->ts.type == BT_CLASS)\n \t\t{\n-\t\t  ppc = gfc_copy_expr (rhs);\n+\t\t  if (rhs->ref)\n+\t\t    ppc = gfc_find_and_cut_at_last_class_ref (rhs);\n+\t\t  else\n+\t\t    ppc = gfc_copy_expr (rhs);\n \t\t  gfc_add_vptr_component (ppc);\n \t\t}\n \t      else\n@@ -5396,6 +5561,7 @@ gfc_trans_allocate (gfc_code * code)\n \n \t      ppc_code = gfc_get_code (EXEC_CALL);\n \t      ppc_code->resolved_sym = ppc->symtree->n.sym;\n+\t      ppc_code->loc = al->expr->where;\n \t      /* Although '_copy' is set to be elemental in class.c, it is\n \t\t not staying that way.  Find out why, sometime....  */\n \t      ppc_code->resolved_sym->attr.elemental = 1;\n@@ -5404,19 +5570,53 @@ gfc_trans_allocate (gfc_code * code)\n \t      /* Since '_copy' is elemental, the scalarizer will take care\n \t\t of arrays in gfc_trans_call.  */\n \t      tmp = gfc_trans_call (ppc_code, true, NULL, NULL, false);\n+\t      /* We need to add the\n+\t\t   if (al_len > 0)\n+\t\t     al_vptr->copy (expr3_data, al_data, expr3_len, al_len);\n+\t\t   else\n+\t\t     al_vptr->copy (expr3_data, al_data);\n+\t\t block, because al is unlimited polymorphic or a deferred\n+\t\t length char array, whose copy routine needs the array lengths\n+\t\t as third and fourth arguments.  */\n+\t      if (al_len && UNLIMITED_POLY (code->expr3))\n+\t\t{\n+\t\t  tree stdcopy, extcopy;\n+\t\t  /* Add al%_len.  */\n+\t\t  last_arg->next = gfc_get_actual_arglist ();\n+\t\t  last_arg = last_arg->next;\n+\t\t  last_arg->expr = gfc_find_and_cut_at_last_class_ref (\n+\t\t\tal->expr);\n+\t\t  gfc_add_len_component (last_arg->expr);\n+\t\t  /* Add expr3's length.  */\n+\t\t  last_arg->next = gfc_get_actual_arglist ();\n+\t\t  last_arg = last_arg->next;\n+\t\t  if (code->expr3->ts.type == BT_CLASS)\n+\t\t    {\n+\t\t      last_arg->expr =\n+\t\t\t  gfc_find_and_cut_at_last_class_ref (code->expr3);\n+\t\t      gfc_add_len_component (last_arg->expr);\n+\t\t    }\n+\t\t  else if (code->expr3->ts.type == BT_CHARACTER)\n+\t\t      last_arg->expr =\n+\t\t\t  gfc_copy_expr (code->expr3->ts.u.cl->length);\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\n+\t\t  stdcopy = tmp;\n+\t\t  extcopy = gfc_trans_call (ppc_code, true, NULL, NULL, false);\n+\n+\t\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\t boolean_type_node, expr3_len,\n+\t\t\t\t\t integer_zero_node);\n+\t\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n+\t\t}\n \t      gfc_free_statements (ppc_code);\n \t    }\n-\t  else if (expr3 != NULL_TREE)\n-\t    {\n-\t      tmp = build_fold_indirect_ref_loc (input_location, se.expr);\n-\t      gfc_trans_string_copy (&block, slen3, tmp, code->expr3->ts.kind,\n-\t\t\t\t     slen3, expr3, code->expr3->ts.kind);\n-\t      tmp = NULL_TREE;\n-\t    }\n \t  else\n \t    {\n-\t      /* Switch off automatic reallocation since we have just done\n-\t\t the ALLOCATE.  */\n+\t      /* Switch off automatic reallocation since we have just\n+\t\t done the ALLOCATE.  */\n \t      int realloc_lhs = flag_realloc_lhs;\n \t      flag_realloc_lhs = 0;\n \t      tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n@@ -5433,12 +5633,13 @@ gfc_trans_allocate (gfc_code * code)\n \t     object, we can use gfc_copy_class_to_class in its\n \t     initialization mode.  */\n \t  tmp = TREE_OPERAND (se.expr, 0);\n-\t  tmp = gfc_copy_class_to_class (NULL_TREE, tmp, nelems);\n+\t  tmp = gfc_copy_class_to_class (NULL_TREE, tmp, nelems,\n+\t\t\t\t\t upoly_expr);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n        gfc_free_expr (expr);\n-    }\n+    } // for-loop\n \n   /* STAT.  */\n   if (code->expr1)\n@@ -5463,17 +5664,20 @@ gfc_trans_allocate (gfc_code * code)\n \n       slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n       dlen = gfc_get_expr_charlen (code->expr2);\n-      slen = fold_build2_loc (input_location, MIN_EXPR, TREE_TYPE (slen), dlen,\n-\t\t\t      slen);\n+      slen = fold_build2_loc (input_location, MIN_EXPR,\n+\t\t\t      TREE_TYPE (slen), dlen, slen);\n \n-      gfc_trans_string_copy (&errmsg_block, dlen, errmsg, code->expr2->ts.kind,\n-\t\t\t     slen, errmsg_str, gfc_default_character_kind);\n+      gfc_trans_string_copy (&errmsg_block, dlen, errmsg,\n+\t\t\t     code->expr2->ts.kind,\n+\t\t\t     slen, errmsg_str,\n+\t\t\t     gfc_default_character_kind);\n       dlen = gfc_finish_block (&errmsg_block);\n \n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n-\t\t\t     build_int_cst (TREE_TYPE (stat), 0));\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     stat, build_int_cst (TREE_TYPE (stat), 0));\n \n-      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt (input_location));\n+      tmp = build3_v (COND_EXPR, tmp,\n+\t\t      dlen, build_empty_stmt (input_location));\n \n       gfc_add_expr_to_block (&block, tmp);\n     }\n@@ -5571,7 +5775,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t\t  last = ref;\n \n \t      /* Do not deallocate the components of a derived type\n-\t\tultimate pointer component.  */\n+\t\t ultimate pointer component.  */\n \t      if (!(last && last->u.c.component->attr.pointer)\n \t\t    && !(!last && expr->symtree->n.sym->attr.pointer))\n \t\t{\n@@ -5616,7 +5820,14 @@ gfc_trans_deallocate (gfc_code *code)\n \t    }\n \n \t  if (al->expr->ts.type == BT_CLASS)\n-\t    gfc_reset_vptr (&se.pre, al->expr);\n+\t    {\n+\t      gfc_reset_vptr (&se.pre, al->expr);\n+\t      if (UNLIMITED_POLY (al->expr)\n+\t\t  || (al->expr->ts.type == BT_DERIVED\n+\t\t      && al->expr->ts.u.derived->attr.unlimited_polymorphic))\n+\t\t/* Clear _len, too.  */\n+\t\tgfc_reset_len (&se.pre, al->expr);\n+\t    }\n \t}\n       else\n \t{\n@@ -5631,7 +5842,14 @@ gfc_trans_deallocate (gfc_code *code)\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  if (al->expr->ts.type == BT_CLASS)\n-\t    gfc_reset_vptr (&se.pre, al->expr);\n+\t    {\n+\t      gfc_reset_vptr (&se.pre, al->expr);\n+\t      if (UNLIMITED_POLY (al->expr)\n+\t\t  || (al->expr->ts.type == BT_DERIVED\n+\t\t      && al->expr->ts.u.derived->attr.unlimited_polymorphic))\n+\t\t/* Clear _len, too.  */\n+\t\tgfc_reset_len (&se.pre, al->expr);\n+\t    }\n \t}\n \n       if (code->expr1)"}, {"sha": "b7ec0e52cf978aaa97b3e7205eba44459c328dd3", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -373,7 +373,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n \t    return build4_loc (input_location, ARRAY_REF, type, base,\n \t\t\t       offset, NULL_TREE, NULL_TREE);\n \n-\t  span = gfc_vtable_size_get (decl);\n+\t  span = gfc_class_vtab_size_get (decl);\n \t}\n       else if (GFC_DECL_SUBREF_ARRAY_P (decl))\n \tspan = GFC_DECL_SPAN(decl);\n@@ -1015,8 +1015,8 @@ gfc_add_comp_finalizer_call (stmtblock_t *block, tree decl, gfc_component *comp,\n \treturn false;\n \n       gfc_is_finalizable (CLASS_DATA (comp)->ts.u.derived, &final_expr);\n-      final_fndecl = gfc_vtable_final_get (decl);\n-      size = gfc_vtable_size_get (decl);\n+      final_fndecl = gfc_class_vtab_final_get (decl);\n+      size = gfc_class_vtab_size_get (decl);\n       array = gfc_class_data_get (decl);\n     }\n "}, {"sha": "199835861cd99b43ca542278dd3a9b2a152fe4f4", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -350,20 +350,31 @@ typedef struct\n gfc_wrapped_block;\n \n /* Class API functions.  */\n+tree gfc_class_set_static_fields (tree, tree, tree);\n tree gfc_class_data_get (tree);\n tree gfc_class_vptr_get (tree);\n tree gfc_class_len_get (tree);\n+gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *);\n+/* Get an accessor to the class' vtab's * field, when a class handle is\n+   available.  */\n+tree gfc_class_vtab_hash_get (tree);\n+tree gfc_class_vtab_size_get (tree);\n+tree gfc_class_vtab_extends_get (tree);\n+tree gfc_class_vtab_def_init_get (tree);\n+tree gfc_class_vtab_copy_get (tree);\n+tree gfc_class_vtab_final_get (tree);\n+/* Get an accessor to the vtab's * field, when a vptr handle is present.  */\n+tree gfc_vtpr_hash_get (tree);\n+tree gfc_vptr_size_get (tree);\n+tree gfc_vptr_extends_get (tree);\n+tree gfc_vptr_def_init_get (tree);\n+tree gfc_vptr_copy_get (tree);\n+tree gfc_vptr_final_get (tree);\n void gfc_reset_vptr (stmtblock_t *, gfc_expr *);\n-tree gfc_class_set_static_fields (tree, tree, tree);\n-tree gfc_vtable_hash_get (tree);\n-tree gfc_vtable_size_get (tree);\n-tree gfc_vtable_extends_get (tree);\n-tree gfc_vtable_def_init_get (tree);\n-tree gfc_vtable_copy_get (tree);\n-tree gfc_vtable_final_get (tree);\n+void gfc_reset_len (stmtblock_t *, gfc_expr *);\n tree gfc_get_vptr_from_expr (tree);\n tree gfc_get_class_array_ref (tree, tree);\n-tree gfc_copy_class_to_class (tree, tree, tree);\n+tree gfc_copy_class_to_class (tree, tree, tree, bool);\n bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);\n bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);\n "}, {"sha": "6049784558fe7f8d840e41983b3ec83d7ef59053", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -1,3 +1,18 @@\n+2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n+\n+\t* gfortran.dg/allocate_alloc_opt_13.f90: Added tests for\n+\tsource= and mold= expressions functionality.\n+\t* gfortran.dg/allocate_class_4.f90: New test.\n+\t* gfortran.dg/unlimited_polymorphic_20.f90: Added test whether\n+\tcopying an unlimited polymorhpic object containing a char array\n+\tto another unlimited polymorphic object respects the _len\n+\tcomponent.\n+\t* gfortran.dg/unlimited_polymorphic_22.f90: Extended to check\n+\twhether deferred length char array allocate works, unlimited\n+\tpolymorphic object allocation from a string works and if\n+\tallocating an array of deferred length strings works.\n+\t* gfortran.dg/unlimited_polymorphic_24.f03: New test.\n+\n 2015-03-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/65513"}, {"sha": "f9e199c43662e24f1d3aac520625089876f8e325", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_13.f90", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_13.f90?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -12,6 +12,9 @@\n allocate (a, b, source=c(1))\n allocate (c(4), d(6), source=e)\n \n+allocate (a, b, mold=f())\n+allocate (c(1), d(6), mold=g())\n+\n allocate (a, b, source=f())\n allocate (c(1), d(6), source=g())\n "}, {"sha": "23c9d53d171feb61f16e289bac469b24acdee87e", "filename": "gcc/testsuite/gfortran.dg/allocate_class_4.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_class_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_class_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_class_4.f90?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+!\n+! Part of PR 51946, but breaks easily, therefore introduce its own test\n+! Authors: Damian Rouson  <damian@sourceryinstitute.org>,\n+!          Dominique Pelletier  <dominique.pelletier@polymtl.ca>\n+! Contributed by: Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+module integrable_model_module\n+\n+   implicit none\n+\n+   type, abstract, public :: integrable_model\n+      contains\n+         procedure(default_constructor), deferred :: empty_instance\n+   end type\n+\n+   abstract interface\n+      function default_constructor(this) result(blank_slate)\n+         import :: integrable_model\n+         class(integrable_model), intent(in)  :: this\n+         class(integrable_model), allocatable :: blank_slate\n+      end function\n+   end interface\n+\n+   contains\n+\n+      subroutine integrate(this)\n+         class(integrable_model), intent(inout) :: this\n+         class(integrable_model), allocatable   :: residual\n+         allocate(residual, source=this%empty_instance())\n+      end subroutine\n+\n+end module integrable_model_module\n+\n+! { dg-final { cleanup-modules \"integrable_model_module\" } }\n+ "}, {"sha": "49d35c88b6dcd249cdb99b39cc7db85f7e85af4b", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f90", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_20.f90?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -23,12 +23,14 @@ program test\n     implicit none\n     character(LEN=:), allocatable, target :: S\n     character(LEN=100) :: res\n-    class(*), pointer :: ucp\n+    class(*), pointer :: ucp, ucp2\n     call sub1 (\"long test string\", 16)\n     call sub2 ()\n     S = \"test\"\n     ucp => S\n     call sub3 (ucp)\n+    allocate (ucp2, source=ucp)\n+    call sub3 (ucp2)\n     call sub4 (S, 4)\n     call sub4 (\"This is a longer string.\", 24)\n     call bar (S, res)"}, {"sha": "1d44c9f86864da45af6afa7dc51220ef1a238b8f", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_22.f90", "status": "modified", "additions": 186, "deletions": 27, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_22.f90?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -5,52 +5,211 @@\n program test\n     implicit none\n \n-    class(*), pointer :: P\n+    class(*), pointer :: P1, P2, P3\n+    class(*), pointer, dimension(:) :: PA1\n+    class(*), allocatable :: A1, A2\n     integer :: string_len = 10 *2\n+    character(len=:), allocatable, target :: str\n+    character(len=:,kind=4), allocatable :: str4\n+    type T\n+        class(*), pointer :: content\n+    end type\n+    type(T) :: o1, o2\n+\n+    str = \"string for test\"\n+    str4 = 4_\"string for test\"\n+\n+    allocate(character(string_len)::P1)\n+\n+    select type(P1)\n+        type is (character(*))\n+            P1 =\"some test string\"\n+            if (P1 .ne. \"some test string\") call abort ()\n+            if (len(P1) .ne. 20) call abort ()\n+            if (len(P1) .eq. len(\"some test string\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(A1, source = P1)\n \n-    allocate(character(string_len)::P)\n+    select type(A1)\n+        type is (character(*))\n+            if (A1 .ne. \"some test string\") call abort ()\n+            if (len(A1) .ne. 20) call abort ()\n+            if (len(A1) .eq. len(\"some test string\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(A2, source = convertType(P1))\n \n-    select type(P)\n+    select type(A2)\n         type is (character(*))\n-            P =\"some test string\"\n-            if (P .ne. \"some test string\") then\n-                call abort ()\n-            end if\n-            if (len(P) .ne. 20) then\n-                call abort ()\n-            end if\n-            if (len(P) .eq. len(\"some test string\")) then\n-                call abort ()\n-            end if\n+            if (A2 .ne. \"some test string\") call abort ()\n+            if (len(A2) .ne. 20) call abort ()\n+            if (len(A2) .eq. len(\"some test string\")) call abort ()\n         class default\n             call abort ()\n     end select\n \n-    deallocate(P)\n+    allocate(P2, source = str)\n+\n+    select type(P2)\n+        type is (character(*))\n+            if (P2 .ne. \"string for test\") call abort ()\n+            if (len(P2) .eq. 20) call abort ()\n+            if (len(P2) .ne. len(\"string for test\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(P3, source = \"string for test\")\n+\n+    select type(P3)\n+        type is (character(*))\n+            if (P3 .ne. \"string for test\") call abort ()\n+            if (len(P3) .eq. 20) call abort ()\n+            if (len(P3) .ne. len(\"string for test\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(character(len=10)::PA1(3))\n+\n+    select type(PA1)\n+        type is (character(*))\n+            PA1(1) = \"string 10 \"\n+            if (PA1(1) .ne. \"string 10 \") call abort ()\n+            if (any(len(PA1(:)) .ne. [10,10,10])) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    deallocate(PA1)\n+    deallocate(P3)\n+!   if (len(P3) .ne. 0) call abort() ! Can't check, because select\n+!     type would be needed, which needs the vptr, which is 0 now.\n+    deallocate(P2)\n+    deallocate(A2)\n+    deallocate(A1)\n+    deallocate(P1)\n \n     ! Now for kind=4 chars.\n \n-    allocate(character(len=20,kind=4)::P)\n+    allocate(character(len=20,kind=4)::P1)\n+\n+    select type(P1)\n+        type is (character(len=*,kind=4))\n+            P1 =\"some test string\"\n+            if (P1 .ne. 4_\"some test string\") call abort ()\n+            if (len(P1) .ne. 20) call abort ()\n+            if (len(P1) .eq. len(\"some test string\")) call abort ()\n+        type is (character(len=*,kind=1))\n+            call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(A1, source=P1)\n \n-    select type(P)\n+    select type(A1)\n         type is (character(len=*,kind=4))\n-            P =\"some test string\"\n-            if (P .ne. 4_\"some test string\") then\n-                call abort ()\n-            end if\n-            if (len(P) .ne. 20) then\n-                call abort ()\n-            end if\n-            if (len(P) .eq. len(\"some test string\")) then\n-                call abort ()\n-            end if\n+            if (A1 .ne. 4_\"some test string\") call abort ()\n+            if (len(A1) .ne. 20) call abort ()\n+            if (len(A1) .eq. len(\"some test string\")) call abort ()\n         type is (character(len=*,kind=1))\n             call abort ()\n         class default\n             call abort ()\n     end select\n \n-    deallocate(P)\n+    allocate(A2, source = convertType(P1))\n+\n+    select type(A2)\n+        type is (character(len=*, kind=4))\n+            if (A2 .ne. 4_\"some test string\") call abort ()\n+            if (len(A2) .ne. 20) call abort ()\n+            if (len(A2) .eq. len(\"some test string\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(P2, source = str4)\n+\n+    select type(P2)\n+        type is (character(len=*,kind=4))\n+            if (P2 .ne. 4_\"string for test\") call abort ()\n+            if (len(P2) .eq. 20) call abort ()\n+            if (len(P2) .ne. len(\"string for test\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(P3, source = convertType(P2))\n \n+    select type(P3)\n+        type is (character(len=*, kind=4))\n+            if (P3 .ne. 4_\"string for test\") call abort ()\n+            if (len(P3) .eq. 20) call abort ()\n+            if (len(P3) .ne. len(\"string for test\")) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    allocate(character(kind=4, len=10)::PA1(3))\n+\n+    select type(PA1)\n+        type is (character(len=*, kind=4))\n+            PA1(1) = 4_\"string 10 \"\n+            if (PA1(1) .ne. 4_\"string 10 \") call abort ()\n+            if (any(len(PA1(:)) .ne. [10,10,10])) call abort ()\n+        class default\n+            call abort ()\n+    end select\n+\n+    deallocate(PA1)\n+    deallocate(P3)\n+    deallocate(P2)\n+    deallocate(A2)\n+    deallocate(P1)\n+    deallocate(A1)\n+\n+    allocate(o1%content, source='test string')\n+    allocate(o2%content, source=o1%content)\n+    select type (c => o1%content)\n+      type is (character(*))\n+        if (c /= 'test string') call abort ()\n+      class default\n+        call abort()\n+    end select\n+    select type (d => o2%content)\n+      type is (character(*))\n+        if (d /= 'test string') call abort ()\n+      class default\n+    end select\n+\n+    call AddCopy ('test string')\n+\n+contains\n+\n+  function convertType(in)\n+    class(*), pointer, intent(in) :: in\n+    class(*), pointer :: convertType\n+\n+    convertType => in\n+  end function\n+\n+  subroutine AddCopy(C)\n+    class(*), intent(in) :: C\n+    class(*), pointer :: P\n+    allocate(P, source=C)\n+    select type (P)\n+      type is (character(*))\n+        if (P /= 'test string') call abort()\n+      class default\n+        call abort()\n+    end select\n+  end subroutine\n \n end program test"}, {"sha": "48efa11c62a51071838f75767d575364b509a180", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_24.f03", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_24.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d9d74996badd2b9ee315903f916ebb7a8d422f/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_24.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_24.f03?ref=34d9d74996badd2b9ee315903f916ebb7a8d422f", "patch": "@@ -0,0 +1,215 @@\n+! { dg-do run }\n+!\n+! Test case for unlimited polymorphism that is derived from the article\n+! by Mark Leair, in the 'PGI Insider':\n+! https://www.pgroup.com/lit/articles/insider/v3n2a2.htm\n+! Note that 'getValue' has been removed from the generic 'add' becuse\n+! gfortran asserts that this is ambiguous. See\n+! https://gcc.gnu.org/ml/fortran/2015-03/msg00002.html for a discussion.\n+!\n+module link_mod\n+  private\n+  public :: link, output, index\n+  character(6) :: output (14)\n+  integer :: index = 0\n+  type link\n+     private\n+     class(*), pointer :: value => null() ! value stored in link\n+     type(link), pointer :: next => null()! next link in list\n+     contains\n+     procedure :: getValue    ! return value pointer\n+     procedure :: printLinks  ! print linked list starting with this link\n+     procedure :: nextLink    ! return next pointer\n+     procedure :: setNextLink ! set next pointer\n+  end type link\n+\n+  interface link\n+   procedure constructor ! construct/initialize a link\n+  end interface\n+\n+contains\n+\n+  function nextLink(this)\n+  class(link) :: this\n+  class(link), pointer :: nextLink\n+    nextLink => this%next\n+  end function nextLink\n+\n+  subroutine setNextLink(this,next)\n+  class(link) :: this\n+  class(link), pointer :: next\n+     this%next => next\n+  end subroutine setNextLink\n+\n+  function getValue(this)\n+  class(link) :: this\n+  class(*), pointer :: getValue\n+  getValue => this%value\n+  end function getValue\n+\n+  subroutine printLink(this)\n+  class(link) :: this\n+\n+  index = index + 1\n+\n+  select type(v => this%value)\n+  type is (integer)\n+    write (output(index), '(i6)') v\n+  type is (character(*))\n+    write (output(index), '(a6)') v\n+  type is (real)\n+    write (output(index), '(f6.2)') v\n+  class default\n+    stop 'printLink: unexepected type for link'\n+  end select\n+\n+  end subroutine printLink\n+\n+  subroutine printLinks(this)\n+  class(link) :: this\n+  class(link), pointer :: curr\n+\n+  call printLink(this)\n+  curr => this%next\n+  do while(associated(curr))\n+    call printLink(curr)\n+    curr => curr%next\n+  end do\n+\n+  end subroutine\n+\n+  function constructor(value, next)\n+    class(link),pointer :: constructor\n+    class(*) :: value\n+    class(link), pointer :: next\n+    allocate(constructor)\n+    constructor%next => next\n+    allocate(constructor%value, source=value)\n+  end function constructor\n+\n+end module link_mod\n+\n+module list_mod\n+  use link_mod\n+  private\n+  public :: list\n+  type list\n+     private\n+     class(link),pointer :: firstLink => null() ! first link in list\n+     class(link),pointer :: lastLink => null()  ! last link in list\n+   contains\n+     procedure :: printValues ! print linked list\n+     procedure :: addInteger  ! add integer to linked list\n+     procedure :: addChar     ! add character to linked list\n+     procedure :: addReal     ! add real to linked list\n+     procedure :: addValue    ! add class(*) to linked list\n+     procedure :: firstValue  ! return value associated with firstLink\n+     procedure :: isEmpty     ! return true if list is empty\n+     generic :: add => addInteger, addChar, addReal\n+  end type list\n+\n+contains\n+\n+  subroutine printValues(this)\n+    class(list) :: this\n+\n+    if (.not.this%isEmpty()) then\n+       call this%firstLink%printLinks()\n+    endif\n+  end subroutine printValues\n+\n+  subroutine addValue(this, value)\n+    class(list) :: this\n+    class(*) :: value\n+    class(link), pointer :: newLink\n+\n+    if (.not. associated(this%firstLink)) then\n+       this%firstLink => link(value, this%firstLink)\n+       this%lastLink => this%firstLink\n+    else\n+       newLink => link(value, this%lastLink%nextLink())\n+       call this%lastLink%setNextLink(newLink)\n+       this%lastLink => newLink\n+    end if\n+\n+  end subroutine addValue\n+\n+  subroutine addInteger(this, value)\n+   class(list) :: this\n+    integer value\n+    class(*), allocatable :: v\n+    allocate(v,source=value)\n+    call this%addValue(v)\n+  end subroutine addInteger\n+\n+  subroutine addChar(this, value)\n+    class(list) :: this\n+    character(*) :: value\n+    class(*), allocatable :: v\n+\n+    allocate(v,source=value)\n+    call this%addValue(v)\n+  end subroutine addChar\n+\n+  subroutine addReal(this, value)\n+    class(list) :: this\n+    real value\n+    class(*), allocatable :: v\n+\n+    allocate(v,source=value)\n+    call this%addValue(v)\n+  end subroutine addReal\n+\n+  function firstValue(this)\n+    class(list) :: this\n+    class(*), pointer :: firstValue\n+\n+    firstValue => this%firstLink%getValue()\n+\n+  end function firstValue\n+\n+  function isEmpty(this)\n+    class(list) :: this\n+    logical isEmpty\n+\n+    if (associated(this%firstLink)) then\n+       isEmpty = .false.\n+    else\n+       isEmpty = .true.\n+    endif\n+  end function isEmpty\n+\n+end module list_mod\n+\n+program main\n+  use link_mod, only : output\n+  use list_mod\n+  implicit none\n+  integer i, j\n+  type(list) :: my_list\n+\n+  do i=1, 10\n+     call my_list%add(i)\n+  enddo\n+  call my_list%add(1.23)\n+  call my_list%add('A')\n+  call my_list%add('BC')\n+  call my_list%add('DEF')\n+  call my_list%printvalues()\n+  do i = 1, 14\n+    select case (i)\n+      case (1:10)\n+        read (output(i), '(i6)') j\n+        if (j .ne. i) call abort\n+      case (11)\n+        if (output(i) .ne. \"  1.23\") call abort\n+      case (12)\n+        if (output(i) .ne. \"     A\") call abort\n+      case (13)\n+        if (output(i) .ne. \"    BC\") call abort\n+      case (14)\n+        if (output(i) .ne. \"   DEF\") call abort\n+    end select\n+  end do\n+end program main\n+"}]}