{"sha": "7971481596bce205104973904b140708593c1ebb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk3MTQ4MTU5NmJjZTIwNTEwNDk3MzkwNGIxNDA3MDg1OTNjMWViYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-28T15:33:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-28T15:33:00Z"}, "message": "utils.c (gnat_pushdecl): Reunify the handling of array and pointer types wrt DECL_ORIGINAL_TYPE and...\n\n\t* gcc-interface/utils.c (gnat_pushdecl): Reunify the handling of array\n\tand pointer types wrt DECL_ORIGINAL_TYPE and adjust left and right.\n\nFrom-SVN: r223835", "tree": {"sha": "3d0f6d7c622238c9d32061494986414587216075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d0f6d7c622238c9d32061494986414587216075"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7971481596bce205104973904b140708593c1ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7971481596bce205104973904b140708593c1ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7971481596bce205104973904b140708593c1ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7971481596bce205104973904b140708593c1ebb/comments", "author": null, "committer": null, "parents": [{"sha": "fc7a823e1507110aba804cf94415155a8783e698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7a823e1507110aba804cf94415155a8783e698", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7a823e1507110aba804cf94415155a8783e698"}], "stats": {"total": 67, "additions": 35, "deletions": 32}, "files": [{"sha": "54c51110402c6de2a36bb9922811d099eb1520e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7971481596bce205104973904b140708593c1ebb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7971481596bce205104973904b140708593c1ebb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7971481596bce205104973904b140708593c1ebb", "patch": "@@ -1,3 +1,8 @@\n+2015-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (gnat_pushdecl): Reunify the handling of array\n+\tand pointer types wrt DECL_ORIGINAL_TYPE and adjust left and right.\n+\n 2015-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (gnat_stabilize_reference): Adjust."}, {"sha": "7615d2d727d8b32847d062264536e569608f12da", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7971481596bce205104973904b140708593c1ebb/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7971481596bce205104973904b140708593c1ebb/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=7971481596bce205104973904b140708593c1ebb", "patch": "@@ -776,31 +776,21 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     {\n       tree t = TREE_TYPE (decl);\n \n+      /* Array and pointer types aren't tagged types in the C sense so we need\n+\t to generate a typedef in DWARF for them and make sure it is preserved,\n+\t unless the type is artificial.  */\n       if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n-\t  && (TREE_CODE (t) != POINTER_TYPE || DECL_ARTIFICIAL (decl)))\n-\t{\n-\t  /* Array types aren't \"tagged\" types so we force the type to be\n-\t     associated with its typedef in the DWARF back-end, in order to\n-\t     make sure that the latter is always preserved, by creating an\n-\t     on-side copy for DECL_ORIGINAL_TYPE.  We used to do the same\n-\t     for pointer types, but to have consistent DWARF output we now\n-\t     create a copy for the type itself and use the original type\n-\t     for DECL_ORIGINAL_TYPE like the C front-end.  */\n-\t  if (!DECL_ARTIFICIAL (decl) && TREE_CODE (t) == ARRAY_TYPE)\n-\t    {\n-\t      tree tt = build_distinct_type_copy (t);\n-\t      /* Array types need to have a name so that they can be related\n-\t\t to their GNAT encodings.  */\n-\t      TYPE_NAME (tt) = DECL_NAME (decl);\n-\t      defer_or_set_type_context (tt,\n-\t\t\t\t\t DECL_CONTEXT (decl),\n-\t\t\t\t\t deferred_decl_context);\n-\t      TYPE_STUB_DECL (tt) = TYPE_STUB_DECL (t);\n-\t      DECL_ORIGINAL_TYPE (decl) = tt;\n-\t    }\n-\t}\n+\t  && ((TREE_CODE (t) != ARRAY_TYPE && TREE_CODE (t) != POINTER_TYPE)\n+\t      || DECL_ARTIFICIAL (decl)))\n+\t;\n+      /* For array and pointer types, create the DECL_ORIGINAL_TYPE that will\n+\t generate the typedef in DWARF.  Also do that for fat pointer types\n+\t because, even though they are tagged types in the C sense, they are\n+\t still XUP types attached to the base array type at this point.  */\n       else if (!DECL_ARTIFICIAL (decl)\n-\t       && (TREE_CODE (t) == POINTER_TYPE || TYPE_IS_FAT_POINTER_P (t)))\n+\t       && (TREE_CODE (t) == ARRAY_TYPE\n+\t\t   || TREE_CODE (t) == POINTER_TYPE\n+\t\t   || TYPE_IS_FAT_POINTER_P (t)))\n \t{\n \t  tree tt;\n \t  /* ??? Copy and original type are not supposed to be variant but we\n@@ -811,7 +801,8 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t    {\n \t      /* TYPE_NEXT_PTR_TO is a chain of main variants.  */\n \t      tt = build_distinct_type_copy (TYPE_MAIN_VARIANT (t));\n-\t      TYPE_NEXT_PTR_TO (TYPE_MAIN_VARIANT (t)) = tt;\n+\t      if (TREE_CODE (t) == POINTER_TYPE)\n+\t\tTYPE_NEXT_PTR_TO (TYPE_MAIN_VARIANT (t)) = tt;\n \t      tt = build_qualified_type (tt, TYPE_QUALS (t));\n \t    }\n \t  TYPE_NAME (tt) = decl;\n@@ -820,29 +811,36 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t\t\t\t     deferred_decl_context);\n \t  TREE_USED (tt) = TREE_USED (t);\n \t  TREE_TYPE (decl) = tt;\n-\t  if (TYPE_NAME (t) != NULL_TREE\n+\t  if (TYPE_NAME (t)\n \t      && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n \t      && DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n \t    DECL_ORIGINAL_TYPE (decl) = DECL_ORIGINAL_TYPE (TYPE_NAME (t));\n \t  else\n \t    DECL_ORIGINAL_TYPE (decl) = t;\n+\t  /* Array types need to have a name so that they can be related to\n+\t     their GNAT encodings.  */\n+\t  if (TREE_CODE (t) == ARRAY_TYPE && !TYPE_NAME (t))\n+\t    TYPE_NAME (t) = DECL_NAME (decl);\n \t  t = NULL_TREE;\n \t}\n-      else if (TYPE_NAME (t) != NULL_TREE\n+      else if (TYPE_NAME (t)\n \t       && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n \t       && DECL_ARTIFICIAL (TYPE_NAME (t)) && !DECL_ARTIFICIAL (decl))\n \t;\n       else\n \tt = NULL_TREE;\n \n-      /* Propagate the name to all the anonymous variants.  This is needed\n-\t for the type qualifiers machinery to work properly (see\n-\t check_qualified_type).  Also propagate the context to them.  Note that\n-\t the context will be propagated to all parallel types too thanks to\n-\t gnat_set_type_context.  */\n+      /* Propagate the name to all the variants, this is needed for the type\n+\t qualifiers machinery to work properly (see check_qualified_type).\n+\t Also propagate the context to them.  Note that it will be propagated\n+\t to all parallel types too thanks to gnat_set_type_context.  */\n       if (t)\n \tfor (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n-\t  if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n+\t  /* ??? Because of the previous kludge, we can have variants of fat\n+\t     pointer types with different names.  */\n+\t  if (!(TYPE_IS_FAT_POINTER_P (t)\n+\t\t&& TYPE_NAME (t)\n+\t\t&& TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n \t    {\n \t      TYPE_NAME (t) = decl;\n \t      defer_or_set_type_context (t,"}]}