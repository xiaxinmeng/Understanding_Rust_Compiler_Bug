{"sha": "71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFlM2Y3N2U4YzQ5NTE2ZWU1Zjk0YzdiNmFmMTE0ZGNkNDYwZThkZg==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-03-25T22:49:47Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-03-25T22:49:47Z"}, "message": "diamonds are not valid execution threads for jump threading\n\n\tPR tree-optimization/65177\n\t* tree-ssa-threadupdate.c (verify_seme): Renamed verify_jump_thread.\n\t(bb_in_bbs): New.\n\t(duplicate_seme_region): Renamed duplicate_thread_path.  Redirect all\n\tedges not adjacent on the path to the original code.\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-10.c: New.\n\nFrom-SVN: r221675", "tree": {"sha": "2a9776a037b33ebf45a601fe46032ded61b9bc3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9776a037b33ebf45a601fe46032ded61b9bc3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c8129f563e1788f5ff6ad041d8ece56d575a05c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8129f563e1788f5ff6ad041d8ece56d575a05c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8129f563e1788f5ff6ad041d8ece56d575a05c"}], "stats": {"total": 130, "additions": 104, "deletions": 26}, "files": [{"sha": "5e47d38c218e1825285b8cd09f8e7c62c27125ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "patch": "@@ -1,3 +1,11 @@\n+2015-03-25  Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/65177\n+\t* tree-ssa-threadupdate.c (verify_seme): Renamed verify_jump_thread.\n+\t(bb_in_bbs): New.\n+\t(duplicate_seme_region): Renamed duplicate_thread_path.  Redirect all\n+\tedges not adjacent on the path to the original code.\n+\n 2015-03-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR bootstrap/65537"}, {"sha": "92e09887302a66ec4d9e7aec96e803cb4466c2f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "patch": "@@ -1,3 +1,8 @@\n+2015-03-25  Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/65177\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-10.c: New.\n+\n 2015-03-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/sse-13.c: Include x86intrin.h and adjust #defines."}, {"sha": "4acf580e1d703bf8239b7ed188c96739ac717d40", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-10.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-10.c?ref=71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "patch": "@@ -0,0 +1,24 @@\n+/* PR 65177 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+typedef struct p7_profile_s {} P7_PROFILE;\n+enum p7t_statetype_e {\n+  p7T_S = 4,   p7T_N = 5,   p7T_E = 7,   p7T_C = 8,   p7T_J = 10, };\n+typedef struct p7_trace_s {} P7_TRACE;\n+typedef struct p7_gmx_s {\n+  int L;\n+} P7_GMX;\n+static inline int select_c(const P7_PROFILE *gm, const P7_GMX *pp, const P7_GMX *gx, int i) {\n+  float path[2];\n+  return ((path[0] > path[1]) ? p7T_C : p7T_E);\n+}\n+void p7_GOATrace(const P7_PROFILE *gm, const P7_GMX *pp, const P7_GMX *gx, P7_TRACE *tr) {\n+  int i = gx->L;\n+  int sprv, scur;\n+  while (sprv != p7T_S)     {\n+    switch (sprv) {       case p7T_C: scur = select_c(gm, pp, gx, i); break;       }\n+    if ( (scur == p7T_N || scur == p7T_J || scur == p7T_C) && scur == sprv) i--;\n+    sprv = scur;\n+  }\n+}"}, {"sha": "610e80792d302a25ccabc2a89b1cfc9901e1dadd", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e3f77e8c49516ee5f94c7b6af114dcd460e8df/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=71e3f77e8c49516ee5f94c7b6af114dcd460e8df", "patch": "@@ -2328,36 +2328,32 @@ bb_ends_with_multiway_branch (basic_block bb ATTRIBUTE_UNUSED)\n   return false;\n }\n \n-/* Verify that the REGION is a Single Entry Multiple Exits region: make sure no\n-   edge other than ENTRY is entering the REGION.  */\n+/* Verify that the REGION is a valid jump thread.  A jump thread is a special\n+   case of SEME Single Entry Multiple Exits region in which all nodes in the\n+   REGION have exactly one incoming edge.  The only exception is the first block\n+   that may not have been connected to the rest of the cfg yet.  */\n \n DEBUG_FUNCTION void\n-verify_seme (edge entry, basic_block *region, unsigned n_region)\n+verify_jump_thread (basic_block *region, unsigned n_region)\n {\n-  bitmap bbs = BITMAP_ALLOC (NULL);\n-\n   for (unsigned i = 0; i < n_region; i++)\n-    bitmap_set_bit (bbs, region[i]->index);\n+    gcc_assert (EDGE_COUNT (region[i]->preds) <= 1);\n+}\n \n-  for (unsigned i = 0; i < n_region; i++)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      basic_block bb = region[i];\n+/* Return true when BB is one of the first N items in BBS.  */\n \n-      /* All predecessors other than ENTRY->src should be in the region.  */\n-      for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); ei_next (&ei))\n-\tif (e != entry)\n-\t  gcc_assert (bitmap_bit_p (bbs, e->src->index));\n-    }\n+static inline bool\n+bb_in_bbs (basic_block bb, basic_block *bbs, int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    if (bb == bbs[i])\n+      return true;\n \n-  BITMAP_FREE (bbs);\n+  return false;\n }\n \n-/* Duplicates a Single Entry Multiple Exit REGION (set of N_REGION basic\n-   blocks).  The ENTRY edge is redirected to the duplicate of the region.  If\n-   REGION is not a Single Entry region, ignore any incoming edges other than\n-   ENTRY: this makes the copied region a Single Entry region.\n+/* Duplicates a jump-thread path of N_REGION basic blocks.\n+   The ENTRY edge is redirected to the duplicate of the region.\n \n    Remove the last conditional statement in the last basic block in the REGION,\n    and create a single fallthru edge pointing to the same destination as the\n@@ -2369,7 +2365,7 @@ verify_seme (edge entry, basic_block *region, unsigned n_region)\n    Returns false if it is unable to copy the region, true otherwise.  */\n \n static bool\n-duplicate_seme_region (edge entry, edge exit,\n+duplicate_thread_path (edge entry, edge exit,\n \t\t       basic_block *region, unsigned n_region,\n \t\t       basic_block *region_copy)\n {\n@@ -2428,7 +2424,53 @@ duplicate_seme_region (edge entry, edge exit,\n     }\n \n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n-\t    split_edge_bb_loc (entry), 0);\n+\t    split_edge_bb_loc (entry), false);\n+\n+  /* Fix up: copy_bbs redirects all edges pointing to copied blocks.  The\n+     following code ensures that all the edges exiting the jump-thread path are\n+     redirected back to the original code: these edges are exceptions\n+     invalidating the property that is propagated by executing all the blocks of\n+     the jump-thread path in order.  */\n+\n+  for (i = 0; i < n_region; i++)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      basic_block bb = region_copy[i];\n+\n+      if (single_succ_p (bb))\n+\t{\n+\t  /* Make sure the successor is the next node in the path.  */\n+\t  gcc_assert (i + 1 == n_region\n+\t\t      || region_copy[i + 1] == single_succ_edge (bb)->dest);\n+\t  continue;\n+\t}\n+\n+      /* Special case the last block on the path: make sure that it does not\n+\t jump back on the copied path.  */\n+      if (i + 1 == n_region)\n+\t{\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    if (bb_in_bbs (e->dest, region_copy, n_region - 1))\n+\t      {\n+\t\tbasic_block orig = get_bb_original (e->dest);\n+\t\tif (orig)\n+\t\t  redirect_edge_and_branch_force (e, orig);\n+\t      }\n+\t  continue;\n+\t}\n+\n+      /* Redirect all other edges jumping to non-adjacent blocks back to the\n+\t original code.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (region_copy[i + 1] != e->dest)\n+\t  {\n+\t    basic_block orig = get_bb_original (e->dest);\n+\t    if (orig)\n+\t      redirect_edge_and_branch_force (e, orig);\n+\t  }\n+    }\n+\n   if (total_count)\n     {\n       scale_bbs_frequencies_gcov_type (region, n_region,\n@@ -2445,8 +2487,7 @@ duplicate_seme_region (edge entry, edge exit,\n     }\n \n #ifdef ENABLE_CHECKING\n-  /* Make sure no edge other than ENTRY is entering the copied region.  */\n-  verify_seme (entry, region_copy, n_region);\n+  verify_jump_thread (region_copy, n_region);\n #endif\n \n   /* Remove the last branch in the jump thread path.  */\n@@ -2550,7 +2591,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n       for (unsigned int j = 0; j < len - 1; j++)\n \tregion[j] = (*path)[j]->e->dest;\n \n-      if (duplicate_seme_region (entry, exit, region, len - 1, NULL))\n+      if (duplicate_thread_path (entry, exit, region, len - 1, NULL))\n \t{\n \t  /* We do not update dominance info.  */\n \t  free_dominance_info (CDI_DOMINATORS);"}]}