{"sha": "92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJjMDY4ZDFkYzliMmJmNzdhOTE1NGU5Y2JhYWM5NzY4N2FlOTgxOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1998-12-13T13:29:08Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1998-12-13T13:29:08Z"}, "message": "jcf-reader.c (jcf_parse_one_method): Recognize HANDLE_END_METHOD.\n\n\t* jcf-reader.c (jcf_parse_one_method): Recognize\n\tHANDLE_END_METHOD.\n\t* gjavah.c (HANDLE_END_METHOD): New macro.\n\t(HANDLE_CODE_ATTRIBUTE): New macro.\n\t(decompile_method): New function.\n\t(print_method_info): Don't print `;\\n' at end of function decl.\n\tInclude java-opcodes.h.\n\t(decompiled): New global.\n\nFrom-SVN: r24295", "tree": {"sha": "3212e14f751decf2c01ee8441b474324dc8ae361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3212e14f751decf2c01ee8441b474324dc8ae361"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/comments", "author": null, "committer": null, "parents": [{"sha": "5d943c3cfb5cb1e6559ca609ead72a331e32db36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d943c3cfb5cb1e6559ca609ead72a331e32db36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d943c3cfb5cb1e6559ca609ead72a331e32db36"}], "stats": {"total": 62, "additions": 57, "deletions": 5}, "files": [{"sha": "adf8787c9b4fc38eedb2e8c802d952f4b5639c3b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "patch": "@@ -1,3 +1,14 @@\n+1998-12-13  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* jcf-reader.c (jcf_parse_one_method): Recognize\n+\tHANDLE_END_METHOD.\n+\t* gjavah.c (HANDLE_END_METHOD): New macro.\n+\t(HANDLE_CODE_ATTRIBUTE): New macro.\n+\t(decompile_method): New function.\n+\t(print_method_info): Don't print `;\\n' at end of function decl.\n+\tInclude java-opcodes.h.\n+\t(decompiled): New global.\n+\n Sat Dec 12 20:13:19 1998  Per Bothner  <bothner@cygnus.com>\n \n \t* class.c (build_class_ref):  Handle PRIMTYPE.class if"}, {"sha": "eec27b3dc34b7de7f4d021caa90fb730e4e63edf", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "patch": "@@ -33,6 +33,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n #include <string.h>\n \n+#include \"java-opcodes.h\"\n+\n /* The output file.  */\n FILE *out = NULL;\n \n@@ -99,6 +101,7 @@ static struct method_name *method_name_list;\n static void print_field_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n static void print_method_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n static void print_c_decl PROTO ((FILE*, JCF*, int, int, JCF_u2, int, char *));\n+static void decompile_method PROTO ((FILE *, JCF *, int));\n \n JCF_u2 current_field_name;\n JCF_u2 current_field_value;\n@@ -122,7 +125,16 @@ static int field_pass;\n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n #define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n-  if (out) print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS)\n+  if (out) { decompiled = 0; \\\n+      print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS); \\\n+  }\n+\n+#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n+  if (out) decompile_method (out, jcf, CODE_LENGTH);\n+\n+static int decompiled = 0;\n+#define HANDLE_END_METHOD() \\\n+  if (out) fputs (decompiled ? \"\\n\" : \";\\n\", out);\n \n #include \"jcf-reader.c\"\n \n@@ -439,11 +451,37 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n \tfputs (\"virtual \", out);\n     }\n   print_c_decl (out, jcf, name_index, sig_index, flags, is_init, override);\n+}\n \n-  /* FIXME: it would be nice to decompile small methods here.  That\n-     would allow for inlining.  */\n-\n-  fprintf(out, \";\\n\");\n+/* Try to decompile a method body.  Right now we just try to handle a\n+   simple case that we can do.  Expand as desired.  */\n+static void\n+decompile_method (out, jcf, code_len)\n+     FILE *out;\n+     JCF *jcf;\n+     int code_len;\n+{\n+  unsigned char *codes = jcf->read_ptr;\n+  int index;\n+  uint16 name_and_type, name;\n+\n+  if (code_len == 5\n+      && codes[0] == OPCODE_aload_0\n+      && codes[1] == OPCODE_getfield\n+      && codes[4] == OPCODE_areturn)\n+    {\n+      /* Found something useful to decompile.  */\n+      fputs (\" { return \", out);\n+      index = (codes[2] << 8) | codes[3];\n+      /* FIXME: ensure that tag is CONSTANT_Fieldref.  */\n+      /* FIXME: ensure that the field's class is this class.  */\n+      name_and_type = JPOOL_USHORT2 (jcf, index);\n+      /* FIXME: ensure that tag is CONSTANT_NameAndType.  */\n+      name = JPOOL_USHORT1 (jcf, name_and_type);\n+      print_name (out, jcf, name);\n+      fputs (\"; }\", out);\n+      decompiled = 1;\n+    }\n }\n \n /* Print one piece of a signature.  Returns pointer to next parseable"}, {"sha": "f3c860f6a9e41c6a61d5e66ea648fdce335f09bb", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92c068d1dc9b2bf77a9154e9cbaac97687ae9818/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=92c068d1dc9b2bf77a9154e9cbaac97687ae9818", "patch": "@@ -308,6 +308,9 @@ DEFUN(jcf_parse_one_method, (jcf),\n       if (code != 0)\n \treturn code;\n     }\n+#ifdef HANDLE_END_METHOD\n+  HANDLE_END_METHOD ();\n+#endif\n   return 0;\n }\n "}]}