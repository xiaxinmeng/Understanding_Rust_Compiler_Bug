{"sha": "579fda569ddfa62b27e417f1fe7c2c64c292d49c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5ZmRhNTY5ZGRmYTYyYjI3ZTQxN2YxZmU3YzJjNjRjMjkyZDQ5Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T10:32:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T10:32:07Z"}, "message": "[multiple changes]\n\n2011-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_strm.adb: Remove with and use clause for Opt.\n\t(Build_Array_Input_Function): Remove the version-dependent generation\n\tof the return statement. The Ada 2005 tree is now the default.\n\n2011-09-01  Yannick Moy  <moy@adacore.com>\n\n\t* put_alfa.adb: Unconditionnally write files in Alfa section, so that\n\tit is never empty when compiling in Alfa mode.\n\n2011-09-01  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aggr.adb, sem_ch3.adb, a-direct.adb, s-taprop-vxworks.adb,\n\tcomperr.adb, exp_ch9.adb, exp_pakd.adb, sem_ch12.adb, freeze.adb,\n\ts-taprop-mingw.adb, s-taprop-linux.adb, s-taprop-solaris.adb,\n\tgnat1drv.adb, a-rbtgbo.adb, exp_dist.adb: Minor reformatting\n\n2011-09-01  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Add a-csquin.ads, a-cusyqu.ad[sb],\n\ta-cuprqu.ad[sb], a-cbsyqu.ad[sb], a-cbprqu.ad[sb]\n\t* a-csquin.ads: New Ada 2012 unit that specifies the queue interface\n\t* a-cusyqu.ads, a-cusyqu.adb: New Ada 2012 unit that specifies the\n\tunbounded queue container.\n\t* a-cbsyqu.ads, a-cbsyqu.adb: New Ada 2012 unit that specifies the\n\tbounded queue container.\n\t* a-cuprqu.ads, a-cuprqu.adb: New Ada 2012 unit that specifies the\n\tunbounded priority queue container.\n\t* a-cbprqu.ads, a-cbprqu.adb: New Ada 2012 unit that specifies the\n\tbounded priority queue container.\n\nFrom-SVN: r178398", "tree": {"sha": "3bf386129cb6edc9bc9ad806556457084e89b051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bf386129cb6edc9bc9ad806556457084e89b051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579fda569ddfa62b27e417f1fe7c2c64c292d49c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579fda569ddfa62b27e417f1fe7c2c64c292d49c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579fda569ddfa62b27e417f1fe7c2c64c292d49c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579fda569ddfa62b27e417f1fe7c2c64c292d49c/comments", "author": null, "committer": null, "parents": [{"sha": "c49eacd5445f8a46b015995b9834f9c2b13b38c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49eacd5445f8a46b015995b9834f9c2b13b38c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49eacd5445f8a46b015995b9834f9c2b13b38c3"}], "stats": {"total": 1454, "additions": 1366, "deletions": 88}, "files": [{"sha": "4188b5597db8b1775d097946a2573cdc456a06a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -1,3 +1,35 @@\n+2011-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_strm.adb: Remove with and use clause for Opt.\n+\t(Build_Array_Input_Function): Remove the version-dependent generation\n+\tof the return statement. The Ada 2005 tree is now the default.\n+\n+2011-09-01  Yannick Moy  <moy@adacore.com>\n+\n+\t* put_alfa.adb: Unconditionnally write files in Alfa section, so that\n+\tit is never empty when compiling in Alfa mode.\n+\n+2011-09-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aggr.adb, sem_ch3.adb, a-direct.adb, s-taprop-vxworks.adb,\n+\tcomperr.adb, exp_ch9.adb, exp_pakd.adb, sem_ch12.adb, freeze.adb,\n+\ts-taprop-mingw.adb, s-taprop-linux.adb, s-taprop-solaris.adb,\n+\tgnat1drv.adb, a-rbtgbo.adb, exp_dist.adb: Minor reformatting\n+\n+2011-09-01  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Add a-csquin.ads, a-cusyqu.ad[sb],\n+\ta-cuprqu.ad[sb], a-cbsyqu.ad[sb], a-cbprqu.ad[sb]\n+\t* a-csquin.ads: New Ada 2012 unit that specifies the queue interface\n+\t* a-cusyqu.ads, a-cusyqu.adb: New Ada 2012 unit that specifies the\n+\tunbounded queue container.\n+\t* a-cbsyqu.ads, a-cbsyqu.adb: New Ada 2012 unit that specifies the\n+\tbounded queue container.\n+\t* a-cuprqu.ads, a-cuprqu.adb: New Ada 2012 unit that specifies the\n+\tunbounded priority queue container.\n+\t* a-cbprqu.ads, a-cbprqu.adb: New Ada 2012 unit that specifies the\n+\tbounded priority queue container.\n+\n 2011-08-31  Pascal Obry  <obry@adacore.com>\n \n \t* a-direct.adb: Do not try to create an UNC path on Windows."}, {"sha": "7707300d0be920b66ead50347a564857564a6209", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -94,6 +94,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cbdlli$(objext) \\\n   a-cbmutr$(objext) \\\n   a-cborma$(objext) \\\n+  a-cbprqu$(objext) \\\n+  a-cbsyqu$(objext) \\\n   a-cdlili$(objext) \\\n   a-cfdlli$(objext) \\\n   a-cfhama$(objext) \\\n@@ -144,6 +146,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-crdlli$(objext) \\\n   a-comutr$(objext) \\\n   a-cimutr$(objext) \\\n+  a-csquin$(objext) \\\n+  a-cuprqu$(objext) \\\n+  a-cusyqu$(objext) \\\n   a-cwila1$(objext) \\\n   a-cwila9$(objext) \\\n   a-decima$(objext) \\"}, {"sha": "99c9f0801af72427d7caded8b61c5ff89964aa91", "filename": "gcc/ada/a-cbprqu.adb", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbprqu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbprqu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbprqu.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,159 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.BOUNDED_PRIORITY_QUEUES                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Bounded_Priority_Queues is\n+\n+   package body Implementation is\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type)\n+      is\n+      begin\n+         Element := List.Container.First_Element;\n+         List.Container.Delete_First;\n+      end Dequeue;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type)\n+      is\n+         P : constant Queue_Priority := Get_Priority (New_Item);\n+\n+         C : List_Types.Cursor;\n+         use List_Types;\n+\n+         Count : Count_Type;\n+\n+      begin\n+         C := List.Container.First;\n+         while Has_Element (C) loop\n+            --  ???\n+            --  if Before (P, Get_Priority (List.Constant_Reference (C))) then\n+            if Before (P, Get_Priority (Element (C))) then\n+               List.Container.Insert (C, New_Item);\n+               exit;\n+            end if;\n+\n+            Next (C);\n+         end loop;\n+\n+         if not Has_Element (C) then\n+            List.Container.Append (New_Item);\n+         end if;\n+\n+         Count := List.Container.Length;\n+\n+         if Count > List.Max_Length then\n+            List.Max_Length := Count;\n+         end if;\n+      end Enqueue;\n+\n+      ------------\n+      -- Length --\n+      ------------\n+\n+      function Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Container.Length;\n+      end Length;\n+\n+      ----------------\n+      -- Max_Length --\n+      ----------------\n+\n+      function Max_Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Max_Length;\n+\n+   end Implementation;\n+\n+   protected body Queue is\n+\n+      ------------------\n+      --  Current_Use --\n+      ------------------\n+\n+      function Current_Use return Count_Type is\n+      begin\n+         return List.Length;\n+      end Current_Use;\n+\n+      --------------\n+      --  Dequeue --\n+      --------------\n+\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type)\n+        when List.Length > 0\n+      is\n+      begin\n+         List.Dequeue (Element);\n+      end Dequeue;\n+\n+      --  ???\n+      --  entry Dequeue_Only_High_Priority\n+      --    (Low_Priority : Queue_Priority;\n+      --     Element      : out Queue_Interfaces.Element_Type) when True\n+      --  is\n+      --  begin\n+      --     null;\n+      --  end Dequeue_Only_High_Priority;\n+\n+      --------------\n+      --  Enqueue --\n+      --------------\n+\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type)\n+        when List.Length < Capacity\n+      is\n+      begin\n+         List.Enqueue (New_Item);\n+      end Enqueue;\n+\n+      ---------------\n+      --  Peak_Use --\n+      ---------------\n+\n+      function Peak_Use return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Peak_Use;\n+\n+   end Queue;\n+\n+end Ada.Containers.Bounded_Priority_Queues;"}, {"sha": "1ee087a9ed2607d16a26f4566ffcab608bf741dd", "filename": "gcc/ada/a-cbprqu.ads", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbprqu.ads?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,118 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.BOUNDED_PRIORITY_QUEUES                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Ada.Containers.Synchronized_Queue_Interfaces;\n+with Ada.Containers.Bounded_Doubly_Linked_Lists;\n+\n+generic\n+   with package Queue_Interfaces is\n+     new Ada.Containers.Synchronized_Queue_Interfaces (<>);\n+\n+   type Queue_Priority is private;\n+\n+   with function Get_Priority\n+     (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>;\n+\n+   with function Before\n+     (Left, Right : Queue_Priority) return Boolean is <>;\n+\n+   Default_Capacity : Count_Type;\n+   Default_Ceiling  : System.Any_Priority := System.Priority'Last;\n+\n+package Ada.Containers.Bounded_Priority_Queues is\n+   pragma Preelaborate;\n+\n+   package Implementation is\n+\n+      type List_Type (Capacity : Count_Type) is tagged limited private;\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type);\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type);\n+\n+      function Length (List : List_Type) return Count_Type;\n+\n+      function Max_Length (List : List_Type) return Count_Type;\n+\n+   private\n+\n+      --  We need a better data structure here, such as a proper heap.  ???\n+\n+      package List_Types is new Bounded_Doubly_Linked_Lists\n+        (Element_Type => Queue_Interfaces.Element_Type,\n+         \"=\"          => Queue_Interfaces.\"=\");\n+\n+      type List_Type (Capacity : Count_Type) is tagged limited record\n+         Container  : List_Types.List (Capacity);\n+         Max_Length : Count_Type := 0;\n+      end record;\n+\n+   end Implementation;\n+\n+   protected type Queue\n+     (Capacity : Count_Type := Default_Capacity;\n+      Ceiling  : System.Any_Priority := Default_Ceiling)\n+   --  ???\n+   --  with Priority => Ceiling is new Queue_Interfaces.Queue with\n+   is new Queue_Interfaces.Queue with\n+\n+      overriding\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+\n+      overriding\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+\n+      --  ???\n+      --  not overriding\n+      --  entry Dequeue_Only_High_Priority\n+      --    (Low_Priority : Queue_Priority;\n+      --     Element      : out Queue_Interfaces.Element_Type);\n+\n+      overriding\n+      function Current_Use return Count_Type;\n+\n+      overriding\n+      function Peak_Use return Count_Type;\n+\n+   private\n+\n+      List : Implementation.List_Type (Capacity);\n+\n+   end Queue;\n+\n+end Ada.Containers.Bounded_Priority_Queues;"}, {"sha": "7f8400e4840ebfea9d5b1622592b1e244f9a40f4", "filename": "gcc/ada/a-cbsyqu.adb", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbsyqu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbsyqu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbsyqu.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,168 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.BOUNDED_SYNCHRONIZED_QUEUES                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Bounded_Synchronized_Queues is\n+\n+   package body Implementation is\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type)\n+      is\n+         EE : Element_Array renames List.Elements;\n+\n+      begin\n+         Element := EE (List.First);\n+         List.Length := List.Length - 1;\n+\n+         if List.Length = 0 then\n+            List.First := 0;\n+            List.Last := 0;\n+\n+         elsif List.First <= List.Last then\n+            List.First := List.First + 1;\n+\n+         else\n+            List.First := List.First + 1;\n+\n+            if List.First > List.Capacity then\n+               List.First := 1;\n+            end if;\n+         end if;\n+      end Dequeue;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type)\n+      is\n+      begin\n+         if List.Length >= List.Capacity then\n+            raise Capacity_Error with \"No capacity for insertion\";\n+         end if;\n+\n+         if List.Length = 0 then\n+            List.Elements (1) := New_Item;\n+            List.First := 1;\n+            List.Last := 1;\n+\n+         elsif List.First <= List.Last then\n+            if List.Last < List.Capacity then\n+               List.Elements (List.Last + 1) := New_Item;\n+               List.Last := List.Last + 1;\n+\n+            else\n+               List.Elements (1) := New_Item;\n+               List.Last := 1;\n+            end if;\n+\n+         else\n+            List.Elements (List.Last + 1) := New_Item;\n+            List.Last := List.Last + 1;\n+         end if;\n+\n+         List.Length := List.Length + 1;\n+\n+         if List.Length > List.Max_Length then\n+            List.Max_Length := List.Length;\n+         end if;\n+      end Enqueue;\n+\n+      ------------\n+      -- Length --\n+      ------------\n+\n+      function Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Length;\n+      end Length;\n+\n+      ----------------\n+      -- Max_Length --\n+      ----------------\n+\n+      function Max_Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Max_Length;\n+\n+   end Implementation;\n+\n+   protected body Queue is\n+\n+      -----------------\n+      -- Current_Use --\n+      -----------------\n+\n+      function Current_Use return Count_Type is\n+      begin\n+         return List.Length;\n+      end Current_Use;\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type)\n+        when List.Length > 0\n+      is\n+      begin\n+         List.Dequeue (Element);\n+      end Dequeue;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type)\n+        when List.Length < Capacity\n+      is\n+      begin\n+         List.Enqueue (New_Item);\n+      end Enqueue;\n+\n+      --------------\n+      -- Peak_Use --\n+      --------------\n+\n+      function Peak_Use return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Peak_Use;\n+\n+   end Queue;\n+\n+end Ada.Containers.Bounded_Synchronized_Queues;"}, {"sha": "ab4a31cb28d8dd11bf9bf11e0bd8acb473d83e53", "filename": "gcc/ada/a-cbsyqu.ads", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbsyqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cbsyqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbsyqu.ads?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.BOUNDED_SYNCHRONIZED_QUEUES                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Ada.Containers.Synchronized_Queue_Interfaces;\n+\n+generic\n+   with package Queue_Interfaces is\n+     new Ada.Containers.Synchronized_Queue_Interfaces (<>);\n+\n+   Default_Capacity : Count_Type;\n+   Default_Ceiling  : System.Any_Priority := System.Priority'Last;\n+\n+package Ada.Containers.Bounded_Synchronized_Queues is\n+   pragma Preelaborate;\n+\n+   package Implementation is\n+\n+      type List_Type (Capacity : Count_Type) is tagged limited private;\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type);\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type);\n+\n+      function Length (List : List_Type) return Count_Type;\n+\n+      function Max_Length (List : List_Type) return Count_Type;\n+\n+   private\n+\n+      --  Need proper heap data structure here ???\n+\n+      type Element_Array is\n+        array (Count_Type range <>) of Queue_Interfaces.Element_Type;\n+\n+      type List_Type (Capacity : Count_Type) is tagged limited record\n+         First, Last : Count_Type := 0;\n+         Length      : Count_Type := 0;\n+         Max_Length  : Count_Type := 0;\n+         Elements    : Element_Array (1 .. Capacity) := (others => <>);\n+      end record;\n+\n+   end Implementation;\n+\n+   protected type Queue\n+     (Capacity : Count_Type := Default_Capacity;\n+      Ceiling  : System.Any_Priority := Default_Ceiling)\n+   --  ???\n+   --  with Priority => Ceiling is new Queue_Interfaces.Queue with\n+   is new Queue_Interfaces.Queue with\n+\n+      overriding\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+\n+      overriding\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+\n+      overriding\n+      function Current_Use return Count_Type;\n+\n+      overriding\n+      function Peak_Use return Count_Type;\n+\n+   private\n+\n+      List : Implementation.List_Type (Capacity);\n+\n+   end Queue;\n+\n+end Ada.Containers.Bounded_Synchronized_Queues;"}, {"sha": "4a544d43188ba01e788968adbd0a586ea2899c40", "filename": "gcc/ada/a-csquin.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-csquin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-csquin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-csquin.ads?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,56 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.SYNCHRONIZED_QUEUE_INTERFACES               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Element_Type is private;\n+\n+package Ada.Containers.Synchronized_Queue_Interfaces is\n+   pragma Pure;\n+\n+   type Queue is synchronized interface;\n+\n+   procedure Enqueue\n+     (Container : in out Queue;\n+      New_Item  : Element_Type) is abstract;\n+   --  with Is_Synchronized => By_Entry;  ???\n+\n+   procedure Dequeue\n+     (Container : in out Queue;\n+      Element   : out Element_Type) is abstract;\n+   --  with Is_Synchronized => By_Entry;  ???\n+\n+   function Current_Use (Container : Queue) return Count_Type is abstract;\n+\n+   function Peak_Use (Container : Queue) return Count_Type is abstract;\n+\n+end Ada.Containers.Synchronized_Queue_Interfaces;"}, {"sha": "f83ca4290126ba4d9a34479345fbffe2318d5149", "filename": "gcc/ada/a-cuprqu.adb", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cuprqu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cuprqu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,223 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.UNBOUNDED_PRIORITY_QUEUES                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Containers.Unbounded_Priority_Queues is\n+\n+   package body Implementation is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      procedure Free is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type)\n+      is\n+         X : Node_Access;\n+\n+      begin\n+         Element := List.First.Element;\n+\n+         X := List.First;\n+         List.First := List.First.Next;\n+\n+         if List.First = null then\n+            List.Last := null;\n+         end if;\n+\n+         List.Length := List.Length - 1;\n+\n+         Free (X);\n+      end Dequeue;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type)\n+      is\n+         P : constant Queue_Priority := Get_Priority (New_Item);\n+\n+         Node : Node_Access;\n+         Prev : Node_Access;\n+\n+      begin\n+         Node := new Node_Type'(New_Item, null);\n+\n+         if List.First = null then\n+            List.First := Node;\n+            List.Last := List.First;\n+\n+         else\n+            Prev := List.First;\n+\n+            if Before (P, Get_Priority (Prev.Element)) then\n+               Node.Next := List.First;\n+               List.First := Node;\n+\n+            else\n+               while Prev.Next /= null loop\n+                  if Before (P, Get_Priority (Prev.Next.Element)) then\n+                     Node.Next := Prev.Next;\n+                     Prev.Next := Node;\n+\n+                     exit;\n+                  end if;\n+\n+                  Prev := Prev.Next;\n+               end loop;\n+\n+               if Prev.Next = null then\n+                  List.Last.Next := Node;\n+                  List.Last := Node;\n+               end if;\n+            end if;\n+         end if;\n+\n+         List.Length := List.Length + 1;\n+\n+         if List.Length > List.Max_Length then\n+            List.Max_Length := List.Length;\n+         end if;\n+      end Enqueue;\n+\n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (List : in out List_Type) is\n+         X : Node_Access;\n+\n+      begin\n+         while List.First /= null loop\n+            X := List.First;\n+            List.First := List.First.Next;\n+            Free (X);\n+         end loop;\n+      end Finalize;\n+\n+      ------------------------\n+      -- Have_High_Priority --\n+      ------------------------\n+\n+      --  ???\n+      --  function Have_High_Priority\n+      --    (List         : List_Type;\n+      --     Low_Priority : Queue_Priority) return Boolean\n+      --  is\n+      --  begin\n+      --     if List.Length = 0 then\n+      --        return False;\n+      --     end if;\n+      --     return Before (Get_Priority (List.First.Element), Low_Priority);\n+      --  end Have_High_Priority;\n+\n+      ------------\n+      -- Length --\n+      ------------\n+\n+      function Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Length;\n+      end Length;\n+\n+      ----------------\n+      -- Max_Length --\n+      ----------------\n+\n+      function Max_Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Max_Length;\n+\n+   end Implementation;\n+\n+   protected body Queue is\n+\n+      -----------------\n+      -- Current_Use --\n+      -----------------\n+\n+      function Current_Use return Count_Type is\n+      begin\n+         return List.Length;\n+      end Current_Use;\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type)\n+        when List.Length > 0\n+      is\n+      begin\n+         List.Dequeue (Element);\n+      end Dequeue;\n+\n+      --  ???\n+      --  entry Dequeue_Only_High_Priority\n+      --    (Low_Priority : Queue_Priority;\n+      --     Element      : out Queue_Interfaces.Element_Type) when True\n+      --  is\n+      --  begin\n+      --     null;\n+      --  end Dequeue_Only_High_Priority;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type) when True is\n+      begin\n+         List.Enqueue (New_Item);\n+      end Enqueue;\n+\n+      --------------\n+      -- Peak_Use --\n+      --------------\n+\n+      function Peak_Use return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Peak_Use;\n+\n+   end Queue;\n+\n+end Ada.Containers.Unbounded_Priority_Queues;"}, {"sha": "c06faf33cabf89d742171ea7ec948367c2622cea", "filename": "gcc/ada/a-cuprqu.ads", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cuprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cuprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.ads?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,127 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.UNBOUNDED_PRIORITY_QUEUES                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Ada.Containers.Synchronized_Queue_Interfaces;\n+with Ada.Finalization;\n+\n+generic\n+   with package Queue_Interfaces is\n+     new Ada.Containers.Synchronized_Queue_Interfaces (<>);\n+\n+   type Queue_Priority is private;\n+\n+   with function Get_Priority\n+     (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>;\n+\n+   with function Before\n+     (Left, Right : Queue_Priority) return Boolean is <>;\n+\n+   Default_Ceiling : System.Any_Priority := System.Priority'Last;\n+\n+package Ada.Containers.Unbounded_Priority_Queues is\n+   pragma Preelaborate;\n+\n+   package Implementation is\n+\n+      type List_Type is tagged limited private;\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type);\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type);\n+\n+      function Length (List : List_Type) return Count_Type;\n+\n+      function Max_Length (List : List_Type) return Count_Type;\n+\n+   private\n+\n+      type Node_Type;\n+      type Node_Access is access Node_Type;\n+\n+      type Node_Type is limited record\n+         Element : Queue_Interfaces.Element_Type;\n+         Next    : Node_Access;\n+      end record;\n+\n+      type List_Type is new Ada.Finalization.Limited_Controlled with record\n+         First, Last : Node_Access;\n+         Length      : Count_Type := 0;\n+         Max_Length  : Count_Type := 0;\n+      end record;\n+\n+      overriding\n+      procedure Finalize (List : in out List_Type);\n+\n+      --  ???\n+      --  not overriding\n+      --  function Have_High_Priority\n+      --    (List         : List_Type;\n+      --     Low_Priority : Queue_Priority) return Boolean;\n+\n+   end Implementation;\n+\n+   protected type Queue (Ceiling : System.Any_Priority := Default_Ceiling)\n+     --  ???\n+     --  with Priority => Ceiling is new Queue_Interfaces.Queue with\n+     is new Queue_Interfaces.Queue with\n+\n+     overriding\n+     entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+\n+     overriding\n+     entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+\n+     --  ???\n+     --  not overriding\n+     --  entry Dequeue_Only_High_Priority\n+     --    (Low_Priority : Queue_Priority;\n+     --     Element      : out Queue_Interfaces.Element_Type);\n+\n+     overriding\n+     function Current_Use return Count_Type;\n+\n+     overriding\n+     function Peak_Use return Count_Type;\n+\n+   private\n+\n+      List : Implementation.List_Type;\n+\n+   end Queue;\n+\n+end Ada.Containers.Unbounded_Priority_Queues;"}, {"sha": "6a8e0d8506eb1008441ac496221343a248f8d913", "filename": "gcc/ada/a-cusyqu.adb", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cusyqu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cusyqu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cusyqu.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,174 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.UNBOUNDED_SYNCHRONIZED_QUEUES               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Containers.Unbounded_Synchronized_Queues is\n+\n+   package body Implementation is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      procedure Free is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type)\n+      is\n+         X : Node_Access;\n+\n+      begin\n+         Element := List.First.Element;\n+\n+         X := List.First;\n+         List.First := List.First.Next;\n+\n+         if List.First = null then\n+            List.Last := null;\n+         end if;\n+\n+         List.Length := List.Length - 1;\n+\n+         Free (X);\n+      end Dequeue;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type)\n+      is\n+         Node : Node_Access;\n+\n+      begin\n+         Node := new Node_Type'(New_Item, null);\n+\n+         if List.First = null then\n+            List.First := Node;\n+            List.Last := List.First;\n+\n+         else\n+            List.Last.Next := Node;\n+            List.Last := Node;\n+         end if;\n+\n+         List.Length := List.Length + 1;\n+\n+         if List.Length > List.Max_Length then\n+            List.Max_Length := List.Length;\n+         end if;\n+      end Enqueue;\n+\n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (List : in out List_Type) is\n+         X : Node_Access;\n+\n+      begin\n+         while List.First /= null loop\n+            X := List.First;\n+            List.First := List.First.Next;\n+            Free (X);\n+         end loop;\n+      end Finalize;\n+\n+      ------------\n+      -- Length --\n+      ------------\n+\n+      function Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Length;\n+      end Length;\n+\n+      ----------------\n+      -- Max_Length --\n+      ----------------\n+\n+      function Max_Length (List : List_Type) return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Max_Length;\n+\n+   end Implementation;\n+\n+   protected body Queue is\n+\n+      -----------------\n+      -- Current_Use --\n+      -----------------\n+\n+      function Current_Use return Count_Type is\n+      begin\n+         return List.Length;\n+      end Current_Use;\n+\n+      -------------\n+      -- Dequeue --\n+      -------------\n+\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type)\n+        when List.Length > 0\n+      is\n+      begin\n+         List.Dequeue (Element);\n+      end Dequeue;\n+\n+      -------------\n+      -- Enqueue --\n+      -------------\n+\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type) when True is\n+      begin\n+         List.Enqueue (New_Item);\n+      end Enqueue;\n+\n+      --------------\n+      -- Peak_Use --\n+      --------------\n+\n+      function Peak_Use return Count_Type is\n+      begin\n+         return List.Max_Length;\n+      end Peak_Use;\n+\n+   end Queue;\n+\n+end Ada.Containers.Unbounded_Synchronized_Queues;"}, {"sha": "a8a2dda160cbf9cf536d9d7cfbf7eba5f03981ae", "filename": "gcc/ada/a-cusyqu.ads", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cusyqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-cusyqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cusyqu.ads?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -0,0 +1,107 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.UNBOUNDED_SYNCHRONIZED_QUEUES               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with Ada.Containers.Synchronized_Queue_Interfaces;\n+with Ada.Finalization;\n+\n+generic\n+   with package Queue_Interfaces is\n+     new Ada.Containers.Synchronized_Queue_Interfaces (<>);\n+\n+   Default_Ceiling : System.Any_Priority := System.Priority'Last;\n+\n+package Ada.Containers.Unbounded_Synchronized_Queues is\n+   pragma Preelaborate;\n+\n+   package Implementation is\n+\n+      type List_Type is tagged limited private;\n+\n+      procedure Enqueue\n+        (List     : in out List_Type;\n+         New_Item : Queue_Interfaces.Element_Type);\n+\n+      procedure Dequeue\n+        (List    : in out List_Type;\n+         Element : out Queue_Interfaces.Element_Type);\n+\n+      function Length (List : List_Type) return Count_Type;\n+\n+      function Max_Length (List : List_Type) return Count_Type;\n+\n+   private\n+\n+      type Node_Type;\n+      type Node_Access is access Node_Type;\n+\n+      type Node_Type is limited record\n+         Element : Queue_Interfaces.Element_Type;\n+         Next    : Node_Access;\n+      end record;\n+\n+      type List_Type is new Ada.Finalization.Limited_Controlled with record\n+         First, Last : Node_Access;\n+         Length      : Count_Type := 0;\n+         Max_Length  : Count_Type := 0;\n+      end record;\n+\n+      overriding\n+      procedure Finalize (List : in out List_Type);\n+\n+   end Implementation;\n+\n+   protected type Queue (Ceiling : System.Any_Priority := Default_Ceiling)\n+     --  ???\n+     --  with Priority => Ceiling is new Queue_Interfaces.Queue with\n+     is new Queue_Interfaces.Queue with\n+\n+      overriding\n+      entry Enqueue (New_Item : Queue_Interfaces.Element_Type);\n+\n+      overriding\n+      entry Dequeue (Element : out Queue_Interfaces.Element_Type);\n+\n+      overriding\n+      function Current_Use return Count_Type;\n+\n+      overriding\n+      function Peak_Use return Count_Type;\n+\n+   private\n+\n+      List : Implementation.List_Type;\n+\n+   end Queue;\n+\n+end Ada.Containers.Unbounded_Synchronized_Queues;"}, {"sha": "e27bb3fdd6d8c3c7a9a9c772109242630170b60b", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -32,7 +32,7 @@\n with Ada.Calendar;               use Ada.Calendar;\n with Ada.Calendar.Formatting;    use Ada.Calendar.Formatting;\n with Ada.Directories.Validity;   use Ada.Directories.Validity;\n-with Ada.Strings.Maps;           use Ada; use Ada.Strings.Maps;\n+with Ada.Strings.Maps;           use Ada.Strings.Maps;\n with Ada.Strings.Fixed;\n with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n with Ada.Unchecked_Conversion;\n@@ -451,14 +451,15 @@ package body Ada.Directories is\n          New_Dir (1 .. New_Directory'Length) := New_Directory;\n          New_Dir (New_Dir'Last) := Directory_Separator;\n \n+         --  If host is windows, and the first two characters are directory\n+         --  separators, we have an UNC path. Skip it.\n+\n          if Directory_Separator = '\\'\n            and then New_Dir'Length > 2\n            and then Is_In (New_Dir (1), Dir_Seps)\n            and then Is_In (New_Dir (2), Dir_Seps)\n          then\n             Start := 2;\n-            --  If the first two characters are directory separators and host\n-            --  is windows, we have an UNC path. Skip it.\n             loop\n                Start := Start + 1;\n                exit when Start = New_Dir'Last"}, {"sha": "d66571396c7396bc6976dd347ccbc0adf0c9d9fe", "filename": "gcc/ada/a-rbtgbo.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-rbtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fa-rbtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbo.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -63,6 +63,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations is\n       --  that the busy status (which monitors \"cursor tampering\") is set too;\n       --  this is a representation invariant. Thus if the busy bit is not set,\n       --  then the lock bit must not be set either.\n+\n       pragma Assert (Tree.Lock = 0);\n \n       Tree.First  := 0;"}, {"sha": "d21b3ecb34f07d20f5df45b0b5db87e036fb301b", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -23,30 +23,30 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains routines called when a fatal internal compiler\n---  error is detected. Calls to these routines cause termination of the\n---  current compilation with appropriate error output.\n-\n-with Atree;         use Atree;\n-with Debug;         use Debug;\n-with Errout;        use Errout;\n-with Gnatvsn;       use Gnatvsn;\n-with Lib;           use Lib;\n-with Namet;         use Namet;\n-with Opt;           use Opt;\n-with Osint;         use Osint;\n-with Output;        use Output;\n-with Sinfo;         use Sinfo;\n-with Sinput;        use Sinput;\n-with Sprint;        use Sprint;\n-with Sdefault;      use Sdefault;\n-with System.OS_Lib; use System.OS_Lib;\n-with Targparm;      use Targparm;\n-with Treepr;        use Treepr;\n-with Types;         use Types;\n+--  This package contains routines called when a fatal internal compiler error\n+--  is detected. Calls to these routines cause termination of the current\n+--  compilation with appropriate error output.\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Errout;   use Errout;\n+with Gnatvsn;  use Gnatvsn;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Osint;    use Osint;\n+with Output;   use Output;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Sprint;   use Sprint;\n+with Sdefault; use Sdefault;\n+with Targparm; use Targparm;\n+with Treepr;   use Treepr;\n+with Types;    use Types;\n \n with Ada.Exceptions; use Ada.Exceptions;\n \n+with System.OS_Lib;     use System.OS_Lib;\n with System.Soft_Links; use System.Soft_Links;\n \n package body Comperr is\n@@ -147,6 +147,8 @@ package body Comperr is\n          end if;\n       end if;\n \n+      --  If we are in CodePeer mode, we must also delete SCIL files\n+\n       if CodePeer_Mode then\n          Delete_SCIL_Files;\n       end if;\n@@ -439,6 +441,7 @@ package body Comperr is\n       Main    : Node_Id;\n       Success : Boolean;\n       pragma Unreferenced (Success);\n+\n    begin\n       --  If parsing was not successful, no Main_Unit is available, so return\n       --  immediately.\n@@ -458,7 +461,8 @@ package body Comperr is\n          Get_Name_String (Chars (Defining_Unit_Name (Main)));\n       end if;\n \n-      Delete_File (\"SCIL/\" & Name_Buffer (1 .. Name_Len) & \".scil\", Success);\n+      Delete_File\n+        (\"SCIL/\" & Name_Buffer (1 .. Name_Len) & \".scil\", Success);\n       Delete_File\n         (\"SCIL/\" & Name_Buffer (1 .. Name_Len) & \"__body.scil\", Success);\n    end Delete_SCIL_Files;"}, {"sha": "3d0652232cbe14d2f24fba89c98c5567b51055d4", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -10851,7 +10851,7 @@ package body Exp_Ch9 is\n       then\n          Append_To (Cdecls,\n            Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n+             Defining_Identifier  =>\n                Make_Defining_Identifier (Loc, Name_uDispatching_Domain),\n \n              Component_Definition =>\n@@ -10861,13 +10861,14 @@ package body Exp_Ch9 is\n                    New_Reference_To\n                      (RTE (RE_Dispatching_Domain_Access), Loc)),\n \n-             Expression =>\n+             Expression           =>\n                Unchecked_Convert_To (RTE (RE_Dispatching_Domain_Access),\n-                 Relocate_Node (\n-                   Expression (First (\n-                     Pragma_Argument_Associations (\n-                       Find_Task_Or_Protected_Pragma\n-                         (Taskdef, Name_Dispatching_Domain))))))));\n+                 Relocate_Node\n+                   (Expression\n+                      (First\n+                         (Pragma_Argument_Associations\n+                            (Find_Task_Or_Protected_Pragma\n+                               (Taskdef, Name_Dispatching_Domain))))))));\n       end if;\n \n       Insert_After (Size_Decl, Rec_Decl);"}, {"sha": "4717d74afac5e0e18b096f63f836d45b0fc60004", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -10846,7 +10846,8 @@ package body Exp_Dist is\n             --  always force transmission as a 64-bit value.\n \n             if Is_RTE (FST, RE_Stream_Element_Offset)\n-                 or else Is_RTE (FST, RE_Storage_Offset)\n+                 or else\n+               Is_RTE (FST, RE_Storage_Offset)\n             then\n                return RTE (RE_Unsigned_64);\n             end if;"}, {"sha": "8a95ec5c8768fef75e0669fd50a093d73b1a52d6", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -703,19 +703,18 @@ package body Exp_Pakd is\n       --  array reference, reanalysis can produce spurious type errors when the\n       --  PAT type is replaced again with the original type of the array. Same\n       --  for the case of a dereference. Ditto for function calls: expansion\n-      --  may introduce additional actuals which will trigger errors if call\n-      --  is reanalyzed. The following is correct and minimal,\n-      --  but the handling of more complex packed expressions in actuals is\n-      --  confused. Probably the problem only remains for actuals in calls.\n+      --  may introduce additional actuals which will trigger errors if call is\n+      --  reanalyzed. The following is correct and minimal, but the handling of\n+      --  more complex packed expressions in actuals is confused. Probably the\n+      --  problem only remains for actuals in calls.\n \n       Set_Etype (Aexp, Packed_Array_Type (Act_ST));\n \n       if Is_Entity_Name (Aexp)\n         or else\n            (Nkind (Aexp) = N_Indexed_Component\n              and then Is_Entity_Name (Prefix (Aexp)))\n-        or else Nkind (Aexp) = N_Explicit_Dereference\n-        or else Nkind (Aexp) = N_Function_Call\n+        or else Nkind_In (Aexp, N_Explicit_Dereference, N_Function_Call)\n       then\n          Set_Analyzed (Aexp);\n       end if;"}, {"sha": "d7aba2447a7d6a953f550cbb47cb779c14091d41", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -29,7 +29,6 @@ with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n-with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Util; use Sem_Util;\n@@ -222,23 +221,11 @@ package body Exp_Strm is\n             Make_Identifier (Loc, Name_S),\n             Make_Identifier (Loc, Name_V)));\n \n-      if Ada_Version >= Ada_2005 then\n-         Stms := New_List (\n-            Make_Extended_Return_Statement (Loc,\n-              Return_Object_Declarations => New_List (Odecl),\n-              Handled_Statement_Sequence =>\n-                Make_Handled_Sequence_Of_Statements (Loc, New_List (Rstmt))));\n-      else\n-         --  pragma Assert (not Is_Limited_Type (Typ));\n-         --  Returning a local object, shouldn't happen in the case of a\n-         --  limited type, but currently occurs in DSA stubs in Ada 95 mode???\n-\n-         Stms := New_List (\n-                   Odecl,\n-                   Rstmt,\n-                   Make_Simple_Return_Statement (Loc,\n-                     Expression => Make_Identifier (Loc, Name_V)));\n-      end if;\n+      Stms := New_List (\n+         Make_Extended_Return_Statement (Loc,\n+           Return_Object_Declarations => New_List (Odecl),\n+           Handled_Statement_Sequence =>\n+             Make_Handled_Sequence_Of_Statements (Loc, New_List (Rstmt))));\n \n       Fnam :=\n         Make_Defining_Identifier (Loc,"}, {"sha": "a64c0d782a03d9238db2b022d63e2c2ee9ae034b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -1839,6 +1839,7 @@ package body Freeze is\n                   --  since the component type has to be frozen for us to know\n                   --  if it is variable length. We omit this test in a generic\n                   --  context, it will be applied at instantiation time.\n+\n                   --  We also omit this test in CodePeer mode, since we do not\n                   --  have sufficient info on size and representation clauses.\n "}, {"sha": "b0b90242209f7b01a116bde0c0b47b690cdb851f", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -842,6 +842,8 @@ begin\n             Tree_Gen;\n          end if;\n \n+         --  In CodePeer mode we delete SCIL files if there is an error\n+\n          if CodePeer_Mode then\n             Comperr.Delete_SCIL_Files;\n          end if;"}, {"sha": "c3d250032fe16dc5125e8bbaf7f946ad83c5479e", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -519,6 +519,11 @@ package body Impunit is\n      \"a-comutr\",    -- Ada.Containers.Multiway_Trees\n      \"a-cimutr\",    -- Ada.Containers.Indefinite_Multiway_Trees\n      \"a-cbmutr\",    -- Ada.Containers.Bounded_Multiway_Trees\n+     \"a-csquin\",    -- Ada.Containers.Synchronized_Queue_Interfaces\n+     \"a-cusyqu\",    -- Ada.Containers.Unbounded_Synchronized_Queues\n+     \"a-cuprqu\",    -- Ada.Containers.Unbounded_Priority_Queues\n+     \"a-cbsyqu\",    -- Ada.Containers.Bounded_Synchronized_Queues\n+     \"a-cbprqu\",    -- Ada.Containers.Bounded_Priority_Queues\n      \"a-extiin\",    -- Ada.Execution_Time.Interrupts\n      \"a-iteint\",    -- Ada.Iterator_Interfaces\n      \"a-synbar\",    -- Ada.Synchronous_Barriers"}, {"sha": "adb41a8397f85b3bffda989e7b005d3d823e90a9", "filename": "gcc/ada/put_alfa.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fput_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fput_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_alfa.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -39,19 +39,17 @@ begin\n          Start := F.From_Scope;\n          Stop  := F.To_Scope;\n \n-         if Start <= Stop then\n-            Write_Info_Initiate ('F');\n-            Write_Info_Char ('D');\n-            Write_Info_Char (' ');\n-            Write_Info_Nat (F.File_Num);\n-            Write_Info_Char (' ');\n-\n-            for N in F.File_Name'Range loop\n-               Write_Info_Char (F.File_Name (N));\n-            end loop;\n-\n-            Write_Info_Terminate;\n-         end if;\n+         Write_Info_Initiate ('F');\n+         Write_Info_Char ('D');\n+         Write_Info_Char (' ');\n+         Write_Info_Nat (F.File_Num);\n+         Write_Info_Char (' ');\n+\n+         for N in F.File_Name'Range loop\n+            Write_Info_Char (F.File_Name (N));\n+         end loop;\n+\n+         Write_Info_Terminate;\n \n          --  Loop through scope entries for this file\n "}, {"sha": "a8f1568ee78fa7da22ff570638e187e6ae370e13", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -822,10 +822,11 @@ package body System.Task_Primitives.Operations is\n       --  task, and the CPU value is not contained within the range of\n       --  processors for the domain.\n \n-      if T.Common.Domain /= null and then\n-        T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU and then\n-        (T.Common.Base_CPU not in T.Common.Domain'Range\n-         or else not T.Common.Domain (T.Common.Base_CPU))\n+      if T.Common.Domain /= null\n+        and then T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU\n+        and then\n+          (T.Common.Base_CPU not in T.Common.Domain'Range\n+            or else not T.Common.Domain (T.Common.Base_CPU))\n       then\n          Succeeded := False;\n          return;"}, {"sha": "ab66a889741ea213d05550fff79c00ddc6cea46d", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -902,10 +902,11 @@ package body System.Task_Primitives.Operations is\n       --  task, and the CPU value is not contained within the range of\n       --  processors for the domain.\n \n-      if T.Common.Domain /= null and then\n-        T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU and then\n-        (T.Common.Base_CPU not in T.Common.Domain'Range\n-         or else not T.Common.Domain (T.Common.Base_CPU))\n+      if T.Common.Domain /= null\n+        and then T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU\n+        and then\n+          (T.Common.Base_CPU not in T.Common.Domain'Range\n+            or else not T.Common.Domain (T.Common.Base_CPU))\n       then\n          Succeeded := False;\n          return;"}, {"sha": "421c60e219e1abc44882df4003dee1f2948f314e", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -981,10 +981,11 @@ package body System.Task_Primitives.Operations is\n       --  task, and the CPU value is not contained within the range of\n       --  processors for the domain.\n \n-      if T.Common.Domain /= null and then\n-        T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU and then\n-        (T.Common.Base_CPU not in T.Common.Domain'Range\n-         or else not T.Common.Domain (T.Common.Base_CPU))\n+      if T.Common.Domain /= null\n+        and then T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU\n+        and then\n+          (T.Common.Base_CPU not in T.Common.Domain'Range\n+            or else not T.Common.Domain (T.Common.Base_CPU))\n       then\n          Succeeded := False;\n          return;"}, {"sha": "ae286498d5c5703976b6b9a6e305a65270472304", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -897,10 +897,11 @@ package body System.Task_Primitives.Operations is\n       --  task, and the CPU value is not contained within the range of\n       --  processors for the domain.\n \n-      if T.Common.Domain /= null and then\n-        T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU and then\n-        (T.Common.Base_CPU not in T.Common.Domain'Range\n-         or else not T.Common.Domain (T.Common.Base_CPU))\n+      if T.Common.Domain /= null\n+        and then T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU\n+        and then\n+          (T.Common.Base_CPU not in T.Common.Domain'Range\n+            or else not T.Common.Domain (T.Common.Base_CPU))\n       then\n          Succeeded := False;\n          return;"}, {"sha": "d4ea223c7b872b2dfd600312e95736f1c0fc58eb", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -1052,6 +1052,7 @@ package body Sem_Aggr is\n       end if;\n \n       --  Ada 2005 (AI-287): Limited aggregates allowed\n+\n       --  In an instance, ignore aggregate subcomponents tnat may be limited,\n       --  because they originate in view conflicts. If the original aggregate\n       --  is legal and the actuals are legal, the aggregate itself is legal."}, {"sha": "5ab7783b277163fb6a5ca755d1b3b5c4db966193", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -12745,7 +12745,6 @@ package body Sem_Ch12 is\n          if Has_Aspects (N) then\n             declare\n                Aspect : Node_Id;\n-\n             begin\n                Aspect := First (Aspect_Specifications (N));\n                while Present (Aspect) loop"}, {"sha": "3dded45cd121a38370a838104d535a50abd6f131", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579fda569ddfa62b27e417f1fe7c2c64c292d49c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=579fda569ddfa62b27e417f1fe7c2c64c292d49c", "patch": "@@ -2869,7 +2869,7 @@ package body Sem_Ch3 is\n       --   2. Those generated by the Expression\n \n       --   3. Those used to constrain the Object Definition with the\n-      --       expression constraints when the definition is unconstrained\n+      --      expression constraints when the definition is unconstrained.\n \n       --  They must be generated in this order to avoid order of elaboration\n       --  issues. Thus the first step (after entering the name) is to analyze\n@@ -2880,6 +2880,7 @@ package body Sem_Ch3 is\n \n          if Present (Prev_Entity)\n            and then\n+\n              --  If the homograph is an implicit subprogram, it is overridden\n              --  by the current declaration.\n "}]}