{"sha": "e8426e0a22212f9b355364186c9d1748a38b0549", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0MjZlMGEyMjIxMmY5YjM1NTM2NDE4NmM5ZDE3NDhhMzhiMDU0OQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-12-04T03:26:19Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-12-04T03:26:19Z"}, "message": "aarch64.c (aarch64_legitimize_address): legitimize address expressions like Ra + Rb + CONST and Ra + Rb<<SCALE + CONST.\n\n\n\t* config/aarch64/aarch64.c (aarch64_legitimize_address): legitimize\n\taddress expressions like Ra + Rb + CONST and Ra + Rb<<SCALE + CONST.\n\n\nCo-Authored-By: Jiong Wang <jiong.wang@arm.com>\n\nFrom-SVN: r231244", "tree": {"sha": "db11a2a168f632b1beed0eba339c7cb492f9b486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db11a2a168f632b1beed0eba339c7cb492f9b486"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8426e0a22212f9b355364186c9d1748a38b0549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8426e0a22212f9b355364186c9d1748a38b0549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8426e0a22212f9b355364186c9d1748a38b0549", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8426e0a22212f9b355364186c9d1748a38b0549/comments", "author": null, "committer": null, "parents": [{"sha": "72cc0e580391b320b96f9fbdaf1c26f905a4058f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72cc0e580391b320b96f9fbdaf1c26f905a4058f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72cc0e580391b320b96f9fbdaf1c26f905a4058f"}], "stats": {"total": 70, "additions": 69, "deletions": 1}, "files": [{"sha": "977f7aed906a56f6abc412069d214b0d2b03237c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8426e0a22212f9b355364186c9d1748a38b0549/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8426e0a22212f9b355364186c9d1748a38b0549/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8426e0a22212f9b355364186c9d1748a38b0549", "patch": "@@ -1,3 +1,9 @@\n+2015-12-04  Bin Cheng  <bin.cheng@arm.com>\n+\t    Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_legitimize_address): legitimize\n+\taddress expressions like Ra + Rb + CONST and Ra + Rb<<SCALE + CONST.\n+\n 2015-12-03  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* alias.c (alias_set_subset_of, alias_sets_must_conflict_p)"}, {"sha": "191ad6debb832d84c807bdcbdd9d0def8b98a1bd", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8426e0a22212f9b355364186c9d1748a38b0549/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8426e0a22212f9b355364186c9d1748a38b0549/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e8426e0a22212f9b355364186c9d1748a38b0549", "patch": "@@ -4823,13 +4823,75 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n      We try to pick as large a range for the offset as possible to\n      maximize the chance of a CSE.  However, for aligned addresses\n      we limit the range to 4k so that structures with different sized\n-     elements are likely to use the same base.  */\n+     elements are likely to use the same base.  We need to be careful\n+     not to split a CONST for some forms of address expression, otherwise\n+     it will generate sub-optimal code.  */\n \n   if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n     {\n       HOST_WIDE_INT offset = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT base_offset;\n \n+      if (GET_CODE (XEXP (x, 0)) == PLUS)\n+\t{\n+\t  rtx op0 = XEXP (XEXP (x, 0), 0);\n+\t  rtx op1 = XEXP (XEXP (x, 0), 1);\n+\n+\t  /* Address expressions of the form Ra + Rb + CONST.\n+\n+\t     If CONST is within the range supported by the addressing\n+\t     mode \"reg+offset\", do not split CONST and use the\n+\t     sequence\n+\t       Rt = Ra + Rb;\n+\t       addr = Rt + CONST.  */\n+\t  if (REG_P (op0) && REG_P (op1))\n+\t    {\n+\t      machine_mode addr_mode = GET_MODE (x);\n+\t      rtx base = gen_reg_rtx (addr_mode);\n+\t      rtx addr = plus_constant (addr_mode, base, offset);\n+\n+\t      if (aarch64_legitimate_address_hook_p (mode, addr, false))\n+\t\t{\n+\t\t  emit_insn (gen_adddi3 (base, op0, op1));\n+\t\t  return addr;\n+\t\t}\n+\t    }\n+\t  /* Address expressions of the form Ra + Rb<<SCALE + CONST.\n+\n+\t     If Reg + Rb<<SCALE is a valid address expression, do not\n+\t     split CONST and use the sequence\n+\t       Rc = CONST;\n+\t       Rt = Ra + Rc;\n+\t       addr = Rt + Rb<<SCALE.\n+\n+\t     Here we split CONST out of memory referece because:\n+\t       a) We depend on GIMPLE optimizers to pick up common sub\n+\t\t  expression involving the scaling operation.\n+\t       b) The index Rb is likely a loop iv, it's better to split\n+\t\t  the CONST so that computation of new base Rt is a loop\n+\t\t  invariant and can be moved out of loop.  This is more\n+\t\t  important when the original base Ra is sfp related.  */\n+\t  else if (REG_P (op0) || REG_P (op1))\n+\t    {\n+\t      machine_mode addr_mode = GET_MODE (x);\n+\t      rtx base = gen_reg_rtx (addr_mode);\n+\n+\t      /* Switch to make sure that register is in op0.  */\n+\t      if (REG_P (op1))\n+\t\tstd::swap (op0, op1);\n+\n+\t      rtx addr = gen_rtx_PLUS (addr_mode, op1, base);\n+\n+\t      if (aarch64_legitimate_address_hook_p (mode, addr, false))\n+\t\t{\n+\t\t  base = force_operand (plus_constant (addr_mode,\n+\t\t\t\t\t\t       op0, offset),\n+\t\t\t\t\tNULL_RTX);\n+\t\t  return gen_rtx_PLUS (addr_mode, op1, base);\n+\t\t}\n+\t    }\n+\t}\n+\n       /* Does it look like we'll need a load/store-pair operation?  */\n       if (GET_MODE_SIZE (mode) > 16\n \t  || mode == TImode)"}]}