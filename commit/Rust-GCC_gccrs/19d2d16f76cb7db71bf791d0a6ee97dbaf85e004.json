{"sha": "19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkMmQxNmY3NmNiN2RiNzFiZjc5MWQwYTZlZTk3ZGJhZjg1ZTAwNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-12-13T12:03:00Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-12-13T12:03:00Z"}, "message": "Use simpler functions instead of printf.  INT_TYPE_SIZE is always 32.  For NT, do not emit .extern for builtin functions\n\nFrom-SVN: r10704", "tree": {"sha": "5d3dbd61d745acb21e9375435f20f5d65be67bc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d3dbd61d745acb21e9375435f20f5d65be67bc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/comments", "author": null, "committer": null, "parents": [{"sha": "8282721e69149bb576f793043144f1d7ddc68681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8282721e69149bb576f793043144f1d7ddc68681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8282721e69149bb576f793043144f1d7ddc68681"}], "stats": {"total": 164, "additions": 86, "deletions": 78}, "files": [{"sha": "6715dddf9b338dcd614e4b3f08edcf46ea6cec61", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "patch": "@@ -2028,7 +2028,7 @@ print_operand (file, x, code)\n \t the left.  */\n       if (val < 0 && (val & 1) == 0)\n \t{\n-\t  fprintf (file, \"0\");\n+\t  putc ('0', file);\n \t  return;\n \t}\n       else if (val >= 0)\n@@ -2997,9 +2997,9 @@ output_prolog (file, size)\n       if (TARGET_RELOCATABLE)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n-\t  fprintf (file, \"\\tbl \");\n+\t  fputs (\"\\tbl \", file);\n \t  assemble_name (file, buf);\n-\t  fprintf (file, \"\\n\");\n+\t  putc ('\\n', file);\n \n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LCF\", rs6000_pic_labelno);\n \t  fprintf (file, \"\\tmflr %s\\n\", reg_names[30]);\n@@ -3008,7 +3008,7 @@ output_prolog (file, size)\n \t  fprintf (file, \" %s,(\", reg_names[0]);\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n \t  assemble_name (file, buf);\n-\t  fprintf (file, \"-\");\n+\t  putc ('-', file);\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n \t  assemble_name (file, buf);\n \t  fprintf (file, \")(%s)\\n\", reg_names[30]);\n@@ -3197,10 +3197,10 @@ output_epilog (file, size)\n       /* An all-zero word flags the start of the tbtab, for debuggers\n \t that have to find it by searching forward from the entry\n \t point or from the current pc.  */\n-      fprintf (file, \"\\t.long 0\\n\");\n+      fputs (\"\\t.long 0\\n\", file);\n \n       /* Tbtab format type.  Use format type 0.  */\n-      fprintf (file, \"\\t.byte 0,\");\n+      fputs (\"\\t.byte 0,\", file);\n \n       /* Language type.  Unfortunately, there doesn't seem to be any\n \t official way to get this info, so we use language_string.  C\n@@ -3322,12 +3322,12 @@ output_epilog (file, size)\n \tfprintf (file, \"\\t.long %d\\n\", parm_info);\n \n       /* Offset from start of code to tb table.  */\n-      fprintf (file, \"\\t.long \");\n+      fputs (\"\\t.long \", file);\n       ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LT\");\n       RS6000_OUTPUT_BASENAME (file, fname);\n-      fprintf (file, \"-.\");\n+      fputs (\"-.\", file);\n       RS6000_OUTPUT_BASENAME (file, fname);\n-      fprintf (file, \"\\n\");\n+      putc ('\\n', file);\n \n       /* Interrupt handler mask.  */\n       /* Omit this long, since we never set the interrupt handler bit\n@@ -3348,7 +3348,7 @@ output_epilog (file, size)\n       /* Register for alloca automatic storage; this is always reg 31.\n \t Only emit this if the alloca bit was set above.  */\n       if (frame_pointer_needed)\n-\tfprintf (file, \"\\t.byte 31\\n\");\n+\tfputs (\"\\t.byte 31\\n\", file);\n     }\n \n   /* Reset varargs and save TOC indicator */\n@@ -3397,7 +3397,7 @@ output_toc (file, x, labelno)\n       ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n       fprintf (file, \"%d = .-\", labelno);\n       ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LCTOC\");\n-      fprintf (file, \"1\\n\");\n+      fputs (\"1\\n\", file);\n     }\n   else\n     ASM_OUTPUT_INTERNAL_LABEL (file, \"LC\", labelno);\n@@ -3452,7 +3452,7 @@ output_toc (file, x, labelno)\n     abort ();\n \n   if (TARGET_MINIMAL_TOC)\n-    fprintf (file, \"\\t.long \");\n+    fputs (\"\\t.long \", file);\n   else\n     {\n       STRIP_NAME_ENCODING (real_name, name);\n@@ -3463,10 +3463,10 @@ output_toc (file, x, labelno)\n       else if (offset)\n \tfprintf (file, \".P%d\", offset);\n \n-      fprintf (file, \"[TC],\");\n+      fputs (\"[TC],\", file);\n     }\n   output_addr_const (file, x);\n-  fprintf (file, \"\\n\");\n+  putc ('\\n', file);\n }\n \f\n /* Output an assembler pseudo-op to write an ASCII string of N characters\n@@ -3615,17 +3615,17 @@ output_function_profiler (file, labelno)\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LP\", labelno);\n   if (TARGET_MINIMAL_TOC)\n     {\n-      fprintf (file, \"\\t.long \");\n+      fputs (\"\\t.long \", file);\n       assemble_name (file, buf);\n-      fprintf (file, \"\\n\");\n+      putc ('\\n', file);\n     }\n   else\n     {\n-      fprintf (file, \"\\t.tc\\t\");\n+      fputs (\"\\t.tc\\t\", file);\n       assemble_name (file, buf);\n-      fprintf (file, \"[TC],\");\n+      fputs (\"[TC],\", file);\n       assemble_name (file, buf);\n-      fprintf (file, \"\\n\");\n+      putc ('\\n', file);\n     }\n   text_section ();\n \n@@ -3642,19 +3642,19 @@ output_function_profiler (file, labelno)\n      it might be set up as the frame pointer.  */\n \n   for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n-    fprintf (file, \"\\tai %d,%d,0\\n\", j, i);\n+    asm_fprintf (file, \"\\tmr %d,%d\\n\", j, i);\n \n   /* Load location address into r3, and call mcount.  */\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LPC\", labelno);\n-  fprintf (file, \"\\tl 3,\");\n+  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[3]);\n   assemble_name (file, buf);\n-  fprintf (file, \"(2)\\n\\tbl .mcount\\n\");\n+  asm_fprintf (file, \"(%s)\\n\\tbl .mcount\\n\", reg_names[2]);\n \n   /* Restore parameter registers.  */\n \n   for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n-    fprintf (file, \"\\tai %d,%d,0\\n\", i, j);\n+    asm_fprintf (file, \"\\tmr %d,%d\\n\", i, j);\n }\n \n /* Adjust the cost of a scheduling dependency.  Return the new cost of"}, {"sha": "fb6f98fb5cd751b3e4bcbfb44e930c42fa353dbd", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "patch": "@@ -404,8 +404,7 @@ extern char *rs6000_cpu_string;\n /* A C expression for the size in bits of the type `int' on the\n    target machine.  If you don't define this, the default is one\n    word.  */\n-#define INT_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n-#define MAX_INT_TYPE_SIZE 64\n+#define INT_TYPE_SIZE 32\n \n /* A C expression for the size in bits of the type `long' on the\n    target machine.  If you don't define this, the default is one\n@@ -1914,7 +1913,7 @@ extern int rs6000_trunc_used;\n     private_data_section ();\t\t\t\t\t\\\n   text_section ();\t\t\t\t\t\t\\\n   if (profile_flag)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.extern .mcount\\n\");\t\t\t\\\n+    fputs (\"\\t.extern .mcount\\n\", FILE);\t\t\t\\\n }\n \n /* Output at end of assembler file.\n@@ -1924,9 +1923,9 @@ extern int rs6000_trunc_used;\n #define ASM_FILE_END(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   text_section ();\t\t\t\t\t\t\\\n-  fprintf (FILE, \"_section_.text:\\n\");\t\t\t\t\\\n+  fputs (\"_section_.text:\\n\", FILE);\t\t\t\t\\\n   data_section ();\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long _section_.text\\n\");\t\t\t\\\n+  fputs (\"\\t.long _section_.text\\n\", FILE);\t\t\t\\\n }\n \n /* We define this to prevent the name mangler from putting dollar signs into\n@@ -2021,18 +2020,18 @@ toc_section ()\t\t\t\t\t\t\\\n \t in each file.  */\t\t\t\t\t\t \\\n       if (! toc_initialized)\t\t\t\t\\\n \t{\t\t\t\t\t\t\\\n-\t  fprintf (asm_out_file, \".toc\\nLCTOC..0:\\n\");\t\\\n-\t  fprintf (asm_out_file, \"\\t.tc toc_table[TC],toc_table[RW]\\n\"); \\\n+\t  fputs (\".toc\\nLCTOC..0:\\n\", asm_out_file);\t\\\n+\t  fputs (\"\\t.tc toc_table[TC],toc_table[RW]\\n\", asm_out_file); \\\n \t  toc_initialized = 1;\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n       if (in_section != toc)\t\t\t\t\\\n-\tfprintf (asm_out_file, \".csect toc_table[RW]\\n\"); \\\n+\tfputs (\".csect toc_table[RW]\\n\", asm_out_file); \\\n     }\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       if (in_section != toc)\t\t\t\t\\\n-        fprintf (asm_out_file, \".toc\\n\");\t\t\\\n+        fputs (\".toc\\n\", asm_out_file);\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   in_section = toc;\t\t\t\t\t\\\n }\n@@ -2050,27 +2049,27 @@ toc_section ()\t\t\t\t\t\t\\\n #define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n { if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.globl .\");\t\t\t\t\\\n+      fputs (\"\\t.globl .\", FILE);\t\t\t\t\\\n       RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.lglobl .\");\t\t\t\t\\\n+      fputs (\"\\t.lglobl .\", FILE);\t\t\t\t\\\n       RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \".csect \");\t\t\t\t\t\\\n+  fputs (\".csect \", FILE);\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fprintf (FILE, \"[DS]\\n\");\t\t\t\t\t\\\n+  fputs (\"[DS]\\n\", FILE);\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long .\");\t\t\t\t\t\\\n+  fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n+  fputs (\"\\t.long .\", FILE);\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fprintf (FILE, \", TOC[tc0], 0\\n\");\t\t\t\t\\\n-  fprintf (FILE, \".csect .text[PR]\\n.\");\t\t\t\\\n+  fputs (\", TOC[tc0], 0\\n\", FILE);\t\t\t\t\\\n+  fputs (\".csect .text[PR]\\n.\", FILE);\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n+  fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n   if (write_symbols == XCOFF_DEBUG)\t\t\t\t\\\n     xcoffout_declare_function (FILE, DECL, NAME);\t\t\\\n }\n@@ -2200,23 +2199,23 @@ toc_section ()\t\t\t\t\t\t\\\n       strcat (_name, TREE_CODE (DECL) == FUNCTION_DECL ? \"[DS]\" : \"[RW]\"); \\\n       XSTR (_symref, 0) = _name;\t\t\\\n     }\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.extern \");\t\t\t\\\n+  fputs (\"\\t.extern \", FILE);\t\t\t\\\n   assemble_name (FILE, XSTR (_symref, 0));\t\\\n   if (TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n     {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\\t.extern .\");\t\t\\\n+      fputs (\"\\n\\t.extern .\", FILE);\t\t\\\n       RS6000_OUTPUT_BASENAME (FILE, XSTR (_symref, 0));\t\\\n     }\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+  putc ('\\n', FILE);\t\t\t\t\\\n }\n \n /* Similar, but for libcall.  We only have to worry about the function name,\n    not that of the descriptor. */\n \n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n-{ fprintf (FILE, \"\\t.extern .\");\t\t\\\n+{ fputs (\"\\t.extern .\", FILE);\t\t\t\\\n   assemble_name (FILE, XSTR (FUN, 0));\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+  putc ('\\n', FILE);\t\t\t\t\\\n }\n \n /* Output to assembler file text saying following lines\n@@ -2374,21 +2373,21 @@ toc_section ()\t\t\t\t\t\t\\\n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+( fputs (\"\\t.long \", FILE),\t\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+  putc ('\\n', FILE))\n \n /* Likewise for `char' and `short' constants.  */\n \n #define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n+( fputs (\"\\t.short \", FILE),\t\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+  putc ('\\n', FILE))\n \n #define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+( fputs (\"\\t.byte \", FILE),\t\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+  putc ('\\n', FILE))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n \n@@ -2427,23 +2426,23 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n   do { char buf[100];\t\t\t\t\t\\\n-       fprintf (FILE, \"\\t.long \");\t\t\t\\\n+       fputs (\"\\t.long \", FILE);\t\t\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n-       fprintf (FILE, \"\\n\");\t\t\t\t\\\n+       putc ('\\n', FILE);\t\t\t\t\\\n      } while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n   do { char buf[100];\t\t\t\t\t\\\n-       fprintf (FILE, \"\\t.long \");\t\t\t\\\n+       fputs (\"\\t.long \", FILE);\t\t\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n-       fprintf (FILE, \"-\");\t\t\t\t\\\n+       putc ('-', FILE);\t\t\t\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", REL);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n-       fprintf (FILE, \"\\n\");\t\t\t\t\\\n+       putc ('\\n', FILE);\t\t\t\t\\\n      } while (0)\n \n /* This is how to output an assembler line"}, {"sha": "fa71bf8dd38c51dd50fdc5d446c7622d5dcf9827", "filename": "gcc/config/rs6000/win-nt.h", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d2d16f76cb7db71bf791d0a6ee97dbaf85e004/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fwin-nt.h?ref=19d2d16f76cb7db71bf791d0a6ee97dbaf85e004", "patch": "@@ -325,25 +325,34 @@ toc_section ()\t\t\t\t\t\t\\\n \n #undef ASM_OUTPUT_EXTERNAL\n \n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n-{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n-  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n-       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n-      && (NAME)[0] != '*'\t\t\t\\\n-      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n-    {\t\t\t\t\t\t\\\n-      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n-      strcpy (_name, XSTR (_symref, 0));\t\\\n-      XSTR (_symref, 0) = _name;\t\t\\\n-    }\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.extern \");\t\t\t\\\n-  assemble_name (FILE, XSTR (_symref, 0));\t\\\n-  if (TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n-    {\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\\t.extern ..\");\t\t\\\n-      assemble_name (FILE, XSTR (_symref, 0));\t\\\n-    }\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  char *_name;\t\t\t\t\t\t\t\t\\\n+  rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\t\t\t\\\n+  if ((TREE_CODE (DECL) == VAR_DECL\t\t\t\t\t\\\n+       || TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\t\\\n+      && (NAME)[0] != '*'\t\t\t\t\t\t\\\n+      && (NAME)[strlen (NAME) - 1] != ']')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5);\t\\\n+      strcpy (_name, XSTR (_symref, 0));\t\t\t\t\\\n+      XSTR (_symref, 0) = _name;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    _name = XSTR (_symref, 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (DECL_FUNCTION_CODE (DECL) == 0)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.extern \", FILE);\t\t\t\t\t\\\n+      assemble_name (FILE, _name);\t\t\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\t\\\n+      if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fputs (\"\\t.extern ..\", FILE);\t\t\t\t\t\\\n+\t  assemble_name (FILE, _name);\t\t\t\t\t\\\n+\t  putc ('\\n', FILE);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n /* Similar, but for libcall.  We only have to worry about the function name,"}]}